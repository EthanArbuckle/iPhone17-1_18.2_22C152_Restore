uint64_t figPlaybackCoordinator_addTimebaseNotificationListeners(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t vars8;

  FigPlaybackCoordinatorGetCMBaseObject(a1);
  result = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    return FigNotificationCenterAddWeakListener();
  }
  return result;
}

void figPlaybackCoordinator_updateHLSInterstitialStartTimes(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  CFTypeRef v39 = 0;
  memset(cf, 0, sizeof(cf));
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v2 = DerivedStorage[5];
  if (!v2) {
    goto LABEL_16;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t FigBaseObject = FigPlaybackItemGetFigBaseObject(v2);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
  uint64_t v6 = v5 ? v5 : 0;
  v7 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, CFTypeRef *))(v6 + 48);
  if (v7)
  {
    int v8 = v7(FigBaseObject, @"interstitialEvents", v3, cf);
    CFTypeRef v9 = cf[0];
    v10 = (const void *)DerivedStorage[58];
    DerivedStorage[58] = cf[0];
    if (v9) {
      CFRetain(v9);
    }
  }
  else
  {
    v10 = (const void *)DerivedStorage[58];
    DerivedStorage[58] = 0;
    int v8 = -12782;
  }
  if (v10) {
    CFRelease(v10);
  }
  if (!cf[0])
  {
LABEL_16:
    Mutable = 0;
    goto LABEL_17;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)cf[0]);
  Mutable = 0;
  char v13 = 1;
  if (v8) {
    goto LABEL_40;
  }
  CFIndex v14 = Count;
  if (Count < 1) {
    goto LABEL_40;
  }
  CMTime v37 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  uint64_t v15 = FigPlaybackItemGetFigBaseObject(DerivedStorage[5]);
  uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v16) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  v18 = *(unsigned int (**)(uint64_t, __CFString *, const __CFAllocator *, CFTypeRef *))(v17 + 48);
  if (!v18
    || v18(v15, @"currentDateAndTime", v3, &v39)
    || (FigDateTimeMakeFromDictionary(v39, (uint64_t)&time), *(CMTime *)&cf[1] = time, !v36)
    || !v35)
  {
    Mutable = 0;
    goto LABEL_40;
  }
  CMTimeMakeWithSeconds(&v37, seconds, 1000000000);
  CMTime lhs = v37;
  CMTime v32 = *(CMTime *)&cf[1];
  CMTimeSubtract(&time, &lhs, &v32);
  CMTime v37 = time;
  double v19 = CMTimeGetSeconds(&time);
  Mutable = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  CFIndex v20 = 0;
  do
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)cf[0], v20);
    v32.value = 0;
    if (!FigPlayerInterstitialEventCreateFromDictionary(0, ValueAtIndex, &v32.value))
    {
      FigPlayerInterstitialEventGetStartTime(v32.value, (uint64_t)&time);
      lhs.value = time.value;
      CMTimeFlags flags = time.flags;
      lhs.timescale = time.timescale;
      CMTimeEpoch epoch = time.epoch;
      if ((time.flags & 1) == 0)
      {
        started = FigPlayerInterstitialEventCopyStartDate(v32.value);
        if (started)
        {
          v25 = started;
          double v26 = MEMORY[0x199707BD0]();
          CMTimeMakeWithSeconds(&time, v26 - v19, 1000000000);
          lhs.value = time.value;
          CMTimeFlags flags = time.flags;
          lhs.timescale = time.timescale;
          CMTimeEpoch epoch = time.epoch;
          CFRelease(v25);
        }
      }
      time.value = lhs.value;
      time.timescale = lhs.timescale;
      time.CMTimeFlags flags = flags;
      time.CMTimeEpoch epoch = epoch;
      CFDictionaryRef v27 = CMTimeCopyAsDictionary(&time, v3);
      if (v27)
      {
        CFDictionaryRef v28 = v27;
        CFArrayAppendValue(Mutable, v27);
        CFRelease(v28);
      }
      CFRelease((CFTypeRef)v32.value);
    }
    ++v20;
  }
  while (v14 != v20);
  if (!Mutable)
  {
LABEL_17:
    char v13 = 1;
    goto LABEL_40;
  }
  if (CFArrayGetCount(Mutable) >= 1)
  {
    v29 = (const void *)FigCFCopyCompactDescription();
    if (v29) {
      CFRelease(v29);
    }
    v30 = (const void *)DerivedStorage[57];
    DerivedStorage[57] = Mutable;
    CFRetain(Mutable);
    if (v30) {
      CFRelease(v30);
    }
    char v13 = 0;
    goto LABEL_42;
  }
  char v13 = 0;
LABEL_40:
  v31 = (const void *)DerivedStorage[57];
  if (v31)
  {
    CFRelease(v31);
    DerivedStorage[57] = 0;
  }
LABEL_42:
  if (v39) {
    CFRelease(v39);
  }
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  if ((v13 & 1) == 0) {
    CFRelease(Mutable);
  }
}

void figPlaybackCoordinator_recordCurrentHLSInterstitialEventCoordinationStatus(uint64_t a1)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf1 = 0;
  uint64_t v2 = *(void *)(DerivedStorage + 40);
  if (v2)
  {
    if (*(_DWORD *)(DerivedStorage + 56) != 10000) {
      goto LABEL_20;
    }
    uint64_t FigBaseObject = FigPlaybackItemGetFigBaseObject(v2);
    uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 8);
    uint64_t v5 = v4 ? v4 : 0;
    uint64_t v6 = *(unsigned int (**)(uint64_t, __CFString *, void, CFTypeRef *))(v5 + 48);
    if (!v6 || v6(FigBaseObject, @"currentInterstitialEvent", *MEMORY[0x1E4F1CF80], &cf1)) {
      goto LABEL_20;
    }
    if (cf1)
    {
      if (CFEqual(cf1, &stru_1EE53F4B8)) {
        goto LABEL_20;
      }
      *(unsigned char *)(DerivedStorage + 480) = 1;
      CFArrayRef v7 = *(const __CFArray **)(DerivedStorage + 464);
      if (!v7) {
        goto LABEL_20;
      }
      CFIndex Count = CFArrayGetCount(v7);
      if (Count < 1) {
        goto LABEL_20;
      }
      CFIndex v9 = Count;
      CFIndex v10 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 464), v10);
        CFTypeRef cf = 0;
        if (!FigPlayerInterstitialEventCreateFromDictionary(0, ValueAtIndex, (uint64_t *)&cf))
        {
          CFStringRef v12 = (const __CFString *)FigPlayerInterstitialEventCopyIdentifier((uint64_t)cf);
          if (CFEqual((CFStringRef)cf1, v12))
          {
            if (FigPlayerInterstitialEventContentMayVary((uint64_t)cf)
              || !FigPlayerInterstitialEventGetTimelineOccupancy((uint64_t)cf)
              || FigPlayerInterstitialEventIsPreRoll((uint64_t)cf))
            {
              *(unsigned char *)(DerivedStorage + 480) = 0;
            }
            if (cf) {
              CFRelease(cf);
            }
            if (v12) {
              CFRelease(v12);
            }
LABEL_20:
            if (cf1) {
              CFRelease(cf1);
            }
            return;
          }
          if (cf) {
            CFRelease(cf);
          }
          if (v12) {
            CFRelease(v12);
          }
        }
        if (v9 == ++v10) {
          goto LABEL_20;
        }
      }
    }
  }
}

void figPlaybackCoordinator_seekDidComplete(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = FigCFWeakReferenceHolderCopyReferencedObject();
  long long v17 = *MEMORY[0x1E4F1F9F8];
  uint64_t v18 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  uint64_t v16 = 0;
  if (v7)
  {
    int v8 = (const void *)v7;
    if (*(void *)(DerivedStorage + 40) == a4)
    {
      FigCFDictionaryGetInt32IfPresent();
      uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v9) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = 0;
      }
      v11 = *(void (**)(const void *, uint64_t *))(v10 + 48);
      if (v11) {
        v11(v8, &v16);
      }
      uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v12) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = 0;
      }
      CFIndex v14 = *(void (**)(uint64_t, long long *))(v13 + 32);
      if (v14) {
        v14(a4, &v17);
      }
      if (dword_1EB2AEA78)
      {
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      if (*(unsigned char *)(DerivedStorage + 96))
      {
        figPlaybackCoordinator_resetTimelineCoordinatorStateToCurrentItemIdentifierAndTiming(a2);
      }
      else if (HIDWORD(v16))
      {
        if (HIDWORD(v16) == *(_DWORD *)(DerivedStorage + 236))
        {
          *(_DWORD *)(DerivedStorage + 236) = 0;
          figPlaybackCoordinator_checkForCommandCompletion((uint64_t)a2);
        }
      }
      figPlaybackCoordinator_updateInterstitialStateMachine(a2, 1);
    }
    else
    {
      FigSignalErrorAt();
    }
    CFRelease(v8);
  }
  else
  {
    FigSignalErrorAt();
  }
}

void figPlaybackCoordinator_seekWasCancelled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v7)
  {
    int v8 = (const void *)v7;
    if (*(void *)(DerivedStorage + 40) == a4)
    {
      FigCFDictionaryGetInt32IfPresent();
      if (!*(_DWORD *)(DerivedStorage + 236))
      {
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        figPlaybackCoordinator_completePendingCommandAndRecordNewCallback(a2, 0, 0, 0);
      }
    }
    else
    {
      FigSignalErrorAt();
    }
    CFRelease(v8);
  }
  else
  {
    FigSignalErrorAt();
  }
}

uint64_t figPlaybackCoordinator_coordinationIdentifierChanged(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  if (*(void *)(CMBaseObjectGetDerivedStorage() + 40) == a4)
  {
    return figPlaybackCoordinator_resetTimelineCoordinatorStateToCurrentItemIdentifierAndTiming(a2);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void figPlaybackCoordinator_playbackStalled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  if (*(void *)(CMBaseObjectGetDerivedStorage() + 40) == a4)
  {
    uint64_t v6 = (const void *)*MEMORY[0x1E4F21FB0];
    playbackCoordinator_beginSystemEventSuspensionForReason(a2, v6);
  }
  else
  {
    FigSignalErrorAt();
  }
}

void figPlaybackCoordinator_itemBecameLikelyToKeepUp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)(DerivedStorage + 40) == a4)
  {
    uint64_t v7 = DerivedStorage;
    int v8 = (const void *)*MEMORY[0x1E4F21FB0];
    FigPlaybackCoordinatorGetCMBaseObject(a2);
    uint64_t v9 = CMBaseObjectGetDerivedStorage();
    MEMORY[0x19970E910](*(void *)(v9 + 280));
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v9 + 288), v8);
    if (Value)
    {
      v11 = Value;
      CFRetain(Value);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v9 + 288), v8);
      MEMORY[0x19970E930](*(void *)(v9 + 280));
      int v12 = FigTimelineCoordinatorEndSuspension();
      CFRelease(v11);
      if (v12) {
        return;
      }
    }
    else
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v9 + 288), v8);
      MEMORY[0x19970E930](*(void *)(v9 + 280));
    }
    figPlaybackCoordinator_checkForCommandCompletion(a2);
    uint64_t v13 = *(const void **)(v7 + 200);
    if (v13)
    {
      CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      CFDateRef v16 = CFDateCreate(v14, Current);
      *(void *)(v7 + 200) = v16;
      if (v16) {
        CFRetain(v16);
      }
      CFRelease(v13);
    }
  }
  else
  {
    FigSignalErrorAt();
  }
}

uint64_t figPlaybackCoordinator_coordinatedPlaybackSupportChanged(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)(DerivedStorage + 40) == a4 && *(_DWORD *)(DerivedStorage + 56) == 10000 && a5)
  {
    BOOL v9 = CFDictionaryGetValue(a5, @"IsCoordinatedPlaybackSupported") == (const void *)*MEMORY[0x1E4F1CFD0];
    return figPlaybackCoordinator_beginOrEndCoordinatedPlaybackNotPossibleSuspension(a2, v9, 1);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void figPlaybackCoordinator_currentItemTimebaseDidChange(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef cf = 0;
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)(DerivedStorage + 40) == a4)
  {
    uint64_t v7 = DerivedStorage;
    uint64_t FigBaseObject = FigPlaybackItemGetFigBaseObject(a4);
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    v11 = *(uint64_t (**)(uint64_t, __CFString *, void, CFTypeRef *))(v10 + 48);
    if (v11)
    {
      int v12 = v11(FigBaseObject, @"Timebase", *MEMORY[0x1E4F1CF80], &cf);
      CFTypeRef v13 = cf;
      if (!v12)
      {
        CFTypeRef v14 = *(CFTypeRef *)(v7 + 48);
        if (cf != v14)
        {
          figPlaybackCoordinator_removeTimebaseNotificationListeners((uint64_t)a2, (uint64_t)v14);
          uint64_t v15 = *(const void **)(v7 + 48);
          CFTypeRef v16 = cf;
          *(void *)(v7 + 48) = cf;
          if (v16) {
            CFRetain(v16);
          }
          if (v15) {
            CFRelease(v15);
          }
          figPlaybackCoordinator_addTimebaseNotificationListeners((uint64_t)a2, *(void *)(v7 + 48));
          figPlaybackCoordinator_handleCurrentTimebaseRateChange(a2);
          CFTypeRef v13 = cf;
        }
      }
      if (v13) {
        CFRelease(v13);
      }
    }
  }
  else
  {
    FigSignalErrorAt();
  }
}

void figPlaybackCoordinator_hlsInterstitialEventsChanged(uint64_t a1, uint64_t a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = FigCFWeakReferenceHolderCopyReferencedObject();
  uint64_t v10 = 0;
  if (v4)
  {
    uint64_t v5 = (const void *)v4;
    uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v6) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 0;
    }
    int v8 = *(void (**)(const void *, void, const void **))(v7 + 32);
    if (v8)
    {
      v8(v5, 0, &v10);
      uint64_t v9 = v10;
    }
    else
    {
      uint64_t v9 = 0;
    }
    if (v9 == *(const void **)(DerivedStorage + 40))
    {
      figPlaybackCoordinator_updateHLSInterstitialStartTimes(a2);
      uint64_t v9 = v10;
      if (!v10) {
        goto LABEL_11;
      }
    }
    else if (!v9)
    {
LABEL_11:
      CFRelease(v5);
      return;
    }
    CFRelease(v9);
    goto LABEL_11;
  }
}

void figPlaybackCoordinator_hlsCurrentInterstitialEventChanged(uint64_t a1, uint64_t a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = FigCFWeakReferenceHolderCopyReferencedObject();
  CFTypeRef cf = 0;
  if (v4)
  {
    uint64_t v5 = (const void *)v4;
    uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v6) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 0;
    }
    int v8 = *(void (**)(const void *, void, CFTypeRef *))(v7 + 32);
    if (v8)
    {
      v8(v5, 0, &cf);
      CFTypeRef v9 = cf;
    }
    else
    {
      CFTypeRef v9 = 0;
    }
    if (!*(unsigned char *)(DerivedStorage + 488) && v9 == *(CFTypeRef *)(DerivedStorage + 40))
    {
      figPlaybackCoordinator_recordCurrentHLSInterstitialEventCoordinationStatus(a2);
      CFTypeRef v9 = cf;
    }
    if (v9) {
      CFRelease(v9);
    }
    CFRelease(v5);
  }
}

void figPlaybackCoordinator_integratedTimelineOffsetsChanged(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  if (*(void *)(CMBaseObjectGetDerivedStorage() + 40) == a4)
  {
    figPlaybackCoordinator_setIntegratedTimelineOffsetTimesForItem(a2, a4);
  }
  else
  {
    FigSignalErrorAt();
  }
}

void figPlaybackCoordinator_checkForCommandCompletion(uint64_t a1)
{
  cf[24] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  cf[0] = 0;
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!*(void *)(DerivedStorage + 216)) {
    goto LABEL_19;
  }
  uint64_t v3 = DerivedStorage;
  double Rate = CMTimebaseGetRate(*(CMTimebaseRef *)(DerivedStorage + 48));
  if (*(_DWORD *)(v3 + 236))
  {
    if (!dword_1EB2AEA78) {
      goto LABEL_19;
    }
LABEL_4:
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
LABEL_18:
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    goto LABEL_19;
  }
  float v6 = Rate;
  if (*(float *)(v3 + 240) != v6)
  {
    if (!dword_1EB2AEA78) {
      goto LABEL_19;
    }
    goto LABEL_4;
  }
  if (!*(unsigned char *)(v3 + 244)) {
    goto LABEL_15;
  }
  uint64_t FigBaseObject = FigPlaybackItemGetFigBaseObject(*(void *)(v3 + 40));
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(void (**)(uint64_t, __CFString *, void, CFTypeRef *))(v9 + 48);
  if (v10) {
    v10(FigBaseObject, @"WillKeepUpPrediction", *MEMORY[0x1E4F1CF80], cf);
  }
  if (FigCFEqual())
  {
LABEL_15:
    figPlaybackCoordinator_completePendingCommandAndRecordNewCallback(a1, 0, 0, 1);
    goto LABEL_19;
  }
  if (dword_1EB2AEA78)
  {
    v11 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    goto LABEL_18;
  }
LABEL_19:
  if (cf[0]) {
    CFRelease(cf[0]);
  }
}

void figPlaybackCoordinator_updateInterstitialStateMachine(const void *a1, int a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(_OWORD *)&start.value = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v5 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  start.CMTimeEpoch epoch = v5;
  long long v59 = *(_OWORD *)&start.value;
  *(_OWORD *)&v74.value = *(_OWORD *)&start.value;
  v74.CMTimeEpoch epoch = v5;
  CFArrayRef v6 = *(const __CFArray **)(DerivedStorage + 360);
  if (v6 && CFArrayGetCount(v6) >= 1)
  {
    uint64_t v7 = (long long *)(DerivedStorage + 384);
    unsigned int v8 = *(_DWORD *)(DerivedStorage + 376);
    uint64_t v9 = (long long *)MEMORY[0x1E4F1FA20];
    while (1)
    {
      do
      {
        while (1)
        {
          if (v8 < 2)
          {
            *(_OWORD *)&v73.value = v59;
            v73.CMTimeEpoch epoch = v5;
            uint64_t v19 = *(void *)(DerivedStorage + 40);
            uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v20) {
              uint64_t v21 = v20;
            }
            else {
              uint64_t v21 = 0;
            }
            v22 = *(void (**)(uint64_t, CMTime *))(v21 + 32);
            if (v22) {
              v22(v19, &v73);
            }
            long long v56 = v9[1];
            long long v58 = *v9;
            long long v70 = *v9;
            long long v71 = v56;
            long long v54 = v9[2];
            long long v72 = v54;
            FigPlaybackCoordinatorGetCMBaseObject(a1);
            uint64_t v23 = CMBaseObjectGetDerivedStorage();
            *(_OWORD *)&range.start.value = v59;
            range.start.CMTimeEpoch epoch = v5;
            LODWORD(v65.start.value) = 0;
            uint64_t v24 = FigCFWeakReferenceHolderCopyReferencedObject();
            if (v24)
            {
              v25 = (const void *)v24;
              uint64_t v26 = *(void *)(v23 + 40);
              uint64_t v27 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v27) {
                uint64_t v28 = v27;
              }
              else {
                uint64_t v28 = 0;
              }
              v29 = *(void (**)(uint64_t, CMTimeRange *))(v28 + 32);
              if (v29) {
                v29(v26, &range);
              }
              uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v30) {
                uint64_t v31 = v30;
              }
              else {
                uint64_t v31 = 0;
              }
              CMTime v32 = *(void (**)(const void *, CMTimeRange *))(v31 + 48);
              if (!v32 || (v32(v25, &v65), *(float *)&v65.start.value == 0.0))
              {
                CFRelease(v25);
              }
              else
              {
                *(_OWORD *)&time1.start.value = *(_OWORD *)&range.start.value;
                time1.start.CMTimeEpoch epoch = range.start.epoch;
                int isTimeInInterstitialRange = figPlaybackCoordinator_isTimeInInterstitialRange((uint64_t)a1, &time1.start, &v70);
                CFRelease(v25);
                if (isTimeInInterstitialRange)
                {
                  if ((*(unsigned char *)(DerivedStorage + 396) & 1) == 0
                    || (*(unsigned char *)(DerivedStorage + 420) & 1) == 0
                    || *(void *)(DerivedStorage + 424)
                    || (*(void *)(DerivedStorage + 408) & 0x8000000000000000) != 0)
                  {
                    long long v34 = v71;
                    *uint64_t v7 = v70;
                    *(_OWORD *)(DerivedStorage + 400) = v34;
                    *(_OWORD *)(DerivedStorage + 416) = v72;
                  }
                  long long v35 = *(_OWORD *)(DerivedStorage + 400);
                  *(_OWORD *)&range.start.value = *v7;
                  *(_OWORD *)&range.start.CMTimeEpoch epoch = v35;
                  *(_OWORD *)&range.duration.timescale = *(_OWORD *)(DerivedStorage + 416);
                  CMTimeRangeGetEnd(&v69, &range);
                  CMTimeMake(&v68, 20, 1000);
                  CMTimeAdd(&v74, &v69, &v68);
                  range.CMTime start = v74;
                  figPlaybackCoordinator_primeNextInterstitialEventTimer((uint64_t)a1, (uint64_t)&range, 1);
                  *(_OWORD *)&range.start.value = *v7;
                  range.start.CMTimeEpoch epoch = *(void *)(DerivedStorage + 400);
                  figPlaybackCoordinator_getGroupTimeFromPlayerTimeForInterstitials((uint64_t)a1, &range.start, &start);
                  FigPlaybackCoordinatorGetCMBaseObject(a1);
                  uint64_t v36 = CMBaseObjectGetDerivedStorage();
                  if (!*(void *)(v36 + 432))
                  {
                    CMTime v37 = (void *)(v36 + 432);
                    if (!FigTimelineCoordinatorSuspensionCreate())
                    {
                      if (*v37) {
                        figPlaybackCoordinator_BeginSuspension(a1);
                      }
                    }
                  }
                  int v38 = 3;
LABEL_77:
                  *(_DWORD *)(DerivedStorage + 376) = v38;
                  return;
                }
              }
            }
            else
            {
              FigSignalErrorAt();
            }
            *(_OWORD *)&range.start.value = *v7;
            range.start.CMTimeEpoch epoch = *(void *)(DerivedStorage + 400);
            figPlaybackCoordinator_getGroupTimeFromPlayerTimeForInterstitials((uint64_t)a1, &range.start, &start);
            CMTimeMake(&v66, 20, 1000);
            range.CMTime start = start;
            CMTimeAdd(&v67, &range.start, &v66);
            figPlaybackCoordinator_endDiscontinuitiyBasedInterstitialSuspensionProposingNewTime((uint64_t)a1);
            CMTime v64 = v73;
            FigPlaybackCoordinatorGetCMBaseObject(a1);
            uint64_t v39 = CMBaseObjectGetDerivedStorage();
            CFArrayRef v40 = *(const __CFArray **)(v39 + 360);
            if (v40) {
              CFIndex Count = CFArrayGetCount(v40);
            }
            else {
              CFIndex Count = 0;
            }
            *(_OWORD *)&v65.start.value = v58;
            *(_OWORD *)&v65.start.CMTimeEpoch epoch = v56;
            *(_OWORD *)&v65.duration.timescale = v54;
            float v79 = 0.0;
            uint64_t v42 = FigCFWeakReferenceHolderCopyReferencedObject();
            if (v42)
            {
              v43 = (const void *)v42;
              uint64_t v44 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v44) {
                uint64_t v45 = v44;
              }
              else {
                uint64_t v45 = 0;
              }
              v46 = *(void (**)(const void *, float *))(v45 + 48);
              if (v46) {
                v46(v43, &v79);
              }
              if (Count >= 1)
              {
                CFIndex v47 = 0;
                while (1)
                {
                  memset(&range, 0, sizeof(range));
                  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v39 + 360), v47);
                  CMTimeRangeMakeFromDictionary(&range, ValueAtIndex);
                  CMTimeRange time1 = range;
                  CMTime time2 = v64;
                  if (figPlaybackCoordinator_timeRangeContainsTimeWithStartTolerance((uint64_t)&time1, &time2))
                  {
                    if (v79 == 0.0) {
                      break;
                    }
                  }
                  *(_OWORD *)&time1.start.value = *(_OWORD *)&range.start.value;
                  time1.start.CMTimeEpoch epoch = range.start.epoch;
                  CMTime time2 = v64;
                  if ((CMTimeCompare(&time1.start, &time2) & 0x80000000) == 0) {
                    break;
                  }
                  if (Count == ++v47) {
                    goto LABEL_71;
                  }
                }
                CMTimeRange v65 = range;
              }
LABEL_71:
              CFRelease(v43);
            }
            else
            {
              FigSignalErrorAt();
            }
            long long v49 = *(_OWORD *)&v65.start.epoch;
            *uint64_t v7 = *(_OWORD *)&v65.start.value;
            *(_OWORD *)(DerivedStorage + 400) = v49;
            *(_OWORD *)(DerivedStorage + 416) = *(_OWORD *)&v65.duration.timescale;
            if ((*(unsigned char *)(DerivedStorage + 396) & 1) == 0
              || (*(unsigned char *)(DerivedStorage + 420) & 1) == 0
              || *(void *)(DerivedStorage + 424)
              || (*(void *)(DerivedStorage + 408) & 0x8000000000000000) != 0)
            {
              figPlaybackCoordinator_clearInterstitialEventTimer((uint64_t)a1);
            }
            else
            {
              *(_OWORD *)&range.start.value = *v7;
              range.start.CMTimeEpoch epoch = *(void *)(DerivedStorage + 400);
              figPlaybackCoordinator_primeNextInterstitialEventTimer((uint64_t)a1, (uint64_t)&range, 0);
            }
            int v38 = 2;
            goto LABEL_77;
          }
          if (v8 != 2) {
            break;
          }
          if (a2 == 2) {
            goto LABEL_26;
          }
          unsigned int v8 = 2;
          if (a2 == 1)
          {
            long long v13 = v9[1];
            *uint64_t v7 = *v9;
            *(_OWORD *)(DerivedStorage + 400) = v13;
            *(_OWORD *)(DerivedStorage + 416) = v9[2];
            goto LABEL_26;
          }
        }
      }
      while (v8 != 3);
      long long v70 = v59;
      *(void *)&long long v71 = v5;
      long long v10 = *v9;
      long long v11 = v9[1];
      *(_OWORD *)&range.start.value = *v9;
      *(_OWORD *)&range.start.CMTimeEpoch epoch = v11;
      long long v12 = v9[2];
      *(_OWORD *)&range.duration.timescale = v12;
      if (a2 == 1) {
        break;
      }
      if (a2 == 3)
      {
LABEL_21:
        if (BYTE12(v70))
        {
          *(_OWORD *)&time1.start.value = v70;
          time1.start.CMTimeEpoch epoch = v71;
          figPlaybackCoordinator_getGroupTimeFromPlayerTimeForInterstitials((uint64_t)a1, &time1.start, &start);
        }
        else
        {
          *(_OWORD *)&time1.start.value = *v7;
          time1.start.CMTimeEpoch epoch = *(void *)(DerivedStorage + 400);
          figPlaybackCoordinator_getGroupTimeFromPlayerTimeForInterstitials((uint64_t)a1, &time1.start, &lhs);
          CMTimeMake(&rhs, 20, 1000);
          CMTimeAdd(&time1.start, &lhs, &rhs);
          CMTime start = time1.start;
        }
        time1.CMTime start = start;
        figPlaybackCoordinator_endDiscontinuitiyBasedInterstitialSuspensionProposingNewTime((uint64_t)a1);
        if (*(unsigned char *)(DerivedStorage + 96)) {
          figPlaybackCoordinator_resetTimelineCoordinatorStateToCurrentItemIdentifierAndTiming(a1);
        }
LABEL_26:
        unsigned int v8 = 1;
        *(_DWORD *)(DerivedStorage + 376) = 1;
      }
      else
      {
        unsigned int v8 = 3;
      }
    }
    long long v53 = v12;
    long long v55 = v11;
    long long v57 = v10;
    uint64_t v14 = *(void *)(DerivedStorage + 40);
    uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v15) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = 0;
    }
    long long v17 = *(void (**)(uint64_t, long long *))(v16 + 32);
    if (v17) {
      v17(v14, &v70);
    }
    long long v18 = *(_OWORD *)(DerivedStorage + 400);
    *(_OWORD *)&time1.start.value = *v7;
    *(_OWORD *)&time1.start.CMTimeEpoch epoch = v18;
    *(_OWORD *)&time1.duration.timescale = *(_OWORD *)(DerivedStorage + 416);
    *(_OWORD *)&v65.start.value = v70;
    v65.start.CMTimeEpoch epoch = v71;
    if (figPlaybackCoordinator_timeRangeContainsTimeWithStartTolerance((uint64_t)&time1, &v65.start)) {
      return;
    }
    *(_OWORD *)&time1.start.value = v70;
    time1.start.CMTimeEpoch epoch = v71;
    if (figPlaybackCoordinator_isTimeInInterstitialRange((uint64_t)a1, &time1.start, &range))
    {
      long long v50 = *(_OWORD *)&range.start.value;
      long long v51 = *(_OWORD *)&range.start.epoch;
      *uint64_t v7 = *(_OWORD *)&range.start.value;
      *(_OWORD *)(DerivedStorage + 400) = v51;
      long long v52 = *(_OWORD *)&range.duration.timescale;
      *(_OWORD *)(DerivedStorage + 416) = *(_OWORD *)&range.duration.timescale;
      *(_OWORD *)&time1.start.value = v50;
      *(_OWORD *)&time1.start.CMTimeEpoch epoch = v51;
      *(_OWORD *)&time1.duration.timescale = v52;
      CMTimeRangeGetEnd(&v63, &time1);
      CMTimeMake(&v62, 20, 1000);
      CMTimeAdd(&v74, &v63, &v62);
      time1.CMTime start = v74;
      figPlaybackCoordinator_primeNextInterstitialEventTimer((uint64_t)a1, (uint64_t)&time1, 1);
      return;
    }
    *uint64_t v7 = v57;
    *(_OWORD *)(DerivedStorage + 400) = v55;
    *(_OWORD *)(DerivedStorage + 416) = v53;
    goto LABEL_21;
  }
}

void figPlaybackCoordinator_primeNextInterstitialEventTimer(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  figPlaybackCoordinator_clearInterstitialEventTimer(a1);
  *(_OWORD *)&v14.value = *(_OWORD *)a2;
  v14.CMTimeEpoch epoch = *(void *)(a2 + 16);
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v7 = CMBaseObjectGetDerivedStorage();
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v8 = CMBaseObjectGetDerivedStorage();
  dispatch_source_t v9 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 1uLL, *(dispatch_queue_t *)(v8 + 272));
  if (v9)
  {
    long long v10 = v9;
    long long v11 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
    dispatch_set_context(v10, v11);
    dispatch_source_set_timer(v10, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x989680uLL);
    dispatch_source_set_event_handler_f(v10, (dispatch_function_t)figPlaybackCoordinator_interstitialTimerEventProc);
    dispatch_source_set_cancel_handler_f(v10, 0);
    dispatch_set_finalizer_f(v10, (dispatch_function_t)FigCFRelease_6);
    dispatch_resume(v10);
    if (CMTimebaseAddTimerDispatchSource(*(CMTimebaseRef *)(v7 + 48), v10)
      || (long long v12 = *(OpaqueCMTimebase **)(v7 + 48),
          CMTime fireTime = v14,
          CMTimebaseSetTimerDispatchSourceNextFireTime(v12, v10, &fireTime, 1u)))
    {
      CFRelease(v10);
    }
    else
    {
      *(_DWORD *)(v7 + 380) = a3;
      if (dword_1EB2AEA78)
      {
        int v16 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      *(void *)(DerivedStorage + 368) = v10;
    }
  }
  else
  {
    FigSignalErrorAt();
  }
}

CMTime *figPlaybackCoordinator_getGroupTimeFromPlayerTimeForInterstitials@<X0>(uint64_t a1@<X0>, CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef v6 = *(const __CFArray **)(DerivedStorage + 360);
  if (v6)
  {
    CFIndex Count = CFArrayGetCount(v6);
    CMTime v18 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      CFIndex v9 = 0;
      long long v10 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
      *(_OWORD *)&v17.start.value = *MEMORY[0x1E4F1FA20];
      *(_OWORD *)&v17.start.CMTimeEpoch epoch = v10;
      *(_OWORD *)&v17.duration.timescale = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 360), v9);
        CMTimeRangeMakeFromDictionary(&v17, ValueAtIndex);
        CMTimeRange range = v17;
        CMTimeRangeGetEnd(&time1, &range);
        *(_OWORD *)&range.start.value = *(_OWORD *)&a2->value;
        range.start.CMTimeEpoch epoch = a2->epoch;
        if (CMTimeCompare(&time1, &range.start) >= 1) {
          break;
        }
        range.CMTime start = v18;
        CMTime rhs = v17.duration;
        CMTimeAdd(&v18, &range.start, &rhs);
        if (v8 == ++v9) {
          goto LABEL_10;
        }
      }
      CMTimeRange range = v17;
      CMTime rhs = *a2;
      if (figPlaybackCoordinator_timeRangeContainsTimeWithStartTolerance((uint64_t)&range, &rhs))
      {
        *(_OWORD *)&range.start.value = *(_OWORD *)&a2->value;
        range.start.CMTimeEpoch epoch = a2->epoch;
        CMTime rhs = v17.start;
        CMTimeSubtract(&v13, &range.start, &rhs);
        range.CMTime start = v18;
        CMTimeAdd(&v18, &range.start, &v13);
      }
    }
  }
  else
  {
    CMTime v18 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  }
LABEL_10:
  *(_OWORD *)&v17.start.value = *(_OWORD *)&a2->value;
  v17.start.CMTimeEpoch epoch = a2->epoch;
  range.CMTime start = v18;
  return CMTimeSubtract(a3, &v17.start, &range.start);
}

void figPlaybackCoordinator_endDiscontinuitiyBasedInterstitialSuspensionProposingNewTime(uint64_t a1)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)(DerivedStorage + 432))
  {
    uint64_t v2 = DerivedStorage;
    uint64_t v3 = (const void *)FigCFWeakReferenceHolderCopyReferencedObject();
    int v8 = 0;
    uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v4) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    CFArrayRef v6 = *(void (**)(const void *, int *))(v5 + 48);
    if (v6) {
      v6(v3, &v8);
    }
    if (v3) {
      CFRelease(v3);
    }
    FigTimelineCoordinatorEndSuspensionWeaklyIfNeededProposingNewRateAndTime();
    uint64_t v7 = *(const void **)(v2 + 432);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(v2 + 432) = 0;
    }
  }
}

void figPlaybackCoordinator_clearInterstitialEventTimer(uint64_t a1)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef v2 = *(const __CFArray **)(DerivedStorage + 360);
  if (v2 && CFArrayGetCount(v2) >= 1)
  {
    uint64_t v3 = *(NSObject **)(DerivedStorage + 368);
    if (v3)
    {
      dispatch_source_cancel(v3);
      dispatch_release(*(dispatch_object_t *)(DerivedStorage + 368));
      *(void *)(DerivedStorage + 368) = 0;
    }
  }
}

uint64_t figPlaybackCoordinator_timeRangeContainsTimeWithStartTolerance(uint64_t a1, CMTime *a2)
{
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&range.start.value = *(_OWORD *)a1;
  *(_OWORD *)&range.start.CMTimeEpoch epoch = v4;
  *(_OWORD *)&range.duration.timescale = *(_OWORD *)(a1 + 32);
  CMTime time = *a2;
  if (CMTimeRangeContainsTime(&range, &time)) {
    return 1;
  }
  CMTimeMake(&rhs, 40, 1000);
  *(_OWORD *)&range.start.value = *(_OWORD *)&a2->value;
  range.start.CMTimeEpoch epoch = a2->epoch;
  CMTimeAdd(&time1, &range.start, &rhs);
  *(_OWORD *)&range.start.value = *(_OWORD *)a1;
  range.start.CMTimeEpoch epoch = *(void *)(a1 + 16);
  if (CMTimeCompare(&time1, &range.start) < 0) {
    return 0;
  }
  long long v6 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&range.start.value = *(_OWORD *)a1;
  *(_OWORD *)&range.start.CMTimeEpoch epoch = v6;
  *(_OWORD *)&range.duration.timescale = *(_OWORD *)(a1 + 32);
  CMTimeRangeGetEnd(&time2, &range);
  *(_OWORD *)&range.start.value = *(_OWORD *)&a2->value;
  range.start.CMTimeEpoch epoch = a2->epoch;
  return CMTimeCompare(&range.start, &time2) >> 31;
}

uint64_t figPlaybackCoordinator_isTimeInInterstitialRange(uint64_t a1, CMTime *a2, _OWORD *a3)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = *(void *)(DerivedStorage + 360);
  if (!result)
  {
    long long v12 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
    *(_OWORD *)&v17.start.value = *MEMORY[0x1E4F1FA20];
    *(_OWORD *)&v17.start.CMTimeEpoch epoch = v12;
    *(_OWORD *)&v17.duration.timescale = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
    if (!a3) {
      return result;
    }
    goto LABEL_9;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)result);
  long long v8 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  *(_OWORD *)&v17.start.value = *MEMORY[0x1E4F1FA20];
  *(_OWORD *)&v17.start.CMTimeEpoch epoch = v8;
  *(_OWORD *)&v17.duration.timescale = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  if (Count < 1)
  {
LABEL_6:
    uint64_t result = 0;
    if (!a3) {
      return result;
    }
    goto LABEL_9;
  }
  CFIndex v9 = Count;
  CFIndex v10 = 0;
  while (1)
  {
    memset(&v16, 0, sizeof(v16));
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 360), v10);
    CMTimeRangeMakeFromDictionary(&v16, ValueAtIndex);
    CMTimeRange v15 = v16;
    CMTime v14 = *a2;
    if (figPlaybackCoordinator_timeRangeContainsTimeWithStartTolerance((uint64_t)&v15, &v14)) {
      break;
    }
    if (v9 == ++v10) {
      goto LABEL_6;
    }
  }
  CMTimeRange v17 = v16;
  uint64_t result = 1;
  if (a3)
  {
LABEL_9:
    long long v13 = *(_OWORD *)&v17.start.epoch;
    *a3 = *(_OWORD *)&v17.start.value;
    a3[1] = v13;
    a3[2] = *(_OWORD *)&v17.duration.timescale;
  }
  return result;
}

void figPlaybackCoordinator_interstitialTimerEventProc()
{
  uint64_t v0 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v0)
  {
    v1 = (const void *)v0;
    FigPlaybackCoordinatorGetCMBaseObject(v0);
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    long long v4 = *(_OWORD *)(DerivedStorage + 400);
    *(_OWORD *)&v7.start.value = *(_OWORD *)(DerivedStorage + 384);
    *(_OWORD *)&v7.start.CMTimeEpoch epoch = v4;
    *(_OWORD *)&v7.duration.timescale = *(_OWORD *)(DerivedStorage + 416);
    CFStringRef v5 = CMTimeRangeCopyDescription(v3, &v7);
    CFRelease(v5);
    if (*(_DWORD *)(DerivedStorage + 380)) {
      uint64_t v6 = 3;
    }
    else {
      uint64_t v6 = 2;
    }
    figPlaybackCoordinator_updateInterstitialStateMachine(v1, v6);
    CFRelease(v1);
  }
}

uint64_t figPlaybackCoordinator_BeginSuspension(const void *a1)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = FigTimelineCoordinatorBeginSuspension();
  if (!v3)
  {
    long long v4 = malloc_type_malloc(0x10uLL, 0x10200405F07FB98uLL);
    if (a1) {
      CFTypeRef v5 = CFRetain(a1);
    }
    else {
      CFTypeRef v5 = 0;
    }
    *(void *)long long v4 = v5;
    v4[8] = 1;
    dispatch_async_f(*(dispatch_queue_t *)(DerivedStorage + 272), v4, (dispatch_function_t)playbackCoordinator_completePendingStartupTaskOnQueue);
  }
  return v3;
}

void playbackCoordinator_completePendingStartupTaskOnQueue(uint64_t a1)
{
  CFArrayRef v2 = *(const void **)a1;
  playbackCoordinator_completePendingStartupTask(*(void *)a1, *(unsigned __int8 *)(a1 + 8));
  if (v2) {
    CFRelease(v2);
  }

  free((void *)a1);
}

void playbackCoordinator_beginSystemEventSuspensionForReason(uint64_t a1, const void *a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 280));
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(DerivedStorage + 288), a2))
  {
    if (FigTimelineCoordinatorSuspensionCreate()) {
      return;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(DerivedStorage + 288), a2, 0);
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 280));
}

void figPlaybackCoordinator_handleCurrentTimebaseRateChange(const void *a1)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  double Rate = CMTimebaseGetRate(*(CMTimebaseRef *)(DerivedStorage + 48));
  if (*(unsigned char *)(DerivedStorage + 96))
  {
    float v4 = Rate;
    if (dword_1EB2AEA78)
    {
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (v4 != 0.0) {
      figPlaybackCoordinator_resetTimelineCoordinatorStateToCurrentItemIdentifierAndTiming(a1);
    }
  }
  else if (*(void *)(DerivedStorage + 216))
  {
    figPlaybackCoordinator_checkForCommandCompletion((uint64_t)a1);
  }
}

void figPlaybackCoordinator_currentItemTimebaseRateDidChange(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  FigPlaybackCoordinatorGetCMBaseObject(a2);
  if (*(void *)(CMBaseObjectGetDerivedStorage() + 48) == a4)
  {
    figPlaybackCoordinator_handleCurrentTimebaseRateChange(a2);
  }
  else
  {
    FigSignalErrorAt();
  }
}

uint64_t figPlaybackCoordinator_CopyParticipantSnapshots(uint64_t a1, uint64_t a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);

  return MEMORY[0x1F40DE658](v3, a2);
}

double figPlaybackCoordinator_getGroupTimeFromPlayerTime@<D0>(uint64_t a1@<X0>, CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = DerivedStorage;
  a3->CMTimeEpoch epoch = a2->epoch;
  long long v8 = *(_OWORD *)&a2->value;
  *(_OWORD *)&a3->value = *(_OWORD *)&a2->value;
  if (*(unsigned char *)(DerivedStorage + 336))
  {
    CMTime lhs = *a2;
    CMTime v16 = *(CMTime *)(DerivedStorage + 324);
    CMTimeAdd(a3, &lhs, &v16);
    char v10 = 1;
    int v11 = 1;
  }
  else
  {
    CFArrayRef v9 = *(const __CFArray **)(DerivedStorage + 360);
    if (v9 && CFArrayGetCount(v9) >= 1)
    {
      CMTime lhs = *a2;
      figPlaybackCoordinator_getGroupTimeFromPlayerTimeForInterstitials(a1, &lhs, a3);
      char v10 = 0;
      int v11 = 0;
    }
    else
    {
      int v11 = 0;
      char v10 = 1;
    }
  }
  CFArrayRef v12 = *(const __CFArray **)(v7 + 472);
  if (v12)
  {
    CFIndex Count = CFArrayGetCount(v12);
    char v14 = v10 ^ 1;
    if (Count < 1) {
      char v14 = 1;
    }
    if ((v14 & 1) == 0)
    {
      CMTime v16 = *a3;
      figPlaybackCoordinator_getGroupTimeFromPlayerTimeOnIntegratedTimeline(a1, (long long *)&v16.value, v11, &lhs);
      *(void *)&long long v8 = lhs.value;
      *a3 = lhs;
    }
  }
  return *(double *)&v8;
}

uint64_t figPlaybackCoordinator_copyGroupTimebaseFromCurrentItemTimebase(uint64_t a1, CMTimebaseRef *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  CFTypeRef v5 = *(OpaqueCMTimebase **)(DerivedStorage + 48);
  if (v5)
  {
    CMTimebaseGetTime(&v21, v5);
    CMTimeValue value = v21.value;
    CMTimeFlags flags = v21.flags;
    CMTimeScale timescale = v21.timescale;
    CMTimeEpoch epoch = v21.epoch;
  }
  else
  {
    CMTimeFlags flags = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
    CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  }
  CMTime v21 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  if (*(unsigned char *)(DerivedStorage + 336))
  {
    CMTime v21 = *(CMTime *)(DerivedStorage + 324);
    if ((flags & 1) == 0) {
      goto LABEL_19;
    }
    int v9 = 1;
  }
  else
  {
    if ((flags & 1) == 0) {
      goto LABEL_19;
    }
    CFArrayRef v8 = *(const __CFArray **)(DerivedStorage + 360);
    if (v8 && CFArrayGetCount(v8) >= 1)
    {
      memset(&v20, 0, sizeof(v20));
      lhs.CMTimeValue value = value;
      lhs.CMTimeScale timescale = timescale;
      lhs.CMTimeFlags flags = flags;
      lhs.CMTimeEpoch epoch = epoch;
      figPlaybackCoordinator_getGroupTimeFromPlayerTimeForInterstitials(a1, &lhs, &v20);
      CMTime lhs = v20;
      rhs.CMTimeValue value = value;
      rhs.CMTimeScale timescale = timescale;
      rhs.CMTimeFlags flags = flags;
      rhs.CMTimeEpoch epoch = epoch;
      CMTimeSubtract(&v21, &lhs, &rhs);
      int v9 = 0;
      char v10 = 0;
      goto LABEL_13;
    }
    int v9 = 0;
  }
  char v10 = 1;
LABEL_13:
  CFArrayRef v11 = *(const __CFArray **)(DerivedStorage + 472);
  if (v11)
  {
    CFIndex Count = CFArrayGetCount(v11);
    char v13 = v10 ^ 1;
    if (Count < 1) {
      char v13 = 1;
    }
    if ((v13 & 1) == 0)
    {
      memset(&v20, 0, sizeof(v20));
      lhs.CMTimeValue value = value;
      lhs.CMTimeScale timescale = timescale;
      lhs.CMTimeFlags flags = flags;
      lhs.CMTimeEpoch epoch = epoch;
      figPlaybackCoordinator_getGroupTimeFromPlayerTimeOnIntegratedTimeline(a1, (long long *)&lhs.value, v9, &v20);
      if (v20.flags)
      {
        memset(&lhs, 0, sizeof(lhs));
        CMTime rhs = v20;
        v17.CMTimeValue value = value;
        v17.CMTimeScale timescale = timescale;
        v17.CMTimeFlags flags = flags;
        v17.CMTimeEpoch epoch = epoch;
        CMTimeSubtract(&lhs, &rhs, &v17);
        CMTime v17 = v21;
        CMTime v16 = lhs;
        CMTimeAdd(&rhs, &v17, &v16);
        CMTime v21 = rhs;
      }
    }
  }
LABEL_19:
  char v14 = *(OpaqueCMTimebase **)(DerivedStorage + 48);
  CMTime v20 = v21;
  return figPlaybackCoordinator_copyTimebaseAndAddOffset(v14, &v20, a2);
}

uint64_t figPlaybackCoordinator_getGroupTimeFromPlayerTimeOnIntegratedTimeline@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, int a3@<W2>, CMTime *a4@<X8>)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef v8 = (_OWORD *)MEMORY[0x1E4F1F9F8];
  a4->CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  *(_OWORD *)&a4->CMTimeValue value = *v8;
  uint64_t result = *(void *)(DerivedStorage + 472);
  if (result)
  {
    uint64_t result = CFArrayGetCount((CFArrayRef)result);
    uint64_t v10 = result - 1;
    if (result >= 1)
    {
      uint64_t v11 = result;
      CFIndex v12 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 472), v12);
        memset(&v23, 0, sizeof(v23));
        CMTimeMappingMakeFromDictionary(&v23, ValueAtIndex);
        CMTimeRange source = v23.source;
        *(_OWORD *)&lhs.start.CMTimeValue value = *a2;
        memset(&v21, 0, sizeof(v21));
        lhs.start.CMTimeEpoch epoch = *((void *)a2 + 2);
        CMTime rhs = v23.source.start;
        CMTimeSubtract(&v21, &lhs.start, &rhs);
        *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&source.start.value;
        *(_OWORD *)&lhs.start.CMTimeEpoch epoch = *(_OWORD *)&source.start.epoch;
        long long v14 = *a2;
        *(_OWORD *)&lhs.duration.CMTimeScale timescale = *(_OWORD *)&source.duration.timescale;
        *(_OWORD *)&rhs.CMTimeValue value = v14;
        rhs.CMTimeEpoch epoch = *((void *)a2 + 2);
        if (CMTimeRangeContainsTime(&lhs, &rhs)) {
          break;
        }
        lhs.CMTime start = v21;
        CMTimeAbsoluteValue(&time1, &lhs.start);
        CMTimeMake(&time2, 350, 1000);
        if (CMTimeCompare(&time1, &time2) < 0) {
          break;
        }
        CMTimeRange lhs = source;
        CMTimeRangeGetEnd(&v16, &lhs);
        *(_OWORD *)&lhs.start.CMTimeValue value = *a2;
        lhs.start.CMTimeEpoch epoch = *((void *)a2 + 2);
        uint64_t result = CMTimeCompare(&v16, &lhs.start);
        if (!result) {
          break;
        }
        if (a3)
        {
          if (v10 == v12 && !*(unsigned char *)(DerivedStorage + 488))
          {
            CMTimeRange lhs = source;
            CMTimeRangeGetEnd(&v15, &lhs);
            *(_OWORD *)&lhs.start.CMTimeValue value = *a2;
            lhs.start.CMTimeEpoch epoch = *((void *)a2 + 2);
            uint64_t result = CMTimeCompare(&lhs.start, &v15);
            if ((int)result >= 1) {
              break;
            }
          }
        }
        if (v11 == ++v12) {
          return result;
        }
      }
      *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&v23.target.start.value;
      lhs.start.CMTimeEpoch epoch = v23.target.start.epoch;
      CMTime rhs = v21;
      return (uint64_t)CMTimeAdd(a4, &lhs.start, &rhs);
    }
  }
  return result;
}

uint64_t figPlaybackCoordinator_copyTimebaseAndAddOffset(OpaqueCMTimebase *a1, CMTime *a2, CMTimebaseRef *a3)
{
  CMTimebaseRef timebaseOut = 0;
  uint64_t v6 = (OpaqueCMTimebase *)CMTimebaseCopySource(a1);
  uint64_t v7 = v6;
  outRelativedouble Rate = 0.0;
  CMTime outOfClockOrTimebaseAnchorTime = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CMTime outRelativeToClockOrTimebaseAnchorTime = outOfClockOrTimebaseAnchorTime;
  if (a1)
  {
    if (v6 && (CFTypeID v8 = CFGetTypeID(v6), v8 == CMTimebaseGetTypeID()))
    {
      uint64_t RelativeRateAndAnchorTime = CMTimebaseCreateWithSourceTimebase((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, &timebaseOut);
      if (RelativeRateAndAnchorTime) {
        goto LABEL_9;
      }
    }
    else
    {
      uint64_t RelativeRateAndAnchorTime = CMTimebaseCreateWithSourceClock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, &timebaseOut);
      if (RelativeRateAndAnchorTime) {
        goto LABEL_9;
      }
    }
    uint64_t RelativeRateAndAnchorTime = CMSyncGetRelativeRateAndAnchorTime(a1, v7, &outRelativeRate, &outOfClockOrTimebaseAnchorTime, &outRelativeToClockOrTimebaseAnchorTime);
    if (!RelativeRateAndAnchorTime)
    {
      uint64_t v10 = timebaseOut;
      Float64 v11 = outRelativeRate;
      CMTime lhs = outOfClockOrTimebaseAnchorTime;
      CMTime v14 = *a2;
      CMTimeAdd(&timebaseTime, &lhs, &v14);
      CMTime lhs = outRelativeToClockOrTimebaseAnchorTime;
      uint64_t RelativeRateAndAnchorTime = CMTimebaseSetRateAndAnchorTime(v10, v11, &timebaseTime, &lhs);
    }
LABEL_9:
    uint64_t v12 = RelativeRateAndAnchorTime;
    if (!a3) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = 0;
  if (a3) {
LABEL_10:
  }
    *a3 = timebaseOut;
LABEL_11:
  if (v7) {
    CFRelease(v7);
  }
  return v12;
}

uint64_t figPlaybackCoordinator_playerHasPlaybackStalled()
{
  return 0;
}

uint64_t figPlaybackCoordinator_playerIsAudioSessionInterrupted()
{
  return 0;
}

void figPlaybackCoordinator_timelineCoordinatorParticipantsDidChangeDispatch(uint64_t *a1)
{
  v44[22] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  FigPlaybackCoordinatorGetCMBaseObject(*a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = (const void *)FigCFWeakReferenceHolderCopyReferencedObject();
  CFTypeRef cf = 0;
  v44[0] = 0;
  CFDictionaryRef v4 = (const __CFDictionary *)a1[1];
  if (v4) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    goto LABEL_49;
  }
  uint64_t v6 = (const void *)*MEMORY[0x1E4F21F18];
  if (CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E4F21F18]))
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1[1], v6);
    if (!Value) {
      goto LABEL_49;
    }
    CFArrayRef v8 = Value;
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 != CFArrayGetTypeID()) {
      goto LABEL_49;
    }
  }
  else
  {
    CFArrayRef v8 = 0;
  }
  CFIndex Count = CFArrayGetCount(v8);
  if (Count < 1)
  {
    *(unsigned char *)(DerivedStorage + 96) = 1;
    uint64_t FigBaseObject = FigPlayerGetFigBaseObject(v3);
    uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v16) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v30 = *(void (**)(uint64_t, __CFString *, void))(v17 + 56);
    if (v30) {
      v30(FigBaseObject, @"ParticipatingInCoordinatedPlayback", *MEMORY[0x1E4F1CFC8]);
    }
    uint64_t v31 = *(void *)(DerivedStorage + 40);
    if (v31)
    {
      uint64_t v32 = FigPlaybackItemGetFigBaseObject(v31);
      uint64_t v33 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v34 = v33 ? v33 : 0;
      long long v35 = *(void (**)(uint64_t, __CFString *, void))(v34 + 56);
      if (v35) {
        v35(v32, @"TransientTimebaseForCoordinatedPlaybackSynchronization", 0);
      }
    }
    uint64_t v26 = *a1;
    CFStringRef v27 = @"CPCntOfParts";
    uint64_t v28 = Count;
    goto LABEL_48;
  }
  if (!*(unsigned char *)(DerivedStorage + 96))
  {
LABEL_32:
    figPlaybackCoordinator_updateReportingStats(*a1, @"CPCntOfParts", Count);
    uint64_t v26 = *a1;
    CFStringRef v27 = @"CPPlayIsParticipating";
    uint64_t v28 = 1;
LABEL_48:
    figPlaybackCoordinator_updateReportingStats(v26, v27, v28);
    goto LABEL_49;
  }
  float v42 = 0.0;
  *(unsigned char *)(DerivedStorage + 96) = 0;
  uint64_t v11 = *MEMORY[0x1E4F1CFD0];
  uint64_t v12 = FigPlayerGetFigBaseObject(v3);
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  CMTime v18 = *(void (**)(uint64_t, __CFString *, uint64_t))(v14 + 56);
  if (v18) {
    v18(v12, @"ParticipatingInCoordinatedPlayback", v11);
  }
  FigPlaybackCoordinatorGetCMBaseObject(*a1);
  CMBaseObjectGetDerivedStorage();
  uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  CMTime v21 = *(void (**)(const void *, float *))(v20 + 48);
  if (v21) {
    v21(v3, &v42);
  }
  uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v22) {
    uint64_t v23 = v22;
  }
  else {
    uint64_t v23 = 0;
  }
  uint64_t v24 = *(void (**)(const void *, void, CFTypeRef *))(v23 + 32);
  if (v24)
  {
    v24(v3, 0, &cf);
    CFTypeRef v25 = cf;
  }
  else
  {
    CFTypeRef v25 = 0;
  }
  if (v25 != *(CFTypeRef *)(DerivedStorage + 40) || v42 == 0.0 || v42 == *(float *)(DerivedStorage + 168))
  {
    FigTimelineCoordinatorReapplyGroupStateViaTimelineControl();
    goto LABEL_32;
  }
  if (!FPSupport_CreateSetRateOptions((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 33, (CFMutableDictionaryRef *)v44))
  {
    FigCFDictionarySetValue();
    FigCFDictionarySetValue();
    if (dword_1EB2AEA78)
    {
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    float v37 = v42;
    CFTypeRef v38 = v44[0];
    uint64_t v39 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v40 = v39 ? v39 : 0;
    uint64_t v41 = *(unsigned int (**)(const void *, CFTypeRef, float))(v40 + 104);
    if (v41)
    {
      if (!v41(v3, v38, v37)) {
        goto LABEL_32;
      }
    }
  }
LABEL_49:
  if (cf) {
    CFRelease(cf);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (*a1) {
    CFRelease((CFTypeRef)*a1);
  }
  uint64_t v36 = (const void *)a1[1];
  if (v36) {
    CFRelease(v36);
  }
  if (v44[0]) {
    CFRelease(v44[0]);
  }
  free(a1);
}

uint64_t figPlaybackCoordinator_updateReportingStats(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (!*(void *)(result + 312)) {
    return result;
  }
  uint64_t v6 = result;
  uint64_t v7 = 0x1EE585698;
  uint64_t result = CFStringCompare(a2, @"CPPlayRemoteSetRate", 0);
  if (!result) {
    goto LABEL_10;
  }
  uint64_t v7 = 0x1EE585678;
  uint64_t result = CFStringCompare(a2, @"CPPlayRemoteSeek", 0);
  if (!result) {
    goto LABEL_10;
  }
  uint64_t result = CFStringCompare(a2, @"CPCntOfParts", 0);
  if (!result)
  {
    uint64_t v22 = *(void *)(v6 + 312);
    if (!v22) {
      return result;
    }
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v25 = *(void *)(VTable + 16);
    uint64_t result = VTable + 16;
    uint64_t v24 = v25;
    uint64_t v26 = v25 ? v24 : 0;
    CMTime v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v26 + 40);
    if (!v18) {
      return result;
    }
    uint64_t v19 = v22;
    uint64_t v20 = 0x1EE585618;
    uint64_t v21 = a3;
    return v18(v19, 0x1EE582C98, v20, v21);
  }
  uint64_t v7 = 0x1EE585638;
  uint64_t result = CFStringCompare(a2, @"CPPlayWaitTime", 0);
  if (!result)
  {
LABEL_10:
    uint64_t v13 = *(void *)(v6 + 312);
    if (!v13) {
      return result;
    }
    uint64_t v14 = CMBaseObjectGetVTable();
    uint64_t v16 = *(void *)(v14 + 16);
    uint64_t result = v14 + 16;
    uint64_t v15 = v16;
    uint64_t v17 = v16 ? v15 : 0;
    CMTime v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v17 + 32);
    if (!v18) {
      return result;
    }
    uint64_t v19 = v13;
    uint64_t v20 = v7;
    uint64_t v21 = a3;
    return v18(v19, 0x1EE582C98, v20, v21);
  }
  uint64_t result = CFStringCompare(a2, @"CPPlayIsParticipating", 0);
  if (!result)
  {
    uint64_t v8 = *(void *)(v6 + 312);
    if (v8)
    {
      uint64_t v9 = CMBaseObjectGetVTable();
      uint64_t v11 = *(void *)(v9 + 16);
      uint64_t result = v9 + 16;
      uint64_t v10 = v11;
      uint64_t v12 = v11 ? v10 : 0;
      CFStringRef v27 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v12 + 56);
      if (v27)
      {
        return v27(v8, 0x1EE582C98, 0x1EE5855F8, a3, 0);
      }
    }
  }
  return result;
}

void figPlaybackCoordinator_handleChangeInInterstitialActiveStatusOnQueue(void *a1)
{
  CFArrayRef v2 = (const void *)*a1;
  uint64_t v3 = a1[1];
  FigPlaybackCoordinatorGetCMBaseObject(*a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 488))
  {
    if (*MEMORY[0x1E4F1CFC8] == v3
      && !playbackCoordinator_coordinatedPlaybackNotPossibleSuspensionActive((uint64_t)v2, 4))
    {
      figPlaybackCoordinator_beginPlayingPrimarySuspension(v2);
      if (!v2) {
        goto LABEL_11;
      }
LABEL_10:
      CFRelease(v2);
      goto LABEL_11;
    }
LABEL_9:
    if (!v2) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (*MEMORY[0x1E4F1CFD0] != v3)
  {
    uint64_t v5 = DerivedStorage;
    figPlaybackCoordinator_endPlayingInterstitialSuspension((uint64_t)v2);
    if (*(unsigned char *)(v5 + 96)) {
      figPlaybackCoordinator_resetTimelineCoordinatorStateToCurrentItemIdentifierAndTiming(v2);
    }
    goto LABEL_9;
  }
  FigPlaybackCoordinatorGetCMBaseObject(v2);
  uint64_t v6 = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(v6 + 352));
  if (!*(void *)(v6 + 440) && !FigTimelineCoordinatorSuspensionCreate() && *(void *)(v6 + 440)) {
    figPlaybackCoordinator_BeginSuspension(v2);
  }
  MEMORY[0x19970E930](*(void *)(v6 + 352));
  if (v2) {
    goto LABEL_10;
  }
LABEL_11:

  free(a1);
}

uint64_t figPlaybackCoordinator_EndSuspension(uint64_t a1)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 64));
  uint64_t v2 = FigTimelineCoordinatorEndSuspension();
  if (!v2 && !FigTimelineCoordinatorIsSuspended()) {
    *(unsigned char *)(DerivedStorage + 320) = 1;
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 64));
  return v2;
}

uint64_t figPlaybackCoordinator_EndSuspensionProposingNewTime(const void *a1, const void *a2, long long *a3)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = malloc_type_malloc(0x28uLL, 0x1020040E349F4B1uLL);
  if (a1) {
    CFTypeRef v8 = CFRetain(a1);
  }
  else {
    CFTypeRef v8 = 0;
  }
  *uint64_t v7 = v8;
  if (a2) {
    CFTypeRef v9 = CFRetain(a2);
  }
  else {
    CFTypeRef v9 = 0;
  }
  v7[1] = v9;
  long long v10 = *a3;
  v7[4] = *((void *)a3 + 2);
  *((_OWORD *)v7 + 1) = v10;
  dispatch_async_f(*(dispatch_queue_t *)(DerivedStorage + 272), v7, (dispatch_function_t)figPlaybackCoordinator_EndSuspensionProposingNewTimeOnQueue);
  return 0;
}

uint64_t figPlaybackCoordinator_SetWeakMediumAndCallbacks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);

  return MEMORY[0x1F40DE718](v5, a2, a3);
}

uint64_t figPlaybackCoordinator_HandleAssignmentOfUUIDToLocalParticipantByMedium(uint64_t a1, uint64_t a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);

  return MEMORY[0x1F40DE6B8](v3, a2);
}

uint64_t figPlaybackCoordinator_CopyParticipantSnapshotForUUID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);

  return MEMORY[0x1F40DE650](v5, a2, a3);
}

uint64_t figPlaybackCoordinator_HandleRemovalOfParticipantStateFromMedium(uint64_t a1, uint64_t a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);

  return MEMORY[0x1F40DE6C0](v3, a2);
}

uint64_t figPlaybackCoordinator_GetExpectedTimeAtHostTime(uint64_t a1)
{
  return FigTimelineCoordinatorGetExpectedTimeAtHostTime();
}

uint64_t figPlaybackCoordinator_HandleUpdatedTimelineStateFromMedium(uint64_t a1, uint64_t a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);

  return MEMORY[0x1F40DE6E8](v3, a2);
}

uint64_t figPlaybackCoordinator_HandleReplacementOfAllParticipantStatesFromMedium(uint64_t a1, uint64_t a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);

  return MEMORY[0x1F40DE6C8](v3, a2);
}

uint64_t figPlaybackCoordinator_HandleUpdatedParticipantStateFromMedium(uint64_t a1, uint64_t a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);

  return MEMORY[0x1F40DE6E0](v3, a2);
}

uint64_t figPlaybackCoordinator_DisconnectFromMedium(uint64_t a1)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v1 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);

  return MEMORY[0x1F40DE670](v1);
}

uint64_t figPlaybackCoordinator_StopTrackingPlayer(void *a1)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a1) {
    CFRetain(a1);
  }
  dispatch_async_f(*(dispatch_queue_t *)(DerivedStorage + 272), a1, (dispatch_function_t)playbackCoordinator_stopTrackingPlayerOnQueue);
  return 0;
}

uint64_t figPlaybackCoordinator_ResetGroupTimelineExpectations(uint64_t a1)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t v1 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);

  return MEMORY[0x1F40DE700](v1);
}

void figPlaybackCoordinator_EndSuspensionProposingNewTimeOnQueue(uint64_t a1)
{
  CFTypeRef v2 = *(CFTypeRef *)a1;
  uint64_t v3 = *(const void **)(a1 + 8);
  CMTime v13 = *(CMTime *)(a1 + 16);
  long long v4 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  long long v10 = *MEMORY[0x1E4F1FA20];
  long long v11 = v4;
  long long v12 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  FigPlaybackCoordinatorGetCMBaseObject(v2);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, v3);
  FigPlaybackCoordinatorGetCMBaseObject(v2);
  if (!*(void *)(CMBaseObjectGetDerivedStorage() + 432)
    || (CMTime v9 = v13, !figPlaybackCoordinator_isTimeInCurrentlyPlayingInterstitial((uint64_t)v2, &v9)))
  {
    CMTime v9 = v13;
    if (figPlaybackCoordinator_isTimeInInterstitialRange((uint64_t)v2, &v9, &v10))
    {
      *(_OWORD *)&v13.CMTimeValue value = v10;
      v13.CMTimeEpoch epoch = v11;
    }
  }
  FigPlaybackCoordinatorGetCMBaseObject(v2);
  if (*(void *)(CMBaseObjectGetDerivedStorage() + 432))
  {
    CMTime v9 = v13;
    if (!figPlaybackCoordinator_isTimeInCurrentlyPlayingInterstitial((uint64_t)v2, &v9))
    {
      CFArrayAppendValue(Mutable, *(const void **)(DerivedStorage + 432));
      uint64_t v7 = *(const void **)(DerivedStorage + 432);
      if (v7)
      {
        CFRelease(v7);
        *(void *)(DerivedStorage + 432) = 0;
      }
    }
  }
  CMTime v9 = v13;
  figPlaybackCoordinator_getGroupTimeFromPlayerTime((uint64_t)v2, &v9, &v13);
  CMTime v9 = v13;
  FigTimelineCoordinatorEndSuspensionsProposingNewTime();
  CFTypeRef v8 = *(const void **)(a1 + 8);
  if (v8) {
    CFRelease(v8);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  free((void *)a1);
}

uint64_t figPlaybackCoordinator_isTimeInCurrentlyPlayingInterstitial(uint64_t a1, CMTime *a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = (_OWORD *)CMBaseObjectGetDerivedStorage();
  long long v4 = DerivedStorage[25];
  v7[0] = DerivedStorage[24];
  v7[1] = v4;
  v7[2] = DerivedStorage[26];
  CMTime v6 = *a2;
  return figPlaybackCoordinator_timeRangeContainsTimeWithStartTolerance((uint64_t)v7, &v6);
}

void playbackCoordinator_stopTrackingPlayerOnQueue(const void *a1)
{
  figPlaybackCoordinator_transitionToNewCurrentItem(a1, 0);
  if (a1)
  {
    CFRelease(a1);
  }
}

BOOL playbackCoordinator_systemEventSuspensionsActive(uint64_t a1)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 280));
  BOOL v2 = FigCFDictionaryGetCount() > 0;
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 280));
  return v2;
}

void playbackCoordinator_setReferenceTimebaseAndCompleteStartupTask(CFTypeRef *a1)
{
  uint64_t v2 = (uint64_t)*a1;
  FigPlaybackCoordinatorGetCMBaseObject(*a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = FigCFWeakReferenceHolderCopyReferencedObject();
  uint64_t v5 = (const void *)v4;
  if (*(_DWORD *)(DerivedStorage + 176) == *((_DWORD *)a1 + 2))
  {
    if (v4)
    {
      uint64_t v6 = *(void *)(DerivedStorage + 40);
      if (v6 && *(_DWORD *)(DerivedStorage + 56) == 10000)
      {
        uint64_t v7 = *(void *)(DerivedStorage + 160);
        uint64_t FigBaseObject = FigPlaybackItemGetFigBaseObject(v6);
        uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v9) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = 0;
        }
        long long v11 = *(void (**)(uint64_t, __CFString *, uint64_t))(v10 + 56);
        if (v11) {
          v11(FigBaseObject, @"TransientTimebaseForCoordinatedPlaybackSynchronization", v7);
        }
        CFTypeRef cf = 0;
        uint64_t v12 = FigPlayerGetFigBaseObject(v5);
        uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v13) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v15 = *(void (**)(uint64_t, __CFString *, void, CFTypeRef *))(v14 + 48);
        if (v15)
        {
          v15(v12, @"SynchronizedNULL", *MEMORY[0x1E4F1CF80], &cf);
          if (cf) {
            CFRelease(cf);
          }
        }
        playbackCoordinator_completePendingStartupTask(v2, 1);
      }
      else
      {
        FigSignalErrorAt();
      }
      goto LABEL_17;
    }
    FigSignalErrorAt();
  }
  else if (v4)
  {
LABEL_17:
    CFRelease(v5);
  }
  if (*a1) {
    CFRelease(*a1);
  }
  free(a1);
}

BOOL CMTimeDifferenceIsWithinTolerance(CMTime *a1, CMTime *a2, CMTime *a3)
{
  CMTime lhs = *a1;
  CMTime v5 = *a2;
  CMTimeSubtract(&time, &lhs, &v5);
  CMTimeAbsoluteValue(&time1, &time);
  CMTime lhs = *a3;
  return CMTimeCompare(&time1, &lhs) < 1;
}

uint64_t figPlaybackCoordinator_isInterstitialScheduledAtTime(uint64_t a1, CMTime *a2)
{
  FigPlaybackCoordinatorGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef v5 = *(const __CFArray **)(DerivedStorage + 360);
  if (v5 && CFArrayGetCount(v5) >= 1)
  {
    CMTime v19 = *a2;
    return figPlaybackCoordinator_isTimeInInterstitialRange(a1, &v19, 0);
  }
  else
  {
    CFArrayRef v7 = *(const __CFArray **)(DerivedStorage + 456);
    if (v7
      && CFArrayGetCount(v7) >= 1
      && (*(_OWORD *)&v15.CMTimeValue value = *(_OWORD *)&a2->value,
          v15.CMTimeEpoch epoch = a2->epoch,
          FigPlaybackCoordinatorGetCMBaseObject(a1),
          uint64_t v8 = CMBaseObjectGetDerivedStorage(),
          (CFArrayRef v9 = *(const __CFArray **)(v8 + 456)) != 0)
      && (CFIndex Count = CFArrayGetCount(v9), Count >= 1))
    {
      CFIndex v11 = Count;
      CFIndex v12 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v8 + 456), v12);
        memset(&v19, 0, sizeof(v19));
        CMTimeMakeFromDictionary(&v19, ValueAtIndex);
        uint64_t v6 = 1;
        CMTimeMake(&v18, 1, 1000);
        CMTime v17 = v19;
        CMTime v16 = v15;
        if (CMTimeDifferenceIsWithinTolerance(&v17, &v16, &v18)) {
          break;
        }
        if (v11 == ++v12) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

uint64_t FigTTMLHeadCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a4)
  {
    FigTTMLNodeGetClassID();
    uint64_t Default = CMDerivedObjectCreate();
    if (Default) {
      return Default;
    }
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    uint64_t Default = FigTTMLInitializeNodeBaseStorage(DerivedStorage, (long long *)a3);
    if (Default) {
      return Default;
    }
    *(void *)(DerivedStorage + 152) = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
    uint64_t Default = FigTTMLAddCurrentElementAttributesToDictionary(a2, *(__CFDictionary **)(DerivedStorage + 24));
    if (Default) {
      return Default;
    }
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    uint64_t Default = FigTTMLParseNode(a2, (uint64_t (*)(uint64_t, uint64_t *, CFTypeRef *))figTTMLHead_ConsumeChildNode, (uint64_t *)a3);
    if (Default) {
      return Default;
    }
    uint64_t v11 = *(void *)(DerivedStorage + 144);
    uint64_t v10 = (CFTypeRef *)(DerivedStorage + 144);
    if (!v11)
    {
      uint64_t Default = FigTTMLLayoutCreateDefault(a1, a3, v10);
      if (Default) {
        return Default;
      }
    }
    uint64_t v12 = 0;
    *a4 = 0;
    return v12;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t figTTMLHead_ConsumeChildNode(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef v17 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v16 = 0;
  uint64_t v7 = FigTTMLGetLibXMLAccess();
  if (!v7)
  {
    uint64_t v14 = FigSignalErrorAt();
    goto LABEL_25;
  }
  if ((*(unsigned int (**)(uint64_t))(v7 + 72))(a1) != 1) {
    goto LABEL_20;
  }
  uint64_t v8 = FigTTMLCopyNamespaceAndLocalNameOfCurrentNode(a1, (const char **)&v17, (CFStringRef *)&v16);
  if (v8) {
    goto LABEL_30;
  }
  if (FigCFEqual() && FigCFEqual())
  {
    CFAllocatorRef v9 = CFGetAllocator(*a2);
    uint64_t v8 = FigTTMLStylingCreate(v9, a1, (uint64_t)a2, &cf);
    if (!v8)
    {
      uint64_t v10 = *(const void **)(DerivedStorage + 136);
      CFTypeRef v11 = cf;
      *(void *)(DerivedStorage + 136) = cf;
      if (!v11) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
    goto LABEL_30;
  }
  if (!FigCFEqual() || !FigCFEqual())
  {
    if (FigCFEqual() && FigCFEqual())
    {
      CFAllocatorRef v13 = CFGetAllocator(*a2);
      uint64_t v8 = FigTTMLProfileCreate(v13, a1, (uint64_t)a2, &cf);
      if (v8) {
        goto LABEL_30;
      }
      CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 152), cf);
LABEL_21:
      uint64_t v14 = 0;
      if (a3)
      {
        *a3 = cf;
        CFTypeRef cf = 0;
      }
      goto LABEL_23;
    }
LABEL_20:
    uint64_t v8 = FigTTMLSkipNode(a1, (uint64_t *)a2, *(__CFArray **)(DerivedStorage + 128));
    if (v8) {
      goto LABEL_30;
    }
    goto LABEL_21;
  }
  CFAllocatorRef v12 = CFGetAllocator(*a2);
  uint64_t v8 = FigTTMLLayoutCreate(v12, a1, (uint64_t)a2, &cf);
  if (!v8)
  {
    uint64_t v10 = *(const void **)(DerivedStorage + 144);
    CFTypeRef v11 = cf;
    *(void *)(DerivedStorage + 144) = cf;
    if (!v11)
    {
LABEL_9:
      if (v10) {
        CFRelease(v10);
      }
      goto LABEL_21;
    }
LABEL_8:
    CFRetain(v11);
    goto LABEL_9;
  }
LABEL_30:
  uint64_t v14 = v8;
LABEL_23:
  if (v16) {
    CFRelease(v16);
  }
LABEL_25:
  if (v17) {
    CFRelease(v17);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v14;
}

uint64_t FigTTMLHeadCreateDefault(const __CFAllocator *a1, uint64_t a2, void *a3)
{
  if (a3)
  {
    FigTTMLNodeGetClassID();
    uint64_t Default = CMDerivedObjectCreate();
    if (!Default)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      uint64_t v8 = FigTTMLInitializeNodeBaseStorage(DerivedStorage, (long long *)a2);
      if (v8)
      {
        return v8;
      }
      else
      {
        *(void *)(DerivedStorage + 152) = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
        *(void *)a2 = 0;
        *(void *)(a2 + 8) = 0;
        uint64_t Default = FigTTMLLayoutCreateDefault(a1, a2, (CFTypeRef *)(DerivedStorage + 144));
        if (!Default) {
          *a3 = 0;
        }
      }
    }
    return Default;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void figTTMLHead_Finalize()
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v1 = (const void *)DerivedStorage[17];
  if (v1) {
    CFRelease(v1);
  }
  uint64_t v2 = (const void *)DerivedStorage[18];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)DerivedStorage[19];
  if (v3) {
    CFRelease(v3);
  }

  FigTTMLReleaseNodeBaseStorage((uint64_t)DerivedStorage);
}

CFStringRef figTTMLHead_CopyDebugDesc()
{
  CMBaseObjectGetDerivedStorage();
  uint64_t v0 = (const void *)FigCFCopyCompactDescription();
  CFStringRef v1 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"head %@", v0);
  if (v0) {
    CFRelease(v0);
  }
  return v1;
}

uint64_t figTTMLHead_CopyChildNodeArray(const void *a1, __CFArray **a2)
{
  CFAllocatorRef v3 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    uint64_t v6 = DerivedStorage;
    CFArrayRef v7 = *(const __CFArray **)(DerivedStorage + 152);
    if (v7) {
      v8.length = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 152));
    }
    else {
      v8.length = 0;
    }
    v8.location = 0;
    CFArrayAppendArray(Mutable, v7, v8);
    CFAllocatorRef v9 = *(const void **)(v6 + 136);
    if (v9) {
      CFArrayAppendValue(Mutable, v9);
    }
    uint64_t v10 = *(const void **)(v6 + 144);
    if (v10) {
      CFArrayAppendValue(Mutable, v10);
    }
    uint64_t v11 = 0;
    *a2 = Mutable;
  }
  else
  {
    uint64_t v11 = FigSignalErrorAt();
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  return v11;
}

uint64_t figTTMLHead_GetNodeType(uint64_t a1, _DWORD *a2)
{
  if (!a2) {
    return FigSignalErrorAt();
  }
  *a2 = 8;
  return 0;
}

uint64_t CreateTrackReaderDictionary(const __CFAllocator *a1, uint64_t *a2)
{
  CMTimeValue value = 0;
  MovieInformationLockForRead(a2[1]);
  uint64_t v4 = FigSimpleMutexCreate();
  a2[2] = v4;
  if (v4 && (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) != 0)
  {
    uint64_t v6 = Mutable;
    TrackCFIndex Count = MovieInformationGetTrackCount(a2[1]);
    if (TrackCount < 1)
    {
LABEL_7:
      uint64_t v13 = 0;
      a2[3] = (uint64_t)v6;
    }
    else
    {
      uint64_t v8 = TrackCount;
      uint64_t v9 = 0;
      while (1)
      {
        TrackForTrackIndex = (const void *)MovieInformationFindTrackForTrackIndex(a2[1], v9);
        uint64_t v11 = CreateTrackReaderForMovieTrack((uint64_t)a1, (const void *)a2[1], TrackForTrackIndex, &value);
        CFAllocatorRef v12 = value;
        if (v11) {
          break;
        }
        CFDictionarySetValue(v6, TrackForTrackIndex, value);
        CFRelease(v12);
        CMTimeValue value = 0;
        if (v8 == ++v9) {
          goto LABEL_7;
        }
      }
      uint64_t v13 = v11;
      if (value) {
        CFRelease(value);
      }
      CFRelease(v6);
    }
  }
  else
  {
    uint64_t v13 = FigSignalErrorAt();
  }
  MovieInformationUnlockForRead(a2[1]);
  return v13;
}

uint64_t MovieFormatReaderGetMovieInformation(uint64_t a1)
{
  if (a1 && (_UNKNOWN *)CMBaseObjectGetVTable() == &kMovieFormatReaderVTable) {
    return *(void *)(CMBaseObjectGetDerivedStorage() + 8);
  }
  FigSignalErrorAt();
  return 0;
}

uint64_t MovieFormatReaderCreateWithMovieInformation(void *a1, char a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    CFAllocatorRef v6 = CFGetAllocator(a1);
    FigFormatReaderGetClassID();
    uint64_t TrackReaderDictionary = CMDerivedObjectCreate();
    if (!TrackReaderDictionary)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      uint64_t v9 = FigSimpleMutexCreate();
      *(void *)(DerivedStorage + 80) = v9;
      if (v9 && (uint64_t v10 = FigSimpleMutexCreate(), (*(void *)(DerivedStorage + 72) = v10) != 0))
      {
        IsCFMutableDictionaryRef Mutable = MovieInformationIsMutable((uint64_t)a1);
        BOOL v12 = !IsMutable;
        if (!IsMutable)
        {
LABEL_13:
          *(void *)(DerivedStorage + 8) = CFRetain(a1);
LABEL_14:
          uint64_t TrackReaderDictionary = CreateTrackReaderDictionary(v6, (uint64_t *)DerivedStorage);
          if (!TrackReaderDictionary)
          {
            MovieInformationLockForRead(*(void *)(DerivedStorage + 8));
            if (!v12)
            {
              CMNotificationCenterGetDefaultLocalCenter();
              CMNotificationCenterAddListener();
              *(unsigned char *)(DerivedStorage + 120) = 1;
              TrackCFIndex Count = MovieInformationGetTrackCount(*(void *)(DerivedStorage + 8));
              if (TrackCount >= 1)
              {
                uint64_t v15 = TrackCount;
                for (uint64_t i = 0; i != v15; ++i)
                {
                  uint64_t v21 = 0;
                  TrackForTrackIndex = (const void *)MovieInformationFindTrackForTrackIndex(*(void *)(DerivedStorage + 8), i);
                  CopyTrackReader(DerivedStorage, TrackForTrackIndex, &v21);
                  CMTime v18 = v21;
                  if (v21)
                  {
                    uint64_t v19 = CMBaseObjectGetDerivedStorage();
                    CMNotificationCenterGetDefaultLocalCenter();
                    CMNotificationCenterAddListener();
                    *(unsigned char *)(v19 + 64) = 1;
                    CFRelease(v18);
                  }
                }
              }
            }
            MovieInformationUnlockForRead(*(void *)(DerivedStorage + 8));
            uint64_t v13 = 0;
            *a3 = cf;
            return v13;
          }
          goto LABEL_24;
        }
        if ((a2 & 1) == 0)
        {
          uint64_t v13 = MovieInformationLockForWrite((uint64_t)a1);
          if (v13) {
            goto LABEL_8;
          }
          uint64_t v13 = MovieInformationEnsureMutationsWillNotify((uint64_t)a1);
          MovieInformationUnlockForWrite(a1);
          if (v13) {
            goto LABEL_8;
          }
          goto LABEL_13;
        }
        uint64_t TrackReaderDictionary = MovieInformationCreateDeepCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (uint64_t)a1, 0, (void *)(DerivedStorage + 8));
        if (!TrackReaderDictionary)
        {
          BOOL v12 = 1;
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t TrackReaderDictionary = FigSignalErrorAt();
      }
    }
LABEL_24:
    uint64_t v13 = TrackReaderDictionary;
LABEL_8:
    if (cf) {
      CFRelease(cf);
    }
    return v13;
  }

  return FigSignalErrorAt();
}

void MovieMutationNotificationCallback(int a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, const __CFDictionary *a5)
{
  uint64_t v20 = 0;
  if (!CFEqual(cf1, @"MovieChanges"))
  {
    if (CFEqual(cf1, @"TrackAdded"))
    {
      if (!a5 || !CFDictionaryGetValueIfPresent(a5, @"TrackInfo", (const void **)&v20)) {
        return;
      }
      BOOL v12 = v20;
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      CMTimeValue value = 0;
      if (CreateTrackReaderForMovieTrack(*MEMORY[0x1E4F1CF80], *(const void **)(DerivedStorage + 8), v12, &value))
      {
        uint64_t v14 = value;
        if (!value) {
          goto LABEL_35;
        }
      }
      else
      {
        MEMORY[0x19970E910](*(void *)(DerivedStorage + 16));
        uint64_t v14 = value;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(DerivedStorage + 24), v12, value);
        MEMORY[0x19970E930](*(void *)(DerivedStorage + 16));
        CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterAddListener();
        *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 64) = 1;
        if (!v14)
        {
LABEL_35:
          CMNotificationCenterGetDefaultLocalCenter();
          CMNotificationCenterPostNotification();
          return;
        }
      }
      uint64_t v15 = v14;
    }
    else
    {
      int v16 = CFEqual(cf1, @"TrackRemoved");
      if (!a5 || !v16 || !CFDictionaryGetValueIfPresent(a5, @"TrackInfo", (const void **)&v20)) {
        return;
      }
      CFTypeRef v17 = v20;
      uint64_t v18 = CMBaseObjectGetDerivedStorage();
      CMTimeValue value = 0;
      CopyTrackReader(v18, v17, &value);
      uint64_t v19 = value;
      if (!value)
      {
        MEMORY[0x19970E910](*(void *)(v18 + 16));
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v18 + 24), v17);
        MEMORY[0x19970E930](*(void *)(v18 + 16));
        goto LABEL_35;
      }
      *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 64) = 0;
      CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterRemoveListener();
      CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterBarrier();
      MEMORY[0x19970E910](*(void *)(v18 + 16));
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v18 + 24), v17);
      MEMORY[0x19970E930](*(void *)(v18 + 16));
      uint64_t v15 = v19;
    }
    CFRelease(v15);
    goto LABEL_35;
  }
  if (!a5) {
    return;
  }
  CFTypeID v8 = CFGetTypeID(a5);
  if (v8 != CFDictionaryGetTypeID()) {
    return;
  }
  CMTimeValue value = 0;
  if (!CFDictionaryGetValueIfPresent(a5, @"ChangeBits", (const void **)&value)) {
    return;
  }
  uint64_t valuePtr = 0;
  CFNumberGetValue((CFNumberRef)value, kCFNumberSInt64Type, &valuePtr);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  __int16 v10 = valuePtr;
  if (valuePtr)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    __int16 v10 = valuePtr;
  }
  uint64_t v11 = (const void **)MEMORY[0x1E4F1CFD0];
  if ((v10 & 0x100) != 0)
  {
    CFDictionarySetValue(Mutable, @"TrackReferenceDictionary", (const void *)*MEMORY[0x1E4F1CFD0]);
    __int16 v10 = valuePtr;
    if ((valuePtr & 0x80) == 0)
    {
LABEL_9:
      if ((v10 & 0x200) == 0) {
        goto LABEL_10;
      }
      goto LABEL_39;
    }
  }
  else if ((v10 & 0x80) == 0)
  {
    goto LABEL_9;
  }
  CFDictionarySetValue(Mutable, @"AlternateGroupArray", *v11);
  __int16 v10 = valuePtr;
  if ((valuePtr & 0x200) == 0)
  {
LABEL_10:
    if ((v10 & 0x400) == 0) {
      goto LABEL_11;
    }
    goto LABEL_40;
  }
LABEL_39:
  CFDictionarySetValue(Mutable, @"PreferredRate", *v11);
  __int16 v10 = valuePtr;
  if ((valuePtr & 0x400) == 0)
  {
LABEL_11:
    if ((v10 & 0x1000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_41;
  }
LABEL_40:
  CFDictionarySetValue(Mutable, @"PreferredVolume", *v11);
  __int16 v10 = valuePtr;
  if ((valuePtr & 0x1000) == 0)
  {
LABEL_12:
    if ((v10 & 0x2000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_42;
  }
LABEL_41:
  CFDictionarySetValue(Mutable, @"FormatDescriptionsChanged", *v11);
  __int16 v10 = valuePtr;
  if ((valuePtr & 0x2000) == 0)
  {
LABEL_13:
    if ((v10 & 0x4000) == 0) {
      goto LABEL_14;
    }
    goto LABEL_43;
  }
LABEL_42:
  CFDictionarySetValue(Mutable, @"EnabledTracksChanged", *v11);
  LOBYTE(v10) = valuePtr;
  if ((valuePtr & 0x4000) == 0)
  {
LABEL_14:
    if ((v10 & 8) == 0) {
      goto LABEL_15;
    }
    goto LABEL_44;
  }
LABEL_43:
  CFDictionarySetValue(Mutable, @"ContainsChapters", *v11);
  LOBYTE(v10) = valuePtr;
  if ((valuePtr & 8) == 0)
  {
LABEL_15:
    if ((v10 & 0x10) == 0) {
      goto LABEL_16;
    }
    goto LABEL_45;
  }
LABEL_44:
  ReactToMovieMetadataChange(a2, 8, Mutable);
  LOBYTE(v10) = valuePtr;
  if ((valuePtr & 0x10) == 0)
  {
LABEL_16:
    if ((v10 & 0x20) == 0) {
      goto LABEL_17;
    }
LABEL_46:
    ReactToMovieMetadataChange(a2, 32, Mutable);
    if ((valuePtr & 0x40) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
LABEL_45:
  ReactToMovieMetadataChange(a2, 16, Mutable);
  LOBYTE(v10) = valuePtr;
  if ((valuePtr & 0x20) != 0) {
    goto LABEL_46;
  }
LABEL_17:
  if ((v10 & 0x40) != 0) {
LABEL_18:
  }
    ReactToMovieMetadataChange(a2, 64, Mutable);
LABEL_19:
  if (CFDictionaryGetCount(Mutable))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

uint64_t CopyTrackReader(uint64_t a1, const void *a2, void *a3)
{
  MEMORY[0x19970E910](*(void *)(a1 + 16));
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    CFArrayRef v7 = Value;
    CFRetain(Value);
    MEMORY[0x19970E930](*(void *)(a1 + 16));
    *a3 = v7;
    return 0;
  }
  else
  {
    MEMORY[0x19970E930](*(void *)(a1 + 16));
    return FigSignalErrorAt();
  }
}

void TrackMutationNotificationCallback(int a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, const void *a5)
{
  if (CFEqual(cf1, @"TrackChanges"))
  {
    if (!a5) {
      return;
    }
    CFTypeID v8 = CFGetTypeID(a5);
    if (v8 != CFDictionaryGetTypeID()) {
      return;
    }
    CMTimeValue value = 0;
    if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)a5, @"ChangeBits", (const void **)&value)) {
      return;
    }
    uint64_t v16 = 0;
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt64Type, &v16);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    int v10 = v16;
    if (v16)
    {
      CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification();
      uint64_t v11 = (const void *)*MEMORY[0x1E4F1CFD0];
      CFDictionarySetValue(Mutable, @"UneditedSampleCount", (const void *)*MEMORY[0x1E4F1CFD0]);
      CFDictionarySetValue(Mutable, @"UneditedTrackDuration", v11);
      CFDictionarySetValue(Mutable, @"NominalFrameRate", v11);
      CFDictionarySetValue(Mutable, @"MinSampleDuration", v11);
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      MEMORY[0x19970E910](*(void *)(DerivedStorage + 48));
      uint64_t v13 = *(const void **)(DerivedStorage + 56);
      if (v13)
      {
        CFRelease(v13);
        *(void *)(DerivedStorage + 56) = 0;
      }
      MEMORY[0x19970E930](*(void *)(DerivedStorage + 48));
      int v10 = v16;
      if ((v16 & 4) == 0)
      {
LABEL_7:
        if ((v10 & 0x40) == 0) {
          goto LABEL_8;
        }
        goto LABEL_47;
      }
    }
    else if ((v16 & 4) == 0)
    {
      goto LABEL_7;
    }
    CFDictionarySetValue(Mutable, @"TrackFormatDescriptionArray", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x40) == 0)
    {
LABEL_8:
      if ((v10 & 0x80) == 0) {
        goto LABEL_9;
      }
      goto LABEL_48;
    }
LABEL_47:
    CFDictionarySetValue(Mutable, @"TrackEnabled", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x80) == 0)
    {
LABEL_9:
      if ((v10 & 0x100) == 0) {
        goto LABEL_10;
      }
      goto LABEL_49;
    }
LABEL_48:
    CFDictionarySetValue(Mutable, @"TrackLanguageCode", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x100) == 0)
    {
LABEL_10:
      if ((v10 & 0x200) == 0) {
        goto LABEL_11;
      }
      goto LABEL_50;
    }
LABEL_49:
    CFDictionarySetValue(Mutable, @"ExtendedLanguageTagString", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x200) == 0)
    {
LABEL_11:
      if ((v10 & 0x400) == 0) {
        goto LABEL_12;
      }
      goto LABEL_51;
    }
LABEL_50:
    CFDictionarySetValue(Mutable, @"CleanApertureDimensions", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x400) == 0)
    {
LABEL_12:
      if ((v10 & 0x800) == 0) {
        goto LABEL_13;
      }
      goto LABEL_52;
    }
LABEL_51:
    CFDictionarySetValue(Mutable, @"TrackDimensions", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x800) == 0)
    {
LABEL_13:
      if ((v10 & 0x1000) == 0) {
        goto LABEL_14;
      }
      goto LABEL_53;
    }
LABEL_52:
    CFDictionarySetValue(Mutable, @"TrackExcludeFromAutoSelection", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x1000) == 0)
    {
LABEL_14:
      if ((v10 & 0x400000) == 0) {
        goto LABEL_15;
      }
      goto LABEL_54;
    }
LABEL_53:
    CFDictionarySetValue(Mutable, @"AlternateGroupID", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x400000) == 0)
    {
LABEL_15:
      if ((v10 & 0x800000) == 0) {
        goto LABEL_16;
      }
      goto LABEL_55;
    }
LABEL_54:
    CFDictionarySetValue(Mutable, @"ProvisionalAlternateGroupID", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x800000) == 0)
    {
LABEL_16:
      if ((v10 & 0x2000) == 0) {
        goto LABEL_17;
      }
      goto LABEL_56;
    }
LABEL_55:
    CFDictionarySetValue(Mutable, @"DefaultAlternateGroupID", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x2000) == 0)
    {
LABEL_17:
      if ((v10 & 0x4000) == 0) {
        goto LABEL_18;
      }
      goto LABEL_57;
    }
LABEL_56:
    uint64_t v14 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionarySetValue(Mutable, @"EstimatedDataRate", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionarySetValue(Mutable, @"UneditedNumDataBytes", v14);
    int v10 = v16;
    if ((v16 & 0x4000) == 0)
    {
LABEL_18:
      if ((v10 & 0x8000) == 0) {
        goto LABEL_19;
      }
      goto LABEL_58;
    }
LABEL_57:
    CFDictionarySetValue(Mutable, @"ProductionApertureDimensions", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x8000) == 0)
    {
LABEL_19:
      if ((v10 & 0x10000) == 0) {
        goto LABEL_20;
      }
      goto LABEL_59;
    }
LABEL_58:
    CFDictionarySetValue(Mutable, @"EncodedPixelsDimensions", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x10000) == 0)
    {
LABEL_20:
      if ((v10 & 0x20000) == 0) {
        goto LABEL_21;
      }
      goto LABEL_60;
    }
LABEL_59:
    CFDictionarySetValue(Mutable, @"Volume", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x20000) == 0)
    {
LABEL_21:
      if ((v10 & 0x40000) == 0) {
        goto LABEL_22;
      }
      goto LABEL_61;
    }
LABEL_60:
    CFDictionarySetValue(Mutable, @"TrackLayer", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x40000) == 0)
    {
LABEL_22:
      if ((v10 & 0x80000) == 0) {
        goto LABEL_23;
      }
      goto LABEL_62;
    }
LABEL_61:
    CFDictionarySetValue(Mutable, @"TrackQTLoadSettings", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x80000) == 0)
    {
LABEL_23:
      if ((v10 & 0x100000) == 0) {
        goto LABEL_24;
      }
      goto LABEL_63;
    }
LABEL_62:
    CFDictionarySetValue(Mutable, @"TrackMatrix", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x100000) == 0)
    {
LABEL_24:
      if ((v10 & 2) == 0) {
        goto LABEL_25;
      }
      goto LABEL_64;
    }
LABEL_63:
    CFDictionarySetValue(Mutable, @"TrackReferencesChanged", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 2) == 0)
    {
LABEL_25:
      if ((v10 & 0x200000) == 0) {
        goto LABEL_26;
      }
      goto LABEL_65;
    }
LABEL_64:
    CFDictionarySetValue(Mutable, @"EditCursorService", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x200000) == 0)
    {
LABEL_26:
      if ((v10 & 8) == 0) {
        goto LABEL_27;
      }
      goto LABEL_66;
    }
LABEL_65:
    CFDictionarySetValue(Mutable, @"ContainsChapters", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 8) == 0)
    {
LABEL_27:
      if ((v10 & 0x10) == 0) {
        goto LABEL_28;
      }
      goto LABEL_67;
    }
LABEL_66:
    ReactToTrackMetadataChange(a2, 8, Mutable);
    int v10 = v16;
    if ((v16 & 0x10) == 0)
    {
LABEL_28:
      if ((v10 & 0x20) == 0) {
        goto LABEL_29;
      }
      goto LABEL_68;
    }
LABEL_67:
    ReactToTrackMetadataChange(a2, 16, Mutable);
    int v10 = v16;
    if ((v16 & 0x20) == 0)
    {
LABEL_29:
      if ((v10 & 0x1000000) == 0) {
        goto LABEL_30;
      }
      goto LABEL_69;
    }
LABEL_68:
    ReactToTrackMetadataChange(a2, 32, Mutable);
    int v10 = v16;
    if ((v16 & 0x1000000) == 0)
    {
LABEL_30:
      if ((v10 & 0x2000000) == 0) {
        goto LABEL_31;
      }
      goto LABEL_70;
    }
LABEL_69:
    CFDictionarySetValue(Mutable, @"SampleGroupDescriptions", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x2000000) == 0)
    {
LABEL_31:
      if ((v10 & 0x4000000) == 0) {
        goto LABEL_32;
      }
      goto LABEL_71;
    }
LABEL_70:
    CFDictionarySetValue(Mutable, @"HasRollInformation", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v10 = v16;
    if ((v16 & 0x4000000) == 0)
    {
LABEL_32:
      if ((v10 & 0x8000000) == 0)
      {
LABEL_34:
        if (CFDictionaryGetCount(Mutable))
        {
          CMNotificationCenterGetDefaultLocalCenter();
          CMNotificationCenterPostNotification();
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        return;
      }
LABEL_33:
      CFDictionarySetValue(Mutable, @"HasAudioSampleDependencyInformation", (const void *)*MEMORY[0x1E4F1CFD0]);
      goto LABEL_34;
    }
LABEL_71:
    uint64_t v15 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionarySetValue(Mutable, @"HEVCSyncSampleNALUnitTypes", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionarySetValue(Mutable, @"HEVCTemporalLevelInfoCombinations", v15);
    if ((v16 & 0x8000000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  if (CFEqual(cf1, @"TrackEditSegmentsChanged"))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
  }
}

uint64_t MovieFormatReaderFinalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 120))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterRemoveListener();
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterBarrier();
  }
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  CFStringRef v1 = *(const void **)(DerivedStorage + 24);
  if (v1)
  {
    CFRelease(v1);
    *(void *)(DerivedStorage + 24) = 0;
  }
  if (*(void *)(DerivedStorage + 16)) {
    FigSimpleMutexDestroy();
  }
  uint64_t v2 = *(const void **)(DerivedStorage + 8);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(DerivedStorage + 8) = 0;
  }
  if (*(void *)(DerivedStorage + 80)) {
    FigSimpleMutexDestroy();
  }
  CFAllocatorRef v3 = *(const void **)(DerivedStorage + 64);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(DerivedStorage + 64) = 0;
  }
  uint64_t v4 = *(const void **)(DerivedStorage + 88);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(DerivedStorage + 88) = 0;
  }
  CFArrayRef v5 = *(const void **)(DerivedStorage + 104);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(DerivedStorage + 104) = 0;
  }
  CFAllocatorRef v6 = *(const void **)(DerivedStorage + 96);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(DerivedStorage + 96) = 0;
  }
  CFArrayRef v7 = *(const void **)(DerivedStorage + 112);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(DerivedStorage + 112) = 0;
  }

  return FigSimpleMutexDestroy();
}

__CFString *MovieFormatReaderCopyDebugDescription(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  uint64_t v5 = *(void *)(DerivedStorage + 8);
  if (v5)
  {
    if (*(void *)DerivedStorage)
    {
      CFStringRef v6 = CFCopyDescription(*(CFTypeRef *)DerivedStorage);
      uint64_t v5 = *(void *)(DerivedStorage + 8);
    }
    else
    {
      CFStringRef v6 = 0;
    }
    TrackCFIndex Count = MovieInformationGetTrackCount(v5);
    IsCFMutableDictionaryRef Mutable = MovieInformationIsMutable(*(void *)(DerivedStorage + 8));
    uint64_t v9 = " Mutable";
    if (!IsMutable) {
      uint64_t v9 = "";
    }
    CFStringAppendFormat(Mutable, 0, @"\tMovieFormatReader: %p stream<%@> trackCount<%d>%s", a1, v6, TrackCount, v9);
    if (v6) {
      CFRelease(v6);
    }
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"\tMovieFormatReader: %p APPEARS INVALIDATED", a1);
  }
  return Mutable;
}

uint64_t MovieFormatReaderCopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFDictionaryRef *a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*(void *)(DerivedStorage + 8));
  if (!a4) {
    goto LABEL_101;
  }
  *a4 = 0;
  if (CFEqual(a2, @"Duration"))
  {
    keys[1] = 0;
    *(void *)&long long v39 = 0;
    keys[0] = 0;
    MovieInformationGetMovieDuration(*(void *)(DerivedStorage + 8), (uint64_t)keys);
    CMTime context = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    MEMORY[0x19970E910](*(void *)(DerivedStorage + 16));
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(DerivedStorage + 24), (CFDictionaryApplierFunction)FindMaximumEditedTrackDuration, &context);
    MEMORY[0x19970E930](*(void *)(DerivedStorage + 16));
    CMTime time1 = context;
    *(_OWORD *)&v36.CMTimeValue value = *(_OWORD *)keys;
    v36.CMTimeEpoch epoch = v39;
    if (CMTimeCompare(&time1, &v36) < 0)
    {
      *(_OWORD *)keys = *(_OWORD *)&context.value;
      *(void *)&long long v39 = context.epoch;
    }
    *(_OWORD *)&time1.CMTimeValue value = *(_OWORD *)keys;
    time1.CMTimeEpoch epoch = v39;
    p_CMTime time1 = &time1;
LABEL_9:
    CFDictionaryRef v9 = CMTimeCopyAsDictionary(p_time1, a3);
    *a4 = v9;
    if (v9)
    {
LABEL_10:
      uint64_t v10 = 0;
      goto LABEL_11;
    }
    goto LABEL_101;
  }
  if (CFEqual(a2, @"NominalDuration"))
  {
    keys[1] = 0;
    *(void *)&long long v39 = 0;
    keys[0] = 0;
    MovieInformationGetMovieDuration(*(void *)(DerivedStorage + 8), (uint64_t)keys);
LABEL_8:
    *(_OWORD *)&context.CMTimeValue value = *(_OWORD *)keys;
    context.CMTimeEpoch epoch = v39;
    p_CMTime time1 = &context;
    goto LABEL_9;
  }
  if (CFEqual(a2, @"Identifier"))
  {
    BOOL v12 = (const void **)kFigFormatReaderIdentifier_QuickTime_ISO;
LABEL_17:
    uint64_t v13 = *v12;
LABEL_18:
    CFDictionaryRef AlternateGroupArray = (const __CFDictionary *)CFRetain(v13);
LABEL_19:
    uint64_t v10 = 0;
LABEL_20:
    *a4 = AlternateGroupArray;
    goto LABEL_11;
  }
  if (CFEqual(a2, @"AccurateDurationIsKnown") || CFEqual(a2, @"SampleCursorTimeAccuracyIsExact"))
  {
LABEL_16:
    BOOL v12 = (const void **)MEMORY[0x1E4F1CFD0];
    goto LABEL_17;
  }
  if (CFEqual(a2, @"ImportantResourceLocation"))
  {
    time1.CMTimeValue value = 0;
    v36.CMTimeValue value = 0;
    keys[0] = @"LocationOffset";
    keys[1] = @"LocationSize";
    MovieInformationGetMoovLocation(*(void *)(DerivedStorage + 8), &time1, &v36);
    CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    context.CMTimeValue value = (CMTimeValue)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &time1);
    *(void *)&context.CMTimeScale timescale = CFNumberCreate(v15, kCFNumberSInt64Type, &v36);
    *a4 = CFDictionaryCreate(a3, (const void **)keys, (const void **)&context, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (context.value) {
      CFRelease((CFTypeRef)context.value);
    }
    uint64_t v16 = *(__CFArray **)&context.timescale;
    if (!*(void *)&context.timescale) {
      goto LABEL_10;
    }
    goto LABEL_25;
  }
  if (CFEqual(a2, @"AlternateGroupArray"))
  {
    CFDictionaryRef AlternateGroupArray = MovieInformationCreateAlternateGroupArray(a3, *(void *)(DerivedStorage + 8));
    goto LABEL_19;
  }
  if (CFEqual(a2, @"TrackReferenceDictionary"))
  {
    uint64_t TrackReferenceDictionary = MovieInformationCreateTrackReferenceDictionary(a3, *(void *)(DerivedStorage + 8), a4);
LABEL_102:
    uint64_t v10 = TrackReferenceDictionary;
    goto LABEL_11;
  }
  if (CFEqual(a2, @"Lyrics"))
  {
    uint64_t TrackReferenceDictionary = GetLyricsFromMovieMetadata((uint64_t)a3, (uint64_t *)DerivedStorage, a4);
    goto LABEL_102;
  }
  if (CFEqual(a2, @"LyricsScanCompleted"))
  {
    uint64_t v10 = 0;
    *a4 = (CFDictionaryRef)*MEMORY[0x1E4F1CFD0];
    goto LABEL_11;
  }
  if (CFEqual(a2, @"PreferredRate"))
  {
    LODWORD(keys[0]) = 1065353216;
    uint64_t v18 = *(void *)(DerivedStorage + 8);
    uint64_t v19 = keys;
    uint64_t v20 = 0;
LABEL_39:
    MovieInformationGetBasicMetrics(v18, v19, v20, 0, 0);
    CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberType v22 = kCFNumberFloat32Type;
LABEL_40:
    CFDictionaryRef AlternateGroupArray = CFNumberCreate(v21, v22, keys);
    goto LABEL_19;
  }
  if (CFEqual(a2, @"PreferredVolume"))
  {
    LODWORD(keys[0]) = 1065353216;
    uint64_t v18 = *(void *)(DerivedStorage + 8);
    uint64_t v20 = keys;
    uint64_t v19 = 0;
    goto LABEL_39;
  }
  if (CFEqual(a2, @"Timescale"))
  {
    LODWORD(keys[0]) = 0;
    MovieInformationGetBasicMetrics(*(void *)(DerivedStorage + 8), 0, 0, keys, 0);
LABEL_43:
    CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberType v22 = kCFNumberSInt32Type;
    goto LABEL_40;
  }
  if (CFEqual(a2, @"MovieMatrix"))
  {
    int v40 = 0;
    *(_OWORD *)keys = 0u;
    long long v39 = 0u;
    MovieInformationGetBasicMetrics(*(void *)(DerivedStorage + 8), 0, 0, 0, (uint64_t)keys);
    CFDictionaryRef AlternateGroupArray = FigMatrixToCFArray(a3, (uint64_t)keys);
    goto LABEL_19;
  }
  if (CFEqual(a2, @"iTunesGaplessInfo"))
  {
    CFDictionaryRef AlternateGroupArray = CreateiTunesGaplessInfoDictionaryEnhanced(DerivedStorage);
    goto LABEL_19;
  }
  if (CFEqual(a2, @"iTunesSoundCheckVolumeNormalization"))
  {
    keys[0] = (void *)CopySoundCheckInfoDictionary_0(DerivedStorage);
    if (keys[0])
    {
      LODWORD(context.value) = 0;
      LODWORD(time1.value) = 4;
      if (AudioFormatGetProperty(0x73636462u, 8u, keys, (UInt32 *)&time1, &context))
      {
        CFRelease(keys[0]);
        goto LABEL_52;
      }
      uint64_t v23 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, &context);
      CFRelease(keys[0]);
      if (!v23) {
        goto LABEL_52;
      }
LABEL_56:
      uint64_t v10 = 0;
      *a4 = v23;
      goto LABEL_11;
    }
LABEL_52:
    uint64_t v10 = 4294954512;
    goto LABEL_11;
  }
  if (CFEqual(a2, @"SoundCheckInfo"))
  {
    CFDictionaryRef AlternateGroupArray = (const __CFDictionary *)CopySoundCheckInfoDictionary_0(DerivedStorage);
    goto LABEL_19;
  }
  if (!CFEqual(a2, @"iTunesStoreItemKind"))
  {
    if (CFEqual(a2, @"QuickTimeUserDataReader"))
    {
      AssureQuickTimeUserDataReaderCreated((uint64_t *)DerivedStorage);
      uint64_t v13 = *(const void **)(DerivedStorage + 88);
      if (v13) {
        goto LABEL_18;
      }
LABEL_74:
      uint64_t v10 = 4294954513;
      goto LABEL_11;
    }
    if (CFEqual(a2, @"QuickTimeMetadataReader"))
    {
      AssureQuickTimeMetadataReaderCreated((uint64_t *)DerivedStorage);
      uint64_t v13 = *(const void **)(DerivedStorage + 96);
      if (v13) {
        goto LABEL_18;
      }
      goto LABEL_74;
    }
    if (CFEqual(a2, @"ISOUserDataReader"))
    {
      AssureISOUserDataReaderCreated((uint64_t *)DerivedStorage);
      uint64_t v13 = *(const void **)(DerivedStorage + 104);
      if (v13) {
        goto LABEL_18;
      }
      goto LABEL_74;
    }
    if (CFEqual(a2, @"iTunesMetadataReader"))
    {
      AssureiTunesMetadataReaderCreated((uint64_t *)DerivedStorage);
      uint64_t v13 = *(const void **)(DerivedStorage + 112);
      if (v13) {
        goto LABEL_18;
      }
      goto LABEL_74;
    }
    if (CFEqual(a2, @"MetadataReaders"))
    {
      AssureQuickTimeUserDataReaderCreated((uint64_t *)DerivedStorage);
      AssureQuickTimeMetadataReaderCreated((uint64_t *)DerivedStorage);
      AssureISOUserDataReaderCreated((uint64_t *)DerivedStorage);
      AssureiTunesMetadataReaderCreated((uint64_t *)DerivedStorage);
      if (!*(void *)(DerivedStorage + 88)
        && !*(void *)(DerivedStorage + 104)
        && !*(void *)(DerivedStorage + 96)
        && !*(void *)(DerivedStorage + 112))
      {
        goto LABEL_10;
      }
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
      if (Mutable)
      {
        uint64_t v23 = Mutable;
        CFStringRef v27 = *(const void **)(DerivedStorage + 96);
        if (v27) {
          CFArrayAppendValue(Mutable, v27);
        }
        uint64_t v28 = *(const void **)(DerivedStorage + 112);
        if (v28) {
          CFArrayAppendValue(v23, v28);
        }
        v29 = *(const void **)(DerivedStorage + 88);
        if (v29) {
          CFArrayAppendValue(v23, v29);
        }
        uint64_t v30 = *(const void **)(DerivedStorage + 104);
        if (v30) {
          CFArrayAppendValue(v23, v30);
        }
        goto LABEL_56;
      }
      goto LABEL_101;
    }
    if (CFEqual(a2, @"MetadataReaderTypes"))
    {
      CFMutableArrayRef v31 = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
      if (v31)
      {
        uint64_t v23 = v31;
        if (MovieInformationMetadataFormatIsAvailable(*(void **)(DerivedStorage + 8), @"com.apple.itunes"))CFArrayAppendValue(v23, @"iTunesMetadataReader"); {
        if (MovieInformationMetadataFormatIsAvailable(*(void **)(DerivedStorage + 8), @"com.apple.quicktime.mdta"))CFArrayAppendValue(v23, @"QuickTimeMetadataReader");
        }
        if (MovieInformationMetadataFormatIsAvailable(*(void **)(DerivedStorage + 8), @"com.apple.quicktime.udta"))CFArrayAppendValue(v23, @"QuickTimeUserDataReader"); {
        if (MovieInformationMetadataFormatIsAvailable(*(void **)(DerivedStorage + 8), @"org.mp4ra"))CFArrayAppendValue(v23, @"ISOUserDataReader");
        }
        if (CFArrayGetCount(v23) < 1)
        {
          uint64_t v16 = v23;
LABEL_25:
          CFRelease(v16);
          goto LABEL_10;
        }
        goto LABEL_56;
      }
LABEL_101:
      uint64_t TrackReferenceDictionary = FigSignalErrorAt();
      goto LABEL_102;
    }
    if (CFEqual(a2, @"CreationDate"))
    {
      uint64_t TrackReferenceDictionary = CopyCreationDate(a3, (uint64_t *)DerivedStorage, a4);
      goto LABEL_102;
    }
    if (CFEqual(a2, @"HasCompressedMovieAtom"))
    {
      int HasCompressedMovieAtom = MovieInformationHasCompressedMovieAtom(*(void *)(DerivedStorage + 8));
      goto LABEL_107;
    }
    if (CFEqual(a2, @"CouldContainFragments"))
    {
      if (!MovieInformationCouldContainFragments(*(void *)(DerivedStorage + 8))) {
        goto LABEL_117;
      }
    }
    else
    {
      if (!CFEqual(a2, @"ContainsFragments"))
      {
        if (CFEqual(a2, @"MovieExtendsDuration"))
        {
          keys[1] = 0;
          *(void *)&long long v39 = 0;
          keys[0] = 0;
          MovieInformationGetMovieExtendsDuration(*(__n128 **)(DerivedStorage + 8), (uint64_t)keys);
          goto LABEL_8;
        }
        if (CFEqual(a2, @"CanMutate"))
        {
          int HasCompressedMovieAtom = MovieInformationIsMutable(*(void *)(DerivedStorage + 8));
        }
        else if (CFEqual(a2, @"IsSelfContained"))
        {
          int HasCompressedMovieAtom = MovieInformationAllTracksAreSelfContained(*(void *)(DerivedStorage + 8));
        }
        else
        {
          if (!CFEqual(a2, @"ContainsChapters"))
          {
            if (CFEqual(a2, @"PictureCollection"))
            {
              uint64_t TrackReferenceDictionary = CopyPictureCollection((uint64_t)a3, DerivedStorage, a4);
              goto LABEL_102;
            }
            if (CFEqual(a2, @"FirstFragmentSequenceNumber"))
            {
              LODWORD(keys[0]) = 0;
              if (MovieInformationGetFirstFragmentSequenceNumber(*(void *)(DerivedStorage + 8), keys)) {
                goto LABEL_43;
              }
            }
            else
            {
              if (!CFEqual(a2, @"FragmentCount"))
              {
                if (!CFEqual(a2, @"IsAssetAnalysisActive"))
                {
                  if (CFEqual(a2, @"AssetAnalysisMessages"))
                  {
                    if (MovieInformationGetAssetAnalysisReporter(*(void *)(DerivedStorage + 8))) {
                      FigAssetAnalysisReporterCopyMessages();
                    }
                    goto LABEL_10;
                  }
                  goto LABEL_52;
                }
                uint64_t AssetAnalysisReporter = MovieInformationGetAssetAnalysisReporter(*(void *)(DerivedStorage + 8));
                BOOL v12 = (const void **)MEMORY[0x1E4F1CFD0];
                uint64_t v33 = (const void **)MEMORY[0x1E4F1CFC8];
                BOOL v34 = AssetAnalysisReporter == 0;
LABEL_108:
                if (v34) {
                  BOOL v12 = v33;
                }
                goto LABEL_17;
              }
              LODWORD(keys[0]) = 0;
              if (MovieInformationGetParsedFragmentCount(*(_DWORD **)(DerivedStorage + 8), keys)) {
                goto LABEL_43;
              }
            }
            CFDictionaryRef AlternateGroupArray = 0;
            goto LABEL_19;
          }
          int HasCompressedMovieAtom = MovieInformationContainsChapters(*(void *)(DerivedStorage + 8));
        }
LABEL_107:
        BOOL v12 = (const void **)MEMORY[0x1E4F1CFD0];
        uint64_t v33 = (const void **)MEMORY[0x1E4F1CFC8];
        BOOL v34 = HasCompressedMovieAtom == 0;
        goto LABEL_108;
      }
      if (!MovieInformationContainsFragments(*(void *)(DerivedStorage + 8)))
      {
LABEL_117:
        BOOL v12 = (const void **)MEMORY[0x1E4F1CFC8];
        goto LABEL_17;
      }
    }
    if (!*(unsigned char *)(*(void *)(DerivedStorage + 8) + 90)) {
      goto LABEL_16;
    }
    goto LABEL_117;
  }
  keys[0] = 0;
  uint64_t v10 = CopyiTunesStoreItemKindValue((uint64_t)a3, (uint64_t *)DerivedStorage, keys);
  CFDictionaryRef AlternateGroupArray = (const __CFDictionary *)keys[0];
  if (!v10)
  {
    if (keys[0])
    {
      CFTypeID v24 = CFGetTypeID(keys[0]);
      CFTypeID TypeID = CFNumberGetTypeID();
      CFDictionaryRef AlternateGroupArray = (const __CFDictionary *)keys[0];
      if (v24 == TypeID) {
        goto LABEL_20;
      }
    }
  }
  if (AlternateGroupArray) {
    CFRelease(AlternateGroupArray);
  }
LABEL_11:
  MovieInformationUnlockForRead(*(void *)(DerivedStorage + 8));
  return v10;
}

uint64_t GetLyricsFromMovieMetadata(uint64_t a1, uint64_t *a2, void *a3)
{
  *a3 = 0;
  AssureiTunesMetadataReaderCreated(a2);
  uint64_t v6 = a2[14];
  if (!v6) {
    return 0;
  }
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, void, uint64_t, void *, void))(v8 + 8);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, @"itsk", @"@lyr", 0, a1, a3, 0);
}

CFMutableDictionaryRef CreateiTunesGaplessInfoDictionaryEnhanced(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 32))
  {
    if (!*(unsigned char *)(a1 + 33)) {
      return 0;
    }
  }
  else
  {
    AssureiTunesMetadataReaderCreated((uint64_t *)a1);
    int v2 = FigGaplessInfoFetchiTunesParametersFromMetadataReader(*(void *)(a1 + 112), a1 + 40);
    *(unsigned char *)(a1 + 33) = v2;
    *(unsigned char *)(a1 + 32) = 1;
    if (!v2) {
      return 0;
    }
  }
  uint64_t v3 = *(void *)(a1 + 8);
  CMTime v16 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  uint64_t NthTrackOfType = MovieInformationFindNthTrackOfType(v3, 0, 1936684398);
  if (!NthTrackOfType) {
    return 0;
  }
  uint64_t v5 = NthTrackOfType;
  CFArrayRef v6 = MovieTrackCopyFormatDescriptionArray(NthTrackOfType);
  if (!v6) {
    return 0;
  }
  CFArrayRef v7 = v6;
  if (CFArrayGetCount(v6) >= 1 && (CFDictionaryRef ValueAtIndex = (const AudioFormatListItem *)CFArrayGetValueAtIndex(v7, 0)) != 0)
  {
    CFDictionaryRef v9 = ValueAtIndex;
    MovieTrackGetMediaDuration(v5, (uint64_t)&v16);
    int v10 = *(_DWORD *)(a1 + 40);
    int v11 = *(_DWORD *)(a1 + 44);
    int64_t v12 = *(void *)(a1 + 48);
    CMTime v15 = v16;
    CFMutableDictionaryRef v13 = FigGaplessInfoCreateEnhanced_CorrectingWithUneditedDuration(v9, &v15, v10, v11, v12);
  }
  else
  {
    CFMutableDictionaryRef v13 = 0;
  }
  CFRelease(v7);
  return v13;
}

CFTypeRef CopySoundCheckInfoDictionary_0(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  MEMORY[0x19970E910](*(void *)(a1 + 72));
  if (*(unsigned char *)(a1 + 56)) {
    goto LABEL_2;
  }
  *(unsigned char *)(a1 + 56) = 1;
  AssureiTunesMetadataReaderCreated((uint64_t *)a1);
  uint64_t v3 = *(void *)(a1 + 112);
  if (!v3) {
    goto LABEL_2;
  }
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  uint64_t v5 = v4 ? v4 : 0;
  CFArrayRef v6 = *(unsigned int (**)(uint64_t, __CFString *, __CFString *, void))(v5 + 8);
  if (!v6) {
    goto LABEL_2;
  }
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v6(v3, @"itlk", @"com.apple.iTunes.iTunNORM", 0) || cf == 0) {
    goto LABEL_2;
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(cf))
  {
    CFStringRef v9 = (const __CFString *)CFRetain(cf);
  }
  else
  {
    CFTypeID v10 = CFDataGetTypeID();
    if (v10 != CFGetTypeID(cf))
    {
LABEL_2:
      MEMORY[0x19970E930](*(void *)(a1 + 72));
      goto LABEL_3;
    }
    BytePtr = CFDataGetBytePtr((CFDataRef)cf);
    CFIndex Length = CFDataGetLength((CFDataRef)cf);
    CFStringRef v9 = CFStringCreateWithBytes(alloc, BytePtr, Length, 0x8000100u, 0);
  }
  CFStringRef v13 = v9;
  if (!v9) {
    goto LABEL_2;
  }
  unint64_t v14 = CFStringGetLength(v9);
  if ((uint64_t)v14 >= 45
    && (unsigned int v15 = (v14 / 9) / 5, v28 = v14 / 9, 5 * v15 == (v14 / 9))
    && (CFIndex v16 = v14 + 1, (v17 = (char *)malloc_type_malloc(v14 + 1, 0xF14B7FE2uLL)) != 0))
  {
    uint64_t v18 = v17;
    if (CFStringGetCString(v13, v17, v16, 0))
    {
      CFStringRef v26 = v13;
      uint64_t v19 = 0;
      keys[0] = xmmword_1E57A16E8;
      keys[1] = *(_OWORD *)off_1E57A16F8;
      float v37 = @"sc peak amplitude msec";
      uint64_t v35 = 0;
      if (v15 <= 1) {
        int v20 = 1;
      }
      else {
        int v20 = v15;
      }
      int v27 = v20;
      *(_OWORD *)values = 0u;
      long long v34 = 0u;
      uint64_t v25 = v18;
      do
      {
        int v30 = 0;
        if (v28 >= 5)
        {
          CFAllocatorRef v21 = cStr;
          int v22 = v27;
          do
          {
            sscanf(v18, "%X", &v30);
            v18 += 9;
            snprintf(v21, (char *)values - v21, "%u%s", v30, " ");
            v21 += strlen(v21);
            --v22;
          }
          while (v22);
        }
        values[v19++] = (void *)CFStringCreateWithCString(alloc, cStr, 0);
      }
      while (v19 != 5);
      uint64_t v23 = 0;
      *(void *)(a1 + 64) = CFDictionaryCreate(alloc, (const void **)keys, (const void **)values, 5, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      uint64_t v18 = v25;
      do
      {
        CFTypeID v24 = values[v23];
        if (v24) {
          CFRelease(v24);
        }
        ++v23;
      }
      while (v23 != 5);
      CFStringRef v13 = v26;
    }
    free(v18);
  }
  else
  {
    FigSignalErrorAt();
  }
  MEMORY[0x19970E930](*(void *)(a1 + 72));
  CFRelease(v13);
LABEL_3:
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 64);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t CopyiTunesStoreItemKindValue(uint64_t a1, uint64_t *a2, void *a3)
{
  *a3 = 0;
  AssureiTunesMetadataReaderCreated(a2);
  uint64_t v6 = a2[14];
  if (!v6) {
    return 0;
  }
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  CFTypeID v10 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, void, uint64_t, void *, void))(v8 + 8);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, @"itsk", @"stik", 0, a1, a3, 0);
}

void AssureQuickTimeUserDataReaderCreated(uint64_t *a1)
{
  MEMORY[0x19970E910](a1[10]);
  if (!a1[11])
  {
    MovieInformationLockForRead(a1[1]);
    MovieInformationCreateQuickTimeUserDataReader((void *)a1[1], a1 + 11);
    MovieInformationUnlockForRead(a1[1]);
  }

  JUMPOUT(0x19970E930);
}

void AssureQuickTimeMetadataReaderCreated(uint64_t *a1)
{
  MEMORY[0x19970E910](a1[10]);
  if (!a1[12])
  {
    MovieInformationLockForRead(a1[1]);
    MovieInformationCreateQuickTimeMetadataReader((void *)a1[1], a1 + 12);
    MovieInformationUnlockForRead(a1[1]);
  }

  JUMPOUT(0x19970E930);
}

void AssureISOUserDataReaderCreated(uint64_t *a1)
{
  MEMORY[0x19970E910](a1[10]);
  if (!a1[13])
  {
    MovieInformationLockForRead(a1[1]);
    MovieInformationCreateISOUserDataReader((void *)a1[1], a1 + 13);
    MovieInformationUnlockForRead(a1[1]);
  }

  JUMPOUT(0x19970E930);
}

void AssureiTunesMetadataReaderCreated(uint64_t *a1)
{
  MEMORY[0x19970E910](a1[10]);
  if (!a1[14])
  {
    MovieInformationLockForRead(a1[1]);
    MovieInformationCreateiTunesMetadataReader((void *)a1[1], a1 + 14);
    MovieInformationUnlockForRead(a1[1]);
  }

  JUMPOUT(0x19970E930);
}

uint64_t CopyCreationDate(const __CFAllocator *a1, uint64_t *a2, void *a3)
{
  CFTypeRef v37 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v36 = 0;
  AssureQuickTimeMetadataReaderCreated(a2);
  uint64_t v6 = a2[12];
  if (!v6) {
    goto LABEL_22;
  }
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  CFStringRef v9 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, void, const __CFAllocator *, CFTypeRef *, CFTypeRef *))(v8 + 8);
  if (!v9)
  {
    uint64_t v13 = 0;
    goto LABEL_19;
  }
  int v10 = v9(v6, @"comn", @"creationDate", 0, a1, &cf, &v37);
  CFTypeRef v11 = cf;
  if (v10) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = cf == 0;
  }
  if (!v12)
  {
    uint64_t result = CopyCreationDateAsDictionary(a1, cf, (const __CFDictionary *)v37, (__CFDictionary **)&v36);
    if (result) {
      return result;
    }
    if (v37) {
      CFDictionaryGetValue((CFDictionaryRef)v37, @"locale");
    }
    uint64_t v13 = FigCFDateCreateFromString();
    CFTypeRef v11 = cf;
    if (!cf) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  uint64_t v13 = 0;
  if (cf)
  {
LABEL_18:
    CFRelease(v11);
    CFTypeRef cf = 0;
  }
LABEL_19:
  if (v37)
  {
    CFRelease(v37);
    CFTypeRef v37 = 0;
  }
  if (v13) {
    goto LABEL_89;
  }
LABEL_22:
  AssureiTunesMetadataReaderCreated(a2);
  uint64_t v15 = a2[14];
  if (!v15) {
    goto LABEL_45;
  }
  uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v16) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v18 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, void, const __CFAllocator *, CFTypeRef *, CFTypeRef *))(v17 + 8);
  if (!v18)
  {
    uint64_t v13 = 0;
    goto LABEL_40;
  }
  int v19 = v18(v15, @"comn", @"creationDate", 0, a1, &cf, &v37);
  CFTypeRef v20 = cf;
  if (v19) {
    BOOL v21 = 1;
  }
  else {
    BOOL v21 = cf == 0;
  }
  if (!v21)
  {
    if (!v36)
    {
      uint64_t result = CopyCreationDateAsDictionary(a1, cf, (const __CFDictionary *)v37, (__CFDictionary **)&v36);
      if (result) {
        return result;
      }
    }
    if (v37) {
      CFDictionaryGetValue((CFDictionaryRef)v37, @"locale");
    }
    uint64_t v13 = FigCFDateCreateFromString();
LABEL_40:
    CFTypeRef v20 = cf;
    if (!cf) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  uint64_t v13 = 0;
  if (cf)
  {
LABEL_41:
    CFRelease(v20);
    CFTypeRef cf = 0;
  }
LABEL_42:
  if (v37)
  {
    CFRelease(v37);
    CFTypeRef v37 = 0;
  }
  if (v13) {
    goto LABEL_89;
  }
LABEL_45:
  AssureQuickTimeUserDataReaderCreated(a2);
  uint64_t v22 = a2[11];
  if (v22)
  {
    uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v23) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = 0;
    }
    uint64_t v25 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, void, const __CFAllocator *, CFTypeRef *, CFTypeRef *))(v24 + 8);
    if (v25)
    {
      int v26 = v25(v22, @"comn", @"creationDate", 0, a1, &cf, &v37);
      CFTypeRef v27 = cf;
      if (v26) {
        BOOL v28 = 1;
      }
      else {
        BOOL v28 = cf == 0;
      }
      if (v28)
      {
        uint64_t v13 = 0;
        goto LABEL_63;
      }
      if (!v36)
      {
        uint64_t result = CopyCreationDateAsDictionary(a1, cf, (const __CFDictionary *)v37, (__CFDictionary **)&v36);
        if (result) {
          return result;
        }
      }
      if (v37) {
        CFDictionaryGetValue((CFDictionaryRef)v37, @"locale");
      }
      uint64_t v13 = FigCFDateCreateFromString();
    }
    else
    {
      uint64_t v13 = 0;
    }
    CFTypeRef v27 = cf;
LABEL_63:
    if (v27)
    {
      CFRelease(v27);
      CFTypeRef cf = 0;
    }
    if (v37)
    {
      CFRelease(v37);
      CFTypeRef v37 = 0;
    }
    if (v13) {
      goto LABEL_89;
    }
  }
  AssureISOUserDataReaderCreated(a2);
  uint64_t v29 = a2[13];
  if (!v29) {
    goto LABEL_87;
  }
  uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v30) {
    uint64_t v31 = v30;
  }
  else {
    uint64_t v31 = 0;
  }
  uint64_t v32 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, void, const __CFAllocator *, CFTypeRef *, CFTypeRef *))(v31 + 8);
  if (!v32)
  {
    uint64_t v13 = 0;
LABEL_81:
    CFTypeRef v34 = cf;
    goto LABEL_82;
  }
  int v33 = v32(v29, @"comn", @"creationDate", 0, a1, &cf, &v37);
  uint64_t v13 = 0;
  CFTypeRef v34 = cf;
  if (v33 || !cf)
  {
LABEL_82:
    if (v34)
    {
      CFRelease(v34);
      CFTypeRef cf = 0;
    }
    if (v37)
    {
      CFRelease(v37);
      CFTypeRef v37 = 0;
    }
    if (!v13)
    {
LABEL_87:
      unint64_t v35 = 0;
      MovieInformationLockForRead(a2[1]);
      MovieInformationGetTimeInfo(a2[1], &v35, 0);
      MovieInformationUnlockForRead(a2[1]);
      if (!v35 || (uint64_t v13 = (uint64_t)CFDateCreate(a1, (double)v35 - *MEMORY[0x1E4F1CF68])) == 0)
      {
        uint64_t result = 0;
        *a3 = v36;
        return result;
      }
    }
LABEL_89:
    *a3 = v13;
    uint64_t result = (uint64_t)v36;
    if (v36)
    {
      CFRelease(v36);
      return 0;
    }
    return result;
  }
  if (v36
    || (uint64_t result = CopyCreationDateAsDictionary(a1, cf, (const __CFDictionary *)v37, (__CFDictionary **)&v36),
        !result))
  {
    if (v37) {
      CFDictionaryGetValue((CFDictionaryRef)v37, @"locale");
    }
    uint64_t v13 = FigCFDateCreateFromString();
    goto LABEL_81;
  }
  return result;
}

uint64_t CopyPictureCollection(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v8 = 0;
  CFTypeRef cf = 0;
  uint64_t v5 = MovieInformationCopyIFFItemInformation(*(void *)(a2 + 8), &cf);
  if (v5)
  {
    uint64_t v6 = v5;
  }
  else
  {
    if (!cf) {
      return 0;
    }
    uint64_t v6 = FigPictureCollectionCreateFromIFFItemInformation(a1, cf, &v8);
    if (!v6)
    {
      *a3 = v8;
      uint64_t v8 = 0;
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

double FindMaximumEditedTrackDuration(uint64_t a1, const void *a2, CMTime *a3)
{
  memset(&v7, 0, sizeof(v7));
  GetTrackEditedDuration(a2, &v7);
  CMTime time1 = v7;
  CMTime v5 = *a3;
  if (CMTimeCompare(&time1, &v5) >= 1)
  {
    double result = *(double *)&v7.value;
    *a3 = v7;
  }
  return result;
}

void GetTrackEditedDuration(const void *a1@<X0>, CMTime *a2@<X8>)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = *(void *)(DerivedStorage + 8);
  uint64_t v6 = (_OWORD *)MEMORY[0x1E4F1F9F8];
  uint64_t v29 = 0;
  a2->CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  *(_OWORD *)&a2->CMTimeValue value = *v6;
  if (*(unsigned char *)(v5 + 723))
  {
    if (*(unsigned char *)(v5 + 201))
    {
      uint64_t v7 = MEMORY[0x1E4F1F9F0];
      *(_OWORD *)&a2->CMTimeValue value = *MEMORY[0x1E4F1F9F0];
      a2->CMTimeEpoch epoch = *(void *)(v7 + 16);
    }
    else
    {
      uint64_t v19 = DerivedStorage;
      TrackDurationCFArrayRef Value = MovieTrackGetTrackDurationValue(v5);
      int32_t v21 = *(_DWORD *)(*(void *)v19 + 240);
      CMTimeMake(a2, TrackDurationValue, v21);
    }
  }
  else
  {
    long long v27 = 0uLL;
    CMTimeEpoch v28 = 0;
    MovieTrackGetMediaDuration(v5, (uint64_t)&v27);
    int v26 = 0;
    MovieTrackReaderCreateEditCursorService(a1, *MEMORY[0x1E4F1CF80], &v26);
    memset(&v25, 0, sizeof(v25));
    GetGaplessSourceTimeRange(&v25);
    uint64_t v8 = v26;
    *(_OWORD *)&range.start.CMTimeValue value = v27;
    range.start.CMTimeEpoch epoch = v28;
    CMTimeRange v24 = v25;
    FigGaplessInfoCreateSegmentDataForTrack((uint64_t)v26, &range.start, (long long *)&v24.start.value, &v29);
    if (v8) {
      CFRelease(v8);
    }
    if (v29 && (CFTypeID v9 = CFGetTypeID(v29), v9 == CFDataGetTypeID()))
    {
      uint64_t v10 = MEMORY[0x1E4F1FA48];
      *(_OWORD *)&a2->CMTimeValue value = *MEMORY[0x1E4F1FA48];
      a2->CMTimeEpoch epoch = *(void *)(v10 + 16);
      unint64_t Length = CFDataGetLength(v29);
      if (Length >= 0x60)
      {
        unint64_t v12 = Length;
        BytePtr = CFDataGetBytePtr(v29);
        long long v14 = *((_OWORD *)BytePtr + 4);
        *(_OWORD *)&v24.start.CMTimeValue value = *((_OWORD *)BytePtr + 3);
        *(_OWORD *)&v24.start.CMTimeEpoch epoch = v14;
        *(_OWORD *)&v24.duration.CMTimeScale timescale = *((_OWORD *)BytePtr + 5);
        if (v12 >= 0xC0)
        {
          uint64_t v15 = &BytePtr[96 * (v12 / 0x60)];
          long long v16 = *((_OWORD *)BytePtr + 4);
          *(_OWORD *)&range.start.CMTimeValue value = *((_OWORD *)BytePtr + 3);
          *(_OWORD *)&range.start.CMTimeEpoch epoch = v16;
          *(_OWORD *)&range.duration.CMTimeScale timescale = *((_OWORD *)BytePtr + 5);
          long long v17 = *((_OWORD *)v15 - 3);
          long long v18 = *((_OWORD *)v15 - 1);
          *(_OWORD *)&v22.start.CMTimeEpoch epoch = *((_OWORD *)v15 - 2);
          *(_OWORD *)&v22.duration.CMTimeScale timescale = v18;
          *(_OWORD *)&v22.start.CMTimeValue value = v17;
          CMTimeRangeGetUnion(&v24, &range, &v22);
        }
        *a2 = v24.duration;
      }
    }
    else
    {
      MovieTrackGetMediaDuration(v5, (uint64_t)a2);
    }
    if (v29) {
      CFRelease(v29);
    }
  }
}

uint64_t MovieTrackReaderCreateEditCursorService(const void *a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = *(const void **)DerivedStorage;
  uint64_t v6 = *(const void **)(DerivedStorage + 8);
  if (MovieTrackIsValid((uint64_t)v6))
  {
    FigEditCursorServiceGetClassID();
    uint64_t v8 = CMDerivedObjectCreate();
    if (!v8)
    {
      uint64_t v9 = CMBaseObjectGetDerivedStorage();
      if (v7) {
        uint64_t v10 = CFRetain(v7);
      }
      else {
        uint64_t v10 = 0;
      }
      *(void *)uint64_t v9 = v10;
      if (v6)
      {
        CFTypeRef v11 = CFRetain(v6);
        uint64_t v10 = *(unsigned char **)v9;
      }
      else
      {
        CFTypeRef v11 = 0;
      }
      *(void *)(v9 + 8) = v11;
      if (v10[89])
      {
        if (a1) {
          CFTypeRef v12 = CFRetain(a1);
        }
        else {
          CFTypeRef v12 = 0;
        }
        *(void *)(v9 + 16) = v12;
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterAddWeakListener();
        *(unsigned char *)(v9 + 24) = 1;
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterAddWeakListener();
        *(unsigned char *)(v9 + 25) = 1;
      }
      uint64_t v8 = 0;
      *a3 = 0;
    }
    return v8;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void GetGaplessSourceTimeRange(_OWORD *a1@<X8>)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = MEMORY[0x1E4F1FA20];
  long long v4 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  *a1 = *MEMORY[0x1E4F1FA20];
  a1[1] = v4;
  a1[2] = *(_OWORD *)(v3 + 32);
  CFTypeRef cf = 0;
  uint64_t v5 = *(void *)(DerivedStorage + 8);
  if (*(_DWORD *)(v5 + 24) == 1936684398)
  {
    CFArrayRef v6 = MovieTrackCopyFormatDescriptionArray(v5);
    if (v6)
    {
      CFArrayRef v7 = v6;
      if (CFArrayGetCount(v6) >= 1)
      {
        CFDictionaryRef ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(v7, 0);
        MovieTrackCopyEnhancedGaplessInfo(*(void *)(DerivedStorage + 8), &cf);
        FigGaplessInfoGetGaplessSourceTimeRange(ValueAtIndex, (__CFDictionary *)cf, a1);
      }
      CFRelease(v7);
      if (cf) {
        CFRelease(cf);
      }
    }
  }
}

uint64_t MovieEditCursorServiceEditsChanged()
{
  CMNotificationCenterGetDefaultLocalCenter();

  return CMNotificationCenterPostNotification();
}

uint64_t MovieEditCursorServiceTimeRangesMayNoLongerIncrease()
{
  CMNotificationCenterGetDefaultLocalCenter();

  return CMNotificationCenterPostNotification();
}

void MovieEditCursorServiceFinalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    *(unsigned char *)(DerivedStorage + 24) = 0;
  }
  if (*(unsigned char *)(DerivedStorage + 25))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    *(unsigned char *)(DerivedStorage + 25) = 0;
  }
  CFStringRef v1 = *(const void **)(DerivedStorage + 16);
  if (v1)
  {
    CFRelease(v1);
    *(void *)(DerivedStorage + 16) = 0;
  }
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  int v2 = *(const void **)(DerivedStorage + 8);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(DerivedStorage + 8) = 0;
  }
}

__CFString *MovieEditCursorServiceCopyDebugDescription(const void *a1)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  uint64_t v5 = *DerivedStorage;
  if (*DerivedStorage)
  {
    uint64_t v6 = DerivedStorage[1];
    if (v6)
    {
      unsigned int v9 = 1061109567;
      unsigned int v8 = 0;
      MovieInformationLockForRead(v5);
      MovieTrackGetBasicInfo(v6, &v9, &v8);
      MovieInformationUnlockForRead(*DerivedStorage);
      CFStringAppendFormat(Mutable, 0, @"<MovieEditCursorService: '%c%c%c%c' trackID %d>", HIBYTE(v9), BYTE2(v9), BYTE1(v9), v9, v8);
    }
  }
  return Mutable;
}

uint64_t MovieEditCursorServiceCreateCursorAtTrackTime(const void *a1, CMTime *a2, void *a3)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  if (*DerivedStorage && (CFArrayRef v7 = DerivedStorage, MovieTrackIsValid(DerivedStorage[1])))
  {
    uint64_t v8 = v7[1];
    MovieInformationLockForRead(*v7);
    CMTime v19 = *a2;
    uint64_t EditIndexForTrackTime = MovieTrackFindEditIndexForTrackTime(v8, &v19, &v26);
    if (!EditIndexForTrackTime) {
      uint64_t EditIndexForTrackTime = MovieTrackGetEditSegmentWithIndex(v8, v26, &v20);
    }
    MovieInformationUnlockForRead(*v7);
    if (!EditIndexForTrackTime)
    {
      CFGetAllocator(a1);
      FigEditCursorGetClassID();
      uint64_t v10 = CMDerivedObjectCreate();
      if (v10)
      {
        return v10;
      }
      else
      {
        uint64_t v11 = CMBaseObjectGetDerivedStorage();
        CFTypeRef v12 = (const void *)*v7;
        if (*v7) {
          CFTypeRef v12 = CFRetain(v12);
        }
        *(void *)uint64_t v11 = v12;
        CFTypeRef v13 = (CFTypeRef)v7[1];
        if (v13) {
          CFTypeRef v13 = CFRetain(v13);
        }
        uint64_t EditIndexForTrackTime = 0;
        *(void *)(v11 + 8) = v13;
        *(_DWORD *)(v11 + 16) = v26;
        long long v15 = v24;
        long long v14 = v25;
        long long v16 = v23;
        *(_OWORD *)(v11 + 52) = v22;
        *(_OWORD *)(v11 + 68) = v16;
        *(_OWORD *)(v11 + 84) = v15;
        long long v17 = v21;
        *(_OWORD *)(v11 + 20) = v20;
        *(_OWORD *)(v11 + 100) = v14;
        *(_OWORD *)(v11 + 36) = v17;
        *a3 = v27;
      }
    }
    return EditIndexForTrackTime;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void MovieEditCursorFinalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  CFStringRef v1 = *(const void **)(DerivedStorage + 8);
  if (v1)
  {
    CFRelease(v1);
    *(void *)(DerivedStorage + 8) = 0;
  }
}

__CFString *MovieEditCursorCopyDebugDescription(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  uint64_t v5 = *(void *)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    uint64_t v6 = *(void *)(DerivedStorage + 8);
    if (v6)
    {
      uint64_t v8 = 0;
      MovieInformationLockForRead(v5);
      MovieTrackGetBasicInfo(v6, &v8, (_DWORD *)&v8 + 1);
      MovieInformationUnlockForRead(*(void *)DerivedStorage);
      CFStringAppendFormat(Mutable, 0, @"<MovieEditCursor: %c%c%c%c trackID %d, editIndex %d>", BYTE3(v8), BYTE2(v8), BYTE1(v8), v8, HIDWORD(v8), *(unsigned int *)(DerivedStorage + 16));
    }
  }
  return Mutable;
}

uint64_t MovieEditCursorCopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*DerivedStorage);
  if (!a4)
  {
    uint64_t v10 = FigSignalErrorAt();
    goto LABEL_13;
  }
  *a4 = 0;
  if (CFEqual(a2, @"TimeRangesMayIncrease"))
  {
    CFArrayRef v7 = (const void *)*MEMORY[0x1E4F1CFC8];
    if (*(unsigned char *)(*DerivedStorage + 89) && MovieInformationCouldContainFragments(*DerivedStorage)) {
      CFArrayRef v7 = (const void *)*MEMORY[0x1E4F1CFD0];
    }
    uint64_t v8 = v7;
  }
  else
  {
    if (!CFEqual(a2, @"RepeatsEdits"))
    {
      uint64_t v10 = 4294954512;
      goto LABEL_13;
    }
    if (*(unsigned char *)(DerivedStorage[1] + 723)) {
      unsigned int v9 = (const void **)MEMORY[0x1E4F1CFD0];
    }
    else {
      unsigned int v9 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    uint64_t v8 = *v9;
  }
  uint64_t v10 = 0;
  *a4 = CFRetain(v8);
LABEL_13:
  MovieInformationUnlockForRead(*DerivedStorage);
  return v10;
}

uint64_t MovieEditCursorCopy(const void *a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (MovieTrackIsValid(*(void *)(DerivedStorage + 8)))
  {
    CFGetAllocator(a1);
    FigEditCursorGetClassID();
    uint64_t result = CMDerivedObjectCreate();
    if (!result)
    {
      uint64_t v6 = CMBaseObjectGetDerivedStorage();
      CFTypeRef v7 = *(CFTypeRef *)DerivedStorage;
      if (*(void *)DerivedStorage) {
        CFTypeRef v7 = CFRetain(v7);
      }
      *(void *)uint64_t v6 = v7;
      uint64_t v8 = *(const void **)(DerivedStorage + 8);
      if (v8) {
        CFTypeRef v9 = CFRetain(v8);
      }
      else {
        CFTypeRef v9 = 0;
      }
      uint64_t result = 0;
      *(void *)(v6 + 8) = v9;
      *(_DWORD *)(v6 + 16) = *(_DWORD *)(DerivedStorage + 16);
      long long v10 = *(_OWORD *)(DerivedStorage + 20);
      *(_OWORD *)(v6 + 36) = *(_OWORD *)(DerivedStorage + 36);
      *(_OWORD *)(v6 + 20) = v10;
      long long v11 = *(_OWORD *)(DerivedStorage + 52);
      long long v12 = *(_OWORD *)(DerivedStorage + 68);
      long long v13 = *(_OWORD *)(DerivedStorage + 84);
      *(_OWORD *)(v6 + 100) = *(_OWORD *)(DerivedStorage + 100);
      *(_OWORD *)(v6 + 84) = v13;
      *(_OWORD *)(v6 + 68) = v12;
      *(_OWORD *)(v6 + 52) = v11;
      *a2 = 0;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t MovieEditCursorStep(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(void *)(DerivedStorage + 8);
  MovieInformationLockForRead(*(void *)DerivedStorage);
  unsigned int v5 = ValidateMovieEditCursor();
  if (v5)
  {
    unsigned int EditSegmentWithIndex = v5;
    int v8 = 0;
  }
  else
  {
    EditSegmentCFIndex Count = MovieTrackGetEditSegmentCount(v4);
    int v7 = *(_DWORD *)(DerivedStorage + 16) + a2;
    if (v7 < 0)
    {
      int v7 = 0;
      int v8 = 1;
    }
    else if (EditSegmentCount > v7)
    {
      int v8 = 0;
    }
    else
    {
      int v7 = EditSegmentCount - 1;
      int v8 = 1;
    }
    *(_DWORD *)(DerivedStorage + 16) = v7;
    unsigned int EditSegmentWithIndex = MovieTrackGetEditSegmentWithIndex(*(void *)(DerivedStorage + 8), v7, (_OWORD *)(DerivedStorage + 20));
  }
  MovieInformationUnlockForRead(*(void *)DerivedStorage);
  if (v8) {
    BOOL v10 = EditSegmentWithIndex == 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10) {
    return 4294954776;
  }
  else {
    return EditSegmentWithIndex;
  }
}

uint64_t MovieEditCursorGetEditSegment(uint64_t a1, _OWORD *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*(void *)DerivedStorage);
  uint64_t v4 = ValidateMovieEditCursor();
  if (!v4)
  {
    long long v5 = *(_OWORD *)(DerivedStorage + 36);
    *a2 = *(_OWORD *)(DerivedStorage + 20);
    a2[1] = v5;
    long long v6 = *(_OWORD *)(DerivedStorage + 52);
    long long v7 = *(_OWORD *)(DerivedStorage + 68);
    long long v8 = *(_OWORD *)(DerivedStorage + 100);
    a2[4] = *(_OWORD *)(DerivedStorage + 84);
    a2[5] = v8;
    a2[2] = v6;
    a2[3] = v7;
  }
  MovieInformationUnlockForRead(*(void *)DerivedStorage);
  return v4;
}

uint64_t ValidateMovieEditCursor()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = *(void *)(DerivedStorage + 8);
  memset(v17, 0, sizeof(v17));
  long long v16 = 0u;
  memset(v15, 0, sizeof(v15));
  uint64_t result = MovieInformationIsMutable(*(void *)DerivedStorage);
  if (result)
  {
    if (MovieTrackIsValid(*(void *)(DerivedStorage + 8))
      && (EditSegmentCFIndex Count = MovieTrackGetEditSegmentCount(v1), v4 = *(int *)(DerivedStorage + 16),
                                                                EditSegmentCount > v4))
    {
      uint64_t result = MovieTrackGetEditSegmentWithIndex(*(void *)(DerivedStorage + 8), v4, v15);
      if (!result)
      {
        *(_OWORD *)&time1.CMTimeValue value = v16;
        time1.CMTimeEpoch epoch = *(void *)&v17[0];
        CMTime time2 = *(CMTime *)(DerivedStorage + 68);
        if (CMTimeCompare(&time1, &time2)) {
          return FigSignalErrorAt();
        }
        CMTime time1 = v15[0];
        CMTime time2 = *(CMTime *)(DerivedStorage + 20);
        if (CMTimeCompare(&time1, &time2)) {
          return FigSignalErrorAt();
        }
        if ((v15[0].flags & 0x1D) != 1) {
          return 0;
        }
        CMTime time1 = *(CMTime *)(DerivedStorage + 92);
        CMTime time2 = *(CMTime *)(DerivedStorage + 44);
        if (CMTimeCompare(&time1, &time2))
        {
          int32_t v5 = *(_DWORD *)(DerivedStorage + 92);
          int32_t v6 = *(_DWORD *)(DerivedStorage + 100);
          CMTime time1 = v15[1];
          CMTimeMultiplyByRatio(&v12, &time1, v5, v6);
          int32_t v7 = *(_DWORD *)(DerivedStorage + 44);
          int32_t v8 = *(_DWORD *)(DerivedStorage + 52);
          CMTime time1 = *(CMTime *)((char *)v17 + 8);
          CMTimeMultiplyByRatio(&v11, &time1, v7, v8);
          p_CMTime time1 = &v12;
          p_CMTime time2 = &v11;
        }
        else
        {
          CMTime time1 = v15[1];
          CMTime time2 = *(CMTime *)((char *)v17 + 8);
          p_CMTime time1 = &time1;
          p_CMTime time2 = &time2;
        }
        uint64_t result = CMTimeCompare(p_time1, p_time2);
        if (result) {
          return FigSignalErrorAt();
        }
      }
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t CopyCreationDateAsDictionary(const __CFAllocator *a1, const void *a2, const __CFDictionary *a3, __CFDictionary **a4)
{
  if (a4 && (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) != 0)
  {
    int32_t v8 = Mutable;
    CFDictionaryAddValue(Mutable, @"CreationDate_Value", a2);
    if (a3 && CFDictionaryGetValue(a3, @"locale"))
    {
      CFTypeRef v9 = (const void *)MEMORY[0x199707EB0]();
      if (v9) {
        CFDictionaryAddValue(v8, @"CreationDate_LocaleIdentifier", v9);
      }
    }
    *a4 = v8;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieFormatReaderGetTrackCount(uint64_t a1, uint64_t *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*(void *)(DerivedStorage + 8));
  *a2 = MovieInformationGetTrackCount(*(void *)(DerivedStorage + 8));
  MovieInformationUnlockForRead(*(void *)(DerivedStorage + 8));
  return 0;
}

uint64_t MovieFormatReaderParseAdditionalFragments(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  int v28 = 0;
  uint64_t v5 = MovieInformationLockForWrite(*(void *)(DerivedStorage + 8));
  if (v5) {
    return v5;
  }
  uint64_t v6 = *(void *)(DerivedStorage + 8);
  if (*(unsigned char *)(v6 + 89))
  {
    MovieInformationClearChangeBits((void *)v6, 1);
    uint64_t v27 = DerivedStorage;
    unsigned int v25 = MoovParseIncrementalFragments(*(void *)(DerivedStorage + 8), &v28);
    uint64_t v7 = CMBaseObjectGetDerivedStorage();
    if (MovieInformationGetChangeBits(*(void *)(v7 + 8)))
    {
      CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification();
    }
    uint64_t v26 = a3;
    TrackCFIndex Count = MovieInformationGetTrackCount(*(void *)(v7 + 8));
    if (TrackCount >= 1)
    {
      uint64_t v9 = TrackCount;
      uint64_t v10 = 0;
      CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CMTime v12 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      do
      {
        TrackForTrackIndex = (const void *)MovieInformationFindTrackForTrackIndex(*(void *)(v7 + 8), v10);
        uint64_t AudioQueue = FigAudioQueueTimingShimGetAudioQueue((uint64_t)TrackForTrackIndex);
        if (AudioQueue)
        {
          char v15 = AudioQueue;
          CFTypeRef cf = 0;
          CopyTrackReader(v7, TrackForTrackIndex, &cf);
          CFTypeRef v16 = cf;
          if (cf)
          {
            if ((v15 & 2) != 0)
            {
              CFDictionaryRef v17 = CFDictionaryCreate(v11, (const void **)kFigTrackReaderPayloadKey_FragmentWasAdded, MEMORY[0x1E4F1CFD0], 1, MEMORY[0x1E4F1D530], v12);
              CMNotificationCenterGetDefaultLocalCenter();
              CMNotificationCenterPostNotification();
              if (v17) {
                CFRelease(v17);
              }
            }
            if (v15)
            {
              CMNotificationCenterGetDefaultLocalCenter();
              CMNotificationCenterPostNotification();
            }
            CFRelease(v16);
          }
        }
        ++v10;
      }
      while (v9 != v10);
    }
    if ((v28 & 4) != 0)
    {
      uint64_t DerivedStorage = v27;
      uint64_t v18 = v25;
      if (*(unsigned char *)(*(void *)(v27 + 8) + 90))
      {
        CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterPostNotification();
        CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterPostNotification();
        MEMORY[0x19970E910](*(void *)(v27 + 16));
        CFArrayRef v20 = (const __CFArray *)FigCFDictionaryCopyArrayOfValues();
        MEMORY[0x19970E930](*(void *)(v27 + 16));
        CFIndex Count = CFArrayGetCount(v20);
        if (Count >= 1)
        {
          CFIndex v22 = Count;
          for (CFIndex i = 0; i != v22; ++i)
          {
            CFArrayGetValueAtIndex(v20, i);
            CMNotificationCenterGetDefaultLocalCenter();
            CMNotificationCenterPostNotification();
          }
        }
        if (v20) {
          CFRelease(v20);
        }
      }
    }
    else
    {
      uint64_t DerivedStorage = v27;
      uint64_t v18 = v25;
      if ((v28 & 2) != 0)
      {
        uint64_t v19 = *(void *)(v27 + 8);
        if (!*(unsigned char *)(v19 + 91))
        {
          *(unsigned char *)(v19 + 91) = 1;
          CMNotificationCenterGetDefaultLocalCenter();
          CMNotificationCenterPostNotification();
        }
      }
    }
    if (v26) {
      *uint64_t v26 = v28;
    }
  }
  else
  {
    uint64_t v18 = FigSignalErrorAt();
  }
  MovieInformationUnlockForWrite(*(void **)(DerivedStorage + 8));
  return v18;
}

uint64_t MovieFormatReaderCopyTrackByIndex(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*(void *)(DerivedStorage + 8));
  TrackForTrackIndex = (const void *)MovieInformationFindTrackForTrackIndex(*(void *)(DerivedStorage + 8), a2);
  if (TrackForTrackIndex)
  {
    uint64_t v11 = (uint64_t)TrackForTrackIndex;
    if (!a3 || (uint64_t BasicInfo = CopyTrackReader(DerivedStorage, TrackForTrackIndex, a3), !BasicInfo)) {
      uint64_t BasicInfo = MovieTrackGetBasicInfo(v11, a4, a5);
    }
    uint64_t v13 = BasicInfo;
  }
  else
  {
    uint64_t v13 = 4294954453;
  }
  MovieInformationUnlockForRead(*(void *)(DerivedStorage + 8));
  return v13;
}

uint64_t MovieFormatReaderCopyTrackByID(uint64_t a1, int a2, void *a3, _DWORD *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*(void *)(DerivedStorage + 8));
  TrackForTrackID = (const void *)MovieInformationFindTrackForTrackID(*(void *)(DerivedStorage + 8), a2);
  if (TrackForTrackID)
  {
    uint64_t v9 = (uint64_t)TrackForTrackID;
    if (!a3 || (uint64_t BasicInfo = CopyTrackReader(DerivedStorage, TrackForTrackID, a3), !BasicInfo)) {
      uint64_t BasicInfo = MovieTrackGetBasicInfo(v9, a4, 0);
    }
  }
  else
  {
    uint64_t BasicInfo = FigSignalErrorAt();
  }
  uint64_t v11 = BasicInfo;
  MovieInformationUnlockForRead(*(void *)(DerivedStorage + 8));
  return v11;
}

uint64_t MovieFormatReaderCopyTrackByType(uint64_t a1, uint64_t a2, int a3, void *a4, _DWORD *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*(void *)(DerivedStorage + 8));
  uint64_t NthTrackOfType = (const void *)MovieInformationFindNthTrackOfType(*(void *)(DerivedStorage + 8), a2, a3);
  if (NthTrackOfType)
  {
    uint64_t v11 = (uint64_t)NthTrackOfType;
    if (!a4 || (uint64_t BasicInfo = CopyTrackReader(DerivedStorage, NthTrackOfType, a4), !BasicInfo)) {
      uint64_t BasicInfo = MovieTrackGetBasicInfo(v11, 0, a5);
    }
    uint64_t v13 = BasicInfo;
  }
  else
  {
    uint64_t v13 = 4294954453;
  }
  MovieInformationUnlockForRead(*(void *)(DerivedStorage + 8));
  return v13;
}

uint64_t CreateTrackReaderForMovieTrack(uint64_t a1, const void *a2, const void *a3, void *a4)
{
  FigTrackReaderGetClassID();
  uint64_t v7 = CMDerivedObjectCreate();
  if (v7) {
    return v7;
  }
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  if (a2) {
    CFTypeRef v9 = CFRetain(a2);
  }
  else {
    CFTypeRef v9 = 0;
  }
  void *DerivedStorage = v9;
  if (a3) {
    CFTypeRef v10 = CFRetain(a3);
  }
  else {
    CFTypeRef v10 = 0;
  }
  DerivedStorage[1] = v10;
  uint64_t v11 = FigReentrantMutexCreate();
  DerivedStorage[2] = v11;
  if (!v11) {
    return FigSignalErrorAt();
  }
  uint64_t v12 = FigSimpleMutexCreate();
  DerivedStorage[6] = v12;
  if (!v12) {
    return FigSignalErrorAt();
  }
  uint64_t v13 = 0;
  *a4 = 0;
  return v13;
}

void MovieTrackReaderFinalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 64))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterRemoveListener();
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterBarrier();
  }
  uint64_t v1 = *(const void **)(DerivedStorage + 24);
  if (v1)
  {
    CFRelease(v1);
    *(void *)(DerivedStorage + 24) = 0;
  }
  int v2 = *(const void **)(DerivedStorage + 40);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(DerivedStorage + 40) = 0;
  }
  CFAllocatorRef v3 = *(const void **)(DerivedStorage + 32);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(DerivedStorage + 32) = 0;
  }
  if (*(void *)(DerivedStorage + 16))
  {
    FigSimpleMutexDestroy();
    *(void *)(DerivedStorage + 16) = 0;
  }
  if (*(void *)(DerivedStorage + 48))
  {
    FigSimpleMutexDestroy();
    *(void *)(DerivedStorage + 48) = 0;
  }
  uint64_t v4 = *(const void **)(DerivedStorage + 56);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(DerivedStorage + 56) = 0;
  }
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  uint64_t v5 = *(const void **)(DerivedStorage + 8);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(DerivedStorage + 8) = 0;
  }
}

CFMutableStringRef MovieTrackReaderCopyDebugDescription(const void *a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v3, 0);
  if (*DerivedStorage)
  {
    uint64_t v5 = DerivedStorage[1];
    if (v5)
    {
      unsigned int TrackType = MovieTrackGetTrackType(DerivedStorage[1]);
      uint64_t v33 = 0;
      MovieInformationLockForRead(*DerivedStorage);
      MovieTrackGetMediaDuration(v5, (uint64_t)&time);
      uint64_t timescale = time.timescale;
      CMTimeValue value = time.value;
      uint64_t v34 = *(void *)&time.flags;
      int epoch_high = HIDWORD(time.epoch);
      MovieTrackGetBasicInfo(v5, &v33, (_DWORD *)&v33 + 1);
      CFArrayRef NumFormatDescriptions = MovieTrackGetNumFormatDescriptions(v5);
      int32_t v8 = *(const void **)(*DerivedStorage + 48);
      theString = Mutable;
      if (v8) {
        CFStringRef v24 = CFCopyDescription(v8);
      }
      else {
        CFStringRef v24 = 0;
      }
      uint64_t v9 = HIDWORD(v33);
      uint64_t v23 = BYTE3(v33);
      uint64_t v22 = BYTE2(v33);
      uint64_t v20 = v33;
      uint64_t v21 = BYTE1(v33);
      if (MovieTrackIsValid(v5)) {
        CFTypeRef v10 = "";
      }
      else {
        CFTypeRef v10 = " (Invalidated)";
      }
      uint64_t v11 = *(unsigned int *)(v5 + 288);
      time.CMTimeValue value = value;
      time.uint64_t timescale = timescale;
      *(void *)&time.CMTimeFlags flags = v34;
      HIDWORD(time.epoch) = epoch_high;
      double Seconds = CMTimeGetSeconds(&time);
      uint64_t v13 = "s";
      if (NumFormatDescriptions == 1) {
        uint64_t v13 = "";
      }
      uint64_t v19 = v10;
      CFMutableStringRef Mutable = theString;
      CFStringAppendFormat(theString, 0, @"\tMovieTrackReader: stream<%@> mediaType %c%c%c%c trackType %c%c%c%c trackID %d%s contains %d samples media duration %1.3f seconds (%lld/%d) has %d formatDescription%s", v24, v23, v22, v21, v20, HIBYTE(TrackType), BYTE2(TrackType), BYTE1(TrackType), TrackType, v9, v19, v11, *(void *)&Seconds, value, timescale, NumFormatDescriptions,
        v13);
      uint64_t v14 = *(void *)(v5 + 728);
      if (v14 && *(void *)(v14 + 56))
      {
        uint64_t v15 = *(unsigned int *)(v14 + 8);
        CMTimeMake(&v31, *(void *)v14, *(_DWORD *)(v5 + 232));
        Float64 v16 = CMTimeGetSeconds(&v31);
        CMTimeMake(&lhs, *(void *)(v5 + 224), *(_DWORD *)(v5 + 232));
        CMTimeMake(&rhs, **(void **)(v5 + 728), *(_DWORD *)(v5 + 232));
        CMTimeAdd(&v30, &lhs, &rhs);
        Float64 v17 = CMTimeGetSeconds(&v30);
        CFStringAppendFormat(theString, 0, @"\nFragments supply %d samples or %1.3f seconds (%1.3f total media duration)", v15, *(void *)&v16, *(void *)&v17);
      }
      if (v24) {
        CFRelease(v24);
      }
      MovieInformationUnlockForRead(*DerivedStorage);
    }
  }
  return Mutable;
}

uint64_t MovieTrackReaderCopyProperty(const void *a1, const void *a2, const __CFAllocator *a3, CFDictionaryRef *a4)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage && DerivedStorage[1])
  {
    uint64_t v9 = (uint64_t *)CMBaseObjectGetDerivedStorage();
    CFTypeRef v10 = (void *)*v9;
    uint64_t v11 = v9[1];
    MovieInformationLockForRead(*v9);
    if (!a4 || !MovieTrackIsValid(v11)) {
      goto LABEL_33;
    }
    *a4 = 0;
    if (CFEqual(a2, @"TrackFormatDescriptionArray"))
    {
      CFDictionaryRef value = MovieTrackCopyFormatDescriptionArray(v11);
LABEL_19:
      uint64_t MustBeShown = 0;
LABEL_20:
      *a4 = value;
LABEL_21:
      MovieInformationUnlockForRead((uint64_t)v10);
      return MustBeShown;
    }
    if (CFEqual(a2, @"TrackTimescale"))
    {
      int MediaTimeScale = MovieTrackGetMediaTimeScale(v11);
LABEL_12:
      LODWORD(valuePtr.start.value) = MediaTimeScale;
      CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFNumberType v16 = kCFNumberSInt32Type;
LABEL_13:
      CFDictionaryRef value = CFNumberCreate(v15, v16, &valuePtr);
      goto LABEL_19;
    }
    if (CFEqual(a2, @"TrackDuration"))
    {
      memset(&valuePtr, 0, 24);
      GetTrackEditedDuration(a1, &valuePtr.start);
LABEL_18:
      *(_OWORD *)&time.start.CFDictionaryRef value = *(_OWORD *)&valuePtr.start.value;
      time.start.CMTimeEpoch epoch = valuePtr.start.epoch;
      CFDictionaryRef value = CMTimeCopyAsDictionary(&time.start, a3);
      goto LABEL_19;
    }
    if (CFEqual(a2, @"UneditedTrackDuration"))
    {
      memset(&valuePtr, 0, 24);
      MovieTrackGetMediaDuration(v11, (uint64_t)&valuePtr);
      goto LABEL_18;
    }
    if (CFEqual(a2, @"UneditedNumDataBytes"))
    {
      valuePtr.start.CFDictionaryRef value = 0;
      uint64_t MustBeShown = MovieTrackComputeTotalTrackBytes(v10, v11, &valuePtr.start.value);
      if (MustBeShown) {
        goto LABEL_21;
      }
      CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      p_CMTimeRange valuePtr = (float *)&valuePtr;
      CFNumberType v20 = kCFNumberSInt64Type;
      goto LABEL_25;
    }
    if (CFEqual(a2, @"UneditedSampleCount"))
    {
      int MediaTimeScale = MovieTrackGetSampleCount(v11);
      goto LABEL_12;
    }
    if (CFEqual(a2, @"EstimatedDataRate"))
    {
      uint64_t v85 = 0;
      uint64_t MustBeShown = MovieTrackComputeTotalTrackBytes(v10, v11, &v85);
      if (MustBeShown) {
        goto LABEL_21;
      }
      memset(&valuePtr, 0, 24);
      MovieTrackGetMediaDuration(v11, (uint64_t)&valuePtr);
      double v21 = (double)v85;
      *(_OWORD *)&time.start.CFDictionaryRef value = *(_OWORD *)&valuePtr.start.value;
      time.start.CMTimeEpoch epoch = valuePtr.start.epoch;
      float v22 = v21 / CMTimeGetSeconds(&time.start);
      float v86 = v22;
      CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      p_CMTimeRange valuePtr = &v86;
      goto LABEL_39;
    }
    if (CFEqual(a2, @"PeakDataRate"))
    {
      LODWORD(valuePtr.start.value) = 0;
      uint64_t v23 = MovieTrackComputePeakDataRate(v10, v11, (float *)&valuePtr);
LABEL_37:
      uint64_t MustBeShown = v23;
      if (v23) {
        goto LABEL_21;
      }
      CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      p_CMTimeRange valuePtr = (float *)&valuePtr;
LABEL_39:
      CFNumberType v20 = kCFNumberFloat32Type;
LABEL_25:
      CFDictionaryRef value = CFNumberCreate(v18, v20, p_valuePtr);
      goto LABEL_20;
    }
    if (CFEqual(a2, @"NominalFrameRate"))
    {
      LODWORD(valuePtr.start.value) = 0;
      uint64_t v23 = MovieTrackComputeNominalFrameRate(v10, v11, (float *)&valuePtr);
      goto LABEL_37;
    }
    if (CFEqual(a2, @"Volume"))
    {
      LODWORD(valuePtr.start.value) = MovieTrackGetVolume(v11);
      CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFNumberType v16 = kCFNumberFloat32Type;
      goto LABEL_13;
    }
    if (CFEqual(a2, @"LoudnessInfo"))
    {
      valuePtr.start.CFDictionaryRef value = 0;
      LODWORD(time.start.value) = 8;
      uint64_t v25 = *v9;
      if (*(unsigned char *)(*v9 + 81))
      {
        if (*(unsigned char *)(v25 + 82))
        {
LABEL_45:
          uint64_t v26 = @"udta";
          uint64_t v27 = AssureTrackQuickTimeUserDataReaderCreated((uint64_t)v9);
          goto LABEL_52;
        }
      }
      else if (!*(unsigned char *)(v25 + 84))
      {
        goto LABEL_45;
      }
      uint64_t v26 = @"uiso";
      uint64_t v27 = AssureTrackISOUserDataReaderCreated((uint64_t)v9);
LABEL_52:
      uint64_t v30 = v27;
      if (!v27
        || ((v31 = *(void *)(CMBaseObjectGetVTable() + 16)) == 0 ? (uint64_t v32 = 0) : (uint64_t v32 = v31),
            (uint64_t v33 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(v32 + 40)) == 0
         || (v34 = v33(v30, v26, @"ludt"), uint64_t v35 = v34 - 1, v34 < 1)))
      {
LABEL_78:
        uint64_t MustBeShown = 4294954513;
        goto LABEL_80;
      }
      uint64_t v36 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v36) {
        uint64_t v37 = v36;
      }
      else {
        uint64_t v37 = 0;
      }
      int v40 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, uint64_t, const __CFAllocator *, CMTimeRange *, void))(v37 + 48);
      if (!v40)
      {
        uint64_t MustBeShown = 4294954514;
LABEL_80:
        if (valuePtr.start.value) {
          CFRelease((CFTypeRef)valuePtr.start.value);
        }
        goto LABEL_21;
      }
      uint64_t Property = v40(v30, v26, @"ludt", v35, a3, &valuePtr, 0);
      if (Property)
      {
LABEL_77:
        uint64_t MustBeShown = Property;
        goto LABEL_80;
      }
      if (valuePtr.start.value)
      {
        CFTypeID v42 = CFGetTypeID((CFTypeRef)valuePtr.start.value);
        if (v42 == CFDataGetTypeID())
        {
          uint64_t Property = AudioFormatGetProperty(0x6C646C62u, 8u, &valuePtr, (UInt32 *)&time, a4);
          goto LABEL_77;
        }
        goto LABEL_78;
      }
LABEL_84:
      uint64_t MustBeShown = 4294954513;
      goto LABEL_21;
    }
    if (CFEqual(a2, @"TrackFrameReorderingRequired"))
    {
      int v28 = *(_DWORD *)(v11 + 24);
      uint64_t MustBeShown = 4294954452;
      if (v28 > 1935893869)
      {
        if (v28 != 1986618469)
        {
          int v29 = 1935893870;
LABEL_65:
          if (v28 != v29) {
            goto LABEL_21;
          }
        }
      }
      else if (v28 != 1635088502)
      {
        int v29 = 1885954932;
        goto LABEL_65;
      }
      int IsFrameReorderingRequired = MovieTrackIsFrameReorderingRequired(v10, v11);
      goto LABEL_67;
    }
    if (CFEqual(a2, @"TrackLanguageCode"))
    {
      valuePtr.start.CFDictionaryRef value = 0;
      MovieTrackGetLanguageInformation(v11, 0, &valuePtr, 0);
      CFDictionaryRef value = (const __CFDictionary *)valuePtr.start.value;
      if (!valuePtr.start.value) {
        goto LABEL_19;
      }
      goto LABEL_70;
    }
    if (CFEqual(a2, @"ExtendedLanguageTagString"))
    {
      valuePtr.start.CFDictionaryRef value = 0;
      MovieTrackGetLanguageInformation(v11, 0, 0, &valuePtr);
      CFDictionaryRef value = (const __CFDictionary *)valuePtr.start.value;
      if (!valuePtr.start.value) {
        goto LABEL_84;
      }
LABEL_70:
      CFDictionaryRef value = (const __CFDictionary *)CFRetain(value);
      goto LABEL_19;
    }
    if (CFEqual(a2, @"TrackQTLoadSettings"))
    {
      CFDictionaryRef QTLoadSettingsDictionary = MovieInformationCreateQTLoadSettingsDictionary(a3, (uint64_t)v10, (unsigned char *)v11);
      *a4 = QTLoadSettingsDictionary;
      if (QTLoadSettingsDictionary) {
        uint64_t MustBeShown = 0;
      }
      else {
        uint64_t MustBeShown = 4294954513;
      }
      goto LABEL_21;
    }
    if (CFEqual(a2, @"TrackEnabled"))
    {
      int IsEnabled = MovieTrackIsEnabled(v11);
      goto LABEL_91;
    }
    if (CFEqual(a2, @"TrackDimensions"))
    {
      LODWORD(valuePtr.start.value) = 0;
      LODWORD(time.start.value) = 0;
      MovieTrackGetSpatialInformation(v11, &valuePtr, &time, 0);
      goto LABEL_96;
    }
    if (CFEqual(a2, @"CleanApertureDimensions"))
    {
      LODWORD(valuePtr.start.value) = 0;
      LODWORD(time.start.value) = 0;
      MovieTrackGetCleanApertureDimensions(v11, (float *)&valuePtr, (float *)&time);
      if (!v45) {
        goto LABEL_84;
      }
LABEL_96:
      v88.width = *(float *)&valuePtr.start.value;
      v88.height = *(float *)&time.start.value;
      CFDictionaryRef value = CGSizeCreateDictionaryRepresentation(v88);
      goto LABEL_19;
    }
    if (CFEqual(a2, @"ProductionApertureDimensions"))
    {
      LODWORD(valuePtr.start.value) = 0;
      LODWORD(time.start.value) = 0;
      MovieTrackGetProductionApertureDimensions(v11, (float *)&valuePtr, (float *)&time);
      if (!v46) {
        goto LABEL_84;
      }
      goto LABEL_96;
    }
    if (CFEqual(a2, @"EncodedPixelsDimensions"))
    {
      LODWORD(valuePtr.start.value) = 0;
      LODWORD(time.start.value) = 0;
      MovieTrackGetEncodedPixelsDimensions(v11, (float *)&valuePtr, (float *)&time);
      if (!v47) {
        goto LABEL_84;
      }
      goto LABEL_96;
    }
    if (CFEqual(a2, @"TrackMatrix"))
    {
      memset(&valuePtr, 0, 36);
      MovieTrackGetSpatialInformation(v11, 0, 0, (uint64_t)&valuePtr);
      CFDictionaryRef value = FigMatrixToCFArray(a3, (uint64_t)&valuePtr);
      goto LABEL_19;
    }
    if (CFEqual(a2, @"TrackLayer"))
    {
      __int16 Layer = MovieTrackGetLayer(v11);
LABEL_112:
      LOWORD(valuePtr.start.value) = Layer;
LABEL_113:
      CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFNumberType v16 = kCFNumberSInt16Type;
      goto LABEL_13;
    }
    if (CFEqual(a2, @"AlternateGroupID"))
    {
      __int16 Layer = MovieTrackGetAlternateGroupID(v11);
      goto LABEL_112;
    }
    if (CFEqual(a2, @"ProvisionalAlternateGroupID"))
    {
      LOWORD(valuePtr.start.value) = 0;
      if (!MovieTrackGetProvisionalAlternateGroupID(v11, &valuePtr))
      {
        CFDictionaryRef value = 0;
        goto LABEL_19;
      }
      goto LABEL_113;
    }
    if (CFEqual(a2, @"DefaultAlternateGroupID"))
    {
      __int16 Layer = MovieTrackGetDefaultAlternateGroupID(v11);
      goto LABEL_112;
    }
    if (CFEqual(a2, @"TrackExcludeFromAutoSelection"))
    {
      int IsEnabled = MovieTrackIsExcludedFromAutoSelection(v11);
LABEL_91:
      long long v39 = (const void **)MEMORY[0x1E4F1CFD0];
      if (IsEnabled != 1) {
        long long v39 = (const void **)MEMORY[0x1E4F1CFC8];
      }
      goto LABEL_69;
    }
    if (CFEqual(a2, @"TrackIsSelfContained"))
    {
      int IsFrameReorderingRequired = MovieTrackIsSelfContained(v11);
      goto LABEL_67;
    }
    if (CFEqual(a2, @"ContainsUnsupportedDataReferences"))
    {
      int IsFrameReorderingRequired = MovieTrackContainsUnsupportedDataReferences((uint64_t)v10, v11);
      goto LABEL_67;
    }
    if (CFEqual(a2, @"AdvanceDecodeDelta"))
    {
      CFDictionaryRef value = MovieTrackCreateAdvanceDecodeDeltaDictionary(a3, v10, v11);
      goto LABEL_19;
    }
    if (CFEqual(a2, @"ShowTimeCode"))
    {
      LOBYTE(valuePtr.start.value) = 0;
      uint64_t MustBeShown = MovieTrackGetTimecodeMustBeShown(v11, &valuePtr);
      if (MustBeShown) {
        goto LABEL_21;
      }
      long long v49 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      if (LOBYTE(valuePtr.start.value) != 1) {
        long long v49 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
      }
      CFDictionaryRef value = (const __CFDictionary *)CFRetain(*v49);
      goto LABEL_20;
    }
    if (CFEqual(a2, @"TrackName"))
    {
      uint64_t v50 = AssureTrackQuickTimeUserDataReaderCreated((uint64_t)v9);
      if (!v50) {
        goto LABEL_166;
      }
      uint64_t v51 = v50;
      uint64_t v52 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v52) {
        uint64_t v53 = v52;
      }
      else {
        uint64_t v53 = 0;
      }
      long long v54 = *(uint64_t (**)(uint64_t, __CFString *))(v53 + 40);
      if (v54)
      {
        uint64_t v55 = v54(v51, @"udta");
        if (v55)
        {
          uint64_t v56 = v55;
          if (v55 >= 1)
          {
            uint64_t v57 = 0;
            CFMutableStringRef Mutable = 0;
            CFAllocatorRef v59 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            do
            {
              valuePtr.start.CFDictionaryRef value = 0;
              time.start.CFDictionaryRef value = 0;
              uint64_t v60 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v60) {
                uint64_t v61 = v60;
              }
              else {
                uint64_t v61 = 0;
              }
              CMTime v62 = *(unsigned int (**)(uint64_t, __CFString *, __CFString *, uint64_t, const __CFAllocator *, CMTimeRange *, CMTimeRange *))(v61 + 48);
              if (v62 && !v62(v51, @"udta", @"tnam", v57, v59, &valuePtr, &time))
              {
                LOWORD(v85) = 0;
                CFNumberRef v63 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)time.start.value, @"languageCode");
                if (v63)
                {
                  CFNumberGetValue(v63, kCFNumberSInt16Type, &v85);
                  uint64_t v64 = *v9;
                  int v65 = *(unsigned char *)(*v9 + 81) ? *(unsigned char *)(v64 + 82) == 0 : *(unsigned char *)(v64 + 84) != 0;
                  CFStringRef StringForLanguageCode = FigCreateStringForLanguageCode(v59, (unsigned __int16)v85, v65);
                  if (StringForLanguageCode)
                  {
                    CFStringRef v67 = StringForLanguageCode;
                    if (Mutable
                      || (CFMutableStringRef Mutable = CFDictionaryCreateMutable(a3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) != 0)
                    {
                      CFDictionarySetValue(Mutable, v67, (const void *)valuePtr.start.value);
                    }
                    CFRelease(v67);
                  }
                }
                if (valuePtr.start.value) {
                  CFRelease((CFTypeRef)valuePtr.start.value);
                }
                if (time.start.value) {
                  CFRelease((CFTypeRef)time.start.value);
                }
              }
              ++v57;
            }
            while (v56 != v57);
            goto LABEL_180;
          }
LABEL_166:
          CFMutableStringRef Mutable = 0;
LABEL_180:
          uint64_t MustBeShown = 0;
          *a4 = Mutable;
          goto LABEL_21;
        }
      }
      valuePtr.start.CFDictionaryRef value = 0;
      uint64_t v68 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v68) {
        uint64_t v69 = v68;
      }
      else {
        uint64_t v69 = 0;
      }
      long long v70 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, void, void, CMTimeRange *, void))(v69 + 8);
      if (!v70) {
        goto LABEL_176;
      }
      int v71 = v70(v51, @"udta", @"name", 0, *MEMORY[0x1E4F1CF80], &valuePtr, 0);
      CFMutableStringRef Mutable = 0;
      long long v72 = (const void *)valuePtr.start.value;
      if (v71 || !valuePtr.start.value)
      {
LABEL_178:
        if (v72) {
          CFRelease(v72);
        }
        goto LABEL_180;
      }
      CFTypeID v73 = CFGetTypeID((CFTypeRef)valuePtr.start.value);
      if (v73 == CFStringGetTypeID())
      {
        time.start.CFDictionaryRef value = (CMTimeValue)@"eng";
        CFMutableStringRef Mutable = CFDictionaryCreate(a3, (const void **)&time, (const void **)&valuePtr, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
      else
      {
LABEL_176:
        CFMutableStringRef Mutable = 0;
      }
      long long v72 = (const void *)valuePtr.start.value;
      goto LABEL_178;
    }
    if (CFEqual(a2, @"QuickTimeUserDataReader"))
    {
      CFDictionaryRef value = (const __CFDictionary *)AssureTrackQuickTimeUserDataReaderCreated((uint64_t)v9);
      if (!value) {
        goto LABEL_84;
      }
      goto LABEL_70;
    }
    if (CFEqual(a2, @"ISOUserDataReader"))
    {
      CFDictionaryRef value = (const __CFDictionary *)AssureTrackISOUserDataReaderCreated((uint64_t)v9);
      if (!value) {
        goto LABEL_84;
      }
      goto LABEL_70;
    }
    if (CFEqual(a2, @"QuickTimeMetadataReader"))
    {
      CFDictionaryRef value = (const __CFDictionary *)AssureTrackQuickTimeMetadataReaderCreated((uint64_t)v9);
      if (!value) {
        goto LABEL_84;
      }
      goto LABEL_70;
    }
    if (CFEqual(a2, @"MetadataReaders"))
    {
      CMTime v74 = (const void *)AssureTrackQuickTimeUserDataReaderCreated((uint64_t)v9);
      v75 = (const void *)AssureTrackQuickTimeMetadataReaderCreated((uint64_t)v9);
      uint64_t v76 = AssureTrackISOUserDataReaderCreated((uint64_t)v9);
      v77 = (const void *)v76;
      if (v74 || v76 || v75)
      {
        v78 = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
        if (v78)
        {
          CFMutableStringRef Mutable = v78;
          if (v75) {
            CFArrayAppendValue(v78, v75);
          }
          if (v74) {
            CFArrayAppendValue(Mutable, v74);
          }
          if (v77) {
            CFArrayAppendValue(Mutable, v77);
          }
          goto LABEL_180;
        }
        goto LABEL_33;
      }
LABEL_208:
      uint64_t MustBeShown = 0;
      goto LABEL_21;
    }
    if (CFEqual(a2, @"MetadataReaderTypes"))
    {
      CFMutableArrayRef v79 = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
      if (v79)
      {
        v80 = v79;
        if (MovieTrackMetadataFormatIsAvailable((int)v10, (void *)v11, @"com.apple.quicktime.udta"))CFArrayAppendValue(v80, @"QuickTimeUserDataReader"); {
        if (MovieTrackMetadataFormatIsAvailable((int)v10, (void *)v11, @"org.mp4ra"))
        }
          CFArrayAppendValue(v80, @"ISOUserDataReader");
        if (MovieTrackMetadataFormatIsAvailable((int)v10, (void *)v11, @"com.apple.quicktime.mdta"))CFArrayAppendValue(v80, @"QuickTimeMetadataReader"); {
        if (CFArrayGetCount(v80) >= 1)
        }
        {
          uint64_t MustBeShown = 0;
          *a4 = v80;
          goto LABEL_21;
        }
        CFRelease(v80);
        goto LABEL_208;
      }
LABEL_33:
      uint64_t EditCursorService = FigSignalErrorAt();
      goto LABEL_34;
    }
    if (CFEqual(a2, @"EditCursorService"))
    {
      uint64_t EditCursorService = MovieTrackReaderCreateEditCursorService(a1, (uint64_t)a3, a4);
      goto LABEL_34;
    }
    if (CFEqual(a2, @"HasRollInformation"))
    {
      int IsFrameReorderingRequired = MovieTrackHasRollInformation(v11);
      goto LABEL_67;
    }
    if (CFEqual(a2, @"HasAudioSampleDependencyInformation"))
    {
      int IsFrameReorderingRequired = MovieTrackHasAudioDependencyInformation(v11);
      goto LABEL_67;
    }
    if (CFEqual(a2, @"EditsExcludePrimingAndRemainderDuration"))
    {
      int IsFrameReorderingRequired = MovieTrackEditsExcludeAudioPrimingAndRemainderDuration(v11);
      goto LABEL_67;
    }
    if (CFEqual(a2, @"GaplessSourceTimeRange"))
    {
      memset(&valuePtr, 0, sizeof(valuePtr));
      GetGaplessSourceTimeRange(&valuePtr);
      CMTimeRange time = valuePtr;
      CFDictionaryRef value = CMTimeRangeCopyAsDictionary(&time, a3);
      goto LABEL_19;
    }
    if (CFEqual(a2, @"HasSeamSamples"))
    {
      int IsFrameReorderingRequired = MovieTrackHasSeamSamples(v11);
      goto LABEL_67;
    }
    if (CFEqual(a2, @"ContainsChapters"))
    {
      int IsFrameReorderingRequired = MovieTrackIsChapterTrack((uint64_t)v10, v11);
LABEL_67:
      long long v39 = (const void **)MEMORY[0x1E4F1CFD0];
      if (!IsFrameReorderingRequired) {
        long long v39 = (const void **)MEMORY[0x1E4F1CFC8];
      }
LABEL_69:
      CFDictionaryRef value = (const __CFDictionary *)*v39;
      goto LABEL_70;
    }
    if (!CFEqual(a2, @"MinSampleDuration"))
    {
      if (CFEqual(a2, @"MaxEditRate"))
      {
        LODWORD(valuePtr.start.value) = 1065353216;
        uint64_t v23 = MovieTrackComputeMaxEditRate((void *)*v9, v9[1], (float *)&valuePtr);
        goto LABEL_37;
      }
      if (CFEqual(a2, @"SampleDescriptionAtomLocation"))
      {
        uint64_t EditCursorService = MovieTrackCreateSampleDescriptionAtomLocationDictionary(v11, a4);
      }
      else if (CFEqual(a2, @"ExternalDataReferenceSchemes"))
      {
        uint64_t EditCursorService = MovieTrackCopyExternalDataReferenceSchemes(v10, v11, a4);
      }
      else if (CFEqual(a2, @"MediaCharacteristicArray"))
      {
        uint64_t EditCursorService = FigMediaCharacteristicsCopyMediaCharacteristicsForTrackInformation((uint64_t)a3, v11, a4);
      }
      else if (CFEqual(a2, @"HEVCSyncSampleNALUnitTypes"))
      {
        uint64_t EditCursorService = MovieTrackCopySyncSampleCombinations(a3, v11, a4);
      }
      else if (CFEqual(a2, @"HEVCTemporalLevelInfoCombinations"))
      {
        uint64_t EditCursorService = MovieTrackCopyTemporalLevelCombinations(a3, v11, a4);
      }
      else if (CFEqual(a2, @"SampleGroupDescriptions"))
      {
        uint64_t EditCursorService = MovieTrackCopySampleGroupDescriptionDictionary(a3, v11, a4);
      }
      else
      {
        if (!CFEqual(a2, @"LatentBaseDecodeTimeStampOfFirstTrackFragment"))
        {
          if (CFEqual(a2, @"UsesAudibleDRM"))
          {
            int IsFrameReorderingRequired = MovieTrackUsesAudibleDRM(v11);
          }
          else if (CFEqual(a2, @"AudibleContentIsAuthorized"))
          {
            int IsFrameReorderingRequired = MovieTrackAudibleContentIsAuthorized((uint64_t)v10, v11);
          }
          else
          {
            if (!CFEqual(a2, @"HasEditListBox"))
            {
              uint64_t MustBeShown = 4294954512;
              goto LABEL_21;
            }
            int IsFrameReorderingRequired = MovieTrackHasEditList(v11);
          }
          goto LABEL_67;
        }
        uint64_t EditCursorService = MovieTrackCopyLatentBaseDecodeTimeStampOfFirstTrackFragmentDictionary(a3, v11, a4);
      }
LABEL_34:
      uint64_t MustBeShown = EditCursorService;
      goto LABEL_21;
    }
    MEMORY[0x19970E910](v9[6]);
    v81 = (const void *)v9[7];
    if (v81)
    {
      uint64_t MustBeShown = 0;
    }
    else
    {
      memset(&valuePtr, 0, 24);
      uint64_t MustBeShown = MovieTrackComputeMinSampleDuration((void *)*v9, v9[1], &valuePtr.start);
      if (MustBeShown)
      {
        v81 = (const void *)v9[7];
      }
      else
      {
        CFAllocatorRef v82 = CFGetAllocator((CFTypeRef)v9[1]);
        *(_OWORD *)&time.start.CFDictionaryRef value = *(_OWORD *)&valuePtr.start.value;
        time.start.CMTimeEpoch epoch = valuePtr.start.epoch;
        v81 = CMTimeCopyAsDictionary(&time.start, v82);
        v9[7] = (uint64_t)v81;
      }
      if (!v81) {
        goto LABEL_234;
      }
    }
    v81 = CFRetain(v81);
LABEL_234:
    *a4 = (CFDictionaryRef)v81;
    MEMORY[0x19970E930](v9[6]);
    goto LABEL_21;
  }

  return FigSignalErrorAt();
}

uint64_t AssureTrackQuickTimeUserDataReaderCreated(uint64_t a1)
{
  if (!*(void *)(a1 + 24))
  {
    MovieInformationLockForRead(*(void *)a1);
    MovieTrackCreateQuickTimeUserDataReader(*(void *)a1, *(uint64_t **)(a1 + 8), (void *)(a1 + 24));
    MovieInformationUnlockForRead(*(void *)a1);
  }
  MEMORY[0x19970E2B0](*(void *)(a1 + 16));
  return *(void *)(a1 + 24);
}

uint64_t AssureTrackISOUserDataReaderCreated(uint64_t a1)
{
  if (!*(void *)(a1 + 32))
  {
    MovieInformationLockForRead(*(void *)a1);
    MovieTrackCreateISOUserDataReader(*(void *)a1, *(uint64_t **)(a1 + 8), (void *)(a1 + 32));
    MovieInformationUnlockForRead(*(void *)a1);
  }
  MEMORY[0x19970E2B0](*(void *)(a1 + 16));
  return *(void *)(a1 + 32);
}

uint64_t AssureTrackQuickTimeMetadataReaderCreated(uint64_t a1)
{
  if (!*(void *)(a1 + 40))
  {
    MovieInformationLockForRead(*(void *)a1);
    MovieTrackCreateQuickTimeMetadataReader(*(void *)a1, *(uint64_t **)(a1 + 8), (void *)(a1 + 40));
    MovieInformationUnlockForRead(*(void *)a1);
  }
  MEMORY[0x19970E2B0](*(void *)(a1 + 16));
  return *(void *)(a1 + 40);
}

uint64_t MovieTrackReaderGetTrackInfo(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage && DerivedStorage[1])
  {
    MovieInformationLockForRead(*DerivedStorage);
    uint64_t BasicInfo = MovieTrackGetBasicInfo(DerivedStorage[1], a3, a2);
    MovieInformationUnlockForRead(*DerivedStorage);
    return BasicInfo;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieTrackReaderGetTrackEditCount()
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage && DerivedStorage[1])
  {
    MovieInformationLockForRead(*DerivedStorage);
    EditSegmentCFIndex Count = MovieTrackGetEditSegmentCount(DerivedStorage[1]);
    MovieInformationUnlockForRead(*DerivedStorage);
    return EditSegmentCount;
  }
  else
  {
    FigSignalErrorAt();
    return 0;
  }
}

uint64_t MovieTrackReaderGetTrackEditWithIndex(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage && DerivedStorage[1] && a3)
  {
    MovieInformationLockForRead(*DerivedStorage);
    uint64_t EditSegmentWithIndex = MovieTrackGetEditSegmentWithIndex(DerivedStorage[1], a2, a3);
    MovieInformationUnlockForRead(*DerivedStorage);
    return EditSegmentWithIndex;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieTrackReaderCopySampleCursorService(const void *a1, void *a2)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage && (uint64_t v5 = DerivedStorage, MovieTrackIsValid(DerivedStorage[1])))
  {
    uint64_t v6 = MoovAssureSampleTableParsed((void *)*v5, v5[1]);
    if (v6) {
      return v6;
    }
    CFGetAllocator(a1);
    FigSampleCursorServiceGetClassID();
    uint64_t v7 = CMDerivedObjectCreate();
    if (v7)
    {
      uint64_t v11 = v7;
      FigSignalErrorAt();
    }
    else
    {
      int32_t v8 = (void *)CMBaseObjectGetDerivedStorage();
      uint64_t v9 = (void *)*v5;
      if (*v5) {
        uint64_t v9 = CFRetain(v9);
      }
      *int32_t v8 = v9;
      CFTypeRef v10 = (CFTypeRef)v5[1];
      if (v10) {
        CFTypeRef v10 = CFRetain(v10);
      }
      uint64_t v11 = 0;
      v8[1] = v10;
      *a2 = 0;
    }
    return v11;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieTrackReaderGetTrackEditIndexWithTrackTime(uint64_t a1, CMTime *a2, void *a3)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage && DerivedStorage[1])
  {
    MovieInformationLockForRead(*DerivedStorage);
    uint64_t v6 = DerivedStorage[1];
    CMTime v9 = *a2;
    uint64_t EditIndexForTrackTime = MovieTrackFindEditIndexForTrackTime(v6, &v9, a3);
    MovieInformationUnlockForRead(*DerivedStorage);
    return EditIndexForTrackTime;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void MovieCursorService_finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  uint64_t v1 = *(const void **)(DerivedStorage + 8);
  if (v1)
  {
    CFRelease(v1);
    *(void *)(DerivedStorage + 8) = 0;
  }
}

__CFString *MovieCursorService_copyDebugDescription(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v3, 0);
  CFStringAppendFormat(Mutable, 0, @"<FigFormatReader_Movie_CursorService %p>{ track %p }", a1, *(void *)(DerivedStorage + 8));
  return Mutable;
}

uint64_t MovieCursorService_createCursorAtPresentationTimeStamp(const void *a1, long long *a2, void *a3, unsigned char *a4, unsigned char *a5)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  CFNumberType v20 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  CFAllocatorRef v11 = CFGetAllocator(a1);
  uint64_t v12 = CreateMovieSampleCursor((uint64_t)v11, (const void *)*DerivedStorage, DerivedStorage[1], &v20);
  if (v12)
  {
    uint64_t v16 = v12;
  }
  else
  {
    uint64_t v13 = v20;
    uint64_t v14 = *(void *)(CMBaseObjectGetDerivedStorage() + 8);
    long long v18 = *a2;
    uint64_t v19 = *((void *)a2 + 2);
    MovieSampleAccessorMoveToSampleAtPTS(v14, (uint64_t)&v18, a4, a5);
    uint64_t v16 = v15;
    if (v15)
    {
      if (v13) {
        CFRelease(v13);
      }
    }
    else
    {
      *a3 = v13;
    }
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return v16;
}

uint64_t MovieCursorService_createCursorNearPresentationTimeStamp(const void *a1, long long *a2, uint64_t a3, void *a4, unsigned char *a5, unsigned char *a6)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  double v21 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  CFAllocatorRef v12 = CFGetAllocator(a1);
  uint64_t v13 = CreateMovieSampleCursor((uint64_t)v12, (const void *)*DerivedStorage, DerivedStorage[1], &v21);
  if (v13)
  {
    uint64_t v17 = v13;
  }
  else
  {
    uint64_t v14 = v21;
    uint64_t v15 = *(void *)(CMBaseObjectGetDerivedStorage() + 8);
    long long v19 = *a2;
    uint64_t v20 = *((void *)a2 + 2);
    MovieSampleAccessorMoveToSampleAtPTS(v15, (uint64_t)&v19, a5, a6);
    uint64_t v17 = v16;
    if (v16)
    {
      if (v14) {
        CFRelease(v14);
      }
    }
    else
    {
      *a4 = v14;
    }
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return v17;
}

uint64_t MovieCursorService_createCursorAtFirstSampleInDecodeOrder(const void *a1, void *a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  uint64_t v8 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  uint64_t v6 = CreateMovieSampleCursor((uint64_t)v5, (const void *)*DerivedStorage, DerivedStorage[1], &v8);
  if (!v6) {
    *a2 = v8;
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return v6;
}

uint64_t MovieCursorService_createCursorAtLastSampleInDecodeOrder(const void *a1, void *a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v11 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  uint64_t v6 = CreateMovieSampleCursor((uint64_t)v5, (const void *)*DerivedStorage, DerivedStorage[1], &v11);
  if (v6)
  {
    uint64_t SampleInDecodeOrder = v6;
  }
  else
  {
    uint64_t v7 = v11;
    uint64_t v8 = CMBaseObjectGetDerivedStorage();
    uint64_t SampleInDecodeOrder = MovieSampleAccessorMoveToLastSampleInDecodeOrder(*(void *)(v8 + 8));
    if (SampleInDecodeOrder)
    {
      if (v7) {
        CFRelease(v7);
      }
    }
    else
    {
      *a2 = v7;
    }
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return SampleInDecodeOrder;
}

uint64_t CreateMovieSampleCursor(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  if (!MovieTrackIsValid(a3))
  {
    uint64_t v9 = FigSignalErrorAt();
LABEL_10:
    uint64_t v11 = v9;
    goto LABEL_8;
  }
  FigSampleCursorGetClassID();
  uint64_t v7 = CMDerivedObjectCreate();
  if (v7)
  {
    uint64_t v11 = v7;
    FigSignalErrorAt();
    goto LABEL_8;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v9 = MovieSampleAccessorCreate(a2, a3, (const void ***)(DerivedStorage + 8));
  if (v9) {
    goto LABEL_10;
  }
  if (a2) {
    CFTypeRef v10 = CFRetain(a2);
  }
  else {
    CFTypeRef v10 = 0;
  }
  uint64_t v11 = 0;
  *(void *)uint64_t DerivedStorage = v10;
LABEL_8:
  *a4 = 0;
  return v11;
}

void MovieCursor_finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MovieSampleAccessorDispose(*(const void ***)(DerivedStorage + 8));
  if (*(void *)DerivedStorage) {
    CFRelease(*(CFTypeRef *)DerivedStorage);
  }
  uint64_t v1 = *(const void **)(DerivedStorage + 16);
  if (v1) {
    CFRelease(v1);
  }
  *(void *)uint64_t DerivedStorage = 0;
  *(void *)(DerivedStorage + 8) = 0;
  *(void *)(DerivedStorage + 16) = 0;
}

__CFString *MovieCursor_copyDebugDescription(const void *a1)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v3, 0);
  unsigned int TrackType = MovieTrackGetTrackType(*(void *)(DerivedStorage[1] + 8));
  unsigned int v19 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  MovieTrackGetBasicInfo(*(void *)(DerivedStorage[1] + 8), 0, &v19);
  MovieInformationUnlockForRead(*DerivedStorage);
  uint64_t v6 = DerivedStorage[1];
  uint64_t v7 = *(unsigned int *)(v6 + 80);
  uint64_t v8 = v19;
  BOOL IsValid = MovieTrackIsValid(*(void *)(v6 + 8));
  CFTypeRef v10 = "";
  if (!IsValid) {
    CFTypeRef v10 = " (INVALIDATED)";
  }
  CFStringAppendFormat(Mutable, 0, @"<Movie_SampleCursor %p>{ sampleNum %d, Track ID %d%s, Type %c%c%c%c }", a1, v7, v8, v10, HIBYTE(TrackType), BYTE2(TrackType), BYTE1(TrackType), TrackType);
  uint64_t v11 = DerivedStorage[1];
  uint64_t v12 = *(void *)(v11 + 8);
  uint64_t v13 = *(void *)(v12 + 728);
  if (v13)
  {
    if (*(void *)(v13 + 56))
    {
      unsigned int v14 = *(_DWORD *)(v11 + 80);
      unsigned int v15 = *(_DWORD *)(v12 + 288);
      BOOL v16 = v14 >= v15;
      uint64_t v17 = v14 - v15;
      if (v17 != 0 && v16) {
        CFStringAppendFormat(Mutable, 0, @"\nFragment Sample %d of %d [Fragment %p Run %p IndexInRun %u/%d]", v17, *(unsigned int *)(v13 + 8), *(void *)(v11 + 200), *(void *)(v11 + 208), v14 - *(_DWORD *)(*(void *)(v11 + 208) + 16), *(unsigned int *)(*(void *)(v11 + 208) + 36));
      }
    }
  }
  return Mutable;
}

uint64_t MovieCursor_copyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CMTimeValue *a4)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*DerivedStorage);
  if (!a4 || !MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    uint64_t v8 = FigSignalErrorAt();
    goto LABEL_30;
  }
  *a4 = 0;
  if (!CFEqual(a2, @"CursorPlayableHorizon"))
  {
    if (CFEqual(a2, @"SampleDependencyAttributes"))
    {
      v16.CMTimeValue value = 0;
      uint64_t SampleDependencyAttributeDictionary = MovieSampleAccessorCreateSampleDependencyAttributeDictionary(a3, DerivedStorage[1], (__CFDictionary **)&v16);
LABEL_8:
      uint64_t v8 = SampleDependencyAttributeDictionary;
      if (SampleDependencyAttributeDictionary) {
        goto LABEL_30;
      }
      CMTimeValue value = v16.value;
LABEL_16:
      *a4 = value;
      goto LABEL_30;
    }
    if (CFEqual(a2, @"GradualDecoderRefresh"))
    {
      LOWORD(v16.value) = 0;
      if (!MovieSampleAccessorGetRollValue(DerivedStorage[1], &v16))
      {
        uint64_t v8 = 4294954513;
        goto LABEL_30;
      }
      LOWORD(v15.value) = -LOWORD(v16.value);
      AdvanceDecodeDeltaDictionary = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt16Type, &v15);
    }
    else
    {
      if (CFEqual(a2, @"SeamIdentifier"))
      {
        v16.CMTimeValue value = 0;
        BOOL v12 = MovieSampleAccessorCopySeamIdentifier(DerivedStorage[1], (CFStringRef *)&v16);
        uint64_t v8 = 0;
        CMTimeValue value = v16.value;
        if (!v12) {
          CMTimeValue value = 0;
        }
        goto LABEL_16;
      }
      if (CFEqual(a2, @"AdvanceDecodeDelta"))
      {
        AdvanceDecodeDeltaDictionary = (const void *)DerivedStorage[2];
        if (!AdvanceDecodeDeltaDictionary)
        {
          AdvanceDecodeDeltaDictionary = MovieTrackCreateAdvanceDecodeDeltaDictionary(a3, *(void **)DerivedStorage[1], *(void *)(DerivedStorage[1] + 8));
          DerivedStorage[2] = (uint64_t)AdvanceDecodeDeltaDictionary;
          if (!AdvanceDecodeDeltaDictionary) {
            goto LABEL_28;
          }
        }
      }
      else
      {
        if (!CFEqual(a2, @"MoreSamplesMayBeForthcoming"))
        {
          if (!CFEqual(a2, @"SampleGroupData"))
          {
            uint64_t v8 = 4294954512;
            goto LABEL_30;
          }
          v16.CMTimeValue value = 0;
          uint64_t SampleDependencyAttributeDictionary = MovieSampleAccessorCreateSampleGroupDataDictionary(a3, DerivedStorage[1], (CFMutableDictionaryRef *)&v16);
          goto LABEL_8;
        }
        uint64_t v13 = (const void *)*MEMORY[0x1E4F1CFC8];
        if (*(unsigned char *)(*DerivedStorage + 89) && MovieInformationCouldContainFragments(*DerivedStorage)) {
          uint64_t v13 = (const void *)*MEMORY[0x1E4F1CFD0];
        }
        AdvanceDecodeDeltaDictionary = v13;
      }
      AdvanceDecodeDeltaDictionary = CFRetain(AdvanceDecodeDeltaDictionary);
    }
LABEL_28:
    uint64_t v8 = 0;
    goto LABEL_29;
  }
  memset(&v16, 0, sizeof(v16));
  uint64_t v8 = MovieSampleAccessorComputePlayableHorizon(DerivedStorage[1], (uint64_t)&v16);
  if (!v8)
  {
    CMTime v15 = v16;
    AdvanceDecodeDeltaDictionary = CMTimeCopyAsDictionary(&v15, a3);
LABEL_29:
    *a4 = (CMTimeValue)AdvanceDecodeDeltaDictionary;
  }
LABEL_30:
  MovieInformationUnlockForRead(*DerivedStorage);
  return v8;
}

uint64_t MovieCursor_copy(const void *a1, CFTypeRef *a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  uint64_t v11 = 0;
  CFTypeRef cf = 0;
  MovieInformationLockForRead(*DerivedStorage);
  if (!MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    uint64_t v7 = FigSignalErrorAt();
LABEL_9:
    uint64_t v9 = v7;
    goto LABEL_11;
  }
  CFGetAllocator(a1);
  FigSampleCursorGetClassID();
  uint64_t v5 = CMDerivedObjectCreate();
  if (!v5)
  {
    uint64_t v6 = (void *)CMBaseObjectGetDerivedStorage();
    uint64_t v7 = MovieSampleAccessorCopy(DerivedStorage[1], &v11);
    if (!v7)
    {
      v6[1] = v11;
      uint64_t v11 = 0;
      uint64_t v8 = (const void *)*DerivedStorage;
      if (*DerivedStorage) {
        uint64_t v8 = CFRetain(v8);
      }
      uint64_t v9 = 0;
      *uint64_t v6 = v8;
      *a2 = cf;
      CFTypeRef cf = 0;
      goto LABEL_7;
    }
    goto LABEL_9;
  }
  uint64_t v9 = v5;
  FigSignalErrorAt();
LABEL_11:
  if (cf) {
    CFRelease(cf);
  }
LABEL_7:
  MovieInformationUnlockForRead(*DerivedStorage);
  MovieSampleAccessorDispose((const void **)v11);
  return v9;
}

uint64_t MovieCursor_compareInDecodeOrder()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = CMBaseObjectGetDerivedStorage();
  unsigned int v2 = *(_DWORD *)(*(void *)(DerivedStorage + 8) + 80);
  unsigned int v3 = *(_DWORD *)(*(void *)(v1 + 8) + 80);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return -1;
  }
}

uint64_t MovieCursor_getPresentationTimeStamp(uint64_t a1, CMTime *a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*DerivedStorage);
  if (MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    MovieSampleAccessorGetPTS(DerivedStorage[1], &v6);
    uint64_t v4 = 0;
    *a2 = v6;
  }
  else
  {
    uint64_t v4 = FigSignalErrorAt();
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return v4;
}

uint64_t MovieCursor_getDecodeTimeStamp(uint64_t a1, CMTime *a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*DerivedStorage);
  if (MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    MovieSampleAccessorGetDTS(DerivedStorage[1], &v6);
    uint64_t v4 = 0;
    *a2 = v6;
  }
  else
  {
    uint64_t v4 = FigSignalErrorAt();
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return v4;
}

uint64_t MovieCursor_getDuration(uint64_t a1, CMTime *a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*DerivedStorage);
  if (MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8))) {
    uint64_t SampleDuration = MovieSampleAccessorGetSampleDuration(DerivedStorage[1], a2);
  }
  else {
    uint64_t SampleDuration = FigSignalErrorAt();
  }
  uint64_t v5 = SampleDuration;
  MovieInformationUnlockForRead(*DerivedStorage);
  return v5;
}

uint64_t MovieCursor_getDependencyInfo(uint64_t a1, unsigned char *a2, unsigned char *a3, _DWORD *a4, BOOL *a5)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*DerivedStorage);
  if (MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    uint64_t DependencyInfo = MovieSampleAccessorGetDependencyInfo(DerivedStorage[1], a2, a3, 0, 0, a4, a5);
    MovieInformationUnlockForRead(*DerivedStorage);
    return DependencyInfo;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

BOOL MovieCursor_testReorderingBoundary(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  uint64_t v5 = CMBaseObjectGetDerivedStorage();
  uint64_t v10 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  if (MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    DTSTimeCFArrayRef Value = MovieSampleAccessorGetDTSTimeValue(DerivedStorage[1]);
    PTSTimeCFArrayRef Value = MovieSampleAccessorGetPTSTimeValue(*(void *)(v5 + 8));
    MovieTrackGetCompositionOffsetRange(*(void **)DerivedStorage[1], *(void *)(DerivedStorage[1] + 8), (_DWORD *)&v10 + 1, &v10);
    if (a3) {
      BOOL v8 = DTSTimeValue + SHIDWORD(v10) >= PTSTimeValue;
    }
    else {
      BOOL v8 = DTSTimeValue + (int)v10 <= PTSTimeValue;
    }
  }
  else
  {
    FigSignalErrorAt();
    BOOL v8 = 0;
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return v8;
}

uint64_t MovieCursor_stepByDecodeTime(uint64_t a1, CMTime *a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  memset(&v10, 0, sizeof(v10));
  __int16 v9 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  if (MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    MovieSampleAccessorGetDTS(DerivedStorage[1], &v10);
    CMTime lhs = v10;
    CMTime v6 = *a2;
    CMTimeAdd(&v8, &lhs, &v6);
    CMTime v10 = v8;
    MovieSampleAccessorMoveToSampleForDTS(DerivedStorage[1], &v8, (char *)&v9 + 1, (char *)&v9);
    if (HIBYTE(v9) | v9) {
      uint64_t v4 = 4294954456;
    }
    else {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = FigSignalErrorAt();
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return v4;
}

uint64_t MovieCursor_stepByPresentationTime(uint64_t a1, CMTime *a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  memset(&v11, 0, sizeof(v11));
  __int16 v10 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  if (MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    MovieSampleAccessorGetPTS(DerivedStorage[1], &v11);
    CMTime lhs = v11;
    CMTime v7 = *a2;
    CMTimeAdd(&v9, &lhs, &v7);
    CMTime v11 = v9;
    MovieSampleAccessorMoveToSampleAtPTS(DerivedStorage[1], (uint64_t)&v9, (unsigned char *)&v10 + 1, &v10);
    uint64_t v5 = v4;
    if (!v4)
    {
      if (HIBYTE(v10) | v10) {
        uint64_t v5 = 4294954456;
      }
      else {
        uint64_t v5 = 0;
      }
    }
  }
  else
  {
    uint64_t v5 = FigSignalErrorAt();
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return v5;
}

uint64_t MovieCursor_copySampleLocation(uint64_t a1, uint64_t *a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  int v13 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  if (!MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    uint64_t v11 = FigSignalErrorAt();
LABEL_5:
    uint64_t SampleLocation = v11;
    goto LABEL_7;
  }
  uint64_t SampleLocation = MovieSampleAccessorGetSampleLocation(DerivedStorage[1], a2, a3, &v13);
  if (!SampleLocation)
  {
    if (!(a4 | a5))
    {
      uint64_t SampleLocation = 0;
      goto LABEL_7;
    }
    uint64_t v11 = MovieTrackCopyDataSourceForSampleDescriptionID(*(void **)DerivedStorage[1], *(void *)(DerivedStorage[1] + 8), v13, (void *)a5, (void *)a4);
    goto LABEL_5;
  }
LABEL_7:
  MovieInformationUnlockForRead(*DerivedStorage);
  return SampleLocation;
}

uint64_t MovieCursor_copyChunkDetails(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t *a4, uint64_t *a5, void *a6, void *a7, BOOL *a8, BOOL *a9, unsigned char *a10)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  int v21 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  if (!MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    uint64_t v19 = FigSignalErrorAt();
LABEL_5:
    uint64_t ChunkDetails = v19;
    goto LABEL_7;
  }
  uint64_t ChunkDetails = MovieSampleAccessorGetChunkDetails(DerivedStorage[1], &v21, a4, a5, a6, a7, a8, a9, a10);
  if (!ChunkDetails)
  {
    if (!(a2 | a3))
    {
      uint64_t ChunkDetails = 0;
      goto LABEL_7;
    }
    uint64_t v19 = MovieTrackCopyDataSourceForSampleDescriptionID((void *)*DerivedStorage, *(void *)(DerivedStorage[1] + 8), v21, (void *)a3, (void *)a2);
    goto LABEL_5;
  }
LABEL_7:
  MovieInformationUnlockForRead(*DerivedStorage);
  return ChunkDetails;
}

uint64_t MovieCursor_copyFormatDescription(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  MovieInformationLockForRead(*DerivedStorage);
  if (!MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    uint64_t FormatDescription = FigSignalErrorAt();
    goto LABEL_8;
  }
  uint64_t FormatDescription = MovieSampleAccessorGetFormatDescription(DerivedStorage[1], &cf);
  if (FormatDescription)
  {
LABEL_8:
    uint64_t v6 = FormatDescription;
    goto LABEL_6;
  }
  CFTypeRef v5 = cf;
  if (cf) {
    CFTypeRef v5 = CFRetain(cf);
  }
  uint64_t v6 = 0;
  *a2 = v5;
LABEL_6:
  MovieInformationUnlockForRead(*DerivedStorage);
  return v6;
}

uint64_t MovieCursor_stepInDecodeOrderAndReportStepsTaken(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*DerivedStorage);
  if (MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    unsigned int v6 = MovieSampleAccessorStepCursor(DerivedStorage[1], a2, a3);
    if (v6 == -12840) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v6;
    }
  }
  else
  {
    uint64_t v7 = FigSignalErrorAt();
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return v7;
}

uint64_t MovieCursor_stepInPresentationOrderAndReportStepsTaken(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  MovieInformationLockForRead(*DerivedStorage);
  if (!MovieTrackIsValid(*(void *)(DerivedStorage[1] + 8)))
  {
    uint64_t v10 = FigSignalErrorAt();
    goto LABEL_17;
  }
  if (a2 < 0)
  {
    uint64_t v6 = a2;
    while (1)
    {
      MovieSampleAccessorStepBackPTS(DerivedStorage[1]);
      if (v7) {
        break;
      }
      if (__CFADD__(v6++, 1)) {
        goto LABEL_13;
      }
    }
LABEL_14:
    uint64_t v10 = v7;
    if (v7 != -12840) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  if (a2)
  {
    uint64_t v6 = a2;
    do
    {
      MovieSampleAccessorStepFwdPTS(DerivedStorage[1]);
      if (v7) {
        goto LABEL_14;
      }
    }
    while (v6-- > 1);
  }
LABEL_13:
  uint64_t v6 = 0;
LABEL_15:
  uint64_t v10 = 0;
  if (a3) {
    *a3 = a2 - v6;
  }
LABEL_17:
  MovieInformationUnlockForRead(*DerivedStorage);
  return v10;
}

uint64_t MovieCursor_getDecodeToPresentationTimeDeltaRange(uint64_t a1, CMTime *a2, CMTime *a3)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  uint64_t v14 = 0;
  MovieInformationLockForRead(*DerivedStorage);
  uint64_t v6 = *(void *)(DerivedStorage[1] + 8);
  if (MovieTrackIsValid(v6))
  {
    MovieTrackGetCompositionOffsetRange(*(void **)DerivedStorage[1], v6, (_DWORD *)&v14 + 1, &v14);
    if (a2)
    {
      int64_t v7 = SHIDWORD(v14);
      int32_t MediaTimeScale = MovieTrackGetMediaTimeScale(v6);
      CMTimeMake(&v13, v7, MediaTimeScale);
      *a2 = v13;
    }
    if (a3)
    {
      int64_t v9 = (int)v14;
      int32_t v10 = MovieTrackGetMediaTimeScale(v6);
      CMTimeMake(&v13, v9, v10);
      uint64_t v11 = 0;
      *a3 = v13;
    }
    else
    {
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = FigSignalErrorAt();
  }
  MovieInformationUnlockForRead(*DerivedStorage);
  return v11;
}

void ReactToMovieMetadataChange(uint64_t a1, uint64_t a2, __CFDictionary *a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](DerivedStorage[10]);
  *((void *)&v6 + 1) = a2;
  *(void *)&long long v6 = a2 - 8;
  switch((unint64_t)(v6 >> 3))
  {
    case 0uLL:
      int64_t v7 = @"ISOUserDataReader";
      int64_t v9 = DerivedStorage + 13;
      CMTime v8 = (const void *)DerivedStorage[13];
      if (v8) {
        goto LABEL_3;
      }
      goto LABEL_4;
    case 1uLL:
      int64_t v7 = @"QuickTimeUserDataReader";
      int64_t v9 = DerivedStorage + 11;
      CMTime v8 = (const void *)DerivedStorage[11];
      if (!v8) {
        goto LABEL_4;
      }
      goto LABEL_3;
    case 3uLL:
      int64_t v7 = @"QuickTimeMetadataReader";
      int64_t v9 = DerivedStorage + 12;
      CMTime v8 = (const void *)DerivedStorage[12];
      if (!v8) {
        goto LABEL_4;
      }
      goto LABEL_3;
    case 7uLL:
      int64_t v7 = @"iTunesMetadataReader";
      int64_t v9 = DerivedStorage + 14;
      CMTime v8 = (const void *)DerivedStorage[14];
      if (!v8) {
        goto LABEL_4;
      }
LABEL_3:
      CFRelease(v8);
      *int64_t v9 = 0;
LABEL_4:
      MEMORY[0x19970E930](DerivedStorage[10]);
      if (v7)
      {
        int32_t v10 = (const void *)*MEMORY[0x1E4F1CFD0];
        CFDictionarySetValue(a3, v7, (const void *)*MEMORY[0x1E4F1CFD0]);
        CFDictionarySetValue(a3, @"MetadataReaderTypes", v10);
        CFDictionarySetValue(a3, @"MetadataReaders", v10);
      }
      return;
    default:
      JUMPOUT(0x19970E930);
  }
}

void ReactToTrackMetadataChange(uint64_t a1, uint64_t a2, __CFDictionary *a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E290](DerivedStorage[2]);
  if (a2 == 8)
  {
    long long v6 = @"ISOUserDataReader";
    CMTime v8 = DerivedStorage + 4;
    int64_t v7 = (const void *)DerivedStorage[4];
    if (!v7) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  if (a2 == 16)
  {
    long long v6 = @"QuickTimeUserDataReader";
    CMTime v8 = DerivedStorage + 3;
    int64_t v7 = (const void *)DerivedStorage[3];
    if (!v7) {
      goto LABEL_8;
    }
LABEL_7:
    CFRelease(v7);
    *CMTime v8 = 0;
    goto LABEL_8;
  }
  if (a2 != 32)
  {
    JUMPOUT(0x19970E2B0);
  }
  long long v6 = @"QuickTimeMetadataReader";
  CMTime v8 = DerivedStorage + 5;
  int64_t v7 = (const void *)DerivedStorage[5];
  if (v7) {
    goto LABEL_7;
  }
LABEL_8:
  MEMORY[0x19970E2B0](DerivedStorage[2]);
  if (v6)
  {
    int64_t v9 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionarySetValue(a3, v6, (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionarySetValue(a3, @"MetadataReaderTypes", v9);
    CFDictionarySetValue(a3, @"MetadataReaders", v9);
  }
}

uint64_t MoovIsParsingError(int a1)
{
  uint64_t result = 1;
  if (a1 <= -12720)
  {
    unsigned int v4 = a1 + 12896;
    if (v4 > 0x33 || ((1 << v4) & 0x900000000007FLL) == 0) {
      return 0;
    }
  }
  else
  {
    if (a1 <= -207)
    {
      unsigned int v3 = a1 + 12719;
      if (v3 <= 9 && ((1 << v3) & 0x23D) != 0) {
        return result;
      }
      return 0;
    }
    if (a1 > 560360819)
    {
      if (a1 == 560360820) {
        return result;
      }
      int v5 = 1718449215;
    }
    else
    {
      if (a1 == -206) {
        return result;
      }
      int v5 = 560226676;
    }
    if (a1 != v5) {
      return 0;
    }
  }
  return result;
}

uint64_t MoovParseByteStream(uint64_t a1, char a2, const void *a3, const void *a4)
{
  v24[1] = 0;
  v24[2] = 0;
  uint64_t v25 = 0;
  uint64_t result = MovieInformationSetByteStream(a1, a3);
  if (result) {
    return result;
  }
  MovieInformationSetAssetAnalysisReporter(a1, a4);
  v24[0] = a1;
  if ((a2 & 2) != 0)
  {
    BYTE1(v25) = 1;
    a2 |= 1u;
  }
  LOBYTE(v25) = (a2 & 1) == 0;
  *(unsigned char *)(a1 + 153) = (a2 & 0x20) != 0;
  *(unsigned char *)(a1 + 80) = (a2 & 0x40) != 0;
  if (a2 < 0) {
    BYTE3(v25) = 1;
  }
  memset(v23, 0, sizeof(v23));
  uint64_t result = FigAtomStreamInitWithByteStreamAndReporter();
  if (result) {
    return result;
  }
  uint64_t result = ParseChildAtoms((void *)a1, (uint64_t)v23, 4, (uint64_t)&MoovParseByteStream_atomDispatch, (uint64_t)v24);
  if (!*(unsigned char *)(a1 + 85))
  {
    if (!result)
    {
      _MovieAtomReportParsingMessage((void *)a1, 0, (uint64_t)v23, (uint64_t)"'moov' atom could not be parsed", 3);
      return FigSignalErrorAt();
    }
    return result;
  }
  MovieInformationCheckForMovieTimescaleAnomaly_7135294(a1);
  int NextTrackID = MovieInformationGetNextTrackID(a1);
  TrackCFIndex Count = MovieInformationGetTrackCount(a1);
  if (TrackCount < 1) {
    goto LABEL_32;
  }
  uint64_t v10 = TrackCount;
  CFArrayRef Mutable = 0;
  int v12 = 0;
  uint64_t v13 = 0;
  LODWORD(v22) = 0;
  LOWORD(valuePtr) = 0;
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    uint64_t TrackForTrackIndex = MovieInformationFindTrackForTrackIndex(a1, v13);
    MovieTrackGetBasicInfo(TrackForTrackIndex, 0, &v22);
    if (v22 == 0x7FFFFFFF) {
      int v16 = v12;
    }
    else {
      int v16 = 1;
    }
    if (v22 == 0x7FFFFFFF) {
      int v17 = NextTrackID;
    }
    else {
      int v17 = v22 + 1;
    }
    if ((int)v22 > NextTrackID)
    {
      int v12 = v16;
      int NextTrackID = v17;
    }
    int AlternateGroupID = MovieTrackGetAlternateGroupID(TrackForTrackIndex);
    LOWORD(valuePtr) = AlternateGroupID;
    if (AlternateGroupID)
    {
      if (MovieTrackIsEnabled(TrackForTrackIndex))
      {
        CFNumberRef v19 = CFNumberCreate(v14, kCFNumberSInt16Type, &valuePtr);
        if (v19)
        {
          CFNumberRef v20 = v19;
          if (Mutable)
          {
            v26.length = CFArrayGetCount(Mutable);
            v26.location = 0;
            if (CFArrayContainsValue(Mutable, v26, v20))
            {
              MovieTrackSetEnabled(TrackForTrackIndex, 0);
LABEL_26:
              CFRelease(v20);
              goto LABEL_27;
            }
          }
          else
          {
            CFArrayRef Mutable = CFArrayCreateMutable(v14, 0, MEMORY[0x1E4F1D510]);
            if (!Mutable) {
              goto LABEL_26;
            }
          }
          CFArrayAppendValue(Mutable, v20);
          goto LABEL_26;
        }
      }
    }
LABEL_27:
    MovieTrackCreateEnhancedGaplessInfo((void *)a1, TrackForTrackIndex);
    ++v13;
  }
  while (v10 != v13);
  if ((_BYTE)v12) {
    MovieInformationSetParsedNextTrackID(a1, NextTrackID);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_32:
  if ((a2 & 0x10) != 0
    && *(unsigned char *)(a1 + 154)
    && (valuePtr = 0, uint64_t v22 = 0, !FigAtomStreamGetCurrentAtomGlobalOffset()))
  {
    *(void *)(a1 + 144) = valuePtr + v22;
    *(unsigned char *)(a1 + 89) = 1;
    if ((a2 & 8) != 0) {
      return MovieInformationPerformPostParsingForHeaderWriting(a1);
    }
    return 0;
  }
  else
  {
    if ((a2 & 8) == 0) {
      return 0;
    }
    return MovieInformationPerformPostParsingForHeaderWriting(a1);
  }
}

uint64_t ParseFileTypeAtom_0(uint64_t a1, void **a2)
{
  unsigned int v3 = *a2;
  CMBlockBufferRef theBuffer = 0;
  uint64_t v9 = 0;
  dataPointerOut = 0;
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!CurrentAtomTypeAndDataLength)
  {
    _MovieAtomReportParsingMessage(v3, 0, a1, (uint64_t)"Incorrect 'ftyp' atom size", 1);
    CurrentAtomTypeAndDataunint64_t Length = FigSignalErrorAt();
  }
  uint64_t v6 = CurrentAtomTypeAndDataLength;
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return v6;
}

uint64_t ParseMovieAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a2;
  v13[1] = 0;
  CFTypeRef v14 = 0;
  int v12 = 0;
  v13[0] = (uint64_t *)a2;
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  uint64_t v5 = 0;
  if (!*(unsigned char *)(v4 + 85))
  {
    memset(v11, 0, sizeof(v11));
    if (!*(void *)(v4 + 56))
    {
      if (*(unsigned char *)(v4 + 80))
      {
        uint64_t BBuf = FigAtomStreamReadCurrentAtomAndCreateBBuf();
        if (BBuf) {
          goto LABEL_30;
        }
        uint64_t v5 = CMByteStreamCreateForBlockBuffer();
        if (v5) {
          goto LABEL_10;
        }
        *(void *)(v4 + 56) = 0;
        uint64_t BBuf = FigAtomStreamInitWithByteStream();
        if (BBuf) {
          goto LABEL_30;
        }
        uint64_t v8 = FigAtomStreamInitWithParent();
        if (v8) {
          return v8;
        }
LABEL_5:
        uint64_t v7 = ParseChildAtoms((void *)v4, (uint64_t)v11, 6, (uint64_t)&ParseMovieAtom_atomDispatch, (uint64_t)v13);
        if (v7)
        {
          uint64_t v5 = v7;
          _MovieAtomReportParsingMessage((void *)v4, 0, a1, (uint64_t)"while parsing", 6);
          goto LABEL_10;
        }
        if (*(unsigned char *)(v4 + 86))
        {
          if (!v14 || (uint64_t BBuf = ParseMovieExtendsAtomFromBBuf((uint64_t)v14, v13), !BBuf))
          {
            uint64_t v5 = 0;
            *(unsigned char *)(v4 + 85) = 1;
            goto LABEL_10;
          }
        }
        else
        {
          _MovieAtomReportParsingMessage((void *)v4, 0, a1, (uint64_t)"No movie header atom found", 3);
          uint64_t BBuf = FigSignalErrorAt();
        }
LABEL_30:
        uint64_t v5 = BBuf;
LABEL_10:
        if (v14) {
          CFRelease(v14);
        }
        goto LABEL_12;
      }
      CFTypeRef v10 = *(CFTypeRef *)(v4 + 48);
      if (v10) {
        CFTypeRef v10 = CFRetain(v10);
      }
      *(void *)(v4 + 56) = v10;
    }
    uint64_t BBuf = FigAtomStreamInitWithParent();
    if (BBuf) {
      goto LABEL_30;
    }
    goto LABEL_5;
  }
  _MovieAtomReportParsingMessage((void *)v4, 0, a1, (uint64_t)"File contains multiple 'moov' atoms", 3);
LABEL_12:
  if (!v5)
  {
    if (*(unsigned char *)(v4 + 154))
    {
      return 0;
    }
    else if (*(unsigned char *)(a2 + 26))
    {
      return 0;
    }
    else
    {
      return 1937010544;
    }
  }
  return v5;
}

uint64_t ParseMovieFragmentAtom(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  long long v12 = 0u;
  long long v13 = 0u;
  CFTypeRef v9 = 0;
  if (!*(unsigned char *)(v2 + 154)) {
    return 0;
  }
  int v11 = 0;
  uint64_t v10 = 0;
  memset(v8, 0, sizeof(v8));
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  uint64_t BBuf = FigAtomStreamReadCurrentAtomDataAndCreateBBuf();
  if (BBuf) {
    goto LABEL_13;
  }
  uint64_t BBuf = FigAtomStreamInitWithBBuf();
  if (BBuf) {
    goto LABEL_13;
  }
  if (*((unsigned char *)a2 + 8))
  {
    *((void *)&v12 + 1) = a2[2];
    goto LABEL_8;
  }
  uint64_t BBuf = FigAtomStreamGetCurrentAtomGlobalOffset();
  if (BBuf)
  {
LABEL_13:
    uint64_t v6 = BBuf;
    goto LABEL_10;
  }
LABEL_8:
  *(void *)&long long v12 = a2;
  *(void *)&long long v13 = a1;
  uint64_t v6 = ParseChildAtoms((void *)v2, (uint64_t)v8, 2, (uint64_t)&ParseMovieFragmentAtom_atomDispatch, (uint64_t)&v12);
  if (v6) {
    _MovieAtomReportParsingMessage((void *)v2, 0, a1, (uint64_t)"Encountered an error during parsing of movie fragment atom", 3);
  }
  else {
    *(unsigned char *)(v2 + 156) = 1;
  }
LABEL_10:
  if (v9) {
    CFRelease(v9);
  }
  return v6;
}

uint64_t ParseTopLevelMetaAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t ItemInformation = IFFParseMetaAtomStreamAndCreateItemInformation();
  if (ItemInformation) {
    return ItemInformation;
  }
  uint64_t v5 = MovieInformationSetParsedIFFItemInformation(v3, 0);
  if (!v5) {
    *(unsigned char *)(a2 + 26) = 0;
  }
  return v5;
}

uint64_t MoovParseMovieLevelAtom()
{
  uint64_t result = FigAtomStreamInitWithBBuf();
  if (!result)
  {
    FigAtomStreamGetCurrentAtomTypeAndDataLength();
    return 0;
  }
  return result;
}

uint64_t MoovParseIncrementalFragments(uint64_t a1, int *a2)
{
  v23[1] = 0;
  v23[2] = 0;
  uint64_t v24 = 0;
  uint64_t v22 = 0;
  if (!*(unsigned char *)(a1 + 89)) {
    goto LABEL_41;
  }
  if (!*(unsigned char *)(a1 + 154))
  {
    long long v18 = "Movie does not support fragments";
LABEL_40:
    _MovieAtomReportParsingMessage((void *)a1, 0, 0, (uint64_t)v18, 3);
LABEL_41:
    uint64_t result = FigSignalErrorAt();
LABEL_42:
    int v15 = 0;
    goto LABEL_31;
  }
  if (*(_DWORD *)(a1 + 184) == 2)
  {
    long long v18 = "Fragments were out of sequence";
    goto LABEL_40;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  int v21 = 0;
  uint64_t v20 = 0;
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, void, int *, void))(v6 + 8);
  if (v7) {
    v7(v4, 1, 0, &v21, 0);
  }
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v9 = *(void *)(a1 + 144);
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  long long v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(v11 + 24);
  if (!v12)
  {
    int v15 = 0;
    uint64_t result = 4294954514;
    goto LABEL_31;
  }
  uint64_t result = v12(v8, v9, &v22);
  if (result) {
    goto LABEL_42;
  }
  if (!v22)
  {
    uint64_t result = 0;
    goto LABEL_42;
  }
  uint64_t v14 = *(void *)(a1 + 144) + v22;
  if (v14 <= *(void *)(a1 + 72))
  {
    int v15 = 0;
  }
  else
  {
    *(void *)(a1 + 72) = v14;
    int v15 = 1;
  }
  v23[0] = a1;
  BYTE1(v24) = 1;
  while (1)
  {
    if (FigAtomUtilityGetAtomTypeAndLengthInByteStream() || (uint64_t v16 = v20, v17 = v22 - v20, v22 < v20))
    {
LABEL_30:
      uint64_t result = 0;
      goto LABEL_31;
    }
    if (v20 <= 0) {
      break;
    }
    if (v21 == 1836019558)
    {
      memset(v19, 0, sizeof(v19));
      uint64_t result = FigAtomStreamInitWithByteStream();
      if (result) {
        goto LABEL_31;
      }
      uint64_t result = ParseMovieFragmentAtom((uint64_t)v19, v23);
      if (result) {
        goto LABEL_31;
      }
      v15 |= 2u;
      uint64_t v16 = v20;
      uint64_t v17 = v22 - v20;
    }
    else if (v21 == 1836019574)
    {
      uint64_t result = 0;
      v15 |= 4u;
      *(_WORD *)(a1 + 89) = 256;
      goto LABEL_31;
    }
    uint64_t v22 = v17;
    *(void *)(a1 + 144) += v16;
    if (v17 <= 0) {
      goto LABEL_30;
    }
  }
  uint64_t result = FigSignalErrorAt();
LABEL_31:
  if (a2) {
    *a2 = v15;
  }
  if (result) {
    *(unsigned char *)(a1 + 89) = 0;
  }
  return result;
}

uint64_t MoovAssureSampleTableParsed(void *a1, uint64_t a2)
{
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  v14[0] = 0;
  v14[1] = 0;
  long long v12 = 0;
  uint64_t v13 = 0;
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  if (!a1[7]) {
    return 0;
  }
  memset(v9, 0, sizeof(v9));
  MEMORY[0x19970E290](*(void *)(a2 + 32));
  if (*(unsigned char *)(a2 + 718))
  {
    uint64_t v4 = FigAtomStreamInitWithByteStream();
    if (v4)
    {
      uint64_t v5 = v4;
      *(unsigned char *)(a2 + 718) = 0;
LABEL_13:
      *(_DWORD *)(a2 + 712) = v5;
      goto LABEL_14;
    }
    *(void *)&v10[0] = a1;
    v11[0] = v10;
    long long v12 = v11;
    uint64_t v13 = a2;
    v14[0] = &v12;
    uint64_t v16 = v14;
    uint64_t v17 = 0;
    memset(v18, 0, sizeof(v18));
    *(unsigned char *)(a2 + 718) = 0;
    CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
    if (!CurrentAtomTypeAndDataLength)
    {
      if (v17 < 1)
      {
LABEL_11:
        CurrentAtomTypeAndDataunint64_t Length = DoPostParsingSampleTableCommon(a1, a2);
        goto LABEL_12;
      }
      CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamInitWithParent();
      if (!CurrentAtomTypeAndDataLength)
      {
        uint64_t v7 = ParseChildAtoms(a1, (uint64_t)v18, 11, (uint64_t)&ParseSampleTableAtom_Phase2_atomDispatch, (uint64_t)&v15);
        if (v7)
        {
          uint64_t v5 = v7;
          _MovieAtomReportParsingMessage(a1, a2, (uint64_t)v9, (uint64_t)"while parsing", 5);
          goto LABEL_13;
        }
        goto LABEL_11;
      }
    }
LABEL_12:
    uint64_t v5 = CurrentAtomTypeAndDataLength;
    goto LABEL_13;
  }
  uint64_t v5 = *(unsigned int *)(a2 + 712);
LABEL_14:
  MEMORY[0x19970E2B0](*(void *)(a2 + 32));
  return v5;
}

uint64_t ParseMovieHeaderAtom(uint64_t a1, void ***a2)
{
  uint64_t v3 = **a2;
  int v18 = 0;
  uint64_t v17 = 0;
  char v16 = 0;
  int v15 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    uint64_t result = FigAtomStreamGetCurrentAtomVersionAndFlags();
    if (!result)
    {
      if (v16 == 1)
      {
        long long v11 = 0u;
        long long v12 = 0u;
        long long v9 = 0u;
        long long v10 = 0u;
        long long v7 = 0u;
        long long v8 = 0u;
        long long v6 = 0u;
        uint64_t v5 = "'mvhd' V1 atom data size less than minimum";
      }
      else
      {
        LODWORD(v12) = 0;
        long long v10 = 0u;
        long long v11 = 0u;
        long long v8 = 0u;
        long long v9 = 0u;
        long long v6 = 0u;
        long long v7 = 0u;
        uint64_t v5 = "'mvhd' V0 atom data size less than minimum";
      }
      _MovieAtomReportParsingMessage(v3, 0, a1, (uint64_t)v5, 3);
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t ParseTrackAtom(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = **a2;
  memset(v18, 0, sizeof(v18));
  CFTypeRef v16 = 0;
  CFTypeRef cf = 0;
  int v15 = a2;
  uint64_t started = FigAtomStreamInitWithParent();
  if (!started)
  {
    uint64_t started = MovieTrackCreate((uint64_t *)&cf);
    if (!started)
    {
      CFTypeRef v5 = cf;
      *((unsigned char *)cf + 736) = *(unsigned char *)(v3 + 153);
      CFTypeRef v16 = v5;
      uint64_t v6 = ParseChildAtoms((void *)v3, (uint64_t)v18, 11, (uint64_t)&ParseTrackAtom_atomDispatch, (uint64_t)&v15);
      if (v6)
      {
        uint64_t v7 = v6;
        if (!MoovIsParsingError(v6)) {
          goto LABEL_21;
        }
        _MovieAtomReportParsingMessage((void *)v3, (uint64_t)cf, 0, (uint64_t)"Omitting a track that encountered an error during atom parsing", 2);
        goto LABEL_6;
      }
      if (*(unsigned char *)(v3 + 81)) {
        BOOL v8 = *(unsigned char *)(v3 + 82) == 0;
      }
      else {
        BOOL v8 = *(unsigned char *)(v3 + 84) != 0;
      }
      MovieTrackEvaluateParsedLanguageCode((uint64_t)cf, v8);
      MovieTrackCreateEditSegmentArray(v3, (uint64_t)cf);
      MovieTrackEvaluateAlternateTrackGroupAssignment((uint64_t)cf);
      uint64_t started = MovieTrackInitializeLowestDisplayStartTimeAndHighestDisplayEndTime((void *)v3, (uint64_t)cf);
      if (!started)
      {
        if (*((unsigned char *)*a2 + 27))
        {
          CFTypeRef v9 = cf;
          if (!MovieTrackIsEnabled((uint64_t)cf)
            && MovieTrackGetMediaType((uint64_t)v9) == 1936684398)
          {
            CFArrayRef v10 = MovieTrackCopyFormatDescriptionArray((uint64_t)v9);
            if (v10)
            {
              CFArrayRef v11 = v10;
              if (CFArrayGetCount(v10) <= 0)
              {
                CFRelease(v11);
              }
              else
              {
                CFDictionaryRef ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(v11, 0);
                FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(ValueAtIndex);
                CFRelease(v11);
                if (MediaSubType == 1634754915)
                {
LABEL_6:
                  uint64_t v7 = 0;
                  goto LABEL_21;
                }
              }
            }
          }
        }
        uint64_t started = MovieInformationAddNewPerTrackInfo((void *)v3, cf);
      }
    }
  }
  uint64_t v7 = started;
LABEL_21:
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

uint64_t ParseMovieUserDataAtom(uint64_t a1, void **a2)
{
  uint64_t v4 = (void *)**a2;
  memset(v7, 0, sizeof(v7));
  uint64_t result = FigAtomStreamGetCurrentAtomGlobalOffset();
  if (!result)
  {
    uint64_t v6 = FigAtomStreamInitWithParent();
    if (!v6) {
      uint64_t v6 = ParseChildAtoms(v4, (uint64_t)v7, 1, (uint64_t)ParseMovieUserDataAtom_atomDispatch, (uint64_t)a2);
    }
    uint64_t result = 0;
    if (v6 != -12893)
    {
      if (v6)
      {
        _MovieAtomReportParsingMessage(v4, 0, a1, (uint64_t)"while parsing", 6);
        return v6;
      }
    }
  }
  return result;
}

uint64_t ParseMovieMetaDataAtom(uint64_t a1, void ***a2)
{
  uint64_t v3 = **a2;
  char v10 = 0;
  int v9 = 0;
  memset(v8, 0, sizeof(v8));
  int v7 = 0;
  FigAtomStreamGetCurrentAtomVersionAndFlags();
  uint64_t v4 = FigAtomStreamInitWithParent();
  if (!v4) {
    uint64_t v4 = ParseChildAtoms(v3, (uint64_t)v8, 1, (uint64_t)&ParseMovieMetaDataAtom_atomDispatch, (uint64_t)&v7);
  }
  if (v4 == -12893 || v4 == 0) {
    uint64_t v4 = 0;
  }
  else {
    _MovieAtomReportParsingMessage(v3, 0, a1, (uint64_t)"while parsing", 6);
  }
  if (v7 == 1835299937) {
    return FigAtomStreamGetCurrentAtomGlobalOffset();
  }
  return v4;
}

uint64_t ParseCompressedMovieAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)a2;
  memset(v7, 0, sizeof(v7));
  *(unsigned char *)(a2 + 9) = 1;
  *(unsigned char *)(v3 + 88) = 1;
  if (*(unsigned char *)(v3 + 86) || *(unsigned char *)(a2 + 8))
  {
    _MovieAtomReportParsingMessage((void *)v3, 0, a1, (uint64_t)"Can't have a compressed movie atom, if we already have a movie header atom or movie alias", 3);
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t result = FigAtomStreamInitWithParent();
    if (!result)
    {
      uint64_t result = ParseChildAtoms((void *)v3, (uint64_t)v7, 2, (uint64_t)&ParseCompressedMovieAtom_atomDispatch, a2);
      if (result)
      {
        uint64_t v6 = result;
        _MovieAtomReportParsingMessage((void *)v3, 0, a1, (uint64_t)"while parsing", 6);
        return v6;
      }
    }
  }
  return result;
}

uint64_t ParseMovieExtendsAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 16);
  uint64_t BBuf = FigAtomStreamReadCurrentAtomAndCreateBBuf();
  if (BBuf) {
    return BBuf;
  }
  if (!MovieInformationGetTrackCount(**(void **)a2)) {
    return 0;
  }
  uint64_t v5 = ParseMovieExtendsAtomFromBBuf(*(void *)(a2 + 16), (uint64_t **)a2);
  uint64_t v6 = *(const void **)(a2 + 16);
  if (v6)
  {
    CFRelease(v6);
    *uint64_t v3 = 0;
  }
  return v5;
}

uint64_t ParseMovieExtendsAtomFromBBuf(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = **a2;
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  uint64_t v4 = FigAtomStreamInitWithBBuf();
  if (v4) {
    return v4;
  }
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  uint64_t v4 = FigAtomStreamInitWithParent();
  if (v4) {
    return v4;
  }
  uint64_t v5 = ParseChildAtoms((void *)v3, (uint64_t)v8, 2, (uint64_t)&ParseMovieExtendsAtomFromBBuf_atomDispatch, (uint64_t)a2);
  if (v5)
  {
    uint64_t v6 = v5;
    _MovieAtomReportParsingMessage((void *)v3, 0, (uint64_t)v9, (uint64_t)"while parsing", 6);
  }
  else
  {
    *(unsigned char *)(v3 + 154) = 1;
    uint64_t v6 = 0;
    if (*((unsigned char *)*a2 + 25)) {
      *((unsigned char *)*a2 + 24) = 0;
    }
  }
  return v6;
}

uint64_t ParseTrackHeaderAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = ***(void ****)a2;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    uint64_t result = FigAtomStreamGetCurrentAtomVersionAndFlags();
    if (!result)
    {
      _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"'tkhd' V0 atom size less than minimum", 2);
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t ParseEditsAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = ***(void ****)a2;
  memset(v11, 0, sizeof(v11));
  int v10 = 0;
  v8[1] = v3;
  uint64_t v9 = 0;
  v8[0] = v4;
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (CurrentAtomTypeAndDataLength) {
    return CurrentAtomTypeAndDataLength;
  }
  *(_WORD *)(v3 + 721) = 257;
  if (v9 < 1) {
    return 0;
  }
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamInitWithParent();
  if (CurrentAtomTypeAndDataLength) {
    return CurrentAtomTypeAndDataLength;
  }
  uint64_t v6 = ParseChildAtoms(v4, (uint64_t)v11, 1, (uint64_t)&ParseEditsAtom_atomDispatch, (uint64_t)v8);
  if (v6) {
    _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"while parsing", 5);
  }
  return v6;
}

uint64_t ParseMediaAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = ***(void ****)a2;
  memset(v9, 0, sizeof(v9));
  v8[0] = a2;
  v8[1] = 0;
  uint64_t v5 = FigAtomStreamInitWithParent();
  if (v5) {
    return v5;
  }
  uint64_t v6 = ParseChildAtoms(v4, (uint64_t)v9, 4, (uint64_t)&ParseMediaAtom_atomDispatch, (uint64_t)v8);
  if (v6) {
    _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"while parsing", 5);
  }
  return v6;
}

uint64_t ParseTrackReferenceAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = ***(void ****)a2;
  int v14 = 0;
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v6 = 0u;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"'tref' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseTrackLoadSettingsAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = ***(void ****)a2;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"Incorrect 'load' atom size", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseTrackUserDataAtom(uint64_t a1, uint64_t ***a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  uint64_t v3 = ***a2;
  if (*(void *)(v3 + 56)) {
    return FigAtomStreamGetCurrentAtomGlobalOffset();
  }
  uint64_t result = FigAtomStreamReadCurrentAtomAndCreateBBuf();
  if (!result)
  {
    if (*(unsigned char *)(v3 + 81))
    {
      if (*(unsigned char *)(v3 + 82)) {
        return MovieTrackSupplementQuickTimeUserDataFromBlockBuffer((const void *)v3, v2, 0);
      }
    }
    else if (!*(unsigned char *)(v3 + 84))
    {
      return MovieTrackSupplementQuickTimeUserDataFromBlockBuffer((const void *)v3, v2, 0);
    }
    return MovieTrackSupplementISOUserDataFromBlockBuffer((const void *)v3, v2, 0);
  }
  return result;
}

uint64_t SaveTrackMetadataAtomLocation()
{
  return FigAtomStreamGetCurrentAtomGlobalOffset();
}

uint64_t ParseTrackExcludeFromAutoSelectionAtom(uint64_t a1, uint64_t a2)
{
  return MovieTrackSetExcludeFromAutoSelection(*(void *)(a2 + 8), 1);
}

uint64_t ParseTrackApertureModeDimensionsAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = ***(void ****)a2;
  memset(v9, 0, sizeof(v9));
  uint64_t v6 = FigAtomStreamInitWithParent();
  if (v6) {
    return v6;
  }
  uint64_t v7 = ParseChildAtoms(v5, (uint64_t)v9, 3, (uint64_t)&ParseTrackApertureModeDimensionsAtom_atomDispatch, a2);
  if (v7) {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"while parsing", 5);
  }
  return v7;
}

uint64_t ParseProvisionalTrackGroupAssignmentAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = ***(void ****)a2;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"Incorrect 'tgas' atom size", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseSampleEncryptionAtomInTrak(uint64_t a1, uint64_t a2)
{
  return 0;
}

void _MovieAtomReportParsingMessage(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a1[8])
  {
    CFAllocatorRef v10 = CFGetAllocator(a1);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v10, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      long long v12 = Mutable;
      CFAllocatorRef v13 = CFGetAllocator(a1);
      int v14 = CFStringCreateMutable(v13, 0);
      if (v14)
      {
        int v15 = v14;
        CFStringAppendFormat(v14, 0, @"%s.", a4);
        if (a3)
        {
          uint64_t v18 = 0;
          int v17 = 0;
          FigAtomStreamGetCurrentAtomGlobalOffset();
          FigAtomStreamGetCurrentAtomTypeAndDataLength();
          CFStringForOSTypeCFArrayRef Value = FigGetCFStringForOSTypeValue();
          CFStringAppendFormat(v15, 0, @" Atom: '%@' Offset: %lld", CFStringForOSTypeValue, 0);
          FigCFDictionarySetInt64();
          FigCFDictionarySetInt32();
        }
        if (a2)
        {
          int v17 = 0;
          LODWORD(v18) = 0;
          MovieTrackGetBasicInfo(a2, &v18, &v17);
          FigCFDictionarySetInt32();
          FigCFDictionarySetInt32();
        }
        FigCFDictionarySetInt64();
        CFDictionarySetValue(v12, (const void *)*MEMORY[0x1E4F1FAD0], v15);
        FigCFDictionarySetInt32();
        if (a5 == 6 || a5 == 5) {
          FigAssetAnalysisReporterEditAndAppendMessage();
        }
        else {
          FigAssetAnalysisReporterAddMessage();
        }
        CFRelease(v15);
      }
      CFRelease(v12);
    }
  }
}

uint64_t ParseEditListAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (CurrentAtomTypeAndDataLength)
  {
    uint64_t v6 = CurrentAtomTypeAndDataLength;
  }
  else
  {
    _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"'elst' atom size less than minimum", 2);
    uint64_t v6 = FigSignalErrorAt();
    if (!v6) {
      return v6;
    }
  }
  uint64_t v7 = *(const void **)(v3 + 696);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(v3 + 696) = 0;
  *(void *)(v3 + 704) = 0;
  return v6;
}

uint64_t ParseMediaHeaderAtom(uint64_t a1, void *****a2)
{
  uint64_t v3 = (uint64_t)(*a2)[1];
  uint64_t v4 = ****a2;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    uint64_t result = FigAtomStreamGetCurrentAtomVersionAndFlags();
    if (!result)
    {
      _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"'mdhd' V0 atom size less than minimum", 2);
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t ParseMediaHandlerAtom(uint64_t a1, uint64_t a2)
{
  uint64_t result = FigAtomStreamReadCurrentAtomData();
  if (!result)
  {
    uint64_t result = CheckAtomVersionIsZero_0();
    if (!result) {
      *(_DWORD *)(a2 + 8) = 0;
    }
  }
  return result;
}

uint64_t ParseMediaInfoAtom(long long *a1, _DWORD *a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = a2[2];
  int v5 = bswap32(v4);
  if (v5 <= 1885954931)
  {
    if (!v5)
    {
      long long v14 = a1[5];
      long long v41 = a1[4];
      long long v42 = v14;
      long long v43 = a1[6];
      long long v15 = a1[1];
      long long dataPointerOut = *a1;
      long long v38 = v15;
      long long v16 = a1[3];
      long long v39 = a1[2];
      long long v40 = v16;
      if (!FigAtomStreamAdvanceToNextAtomWithType())
      {
        uint64_t v17 = ParseMediaHandlerAtom((uint64_t)&dataPointerOut, (uint64_t)a2);
        if (v17) {
          return v17;
        }
      }
      unsigned int v4 = a2[2];
      goto LABEL_21;
    }
    int v6 = 1635088502;
LABEL_7:
    if (v5 == v6)
    {
LABEL_8:
      uint64_t v7 = *(CFArrayRef **)(*(void *)a2 + 8);
      uint64_t v8 = ****(void ****)a2;
      *((void *)&v35[0] + 1) = a2;
      long long dataPointerOut = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      *(void *)&v35[0] = v5;
      MovieTrackSetParsedTrackType((uint64_t)v7, v5);
      uint64_t v9 = FigAtomStreamInitWithParent();
      if (!v9)
      {
        uint64_t v10 = ParseChildAtoms((void *)v8, (uint64_t)&dataPointerOut, 3, (uint64_t)&ParseVideoMediaInfoAtom_atomDispatch, (uint64_t)v35);
        if (!v10)
        {
LABEL_23:
          uint64_t v18 = ConvertSampleDescriptionsToFormatDescriptions((void *)v8, v7);
          goto LABEL_24;
        }
LABEL_25:
        _MovieAtomReportParsingMessage((void *)v8, (uint64_t)v7, (uint64_t)a1, (uint64_t)"while parsing", 5);
        return v10;
      }
LABEL_55:
      uint64_t v10 = v9;
      goto LABEL_25;
    }
LABEL_21:
    uint64_t v7 = *(CFArrayRef **)(*(void *)a2 + 8);
    uint64_t v8 = ****(void ****)a2;
    *((void *)&v35[0] + 1) = a2;
    long long dataPointerOut = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    *(void *)&v35[0] = bswap32(v4);
    MovieTrackSetParsedTrackType((uint64_t)v7, v35[0]);
    uint64_t v9 = FigAtomStreamInitWithParent();
    if (!v9)
    {
      uint64_t v9 = ParseChildAtoms((void *)v8, (uint64_t)&dataPointerOut, 4, (uint64_t)&ParseMediaInfoAtomForGenericMedia_atomDispatch, (uint64_t)v35);
      if (!v9) {
        goto LABEL_23;
      }
    }
    goto LABEL_55;
  }
  if (v5 == 1885954932) {
    goto LABEL_8;
  }
  if (v5 != 1936684398)
  {
    int v6 = 1986618469;
    goto LABEL_7;
  }
  uint64_t v7 = *(CFArrayRef **)(*(void *)a2 + 8);
  uint64_t v8 = ****(void ****)a2;
  memset(v35, 0, sizeof(v35));
  v36[0] = 1936684398;
  v36[1] = a2;
  MovieTrackSetParsedTrackType((uint64_t)v7, 1936684398);
  uint64_t v9 = FigAtomStreamInitWithParent();
  if (v9) {
    goto LABEL_55;
  }
  uint64_t v10 = ParseChildAtoms((void *)v8, (uint64_t)v35, 3, (uint64_t)&ParseSoundMediaInfoAtom_atomDispatch, (uint64_t)v36);
  if (v10) {
    goto LABEL_25;
  }
  CFArrayRef v11 = v7[7];
  if (v11)
  {
    *(void *)&long long dataPointerOut = 0;
    if (CFArrayGetCount(v11) && (long long v12 = (CFIndex *)CFArrayGetValueAtIndex(v7[7], 0)) != 0 && v7[5]) {
      CFDictionaryRef ValueAtIndex = (OpaqueCMBlockBuffer *)CFArrayGetValueAtIndex(v7[5], *v12);
    }
    else {
      CFDictionaryRef ValueAtIndex = 0;
    }
    size_t lengthAtOffsetOut = 0;
    CMBlockBufferGetDataPointer(ValueAtIndex, 0, &lengthAtOffsetOut, 0, (char **)&dataPointerOut);
    if (lengthAtOffsetOut <= 0x23)
    {
      uint64_t v30 = "Invalid size for sound description";
    }
    else
    {
      if (*(_WORD *)(dataPointerOut + 16) || !*(unsigned char *)(v8 + 82) || !*(unsigned char *)(v8 + 84))
      {
        if (*(unsigned char *)(v8 + 81))
        {
          if (*(unsigned char *)(v8 + 82))
          {
LABEL_34:
            uint64_t v20 = (CMSoundDescriptionFlavor *)MEMORY[0x1E4F1F3C8];
            goto LABEL_39;
          }
        }
        else if (!*(unsigned char *)(v8 + 84))
        {
          goto LABEL_34;
        }
        uint64_t v20 = (CMSoundDescriptionFlavor *)MEMORY[0x1E4F1F3C0];
LABEL_39:
        int v21 = CMDoesBigEndianSoundDescriptionRequireLegacyCBRSampleTableLayout(ValueAtIndex, *v20);
        MovieTrackSetSampleOverrides((uint64_t)v7, 0, 0);
        uint64_t v9 = ConvertSampleDescriptionsToFormatDescriptions((void *)v8, v7);
        if (v9) {
          goto LABEL_55;
        }
        if (v21)
        {
          Firstuint64_t FormatDescription = (const opaqueCMFormatDescription *)GetFirstFormatDescription((uint64_t)v7);
          if (FirstFormatDescription)
          {
            StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(FirstFormatDescription);
            MovieTrackSetSampleOverrides((uint64_t)v7, StreamBasicDescription->mBytesPerPacket, StreamBasicDescription->mFramesPerPacket);
          }
          return 0;
        }
        goto LABEL_43;
      }
      uint64_t v30 = "V0 sound description in file with QT ftyp and ISO file extension";
    }
    uint64_t v31 = (void *)v8;
    uint64_t v32 = (uint64_t)v7;
    uint64_t v33 = (uint64_t)a1;
    goto LABEL_54;
  }
  uint64_t v9 = ConvertSampleDescriptionsToFormatDescriptions((void *)v8, v7);
  if (v9) {
    goto LABEL_55;
  }
LABEL_43:
  uint64_t v24 = (const opaqueCMFormatDescription *)GetFirstFormatDescription((uint64_t)v7);
  if (!v24) {
    return 0;
  }
  uint64_t v25 = CMAudioFormatDescriptionGetStreamBasicDescription(v24);
  AudioFormatID mFormatID = v25->mFormatID;
  if (mFormatID == 1634492791 || mFormatID == 1970037111) {
    return 0;
  }
  int v28 = v25;
  if (!v25->mBytesPerPacket) {
    return 0;
  }
  int CommonSampleSize = MovieSampleTableGetCommonSampleSize((uint64_t)v7);
  if (!CommonSampleSize || v28->mBytesPerPacket == CommonSampleSize) {
    return 0;
  }
  snprintf((char *)&dataPointerOut, 0x100uLL, "ASBD mBytesPerPacket %d expected to match common sample size %d from the sample table", v28->mBytesPerPacket, CommonSampleSize);
  _MovieAtomReportParsingMessage((void *)v8, (uint64_t)v7, (uint64_t)a1, (uint64_t)&dataPointerOut, 5);
  uint64_t v30 = "ASBD mBytesPerPacket does not match the common sample size";
  uint64_t v31 = (void *)v8;
  uint64_t v32 = (uint64_t)v7;
  uint64_t v33 = 0;
LABEL_54:
  _MovieAtomReportParsingMessage(v31, v32, v33, (uint64_t)v30, 2);
  uint64_t v18 = FigSignalErrorAt();
LABEL_24:
  uint64_t v10 = v18;
  if (v18) {
    goto LABEL_25;
  }
  return v10;
}

uint64_t ParseExtendedLanguageTagAtom()
{
  int v7 = 0;
  uint64_t v6 = 0;
  char v5 = 0;
  int v4 = 0;
  CMBlockBufferRef theBuffer = 0;
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (CurrentAtomTypeAndDataLength) {
    return CurrentAtomTypeAndDataLength;
  }
  FigAtomStreamGetCurrentAtomVersionAndFlags();
  return 0;
}

uint64_t ParseVideoMediaInfoHeaderAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(**(void **)(a2 + 8) + 8);
  int v4 = *****(void ******)(a2 + 8);
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!CurrentAtomTypeAndDataLength)
  {
    _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"Unexpected size for 'vmhd' atom", 2);
    return (__int16)FigSignalErrorAt();
  }
  return CurrentAtomTypeAndDataLength;
}

uint64_t ParseDataInfoAtom(uint64_t a1, uint64_t a2)
{
  int v4 = *****(void ******)(a2 + 8);
  memset(v8, 0, sizeof(v8));
  uint64_t v5 = FigAtomStreamInitWithParent();
  if (v5) {
    return v5;
  }
  uint64_t v6 = ParseChildAtoms(v4, (uint64_t)v8, 1, (uint64_t)ParseDataInfoAtom_atomDispatch, a2);
  if (v6) {
    _MovieAtomReportParsingMessage(v4, 0, a1, (uint64_t)"while parsing", 5);
  }
  return v6;
}

uint64_t ParseSampleTableAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = **(uint64_t ****)(a2 + 8);
  uint64_t v3 = (uint64_t)v2[1];
  uint64_t v4 = **v2;
  uint64_t v5 = *(void **)v4;
  if (!*(unsigned char *)(v4 + 24))
  {
    CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
    if (CurrentAtomTypeAndDataLength) {
      goto LABEL_7;
    }
    uint64_t v6 = DoPostParsingSampleTableCommon(v5, v3);
LABEL_6:
    CurrentAtomTypeAndDataunint64_t Length = v6;
    goto LABEL_7;
  }
  FigAtomStreamGetCurrentAtomGlobalOffset();
  uint64_t v6 = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (v6) {
    goto LABEL_6;
  }
  CurrentAtomTypeAndDataunint64_t Length = 0;
  *(unsigned char *)(v3 + 718) = 1;
LABEL_7:
  *(_DWORD *)(v3 + 712) = CurrentAtomTypeAndDataLength;
  return CurrentAtomTypeAndDataLength;
}

uint64_t ParseDataRefAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!CurrentAtomTypeAndDataLength)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'dref' atom size less than minimum", 2);
    CurrentAtomTypeAndDataunint64_t Length = FigSignalErrorAt();
  }
  uint64_t v7 = CurrentAtomTypeAndDataLength;
  if (CurrentAtomTypeAndDataLength) {
    ReleaseDataReferenceInfoArray(v4);
  }
  return v7;
}

uint64_t ParseSampleDescriptionAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t v20 = 0;
  int v19 = 0;
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v11 = 0u;
  CFTypeRef cf = 0;
  char v9 = 0;
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (CurrentAtomTypeAndDataLength)
  {
    uint64_t v7 = CurrentAtomTypeAndDataLength;
  }
  else
  {
    FigAtomStreamGetCurrentAtomGlobalOffset();
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'stsd' atom size less than minimum", 2);
    uint64_t v7 = FigSignalErrorAt();
    if (!v7) {
      goto LABEL_4;
    }
  }
  ReleaseSampleDescriptionInfoArray(v4);
LABEL_4:
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

uint64_t ParseSampleGroupDescriptionAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void **)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  int v23 = 0;
  CMBlockBufferRef sourceBuffer = 0;
  unint64_t v22 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  unsigned __int8 v19 = 0;
  CFTypeRef cf = 0;
  int v17 = 0;
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (CurrentAtomTypeAndDataLength) {
    goto LABEL_21;
  }
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomVersionAndFlags();
  if (CurrentAtomTypeAndDataLength) {
    goto LABEL_21;
  }
  if (v19 >= 3u)
  {
    long long v14 = "Only support V0, V1 or V2 'sgpd' atoms";
    goto LABEL_30;
  }
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamReadCurrentAtomDataAndCreateBBuf();
  if (CurrentAtomTypeAndDataLength) {
    goto LABEL_21;
  }
  CurrentAtomTypeAndDataunint64_t Length = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E4F1CF80], sourceBuffer, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, 2u, &blockBufferOut);
  if (CurrentAtomTypeAndDataLength) {
    goto LABEL_21;
  }
  if (v19 == 1)
  {
    long long v16 = 0;
    if (v22 < 0x10)
    {
      long long v15 = "V1 'sgpd' atom size less than minimum";
      goto LABEL_37;
    }
    CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v16);
    int v7 = bswap32(*((_DWORD *)v16 + 1));
    int v9 = bswap32(*((_DWORD *)v16 + 3));
    int v8 = bswap32(*((_DWORD *)v16 + 2));
    uint64_t v10 = v16 + 16;
    unint64_t v11 = v22 - 16;
  }
  else
  {
    long long v16 = 0;
    if (v22 <= 0xB)
    {
      long long v15 = "V0 'sgpd' atom size less than minimum";
      goto LABEL_37;
    }
    CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v16);
    int v7 = bswap32(*((_DWORD *)v16 + 1));
    int v8 = 2;
    if (v7 != 1886547820 && v7 != 1919904876)
    {
      if (v7 != 1936023917)
      {
        long long v14 = "V0 'sgpd' atom has group description with unknown entry lengths";
        goto LABEL_30;
      }
      int v8 = 16;
    }
    int v9 = bswap32(*((_DWORD *)v16 + 2));
    uint64_t v10 = v16 + 12;
    unint64_t v11 = v22 - 12;
  }
  if (v9 < 0)
  {
    long long v14 = "Negative number of sample group description entries";
  }
  else
  {
    if ((v8 & 0x80000000) == 0)
    {
      CurrentAtomTypeAndDataunint64_t Length = MovieTrackAddAndRetainSampleGroupDescriptionArray(v4, v7, &cf);
      if (CurrentAtomTypeAndDataLength) {
        goto LABEL_21;
      }
      CurrentAtomTypeAndDataunint64_t Length = MovieSampleGroupDescriptionArrayCopyInfo((uint64_t)cf, 0, 0, &v17, 0, 0);
      if (CurrentAtomTypeAndDataLength) {
        goto LABEL_21;
      }
      if (!v17)
      {
        CurrentAtomTypeAndDataunint64_t Length = CommonSampleGroupDescriptionEntryParse(v5, (uint64_t)v4, (unsigned int *)v10, v9, v8, 0, v11, (uint64_t)cf);
LABEL_21:
        uint64_t v12 = CurrentAtomTypeAndDataLength;
        goto LABEL_22;
      }
      long long v15 = "Parsing a second 'sgpd' for the same groupType";
LABEL_37:
      _MovieAtomReportParsingMessage(v5, (uint64_t)v4, a1, (uint64_t)v15, 2);
      CurrentAtomTypeAndDataunint64_t Length = FigSignalErrorAt();
      goto LABEL_21;
    }
    long long v14 = "Negative default entry length";
  }
LABEL_30:
  _MovieAtomReportParsingMessage(v5, (uint64_t)v4, a1, (uint64_t)v14, 2);
  FigSignalErrorAt();
  uint64_t v12 = 0;
LABEL_22:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  if (sourceBuffer) {
    CFRelease(sourceBuffer);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v12;
}

uint64_t ParseSampleToGroupAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void **)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  int v14 = 0;
  unsigned int v13 = 0;
  CMBlockBufferRef v11 = 0;
  unint64_t v12 = 0;
  CFTypeRef cf = 0;
  Arrayuint64_t BBuf = CommonSampleToGroupAtomParseAndCreateArrayBBuf(v5, (uint64_t)v4, a1);
  if (!ArrayBBuf)
  {
    Arrayuint64_t BBuf = MovieTrackAddAndRetainSampleGroup(v4, v12, v13, &cf);
    if (!ArrayBBuf)
    {
      CMBlockBufferRef v7 = v11;
      uint64_t v8 = MovieSampleGroupSet_sbgp((uint64_t)cf, v14, v11);
      if (!v7) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  uint64_t v8 = ArrayBBuf;
  CMBlockBufferRef v7 = v11;
  if (v11) {
LABEL_4:
  }
    CFRelease(v7);
LABEL_5:
  if (cf) {
    CFRelease(cf);
  }
  return v8;
}

uint64_t ParseMOVCompactSampleToGroupAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = **(void **)(a2 + 8);
  uint64_t v3 = *(void **)(v2 + 8);
  uint64_t v4 = ***(void ****)v2;
  unsigned int v15 = 0;
  CFTypeRef cf = 0;
  unint64_t v14 = 0;
  CFTypeRef v11 = 0;
  unint64_t v12 = 0;
  v9[0] = 0;
  v9[1] = 0;
  int v10 = 0;
  Arrayuint64_t BBuf = CommonMOVCompactSampleToGroupAtomParseAndCreateArrayBBuf(v4, (uint64_t)v3, a1);
  if (!ArrayBBuf)
  {
    Arrayuint64_t BBuf = MovieTrackAddAndRetainSampleGroup(v3, v14, v15, &v11);
    if (!ArrayBBuf)
    {
      uint64_t v6 = v12;
      uint64_t v7 = MovieSampleGroupSet_csgp((CMBlockBufferRef *)v11, v9, (CMBlockBufferRef)cf, v12);
      if (!v6) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  uint64_t v7 = ArrayBBuf;
  uint64_t v6 = v12;
  if (v12) {
LABEL_4:
  }
    CFRelease(v6);
LABEL_5:
  if (cf) {
    CFRelease(cf);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v7;
}

uint64_t ParseTimeToSampleNumAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'stts' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseSyncSampleAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'stss' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseSampleToChunkAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'stsc' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseSampleSizeAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'stsz' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseCompactSampleSizeAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'stz2' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseChunkOffsetAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'stco' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseChunkOffset64Atom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'co64' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseCompositionOffsetAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'ctts' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParsePartialSyncSampleAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'stps' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseSampleDependencyAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(**(void **)(a2 + 8) + 8);
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (CurrentAtomTypeAndDataLength) {
    return CurrentAtomTypeAndDataLength;
  }
  CurrentAtomTypeAndDataunint64_t Length = CheckAtomVersionIsZero_0();
  if (CurrentAtomTypeAndDataLength) {
    return CurrentAtomTypeAndDataLength;
  }
  uint64_t BBuf = FigAtomStreamReadCurrentAtomDataAndCreateBBuf();
  if (!BBuf)
  {
    Dataunint64_t Length = CMBlockBufferGetDataLength(0);
    return MovieSampleTableSet_sdtp(v2, DataLength, 0);
  }
  return BBuf;
}

uint64_t ParseCompositionShiftLeastGreatestAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = ***(void ****)v3;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'cslg' atom size less than minimum", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t CommonSampleGroupDescriptionEntryParse(void *a1, uint64_t a2, unsigned int *a3, int a4, int a5, unsigned int a6, unint64_t a7, uint64_t a8)
{
  int v11 = a4;
  if (!a5)
  {
    if (a4 >= 1)
    {
      unint64_t v17 = 0;
      while (1)
      {
        if (v17 + 4 > a7)
        {
LABEL_22:
          unint64_t v22 = "Atom too short to hold description length";
          goto LABEL_23;
        }
        unsigned int v18 = *a3;
        CFIndex v19 = bswap32(*a3);
        if ((v19 & 0x80000000) != 0) {
          break;
        }
        v17 += 4 + v19;
        if (v17 > a7) {
          goto LABEL_22;
        }
        uint64_t v20 = (const UInt8 *)(a3 + 1);
        if (v18) {
          int v21 = v20;
        }
        else {
          int v21 = 0;
        }
        uint64_t result = MovieSampleGroupDescriptionArrayAppendParsedDescription(a8, v19, v21);
        if (result) {
          return result;
        }
        a3 = (unsigned int *)&v20[v19];
        if (!--v11) {
          goto LABEL_18;
        }
      }
      _MovieAtomReportParsingMessage(a1, a2, 0, (uint64_t)"Invalid sample group description length", 2);
      FigSignalErrorAt();
      return 0;
    }
LABEL_18:
    if (a6)
    {
      return MovieSampleGroupDescriptionArraySetDefaultDescriptionIndex(a8, a6);
    }
    return 0;
  }
  if (a5 * (uint64_t)a4 <= (uint64_t)a7)
  {
    if (a4 >= 1)
    {
      CFIndex v15 = a5;
      while (1)
      {
        uint64_t result = MovieSampleGroupDescriptionArrayAppendParsedDescription(a8, v15, (const UInt8 *)a3);
        if (result) {
          return result;
        }
        a3 = (unsigned int *)((char *)a3 + v15);
        if (!--v11) {
          goto LABEL_18;
        }
      }
    }
    goto LABEL_18;
  }
  unint64_t v22 = "Entry length and count inconsistent with atom data size";
LABEL_23:
  _MovieAtomReportParsingMessage(a1, a2, 0, (uint64_t)v22, 2);

  return FigSignalErrorAt();
}

uint64_t CommonSampleToGroupAtomParseAndCreateArrayBBuf(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    uint64_t result = FigAtomStreamGetCurrentAtomVersionAndFlags();
    if (!result)
    {
      _MovieAtomReportParsingMessage(a1, a2, a3, (uint64_t)"'sbgp' V0 atom size less than minimum", 2);
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t CommonMOVCompactSampleToGroupAtomParseAndCreateArrayBBuf(void *a1, uint64_t a2, uint64_t a3)
{
  int v18 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v17 = 0;
  CMBlockBufferRef sourceBuffer = 0;
  CFTypeRef cf = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  *(void *)((char *)v13 + 6) = 0;
  v13[0] = 0;
  char v10 = 0;
  int v9 = 0;
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!CurrentAtomTypeAndDataLength)
  {
    CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomVersionAndFlags();
    if (!CurrentAtomTypeAndDataLength)
    {
      _MovieAtomReportParsingMessage(a1, a2, a3, (uint64_t)"'csgm' atom size less than minimum", 2);
      CurrentAtomTypeAndDataunint64_t Length = FigSignalErrorAt();
    }
  }
  uint64_t v7 = CurrentAtomTypeAndDataLength;
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  if (sourceBuffer) {
    CFRelease(sourceBuffer);
  }
  return v7;
}

uint64_t NoteThatCompositionOffsetAtomExists(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(**(void **)(a2 + 8) + 8) + 720) = 1;
  return 0;
}

uint64_t ParseSoundMediaInfoHeaderAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(**(void **)(a2 + 8) + 8);
  uint64_t v4 = *****(void ******)(a2 + 8);
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"Unexpected size for 'smhd' atom", 2);
    return FigSignalErrorAt();
  }
  return result;
}

const void *GetFirstFormatDescription(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 56);
  if (!v2) {
    return 0;
  }
  if (!CFArrayGetCount(v2)) {
    return 0;
  }
  CFDictionaryRef ValueAtIndex = (CFIndex *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), 0);
  if (!ValueAtIndex || !*(void *)(a1 + 48)) {
    return 0;
  }
  CFIndex v4 = *ValueAtIndex;
  CFArrayRef v5 = *(const __CFArray **)(a1 + 48);

  return CFArrayGetValueAtIndex(v5, v4);
}

uint64_t ParseGenericMediaInfoHeaderAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)(a2 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  CFArrayRef v5 = ***(void ****)v3;
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  _MovieAtomReportParsingMessage(v5, v4, a1, (uint64_t)"'gmhd' atom size too small", 2);
  return FigSignalErrorAt();
}

uint64_t ParseGenericMediaInfoAtom()
{
  return 0;
}

uint64_t ParseTimeCodeMediaHeaderAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = **(void **)(a2 + 8);
  uint64_t v5 = *(void *)(v4 + 8);
  uint64_t v6 = ***(void ****)v4;
  int v12 = 0;
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  uint64_t v7 = FigAtomStreamInitWithParent();
  if (v7) {
    return v7;
  }
  uint64_t v8 = ParseChildAtoms(v6, (uint64_t)v10, 1, (uint64_t)&ParseTimeCodeMediaHeaderAtom_atomDispatch, a2);
  if (v8) {
    _MovieAtomReportParsingMessage(v6, v5, a1, (uint64_t)"while parsing", 5);
  }
  return v8;
}

uint64_t ParseTimeCodeMediaInfoAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(**(void **)(a2 + 8) + 8);
  uint64_t v4 = *****(void ******)(a2 + 8);
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"Incorrect 'tcmi' atom size", 2);
  uint64_t CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomVersionAndFlags();
  if (!CurrentAtomVersionAndFlags) {
    MovieTrackSetTimecodeSpecifics(v3, 0);
  }
  return CurrentAtomVersionAndFlags;
}

uint64_t ParseTrackCleanApertureDimensionsAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    uint64_t result = FigAtomStreamReadCurrentAtomData();
    if (!result)
    {
      uint64_t result = FigAtomStreamReadCurrentAtomData();
      if (!result) {
        return MovieTrackSetCleanApertureDimensions(v2, (float)(int)bswap32(0) * 0.000015259, (float)(int)bswap32(0) * 0.000015259);
      }
    }
  }
  return result;
}

uint64_t ParseTrackProductionApertureDimensionsAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    uint64_t result = FigAtomStreamReadCurrentAtomData();
    if (!result)
    {
      uint64_t result = FigAtomStreamReadCurrentAtomData();
      if (!result) {
        return MovieTrackSetProductionApertureDimensions(v2, (float)(int)bswap32(0) * 0.000015259, (float)(int)bswap32(0) * 0.000015259);
      }
    }
  }
  return result;
}

uint64_t ParseTrackEncodedPixelsDimensionsAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    uint64_t result = FigAtomStreamReadCurrentAtomData();
    if (!result)
    {
      uint64_t result = FigAtomStreamReadCurrentAtomData();
      if (!result) {
        return MovieTrackSetEncodedPixelsDimensions(v2, (float)(int)bswap32(0) * 0.000015259, (float)(int)bswap32(0) * 0.000015259);
      }
    }
  }
  return result;
}

uint64_t SaveiTunesMetaDataAtomLocation(uint64_t a1, uint64_t a2)
{
  if (*(uint64_t *)(**(void **)a2 + 136) <= 0) {
    return FigAtomStreamGetCurrentAtomGlobalOffset();
  }
  else {
    return 0;
  }
}

uint64_t ParseMetaDataHandlerAtom(uint64_t a1, _DWORD *a2)
{
  uint64_t result = FigAtomStreamReadCurrentAtomData();
  if (!result) {
    *a2 = bswap32(0);
  }
  return result;
}

uint64_t ParseDataCompressionAtom(uint64_t a1, uint64_t a2)
{
  uint64_t result = FigAtomStreamReadCurrentAtomData();
  *(_DWORD *)(a2 + 12) = bswap32(0);
  return result;
}

uint64_t ParseCompressedMovieDataAtom(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void **)*a2;
  CMBlockBufferRef blockBufferOut = 0;
  CMBlockBufferRef theBuffer = 0;
  long long dataPointerOut = 0;
  size_t totalLengthOut = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  memset(v15, 0, sizeof(v15));
  if (*((_DWORD *)a2 + 3) != 2053925218) {
    goto LABEL_33;
  }
  uint64_t BBuf = FigAtomStreamReadCurrentAtomDataAndCreateBBuf();
  if (BBuf) {
    goto LABEL_24;
  }
  CMBlockBufferGetDataPointer(theBuffer, 0, 0, &totalLengthOut, &dataPointerOut);
  if (totalLengthOut <= 3)
  {
    _MovieAtomReportParsingMessage(v2, 0, a1, (uint64_t)"'cmvd' atom data size less than minimum", 3);
LABEL_33:
    uint64_t BBuf = FigSignalErrorAt();
    goto LABEL_24;
  }
  size_t v6 = bswap32(*(_DWORD *)dataPointerOut);
  if ((int)v6 < 1)
  {
LABEL_30:
    uint64_t v11 = 0;
    goto LABEL_25;
  }
  uint64_t BBuf = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v6, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, v6, 1u, &blockBufferOut);
  if (BBuf)
  {
LABEL_24:
    uint64_t v11 = BBuf;
    goto LABEL_25;
  }
  CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v17);
  uint64_t v7 = dataPointerOut + 4;
  int v9 = totalLengthOut - 4;
  BOOL v8 = totalLengthOut == 4;
  dataPointerOut += 4;
  totalLengthOut -= 4;
  if (v8) {
    goto LABEL_30;
  }
  char v10 = v17;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  MEMORY[0x19970EE10](&gFigInitInflatorLibOnce_0, InitInflatorLibrary_0);
  if (!s_inflateInit__0 || !s_inflate_0 || !s_inflateEnd_0)
  {
    uint64_t v11 = 0xFFFFFFFFLL;
    goto LABEL_25;
  }
  if (s_inflateInit__0(&v22, "1.2.12", 112))
  {
    uint64_t v12 = FigSignalErrorAt();
    uint64_t v11 = v12;
    if (v12) {
      goto LABEL_25;
    }
    goto LABEL_19;
  }
  *(void *)&long long v22 = v7;
  DWORD2(v22) = v9;
  *(void *)&long long v23 = 0;
  *((void *)&v23 + 1) = v10;
  LODWORD(v24) = v6;
  *((void *)&v24 + 1) = 0;
  if (s_inflate_0(&v22, 4) == 1) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = FigSignalErrorAt();
  }
  s_inflateEnd_0(&v22);
  if (!v11)
  {
LABEL_19:
    uint64_t BBuf = CMByteStreamCreateForBlockBuffer();
    if (!BBuf)
    {
      unsigned int v13 = (const void *)v2[7];
      if (v13) {
        CFRelease(v13);
      }
      v2[7] = v16;
      uint64_t BBuf = FigAtomStreamInitWithByteStream();
      if (!BBuf) {
        uint64_t BBuf = ParseMovieAtom((uint64_t)v15, *a2);
      }
    }
    goto LABEL_24;
  }
LABEL_25:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v11;
}

void *InitInflatorLibrary_0()
{
  uint64_t result = dlopen("/usr/lib/libz.dylib", 6);
  if (result)
  {
    uint64_t v1 = result;
    s_inflateInit__0 = dlsym(result, "inflateInit_");
    s_inflate_0 = dlsym(v1, "inflate");
    uint64_t result = dlsym(v1, "inflateEnd");
    s_inflateEnd_0 = result;
  }
  return result;
}

uint64_t ParseMovieExtendsHeaderAtom(uint64_t a1, uint64_t **a2)
{
  uint64_t v2 = **a2;
  char v10 = 0;
  uint64_t v9 = 0;
  uint64_t v8 = 0;
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  uint64_t CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomVersionAndFlags();
  if (CurrentAtomVersionAndFlags) {
    return CurrentAtomVersionAndFlags;
  }
  if (v10 == 1)
  {
    uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData();
    if (!CurrentAtomData)
    {
      int64_t v5 = bswap64(0);
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData();
    if (!CurrentAtomData)
    {
      int64_t v5 = bswap32(0);
LABEL_7:
      CMTimeMake(&v7, v5, *(_DWORD *)(v2 + 240));
      *(CMTime *)(v2 + 160) = v7;
      *(unsigned char *)(v2 + 155) = 1;
    }
  }
  return CurrentAtomData;
}

_DWORD *ParseTrackExtendsAtom(uint64_t a1, uint64_t **a2)
{
  uint64_t v2 = **a2;
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  uint64_t result = (_DWORD *)FigAtomStreamGetCurrentAtomVersionAndFlags();
  if (!result)
  {
    uint64_t result = (_DWORD *)FigAtomStreamReadCurrentAtomData();
    if (!result)
    {
      uint64_t result = (_DWORD *)MovieInformationFindTrackForTrackID(v2, bswap32(0));
      if (result)
      {
        uint64_t v4 = result;
        int v5 = bswap32(0);
        uint64_t result = (_DWORD *)MovieTrackSetTrackExtendsDefaultValues(result, v5, v5, v5, v5);
        if (!result)
        {
          if (*((void *)v4 + 91))
          {
            return 0;
          }
          else
          {
            size_t v6 = malloc_type_calloc(1uLL, 0x40uLL, 0x10200407FA1957DuLL);
            *((void *)v4 + 91) = v6;
            if (v6)
            {
              CMTime v7 = v6;
              uint64_t result = 0;
              v7[10] = v5;
              v7[11] = v5;
              v7[12] = v5;
              v7[13] = v5;
              *((_OWORD *)v7 + 1) = xmmword_1949983B0;
              *((void *)v7 + 4) = 0x7FFFFFFF80000000;
            }
            else
            {
              return (_DWORD *)FigSignalErrorAt();
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t ParseMovieFragmentHeaderAtom(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = **a2;
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData();
  if (CurrentAtomData) {
    return CurrentAtomData;
  }
  int v5 = bswap32(0);
  int v6 = *(_DWORD *)(v3 + 184);
  switch(v6)
  {
    case 2:
      return 1937010544;
    case 1:
      if (v5 != *(_DWORD *)(v3 + 188) + 1)
      {
        uint64_t v7 = 1937010544;
        _MovieAtomReportParsingMessage((void *)v3, 0, a1, (uint64_t)"Movie fragment sequence number out of sequence. This and subsequent fragments ignored", 3);
        *(_DWORD *)(v3 + 184) = 2;
        return v7;
      }
      MovieInformationUpdateLastParsedFragmentSequenceNumber(v3, v5);
      break;
    case 0:
      MovieInformationEstablishFirstParsedFragmentSequenceNumber(v3, v5);
      break;
  }
  return 0;
}

uint64_t ParseTrackFragmentAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = **(void **)a2;
  uint64_t v59 = 0;
  long long v58 = 0u;
  long long v57 = 0u;
  int v55 = 0;
  uint64_t v54 = 0;
  memset(v53, 0, sizeof(v53));
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  uint64_t v5 = FigAtomStreamInitWithParent();
  if (v5) {
    return v5;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v56 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 16);
  *(void *)&long long v58 = v6;
  *((void *)&v58 + 1) = v7;
  LOBYTE(v59) = *(unsigned char *)(a2 + 24);
  uint64_t v8 = ParseChildAtoms((void *)v4, (uint64_t)v53, 12, (uint64_t)&ParseTrackFragmentAtom_atomDispatch, (uint64_t)&v56);
  if (v8) {
    _MovieAtomReportParsingMessage((void *)v4, v57, a1, (uint64_t)"Encountered an error during parsing of track fragment atom", 5);
  }
  if (!*(unsigned char *)(a2 + 24))
  {
    if ((_BYTE)v59) {
      BOOL v9 = BYTE1(v59) == 0;
    }
    else {
      BOOL v9 = 1;
    }
    char v10 = !v9;
    *(unsigned char *)(a2 + 24) = v10;
  }
  if (*((void *)&v57 + 1))
  {
    if (*(unsigned char *)(*((void *)&v57 + 1) + 176)) {
      MovieTrackEstablishFirstFragmentBaseDecodeTime(v4, v57, *(void *)(*((void *)&v57 + 1) + 16));
    }
    MovieTrackCreateEditSegmentArrayFromFragmentEditList(v4, v57, *(unsigned __int8 *)(*(void *)a2 + 25));
    uint64_t v11 = *((void *)&v57 + 1);
    if (!*(void *)(*((void *)&v57 + 1) + 72))
    {
      long long v27 = *(void **)(*((void *)&v57 + 1) + 8);
      if (!v27) {
        long long v27 = (void *)(*(void *)(v57 + 728) + 56);
      }
      *long long v27 = 0;
      if (*(unsigned char *)(*(void *)a2 + 25))
      {
        MovieTrackIntegrateFragmentSampleGroups(v57, *(void *)(v11 + 104));
        uint64_t v11 = *((void *)&v57 + 1);
      }
      if (*(void *)(v11 + 96))
      {
        CFRelease(*(CFTypeRef *)(v11 + 96));
        uint64_t v11 = *((void *)&v57 + 1);
      }
      if (*(void *)(v11 + 112))
      {
        CFRelease(*(CFTypeRef *)(v11 + 112));
        uint64_t v11 = *((void *)&v57 + 1);
      }
      if (*(void *)(v11 + 104))
      {
        CFRelease(*(CFTypeRef *)(v11 + 104));
        uint64_t v11 = *((void *)&v57 + 1);
      }
      FreeSampleAuxInfo(v11);
      free(*((void **)&v57 + 1));
      return v8;
    }
    *(unsigned char *)(v4 + 157) = 1;
    if (!*(void *)(v11 + 88)) {
      return v8;
    }
    uint64_t v12 = v57;
    uint64_t v52 = (void *)*v56;
    unint64_t v64 = 0;
    Firstuint64_t FormatDescription = (const opaqueCMFormatDescription *)GetFirstFormatDescription(v57);
    uint64_t v14 = *(void *)(*((void *)&v57 + 1) + 88);
    if (!*(_DWORD *)(v14 + 12)) {
      return v8;
    }
    if (!*(void *)v14) {
      return v8;
    }
    if (!*((void *)&v58 + 1)) {
      return v8;
    }
    CFIndex v15 = FirstFormatDescription;
    if (!FirstFormatDescription) {
      return v8;
    }
    CFDataRef Extension = (const __CFData *)CMFormatDescriptionGetExtension(FirstFormatDescription, (CFStringRef)*MEMORY[0x1E4F21600]);
    if (!Extension) {
      return v8;
    }
    CFDataRef v17 = Extension;
    CFTypeID v18 = CFGetTypeID(Extension);
    if (v18 != CFDataGetTypeID()) {
      return v8;
    }
    if (CFDataGetLength(v17) <= 7)
    {
      uint64_t v31 = ">> CommonEncryptionTrackEncryptionBox is too small";
    }
    else
    {
      BytePtr = CFDataGetBytePtr(v17);
      if ((BytePtr[6] & 1) == 0) {
        return v8;
      }
      uint64_t v20 = BytePtr;
      CFIndex v21 = BytePtr[7];
      if (BytePtr[7])
      {
        if (v21 == 8 || v21 == 16)
        {
          long long v22 = *(uint64_t **)(*((void *)&v57 + 1) + 88);
          uint64_t v23 = *v22;
          CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *((unsigned int *)v22 + 3), MEMORY[0x1E4F1D510]);
          *(void *)(*(void *)(*((void *)&v57 + 1) + 88) + 24) = Mutable;
          if (Mutable)
          {
            CFDataRef v26 = 0;
LABEL_56:
            uint64_t v51 = v12;
            CFMutableArrayRef v32 = CFArrayCreateMutable(v24, *(unsigned int *)(*(void *)(*((void *)&v57 + 1) + 88) + 12), MEMORY[0x1E4F1D510]);
            *(void *)(*(void *)(*((void *)&v57 + 1) + 88) + 32) = v32;
            if (!v32)
            {
LABEL_94:
              FigSignalErrorAt();
              goto LABEL_85;
            }
            if (FigAtomStreamGetCurrentAtomTypeAndDataLength()) {
              goto LABEL_85;
            }
            uint64_t v33 = *(void *)(*((void *)&v57 + 1) + 88);
            if (!*(_DWORD *)(v33 + 12)) {
              goto LABEL_85;
            }
            size_t v34 = 0;
            uint64_t v35 = v23 - 8;
            while (1)
            {
              unsigned __int8 destination = 0;
              int v36 = *(_DWORD *)(v33 + 8);
              if (v36)
              {
                uint64_t v37 = *(_DWORD *)(v33 + 8);
                unsigned __int8 destination = v36;
              }
              else
              {
                if (CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v33 + 16), v34, 1uLL, &destination)) {
                  goto LABEL_85;
                }
                uint64_t v37 = destination;
              }
              if (v35 + v37 > v64) {
                break;
              }
              if (v21)
              {
                long long v38 = CFDataCreateMutable(v24, v21);
                if (!v38) {
                  goto LABEL_94;
                }
                long long v39 = v38;
                CFDataSetLength(v38, v21);
                CFDataGetMutableBytePtr(v39);
                if (FigAtomStreamReadCurrentAtomData())
                {
                  CFRelease(v39);
                  goto LABEL_85;
                }
                CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*((void *)&v57 + 1) + 88) + 24), v39);
                CFRelease(v39);
                v35 += v21;
              }
              else if (v26)
              {
                CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*((void *)&v57 + 1) + 88) + 24), v26);
              }
              if (destination > v21)
              {
                unsigned __int16 v62 = 0;
                if (FigAtomStreamReadCurrentAtomData()) {
                  goto LABEL_85;
                }
                unsigned int v40 = bswap32(v62) >> 16;
                unsigned __int16 v62 = v40;
                if (v21 + 2 + 6 * v40 != destination)
                {
                  uint64_t v50 = ">> Bad sample auxiliary data";
                  goto LABEL_93;
                }
                CFIndex v41 = 8 * v40;
                long long v42 = CFDataCreateMutable(v24, v41);
                if (!v42) {
                  goto LABEL_94;
                }
                long long v43 = v42;
                v35 += 2;
                CFDataSetLength(v42, v41);
                MutableBytePtr = CFDataGetMutableBytePtr(v43);
                if (v62)
                {
                  CFDataRef v45 = v26;
                  unint64_t v46 = 0;
                  int v47 = MutableBytePtr + 4;
                  while (1)
                  {
                    uint64_t v48 = v35;
                    unsigned __int16 v61 = 0;
                    unsigned int v60 = 0;
                    if (FigAtomStreamReadCurrentAtomData()
                      || FigAtomStreamReadCurrentAtomData())
                    {
                      break;
                    }
                    *(v47 - 1) = bswap32(v61) >> 16;
                    *int v47 = bswap32(v60);
                    v47 += 2;
                    ++v46;
                    v35 += 6;
                    if (v46 >= v62)
                    {
                      uint64_t v35 = v48 + 6;
                      CFDataRef v26 = v45;
                      goto LABEL_81;
                    }
                  }
                  CFRelease(v43);
                  CFDataRef v26 = v45;
LABEL_85:
                  if (v26) {
                    CFRelease(v26);
                  }
                  return v8;
                }
LABEL_81:
                CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*((void *)&v57 + 1) + 88) + 32), v43);
                CFRelease(v43);
              }
              ++v34;
              uint64_t v33 = *(void *)(*((void *)&v57 + 1) + 88);
              if (v34 >= *(unsigned int *)(v33 + 12)) {
                goto LABEL_85;
              }
            }
            uint64_t v50 = ">> Sample auxiliary data read offset out of range";
LABEL_93:
            _MovieAtomReportParsingMessage(v52, v51, 0, (uint64_t)v50, 2);
            goto LABEL_94;
          }
LABEL_54:
          FigSignalErrorAt();
          return v8;
        }
        uint64_t v31 = ">> Only default_Per_Sample_IV_Size = 0, 8, 16  is supported";
      }
      else if (CFDataGetLength(v17) <= 24)
      {
        uint64_t v31 = ">> CommonEncryptionTrackEncryptionBox is too small (< 25)";
      }
      else
      {
        CFIndex v28 = v20[24];
        if (v28 <= 0x10 && ((1 << v28) & 0x10101) != 0)
        {
          uint64_t v23 = **(void **)(*((void *)&v57 + 1) + 88);
          FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(v15);
          if (MediaSubType != 1635135537 && MediaSubType != 1902212657)
          {
            CFDataRef v26 = 0;
            CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            goto LABEL_56;
          }
          if (v28 != 8 && v28 != 16) {
            goto LABEL_54;
          }
          CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFMutableArrayRef v30 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(unsigned int *)(*(void *)(*((void *)&v57 + 1) + 88) + 12), MEMORY[0x1E4F1D510]);
          *(void *)(*(void *)(*((void *)&v57 + 1) + 88) + 24) = v30;
          if (!v30) {
            goto LABEL_54;
          }
          if (CFDataGetLength(v17) >= v28 + 25)
          {
            CFDataRef v26 = CFDataCreate(v24, v20 + 25, v28);
            goto LABEL_56;
          }
          uint64_t v31 = ">> CommonEncryptionTrackEncryptionBox is too small (25+default_constant_IV_size)";
        }
        else
        {
          uint64_t v31 = ">> Only default_constant_IV_size = 0, 8, 16  is supported";
        }
      }
    }
    _MovieAtomReportParsingMessage(v52, v12, 0, (uint64_t)v31, 2);
    goto LABEL_54;
  }
  return v8;
}

uint64_t ParseTrackFragmentHeaderAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void ***)a2;
  if (*(unsigned char *)(a2 + 40))
  {
    _MovieAtomReportParsingMessage(v3, 0, a1, (uint64_t)"Inherited base data offset with more than one track fragment not supported", 2);
    return FigSignalErrorAt();
  }
  else
  {
    FigAtomStreamGetCurrentAtomTypeAndDataLength();
    uint64_t result = FigAtomStreamGetCurrentAtomVersionAndFlags();
    if (!result)
    {
      uint64_t result = FigAtomStreamReadCurrentAtomData();
      if (!result)
      {
        uint64_t TrackForTrackID = MovieInformationFindTrackForTrackID((uint64_t)v3, bswap32(0));
        *(void *)(a2 + 8) = TrackForTrackID;
        if (TrackForTrackID)
        {
          uint64_t v7 = TrackForTrackID;
          if (*(void *)(TrackForTrackID + 728))
          {
            if (*(unsigned char *)(*(void *)a2 + 25)) {
              MoovAssureSampleTableParsed(v3, TrackForTrackID);
            }
            char v10 = "Incorrect 'tfhd' atom size";
          }
          else
          {
            char v10 = "Track not set up to receive fragments";
          }
          uint64_t v8 = v3;
          uint64_t v9 = v7;
        }
        else
        {
          char v10 = "Fragment contains unknown track ID";
          uint64_t v8 = v3;
          uint64_t v9 = 0;
        }
        _MovieAtomReportParsingMessage(v8, v9, a1, (uint64_t)v10, 2);
        return FigSignalErrorAt();
      }
    }
  }
  return result;
}

uint64_t ParseTrackFragmentBaseMediaDecodeTimeAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2)
  {
    if (!*(void *)(v2 + 72))
    {
      uint64_t result = FigAtomStreamGetCurrentAtomVersionAndFlags();
      if (!result)
      {
        uint64_t result = FigAtomStreamReadCurrentAtomData();
        if (!result)
        {
          uint64_t v5 = *(void *)(a2 + 16);
          *(void *)(v5 + 16) = bswap32(0);
          uint64_t result = 0;
          *(unsigned char *)(v5 + 176) = 1;
        }
      }
      return result;
    }
    uint64_t v6 = "'tfdt' atom appeared after encountering 'trun' atom";
  }
  else
  {
    uint64_t v6 = "'tfdt' atom appears without prior 'tfhd' atom";
  }
  _MovieAtomReportParsingMessage(**(void ***)a2, *(void *)(a2 + 8), a1, (uint64_t)v6, 2);

  return FigSignalErrorAt();
}

uint64_t ParseTrackRunAtom(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 16)
    && ((FigAtomStreamGetCurrentAtomTypeAndDataLength(),
         uint64_t CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomVersionAndFlags(),
         CurrentAtomVersionAndFlags)
     || (uint64_t CurrentAtomVersionAndFlags = FigAtomStreamReadCurrentAtomData(), CurrentAtomVersionAndFlags)))
  {
    return CurrentAtomVersionAndFlags;
  }
  else
  {
    return 0;
  }
}

uint64_t ParseSampleAuxInfoSizesAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 16);
  if (!v4)
  {
    uint64_t v14 = "'saiz' atom appears without prior 'tfhd' atom";
LABEL_14:
    _MovieAtomReportParsingMessage(**(void ***)a2, v3, a1, (uint64_t)v14, 2);
    uint64_t CurrentAtomData = FigSignalErrorAt();
    goto LABEL_15;
  }
  if (*(unsigned char *)(v4 + 40) != 1)
  {
    uint64_t v14 = "Only supports sample auxiliary info data when default-base-is-moof is set";
    goto LABEL_14;
  }
  uint64_t v5 = *(void *)(v4 + 88);
  if (v5 && *(void *)(v5 + 16)) {
    return 0;
  }
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  uint64_t CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomVersionAndFlags();
  if (CurrentAtomVersionAndFlags)
  {
    uint64_t v12 = CurrentAtomVersionAndFlags;
    goto LABEL_16;
  }
  Firstuint64_t FormatDescription = (const opaqueCMFormatDescription *)GetFirstFormatDescription(v3);
  MovieTrackNoteSampleAuxInfoSizesAtomPresent(v3);
  memset(v15, 0, sizeof(v15));
  uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData();
  if (CurrentAtomData)
  {
LABEL_15:
    uint64_t v12 = CurrentAtomData;
    if (!CurrentAtomData) {
      return v12;
    }
LABEL_16:
    FreeSampleAuxInfo(*(void *)(a2 + 16));
    return v12;
  }
  CFPropertyListRef v9 = (CFPropertyListRef)*MEMORY[0x1E4F1CFD0];
  if (v9 != CMFormatDescriptionGetExtension(FirstFormatDescription, (CFStringRef)*MEMORY[0x1E4F215F8])) {
    return 0;
  }
  unsigned int v10 = bswap32(*(unsigned int *)&v15[1]);
  uint64_t v11 = *(_DWORD **)(*(void *)(a2 + 16) + 88);
  if (!v11)
  {
    uint64_t v11 = malloc_type_calloc(1uLL, 0x28uLL, 0x1020040DB654AE0uLL);
    *(void *)(*(void *)(a2 + 16) + 88) = v11;
  }
  v11[2] = 0;
  void v11[3] = v10;
  uint64_t v12 = 0;
  *((void *)v11 + 2) = 0;
  return v12;
}

uint64_t ParseSampleAuxInfoOffsetsAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 16);
  if (!v4)
  {
    uint64_t v11 = "'saio' atom appears without prior 'tfhd' atom";
LABEL_16:
    _MovieAtomReportParsingMessage(**(void ***)a2, v3, a1, (uint64_t)v11, 2);
    uint64_t CurrentAtomData = FigSignalErrorAt();
    goto LABEL_17;
  }
  if (*(unsigned char *)(v4 + 40) != 1)
  {
    uint64_t v11 = "Only supports sample auxiliary info data when default-base-is-moof is set";
    goto LABEL_16;
  }
  uint64_t v5 = *(void **)(v4 + 88);
  if (v5 && *v5) {
    return 0;
  }
  FigAtomStreamGetCurrentAtomTypeAndDataLength();
  uint64_t CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomVersionAndFlags();
  if (CurrentAtomVersionAndFlags) {
    goto LABEL_13;
  }
  Firstuint64_t FormatDescription = (const opaqueCMFormatDescription *)GetFirstFormatDescription(v3);
  MovieTrackNoteSampleAuxInfoOffsetsAtomPresent(v3);
  uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData();
  if (CurrentAtomData
    || (CFPropertyListRef v9 = (CFPropertyListRef)*MEMORY[0x1E4F1CFD0],
        v9 != CMFormatDescriptionGetExtension(FirstFormatDescription, (CFStringRef)*MEMORY[0x1E4F215F8])))
  {
LABEL_17:
    if (!CurrentAtomData) {
      return CurrentAtomData;
    }
LABEL_18:
    FreeSampleAuxInfo(*(void *)(a2 + 16));
    return CurrentAtomData;
  }
  if (!*(void *)(*(void *)(a2 + 16) + 88)) {
    *(void *)(*(void *)(a2 + 16) + 88) = malloc_type_calloc(1uLL, 0x28uLL, 0x1020040DB654AE0uLL);
  }
  uint64_t CurrentAtomVersionAndFlags = FigAtomStreamReadCurrentAtomData();
  if (CurrentAtomVersionAndFlags)
  {
LABEL_13:
    uint64_t CurrentAtomData = CurrentAtomVersionAndFlags;
    goto LABEL_18;
  }
  uint64_t CurrentAtomData = 0;
  **(void **)(*(void *)(a2 + 16) + 88) = bswap32(0);
  return CurrentAtomData;
}

uint64_t ParseEditsAtomInTrackFragment(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = **(void ***)a2;
  uint64_t v16 = v4;
  uint64_t v17 = v3;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (CurrentAtomTypeAndDataLength) {
    return CurrentAtomTypeAndDataLength;
  }
  if (!v3)
  {
    _MovieAtomReportParsingMessage(v4, 0, a1, (uint64_t)"Track Information is NULL (missing track fragment header)", 3);
    return FigSignalErrorAt();
  }
  *(unsigned char *)(v3 + 722) = 1;
  *(unsigned char *)(v3 + 727) = 1;
  uint64_t v6 = *(const void **)(v3 + 696);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(v3 + 696) = 0;
  *(void *)(v3 + 704) = 0;
  return 0;
}

uint64_t ParseSampleDependencyAtomInTrackFragment(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 16)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = **(void ***)a2;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result)
  {
    _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)"'sdtp' atom not minimum size", 2);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseFragmentSampleGroupDescriptionAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = **(void ***)a2;
  int v30 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  unint64_t v29 = 0;
  CMBlockBufferRef sourceBuffer = 0;
  unsigned __int8 v26 = 0;
  CFTypeRef cf = 0;
  int v24 = 0;
  if (!v3)
  {
    uint64_t v17 = "Track Information is NULL (missing track fragment header)";
    CFTypeID v18 = v4;
    uint64_t v19 = 0;
    uint64_t v20 = a1;
    int v21 = 3;
LABEL_37:
    _MovieAtomReportParsingMessage(v18, v19, v20, (uint64_t)v17, v21);
    CurrentAtomTypeAndDataunint64_t Length = FigSignalErrorAt();
    goto LABEL_19;
  }
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (CurrentAtomTypeAndDataLength) {
    goto LABEL_19;
  }
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamGetCurrentAtomVersionAndFlags();
  if (CurrentAtomTypeAndDataLength) {
    goto LABEL_19;
  }
  if (v26 - 3 <= 0xFFFFFFFD)
  {
    long long v22 = "Only support V1 or V2 'sgpd' atoms";
    goto LABEL_31;
  }
  CurrentAtomTypeAndDataunint64_t Length = FigAtomStreamReadCurrentAtomDataAndCreateBBuf();
  if (CurrentAtomTypeAndDataLength) {
    goto LABEL_19;
  }
  CurrentAtomTypeAndDataunint64_t Length = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E4F1CF80], sourceBuffer, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, 2u, &blockBufferOut);
  if (CurrentAtomTypeAndDataLength) {
    goto LABEL_19;
  }
  if (v26 == 1)
  {
    uint64_t v23 = 0;
    if (v29 >= 0x10)
    {
      CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v23);
      unsigned int v7 = 0;
      int v8 = bswap32(*((_DWORD *)v23 + 1));
      int v9 = bswap32(*((_DWORD *)v23 + 3));
      int v10 = bswap32(*((_DWORD *)v23 + 2));
      long long v11 = v23 + 16;
      unint64_t v12 = v29 - 16;
      goto LABEL_12;
    }
    uint64_t v17 = "V1 'sgpd' atom size less than minimum";
LABEL_36:
    CFTypeID v18 = v4;
    uint64_t v19 = v3;
    uint64_t v20 = a1;
    int v21 = 2;
    goto LABEL_37;
  }
  uint64_t v23 = 0;
  if (v29 < 0x14)
  {
    uint64_t v17 = "V2 'sgpd' atom size less than minimum";
    goto LABEL_36;
  }
  CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v23);
  int v8 = bswap32(*((_DWORD *)v23 + 1));
  int v9 = bswap32(*((_DWORD *)v23 + 4));
  int v10 = bswap32(*((_DWORD *)v23 + 2));
  unsigned int v7 = bswap32(*((_DWORD *)v23 + 3));
  long long v11 = v23 + 20;
  unint64_t v12 = v29 - 20;
LABEL_12:
  if (v9 < 0)
  {
    long long v22 = "Negative number of sample group description entries";
  }
  else
  {
    if ((v10 & 0x80000000) == 0)
    {
      uint64_t v13 = *(void *)(a2 + 16);
      if (v13)
      {
        CurrentAtomTypeAndDataunint64_t Length = FragmentInfoAddAndRetainSampleGroupDescriptionArray(*(const void **)(a2 + 8), v13, v8, &cf);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_19;
        }
        CFTypeRef v14 = cf;
        CurrentAtomTypeAndDataunint64_t Length = MovieSampleGroupDescriptionArrayCopyInfo((uint64_t)cf, 0, 0, &v24, 0, 0);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_19;
        }
        if (!v24)
        {
          CurrentAtomTypeAndDataunint64_t Length = CommonSampleGroupDescriptionEntryParse(v4, v3, (unsigned int *)v11, v9, v10, v7, v12, (uint64_t)v14);
LABEL_19:
          uint64_t v15 = CurrentAtomTypeAndDataLength;
          goto LABEL_20;
        }
        uint64_t v17 = "Parsing a second 'sgpd' for the same groupType in fragment";
      }
      else
      {
        uint64_t v17 = "No FragmentInfo (missing track fragment header)";
      }
      goto LABEL_36;
    }
    long long v22 = "Negative default entry length in sample group description";
  }
LABEL_31:
  _MovieAtomReportParsingMessage(v4, v3, a1, (uint64_t)v22, 2);
  FigSignalErrorAt();
  uint64_t v15 = 0;
LABEL_20:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  if (sourceBuffer) {
    CFRelease(sourceBuffer);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v15;
}

uint64_t ParseFragmentSampleToGroupAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void ***)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v6 = *v5;
  int v16 = 0;
  unsigned int v15 = 0;
  CFTypeRef cf = 0;
  unint64_t v14 = 0;
  CFTypeRef v12 = 0;
  if (v4)
  {
    Arrayuint64_t BBuf = CommonSampleToGroupAtomParseAndCreateArrayBBuf(v6, v4, a1);
    if (ArrayBBuf)
    {
      uint64_t v10 = ArrayBBuf;
    }
    else
    {
      uint64_t v8 = FragmentInfoAddAndRetainSampleGroup(*(void **)(a2 + 8), *(void *)(a2 + 16), v14, v15, &v12);
      CFTypeRef v9 = cf;
      if (!v8) {
        uint64_t v8 = MovieSampleGroupSet_sbgp((uint64_t)v12, v16, (CMBlockBufferRef)cf);
      }
      uint64_t v10 = v8;
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v12) {
      CFRelease(v12);
    }
    return v10;
  }
  else
  {
    _MovieAtomReportParsingMessage(v6, 0, a1, (uint64_t)"Track Information is NULL (missing track fragment header)", 3);
    return FigSignalErrorAt();
  }
}

uint64_t ParseFragmentMOVCompactSampleToGroupAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void ***)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v6 = *v5;
  unsigned int v18 = 0;
  unint64_t v17 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v16 = 0;
  CFTypeRef v14 = 0;
  v12[0] = 0;
  v12[1] = 0;
  int v13 = 0;
  if (v4)
  {
    Arrayuint64_t BBuf = CommonMOVCompactSampleToGroupAtomParseAndCreateArrayBBuf(v6, v4, a1);
    if (ArrayBBuf)
    {
      uint64_t v10 = ArrayBBuf;
    }
    else
    {
      uint64_t v8 = FragmentInfoAddAndRetainSampleGroup(*(void **)(a2 + 8), *(void *)(a2 + 16), v17, v18, &v14);
      CFTypeRef v9 = cf;
      if (!v8) {
        uint64_t v8 = MovieSampleGroupSet_csgp((CMBlockBufferRef *)v14, v12, (CMBlockBufferRef)v16, (OpaqueCMBlockBuffer *)cf);
      }
      uint64_t v10 = v8;
      if (v9) {
        CFRelease(v9);
      }
    }
  }
  else
  {
    _MovieAtomReportParsingMessage(v6, 0, a1, (uint64_t)"Track Information is NULL (missing track fragment header)", 3);
    uint64_t v10 = FigSignalErrorAt();
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v14) {
    CFRelease(v14);
  }
  return v10;
}

uint64_t ParseTrackFragmentUserDataAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = **(unsigned char ***)a2;
  if (*(void *)(a2 + 8))
  {
    uint64_t result = FigAtomStreamReadCurrentAtomAndCreateBBuf();
    if (!result)
    {
      if (v2[81])
      {
        if (v2[82]) {
          return MovieTrackSupplementQuickTimeUserDataFromBlockBuffer(v2, *(uint64_t **)(a2 + 8), 0);
        }
      }
      else if (!v2[84])
      {
        return MovieTrackSupplementQuickTimeUserDataFromBlockBuffer(v2, *(uint64_t **)(a2 + 8), 0);
      }
      return MovieTrackSupplementISOUserDataFromBlockBuffer(v2, *(uint64_t **)(a2 + 8), 0);
    }
  }
  else
  {
    _MovieAtomReportParsingMessage(v2, 0, a1, (uint64_t)"Track Information is NULL (missing track fragment header)", 3);
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t ParseSampleEncryptionAtomInTraf(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3)
  {
    MovieTrackNoteSampleEncryptionAtomPresent(v3);
    return 0;
  }
  else
  {
    _MovieAtomReportParsingMessage(**(void ***)a2, 0, a1, (uint64_t)"Track Information is NULL (missing track fragment header)", 3);
    return FigSignalErrorAt();
  }
}

uint64_t FragmentInfoAddAndRetainSampleGroupDescriptionArray(const void *a1, uint64_t a2, int a3, void *a4)
{
  CFDictionaryRef Mutable = *(const __CFDictionary **)(a2 + 112);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
    *(void *)(a2 + 112) = Mutable;
    if (!Mutable)
    {
      FigSignalErrorAt();
      return 0;
    }
  }
  CFTypeRef v9 = (void *)CFDictionaryGetValue(Mutable, (const void *)a3);
  CMTimeValue value = v9;
  if (v9)
  {
    uint64_t v10 = v9;
    CFRetain(v9);
LABEL_7:
    uint64_t v13 = 0;
    *a4 = v10;
    return v13;
  }
  CFAllocatorRef v11 = CFGetAllocator(a1);
  uint64_t v12 = MovieSampleGroupDescriptionArrayCreate(v11, a3, (uint64_t *)&value);
  if (!v12)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 112), (const void *)a3, value);
    uint64_t v10 = value;
    goto LABEL_7;
  }
  uint64_t v13 = v12;
  if (value) {
    CFRelease(value);
  }
  return v13;
}

uint64_t FragmentInfoAddAndRetainSampleGroup(void *cf, uint64_t a2, unint64_t a3, unsigned int a4, void *a5)
{
  CFTypeRef cfa = 0;
  CFTypeRef v20 = 0;
  CFTypeRef v18 = 0;
  CFAllocatorRef v11 = (uint64_t *)(a2 + 104);
  uint64_t v10 = *(void *)(a2 + 104);
  if (!v10)
  {
    CFAllocatorRef v12 = CFGetAllocator(cf);
    uint64_t v13 = MovieSampleGroupCollectionCreate(v12, v11);
    if (v13) {
      goto LABEL_18;
    }
    uint64_t v10 = *v11;
  }
  CFTypeRef v14 = MovieSampleGroupCollectionLookupAndRetainSampleGroup(v10, a3, a4);
  CFTypeRef v20 = v14;
  if (v14)
  {
LABEL_10:
    uint64_t v16 = 0;
    *a5 = v14;
    CFTypeRef v20 = 0;
    goto LABEL_11;
  }
  MovieTrackAddAndRetainSampleGroup(cf, a3, a4, &cfa);
  CFAllocatorRef v15 = CFGetAllocator(cf);
  uint64_t v13 = MovieSampleGroupCreateForFragment(v15, a3, a4, (uint64_t)cfa, &v20);
  if (!v13)
  {
    uint64_t v13 = FragmentInfoAddAndRetainSampleGroupDescriptionArray(cf, a2, a3, &v18);
    if (!v13)
    {
      uint64_t v13 = MovieSampleGroupSetDescriptionArray((uint64_t)v20, v18);
      if (!v13)
      {
        uint64_t v13 = MovieSampleGroupCollectionAddSampleGroup(*v11, (uint64_t)v20);
        if (!v13)
        {
          CFTypeRef v14 = v20;
          goto LABEL_10;
        }
      }
    }
  }
LABEL_18:
  uint64_t v16 = v13;
LABEL_11:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v20) {
    CFRelease(v20);
  }
  return v16;
}

void MovieAtomReportChildAtomParsingFailureMessage(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1[8])
  {
    CFAllocatorRef v6 = CFGetAllocator(a1);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      uint64_t v8 = Mutable;
      CFAllocatorRef v9 = CFGetAllocator(a1);
      uint64_t v10 = CFStringCreateMutable(v9, 0);
      if (v10)
      {
        CFAllocatorRef v11 = v10;
        CFStringAppendFormat(v10, 0, @"%s.", a4);
        CFStringForOSTypeCFArrayRef Value = FigGetCFStringForOSTypeValue();
        FigAtomStreamGetCurrentAtomGlobalOffset();
        CFStringAppendFormat(v11, 0, @" Atom: '%@' Offset: %lld", CFStringForOSTypeValue, 0);
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt32();
        FigCFDictionarySetInt64();
        CFDictionarySetValue(v8, (const void *)*MEMORY[0x1E4F1FAD0], v11);
        FigCFDictionarySetInt32();
        FigAssetAnalysisReporterAddMessage();
        CFRelease(v11);
      }
      CFRelease(v8);
    }
  }
}

CFArrayRef MovieTrackGetNumDataSources(uint64_t a1)
{
  CFArrayRef result = *(const __CFArray **)(a1 + 64);
  if (result) {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

uint64_t MovieTrackGetDataSourceAtIndex(void *a1, uint64_t a2, CFIndex idx, BOOL *a4, void *a5)
{
  if ((idx & 0x8000000000000000) == 0)
  {
    CFArrayRef Count = *(const __CFArray **)(a2 + 64);
    if (Count) {
      CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
    }
    if ((uint64_t)Count > idx)
    {
      CFDictionaryRef ValueAtIndex = (CMBlockBufferRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 64), idx);
      CFAllocatorRef v12 = ValueAtIndex;
      size_t totalLengthOut = 0;
      if (!ValueAtIndex[2])
      {
        long long dataPointerOut = 0;
        if (*(_DWORD *)ValueAtIndex)
        {
          uint64_t result = CMBlockBufferGetDataPointer(ValueAtIndex[1], 0, 0, &totalLengthOut, &dataPointerOut);
          if (result) {
            return result;
          }
          if (*(_DWORD *)v12 != 1970433056)
          {
LABEL_19:
            uint64_t result = FigSignalErrorAt();
            if (result) {
              return result;
            }
            goto LABEL_20;
          }
          if (!totalLengthOut) {
            goto LABEL_17;
          }
          size_t v16 = 0;
          while (dataPointerOut[v16])
          {
            if (totalLengthOut == ++v16) {
              goto LABEL_17;
            }
          }
          if (!v16 || v16 >= totalLengthOut)
          {
LABEL_17:
            unint64_t v17 = "Bad string in url data ref";
LABEL_18:
            MovieInformationReportParsingFailureMessage(a1, a2, (uint64_t)v17, 2);
            goto LABEL_19;
          }
          CFTypeRef cf = 0;
          CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
          uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v20) {
            uint64_t v21 = v20;
          }
          else {
            uint64_t v21 = 0;
          }
          long long v22 = *(void (**)(uint64_t, void, const __CFAllocator *, CFTypeRef *))(v21 + 48);
          if (v22)
          {
            v22(CMBaseObject, *MEMORY[0x1E4F1EC78], v18, &cf);
            CFURLRef v23 = (const __CFURL *)cf;
          }
          else
          {
            CFURLRef v23 = 0;
          }
          CFURLRef v14 = CFURLCreateWithBytes(v18, (const UInt8 *)dataPointerOut, v16, 0x8000100u, v23);
          if (cf) {
            CFRelease(cf);
          }
          if (!v14)
          {
            unint64_t v17 = "Could not create CFURL for url data ref";
            goto LABEL_18;
          }
        }
        else
        {
          CFURLRef v14 = 0;
        }
        void v12[2] = v14;
        CMBlockBufferRef v15 = v12[1];
        if (v15)
        {
          CFRelease(v15);
          v12[1] = 0;
        }
      }
LABEL_20:
      *a5 = v12[2];
      uint64_t result = 0;
      if (a4) {
        *a4 = *(_DWORD *)v12 == 0;
      }
      return result;
    }
  }

  return FigSignalErrorAt();
}

uint64_t MovieTrackSetDataSourceAtIndex(void *a1, uint64_t a2, CFIndex idx, int a4, const void *a5)
{
  if (idx < 0) {
    goto LABEL_15;
  }
  CFArrayRef Count = *(const __CFArray **)(a2 + 64);
  if (Count) {
    CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
  }
  if ((uint64_t)Count <= idx)
  {
LABEL_15:
    MovieInformationReportParsingFailureMessage(a1, a2, (uint64_t)"Data source index is invalid", 2);
    return FigSignalErrorAt();
  }
  else
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 64), idx);
    CFAllocatorRef v12 = ValueAtIndex;
    if (a4) {
      int v13 = 0;
    }
    else {
      int v13 = 1970433056;
    }
    *(_DWORD *)CFDictionaryRef ValueAtIndex = v13;
    CFURLRef v14 = (const void *)ValueAtIndex[2];
    ValueAtIndex[2] = a5;
    if (a5) {
      CFRetain(a5);
    }
    if (v14) {
      CFRelease(v14);
    }
    CMBlockBufferRef v15 = (const void *)v12[1];
    if (v15)
    {
      CFRelease(v15);
      v12[1] = 0;
    }
    return 0;
  }
}

void MovieInformationReportParsingFailureMessage(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = a1 + 8;
  if (!a1) {
    uint64_t v4 = (void *)(a2 + 640);
  }
  if (*v4)
  {
    CFAllocatorRef v9 = CFGetAllocator(a1);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFAllocatorRef v11 = Mutable;
      CFAllocatorRef v12 = CFGetAllocator(a1);
      int v13 = CFStringCreateMutable(v12, 0);
      if (v13)
      {
        CFURLRef v14 = v13;
        CFStringAppendFormat(v13, 0, @"%s.", a3);
        if (a2)
        {
          FigCFDictionarySetInt32();
          FigCFDictionarySetInt32();
        }
        FigCFDictionarySetInt64();
        CFDictionarySetValue(v11, (const void *)*MEMORY[0x1E4F1FAD0], v14);
        FigCFDictionarySetInt32();
        if (a4 == 7) {
          FigAssetAnalysisReporterEditAndCombineMessage();
        }
        else {
          FigAssetAnalysisReporterAddMessage();
        }
        CFRelease(v14);
      }
      CFRelease(v11);
    }
  }
}

uint64_t MovieTrackCopyExternalDataReferenceSchemes(void *a1, uint64_t a2, const __CFArray **a3)
{
  CFArrayRef v6 = *(const __CFArray **)(a2 + 64);
  if (v6) {
    CFIndex Count = CFArrayGetCount(v6);
  }
  else {
    CFIndex Count = 0;
  }
  *a3 = 0;
  MEMORY[0x19970E290](*(void *)(a2 + 32));
  if (Count < 1)
  {
    CFArrayRef Mutable = 0;
LABEL_17:
    *a3 = Mutable;
    MEMORY[0x19970E2B0](*(void *)(a2 + 32));
    return 0;
  }
  else
  {
    CFArrayRef Mutable = 0;
    CFIndex v9 = 0;
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFAllocatorRef v11 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    while (1)
    {
      CFURLRef anURL = 0;
      uint64_t DataSourceAtIndex = MovieTrackGetDataSourceAtIndex(a1, a2, v9, 0, &anURL);
      if (DataSourceAtIndex) {
        break;
      }
      if (anURL)
      {
        CFStringRef v13 = CFURLCopyScheme(anURL);
        if (v13)
        {
          CFStringRef v14 = v13;
          if (!Mutable)
          {
            CFArrayRef Mutable = CFArrayCreateMutable(v10, 0, v11);
            if (!Mutable)
            {
              uint64_t v17 = FigSignalErrorAt();
              MEMORY[0x19970E2B0](*(void *)(a2 + 32));
              CFRelease(v14);
              return v17;
            }
          }
          v19.length = CFArrayGetCount(Mutable);
          v19.location = 0;
          if (!CFArrayContainsValue(Mutable, v19, v14)) {
            CFArrayAppendValue(Mutable, v14);
          }
          CFRelease(v14);
        }
      }
      if (Count == ++v9) {
        goto LABEL_17;
      }
    }
    uint64_t v15 = DataSourceAtIndex;
    MEMORY[0x19970E2B0](*(void *)(a2 + 32));
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  return v15;
}

uint64_t MovieTrackCopySyncSampleCombinations(const __CFAllocator *a1, uint64_t a2, CFMutableArrayRef *a3)
{
  memset(capacity, 0, sizeof(capacity));
  *a3 = 0;
  CFDictionaryRef v4 = *(const __CFDictionary **)(a2 + 80);
  if (v4 && (CFArrayRef Value = CFDictionaryGetValue(v4, (const void *)0x73796E63)) != 0)
  {
    uint64_t v7 = MovieSampleGroupDescriptionArrayCopyInfo((uint64_t)Value, 0, &capacity[1], capacity, 0, 0);
    if (capacity[0])
    {
      if (capacity[0] < 1)
      {
        CFMutableArrayRef Mutable = 0;
LABEL_12:
        *a3 = Mutable;
      }
      else
      {
        CFIndex v8 = 0;
        CFMutableArrayRef Mutable = 0;
        CFAllocatorRef v10 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
        while (1)
        {
          CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)&capacity[1], v8);
          if (CFDataGetLength(ValueAtIndex) != 1) {
            break;
          }
          CFDataGetBytePtr(ValueAtIndex);
          if (!Mutable)
          {
            CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, capacity[0], v10);
            if (!Mutable)
            {
              uint64_t v7 = FigSignalErrorAt();
              goto LABEL_13;
            }
          }
          FigCFArrayAppendInt();
          if (++v8 >= capacity[0]) {
            goto LABEL_12;
          }
        }
        uint64_t v7 = FigSignalErrorAt();
        if (Mutable) {
          CFRelease(Mutable);
        }
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
LABEL_13:
  if (*(void *)&capacity[1]) {
    CFRelease(*(CFTypeRef *)&capacity[1]);
  }
  return v7;
}

uint64_t MovieTrackCopyTemporalLevelCombinations(const __CFAllocator *a1, uint64_t a2, CFMutableArrayRef *a3)
{
  CFArrayRef v29 = 0;
  int v28 = 0;
  *a3 = 0;
  CFDictionaryRef v4 = *(const __CFDictionary **)(a2 + 80);
  if (!v4 || (CFArrayRef Value = CFDictionaryGetValue(v4, (const void *)0x7473636C)) == 0)
  {
    uint64_t v9 = 0;
    goto LABEL_16;
  }
  uint64_t v8 = MovieSampleGroupDescriptionArrayCopyInfo((uint64_t)Value, 0, &v29, &v28, 0, 0);
  uint64_t v9 = v8;
  if (!v28) {
    goto LABEL_16;
  }
  CFURLRef v23 = a3;
  unsigned int v24 = v8;
  if (v28 < 1)
  {
    CFMutableArrayRef v11 = 0;
LABEL_15:
    *CFURLRef v23 = v11;
    uint64_t v9 = v24;
    goto LABEL_16;
  }
  uint64_t v22 = a2;
  CFIndex v10 = 0;
  CFMutableArrayRef v11 = 0;
  key = (void *)*MEMORY[0x1E4F1EF70];
  CFAllocatorRef v12 = (const void *)*MEMORY[0x1E4F1EF60];
  while (1)
  {
    CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v29, v10);
    long long v26 = 0uLL;
    int v27 = 0;
    if (CFDataGetLength(ValueAtIndex) != 20)
    {
      MovieInformationReportParsingFailureMessage(0, v22, (uint64_t)"Invalid tscl sample group description size", 2);
      CFMutableArrayRef Mutable = 0;
LABEL_21:
      uint64_t v9 = FigSignalErrorAt();
      if (!v11) {
        goto LABEL_23;
      }
LABEL_22:
      CFRelease(v11);
      goto LABEL_23;
    }
    BytePtr = CFDataGetBytePtr(ValueAtIndex);
    int v15 = *((_DWORD *)BytePtr + 4);
    long long v26 = *(_OWORD *)BytePtr;
    int v27 = v15;
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable) {
      goto LABEL_21;
    }
    CFDataRef v17 = CFDataCreate(a1, (const UInt8 *)&v26 + 2, 4);
    if (!v17) {
      goto LABEL_21;
    }
    CFDataRef v18 = v17;
    CFDataRef v19 = CFDataCreate(a1, (const UInt8 *)&v26 + 6, 6);
    if (!v19) {
      break;
    }
    CFDataRef v20 = v19;
    FigCFDictionarySetInt();
    FigCFDictionarySetInt();
    FigCFDictionarySetInt();
    FigCFDictionarySetInt();
    CFDictionarySetValue(Mutable, key, v18);
    CFDictionarySetValue(Mutable, v12, v20);
    FigCFDictionarySetInt();
    if (!v11)
    {
      CFMutableArrayRef v11 = CFArrayCreateMutable(a1, v28, MEMORY[0x1E4F1D510]);
      if (!v11)
      {
        uint64_t v9 = FigSignalErrorAt();
        CFRelease(v18);
        CFRelease(v20);
        goto LABEL_24;
      }
    }
    CFArrayAppendValue(v11, Mutable);
    CFRelease(Mutable);
    CFRelease(v18);
    CFRelease(v20);
    if (++v10 >= v28) {
      goto LABEL_15;
    }
  }
  uint64_t v9 = FigSignalErrorAt();
  CFRelease(v18);
  if (v11) {
    goto LABEL_22;
  }
LABEL_23:
  if (!Mutable) {
    goto LABEL_16;
  }
LABEL_24:
  CFRelease(Mutable);
LABEL_16:
  if (v29) {
    CFRelease(v29);
  }
  return v9;
}

uint64_t MovieTrackCopySampleGroupDescriptionDictionary(const __CFAllocator *a1, uint64_t a2, CFMutableDictionaryRef *a3)
{
  *a3 = 0;
  if (!FigCFDictionaryGetCount()) {
    return 0;
  }
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a2 + 80));
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFMutableDictionaryRef v8 = Mutable;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a2 + 80), (CFDictionaryApplierFunction)SampleGroupDescCollectingApplierFunction, Mutable);
    *a3 = v8;
    return 0;
  }

  return FigSignalErrorAt();
}

void SampleGroupDescCollectingApplierFunction(unsigned int a1, uint64_t a2, void *a3)
{
  CFArrayRef theArray = 0;
  MovieSampleGroupDescriptionArrayCopyInfo(a2, 0, &theArray, 0, 0, 0);
  if (!theArray) {
    return;
  }
  if (!CFArrayGetCount(theArray)) {
    goto LABEL_13;
  }
  CFAllocatorRef v5 = CFGetAllocator(a3);
  CFArrayRef Copy = CFArrayCreateCopy(v5, theArray);
  if (!Copy)
  {
    FigSignalErrorAt();
LABEL_13:
    CFStringRef v9 = 0;
    goto LABEL_7;
  }
  CFArrayRef v7 = Copy;
  CFAllocatorRef v8 = CFGetAllocator(a3);
  CFStringRef v9 = CFStringCreateWithFormat(v8, 0, @"%c%c%c%c", HIBYTE(a1), BYTE2(a1), BYTE1(a1), a1);
  if (v9) {
    CFDictionarySetValue((CFMutableDictionaryRef)a3, v9, v7);
  }
  else {
    FigSignalErrorAt();
  }
  CFRelease(v7);
LABEL_7:
  if (theArray) {
    CFRelease(theArray);
  }
  if (v9) {
    CFRelease(v9);
  }
}

uint64_t MovieTrackCopySampleGroupDescriptionArrays(uint64_t a1, void *a2)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 80);
  if (v3) {
    CFTypeRef v3 = CFRetain(v3);
  }
  *a2 = v3;
  return 0;
}

uint64_t MovieTrackAppendSampleGroupDescriptions(void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFTypeRef cf = 0;
  CFIndex Count = CFDictionaryGetCount(a2);
  if (!Count) {
    return 0;
  }
  uint64_t v6 = Count;
  CFIndex v7 = 8 * Count;
  CFAllocatorRef v8 = (const void **)CFAllocatorAllocate(v4, 8 * Count, 0);
  if (!v8)
  {
    uint64_t v19 = FigSignalErrorAt();
    CFStringRef v9 = 0;
    goto LABEL_25;
  }
  CFStringRef v9 = (const void **)CFAllocatorAllocate(v4, v7, 0);
  if (!v9)
  {
    uint64_t v19 = FigSignalErrorAt();
    goto LABEL_25;
  }
  CFDictionaryGetKeysAndValues(a2, v8, v9);
  if (v6 < 1)
  {
    uint64_t v19 = 0;
    goto LABEL_25;
  }
  CFAllocatorRef allocator = v4;
  uint64_t v10 = 0;
  while (1)
  {
    CFArrayRef v11 = (const __CFArray *)v9[v10];
    CFIndex v12 = v11 ? CFArrayGetCount((CFArrayRef)v9[v10]) : 0;
    if (FigCFStringGetOSTypeValue() && v12 != 0) {
      break;
    }
LABEL_20:
    if (++v10 == v6)
    {
      uint64_t v19 = 0;
      goto LABEL_23;
    }
  }
  uint64_t appended = MovieTrackAddAndRetainSampleGroupDescriptionArray(a1, 0, &cf);
  if (appended) {
    goto LABEL_22;
  }
  if (v12 < 1)
  {
LABEL_18:
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
    goto LABEL_20;
  }
  CFIndex v15 = 0;
  while (1)
  {
    CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v11, v15);
    BytePtr = CFDataGetBytePtr(ValueAtIndex);
    size_t Length = CFDataGetLength(ValueAtIndex);
    uint64_t appended = MovieSampleGroupDescriptionArrayAppendDescriptionUniquely((uint64_t)cf, Length, BytePtr, 0);
    if (appended) {
      break;
    }
    if (v12 == ++v15) {
      goto LABEL_18;
    }
  }
LABEL_22:
  uint64_t v19 = appended;
LABEL_23:
  CFAllocatorRef v4 = allocator;
LABEL_25:
  if (cf) {
    CFRelease(cf);
  }
  if (v9) {
    CFAllocatorDeallocate(v4, v9);
  }
  if (v8) {
    CFAllocatorDeallocate(v4, v8);
  }
  return v19;
}

uint64_t MovieTrackAddAndRetainSampleGroupDescriptionArray(void *a1, int a2, void *a3)
{
  CFTypeRef cf = 0;
  MovieTrackCopySampleGroupDescriptionArray((uint64_t)a1, a2, (const __CFDictionary **)&cf);
  CFTypeRef v6 = cf;
  if (cf)
  {
    if (!a3)
    {
      uint64_t v7 = 0;
LABEL_11:
      CFRelease(v6);
      return v7;
    }
    goto LABEL_8;
  }
  CFAllocatorRef v8 = CFGetAllocator(a1);
  uint64_t v9 = MovieSampleGroupDescriptionArrayCreate(v8, a2, (uint64_t *)&cf);
  CFTypeRef v6 = cf;
  if (v9)
  {
    uint64_t v7 = v9;
    if (!cf) {
      return v7;
    }
    goto LABEL_11;
  }
  uint64_t v10 = MovieTrackAddSampleGroupDescriptionArray((CFMutableDictionaryRef *)a1, cf);
  uint64_t v7 = v10;
  CFTypeRef v6 = cf;
  if (a3 && !v10)
  {
    if (!cf)
    {
      CFTypeRef v11 = 0;
      goto LABEL_9;
    }
LABEL_8:
    CFTypeRef v11 = CFRetain(v6);
    CFTypeRef v6 = cf;
LABEL_9:
    uint64_t v7 = 0;
    *a3 = v11;
  }
  if (v6) {
    goto LABEL_11;
  }
  return v7;
}

uint64_t MovieTrackAppendSyncSampleCombinations(void *a1, const __CFArray *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  values = 0;
  keys = @"sync";
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!a2 || (CFIndex Count = CFArrayGetCount(a2)) == 0)
  {
    uint64_t v18 = 0;
    goto LABEL_21;
  }
  uint64_t v7 = Count;
  CFMutableArrayRef v8 = CFArrayCreateMutable(v4, Count, MEMORY[0x1E4F1D510]);
  values = v8;
  if (!v8)
  {
LABEL_23:
    uint64_t VideoSyncSampleEntryFromSampleAttachment = FigSignalErrorAt();
LABEL_24:
    uint64_t v18 = VideoSyncSampleEntryFromSampleAttachment;
LABEL_21:
    CFDictionaryRef v16 = 0;
    if (!Mutable) {
      goto LABEL_15;
    }
LABEL_14:
    CFRelease(Mutable);
    goto LABEL_15;
  }
  if (v7 >= 1)
  {
    uint64_t v9 = v8;
    CFIndex v10 = 0;
    CFTypeRef v11 = (const void *)*MEMORY[0x1E4F1F1D8];
    do
    {
      CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(a2, v10);
      *(_WORD *)bytes = 0;
      CFDictionarySetValue(Mutable, v11, ValueAtIndex);
      uint64_t VideoSyncSampleEntryFromSampleAttachment = FigMovieGetVideoSyncSampleEntryFromSampleAttachment((uint64_t)Mutable, &bytes[1], (BOOL *)bytes);
      if (VideoSyncSampleEntryFromSampleAttachment) {
        goto LABEL_24;
      }
      if (bytes[0])
      {
        CFDataRef v14 = CFDataCreate(v4, &bytes[1], 1);
        if (!v14) {
          goto LABEL_23;
        }
        CFDataRef v15 = v14;
        CFArrayAppendValue(v9, v14);
        CFRelease(v15);
      }
    }
    while (v7 != ++v10);
  }
  CFDictionaryRef v16 = CFDictionaryCreate(v4, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v16) {
    uint64_t appended = MovieTrackAppendSampleGroupDescriptions(a1, v16);
  }
  else {
    uint64_t appended = FigSignalErrorAt();
  }
  uint64_t v18 = appended;
  if (Mutable) {
    goto LABEL_14;
  }
LABEL_15:
  if (v16) {
    CFRelease(v16);
  }
  if (values) {
    CFRelease(values);
  }
  return v18;
}

uint64_t MovieTrackAppendTemporalLevelCombinations(const void *a1, const __CFArray *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  keys = @"tscl";
  if (!a2) {
    return 0;
  }
  CFAllocatorRef v5 = v4;
  CFIndex Count = CFArrayGetCount(a2);
  if (!Count) {
    return 0;
  }
  uint64_t v7 = Count;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v5, Count, MEMORY[0x1E4F1D510]);
  CFTypeRef cf = Mutable;
  if (Mutable)
  {
    uint64_t v22 = (void *)a1;
    if (v7 < 1)
    {
LABEL_13:
      CFDictionaryRef v18 = CFDictionaryCreate(v5, (const void **)&keys, &cf, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v18)
      {
        CFDictionaryRef v19 = v18;
        uint64_t appended = MovieTrackAppendSampleGroupDescriptions(v22, v18);
        CFRelease(v19);
      }
      else
      {
        uint64_t appended = FigSignalErrorAt();
      }
      CFDictionaryRef v14 = 0;
    }
    else
    {
      uint64_t v9 = Mutable;
      CFIndex v10 = 0;
      CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFIndex v12 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      CFStringRef v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      while (1)
      {
        values = 0;
        values = (void *)CFArrayGetValueAtIndex(a2, v10);
        CFDictionaryRef v14 = CFDictionaryCreate(v11, MEMORY[0x1E4F1F1E0], (const void **)&values, 1, v12, v13);
        *(void *)bytes = 0;
        uint64_t v25 = 0;
        int v26 = 0;
        char v23 = 0;
        uint64_t VideoTemporalLayerEntryFromSampleAttachment = FigMovieGetVideoTemporalLayerEntryFromSampleAttachment(v14, (uint64_t)bytes, &v23);
        if (VideoTemporalLayerEntryFromSampleAttachment) {
          break;
        }
        if (v23)
        {
          CFDataRef v16 = CFDataCreate(v5, bytes, 20);
          if (!v16)
          {
            uint64_t VideoTemporalLayerEntryFromSampleAttachment = FigSignalErrorAt();
            break;
          }
          CFDataRef v17 = v16;
          CFArrayAppendValue(v9, v16);
          CFRelease(v17);
        }
        if (v14) {
          CFRelease(v14);
        }
        if (v7 == ++v10) {
          goto LABEL_13;
        }
      }
      uint64_t appended = VideoTemporalLayerEntryFromSampleAttachment;
    }
    if (cf) {
      CFRelease(cf);
    }
    if (v14) {
      CFRelease(v14);
    }
    return appended;
  }

  return FigSignalErrorAt();
}

uint64_t MovieTrackCopyDataSourceForSampleDescriptionID(void *a1, uint64_t a2, int a3, void *a4, void *a5)
{
  CFIndex v9 = a3 - 1;
  CFTypeRef cf = 0;
  CFIndex idx = -1;
  BOOL v16 = 0;
  MEMORY[0x19970E290](*(void *)(a2 + 32));
  uint64_t SampleDescriptionInformationAtIndex = MovieTrackGetSampleDescriptionInformationAtIndex(a2, v9, 0, &idx);
  if (SampleDescriptionInformationAtIndex
    || (uint64_t SampleDescriptionInformationAtIndex = MovieTrackGetDataSourceAtIndex(a1, a2, idx, &v16, &cf),
        SampleDescriptionInformationAtIndex))
  {
    uint64_t v14 = SampleDescriptionInformationAtIndex;
    goto LABEL_15;
  }
  if (v16 && (CFAllocatorRef v11 = (const void *)a1[6]) != 0)
  {
    CFTypeRef cf = 0;
    if (!a5) {
      goto LABEL_10;
    }
    CFTypeRef v12 = CFRetain(v11);
  }
  else
  {
    if (!a5) {
      goto LABEL_10;
    }
    CFTypeRef v12 = 0;
  }
  *a5 = v12;
LABEL_10:
  if (a4)
  {
    CFTypeRef v13 = cf;
    if (cf) {
      CFTypeRef v13 = CFRetain(cf);
    }
    uint64_t v14 = 0;
    *a4 = v13;
  }
  else
  {
    uint64_t v14 = 0;
  }
LABEL_15:
  MEMORY[0x19970E2B0](*(void *)(a2 + 32));
  return v14;
}

uint64_t MovieTrackGetSampleDescriptionInformationAtIndex(uint64_t a1, CFIndex a2, void *a3, void *a4)
{
  CFArrayRef v5 = *(const __CFArray **)(a1 + 56);
  if (!v5 || a2 < 0 || CFArrayGetCount(v5) <= a2)
  {
    return FigSignalErrorAt();
  }
  else
  {
    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), a2);
    if (a3) {
      *a3 = *ValueAtIndex;
    }
    if (a4) {
      *a4 = ValueAtIndex[1];
    }
    return 0;
  }
}

uint64_t MovieTrackAddParsedDataReference(uint64_t a1, int a2, int a3, const void *a4)
{
  if (a3 == 1)
  {
    int v6 = 0;
    goto LABEL_5;
  }
  if (a3)
  {
    CFTypeRef v12 = "Unexpected value for data reference flags";
LABEL_15:
    MovieInformationReportParsingFailureMessage(0, a1, (uint64_t)v12, 2);
    goto LABEL_16;
  }
  int v6 = a2;
  if (!a4)
  {
    CFTypeRef v12 = "External data reference must have reference data";
    goto LABEL_15;
  }
LABEL_5:
  if (*(void *)(a1 + 64)
    || (CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0),
        (*(void *)(a1 + 64) = Mutable) != 0))
  {
    CFMutableArrayRef v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x1060040ABACF81FuLL);
    if (v8)
    {
      CFIndex v9 = v8;
      *CFMutableArrayRef v8 = v6;
      if (a4) {
        CFTypeRef v10 = CFRetain(a4);
      }
      else {
        CFTypeRef v10 = 0;
      }
      v9[1] = v10;
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 64), v9);
      return 0;
    }
  }
LABEL_16:

  return FigSignalErrorAt();
}

uint64_t TotalRunDataSize(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 48);
  if ((v2 & 2) == 0) {
    return (*(_DWORD *)(a1 + 64) * *(_DWORD *)(a2 + 36));
  }
  int v4 = *(_DWORD *)(a2 + 36);
  if (v4 < 1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = kPerSampleInfo_SizeInInt32s[v2];
  int v6 = (unsigned int *)(a2 + 4 * kPerSampleInfo_SizeIndex[v2] + 52);
  uint64_t v7 = 4 * v5;
  do
  {
    result += bswap32(*v6);
    int v6 = (unsigned int *)((char *)v6 + v7);
    --v4;
  }
  while (v4);
  return result;
}

CMTime *GetRevisedTrackDuration@<X0>(CMTime *result@<X0>, CMTime *a2@<X8>)
{
  int value = result[34].value;
  uint64_t v3 = (value - 1);
  if (value < 1)
  {
LABEL_6:
    uint64_t v7 = MEMORY[0x1E4F1FA48];
    *(_OWORD *)&a2->int value = *MEMORY[0x1E4F1FA48];
    a2->CMTimeEpoch epoch = *(void *)(v7 + 16);
  }
  else
  {
    int v4 = (_OWORD *)(result[33].epoch + 96 * v3 + 48);
    uint64_t v5 = v3 + 1;
    while ((*((unsigned char *)v4 - 36) & 1) == 0)
    {
      v4 -= 6;
      if (v5-- <= 1) {
        goto LABEL_6;
      }
    }
    long long v8 = *v4;
    long long v9 = v4[2];
    *(_OWORD *)&v10.start.CMTimeEpoch epoch = v4[1];
    *(_OWORD *)&v10.duration.uint64_t timescale = v9;
    *(_OWORD *)&v10.start.int value = v8;
    return CMTimeRangeGetEnd(a2, &v10);
  }
  return result;
}

uint64_t MovieDurationWithFragmentContribution@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = result;
  if (*(unsigned char *)(result + 155))
  {
    *(_OWORD *)a2 = *(_OWORD *)(result + 160);
    CMTimeEpoch epoch = *(void *)(result + 176);
  }
  else
  {
    CMTime v9 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    memset(&v8, 0, sizeof(v8));
    if (*(uint64_t *)(result + 304) >= 1)
    {
      uint64_t v5 = 0;
      do
      {
        GetRevisedTrackDuration(*(CMTime **)(*(void *)(v2 + 320) + 8 * v5), &v8);
        CMTime time1 = v8;
        CMTime v6 = v9;
        uint64_t result = CMTimeCompare(&time1, &v6);
        if ((int)result >= 1) {
          CMTime v9 = v8;
        }
        ++v5;
      }
      while (v5 < *(void *)(v2 + 304));
    }
    *(_OWORD *)a2 = *(_OWORD *)&v9.value;
    CMTimeEpoch epoch = v9.epoch;
  }
  *(void *)(a2 + 16) = epoch;
  return result;
}

void FreeSampleAuxInfo(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(CFTypeRef **)(a1 + 88);
    if (v2)
    {
      if (v2[2])
      {
        CFRelease(v2[2]);
        uint64_t v2 = *(CFTypeRef **)(a1 + 88);
      }
      if (v2[3])
      {
        CFRelease(v2[3]);
        uint64_t v2 = *(CFTypeRef **)(a1 + 88);
      }
      if (v2[4])
      {
        CFRelease(v2[4]);
        uint64_t v2 = *(CFTypeRef **)(a1 + 88);
      }
      free(v2);
      *(void *)(a1 + 88) = 0;
    }
  }
}

void MovieTrackDisposeFragments(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 728);
  if (v2)
  {
    FreeFragmentInfos(v2);
    uint64_t v3 = *(void *)(a1 + 728);
    *(void *)(v3 + 56) = 0;
    *(_DWORD *)(v3 + 8) = 0;
    *(void *)uint64_t v3 = 0;
  }
}

void FreeFragmentInfos(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 56);
  if (v1)
  {
    do
    {
      uint64_t v2 = (void *)*v1;
      uint64_t v3 = (void *)v1[9];
      if (v3)
      {
        do
        {
          int v4 = (void *)*v3;
          free(v3);
          uint64_t v3 = v4;
        }
        while (v4);
      }
      uint64_t v5 = (const void *)v1[12];
      if (v5)
      {
        CFRelease(v5);
        v1[12] = 0;
      }
      CMTime v6 = (const void *)v1[13];
      if (v6)
      {
        CFRelease(v6);
        v1[13] = 0;
      }
      uint64_t v7 = (const void *)v1[14];
      if (v7)
      {
        CFRelease(v7);
        v1[14] = 0;
      }
      CMTime v8 = (const void *)v1[15];
      if (v8)
      {
        CFRelease(v8);
        v1[15] = 0;
      }
      CMTime v9 = (const void *)v1[16];
      if (v9)
      {
        CFRelease(v9);
        v1[16] = 0;
      }
      CMTimeRange v10 = (const void *)v1[17];
      if (v10)
      {
        CFRelease(v10);
        v1[17] = 0;
      }
      CFAllocatorRef v11 = (const void *)v1[18];
      if (v11)
      {
        CFRelease(v11);
        v1[18] = 0;
      }
      CFTypeRef v12 = (const void *)v1[19];
      if (v12)
      {
        CFRelease(v12);
        v1[19] = 0;
      }
      CFTypeRef v13 = (const void *)v1[20];
      if (v13)
      {
        CFRelease(v13);
        v1[20] = 0;
      }
      uint64_t v14 = (const void *)v1[21];
      if (v14)
      {
        CFRelease(v14);
        v1[21] = 0;
      }
      FreeSampleAuxInfo((uint64_t)v1);
      free(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

uint64_t MovieSampleAccessorStepCursor(uint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v5 = *(unsigned int *)(a1 + 80);
  if (a3) {
    *a3 = 0;
  }
  uint64_t v6 = v5 + a2;
  uint64_t v7 = *(void *)(a1 + 8);
  if (a2 < 1)
  {
    uint64_t v14 = *(void *)(v7 + 728);
    if (v14 && (uint64_t v15 = *(void *)(v14 + 56)) != 0 && v5 > *(_DWORD *)(v7 + 288))
    {
      BOOL v11 = v6 < 1;
      if (v6 <= 1) {
        unint64_t v8 = 1;
      }
      else {
        unint64_t v8 = v5 + a2;
      }
      if (HIDWORD(v8)) {
        goto LABEL_60;
      }
      if (*(_DWORD *)(v15 + 32) <= v8)
      {
        LODWORD(result) = StepFragmentCursorTo(a1, v8);
LABEL_54:
        if (a3) {
          *a3 = v8 - v5;
        }
        *(_DWORD *)(a1 + 80) = v8;
        if (v11) {
          return 4294954456;
        }
        else {
          return result;
        }
      }
      unsigned int v16 = *(_DWORD *)(a1 + 184);
      *(_DWORD *)(a1 + 80) = v16;
      if (v16 >= v8)
      {
        if (v16 > v8)
        {
          while (*(_DWORD *)(a1 + 116) > v8)
          {
            uint64_t result = stepUpEntry(a1);
            if (result) {
              return result;
            }
          }
        }
      }
      else
      {
        while (*(_DWORD *)(a1 + 112) + *(_DWORD *)(a1 + 116) <= v8)
        {
          uint64_t result = stepDownEntry(a1);
          if (result) {
            return result;
          }
        }
      }
    }
    else
    {
      BOOL v11 = v5 <= -a2;
      if (v5 <= -a2) {
        unint64_t v8 = 1;
      }
      else {
        unint64_t v8 = v5 + a2;
      }
      if (HIDWORD(v8)) {
        goto LABEL_60;
      }
      while (*(_DWORD *)(a1 + 116) > v8)
      {
        uint64_t result = stepUpEntry(a1);
        if (result) {
          return result;
        }
      }
    }
LABEL_53:
    LODWORD(result) = 0;
    goto LABEL_54;
  }
  if (!HIDWORD(v6))
  {
    LODWORD(v8) = *(_DWORD *)(v7 + 288);
    uint64_t v9 = *(void *)(v7 + 728);
    if (v9)
    {
      if (*(void *)(v9 + 56) && v5 > v8) {
        goto LABEL_42;
      }
    }
    if (*(unsigned char *)(v7 + 240)) {
      LODWORD(v8) = (int)v8 / *(_DWORD *)(v7 + 244);
    }
    BOOL v11 = v8 < v6;
    if (v8 >= v6) {
      int v12 = v5 + a2;
    }
    else {
      int v12 = v8;
    }
    if (v9) {
      BOOL v13 = v8 >= v6;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13)
    {
      LODWORD(v8) = v12;
      goto LABEL_45;
    }
    if (*(void *)(v9 + 56))
    {
      ResetFragmentCursor(v7, a1 + 184);
      *(_DWORD *)(a1 + 184) = *(_DWORD *)(a1 + 80);
      *(_DWORD *)(a1 + 80) = *(_DWORD *)(*(void *)(a1 + 208) + 16);
LABEL_42:
      uint64_t result = StepFragmentCursorTo(a1, v6);
      if (a3) {
        *a3 = (*(_DWORD *)(a1 + 80) - v5);
      }
      return result;
    }
    BOOL v11 = 1;
LABEL_45:
    while (*(_DWORD *)(a1 + 112) + *(_DWORD *)(a1 + 116) <= v8)
    {
      uint64_t result = stepDownEntry(a1);
      if (result) {
        return result;
      }
    }
    goto LABEL_53;
  }
LABEL_60:

  return FigSignalErrorAt();
}

uint64_t StepFragmentCursorTo(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 208);
  unsigned int v3 = *((_DWORD *)v2 + 4);
  int v4 = *((_DWORD *)v2 + 9);
  if (v4 + v3 <= a2)
  {
    while (1)
    {
      uint64_t v2 = (uint64_t *)*v2;
      if (!v2)
      {
        uint64_t v6 = **(void **)(a1 + 200);
        if (!v6)
        {
          a2 = v3 + v4 - 1;
LABEL_13:
          uint64_t v7 = 4294954456;
          goto LABEL_14;
        }
        *(void *)(a1 + 200) = v6;
        uint64_t v2 = *(uint64_t **)(v6 + 72);
      }
      *(void *)(a1 + 208) = v2;
      unsigned int v3 = *((_DWORD *)v2 + 4);
      int v4 = *((_DWORD *)v2 + 9);
      if (v4 + v3 > a2) {
        goto LABEL_11;
      }
    }
  }
  while (v3 > a2)
  {
    uint64_t v2 = (uint64_t *)v2[1];
    if (!v2)
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 200) + 8);
      if (!v5) {
        goto LABEL_13;
      }
      *(void *)(a1 + 200) = v5;
      uint64_t v2 = *(uint64_t **)(v5 + 80);
    }
    *(void *)(a1 + 208) = v2;
    unsigned int v3 = *((_DWORD *)v2 + 4);
  }
LABEL_11:
  uint64_t v7 = 0;
LABEL_14:
  *(_DWORD *)(a1 + 80) = a2;
  return v7;
}

uint64_t AssureTrackFragmentFixups(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 728);
  if (!*(unsigned char *)(v1 + 12))
  {
    uint64_t v2 = *(uint64_t **)(v1 + 56);
    if (v2)
    {
      int v3 = *(_DWORD *)(result + 288);
      do
      {
        *((_DWORD *)v2 + 8) += v3;
        for (CFIndex i = (uint64_t *)v2[9]; i; CFIndex i = (uint64_t *)*i)
          *((_DWORD *)i + 4) += v3;
        uint64_t v2 = (uint64_t *)*v2;
      }
      while (v2);
    }
    *(unsigned char *)(v1 + 12) = 1;
  }
  return result;
}

uint64_t MovieTrackGetSampleCount(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 288);
  uint64_t v3 = *(void *)(a1 + 728);
  if (v3) {
    return (*(_DWORD *)(v3 + 8) + result);
  }
  return result;
}

uint64_t MovieSampleAccessorMoveToSampleForDTS(uint64_t a1, CMTime *a2, char *a3, char *a4)
{
  memset(&v46, 0, sizeof(v46));
  int32_t v8 = *(_DWORD *)(*(void *)(a1 + 8) + 232);
  CMTime v45 = *a2;
  CMTimeConvertScale(&v46, &v45, v8, kCMTimeRoundingMethod_RoundTowardNegativeInfinity);
  int v9 = a2->flags & 9;
  BOOL v10 = (~a2->flags & 5) == 0 || v9 == 9;
  if (v10)
  {
    BOOL v10 = v9 == 9;
    CMTimeValue v11 = 0x8000000000000000;
    if (!v10) {
      CMTimeValue v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    v46.CMTimeValue value = v11;
  }
  uint64_t result = *(void *)(a1 + 8);
  uint64_t v13 = *(void *)(result + 728);
  if (!v13 || (uint64_t v14 = *(void *)(v13 + 56)) == 0)
  {
    CMTimeValue value = v46.value;
LABEL_24:
    if (value >= *(void *)(a1 + 96))
    {
      while (1)
      {
        while (1)
        {
          CMTimeValue v22 = *(void *)(a1 + 96);
          uint64_t v23 = *(void *)(a1 + 104);
          uint64_t v27 = *(unsigned int *)(a1 + 112) * v23;
          BOOL v28 = ((unsigned __int128)*(unsigned int *)(a1 + 112) * v23) >> 64 != v27 >> 63;
          CMTimeValue v29 = v22 + v27;
          BOOL v30 = __OFADD__(v22, v27);
          if (!v28 && !v30) {
            break;
          }
          uint64_t result = FigSignalErrorAt();
          if (result) {
            goto LABEL_38;
          }
        }
        CMTimeValue v21 = v46.value;
        if (v46.value < v29) {
          break;
        }
        uint64_t result = stepDownEntry(a1);
        if (result) {
          goto LABEL_38;
        }
      }
LABEL_28:
      char v24 = 0;
      char v25 = 0;
      int v26 = *(_DWORD *)(a1 + 116) + (v21 - v22) / v23;
    }
    else
    {
      while (1)
      {
        uint64_t result = stepUpEntry(a1);
        if (result) {
          break;
        }
        CMTimeValue v21 = v46.value;
        CMTimeValue v22 = *(void *)(a1 + 96);
        if (v46.value >= v22)
        {
          uint64_t v23 = *(void *)(a1 + 104);
          goto LABEL_28;
        }
      }
LABEL_38:
      if (v46.value >= *(void *)(a1 + 96))
      {
        char v24 = 0;
        int v26 = *(_DWORD *)(*(void *)(a1 + 8) + 288);
        char v25 = 1;
      }
      else
      {
        char v25 = 0;
        int v26 = 1;
        char v24 = 1;
      }
    }
    *(_DWORD *)(a1 + 80) = v26;
    *a3 = v24;
    *a4 = v25;
    return result;
  }
  if (*(_DWORD *)(a1 + 80) <= *(_DWORD *)(result + 288))
  {
    CMTimeValue value = v46.value;
    if (v46.value < *(void *)(result + 224)) {
      goto LABEL_24;
    }
  }
  if (*(_DWORD *)(a1 + 80) <= *(_DWORD *)(result + 288))
  {
    unsigned int v16 = *(_DWORD *)(v14 + 32);
    ResetFragmentCursor(result, a1 + 184);
    *(_DWORD *)(a1 + 184) = *(_DWORD *)(a1 + 80);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(*(void *)(a1 + 208) + 16);
    uint64_t result = StepFragmentCursorTo(a1, v16);
  }
  CMTimeValue value = v46.value;
  *a4 = 0;
  CFDataRef v17 = *(uint64_t ***)(a1 + 200);
  CMTimeValue v18 = (CMTimeValue)v17[2];
  if (value >= v18)
  {
    LOBYTE(v20) = 1;
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 208);
    do
    {
      uint64_t v19 = *(void *)(v19 + 8);
      if (!v19)
      {
        CFDataRef v20 = v17[1];
        if (!v20) {
          goto LABEL_22;
        }
        *(void *)(a1 + 200) = v20;
        uint64_t v19 = v20[10];
        CFDataRef v17 = (uint64_t **)v20;
      }
      *(void *)(a1 + 208) = v19;
    }
    while (value < *(void *)(v19 + 24));
    LOBYTE(v20) = 1;
LABEL_22:
    CMTimeValue v18 = (CMTimeValue)v17[2];
  }
  if (value >= v18)
  {
    while (value >= (uint64_t)v17[2] + (uint64_t)v17[3])
    {
      CFMutableArrayRef v32 = *v17;
      if (!*v17)
      {
        uint64_t v37 = v17[9];
        do
        {
          long long v38 = v37;
          if (!v37) {
            break;
          }
          uint64_t v37 = (uint64_t *)*v37;
        }
        while (*v38);
        char v31 = 0;
        *(void *)(a1 + 208) = v38;
        *(_DWORD *)(a1 + 80) = *((_DWORD *)v38 + 4) + *((_DWORD *)v38 + 9) - 1;
        *a4 = 1;
        if (a3) {
          goto LABEL_46;
        }
        goto LABEL_47;
      }
      *(void *)(a1 + 200) = v32;
      *(void *)(a1 + 208) = v32[9];
      CFDataRef v17 = (uint64_t **)v32;
      if ((v20 & 1) == 0)
      {
        char v31 = 0;
        if (a3) {
          goto LABEL_46;
        }
        goto LABEL_47;
      }
    }
    uint64_t v33 = v17[9];
    if (v33 && value >= v33[3])
    {
      do
      {
        uint64_t v35 = v33;
        uint64_t v33 = (uint64_t *)*v33;
      }
      while (v33 && value >= v33[3]);
      *(void *)(a1 + 208) = v35;
      uint64_t v36 = *((unsigned int *)v35 + 12);
      if (v36)
      {
        int v39 = *((_DWORD *)v35 + 9);
        if (v39 < 1)
        {
          int v40 = 0;
        }
        else
        {
          int v40 = 0;
          uint64_t v41 = kPerSampleInfo_SizeInInt32s[v36];
          long long v42 = (unsigned int *)v35 + 13;
          CMTimeValue v43 = v35[3];
          uint64_t v44 = 4 * v41;
          while (1)
          {
            v43 += bswap32(*v42);
            if (v43 > value) {
              break;
            }
            ++v40;
            long long v42 = (unsigned int *)((char *)v42 + v44);
            if (v39 == v40)
            {
              int v40 = *((_DWORD *)v35 + 9);
              break;
            }
          }
        }
        char v31 = 0;
        int v34 = *((_DWORD *)v35 + 4) + v40;
      }
      else
      {
        char v31 = 0;
        int v34 = *((_DWORD *)v35 + 4) + (value - v35[3]) / *((unsigned int *)v17 + 15);
      }
    }
    else
    {
      char v31 = 0;
      *(void *)(a1 + 208) = v33;
      int v34 = *((_DWORD *)v33 + 4);
    }
    *(_DWORD *)(a1 + 80) = v34;
    if (a3) {
      goto LABEL_46;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(*(void *)(a1 + 208) + 16);
    char v31 = 1;
    if (a3) {
LABEL_46:
    }
      *a3 = v31;
  }
LABEL_47:
  if (value < v18 && *(_DWORD *)(*(void *)(a1 + 8) + 288))
  {
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 184);
    goto LABEL_24;
  }
  return result;
}

uint64_t MovieTrackGetMediaTimeScale(uint64_t a1)
{
  return *(unsigned int *)(a1 + 232);
}

uint64_t MovieSampleAccessorMoveToLastSampleInDecodeOrder(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 728);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 56);
    if (v4)
    {
      int v5 = *(_DWORD *)(v4 + 32);
      int v6 = *(_DWORD *)(v3 + 8);
      if (*(_DWORD *)(a1 + 80) <= *(_DWORD *)(v2 + 288))
      {
        ResetFragmentCursor(v2, a1 + 184);
        *(_DWORD *)(a1 + 184) = *(_DWORD *)(a1 + 80);
        *(_DWORD *)(a1 + 80) = *(_DWORD *)(*(void *)(a1 + 208) + 16);
      }
      StepFragmentCursorTo(a1, v5 + v6 - 1);
      return 0;
    }
  }
  while (!stepDownEntry(a1))
    ;
  int v7 = *(_DWORD *)(a1 + 116) + *(_DWORD *)(a1 + 112) - 1;
  *(_DWORD *)(a1 + 80) = v7;
  uint64_t v8 = *(void *)(a1 + 8);
  int v9 = *(_DWORD *)(v8 + 244);
  int v10 = *(_DWORD *)(v8 + 288);
  if (v9) {
    v10 /= v9;
  }
  if (v7 == v10) {
    return 0;
  }

  return FigSignalErrorAt();
}

uint64_t MovieSampleAccessorCreate(const void *a1, uint64_t a2, const void ***a3)
{
  int v6 = *(_DWORD *)(a2 + 288);
  uint64_t v7 = *(void *)(a2 + 728);
  if (v7 && *(void *)(v7 + 56)) {
    v6 += *(_DWORD *)(v7 + 8);
  }
  if (!v6)
  {
    uint64_t v8 = 0;
    uint64_t v11 = 4294954454;
LABEL_11:
    MovieSampleAccessorDispose(v8);
    uint64_t v8 = 0;
    goto LABEL_12;
  }
  uint64_t v8 = (const void **)malloc_type_calloc(1uLL, 0xD8uLL, 0x106004069928606uLL);
  if (v8)
  {
    if (a1) {
      CFTypeRef v9 = CFRetain(a1);
    }
    else {
      CFTypeRef v9 = 0;
    }
    *uint64_t v8 = v9;
    v8[1] = CFRetain((CFTypeRef)a2);
    uint64_t v10 = resetTrackCursor((uint64_t)v8);
  }
  else
  {
    uint64_t v10 = FigSignalErrorAt();
  }
  uint64_t v11 = v10;
  if (v10) {
    goto LABEL_11;
  }
LABEL_12:
  *a3 = v8;
  return v11;
}

void MovieSampleAccessorDispose(const void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2)
    {
      CFRelease(v2);
      *a1 = 0;
    }
    uint64_t v3 = a1[1];
    if (v3)
    {
      CFRelease(v3);
      a1[1] = 0;
    }
    uint64_t v4 = a1[2];
    if (v4)
    {
      CFRelease(v4);
      a1[2] = 0;
    }
    int v5 = a1[3];
    if (v5)
    {
      CFRelease(v5);
      a1[3] = 0;
    }
    int v6 = a1[4];
    if (v6)
    {
      CFRelease(v6);
      a1[4] = 0;
    }
    uint64_t v7 = a1[5];
    if (v7)
    {
      CFRelease(v7);
      a1[5] = 0;
    }
    uint64_t v8 = a1[6];
    if (v8)
    {
      CFRelease(v8);
      a1[6] = 0;
    }
    CFTypeRef v9 = a1[7];
    if (v9)
    {
      CFRelease(v9);
      a1[7] = 0;
    }
    uint64_t v10 = a1[8];
    if (v10)
    {
      CFRelease(v10);
      a1[8] = 0;
    }
    uint64_t v11 = a1[9];
    if (v11) {
      CFRelease(v11);
    }
    free(a1);
  }
}

uint64_t MovieSampleAccessorCopy(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(_DWORD *)(v4 + 288);
  uint64_t v6 = *(void *)(v4 + 728);
  if (v6 && *(void *)(v6 + 56)) {
    v5 += *(_DWORD *)(v6 + 8);
  }
  if (!v5)
  {
    uint64_t v7 = 0;
    uint64_t v23 = 4294954454;
    goto LABEL_28;
  }
  uint64_t v7 = malloc_type_calloc(1uLL, 0xD8uLL, 0x106004069928606uLL);
  if (!v7)
  {
LABEL_30:
    uint64_t v11 = FigSignalErrorAt();
LABEL_31:
    uint64_t v23 = v11;
    goto LABEL_28;
  }
  CFTypeRef v8 = *(CFTypeRef *)a1;
  if (*(void *)a1) {
    CFTypeRef v8 = CFRetain(v8);
  }
  *uint64_t v7 = v8;
  CFTypeRef v9 = *(CFTypeRef *)(a1 + 8);
  if (v9) {
    CFTypeRef v9 = CFRetain(v9);
  }
  v7[1] = v9;
  uint64_t v10 = *(void *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = MovieSampleGroupAccessorCopy(v10, v7 + 2);
    if (v11) {
      goto LABEL_31;
    }
  }
  uint64_t v12 = *(void *)(a1 + 24);
  if (v12)
  {
    uint64_t v11 = MovieSampleGroupAccessorCopy(v12, v7 + 3);
    if (v11) {
      goto LABEL_31;
    }
  }
  uint64_t v13 = *(void *)(a1 + 32);
  if (v13)
  {
    uint64_t v11 = MovieSampleGroupAccessorCopy(v13, v7 + 4);
    if (v11) {
      goto LABEL_31;
    }
  }
  uint64_t v14 = *(void *)(a1 + 40);
  if (v14)
  {
    uint64_t v11 = MovieSampleGroupAccessorCopy(v14, v7 + 5);
    if (v11) {
      goto LABEL_31;
    }
  }
  uint64_t v15 = *(void *)(a1 + 48);
  if (v15)
  {
    uint64_t v11 = MovieSampleGroupAccessorCopy(v15, v7 + 6);
    if (v11) {
      goto LABEL_31;
    }
  }
  uint64_t v16 = *(void *)(a1 + 56);
  if (v16)
  {
    uint64_t v11 = MovieSampleGroupAccessorCopy(v16, v7 + 7);
    if (v11) {
      goto LABEL_31;
    }
  }
  uint64_t v17 = *(void *)(a1 + 64);
  if (v17)
  {
    uint64_t v11 = MovieSampleGroupAccessorCopy(v17, v7 + 8);
    if (v11) {
      goto LABEL_31;
    }
  }
  CFDictionaryRef v18 = *(const __CFDictionary **)(a1 + 72);
  if (v18)
  {
    CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex Count = CFDictionaryGetCount(v18);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v19, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFMutableDictionaryRef v22 = Mutable;
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 72), (CFDictionaryApplierFunction)CopyMovieSampleGroupAccessorIntoNewDictionary, Mutable);
      v7[9] = v22;
      goto LABEL_27;
    }
    goto LABEL_30;
  }
LABEL_27:
  uint64_t v23 = 0;
  *((_OWORD *)v7 + 5) = *(_OWORD *)(a1 + 80);
  long long v24 = *(_OWORD *)(a1 + 96);
  long long v25 = *(_OWORD *)(a1 + 112);
  long long v26 = *(_OWORD *)(a1 + 144);
  *((_OWORD *)v7 + 8) = *(_OWORD *)(a1 + 128);
  *((_OWORD *)v7 + 9) = v26;
  *((_OWORD *)v7 + 6) = v24;
  *((_OWORD *)v7 + 7) = v25;
  long long v27 = *(_OWORD *)(a1 + 160);
  long long v28 = *(_OWORD *)(a1 + 176);
  long long v29 = *(_OWORD *)(a1 + 192);
  v7[26] = *(void *)(a1 + 208);
  *((_OWORD *)v7 + 11) = v28;
  *((_OWORD *)v7 + 12) = v29;
  *((_OWORD *)v7 + 10) = v27;
  *a2 = v7;
  uint64_t v7 = 0;
LABEL_28:
  MovieSampleAccessorDispose((const void **)v7);
  return v23;
}

void CopyMovieSampleGroupAccessorIntoNewDictionary(const void *a1, uint64_t a2, __CFDictionary *a3)
{
  CMTimeValue value = 0;
  MovieSampleGroupAccessorCopy(a2, (uint64_t *)&value);
  if (value)
  {
    CFDictionarySetValue(a3, a1, value);
    CFRelease(value);
  }
}

uint64_t MovieSampleAccessorGetDTSTimeValue(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 728);
  if (v2 && *(void *)(v2 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v1 + 288)) {
    return FragmentCursorGetDTSTimeValue(a1);
  }
  else {
    return *(void *)(a1 + 96) + *(void *)(a1 + 104) * (*(_DWORD *)(a1 + 80) - *(_DWORD *)(a1 + 116));
  }
}

uint64_t FragmentCursorGetDTSTimeValue(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 208);
  uint64_t v2 = *(void *)(v1 + 24);
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  unsigned int v4 = *(_DWORD *)(v1 + 16);
  LODWORD(v5) = v3 - v4;
  if (v3 < v4 || v3 >= *(_DWORD *)(v1 + 36) + v4)
  {
    FigSignalErrorAt();
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(v1 + 48);
    if (v6)
    {
      if ((int)v5 >= 1)
      {
        uint64_t v5 = (int)v5;
        uint64_t v7 = (unsigned int *)(v1 + 52);
        uint64_t v8 = 4 * kPerSampleInfo_SizeInInt32s[v6];
        do
        {
          v2 += bswap32(*v7);
          uint64_t v7 = (unsigned int *)((char *)v7 + v8);
          --v5;
        }
        while (v5);
      }
    }
    else
    {
      v2 += (*(_DWORD *)(*(void *)(a1 + 200) + 60) * v5);
    }
  }
  return v2;
}

uint64_t MovieSampleAccessorGetPTSTimeValue(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 80);
  unsigned int v3 = *(_DWORD *)(a1 + 132);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 728);
  if (v5 && *(void *)(v5 + 56) && v2 > *(_DWORD *)(v4 + 288))
  {
    DTSTimeCFArrayRef Value = FragmentCursorGetDTSTimeValue(a1);
    uint64_t v7 = *(_DWORD **)(a1 + 208);
    uint64_t v8 = v7[12];
    if ((v8 & 8) != 0)
    {
      unsigned int v27 = *(_DWORD *)(a1 + 80);
      unsigned int v28 = v7[4];
      if (v27 >= v28 && v27 < v7[9] + v28)
      {
        uint64_t v9 = (int)bswap32(v7[kPerSampleInfo_SizeInInt32s[v8] * (int)(v27 - v28)
                           + 13
                           + kPerSampleInfo_CompTimeOffIndex[v8]]);
        return v9 + DTSTimeValue;
      }
      uint64_t v29 = DTSTimeValue;
      FigSignalErrorAt();
      DTSTimeCFArrayRef Value = v29;
    }
    uint64_t v9 = 0;
    return v9 + DTSTimeValue;
  }
  uint64_t v10 = *(OpaqueCMBlockBuffer **)(v4 + 464);
  if (v10)
  {
    uint64_t v11 = *(int *)(a1 + 128);
    uint64_t destination = 0;
    CMBlockBufferCopyDataBytes(v10, 8 * v11, 8uLL, &destination);
    unsigned int v12 = *(_DWORD *)(a1 + 132);
    unsigned int v13 = v12 + bswap32(destination);
    if (v12 > v2 || v2 >= v13)
    {
      do
      {
        int v15 = *(_DWORD *)(a1 + 128);
        if (v2 >= v3)
        {
          int v19 = v15 + 1;
          uint64_t v18 = *(void *)(a1 + 8);
          if (v19 >= *(_DWORD *)(v18 + 456)) {
            goto LABEL_20;
          }
          *(_DWORD *)(a1 + 128) = v19;
        }
        else
        {
          unsigned int v16 = v15 - 1;
          if (v15 < 1) {
            goto LABEL_20;
          }
          *(_DWORD *)(a1 + 128) = v16;
          uint64_t v17 = *(void *)(a1 + 8);
          uint64_t destination = 0;
          CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v17 + 464), 8 * v16, 8uLL, &destination);
          unsigned int v13 = *(_DWORD *)(a1 + 132) - bswap32(destination);
          uint64_t v18 = *(void *)(a1 + 8);
        }
        *(_DWORD *)(a1 + 132) = v13;
        CFDataRef v20 = *(OpaqueCMBlockBuffer **)(v18 + 464);
        uint64_t v21 = *(int *)(a1 + 128);
        uint64_t destination = 0;
        CMBlockBufferCopyDataBytes(v20, 8 * v21, 8uLL, &destination);
        unsigned int v22 = *(_DWORD *)(a1 + 132);
        unsigned int v13 = v22 + bswap32(destination);
      }
      while (v22 > v2 || v2 >= v13);
    }
    uint64_t v23 = *(void *)(a1 + 8);
    uint64_t v24 = *(int *)(a1 + 128);
    uint64_t destination = 0;
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v23 + 464), 8 * v24, 8uLL, &destination);
    uint64_t v25 = (int)bswap32(HIDWORD(destination));
  }
  else
  {
LABEL_20:
    uint64_t v25 = 0;
  }
  return MovieSampleAccessorGetDTSTimeValue(a1) + v25;
}

BOOL MovieSampleTableHaveCompositionOffsetTable(uint64_t a1)
{
  return *(void *)(a1 + 464) != 0;
}

uint64_t MovieSampleTableGetCompositionOffsetDisplayOffset(uint64_t a1, int a2)
{
  uint64_t destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 464), 8 * a2, 8uLL, &destination);
  return bswap32(HIDWORD(destination));
}

uint64_t MovieSampleTableNumCompositionOffsetEntries(uint64_t a1)
{
  return *(unsigned int *)(a1 + 456);
}

uint64_t MovieSampleAccessorGetSampleDuration(uint64_t a1, CMTime *a2)
{
  long long v4 = *(_OWORD *)(a1 + 176);
  v25[10] = *(_OWORD *)(a1 + 160);
  v25[11] = v4;
  v25[12] = *(_OWORD *)(a1 + 192);
  uint64_t v26 = *(void *)(a1 + 208);
  long long v5 = *(_OWORD *)(a1 + 112);
  v25[6] = *(_OWORD *)(a1 + 96);
  v25[7] = v5;
  long long v6 = *(_OWORD *)(a1 + 144);
  v25[8] = *(_OWORD *)(a1 + 128);
  v25[9] = v6;
  long long v7 = *(_OWORD *)(a1 + 48);
  v25[2] = *(_OWORD *)(a1 + 32);
  v25[3] = v7;
  long long v8 = *(_OWORD *)(a1 + 80);
  v25[4] = *(_OWORD *)(a1 + 64);
  v25[5] = v8;
  long long v9 = *(_OWORD *)(a1 + 16);
  v25[0] = *(_OWORD *)a1;
  v25[1] = v9;
  MovieSampleAccessorStepFwdPTS((uint64_t)v25);
  if (v10 == -12840)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = *(void *)(v11 + 728);
    if (v12 && *(void *)(v12 + 56) && (unsigned int v13 = *(_DWORD *)(a1 + 80), v13 > *(_DWORD *)(v11 + 288)))
    {
      uint64_t v14 = *(_DWORD **)(a1 + 208);
      uint64_t v15 = v14[12];
      if (v15)
      {
        unsigned int v21 = v14[4];
        if (v13 < v21 || v13 >= v14[9] + v21)
        {
          FigSignalErrorAt();
          unsigned int v16 = 0;
        }
        else
        {
          unsigned int v16 = bswap32(v14[kPerSampleInfo_SizeInInt32s[v15] * (int)(v13 - v21) + 13]);
        }
      }
      else
      {
        unsigned int v16 = *(_DWORD *)(*(void *)(a1 + 200) + 60);
      }
      int64_t v19 = v16;
      uint64_t v11 = *(void *)(a1 + 8);
    }
    else
    {
      int64_t v19 = *(void *)(a1 + 104);
    }
    CMTimeMake(&v24, v19, *(_DWORD *)(v11 + 232));
  }
  else
  {
    PTSTimeCFArrayRef Value = MovieSampleAccessorGetPTSTimeValue((uint64_t)v25);
    CMTimeMake(&lhs, PTSTimeValue, *(_DWORD *)(*((void *)&v25[0] + 1) + 232));
    int64_t v18 = MovieSampleAccessorGetPTSTimeValue(a1);
    CMTimeMake(&rhs, v18, *(_DWORD *)(*(void *)(a1 + 8) + 232));
    CMTimeSubtract(&v24, &lhs, &rhs);
  }
  *a2 = v24;
  return 0;
}

__n128 MovieSampleAccessorStepFwdPTS(uint64_t a1)
{
  uint64_t v47 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  __n128 v40 = 0u;
  PTSTimeCFArrayRef Value = MovieSampleAccessorGetPTSTimeValue(a1);
  uint64_t v3 = PTSTimeValue;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 728);
  if (v5 && *(void *)(v5 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v4 + 288))
  {
    if (!*(unsigned char *)(v5 + 13))
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      goto LABEL_8;
    }
    long long v6 = (int *)(v5 + 32);
    long long v7 = (int *)(v5 + 36);
  }
  else
  {
    long long v6 = (int *)(v4 + 112);
    long long v7 = (int *)(v4 + 116);
  }
  uint64_t v8 = *v6;
  uint64_t v9 = *v7;
LABEL_8:
  long long v10 = *(_OWORD *)(a1 + 160);
  long long v11 = *(_OWORD *)(a1 + 192);
  long long v34 = *(_OWORD *)(a1 + 176);
  long long v35 = v11;
  __n128 v12 = *(__n128 *)(a1 + 96);
  long long v13 = *(_OWORD *)(a1 + 128);
  long long v14 = *(_OWORD *)(a1 + 144);
  long long v30 = *(_OWORD *)(a1 + 112);
  long long v31 = v13;
  char v38 = 0;
  uint64_t v36 = *(void *)(a1 + 208);
  long long v32 = v14;
  long long v33 = v10;
  long long v15 = *(_OWORD *)(a1 + 48);
  v27[2] = *(_OWORD *)(a1 + 32);
  v27[3] = v15;
  long long v16 = *(_OWORD *)(a1 + 80);
  v27[4] = *(_OWORD *)(a1 + 64);
  long long v28 = v16;
  __n128 v29 = v12;
  long long v17 = *(_OWORD *)(a1 + 16);
  v27[0] = *(_OWORD *)a1;
  v27[1] = v17;
  CMTimeMake(&v26, (PTSTimeValue - v8) & ~((PTSTimeValue - v8) >> 63), *(_DWORD *)(*((void *)&v27[0] + 1) + 232));
  MovieSampleAccessorMoveToSampleForDTS((uint64_t)v27, &v26, &v38, &v37);
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  char v20 = 1;
  do
  {
    while (1)
    {
      uint64_t v21 = MovieSampleAccessorGetPTSTimeValue((uint64_t)v27);
      if (v21 <= v3) {
        break;
      }
      if (v20 & 1 | (v21 < v18))
      {
        long long v45 = v34;
        long long v46 = v35;
        uint64_t v47 = v36;
        long long v41 = v30;
        long long v42 = v31;
        long long v43 = v32;
        long long v44 = v33;
        uint64_t v19 = v21 - v9;
        uint64_t v18 = v21;
        long long v39 = v28;
        __n128 v40 = v29;
      }
      if (MovieSampleAccessorGetDTSTimeValue((uint64_t)v27) <= v19)
      {
        char v20 = 0;
        if (!MovieSampleAccessorStepCursor((uint64_t)v27, 1, 0)) {
          continue;
        }
      }
      goto LABEL_18;
    }
  }
  while (!MovieSampleAccessorStepCursor((uint64_t)v27, 1, 0));
  if (v20) {
    return result;
  }
LABEL_18:
  *(void *)(a1 + 208) = v47;
  long long v23 = v46;
  *(_OWORD *)(a1 + 176) = v45;
  *(_OWORD *)(a1 + 192) = v23;
  long long v24 = v42;
  *(_OWORD *)(a1 + 112) = v41;
  *(_OWORD *)(a1 + 128) = v24;
  long long v25 = v44;
  *(_OWORD *)(a1 + 144) = v43;
  *(_OWORD *)(a1 + 160) = v25;
  __n128 result = v40;
  *(_OWORD *)(a1 + 80) = v39;
  *(__n128 *)(a1 + 96) = result;
  return result;
}

CMTime *MovieSampleAccessorGetPTS@<X0>(uint64_t a1@<X0>, CMTime *a2@<X8>)
{
  PTSTimeCFArrayRef Value = MovieSampleAccessorGetPTSTimeValue(a1);
  int32_t v5 = *(_DWORD *)(*(void *)(a1 + 8) + 232);

  return CMTimeMake(a2, PTSTimeValue, v5);
}

CMTime *MovieSampleAccessorGetDTS@<X0>(uint64_t a1@<X0>, CMTime *a2@<X8>)
{
  DTSTimeCFArrayRef Value = MovieSampleAccessorGetDTSTimeValue(a1);
  int32_t v5 = *(_DWORD *)(*(void *)(a1 + 8) + 232);

  return CMTimeMake(a2, DTSTimeValue, v5);
}

__n128 MovieSampleAccessorMoveToSampleAtPTS(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned char *a4)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  memset(&v51, 0, sizeof(v51));
  int32_t v8 = *(_DWORD *)(*(void *)(a1 + 8) + 232);
  *(_OWORD *)CMTimeRange time = *(_OWORD *)a2;
  *(void *)&time[16] = *(void *)(a2 + 16);
  CMTimeConvertScale(&v51, (CMTime *)time, v8, kCMTimeRoundingMethod_RoundTowardNegativeInfinity);
  int v9 = *(_DWORD *)(a2 + 12) & 9;
  if ((~*(_DWORD *)(a2 + 12) & 5) == 0 || v9 == 9)
  {
    BOOL v10 = v9 == 9;
    CMTimeValue v11 = 0x8000000000000000;
    if (!v10) {
      CMTimeValue v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    v51.CMTimeValue value = v11;
  }
  __int16 v50 = 0;
  *(CMTime *)CMTimeRange time = v51;
  MovieSampleAccessorMoveToSampleForDTS(a1, (CMTime *)time, (char *)&v50 + 1, (char *)&v50);
  uint64_t v13 = *(void *)(a1 + 8);
  uint64_t v14 = *(void *)(v13 + 728);
  if (v14) {
    LODWORD(v14) = *(unsigned __int8 *)(v14 + 13) != 0;
  }
  if (!*(unsigned char *)(v13 + 720) && !v14)
  {
    if (a3) {
      *a3 = HIBYTE(v50);
    }
    if (a4) {
      *a4 = v50;
    }
    return result;
  }
  uint64_t v16 = *(int *)(v13 + 112);
  uint64_t v15 = *(int *)(v13 + 116);
  unint64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
  if (v51.value <= 0) {
    unint64_t v17 = 0x8000000000000000;
  }
  BOOL v18 = __OFSUB__(v51.value, v15);
  uint64_t v19 = v51.value - v15;
  if (v18) {
    uint64_t v20 = v17;
  }
  else {
    uint64_t v20 = v19;
  }
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  char v21 = 0;
  do
  {
    if (MovieSampleAccessorStepCursor(a1, 1, 0)) {
      break;
    }
    PTSTimeCFArrayRef Value = MovieSampleAccessorGetPTSTimeValue(a1);
    if (PTSTimeValue == v51.value) {
      return result;
    }
    if (PTSTimeValue > v51.value) {
      char v21 = 1;
    }
  }
  while (MovieSampleAccessorGetDTSTimeValue(a1) <= v20);
  long long v58 = 0uLL;
  int v59 = 0;
  memset(time, 0, sizeof(time));
  long long v53 = 0u;
  __n128 v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  uint64_t v57 = 0;
  uint64_t v23 = *(void *)(a1 + 8);
  unsigned int v24 = *(_DWORD *)(v23 + 288);
  uint64_t v25 = *(void *)(v23 + 728);
  uint64_t v48 = a3;
  long long v49 = a4;
  if (v25) {
    v24 += *(_DWORD *)(v25 + 8);
  }
  int v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  if (*(_DWORD *)(a1 + 80) + 1 <= v24) {
    char v21 = 1;
  }
  __n128 v29 = (long long *)(a1 + 84);
  long long v30 = (_OWORD *)(a1 + 112);
  uint64_t v31 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    uint64_t v32 = MovieSampleAccessorGetPTSTimeValue(a1);
    CMTimeValue v33 = v32;
    if (v51.value == v32) {
      break;
    }
    if ((v32 & 0x8000000000000000) == 0 && v51.value > v32 && v51.value - v32 < v31)
    {
      int v26 = *(_DWORD *)(a1 + 80);
      long long v58 = *v29;
      int v59 = *(_DWORD *)(a1 + 100);
      uint64_t v27 = *(void *)(a1 + 104);
      long long v34 = *(_OWORD *)(a1 + 192);
      long long v55 = *(_OWORD *)(a1 + 176);
      long long v56 = v34;
      uint64_t v57 = *(void *)(a1 + 208);
      long long v35 = *(_OWORD *)(a1 + 128);
      *(_OWORD *)CMTimeRange time = *v30;
      *(_OWORD *)&time[16] = v35;
      __n128 v36 = *(__n128 *)(a1 + 160);
      uint64_t v31 = v51.value - v32;
      uint64_t v28 = v32;
      long long v53 = *(_OWORD *)(a1 + 144);
      __n128 v54 = v36;
    }
    if (v51.value < v32) {
      char v21 = 1;
    }
  }
  while ((!v26 || MovieSampleAccessorGetDTSTimeValue(a1) + v16 > v28)
       && !MovieSampleAccessorStepCursor(a1, -1, 0));
  if (v33 != v51.value)
  {
    if (v26 && (v21 || v28 + v27 > v51.value))
    {
      *(_DWORD *)(a1 + 80) = v26;
      long long *v29 = v58;
      *(_DWORD *)(a1 + 100) = v59;
      *(void *)(a1 + 104) = v27;
      long long v46 = v56;
      *(_OWORD *)(a1 + 176) = v55;
      *(_OWORD *)(a1 + 192) = v46;
      *(void *)(a1 + 208) = v57;
      long long v47 = *(_OWORD *)&time[16];
      _OWORD *v30 = *(_OWORD *)time;
      *(_OWORD *)(a1 + 128) = v47;
      __n128 result = v54;
      *(_OWORD *)(a1 + 144) = v53;
      *(__n128 *)(a1 + 160) = result;
      return result;
    }
    if (v51.value >= v33)
    {
      int64_t v39 = 0x8000000000000000;
      do
      {
        uint64_t v40 = MovieSampleAccessorGetPTSTimeValue(a1);
        if (v39 < v40)
        {
          int v26 = *(_DWORD *)(a1 + 80);
          long long v58 = *v29;
          int v59 = *(_DWORD *)(a1 + 100);
          uint64_t v27 = *(void *)(a1 + 104);
          long long v41 = *(_OWORD *)(a1 + 192);
          long long v55 = *(_OWORD *)(a1 + 176);
          long long v56 = v41;
          uint64_t v57 = *(void *)(a1 + 208);
          long long v42 = *(_OWORD *)(a1 + 128);
          *(_OWORD *)CMTimeRange time = *v30;
          *(_OWORD *)&time[16] = v42;
          __n128 v43 = *(__n128 *)(a1 + 160);
          int64_t v39 = v40;
          long long v53 = *(_OWORD *)(a1 + 144);
          __n128 v54 = v43;
        }
      }
      while (!MovieSampleAccessorStepCursor(a1, 1, 0));
      *(_DWORD *)(a1 + 80) = v26;
      long long *v29 = v58;
      *(_DWORD *)(a1 + 100) = v59;
      *(void *)(a1 + 104) = v27;
      long long v44 = v56;
      *(_OWORD *)(a1 + 176) = v55;
      *(_OWORD *)(a1 + 192) = v44;
      *(void *)(a1 + 208) = v57;
      long long v45 = *(_OWORD *)&time[16];
      _OWORD *v30 = *(_OWORD *)time;
      *(_OWORD *)(a1 + 128) = v45;
      __n128 result = v54;
      *(_OWORD *)(a1 + 144) = v53;
      *(__n128 *)(a1 + 160) = result;
      char v38 = v49;
      if (!v49) {
        return result;
      }
    }
    else
    {
      int v37 = resetTrackCursor(a1);
      char v38 = v48;
      if (!v48 || v37) {
        return result;
      }
    }
    *char v38 = 1;
  }
  return result;
}

void MovieSampleAccessorStepBackPTS(uint64_t a1)
{
  PTSTimeCFArrayRef Value = MovieSampleAccessorGetPTSTimeValue(a1);
  BOOL v3 = PTSTimeValue < 1;
  int64_t v4 = PTSTimeValue - 1;
  if (!v3)
  {
    __int16 v6 = 0;
    CMTimeMake(&v5, v4, *(_DWORD *)(*(void *)(a1 + 8) + 232));
    MovieSampleAccessorMoveToSampleAtPTS(a1, (uint64_t)&v5, (unsigned char *)&v6 + 1, &v6);
  }
}

uint64_t MovieSampleAccessorGetSampleLocation(uint64_t a1, uint64_t *a2, unint64_t a3, _DWORD *a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (!*(unsigned char *)(v4 + 719))
  {
    uint64_t v9 = *(void *)(v4 + 728);
    if (v9)
    {
      if (*(void *)(v9 + 56))
      {
        unsigned int v10 = *(_DWORD *)(a1 + 80);
        if (v10 > *(_DWORD *)(v4 + 288))
        {
          CMTimeValue v11 = *(_DWORD **)(a1 + 208);
          unsigned int v12 = v11[4];
          int v13 = v10 - v12;
          if (v10 < v12 || v10 >= v11[9] + v12)
          {
            FigSignalErrorAt();
            if (a4)
            {
LABEL_46:
              uint64_t result = 0;
              *a4 = *(_DWORD *)(*(void *)(a1 + 200) + 56);
              return result;
            }
          }
          else
          {
            if (a2)
            {
              uint64_t v14 = *(void *)(a1 + 200);
              uint64_t v15 = *(void *)(v14 + 48) + (int)v11[8];
              uint64_t v16 = v11[12];
              if ((v16 & 2) != 0)
              {
                if (v13 < 1)
                {
                  uint64_t v17 = 0;
                }
                else
                {
                  uint64_t v17 = 0;
                  uint64_t v30 = kPerSampleInfo_SizeInInt32s[v16];
                  uint64_t v31 = &v11[kPerSampleInfo_SizeIndex[v16] + 13];
                  uint64_t v32 = 4 * v30;
                  int v33 = v13;
                  do
                  {
                    v17 += bswap32(*v31);
                    uint64_t v31 = (unsigned int *)((char *)v31 + v32);
                    --v33;
                  }
                  while (v33);
                }
              }
              else
              {
                uint64_t v17 = (*(_DWORD *)(v14 + 64) * v13);
              }
              *a2 = v15 + v17;
            }
            if (a3)
            {
              uint64_t v34 = v11[12];
              if ((v34 & 2) != 0) {
                uint64_t v35 = bswap32(v11[kPerSampleInfo_SizeInInt32s[v34] * v13 + 13 + kPerSampleInfo_SizeIndex[v34]]);
              }
              else {
                uint64_t v35 = *(unsigned int *)(*(void *)(a1 + 200) + 64);
              }
              *(void *)a3 = v35;
            }
            if (a4) {
              goto LABEL_46;
            }
          }
          return 0;
        }
      }
    }
    int v36 = 0;
    uint64_t result = locateChunk(a1, &v36, a4);
    if (result) {
      return result;
    }
    if (!((unint64_t)a2 | a3)) {
      return 0;
    }
    uint64_t v19 = *(void *)(a1 + 8);
    LODWORD(v20) = *(_DWORD *)(v19 + 248);
    int v21 = v36;
    uint64_t result = CheckChunkNumber(v19, v36);
    if (result) {
      return result;
    }
    uint64_t v22 = (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 616))();
    if (!v20) {
      LODWORD(v20) = *(_DWORD *)(*(void *)(a1 + 8) + 292);
    }
    uint64_t v20 = (int)v20;
    if (*(_DWORD *)(a1 + 160) == v21)
    {
      int v23 = *(_DWORD *)(a1 + 164);
      unsigned int v24 = *(_DWORD *)(a1 + 80);
      if (v23 && v23 == v24 - 1)
      {
        if (!v20)
        {
          uint64_t v20 = (*(int (**)(void))(*(void *)(a1 + 8) + 592))();
          unsigned int v24 = *(_DWORD *)(a1 + 80);
        }
        uint64_t v22 = *(void *)(a1 + 176) + *(void *)(a1 + 168);
        uint64_t v25 = v20;
        goto LABEL_28;
      }
    }
    else
    {
      unsigned int v24 = *(_DWORD *)(a1 + 80);
    }
    unsigned int v26 = (v24 - *(_DWORD *)(a1 + 140)) % *(_DWORD *)(a1 + 148);
    unsigned int v27 = v24 - v26;
    if (v24 >= v26)
    {
      uint64_t v28 = 0;
      do
      {
        uint64_t v25 = (int)v20;
        if (!v20)
        {
          uint64_t v25 = (*(int (**)(void))(*(void *)(a1 + 8) + 592))();
          unsigned int v24 = *(_DWORD *)(a1 + 80);
        }
        v22 += v28;
        ++v27;
        uint64_t v28 = v25;
      }
      while (v27 <= v24);
    }
    else
    {
      uint64_t v25 = 0;
    }
LABEL_28:
    *(_DWORD *)(a1 + 160) = v21;
    *(_DWORD *)(a1 + 164) = v24;
    *(void *)(a1 + 168) = v22;
    *(void *)(a1 + 176) = v25;
    if (a2) {
      *a2 = v22;
    }
    if (a3)
    {
      uint64_t result = 0;
      uint64_t v29 = *(int *)(*(void *)(a1 + 8) + 248);
      if (!v29) {
        uint64_t v29 = v25;
      }
      *(void *)a3 = v29;
      return result;
    }
    return 0;
  }

  return FigSignalErrorAt();
}

uint64_t MovieSampleTableGetCommonSampleSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 292);
}

uint64_t MovieSampleAccessorGetChunkDetails(uint64_t a1, _DWORD *a2, uint64_t *a3, uint64_t *a4, void *a5, void *a6, BOOL *a7, BOOL *a8, unsigned char *a9)
{
  if (a9) {
    *a9 = 1;
  }
  uint64_t v17 = *(void *)(a1 + 8);
  uint64_t v18 = *(void *)(v17 + 728);
  if (v18)
  {
    if (*(void *)(v18 + 56))
    {
      unsigned int v19 = *(_DWORD *)(a1 + 80);
      if (v19 > *(_DWORD *)(v17 + 288))
      {
        if (a3) {
          *a3 = *(void *)(*(void *)(a1 + 200) + 48) + *(int *)(*(void *)(a1 + 208) + 32);
        }
        if (a4) {
          *a4 = TotalRunDataSize(*(void *)(a1 + 200), *(void *)(a1 + 208));
        }
        if (a5) {
          *a5 = *(int *)(*(void *)(a1 + 208) + 36);
        }
        if (a6) {
          *a6 = v19 - *(_DWORD *)(*(void *)(a1 + 208) + 16);
        }
        if (a7) {
          *a7 = (*(_DWORD *)(*(void *)(a1 + 208) + 48) & 2) == 0;
        }
        if (a8) {
          *a8 = (*(_DWORD *)(*(void *)(a1 + 208) + 48) & 1) == 0;
        }
        if (a2)
        {
          uint64_t result = 0;
          int v21 = *(_DWORD *)(*(void *)(a1 + 200) + 56);
LABEL_42:
          *a2 = v21;
          return result;
        }
        return 0;
      }
    }
  }
  uint64_t v44 = 0;
  uint64_t result = locateChunk(a1, (_DWORD *)&v44 + 1, &v44);
  if (!result)
  {
    uint64_t result = CheckChunkNumber(*(void *)(a1 + 8), SHIDWORD(v44));
    if (!result)
    {
      uint64_t v22 = (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 616))();
      uint64_t v23 = v22;
      if (a3) {
        *a3 = v22;
      }
      if (a4)
      {
        long long v24 = *(_OWORD *)(a1 + 176);
        long long v40 = *(_OWORD *)(a1 + 160);
        long long v41 = v24;
        long long v42 = *(_OWORD *)(a1 + 192);
        uint64_t v43 = *(void *)(a1 + 208);
        long long v25 = *(_OWORD *)(a1 + 112);
        long long v36 = *(_OWORD *)(a1 + 96);
        long long v37 = v25;
        long long v26 = *(_OWORD *)(a1 + 144);
        long long v38 = *(_OWORD *)(a1 + 128);
        long long v39 = v26;
        long long v27 = *(_OWORD *)(a1 + 48);
        v34[2] = *(_OWORD *)(a1 + 32);
        v34[3] = v27;
        long long v28 = *(_OWORD *)(a1 + 80);
        v34[4] = *(_OWORD *)(a1 + 64);
        long long v35 = v28;
        long long v29 = *(_OWORD *)(a1 + 16);
        v34[0] = *(_OWORD *)a1;
        v34[1] = v29;
        uint64_t v32 = 0;
        uint64_t v33 = 0;
        LODWORD(v35) = DWORD1(v39) + v35 + ~((v35 - HIDWORD(v38)) % DWORD1(v39));
        uint64_t result = MovieSampleAccessorGetSampleLocation((uint64_t)v34, &v33, (unint64_t)&v32, 0);
        if (result) {
          return result;
        }
        *a4 = v33 - v23 + v32;
      }
      uint64_t v30 = *(int *)(a1 + 148);
      if (a5) {
        *a5 = v30;
      }
      if (a6) {
        *a6 = (*(_DWORD *)(a1 + 80) - *(_DWORD *)(a1 + 140)) % v30;
      }
      if (a7)
      {
        BOOL v31 = v30 == 1 || *(_DWORD *)(*(void *)(a1 + 8) + 292) != 0;
        *a7 = v31;
      }
      if (a8)
      {
        if (v30 != 1) {
          LOBYTE(v30) = *(_DWORD *)(*(void *)(a1 + 8) + 408) == 1;
        }
        *a8 = v30;
      }
      if (a2)
      {
        uint64_t result = 0;
        int v21 = v44;
        goto LABEL_42;
      }
      return 0;
    }
  }
  return result;
}

uint64_t MovieSampleTableNumTimeToSampleEntries(uint64_t a1)
{
  return *(unsigned int *)(a1 + 408);
}

uint64_t MovieSampleAccessorComputePlayableHorizon(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a1 + 176);
  long long v5 = *(_OWORD *)(a1 + 192);
  long long v6 = *(_OWORD *)(a1 + 144);
  long long v81 = *(_OWORD *)(a1 + 160);
  long long v82 = v4;
  long long v83 = v5;
  long long v7 = *(_OWORD *)(a1 + 112);
  long long v8 = *(_OWORD *)(a1 + 128);
  long long v9 = *(_OWORD *)(a1 + 80);
  long long v77 = *(_OWORD *)(a1 + 96);
  long long v78 = v7;
  long long v79 = v8;
  long long v80 = v6;
  long long v10 = *(_OWORD *)(a1 + 48);
  long long v11 = *(_OWORD *)(a1 + 64);
  long long v12 = *(_OWORD *)(a1 + 16);
  v76[2] = *(_OWORD *)(a1 + 32);
  v76[3] = v10;
  uint64_t v84 = *(void *)(a1 + 208);
  v76[4] = v11;
  v76[5] = v9;
  v76[0] = *(_OWORD *)a1;
  v76[1] = v12;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  uint64_t v73 = 0;
  CMTime v72 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CMTime v71 = v72;
  uint64_t v13 = *(void *)(*(void *)(a1 + 8) + 728);
  if (v13 && *(void *)(v13 + 56))
  {
    PTSTimeCFArrayRef Value = MovieSampleAccessorGetPTSTimeValue(a1);
    CMTimeMake(&v71, PTSTimeValue, *(_DWORD *)(*(void *)(a1 + 8) + 232));
    MovieTrackGetMediaDuration(*(void *)(a1 + 8), (uint64_t)&v72);
    uint64_t v15 = 0;
    goto LABEL_19;
  }
  uint64_t SampleLocation = MovieSampleAccessorGetSampleLocation(a1, &v74, (unint64_t)&v75, 0);
  if (SampleLocation) {
    goto LABEL_72;
  }
  uint64_t v17 = v74;
  if (((v75 | v74) & 0x8000000000000000) == 0)
  {
    uint64_t v18 = *(void *)a1;
    unint64_t v19 = *(void *)(*(void *)a1 + 72);
    if ((uint64_t)v19 > v74 && v75 + v74 <= v19) {
      goto LABEL_10;
    }
  }
  uint64_t SampleLocation = FigSignalErrorAt();
  if (SampleLocation)
  {
LABEL_72:
    uint64_t v15 = SampleLocation;
    goto LABEL_19;
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v17 = v74;
LABEL_10:
  uint64_t v20 = *(void *)(v18 + 48);
  uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v21) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  uint64_t v23 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(v22 + 24);
  if (!v23)
  {
    uint64_t v15 = 4294954514;
    goto LABEL_19;
  }
  uint64_t SampleLocation = v23(v20, v17, &v73);
  if (SampleLocation) {
    goto LABEL_72;
  }
  if (!v73)
  {
    uint64_t v15 = 0;
    uint64_t v28 = MEMORY[0x1E4F1FA48];
    *(_OWORD *)a2 = *MEMORY[0x1E4F1FA48];
    uint64_t v26 = *(void *)(v28 + 16);
    goto LABEL_20;
  }
  uint64_t v68 = v74 + v73;
  int v67 = *(_DWORD *)(a1 + 80);
  int v24 = *(_DWORD *)(a1 + 136);
  uint64_t v64 = a2;
  if (*(_DWORD *)(*(void *)(a1 + 8) + 432) == 1) {
    int v25 = 1;
  }
  else {
    int v25 = *(_DWORD *)(a1 + 140);
  }
  int v65 = 0;
  int v66 = 0;
  lhs.CMTimeValue value = 0;
  rhs.CMTimeValue value = 0;
  unsigned int v30 = *(_DWORD *)(a1 + 144);
  signed int v29 = *(_DWORD *)(a1 + 148);
  int v31 = v25 + (v67 - v25) / v29 * v29;
  while (1)
  {
    int v32 = v25 + v30 * v29;
    if (v31 < v25)
    {
      uint64_t v33 = *(void *)(a1 + 8);
LABEL_32:
      int v41 = v24 + 1;
      int v42 = *(_DWORD *)(v33 + 432);
      if (v24 + 1 >= v42) {
        goto LABEL_60;
      }
      if (v42 != 1)
      {
        *(_DWORD *)&destination[8] = 0;
        *(void *)uint64_t destination = 0;
        CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v33 + 440), 12 * v41, 0xCuLL, destination);
        signed int v29 = bswap32(*(unsigned int *)&destination[4]);
        uint64_t v33 = *(void *)(a1 + 8);
      }
      v29 /= *(int *)(v33 + 244);
      if (v24 + 2 == *(_DWORD *)(v33 + 432))
      {
        unsigned int v43 = (*(uint64_t (**)(void))(v33 + 624))() + 1;
      }
      else
      {
        *(_DWORD *)&destination[8] = 0;
        *(void *)uint64_t destination = 0;
        CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v33 + 440), 12 * (v24 + 2), 0xCuLL, destination);
        unsigned int v43 = bswap32(*(unsigned int *)destination);
      }
      uint64_t v44 = *(void *)(a1 + 8);
      *(_DWORD *)&destination[8] = 0;
      *(void *)uint64_t destination = 0;
      CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v44 + 440), 12 * v41, 0xCuLL, destination);
      BOOL v45 = 0;
      unsigned int v30 = v43 - bswap32(*(unsigned int *)destination);
      ++v24;
      int v25 = v32;
      goto LABEL_39;
    }
    uint64_t v33 = *(void *)(a1 + 8);
    if (v31 >= v32) {
      goto LABEL_32;
    }
    *(_DWORD *)&destination[8] = 0;
    *(void *)uint64_t destination = 0;
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v33 + 440), 12 * v24, 0xCuLL, destination);
    unsigned int v34 = bswap32(*(unsigned int *)destination);
    uint64_t v35 = CheckChunkNumber(*(void *)(a1 + 8), v34 - 1);
    if (v35
      || (v36 = (v31 - v25) / v29, uint64_t v35 = CheckChunkNumber(*(void *)(a1 + 8), v36 + v34 - 1), v35))
    {
LABEL_71:
      uint64_t v15 = v35;
      goto LABEL_70;
    }
    uint64_t v37 = (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 616))();
    if (v37 >= v68) {
      break;
    }
LABEL_46:
    if ((int)(v36 + v34) < (*(int (**)(void))(*(void *)(a1 + 8) + 624))()
      && ((uint64_t v47 = (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 616))(), v37 < v47) ? (v48 = v47 <= v68) : (v48 = 0), v48))
    {
      BOOL v45 = 0;
      v31 += v29;
      int v65 = 1;
      int v66 = v31;
    }
    else
    {
      uint64_t v98 = 0;
      long long v49 = *(_OWORD *)(a1 + 176);
      long long v94 = *(_OWORD *)(a1 + 160);
      long long v95 = v49;
      long long v96 = *(_OWORD *)(a1 + 192);
      uint64_t v97 = *(void *)(a1 + 208);
      long long v50 = *(_OWORD *)(a1 + 112);
      long long v90 = *(_OWORD *)(a1 + 96);
      long long v91 = v50;
      long long v51 = *(_OWORD *)(a1 + 144);
      long long v92 = *(_OWORD *)(a1 + 128);
      long long v93 = v51;
      long long v52 = *(_OWORD *)(a1 + 48);
      long long v86 = *(_OWORD *)(a1 + 32);
      long long v87 = v52;
      long long v53 = *(_OWORD *)(a1 + 80);
      long long v88 = *(_OWORD *)(a1 + 64);
      long long v89 = v53;
      long long v54 = *(_OWORD *)(a1 + 16);
      int v55 = v31 + v29;
      *(_OWORD *)uint64_t destination = *(_OWORD *)a1;
      *(_OWORD *)&destination[16] = v54;
      MovieSampleAccessorStepCursor((uint64_t)destination, (v31 + v29 + ~v89), 0);
      if (MovieSampleAccessorGetSampleLocation((uint64_t)destination, &lhs.value, (unint64_t)&v98, 0))
      {
        BOOL v45 = 1;
      }
      else
      {
        BOOL v45 = v98 + lhs.value > (unint64_t)v68;
        if (v98 + lhs.value <= (unint64_t)v68) {
          v31 += v29;
        }
      }
      if (v31 <= v67) {
        int v56 = v67;
      }
      else {
        int v56 = v31;
      }
      int v65 = 1;
      int v66 = v56;
      int v31 = v55;
    }
LABEL_39:
    if (v45) {
      goto LABEL_60;
    }
  }
  uint64_t v38 = *(void *)(*(void *)a1 + 48);
  uint64_t v39 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v39) {
    uint64_t v40 = v39;
  }
  else {
    uint64_t v40 = 0;
  }
  long long v46 = *(uint64_t (**)(uint64_t, uint64_t, CMTime *))(v40 + 24);
  if (!v46)
  {
    uint64_t v15 = 4294954514;
LABEL_70:
    a2 = v64;
    goto LABEL_19;
  }
  uint64_t v35 = v46(v38, v37, &rhs);
  if (v35) {
    goto LABEL_71;
  }
  if (rhs.value)
  {
    uint64_t v68 = rhs.value + v37;
    goto LABEL_46;
  }
LABEL_60:
  if (v65) {
    int v57 = v66;
  }
  else {
    int v57 = v67;
  }
  int64_t v58 = MovieSampleAccessorGetPTSTimeValue(a1);
  CMTimeMake(&v71, v58, *(_DWORD *)(*(void *)(a1 + 8) + 232));
  uint64_t v59 = MovieSampleAccessorStepCursor((uint64_t)v76, (v57 - *(_DWORD *)(a1 + 80)), 0);
  if (v59 == -12840)
  {
    MovieSampleAccessorMoveToSampleAtPTS((uint64_t)v76, MEMORY[0x1E4F1FA10], 0, 0);
    uint64_t v15 = v62;
    a2 = v64;
    if (v62) {
      goto LABEL_19;
    }
    uint64_t v63 = MovieSampleAccessorGetPTSTimeValue((uint64_t)v76);
    int64_t v60 = *((void *)&v77 + 1) + v63;
    int32_t v61 = *(_DWORD *)(*((void *)&v76[0] + 1) + 232);
  }
  else
  {
    uint64_t v15 = v59;
    a2 = v64;
    if (v59) {
      goto LABEL_19;
    }
    int64_t v60 = MovieSampleAccessorGetPTSTimeValue((uint64_t)v76);
    int32_t v61 = *(_DWORD *)(*(void *)(a1 + 8) + 232);
  }
  CMTimeMake(&v72, v60, v61);
LABEL_19:
  CMTime lhs = v72;
  CMTime rhs = v71;
  CMTimeSubtract((CMTime *)destination, &lhs, &rhs);
  *(_OWORD *)a2 = *(_OWORD *)destination;
  uint64_t v26 = *(void *)&destination[16];
LABEL_20:
  *(void *)(a2 + 16) = v26;
  return v15;
}

double MovieTrackGetMediaDuration@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  CMTimeMake((CMTime *)a2, *(void *)(a1 + 224), *(_DWORD *)(a1 + 232));
  long long v5 = *(int64_t **)(a1 + 728);
  if (v5)
  {
    if (v5[7])
    {
      CMTimeMake(&rhs, *v5, *(_DWORD *)(a1 + 232));
      CMTime v6 = *(CMTime *)a2;
      CMTimeAdd(&v8, &v6, &rhs);
      double result = *(double *)&v8.value;
      *(CMTime *)a2 = v8;
    }
  }
  return result;
}

uint64_t MovieSampleAccessorGetDependencyInfo(uint64_t a1, unsigned char *a2, unsigned char *a3, unsigned char *a4, unsigned char *a5, _DWORD *a6, BOOL *a7)
{
  uint64_t v14 = *(void *)(a1 + 8);
  uint64_t v15 = *(void *)(v14 + 728);
  if (v15 && *(void *)(v15 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v14 + 288))
  {
    uint64_t SampleFlags = FragmentCursorGetSampleFlags(a1);
    if (a2) {
      *a2 = (SampleFlags & 0x10000) == 0;
    }
    if (a3) {
      *a3 = 0;
    }
    if (a6) {
      *a6 = 2;
    }
    if (a7) {
      *a7 = (SampleFlags & 0xC00000) == 0x800000;
    }
    unsigned int v17 = FragmentCursorGetSampleFlags(a1);
    if (a4 && a5)
    {
      unsigned int v18 = v17;
      uint64_t v19 = *(void *)(a1 + 200);
      uint64_t v20 = *(OpaqueCMBlockBuffer **)(v19 + 96);
      if (!v20
        || CMBlockBufferCopyDataBytes(v20, (*(_DWORD *)(a1 + 80) - *(_DWORD *)(v19 + 32)), 1uLL, a5))
      {
        *a5 = (v18 >> 20) & 0x7F;
      }
      *a4 = 1;
    }
  }
  else
  {
    if (a2)
    {
      if (*(void *)(v14 + 488))
      {
        uint64_t v21 = *(int *)(v14 + 480);
        if (v21) {
          char SampleInTable = NEW_findSampleInTable(v14, (uint64_t (*)(void))MovieSampleTableGetSyncSampleNumber, v21, *(_DWORD *)(a1 + 80), (_DWORD *)(a1 + 152));
        }
        else {
          char SampleInTable = 0;
        }
      }
      else
      {
        char SampleInTable = 1;
      }
      *a2 = SampleInTable;
    }
    if (a3)
    {
      uint64_t v23 = *(void *)(a1 + 8);
      if (*(void *)(v23 + 512) && (uint64_t v24 = *(int *)(v23 + 504), v24)) {
        char v25 = NEW_findSampleInTable(v23, (uint64_t (*)(void))MovieSampleTableGetPartialSyncSampleNumber, v24, *(_DWORD *)(a1 + 80), (_DWORD *)(a1 + 156));
      }
      else {
        char v25 = 0;
      }
      *a3 = v25;
    }
    if (a4 && a5)
    {
      uint64_t v26 = *(void *)(a1 + 8);
      uint64_t v27 = *(void *)(v26 + 536);
      if (v27)
      {
        *a5 = MovieSampleTableGetSampleDependencyFlags(v26, *(_DWORD *)(a1 + 80) - 1);
        LOBYTE(v27) = 1;
      }
      *a4 = v27;
    }
    if (a6) {
      *a6 = 2;
    }
    if (a7)
    {
      uint64_t v28 = *(void *)(a1 + 8);
      if (*(void *)(v28 + 536)) {
        *a7 = (MovieSampleTableGetSampleDependencyFlags(v28, *(_DWORD *)(a1 + 80) - 1) & 8) != 0;
      }
      else {
        *a7 = 0;
      }
    }
  }
  return 0;
}

uint64_t FragmentCursorGetSampleFlags(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 80);
  uint64_t v2 = *(void *)(a1 + 208);
  unsigned int v3 = *(_DWORD *)(v2 + 16);
  if (v1 == v3 && *(unsigned char *)(v2 + 40))
  {
    unsigned int v4 = *(_DWORD *)(v2 + 44);
  }
  else
  {
    uint64_t v5 = *(unsigned int *)(v2 + 48);
    if ((v5 & 4) == 0) {
      return *(unsigned int *)(*(void *)(a1 + 200) + 68);
    }
    if (v1 < v3 || v1 >= *(_DWORD *)(v2 + 36) + v3)
    {
      FigSignalErrorAt();
      return 0;
    }
    unsigned int v4 = *(_DWORD *)(v2 + 4 * kPerSampleInfo_SizeInInt32s[v5] * (int)(v1 - v3) + 4 * kPerSampleInfo_FlagsIndex[v5] + 52);
  }
  return bswap32(v4);
}

BOOL MovieSampleTableHaveSampleDependencyTable(uint64_t a1)
{
  return *(void *)(a1 + 536) != 0;
}

uint64_t MovieSampleTableGetSampleDependencyFlags(uint64_t a1, int a2)
{
  uint64_t result = 0;
  unsigned __int8 destination = 0;
  if (*(_DWORD *)(a1 + 528) > a2)
  {
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 536), a2, 1uLL, &destination);
    return destination;
  }
  return result;
}

CFArrayRef MovieTrackGetNumSampleDescriptions(uint64_t a1)
{
  CFArrayRef result = *(const __CFArray **)(a1 + 56);
  if (result) {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

void *MovieInformationClearChangeBits(void *result, int a2)
{
  result[5] = 0;
  if (a2)
  {
    uint64_t v2 = result[38];
    if (v2 >= 1)
    {
      unsigned int v3 = (uint64_t *)result[40];
      do
      {
        uint64_t v4 = *v3++;
        *(void *)(v4 + 16) = 0;
        --v2;
      }
      while (v2);
    }
  }
  return result;
}

uint64_t MovieInformationGetTrackCount(uint64_t a1)
{
  return *(void *)(a1 + 304);
}

uint64_t MovieInformationFindTrackForTrackIndex(uint64_t a1, uint64_t a2)
{
  if (a2 < 0 || *(void *)(a1 + 304) <= a2) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 320) + 8 * a2);
  }
}

uint64_t MovieInformationGetChangeBits(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t MovieTrackFindOrAddSampleDescription(uint64_t a1, const void *a2, const void *a3, _DWORD *a4)
{
  if (!*(void *)(a1 + 56))
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    *(void *)(a1 + 56) = Mutable;
    if (!Mutable) {
      goto LABEL_34;
    }
  }
  if (!*(void *)(a1 + 64))
  {
    CFMutableArrayRef v9 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    *(void *)(a1 + 64) = v9;
    if (!v9) {
      goto LABEL_34;
    }
  }
  CFArrayRef v10 = *(const __CFArray **)(a1 + 48);
  if (!v10)
  {
    CFArrayRef v10 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    *(void *)(a1 + 48) = v10;
    if (!v10) {
      goto LABEL_34;
    }
  }
  v26.length = CFArrayGetCount(v10);
  v26.location = 0;
  FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v10, v26, a2);
  for (CFIndex i = 0; ; ++i)
  {
    CFArrayRef Count = *(const __CFArray **)(a1 + 64);
    if (Count) {
      CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
    }
    if (i >= (uint64_t)Count) {
      break;
    }
    CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), i);
    if (FigCFEqual())
    {
      if (FirstIndexOfValue != -1)
      {
        CFIndex v18 = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
        while (v18-- >= 1)
        {
          CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v18);
          if (*ValueAtIndex == FirstIndexOfValue && ValueAtIndex[1] == i)
          {
            int v22 = v18 + 1;
            if (a4) {
              goto LABEL_32;
            }
            return 0;
          }
        }
      }
      goto LABEL_28;
    }
  }
  uint64_t v14 = malloc_type_malloc(0x18uLL, 0x1060040ABACF81FuLL);
  if (!v14) {
    goto LABEL_34;
  }
  uint64_t v15 = v14;
  v14[1] = 0;
  if (a3)
  {
    CFTypeRef v16 = CFRetain(a3);
    int v17 = 1970433056;
  }
  else
  {
    int v17 = 0;
    CFTypeRef v16 = 0;
  }
  CMTime v15[2] = v16;
  *(_DWORD *)uint64_t v15 = v17;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 64), v15);
  CFIndex i = CFArrayGetCount(*(CFArrayRef *)(a1 + 64)) - 1;
LABEL_28:
  if (FirstIndexOfValue == -1)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), a2);
    FirstIndexOfCFArrayRef Value = CFArrayGetCount(*(CFArrayRef *)(a1 + 48)) - 1;
    *(void *)(a1 + 16) |= 4uLL;
  }
  uint64_t v23 = malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
  if (v23)
  {
    *uint64_t v23 = FirstIndexOfValue;
    v23[1] = i;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), v23);
    int v22 = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
    if (a4) {
LABEL_32:
    }
      *a4 = v22;
    return 0;
  }
  else
  {
LABEL_34:
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleAccessorGetFormatDescription(uint64_t a1, const void **a2)
{
  int v8 = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 728);
  if (v5 && *(void *)(v5 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v4 + 288))
  {
    int v6 = *(_DWORD *)(*(void *)(a1 + 200) + 56);
    int v8 = v6;
  }
  else
  {
    uint64_t result = locateChunk(a1, &v9, &v8);
    if (result) {
      return result;
    }
    uint64_t v4 = *(void *)(a1 + 8);
    int v6 = v8;
  }
  return GetFormatDescriptionForSampleDescriptionID(v4, v6, a2);
}

uint64_t GetFormatDescriptionForSampleDescriptionID(uint64_t a1, int a2, const void **a3)
{
  CFIndex idx = -1;
  uint64_t SampleDescriptionInformationAtIndex = MovieTrackGetSampleDescriptionInformationAtIndex(a1, a2 - 1, &idx, 0);
  if (!SampleDescriptionInformationAtIndex) {
    *a3 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), idx);
  }
  return SampleDescriptionInformationAtIndex;
}

uint64_t MovieSampleAccessorGetRollValue(uint64_t a1, _WORD *a2)
{
  CFDataRef theData = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 728);
  if (v5 && *(void *)(v5 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v4 + 288))
  {
    int v6 = (uint64_t *)(*(void *)(a1 + 200) + 120);
    uint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1919904876);
    CFDataRef v9 = (const __CFData *)FragmentCursorEnsureAccessorAndCopySampleGroupDescription(a1, v6, Basic, v8);
    CFArrayRef v10 = 0;
    CFDataRef theData = v9;
  }
  else
  {
    long long v12 = (uint64_t *)(a1 + 16);
    uint64_t v11 = *(void *)(a1 + 16);
    if (v11)
    {
      CFArrayRef v10 = 0;
    }
    else
    {
      uint64_t v14 = MovieSampleGroupTypeSpecMakeBasic(1919904876);
      uint64_t v15 = *(void *)(v4 + 72);
      if (v15) {
        CFArrayRef v10 = MovieSampleGroupCollectionLookupAndRetainSampleGroup(v15, v14, v13);
      }
      else {
        CFArrayRef v10 = 0;
      }
      if (MovieSampleGroupAccessorCreate(v10, (uint64_t *)(a1 + 16))) {
        goto LABEL_21;
      }
      uint64_t v11 = *v12;
    }
    if (MovieSampleGroupAccessorCopyDescriptionForSample(v11, *(unsigned int *)(a1 + 80), &theData)) {
      goto LABEL_21;
    }
    CFDataRef v9 = theData;
  }
  if (v9 && CFDataGetLength(v9) == 2)
  {
    *a2 = bswap32(*(unsigned __int16 *)CFDataGetBytePtr(theData)) >> 16;
    uint64_t v16 = 1;
    if (!v10) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_21:
  uint64_t v16 = 0;
  if (v10) {
LABEL_17:
  }
    CFRelease(v10);
LABEL_18:
  if (theData) {
    CFRelease(theData);
  }
  return v16;
}

uint64_t MovieSampleAccessorGetIndependentFramePrerollPacketCount(uint64_t a1, _WORD *a2)
{
  CFDataRef theData = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 728);
  if (v5 && *(void *)(v5 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v4 + 288))
  {
    int v6 = (uint64_t *)(*(void *)(a1 + 200) + 128);
    uint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1886547820);
    CFDataRef v9 = (const __CFData *)FragmentCursorEnsureAccessorAndCopySampleGroupDescription(a1, v6, Basic, v8);
    CFArrayRef v10 = 0;
    CFDataRef theData = v9;
  }
  else
  {
    long long v12 = (uint64_t *)(a1 + 24);
    uint64_t v11 = *(void *)(a1 + 24);
    if (v11)
    {
      CFArrayRef v10 = 0;
    }
    else
    {
      uint64_t v14 = MovieSampleGroupTypeSpecMakeBasic(1886547820);
      uint64_t v15 = *(void *)(v4 + 72);
      if (v15) {
        CFArrayRef v10 = MovieSampleGroupCollectionLookupAndRetainSampleGroup(v15, v14, v13);
      }
      else {
        CFArrayRef v10 = 0;
      }
      if (MovieSampleGroupAccessorCreate(v10, (uint64_t *)(a1 + 24))) {
        goto LABEL_21;
      }
      uint64_t v11 = *v12;
    }
    if (MovieSampleGroupAccessorCopyDescriptionForSample(v11, *(unsigned int *)(a1 + 80), &theData)) {
      goto LABEL_21;
    }
    CFDataRef v9 = theData;
  }
  if (v9 && CFDataGetLength(v9) == 2)
  {
    *a2 = bswap32(*(unsigned __int16 *)CFDataGetBytePtr(theData)) >> 16;
    uint64_t v16 = 1;
    if (!v10) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_21:
  uint64_t v16 = 0;
  if (v10) {
LABEL_17:
  }
    CFRelease(v10);
LABEL_18:
  if (theData) {
    CFRelease(theData);
  }
  return v16;
}

BOOL MovieSampleAccessorCopySeamIdentifier(uint64_t a1, CFStringRef *a2)
{
  CFDataRef theData = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 728);
  if (v5 && *(void *)(v5 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v4 + 288))
  {
    int v6 = (uint64_t *)(*(void *)(a1 + 200) + 136);
    uint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1936023917);
    CFDataRef v9 = (const __CFData *)FragmentCursorEnsureAccessorAndCopySampleGroupDescription(a1, v6, Basic, v8);
    CFArrayRef v10 = 0;
    CFDataRef theData = v9;
  }
  else
  {
    long long v12 = (uint64_t *)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11)
    {
      CFArrayRef v10 = 0;
    }
    else
    {
      uint64_t v14 = MovieSampleGroupTypeSpecMakeBasic(1936023917);
      uint64_t v15 = *(void *)(v4 + 72);
      if (v15) {
        CFArrayRef v10 = MovieSampleGroupCollectionLookupAndRetainSampleGroup(v15, v14, v13);
      }
      else {
        CFArrayRef v10 = 0;
      }
      if (MovieSampleGroupAccessorCreate(v10, (uint64_t *)(a1 + 32))) {
        goto LABEL_23;
      }
      uint64_t v11 = *v12;
    }
    if (MovieSampleGroupAccessorCopyDescriptionForSample(v11, *(unsigned int *)(a1 + 80), &theData)) {
      goto LABEL_23;
    }
    CFDataRef v9 = theData;
  }
  if (v9 && CFDataGetLength(v9) == 16)
  {
    CFAllocatorRef v16 = CFGetAllocator(theData);
    CFUUIDBytes v23 = *(CFUUIDBytes *)CFDataGetBytePtr(theData);
    CFUUIDRef v17 = CFUUIDCreateFromUUIDBytes(v16, v23);
    CFAllocatorRef v18 = CFGetAllocator(theData);
    CFStringRef v19 = CFUUIDCreateString(v18, v17);
    BOOL v20 = v19 != 0;
    *a2 = v19;
    if (!v10) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_23:
  BOOL v20 = 0;
  CFUUIDRef v17 = 0;
  if (v10) {
LABEL_17:
  }
    CFRelease(v10);
LABEL_18:
  if (theData) {
    CFRelease(theData);
  }
  if (v17) {
    CFRelease(v17);
  }
  return v20;
}

uint64_t MovieSampleAccessorGetSyncValues(uint64_t a1, unsigned char *a2)
{
  CFDataRef theData = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 728);
  if (v5 && *(void *)(v5 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v4 + 288))
  {
    int v6 = (uint64_t *)(*(void *)(a1 + 200) + 168);
    uint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1937337955);
    CFDataRef v9 = (const __CFData *)FragmentCursorEnsureAccessorAndCopySampleGroupDescription(a1, v6, Basic, v8);
    CFArrayRef v10 = 0;
    CFDataRef theData = v9;
  }
  else
  {
    long long v12 = (uint64_t *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 40);
    if (v11)
    {
      CFArrayRef v10 = 0;
    }
    else
    {
      uint64_t v14 = MovieSampleGroupTypeSpecMakeBasic(1937337955);
      uint64_t v15 = *(void *)(v4 + 72);
      if (v15) {
        CFArrayRef v10 = MovieSampleGroupCollectionLookupAndRetainSampleGroup(v15, v14, v13);
      }
      else {
        CFArrayRef v10 = 0;
      }
      if (MovieSampleGroupAccessorCreate(v10, (uint64_t *)(a1 + 40))) {
        goto LABEL_21;
      }
      uint64_t v11 = *v12;
    }
    if (MovieSampleGroupAccessorCopyDescriptionForSample(v11, *(unsigned int *)(a1 + 80), &theData)) {
      goto LABEL_21;
    }
    CFDataRef v9 = theData;
  }
  if (v9 && CFDataGetLength(v9) == 1)
  {
    *a2 = *CFDataGetBytePtr(theData) & 0x3F;
    uint64_t v16 = 1;
    if (!v10) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_21:
  uint64_t v16 = 0;
  if (v10) {
LABEL_17:
  }
    CFRelease(v10);
LABEL_18:
  if (theData) {
    CFRelease(theData);
  }
  return v16;
}

uint64_t MovieSampleAccessorGetTsclValues(uint64_t a1, UInt8 *a2, unsigned char *a3, BOOL *a4, unsigned char *a5, _DWORD *a6, uint64_t a7, unsigned char *a8, unsigned char *a9, unsigned char *a10, unsigned char *a11, unsigned char *a12)
{
  CFDataRef theData = 0;
  uint64_t v20 = *(void *)(a1 + 8);
  uint64_t v21 = *(void *)(v20 + 728);
  if (v21 && *(void *)(v21 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v20 + 288))
  {
    int v22 = (uint64_t *)(*(void *)(a1 + 200) + 144);
    uint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1953719148);
    CFDataRef v25 = (const __CFData *)FragmentCursorEnsureAccessorAndCopySampleGroupDescription(a1, v22, Basic, v24);
    CFRange v26 = 0;
    CFDataRef theData = v25;
  }
  else
  {
    uint64_t v28 = (uint64_t *)(a1 + 48);
    uint64_t v27 = *(void *)(a1 + 48);
    if (v27)
    {
      CFRange v26 = 0;
    }
    else
    {
      uint64_t v30 = MovieSampleGroupTypeSpecMakeBasic(1953719148);
      uint64_t v31 = *(void *)(v20 + 72);
      if (v31) {
        CFRange v26 = MovieSampleGroupCollectionLookupAndRetainSampleGroup(v31, v30, v29);
      }
      else {
        CFRange v26 = 0;
      }
      if (MovieSampleGroupAccessorCreate(v26, (uint64_t *)(a1 + 48))) {
        goto LABEL_21;
      }
      uint64_t v27 = *v28;
    }
    if (MovieSampleGroupAccessorCopyDescriptionForSample(v27, *(unsigned int *)(a1 + 80), &theData)) {
      goto LABEL_21;
    }
    CFDataRef v25 = theData;
  }
  if (v25 && CFDataGetLength(v25) == 20)
  {
    BytePtr = CFDataGetBytePtr(theData);
    *a2 = *BytePtr;
    *a3 = BytePtr[1] >> 6;
    *a4 = (BytePtr[1] & 0x20) != 0;
    *a5 = BytePtr[1] & 0x1F;
    *a6 = *(_DWORD *)(BytePtr + 2);
    int v33 = *(_DWORD *)(BytePtr + 6);
    *(_WORD *)(a7 + 4) = *((_WORD *)BytePtr + 5);
    *(_DWORD *)a7 = v33;
    *a8 = BytePtr[12];
    *a9 = BytePtr[13];
    *a10 = BytePtr[15];
    *a11 = BytePtr[17];
    *a12 = BytePtr[18];
    uint64_t v34 = 1;
    if (!v26) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_21:
  uint64_t v34 = 0;
  if (v26) {
LABEL_17:
  }
    CFRelease(v26);
LABEL_18:
  if (theData) {
    CFRelease(theData);
  }
  return v34;
}

BOOL MovieSampleAccessorIsInTsas(uint64_t a1)
{
  CFDataRef theData = 0;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 728);
  if (v3 && *(void *)(v3 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v2 + 288))
  {
    uint64_t v4 = (uint64_t *)(*(void *)(a1 + 200) + 152);
    uint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1953718643);
    CFDataRef v7 = (const __CFData *)FragmentCursorEnsureAccessorAndCopySampleGroupDescription(a1, v4, Basic, v6);
    unsigned int v8 = 0;
    CFDataRef theData = v7;
  }
  else
  {
    CFArrayRef v10 = (uint64_t *)(a1 + 56);
    uint64_t v9 = *(void *)(a1 + 56);
    if (v9)
    {
      unsigned int v8 = 0;
    }
    else
    {
      uint64_t v12 = MovieSampleGroupTypeSpecMakeBasic(1953718643);
      uint64_t v13 = *(void *)(v2 + 72);
      if (v13) {
        unsigned int v8 = MovieSampleGroupCollectionLookupAndRetainSampleGroup(v13, v12, v11);
      }
      else {
        unsigned int v8 = 0;
      }
      if (MovieSampleGroupAccessorCreate(v8, (uint64_t *)(a1 + 56))) {
        goto LABEL_20;
      }
      uint64_t v9 = *v10;
    }
    if (MovieSampleGroupAccessorCopyDescriptionForSample(v9, *(unsigned int *)(a1 + 80), &theData)) {
      goto LABEL_20;
    }
    CFDataRef v7 = theData;
  }
  if (v7)
  {
    BOOL v14 = CFDataGetLength(v7) == 0;
    if (!v8) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_20:
  BOOL v14 = 0;
  if (v8) {
LABEL_16:
  }
    CFRelease(v8);
LABEL_17:
  if (theData) {
    CFRelease(theData);
  }
  return v14;
}

BOOL MovieSampleAccessorIsInStsa(uint64_t a1)
{
  CFDataRef theData = 0;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 728);
  if (v3 && *(void *)(v3 + 56) && *(_DWORD *)(a1 + 80) > *(_DWORD *)(v2 + 288))
  {
    uint64_t v4 = (uint64_t *)(*(void *)(a1 + 200) + 160);
    uint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1937011553);
    CFDataRef v7 = (const __CFData *)FragmentCursorEnsureAccessorAndCopySampleGroupDescription(a1, v4, Basic, v6);
    unsigned int v8 = 0;
    CFDataRef theData = v7;
  }
  else
  {
    CFArrayRef v10 = (uint64_t *)(a1 + 64);
    uint64_t v9 = *(void *)(a1 + 64);
    if (v9)
    {
      unsigned int v8 = 0;
    }
    else
    {
      uint64_t v12 = MovieSampleGroupTypeSpecMakeBasic(1937011553);
      uint64_t v13 = *(void *)(v2 + 72);
      if (v13) {
        unsigned int v8 = MovieSampleGroupCollectionLookupAndRetainSampleGroup(v13, v12, v11);
      }
      else {
        unsigned int v8 = 0;
      }
      if (MovieSampleGroupAccessorCreate(v8, (uint64_t *)(a1 + 64))) {
        goto LABEL_20;
      }
      uint64_t v9 = *v10;
    }
    if (MovieSampleGroupAccessorCopyDescriptionForSample(v9, *(unsigned int *)(a1 + 80), &theData)) {
      goto LABEL_20;
    }
    CFDataRef v7 = theData;
  }
  if (v7)
  {
    BOOL v14 = CFDataGetLength(v7) == 0;
    if (!v8) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_20:
  BOOL v14 = 0;
  if (v8) {
LABEL_16:
  }
    CFRelease(v8);
LABEL_17:
  if (theData) {
    CFRelease(theData);
  }
  return v14;
}

uint64_t MovieSampleAccessorCreateSampleGroupDataDictionary(const __CFAllocator *a1, uint64_t a2, CFMutableDictionaryRef *a3)
{
  *a3 = 0;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = *(void *)(v6 + 728);
  if (v7 && *(void *)(v7 + 56) && *(_DWORD *)(a2 + 80) > *(_DWORD *)(v6 + 288)) {
    goto LABEL_14;
  }
  CFDictionaryRef v8 = *(const __CFDictionary **)(a2 + 72);
  if (!v8)
  {
    if (!MovieSampleGroupCollectionGetCount(*(void *)(v6 + 72))) {
      return 0;
    }
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)(a2 + 72) = Mutable;
    if (!Mutable) {
      goto LABEL_14;
    }
    MovieSampleGroupCollectionApplyFunction(*(void *)(*(void *)(a2 + 8) + 72), (uint64_t)AllSampleGroupCollectionApplierFunction, (uint64_t)Mutable);
    CFDictionaryRef v8 = *(const __CFDictionary **)(a2 + 72);
    if (!v8) {
      goto LABEL_11;
    }
  }
  CFIndex Count = CFDictionaryGetCount(v8);
  if (!Count)
  {
LABEL_11:
    CFMutableDictionaryRef v12 = 0;
    goto LABEL_12;
  }
  v14[0] = 0;
  CFMutableDictionaryRef v11 = CFDictionaryCreateMutable(a1, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v11)
  {
    CFMutableDictionaryRef v12 = v11;
    LODWORD(v14[0]) = *(_DWORD *)(a2 + 80);
    v14[1] = v11;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a2 + 72), (CFDictionaryApplierFunction)CopySampleGroupAccessorDataApplierFunction, v14);
LABEL_12:
    *a3 = v12;
    return 0;
  }
LABEL_14:

  return FigSignalErrorAt();
}

void AllSampleGroupCollectionApplierFunction(void *a1, __CFDictionary *a2)
{
  key = 0;
  CMTimeValue value = 0;
  MovieSampleGroupAccessorCreate(a1, (uint64_t *)&value);
  if (value)
  {
    MovieSampleGroupCopyGroupTypeKeyString((uint64_t)a1, &key);
    if (key) {
      CFDictionarySetValue(a2, key, value);
    }
    else {
      FigSignalErrorAt();
    }
  }
  if (key) {
    CFRelease(key);
  }
  if (value) {
    CFRelease(value);
  }
}

void CopySampleGroupAccessorDataApplierFunction(const void *a1, uint64_t a2, CFMutableDictionaryRef *a3)
{
  CMTimeValue value = 0;
  MovieSampleGroupAccessorCopyDescriptionForSample(a2, *(unsigned int *)a3, &value);
  if (value)
  {
    CFDictionarySetValue(a3[1], a1, value);
    CFRelease(value);
  }
}

uint64_t MovieSampleAccessorCreateSampleDependencyAttributeDictionary(CFAllocatorRef allocator, uint64_t a2, __CFDictionary **a3)
{
  uint64_t v6 = *(void *)(a2 + 8);
  if (*(_DWORD *)(v6 + 24) == 1936684398 && !*(void *)(v6 + 536))
  {
    CMFormatDescriptionRef desc = 0;
    MovieSampleAccessorGetFormatDescription(a2, (const void **)&desc);
    if (FigAudioFormatDescriptionEmploysDependentPackets()
      || (uint64_t v21 = *(void *)(a2 + 8), *(_DWORD *)(v21 + 24) == 1936684398)
      && (*(void *)(v21 + 488) || MovieTrackHasIndependentFramePrerollPacketCount(v21)))
    {
      *(void *)int v22 = 0;
      *(_WORD *)bytes = 0;
      LOBYTE(v23) = 0;
      MovieSampleAccessorGetDependencyInfo(a2, &v23, 0, 0, 0, 0, 0);
      if (!(_BYTE)v23) {
        MovieSampleAccessorGetIndependentFramePrerollPacketCount(a2, bytes);
      }
      uint64_t result = FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary();
      *a3 = *(__CFDictionary **)v22;
    }
    else
    {
      uint64_t result = 0;
      *a3 = 0;
    }
  }
  else
  {
    __int16 v35 = 0;
    __int16 v33 = 0;
    __int16 v32 = 0;
    *(_DWORD *)bytes = 0;
    *(_WORD *)&v22[4] = 0;
    *(_DWORD *)int v22 = 0;
    char v30 = 0;
    char v25 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 8, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFDictionaryRef v8 = Mutable;
      __int16 v34 = 0;
      MovieSampleAccessorGetDependencyInfo(a2, (unsigned char *)&v34 + 1, &v34, &v35, (unsigned char *)&v35 + 1, 0, 0);
      uint64_t v9 = (const void **)MEMORY[0x1E4F1CFD0];
      if (!HIBYTE(v34)) {
        CFDictionarySetValue(v8, (const void *)*MEMORY[0x1E4F1F200], (const void *)*MEMORY[0x1E4F1CFD0]);
      }
      if ((_BYTE)v34) {
        CFDictionarySetValue(v8, (const void *)*MEMORY[0x1E4F1F208], *v9);
      }
      if ((_BYTE)v35)
      {
        char v10 = HIBYTE(v35);
        CFMutableDictionaryRef v11 = (const void **)MEMORY[0x1E4F1CFC8];
        if ((v35 & 0xC00) != 0 && (HIBYTE(v35) & 0xC) != 0xC)
        {
          if ((v35 & 0x400) != 0) {
            CFMutableDictionaryRef v12 = v9;
          }
          else {
            CFMutableDictionaryRef v12 = (const void **)MEMORY[0x1E4F1CFC8];
          }
          CFDictionarySetValue(v8, (const void *)*MEMORY[0x1E4F1F1F8], *v12);
          char v10 = HIBYTE(v35);
        }
        if ((v10 & 0x30) != 0 && (v10 & 0x30) != 0x30)
        {
          if ((v10 & 0x10) != 0) {
            uint64_t v13 = v9;
          }
          else {
            uint64_t v13 = v11;
          }
          CFDictionarySetValue(v8, (const void *)*MEMORY[0x1E4F1F1A8], *v13);
          char v10 = HIBYTE(v35);
        }
        if ((v10 & 3) != 0 && (v10 & 3) != 3)
        {
          if (v10) {
            BOOL v14 = v9;
          }
          else {
            BOOL v14 = v11;
          }
          CFDictionarySetValue(v8, (const void *)*MEMORY[0x1E4F1F1F0], *v14);
          char v10 = HIBYTE(v35);
        }
        if ((v10 & 0x40) != 0) {
          uint64_t v15 = v9;
        }
        else {
          uint64_t v15 = v11;
        }
        CFDictionarySetValue(v8, (const void *)*MEMORY[0x1E4F1F1C0], *v15);
      }
      CMFormatDescriptionRef desc = 0;
      MovieSampleAccessorGetFormatDescription(a2, (const void **)&desc);
      uint64_t v16 = desc;
      CMFormatDescriptionGetMediaSubType(desc);
      if (MovieSampleAccessorGetTsclValues(a2, (UInt8 *)&v33 + 1, &v33, (BOOL *)&v32 + 1, &v32, bytes, (uint64_t)v22, &v30, &v29, &v28, &v27, &v26))
      {
        CFUUIDRef v17 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFDataRef v18 = CFDataCreate(allocator, bytes, 4);
        CFDataRef v19 = CFDataCreate(allocator, v22, 6);
        FigCFDictionarySetInt();
        FigCFDictionarySetInt();
        FigCFDictionarySetInt();
        FigCFDictionarySetInt();
        CFDictionarySetValue(v17, (const void *)*MEMORY[0x1E4F1EF70], v18);
        CFDictionarySetValue(v17, (const void *)*MEMORY[0x1E4F1EF60], v19);
        FigCFDictionarySetInt();
        CFDictionarySetValue(v8, (const void *)*MEMORY[0x1E4F1F1E0], v17);
      }
      else
      {
        CFUUIDRef v17 = 0;
        CFDataRef v18 = 0;
        CFDataRef v19 = 0;
      }
      if (MovieSampleAccessorGetSyncValues(a2, &v25)) {
        FigCFDictionarySetInt();
      }
      if (MovieSampleAccessorIsInTsas(a2)) {
        CFDictionarySetValue(v8, (const void *)*MEMORY[0x1E4F1F1E8], *v9);
      }
      if (MovieSampleAccessorIsInStsa(a2)) {
        CFDictionarySetValue(v8, (const void *)*MEMORY[0x1E4F1F1D0], *v9);
      }
      if (v16)
      {
        if (CMFormatDescriptionGetMediaType(v16) == 1936684398)
        {
          if (FigAudioFormatDescriptionEmploysDependentPackets())
          {
            __int16 v23 = 0;
            if (HIBYTE(v34) || MovieSampleAccessorGetIndependentFramePrerollPacketCount(a2, &v23)) {
              FigCFDictionarySetInt();
            }
          }
        }
      }
      if (!CFDictionaryGetCount(v8))
      {
        CFRelease(v8);
        CFDictionaryRef v8 = 0;
      }
      *a3 = v8;
      if (v17) {
        CFRelease(v17);
      }
      if (v18) {
        CFRelease(v18);
      }
      if (v19) {
        CFRelease(v19);
      }
      return 0;
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t MovieSampleAccessorCopyCryptorIV(uint64_t a1, CFTypeRef *a2)
{
  CFArrayRef theArray = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v3 = MovieSampleAccessorCopyCryptorIVArray(a1, 1, &theArray);
  if (v3)
  {
    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
    *a2 = CFRetain(ValueAtIndex);
    CFRelease(theArray);
  }
  return v3;
}

uint64_t MovieSampleAccessorCopyCryptorIVArray(uint64_t a1, CFIndex a2, CFArrayRef *a3)
{
  uint64_t v3 = 0;
  if (a2 >= 1 && a3)
  {
    uint64_t v6 = *(void *)(a1 + 200);
    if (!v6) {
      return 0;
    }
    uint64_t v7 = *(void *)(v6 + 88);
    if (!v7) {
      return 0;
    }
    CFArrayRef v8 = *(const __CFArray **)(v7 + 24);
    if (!v8) {
      return 0;
    }
    CFIndex Count = CFArrayGetCount(v8);
    uint64_t v11 = *(void *)(a1 + 200);
    CFIndex v12 = (*(_DWORD *)(a1 + 80) - *(_DWORD *)(v11 + 32));
    if (v12 + a2 > Count) {
      return 0;
    }
    CFAllocatorRef v14 = CFGetAllocator(*(CFTypeRef *)(*(void *)(v11 + 88) + 24));
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v14, a2, MEMORY[0x1E4F1D510]);
    if (!Mutable)
    {
      FigSignalErrorAt();
      return 0;
    }
    uint64_t v16 = Mutable;
    v19.location = v12;
    v19.length = a2;
    CFArrayAppendArray(Mutable, *(CFArrayRef *)(*(void *)(*(void *)(a1 + 200) + 88) + 24), v19);
    CFAllocatorRef v17 = CFGetAllocator(v16);
    CFArrayRef Copy = CFArrayCreateCopy(v17, v16);
    *a3 = Copy;
    if (Copy)
    {
      uint64_t v3 = 1;
    }
    else
    {
      FigSignalErrorAt();
      uint64_t v3 = 0;
    }
    CFRelease(v16);
  }
  return v3;
}

uint64_t MovieSampleAccessorCopyCryptorSubsampleAuxData(uint64_t a1, CFTypeRef *a2)
{
  CFArrayRef theArray = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v3 = MovieSampleAccessorCopyCryptorSubsampleAuxDataArray(a1, 1, &theArray);
  if (v3)
  {
    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
    *a2 = CFRetain(ValueAtIndex);
    CFRelease(theArray);
  }
  return v3;
}

uint64_t MovieSampleAccessorCopyCryptorSubsampleAuxDataArray(uint64_t a1, CFIndex a2, CFArrayRef *a3)
{
  uint64_t v3 = 0;
  if (a2 >= 1 && a3)
  {
    uint64_t v6 = *(void *)(a1 + 200);
    if (!v6) {
      return 0;
    }
    uint64_t v7 = *(void *)(v6 + 88);
    if (!v7) {
      return 0;
    }
    CFArrayRef v8 = *(const __CFArray **)(v7 + 32);
    if (!v8) {
      return 0;
    }
    CFIndex Count = CFArrayGetCount(v8);
    uint64_t v11 = *(void *)(a1 + 200);
    CFIndex v12 = (*(_DWORD *)(a1 + 80) - *(_DWORD *)(v11 + 32));
    if (v12 + a2 > Count) {
      return 0;
    }
    CFAllocatorRef v14 = CFGetAllocator(*(CFTypeRef *)(*(void *)(v11 + 88) + 32));
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v14, a2, MEMORY[0x1E4F1D510]);
    if (!Mutable)
    {
      FigSignalErrorAt();
      return 0;
    }
    uint64_t v16 = Mutable;
    v19.location = v12;
    v19.length = a2;
    CFArrayAppendArray(Mutable, *(CFArrayRef *)(*(void *)(*(void *)(a1 + 200) + 88) + 32), v19);
    CFAllocatorRef v17 = CFGetAllocator(v16);
    CFArrayRef Copy = CFArrayCreateCopy(v17, v16);
    *a3 = Copy;
    if (Copy)
    {
      uint64_t v3 = 1;
    }
    else
    {
      FigSignalErrorAt();
      uint64_t v3 = 0;
    }
    CFRelease(v16);
  }
  return v3;
}

uint64_t MovieTrackAddSampleGroupDescriptionArray(CFMutableDictionaryRef *cf, const void *a2)
{
  LODWORD(key) = 0;
  if (cf[10]
    || (CFAllocatorRef v4 = CFGetAllocator(cf),
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v4, 0, 0, MEMORY[0x1E4F1D540]),
        (cf[10] = Mutable) != 0))
  {
    uint64_t result = MovieSampleGroupDescriptionArrayCopyInfo((uint64_t)a2, &key, 0, 0, 0, 0);
    if (!result)
    {
      if (CFDictionaryGetValue(cf[10], (const void *)(int)key))
      {
        return FigSignalErrorAt();
      }
      else
      {
        CFDictionarySetValue(cf[10], (const void *)(int)key, a2);
        return 0;
      }
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t MovieTrackCopySampleGroupDescriptionArray(uint64_t a1, int a2, const __CFDictionary **a3)
{
  CFDictionaryRef Value = *(const __CFDictionary **)(a1 + 80);
  if (Value)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, (const void *)a2);
    if (Value) {
      CFDictionaryRef Value = (const __CFDictionary *)CFRetain(Value);
    }
  }
  *a3 = Value;
  return 0;
}

uint64_t MovieTrackAddSampleGroup(uint64_t *cf, uint64_t a2)
{
  uint64_t v5 = cf + 9;
  uint64_t v4 = cf[9];
  if (!v4)
  {
    CFAllocatorRef v6 = CFGetAllocator(cf);
    uint64_t result = MovieSampleGroupCollectionCreate(v6, v5);
    if (result) {
      return result;
    }
    uint64_t v4 = *v5;
  }

  return MovieSampleGroupCollectionAddSampleGroup(v4, a2);
}

uint64_t MovieTrackAddAndRetainSampleGroup(void *a1, unint64_t a2, unsigned int a3, void *a4)
{
  CFTypeRef v15 = 0;
  uint64_t v8 = a1[9];
  if (v8)
  {
    CFTypeRef v9 = MovieSampleGroupCollectionLookupAndRetainSampleGroup(v8, a2, a3);
    CFTypeRef cf = v9;
    if (v9)
    {
      if (!a4)
      {
        uint64_t v10 = 0;
        goto LABEL_14;
      }
      goto LABEL_12;
    }
  }
  else
  {
    CFTypeRef cf = 0;
  }
  uint64_t v11 = MovieTrackAddAndRetainSampleGroupDescriptionArray(a1, a2, &v15);
  if (v11
    || (CFAllocatorRef v12 = CFGetAllocator(a1), v11 = MovieSampleGroupCreate(v12, a2, a3, (uint64_t *)&cf), v11)
    || (uint64_t v11 = MovieSampleGroupSetDescriptionArray((uint64_t)cf, v15), v11))
  {
    uint64_t v10 = v11;
  }
  else
  {
    uint64_t v13 = MovieTrackAddSampleGroup(a1, (uint64_t)cf);
    uint64_t v10 = v13;
    if (a4 && !v13)
    {
      CFTypeRef v9 = cf;
      if (!cf)
      {
LABEL_13:
        uint64_t v10 = 0;
        *a4 = v9;
        goto LABEL_14;
      }
LABEL_12:
      CFTypeRef v9 = CFRetain(v9);
      goto LABEL_13;
    }
  }
LABEL_14:
  if (v15) {
    CFRelease(v15);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t MovieTrackRemoveSampleGroupInfoForGroupingType(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 72);
  if (v4) {
    MovieSampleGroupCollectionRemoveAllGroupsWithGroupingType(v4, a2);
  }
  uint64_t v5 = *(__CFDictionary **)(a1 + 80);
  if (v5) {
    CFDictionaryRemoveValue(v5, (const void *)a2);
  }
  return 0;
}

uint64_t MovieTrackRemoveAllSampleGroups(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 72);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 72) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 80);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 80) = 0;
  }
  return 0;
}

uint64_t MovieTrackCopySampleGroupArray(uint64_t a1, CFArrayRef *a2)
{
  uint64_t v3 = *(void *)(a1 + 72);
  if (v3) {
    CFArrayRef v4 = MovieSampleGroupCollectionCopySampleGroupArray((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v3);
  }
  else {
    CFArrayRef v4 = 0;
  }
  *a2 = v4;
  return 0;
}

uint64_t MovieTrackSetSampleOverrides(uint64_t a1, int a2, int a3)
{
  *(_DWORD *)(a1 + 244) = a3;
  *(_DWORD *)(a1 + 248) = a2;
  if (a2) {
    BOOL v3 = a3 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  char v4 = !v3;
  *(unsigned char *)(a1 + 240) = v4;
  return 0;
}

uint64_t MovieTrackGetSampleOverrides(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (a2) {
    *a2 = *(_DWORD *)(a1 + 248);
  }
  if (a3) {
    *a3 = *(_DWORD *)(a1 + 244);
  }
  return *(unsigned __int8 *)(a1 + 240);
}

uint64_t MovieTrackSetCleanApertureDimensions(uint64_t a1, float a2, float a3)
{
  *(unsigned char *)(a1 + 252) = 1;
  *(float *)(a1 + 256) = a2;
  *(float *)(a1 + 260) = a3;
  *(void *)(a1 + 16) |= 0x200uLL;
  return 0;
}

uint64_t MovieTrackSetProductionApertureDimensions(uint64_t a1, float a2, float a3)
{
  *(unsigned char *)(a1 + 264) = 1;
  *(float *)(a1 + 268) = a2;
  *(float *)(a1 + 272) = a3;
  *(void *)(a1 + 16) |= 0x4000uLL;
  return 0;
}

uint64_t MovieTrackSetEncodedPixelsDimensions(uint64_t a1, float a2, float a3)
{
  *(unsigned char *)(a1 + 276) = 1;
  *(float *)(a1 + 280) = a2;
  *(float *)(a1 + 284) = a3;
  *(void *)(a1 + 16) |= 0x8000uLL;
  return 0;
}

uint64_t MovieTrackGetLoadSettings(uint64_t a1, _OWORD *a2)
{
  uint64_t result = *(unsigned __int8 *)(a1 + 882);
  if (a2)
  {
    if (result)
    {
      *a2 = *(_OWORD *)(a1 + 866);
      return *(unsigned __int8 *)(a1 + 882);
    }
  }
  return result;
}

uint64_t MovieTrackSetLoadSettings(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)(a1 + 882) = 1;
  *(void *)(a1 + 866) = a2;
  *(void *)(a1 + 874) = a3;
  *(void *)(a1 + 16) |= 0x40000uLL;
  return 0;
}

uint64_t MovieTrackSetExtendedLanguageTagString(uint64_t a1, CFTypeRef cf)
{
  BOOL v3 = *(const void **)(a1 + 848);
  *(void *)(a1 + 848) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + 16) |= 0x100uLL;
  return 0;
}

uint64_t MovieTrackSetExcludeFromAutoSelection(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 885) = a2;
  *(void *)(a1 + 16) |= 0x800uLL;
  return 0;
}

uint64_t MovieTrackSetEnabled(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 200) = a2;
  *(void *)(a1 + 16) |= 0x40uLL;
  return 0;
}

uint64_t MovieTrackSetDurationIsAll1s(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 201) = a2;
  return 0;
}

uint64_t MovieTrackUsesAudibleDRM(uint64_t a1)
{
  CFArrayRef v1 = MovieTrackCopyFormatDescriptionArray(a1);
  if (!v1) {
    return 0;
  }
  CFArrayRef v2 = v1;
  CFIndex Count = CFArrayGetCount(v1);
  if (Count < 1)
  {
LABEL_6:
    uint64_t v6 = 0;
  }
  else
  {
    CFIndex v4 = Count;
    CFIndex v5 = 0;
    while (1)
    {
      CFArrayGetValueAtIndex(v2, v5);
      if (FigAudioFormatDescriptionUsesAudibleDRM()) {
        break;
      }
      if (v4 == ++v5) {
        goto LABEL_6;
      }
    }
    uint64_t v6 = 1;
  }
  CFRelease(v2);
  return v6;
}

CFArrayRef MovieTrackCopyFormatDescriptionArray(uint64_t a1)
{
  CFArrayRef result = *(CFArrayRef *)(a1 + 48);
  if (result)
  {
    CFAllocatorRef v3 = CFGetAllocator(result);
    CFArrayRef v4 = *(const __CFArray **)(a1 + 48);
    return CFArrayCreateCopy(v3, v4);
  }
  return result;
}

uint64_t MovieTrackAudibleContentIsAuthorized(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 296)) {
    return 0;
  }
  CFArrayRef v2 = MovieTrackCopyFormatDescriptionArray(a2);
  if (!v2) {
    return 0;
  }
  CFArrayRef v3 = v2;
  CFIndex Count = CFArrayGetCount(v2);
  if (Count < 1)
  {
LABEL_7:
    uint64_t v7 = 0;
  }
  else
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    while (1)
    {
      CFArrayGetValueAtIndex(v3, v6);
      if (FigAudioFormatDescriptionAudibleContentIsAuthorized()) {
        break;
      }
      if (v5 == ++v6) {
        goto LABEL_7;
      }
    }
    uint64_t v7 = 1;
  }
  CFRelease(v3);
  return v7;
}

uint64_t MovieTrackEstablishFirstFragmentBaseDecodeTime(int a1, uint64_t a2, int64_t value)
{
  if ((*(unsigned char *)(a2 + 756) & 1) == 0)
  {
    CFArrayRef v3 = (CMTime *)(a2 + 744);
    CMTimeMake(&v5, value, *(_DWORD *)(a2 + 232));
    *CFArrayRef v3 = v5;
  }
  return 0;
}

uint64_t MovieTrackGetDisplayTimeRange(void *a1, uint64_t a2, CMTime *a3, CMTime *a4)
{
  memset(&v23, 0, sizeof(v23));
  uint64_t v21 = 0;
  uint64_t v8 = MoovAssureSampleTableParsed(a1, a2);
  if (v8)
  {
    uint64_t v12 = v8;
    uint64_t v10 = 0;
    goto LABEL_13;
  }
  uint64_t v9 = MovieSampleAccessorCreate(a1, a2, &v21);
  if (v9)
  {
    uint64_t v12 = v9;
    uint64_t v10 = v21;
    goto LABEL_13;
  }
  uint64_t v10 = v21;
  if (!a3) {
    goto LABEL_7;
  }
  do
    MovieSampleAccessorStepBackPTS((uint64_t)v10);
  while (!v11);
  uint64_t v12 = v11;
  if (v11 == -12840)
  {
    PTSTimeCFDictionaryRef Value = MovieSampleAccessorGetPTSTimeValue((uint64_t)v10);
    CMTimeMake(&v22, PTSTimeValue, *((_DWORD *)v10[1] + 58));
    *a3 = v22;
LABEL_7:
    if (a4)
    {
      uint64_t SampleInDecodeOrder = MovieSampleAccessorMoveToLastSampleInDecodeOrder((uint64_t)v10);
      if (SampleInDecodeOrder)
      {
        uint64_t v12 = SampleInDecodeOrder;
      }
      else
      {
        do
          MovieSampleAccessorStepFwdPTS((uint64_t)v10);
        while (!v15);
        uint64_t v12 = v15;
        if (v15 == -12840)
        {
          memset(&v22, 0, sizeof(v22));
          int64_t v16 = MovieSampleAccessorGetPTSTimeValue((uint64_t)v10);
          CMTimeMake(&v23, v16, *((_DWORD *)v10[1] + 58));
          MovieSampleAccessorGetSampleDuration((uint64_t)v10, &v22);
          CMTime lhs = v23;
          CMTime v18 = v22;
          CMTimeAdd(&v20, &lhs, &v18);
          uint64_t v12 = 0;
          *a4 = v20;
        }
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
  }
LABEL_13:
  MovieSampleAccessorDispose(v10);
  return v12;
}

uint64_t MovieTrackGetCompositionOffsetRange(void *a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result = MoovAssureSampleTableParsed(a1, a2);
  if (!result)
  {
    if (a3) {
      *a3 = *(_DWORD *)(a2 + 116);
    }
    if (a4) {
      *a4 = *(_DWORD *)(a2 + 112);
    }
  }
  return result;
}

uint64_t MovieTrackFragmentGetCompositionOffsetRange(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  if (a3)
  {
    uint64_t result = TrackFragmentBuilderGetMinDecodeToDisplay(*(void *)(a2 + 768), a3);
    if (!a4 || result) {
      return result;
    }
  }
  else if (!a4)
  {
    return 0;
  }
  uint64_t v7 = *(void *)(a2 + 768);

  return TrackFragmentBuilderGetMaxDecodeToDisplay(v7, a4);
}

CFArrayRef MovieTrackGetNumFormatDescriptions(uint64_t a1)
{
  CFArrayRef result = *(const __CFArray **)(a1 + 48);
  if (result) {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

uint64_t MovieTrackReplaceFormatDescriptionArray(uint64_t a1, CFArrayRef theArray)
{
  if (!theArray) {
    goto LABEL_24;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  CFArrayRef v5 = *(const __CFArray **)(a1 + 48);
  if (v5) {
    CFArrayRef v5 = (const __CFArray *)CFArrayGetCount(v5);
  }
  if ((const __CFArray *)Count == v5)
  {
    CFIndex v6 = CFArrayGetCount(theArray);
    if (v6 >= 1)
    {
      CFIndex v7 = v6;
      for (CFIndex i = 0; v7 != i; ++i)
      {
        CFDataRef ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(theArray, i);
        CMMediaType MediaType = CMFormatDescriptionGetMediaType(ValueAtIndex);
        int v11 = *(_DWORD *)(a1 + 24);
        if (MediaType != v11)
        {
          if (v11 != 1885954932 && MediaType == 1986618469)
          {
            if (v11 != 1635088502) {
              goto LABEL_24;
            }
          }
          else if (MediaType != 1986618469 || v11 != 1885954932)
          {
            goto LABEL_24;
          }
        }
      }
    }
    CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)a1);
    MutableCFArrayRef Copy = CFArrayCreateMutableCopy(v13, 0, theArray);
    CFMutableArrayRef v15 = MutableCopy;
    int64_t v16 = *(const void **)(a1 + 48);
    *(void *)(a1 + 48) = MutableCopy;
    if (MutableCopy) {
      CFRetain(MutableCopy);
    }
    if (v16) {
      CFRelease(v16);
    }
    *(void *)(a1 + 16) |= 4uLL;
    if (v15) {
      CFRelease(v15);
    }
    return 0;
  }
  else
  {
LABEL_24:
    return FigSignalErrorAt();
  }
}

uint64_t MovieTrackSetMediaTimeScale(uint64_t a1, int a2)
{
  if (!a2) {
    return FigSignalErrorAt();
  }
  int v2 = *(_DWORD *)(a1 + 288);
  uint64_t v3 = *(void *)(a1 + 728);
  if (v3) {
    v2 += *(_DWORD *)(v3 + 8);
  }
  if (v2) {
    return FigSignalErrorAt();
  }
  *(_DWORD *)(a1 + 232) = a2;
  return 0;
}

uint64_t MovieTrackGetTrackDurationValue(uint64_t a1)
{
  return *(void *)(a1 + 136);
}

uint64_t MovieTrackGetMediaDurationValue(uint64_t a1)
{
  return *(void *)(a1 + 224);
}

uint64_t FigPersistentTrackIDToTrackIndex(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 304);
  if (v2 < 1) {
    return -1;
  }
  uint64_t result = 0;
  uint64_t v5 = *(void *)(a1 + 320);
  while (*(_DWORD *)(*(void *)(v5 + 8 * result) + 144) != a2)
  {
    if (v2 == ++result) {
      return -1;
    }
  }
  return result;
}

uint64_t MovieInformationFindTrackForTrackID(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 304);
  if (v2 < 1) {
    return 0;
  }
  for (CFIndex i = *(uint64_t **)(a1 + 320); ; ++i)
  {
    uint64_t result = *i;
    if (*(_DWORD *)(*i + 144) == a2) {
      break;
    }
    if (!--v2) {
      return 0;
    }
  }
  return result;
}

uint64_t MovieInformationFindNthTrackOfType(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 304);
  if (v3 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(uint64_t **)(a1 + 320);
    do
    {
      uint64_t result = *v5;
      if (*(_DWORD *)(*v5 + 24) == a3)
      {
        if (v4 == a2) {
          return result;
        }
        ++v4;
      }
      ++v5;
      --v3;
    }
    while (v3);
  }
  return 0;
}

uint64_t MovieInformationHasCompressedMovieAtom(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 88);
}

BOOL MovieTrackIsValid(uint64_t a1)
{
  return a1 && !*(unsigned char *)(a1 + 896);
}

uint64_t MovieTrackGetBasicInfo(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (!a1) {
    return FigSignalErrorAt();
  }
  if (a2) {
    *a2 = *(_DWORD *)(a1 + 24);
  }
  if (a3) {
    *a3 = *(_DWORD *)(a1 + 144);
  }
  return 0;
}

uint64_t MovieTrackGetTrackTimeInfo(uint64_t a1, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(a1 + 120);
  }
  if (a3) {
    *a3 = *(void *)(a1 + 128);
  }
  return 0;
}

uint64_t MovieTrackGetMediaTimeInfo(uint64_t a1, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(a1 + 208);
  }
  if (a3) {
    *a3 = *(void *)(a1 + 216);
  }
  return 0;
}

uint64_t MovieTrackSetParsedTrackID(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 144) = a2;
  return 0;
}

uint64_t MovieTrackSetParsedTrackCreateAndModTimes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 120) = a2;
  *(void *)(a1 + 128) = a3;
  return 0;
}

uint64_t MovieTrackSetParsedMediaCreateAndModTimes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 208) = a2;
  *(void *)(a1 + 216) = a3;
  return 0;
}

uint64_t MovieTrackSetParsedDuration(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 136) = a2;
  return 0;
}

uint64_t MovieTrackIsEnabled(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 200);
}

uint64_t MovieTrackIsExcludedFromAutoSelection(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 885);
}

float MovieTrackGetVolume(uint64_t a1)
{
  return *(float *)(a1 + 196);
}

uint64_t MovieTrackSetVolume(uint64_t a1, float a2)
{
  *(float *)(a1 + 196) = a2;
  *(void *)(a1 + 16) |= 0x10000uLL;
  return 0;
}

BOOL MovieTrackHasEditList(uint64_t a1)
{
  return *(unsigned char *)(a1 + 722) && *(_DWORD *)(a1 + 824) != 1;
}

uint64_t MovieTrackGetEditSegmentCount(uint64_t a1)
{
  return *(int *)(a1 + 816);
}

uint64_t MovieTrackFragmentGetEditSegmentCount(uint64_t a1)
{
  return *(int *)(a1 + 792);
}

uint64_t MovieTrackGetEditSegmentWithIndex(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  if (a2 < 0 || *(int *)(a1 + 816) <= a2) {
    return 4294954513;
  }
  uint64_t result = 0;
  uint64_t v5 = (_OWORD *)(*(void *)(a1 + 808) + 96 * a2);
  long long v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  long long v7 = v5[2];
  long long v8 = v5[3];
  long long v9 = v5[5];
  a3[4] = v5[4];
  a3[5] = v9;
  a3[2] = v7;
  a3[3] = v8;
  return result;
}

uint64_t MovieTrackFragmentGetEditSegmentWithIndex(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  if (a2 < 0 || *(int *)(a1 + 792) <= a2) {
    return 4294954513;
  }
  uint64_t result = 0;
  uint64_t v5 = (_OWORD *)(*(void *)(a1 + 784) + 96 * a2);
  long long v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  long long v7 = v5[2];
  long long v8 = v5[3];
  long long v9 = v5[5];
  a3[4] = v5[4];
  a3[5] = v9;
  a3[2] = v7;
  a3[3] = v8;
  return result;
}

uint64_t MovieTrackFindEditIndexForTrackTime(uint64_t a1, CMTime *a2, void *a3)
{
  if (*(_DWORD *)(a1 + 816) && (uint64_t v5 = *(void *)(a1 + 808)) != 0)
  {
    CMTime time1 = *a2;
    CMTime v15 = *(CMTime *)(v5 + 48);
    if (CMTimeCompare(&time1, &v15) < 0)
    {
      uint64_t result = 0;
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v7 = *(int *)(a1 + 816);
      uint64_t v8 = v7 - 1;
      if ((int)v7 < 2)
      {
LABEL_8:
        uint64_t result = 0;
      }
      else
      {
        uint64_t v9 = 0;
        uint64_t v10 = 144;
        while (1)
        {
          uint64_t v11 = *(void *)(a1 + 808) + v10;
          CMTime time1 = *a2;
          long long v12 = *(_OWORD *)v11;
          v15.CMTimeEpoch epoch = *(void *)(v11 + 16);
          *(_OWORD *)&v15.CMTimeValue value = v12;
          if (CMTimeCompare(&time1, &v15) < 0) {
            break;
          }
          uint64_t v13 = v9 + 2;
          ++v9;
          v10 += 96;
          if (v13 >= *(int *)(a1 + 816)) {
            goto LABEL_8;
          }
        }
        uint64_t result = 0;
        uint64_t v8 = v9;
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t result = 4294954775;
  }
  *a3 = v8;
  return result;
}

__n128 MovieTrackGetSpatialInformation(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  if (a2)
  {
    result.n128_u32[0] = *(_DWORD *)(a1 + 188);
    *a2 = result.n128_u32[0];
  }
  if (a3)
  {
    result.n128_u32[0] = *(_DWORD *)(a1 + 192);
    *a3 = result.n128_u32[0];
  }
  if (a4)
  {
    __n128 result = *(__n128 *)(a1 + 152);
    long long v5 = *(_OWORD *)(a1 + 168);
    *(_DWORD *)(a4 + 32) = *(_DWORD *)(a1 + 184);
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v5;
  }
  return result;
}

uint64_t MovieTrackSetSpatialInformation(uint64_t a1, long long *a2, float a3, float a4)
{
  *(float *)(a1 + 188) = a3;
  *(float *)(a1 + 192) = a4;
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v4 | 0x400;
  long long v5 = &kIdentityMatrix_0;
  if (a2) {
    long long v5 = a2;
  }
  long long v6 = *v5;
  long long v7 = v5[1];
  *(_DWORD *)(a1 + 184) = *((_DWORD *)v5 + 8);
  *(_OWORD *)(a1 + 168) = v7;
  *(_OWORD *)(a1 + 152) = v6;
  *(void *)(a1 + 16) = v4 | 0x80400;
  return 0;
}

uint64_t MovieTrackSetTrackDimensions(uint64_t a1, float a2, float a3)
{
  *(float *)(a1 + 188) = a2;
  *(float *)(a1 + 192) = a3;
  *(void *)(a1 + 16) |= 0x400uLL;
  return 0;
}

uint64_t MovieTrackSetTrackMatrix(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    long long v2 = *(_OWORD *)a2;
    long long v3 = *(_OWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 32);
  }
  else
  {
    *(_DWORD *)(a1 + 184) = 1065353216;
    long long v2 = kIdentityMatrix_0;
    long long v3 = unk_194998610;
  }
  *(_OWORD *)(a1 + 152) = v2;
  *(_OWORD *)(a1 + 168) = v3;
  *(void *)(a1 + 16) |= 0x80000uLL;
  return 0;
}

float MovieTrackGetCleanApertureDimensions(uint64_t a1, float *a2, float *a3)
{
  if (*(unsigned char *)(a1 + 252))
  {
    if (a2)
    {
      float result = *(float *)(a1 + 256);
      *a2 = result;
    }
    if (a3)
    {
      float result = *(float *)(a1 + 260);
      *a3 = result;
    }
  }
  return result;
}

float MovieTrackGetProductionApertureDimensions(uint64_t a1, float *a2, float *a3)
{
  if (*(unsigned char *)(a1 + 264))
  {
    if (a2)
    {
      float result = *(float *)(a1 + 268);
      *a2 = result;
    }
    if (a3)
    {
      float result = *(float *)(a1 + 272);
      *a3 = result;
    }
  }
  return result;
}

float MovieTrackGetEncodedPixelsDimensions(uint64_t a1, float *a2, float *a3)
{
  if (*(unsigned char *)(a1 + 276))
  {
    if (a2)
    {
      float result = *(float *)(a1 + 280);
      *a2 = result;
    }
    if (a3)
    {
      float result = *(float *)(a1 + 284);
      *a3 = result;
    }
  }
  return result;
}

uint64_t MovieTrackGetLanguageInformation(uint64_t result, _WORD *a2, void *a3, void *a4)
{
  if (a2) {
    *a2 = *(_WORD *)(result + 236);
  }
  if (a3) {
    *a3 = *(void *)(result + 856);
  }
  if (a4) {
    *a4 = *(void *)(result + 848);
  }
  return result;
}

uint64_t MovieTrackSetParsedLanguageCode(uint64_t a1, __int16 a2)
{
  *(_WORD *)(a1 + 716) = a2;
  return 0;
}

uint64_t MovieTrackSetLanguageCodeString(uint64_t a1, const __CFString *cf)
{
  if (cf)
  {
    long long v5 = *(const void **)(a1 + 856);
    *(void *)(a1 + 856) = cf;
    CFRetain(cf);
    if (v5) {
      CFRelease(v5);
    }
    *(_WORD *)(a1 + 236) = FigGetISOLanguageCodeForString(cf);
    *(void *)(a1 + 16) |= 0x80uLL;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieTrackGetAlternateGroupID(uint64_t a1)
{
  return *(__int16 *)(a1 + 864);
}

uint64_t MovieTrackGetProvisionalAlternateGroupID(uint64_t a1, _WORD *a2)
{
  if (a2) {
    *a2 = *(_WORD *)(a1 + 738);
  }
  return *(unsigned __int8 *)(a1 + 740);
}

uint64_t MovieTrackGetDefaultAlternateGroupID(uint64_t a1)
{
  return *(__int16 *)(a1 + 150);
}

uint64_t MovieTrackGetLayer(uint64_t a1)
{
  return *(__int16 *)(a1 + 148);
}

uint64_t MovieTrackSetAlternateGroupID(uint64_t a1, __int16 a2)
{
  *(_WORD *)(a1 + 150) = a2;
  uint64_t v2 = *(void *)(a1 + 16);
  *(unsigned char *)(a1 + 740) = 1;
  *(_WORD *)(a1 + 738) = 0;
  *(_WORD *)(a1 + 864) = a2;
  *(void *)(a1 + 16) = v2 | 0xC01000;
  return 0;
}

uint64_t MovieTrackSetDefaultAlternateGroupID(uint64_t a1, __int16 a2)
{
  *(_WORD *)(a1 + 150) = a2;
  *(void *)(a1 + 16) |= 0x800000uLL;
  return 0;
}

uint64_t MovieTrackSetProvisionalAlternateGroupID(uint64_t a1, __int16 a2)
{
  *(unsigned char *)(a1 + 740) = 1;
  *(_WORD *)(a1 + 738) = a2;
  *(void *)(a1 + 16) |= 0x400000uLL;
  return 0;
}

uint64_t MovieTrackClearProvisionalAlternateGroupID(uint64_t a1)
{
  *(unsigned char *)(a1 + 740) = 0;
  *(_WORD *)(a1 + 738) = 0;
  *(void *)(a1 + 16) |= 0x400000uLL;
  return 0;
}

uint64_t MovieTrackSetLayer(uint64_t a1, __int16 a2)
{
  *(_WORD *)(a1 + 148) = a2;
  *(void *)(a1 + 16) |= 0x20000uLL;
  return 0;
}

uint64_t MovieTrackGetTimecodeMustBeShown(uint64_t a1, unsigned char *a2)
{
  if (*(_DWORD *)(a1 + 24) != 1953325924 || !*(unsigned char *)(a1 + 883)) {
    return FigSignalErrorAt();
  }
  *a2 = *(unsigned char *)(a1 + 884);
  return 0;
}

uint64_t MovieTrackSetTimecodeSpecifics(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 883) = 1;
  *(unsigned char *)(a1 + 884) = a2;
  return 0;
}

uint64_t MovieTrackGetTrackType(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 48);
  if (!v2 || !CFArrayGetCount(v2)) {
    return *(unsigned int *)(a1 + 24);
  }
  uint64_t result = *(unsigned int *)(a1 + 24);
  if (result != 1885954932)
  {
    if (result == 1635088502)
    {
      return 1635088502;
    }
    else
    {
      CFDataRef ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), 0);
      uint64_t result = CMFormatDescriptionGetMediaType(ValueAtIndex);
      if (result == 1953325924)
      {
        FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(ValueAtIndex);
        if (MediaSubType == 1668167220 || MediaSubType == 1952658996) {
          return 1952658996;
        }
        else {
          return 1953325924;
        }
      }
    }
  }
  return result;
}

uint64_t MovieTrackGetMediaType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t MovieTrackGetMediaTypeForSampleDescriptionID(uint64_t a1, int a2, CMMediaType *a3)
{
  CMFormatDescriptionRef desc = 0;
  uint64_t FormatDescriptionForSampleDescriptionID = GetFormatDescriptionForSampleDescriptionID(a1, a2, (const void **)&desc);
  if (!FormatDescriptionForSampleDescriptionID) {
    *a3 = CMFormatDescriptionGetMediaType(desc);
  }
  return FormatDescriptionForSampleDescriptionID;
}

uint64_t MovieTrackSetParsedTrackType(uint64_t a1, int a2)
{
  if (a2 == 1953325924 || a2 == 1952658996) {
    int v3 = 1953325924;
  }
  else {
    int v3 = a2;
  }
  *(_DWORD *)(a1 + 24) = v3;
  return 0;
}

uint64_t MovieTrackSetTrackExtendsDefaultValues(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  a1[225] = a2;
  a1[226] = a3;
  a1[227] = a4;
  a1[228] = a5;
  return 0;
}

uint64_t MovieTrackGetTrackExtendsDefaultValues(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  if (a2) {
    *a2 = a1[225];
  }
  if (a3) {
    *a3 = a1[226];
  }
  if (a4) {
    *a4 = a1[227];
  }
  if (a5) {
    *a5 = a1[228];
  }
  return 0;
}

uint64_t MovieTrackSetParsedMediaDuration(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)(a1 + 224) = a2;
  *(_DWORD *)(a1 + 232) = a3;
  return 0;
}

CFDictionaryRef MovieTrackCreateAdvanceDecodeDeltaDictionary(const __CFAllocator *a1, void *a2, uint64_t a3)
{
  if (MoovAssureSampleTableParsed(a2, a3)) {
    return 0;
  }
  CMTimeMake(&time, -*(_DWORD *)(a3 + 116) & (*(int *)(a3 + 116) >> 31), *(_DWORD *)(a3 + 232));
  return CMTimeCopyAsDictionary(&time, a1);
}

uint64_t MovieTrackCreateSampleDescriptionAtomLocationDictionary(uint64_t a1, __CFDictionary **a2)
{
  if (*(void *)(a1 + 648)
    && *(void *)(a1 + 656)
    && (CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
        (CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, (const void *)(a1 + 648))) != 0))
  {
    CFNumberRef v6 = v5;
    CFNumberRef v7 = CFNumberCreate(v4, kCFNumberSInt64Type, (const void *)(a1 + 656));
    if (v7)
    {
      CFNumberRef v8 = v7;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v4, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        uint64_t v10 = Mutable;
        CFDictionarySetValue(Mutable, @"Offset", v6);
        CFDictionarySetValue(v10, @"Length", v8);
        *a2 = v10;
      }
      else
      {
        FigSignalErrorAt();
      }
      CFRelease(v6);
      CFNumberRef v11 = v8;
    }
    else
    {
      FigSignalErrorAt();
      CFNumberRef v11 = v6;
    }
    CFRelease(v11);
  }
  else
  {
    FigSignalErrorAt();
  }
  return 0;
}

uint64_t MovieTrackHasRollInformation(uint64_t a1)
{
  uint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1919904876);
  uint64_t result = *(void *)(a1 + 72);
  if (result)
  {
    return MovieSampleGroupCollectionHasSampleGroup(result, Basic, v2);
  }
  return result;
}

uint64_t MovieTrackHasIndependentFramePrerollPacketCount(uint64_t a1)
{
  uint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1886547820);
  uint64_t result = *(void *)(a1 + 72);
  if (result)
  {
    return MovieSampleGroupCollectionHasSampleGroup(result, Basic, v2);
  }
  return result;
}

uint64_t MovieTrackHasSeamSamples(uint64_t a1)
{
  uint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1936023917);
  uint64_t result = *(void *)(a1 + 72);
  if (result)
  {
    return MovieSampleGroupCollectionHasSampleGroup(result, Basic, v2);
  }
  return result;
}

BOOL MovieTrackHasAudioDependencyInformation(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) != 1936684398) {
    return 0;
  }
  if (*(void *)(a1 + 488)) {
    return 1;
  }
  return MovieTrackHasIndependentFramePrerollPacketCount(a1) != 0;
}

BOOL MovieSampleTableHaveSyncSampleTable(uint64_t a1)
{
  return *(void *)(a1 + 488) != 0;
}

BOOL MovieTrackEditsExcludeAudioPrimingAndRemainderDuration(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) != 1936684398 || !*(unsigned char *)(a1 + 722) || *(_DWORD *)(a1 + 824) == 1) {
    return 0;
  }
  if (MovieTrackHasRollInformation(a1)) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 24) != 1936684398) {
    return 0;
  }
  return *(void *)(a1 + 488) || MovieTrackHasIndependentFramePrerollPacketCount(a1) != 0;
}

uint64_t MovieTrackCreateEditSegmentArray(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (!*(unsigned char *)(a2 + 722))
  {
    memset(&v65, 0, sizeof(v65));
    CMTimeMake(&v65, *(void *)(a2 + 136), *(_DWORD *)(a1 + 240));
    memset(&v64, 0, sizeof(v64));
    CMTimeMake(&v64, *(void *)(v2 + 224), *(_DWORD *)(v2 + 232));
    CMTime v63 = v64;
    *(_DWORD *)(v2 + 824) = 0;
    char v29 = (CMTime *)malloc_type_malloc(0x60uLL, 0x1000040565EDBD2uLL);
    if (!v29) {
      return FigSignalErrorAt();
    }
    char v30 = v29;
    uint64_t v31 = MEMORY[0x1E4F1FA48];
    long long v32 = *MEMORY[0x1E4F1FA48];
    *(_OWORD *)&v29[2].int64_t value = *MEMORY[0x1E4F1FA48];
    uint64_t v33 = v2;
    CMTimeEpoch v34 = *(void *)(v31 + 16);
    v29[2].CMTimeEpoch epoch = v34;
    v29->CMTimeEpoch epoch = v34;
    *(_OWORD *)valuea = v32;
    *(_OWORD *)&v29->int64_t value = v32;
    v29[3] = v65;
    v29[1] = v64;
    int32_t v35 = *(_DWORD *)(a1 + 240);
    int32_t v36 = *(_DWORD *)(v33 + 232);
    if (v35 != v36)
    {
      if (v35 >= v36) {
        int32_t v37 = v36;
      }
      else {
        int32_t v37 = *(_DWORD *)(a1 + 240);
      }
      uint64_t v38 = v29;
      CMTimeMake(&rhs, 1, v37);
      CMTime lhs = v64;
      CMTimeAdd(&v63, &lhs, &rhs);
      char v30 = v38;
    }
    uint64_t v39 = v30 + 3;
    uint64_t v40 = v30;
    int v41 = v30 + 1;
    CMTime lhs = v63;
    CMTime time = v65;
    if (CMTimeCompare(&lhs, &time) < 0)
    {
      lhs.CMTimeEpoch epoch = v34;
      CMTime v71 = 0;
      *(_OWORD *)&lhs.int64_t value = *(_OWORD *)valuea;
      CMTime time = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
      CMTime time2 = time;
      int v44 = MoovAssureSampleTableParsed((void *)a1, a2);
      if (v44)
      {
        int SampleInDecodeOrder = v44;
        long long v46 = 0;
      }
      else
      {
        int v45 = MovieSampleAccessorCreate((const void *)a1, a2, &v71);
        long long v46 = v71;
        if (v45)
        {
          int SampleInDecodeOrder = v45;
        }
        else
        {
          int SampleInDecodeOrder = MovieSampleAccessorMoveToLastSampleInDecodeOrder((uint64_t)v71);
          if (!SampleInDecodeOrder)
          {
            DTSTimeCFDictionaryRef Value = MovieSampleAccessorGetDTSTimeValue((uint64_t)v46);
            CMTimeMake(&time, DTSTimeValue, *((_DWORD *)v46[1] + 58));
            MovieSampleAccessorGetSampleDuration((uint64_t)v46, &time2);
            CMTime v67 = time;
            CMTime v66 = time2;
            CMTimeAdd(&lhs, &v67, &v66);
          }
        }
      }
      CMTime v67 = lhs;
      MovieSampleAccessorDispose(v46);
      if (!SampleInDecodeOrder)
      {
        CMTime lhs = v67;
        CMTime time = v64;
        if (CMTimeCompare(&lhs, &time) >= 1)
        {
          int32_t v49 = *(_DWORD *)(a2 + 232);
          CMTime time = v67;
          CMTimeConvertScale(&lhs, &time, v49, kCMTimeRoundingMethod_QuickTime);
          CMTime v64 = lhs;
          CMTimeEpoch epoch = lhs.epoch;
          long long v51 = *(_OWORD *)&lhs.value;
          CMTimeScale timescale = lhs.timescale;
          *(void *)(a2 + 224) = lhs.value;
          *(_DWORD *)(a2 + 232) = timescale;
          v41->CMTimeEpoch epoch = epoch;
          *(_OWORD *)&v41->int64_t value = v51;
        }
      }
      uint64_t v2 = a2;
    }
    else
    {
      uint64_t v2 = a2;
      if (*(unsigned char *)(a1 + 83))
      {
        if (*(_DWORD *)(a2 + 232) == *(_DWORD *)(a1 + 240))
        {
          CMTime lhs = v64;
          CMTime time = v65;
          if (CMTimeCompare(&lhs, &time) >= 1)
          {
            CMTimeValue v42 = v64.value;
            *(void *)(a1 + 232) = v64.value;
            *(void *)(a2 + 136) = v42;
            *uint64_t v39 = v64;
          }
        }
      }
    }
    CMTime time = *v41;
    CMTime time2 = *v39;
    CMTimeMinimum(&lhs, &time, &time2);
    *(_OWORD *)&v41->int64_t value = *(_OWORD *)&lhs.value;
    CMTimeEpoch v53 = lhs.epoch;
    v41->CMTimeEpoch epoch = lhs.epoch;
    *(_OWORD *)&v39->int64_t value = *(_OWORD *)&v41->value;
    v39->CMTimeEpoch epoch = v53;
    int v5 = 1;
    int v28 = 1;
    CFNumberRef v8 = v40;
    goto LABEL_43;
  }
  CFAllocatorRef v4 = *(unsigned int **)(a2 + 704);
  if (!v4)
  {
    CFNumberRef v8 = 0;
    int v5 = 0;
    int v28 = 0;
    int v43 = 1;
LABEL_33:
    *(_DWORD *)(a2 + 824) = v43;
LABEL_43:
    uint64_t result = 0;
    *(void *)(v2 + 808) = v8;
    *(_DWORD *)(v2 + 820) = v28;
    *(_DWORD *)(v2 + 816) = v5;
    return result;
  }
  int v5 = bswap32(v4[1]);
  if (v5 < 1)
  {
    CFNumberRef v8 = 0;
    int v28 = 0;
    int v43 = 2;
    goto LABEL_33;
  }
  *(_DWORD *)(a2 + 824) = 3;
  if (v5 <= 4) {
    size_t v6 = 4;
  }
  else {
    size_t v6 = v5;
  }
  CFNumberRef v7 = (CMTime *)malloc_type_calloc(v6, 0x60uLL, 0x1000040565EDBD2uLL);
  if (v7)
  {
    CFNumberRef v8 = v7;
    unint64_t v9 = 0;
    uint64_t v10 = 0;
    unsigned int v11 = v5;
    int64_t v12 = 0;
    int v56 = v4 + 2;
    uint64_t v13 = v4 + 6;
    int v55 = v11;
    uint64_t v57 = 96 * v11;
    CFAllocatorRef v14 = v4 + 3;
    uint64_t v59 = v7;
    do
    {
      if (**(unsigned char **)(v2 + 704))
      {
        int64_t v15 = bswap64(*((void *)v13 - 1));
        int64_t value = bswap64(*((void *)v13 - 2));
        int64_t v16 = v13;
      }
      else
      {
        int64_t v15 = (int)bswap32(*v14);
        int64_t value = bswap32(*(v14 - 1));
        int64_t v16 = &v56[3 * v10 + 2];
      }
      unsigned int v17 = *v16;
      CMTime v18 = (char *)&v8[v9 / 0x18];
      if (v15 == -1)
      {
        uint64_t v20 = MEMORY[0x1E4F1F9F8];
        *(_OWORD *)CMTime v18 = *MEMORY[0x1E4F1F9F8];
        *((void *)v18 + 2) = *(void *)(v20 + 16);
      }
      else
      {
        CMTimeMake(&lhs, v15, *(_DWORD *)(v2 + 232));
        CFNumberRef v8 = v59;
        long long v19 = *(_OWORD *)&lhs.value;
        *((void *)v18 + 2) = lhs.epoch;
        *(_OWORD *)CMTime v18 = v19;
      }
      uint64_t v21 = (char *)&v8[v9 / 0x18];
      uint64_t v22 = (uint64_t)&v8[v9 / 0x18 + 3];
      CMTimeMake(&lhs, value, *(_DWORD *)(a1 + 240));
      long long v23 = *(_OWORD *)&lhs.value;
      *((void *)v21 + 11) = lhs.epoch;
      *(_OWORD *)(v21 + 72) = v23;
      CMTimeMake(&lhs, v12, *(_DWORD *)(a1 + 240));
      long long v24 = *(_OWORD *)&lhs.value;
      *((void *)v21 + 8) = lhs.epoch;
      *((_OWORD *)v21 + 3) = v24;
      char v25 = v21 + 24;
      if (v17 == 256)
      {
        *(_OWORD *)char v25 = *(_OWORD *)v22;
        *((void *)v25 + 2) = *(void *)(v22 + 16);
      }
      else
      {
        long long v26 = *(_OWORD *)v22;
        time.CMTimeEpoch epoch = *(void *)(v22 + 16);
        *(_OWORD *)&time.int64_t value = v26;
        CMTimeMultiplyByFloat64(&lhs, &time, (double)bswap32(v17) * 0.0000152587891);
        long long v27 = *(_OWORD *)&lhs.value;
        *((void *)v25 + 2) = lhs.epoch;
        *(_OWORD *)char v25 = v27;
      }
      CFNumberRef v8 = v59;
      v12 += value;
      ++v10;
      v13 += 5;
      v9 += 96;
      v14 += 3;
      uint64_t v2 = a2;
    }
    while (v57 != v9);
    int v5 = v55;
    int v28 = v6;
    goto LABEL_43;
  }

  return FigSignalErrorAt();
}

uint64_t MovieTrackAddRunContributionToEditSegmentArray(uint64_t a1, uint64_t a2, int64_t a3, int64_t value)
{
  memset(&v58, 0, sizeof(v58));
  memset(&v57, 0, sizeof(v57));
  memset(&v56, 0, sizeof(v56));
  switch(*(_DWORD *)(a2 + 824))
  {
    case 0:
      CFNumberRef v8 = *(CMTime **)(a2 + 808);
      CMTimeMake(&v55, value, *(_DWORD *)(a2 + 232));
      v8[1] = v55;
      uint64_t v9 = *(void *)(a2 + 808);
      *(_OWORD *)(v9 + 72) = *(_OWORD *)(v9 + 24);
      *(void *)(v9 + 88) = *(void *)(v9 + 40);
      goto LABEL_12;
    case 2:
      *(_DWORD *)(a2 + 820) = 4;
      *(void *)(a2 + 808) = malloc_type_calloc(4uLL, 0x60uLL, 0x1000040565EDBD2uLL);
      *(_DWORD *)(a2 + 816) = 1;
      CMTimeMake(&lhs, value, *(_DWORD *)(a2 + 232));
      CMTimeMake(&rhs, a3, *(_DWORD *)(a2 + 232));
      CMTimeSubtract(&v58, &lhs, &rhs);
      uint64_t v10 = *(CMTime **)(a2 + 808);
      CMTimeMake(&v55, 0, *(_DWORD *)(a1 + 240));
      _OWORD v10[2] = v55;
      *(CMTime *)(*(void *)(a2 + 808) + 72) = v58;
      uint64_t v11 = *(void *)(a2 + 808);
      CMTimeMake(&v55, a3, *(_DWORD *)(a2 + 232));
      long long v12 = *(_OWORD *)&v55.value;
      *(void *)(v11 + 16) = v55.epoch;
      *(_OWORD *)uint64_t v11 = v12;
      *(CMTime *)(*(void *)(a2 + 808) + 24) = v58;
      *(_DWORD *)(a2 + 824) = 4;
      goto LABEL_12;
    case 3:
      int v13 = *(_DWORD *)(a2 + 816);
      uint64_t v14 = v13;
      uint64_t v15 = v13 - 1;
      int64_t v16 = *(void **)(a2 + 808);
      if (*((unsigned char *)v16 + 96 * v15 + 12))
      {
        CMTimeMake(&v52, value, *(_DWORD *)(a2 + 232));
        uint64_t v37 = *(void *)(a2 + 808) + 96 * v15;
        long long v38 = *(_OWORD *)v37;
        v55.CMTimeEpoch epoch = *(void *)(v37 + 16);
        *(_OWORD *)&v55.int64_t value = v38;
        CMTimeSubtract(&v57, &v52, &v55);
        uint64_t v39 = *(void *)(a2 + 808) + 96 * v15;
        CMTime v55 = v57;
        long long v40 = *(_OWORD *)(v39 + 24);
        v51.CMTimeEpoch epoch = *(void *)(v39 + 40);
        *(_OWORD *)&v51.int64_t value = v40;
        CMTimeSubtract(&v56, &v55, &v51);
        uint64_t v41 = *(void *)(a2 + 808) + 96 * v15;
        long long v42 = *(_OWORD *)(v41 + 72);
        v51.CMTimeEpoch epoch = *(void *)(v41 + 88);
        *(_OWORD *)&v51.int64_t value = v42;
        CMTime v50 = v56;
        CMTimeAdd(&v55, &v51, &v50);
        long long v43 = *(_OWORD *)&v55.value;
        *(void *)(v41 + 88) = v55.epoch;
        *(_OWORD *)(v41 + 72) = v43;
        uint64_t v44 = *(void *)(a2 + 808) + 96 * v15;
        long long v45 = *(_OWORD *)&v57.value;
        *(void *)(v44 + 40) = v57.epoch;
        *(_OWORD *)(v44 + 24) = v45;
      }
      else
      {
        if (*(_DWORD *)(a2 + 820) <= v13)
        {
          int v17 = v13 + 1;
          CMTime v18 = malloc_type_realloc(v16, 96 * (v14 + 1), 0x1000040565EDBD2uLL);
          if (!v18)
          {
            return FigSignalErrorAt();
          }
          *(void *)(a2 + 808) = v18;
          *(_DWORD *)(a2 + 820) = v17;
          int v13 = *(_DWORD *)(a2 + 816);
        }
        CMTimeMake(&v49, value, *(_DWORD *)(a2 + 232));
        CMTimeMake(&v48, a3, *(_DWORD *)(a2 + 232));
        CMTimeSubtract(&v58, &v49, &v48);
        uint64_t v19 = *(void *)(a2 + 808) + 96 * v13;
        CMTimeMake(&v55, 0, *(_DWORD *)(a1 + 240));
        long long v20 = *(_OWORD *)&v55.value;
        *(void *)(v19 + 64) = v55.epoch;
        *(_OWORD *)(v19 + 48) = v20;
        uint64_t v21 = *(void *)(a2 + 808) + 96 * v13;
        long long v22 = *(_OWORD *)&v58.value;
        *(void *)(v21 + 88) = v58.epoch;
        *(_OWORD *)(v21 + 72) = v22;
        uint64_t v23 = *(void *)(a2 + 808) + 96 * v13;
        CMTimeMake(&v55, a3, *(_DWORD *)(a2 + 232));
        long long v24 = *(_OWORD *)&v55.value;
        *(void *)(v23 + 16) = v55.epoch;
        *(_OWORD *)uint64_t v23 = v24;
        uint64_t v25 = *(void *)(a2 + 808) + 96 * v13;
        long long v26 = *(_OWORD *)&v58.value;
        *(void *)(v25 + 40) = v58.epoch;
        *(_OWORD *)(v25 + 24) = v26;
        ++*(_DWORD *)(a2 + 816);
      }
      *(_DWORD *)(a2 + 824) = 4;
LABEL_12:
      *(void *)(a2 + 16) |= 2uLL;
      return 0;
    case 4:
      uint64_t v27 = 96 * *(int *)(a2 + 816);
      CMTimeMake(&v47, value, *(_DWORD *)(a2 + 232));
      v27 -= 96;
      uint64_t v28 = *(void *)(a2 + 808) + v27;
      long long v29 = *(_OWORD *)v28;
      v55.CMTimeEpoch epoch = *(void *)(v28 + 16);
      *(_OWORD *)&v55.int64_t value = v29;
      CMTimeSubtract(&v57, &v47, &v55);
      uint64_t v30 = *(void *)(a2 + 808) + v27;
      CMTime v55 = v57;
      long long v31 = *(_OWORD *)(v30 + 24);
      v51.CMTimeEpoch epoch = *(void *)(v30 + 40);
      *(_OWORD *)&v51.int64_t value = v31;
      CMTimeSubtract(&v56, &v55, &v51);
      uint64_t v32 = *(void *)(a2 + 808) + v27;
      long long v33 = *(_OWORD *)(v32 + 72);
      v51.CMTimeEpoch epoch = *(void *)(v32 + 88);
      *(_OWORD *)&v51.int64_t value = v33;
      CMTime v50 = v56;
      CMTimeAdd(&v55, &v51, &v50);
      long long v34 = *(_OWORD *)&v55.value;
      *(void *)(v32 + 88) = v55.epoch;
      *(_OWORD *)(v32 + 72) = v34;
      uint64_t v35 = *(void *)(a2 + 808) + v27;
      long long v36 = *(_OWORD *)&v57.value;
      *(void *)(v35 + 40) = v57.epoch;
      *(_OWORD *)(v35 + 24) = v36;
      goto LABEL_12;
    default:
      return 0;
  }
}

uint64_t MovieTrackCreateEditSegmentArrayFromFragmentEditList(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(unsigned char *)(a2 + 722) || !*(unsigned char *)(a2 + 727)) {
    return 0;
  }
  CFAllocatorRef v4 = *(void **)(a2 + 808);
  uint64_t v38 = a2;
  if (v4)
  {
    int v5 = (void *)(a2 + 808);
    free(v4);
    a2 = v38;
    *int v5 = 0;
    v5[1] = 0;
  }
  size_t v6 = *(unsigned int **)(a2 + 704);
  if (!v6)
  {
    int v7 = 0;
    int v30 = 1;
LABEL_25:
    uint64_t v14 = 0;
    int v29 = 0;
    *(_DWORD *)(a2 + 824) = v30;
LABEL_26:
    *(void *)(a2 + 808) = v14;
    *(_DWORD *)(a2 + 820) = v29;
    *(_DWORD *)(a2 + 816) = v7;
    uint64_t v31 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = v31 | 2;
    if (a3)
    {
      if (*(unsigned char *)(a2 + 898)) {
        *(void *)(a2 + 16) = v31 | 0x200002;
      }
      UpdateDurationsForEditSegmentChange((CMTime *)a1, a2);
    }
    return 0;
  }
  int v7 = bswap32(v6[1]);
  if (v7 < 1)
  {
    int v30 = 2;
    goto LABEL_25;
  }
  *(_DWORD *)(a2 + 824) = 5;
  if (v7 <= 4) {
    size_t v8 = 4;
  }
  else {
    size_t v8 = v7;
  }
  long long v36 = (char *)malloc_type_calloc(v8, 0x60uLL, 0x1000040565EDBD2uLL);
  if (v36)
  {
    int v33 = v8;
    int v34 = a3;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    int64_t v11 = 0;
    long long v12 = v6 + 6;
    uint64_t v35 = v6 + 2;
    int v13 = v6 + 3;
    a2 = v38;
    uint64_t v14 = v36;
    do
    {
      if (**(unsigned char **)(a2 + 704))
      {
        int64_t v15 = bswap64(*((void *)v12 - 1));
        int64_t v16 = bswap64(*((void *)v12 - 2));
        int v17 = v12;
      }
      else
      {
        int64_t v15 = (int)bswap32(*v13);
        int64_t v16 = bswap32(*(v13 - 1));
        int v17 = &v35[3 * v10 + 2];
      }
      unsigned int v18 = *v17;
      uint64_t v19 = &v14[v9];
      if (v15 == -1)
      {
        uint64_t v21 = MEMORY[0x1E4F1F9F8];
        *(_OWORD *)uint64_t v19 = *MEMORY[0x1E4F1F9F8];
        *((void *)v19 + 2) = *(void *)(v21 + 16);
      }
      else
      {
        CMTimeMake(&v40, v15, *(_DWORD *)(a2 + 232));
        long long v20 = *(_OWORD *)&v40.value;
        *((void *)v19 + 2) = v40.epoch;
        *(_OWORD *)uint64_t v19 = v20;
      }
      long long v22 = &v14[v9];
      uint64_t v23 = (uint64_t)&v14[v9 + 72];
      CMTimeMake(&v40, v16, *(_DWORD *)(a1 + 240));
      long long v24 = *(_OWORD *)&v40.value;
      *((void *)v22 + 11) = v40.epoch;
      *(_OWORD *)(v22 + 72) = v24;
      CMTimeMake(&v40, v11, *(_DWORD *)(a1 + 240));
      long long v25 = *(_OWORD *)&v40.value;
      *((void *)v22 + 8) = v40.epoch;
      *((_OWORD *)v22 + 3) = v25;
      long long v26 = v22 + 24;
      if (v18 == 256)
      {
        *(_OWORD *)long long v26 = *(_OWORD *)v23;
        *((void *)v26 + 2) = *(void *)(v23 + 16);
      }
      else
      {
        long long v27 = *(_OWORD *)v23;
        time.CMTimeEpoch epoch = *(void *)(v23 + 16);
        *(_OWORD *)&time.int64_t value = v27;
        CMTimeMultiplyByFloat64(&v40, &time, (double)bswap32(v18) * 0.0000152587891);
        long long v28 = *(_OWORD *)&v40.value;
        *((void *)v26 + 2) = v40.epoch;
        *(_OWORD *)long long v26 = v28;
      }
      a2 = v38;
      v11 += v16;
      ++v10;
      v12 += 5;
      v9 += 96;
      v13 += 3;
      uint64_t v14 = v36;
    }
    while (96 * v7 != v9);
    a3 = v34;
    int v29 = v33;
    goto LABEL_26;
  }

  return FigSignalErrorAt();
}

void NoteEditSegmentModification(uint64_t a1, uint64_t a2, CMTime *a3, int a4)
{
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v4 | 2;
  if (*(unsigned char *)(a2 + 898)) {
    *(void *)(a2 + 16) = v4 | 0x200002;
  }
  if (!a4 && *(void *)(a1 + 32))
  {
    CMTime cf = *a3;
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    cf.int64_t value = (CMTimeValue)CMTimeCopyAsDictionary(&cf, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    if (cf.value) {
      CFDictionaryRef v6 = CFDictionaryCreate(v5, (const void **)kMovieInformationPayloadKey_AffectedTrackTime, (const void **)&cf, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    else {
      CFDictionaryRef v6 = 0;
    }
    CMNotificationCenterGetDefaultLocalCenter();
    FigDeferNotificationToDispatchQueue();
    if (v6) {
      CFRelease(v6);
    }
    if (cf.value) {
      CFRelease((CFTypeRef)cf.value);
    }
  }
}

CMTime *UpdateDurationsForEditSegmentChange(CMTime *result, uint64_t a2)
{
  int v3 = result;
  CMTime start = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  int v4 = *(_DWORD *)(a2 + 816);
  uint64_t v5 = (v4 - 1);
  if (v4 >= 1)
  {
    CFDictionaryRef v6 = (_OWORD *)(*(void *)(a2 + 808) + 96 * v5 + 48);
    uint64_t v7 = v5 + 1;
    while ((*((unsigned char *)v6 - 36) & 1) == 0)
    {
      v6 -= 6;
      if (v7-- <= 1) {
        goto LABEL_8;
      }
    }
    long long v9 = *v6;
    long long v10 = v6[2];
    *(_OWORD *)&range.start.uint64_t epoch = v6[1];
    *(_OWORD *)&range.duration.CMTimeScale timescale = v10;
    *(_OWORD *)&range.start.int32_t value = v9;
    CMTimeRangeGetEnd(&start, &range);
    int32_t value = v3[10].value;
    CMTime time = start;
    uint64_t result = CMTimeConvertScale(&range.start, &time, value, kCMTimeRoundingMethod_QuickTime);
    CMTime start = range.start;
  }
LABEL_8:
  if (start.value != *(void *)(a2 + 136))
  {
    *(void *)(a2 + 136) = start.value;
    uint64_t epoch = v3[12].epoch;
    if (epoch < 1)
    {
      CMTimeEpoch v13 = 0;
    }
    else
    {
      CMTimeEpoch v13 = 0;
      uint64_t v14 = *(uint64_t **)&v3[13].timescale;
      do
      {
        uint64_t v15 = *v14++;
        CMTimeEpoch v16 = *(void *)(v15 + 136);
        if (v16 > v13) {
          CMTimeEpoch v13 = v16;
        }
        --epoch;
      }
      while (epoch);
    }
    if (v3[9].epoch != v13)
    {
      v3[9].uint64_t epoch = v13;
      v3[1].epoch |= 1uLL;
    }
  }
  return result;
}

uint64_t MovieTrackIntegrateFragmentSampleGroups(uint64_t a1, uint64_t a2)
{
  if (a2) {
    MovieSampleGroupCollectionApplyFunction(a2, (uint64_t)IntegrateFragmentSampleGroupCollectionApplier, a1);
  }
  return 0;
}

void IntegrateFragmentSampleGroupCollectionApplier(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  unsigned int v7 = 0;
  unint64_t v6 = 0;
  if (!MovieSampleGroupGetInfo(a1, (uint64_t)&v6, 0, 0, 0))
  {
    int v4 = MovieTrackAddAndRetainSampleGroup((void *)a2, v6, v7, &cf);
    CFTypeRef v5 = cf;
    if (!v4)
    {
      MovieSampleGroupIntegrateSampleGroup(*(_DWORD *)(a2 + 288), (uint64_t)cf, a1);
      CFTypeRef v5 = cf;
    }
    if (v5) {
      CFRelease(v5);
    }
  }
}

uint64_t MovieTrackInitializeLowestDisplayStartTimeAndHighestDisplayEndTime(void *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 576))
  {
    CMTimeValue value = (int)bswap32(*(_DWORD *)(a2 + 568));
    CMTimeValue v4 = (int)bswap32(*(_DWORD *)(a2 + 572));
LABEL_3:
    *(void *)(a2 + 104) = v4;
    *(void *)(a2 + 88) = value;
    *(void *)(a2 + 96) = 0xFFFFFFFF80000000;
    return 0;
  }
  if (*(void *)(a2 + 416))
  {
    int v6 = *(_DWORD *)(a2 + 288);
    uint64_t v7 = *(void *)(a2 + 728);
    if (v7) {
      v6 += *(_DWORD *)(v7 + 8);
    }
    if (v6)
    {
      CMTime v9 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
      CMTime v8 = v9;
      if (!MovieTrackGetDisplayTimeRange(a1, a2, &v9, &v8))
      {
        CMTimeValue value = v9.value;
        CMTimeValue v4 = v8.value;
        goto LABEL_3;
      }
    }
  }
  return 0;
}

uint64_t MovieSampleTableHaveCompositionShiftLeastInfo(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 576);
}

BOOL MovieSampleTableHaveTimeToSampleTable(uint64_t a1)
{
  return *(void *)(a1 + 416) != 0;
}

CMBlockBufferRef MovieTrackReviseParsedSampleCount(uint64_t a1, int a2)
{
  CMBlockBufferRef blockBufferOut = 0;
  *(_DWORD *)(a1 + 288) = a2;
  if (!*(_DWORD *)(a1 + 312))
  {
    if (!*(_DWORD *)(a1 + 340)) {
      return 0;
    }
    *(_DWORD *)(a1 + 340) = a2;
    if (!*(void *)(a1 + 344)) {
      return 0;
    }
    int v7 = *(_DWORD *)(a1 + 336);
    size_t v8 = a2;
    int v9 = a2 + 2;
    if (a2 >= -1) {
      int v9 = a2 + 1;
    }
    uint64_t v10 = (uint64_t)v9 >> 1;
    if (v7 != 4) {
      uint64_t v10 = 0;
    }
    if (v7 != 8) {
      size_t v8 = v10;
    }
    if (v7 == 16) {
      size_t v11 = 2 * a2;
    }
    else {
      size_t v11 = v8;
    }
    CMBlockBufferRef result = (CMBlockBufferRef)CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CMBlockBufferRef *)(a1 + 344), 0, v11, 0, &blockBufferOut);
    if (result) {
      return result;
    }
    CMBlockBufferRef result = blockBufferOut;
    if (!blockBufferOut) {
      return result;
    }
    int v6 = *(const void **)(a1 + 344);
    *(void *)(a1 + 344) = blockBufferOut;
    goto LABEL_22;
  }
  *(_DWORD *)(a1 + 312) = a2;
  if (!*(void *)(a1 + 320)) {
    return 0;
  }
  CMBlockBufferRef result = (CMBlockBufferRef)CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CMBlockBufferRef *)(a1 + 320), 0, 4 * a2, 0, &blockBufferOut);
  CMBlockBufferRef v4 = blockBufferOut;
  if (result) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = blockBufferOut == 0;
  }
  if (!v5)
  {
    int v6 = *(const void **)(a1 + 320);
    *(void *)(a1 + 320) = blockBufferOut;
    CMBlockBufferRef result = v4;
LABEL_22:
    CFRetain(result);
    if (v6) {
      CFRelease(v6);
    }
    CMBlockBufferRef result = blockBufferOut;
    if (blockBufferOut)
    {
      CFRelease(blockBufferOut);
      return 0;
    }
  }
  return result;
}

uint64_t MovieTrackReviseSampleDependencyTable(uint64_t a1, int a2)
{
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v4 = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CMBlockBufferRef *)(a1 + 536), 0, a2, 0, &blockBufferOut);
  CMBlockBufferRef v5 = blockBufferOut;
  if (v4) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = blockBufferOut == 0;
  }
  if (!v6)
  {
    int v7 = *(const void **)(a1 + 536);
    *(void *)(a1 + 536) = blockBufferOut;
    CFRetain(v5);
    if (v7) {
      CFRelease(v7);
    }
    if (blockBufferOut) {
      CFRelease(blockBufferOut);
    }
    *(_DWORD *)(a1 + 528) = a2;
  }
  return v4;
}

uint64_t MovieTrackReviseSyncSampleTable(uint64_t a1, signed int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 480);
  CFTypeRef cf = 0;
  if ((int)v3 < 1) {
    goto LABEL_10;
  }
  size_t v5 = 0;
  unsigned int v6 = 0;
  while (1)
  {
    unsigned int destination = 0;
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 488), v5, 4uLL, &destination);
    if ((int)bswap32(destination) > a2) {
      break;
    }
    ++v6;
    v5 += 4;
    if (4 * v3 == v5)
    {
      unsigned int v6 = v3;
      break;
    }
  }
  if (v6)
  {
    uint64_t v7 = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CMBlockBufferRef *)(a1 + 488), 0, 4 * v6, 0, (CMBlockBufferRef *)&cf);
    CFTypeRef v8 = cf;
    if (v7) {
      goto LABEL_14;
    }
    int v9 = *(const void **)(a1 + 488);
    *(void *)(a1 + 488) = cf;
    if (v8) {
      CFRetain(v8);
    }
  }
  else
  {
LABEL_10:
    unsigned int v6 = 0;
    int v9 = *(const void **)(a1 + 488);
    *(void *)(a1 + 488) = 0;
  }
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v7 = 0;
  *(_DWORD *)(a1 + 480) = v6;
  CFTypeRef v8 = cf;
LABEL_14:
  if (v8) {
    CFRelease(v8);
  }
  return v7;
}

uint64_t MovieSampleTableNumSyncSampleEntries(uint64_t a1)
{
  return *(unsigned int *)(a1 + 480);
}

uint64_t MovieSampleTableGetSyncSampleNumber(uint64_t a1, int a2)
{
  unsigned int destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 488), 4 * a2, 4uLL, &destination);
  return bswap32(destination);
}

uint64_t MovieTrackRevisePartialSyncSampleTable(uint64_t a1, signed int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 504);
  CFTypeRef cf = 0;
  if ((int)v3 < 1) {
    goto LABEL_10;
  }
  size_t v5 = 0;
  unsigned int v6 = 0;
  while (1)
  {
    unsigned int destination = 0;
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 512), v5, 4uLL, &destination);
    if ((int)bswap32(destination) > a2) {
      break;
    }
    ++v6;
    v5 += 4;
    if (4 * v3 == v5)
    {
      unsigned int v6 = v3;
      break;
    }
  }
  if (v6)
  {
    uint64_t v7 = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CMBlockBufferRef *)(a1 + 512), 0, 4 * v6, 0, (CMBlockBufferRef *)&cf);
    CFTypeRef v8 = cf;
    if (v7) {
      goto LABEL_14;
    }
    int v9 = *(const void **)(a1 + 512);
    *(void *)(a1 + 512) = cf;
    if (v8) {
      CFRetain(v8);
    }
  }
  else
  {
LABEL_10:
    unsigned int v6 = 0;
    int v9 = *(const void **)(a1 + 512);
    *(void *)(a1 + 512) = 0;
  }
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v7 = 0;
  *(_DWORD *)(a1 + 504) = v6;
  CFTypeRef v8 = cf;
LABEL_14:
  if (v8) {
    CFRelease(v8);
  }
  return v7;
}

uint64_t MovieSampleTableNumPartialSyncSampleEntries(uint64_t a1)
{
  return *(unsigned int *)(a1 + 504);
}

uint64_t MovieSampleTableGetPartialSyncSampleNumber(uint64_t a1, int a2)
{
  unsigned int destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 512), 4 * a2, 4uLL, &destination);
  return bswap32(destination);
}

uint64_t MovieTrackReviseCompositionOffsetTable(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 456);
  CMBlockBufferRef theSourceBuffer = 0;
  if ((int)v3 < 1)
  {
    unsigned int v7 = 0;
    long long v12 = *(const void **)(a1 + 464);
    *(void *)(a1 + 464) = 0;
    if (!v12) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  size_t v5 = 0;
  int v6 = 0;
  unsigned int v7 = 1;
  while (1)
  {
    uint64_t destination = 0;
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 464), v5, 8uLL, &destination);
    v6 += bswap32(destination);
    if (a2 <= v6) {
      break;
    }
    v5 += 8;
    ++v7;
    if (8 * v3 == v5)
    {
      unsigned int v7 = v3;
      break;
    }
  }
  uint64_t v8 = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CMBlockBufferRef *)(a1 + 464), 0, 8 * v7, 0, &theSourceBuffer);
  if (!v8)
  {
    CMBlockBufferRef v9 = theSourceBuffer;
    BOOL v10 = __OFSUB__(a2, v6);
    int v11 = a2 - v6;
    if (v11 < 0 == v10)
    {
LABEL_12:
      long long v12 = *(const void **)(a1 + 464);
      *(void *)(a1 + 464) = v9;
      if (v9) {
        CFRetain(v9);
      }
      if (!v12) {
        goto LABEL_16;
      }
LABEL_15:
      CFRelease(v12);
LABEL_16:
      uint64_t v13 = 0;
      *(_DWORD *)(a1 + 456) = v7;
      goto LABEL_17;
    }
    uint64_t destination = 0;
    uint64_t v8 = CMBlockBufferCopyDataBytes(theSourceBuffer, 8 * (v7 - 1), 8uLL, &destination);
    if (!v8)
    {
      LODWORD(destination) = bswap32(bswap32(destination) + v11);
      uint64_t v8 = CMBlockBufferReplaceDataBytes(&destination, theSourceBuffer, 8 * (v7 - 1), 8uLL);
      if (!v8)
      {
        CMBlockBufferRef v9 = theSourceBuffer;
        goto LABEL_12;
      }
    }
  }
  uint64_t v13 = v8;
LABEL_17:
  if (theSourceBuffer) {
    CFRelease(theSourceBuffer);
  }
  return v13;
}

uint64_t MovieTrackComputeNominalFrameRate(void *a1, uint64_t a2, float *a3)
{
  long long v45 = 0;
  uint64_t v6 = MoovAssureSampleTableParsed(a1, a2);
  float v7 = 0.0;
  if (v6)
  {
    uint64_t v26 = v6;
    uint64_t v14 = 0;
    goto LABEL_16;
  }
  uint64_t v8 = *(void *)(a2 + 224);
  if (!v8)
  {
    uint64_t v14 = 0;
    goto LABEL_15;
  }
  int v9 = *(_DWORD *)(a2 + 288);
  if (*(_DWORD *)(a2 + 816) != 1) {
    goto LABEL_9;
  }
  BOOL v10 = *(long long **)(a2 + 808);
  if ((*((_DWORD *)v10 + 3) & 0x1D) != 1) {
    goto LABEL_9;
  }
  long long v11 = *v10;
  time1.start.uint64_t epoch = *((void *)v10 + 2);
  *(_OWORD *)&time1.start.CMTimeValue value = v11;
  long long v40 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&time2.CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v12 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  time2.uint64_t epoch = v12;
  if (CMTimeCompare(&time1.start, &time2))
  {
    CMTimeEpoch v41 = v12;
    uint64_t v13 = MovieSampleAccessorCreate(a1, a2, &v45);
    uint64_t v14 = v45;
    if (v13)
    {
      uint64_t v26 = v13;
      goto LABEL_16;
    }
    uint64_t v15 = *(void *)(a2 + 808);
    *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)v15;
    time1.start.uint64_t epoch = *(void *)(v15 + 16);
    MovieSampleAccessorMoveToSampleAtPTS((uint64_t)v45, (uint64_t)&time1, 0, 0);
    unsigned int v16 = *((_DWORD *)v14 + 20);
    PTSTimeCFDictionaryRef Value = MovieSampleAccessorGetPTSTimeValue((uint64_t)v14);
    uint64_t v18 = PTSTimeValue - MovieSampleAccessorGetDTSTimeValue((uint64_t)v14);
    uint64_t v19 = *(long long **)(a2 + 808);
    long long v20 = *v19;
    long long v21 = v19[2];
    *(_OWORD *)&time1.start.uint64_t epoch = v19[1];
    *(_OWORD *)&time1.duration.CMTimeScale timescale = v21;
    *(_OWORD *)&time1.start.CMTimeValue value = v20;
    CMTimeRangeGetEnd(&v43, &time1);
    MovieSampleAccessorMoveToSampleAtPTS((uint64_t)v14, (uint64_t)&v43, 0, 0);
    unsigned int v22 = *((_DWORD *)v14 + 20);
    uint64_t v39 = MovieSampleAccessorGetPTSTimeValue((uint64_t)v14);
    if (v18 == v39 - MovieSampleAccessorGetDTSTimeValue((uint64_t)v14))
    {
      unsigned int v23 = v22;
      CMTimeEpoch v24 = v41;
    }
    else
    {
      uint64_t v37 = a3;
      uint64_t v38 = PTSTimeValue;
      int v28 = -120;
      unsigned int v23 = v22;
      unsigned int v29 = v22;
      while (v28 && v23 > v16)
      {
        MovieSampleAccessorStepBackPTS((uint64_t)v14);
        unsigned int v23 = *((_DWORD *)v14 + 20);
        uint64_t v30 = MovieSampleAccessorGetPTSTimeValue((uint64_t)v14);
        ++v28;
        if (v18 == v30 - MovieSampleAccessorGetDTSTimeValue((uint64_t)v14))
        {
          uint64_t v39 = v30;
          goto LABEL_25;
        }
      }
      unsigned int v23 = v29;
LABEL_25:
      CMTimeEpoch v24 = v41;
      a3 = v37;
      PTSTimeCFDictionaryRef Value = v38;
    }
    if (v23 > v16)
    {
      float v7 = (float)(v23 - v16) / (float)((float)(v39 - PTSTimeValue) / (float)*(int *)(a2 + 232));
      uint64_t v31 = *(void *)(a2 + 808);
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(v31 + 24);
      time1.start.uint64_t epoch = *(void *)(v31 + 40);
      CMTime time2 = *(CMTime *)(v31 + 72);
      if (CMTimeCompare(&time1.start, &time2))
      {
        uint64_t v32 = *(void *)(a2 + 808);
        *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(v32 + 72);
        time1.start.uint64_t epoch = *(void *)(v32 + 88);
        *(_OWORD *)&time2.CMTimeValue value = v40;
        time2.uint64_t epoch = v24;
        if (CMTimeCompare(&time1.start, &time2) >= 1)
        {
          uint64_t v33 = *(void *)(a2 + 808);
          *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(v33 + 24);
          time1.start.uint64_t epoch = *(void *)(v33 + 40);
          double Seconds = CMTimeGetSeconds(&time1.start);
          uint64_t v35 = *(void *)(a2 + 808);
          *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(v35 + 72);
          time1.start.uint64_t epoch = *(void *)(v35 + 88);
          uint64_t v26 = 0;
          float v36 = Seconds / CMTimeGetSeconds(&time1.start);
          float v7 = v7 * v36;
          goto LABEL_16;
        }
      }
LABEL_15:
      uint64_t v26 = 0;
      goto LABEL_16;
    }
  }
  else
  {
LABEL_9:
    uint64_t v14 = 0;
  }
  uint64_t v25 = *(void *)(a2 + 728);
  if (v25 && *(void *)(v25 + 56))
  {
    v8 += *(void *)v25;
    v9 += *(_DWORD *)(v25 + 8);
  }
  uint64_t v26 = 0;
  float v7 = (double)v9 * (double)*(int *)(a2 + 232) / (double)v8;
LABEL_16:
  MovieSampleAccessorDispose(v14);
  if (a3) {
    *a3 = v7;
  }
  return v26;
}

uint64_t MovieTrackComputePeakDataRate(void *a1, uint64_t a2, float *a3)
{
  uint64_t v41 = 0;
  long long v42 = 0;
  uint64_t v6 = MoovAssureSampleTableParsed(a1, a2);
  if (v6)
  {
    uint64_t v34 = v6;
    uint64_t v8 = 0;
LABEL_38:
    unsigned int v16 = 0;
    goto LABEL_33;
  }
  uint64_t v7 = MovieSampleAccessorCreate(a1, a2, &v42);
  uint64_t v8 = v42;
  if (v7)
  {
    uint64_t v34 = v7;
    goto LABEL_38;
  }
  DTSTimeCFDictionaryRef Value = MovieSampleAccessorGetDTSTimeValue((uint64_t)v42);
  CMTimeMake(&v40, DTSTimeValue, *((_DWORD *)v8[1] + 58));
  uint64_t v10 = *(int *)(a2 + 232);
  if ((int)v10 < 1)
  {
    uint64_t v34 = 0;
    goto LABEL_38;
  }
  float v36 = a3;
  int v37 = 0;
  int v11 = 0;
  int v12 = 0;
  unint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  unsigned int v16 = 0;
  CMTimeValue value = v40.value;
  while (1)
  {
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v8 = v42;
    uint64_t ChunkDetails = MovieSampleAccessorGetChunkDetails((uint64_t)v42, 0, 0, &v39, &v38, 0, 0, 0, 0);
    if (ChunkDetails) {
      break;
    }
    if (!v38) {
      goto LABEL_32;
    }
    MovieSampleAccessorStepCursor((uint64_t)v8, v38, &v41);
    if (!v41 && v14 >= 1 && v14 < v10)
    {
      if ((uint64_t)(v13 / v14) > v15) {
        uint64_t v15 = v13 / v14;
      }
      goto LABEL_32;
    }
    int64_t v19 = MovieSampleAccessorGetDTSTimeValue((uint64_t)v8);
    CMTimeMake(&v40, v19, *((_DWORD *)v8[1] + 58));
    CMTimeValue v20 = v40.value;
    uint64_t v21 = v40.value - value;
    if (v21 >= 1)
    {
      if (v14 >= v10)
      {
        uint64_t v32 = &v16[v12];
        v14 -= *((void *)v32 + 1);
        v13 -= *(void *)v32;
        *((void *)v32 + 1) = v21;
        *(void *)uint64_t v32 = v39;
        if (v12 + 1 == v11) {
          int v12 = 0;
        }
        else {
          ++v12;
        }
      }
      else
      {
        if (v11 == v37)
        {
          unsigned int v22 = (long long *)malloc_type_calloc(v37 + 30, 0x10uLL, 0x1000040451B5BE8uLL);
          unsigned int v23 = v22;
          CMTimeEpoch v24 = v22;
          if (v12 < v37)
          {
            uint64_t v25 = &v16[v12];
            uint64_t v26 = v22;
            uint64_t v27 = v37 - (uint64_t)v12;
            do
            {
              CMTimeEpoch v24 = v26 + 1;
              long long v28 = *v25++;
              *v26++ = v28;
              --v27;
            }
            while (v27);
          }
          if (v12 >= 1)
          {
            uint64_t v29 = v12;
            uint64_t v30 = v16;
            do
            {
              long long v31 = *v30++;
              *v24++ = v31;
              --v29;
            }
            while (v29);
          }
          free(v16);
          int v12 = 0;
          v37 += 30;
          unsigned int v16 = v23;
        }
        else
        {
          unsigned int v23 = v16;
        }
        uint64_t v33 = &v23[v11];
        *((void *)v33 + 1) = v21;
        *(void *)uint64_t v33 = v39;
        ++v11;
      }
      v14 += v21;
      v13 += v39;
      if (v14 >= v10 && (uint64_t)(v13 / v14) > v15) {
        uint64_t v15 = v13 / v14;
      }
    }
    CMTimeValue value = v20;
    if (!v41)
    {
      uint64_t v8 = v42;
LABEL_32:
      uint64_t v34 = 0;
      *float v36 = (float)(int)v10 * (float)v15;
      goto LABEL_33;
    }
  }
  uint64_t v34 = ChunkDetails;
LABEL_33:
  MovieSampleAccessorDispose(v8);
  free(v16);
  return v34;
}

uint64_t MovieTrackComputeTotalTrackBytes(void *a1, uint64_t a2, uint64_t *a3)
{
  MEMORY[0x19970E290](*(void *)(a2 + 32));
  uint64_t v6 = *(void *)(a2 + 840);
  if (!v6)
  {
    uint64_t v9 = MoovAssureSampleTableParsed(a1, a2);
    if (v9)
    {
      uint64_t v7 = v9;
      goto LABEL_3;
    }
    int v10 = *(_DWORD *)(a2 + 248);
    if (v10 || (int v10 = *(_DWORD *)(a2 + 292)) != 0)
    {
      int v11 = *(_DWORD *)(a2 + 244);
      int v12 = *(_DWORD *)(a2 + 288);
      if (v11) {
        v12 /= v11;
      }
      uint64_t v6 = v10 * (uint64_t)v12;
    }
    else if (*(int *)(a2 + 288) < 1)
    {
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v6 = 0;
      uint64_t v13 = 0;
      do
      {
        v6 += (*(int (**)(uint64_t, uint64_t))(a2 + 592))(a2, v13);
        uint64_t v13 = (v13 + 1);
      }
      while ((int)v13 < *(_DWORD *)(a2 + 288));
    }
    *(void *)(a2 + 840) = v6;
    uint64_t v14 = *(void *)(a2 + 728);
    if (v14)
    {
      uint64_t v15 = *(void **)(v14 + 56);
      if (v15)
      {
        uint64_t v16 = 0;
        do
        {
          for (CFIndex i = (void *)v15[9]; i; CFIndex i = (void *)*i)
            v16 += TotalRunDataSize((uint64_t)v15, (uint64_t)i);
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
        v6 += v16;
        *(void *)(a2 + 840) = v6;
      }
    }
  }
  uint64_t v7 = 0;
  *a3 = v6;
LABEL_3:
  MEMORY[0x19970E2B0](*(void *)(a2 + 32));
  return v7;
}

uint64_t MovieTrackCopyLatentBaseDecodeTimeStampOfFirstTrackFragmentDictionary(CFAllocatorRef allocator, uint64_t a2, CFDictionaryRef *a3)
{
  if (*(unsigned char *)(a2 + 756))
  {
    CMTime v6 = *(CMTime *)(a2 + 744);
    CFDictionaryRef v4 = CMTimeCopyAsDictionary(&v6, allocator);
  }
  else
  {
    CFDictionaryRef v4 = 0;
  }
  *a3 = v4;
  return 0;
}

uint64_t MovieTrackComputeMinSampleDuration(void *a1, uint64_t a2, CMTime *a3)
{
  uint64_t v18 = 0;
  CMTime v17 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA10];
  uint64_t v6 = MoovAssureSampleTableParsed(a1, a2);
  if (v6)
  {
    uint64_t v13 = v6;
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t ChunkDetails = MovieSampleAccessorCreate(a1, a2, &v18);
    uint64_t v8 = v18;
    if (!ChunkDetails)
    {
      while (1)
      {
        BOOL v16 = 0;
        uint64_t v15 = 0;
        uint64_t ChunkDetails = MovieSampleAccessorGetChunkDetails((uint64_t)v8, 0, 0, 0, &v15, 0, 0, &v16, 0);
        if (ChunkDetails) {
          break;
        }
        if (v16)
        {
          UpdateMinSampleDuration((uint64_t)v8, &v17);
          if (MovieSampleAccessorStepCursor((uint64_t)v8, v15, 0)) {
            goto LABEL_16;
          }
        }
        else if (v15 >= 1)
        {
          uint64_t v9 = 1;
          do
          {
            UpdateMinSampleDuration((uint64_t)v8, &v17);
            int v10 = MovieSampleAccessorStepCursor((uint64_t)v8, 1, 0);
          }
          while (v9++ < v15 && v10 == 0);
          if (v10)
          {
LABEL_16:
            uint64_t v13 = 0;
            goto LABEL_17;
          }
        }
      }
    }
    uint64_t v13 = ChunkDetails;
  }
LABEL_17:
  *a3 = v17;
  MovieSampleAccessorDispose(v8);
  return v13;
}

double UpdateMinSampleDuration(uint64_t a1, CMTime *a2)
{
  memset(&v6, 0, sizeof(v6));
  MovieSampleAccessorGetSampleDuration(a1, &v6);
  CMTime time1 = v6;
  CMTime v4 = *a2;
  if (CMTimeCompare(&time1, &v4) < 0)
  {
    double result = *(double *)&v6.value;
    *a2 = v6;
  }
  return result;
}

uint64_t MovieTrackComputeMaxEditRate(void *a1, uint64_t a2, float *a3)
{
  uint64_t v5 = MoovAssureSampleTableParsed(a1, a2);
  float v6 = 1.0;
  if (!v5 && *(int *)(a2 + 816) >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    int v9 = 0;
    float v10 = 1.0;
    int v11 = (CMTime *)MEMORY[0x1E4F1FA48];
    while (1)
    {
      uint64_t v12 = *(void *)(a2 + 808);
      if ((*(_DWORD *)(v12 + v7 + 12) & 0x1D) != 1) {
        goto LABEL_11;
      }
      if ((*(_DWORD *)(v12 + v7 + 36) & 0x1D) != 1) {
        goto LABEL_11;
      }
      uint64_t v13 = v12 + v7;
      long long v14 = *(_OWORD *)(v13 + 24);
      time1.uint64_t epoch = *(void *)(v13 + 40);
      *(_OWORD *)&time1.CMTimeValue value = v14;
      CMTime v21 = *v11;
      if (CMTimeCompare(&time1, &v21) < 1) {
        goto LABEL_11;
      }
      uint64_t v15 = *(void *)(a2 + 808) + v7;
      long long v16 = *(_OWORD *)(v15 + 24);
      time1.uint64_t epoch = *(void *)(v15 + 40);
      *(_OWORD *)&time1.CMTimeValue value = v16;
      double Seconds = CMTimeGetSeconds(&time1);
      uint64_t v18 = *(void *)(a2 + 808) + v7;
      long long v19 = *(_OWORD *)(v18 + 72);
      time1.uint64_t epoch = *(void *)(v18 + 88);
      *(_OWORD *)&time1.CMTimeValue value = v19;
      float v6 = Seconds / CMTimeGetSeconds(&time1);
      if (v9)
      {
        if (v10 >= v6) {
          break;
        }
      }
      int v9 = 1;
LABEL_12:
      ++v8;
      v7 += 96;
      float v10 = v6;
      if (v8 >= *(int *)(a2 + 816)) {
        goto LABEL_13;
      }
    }
    int v9 = 1;
LABEL_11:
    float v6 = v10;
    goto LABEL_12;
  }
LABEL_13:
  *a3 = v6;
  return v5;
}

uint64_t MovieTrackAddParsedSampleDescriptionAndDataRefIndex(uint64_t a1, OpaqueCMBlockBuffer *a2, int a3)
{
  if (*(void *)(a1 + 40)
    || (CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]),
        (*(void *)(a1 + 40) = Mutable) != 0)
    && (CFMutableArrayRef v8 = CFArrayCreateMutable(v6, 0, 0), (*(void *)(a1 + 56) = v8) != 0))
  {
    for (CFIndex i = 0; ; ++i)
    {
      CFArrayRef v10 = *(const __CFArray **)(a1 + 40);
      CFIndex v11 = v10 ? CFArrayGetCount(v10) : 0;
      CFArrayRef v12 = *(const __CFArray **)(a1 + 40);
      if (i >= v11) {
        break;
      }
      CFDataRef ValueAtIndex = (OpaqueCMBlockBuffer *)CFArrayGetValueAtIndex(v12, i);
      unsigned int v23 = 0;
      long long dataPointerOut = 0;
      size_t v21 = 0;
      size_t lengthAtOffsetOut = 0;
      size_t v19 = 0;
      size_t totalLengthOut = 0;
      if (!CMBlockBufferGetDataPointer(a2, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut)
        && lengthAtOffsetOut == totalLengthOut
        && !CMBlockBufferGetDataPointer(ValueAtIndex, 0, &v21, &v19, &v23)
        && v21 == v19
        && totalLengthOut == v21
        && totalLengthOut >= 0x10)
      {
        unint64_t v14 = bswap64(*(void *)dataPointerOut);
        unint64_t v15 = bswap64(*(void *)v23);
        if (v14 == v15
          && (unint64_t v14 = bswap64(*(void *)(dataPointerOut + 6)), v15 = bswap64(*(void *)(v23 + 6)), v14 == v15))
        {
          int v16 = 0;
        }
        else
        {
          int v16 = v14 < v15 ? -1 : 1;
        }
        if (v21 != 16 && !v16) {
          int v16 = memcmp(dataPointerOut + 16, v23 + 16, v21 - 16);
        }
        if (!v16) {
          goto LABEL_27;
        }
      }
    }
    CFArrayAppendValue(v12, a2);
    CFIndex i = CFArrayGetCount(*(CFArrayRef *)(a1 + 40)) - 1;
LABEL_27:
    CMTime v17 = malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
    if (v17)
    {
      *CMTime v17 = i;
      v17[1] = a3 - 1;
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), v17);
      return 0;
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void MovieTrackRemoveAllSampleDescriptions(uint64_t a1)
{
  ReleaseSampleDescriptionInfoArray(a1);
  ReleaseDataReferenceInfoArray(a1);
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 48) = 0;
  }
}

uint64_t MovieTrackIsSelfContained(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 64);
  if (v2)
  {
    CFIndex Count = CFArrayGetCount(v2);
    CMTime v4 = (void *)(a1 + 32);
    MEMORY[0x19970E290](*(void *)(a1 + 32));
    if (Count < 1)
    {
LABEL_6:
      uint64_t v6 = 1;
    }
    else
    {
      CFIndex v5 = 0;
      while (!*(_DWORD *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), v5))
      {
        if (Count == ++v5) {
          goto LABEL_6;
        }
      }
      uint64_t v6 = 0;
    }
  }
  else
  {
    MEMORY[0x19970E290](*(void *)(a1 + 32));
    uint64_t v6 = 1;
    CMTime v4 = (void *)(a1 + 32);
  }
  MEMORY[0x19970E2B0](*v4);
  return v6;
}

uint64_t MovieTrackContainsUnsupportedDataReferences(uint64_t a1, uint64_t a2)
{
  CFArrayRef v3 = *(const __CFArray **)(a2 + 64);
  if (v3)
  {
    CFIndex Count = CFArrayGetCount(v3);
    CFIndex v5 = (void *)(a2 + 32);
    MEMORY[0x19970E290](*(void *)(a2 + 32));
    if (Count < 1)
    {
LABEL_10:
      uint64_t v9 = 0;
    }
    else
    {
      CFIndex v6 = 0;
      while (1)
      {
        int v7 = *(_DWORD *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 64), v6);
        if (v7 != 1970433056 && v7 != 0) {
          break;
        }
        if (++v6 >= Count) {
          goto LABEL_10;
        }
      }
      uint64_t v9 = 1;
    }
  }
  else
  {
    MEMORY[0x19970E290](*(void *)(a2 + 32));
    uint64_t v9 = 0;
    CFIndex v5 = (void *)(a2 + 32);
  }
  MEMORY[0x19970E2B0](*v5);
  return v9;
}

uint64_t MovieTrackIsFrameReorderingRequired(void *a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 720)
    || MoovAssureSampleTableParsed(a1, a2)
    || (uint64_t v3 = *(unsigned int *)(a2 + 456), (int)v3 < 2))
  {
LABEL_7:
    uint64_t result = 0;
  }
  else
  {
    uint64_t destination = 0;
    size_t v4 = 8;
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 464), 0, 8uLL, &destination);
    int v5 = HIDWORD(destination);
    uint64_t v6 = 8 * v3;
    while (1)
    {
      uint64_t destination = 0;
      CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 464), v4, 8uLL, &destination);
      if (HIDWORD(destination) != v5) {
        break;
      }
      v4 += 8;
      if (v6 == v4) {
        goto LABEL_7;
      }
    }
    uint64_t result = 1;
  }
  uint64_t v8 = *(void *)(a2 + 728);
  if (v8 && *(void *)(v8 + 56))
  {
    if (*(unsigned char *)(v8 + 13)) {
      return 1;
    }
    else {
      return result;
    }
  }
  return result;
}

uint64_t MovieTrackIsChapterTrack(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 328);
  if (v2 < 1) {
    return 0;
  }
  for (CFIndex i = (_DWORD *)(*(void *)(a1 + 344) + 8); *(i - 2) != 1667785072 || *i != *(_DWORD *)(a2 + 144); i += 3)
  {
    if (!--v2) {
      return 0;
    }
  }
  return 1;
}

uint64_t MovieInformationContainsChapters(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 328);
  if (v1 < 1) {
    return 0;
  }
  uint64_t v2 = *(int **)(a1 + 344);
  while (1)
  {
    int v3 = *v2;
    v2 += 3;
    if (v3 == 1667785072) {
      break;
    }
    if (!--v1) {
      return 0;
    }
  }
  return 1;
}

uint64_t MovieInformationRemoveOneTrackReference(uint64_t *a1, int a2, int a3, int a4)
{
  uint64_t v4 = a1[41];
  if (v4 >= 1)
  {
    uint64_t v9 = (_DWORD *)a1[43];
    size_t v10 = 12 * v4 - 12;
    uint64_t v11 = v4;
    while (*v9 != a2 || v9[1] != a3 || v9[2] != a4)
    {
      v10 -= 12;
      v9 += 3;
      if (!--v11) {
        return 0;
      }
    }
    if (v11 != 1)
    {
      memmove(v9, v9 + 3, v10);
      uint64_t v4 = a1[41];
    }
    a1[41] = v4 - 1;
    NoteTrackReferenceChange(a1, a2, a3, a4);
  }
  return 0;
}

uint64_t *NoteTrackReferenceChange(uint64_t *result, int a2, int a3, int a4)
{
  uint64_t v4 = result[38];
  if (v4 <= 0) {
    goto LABEL_14;
  }
  uint64_t v5 = result[40];
  uint64_t v6 = (uint64_t *)v5;
  uint64_t v7 = result[38];
  do
  {
    uint64_t v8 = *v6;
    if (*(_DWORD *)(*v6 + 144) == a3) {
      goto LABEL_6;
    }
    ++v6;
    --v7;
  }
  while (v7);
  uint64_t v8 = 0;
LABEL_6:
  while (1)
  {
    uint64_t v9 = *(void *)v5;
    if (*(_DWORD *)(*(void *)v5 + 144) == a4) {
      break;
    }
    v5 += 8;
    if (!--v4)
    {
      uint64_t v9 = 0;
      break;
    }
  }
  if (v8) {
    *(void *)(v8 + 16) |= 0x100000uLL;
  }
  if (!v9)
  {
LABEL_14:
    uint64_t v13 = result[5];
    result += 5;
    uint64_t v12 = v13 | 0x100;
    *uint64_t result = v13 | 0x100;
    if (a2 != 1667785072) {
      return result;
    }
    goto LABEL_15;
  }
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = v10 | 0x100000;
  if (a2 == 1667785072)
  {
    *(void *)(v9 + 16) = v10 | 0x300000;
    *(unsigned char *)(v9 + 898) = 1;
    uint64_t v11 = result[5];
    result += 5;
    uint64_t v12 = v11 | 0x100;
LABEL_15:
    *uint64_t result = v12 | 0x4000;
    return result;
  }
  result[5] |= 0x100uLL;
  return result;
}

uint64_t MovieInformationRemoveAllTrackReferences(uint64_t *a1)
{
  uint64_t v1 = a1[41];
  if (v1)
  {
    if (v1 >= 1)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 0;
      do
      {
        NoteTrackReferenceChange(a1, *(_DWORD *)(a1[43] + v3), *(_DWORD *)(a1[43] + v3 + 4), *(_DWORD *)(a1[43] + v3 + 8));
        ++v4;
        v3 += 12;
      }
      while (v4 < a1[41]);
    }
    a1[41] = 0;
  }
  return 0;
}

uint64_t MovieInformationSetAudibleGroupID(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 296) = 1;
  *(_DWORD *)(a1 + 300) = a2;
  return 0;
}

uint64_t MovieInformationAddOneTrackReference(uint64_t *a1, int a2, int a3, int a4)
{
  uint64_t result = 0;
  if (a3 && a4)
  {
    if (a2 == 1952658996) {
      int v8 = 1953325924;
    }
    else {
      int v8 = a2;
    }
    uint64_t v9 = a1[41];
    if (v9 < 1)
    {
LABEL_12:
      uint64_t result = EnsureTrackReferenceArrayCapacityForAddition(a1);
      if (!result)
      {
        uint64_t v11 = a1[41];
        if (v11 < 1)
        {
          uint64_t v13 = 0;
LABEL_21:
          if (v11 != v13)
          {
            memmove((void *)(a1[43] + 12 * v13 + 12), (const void *)(a1[43] + 12 * v13), 12 * (v11 - v13));
            uint64_t v11 = a1[41];
          }
        }
        else
        {
          int v12 = 0;
          uint64_t v13 = 0;
          unint64_t v14 = (int *)a1[43];
          do
          {
            int v15 = *v14;
            v14 += 3;
            if (v15 == v8)
            {
              int v12 = 1;
            }
            else if (v12)
            {
              goto LABEL_21;
            }
            ++v13;
          }
          while (v11 != v13);
          uint64_t v13 = a1[41];
        }
        int v16 = (int *)(a1[43] + 12 * v13);
        *int v16 = v8;
        v16[1] = a3;
        v16[2] = a4;
        a1[41] = v11 + 1;
        NoteTrackReferenceChange(a1, v8, a3, a4);
        return 0;
      }
    }
    else
    {
      uint64_t v10 = (_DWORD *)(a1[43] + 8);
      while (*(v10 - 2) != v8 || *(v10 - 1) != a3 || *v10 != a4)
      {
        v10 += 3;
        if (!--v9) {
          goto LABEL_12;
        }
      }
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t EnsureTrackReferenceArrayCapacityForAddition(void *a1)
{
  uint64_t v1 = a1[41];
  if (v1 != a1[42]) {
    return 0;
  }
  uint64_t v3 = (void *)a1[43];
  if (v3)
  {
    uint64_t v4 = v1 + 4;
    uint64_t v5 = malloc_type_realloc(v3, 12 * (v1 + 4), 0x10000403E1C8BA9uLL);
    if (v5)
    {
      a1[42] = v4;
      a1[43] = v5;
      return 0;
    }
  }
  else
  {
    *(_OWORD *)(a1 + 41) = xmmword_1949985E0;
    uint64_t v6 = malloc_type_malloc(0x60uLL, 0x10000403E1C8BA9uLL);
    a1[43] = v6;
    if (v6) {
      return 0;
    }
  }

  return FigSignalErrorAt();
}

uint64_t MovieInformationAddNewPerTrackInfo(void *a1, CFTypeRef cf)
{
  if (!*((unsigned char *)cf + 896))
  {
    uint64_t v4 = a1[38];
    if (v4 != a1[39])
    {
LABEL_7:
      CFTypeRef v9 = CFRetain(cf);
      uint64_t v10 = a1[38];
      *(void *)(a1[40] + 8 * v10) = v9;
      a1[38] = v10 + 1;
      CFTypeRef v11 = (CFTypeRef)a1[8];
      if (v11) {
        CFTypeRef v11 = CFRetain(v11);
      }
      *((void *)cf + 80) = v11;
      if (a1[4])
      {
        CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRegisterForBarrierSupport();
        *((unsigned char *)cf + 897) = 1;
      }
      return 0;
    }
    uint64_t v5 = (void *)a1[40];
    if (v5)
    {
      uint64_t v6 = v4 + 4;
      uint64_t v7 = malloc_type_realloc(v5, 8 * (v4 + 4), 0x2004093837F09uLL);
      if (v7)
      {
        a1[39] = v6;
        a1[40] = v7;
        goto LABEL_7;
      }
    }
    else
    {
      *((_OWORD *)a1 + 19) = xmmword_1949985E0;
      int v8 = malloc_type_malloc(0x40uLL, 0x2004093837F09uLL);
      a1[40] = v8;
      if (v8) {
        goto LABEL_7;
      }
    }
  }

  return FigSignalErrorAt();
}

void MovieTrackEvaluateParsedLanguageCode(uint64_t a1, int a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef StringForLanguageCode = FigCreateStringForLanguageCode((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(unsigned __int16 *)(a1 + 716), a2);
  MovieTrackSetLanguageCodeString(a1, StringForLanguageCode);
  if (StringForLanguageCode) {
    CFRelease(StringForLanguageCode);
  }
  if (!*(void *)(a1 + 848))
  {
    int v5 = *(__int16 *)(a1 + 716);
    if (v5 > 83)
    {
      switch(v5)
      {
        case 84:
          uint64_t v6 = "ms-Arab";
          break;
        case 146:
          uint64_t v6 = "ga-Latg";
          break;
        case 150:
          uint64_t v6 = "az";
          break;
        default:
          return;
      }
    }
    else
    {
      switch(*(_WORD *)(a1 + 716))
      {
        case '1':
          uint64_t v6 = "az-Cyrl";
          break;
        case '2':
          uint64_t v6 = "az-Arab";
          break;
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
          return;
        case '9':
          uint64_t v6 = "mn-Mong";
          break;
        case ':':
          uint64_t v6 = "mn";
          break;
        default:
          if (v5 == 19)
          {
            uint64_t v6 = "zh-Hant";
          }
          else
          {
            if (v5 != 33) {
              return;
            }
            uint64_t v6 = "zh-Hans";
          }
          break;
      }
    }
    CFStringRef v7 = CFStringCreateWithCStringNoCopy(v3, v6, 0x600u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (v7) {
      *(void *)(a1 + 848) = v7;
    }
  }
}

void MovieTrackEvaluateAlternateTrackGroupAssignment(uint64_t a1)
{
  int v2 = *(unsigned __int16 *)(a1 + 150);
  if (*(unsigned char *)(a1 + 740))
  {
    int v3 = *(unsigned __int16 *)(a1 + 738);
    CFArrayRef v4 = MovieTrackCopyFormatDescriptionArray(a1);
    if (!v4) {
      goto LABEL_15;
    }
    CFArrayRef v5 = v4;
    CFIndex Count = CFArrayGetCount(v4);
    if (Count < 1)
    {
      CFRelease(v5);
      goto LABEL_15;
    }
    CFIndex v7 = Count;
    CFDataRef ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(v5, 0);
    if (CMFormatDescriptionGetMediaType(ValueAtIndex) == 1952807028)
    {
      CFIndex v9 = 1;
      BOOL v10 = 1;
      do
      {
        FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(ValueAtIndex);
        if (MediaSubType != 1937142900 && MediaSubType != 2021028980 && MediaSubType != 2004251764) {
          break;
        }
        if (!FigValidateRequiredFeaturesOfFormatDescription(ValueAtIndex)) {
          break;
        }
        BOOL v10 = v9 < v7;
        if (v7 == v9) {
          break;
        }
        CFDataRef ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(v5, v9++);
      }
      while (CMFormatDescriptionGetMediaType(ValueAtIndex) == 1952807028);
      CFRelease(v5);
      if (v10) {
        goto LABEL_18;
      }
LABEL_15:
      if (*(unsigned __int16 *)(a1 + 864) == v3) {
        return;
      }
      *(_WORD *)(a1 + 864) = v3;
      goto LABEL_20;
    }
    CFRelease(v5);
  }
LABEL_18:
  if (*(unsigned __int16 *)(a1 + 864) == v2) {
    return;
  }
  *(_WORD *)(a1 + 864) = v2;
LABEL_20:
  *(void *)(a1 + 16) |= 0x1000uLL;
}

void MovieTrackCreateEnhancedGaplessInfo(void *a1, uint64_t a2)
{
  CFTypeRef v10 = 0;
  if (*(_DWORD *)(a2 + 24) == 1936684398)
  {
    if (*(void *)(a2 + 832))
    {
      FigSignalErrorAt();
    }
    else
    {
      MovieInformationCreateiTunesMetadataReader(a1, &v10);
      if (!v10) {
        return;
      }
      CFArrayRef v3 = MovieTrackCopyFormatDescriptionArray(a2);
      if (v3)
      {
        CFArrayRef v4 = v3;
        if (CFArrayGetCount(v3) >= 1)
        {
          uint64_t v8 = 0;
          int64_t v9 = 0;
          if (FigGaplessInfoFetchiTunesParametersFromMetadataReader((uint64_t)v10, (uint64_t)&v8))
          {
            CFDataRef ValueAtIndex = (const AudioFormatListItem *)CFArrayGetValueAtIndex(v4, 0);
            memset(&v7, 0, sizeof(v7));
            MovieTrackGetMediaDuration(a2, (uint64_t)&v7);
            CMTime v6 = v7;
            *(void *)(a2 + 832) = FigGaplessInfoCreateEnhanced_CorrectingWithUneditedDuration(ValueAtIndex, &v6, v8, SHIDWORD(v8), v9);
          }
        }
        CFRelease(v4);
      }
    }
    if (v10) {
      CFRelease(v10);
    }
  }
}

uint64_t MovieInformationCreateiTunesMetadataReader(void *a1, void *a2)
{
  CFDictionaryRef v4 = (const __CFDictionary *)a1[44];
  if (v4 && (CFDictionaryRef Value = CFDictionaryGetValue(v4, @"com.apple.itunes")) != 0)
  {
    CMTime v6 = Value;
    uint64_t v7 = *MEMORY[0x1E4F1CF80];
    return FigMetadataReaderCreateForiTunesMetadataArray(v7, v6, a2);
  }
  else
  {
    return MovieInformationCreateiTunesMetadataReaderFromByteStream(a1, a2);
  }
}

uint64_t MovieTrackCopyEnhancedGaplessInfo(uint64_t a1, void *a2)
{
  if (a2)
  {
    if (*(_DWORD *)(a1 + 24) == 1936684398)
    {
      MEMORY[0x19970E290](*(void *)(a1 + 32));
      CFTypeRef v5 = *(CFTypeRef *)(a1 + 832);
      if (v5) {
        CFTypeRef v5 = CFRetain(v5);
      }
      *a2 = v5;
      MEMORY[0x19970E2B0](*(void *)(a1 + 32));
      return 0;
    }
    else
    {
      return 4294954516;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieTrackInvalidateEnhancedGaplessInfo(uint64_t result)
{
  if (*(_DWORD *)(result + 24) == 1936684398)
  {
    uint64_t v1 = result;
    MEMORY[0x19970E290](*(void *)(result + 32));
    uint64_t v2 = *(const void **)(v1 + 832);
    if (v2)
    {
      CFRelease(v2);
      *(void *)(v1 + 832) = 0;
    }
    JUMPOUT(0x19970E2B0);
  }
  return result;
}

uint64_t MovieTrackCreate(uint64_t *a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (sRegisterMoviePerTrackInfoTypeOnce != -1) {
    dispatch_once_f(&sRegisterMoviePerTrackInfoTypeOnce, 0, (dispatch_function_t)RegisterMoviePerTrackInfoType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v4 = FigReentrantMutexCreate();
    *(void *)(Instance + 32) = v4;
    if (v4)
    {
      unint64_t v5 = (unint64_t)(Current + *MEMORY[0x1E4F1CF68]);
      *(unsigned char *)(Instance + 200) = 1;
      *(_DWORD *)(Instance + 184) = 1065353216;
      *(_OWORD *)(Instance + 152) = kIdentityMatrix_0;
      *(_OWORD *)(Instance + 168) = unk_194998610;
      *(void *)(Instance + 120) = v5;
      *(void *)(Instance + 128) = v5;
      *(_DWORD *)(Instance + 196) = 1065353216;
      *(_DWORD *)(Instance + 232) = 0;
      *(void *)(Instance + 208) = v5;
      *(void *)(Instance + 216) = v5;
      *(_OWORD *)(Instance + 88) = xmmword_1949985F0;
      *(void *)(Instance + 104) = 0x8000000000000000;
      *(void *)(Instance + 112) = 0;
      *(_DWORD *)(Instance + 296) = 0x80000000;
      *(void *)(Instance + 304) = 0x8000000000000000;
      CFStringRef v6 = (const __CFString *)CFRetain(@"und");
      *(void *)(Instance + 856) = v6;
      uint64_t v7 = 0;
      *(_WORD *)(Instance + 236) = FigGetISOLanguageCodeForString(v6);
      *(void *)(Instance + 584) = GetNumSamples_stsz;
      *(void *)(Instance + 592) = GetSampleSize_stsz;
      *(void *)(Instance + 600) = GetSampleSizeFieldSize_stsz;
      *(void *)(Instance + 608) = GetSizeTable_stsz;
      *(void *)(Instance + 616) = GetChunkOffset_stco;
      *(void *)(Instance + 624) = GetChunkCount_stco;
      *(void *)(Instance + 632) = GetChunkTable_stco;
    }
    else
    {
      uint64_t v7 = FigSignalErrorAt();
      if (v7)
      {
        CFRelease((CFTypeRef)Instance);
        uint64_t Instance = 0;
      }
    }
  }
  else
  {
    uint64_t v7 = FigSignalErrorAt();
  }
  *a1 = Instance;
  return v7;
}

uint64_t MovieInformationGetNextTrackID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 252);
}

uint64_t MovieInformationGetBasicMetrics(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  if (a2) {
    *a2 = *(_DWORD *)(a1 + 244);
  }
  if (a3) {
    *a3 = *(_DWORD *)(a1 + 248);
  }
  if (a4) {
    *a4 = *(_DWORD *)(a1 + 240);
  }
  if (a5)
  {
    long long v5 = *(_OWORD *)(a1 + 256);
    long long v6 = *(_OWORD *)(a1 + 272);
    *(_DWORD *)(a5 + 32) = *(_DWORD *)(a1 + 288);
    *(_OWORD *)a5 = v5;
    *(_OWORD *)(a5 + 16) = v6;
  }
  return 0;
}

uint64_t MovieInformationGetTimeInfo(uint64_t a1, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(a1 + 216);
  }
  if (a3) {
    *a3 = *(void *)(a1 + 224);
  }
  return 0;
}

uint64_t MovieInformationGetMoovLocation(uint64_t a1, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(a1 + 96);
  }
  if (a3) {
    *a3 = *(void *)(a1 + 104);
  }
  return 0;
}

double MovieInformationGetMovieDuration@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  CMTimeMake((CMTime *)a2, *(void *)(a1 + 232), *(_DWORD *)(a1 + 240));
  if (*(unsigned char *)(a1 + 157))
  {
    MovieDurationWithFragmentContribution(a1, (uint64_t)&v5);
    double result = *(double *)&v5;
    *(_OWORD *)a2 = v5;
    *(void *)(a2 + 16) = v6;
  }
  return result;
}

uint64_t MovieInformationGetPSSHDataEntries(uint64_t a1, void *a2)
{
  *a2 = *(void *)(a1 + 360);
  return 0;
}

uint64_t MovieInformationMetadataFormatIsAvailable(void *a1, CFTypeRef cf1)
{
  uint64_t v4 = @"com.apple.quicktime.udta";
  if (CFEqual(cf1, @"com.apple.quicktime.udta"))
  {
    uint64_t v5 = a1[14];
  }
  else
  {
    uint64_t v4 = @"org.mp4ra";
    if (CFEqual(cf1, @"org.mp4ra"))
    {
      uint64_t v5 = a1[15];
    }
    else
    {
      uint64_t v4 = @"com.apple.quicktime.mdta";
      if (CFEqual(cf1, @"com.apple.quicktime.mdta"))
      {
        uint64_t v5 = a1[16];
      }
      else
      {
        uint64_t v4 = @"com.apple.itunes";
        uint64_t result = CFEqual(cf1, @"com.apple.itunes");
        if (!result) {
          return result;
        }
        uint64_t v5 = a1[17];
      }
    }
  }
  if (v5 > 0) {
    return 1;
  }
  uint64_t result = a1[44];
  if (result) {
    return CFDictionaryGetValue((CFDictionaryRef)result, v4) != 0;
  }
  return result;
}

CFDictionaryRef MovieInformationGetMovieMetadataItemArray(uint64_t a1, const void *a2)
{
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 352);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  }
  return result;
}

uint64_t MovieInformationCreateQuickTimeUserDataReader(void *a1, void *a2)
{
  CFDictionaryRef v4 = (const __CFDictionary *)a1[44];
  if (v4 && (CFDictionaryRef Value = CFDictionaryGetValue(v4, @"com.apple.quicktime.udta")) != 0)
  {
    uint64_t v6 = Value;
    uint64_t v7 = *MEMORY[0x1E4F1CF80];
    return FigMetadataReaderCreateForQuickTimeUserDataArray(v7, v6, a2);
  }
  else
  {
    return MovieInformationCreateQuickTimeUserDataReaderFromByteStream(a1, a2);
  }
}

uint64_t MovieInformationCreateQuickTimeUserDataReaderFromByteStream(void *a1, void *a2)
{
  if ((uint64_t)a1[14] < 1)
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    CFAllocatorRef v4 = CFGetAllocator(a1);
    uint64_t v5 = a1[7];
    uint64_t v6 = a1[14];
    return FigMetadataReaderCreateForQuickTimeUserData((uint64_t)v4, v5, v6, (uint64_t)a2);
  }
}

uint64_t MovieInformationCreateISOUserDataReader(void *a1, void *a2)
{
  CFDictionaryRef v4 = (const __CFDictionary *)a1[44];
  if (v4 && (CFDictionaryRef Value = CFDictionaryGetValue(v4, @"org.mp4ra")) != 0)
  {
    uint64_t v6 = Value;
    uint64_t v7 = *MEMORY[0x1E4F1CF80];
    return FigMetadataReaderCreateForISOUserDataArray(v7, v6, a2);
  }
  else
  {
    return MovieInformationCreateISOUserDataReaderFromByteStream(a1, a2);
  }
}

uint64_t MovieInformationCreateISOUserDataReaderFromByteStream(void *a1, void *a2)
{
  if ((uint64_t)a1[15] < 1)
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    CFAllocatorRef v4 = CFGetAllocator(a1);
    uint64_t v5 = a1[7];
    uint64_t v6 = a1[15];
    return FigMetadataReaderCreateForISOUserData((uint64_t)v4, v5, v6, (uint64_t)a2);
  }
}

uint64_t MovieInformationCreateQuickTimeMetadataReader(void *a1, void *a2)
{
  CFDictionaryRef v4 = (const __CFDictionary *)a1[44];
  if (v4 && (CFDictionaryRef Value = CFDictionaryGetValue(v4, @"com.apple.quicktime.mdta")) != 0)
  {
    uint64_t v6 = Value;
    uint64_t v7 = *MEMORY[0x1E4F1CF80];
    return FigMetadataReaderCreateForQuickTimeMetadataArray(v7, v6, a2);
  }
  else
  {
    return MovieInformationCreateQuickTimeMetadataReaderFromByteStream(a1, a2);
  }
}

uint64_t MovieInformationCreateQuickTimeMetadataReaderFromByteStream(void *a1, void *a2)
{
  if ((uint64_t)a1[16] < 1)
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    CFAllocatorRef v4 = CFGetAllocator(a1);
    uint64_t v5 = (const void *)a1[7];
    uint64_t v6 = a1[16];
    return FigMetadataReaderCreateForQuickTimeMetadata((uint64_t)v4, v5, v6, a2);
  }
}

uint64_t MovieInformationCreateiTunesMetadataReaderFromByteStream(void *a1, void *a2)
{
  if ((uint64_t)a1[17] < 1)
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    CFAllocatorRef v4 = CFGetAllocator(a1);
    uint64_t v5 = (const void *)a1[7];
    uint64_t v6 = a1[17];
    return FigMetadataReaderCreateForiTunes((uint64_t)v4, v5, v6, a2);
  }
}

uint64_t MovieTrackSupplementQuickTimeUserDataFromBlockBuffer(const void *a1, uint64_t *a2, uint64_t a3)
{
  CFArrayRef theArray = 0;
  CFTypeRef cf = 0;
  CFTypeRef v16 = 0;
  CFTypeRef v17 = 0;
  CFAllocatorRef v6 = CFGetAllocator(a1);
  uint64_t v7 = FigMetadataReaderCreateForQuickTimeUserDataBlockBuffer((uint64_t)v6, a3, &cf);
  if (v7) {
    goto LABEL_29;
  }
  CFAllocatorRef v8 = CFGetAllocator(a1);
  uint64_t v7 = FigMetadataCopyAllMetadataItems(v8, (uint64_t)cf, &theArray);
  if (v7) {
    goto LABEL_29;
  }
  if (!theArray || CFArrayGetCount(theArray) < 1)
  {
    uint64_t v11 = 0;
LABEL_10:
    int v12 = 0;
    CFDictionaryRef v13 = 0;
    goto LABEL_15;
  }
  uint64_t v7 = MovieTrackCreateQuickTimeUserDataReader((uint64_t)a1, a2, &v17);
  if (v7)
  {
LABEL_29:
    uint64_t v11 = v7;
    goto LABEL_10;
  }
  if (v17)
  {
    CFAllocatorRef v9 = CFGetAllocator(a1);
    uint64_t v7 = FigMetadataCopyAllMetadataItems(v9, (uint64_t)v17, (__CFArray **)&v16);
    if (!v7)
    {
      uint64_t ConcatenationOfTwoArrays = FigCFArrayCreateConcatenationOfTwoArrays();
      goto LABEL_13;
    }
    goto LABEL_29;
  }
  LODWORD(ConcatenationOfTwoArrays) = theArray;
  if (!theArray)
  {
    int v12 = 0;
    goto LABEL_14;
  }
  uint64_t ConcatenationOfTwoArrays = (uint64_t)CFRetain(theArray);
LABEL_13:
  int v12 = (void *)ConcatenationOfTwoArrays;
LABEL_14:
  MovieTrackSetTrackMetadataItemArray(ConcatenationOfTwoArrays, (uint64_t)a2, @"com.apple.quicktime.udta", v12);
  CFAllocatorRef v14 = CFGetAllocator(a1);
  CFDictionaryRef v13 = CFDictionaryCreate(v14, (const void **)&kFigMetadataFormat_QuickTimeUserData, (const void **)&theArray, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  PostTrackMetadataSupplementedNotification((uint64_t)a1, (uint64_t)a2, v13);
  uint64_t v11 = 0;
LABEL_15:
  if (cf) {
    CFRelease(cf);
  }
  if (theArray) {
    CFRelease(theArray);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v11;
}

uint64_t MovieTrackCreateQuickTimeUserDataReader(uint64_t a1, uint64_t *cf, void *a3)
{
  CFDictionaryRef v6 = (const __CFDictionary *)cf[111];
  if (v6 && (CFDictionaryRef Value = CFDictionaryGetValue(v6, @"com.apple.quicktime.udta")) != 0)
  {
    CFAllocatorRef v8 = Value;
    uint64_t v9 = *MEMORY[0x1E4F1CF80];
    return FigMetadataReaderCreateForQuickTimeUserDataArray(v9, v8, a3);
  }
  else
  {
    return MovieTrackCreateQuickTimeUserDataReaderFromByteStream(a1, cf, a3);
  }
}

uint64_t MovieTrackSetTrackMetadataItemArray(int a1, uint64_t a2, void *key, void *value)
{
  CFMutableArrayRef Mutable = *(__CFDictionary **)(a2 + 888);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)(a2 + 888) = Mutable;
  }
  CFDictionarySetValue(Mutable, key, value);
  uint64_t result = FigCFEqual();
  if (result)
  {
    uint64_t v9 = 8;
  }
  else
  {
    uint64_t result = FigCFEqual();
    if (result)
    {
      uint64_t v9 = 32;
    }
    else
    {
      uint64_t result = FigCFEqual();
      uint64_t v9 = 16 * (result != 0);
    }
  }
  *(void *)(a2 + 16) |= v9;
  return result;
}

void PostTrackMetadataSupplementedNotification(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v14 = 0;
  CFNumberRef v12 = 0;
  if ((*(unsigned char *)(a1 + 16) & 4) == 0 && !*(void *)(a1 + 32)) {
    return;
  }
  keys = @"Metadata";
  values = a3;
  if (!*(_DWORD *)(a1 + 184))
  {
    CFNumberRef v5 = 0;
    goto LABEL_7;
  }
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (const void *)(a1 + 188));
  CFNumberRef v5 = v4;
  if (!v4)
  {
LABEL_7:
    CFIndex v6 = 1;
    goto LABEL_8;
  }
  CFAllocatorRef v14 = @"SequenceNumber";
  CFNumberRef v12 = v4;
  CFIndex v6 = 2;
LABEL_8:
  CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)a1);
  CFDictionaryRef v8 = CFDictionaryCreate(v7, (const void **)&keys, (const void **)&values, v6, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v8)
  {
    CFDictionaryRef v9 = v8;
    uint64_t v10 = *(void *)(a1 + 32);
    CMNotificationCenterGetDefaultLocalCenter();
    if (v10) {
      FigDeferNotificationToDispatchQueue();
    }
    else {
      CMNotificationCenterPostNotification();
    }
    CFRelease(v9);
  }
  if (v5) {
    CFRelease(v5);
  }
}

uint64_t MovieTrackSupplementISOUserDataFromBlockBuffer(const void *a1, uint64_t *a2, uint64_t a3)
{
  CFArrayRef theArray = 0;
  CFTypeRef cf = 0;
  CFTypeRef v16 = 0;
  CFTypeRef v17 = 0;
  CFAllocatorRef v6 = CFGetAllocator(a1);
  uint64_t v7 = FigMetadataReaderCreateForISOUserDataBlockBuffer((uint64_t)v6, a3, &cf);
  if (v7) {
    goto LABEL_29;
  }
  CFAllocatorRef v8 = CFGetAllocator(a1);
  uint64_t v7 = FigMetadataCopyAllMetadataItems(v8, (uint64_t)cf, &theArray);
  if (v7) {
    goto LABEL_29;
  }
  if (!theArray || CFArrayGetCount(theArray) < 1)
  {
    uint64_t v11 = 0;
LABEL_10:
    CFNumberRef v12 = 0;
    CFDictionaryRef v13 = 0;
    goto LABEL_15;
  }
  uint64_t v7 = MovieTrackCreateISOUserDataReader((uint64_t)a1, a2, &v17);
  if (v7)
  {
LABEL_29:
    uint64_t v11 = v7;
    goto LABEL_10;
  }
  if (v17)
  {
    CFAllocatorRef v9 = CFGetAllocator(a1);
    uint64_t v7 = FigMetadataCopyAllMetadataItems(v9, (uint64_t)v17, (__CFArray **)&v16);
    if (!v7)
    {
      uint64_t ConcatenationOfTwoArrays = FigCFArrayCreateConcatenationOfTwoArrays();
      goto LABEL_13;
    }
    goto LABEL_29;
  }
  LODWORD(ConcatenationOfTwoArrays) = theArray;
  if (!theArray)
  {
    CFNumberRef v12 = 0;
    goto LABEL_14;
  }
  uint64_t ConcatenationOfTwoArrays = (uint64_t)CFRetain(theArray);
LABEL_13:
  CFNumberRef v12 = (void *)ConcatenationOfTwoArrays;
LABEL_14:
  MovieTrackSetTrackMetadataItemArray(ConcatenationOfTwoArrays, (uint64_t)a2, @"org.mp4ra", v12);
  CFAllocatorRef v14 = CFGetAllocator(a1);
  CFDictionaryRef v13 = CFDictionaryCreate(v14, (const void **)&kFigMetadataFormat_ISOUserData, (const void **)&theArray, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  PostTrackMetadataSupplementedNotification((uint64_t)a1, (uint64_t)a2, v13);
  uint64_t v11 = 0;
LABEL_15:
  if (cf) {
    CFRelease(cf);
  }
  if (theArray) {
    CFRelease(theArray);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v11;
}

uint64_t MovieTrackCreateISOUserDataReader(uint64_t a1, uint64_t *cf, void *a3)
{
  CFDictionaryRef v6 = (const __CFDictionary *)cf[111];
  if (v6 && (CFDictionaryRef Value = CFDictionaryGetValue(v6, @"org.mp4ra")) != 0)
  {
    CFAllocatorRef v8 = Value;
    uint64_t v9 = *MEMORY[0x1E4F1CF80];
    return FigMetadataReaderCreateForISOUserDataArray(v9, v8, a3);
  }
  else
  {
    return MovieTrackCreateISOUserDataReaderFromByteStream(a1, cf, a3);
  }
}

uint64_t MovieTrackMetadataFormatIsAvailable(int a1, void *a2, CFTypeRef cf1)
{
  CFNumberRef v5 = @"com.apple.quicktime.udta";
  if (CFEqual(cf1, @"com.apple.quicktime.udta"))
  {
    uint64_t v6 = a2[84];
  }
  else
  {
    CFNumberRef v5 = @"org.mp4ra";
    if (CFEqual(cf1, @"org.mp4ra"))
    {
      uint64_t v6 = a2[85];
    }
    else
    {
      CFNumberRef v5 = @"com.apple.quicktime.mdta";
      uint64_t result = CFEqual(cf1, @"com.apple.quicktime.mdta");
      if (!result) {
        return result;
      }
      uint64_t v6 = a2[86];
    }
  }
  if (v6 > 0) {
    return 1;
  }
  uint64_t result = a2[111];
  if (result) {
    return CFDictionaryGetValue((CFDictionaryRef)result, v5) != 0;
  }
  return result;
}

CFDictionaryRef MovieTrackGetTrackMetadataItemArray(uint64_t a1, const void *a2)
{
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 888);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  }
  return result;
}

uint64_t MovieTrackCreateQuickTimeUserDataReaderFromByteStream(uint64_t a1, uint64_t *cf, void *a3)
{
  if (cf[84] < 1)
  {
    *a3 = 0;
    return 0;
  }
  else
  {
    CFAllocatorRef v6 = CFGetAllocator(cf);
    uint64_t v7 = *(void *)(a1 + 56);
    uint64_t v8 = cf[84];
    return FigMetadataReaderCreateForQuickTimeUserData((uint64_t)v6, v7, v8, (uint64_t)a3);
  }
}

uint64_t MovieTrackCreateISOUserDataReaderFromByteStream(uint64_t a1, uint64_t *cf, void *a3)
{
  if (cf[85] < 1)
  {
    *a3 = 0;
    return 0;
  }
  else
  {
    CFAllocatorRef v6 = CFGetAllocator(cf);
    uint64_t v7 = *(void *)(a1 + 56);
    uint64_t v8 = cf[85];
    return FigMetadataReaderCreateForISOUserData((uint64_t)v6, v7, v8, (uint64_t)a3);
  }
}

uint64_t MovieTrackCreateQuickTimeMetadataReader(uint64_t a1, uint64_t *cf, void *a3)
{
  CFDictionaryRef v6 = (const __CFDictionary *)cf[111];
  if (v6 && (CFDictionaryRef Value = CFDictionaryGetValue(v6, @"com.apple.quicktime.mdta")) != 0)
  {
    uint64_t v8 = Value;
    uint64_t v9 = *MEMORY[0x1E4F1CF80];
    return FigMetadataReaderCreateForQuickTimeMetadataArray(v9, v8, a3);
  }
  else
  {
    return MovieTrackCreateQuickTimeMetadataReaderFromByteStream(a1, cf, a3);
  }
}

uint64_t MovieTrackCreateQuickTimeMetadataReaderFromByteStream(uint64_t a1, uint64_t *cf, void *a3)
{
  if (cf[86] < 1)
  {
    *a3 = 0;
    return 0;
  }
  else
  {
    CFAllocatorRef v6 = CFGetAllocator(cf);
    uint64_t v7 = *(const void **)(a1 + 56);
    uint64_t v8 = cf[86];
    return FigMetadataReaderCreateForQuickTimeMetadata((uint64_t)v6, v7, v8, a3);
  }
}

uint64_t MovieInformationCreateTrackReferenceDictionary(const __CFAllocator *a1, uint64_t a2, CFDictionaryRef *a3)
{
  uint64_t v4 = *(void *)(a2 + 328);
  if (v4)
  {
    uint64_t valuePtr = 0;
    CFAllocatorRef v6 = (const void **)malloc_type_malloc(8 * v4, 0x6004044C4A2DFuLL);
    if (v6)
    {
      uint64_t v7 = (const void **)malloc_type_malloc(8 * *(void *)(a2 + 328), 0x6004044C4A2DFuLL);
      if (v7)
      {
        uint64_t v8 = (const void **)malloc_type_malloc(16 * *(void *)(a2 + 328), 0x28B94474uLL);
        if (v8)
        {
          uint64_t v9 = v8;
          if (*(uint64_t *)(a2 + 328) >= 1)
          {
            values = (void **)v7;
            long long v31 = v6;
            uint64_t v29 = a3;
            uint64_t v10 = 0;
            CFIndex v11 = 0;
            CFIndex v12 = 0;
            int v13 = 0;
            uint64_t v14 = 0;
            CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            do
            {
              uint64_t v16 = *(void *)(a2 + 344);
              if (*(_DWORD *)(v16 + 12 * v14) != v13)
              {
                if (v10)
                {
                  v31[v12] = CopyKeyStringForTrackReferenceOSType(a1, v13);
                  values[v12++] = CFArrayCreate(a1, v9, v11, MEMORY[0x1E4F1D510]);
                  if (v11 < 1)
                  {
                    CFIndex v11 = 0;
                  }
                  else
                  {
                    CFTypeRef v17 = v9;
                    do
                    {
                      if (*v17) {
                        CFRelease(*v17);
                      }
                      ++v17;
                      --v11;
                    }
                    while (v11);
                  }
                }
                uint64_t v10 = 0;
                uint64_t v16 = *(void *)(a2 + 344);
                int v13 = *(_DWORD *)(v16 + 12 * v14);
              }
              uint64_t v18 = v16 + 12 * v14;
              HIDWORD(valuePtr) = *(_DWORD *)(v18 + 4);
              int v19 = *(_DWORD *)(v18 + 8);
              LODWORD(valuePtr) = v19;
              if (HIDWORD(valuePtr)) {
                BOOL v20 = v19 == 0;
              }
              else {
                BOOL v20 = 1;
              }
              if (!v20)
              {
                size_t v21 = (CFNumberRef *)&v9[v11];
                *size_t v21 = CFNumberCreate(v15, kCFNumberSInt32Type, (char *)&valuePtr + 4);
                v11 += 2;
                v21[1] = CFNumberCreate(v15, kCFNumberSInt32Type, &valuePtr);
                ++v10;
              }
              ++v14;
            }
            while (v14 < *(void *)(a2 + 328));
            if (!v10)
            {
              a3 = v29;
              uint64_t v7 = (const void **)values;
              CFAllocatorRef v6 = v31;
              goto LABEL_32;
            }
            CFAllocatorRef v6 = v31;
            v31[v12] = CopyKeyStringForTrackReferenceOSType(a1, v13);
            uint64_t v7 = (const void **)values;
            values[v12++] = CFArrayCreate(a1, v9, v11, MEMORY[0x1E4F1D510]);
            if (v11 >= 1)
            {
              unsigned int v22 = v9;
              a3 = v29;
              do
              {
                if (*v22) {
                  CFRelease(*v22);
                }
                ++v22;
                --v11;
              }
              while (v11);
LABEL_32:
              if (v12)
              {
LABEL_33:
                CFDictionaryRef v24 = CFDictionaryCreate(a1, v6, v7, v12, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                if (v12 >= 1)
                {
                  for (uint64_t i = 0; i != v12; ++i)
                  {
                    uint64_t v26 = v6[i];
                    if (v26) {
                      CFRelease(v26);
                    }
                    uint64_t v27 = v7[i];
                    if (v27) {
                      CFRelease(v27);
                    }
                  }
                }
                uint64_t v23 = 0;
                goto LABEL_43;
              }
              goto LABEL_42;
            }
            a3 = v29;
            if (v12) {
              goto LABEL_33;
            }
          }
LABEL_42:
          uint64_t v23 = 0;
          CFDictionaryRef v24 = 0;
LABEL_43:
          free(v6);
          free(v7);
          free(v9);
          goto LABEL_44;
        }
      }
    }
    else
    {
      uint64_t v7 = 0;
    }
    uint64_t v23 = FigSignalErrorAt();
    CFDictionaryRef v24 = 0;
    uint64_t v9 = 0;
    goto LABEL_43;
  }
  uint64_t v23 = 0;
  CFDictionaryRef v24 = 0;
LABEL_44:
  *a3 = v24;
  return v23;
}

CFDictionaryRef MovieInformationCreateQTLoadSettingsDictionary(const __CFAllocator *a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFNumberRef v18 = 0;
  CFDictionaryRef v19 = 0;
  CFDictionaryRef v20 = 0;
  keys[0] = @"DefaultHints";
  keys[1] = @"PreloadFlags";
  _OWORD keys[2] = @"PreloadStart";
  keys[3] = @"PreloadDuration";
  if (!a3[882]) {
    return 0;
  }
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, a3 + 878);
  if (values)
  {
    CFNumberRef v18 = CFNumberCreate(v6, kCFNumberSInt32Type, a3 + 874);
    if (v18)
    {
      uint64_t v7 = (int *)(a3 + 866);
      int64_t v8 = *v7;
      if (v8 == -1)
      {
        CFIndex v9 = 2;
        goto LABEL_10;
      }
      CMTimeMake(&time, v8, *(_DWORD *)(a2 + 240));
      CFDictionaryRef v19 = CMTimeCopyAsDictionary(&time, a1);
      if (v19)
      {
        CMTimeMake(&v14, v7[1], *(_DWORD *)(a2 + 240));
        CFDictionaryRef v20 = CMTimeCopyAsDictionary(&v14, a1);
        if (v20)
        {
          CFIndex v9 = 4;
LABEL_10:
          CFDictionaryRef v10 = CFDictionaryCreate(a1, (const void **)keys, (const void **)&values, v9, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          goto LABEL_11;
        }
      }
    }
  }
  FigSignalErrorAt();
  CFDictionaryRef v10 = 0;
LABEL_11:
  for (uint64_t i = 0; i != 32; i += 8)
  {
    CFIndex v12 = *(void **)((char *)&values + i);
    if (v12) {
      CFRelease(v12);
    }
  }
  return v10;
}

__CFArray *MovieInformationCreateAlternateGroupArray(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 304);
  if (v2 < 1) {
    return 0;
  }
  char v5 = 0;
  CFAllocatorRef v6 = *(uint64_t **)(a2 + 320);
  uint64_t v7 = *(void *)(a2 + 304);
  do
  {
    uint64_t v8 = *v6++;
    if (*(_WORD *)(v8 + 864)) {
      char v5 = 1;
    }
    --v7;
  }
  while (v7);
  if (!v5) {
    return 0;
  }
  CFIndex v9 = (const void **)malloc_type_malloc(16 * v2, 0x10200400CC4F872uLL);
  if (!v9) {
    return 0;
  }
  CFDictionaryRef v10 = v9;
  int valuePtr = 0;
  uint64_t v11 = *(void *)(a2 + 304);
  if (v11 <= 0)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  }
  else
  {
    uint64_t v12 = 0;
    CFIndex v13 = 0;
    CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFAllocatorRef v15 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    do
    {
      int v16 = *(unsigned __int16 *)(*(void *)(*(void *)(a2 + 320) + 8 * v12) + 864);
      if (*(_WORD *)(*(void *)(*(void *)(a2 + 320) + 8 * v12) + 864))
      {
        if (v13 < 1)
        {
          CFIndex v17 = 0;
LABEL_17:
          ++v13;
          CFDictionaryRef v20 = (char *)&v10[2 * v17];
          *(_WORD *)CFDictionaryRef v20 = v16;
          *((void *)v20 + 1) = CFArrayCreateMutable(a1, 0, v15);
          uint64_t v11 = *(void *)(a2 + 304);
        }
        else
        {
          CFIndex v17 = 0;
          CFNumberRef v18 = v10;
          while (1)
          {
            int v19 = *(unsigned __int16 *)v18;
            v18 += 2;
            if (v19 == v16) {
              break;
            }
            if (v13 == ++v17)
            {
              CFIndex v17 = v13;
              goto LABEL_17;
            }
          }
        }
        if (v11 <= v12) {
          int v21 = 0;
        }
        else {
          int v21 = *(_DWORD *)(*(void *)(*(void *)(a2 + 320) + 8 * v12) + 144);
        }
        int valuePtr = v21;
        CFNumberRef v22 = CFNumberCreate(v14, kCFNumberSInt32Type, &valuePtr);
        CFArrayAppendValue((CFMutableArrayRef)v10[2 * v17 + 1], v22);
        CFRelease(v22);
        uint64_t v11 = *(void *)(a2 + 304);
      }
      ++v12;
    }
    while (v12 < v11);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, v13, MEMORY[0x1E4F1D510]);
    if (v13 >= 1)
    {
      CFDictionaryRef v24 = v10 + 1;
      do
      {
        CFArrayAppendValue(Mutable, *v24);
        uint64_t v25 = *v24;
        v24 += 2;
        CFRelease(v25);
        --v13;
      }
      while (v13);
    }
  }
  free(v10);
  return Mutable;
}

uint64_t MovieInformationSetByteStream(uint64_t a1, const void *a2)
{
  CFNumberRef number = 0;
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, void, CFNumberRef *))(v6 + 48);
  if (!v7) {
    return 4294954514;
  }
  uint64_t v8 = *MEMORY[0x1E4F1EC50];
  uint64_t v18 = 0;
  uint64_t result = v7(CMBaseObject, v8, 0, &number);
  if (!result)
  {
    CFNumberGetValue(number, kCFNumberSInt64Type, &v18);
    CFRelease(number);
    CFDictionaryRef v10 = *(const void **)(a1 + 48);
    *(void *)(a1 + 48) = a2;
    if (a2) {
      CFRetain(a2);
    }
    if (v10) {
      CFRelease(v10);
    }
    *(void *)(a1 + 72) = v18;
    CFNumberRef number = 0;
    uint64_t v11 = CMByteStreamGetCMBaseObject();
    uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v12) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    CFAllocatorRef v14 = *(uint64_t (**)(uint64_t, void, void, CFNumberRef *))(v13 + 48);
    if (v14)
    {
      int v15 = v14(v11, *MEMORY[0x1E4F1EC78], 0, &number);
      CFStringRef v16 = 0;
      CFNumberRef v17 = number;
      if (!v15 && number)
      {
        CFStringRef v16 = CFURLCopyPathExtension(number);
        *(unsigned char *)(a1 + 84) = FigCFStringIsISOExtension(v16);
        if (v16 && CFStringCompare(@"aax", v16, 1uLL) == kCFCompareEqualTo) {
          *(unsigned char *)(a1 + 152) = 1;
        }
        *(unsigned char *)(a1 + 208) = FigCFStringIsHEIFExtension(v16);
        CFNumberRef v17 = number;
      }
      if (v17) {
        CFRelease(v17);
      }
      if (v16) {
        CFRelease(v16);
      }
    }
    return 0;
  }
  return result;
}

uint64_t MovieInformationCheckForMovieTimescaleAnomaly_7135294(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 320);
  if (!v1) {
    return result;
  }
  uint64_t v2 = *(void *)(result + 304);
  if (v2 < 1) {
    return result;
  }
  uint64_t v3 = *v1;
  if (*(unsigned char *)(result + 81))
  {
    if (v2 != 1 || *(unsigned char *)(result + 82) != 0) {
      return result;
    }
  }
  else if (v2 != 1 || *(unsigned char *)(result + 84) == 0)
  {
    return result;
  }
  if (*(_DWORD *)(v3 + 24) == 1936684398 && !*(unsigned char *)(v3 + 722))
  {
    uint64_t v6 = *(void *)(v3 + 728);
    if ((!v6 || !*(void *)(v6 + 56)) && *(_DWORD *)(result + 240) == 600)
    {
      int v7 = *(_DWORD *)(v3 + 232);
      if (v7 != 600)
      {
        uint64_t v8 = *(void *)(v3 + 136);
        if (v8 == *(void *)(v3 + 224) && v8 == *(void *)(result + 232)) {
          *(_DWORD *)(result + 240) = v7;
        }
      }
    }
  }
  return result;
}

uint64_t MovieInformationSetParsedNextTrackID(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 252) = a2;
  return 0;
}

uint64_t MovieInformationSetParsedCreateAndModTimes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 216) = a2;
  *(void *)(a1 + 224) = a3;
  return 0;
}

uint64_t MovieInformationSetParsedMovieDuration(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)(a1 + 232) = a2;
  *(_DWORD *)(a1 + 240) = a3;
  return 0;
}

uint64_t MovieInformationSetMovieTimeScale(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 232)) {
    return FigSignalErrorAt();
  }
  *(_DWORD *)(a1 + 240) = a2;
  *(void *)(a1 + 40) |= 0x8000uLL;
  return 0;
}

uint64_t MovieInformationSetPreferredRate(uint64_t a1, float a2)
{
  *(float *)(a1 + 244) = a2;
  *(void *)(a1 + 40) |= 0x200uLL;
  return 0;
}

uint64_t MovieInformationSetPreferredVolume(uint64_t a1, float a2)
{
  *(float *)(a1 + 248) = a2;
  *(void *)(a1 + 40) |= 0x400uLL;
  return 0;
}

uint64_t MovieInformationSetMovieMatrix(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    long long v2 = *(_OWORD *)a2;
    long long v3 = *(_OWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 288) = *(_DWORD *)(a2 + 32);
  }
  else
  {
    *(_DWORD *)(a1 + 288) = 1065353216;
    long long v2 = kIdentityMatrix_0;
    long long v3 = unk_194998610;
  }
  *(_OWORD *)(a1 + 256) = v2;
  *(_OWORD *)(a1 + 272) = v3;
  *(void *)(a1 + 40) |= 0x800uLL;
  return 0;
}

uint64_t MovieInformationSetPSSHDataEntries(uint64_t a1, CFTypeRef cf)
{
  long long v3 = *(const void **)(a1 + 360);
  *(void *)(a1 + 360) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + 40) |= 0x20000uLL;
  return 0;
}

uint64_t MovieInformationAllTracksAreSelfContained(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (v1 < 1) {
    return 1;
  }
  uint64_t v3 = 0;
  do
  {
    if (*(void *)(a1 + 304) <= v3) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = *(void *)(*(void *)(a1 + 320) + 8 * v3);
    }
    uint64_t result = MovieTrackIsSelfContained(v4);
    ++v3;
  }
  while (v3 < v1 && result);
  return result;
}

uint64_t MovieInformationCreateTrack(uint64_t a1, int a2, int a3, _DWORD *a4, void *a5)
{
  CFTypeRef cf = 0;
  if (*(_DWORD *)(a1 + 252) <= a3) {
    int v9 = a3;
  }
  else {
    int v9 = *(_DWORD *)(a1 + 252);
  }
  *(_DWORD *)(a1 + 252) = v9 + 1;
  uint64_t v10 = MovieTrackCreate((uint64_t *)&cf);
  if (v10)
  {
    uint64_t v16 = v10;
    uint64_t v11 = cf;
    if (!cf) {
      return v16;
    }
    goto LABEL_17;
  }
  uint64_t v11 = cf;
  float v12 = 0.0;
  if (a2 == 1936684398) {
    float v12 = 1.0;
  }
  *((float *)cf + 49) = v12;
  v11[6] = a2;
  v11[36] = v9;
  uint64_t v13 = MovieInformationAddNewPerTrackInfo((void *)a1, v11);
  if (v13)
  {
    uint64_t v16 = v13;
LABEL_17:
    CFRelease(v11);
    return v16;
  }
  uint64_t v14 = *(void *)(a1 + 32);
  *(void *)(a1 + 40) |= 0x2002uLL;
  if (v14)
  {
    values = v11;
    CFDictionaryRef v15 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&kMovieInformationPayloadKey_TrackInfo, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CMNotificationCenterGetDefaultLocalCenter();
    FigDeferNotificationToDispatchQueue();
    if (v15) {
      CFRelease(v15);
    }
  }
  *a5 = v11;
  uint64_t v16 = 0;
  if (a4) {
    *a4 = v9;
  }
  return v16;
}

uint64_t MovieInformationRemoveTrack(uint64_t *a1, _DWORD *cf)
{
  uint64_t v2 = a1[38];
  uint64_t v3 = v2 - 1;
  if (v2 >= 1)
  {
    uint64_t v6 = (CFTypeRef *)a1[40];
    size_t v7 = 8 * v2 - 8;
    while (*v6 != cf)
    {
      v7 -= 8;
      ++v6;
      if (!--v2) {
        goto LABEL_5;
      }
    }
    if (v2 != 1)
    {
      memmove(v6, v6 + 1, v7);
      uint64_t v3 = a1[38] - 1;
    }
    a1[38] = v3;
    if (cf)
    {
      int v9 = cf[36];
    }
    else
    {
      uint64_t v27 = FigSignalErrorAt();
      if (v27)
      {
LABEL_40:
        CFRelease(cf);
        return v27;
      }
      int v9 = 0;
    }
    uint64_t v10 = 132;
    if (!*((_WORD *)cf + 432)) {
      uint64_t v10 = 4;
    }
    if (*((unsigned char *)cf + 200)) {
      uint64_t v11 = v10 | 0x2000;
    }
    else {
      uint64_t v11 = v10;
    }
    uint64_t v12 = a1[41];
    if (v12 >= 1)
    {
      for (uint64_t i = 0; i < v12; ++i)
      {
        uint64_t v14 = a1[43];
        uint64_t v15 = v14 + 12 * i;
        int v16 = *(_DWORD *)(v15 + 4);
        int v17 = *(_DWORD *)(v15 + 8);
        if (v16 != v9)
        {
          BOOL v18 = v17 == v9;
          int v17 = v9;
          if (!v18) {
            continue;
          }
        }
        NoteTrackReferenceChange(a1, *(_DWORD *)(v14 + 12 * i), v16, v17);
        uint64_t v19 = a1[41];
        if (v19 + ~i)
        {
          memmove((void *)(a1[43] + 12 * i), (const void *)(a1[43] + 12 * i + 12), 12 * (v19 + ~i));
          uint64_t v19 = a1[41];
        }
        uint64_t v12 = v19 - 1;
        a1[41] = v12;
        --i;
      }
    }
    uint64_t v20 = a1[38];
    if (v20 < 1)
    {
      uint64_t v21 = 0;
    }
    else
    {
      uint64_t v21 = 0;
      CFNumberRef v22 = (uint64_t *)a1[40];
      do
      {
        uint64_t v23 = *v22++;
        uint64_t v24 = *(void *)(v23 + 136);
        if (v24 > v21) {
          uint64_t v21 = v24;
        }
        --v20;
      }
      while (v20);
    }
    if (a1[29] == v21)
    {
      uint64_t v25 = a1[5];
    }
    else
    {
      a1[29] = v21;
      uint64_t v25 = a1[5] | 1;
    }
    *((unsigned char *)cf + 896) = 1;
    a1[5] = v25 | v11;
    if (a1[4])
    {
      values = cf;
      CFDictionaryRef v26 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&kMovieInformationPayloadKey_TrackInfo, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CMNotificationCenterGetDefaultLocalCenter();
      FigDeferNotificationToDispatchQueue();
      if (v26) {
        CFRelease(v26);
      }
    }
    uint64_t v27 = 0;
    goto LABEL_40;
  }
LABEL_5:

  return FigSignalErrorAt();
}

uint64_t MovieSampleTableGetSampleCountAtIndex(uint64_t a1, int a2)
{
  uint64_t destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 416), 8 * a2, 8uLL, &destination);
  return bswap32(destination);
}

uint64_t MovieSampleTableGetSampleToChunkFirstChunk(uint64_t a1, int a2)
{
  int v4 = 0;
  uint64_t v3 = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 440), 12 * a2, 0xCuLL, &v3);
  return bswap32(v3);
}

uint64_t MovieSampleTableGetSampleToChunkSamplesPerChunk(uint64_t a1, int a2)
{
  int v4 = 0;
  uint64_t v3 = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 440), 12 * a2, 0xCuLL, &v3);
  return bswap32(HIDWORD(v3));
}

uint64_t MovieSampleTableGetSampleToChunkSampleDescriptionID(uint64_t a1, int a2)
{
  unsigned int v4 = 0;
  uint64_t v3 = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 440), 12 * a2, 0xCuLL, &v3);
  return bswap32(v4);
}

uint64_t MovieSampleTableNumSampleToChunkEntries(uint64_t a1)
{
  return *(unsigned int *)(a1 + 432);
}

uint64_t MovieSampleTableNumChunkTableEntries(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 624))();
}

BOOL MovieSampleTableHaveChunkOffsetTable(uint64_t a1)
{
  return *(void *)(a1 + 368) || *(void *)(a1 + 392) != 0;
}

BOOL MovieSampleTableHave64BitChunkOffsetTable(uint64_t a1)
{
  return *(void *)(a1 + 392) != 0;
}

uint64_t MovieSampleTableNumSampleSizeEntries(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 584))();
}

uint64_t MovieSampleTableGetMinSampleSizeFieldSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 296);
}

uint64_t MovieSampleTableGetSampleSizeTable(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 608))();
}

BOOL MovieSampleTableHaveSampleToChunkTable(uint64_t a1)
{
  return *(void *)(a1 + 440) != 0;
}

BOOL MovieSampleTableHavePartialSyncSampleTable(uint64_t a1)
{
  return *(void *)(a1 + 512) != 0;
}

uint64_t MovieSampleTableNumSampleDependencyEntries(uint64_t a1)
{
  return *(unsigned int *)(a1 + 528);
}

uint64_t MovieSampleTableGetMaxDecodeToDisplay(uint64_t a1)
{
  return bswap32(*(_DWORD *)(a1 + 564));
}

uint64_t MovieSampleTableGetMinDecodeToDisplay(uint64_t a1)
{
  return bswap32(*(_DWORD *)(a1 + 560));
}

uint64_t MovieSampleTableGetSampleToChunkTable(uint64_t a1)
{
  return *(void *)(a1 + 440);
}

uint64_t MovieSampleTableGetTimeToSampleTable(uint64_t a1)
{
  return *(void *)(a1 + 416);
}

uint64_t MovieSampleTableGetChunkOffsetTable(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 632))();
}

uint64_t MovieSampleTableGetCompositionOffsetTable(uint64_t a1)
{
  return *(void *)(a1 + 464);
}

uint64_t MovieSampleTableGetSyncSampleTable(uint64_t a1)
{
  return *(void *)(a1 + 488);
}

uint64_t MovieSampleTableGetPartialSyncSampleTable(uint64_t a1)
{
  return *(void *)(a1 + 512);
}

uint64_t MovieSampleTableGetSampleDependencyTable(uint64_t a1)
{
  return *(void *)(a1 + 536);
}

uint64_t MovieSampleTableSet_stsz(uint64_t a1, int a2, int a3, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 312) = a2;
  *(_DWORD *)(a1 + 316) = a3;
  size_t v7 = *(const void **)(a1 + 320);
  *(void *)(a1 + 320) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(a1 + 584) = GetNumSamples_stsz;
  *(void *)(a1 + 600) = GetSampleSizeFieldSize_stsz;
  *(void *)(a1 + 608) = GetSizeTable_stsz;
  *(void *)(a1 + 592) = GetSampleSize_stsz;
  *(_DWORD *)(a1 + 292) = a3;
  *(_DWORD *)(a1 + 288) = a2;
  return 0;
}

uint64_t GetNumSamples_stsz(uint64_t a1)
{
  return *(unsigned int *)(a1 + 312);
}

uint64_t GetSampleSizeFieldSize_stsz()
{
  return 32;
}

uint64_t GetSizeTable_stsz(uint64_t a1)
{
  return *(void *)(a1 + 320);
}

uint64_t GetSampleSize_stsz(uint64_t a1, int a2)
{
  uint64_t result = *(unsigned int *)(a1 + 316);
  unsigned int destination = result;
  if (!result)
  {
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 320), 4 * a2, 4uLL, &destination);
    return bswap32(destination);
  }
  return result;
}

uint64_t MovieSampleTableSet_stz2(uint64_t a1, int a2, int a3, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 288) = a2;
  *(_DWORD *)(a1 + 340) = a2;
  *(_DWORD *)(a1 + 336) = a3;
  uint64_t v6 = *(const void **)(a1 + 344);
  *(void *)(a1 + 344) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(a1 + 584) = GetNumSamples_stz2;
  *(void *)(a1 + 600) = GetSampleSizeFieldSize_stz2;
  *(void *)(a1 + 608) = GetSizeTable_stz2;
  switch(a3)
  {
    case 16:
      size_t v7 = GetSampleSize_stz2_16;
      goto LABEL_11;
    case 8:
      size_t v7 = GetSampleSize_stz2_8;
      goto LABEL_11;
    case 4:
      size_t v7 = GetSampleSize_stz2_4;
LABEL_11:
      *(void *)(a1 + 592) = v7;
      return 0;
  }
  MovieInformationReportParsingFailureMessage(0, a1, (uint64_t)"Unexpected stz2 field size", 2);

  return FigSignalErrorAt();
}

uint64_t GetNumSamples_stz2(uint64_t a1)
{
  return *(unsigned int *)(a1 + 340);
}

uint64_t GetSampleSizeFieldSize_stz2(uint64_t a1)
{
  return *(unsigned int *)(a1 + 336);
}

uint64_t GetSizeTable_stz2(uint64_t a1)
{
  return *(void *)(a1 + 344);
}

uint64_t GetSampleSize_stz2_4(uint64_t a1, int a2)
{
  char v2 = a2;
  if (a2 >= 0) {
    int v3 = a2;
  }
  else {
    int v3 = a2 + 1;
  }
  unsigned __int8 destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 344), (uint64_t)v3 >> 1, 1uLL, &destination);
  if (v2) {
    return destination & 0xF;
  }
  else {
    return destination >> 4;
  }
}

uint64_t GetSampleSize_stz2_8(uint64_t a1, int a2)
{
  unsigned __int8 destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 344), a2, 1uLL, &destination);
  return destination;
}

uint64_t GetSampleSize_stz2_16(uint64_t a1, int a2)
{
  unsigned __int16 destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 344), 2 * a2, 2uLL, &destination);
  return bswap32(destination) >> 16;
}

uint64_t MovieSampleTableSet_stco(uint64_t a1, int a2, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 360) = a2;
  unsigned int v4 = *(const void **)(a1 + 368);
  *(void *)(a1 + 368) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 616) = GetChunkOffset_stco;
  *(void *)(a1 + 624) = GetChunkCount_stco;
  *(void *)(a1 + 632) = GetChunkTable_stco;
  return 0;
}

uint64_t GetChunkOffset_stco(uint64_t a1, int a2)
{
  unsigned int destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 368), 4 * a2, 4uLL, &destination);
  return bswap32(destination);
}

uint64_t GetChunkCount_stco(uint64_t a1)
{
  return *(unsigned int *)(a1 + 360);
}

uint64_t GetChunkTable_stco(uint64_t a1)
{
  return *(void *)(a1 + 368);
}

uint64_t MovieSampleTableSet_co64(uint64_t a1, int a2, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 384) = a2;
  unsigned int v4 = *(const void **)(a1 + 392);
  *(void *)(a1 + 392) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 616) = GetChunkOffset_co64;
  *(void *)(a1 + 624) = GetChunkCount_co64;
  *(void *)(a1 + 632) = GetChunkTable_co64;
  return 0;
}

unint64_t GetChunkOffset_co64(uint64_t a1, int a2)
{
  unint64_t destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 392), 8 * a2, 8uLL, &destination);
  return bswap64(destination);
}

uint64_t GetChunkCount_co64(uint64_t a1)
{
  return *(unsigned int *)(a1 + 384);
}

uint64_t GetChunkTable_co64(uint64_t a1)
{
  return *(void *)(a1 + 392);
}

uint64_t MovieSampleTableSet_stts(uint64_t a1, int a2, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 408) = a2;
  int v3 = *(const void **)(a1 + 416);
  *(void *)(a1 + 416) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v3) {
    CFRelease(v3);
  }
  return 0;
}

uint64_t MovieSampleTableSet_stsc(uint64_t a1, int a2, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 432) = a2;
  int v3 = *(const void **)(a1 + 440);
  *(void *)(a1 + 440) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v3) {
    CFRelease(v3);
  }
  return 0;
}

uint64_t MovieSampleTableSet_ctts(uint64_t a1, int a2, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 456) = a2;
  uint64_t v5 = *(const void **)(a1 + 464);
  *(void *)(a1 + 464) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v5) {
    CFRelease(v5);
  }
  *(unsigned char *)(a1 + 720) = a2 > 0;
  return 0;
}

uint64_t MovieSampleTableSet_stss(uint64_t a1, int a2, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 480) = a2;
  int v3 = *(const void **)(a1 + 488);
  *(void *)(a1 + 488) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v3) {
    CFRelease(v3);
  }
  return 0;
}

uint64_t MovieSampleTableSet_stps(uint64_t a1, int a2, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 504) = a2;
  int v3 = *(const void **)(a1 + 512);
  *(void *)(a1 + 512) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v3) {
    CFRelease(v3);
  }
  return 0;
}

uint64_t MovieSampleTableSet_sdtp(uint64_t a1, int a2, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 528) = a2;
  int v3 = *(const void **)(a1 + 536);
  *(void *)(a1 + 536) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v3) {
    CFRelease(v3);
  }
  return 0;
}

uint64_t MovieSampleTableSet_cslg(uint64_t a1, CMBlockBufferRef theSourceBuffer)
{
  if (!theSourceBuffer) {
    return 0;
  }
  uint64_t result = CMBlockBufferCopyDataBytes(theSourceBuffer, 0, 0x18uLL, (void *)(a1 + 552));
  if (!result) {
    *(unsigned char *)(a1 + 576) = 1;
  }
  return result;
}

uint64_t MovieInformationLockForRead(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return FigReadWriteLockLockForRead();
  }
  return result;
}

uint64_t MovieInformationUnlockForRead(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return FigReadWriteLockUnlockForRead();
  }
  return result;
}

uint64_t MovieInformationLockForWrite(uint64_t a1)
{
  if (*(void *)(a1 + 24)) {
    return FigReadWriteLockLockForWrite();
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t MovieInformationUnlockForWrite(void *a1)
{
  if (a1[3])
  {
    if (a1[4])
    {
      uint64_t v2 = a1[38];
      if (v2 >= 1)
      {
        uint64_t v3 = 0;
        CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
        uint64_t v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
        do
        {
          if (a1[38] <= v3) {
            uint64_t v7 = 0;
          }
          else {
            uint64_t v7 = *(void *)(a1[40] + 8 * v3);
          }
          if (*(unsigned char *)(v7 + 898) && (a1[5] & 1) != 0) {
            *(void *)(v7 + 16) |= 0x200000uLL;
          }
          uint64_t v8 = *(void *)(v7 + 16);
          if ((v8 & 0x1000) != 0)
          {
            a1[5] |= 0x80uLL;
            if ((v8 & 0x400000) == 0)
            {
LABEL_13:
              if ((v8 & 0x800000) == 0) {
                goto LABEL_14;
              }
              goto LABEL_21;
            }
          }
          else if ((v8 & 0x400000) == 0)
          {
            goto LABEL_13;
          }
          a1[5] |= 0x80uLL;
          if ((v8 & 0x800000) == 0)
          {
LABEL_14:
            if ((v8 & 4) == 0) {
              goto LABEL_15;
            }
            goto LABEL_22;
          }
LABEL_21:
          a1[5] |= 0x80uLL;
          if ((v8 & 4) == 0)
          {
LABEL_15:
            if ((v8 & 0x40) == 0) {
              goto LABEL_16;
            }
            goto LABEL_23;
          }
LABEL_22:
          a1[5] |= 0x1000uLL;
          if ((v8 & 0x40) == 0)
          {
LABEL_16:
            if ((v8 & 0x200000) != 0) {
              goto LABEL_24;
            }
            goto LABEL_17;
          }
LABEL_23:
          a1[5] |= 0x2000uLL;
          if ((v8 & 0x200000) != 0)
          {
LABEL_24:
            a1[5] |= 0x4000uLL;
LABEL_25:
            values = CFNumberCreate(v4, kCFNumberSInt64Type, (const void *)(v7 + 16));
            if (values) {
              CFDictionaryRef v9 = CFDictionaryCreate(v4, (const void **)&kMovieInformationPayloadKey_ChangeBits, (const void **)&values, 1, v5, v6);
            }
            else {
              CFDictionaryRef v9 = 0;
            }
            CMNotificationCenterGetDefaultLocalCenter();
            FigDeferNotificationToDispatchQueue();
            if (v9) {
              CFRelease(v9);
            }
            if (values) {
              CFRelease(values);
            }
            goto LABEL_32;
          }
LABEL_17:
          if (v8) {
            goto LABEL_25;
          }
LABEL_32:
          ++v3;
        }
        while (v2 != v3);
      }
      if (a1[5])
      {
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, a1 + 5);
        if (values) {
          CFDictionaryRef v11 = CFDictionaryCreate(v10, (const void **)&kMovieInformationPayloadKey_ChangeBits, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        }
        else {
          CFDictionaryRef v11 = 0;
        }
        CMNotificationCenterGetDefaultLocalCenter();
        FigDeferNotificationToDispatchQueue();
        if (v11) {
          CFRelease(v11);
        }
        if (values) {
          CFRelease(values);
        }
      }
      a1[5] = 0;
      uint64_t v12 = a1[38];
      if (v12 >= 1)
      {
        uint64_t v13 = (uint64_t *)a1[40];
        do
        {
          uint64_t v14 = *v13++;
          *(void *)(v14 + 16) = 0;
          --v12;
        }
        while (v12);
      }
    }
    uint64_t v15 = FigReadWriteLockUnlockForWrite();
    int v16 = a1[4];
    if (v16) {
      dispatch_sync_f(v16, 0, (dispatch_function_t)WaitingNoOp);
    }
    return v15;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

BOOL MovieInformationIsMutable(uint64_t a1)
{
  return *(void *)(a1 + 24) != 0;
}

uint64_t MovieInformationContainsFragments(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 156);
}

uint64_t MovieInformationCouldContainFragments(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 154);
}

uint64_t MovieInformationGetLastMovieFragmentInformation(uint64_t a1, _DWORD *a2)
{
  if (!*(_DWORD *)(a1 + 184)) {
    return 0;
  }
  if (a2) {
    *a2 = *(_DWORD *)(a1 + 188);
  }
  return 1;
}

__n128 MovieInformationGetMovieExtendsDuration@<Q0>(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = MEMORY[0x1E4F1F9F8];
  __n128 result = *(__n128 *)MEMORY[0x1E4F1F9F8];
  *(_OWORD *)a2 = *MEMORY[0x1E4F1F9F8];
  *(void *)(a2 + 16) = *(void *)(v2 + 16);
  if (a1[9].n128_u8[11])
  {
    __n128 result = a1[10];
    *(__n128 *)a2 = result;
    *(void *)(a2 + 16) = a1[11].n128_u64[0];
  }
  return result;
}

uint64_t MovieInformationEstablishFirstParsedFragmentSequenceNumber(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 184) = 1;
  *(_DWORD *)(a1 + 188) = a2;
  *(_DWORD *)(a1 + 192) = a2;
  *(void *)(a1 + 40) |= 0x10000uLL;
  return 0;
}

uint64_t MovieInformationUpdateLastParsedFragmentSequenceNumber(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 188) = a2;
  *(void *)(a1 + 40) |= 0x10000uLL;
  return 0;
}

uint64_t MovieInformationGetFirstFragmentSequenceNumber(uint64_t a1, _DWORD *a2)
{
  if (*(_DWORD *)(a1 + 184) != 1) {
    return 0;
  }
  *a2 = *(_DWORD *)(a1 + 192);
  return 1;
}

uint64_t MovieInformationGetParsedFragmentCount(_DWORD *a1, _DWORD *a2)
{
  if (a1[46] != 1) {
    return 0;
  }
  *a2 = a1[47] - a1[48] + 1;
  return 1;
}

uint64_t MovieInformationEnsureMutationsWillNotify(uint64_t a1)
{
  if (*(void *)(a1 + 32)) {
    return 0;
  }
  dispatch_queue_t v2 = dispatch_queue_create("MovieInformationNotifications", 0);
  *(void *)(a1 + 32) = v2;
  if (v2)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterRegisterForBarrierSupport();
    return 0;
  }

  return FigSignalErrorAt();
}

uint64_t MovieInformationCreate(uint64_t a1, int a2, uint64_t *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (sRegisterMovieInformationTypeOnce != -1) {
    dispatch_once_f(&sRegisterMovieInformationTypeOnce, 0, (dispatch_function_t)RegisterMovieInformationType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v7 = Instance;
    if ((a2 & 1) != 0
      && (*(void *)(Instance + 24) = FigReadWriteLockCreate(), (a2 & 2) != 0)
      && (uint64_t v8 = MovieInformationEnsureMutationsWillNotify(v7), v8))
    {
      uint64_t v16 = v8;
      CFRelease((CFTypeRef)v7);
      return v16;
    }
    else
    {
      uint64_t result = 0;
      unint64_t v10 = (unint64_t)(Current + *MEMORY[0x1E4F1CF68]);
      *(_DWORD *)(v7 + 16) = a2;
      *(_DWORD *)(v7 + 252) = 1;
      *(_DWORD *)(v7 + 240) = 600;
      *(_DWORD *)(v7 + 288) = 1065353216;
      *(_OWORD *)(v7 + 256) = kIdentityMatrix_0;
      *(_OWORD *)(v7 + 272) = unk_194998610;
      __asm { FMOV            V0.2S, #1.0 }
      *(void *)(v7 + 244) = _D0;
      *(void *)(v7 + 216) = v10;
      *(void *)(v7 + 224) = v10;
      *a3 = v7;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t MovieInformationCreateDeepCopy(const __CFAllocator *a1, uint64_t a2, char a3, void *a4)
{
  uint64_t v6 = a2;
  CFTypeRef v97 = 0;
  if (*(void *)(a2 + 24))
  {
    uint64_t v8 = FigReadWriteLockLockForRead();
    if (v8)
    {
      uint64_t v58 = v8;
      goto LABEL_149;
    }
  }
  uint64_t v9 = MovieInformationCreate((uint64_t)a1, a3 & 3, (uint64_t *)&v97);
  unint64_t v10 = v97;
  if (v9) {
    goto LABEL_152;
  }
  CFDictionaryRef v11 = *(const void **)(v6 + 48);
  if (v11)
  {
    uint64_t v9 = MovieInformationSetByteStream((uint64_t)v97, v11);
    if (v9) {
      goto LABEL_152;
    }
  }
  *(_OWORD *)(v10 + 27) = *(_OWORD *)(v6 + 216);
  long long v12 = *(_OWORD *)(v6 + 232);
  long long v13 = *(_OWORD *)(v6 + 248);
  long long v14 = *(_OWORD *)(v6 + 280);
  *(_OWORD *)(v10 + 33) = *(_OWORD *)(v6 + 264);
  *(_OWORD *)(v10 + 35) = v14;
  *(_OWORD *)(v10 + 31) = v13;
  *(_OWORD *)(v10 + 29) = v12;
  CMBlockBufferRef blockBufferOut = 0;
  CFTypeRef cf = 0;
  uint64_t v95 = *(void *)(v6 + 304);
  if (v95 < 1)
  {
    uint64_t v58 = 0;
    goto LABEL_139;
  }
  long long v93 = a4;
  uint64_t v15 = 0;
  uint64_t v16 = *(void *)(v6 + 24);
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v94 = v6;
  while (1)
  {
    if (*(void *)(v6 + 304) <= v15) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = *(void *)(*(void *)(v6 + 320) + 8 * v15);
    }
    uint64_t v18 = MovieTrackCreate((uint64_t *)&cf);
    if (v18)
    {
      uint64_t v58 = v18;
      goto LABEL_138;
    }
    uint64_t v19 = (char *)cf;
    *((_DWORD *)cf + 6) = *(_DWORD *)(v17 + 24);
    if (*(void *)(v17 + 40))
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
      *((void *)v19 + 5) = Mutable;
      if (!Mutable) {
        goto LABEL_135;
      }
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v17 + 40));
      if (Count >= 1)
      {
        CFIndex v22 = Count;
        CFIndex v23 = 0;
        do
        {
          CFDataRef ValueAtIndex = (OpaqueCMBlockBuffer *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v17 + 40), v23);
          uint64_t v25 = CMBlockBufferCreateContiguous(a1, ValueAtIndex, a1, 0, 0, 0, 2u, &blockBufferOut);
          if (v25) {
            goto LABEL_136;
          }
          CFArrayAppendValue(*((CFMutableArrayRef *)v19 + 5), blockBufferOut);
          if (blockBufferOut)
          {
            CFRelease(blockBufferOut);
            CMBlockBufferRef blockBufferOut = 0;
          }
        }
        while (v22 != ++v23);
      }
    }
    if (*(void *)(v17 + 56))
    {
      CFMutableArrayRef v26 = CFArrayCreateMutable(allocator, 0, 0);
      *((void *)v19 + 7) = v26;
      if (!v26) {
        goto LABEL_135;
      }
      CFIndex v27 = CFArrayGetCount(*(CFArrayRef *)(v17 + 56));
      if (v27 >= 1)
      {
        CFIndex v28 = v27;
        CFIndex v29 = 0;
        while (1)
        {
          uint64_t v30 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v17 + 56), v29);
          long long v31 = malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
          if (!v31) {
            break;
          }
          _OWORD *v31 = *v30;
          CFArrayAppendValue(*((CFMutableArrayRef *)v19 + 7), v31);
          if (v28 == ++v29) {
            goto LABEL_26;
          }
        }
LABEL_135:
        uint64_t v25 = FigSignalErrorAt();
        goto LABEL_136;
      }
    }
LABEL_26:
    CFArrayRef v32 = *(const __CFArray **)(v17 + 48);
    if (v32)
    {
      CFIndex v33 = CFArrayGetCount(v32);
      MutableCFArrayRef Copy = CFArrayCreateMutableCopy(a1, v33, *(CFArrayRef *)(v17 + 48));
      *((void *)v19 + 6) = MutableCopy;
      if (!MutableCopy) {
        goto LABEL_135;
      }
    }
    if (*(void *)(v17 + 64))
    {
      CFMutableArrayRef v35 = CFArrayCreateMutable(allocator, 0, 0);
      *((void *)v19 + 8) = v35;
      if (!v35) {
        goto LABEL_135;
      }
      CFIndex v36 = CFArrayGetCount(*(CFArrayRef *)(v17 + 64));
      if (v36 >= 1)
      {
        CFIndex v37 = v36;
        CFIndex v38 = 0;
        while (1)
        {
          uint64_t v39 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v17 + 64), v38);
          CMTime v40 = (OpaqueCMBlockBuffer *)*((void *)v39 + 1);
          if (v40)
          {
            uint64_t v25 = CMBlockBufferCreateContiguous(a1, v40, a1, 0, 0, 0, 2u, &blockBufferOut);
            if (v25) {
              break;
            }
          }
          uint64_t v41 = malloc_type_calloc(1uLL, 0x18uLL, 0x1060040ABACF81FuLL);
          if (!v41) {
            goto LABEL_135;
          }
          long long v42 = v41;
          *uint64_t v41 = *(_DWORD *)v39;
          CFTypeRef v43 = (CFTypeRef)*((void *)v39 + 2);
          if (v43) {
            CFTypeRef v43 = CFRetain(v43);
          }
          v42[1] = blockBufferOut;
          v42[2] = v43;
          CMBlockBufferRef blockBufferOut = 0;
          CFArrayAppendValue(*((CFMutableArrayRef *)v19 + 8), v42);
          if (v37 == ++v38) {
            goto LABEL_38;
          }
        }
LABEL_136:
        uint64_t v58 = v25;
LABEL_137:
        uint64_t v6 = v94;
        goto LABEL_138;
      }
    }
LABEL_38:
    CMBlockBufferRef v100 = 0;
    if (MovieSampleGroupCollectionGetCount(*(void *)(v17 + 72)))
    {
      CFAllocatorRef v44 = CFGetAllocator(v19);
      uint64_t v45 = MovieSampleGroupCollectionCreate(v44, (uint64_t *)&v100);
      if (v45)
      {
        uint64_t v58 = v45;
        if (v100) {
          CFRelease(v100);
        }
        goto LABEL_137;
      }
      MovieSampleGroupCollectionApplyFunction(*(void *)(v17 + 72), (uint64_t)SampleGroupDeepCopyApplier, (uint64_t)v100);
      *((void *)v19 + 9) = v100;
    }
    *((void *)v19 + 14) = *(void *)(v17 + 112);
    long long v46 = *(_OWORD *)(v17 + 120);
    *(_OWORD *)(v19 + 136) = *(_OWORD *)(v17 + 136);
    *(_OWORD *)(v19 + 120) = v46;
    long long v47 = *(_OWORD *)(v17 + 152);
    long long v48 = *(_OWORD *)(v17 + 168);
    long long v49 = *(_OWORD *)(v17 + 184);
    *((void *)v19 + 25) = *(void *)(v17 + 200);
    *(_OWORD *)(v19 + 184) = v49;
    *(_OWORD *)(v19 + 168) = v48;
    *(_OWORD *)(v19 + 152) = v47;
    long long v50 = *(_OWORD *)(v17 + 224);
    *((_OWORD *)v19 + 13) = *(_OWORD *)(v17 + 208);
    *((_OWORD *)v19 + 14) = v50;
    v19[240] = *(unsigned char *)(v17 + 240);
    *(void *)(v19 + 244) = *(void *)(v17 + 244);
    uint64_t v51 = *(void *)(v17 + 252);
    *((_DWORD *)v19 + 65) = *(_DWORD *)(v17 + 260);
    *(void *)(v19 + 252) = v51;
    uint64_t v52 = *(void *)(v17 + 264);
    *((_DWORD *)v19 + 68) = *(_DWORD *)(v17 + 272);
    *((void *)v19 + 33) = v52;
    uint64_t v53 = *(void *)(v17 + 276);
    *((_DWORD *)v19 + 71) = *(_DWORD *)(v17 + 284);
    *(void *)(v19 + 276) = v53;
    *((void *)v19 + 36) = *(void *)(v17 + 288);
    *(_OWORD *)(v19 + 88) = *(_OWORD *)(v17 + 88);
    *((void *)v19 + 13) = *(void *)(v17 + 104);
    *((_DWORD *)v19 + 74) = *(_DWORD *)(v17 + 296);
    *((void *)v19 + 38) = *(void *)(v17 + 304);
    *((_WORD *)v19 + 432) = *(_WORD *)(v17 + 864);
    CMBlockBufferRef v100 = 0;
    *((void *)v19 + 73) = GetNumSamples_stsz;
    *((void *)v19 + 74) = GetSampleSize_stsz;
    *((void *)v19 + 75) = GetSampleSizeFieldSize_stsz;
    *((void *)v19 + 76) = GetSizeTable_stsz;
    *((void *)v19 + 77) = GetChunkOffset_stco;
    *((void *)v19 + 78) = GetChunkCount_stco;
    *((void *)v19 + 79) = GetChunkTable_stco;
    int v54 = *(_DWORD *)(v17 + 312);
    if (v54)
    {
      CMTime v55 = *(OpaqueCMBlockBuffer **)(v17 + 320);
      if (v55)
      {
        if (v16) {
          uint64_t v56 = CMBlockBufferCreateContiguous(a1, v55, a1, 0, 0, 0, 2u, &v100);
        }
        else {
          uint64_t v56 = CMBlockBufferCreateWithBufferReference(a1, v55, 0, 0, 0, &v100);
        }
        uint64_t v58 = v56;
        CMBlockBufferRef v57 = v100;
        if (v56) {
          goto LABEL_159;
        }
        int v54 = *(_DWORD *)(v17 + 312);
      }
      else
      {
        CMBlockBufferRef v57 = 0;
      }
      MovieSampleTableSet_stsz((uint64_t)v19, v54, *(_DWORD *)(v17 + 316), v57);
      if (v100)
      {
        CFRelease(v100);
        CMBlockBufferRef v100 = 0;
      }
    }
    uint64_t v59 = *(OpaqueCMBlockBuffer **)(v17 + 344);
    if (v59) {
      break;
    }
LABEL_59:
    uint64_t v62 = *(OpaqueCMBlockBuffer **)(v17 + 368);
    if (v62)
    {
      if (v16) {
        uint64_t v63 = CMBlockBufferCreateContiguous(a1, v62, a1, 0, 0, 0, 2u, &v100);
      }
      else {
        uint64_t v63 = CMBlockBufferCreateWithBufferReference(a1, v62, 0, 0, 0, &v100);
      }
      uint64_t v58 = v63;
      CMBlockBufferRef v57 = v100;
      if (v63) {
        goto LABEL_159;
      }
      MovieSampleTableSet_stco((uint64_t)v19, *(_DWORD *)(v17 + 360), v100);
      if (v100)
      {
        CFRelease(v100);
        CMBlockBufferRef v100 = 0;
      }
    }
    CMTime v64 = *(OpaqueCMBlockBuffer **)(v17 + 392);
    if (v64)
    {
      if (v16) {
        uint64_t v65 = CMBlockBufferCreateContiguous(a1, v64, a1, 0, 0, 0, 2u, &v100);
      }
      else {
        uint64_t v65 = CMBlockBufferCreateWithBufferReference(a1, v64, 0, 0, 0, &v100);
      }
      uint64_t v58 = v65;
      CMBlockBufferRef v57 = v100;
      if (v65) {
        goto LABEL_159;
      }
      MovieSampleTableSet_co64((uint64_t)v19, *(_DWORD *)(v17 + 384), v100);
      if (v100)
      {
        CFRelease(v100);
        CMBlockBufferRef v100 = 0;
      }
    }
    CMTime v66 = *(OpaqueCMBlockBuffer **)(v17 + 416);
    if (v66)
    {
      if (v16) {
        uint64_t v67 = CMBlockBufferCreateContiguous(a1, v66, a1, 0, 0, 0, 2u, &v100);
      }
      else {
        uint64_t v67 = CMBlockBufferCreateWithBufferReference(a1, v66, 0, 0, 0, &v100);
      }
      uint64_t v58 = v67;
      CMBlockBufferRef v57 = v100;
      if (v67) {
        goto LABEL_159;
      }
      MovieSampleTableSet_stts((uint64_t)v19, *(_DWORD *)(v17 + 408), v100);
      if (v100)
      {
        CFRelease(v100);
        CMBlockBufferRef v100 = 0;
      }
    }
    uint64_t v68 = *(OpaqueCMBlockBuffer **)(v17 + 440);
    if (v68)
    {
      if (v16) {
        uint64_t v69 = CMBlockBufferCreateContiguous(a1, v68, a1, 0, 0, 0, 2u, &v100);
      }
      else {
        uint64_t v69 = CMBlockBufferCreateWithBufferReference(a1, v68, 0, 0, 0, &v100);
      }
      uint64_t v58 = v69;
      CMBlockBufferRef v57 = v100;
      if (v69) {
        goto LABEL_159;
      }
      MovieSampleTableSet_stsc((uint64_t)v19, *(_DWORD *)(v17 + 432), v100);
      if (v100)
      {
        CFRelease(v100);
        CMBlockBufferRef v100 = 0;
      }
    }
    long long v70 = *(OpaqueCMBlockBuffer **)(v17 + 464);
    if (v70)
    {
      if (v16) {
        uint64_t v71 = CMBlockBufferCreateContiguous(a1, v70, a1, 0, 0, 0, 2u, &v100);
      }
      else {
        uint64_t v71 = CMBlockBufferCreateWithBufferReference(a1, v70, 0, 0, 0, &v100);
      }
      uint64_t v58 = v71;
      CMBlockBufferRef v57 = v100;
      if (v71) {
        goto LABEL_159;
      }
      MovieSampleTableSet_ctts((uint64_t)v19, *(_DWORD *)(v17 + 456), v100);
      if (v100)
      {
        CFRelease(v100);
        CMBlockBufferRef v100 = 0;
      }
    }
    CMTime v72 = *(OpaqueCMBlockBuffer **)(v17 + 488);
    if (v72)
    {
      if (v16)
      {
        if (CMBlockBufferIsEmpty(*(CMBlockBufferRef *)(v17 + 488))) {
          uint64_t v73 = CMBlockBufferCreateEmpty(a1, 0, 0, &v100);
        }
        else {
          uint64_t v73 = CMBlockBufferCreateContiguous(a1, *(CMBlockBufferRef *)(v17 + 488), a1, 0, 0, 0, 2u, &v100);
        }
      }
      else
      {
        uint64_t v73 = CMBlockBufferCreateWithBufferReference(a1, v72, 0, 0, 0, &v100);
      }
      uint64_t v58 = v73;
      CMBlockBufferRef v57 = v100;
      if (v73) {
        goto LABEL_159;
      }
      MovieSampleTableSet_stss((uint64_t)v19, *(_DWORD *)(v17 + 480), v100);
      if (v100)
      {
        CFRelease(v100);
        CMBlockBufferRef v100 = 0;
      }
    }
    uint64_t v74 = *(OpaqueCMBlockBuffer **)(v17 + 512);
    if (v74)
    {
      if (v16)
      {
        if (CMBlockBufferIsEmpty(*(CMBlockBufferRef *)(v17 + 512))) {
          uint64_t v75 = CMBlockBufferCreateEmpty(a1, 0, 0, &v100);
        }
        else {
          uint64_t v75 = CMBlockBufferCreateContiguous(a1, *(CMBlockBufferRef *)(v17 + 512), a1, 0, 0, 0, 2u, &v100);
        }
      }
      else
      {
        uint64_t v75 = CMBlockBufferCreateWithBufferReference(a1, v74, 0, 0, 0, &v100);
      }
      uint64_t v58 = v75;
      CMBlockBufferRef v57 = v100;
      if (v75) {
        goto LABEL_159;
      }
      MovieSampleTableSet_stps((uint64_t)v19, *(_DWORD *)(v17 + 504), v100);
      if (v100)
      {
        CFRelease(v100);
        CMBlockBufferRef v100 = 0;
      }
    }
    uint64_t v76 = *(OpaqueCMBlockBuffer **)(v17 + 536);
    if (v76)
    {
      if (v16) {
        uint64_t v77 = CMBlockBufferCreateContiguous(a1, v76, a1, 0, 0, 0, 2u, &v100);
      }
      else {
        uint64_t v77 = CMBlockBufferCreateWithBufferReference(a1, v76, 0, 0, 0, &v100);
      }
      uint64_t v58 = v77;
      CMBlockBufferRef v57 = v100;
      if (v77) {
        goto LABEL_159;
      }
      MovieSampleTableSet_sdtp((uint64_t)v19, *(_DWORD *)(v17 + 528), v100);
      if (v100) {
        CFRelease(v100);
      }
    }
    if (*(unsigned char *)(v17 + 576))
    {
      v19[576] = 1;
      long long v78 = *(_OWORD *)(v17 + 552);
      *((void *)v19 + 71) = *(void *)(v17 + 568);
      *(_OWORD *)(v19 + 552) = v78;
    }
    v19[722] = *(unsigned char *)(v17 + 722);
    *((void *)v19 + 102) = *(void *)(v17 + 816);
    *((_DWORD *)v19 + 206) = *(_DWORD *)(v17 + 824);
    uint64_t v79 = *(int *)(v17 + 820);
    if (v79)
    {
      long long v80 = malloc_type_malloc(96 * v79, 0x1000040565EDBD2uLL);
      *((void *)v19 + 101) = v80;
      if (!v80) {
        goto LABEL_135;
      }
      uint64_t v81 = *(int *)(v17 + 816);
      if (v81) {
        memcpy(v80, *(const void **)(v17 + 808), 96 * v81);
      }
    }
    CFDictionaryRef v82 = *(const __CFDictionary **)(v17 + 832);
    if (v82) {
      *((void *)v19 + 104) = CFDictionaryCreateCopy(a1, v82);
    }
    *((void *)v19 + 105) = *(void *)(v17 + 840);
    CFStringRef v83 = *(const __CFString **)(v17 + 856);
    if (v83) {
      *((void *)v19 + 107) = CFStringCreateCopy(a1, v83);
    }
    CFStringRef v84 = *(const __CFString **)(v17 + 848);
    if (v84) {
      *((void *)v19 + 106) = CFStringCreateCopy(a1, v84);
    }
    *(_OWORD *)(v19 + 866) = *(_OWORD *)(v17 + 866);
    *(_DWORD *)(v19 + 882) = *(_DWORD *)(v17 + 882);
    uint64_t v25 = MovieInformationAddNewPerTrackInfo(v10, v19);
    if (v25) {
      goto LABEL_136;
    }
    CFRelease(v19);
    CFTypeRef cf = 0;
    ++v15;
    uint64_t v6 = v94;
    if (v15 == v95)
    {
      uint64_t v58 = 0;
LABEL_138:
      a4 = v93;
      goto LABEL_139;
    }
  }
  if (v16) {
    uint64_t v60 = CMBlockBufferCreateContiguous(a1, v59, a1, 0, 0, 0, 2u, &v100);
  }
  else {
    uint64_t v60 = CMBlockBufferCreateWithBufferReference(a1, v59, 0, 0, 0, &v100);
  }
  uint64_t v58 = v60;
  CMBlockBufferRef v57 = v100;
  if (v60) {
    goto LABEL_159;
  }
  uint64_t v61 = MovieSampleTableSet_stz2((uint64_t)v19, *(_DWORD *)(v17 + 340), *(_DWORD *)(v17 + 336), v100);
  CMBlockBufferRef v57 = v100;
  if (!v61)
  {
    if (v100)
    {
      CFRelease(v100);
      CMBlockBufferRef v100 = 0;
    }
    goto LABEL_59;
  }
  uint64_t v58 = v61;
LABEL_159:
  a4 = v93;
  uint64_t v6 = v94;
  if (v57) {
    CFRelease(v57);
  }
LABEL_139:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v58) {
    goto LABEL_153;
  }
  if (*(uint64_t *)(v6 + 328) < 1)
  {
LABEL_148:
    uint64_t v58 = 0;
    *a4 = v10;
  }
  else
  {
    uint64_t v85 = 0;
    uint64_t v86 = 0;
    while (1)
    {
      uint64_t v9 = EnsureTrackReferenceArrayCapacityForAddition(v10);
      if (v9) {
        break;
      }
      uint64_t v87 = v10[43] + 12 * v10[41];
      *(_DWORD *)(v87 + 8) = 0;
      *(void *)uint64_t v87 = 0;
      uint64_t v88 = v10[41];
      uint64_t v89 = v10[43] + 12 * v88;
      v10[41] = v88 + 1;
      long long v90 = (uint64_t *)(*(void *)(v6 + 344) + v85);
      uint64_t v91 = *v90;
      *(_DWORD *)(v89 + 8) = *((_DWORD *)v90 + 2);
      *(void *)uint64_t v89 = v91;
      ++v86;
      v85 += 12;
      if (v86 >= *(void *)(v6 + 328)) {
        goto LABEL_148;
      }
    }
LABEL_152:
    uint64_t v58 = v9;
LABEL_153:
    if (v10) {
      CFRelease(v10);
    }
  }
LABEL_149:
  if (*(void *)(v6 + 24)) {
    FigReadWriteLockUnlockForRead();
  }
  return v58;
}

uint64_t MovieTrackAddFragmentRun(CMTime *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v140 = 0;
  int v10 = (*(uint64_t (**)(uint64_t))(a2 + 624))(a2);
  uint64_t v11 = *(void *)(a3 + 48) + *(int *)(a4 + 32);
  uint64_t v12 = *(void *)(a2 + 392);
  if (v11 > 4000000000)
  {
    if (!v12) {
      UpgradeTo64BitChunkOffsets(a2, v8, v9);
    }
    goto LABEL_5;
  }
  if (v12)
  {
LABEL_5:
    MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 392), (uint64_t *)(a2 + 400));
    unint64_t destination = bswap64(v11);
    CMByteStreamAppend();
    ++*(_DWORD *)(a2 + 384);
    goto LABEL_6;
  }
  MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 368), (uint64_t *)(a2 + 376));
  LODWORD(destination) = bswap32(v11);
  CMByteStreamAppend();
  ++*(_DWORD *)(a2 + 360);
LABEL_6:
  signed int v13 = *(_DWORD *)(a2 + 432);
  if (v13)
  {
    unsigned int v138 = 0;
    unint64_t destination = 0;
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 440), 12 * v13 - 12, 0xCuLL, &destination);
    unsigned int v14 = bswap32(v138);
    uint64_t v15 = 12 * *(int *)(a2 + 432);
    unsigned int v138 = 0;
    unint64_t destination = 0;
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 440), v15 - 12, 0xCuLL, &destination);
    signed int v13 = bswap32(HIDWORD(destination));
  }
  else
  {
    unsigned int v14 = 0;
  }
  if (v14 != *(_DWORD *)(a3 + 56) || *(_DWORD *)(a4 + 36) != v13)
  {
    unint64_t v140 = 0;
    MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 440), (uint64_t *)(a2 + 448));
    unint64_t destination = __PAIR64__(bswap32(*(_DWORD *)(a4 + 36)), bswap32(v10 + 1));
    unsigned int v138 = bswap32(*(_DWORD *)(a3 + 56));
    CMByteStreamAppend();
    ++*(_DWORD *)(a2 + 432);
  }
  uint64_t v16 = UpgradeTo32BitSampleSizes(a2);
  unsigned int v17 = *(_DWORD *)(a2 + 292);
  signed int v18 = *(_DWORD *)(a2 + 288);
  uint64_t v19 = *(void *)(a2 + 728);
  if (v19) {
    v18 += *(_DWORD *)(v19 + 8);
  }
  if (!v17)
  {
    MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 320), (uint64_t *)(a2 + 328));
LABEL_23:
    AddFragmentRunSampleSizes(a3, a4);
    goto LABEL_24;
  }
  uint64_t v20 = *(unsigned int *)(a4 + 48);
  if ((v20 & 2) == 0)
  {
    if (*(_DWORD *)(a3 + 64) == v17) {
      goto LABEL_24;
    }
    unsigned int v21 = bswap32(v17);
    goto LABEL_18;
  }
  uint64_t v44 = *(int *)(a4 + 36);
  if ((int)v44 >= 1)
  {
    uint64_t v45 = kPerSampleInfo_SizeInInt32s[v20];
    long long v46 = (_DWORD *)(a4 + 4 * kPerSampleInfo_SizeIndex[v20] + 52);
    unsigned int v21 = bswap32(v17);
    while (*v46 == v21)
    {
      v46 += v45;
      if (!--v44) {
        goto LABEL_24;
      }
    }
LABEL_18:
    unint64_t destination = 0;
    MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 320), (uint64_t *)(a2 + 328));
    LODWORD(v140) = v21;
    if (*(int *)(a2 + 288) >= 1)
    {
      uint64_t v22 = 0;
      do
      {
        CMByteStreamAppend();
        ++v22;
      }
      while (v22 < *(int *)(a2 + 288));
    }
    *(_DWORD *)(a2 + 316) = 0;
    *(_DWORD *)(a2 + 292) = 0;
    goto LABEL_23;
  }
LABEL_24:
  uint64_t v23 = *(int *)(a4 + 36);
  int v24 = *(_DWORD *)(a2 + 312) + v23;
  *(_DWORD *)(a2 + 312) = v24;
  *(_DWORD *)(a2 + 288) = v24;
  *(void *)(a2 + 840) = 0;
  *(void *)(a2 + 16) |= 0x2001uLL;
  if (!v16)
  {
    uint64_t v25 = *(void *)(a2 + 488);
    if (v25)
    {
      BOOL v26 = 0;
      BOOL v27 = *(_DWORD *)(a2 + 480) == 0;
    }
    else
    {
      uint64_t v28 = *(void *)(a2 + 728);
      if (v28) {
        v24 += *(_DWORD *)(v28 + 8);
      }
      BOOL v27 = 0;
      BOOL v26 = v24 != 0;
    }
    int v29 = v18 + 1;
    LODWORD(v140) = 0;
    unint64_t destination = 0;
    if (!v26 && !v27)
    {
LABEL_32:
      MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 488), (uint64_t *)(a2 + 496));
      uint64_t v30 = *(unsigned int *)(a4 + 48);
      if ((v30 & 4) != 0)
      {
        int v39 = *(_DWORD *)(a4 + 36);
        if (v39 >= 1)
        {
          uint64_t v40 = 0;
          uint64_t v41 = a4 + 4 * kPerSampleInfo_FlagsIndex[v30] + 52;
          uint64_t v42 = 4 * kPerSampleInfo_SizeInInt32s[v30];
          do
          {
            if (v40 || (uint64_t v43 = a4 + 44, !*(unsigned char *)(a4 + 40))) {
              uint64_t v43 = v41;
            }
            if ((*(unsigned char *)(v43 + 1) & 1) == 0)
            {
              LODWORD(v140) = bswap32(v29 + v40);
              CMByteStreamAppend();
              ++*(_DWORD *)(a2 + 480);
              int v39 = *(_DWORD *)(a4 + 36);
            }
            ++v40;
            v41 += v42;
          }
          while (v40 < v39);
        }
      }
      else
      {
        int v31 = *(_DWORD *)(a4 + 36);
        if (v31 >= 1)
        {
          uint64_t v32 = 0;
          while (v32 || !*(unsigned char *)(a4 + 40))
          {
            if ((*(_DWORD *)(a3 + 68) & 0x10000) == 0) {
              goto LABEL_37;
            }
LABEL_38:
            if (++v32 >= v31) {
              goto LABEL_93;
            }
          }
          if ((bswap32(*(_DWORD *)(a4 + 44)) & 0x10000) != 0) {
            goto LABEL_38;
          }
LABEL_37:
          LODWORD(v140) = bswap32(v29 + v32);
          CMByteStreamAppend();
          ++*(_DWORD *)(a2 + 480);
          int v31 = *(_DWORD *)(a4 + 36);
          goto LABEL_38;
        }
      }
LABEL_93:
      if (*(void *)(a2 + 536))
      {
        unint64_t destination = 0;
      }
      else
      {
        uint64_t v58 = *(unsigned int *)(a4 + 48);
        if ((v58 & 4) != 0)
        {
          int v66 = *(_DWORD *)(a4 + 36);
          if (v66 < 1) {
            goto LABEL_128;
          }
          int v67 = 0;
          uint64_t v68 = kPerSampleInfo_SizeInInt32s[v58];
          uint64_t v69 = a4 + 4 * kPerSampleInfo_FlagsIndex[v58] + 52;
          uint64_t v70 = 4 * v68;
          while (1)
          {
            if (v67 || (uint64_t v71 = (_WORD *)(a4 + 44), !*(unsigned char *)(a4 + 40))) {
              uint64_t v71 = (_WORD *)v69;
            }
            if ((*v71 & 0xF007) != 0) {
              break;
            }
            ++v67;
            v69 += v70;
            if (v66 == v67) {
              goto LABEL_128;
            }
          }
        }
        else
        {
          int v59 = *(_DWORD *)(a4 + 36);
          if (v59 < 1) {
            goto LABEL_128;
          }
          int v60 = 0;
          while (1)
          {
            int v61 = v60 || !*(unsigned char *)(a4 + 40) ? *(_DWORD *)(a3 + 68) : bswap32(*(_DWORD *)(a4 + 44));
            if ((v61 & 0x7F00000) != 0) {
              break;
            }
            if (v59 == ++v60) {
              goto LABEL_128;
            }
          }
        }
        unint64_t destination = 0;
        if (v18 >= 1)
        {
          CFAllocatorRef v108 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t v109 = a3;
          v110 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (v18 + 1), 0);
          bzero(v110, (v18 + 1));
          v111 = v110;
          a3 = v109;
          CMBlockBufferCreateWithMemoryBlock(v108, v111, (v18 + 1), v108, 0, 0, (v18 + 1), 0, (CMBlockBufferRef *)(a2 + 536));
          *(_DWORD *)(a2 + 528) = v29;
        }
      }
      MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 536), (uint64_t *)(a2 + 544));
      uint64_t v55 = *(unsigned int *)(a4 + 48);
      if ((v55 & 4) != 0)
      {
        if (*(int *)(a4 + 36) >= 1)
        {
          int v62 = 0;
          uint64_t v63 = a4 + 4 * kPerSampleInfo_FlagsIndex[v55] + 52;
          uint64_t v64 = 4 * kPerSampleInfo_SizeInInt32s[v55];
          do
          {
            if (v62 || (uint64_t v65 = (unsigned int *)(a4 + 44), !*(unsigned char *)(a4 + 40))) {
              uint64_t v65 = (unsigned int *)v63;
            }
            LOBYTE(v140) = (bswap32(*v65) >> 20) & 0x7F;
            CMByteStreamAppend();
            ++*(_DWORD *)(a2 + 528);
            ++v62;
            v63 += v64;
          }
          while (v62 < *(_DWORD *)(a4 + 36));
        }
      }
      else if (*(int *)(a4 + 36) >= 1)
      {
        int v56 = 0;
        do
        {
          if (v56 || !*(unsigned char *)(a4 + 40)) {
            unsigned int v57 = *(_DWORD *)(a3 + 68);
          }
          else {
            unsigned int v57 = bswap32(*(_DWORD *)(a4 + 44));
          }
          LOBYTE(v140) = (v57 >> 20) & 0x7F;
          CMByteStreamAppend();
          ++*(_DWORD *)(a2 + 528);
          ++v56;
        }
        while (v56 < *(_DWORD *)(a4 + 36));
      }
LABEL_128:
      unint64_t v139 = 0;
      unint64_t v140 = 0;
      MakeReadyToWrite_stts(a2);
      int v72 = *(_DWORD *)(a2 + 408);
      if (v72)
      {
        int v73 = v72 - 1;
        unint64_t destination = 0;
        CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 416), 8 * (v72 - 1), 8uLL, &destination);
        unsigned int v74 = bswap32(destination);
        unint64_t destination = 0;
        CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 416), 8 * v73, 8uLL, &destination);
        uint64_t v75 = bswap32(HIDWORD(destination));
      }
      else
      {
        unsigned int v74 = 0;
        int v73 = 0;
        uint64_t v75 = 0xFFFFFFFFLL;
      }
      uint64_t v76 = *(unsigned int *)(a4 + 48);
      uint64_t v135 = a3;
      v136 = a1;
      if (v76)
      {
        int v77 = *(_DWORD *)(a4 + 36);
        if (v77 < 1) {
          goto LABEL_148;
        }
        uint64_t v78 = 0;
        uint64_t v79 = (unsigned int *)(a4 + 52);
        uint64_t v80 = 4 * kPerSampleInfo_SizeInInt32s[v76];
        do
        {
          a3 = bswap32(*v79);
          if (v75 == a3)
          {
            ++v74;
            a3 = v75;
          }
          else
          {
            if (v74)
            {
              unint64_t v139 = _byteswap_uint64(__PAIR64__(v74, v75));
              uint64_t v81 = *(void *)(a2 + 424);
              uint64_t v82 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v82) {
                uint64_t v83 = v82;
              }
              else {
                uint64_t v83 = 0;
              }
              CFStringRef v84 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t *, unint64_t *))(v83 + 16);
              if (v84) {
                v84(v81, 8, 8 * v73, &v139, &v140);
              }
              ++v73;
              int v77 = *(_DWORD *)(a4 + 36);
            }
            unsigned int v74 = 1;
          }
          ++v78;
          uint64_t v79 = (unsigned int *)((char *)v79 + v80);
          uint64_t v75 = a3;
        }
        while (v78 < v77);
      }
      else
      {
        LODWORD(a3) = *(_DWORD *)(a3 + 60);
        if (v75 == a3)
        {
          v74 += *(_DWORD *)(a4 + 36);
LABEL_148:
          LODWORD(a3) = v75;
          goto LABEL_152;
        }
        if (v74) {
          ++v73;
        }
        unsigned int v74 = *(_DWORD *)(a4 + 36);
      }
LABEL_152:
      if (v74)
      {
        unint64_t v139 = _byteswap_uint64(__PAIR64__(v74, a3));
        uint64_t v85 = *(void *)(a2 + 424);
        uint64_t v86 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v87 = v86 ? v86 : 0;
        uint64_t v88 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t *, unint64_t *))(v87 + 16);
        if (v88) {
          v88(v85, 8, 8 * v73, &v139, &v140);
        }
      }
      *(_DWORD *)(a2 + 408) = v73 + 1;
      int64_t v89 = *(void *)(a2 + 88);
      int64_t v90 = *(void *)(a2 + 104);
      int64_t v91 = *(void *)(a2 + 224);
      *(void *)(a4 + 24) = v91;
      uint64_t v92 = *(unsigned int *)(a4 + 48);
      if ((v92 & 8) != 0)
      {
        int v94 = *(_DWORD *)(a4 + 36);
        if (v94)
        {
          int v95 = 0;
          uint64_t v93 = 0;
          uint64_t v96 = kPerSampleInfo_CompTimeOffIndex[v92];
          uint64_t v97 = *(unsigned int *)(v135 + 60);
          uint64_t v98 = (unsigned int *)(a4 + 52);
          uint64_t v99 = 4 * kPerSampleInfo_SizeInInt32s[v92];
          do
          {
            if (v92) {
              uint64_t v97 = bswap32(*v98);
            }
            unsigned int v100 = v98[v96];
            signed int v101 = bswap32(v100);
            if (v100)
            {
              if (v101 > *(_DWORD *)(a2 + 112)) {
                *(_DWORD *)(a2 + 112) = v101;
              }
              if (v101 < *(_DWORD *)(a2 + 116)) {
                *(_DWORD *)(a2 + 116) = v101;
              }
              int v95 = 1;
            }
            int64_t v102 = v91 + v101;
            if (v102 < v89) {
              int64_t v89 = v102;
            }
            int64_t v103 = v102 + v97;
            if (v103 > v90) {
              int64_t v90 = v103;
            }
            v91 += v97;
            v93 += v97;
            uint64_t v98 = (unsigned int *)((char *)v98 + v99);
            --v94;
          }
          while (v94);
        }
        else
        {
          uint64_t v93 = 0;
          int v95 = 0;
        }
      }
      else
      {
        if (v92)
        {
          int v104 = *(_DWORD *)(a4 + 36);
          if (v104)
          {
            uint64_t v93 = 0;
            uint64_t v105 = kPerSampleInfo_SizeInInt32s[v92];
            v106 = (unsigned int *)(a4 + 52);
            uint64_t v107 = 4 * v105;
            do
            {
              v93 += bswap32(*v106);
              v106 = (unsigned int *)((char *)v106 + v107);
              --v104;
            }
            while (v104);
          }
          else
          {
            uint64_t v93 = 0;
          }
        }
        else
        {
          uint64_t v93 = (*(_DWORD *)(v135 + 60) * *(_DWORD *)(a4 + 36));
        }
        int v95 = 0;
        int64_t v90 = v93 + v91;
        int64_t v89 = v91;
      }
      MovieTrackAddRunContributionToEditSegmentArray((uint64_t)v136, a2, v89, v90);
      *(void *)(a2 + 88) = v89;
      *(void *)(a2 + 104) = v90;
      *(void *)(a2 + 224) += v93;
      uint64_t v112 = *(void *)(a2 + 16);
      *(void *)(a2 + 16) = v112 | 2;
      if (*(unsigned char *)(a2 + 898)) {
        *(void *)(a2 + 16) = v112 | 0x200002;
      }
      UpdateDurationsForEditSegmentChange(v136, a2);
      unint64_t v139 = 0;
      unint64_t v140 = 0;
      MakeReadyToWrite_ctts(a2);
      int v113 = *(_DWORD *)(a2 + 456);
      if (v113)
      {
        int v114 = v113 - 1;
        unint64_t destination = 0;
        CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 464), 8 * (v113 - 1), 8uLL, &destination);
        signed int v18 = bswap32(destination);
        unint64_t destination = 0;
        CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 464), 8 * v114, 8uLL, &destination);
        uint64_t v115 = bswap32(HIDWORD(destination));
        if (!v95) {
          goto LABEL_215;
        }
      }
      else
      {
        if (v18 < 1)
        {
          uint64_t v115 = 0;
          signed int v18 = 0;
        }
        else
        {
          unint64_t v140 = bswap32(v18);
          uint64_t v116 = *(void *)(a2 + 472);
          uint64_t v117 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v117) {
            uint64_t v118 = v117;
          }
          else {
            uint64_t v118 = 0;
          }
          v119 = *(void (**)(uint64_t, uint64_t, void, unint64_t *, unint64_t *))(v118 + 16);
          if (v119) {
            v119(v116, 8, 0, &v140, &v139);
          }
          uint64_t v115 = 0;
        }
        int v114 = 0;
        if (!v95) {
          goto LABEL_215;
        }
      }
      uint64_t v120 = *(unsigned int *)(a4 + 48);
      if ((v120 & 8) != 0)
      {
        int v121 = *(_DWORD *)(a4 + 36);
        if (v121 < 1)
        {
          LODWORD(v125) = v115;
          if (v18) {
            goto LABEL_221;
          }
          goto LABEL_227;
        }
        uint64_t v122 = 0;
        v123 = (unsigned int *)(a4 + 4 * kPerSampleInfo_CompTimeOffIndex[v120] + 52);
        uint64_t v124 = 4 * kPerSampleInfo_SizeInInt32s[v120];
        do
        {
          uint64_t v125 = bswap32(*v123);
          if (v115 == v125)
          {
            ++v18;
            uint64_t v125 = v115;
          }
          else
          {
            if (v18)
            {
              unint64_t v140 = _byteswap_uint64(__PAIR64__(v18, v115));
              uint64_t v126 = *(void *)(a2 + 472);
              uint64_t v127 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v127) {
                uint64_t v128 = v127;
              }
              else {
                uint64_t v128 = 0;
              }
              v129 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t *, unint64_t *))(v128 + 16);
              if (v129) {
                v129(v126, 8, 8 * v114, &v140, &v139);
              }
              ++v114;
              int v121 = *(_DWORD *)(a4 + 36);
            }
            signed int v18 = 1;
          }
          ++v122;
          v123 = (unsigned int *)((char *)v123 + v124);
          uint64_t v115 = v125;
        }
        while (v122 < v121);
LABEL_220:
        if (v18)
        {
LABEL_221:
          unint64_t v140 = _byteswap_uint64(__PAIR64__(v18, v125));
          uint64_t v130 = *(void *)(a2 + 472);
          uint64_t v131 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v131) {
            uint64_t v132 = v131;
          }
          else {
            uint64_t v132 = 0;
          }
          v133 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t *, unint64_t *))(v132 + 16);
          if (v133) {
            v133(v130, 8, 8 * v114, &v140, &v139);
          }
        }
LABEL_227:
        uint64_t v16 = 0;
        *(_DWORD *)(a2 + 456) = v114 + 1;
        return v16;
      }
LABEL_215:
      LODWORD(v125) = 0;
      if (v115) {
        signed int v18 = *(_DWORD *)(a4 + 36);
      }
      else {
        v18 += *(_DWORD *)(a4 + 36);
      }
      if (v115) {
        ++v114;
      }
      goto LABEL_220;
    }
    uint64_t v33 = *(unsigned int *)(a4 + 48);
    if ((v33 & 4) != 0)
    {
      if ((int)v23 < 1) {
        goto LABEL_91;
      }
      char v34 = 0;
      char v35 = 0;
      uint64_t v47 = 0;
      uint64_t v48 = kPerSampleInfo_SizeInInt32s[v33];
      uint64_t v49 = a4 + 4 * kPerSampleInfo_FlagsIndex[v33] + 52;
      uint64_t v50 = 4 * v48;
      int v37 = 1;
      do
      {
        if (v47 || (uint64_t v51 = a4 + 44, !*(unsigned char *)(a4 + 40))) {
          uint64_t v51 = v49;
        }
        int v52 = *(unsigned __int8 *)(v51 + 1);
        v37 &= v52 << 31 >> 31;
        if (v52) {
          char v34 = 1;
        }
        else {
          char v35 = 1;
        }
        ++v47;
        v49 += v50;
      }
      while (v23 != v47);
    }
    else
    {
      if ((int)v23 < 1) {
        goto LABEL_91;
      }
      char v34 = 0;
      char v35 = 0;
      uint64_t v36 = 0;
      int v37 = 1;
      do
      {
        if (v36 || !*(unsigned char *)(a4 + 40)) {
          unsigned int v38 = *(_DWORD *)(a3 + 68);
        }
        else {
          unsigned int v38 = bswap32(*(_DWORD *)(a4 + 44));
        }
        v37 &= (int)(v38 << 15) >> 31;
        if ((v38 & 0x10000) != 0) {
          char v34 = 1;
        }
        else {
          char v35 = 1;
        }
        ++v36;
      }
      while (v23 != v36);
    }
    if (v34)
    {
      BOOL v53 = v35 != 0;
    }
    else
    {
      BOOL v26 = 0;
      BOOL v53 = 0;
    }
    if (v26)
    {
      MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 488), (uint64_t *)(a2 + 496));
      if (v18 >= 1)
      {
        int v54 = 0;
        do
        {
          LODWORD(v140) = bswap32(++v54);
          CMByteStreamAppend();
          ++*(_DWORD *)(a2 + 480);
        }
        while (v18 != v54);
      }
      if (v53) {
        goto LABEL_32;
      }
    }
    else if (v53)
    {
      goto LABEL_32;
    }
    if (!(_BYTE)v37) {
      goto LABEL_93;
    }
    uint64_t v25 = *(void *)(a2 + 488);
LABEL_91:
    if (!v25) {
      CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, (CMBlockBufferRef *)(a2 + 488));
    }
    goto LABEL_93;
  }
  return v16;
}

uint64_t MovieTrackExtendMediaDecodeDurationToDisplayEndTime(void *a1, uint64_t a2, uint64_t a3)
{
  int32_t v5 = *(_DWORD *)(a2 + 232);
  CMTime v16 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CMTime v15 = v16;
  uint64_t result = MovieTrackGetDisplayTimeRange(a1, a2, 0, &v16);
  if (!result)
  {
    MovieTrackGetMediaDuration(a2, (uint64_t)&v15);
    CMTime lhs = v16;
    CMTime v12 = v15;
    CMTimeSubtract(&time1, &lhs, &v12);
    CMTime lhs = time1;
    CMTimeConvertScale(&time1, &lhs, v5, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    CMTimeFlags flags = time1.flags;
    uint64_t v8 = MEMORY[0x1E4F1FA48];
    if ((time1.flags & 0x1D) != 1
      || (CMTimeValue value = time1.value,
          CMTimeScale timescale = time1.timescale,
          CMTimeEpoch epoch = time1.epoch,
          CMTime lhs = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48],
          CMTimeCompare(&time1, &lhs) < 0))
    {
      CMTimeValue value = *(void *)v8;
      CMTimeScale timescale = *(_DWORD *)(v8 + 8);
      CMTimeFlags flags = *(_DWORD *)(v8 + 12);
      CMTimeEpoch epoch = *(void *)(v8 + 16);
    }
    if (value < 1)
    {
      if (!a3) {
        return 0;
      }
    }
    else
    {
      uint64_t result = MovieHeaderExtendLastSampleDecodeDuration(a2, value);
      if (!a3 || result) {
        return result;
      }
    }
    uint64_t result = 0;
    *(void *)a3 = value;
    *(_DWORD *)(a3 + 8) = timescale;
    *(_DWORD *)(a3 + 12) = flags;
    *(void *)(a3 + 16) = epoch;
  }
  return result;
}

uint64_t MovieHeaderExtendLastSampleDecodeDuration(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 408);
  if (v2)
  {
    int v5 = v2 - 1;
    uint64_t destination = 0;
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 416), 8 * (v2 - 1), 8uLL, &destination);
    unsigned int v6 = destination;
    uint64_t destination = 0;
    CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 416), 8 * (v2 - 1), 8uLL, &destination);
    if (!v6) {
      return FigSignalErrorAt();
    }
    signed int v7 = bswap32(HIDWORD(destination));
    uint64_t v8 = a2 + v7;
    MakeReadyToWrite_stts(a1);
    if (v8 != (int)v8) {
      return FigSignalErrorAt();
    }
    if (v6 == 0x1000000)
    {
      if (v2 == 1
        || (int v9 = v2 - 2,
            uint64_t destination = 0,
            CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 416), 8 * v9, 8uLL, &destination),
            unsigned int v10 = bswap32(HIDWORD(destination)),
            v8 != v10))
      {
        uint64_t result = WriteTimeToSampleNumEntry(a1, 1u, (int)a2 + v7, v5);
        if (result) {
          return result;
        }
        goto LABEL_14;
      }
      uint64_t destination = 0;
      CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 416), 8 * v9, 8uLL, &destination);
      uint64_t result = WriteTimeToSampleNumEntry(a1, bswap32(destination) + 1, v10, v9);
      if (!result)
      {
        uint64_t result = WriteTimeToSampleNumEntry(a1, 0, 0, v5);
        if (!result)
        {
          int v12 = -1;
LABEL_12:
          *(_DWORD *)(a1 + 408) += v12;
LABEL_14:
          uint64_t result = 0;
          *(void *)(a1 + 224) += a2;
        }
      }
    }
    else
    {
      uint64_t result = WriteTimeToSampleNumEntry(a1, bswap32(v6) - 1, v7, v2 - 1);
      if (!result)
      {
        int v12 = 1;
        uint64_t result = WriteTimeToSampleNumEntry(a1, 1u, (int)a2 + v7, v2);
        if (!result) {
          goto LABEL_12;
        }
      }
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t MovieTrackSetLastSampleDecodeDuration(uint64_t a1, CMTime *a2)
{
  if ((a2->flags & 0x1D) == 1)
  {
    int32_t v4 = *(_DWORD *)(a1 + 232);
    int v5 = *(_DWORD *)(a1 + 408);
    CMTime time1 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    CMTime v8 = *a2;
    if (CMTimeCompare(&time1, &v8) < 0 && v5)
    {
      time1.CMTimeValue value = 0;
      CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 416), 8 * (v5 - 1), 8uLL, &time1);
      signed int v6 = bswap32(HIDWORD(time1.value));
      CMTime v8 = *a2;
      CMTimeConvertScale(&time1, &v8, v4, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      *a2 = time1;
      if (a2->value == v6) {
        return 0;
      }
      else {
        return MovieHeaderExtendLastSampleDecodeDuration(a1, a2->value - v6);
      }
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieTrackNoteSampleEncryptionAtomPresent(uint64_t result)
{
  *(unsigned char *)(result + 724) = 1;
  return result;
}

uint64_t MovieTrackIsSampleEncryptionAtomPresent(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 724);
}

uint64_t MovieTrackNoteSampleAuxInfoSizesAtomPresent(uint64_t result)
{
  *(unsigned char *)(result + 725) = 1;
  return result;
}

uint64_t MovieTrackNoteSampleAuxInfoOffsetsAtomPresent(uint64_t result)
{
  *(unsigned char *)(result + 726) = 1;
  return result;
}

BOOL MovieTrackBothSampleAuxInfoAtomsPresent(uint64_t a1)
{
  return *(unsigned char *)(a1 + 725) && *(unsigned char *)(a1 + 726) != 0;
}

uint64_t MovieInformationBeginBuildingMovieFragment(uint64_t a1, char a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 304);
  if (v3 < 1) {
    return 0;
  }
  uint64_t v6 = 0;
  signed int v7 = &v24;
  if (!a3) {
    signed int v7 = 0;
  }
  uint64_t v21 = (uint64_t)v7;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  while (1)
  {
    if (*(void *)(a1 + 304) <= v6) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = *(void *)(*(void *)(a1 + 320) + 8 * v6);
    }
    uint64_t v24 = 0;
    long long v25 = 0uLL;
    uint64_t v23 = 0;
    if (*(void *)(v9 + 768)) {
      return FigSignalErrorAt();
    }
    if (a3)
    {
      int v10 = *(_DWORD *)(v9 + 144);
      long long v25 = *(_OWORD *)(v9 + 900);
      HIDWORD(v24) = v10;
    }
    uint64_t v11 = *(void *)(v9 + 224);
    int v12 = *(_DWORD *)(v9 + 24);
    signed int v13 = *(const void **)(v9 + 80);
    if (v13)
    {
      CFIndex Count = FigCFDictionaryGetCount();
      CFAllocatorRef v15 = CFGetAllocator(v13);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v15, Count, 0, MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        CFDictionaryRef v17 = Mutable;
        CFDictionaryApplyFunction((CFDictionaryRef)v13, (CFDictionaryApplierFunction)DeepCopySampleGroupDescriptionArraysApplierFunction, Mutable);
        goto LABEL_16;
      }
      uint64_t v18 = FigSignalErrorAt();
      if (v18) {
        return v18;
      }
    }
    CFDictionaryRef v17 = 0;
LABEL_16:
    uint64_t v19 = TrackFragmentBuilderCreate(v12, v17, v11, v21, v8, &v23);
    if (v19) {
      break;
    }
    if (v17) {
      CFRelease(v17);
    }
    *(void *)(v9 + 768) = v23;
    *(unsigned char *)(v9 + 776) = a2;
    if (v3 == ++v6) {
      return 0;
    }
  }
  uint64_t v18 = v19;
  if (v17) {
    CFRelease(v17);
  }
  return v18;
}

void MovieInformationReleaseMovieHeaderSampleTables(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (v1 >= 1)
  {
    for (uint64_t i = 0; i != v1; ++i)
    {
      if (*(void *)(a1 + 304) <= i) {
        int32_t v4 = 0;
      }
      else {
        int32_t v4 = *(void **)(*(void *)(a1 + 320) + 8 * i);
      }
      FreeAllSampleTables(v4);
    }
  }
}

void FreeAllSampleTables(void *a1)
{
  int v2 = (const void *)a1[40];
  if (v2)
  {
    CFRelease(v2);
    a1[40] = 0;
  }
  uint64_t v3 = (const void *)a1[43];
  if (v3)
  {
    CFRelease(v3);
    a1[43] = 0;
  }
  int32_t v4 = (const void *)a1[46];
  if (v4)
  {
    CFRelease(v4);
    a1[46] = 0;
  }
  int v5 = (const void *)a1[49];
  if (v5)
  {
    CFRelease(v5);
    a1[49] = 0;
  }
  uint64_t v6 = (const void *)a1[52];
  if (v6)
  {
    CFRelease(v6);
    a1[52] = 0;
  }
  signed int v7 = (const void *)a1[55];
  if (v7)
  {
    CFRelease(v7);
    a1[55] = 0;
  }
  CFAllocatorRef v8 = (const void *)a1[58];
  if (v8)
  {
    CFRelease(v8);
    a1[58] = 0;
  }
  uint64_t v9 = (const void *)a1[61];
  if (v9)
  {
    CFRelease(v9);
    a1[61] = 0;
  }
  int v10 = (const void *)a1[64];
  if (v10)
  {
    CFRelease(v10);
    a1[64] = 0;
  }
  uint64_t v11 = (const void *)a1[67];
  if (v11)
  {
    CFRelease(v11);
    a1[67] = 0;
  }
  int v12 = (const void *)a1[41];
  if (v12)
  {
    CFRelease(v12);
    a1[41] = 0;
  }
  signed int v13 = (const void *)a1[44];
  if (v13)
  {
    CFRelease(v13);
    a1[44] = 0;
  }
  unsigned int v14 = (const void *)a1[47];
  if (v14)
  {
    CFRelease(v14);
    a1[47] = 0;
  }
  CFAllocatorRef v15 = (const void *)a1[50];
  if (v15)
  {
    CFRelease(v15);
    a1[50] = 0;
  }
  CMTime v16 = (const void *)a1[53];
  if (v16)
  {
    CFRelease(v16);
    a1[53] = 0;
  }
  CFDictionaryRef v17 = (const void *)a1[56];
  if (v17)
  {
    CFRelease(v17);
    a1[56] = 0;
  }
  uint64_t v18 = (const void *)a1[59];
  if (v18)
  {
    CFRelease(v18);
    a1[59] = 0;
  }
  uint64_t v19 = (const void *)a1[62];
  if (v19)
  {
    CFRelease(v19);
    a1[62] = 0;
  }
  uint64_t v20 = (const void *)a1[65];
  if (v20)
  {
    CFRelease(v20);
    a1[65] = 0;
  }
  uint64_t v21 = (const void *)a1[68];
  if (v21)
  {
    CFRelease(v21);
    a1[68] = 0;
  }
}

void MovieInformationReleaseMovieFragmentSampleTables(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (v1 >= 1)
  {
    for (uint64_t i = 0; i != v1; ++i)
    {
      uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 320) + 8 * i) + 768);
      if (v4) {
        TrackFragmentBuilderSampleTableRelease(v4);
      }
    }
  }
}

uint64_t MovieTrackFragmentGetTrackFragmentHeaderSampleDescriptionIndex(uint64_t a1, _DWORD *a2, unsigned char *a3)
{
  return TrackFragmentBuilderGetTrackFragmentHeaderSampleDescriptionIndex(*(void *)(a1 + 768), a2, a3);
}

uint64_t MovieTrackFragmentGetTrackFragmentHeaderDefaultSampleDuration(uint64_t a1, _DWORD *a2, unsigned char *a3)
{
  return TrackFragmentBuilderGetTrackFragmentHeaderDefaultSampleDuration(*(void *)(a1 + 768), a2, a3);
}

uint64_t MovieTrackFragmentGetTrackFragmentHeaderDefaultSampleSize(uint64_t a1, _DWORD *a2, unsigned char *a3)
{
  return TrackFragmentBuilderGetTrackFragmentHeaderDefaultSampleSize(*(void *)(a1 + 768), a2, a3);
}

uint64_t MovieTrackFragmentGetTrackFragmentHeaderDefaultSampleFlags(uint64_t a1, _DWORD *a2, unsigned char *a3)
{
  return TrackFragmentBuilderGetTrackFragmentHeaderDefaultSampleFlags(*(void *)(a1 + 768), a2, a3);
}

uint64_t MovieTrackFragmentGetSampleAuxInformation(uint64_t a1, unsigned char *a2, _DWORD *a3, void *a4, void *a5, unsigned char *a6)
{
  return TrackFragmentBuilderGetSampleAuxInformation(*(void *)(a1 + 768), a2, a3, a4, a5, a6);
}

uint64_t MovieTrackFragmentCopySampleGroupDescriptionArrays(uint64_t a1, void *a2)
{
  return TrackFragmentBuilderCopySampleGroupDescriptionArrays(*(void *)(a1 + 768), a2);
}

uint64_t MovieTrackFragmentCopySampleGroupArray(uint64_t a1, CFArrayRef *a2)
{
  return TrackFragmentBuilderCopySampleGroupArray(*(void *)(a1 + 768), a2);
}

uint64_t MovieTrackFragmentSetInitialBaseMediaDecodeTimeValue(uint64_t a1, uint64_t a2)
{
  return TrackFragmentBuilderSetInitialBaseMediaDecodeTimeValue(*(void *)(a1 + 768), a2);
}

uint64_t MovieTrackFragmentGetTrackFragmentBaseMediaDecodeTimeValue(uint64_t a1, void *a2, char *a3)
{
  return TrackFragmentBuilderGetTrackFragmentBaseMediaDecodeTimeValue(*(void **)(a1 + 768), a2, a3);
}

uint64_t MovieTrackFragmentGetTrackFragmentLowestDisplayStartTimeValue(uint64_t a1, void *a2)
{
  return TrackFragmentBuilderGetTrackFragmentLowestDisplayStartTimeValue(*(void **)(a1 + 768), a2);
}

uint64_t MovieTrackFragmentGetTrackFragmentMediaDecodeDuration(uint64_t a1, void *a2)
{
  return TrackFragmentBuilderGetTrackFragmentMediaDecodeDuration(*(void *)(a1 + 768), a2);
}

uint64_t MovieTrackFragmentNumTrackRuns(uint64_t a1, _DWORD *a2)
{
  return TrackFragmentBuilderNumTrackRuns(*(void *)(a1 + 768), a2);
}

uint64_t MovieTrackFragmentNumSamplesAtTrackRunIndex(uint64_t a1, CFIndex a2, _DWORD *a3)
{
  return TrackFragmentBuilderNumSamplesAtTrackRunIndex(*(void *)(a1 + 768), a2, a3);
}

uint64_t MovieTrackFragmentGetDataOffsetAtTrackRunIndex(uint64_t a1, CFIndex a2, void *a3)
{
  return TrackFragmentBuilderGetDataOffsetAtTrackRunIndex(*(void *)(a1 + 768), a2, a3);
}

uint64_t MovieTrackFragmentGetFirstSampleFlagsAtTrackRunIndex(uint64_t a1, CFIndex a2, _DWORD *a3, unsigned char *a4)
{
  return TrackFragmentBuilderGetFirstSampleFlagsAtTrackRunIndex(*(void *)(a1 + 768), a2, a3, a4);
}

uint64_t MovieTrackFragmentGetSampleDurationArrayBbufAtTrackRunIndex(uint64_t a1, CFIndex a2, _DWORD *a3, void *a4)
{
  return TrackFragmentBuilderGetSampleDurationArrayBbufAtTrackRunIndex(*(void *)(a1 + 768), a2, a3, a4);
}

uint64_t MovieTrackFragmentGetSampleSizeArrayBbufAtTrackRunIndex(uint64_t a1, CFIndex a2, _DWORD *a3, void *a4)
{
  return TrackFragmentBuilderGetSampleSizeArrayBbufAtTrackRunIndex(*(void *)(a1 + 768), a2, a3, a4);
}

uint64_t MovieTrackFragmentGetSampleFlagsArrayBbufAtTrackRunIndex(uint64_t a1, CFIndex a2, _DWORD *a3, void *a4)
{
  return TrackFragmentBuilderGetSampleFlagsArrayBbufAtTrackRunIndex(*(void *)(a1 + 768), a2, a3, a4);
}

uint64_t MovieTrackFragmentGetSampleCompositionTimeOffsetArrayBbufAtTrackRunIndex(uint64_t a1, CFIndex a2, _DWORD *a3, void *a4)
{
  return TrackFragmentBuilderGetSampleCompositionTimeOffsetArrayBbufAtTrackRunIndex(*(void *)(a1 + 768), a2, a3, a4);
}

uint64_t MovieTrackAppendSampleInformation(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, uint64_t *a10, const __CFArray *a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14 = a8;
  unint64_t v15 = a7;
  int v16 = a5;
  uint64_t v19 = a13;
  uint64_t v18 = a14;
  uint64_t v20 = a12;
  uint64_t v21 = (uint64_t)a10;
  int64_t v164 = 0;
  int64_t value = 0;
  int32_t v22 = *(_DWORD *)(a2 + 232);
  uint64_t v23 = *(void *)(a2 + 768);
  if (v23) {
    BOOL v24 = *(unsigned char *)(a2 + 776) != 0;
  }
  else {
    BOOL v24 = 1;
  }
  if (a6 != (int)a6 || a7 != (int)a7 || a9 != (int)a9) {
    goto LABEL_78;
  }
  if (a7 >= 1)
  {
    long long v25 = (_DWORD *)(a8 + 32);
    uint64_t v26 = a7;
    while (v22 == *(v25 - 6) && v22 == *v25 && v22 == v25[6])
    {
      v25 += 18;
      if (!--v26) {
        goto LABEL_13;
      }
    }
LABEL_78:
    return FigSignalErrorAt();
  }
LABEL_13:
  if (!v24) {
    goto LABEL_262;
  }
  uint64_t v156 = a6;
  CMMediaType v171 = 0;
  long long v27 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 48);
  long long v168 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 32);
  long long v169 = v27;
  uint64_t v170 = *(void *)(MEMORY[0x1E4F1FA70] + 64);
  long long v28 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 16);
  *(_OWORD *)v167 = *MEMORY[0x1E4F1FA70];
  *(_OWORD *)&v167[16] = v28;
  unint64_t v166 = 0;
  uint64_t result = MovieTrackGetMediaTypeForSampleDescriptionID(a2, a5, &v171);
  if (result) {
    return result;
  }
  CMMediaType v154 = v171;
  if (v171 == 1936684398)
  {
    if (*(unsigned char *)(a2 + 240))
    {
      uint64_t v30 = *(int *)(a2 + 244);
      unint64_t v31 = *(int *)(a2 + 248);
      long long v32 = *(_OWORD *)(v14 + 48);
      long long v168 = *(_OWORD *)(v14 + 32);
      long long v169 = v32;
      uint64_t v170 = *(void *)(v14 + 64);
      long long v33 = *(_OWORD *)(v14 + 16);
      *(_OWORD *)v167 = *(_OWORD *)v14;
      *(_OWORD *)&v167[16] = v33;
      unint64_t v34 = *a10 / v31;
      unint64_t v166 = v34;
      if (a9 != 1
        || v34 != 1
        || (uint64_t v35 = *(void *)v167 / v30, *(uint64_t *)v167 /= v30, v15 != 1)
        || v35 != 1)
      {
        uint64_t result = FigSignalErrorAt();
        if (result) {
          return result;
        }
        goto LABEL_261;
      }
      int v36 = v30 * v156;
      v153 = (CMTime *)v167;
      v163 = (uint64_t *)&v166;
    }
    else
    {
      v163 = a10;
      v153 = (CMTime *)v14;
      int v36 = v156;
    }
  }
  else
  {
    v163 = a10;
    v153 = (CMTime *)v14;
    int v36 = v156;
  }
  uint64_t v155 = v14;
  unint64_t v157 = v15;
  unsigned int v158 = v16;
  BOOL v152 = v24;
  signed int v160 = v36;
  if (a3)
  {
    rhs.int64_t value = 0;
    int v37 = *(_DWORD *)(a2 + 432);
    if (v37 < 1)
    {
      unsigned int v42 = 0;
      unsigned int v41 = 0;
      int v44 = 0;
      unsigned int v45 = 0;
      unsigned int v46 = 0;
      unsigned int v43 = 1;
    }
    else
    {
      destination.CMTimeScale timescale = 0;
      destination.int64_t value = 0;
      size_t v38 = 12 * (v37 - 1);
      CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 440), v38, 0xCuLL, &destination);
      unsigned int v39 = destination.value;
      destination.CMTimeScale timescale = 0;
      destination.int64_t value = 0;
      CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 440), v38, 0xCuLL, &destination);
      unsigned int value_high = HIDWORD(destination.value);
      destination.CMTimeScale timescale = 0;
      destination.int64_t value = 0;
      CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 440), v38, 0xCuLL, &destination);
      unsigned int v41 = bswap32(value_high);
      unsigned int v42 = bswap32(destination.timescale);
      unsigned int v43 = bswap32(v39) + 1;
      if (v37 == 1)
      {
        int v44 = 0;
        unsigned int v45 = 0;
        unsigned int v46 = 0;
      }
      else
      {
        destination.CMTimeScale timescale = 0;
        destination.int64_t value = 0;
        CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 440), 12 * (v37 - 2), 0xCuLL, &destination);
        unsigned int v45 = bswap32(destination.timescale);
        destination.CMTimeScale timescale = 0;
        destination.int64_t value = 0;
        CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 440), 12 * (v37 - 2), 0xCuLL, &destination);
        unsigned int v46 = bswap32(HIDWORD(destination.value));
        int v44 = v37 - 1;
      }
    }
    if (v45 == v42 && v46 == v41) {
      unsigned int v48 = v44;
    }
    else {
      unsigned int v48 = v44 + 1;
    }
    MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 440), (uint64_t *)(a2 + 448));
    lhs.int64_t value = bswap32(v43);
    lhs.CMTimeScale timescale = bswap32(v158);
    uint64_t v49 = *(void *)(a2 + 448);
    uint64_t v50 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v50) {
      uint64_t v51 = v50;
    }
    else {
      uint64_t v51 = 0;
    }
    int v52 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CMTime *, CMTime *))(v51 + 16);
    if (!v52) {
      return 4294954514;
    }
    uint64_t result = v52(v49, 12, 12 * v48, &lhs, &rhs);
    if (result) {
      return result;
    }
    *(_DWORD *)(a2 + 432) = v48 + 1;
    lhs.int64_t value = 0;
    uint64_t v55 = *(void *)(a2 + 392);
    if (a4 <= 4000000000)
    {
      LODWORD(v15) = v157;
      if (!v55)
      {
        MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 368), (uint64_t *)(a2 + 376));
        LODWORD(rhs.value) = bswap32(a4);
        uint64_t result = CMByteStreamAppend();
        if (result) {
          return result;
        }
        ++*(_DWORD *)(a2 + 360);
        CMTimeValue v56 = a4;
        goto LABEL_48;
      }
    }
    else
    {
      LODWORD(v15) = v157;
      if (!v55) {
        UpgradeTo64BitChunkOffsets(a2, v53, v54);
      }
    }
    MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 392), (uint64_t *)(a2 + 400));
    destination.int64_t value = bswap64(a4);
    uint64_t result = CMByteStreamAppend();
    if (result) {
      return result;
    }
    ++*(_DWORD *)(a2 + 384);
    CMTimeValue v56 = destination.value;
LABEL_48:
    int v36 = v160;
    if (*(void *)(a2 + 304) > v56) {
      CMTimeValue v56 = *(void *)(a2 + 304);
    }
    *(void *)(a2 + 304) = v56;
  }
  if (v15 == 1)
  {
    uint64_t result = AddSampleToTimeToSampleTable(a2, v36, v153->value);
    if (result) {
      return result;
    }
    if (v154 == 1986618469)
    {
      memset(&destination, 0, sizeof(destination));
      CMTime lhs = v153[1];
      CMTime rhs = v153[2];
      CMTimeSubtract(&destination, &lhs, &rhs);
      uint64_t result = AddSampleToCompositionOffsetTable(a2, v160, destination.value);
      if (result) {
        return result;
      }
    }
  }
  else if ((int)v15 >= 1)
  {
    uint64_t v57 = (int)v157;
    uint64_t v58 = v153 + 1;
    do
    {
      uint64_t result = AddSampleToTimeToSampleTable(a2, 1, v58[-1].value);
      if (result) {
        return result;
      }
      if (v154 == 1986618469)
      {
        memset(&destination, 0, sizeof(destination));
        long long v59 = *(_OWORD *)&v58->value;
        lhs.CMTimeEpoch epoch = v58->epoch;
        *(_OWORD *)&lhs.int64_t value = v59;
        long long v60 = *(_OWORD *)&v58[1].value;
        rhs.CMTimeEpoch epoch = v58[1].epoch;
        *(_OWORD *)&rhs.int64_t value = v60;
        CMTimeSubtract(&destination, &lhs, &rhs);
        uint64_t result = AddSampleToCompositionOffsetTable(a2, 1u, destination.value);
        if (result) {
          return result;
        }
      }
      v58 += 3;
      --v57;
    }
    while (v57);
  }
  uint64_t v61 = *(int *)(a2 + 292);
  int v62 = *(_DWORD *)(a2 + 288);
  uint64_t v63 = *(void *)(a2 + 728);
  if (v63) {
    v62 += *(_DWORD *)(v63 + 8);
  }
  int v16 = v158;
  if (a9 != 1 || v62)
  {
    if (a9 == 1 && *v163 == v61) {
      goto LABEL_110;
    }
    LODWORD(lhs.value) = 0;
    destination.int64_t value = 0;
    if (!(*(uint64_t (**)(uint64_t))(a2 + 608))(a2))
    {
      MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 320), (uint64_t *)(a2 + 328));
      if (v62)
      {
        LODWORD(lhs.value) = bswap32(v61);
        if (v62 >= 1)
        {
          uint64_t v65 = v62;
          do
          {
            uint64_t result = CMByteStreamAppend();
            if (result) {
              goto LABEL_278;
            }
          }
          while (--v65);
        }
        *(_DWORD *)(a2 + 316) = 0;
        *(_DWORD *)(a2 + 292) = 0;
        if ((int)v61 < 0x10000)
        {
          if ((int)v61 <= 255)
          {
            if ((int)v61 <= 15) {
              int v66 = 4;
            }
            else {
              int v66 = 8;
            }
          }
          else
          {
            int v66 = 16;
          }
        }
        else
        {
          int v66 = 32;
        }
        if (*(_DWORD *)(a2 + 296) > v66) {
          int v66 = *(_DWORD *)(a2 + 296);
        }
        *(_DWORD *)(a2 + 296) = v66;
      }
    }
    if (v160 < 1)
    {
LABEL_109:
      uint64_t v19 = a13;
      int v16 = v158;
      goto LABEL_110;
    }
    uint64_t v67 = 0;
    while (1)
    {
      uint64_t v68 = a9 == 1 ? 0 : v67;
      unint64_t v69 = v163[v68];
      if (v69 >> 31) {
        break;
      }
      MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 320), (uint64_t *)(a2 + 328));
      LODWORD(lhs.value) = bswap32(v69);
      uint64_t result = CMByteStreamAppend();
      if (result) {
        goto LABEL_277;
      }
      if (v69 <= 0xF) {
        int v70 = 4;
      }
      else {
        int v70 = 8;
      }
      if (v69 > 0xFF) {
        int v70 = 16;
      }
      if (WORD1(v69)) {
        int v71 = 32;
      }
      else {
        int v71 = v70;
      }
      if (*(_DWORD *)(a2 + 296) > v71) {
        int v71 = *(_DWORD *)(a2 + 296);
      }
      *(_DWORD *)(a2 + 296) = v71;
      if (v160 == ++v67) {
        goto LABEL_109;
      }
    }
    uint64_t result = FigSignalErrorAt();
LABEL_277:
    uint64_t v19 = a13;
    int v16 = v158;
LABEL_278:
    uint64_t v14 = v155;
    unint64_t v15 = v157;
    signed int v72 = v160;
    if (result) {
      return result;
    }
    goto LABEL_111;
  }
  uint64_t v64 = *v163;
  if ((unint64_t)*v163 >> 31)
  {
    uint64_t result = FigSignalErrorAt();
    goto LABEL_278;
  }
  *(_DWORD *)(a2 + 316) = v64;
  *(_DWORD *)(a2 + 292) = v64;
LABEL_110:
  signed int v72 = v160;
  *(_DWORD *)(a2 + 312) += v160;
  *(void *)(a2 + 840) = 0;
  *(void *)(a2 + 16) |= 0x2000uLL;
  uint64_t v14 = v155;
  unint64_t v15 = v157;
LABEL_111:
  int v73 = *(_DWORD *)(a2 + 288);
  uint64_t v74 = *(void *)(a2 + 728);
  if (v74) {
    v73 += *(_DWORD *)(v74 + 8);
  }
  int v151 = v72 - 1;
  if (v72 < 1) {
    goto LABEL_144;
  }
  CFIndex v75 = 0;
  int v76 = v73;
  int v162 = v73;
  while (1)
  {
    v176[0] = 0;
    char v175 = 0;
    if (a11)
    {
      CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(a11, v75);
      if (ValueAtIndex) {
        FigMovieGetSampleDependencyFlagsFromSampleAttachments((uint64_t)ValueAtIndex, (char *)v176 + 1, v176, &v175);
      }
    }
    unsigned int v78 = v73 + v75 + 1;
    uint64_t v79 = *(void *)(a2 + 488);
    destination.int64_t value = 0;
    if (!v79) {
      break;
    }
    if (!LOBYTE(v176[0]))
    {
      LODWORD(lhs.value) = bswap32(v78);
      MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 488), (uint64_t *)(a2 + 496));
      __int16 v80 = CMByteStreamAppend();
      if (v80) {
        goto LABEL_142;
      }
      ++*(_DWORD *)(a2 + 480);
LABEL_127:
      int v73 = v162;
    }
LABEL_128:
    if (v175)
    {
      LODWORD(lhs.value) = bswap32(v78);
      destination.int64_t value = 0;
      MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 512), (uint64_t *)(a2 + 520));
      __int16 v80 = CMByteStreamAppend();
      if (v80) {
        goto LABEL_142;
      }
      ++*(_DWORD *)(a2 + 504);
    }
    LOBYTE(lhs.value) = HIBYTE(v176[0]);
    destination.int64_t value = 0;
    if (!*(void *)(a2 + 536))
    {
      if (!HIBYTE(v176[0]))
      {
        uint64_t result = 0;
        goto LABEL_139;
      }
      LOBYTE(rhs.value) = 0;
      MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 536), (uint64_t *)(a2 + 544));
      int v82 = v76;
      if (v78 >= 2)
      {
        do
        {
          __int16 v80 = CMByteStreamAppend();
          if (v80) {
            goto LABEL_142;
          }
          ++*(_DWORD *)(a2 + 528);
        }
        while (--v82);
      }
      int v73 = v162;
    }
    MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 536), (uint64_t *)(a2 + 544));
    __int16 v80 = CMByteStreamAppend();
    if (v80) {
      goto LABEL_142;
    }
    ++*(_DWORD *)(a2 + 528);
    uint64_t result = v80;
LABEL_139:
    ++v75;
    ++v76;
    if (v75 == v72) {
      goto LABEL_143;
    }
  }
  if (!LOBYTE(v176[0])) {
    goto LABEL_128;
  }
  MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(a2 + 488), (uint64_t *)(a2 + 496));
  if (v78 < 2) {
    goto LABEL_128;
  }
  int v81 = 0;
  while (1)
  {
    LODWORD(lhs.value) = bswap32(++v81);
    __int16 v80 = CMByteStreamAppend();
    if (v80) {
      break;
    }
    ++*(_DWORD *)(a2 + 480);
    if (v76 == v81) {
      goto LABEL_127;
    }
  }
LABEL_142:
  uint64_t result = v80;
LABEL_143:
  uint64_t v18 = a14;
  uint64_t v19 = a13;
  uint64_t v14 = v155;
  unint64_t v15 = v157;
  int v16 = v158;
  signed int v72 = v160;
  if (!result)
  {
LABEL_144:
    if (v154 == 1986618469)
    {
      LOBYTE(destination.value) = 0;
      if (!a11)
      {
        unint64_t Basic = MovieSampleGroupTypeSpecMakeBasic(1937337955);
        uint64_t result = AddSampleGroupForGroupType((void *)a2, Basic, v114, 0, v72, 0, 0, 0, 0, &destination);
        if (result || !LOBYTE(destination.value))
        {
          if (result) {
            return result;
          }
        }
        else
        {
          *(void *)(a2 + 16) |= 0x5000000uLL;
        }
        LOBYTE(lhs.value) = 0;
        unint64_t v117 = MovieSampleGroupTypeSpecMakeBasic(1953719148);
        uint64_t result = AddSampleGroupForGroupType((void *)a2, v117, v118, 1, v72, 0, 0, 0, 0, &lhs);
        if (result || !LOBYTE(lhs.value))
        {
          if (result) {
            return result;
          }
        }
        else
        {
          *(void *)(a2 + 16) |= 0x5000000uLL;
        }
        LOBYTE(destination.value) = 0;
        unint64_t v119 = MovieSampleGroupTypeSpecMakeBasic(1953718643);
        uint64_t result = AddSampleGroupForGroupType((void *)a2, v119, v120, 1, v72, 0, 0, 0, 0, &destination);
        if (result || !LOBYTE(destination.value))
        {
          if (result) {
            return result;
          }
        }
        else
        {
          *(void *)(a2 + 16) |= 0x5000000uLL;
        }
        LOBYTE(destination.value) = 0;
        unint64_t v121 = MovieSampleGroupTypeSpecMakeBasic(1937011553);
        uint64_t result = AddSampleGroupForGroupType((void *)a2, v121, v122, 1, v72, 0, 0, 0, 0, &destination);
        if (!result && LOBYTE(destination.value))
        {
          uint64_t result = 0;
          *(void *)(a2 + 16) |= 0x5000000uLL;
        }
        goto LABEL_227;
      }
      if (v72 <= 0)
      {
LABEL_184:
        uint64_t result = 0;
        goto LABEL_227;
      }
      CFIndex v86 = 0;
      while (1)
      {
        LOBYTE(lhs.value) = 0;
        LOBYTE(rhs.value) = 0;
        uint64_t v87 = CFArrayGetValueAtIndex(a11, v86);
        uint64_t result = FigMovieGetVideoSyncSampleEntryFromSampleAttachment((uint64_t)v87, &lhs, (BOOL *)&rhs);
        if (result) {
          break;
        }
        unint64_t v88 = MovieSampleGroupTypeSpecMakeBasic(1937337955);
        uint64_t result = AddSampleGroupForGroupType((void *)a2, v88, v89, 0, 1u, v86, LOBYTE(rhs.value), 1uLL, &lhs, &destination);
        if (result) {
          break;
        }
        if (LOBYTE(destination.value)) {
          *(void *)(a2 + 16) |= 0x5000000uLL;
        }
        if (v72 == ++v86)
        {
          CFIndex v90 = 0;
          LOBYTE(lhs.value) = 0;
          while (1)
          {
            memset(&destination, 0, 20);
            LOBYTE(rhs.value) = 0;
            CFDictionaryRef v91 = (const __CFDictionary *)CFArrayGetValueAtIndex(a11, v90);
            uint64_t result = FigMovieGetVideoTemporalLayerEntryFromSampleAttachment(v91, (uint64_t)&destination, (char *)&rhs);
            if (result) {
              return result;
            }
            unint64_t v92 = MovieSampleGroupTypeSpecMakeBasic(1953719148);
            uint64_t result = AddSampleGroupForGroupType((void *)a2, v92, v93, 1, 1u, v90, LOBYTE(rhs.value), 0x14uLL, &destination, &lhs);
            if (result) {
              return result;
            }
            if (LOBYTE(lhs.value)) {
              *(void *)(a2 + 16) |= 0x5000000uLL;
            }
            if (v72 == ++v90)
            {
              CFIndex v94 = 0;
              LOBYTE(destination.value) = 0;
              int v16 = v158;
              do
              {
                LOBYTE(lhs.value) = 0;
                CFArrayGetValueAtIndex(a11, v94);
                FigCFDictionaryGetBooleanIfPresent();
                unint64_t v95 = MovieSampleGroupTypeSpecMakeBasic(1953718643);
                uint64_t result = AddSampleGroupForGroupType((void *)a2, v95, v96, 1, 1u, v94, LOBYTE(lhs.value), 0, 0, &destination);
                if (result) {
                  BOOL v97 = 1;
                }
                else {
                  BOOL v97 = LOBYTE(destination.value) == 0;
                }
                if (v97)
                {
                  if (result) {
                    return result;
                  }
                }
                else
                {
                  *(void *)(a2 + 16) |= 0x5000000uLL;
                }
                ++v94;
              }
              while (v72 != v94);
              CFIndex v98 = 0;
              LOBYTE(destination.value) = 0;
              do
              {
                LOBYTE(lhs.value) = 0;
                CFArrayGetValueAtIndex(a11, v98);
                FigCFDictionaryGetBooleanIfPresent();
                unint64_t v99 = MovieSampleGroupTypeSpecMakeBasic(1937011553);
                uint64_t result = AddSampleGroupForGroupType((void *)a2, v99, v100, 1, 1u, v98, LOBYTE(lhs.value), 0, 0, &destination);
                if (result) {
                  BOOL v101 = 1;
                }
                else {
                  BOOL v101 = LOBYTE(destination.value) == 0;
                }
                if (v101)
                {
                  if (result) {
                    goto LABEL_227;
                  }
                }
                else
                {
                  *(void *)(a2 + 16) |= 0x5000000uLL;
                }
                ++v98;
              }
              while (v72 != v98);
              goto LABEL_184;
            }
          }
        }
      }
    }
    else
    {
      if (v154 != 1936684398) {
        goto LABEL_228;
      }
      LOWORD(destination.value) = 0;
      LOBYTE(lhs.value) = 0;
      LOBYTE(rhs.value) = 0;
      HIBYTE(v176[0]) = 0;
      if (!a12)
      {
        BOOL v85 = 0;
        unsigned int value_low = 0;
        goto LABEL_186;
      }
      uint64_t result = FigMovieGetAudioRollRecoveryValueFromSampleBufferAttachment(a12, &destination, (BOOL *)&lhs, (unsigned char *)v176 + 1);
      if (!result)
      {
        unsigned int value_low = LOWORD(destination.value);
        BOOL v84 = !LOBYTE(lhs.value) || HIBYTE(v176[0]) == 0;
        BOOL v85 = !v84;
LABEL_186:
        uint64_t v102 = v72;
        LOWORD(destination.value) = __rev16(value_low);
        unint64_t v103 = MovieSampleGroupTypeSpecMakeBasic(1919904876);
        uint64_t result = AddSampleGroupForGroupType((void *)a2, v103, v104, 0, v72, 0, v85, 2uLL, &destination, &rhs);
        if (LOBYTE(rhs.value)) {
          *(void *)(a2 + 16) |= 0x3000000uLL;
        }
        if (!result)
        {
          LOBYTE(lhs.value) = 0;
          if (a11)
          {
            if (v72 > 0)
            {
              CFIndex v105 = 0;
              while (1)
              {
                LOWORD(destination.value) = 0;
                LOBYTE(rhs.value) = 0;
                v106 = CFArrayGetValueAtIndex(a11, v105);
                uint64_t result = FigMovieGetAudioIndependentSampleDecoderRefreshCountFromSampleAttachment((uint64_t)v106, &destination, &rhs);
                if (result) {
                  return result;
                }
                LOWORD(destination.value) = bswap32(LOWORD(destination.value)) >> 16;
                unint64_t v107 = MovieSampleGroupTypeSpecMakeBasic(1886547820);
                uint64_t result = AddSampleGroupForGroupType((void *)a2, v107, v108, 0, 1u, v105, LOBYTE(rhs.value), 2uLL, &destination, &lhs);
                if (result) {
                  return result;
                }
                if (LOBYTE(lhs.value)) {
                  *(void *)(a2 + 16) |= 0x9000000uLL;
                }
                if (v72 == ++v105)
                {
                  CFIndex v109 = 0;
                  LOBYTE(lhs.value) = 0;
                  do
                  {
                    destination.int64_t value = 0;
                    *(void *)&destination.CMTimeScale timescale = 0;
                    int SeamUUIDBytesFromSampleAttachmentArray = FigMovieGetSeamUUIDBytesFromSampleAttachmentArray(a11, v109, (CFUUIDBytes *)&destination);
                    unint64_t v111 = MovieSampleGroupTypeSpecMakeBasic(1936023917);
                    uint64_t result = AddSampleGroupForGroupType((void *)a2, v111, v112, 0, 1u, v109, SeamUUIDBytesFromSampleAttachmentArray, 0x10uLL, &destination, &lhs);
                    if (result || !LOBYTE(lhs.value))
                    {
                      if (result) {
                        goto LABEL_226;
                      }
                    }
                    else
                    {
                      *(void *)(a2 + 16) |= 0x11000000uLL;
                    }
                    ++v109;
                  }
                  while (v102 != v109);
                  break;
                }
              }
            }
            uint64_t result = 0;
          }
          else
          {
            unint64_t v115 = MovieSampleGroupTypeSpecMakeBasic(1886547820);
            uint64_t result = AddSampleGroupForGroupType((void *)a2, v115, v116, 0, v72, 0, 0, 0, 0, &lhs);
            if (result || !LOBYTE(lhs.value))
            {
              if (result) {
                return result;
              }
            }
            else
            {
              *(void *)(a2 + 16) |= 0x9000000uLL;
            }
            LOBYTE(lhs.value) = 0;
            unint64_t v123 = MovieSampleGroupTypeSpecMakeBasic(1936023917);
            uint64_t result = AddSampleGroupForGroupType((void *)a2, v123, v124, 0, v72, 0, 0, 0, 0, &lhs);
            if (!result && LOBYTE(lhs.value))
            {
              uint64_t result = 0;
              *(void *)(a2 + 16) |= 0x11000000uLL;
            }
          }
LABEL_226:
          int v16 = v158;
LABEL_227:
          uint64_t v14 = v155;
          unint64_t v15 = v157;
          signed int v72 = v160;
          if (result) {
            return result;
          }
LABEL_228:
          int64_t v125 = *(void *)(a2 + 224);
          if (v15 == 1)
          {
            CMTimeValue v126 = v153[1].value - v153[2].value;
            int64_t v127 = v126 + v125;
            int64_t v128 = v126 + v125 + v153->value * v151;
            CMTimeValue v129 = v153->value * v72;
            unint64_t v130 = v128 + v153->value;
            LODWORD(v131) = v126;
            goto LABEL_244;
          }
          if ((int)v15 < 1)
          {
            CMTimeValue v129 = 0;
            LODWORD(v126) = 0x7FFFFFFF;
            LODWORD(v131) = 0x80000000;
            int64_t v127 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else
          {
            CMTimeValue v129 = 0;
            uint64_t v132 = v15;
            v133 = v153 + 1;
            LODWORD(v131) = 0x80000000;
            int64_t v128 = 0x8000000000000000;
            int64_t v127 = 0x7FFFFFFFFFFFFFFFLL;
            LODWORD(v134) = 0x7FFFFFFF;
            unint64_t v130 = 0x8000000000000000;
            uint64_t v135 = *(void *)(a2 + 224);
            do
            {
              CMTimeValue v136 = v133[-1].value;
              CMTimeValue v137 = v133->value - v133[1].value;
              int64_t v138 = v137 + v135;
              v135 += v136;
              v129 += v136;
              if (v138 < v127) {
                int64_t v127 = v138;
              }
              unint64_t v139 = v138 + v136;
              if (v128 < v138) {
                unint64_t v130 = v139;
              }
              if (v128 <= v138) {
                int64_t v128 = v138;
              }
              if (v137 < (int)v134) {
                CMTimeValue v134 = v133->value - v133[1].value;
              }
              if (v137 > (int)v131) {
                CMTimeValue v131 = v133->value - v133[1].value;
              }
              v133 += 3;
              --v132;
            }
            while (v132);
            LODWORD(v126) = v134;
LABEL_244:
            int64_t v140 = *(void *)(a2 + 88);
            int64_t v141 = *(void *)(a2 + 96);
            if (v127 < v140) {
              int64_t v140 = v127;
            }
            *(void *)(a2 + 88) = v140;
            if (v141 < v128)
            {
              *(void *)(a2 + 96) = v128;
              *(void *)(a2 + 104) = v130;
            }
          }
          BOOL v24 = v152;
          int v142 = *(_DWORD *)(a2 + 116);
          if ((int)v126 < v142) {
            int v142 = v126;
          }
          if ((int)v131 <= *(_DWORD *)(a2 + 112)) {
            LODWORD(v131) = *(_DWORD *)(a2 + 112);
          }
          *(_DWORD *)(a2 + 112) = v131;
          *(_DWORD *)(a2 + 116) = v142;
          *(void *)(a2 + 224) = v129 + v125;
          int64_t v164 = v125;
          int64_t value = v127;
          lhs.int64_t value = 0;
          uint64_t v143 = 12 * *(int *)(a2 + 432);
          destination.CMTimeScale timescale = 0;
          destination.int64_t value = 0;
          CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 440), v143 - 12, 0xCuLL, &destination);
          LODWORD(destination.value) = bswap32(bswap32(HIDWORD(destination.value)) + v160);
          uint64_t v144 = *(void *)(a2 + 448);
          uint64_t v145 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v145) {
            uint64_t v146 = v145;
          }
          else {
            uint64_t v146 = 0;
          }
          v147 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CMTime *, CMTime *))(v146 + 16);
          if (!v147) {
            return 4294954514;
          }
          uint64_t result = v147(v144, 4, v143 - 8, &destination, &lhs);
          if (result) {
            return result;
          }
          *(_DWORD *)(a2 + 288) += v160;
LABEL_261:
          uint64_t v23 = *(void *)(a2 + 768);
          uint64_t v21 = (uint64_t)a10;
          a6 = v156;
          uint64_t v20 = a12;
LABEL_262:
          if (!v23) {
            goto LABEL_268;
          }
          p_int64_t value = &value;
          if (v24) {
            p_int64_t value = 0;
          }
          v149 = &v164;
          if (v24) {
            v149 = 0;
          }
          uint64_t result = TrackFragmentBuilderAppendSampleInformation(v23, a3, a4, v16, a6, v15, (void *)v14, a9, v21, a11, v20, p_value, v149);
          if (!result)
          {
LABEL_268:
            if (v19)
            {
              CMTimeMake((CMTime *)v167, value, v22);
              *(_OWORD *)uint64_t v19 = *(_OWORD *)v167;
              *(void *)(v19 + 16) = *(void *)&v167[16];
            }
            if (v18)
            {
              CMTimeMake((CMTime *)v167, v164, v22);
              *(_OWORD *)uint64_t v18 = *(_OWORD *)v167;
              *(void *)(v18 + 16) = *(void *)&v167[16];
            }
            uint64_t v150 = *(void *)(a2 + 16);
            *(void *)(a2 + 16) = v150 | 0x2001;
            uint64_t result = 0;
            if (*(unsigned char *)(a2 + 898)) {
              *(void *)(a2 + 16) = v150 | 0x202001;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t MovieInformationPerformPostParsingForHeaderWriting(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 304);
  if (v2 < 2)
  {
    if (v2 == 1)
    {
      uint64_t v19 = **(void **)(a1 + 320);
      if (v19)
      {
        int v20 = *(_DWORD *)(v19 + 144);
      }
      else
      {
        FigSignalErrorAt();
        int v20 = 0;
      }
      int v21 = *(_DWORD *)(a1 + 252);
      if (v20 >= v21)
      {
        int v21 = v20 + 1;
        *(_DWORD *)(a1 + 252) = v20 + 1;
      }
      if (!v20)
      {
        *(_DWORD *)(v19 + 144) = v21;
        *(_DWORD *)(a1 + 252) = v21 + 1;
      }
    }
  }
  else
  {
    int v3 = *(_DWORD *)(a1 + 252);
    uint64_t v4 = (char *)malloc_type_calloc(*(void *)(a1 + 304), 8uLL, 0x100004090D0E795uLL);
    if (v4)
    {
      int v5 = v4;
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      int v8 = 0;
      do
      {
        if (*(void *)(a1 + 304) > v7 && (uint64_t v9 = *(void *)(*(void *)(a1 + 320) + v6)) != 0) {
          int v8 = *(_DWORD *)(v9 + 144);
        }
        else {
          FigSignalErrorAt();
        }
        if (v8 >= v3)
        {
          int v3 = v8 + 1;
          *(_DWORD *)(a1 + 252) = v8 + 1;
        }
        *(_DWORD *)&v5[v6] = v8;
        ++v7;
        v6 += 8;
      }
      while (v2 != v7);
      uint64_t v10 = 0;
      uint64_t v11 = v5 - 8;
      uint64_t v12 = 1;
      do
      {
        signed int v13 = &v5[8 * v10];
        if (*(_DWORD *)v13)
        {
          uint64_t v14 = v12;
          unint64_t v15 = v11;
          while (--v14 >= 1)
          {
            int v16 = *(_DWORD *)v15;
            v15 -= 8;
            if (v16 == *(_DWORD *)v13) {
              goto LABEL_16;
            }
          }
        }
        else
        {
LABEL_16:
          v13[4] = 1;
          *(_DWORD *)signed int v13 = v3++;
          *(_DWORD *)(a1 + 252) = v3;
        }
        ++v10;
        v11 += 8;
        ++v12;
      }
      while (v10 != v2);
      uint64_t v17 = 0;
      uint64_t v18 = v5;
      do
      {
        if (v18[4]) {
          *(_DWORD *)(*(void *)(*(void *)(a1 + 320) + 8 * v17) + 144) = *(_DWORD *)v18;
        }
        ++v17;
        v18 += 8;
      }
      while (v2 != v17);
      free(v5);
    }
    else
    {
      FigSignalErrorAt();
    }
  }
  CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  int64_t value = 0;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v22, 4, MEMORY[0x1E4F1D510]);
  MovieInformationCreateQuickTimeMetadataReaderFromByteStream((void *)a1, &value);
  if (value)
  {
    CFArrayAppendValue(Mutable, value);
    if (value)
    {
      CFRelease(value);
      int64_t value = 0;
    }
  }
  MovieInformationCreateQuickTimeUserDataReaderFromByteStream((void *)a1, &value);
  if (value)
  {
    CFArrayAppendValue(Mutable, value);
    if (value)
    {
      CFRelease(value);
      int64_t value = 0;
    }
  }
  MovieInformationCreateISOUserDataReaderFromByteStream((void *)a1, &value);
  if (value)
  {
    CFArrayAppendValue(Mutable, value);
    if (value)
    {
      CFRelease(value);
      int64_t value = 0;
    }
  }
  MovieInformationCreateiTunesMetadataReaderFromByteStream((void *)a1, &value);
  if (value)
  {
    CFArrayAppendValue(Mutable, value);
    if (value) {
      CFRelease(value);
    }
  }
  uint64_t MetadataItemsPerFormatDictionary = createMetadataItemsPerFormatDictionary(Mutable, v22, (__CFDictionary **)(a1 + 352));
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (!MetadataItemsPerFormatDictionary)
  {
    uint64_t v56 = *(void *)(a1 + 304);
    if (v56 >= 1)
    {
      uint64_t v25 = 0;
      uint64_t v52 = *MEMORY[0x1E4F1EC78];
      CFAllocatorRef v53 = v22;
      do
      {
        if (*(void *)(a1 + 304) <= v25) {
          uint64_t v26 = 0;
        }
        else {
          uint64_t v26 = *(void *)(*(void *)(a1 + 320) + 8 * v25);
        }
        if (*(int *)(v26 + 288) >= 1)
        {
          int64_t value = 0;
          CFArrayRef v27 = *(const __CFArray **)(v26 + 64);
          if (v27) {
            CFIndex Count = CFArrayGetCount(v27);
          }
          else {
            CFIndex Count = 0;
          }
          uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
          uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v30) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = 0;
          }
          long long v32 = *(void (**)(uint64_t, uint64_t, void, void **))(v31 + 48);
          if (v32) {
            v32(CMBaseObject, v52, 0, &value);
          }
          if (Count < 1)
          {
LABEL_66:
            uint64_t MetadataItemsPerFormatDictionary = 0;
          }
          else
          {
            CFIndex v33 = 0;
            while (1)
            {
              BOOL v57 = 0;
              uint64_t DataSourceAtIndex = MovieTrackGetDataSourceAtIndex((void *)a1, v26, v33, &v57, &v58);
              if (DataSourceAtIndex) {
                break;
              }
              if (v57)
              {
                if (!value)
                {
                  uint64_t DataSourceAtIndex = FigSignalErrorAt();
                  break;
                }
                uint64_t DataSourceAtIndex = MovieTrackSetDataSourceAtIndex((void *)a1, v26, v33, 1, value);
                if (DataSourceAtIndex) {
                  break;
                }
              }
              if (Count == ++v33) {
                goto LABEL_66;
              }
            }
            uint64_t MetadataItemsPerFormatDictionary = DataSourceAtIndex;
          }
          if (value) {
            CFRelease(value);
          }
          if (MetadataItemsPerFormatDictionary) {
            return MetadataItemsPerFormatDictionary;
          }
          uint64_t v35 = UpgradeTo32BitSampleSizes(v26);
          if (v35) {
            return v35;
          }
          if ((*(int (**)(uint64_t))(v26 + 584))(v26) >= 1)
          {
            uint64_t v36 = 0;
            do
            {
              int v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v26 + 592))(v26, v36);
              if (v37 <= 15) {
                int v38 = 4;
              }
              else {
                int v38 = 8;
              }
              if (v37 > 255) {
                int v38 = 16;
              }
              if (v37 >= 0x10000) {
                int v38 = 32;
              }
              if (*(_DWORD *)(v26 + 296) > v38) {
                int v38 = *(_DWORD *)(v26 + 296);
              }
              *(_DWORD *)(v26 + 296) = v38;
              uint64_t v36 = (v36 + 1);
            }
            while ((int)v36 < (*(int (**)(uint64_t))(v26 + 584))(v26));
          }
          if ((*(int (**)(uint64_t))(v26 + 624))(v26) >= 1)
          {
            uint64_t v39 = 0;
            do
            {
              uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(v26 + 616))(v26, v39);
              uint64_t v41 = *(void *)(v26 + 304);
              if (v41 <= v40) {
                uint64_t v41 = v40;
              }
              *(void *)(v26 + 304) = v41;
              uint64_t v39 = (v39 + 1);
            }
            while ((int)v39 < (*(int (**)(uint64_t))(v26 + 624))(v26));
          }
          if (*(void *)(v26 + 440))
          {
            unsigned int v42 = (*(uint64_t (**)(uint64_t))(v26 + 624))(v26);
            uint64_t v43 = *(int *)(v26 + 432);
            int v60 = 0;
            int64_t value = 0;
            int v55 = v43;
            uint64_t v54 = 12 * v43;
            size_t v44 = 12 * v43 - 12;
            CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v26 + 440), v44, 0xCuLL, &value);
            unsigned int v45 = HIDWORD(value);
            int v60 = 0;
            int64_t value = 0;
            CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v26 + 440), v44, 0xCuLL, &value);
            LODWORD(v44) = v60;
            int v60 = 0;
            uint64_t v58 = 0;
            int64_t value = 0;
            MakeTableReadyToWrite((OpaqueCMBlockBuffer **)(v26 + 440), (uint64_t *)(v26 + 448));
            int64_t value = (void *)__PAIR64__(v45, bswap32(v42));
            int v60 = v44;
            uint64_t v46 = *(void *)(v26 + 448);
            uint64_t v47 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v47) {
              uint64_t v48 = v47;
            }
            else {
              uint64_t v48 = 0;
            }
            uint64_t v49 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void **, uint64_t *))(v48 + 16);
            CFAllocatorRef v22 = v53;
            if (!v49) {
              return 4294954514;
            }
            uint64_t v35 = v49(v46, 12, v54, &value, &v58);
            if (v35) {
              return v35;
            }
            *(_DWORD *)(v26 + 432) = v55 + 1;
          }
        }
        int64_t value = 0;
        uint64_t v50 = CFArrayCreateMutable(v22, 3, MEMORY[0x1E4F1D510]);
        MovieTrackCreateQuickTimeMetadataReaderFromByteStream(a1, (uint64_t *)v26, &value);
        if (value)
        {
          CFArrayAppendValue(v50, value);
          if (value)
          {
            CFRelease(value);
            int64_t value = 0;
          }
        }
        MovieTrackCreateQuickTimeUserDataReaderFromByteStream(a1, (uint64_t *)v26, &value);
        if (value)
        {
          CFArrayAppendValue(v50, value);
          if (value)
          {
            CFRelease(value);
            int64_t value = 0;
          }
        }
        MovieTrackCreateISOUserDataReaderFromByteStream(a1, (uint64_t *)v26, &value);
        if (value)
        {
          CFArrayAppendValue(v50, value);
          if (value) {
            CFRelease(value);
          }
        }
        uint64_t MetadataItemsPerFormatDictionary = createMetadataItemsPerFormatDictionary(v50, v22, (__CFDictionary **)(v26 + 888));
        if (v50) {
          CFRelease(v50);
        }
        if (MetadataItemsPerFormatDictionary) {
          return MetadataItemsPerFormatDictionary;
        }
        ++v25;
      }
      while (v25 != v56);
    }
    return 0;
  }
  return MetadataItemsPerFormatDictionary;
}

uint64_t createMetadataItemsPerFormatDictionary(const __CFArray *a1, CFAllocatorRef allocator, __CFDictionary **a3)
{
  CFTypeRef cf = 0;
  CFTypeRef v20 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (a1 && (CFIndex Count = CFArrayGetCount(a1), Count >= 1))
  {
    CFIndex v8 = Count;
    CFIndex v9 = 0;
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (1)
    {
      CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(a1, v9);
      uint64_t v12 = FigMetadataCopyAllMetadataItems(allocator, (uint64_t)ValueAtIndex, (__CFArray **)&v20);
      if (v12) {
        break;
      }
      if (!v20) {
        CFTypeRef v20 = CFArrayCreate(v10, 0, 0, MEMORY[0x1E4F1D510]);
      }
      uint64_t FigBaseObject = FigMetadataReaderGetFigBaseObject(ValueAtIndex);
      uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v14) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = 0;
      }
      int v16 = *(uint64_t (**)(uint64_t, __CFString *, CFAllocatorRef, CFTypeRef *))(v15 + 48);
      if (!v16)
      {
        uint64_t v17 = 4294954514;
        goto LABEL_19;
      }
      uint64_t v12 = v16(FigBaseObject, @"format", allocator, &cf);
      if (v12) {
        break;
      }
      CFDictionaryAddValue(Mutable, cf, v20);
      if (cf)
      {
        CFRelease(cf);
        CFTypeRef cf = 0;
      }
      if (v20)
      {
        CFRelease(v20);
        CFTypeRef v20 = 0;
      }
      if (v8 == ++v9) {
        goto LABEL_17;
      }
    }
    uint64_t v17 = v12;
  }
  else
  {
LABEL_17:
    uint64_t v17 = 0;
    *a3 = Mutable;
    CFMutableDictionaryRef Mutable = 0;
  }
LABEL_19:
  if (cf) {
    CFRelease(cf);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v17;
}

uint64_t UpgradeTo32BitSampleSizes(uint64_t a1)
{
  CMBlockBufferRef theBuffer = 0;
  if (!(*(unsigned int (**)(void))(a1 + 584))() || (*(int (**)(uint64_t))(a1 + 600))(a1) > 31) {
    return 0;
  }
  long long dataPointerOut = 0;
  uint64_t v2 = *(int *)(a1 + 340);
  uint64_t v3 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 4 * v2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 4 * v2, 1u, &theBuffer);
  CMBlockBufferRef v4 = theBuffer;
  if (!v3)
  {
    CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    if ((int)v2 >= 1)
    {
      uint64_t v5 = 0;
      do
      {
        unsigned int v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 592))(a1, v5);
        uint64_t v7 = dataPointerOut;
        *(_DWORD *)long long dataPointerOut = bswap32(v6);
        long long dataPointerOut = v7 + 4;
        uint64_t v5 = (v5 + 1);
      }
      while (v2 != v5);
    }
    *(_DWORD *)(a1 + 312) = v2;
    CFIndex v8 = theBuffer;
    if (theBuffer) {
      CFIndex v8 = (void *)CFRetain(theBuffer);
    }
    *(void *)(a1 + 320) = v8;
    *(_DWORD *)(a1 + 316) = 0;
    *(_DWORD *)(a1 + 292) = 0;
    *(_DWORD *)(a1 + 340) = 0;
    CFIndex v9 = *(const void **)(a1 + 344);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 344) = 0;
    }
    CFAllocatorRef v10 = *(const void **)(a1 + 352);
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a1 + 352) = 0;
    }
    uint64_t v3 = 0;
    *(void *)(a1 + 584) = GetNumSamples_stsz;
    *(void *)(a1 + 592) = GetSampleSize_stsz;
    *(void *)(a1 + 600) = GetSampleSizeFieldSize_stsz;
    *(void *)(a1 + 608) = GetSizeTable_stsz;
    CMBlockBufferRef v4 = theBuffer;
  }
  if (v4) {
    CFRelease(v4);
  }
  return v3;
}

void MakeTableReadyToWrite(OpaqueCMBlockBuffer **a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  CMBlockBufferRef blockBufferOut = 0;
  if (!v3)
  {
    if (!CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0x10u, 0, &blockBufferOut))
    {
      if (v2 && CMBlockBufferGetDataLength(v2)) {
        CMBlockBufferAppendBufferReference(blockBufferOut, v2, 0, 0, 0);
      }
      uint64_t v5 = *a1;
      CMBlockBufferRef v6 = blockBufferOut;
      *a1 = blockBufferOut;
      if (v6) {
        CFRetain(v6);
      }
      if (v5) {
        CFRelease(v5);
      }
      CMByteStreamCreateWritableForBlockBuffer();
    }
    if (blockBufferOut) {
      CFRelease(blockBufferOut);
    }
  }
}

uint64_t MovieInformationSetMovieMetadataItemArray(uint64_t a1, void *key, void *value)
{
  CFMutableDictionaryRef Mutable = *(__CFDictionary **)(a1 + 352);
  if (!Mutable)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)(a1 + 352) = Mutable;
  }
  CFDictionarySetValue(Mutable, key, value);
  uint64_t result = FigCFEqual();
  if (result)
  {
    uint64_t v8 = 8;
  }
  else
  {
    uint64_t result = FigCFEqual();
    if (result)
    {
      uint64_t v8 = 64;
    }
    else
    {
      uint64_t result = FigCFEqual();
      if (result)
      {
        uint64_t v8 = 32;
      }
      else
      {
        uint64_t result = FigCFEqual();
        uint64_t v8 = 16 * (result != 0);
      }
    }
  }
  *(void *)(a1 + 40) |= v8;
  return result;
}

uint64_t MovieTrackInsertEmptySegment(CMTime *a1, uint64_t a2, long long *a3)
{
  *(_OWORD *)int v16 = a3[1];
  *(_OWORD *)&v16[16] = a3[2];
  long long v15 = *a3;
  *(_OWORD *)&v21.int64_t value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v6 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  v21.CMTimeEpoch epoch = v6;
  *(_OWORD *)&time1.start.int64_t value = *(_OWORD *)&v16[8];
  time1.start.CMTimeEpoch epoch = *(void *)&v16[24];
  long long v14 = *(_OWORD *)&v21.value;
  *(_OWORD *)&time2.int64_t value = *(_OWORD *)&v21.value;
  time2.CMTimeEpoch epoch = v6;
  if (CMTimeCompare(&time1.start, &time2) < 1) {
    return 4294954516;
  }
  *(_OWORD *)&time1.start.int64_t value = v15;
  time1.start.CMTimeEpoch epoch = *(void *)v16;
  *(_OWORD *)&time2.int64_t value = v14;
  time2.CMTimeEpoch epoch = v6;
  if (CMTimeCompare(&time1.start, &time2) < 0) {
    return 4294954516;
  }
  int v7 = *(_DWORD *)(a2 + 816);
  BOOL v8 = __OFSUB__(v7, 1);
  int v9 = v7 - 1;
  if (v9 < 0 != v8) {
    return 4294954516;
  }
  CFAllocatorRef v10 = (_OWORD *)(*(void *)(a2 + 808) + 96 * v9);
  long long v11 = v10[3];
  long long v12 = v10[5];
  *(_OWORD *)&time1.start.CMTimeEpoch epoch = v10[4];
  *(_OWORD *)&time1.duration.CMTimeScale timescale = v12;
  *(_OWORD *)&time1.start.int64_t value = v11;
  CMTimeRangeGetEnd(&v21, &time1);
  *(_OWORD *)&time1.start.int64_t value = v15;
  time1.start.CMTimeEpoch epoch = *(void *)v16;
  CMTime time2 = v21;
  if ((CMTimeCompare(&time1.start, &time2) & 0x80000000) == 0) {
    goto LABEL_6;
  }
  *(_OWORD *)&time1.start.int64_t value = v15;
  time1.start.CMTimeEpoch epoch = *(void *)v16;
  CMTime time2 = *(CMTime *)&v16[8];
  CMTimeRangeMake(&v18, &time1.start, &time2);
  *(_OWORD *)&time1.start.int64_t value = *MEMORY[0x1E4F1F9F8];
  time1.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  CMTime time2 = *(CMTime *)&v16[8];
  CMTimeRangeMake(&v17, &time1.start, &time2);
  uint64_t result = InsertMediaSegmentIntoTrack(a2 + 808, (uint64_t)&v18, (uint64_t)&v17);
  if (!result)
  {
LABEL_6:
    MovieTrackInvalidateEnhancedGaplessInfo(a2);
    *(_OWORD *)&time1.start.int64_t value = *a3;
    time1.start.CMTimeEpoch epoch = *((void *)a3 + 2);
    NoteEditSegmentModification((uint64_t)a1, a2, &time1.start, 0);
    UpdateDurationsForEditSegmentChange(a1, a2);
    return 0;
  }
  return result;
}

uint64_t MovieTrackInsertMediaSegment(CMTime *a1, uint64_t a2, _OWORD *a3, long long *a4)
{
  if ((*((_DWORD *)a4 + 3) & 0x1D) != 1) {
    return 4294954516;
  }
  *(_OWORD *)CMTimeRange time1 = *a4;
  *(void *)&time1[16] = *((void *)a4 + 2);
  long long v11 = *MEMORY[0x1E4F1FA48];
  *(void *)&long long v12 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  if (CMTimeCompare((CMTime *)time1, (CMTime *)&v11) < 0) {
    return 4294954516;
  }
  long long v8 = a3[1];
  *(_OWORD *)CMTimeRange time1 = *a3;
  *(_OWORD *)&time1[16] = v8;
  long long v15 = a3[2];
  long long v9 = a4[1];
  long long v11 = *a4;
  long long v12 = v9;
  long long v13 = a4[2];
  uint64_t result = InsertMediaSegmentIntoTrack(a2 + 808, (uint64_t)time1, (uint64_t)&v11);
  if (!result)
  {
    MovieTrackInvalidateEnhancedGaplessInfo(a2);
    *(_OWORD *)CMTimeRange time1 = *a3;
    *(void *)&time1[16] = *((void *)a3 + 2);
    NoteEditSegmentModification((uint64_t)a1, a2, (CMTime *)time1, 0);
    UpdateDurationsForEditSegmentChange(a1, a2);
    return 0;
  }
  return result;
}

uint64_t InsertMediaSegmentIntoTrack(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  CMTimeEpoch v6 = (long long *)MEMORY[0x1E4F1FA48];
  if ((*(_DWORD *)(a3 + 12) & 0x1D) == 1)
  {
    *(_OWORD *)CMTimeRange time1 = *(_OWORD *)a3;
    *(void *)&time1[16] = *(void *)(a3 + 16);
    *(_OWORD *)CMTime time2 = *MEMORY[0x1E4F1FA48];
    *(void *)&time2[16] = *(void *)(MEMORY[0x1E4F1FA48] + 16);
    if (CMTimeCompare((CMTime *)time1, (CMTime *)time2) < 0) {
      return 4294954516;
    }
  }
  *(_OWORD *)CMTimeRange time1 = *(_OWORD *)(a3 + 24);
  *(void *)&time1[16] = *(void *)(a3 + 40);
  long long v51 = *v6;
  *(_OWORD *)CMTime time2 = *v6;
  CMTimeEpoch v7 = *((void *)v6 + 2);
  *(void *)&time2[16] = v7;
  if (CMTimeCompare((CMTime *)time1, (CMTime *)time2) < 0) {
    return 4294954516;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (v8)
  {
    *(_OWORD *)CMTimeRange time1 = *(_OWORD *)a2;
    *(void *)&time1[16] = *(void *)(a2 + 16);
    *(_OWORD *)CMTime time2 = v51;
    *(void *)&time2[16] = v7;
    if (CMTimeCompare((CMTime *)time1, (CMTime *)time2) < 0) {
      return 4294954516;
    }
    int v8 = *(_DWORD *)(a2 + 12);
  }
  if ((v8 & 1) == 0)
  {
    *(_OWORD *)CMTime time2 = v51;
    *(void *)&time2[16] = v7;
    int v9 = *(_DWORD *)(a1 + 8);
    BOOL v10 = __OFSUB__(v9, 1);
    int v11 = v9 - 1;
    if (v11 < 0 == v10)
    {
      long long v12 = (_OWORD *)(*(void *)a1 + 96 * v11);
      long long v13 = v12[3];
      long long v14 = v12[5];
      *(_OWORD *)&time1[16] = v12[4];
      *(_OWORD *)long long v59 = v14;
      *(_OWORD *)CMTimeRange time1 = v13;
      CMTimeRangeGetEnd((CMTime *)time2, (CMTimeRange *)time1);
    }
    *(_OWORD *)a2 = *(_OWORD *)time2;
    *(void *)(a2 + 16) = *(void *)&time2[16];
  }
  *(_OWORD *)&v63[12] = 0u;
  long long v15 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)CMTime time2 = *(_OWORD *)a3;
  *(_OWORD *)&time2[16] = v15;
  *(_OWORD *)uint64_t v63 = 0u;
  *(_OWORD *)uint64_t v63 = *(_OWORD *)(a3 + 32);
  *(void *)&v63[16] = *(void *)a2;
  CMTimeFlags v16 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)&v63[24] = *(_DWORD *)(a2 + 8);
  CMTimeEpoch v17 = *(void *)(a2 + 16);
  v52.CMTimeEpoch epoch = *(void *)(a2 + 40);
  *(_OWORD *)&v52.int64_t value = *(_OWORD *)(a2 + 24);
  *(_OWORD *)&v61.int64_t value = v51;
  v61.CMTimeEpoch epoch = v7;
  uint64_t v18 = *(int *)(a1 + 8);
  CMTimeValue v64 = *(void *)a2;
  CMTimeScale v65 = *(_DWORD *)(a2 + 8);
  if ((int)v18 >= 1)
  {
    uint64_t v19 = (_OWORD *)(*(void *)a1 + 96 * (v18 - 1));
    long long v20 = v19[3];
    long long v21 = v19[5];
    *(_OWORD *)&time1[16] = v19[4];
    *(_OWORD *)long long v59 = v21;
    *(_OWORD *)CMTimeRange time1 = v20;
    CMTimeRangeGetEnd(&v61, (CMTimeRange *)time1);
  }
  if (v16)
  {
    *(void *)CMTimeRange time1 = v64;
    *(void *)&time1[8] = __PAIR64__(v16, v65);
    *(void *)&time1[16] = v17;
    lhs.CMTime start = v61;
    if (CMTimeCompare((CMTime *)time1, &lhs.start))
    {
      *(void *)CMTimeRange time1 = v64;
      *(void *)&time1[8] = __PAIR64__(v16, v65);
      *(void *)&time1[16] = v17;
      lhs.CMTime start = v61;
      if (CMTimeCompare((CMTime *)time1, &lhs.start) >= 1)
      {
        uint64_t result = InsertUninitializedEditsIntoTrack((char **)a1, *(_DWORD *)(a1 + 8), 2u);
        if (!result)
        {
          uint64_t v23 = *(void *)a1 + 96 * v18;
          long long v24 = *(_OWORD *)&v61.value;
          *(void *)(v23 + 64) = v61.epoch;
          *(_OWORD *)(v23 + 48) = v24;
          uint64_t v25 = *(void *)a1 + 96 * v18;
          lhs.start.int64_t value = v64;
          lhs.start.CMTimeScale timescale = v65;
          lhs.start.CMTimeFlags flags = v16;
          lhs.start.CMTimeEpoch epoch = v17;
          CMTime rhs = v61;
          CMTimeSubtract((CMTime *)time1, &lhs.start, &rhs);
          uint64_t result = 0;
          long long v26 = *(_OWORD *)time1;
          *(void *)(v25 + 88) = *(void *)&time1[16];
          *(_OWORD *)(v25 + 72) = v26;
          uint64_t v27 = *(void *)a1 + 96 * v18;
          long long v28 = *MEMORY[0x1E4F1F9F8];
          *(void *)(v27 + 16) = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
          *(_OWORD *)uint64_t v27 = v28;
          uint64_t v29 = *(void *)a1 + 96 * v18;
          *(_OWORD *)(v29 + 24) = v51;
          *(void *)(v29 + 40) = v7;
          uint64_t v30 = *(void *)a1 + 96 * ((int)v18 + 1);
LABEL_23:
          *(_OWORD *)uint64_t v30 = *(_OWORD *)time2;
          *(_OWORD *)(v30 + 16) = *(_OWORD *)&time2[16];
          *(_OWORD *)(v30 + 32) = *(_OWORD *)v63;
          *(_OWORD *)(v30 + 44) = *(_OWORD *)&v63[12];
          *(_DWORD *)(v30 + 60) = v16;
          *(void *)(v30 + 64) = v17;
          *(_OWORD *)(v30 + 72) = *(_OWORD *)&v52.value;
          *(void *)(v30 + 88) = v52.epoch;
          return result;
        }
        return result;
      }
      long long v33 = *(_OWORD *)(MEMORY[0x1E4F1FA00] + 48);
      *(_OWORD *)long long v59 = *(_OWORD *)(MEMORY[0x1E4F1FA00] + 32);
      *(_OWORD *)&v59[16] = v33;
      long long v34 = *(_OWORD *)(MEMORY[0x1E4F1FA00] + 80);
      *(_OWORD *)int v60 = *(_OWORD *)(MEMORY[0x1E4F1FA00] + 64);
      *(_OWORD *)&v60[16] = v34;
      long long v35 = *(_OWORD *)(MEMORY[0x1E4F1FA00] + 16);
      *(_OWORD *)CMTimeRange time1 = *MEMORY[0x1E4F1FA00];
      *(_OWORD *)&time1[16] = v35;
      *(_OWORD *)&rhs.int64_t value = v51;
      rhs.CMTimeEpoch epoch = v7;
      *(_OWORD *)&v56.int64_t value = v51;
      v56.CMTimeEpoch epoch = v7;
      *(_OWORD *)&lhs.start.int64_t value = v51;
      lhs.start.CMTimeEpoch epoch = v7;
      CMTime v55 = v52;
      CMTimeAdd(&v56, &lhs.start, &v55);
      lhs.start.int64_t value = v64;
      lhs.start.CMTimeScale timescale = v65;
      lhs.start.CMTimeFlags flags = v16;
      lhs.start.CMTimeEpoch epoch = v17;
      unsigned int EditIndexStartingAtTimeInTrackSplitEditIfNecessary = FindEditIndexStartingAtTimeInTrackSplitEditIfNecessary(a1, &lhs.start);
      if ((EditIndexStartingAtTimeInTrackSplitEditIfNecessary & 0x80000000) == 0)
      {
        unsigned int v37 = EditIndexStartingAtTimeInTrackSplitEditIfNecessary;
        if ((signed int)EditIndexStartingAtTimeInTrackSplitEditIfNecessary < *(_DWORD *)(a1 + 8))
        {
          unsigned int v38 = EditIndexStartingAtTimeInTrackSplitEditIfNecessary - 1;
          if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary) {
            uint64_t v39 = v38;
          }
          else {
            uint64_t v39 = 0;
          }
          unsigned int v40 = EditIndexStartingAtTimeInTrackSplitEditIfNecessary;
          uint64_t v41 = *(void *)a1 + 96 * EditIndexStartingAtTimeInTrackSplitEditIfNecessary;
          long long v42 = *(_OWORD *)(v41 + 48);
          v55.CMTimeEpoch epoch = *(void *)(v41 + 64);
          *(_OWORD *)&v55.int64_t value = v42;
          CMTime v54 = v56;
          CMTimeAdd(&lhs.start, &v55, &v54);
          long long v43 = *(_OWORD *)&lhs.start.value;
          *(void *)(v41 + 64) = lhs.start.epoch;
          *(_OWORD *)(v41 + 48) = v43;
          if (!v37) {
            goto LABEL_34;
          }
          *(_OWORD *)CMTimeRange time1 = *(_OWORD *)time2;
          *(_OWORD *)&time1[16] = *(_OWORD *)&time2[16];
          *(_OWORD *)long long v59 = *(_OWORD *)v63;
          *(_OWORD *)&v59[12] = *(_OWORD *)&v63[12];
          *(_DWORD *)&v59[28] = v16;
          *(_OWORD *)&v60[8] = *(_OWORD *)&v52.value;
          uint64_t v44 = *(void *)a1 + 96 * v38;
          *(void *)int v60 = v17;
          *(void *)&v60[24] = v52.epoch;
          if (CombineEditSegmentsIfPossible(v44, (uint64_t)time1, v44))
          {
            if (CombineEditSegmentsIfPossible(*(void *)a1 + 96 * v38, *(void *)a1 + 96 * v40, *(void *)a1 + 96 * v38))
            {
              uint64_t result = DeleteEditsFromTrack(a1, v37--, 1);
              if (result) {
                return result;
              }
            }
            else
            {
              --v37;
            }
          }
          else
          {
LABEL_34:
            *(_OWORD *)CMTimeRange time1 = *(_OWORD *)time2;
            *(_OWORD *)&time1[16] = *(_OWORD *)&time2[16];
            *(_OWORD *)long long v59 = *(_OWORD *)v63;
            *(_OWORD *)&v59[12] = *(_OWORD *)&v63[12];
            *(_DWORD *)&v59[28] = v16;
            *(_OWORD *)&v60[8] = *(_OWORD *)&v52.value;
            uint64_t v45 = *(void *)a1 + 96 * v40;
            *(void *)int v60 = v17;
            *(void *)&v60[24] = v52.epoch;
            if (!CombineEditSegmentsIfPossible((uint64_t)time1, v45, v45))
            {
              uint64_t result = InsertUninitializedEditsIntoTrack((char **)a1, v37, 1u);
              if (result) {
                return result;
              }
              uint64_t v46 = *(void *)a1 + 96 * v40;
              *(_OWORD *)uint64_t v46 = *(_OWORD *)time2;
              *(_OWORD *)(v46 + 16) = *(_OWORD *)&time2[16];
              *(_OWORD *)(v46 + 32) = *(_OWORD *)v63;
              *(_OWORD *)(v46 + 44) = *(_OWORD *)&v63[12];
              *(_DWORD *)(v46 + 60) = v16;
              *(void *)(v46 + 64) = v17;
              *(_OWORD *)(v46 + 72) = *(_OWORD *)&v52.value;
              *(void *)(v46 + 88) = v52.epoch;
            }
            unsigned int v38 = v37;
          }
          uint64_t v47 = (_OWORD *)(*(void *)a1 + 96 * v38);
          long long v48 = v47[3];
          long long v49 = v47[5];
          *(_OWORD *)&lhs.start.CMTimeEpoch epoch = v47[4];
          *(_OWORD *)&lhs.duration.CMTimeScale timescale = v49;
          *(_OWORD *)&lhs.start.int64_t value = v48;
          CMTimeRangeGetEnd(&rhs, &lhs);
          uint64_t v50 = v37 + 1;
          lhs.CMTime start = rhs;
          UpdateTrackStartTimes(a1, v50, (long long *)&lhs.start.value);
          DeleteEditsWithZeroDuration(a1, v39, v50);
          return 0;
        }
      }
      return 4294954516;
    }
  }
  signed int v31 = *(_DWORD *)(a1 + 8);
  if (v31 >= 1)
  {
    *(_OWORD *)CMTimeRange time1 = *(_OWORD *)time2;
    *(_OWORD *)&time1[16] = *(_OWORD *)&time2[16];
    *(_OWORD *)long long v59 = *(_OWORD *)v63;
    *(_OWORD *)&v59[12] = *(_OWORD *)&v63[12];
    *(_DWORD *)&v59[28] = v16;
    *(_OWORD *)&v60[8] = *(_OWORD *)&v52.value;
    uint64_t v32 = *(void *)a1 + 96 * (v31 - 1);
    *(void *)int v60 = v17;
    *(void *)&v60[24] = v52.epoch;
    if (CombineEditSegmentsIfPossible(v32, (uint64_t)time1, v32)) {
      return 0;
    }
    signed int v31 = *(_DWORD *)(a1 + 8);
  }
  uint64_t result = InsertUninitializedEditsIntoTrack((char **)a1, v31, 1u);
  if (!result)
  {
    uint64_t v30 = *(void *)a1 + 96 * (int)v18;
    goto LABEL_23;
  }
  return result;
}

uint64_t MovieTrackFragmentInsertMediaSegment(uint64_t a1, _OWORD *a2, long long *a3)
{
  if ((*((_DWORD *)a3 + 3) & 0x1D) != 1) {
    return 4294954516;
  }
  *(_OWORD *)CMTimeRange time1 = *a3;
  *(void *)&time1[16] = *((void *)a3 + 2);
  long long v9 = *MEMORY[0x1E4F1FA48];
  *(void *)&long long v10 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  if (CMTimeCompare((CMTime *)time1, (CMTime *)&v9) < 0) {
    return 4294954516;
  }
  long long v6 = a2[1];
  *(_OWORD *)CMTimeRange time1 = *a2;
  *(_OWORD *)&time1[16] = v6;
  long long v13 = a2[2];
  long long v7 = a3[1];
  long long v9 = *a3;
  long long v10 = v7;
  long long v11 = a3[2];
  return InsertMediaSegmentIntoTrack(a1 + 784, (uint64_t)time1, (uint64_t)&v9);
}

uint64_t MovieTrackScaleSegment(CMTime *a1, uint64_t a2, long long *a3, uint64_t a4)
{
  long long v36 = *a3;
  CMTimeEpoch v37 = *((void *)a3 + 2);
  *(_OWORD *)&v35.int64_t value = *(long long *)((char *)a3 + 24);
  v35.CMTimeEpoch epoch = *((void *)a3 + 5);
  *(_OWORD *)&v34.int64_t value = *(_OWORD *)a4;
  v34.CMTimeEpoch epoch = *(void *)(a4 + 16);
  long long v33 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&v41.int64_t value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v7 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  v41.CMTimeEpoch epoch = v7;
  memset(&v40, 0, sizeof(v40));
  *(_OWORD *)&lhs.start.int64_t value = *a3;
  lhs.start.CMTimeEpoch epoch = *((void *)a3 + 2);
  CMTime rhs = *(CMTime *)((unsigned char *)a3 + 1);
  CMTimeAdd(&v40, &lhs.start, &rhs);
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)&v34.value;
  lhs.start.CMTimeEpoch epoch = v34.epoch;
  double Seconds = CMTimeGetSeconds(&lhs.start);
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)&v35.value;
  lhs.start.CMTimeEpoch epoch = v35.epoch;
  double v9 = CMTimeGetSeconds(&lhs.start);
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)&v35.value;
  lhs.start.CMTimeEpoch epoch = v35.epoch;
  CMTime rhs = v34;
  if (!CMTimeCompare(&lhs.start, &rhs)) {
    goto LABEL_32;
  }
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)&v35.value;
  lhs.start.CMTimeEpoch epoch = v35.epoch;
  *(_OWORD *)&rhs.int64_t value = v33;
  rhs.CMTimeEpoch epoch = v7;
  if (CMTimeCompare(&lhs.start, &rhs) < 1) {
    return 4294954516;
  }
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)&v34.value;
  lhs.start.CMTimeEpoch epoch = v34.epoch;
  *(_OWORD *)&rhs.int64_t value = v33;
  rhs.CMTimeEpoch epoch = v7;
  if (CMTimeCompare(&lhs.start, &rhs) < 1) {
    return 4294954516;
  }
  *(_OWORD *)&lhs.start.int64_t value = v36;
  lhs.start.CMTimeEpoch epoch = v37;
  *(_OWORD *)&rhs.int64_t value = v33;
  rhs.CMTimeEpoch epoch = v7;
  if (CMTimeCompare(&lhs.start, &rhs) < 0) {
    return 4294954516;
  }
  int v10 = *(_DWORD *)(a2 + 816);
  BOOL v11 = __OFSUB__(v10, 1);
  int v12 = v10 - 1;
  if (v12 < 0 != v11) {
    return 4294954516;
  }
  long long v13 = (void *)(a2 + 808);
  long long v14 = (_OWORD *)(*(void *)(a2 + 808) + 96 * v12);
  long long v15 = v14[3];
  long long v16 = v14[5];
  *(_OWORD *)&lhs.start.CMTimeEpoch epoch = v14[4];
  *(_OWORD *)&lhs.duration.CMTimeScale timescale = v16;
  *(_OWORD *)&lhs.start.int64_t value = v15;
  CMTimeRangeGetEnd(&v41, &lhs);
  *(_OWORD *)&lhs.start.int64_t value = v36;
  lhs.start.CMTimeEpoch epoch = v37;
  CMTime rhs = v41;
  if ((CMTimeCompare(&lhs.start, &rhs) & 0x80000000) == 0)
  {
LABEL_32:
    MovieTrackInvalidateEnhancedGaplessInfo(a2);
    *(_OWORD *)&lhs.start.int64_t value = *a3;
    lhs.start.CMTimeEpoch epoch = *((void *)a3 + 2);
    NoteEditSegmentModification((uint64_t)a1, a2, &lhs.start, 0);
    UpdateDurationsForEditSegmentChange(a1, a2);
    return 0;
  }
  *(_OWORD *)&lhs.start.int64_t value = v36;
  lhs.start.CMTimeEpoch epoch = v37;
  int EditIndexStartingAtTimeInTrackSplitEditIfNecessary = FindEditIndexStartingAtTimeInTrackSplitEditIfNecessary(a2 + 808, &lhs.start);
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary < 0) {
    return 4294954516;
  }
  int v18 = EditIndexStartingAtTimeInTrackSplitEditIfNecessary;
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary >= *(_DWORD *)(a2 + 816)) {
    return 4294954516;
  }
  lhs.CMTime start = v40;
  CMTime rhs = v41;
  if ((CMTimeCompare(&lhs.start, &rhs) & 0x80000000) == 0)
  {
    int v19 = *(_DWORD *)(a2 + 816);
    goto LABEL_13;
  }
  lhs.CMTime start = v40;
  int v20 = FindEditIndexStartingAtTimeInTrackSplitEditIfNecessary(a2 + 808, &lhs.start);
  if (v20 < 0) {
    return 4294954516;
  }
  int v19 = v20;
  if (v20 >= *(_DWORD *)(a2 + 816)) {
    return 4294954516;
  }
LABEL_13:
  if (v18 == v19 - 1
    && (uint64_t v21 = *v13 + 96 * v18,
        long long v22 = *(_OWORD *)(v21 + 72),
        lhs.start.CMTimeEpoch epoch = *(void *)(v21 + 88),
        *(_OWORD *)&lhs.start.int64_t value = v22,
        CMTime rhs = v35,
        !CMTimeCompare(&lhs.start, &rhs)))
  {
    uint64_t v29 = *v13 + 96 * v18;
    *(_OWORD *)(v29 + 72) = *(_OWORD *)&v34.value;
    *(void *)(v29 + 88) = v34.epoch;
  }
  else
  {
    int v23 = v19 - v18;
    if (v19 > v18)
    {
      uint64_t v24 = 96 * v18 + 72;
      double v25 = Seconds / v9;
      do
      {
        uint64_t v26 = *v13 + v24;
        long long v27 = *(_OWORD *)v26;
        rhs.CMTimeEpoch epoch = *(void *)(v26 + 16);
        *(_OWORD *)&rhs.int64_t value = v27;
        CMTimeMultiplyByFloat64(&lhs.start, &rhs, v25);
        long long v28 = *(_OWORD *)&lhs.start.value;
        *(void *)(v26 + 16) = lhs.start.epoch;
        *(_OWORD *)uint64_t v26 = v28;
        v24 += 96;
        --v23;
      }
      while (v23);
    }
  }
  *(_OWORD *)&lhs.start.int64_t value = v36;
  lhs.start.CMTimeEpoch epoch = v37;
  UpdateTrackStartTimes(a2 + 808, v18, (long long *)&lhs.start.value);
  if (v18 < 1
    || v18 >= *(_DWORD *)(a2 + 816)
    || !CombineEditSegmentsIfPossible(*v13 + 96 * (v18 - 1), *v13 + 96 * v18, *v13 + 96 * (v18 - 1))|| (uint64_t result = DeleteEditsFromTrack(a2 + 808, v18, 1), --v19, !result))
  {
    if (v19 < 1
      || v19 >= *(_DWORD *)(a2 + 816)
      || !CombineEditSegmentsIfPossible(*v13 + 96 * (v19 - 1), *v13 + 96 * v19, *v13 + 96 * (v19 - 1))|| (uint64_t result = DeleteEditsFromTrack(a2 + 808, v19, 1), --v19, !result))
    {
      int v31 = *(_DWORD *)(a2 + 816);
      if (v19 >= v31) {
        int v32 = v31 - 1;
      }
      else {
        int v32 = v19;
      }
      DeleteEditsWithZeroDuration(a2 + 808, v18 - (v18 > 0), v32);
      goto LABEL_32;
    }
  }
  return result;
}

uint64_t MovieTrackDeleteSegment(CMTime *a1, uint64_t a2, uint64_t a3)
{
  CMTime v9 = *(CMTime *)a3;
  CMTime v8 = *(CMTime *)(a3 + 24);
  uint64_t v6 = DeleteTrackSegment(a2 + 808, (uint64_t)&v9, &v8);
  if (!v6)
  {
    MovieTrackInvalidateEnhancedGaplessInfo(a2);
    CMTime v9 = *(CMTime *)a3;
    NoteEditSegmentModification((uint64_t)a1, a2, &v9, 0);
    UpdateDurationsForEditSegmentChange(a1, a2);
  }
  return v6;
}

uint64_t DeleteTrackSegment(uint64_t a1, uint64_t a2, CMTime *a3)
{
  CMTime v28 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  long long v24 = *(_OWORD *)&v28.value;
  CMTimeEpoch epoch = v28.epoch;
  memset(&v27, 0, sizeof(v27));
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)a2;
  lhs.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
  CMTime rhs = *a3;
  CMTimeAdd(&v27, &lhs.start, &rhs);
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)&a3->value;
  lhs.start.CMTimeEpoch epoch = a3->epoch;
  *(_OWORD *)&rhs.int64_t value = v24;
  rhs.CMTimeEpoch epoch = epoch;
  if (!CMTimeCompare(&lhs.start, &rhs)) {
    return 0;
  }
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)&a3->value;
  lhs.start.CMTimeEpoch epoch = a3->epoch;
  *(_OWORD *)&rhs.int64_t value = v24;
  rhs.CMTimeEpoch epoch = epoch;
  if (CMTimeCompare(&lhs.start, &rhs) < 1) {
    return 4294954516;
  }
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)a2;
  lhs.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
  *(_OWORD *)&rhs.int64_t value = v24;
  rhs.CMTimeEpoch epoch = epoch;
  if (CMTimeCompare(&lhs.start, &rhs) < 0) {
    return 4294954516;
  }
  int v7 = *(_DWORD *)(a1 + 8);
  BOOL v8 = __OFSUB__(v7, 1);
  int v9 = v7 - 1;
  if (v9 < 0 != v8) {
    return 0;
  }
  int v10 = (_OWORD *)(*(void *)a1 + 96 * v9);
  long long v11 = v10[3];
  long long v12 = v10[5];
  *(_OWORD *)&lhs.start.CMTimeEpoch epoch = v10[4];
  *(_OWORD *)&lhs.duration.CMTimeScale timescale = v12;
  *(_OWORD *)&lhs.start.int64_t value = v11;
  CMTimeRangeGetEnd(&v28, &lhs);
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)a2;
  lhs.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
  CMTime rhs = v28;
  if ((CMTimeCompare(&lhs.start, &rhs) & 0x80000000) == 0) {
    return 0;
  }
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)a2;
  lhs.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
  signed int EditIndexStartingAtTimeInTrackSplitEditIfNecessary = FindEditIndexStartingAtTimeInTrackSplitEditIfNecessary(a1, &lhs.start);
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary < 0) {
    return 4294954516;
  }
  unsigned int v14 = EditIndexStartingAtTimeInTrackSplitEditIfNecessary;
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary >= *(_DWORD *)(a1 + 8)) {
    return 4294954516;
  }
  lhs.CMTime start = v27;
  CMTime rhs = v28;
  if (CMTimeCompare(&lhs.start, &rhs) < 0)
  {
    lhs.CMTime start = v27;
    int v15 = FindEditIndexStartingAtTimeInTrackSplitEditIfNecessary(a1, &lhs.start);
    if ((v15 & 0x80000000) == 0 && v15 < *(_DWORD *)(a1 + 8)) {
      goto LABEL_13;
    }
    return 4294954516;
  }
  int v15 = *(_DWORD *)(a1 + 8);
LABEL_13:
  uint64_t v17 = DeleteEditsFromTrack(a1, v14, (int)(v15 - v14));
  if (v17) {
    return v17;
  }
  *(_OWORD *)&lhs.start.int64_t value = *(_OWORD *)a2;
  lhs.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
  UpdateTrackStartTimes(a1, v14, (long long *)&lhs.start.value);
  if (v14)
  {
    int v18 = *(_DWORD *)(a1 + 8);
    if ((int)v14 >= v18) {
      goto LABEL_19;
    }
    uint64_t v19 = *(void *)a1 + 96 * (v14 - 1);
    if (CombineEditSegmentsIfPossible(v19, *(void *)a1 + 96 * v14, v19))
    {
      uint64_t v17 = DeleteEditsFromTrack(a1, v14, 1);
      if (v17) {
        return v17;
      }
    }
  }
  int v18 = *(_DWORD *)(a1 + 8);
LABEL_19:
  uint64_t v20 = (v18 - 1);
  if (v18 < 1 || (*(_DWORD *)(*(void *)a1 + 96 * v20 + 12) & 0x1D) == 1)
  {
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v16 = DeleteEditsFromTrack(a1, v20, 1);
    int v18 = *(_DWORD *)(a1 + 8);
  }
  if ((int)v14 >= v18) {
    int v21 = v18 - 1;
  }
  else {
    int v21 = v14;
  }
  if (v14) {
    uint64_t v22 = v14 - 1;
  }
  else {
    uint64_t v22 = 0;
  }
  if (v21 >= (int)v22) {
    DeleteEditsWithZeroDuration(a1, v22, v21);
  }
  return v16;
}

uint64_t MovieTrackFragmentDeleteSegment(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  uint64_t v5 = *((void *)a2 + 2);
  CMTime v3 = *(CMTime *)((unsigned char *)a2 + 1);
  return DeleteTrackSegment(a1 + 784, (uint64_t)&v4, &v3);
}

uint64_t MovieInformationSetParsedIFFItemInformation(uint64_t a1, CFTypeRef cf)
{
  if (!cf || *(void *)(a1 + 200))
  {
    return FigSignalErrorAt();
  }
  else
  {
    *(void *)(a1 + 200) = CFRetain(cf);
    return 0;
  }
}

uint64_t MovieInformationCopyIFFItemInformation(uint64_t a1, void *a2)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 200);
  if (v3) {
    CFTypeRef v3 = CFRetain(v3);
  }
  *a2 = v3;
  return 0;
}

void MovieInformationSetAssetAnalysisReporter(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2 = *(const void **)(a1 + 64);
  *(void *)(a1 + 64) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t MovieInformationGetAssetAnalysisReporter(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t NEW_findSampleInTable(uint64_t a1, uint64_t (*a2)(void), uint64_t a3, int a4, _DWORD *a5)
{
  int v10 = ((uint64_t (*)(uint64_t, void))a2)(a1, *a5);
  uint64_t result = 1;
  if (v10 < a4) {
    int v12 = 1;
  }
  else {
    int v12 = -1;
  }
  if (v10 != a4)
  {
    int v13 = v10;
    do
    {
      uint64_t v14 = (int)*a5;
      if (v10 >= a4)
      {
        uint64_t result = 0;
        if (v13 < a4 || !v14) {
          return result;
        }
      }
      else
      {
        uint64_t result = 0;
        if (v13 > a4 || v14 + 1 == a3) {
          return result;
        }
      }
      *a5 = v14 + v12;
      int v13 = a2(a1);
    }
    while (v13 != a4);
    return 1;
  }
  return result;
}

uint64_t FragmentCursorEnsureAccessorAndCopySampleGroupDescription(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v11 = 0;
  uint64_t v5 = *a2;
  if (*a2)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 200) + 104);
    if (!v7) {
      return v11;
    }
    int v9 = MovieSampleGroupCollectionLookupAndRetainSampleGroup(v7, a3, a4);
    if (!v9) {
      return v11;
    }
    uint64_t v6 = v9;
    if (MovieSampleGroupAccessorCreate(v9, a2))
    {
LABEL_8:
      CFRelease(v6);
      return v11;
    }
    uint64_t v5 = *a2;
  }
  MovieSampleGroupAccessorCopyDescriptionForSample(v5, (*(_DWORD *)(a1 + 80) - *(_DWORD *)(*(void *)(a1 + 208) + 16) + 1), &v11);
  if (v6) {
    goto LABEL_8;
  }
  return v11;
}

uint64_t PostDeferredMovieInformationNotification()
{
  return CMNotificationCenterPostNotification();
}

uint64_t RegisterMoviePerTrackInfoType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sMoviePerTrackInfoID = result;
  return result;
}

void InitMoviePerTrackInfo(uint64_t a1)
{
}

void FinalizeMoviePerTrackInfo(uint64_t a1)
{
  ReleaseSampleDescriptionInfoArray(a1);
  ReleaseDataReferenceInfoArray(a1);
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 48) = 0;
  }
  CFTypeRef v3 = *(const void **)(a1 + 856);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 856) = 0;
  }
  long long v4 = *(const void **)(a1 + 848);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 848) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 72);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 72) = 0;
  }
  uint64_t v6 = *(const void **)(a1 + 80);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 80) = 0;
  }
  uint64_t v7 = *(void *)(a1 + 728);
  if (v7)
  {
    FreeFragmentInfos(v7);
    free(*(void **)(a1 + 728));
    *(void *)(a1 + 728) = 0;
  }
  FreeAllSampleTables((void *)a1);
  BOOL v8 = *(const void **)(a1 + 696);
  if (v8) {
    CFRelease(v8);
  }
  int v9 = *(const void **)(a1 + 640);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 640) = 0;
  }
  free(*(void **)(a1 + 808));
  *(void *)(a1 + 808) = 0;
  int v10 = *(const void **)(a1 + 832);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 832) = 0;
  }
  uint64_t v11 = *(const void **)(a1 + 888);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 888) = 0;
  }
  if (*(void *)(a1 + 32))
  {
    FigSimpleMutexDestroy();
    *(void *)(a1 + 32) = 0;
  }
  if (*(unsigned char *)(a1 + 897))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterUnregisterForBarrierSupport();
    *(unsigned char *)(a1 + 897) = 0;
  }
  TrackFragmentBuilderRelease(*(const __CFAllocator ***)(a1 + 768));
  *(void *)(a1 + 768) = 0;
  free(*(void **)(a1 + 784));
  *(void *)(a1 + 784) = 0;
}

uint64_t RegisterMovieInformationType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sMovieInformationID = result;
  return result;
}

double InitMovieInformation(_OWORD *a1)
{
  double result = 0.0;
  a1[21] = 0u;
  a1[22] = 0u;
  a1[19] = 0u;
  a1[20] = 0u;
  a1[17] = 0u;
  a1[18] = 0u;
  a1[15] = 0u;
  a1[16] = 0u;
  a1[13] = 0u;
  a1[14] = 0u;
  a1[11] = 0u;
  a1[12] = 0u;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

uint64_t FinalizeMovieInformation(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 304);
  if (v3 >= 1)
  {
    for (uint64_t i = 0; i < v3; ++i)
    {
      uint64_t v5 = *(const void **)(*(void *)(a1 + 320) + 8 * i);
      if (v5)
      {
        CFRelease(v5);
        *(void *)(*(void *)(a1 + 320) + 8 * i) = 0;
        uint64_t v3 = *(void *)(a1 + 304);
      }
    }
  }
  free(*(void **)(a1 + 320));
  free(*(void **)(a1 + 344));
  uint64_t v6 = *(const void **)(a1 + 56);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 56) = 0;
  }
  uint64_t v7 = *(const void **)(a1 + 64);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 64) = 0;
  }
  BOOL v8 = *(const void **)(a1 + 352);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 352) = 0;
  }
  int v9 = *(const void **)(a1 + 360);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 360) = 0;
  }
  int v10 = *(const void **)(a1 + 200);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 200) = 0;
  }
  if (*(void *)(a1 + 32))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterUnregisterForBarrierSupport();
    uint64_t v11 = *(NSObject **)(a1 + 32);
    if (v11)
    {
      dispatch_release(v11);
      *(void *)(a1 + 32) = 0;
    }
  }

  return FigReadWriteLockDestroy();
}

void SampleGroupDeepCopyApplier(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef cfa = 0;
  CFAllocatorRef v4 = CFGetAllocator(cf);
  if (!MovieSampleGroupCreateDeepCopy(v4, a1, &cfa)) {
    MovieSampleGroupCollectionAddSampleGroup((uint64_t)cf, (uint64_t)cfa);
  }
  if (cfa) {
    CFRelease(cfa);
  }
}

void UpgradeTo64BitChunkOffsets(uint64_t a1, int a2, size_t dataLength)
{
  long long dataPointerOut = 0;
  CMBlockBufferRef theBuffer = 0;
  int v4 = *(_DWORD *)(a1 + 360);
  if (v4)
  {
    OSStatus v5 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 8 * v4, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 8 * v4, 1u, &theBuffer);
    CMBlockBufferRef v6 = theBuffer;
    if (v5) {
      goto LABEL_14;
    }
    CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    if (v4 >= 1)
    {
      uint64_t v7 = 0;
      do
      {
        unint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 616))(a1, v7);
        int v9 = dataPointerOut;
        *(void *)long long dataPointerOut = bswap64(v8);
        long long dataPointerOut = v9 + 8;
        uint64_t v7 = (v7 + 1);
      }
      while (v4 != v7);
    }
    *(_DWORD *)(a1 + 384) = v4;
    int v10 = theBuffer;
    if (theBuffer) {
      int v10 = (void *)CFRetain(theBuffer);
    }
    *(void *)(a1 + 392) = v10;
  }
  *(_DWORD *)(a1 + 360) = 0;
  uint64_t v11 = *(const void **)(a1 + 368);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 368) = 0;
  }
  int v12 = *(const void **)(a1 + 376);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 376) = 0;
  }
  *(void *)(a1 + 616) = GetChunkOffset_co64;
  *(void *)(a1 + 624) = GetChunkCount_co64;
  *(void *)(a1 + 632) = GetChunkTable_co64;
  CMBlockBufferRef v6 = theBuffer;
LABEL_14:
  if (v6) {
    CFRelease(v6);
  }
}

uint64_t AddFragmentRunSampleSizes(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 48);
  if ((v3 & 2) != 0)
  {
    if (*(int *)(a2 + 36) >= 1)
    {
      uint64_t v6 = 0;
      uint64_t v7 = a2 + 4 * kPerSampleInfo_SizeIndex[v3] + 52;
      uint64_t v8 = 4 * kPerSampleInfo_SizeInInt32s[v3];
      do
      {
        uint64_t result = CMByteStreamAppend();
        if (result) {
          break;
        }
        ++v6;
        v7 += v8;
      }
      while (v6 < *(int *)(a2 + 36));
    }
  }
  else if (*(int *)(a2 + 36) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t result = CMByteStreamAppend();
      if (result) {
        break;
      }
      ++v4;
    }
    while (v4 < *(int *)(a2 + 36));
  }
  return result;
}

void MakeReadyToWrite_stts(uint64_t a1)
{
  CMBlockBufferRef blockBufferOut = 0;
  if (!*(void *)(a1 + 424))
  {
    if (!CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0x10u, 0, &blockBufferOut))
    {
      uint64_t v2 = *(OpaqueCMBlockBuffer **)(a1 + 416);
      if (v2)
      {
        uint64_t destination = 0;
        size_t v3 = 8 * *(int *)(a1 + 408) - 8;
        CMBlockBufferCopyDataBytes(v2, v3, 8uLL, &destination);
        if (*(int *)(a1 + 408) >= 2) {
          CMBlockBufferAppendBufferReference(blockBufferOut, *(CMBlockBufferRef *)(a1 + 416), 0, v3, 0);
        }
        if (CMByteStreamCreateWritableForBlockBuffer()) {
          goto LABEL_13;
        }
        CMByteStreamAppend();
        goto LABEL_9;
      }
      if (!CMByteStreamCreateWritableForBlockBuffer())
      {
LABEL_9:
        uint64_t v4 = *(const void **)(a1 + 416);
        CMBlockBufferRef v5 = blockBufferOut;
        *(void *)(a1 + 416) = blockBufferOut;
        if (v5) {
          CFRetain(v5);
        }
        if (v4) {
          CFRelease(v4);
        }
      }
    }
LABEL_13:
    if (blockBufferOut) {
      CFRelease(blockBufferOut);
    }
  }
}

void MakeReadyToWrite_ctts(uint64_t a1)
{
  CMBlockBufferRef blockBufferOut = 0;
  if (!*(void *)(a1 + 472))
  {
    if (!CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0x10u, 0, &blockBufferOut))
    {
      uint64_t v2 = *(OpaqueCMBlockBuffer **)(a1 + 464);
      if (v2)
      {
        uint64_t destination = 0;
        size_t v3 = 8 * *(int *)(a1 + 456) - 8;
        CMBlockBufferCopyDataBytes(v2, v3, 8uLL, &destination);
        if (*(int *)(a1 + 456) >= 2) {
          CMBlockBufferAppendBufferReference(blockBufferOut, *(CMBlockBufferRef *)(a1 + 464), 0, v3, 0);
        }
        if (CMByteStreamCreateWritableForBlockBuffer()) {
          goto LABEL_14;
        }
        CMByteStreamAppend();
        goto LABEL_9;
      }
      if (!CMByteStreamCreateWritableForBlockBuffer())
      {
LABEL_9:
        uint64_t v4 = *(const void **)(a1 + 464);
        CMBlockBufferRef v5 = blockBufferOut;
        *(void *)(a1 + 464) = blockBufferOut;
        if (v5) {
          CFRetain(v5);
        }
        if (v4) {
          CFRelease(v4);
        }
        *(unsigned char *)(a1 + 720) = 1;
      }
    }
LABEL_14:
    if (blockBufferOut) {
      CFRelease(blockBufferOut);
    }
  }
}

uint64_t WriteTimeToSampleNumEntry(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v10 = 0;
  v11[0] = bswap32(a2);
  v11[1] = bswap32(a3);
  uint64_t v5 = *(void *)(a1 + 424);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _DWORD *, uint64_t *))(v7 + 16);
  if (v8) {
    return v8(v5, 8, 8 * a4, v11, &v10);
  }
  else {
    return 4294954514;
  }
}

void DeepCopySampleGroupDescriptionArraysApplierFunction(const void *a1, uint64_t a2, void *cf)
{
  int64_t value = 0;
  CFAllocatorRef v6 = CFGetAllocator(cf);
  if (MovieSampleGroupCreateDescriptionArrayDeepCopy(v6, a2, &value)) {
    FigSignalErrorAt();
  }
  else {
    CFDictionaryAddValue((CFMutableDictionaryRef)cf, a1, value);
  }
  if (value) {
    CFRelease(value);
  }
}

uint64_t AddSampleToTimeToSampleTable(uint64_t a1, int a2, uint64_t a3)
{
  if (a3 != (int)a3)
  {
    return FigSignalErrorAt();
  }
  uint64_t v20 = 0;
  MakeReadyToWrite_stts(a1);
  int v6 = *(_DWORD *)(a1 + 408);
  if (!v6)
  {
    int v7 = 0;
    unsigned int v9 = 0;
    BOOL v11 = a3 == -1;
    unsigned int v10 = -1;
LABEL_6:
    int v6 = v7;
    goto LABEL_7;
  }
  int v7 = v6 - 1;
  unint64_t destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 416), 8 * (v6 - 1), 8uLL, &destination);
  int v8 = destination;
  unsigned int v9 = bswap32(destination);
  unint64_t destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 416), 8 * (v6 - 1), 8uLL, &destination);
  unsigned int v10 = bswap32(HIDWORD(destination));
  BOOL v11 = v10 == a3;
  if (!v8) {
    goto LABEL_6;
  }
LABEL_7:
  if (v11) {
    unsigned int v12 = v9;
  }
  else {
    unsigned int v12 = 0;
  }
  if (v11) {
    int v13 = v7;
  }
  else {
    int v13 = v6;
  }
  unsigned int v14 = v12 + a2;
  if (!v14) {
    goto LABEL_21;
  }
  if (!v11) {
    unsigned int v10 = a3;
  }
  unint64_t destination = _byteswap_uint64(__PAIR64__(v14, v10));
  uint64_t v15 = *(void *)(a1 + 424);
  uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v16) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  int v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *, uint64_t *))(v17 + 16);
  if (!v18) {
    return 4294954514;
  }
  uint64_t result = v18(v15, 8, 8 * v13, &destination, &v20);
  if (!result)
  {
LABEL_21:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 408) = v13 + 1;
  }
  return result;
}

uint64_t AddSampleToCompositionOffsetTable(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (a3 != (int)a3)
  {
    return FigSignalErrorAt();
  }
  uint64_t v16 = 0;
  MakeReadyToWrite_ctts(a1);
  int v6 = *(_DWORD *)(a1 + 456);
  if (!v6) {
    goto LABEL_13;
  }
  unint64_t destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 464), 8 * (v6 - 1), 8uLL, &destination);
  unsigned int v7 = destination;
  unint64_t destination = 0;
  CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 464), 8 * (v6 - 1), 8uLL, &destination);
  if (*(_DWORD *)(a1 + 456))
  {
    unsigned int v8 = bswap32(HIDWORD(destination));
    unsigned int v9 = bswap32(v7) + a2;
    if (v7) {
      int v10 = v6;
    }
    else {
      int v10 = v6 - 1;
    }
    if (v8 == v3)
    {
      LODWORD(v3) = v8;
      a2 = v9;
      --v6;
    }
    else
    {
      int v6 = v10;
    }
    if (!a2) {
      goto LABEL_19;
    }
    goto LABEL_14;
  }
  if (v7)
  {
LABEL_13:
    if (!a2)
    {
LABEL_19:
      uint64_t result = 0;
      *(_DWORD *)(a1 + 456) = v6 + 1;
      return result;
    }
    goto LABEL_14;
  }
  --v6;
  if (!a2) {
    goto LABEL_19;
  }
LABEL_14:
  unint64_t destination = _byteswap_uint64(__PAIR64__(a2, v3));
  uint64_t v11 = *(void *)(a1 + 472);
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  unsigned int v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *, uint64_t *))(v13 + 16);
  if (!v14) {
    return 4294954514;
  }
  uint64_t result = v14(v11, 8, 8 * v6, &destination, &v16);
  if (!result) {
    goto LABEL_19;
  }
  return result;
}

uint64_t AddSampleGroupForGroupType(void *cf, unint64_t a2, unsigned int a3, int a4, unsigned int a5, int a6, int a7, size_t a8, const void *a9, unsigned char *a10)
{
  CFTypeRef cfa = 0;
  char v30 = 0;
  CFTypeRef v17 = (CFTypeRef)cf[9];
  if (v17) {
    CFTypeRef v17 = MovieSampleGroupCollectionLookupAndRetainSampleGroup((uint64_t)v17, a2, a3);
  }
  CFTypeRef v32 = v17;
  if (a7) {
    BOOL v19 = v17 == 0;
  }
  else {
    BOOL v19 = 0;
  }
  char v20 = v19;
  if (!v19) {
    goto LABEL_23;
  }
  CFAllocatorRef v21 = CFGetAllocator(cf);
  int v22 = *((_DWORD *)cf + 72);
  uint64_t v23 = cf[91];
  if (v23) {
    v22 += *(_DWORD *)(v23 + 8);
  }
  if (a4)
  {
    uint64_t appended = MovieSampleGroupCreateCompact(v21, a2, a3, &v32);
    if (appended) {
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t appended = MovieSampleGroupCreate(v21, a2, a3, (uint64_t *)&v32);
    if (appended) {
      goto LABEL_37;
    }
  }
  uint64_t appended = MovieTrackAddAndRetainSampleGroupDescriptionArray(cf, a2, &cfa);
  if (appended) {
    goto LABEL_37;
  }
  uint64_t appended = MovieSampleGroupSetDescriptionArray((uint64_t)v32, cfa);
  if (appended) {
    goto LABEL_37;
  }
  uint64_t appended = MovieTrackAddSampleGroup(cf, (uint64_t)v32);
  if (appended) {
    goto LABEL_37;
  }
  if (!(v22 + a6)
    || (uint64_t v25 = MovieSampleGroupAppendSamplesWithDescriptionIndex((uint64_t)v32, v22 + a6, 0), !v25))
  {
    CFTypeRef v17 = v32;
LABEL_23:
    if (!v17)
    {
      BOOL v27 = 0;
LABEL_31:
      uint64_t v25 = 0;
      *a10 = v20 | v27;
      goto LABEL_32;
    }
    uint64_t v29 = 0;
    if (!a7)
    {
      uint64_t v26 = 0;
LABEL_29:
      uint64_t appended = MovieSampleGroupAppendSamplesWithDescriptionIndex((uint64_t)v17, a5, v26);
      if (!appended)
      {
        BOOL v27 = v30 != 0;
        goto LABEL_31;
      }
      goto LABEL_37;
    }
    uint64_t appended = MovieSampleGroupAddDescription((uint64_t)v17, a8, a9, (uint64_t)&v29, &v30);
    if (!appended)
    {
      CFTypeRef v17 = v32;
      uint64_t v26 = v29;
      goto LABEL_29;
    }
LABEL_37:
    uint64_t v25 = appended;
  }
LABEL_32:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v32) {
    CFRelease(v32);
  }
  return v25;
}

uint64_t CombineEditSegmentsIfPossible(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v38 = *(_OWORD *)(a1 + 72);
  CMTimeEpoch v39 = *(void *)(a1 + 88);
  CMTime v37 = *(CMTime *)(a2 + 72);
  long long v35 = *(_OWORD *)(a1 + 24);
  CMTimeEpoch v36 = *(void *)(a1 + 40);
  CMTime v34 = *(CMTime *)(a2 + 24);
  *(_OWORD *)&time1.start.int64_t value = *(_OWORD *)(a1 + 72);
  time1.start.CMTimeEpoch epoch = *(void *)(a1 + 88);
  CMTime time2 = *(CMTime *)(a1 + 24);
  int32_t v6 = CMTimeCompare(&time1.start, &time2);
  time1.CMTime start = v37;
  CMTime time2 = v34;
  int32_t v7 = CMTimeCompare(&time1.start, &time2);
  CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  CMTime v32 = time2;
  long long v8 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&time1.start.int64_t value = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&time1.start.CMTimeEpoch epoch = v8;
  *(_OWORD *)&time1.duration.CMTimeScale timescale = *(_OWORD *)(a1 + 80);
  CMTimeRangeGetEnd(&v28, &time1);
  *(_OWORD *)&time1.start.int64_t value = *(_OWORD *)(a2 + 48);
  time1.start.CMTimeEpoch epoch = *(void *)(a2 + 64);
  if (CMTimeCompare(&v28, &time1.start)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 12) & 1) == 0 && (*(unsigned char *)(a2 + 12) & 1) == 0)
  {
    *(_OWORD *)&time1.start.int64_t value = v38;
    time1.start.CMTimeEpoch epoch = v39;
    CMTime rhs = v37;
    CMTimeAdd(&time2, &time1.start, &rhs);
    *(_OWORD *)a3 = *(_OWORD *)a1;
    long long v10 = *(_OWORD *)(a1 + 16);
    long long v11 = *(_OWORD *)(a1 + 32);
    long long v12 = *(_OWORD *)(a1 + 48);
    *(void *)(a3 + 64) = *(void *)(a1 + 64);
    *(_OWORD *)(a3 + 32) = v11;
    *(_OWORD *)(a3 + 48) = v12;
    *(_OWORD *)(a3 + 16) = v10;
    *(CMTime *)(a3 + 72) = time2;
    return 1;
  }
  long long v13 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&time1.start.int64_t value = *(_OWORD *)a1;
  *(_OWORD *)&time1.start.CMTimeEpoch epoch = v13;
  *(_OWORD *)&time1.duration.CMTimeScale timescale = *(_OWORD *)(a1 + 32);
  CMTimeRangeGetEnd(&v26, &time1);
  *(_OWORD *)&time1.start.int64_t value = *(_OWORD *)a2;
  time1.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
  int32_t v14 = CMTimeCompare(&v26, &time1.start);
  uint64_t result = 0;
  if (!v14 && (v6 != 0) == (v7 != 0))
  {
    if (!v6) {
      goto LABEL_12;
    }
    if (!v7) {
      goto LABEL_12;
    }
    *(_OWORD *)&time1.start.int64_t value = v38;
    time1.start.CMTimeEpoch epoch = v39;
    double Seconds = CMTimeGetSeconds(&time1.start);
    time1.CMTime start = v34;
    double v16 = Seconds * CMTimeGetSeconds(&time1.start);
    time1.CMTime start = v37;
    double v17 = CMTimeGetSeconds(&time1.start);
    *(_OWORD *)&time1.start.int64_t value = v35;
    time1.start.CMTimeEpoch epoch = v36;
    if (v16 == v17 * CMTimeGetSeconds(&time1.start))
    {
LABEL_12:
      *(_OWORD *)&time1.start.int64_t value = v38;
      time1.start.CMTimeEpoch epoch = v39;
      CMTime rhs = v37;
      CMTimeAdd(&time2, &time1.start, &rhs);
      *(_OWORD *)&time1.start.int64_t value = v35;
      time1.start.CMTimeEpoch epoch = v36;
      CMTime rhs = v34;
      CMTimeAdd(&v32, &time1.start, &rhs);
      long long v18 = *(_OWORD *)(a1 + 48);
      *(_OWORD *)&time1.duration.CMTimeScale timescale = *(_OWORD *)(a1 + 32);
      long long v30 = v18;
      uint64_t v19 = *(void *)(a1 + 64);
      long long v20 = *(_OWORD *)(a1 + 16);
      *(_OWORD *)&time1.start.int64_t value = *(_OWORD *)a1;
      time1.start.CMTimeEpoch epoch = v20;
      *(CMTime *)&v31[8] = time2;
      *(void *)int v31 = v19;
      time1.duration = v32;
      long long v21 = *MEMORY[0x1E4F1F9F8];
      uint64_t v22 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
      *(void *)(a1 + 16) = v22;
      *(_OWORD *)a1 = v21;
      *(void *)(a2 + 16) = v22;
      *(_OWORD *)a2 = v21;
      long long v23 = *(_OWORD *)&time1.start.epoch;
      *(_OWORD *)a3 = *(_OWORD *)&time1.start.value;
      *(_OWORD *)(a3 + 16) = v23;
      long long v24 = *(_OWORD *)&v31[16];
      *(_OWORD *)(a3 + 64) = *(_OWORD *)v31;
      *(_OWORD *)(a3 + 80) = v24;
      long long v25 = v30;
      uint64_t result = 1;
      *(_OWORD *)(a3 + 32) = *(_OWORD *)&time1.duration.timescale;
      *(_OWORD *)(a3 + 48) = v25;
      return result;
    }
    return 0;
  }
  return result;
}

uint64_t InsertUninitializedEditsIntoTrack(char **a1, unsigned int a2, unsigned int a3)
{
  if ((a2 & 0x80000000) != 0) {
    return 4294954516;
  }
  int v5 = *((_DWORD *)a1 + 2);
  int v6 = v5 - a2;
  if (v5 < (int)a2) {
    return 4294954516;
  }
  uint64_t v8 = *((int *)a1 + 3);
  if ((int)v8 - v5 >= (int)a3)
  {
    uint64_t v15 = a3;
    if (v6 > 0) {
      memmove(&(*a1)[96 * a2 + 96 * a3], &(*a1)[96 * a2], 96 * v6);
    }
    bzero(&(*a1)[96 * a2], 96 * v15);
    goto LABEL_15;
  }
  if ((int)v8 <= 2147483642)
  {
    int v9 = v8 + 5;
    long long v10 = (char *)malloc_type_calloc(v8 + 5, 0x60uLL, 0x1000040565EDBD2uLL);
    long long v11 = v10;
    long long v12 = *a1;
    if (*a1)
    {
      uint64_t v13 = *((int *)a1 + 2) - (uint64_t)(int)a2;
      if (a2)
      {
        memmove(v10, v12, 96 * a2);
        long long v12 = *a1;
      }
      if ((int)v13 >= 1)
      {
        memmove(&v11[96 * a2 + 96 * a3], &v12[96 * a2], 96 * v13);
        long long v12 = *a1;
      }
      free(v12);
    }
    *a1 = v11;
    *((_DWORD *)a1 + 3) = v9;
LABEL_15:
    uint64_t result = 0;
    *((_DWORD *)a1 + 2) += a3;
    return result;
  }

  return FigSignalErrorAt();
}

uint64_t FindEditIndexStartingAtTimeInTrackSplitEditIfNecessary(uint64_t a1, CMTime *a2)
{
  CMTime v33 = *a2;
  int v2 = *(_DWORD *)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = 0;
  int v6 = v2 - 1;
  if (v2 <= 1) {
    goto LABEL_13;
  }
  while (1)
  {
    int v7 = ((int)v5 + v6) >> 1;
    uint64_t v8 = *(void *)a1 + 96 * v7;
    *(_OWORD *)&v31.start.int64_t value = *(_OWORD *)(v8 + 48);
    v31.start.CMTimeEpoch epoch = *(void *)(v8 + 64);
    memset(&v36, 0, sizeof(v36));
    long long v9 = *(_OWORD *)(v8 + 48);
    long long v10 = *(_OWORD *)(v8 + 80);
    *(_OWORD *)&range.start.CMTimeEpoch epoch = *(_OWORD *)(v8 + 64);
    *(_OWORD *)&range.duration.CMTimeScale timescale = v10;
    *(_OWORD *)&range.start.int64_t value = v9;
    CMTimeRangeGetEnd(&v36, &range);
    range.CMTime start = v33;
    CMTime time2 = v36;
    if (CMTimeCompare(&range.start, &time2) < 1) {
      break;
    }
    uint64_t v5 = (v7 + 1);
LABEL_8:
    if ((int)v5 >= v6) {
      goto LABEL_12;
    }
  }
  range.CMTime start = v33;
  CMTime time2 = v36;
  if (!CMTimeCompare(&range.start, &time2))
  {
    uint64_t v5 = (v7 + 1);
    goto LABEL_12;
  }
  range.CMTime start = v33;
  CMTime time2 = v31.start;
  if (CMTimeCompare(&range.start, &time2) < 0)
  {
    int v6 = v7 - 1;
    goto LABEL_8;
  }
  uint64_t v5 = (((int)v5 + v6) >> 1);
LABEL_12:
  if ((v5 & 0x80000000) == 0)
  {
LABEL_13:
    uint64_t v11 = *(void *)a1 + 96 * v5;
    long long v12 = *(_OWORD *)(v11 + 48);
    range.start.CMTimeEpoch epoch = *(void *)(v11 + 64);
    *(_OWORD *)&range.start.int64_t value = v12;
    *(_OWORD *)&v31.start.int64_t value = *(_OWORD *)&a2->value;
    v31.start.CMTimeEpoch epoch = a2->epoch;
    if (CMTimeCompare(&range.start, &v31.start))
    {
      unsigned int v13 = v5;
      int32_t v14 = (long long *)(*(void *)a1 + 96 * v5);
      CMTime v36 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      CMTime time2 = v36;
      CMTime v33 = v36;
      CMTime rhs = *a2;
      long long v15 = v14[3];
      long long v16 = v14[5];
      *(_OWORD *)&range.start.CMTimeEpoch epoch = v14[4];
      *(_OWORD *)&range.duration.CMTimeScale timescale = v16;
      *(_OWORD *)&range.start.int64_t value = v15;
      long long v17 = *v14;
      long long v18 = v14[2];
      *(_OWORD *)&v31.start.CMTimeEpoch epoch = v14[1];
      *(_OWORD *)&v31.duration.CMTimeScale timescale = v18;
      *(_OWORD *)&v31.start.int64_t value = v17;
      CMTimeMapTimeFromRangeToRange(&v36, &rhs, &range, &v31);
      uint64_t v5 = (v5 + 1);
      if (!InsertUninitializedEditsIntoTrack((char **)a1, v5, 1u))
      {
        uint64_t v19 = *(void *)a1 + 96 * v13;
        *(_OWORD *)&range.start.int64_t value = *(_OWORD *)&a2->value;
        range.start.CMTimeEpoch epoch = a2->epoch;
        long long v20 = *(_OWORD *)(v19 + 48);
        v31.start.CMTimeEpoch epoch = *(void *)(v19 + 64);
        *(_OWORD *)&v31.start.int64_t value = v20;
        CMTimeSubtract(&time2, &range.start, &v31.start);
        range.CMTime start = v36;
        long long v21 = *(_OWORD *)v19;
        v31.start.CMTimeEpoch epoch = *(void *)(v19 + 16);
        *(_OWORD *)&v31.start.int64_t value = v21;
        CMTimeSubtract(&v33, &range.start, &v31.start);
        long long v22 = *(_OWORD *)&a2->value;
        *(void *)(v19 + 160) = a2->epoch;
        *(_OWORD *)(v19 + 144) = v22;
        long long v23 = *(_OWORD *)(v19 + 72);
        v31.start.CMTimeEpoch epoch = *(void *)(v19 + 88);
        *(_OWORD *)&v31.start.int64_t value = v23;
        CMTime rhs = time2;
        CMTimeSubtract(&range.start, &v31.start, &rhs);
        long long v24 = *(_OWORD *)&range.start.value;
        *(void *)(v19 + 184) = range.start.epoch;
        *(_OWORD *)(v19 + 168) = v24;
        long long v25 = *(_OWORD *)&v36.value;
        *(void *)(v19 + 112) = v36.epoch;
        *(_OWORD *)(v19 + 96) = v25;
        long long v26 = *(_OWORD *)(v19 + 24);
        v31.start.CMTimeEpoch epoch = *(void *)(v19 + 40);
        *(_OWORD *)&v31.start.int64_t value = v26;
        CMTime rhs = v33;
        CMTimeSubtract(&range.start, &v31.start, &rhs);
        long long v27 = *(_OWORD *)&range.start.value;
        *(void *)(v19 + 136) = range.start.epoch;
        *(_OWORD *)(v19 + 120) = v27;
        long long v28 = *(_OWORD *)&time2.value;
        *(void *)(v19 + 88) = time2.epoch;
        *(_OWORD *)(v19 + 72) = v28;
        long long v29 = *(_OWORD *)&v33.value;
        *(void *)(v19 + 40) = v33.epoch;
        *(_OWORD *)(v19 + 24) = v29;
        return v5;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v5;
}

uint64_t DeleteEditsFromTrack(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a1 + 8);
  uint64_t v4 = v3 - (a3 + a2);
  if (v3 < a3 + a2) {
    return 4294954516;
  }
  if (v4 >= 1)
  {
    memmove((void *)(*(void *)a1 + 96 * a2), (const void *)(*(void *)a1 + 96 * (a3 + a2)), 96 * v4);
    int v3 = *(_DWORD *)(a1 + 8);
  }
  int v7 = v3 - a3;
  *(_DWORD *)(a1 + 8) = v7;
  bzero((void *)(*(void *)a1 + 96 * v7), 96 * a3);
  return 0;
}

double UpdateTrackStartTimes(uint64_t a1, uint64_t a2, long long *a3)
{
  if (*(int *)(a1 + 8) > a2)
  {
    uint64_t v4 = a2;
    uint64_t v6 = 96 * a2 + 48;
    do
    {
      uint64_t v7 = *(void *)a1 + v6;
      long long v8 = *a3;
      *(void *)(v7 + 16) = *((void *)a3 + 2);
      *(_OWORD *)uint64_t v7 = v8;
      long long v9 = (long long *)(*(void *)a1 + v6);
      long long v10 = *v9;
      long long v11 = v9[2];
      *(_OWORD *)&v13.start.CMTimeEpoch epoch = v9[1];
      *(_OWORD *)&v13.duration.CMTimeScale timescale = v11;
      *(_OWORD *)&v13.start.int64_t value = v10;
      CMTimeRangeGetEnd(&v14, &v13);
      double result = *(double *)&v14.value;
      *(CMTime *)a3 = v14;
      ++v4;
      v6 += 96;
    }
    while (v4 < *(int *)(a1 + 8));
  }
  return result;
}

uint64_t DeleteEditsWithZeroDuration(uint64_t result, uint64_t a2, uint64_t a3)
{
  if ((a2 & 0x8000000000000000) == 0)
  {
    uint64_t v3 = a3;
    uint64_t v4 = a2;
    uint64_t v5 = (void *)result;
    uint64_t v6 = *(int *)(result + 8);
    BOOL v7 = v6 > a3 && a2 <= a3;
    if (v7 && v6 > a2)
    {
      long long v12 = *MEMORY[0x1E4F1FA48];
      CMTimeEpoch v9 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
      do
      {
        uint64_t v10 = *v5 + 96 * v4;
        long long v11 = *(_OWORD *)(v10 + 72);
        time1.CMTimeEpoch epoch = *(void *)(v10 + 88);
        *(_OWORD *)&time1.int64_t value = v11;
        *(_OWORD *)&time2.int64_t value = v12;
        time2.CMTimeEpoch epoch = v9;
        double result = CMTimeCompare(&time1, &time2);
        if (result)
        {
          ++v4;
        }
        else
        {
          double result = DeleteEditsFromTrack((uint64_t)v5, v4, 1);
          if (result) {
            return result;
          }
          --v3;
        }
      }
      while (v4 <= v3);
    }
  }
  return result;
}

uint64_t FigMutableCompositionGetClassID()
{
  return sFigMutableCompositionClassID;
}

uint64_t RegisterFigMutableCompositionBaseType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigMutableCompositionGetTypeID()
{
  MEMORY[0x19970EE10](&FigMutableCompositionGetClassID_sRegisterFigMutableCompositionBaseTypeOnce, RegisterFigMutableCompositionBaseType);

  return CMBaseClassGetCFTypeID();
}

uint64_t FigMutableCompositionCreate(const __CFAllocator *a1, const void *a2, uint64_t a3, void *a4)
{
  CMTimeRange v13 = 0;
  MEMORY[0x19970EE10](&FigMutableCompositionGetClassID_sRegisterFigMutableCompositionBaseTypeOnce, RegisterFigMutableCompositionBaseType);
  uint64_t v7 = CMDerivedObjectCreate();
  if (!v7)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    CMTimeEpoch v9 = malloc_type_calloc(0x30uLL, 1uLL, 0x11650DE8uLL);
    *(_DWORD *)CMTimeEpoch v9 = 1;
    void v9[2] = 0;
    v9[3] = 0;
    v9[4] = FigSimpleMutexCreate();
    v9[5] = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CMTimeRange v13 = v9;
    v9[1] = a2;
    if (a2) {
      CFRetain(a2);
    }
    uint64_t v10 = malloc_type_calloc(0xA8uLL, 1uLL, 0x92C34DB9uLL);
    void *v10 = 0x100000001;
    v10[1] = FigSimpleMutexCreate();
    _OWORD v10[2] = 0;
    *((_DWORD *)v10 + 6) = 1;
    v10[4] = 0;
    v10[5] = CFBagCreateMutable(a1, 0, MEMORY[0x1E4F1D520]);
    _OWORD v10[7] = FigSimpleMutexCreate();
    long long v11 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    v10[8] = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    v10[9] = FigSimpleMutexCreate();
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 6) = 0u;
    v10[14] = 0;
    v10[15] = FigSimpleMutexCreate();
    v10[16] = 64;
    v10[17] = malloc_type_calloc(0x40uLL, 0x10uLL, 0x1060040C2E02434uLL);
    v10[18] = 1;
    v10[19] = CFDictionaryCreateMutable(a1, 0, 0, v11);
    v10[20] = v9;
    FigAtomicIncrement32();
    *(void *)(DerivedStorage + 8) = v10;
    *a4 = 0;
  }
  compositionSharedCache_releaseAndClear(&v13);
  return v7;
}

void compositionSharedCache_releaseAndClear(void **a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if (v1 && !FigAtomicDecrement32())
  {
    int v2 = (const void *)v1[1];
    if (v2)
    {
      CFRelease(v2);
      v1[1] = 0;
    }
    v1[2] = 0;
    uint64_t v3 = (const void *)v1[3];
    if (v3)
    {
      CFRelease(v3);
      v1[3] = 0;
    }
    if (v1[4])
    {
      FigSimpleMutexDestroy();
      v1[4] = 0;
    }
    uint64_t v4 = (__CFDictionary *)v1[5];
    if (v4)
    {
      CFDictionaryRemoveAllValues(v4);
      uint64_t v5 = (const void *)v1[5];
      if (v5) {
        CFRelease(v5);
      }
    }
    free(v1);
  }
}

CFStringRef FigMutableCompositionCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigMutableComposition %p]", a1);
}

void mutableComposition_Finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  uint64_t v1 = *(const void **)(DerivedStorage + 24);
  if (v1)
  {
    CFRelease(v1);
    *(void *)(DerivedStorage + 24) = 0;
  }

  compositionTable_releaseAndClear((uint64_t *)(DerivedStorage + 8));
}

__CFString *mutableComposition_CopyDebugDescription()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v2 = *(void *)(DerivedStorage + 8);
  uint64_t v3 = *(void *)(v2 + 32);
  CFStringAppend(Mutable, @"[FigMutableComposition]{\n");
  if (*(uint64_t *)(v2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = compositionTableTrack_CopyDebugDescription(v3);
      if (v4) {
        CFStringAppend(Mutable, @",\n");
      }
      CFStringAppend(Mutable, @"  ");
      CFStringAppend(Mutable, v5);
      if (v5) {
        CFRelease(v5);
      }
      ++v4;
      v3 += 168;
    }
    while (v4 < *(void *)(v2 + 16));
  }
  CFStringAppend(Mutable, @"\n}");
  return Mutable;
}

uint64_t mutableComposition_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFDictionaryRef *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    long long v8 = (uint64_t *)DerivedStorage;
    uint64_t v9 = *(void *)(DerivedStorage + 8);
    if (CFEqual(a2, @"MutableComposition_ByteStreamProvider"))
    {
      uint64_t v10 = *(const void **)(*(void *)(v8[1] + 160) + 8);
      if (v10)
      {
LABEL_4:
        CFDictionaryRef v11 = (const __CFDictionary *)CFRetain(v10);
LABEL_10:
        CFDictionaryRef v13 = v11;
LABEL_14:
        uint64_t result = 0;
        *a4 = v13;
        return result;
      }
LABEL_13:
      CFDictionaryRef v13 = 0;
      goto LABEL_14;
    }
    if (CFEqual(a2, @"MutableComposition_AssetCreationFlags"))
    {
      CFDictionaryRef v11 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, (const void *)(*(void *)(v8[1] + 160) + 16));
      goto LABEL_10;
    }
    if (CFEqual(a2, @"MutableComposition_AssetCreationOptions"))
    {
      uint64_t v10 = *(const void **)(*(void *)(v8[1] + 160) + 24);
      if (v10) {
        goto LABEL_4;
      }
      goto LABEL_13;
    }
    if (CFEqual(a2, @"MutableComposition_Metadata"))
    {
      MEMORY[0x19970E910](*(void *)(v9 + 72));
      *a4 = CFDictionaryCreateCopy(a3, *(CFDictionaryRef *)(v8[1] + 80));
      uint64_t v14 = *(void *)(v9 + 72);
LABEL_21:
      MEMORY[0x19970E930](v14);
      return 0;
    }
    if (CFEqual(a2, @"MutableComposition_TrackReferenceDictionary"))
    {
      MEMORY[0x19970E910](*(void *)(v9 + 8));
      MutableCFArrayRef Copy = *(const __CFDictionary **)(v9 + 48);
      if (MutableCopy)
      {
        CFIndex Count = CFDictionaryGetCount(MutableCopy);
        MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(a3, Count, *(CFDictionaryRef *)(v9 + 48));
      }
      *a4 = MutableCopy;
      uint64_t v14 = *(void *)(v9 + 8);
      goto LABEL_21;
    }
    if (CFEqual(a2, @"MediaSelectionArray"))
    {
      uint64_t v17 = *v8;
      return FigCreateMediaSelectionArrayFromFormatReaderProperties(v17, 1, 0, a4);
    }
    else
    {
      return 4294954512;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t mutableComposition_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    uint64_t v6 = DerivedStorage;
    uint64_t v7 = *(void *)(DerivedStorage + 8);
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (CFEqual(a2, @"MutableComposition_AssetCreationFlags"))
    {
      if (a3)
      {
        CFTypeID v10 = CFGetTypeID(a3);
        if (v10 == CFNumberGetTypeID())
        {
          uint64_t valuePtr = 0;
          CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, &valuePtr);
          uint64_t v11 = 0;
          *(void *)(*(void *)(*(void *)(v6 + 8) + 160) + 16) = valuePtr;
LABEL_51:
          CMNotificationCenterGetDefaultLocalCenter();
          CMNotificationCenterPostNotification();
          if (Mutable) {
            CFRelease(Mutable);
          }
          return v11;
        }
      }
LABEL_50:
      uint64_t v11 = 0;
      goto LABEL_51;
    }
    if (CFEqual(a2, @"MutableComposition_AssetCreationOptions"))
    {
      if (a3)
      {
        CFTypeID v13 = CFGetTypeID(a3);
        if (v13 != CFDictionaryGetTypeID()) {
          goto LABEL_50;
        }
        uint64_t v14 = *(void *)(*(void *)(v6 + 8) + 160);
        long long v15 = *(const void **)(v14 + 24);
        *(void *)(v14 + 24) = a3;
        CFRetain(a3);
      }
      else
      {
        uint64_t v37 = *(void *)(*(void *)(v6 + 8) + 160);
        long long v15 = *(const void **)(v37 + 24);
        *(void *)(v37 + 24) = 0;
      }
      if (v15) {
        CFRelease(v15);
      }
      goto LABEL_50;
    }
    if (!CFEqual(a2, @"MutableComposition_TrackReferenceDictionary"))
    {
      if (!CFEqual(a2, @"MutableComposition_Metadata"))
      {
        uint64_t v11 = 4294954512;
        goto LABEL_51;
      }
      if (a3)
      {
        CFTypeID v38 = CFGetTypeID(a3);
        if (v38 == CFArrayGetTypeID())
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)a3);
          MEMORY[0x19970E910](*(void *)(v7 + 72));
          if (Count >= 1)
          {
            CFIndex v40 = 0;
            valuea = (void *)*MEMORY[0x1E4F1CFD0];
            do
            {
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a3, v40);
              if (ValueAtIndex)
              {
                CFDictionaryRef v42 = ValueAtIndex;
                CFTypeID v43 = CFGetTypeID(ValueAtIndex);
                if (v43 == CFDictionaryGetTypeID())
                {
                  uint64_t v44 = CFDictionaryGetValue(v42, @"format");
                  uint64_t v45 = CFDictionaryGetValue(v42, @"items");
                  if (v44)
                  {
                    uint64_t v46 = v45;
                    if (v45)
                    {
                      CFDictionaryRef v47 = *(const __CFDictionary **)(v7 + 80);
                      if (!v47)
                      {
                        CFDictionaryRef v47 = CFDictionaryCreateMutable(v8, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                        *(void *)(v7 + 80) = v47;
                      }
                      CFDictionaryGetValue(v47, v44);
                      if (!FigCFEqual())
                      {
                        CFDictionarySetValue(Mutable, v44, valuea);
                        CFDictionarySetValue(Mutable, @"MetadataReaderTypes", valuea);
                        CFDictionarySetValue(Mutable, @"MetadataReaders", valuea);
                        if (FigCFEqual())
                        {
                          long long v48 = *(const void **)(v7 + 96);
                          if (v48)
                          {
                            CFRelease(v48);
                            *(void *)(v7 + 96) = 0;
                          }
                        }
                        if (FigCFEqual())
                        {
                          long long v49 = *(const void **)(v7 + 104);
                          if (v49)
                          {
                            CFRelease(v49);
                            *(void *)(v7 + 104) = 0;
                          }
                        }
                        if (FigCFEqual())
                        {
                          uint64_t v50 = *(const void **)(v7 + 88);
                          if (v50)
                          {
                            CFRelease(v50);
                            *(void *)(v7 + 88) = 0;
                          }
                        }
                        if (FigCFEqual())
                        {
                          long long v51 = *(const void **)(v7 + 112);
                          if (v51)
                          {
                            CFRelease(v51);
                            *(void *)(v7 + 112) = 0;
                          }
                        }
                      }
                      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v7 + 80), v44, v46);
                    }
                  }
                }
              }
              ++v40;
            }
            while (Count != v40);
          }
          MEMORY[0x19970E930](*(void *)(v7 + 72));
        }
      }
      goto LABEL_50;
    }
    if (a3)
    {
      CFTypeID v16 = CFGetTypeID(a3);
      if (v16 != CFDictionaryGetTypeID())
      {
        uint64_t v11 = FigSignalErrorAt();
        goto LABEL_51;
      }
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v8, (CFDictionaryRef)a3);
      long long v18 = (void *)(v7 + 8);
      MEMORY[0x19970E910](*(void *)(v7 + 8));
      if (Copy)
      {
        CFTypeID v19 = CFGetTypeID(Copy);
        if (v19 != CFDictionaryGetTypeID())
        {
          LOBYTE(v24) = 0;
          long long v21 = 0;
          long long v22 = 0;
          uint64_t v11 = 4294954516;
          goto LABEL_93;
        }
        int64_t v20 = CFDictionaryGetCount(Copy);
        long long v21 = (const void **)malloc_type_calloc(v20, 8uLL, 0x6004044C4A2DFuLL);
        if (v21)
        {
          long long v22 = (const void **)malloc_type_calloc(v20, 8uLL, 0x6004044C4A2DFuLL);
          if (v22)
          {
            CFDictionaryGetKeysAndValues(Copy, v21, v22);
            if (v20 < 1)
            {
              uint64_t v11 = 0;
              LOBYTE(v24) = 1;
            }
            else
            {
              long long v23 = 0;
              int64_t value = (void *)v20;
              key = v21;
              while (1)
              {
                CFStringRef v24 = (const __CFString *)v21[(void)v23];
                if (!v24) {
                  break;
                }
                long long v25 = v22[(void)v23];
                CFTypeID v26 = CFGetTypeID(v21[(void)v23]);
                if (v26 != CFStringGetTypeID() || v25 == 0) {
                  goto LABEL_90;
                }
                CFTypeID v28 = CFGetTypeID(v25);
                if (v28 != CFArrayGetTypeID()) {
                  goto LABEL_90;
                }
                if (!GetTrackReferenceOSTypeFromKeyString(v24)) {
                  goto LABEL_90;
                }
                CFIndex v29 = CFArrayGetCount((CFArrayRef)v25);
                CFIndex v30 = v29;
                if (v29) {
                  goto LABEL_90;
                }
                if (v29 >= 1)
                {
                  CFIndex v31 = 0;
                  while (1)
                  {
                    LODWORD(valuePtr) = 0;
                    int v58 = 0;
                    if (!FigCFArrayGetInt32AtIndex()) {
                      break;
                    }
                    if (!FigCFArrayGetInt32AtIndex()) {
                      break;
                    }
                    uint64_t v32 = *(void *)(v7 + 16);
                    if (v32 < 1) {
                      break;
                    }
                    uint64_t v33 = *(void *)(v7 + 16);
                    uint64_t v34 = *(void *)(v7 + 32);
                    while (*(_DWORD *)(v34 + 4) != valuePtr)
                    {
                      v34 += 168;
                      if (!--v33)
                      {
                        uint64_t v34 = 0;
                        break;
                      }
                    }
                    long long v35 = (int *)(*(void *)(v7 + 32) + 4);
                    while (1)
                    {
                      int v36 = *v35;
                      v35 += 42;
                      if (v36 == v58) {
                        break;
                      }
                      if (!--v32) {
                        goto LABEL_90;
                      }
                    }
                    if (!v34) {
                      break;
                    }
                    v31 += 2;
                    if (v31 >= v30) {
                      goto LABEL_45;
                    }
                  }
LABEL_90:
                  LOBYTE(v24) = 0;
                  break;
                }
LABEL_45:
                long long v23 = (char *)v23 + 1;
                LOBYTE(v24) = 1;
                long long v21 = key;
                if (v23 == value)
                {
                  uint64_t v11 = 0;
                  goto LABEL_93;
                }
              }
              uint64_t v11 = 4294954516;
              long long v21 = key;
            }
LABEL_93:
            free(v21);
            free(v22);
            if ((v24 & 1) == 0)
            {
              MEMORY[0x19970E930](*v18);
LABEL_97:
              CFRelease(Copy);
LABEL_98:
              CFDictionarySetValue(Mutable, @"TrackReferenceDictionary", (const void *)*MEMORY[0x1E4F1CFD0]);
              goto LABEL_51;
            }
            CMTime v52 = *(const void **)(v7 + 48);
            *(void *)(v7 + 48) = Copy;
            CFRetain(Copy);
            char v53 = 0;
            if (!v52)
            {
LABEL_84:
              MEMORY[0x19970E930](*v18);
              uint64_t v11 = 0;
              if (v53) {
                goto LABEL_98;
              }
              goto LABEL_97;
            }
LABEL_83:
            CFRelease(v52);
            goto LABEL_84;
          }
          LOBYTE(v24) = 0;
        }
        else
        {
          LOBYTE(v24) = 0;
          long long v22 = 0;
        }
        uint64_t v11 = 4294954510;
        goto LABEL_93;
      }
    }
    else
    {
      long long v18 = (void *)(v7 + 8);
      MEMORY[0x19970E910](*(void *)(v7 + 8));
    }
    CFDictionaryRef Copy = 0;
    CMTime v52 = *(const void **)(v7 + 48);
    *(void *)(v7 + 48) = 0;
    char v53 = 1;
    if (!v52) {
      goto LABEL_84;
    }
    goto LABEL_83;
  }

  return FigSignalErrorAt();
}

void compositionTable_releaseAndClear(uint64_t *a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if (v1 && !FigAtomicDecrement32())
  {
    if (*(void *)(v1 + 8))
    {
      FigSimpleMutexDestroy();
      *(void *)(v1 + 8) = 0;
    }
    if (*(void *)(v1 + 72))
    {
      FigSimpleMutexDestroy();
      *(void *)(v1 + 72) = 0;
    }
    uint64_t v2 = *(const void **)(v1 + 80);
    if (v2)
    {
      CFRelease(v2);
      *(void *)(v1 + 80) = 0;
    }
    uint64_t v3 = *(const void **)(v1 + 88);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(v1 + 88) = 0;
    }
    uint64_t v4 = *(const void **)(v1 + 96);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(v1 + 96) = 0;
    }
    uint64_t v5 = *(const void **)(v1 + 104);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(v1 + 104) = 0;
    }
    uint64_t v6 = *(const void **)(v1 + 112);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(v1 + 112) = 0;
    }
    uint64_t v7 = *(uint64_t **)(v1 + 32);
    if (v7)
    {
      if (*(uint64_t *)(v1 + 16) >= 1)
      {
        uint64_t v8 = 0;
        do
        {
          compositionTableTrack_releaseAndClear(v1, v7);
          ++v8;
          v7 += 21;
        }
        while (v8 < *(void *)(v1 + 16));
        uint64_t v7 = *(uint64_t **)(v1 + 32);
      }
      free(v7);
      *(void *)(v1 + 32) = 0;
    }
    uint64_t v9 = *(__CFBag **)(v1 + 40);
    if (v9)
    {
      CFBagRemoveAllValues(v9);
      CFTypeID v10 = *(const void **)(v1 + 40);
      if (v10)
      {
        CFRelease(v10);
        *(void *)(v1 + 40) = 0;
      }
    }
    uint64_t v11 = *(const void **)(v1 + 48);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(v1 + 48) = 0;
    }
    if (*(void *)(v1 + 56))
    {
      FigSimpleMutexDestroy();
      *(void *)(v1 + 56) = 0;
    }
    long long v12 = *(__CFDictionary **)(v1 + 64);
    if (v12)
    {
      CFDictionaryRemoveAllValues(v12);
      CFTypeID v13 = *(const void **)(v1 + 64);
      if (v13)
      {
        CFRelease(v13);
        *(void *)(v1 + 64) = 0;
      }
    }
    if (*(void *)(v1 + 120))
    {
      FigSimpleMutexDestroy();
      *(void *)(v1 + 120) = 0;
    }
    uint64_t v14 = *(char **)(v1 + 136);
    if (v14)
    {
      uint64_t v15 = *(void *)(v1 + 144);
      if (v15 >= 2)
      {
        uint64_t v16 = 1;
        uint64_t v17 = 16;
        do
        {
          if (*(void *)&v14[v17])
          {
            CFRelease(*(CFTypeRef *)&v14[v17]);
            uint64_t v14 = *(char **)(v1 + 136);
            uint64_t v15 = *(void *)(v1 + 144);
            *(void *)&v14[v17] = 0;
          }
          ++v16;
          v17 += 16;
        }
        while (v16 < v15);
      }
      free(v14);
      *(void *)(v1 + 136) = 0;
    }
    long long v18 = *(__CFDictionary **)(v1 + 152);
    if (v18)
    {
      CFDictionaryRemoveAllValues(v18);
      CFTypeID v19 = *(const void **)(v1 + 152);
      if (v19)
      {
        CFRelease(v19);
        *(void *)(v1 + 152) = 0;
      }
    }
    compositionSharedCache_releaseAndClear((void **)(v1 + 160));
    free((void *)v1);
  }
}

void compositionTableTrack_releaseAndClear(uint64_t a1, uint64_t *a2)
{
  compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag(a2[2], a2[1], *(CFMutableBagRef *)(a1 + 40));
  uint64_t v3 = (void *)a2[2];
  if (v3)
  {
    a2[2] = 0;
    free(v3);
  }
  uint64_t v4 = (const void *)a2[4];
  if (v4)
  {
    CFRelease(v4);
    a2[4] = 0;
  }
  uint64_t v5 = (const void *)a2[5];
  if (v5)
  {
    CFRelease(v5);
    a2[5] = 0;
  }
  uint64_t v6 = (const void *)a2[6];
  if (v6)
  {
    CFRelease(v6);
    a2[6] = 0;
  }
  uint64_t v7 = (const void *)a2[7];
  if (v7)
  {
    CFRelease(v7);
    a2[7] = 0;
  }
  uint64_t v8 = (const void *)a2[8];
  if (v8)
  {
    CFRelease(v8);
    a2[8] = 0;
  }
  uint64_t v9 = (const void *)a2[9];
  if (v9)
  {
    CFRelease(v9);
    a2[9] = 0;
  }
  CFTypeID v10 = (const void *)a2[15];
  if (v10)
  {
    CFRelease(v10);
    a2[15] = 0;
  }
  uint64_t v11 = (const void *)a2[16];
  if (v11)
  {
    CFRelease(v11);
    a2[16] = 0;
  }
  long long v12 = (const void *)a2[17];
  if (v12)
  {
    CFRelease(v12);
    a2[17] = 0;
  }
  CFTypeID v13 = (const void *)a2[18];
  if (v13)
  {
    CFRelease(v13);
    a2[18] = 0;
  }
  uint64_t v14 = (const void *)a2[19];
  if (v14)
  {
    CFRelease(v14);
    a2[19] = 0;
  }
  uint64_t v15 = (const void *)a2[10];
  if (v15)
  {
    CFRelease(v15);
    a2[10] = 0;
  }
  uint64_t v16 = (const void *)a2[11];
  if (v16)
  {
    CFRelease(v16);
    a2[11] = 0;
  }
  uint64_t v17 = (const void *)a2[12];
  if (v17)
  {
    CFRelease(v17);
    a2[12] = 0;
  }
  long long v18 = (const void *)a2[13];
  if (v18)
  {
    CFRelease(v18);
    a2[13] = 0;
  }
  CFTypeID v19 = (const void *)a2[14];
  if (v19)
  {
    CFRelease(v19);
    a2[14] = 0;
  }
}

void compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag(uint64_t a1, uint64_t a2, CFMutableBagRef theBag)
{
  if (a1)
  {
    uint64_t v3 = a2;
    if (a2 >= 1)
    {
      uint64_t v5 = (const void **)(a1 + 96);
      do
      {
        if ((*((_DWORD *)v5 - 21) & 0x1D) == 1)
        {
          if (theBag && *v5) {
            CFBagRemoveValue(theBag, *v5);
          }
          if (*v5)
          {
            CFRelease(*v5);
            *uint64_t v5 = 0;
          }
        }
        uint64_t v5 = (const void **)((char *)v5 + 108);
        --v3;
      }
      while (v3);
    }
  }
}

__CFString *compositionTableTrack_CopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v3 = *(unsigned int *)(a1 + 4);
  unsigned int v29 = bswap32(*(_DWORD *)a1);
  CFStringAppendFormat(Mutable, 0, @"{ trackID %d, mediaType %.4s, ", v3, &v29);
  CFStringAppendFormat(Mutable, 0, @"editCount %d", *(void *)(a1 + 8));
  if (*(uint64_t *)(a1 + 8) >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = (long long *)(*(void *)(a1 + 16) + v4);
      int v7 = *((_DWORD *)v6 + 3) & 0x1D;
      v6 += 3;
      long long v8 = *v6;
      time.CMTimeEpoch epoch = *((void *)v6 + 2);
      *(_OWORD *)&time.int64_t value = v8;
      if (v7 == 1)
      {
        Float64 Seconds = CMTimeGetSeconds(&time);
        uint64_t v10 = *(void *)(a1 + 16) + v4;
        long long v11 = *(_OWORD *)(v10 + 72);
        time.CMTimeEpoch epoch = *(void *)(v10 + 88);
        *(_OWORD *)&time.int64_t value = v11;
        Float64 v12 = CMTimeGetSeconds(&time);
        CFTypeID v13 = (long long *)(*(void *)(a1 + 16) + v4);
        long long v14 = *v13;
        time.CMTimeEpoch epoch = *((void *)v13 + 2);
        *(_OWORD *)&time.int64_t value = v14;
        Float64 v15 = CMTimeGetSeconds(&time);
        uint64_t v16 = *(void *)(a1 + 16) + v4;
        long long v17 = *(_OWORD *)(v16 + 24);
        time.CMTimeEpoch epoch = *(void *)(v16 + 40);
        *(_OWORD *)&time.int64_t value = v17;
        Float64 v18 = CMTimeGetSeconds(&time);
        CFStringAppendFormat(Mutable, 0, @", [%1.3f,+%1.3f] -> [%1.3f,+%1.3f] of asset %@ trackID %d", *(void *)&Seconds, *(void *)&v12, *(void *)&v15, *(void *)&v18, *(void *)(*(void *)(a1 + 16) + v4 + 96), *(unsigned int *)(*(void *)(a1 + 16) + v4 + 104));
      }
      else
      {
        Float64 v19 = CMTimeGetSeconds(&time);
        uint64_t v20 = *(void *)(a1 + 16) + v4;
        long long v21 = *(_OWORD *)(v20 + 72);
        time.CMTimeEpoch epoch = *(void *)(v20 + 88);
        *(_OWORD *)&time.int64_t value = v21;
        Float64 v23 = CMTimeGetSeconds(&time);
        CFStringAppendFormat(Mutable, 0, @", [%1.3f,+%1.3f] -> empty", *(void *)&v19, *(void *)&v23, v24, v25, v26, v27);
      }
      ++v5;
      v4 += 108;
    }
    while (v5 < *(void *)(a1 + 8));
  }
  CFStringAppendFormat(Mutable, 0, @" }");
  return Mutable;
}

uint64_t mutableComposition_CreateMutableCopy(const __CFAllocator *a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if ((const __CFAllocator *)*MEMORY[0x1E4F1CFB8] == a1) {
    return 4294954516;
  }
  uint64_t v6 = DerivedStorage;
  if ((_UNKNOWN *)CMBaseObjectGetVTable() == &kMutableComposition_VTable)
  {
    MEMORY[0x19970EE10](&FigMutableCompositionGetClassID_sRegisterFigMutableCompositionBaseTypeOnce, RegisterFigMutableCompositionBaseType);
    uint64_t result = CMDerivedObjectCreate();
    if (!result)
    {
      uint64_t v8 = CMBaseObjectGetDerivedStorage();
      compositionTable_createCopy(a1, *(void *)(v6 + 8), (void *)(v8 + 8));
      uint64_t result = 0;
      *a3 = 0;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t mutableComposition_CopyFormatReader(const void *a1, int a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v8 = CFGetAllocator(a1);
  if (a2 || !*(void *)DerivedStorage)
  {
    FigFormatReaderGetClassID();
    uint64_t v9 = CMDerivedObjectCreate();
    if (v9) {
      return v9;
    }
    uint64_t v10 = CMBaseObjectGetDerivedStorage();
    if (a2)
    {
      compositionTable_createCopy((const __CFAllocator *)*MEMORY[0x1E4F1CFB8], *(void *)(DerivedStorage + 8), (void *)v10);
    }
    else
    {
      *(void *)uint64_t v10 = *(void *)(DerivedStorage + 8);
      FigAtomicIncrement32();
      *(void *)uint64_t DerivedStorage = CFRetain(0);
    }
    *(void *)(v10 + 8) = FigSimpleMutexCreate();
    *(void *)(v10 + 16) = CFDictionaryCreateMutable(v8, 0, 0, MEMORY[0x1E4F1D540]);
    *(unsigned char *)(v10 + 24) = a2 == 0;
    CFTypeRef v11 = 0;
  }
  else
  {
    CFTypeRef v11 = CFRetain(*(CFTypeRef *)DerivedStorage);
  }
  uint64_t v9 = 0;
  *a4 = v11;
  return v9;
}

uint64_t mutableComposition_GetTrackCompatibleWithAssetTrack(uint64_t a1, const void *a2, uint64_t a3, _DWORD *a4)
{
  int v7 = *(void **)(CMBaseObjectGetDerivedStorage() + 8);
  CFTypeRef v28 = 0;
  CFTypeRef v29 = 0;
  int v27 = 0;
  if (!a2)
  {
    uint64_t v20 = 4294954516;
    goto LABEL_23;
  }
  uint64_t v8 = *MEMORY[0x1E4F1CF80];
  uint64_t v9 = compositionSharedCache_copyFormatReaderForAssetURL(v7[20], a2, (const __CFAllocator *)*MEMORY[0x1E4F1CF80], (uint64_t)&v29);
  if (!v9)
  {
    MEMORY[0x19970E910](v7[1]);
    CFTypeRef v10 = v29;
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v11) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0;
    }
    CFTypeID v13 = *(uint64_t (**)(CFTypeRef, uint64_t, CFTypeRef *, int *))(v12 + 56);
    if (!v13)
    {
      uint64_t v20 = 4294954514;
LABEL_20:
      MEMORY[0x19970E930](v7[1]);
      goto LABEL_21;
    }
    uint64_t v14 = v13(v10, a3, &v28, &v27);
    if (v14)
    {
      uint64_t v20 = v14;
      goto LABEL_20;
    }
    uint64_t v15 = v7[2];
    int v16 = v27;
    CFTypeRef cf = 0;
    uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(v28);
    uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v18) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = 0;
    }
    long long v21 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v19 + 48);
    if (!v21)
    {
LABEL_19:
      uint64_t v20 = 4294954453;
      goto LABEL_20;
    }
    int v22 = v21(FigBaseObject, @"TrackFormatDescriptionArray", v8, &cf);
    CFTypeRef v23 = cf;
    if (v22)
    {
      CompatibleTrackForFormatDescriptionArrayAndCMMediaType MediaType = -1;
      if (!cf)
      {
LABEL_16:
        if ((CompatibleTrackForFormatDescriptionArrayAndMediaType & 0x8000000000000000) == 0)
        {
          int v25 = *(_DWORD *)(v7[4] + 168 * CompatibleTrackForFormatDescriptionArrayAndMediaType + 4);
          MEMORY[0x19970E930](v7[1]);
          uint64_t v20 = 0;
          if (a4) {
            *a4 = v25;
          }
          goto LABEL_21;
        }
        goto LABEL_19;
      }
    }
    else
    {
      CompatibleTrackForFormatDescriptionArrayAndCMMediaType MediaType = compositionTable_findCompatibleTrackForFormatDescriptionArrayAndMediaType((uint64_t)v7, 0, v15, cf, v16);
      CFTypeRef v23 = cf;
      if (!cf) {
        goto LABEL_16;
      }
    }
    CFRelease(v23);
    goto LABEL_16;
  }
  uint64_t v20 = v9;
LABEL_21:
  if (v28) {
    CFRelease(v28);
  }
LABEL_23:
  if (v29) {
    CFRelease(v29);
  }
  return v20;
}

uint64_t mutableComposition_AddTrack(uint64_t a1, int a2, uint64_t a3, int a4, _DWORD *a5)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v9 = DerivedStorage[1];
  MEMORY[0x19970E910](*(void *)(v9 + 8));
  compositionTable_addTrack(v9, a2, a4, a5, 0);
  ++*(_DWORD *)(v9 + 4);
  MEMORY[0x19970E930](*(void *)(v9 + 8));
  if (*DerivedStorage) {
    mutableComposition_postPossiblyDeferredTracksChangedNotification();
  }
  return 0;
}

uint64_t mutableComposition_DeleteTrack(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v4 = DerivedStorage[1];
  MEMORY[0x19970E910](*(void *)(v4 + 8));
  uint64_t v5 = *(void *)(v4 + 16);
  if (v5 < 1)
  {
LABEL_5:
    uint64_t v9 = FigSignalErrorAt();
    int v10 = 0;
    goto LABEL_38;
  }
  uint64_t v6 = *(void *)(v4 + 32);
  uint64_t v7 = -v5;
  uint64_t v8 = 1;
  while (*(_DWORD *)(v6 + 4) != a2)
  {
    v6 += 168;
    ++v8;
    if (v7 + v8 == 1) {
      goto LABEL_5;
    }
  }
  if (*(void *)(v4 + 48))
  {
    CFAllocatorRef v28 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
    int64_t Count = CFDictionaryGetCount(*(CFDictionaryRef *)(v4 + 48));
    keys = (void **)malloc_type_calloc(Count, 8uLL, 0x6004044C4A2DFuLL);
    if (!keys)
    {
      CFTypeID v13 = 0;
      if (!Mutable) {
        goto LABEL_34;
      }
      goto LABEL_33;
    }
    CFTypeID v13 = (const void **)malloc_type_calloc(Count, 8uLL, 0x6004044C4A2DFuLL);
    if (v13)
    {
      uint64_t v26 = DerivedStorage;
      uint64_t v25 = v4;
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(v4 + 48), (const void **)keys, v13);
      if (Count < 1)
      {
LABEL_23:
        if (!CFDictionaryGetCount(Mutable))
        {
          uint64_t DerivedStorage = v26;
          uint64_t v4 = v25;
          if (!Mutable) {
            goto LABEL_34;
          }
          goto LABEL_33;
        }
        uint64_t v4 = v25;
        uint64_t DerivedStorage = v26;
        CFMutableArrayRef v18 = *(CFMutableArrayRef *)(v25 + 48);
        *(void *)(v25 + 48) = Mutable;
        if (Mutable) {
          CFRetain(Mutable);
        }
        if (!v18) {
          goto LABEL_32;
        }
        goto LABEL_31;
      }
      uint64_t v14 = 0;
      int v27 = v13;
      while (1)
      {
        int64_t v15 = Count;
        int v16 = keys[v14];
        CFArrayRef v17 = (const __CFArray *)v13[v14];
        CFMutableArrayRef v18 = CFArrayCreateMutable(v28, 0, MEMORY[0x1E4F1D510]);
        CFIndex v19 = CFArrayGetCount(v17);
        if (v19 >= 1) {
          break;
        }
LABEL_20:
        if (v18) {
          CFRelease(v18);
        }
        ++v14;
        int64_t Count = v15;
        CFTypeID v13 = v27;
        if (v14 == v15) {
          goto LABEL_23;
        }
      }
      CFIndex v20 = v19;
      CFIndex v21 = 0;
      while (FigCFArrayGetInt32AtIndex())
      {
        CFIndex v22 = v21 + 1;
        if (!FigCFArrayGetInt32AtIndex()) {
          break;
        }
        if (*(_DWORD *)(v6 + 4))
        {
          FigCFArrayAppendInt32();
          FigCFArrayAppendInt32();
          if (v18)
          {
            if (CFArrayGetCount(v18)) {
              CFDictionarySetValue(Mutable, v16, v18);
            }
          }
        }
        CFIndex v21 = v22 + 1;
        if (v21 >= v20) {
          goto LABEL_20;
        }
      }
      uint64_t DerivedStorage = v26;
      CFTypeID v13 = v27;
      uint64_t v4 = v25;
      if (v18) {
LABEL_31:
      }
        CFRelease(v18);
    }
LABEL_32:
    if (!Mutable)
    {
LABEL_34:
      free(keys);
      free(v13);
      goto LABEL_35;
    }
LABEL_33:
    CFRelease(Mutable);
    goto LABEL_34;
  }
LABEL_35:
  compositionTableTrack_releaseAndClear(v4, (uint64_t *)v6);
  uint64_t v23 = *(void *)(v4 + 16);
  if (v23 > v8)
  {
    memmove((void *)v6, (const void *)(v6 + 168), 168 * (v23 - v8));
    uint64_t v23 = *(void *)(v4 + 16);
  }
  uint64_t v9 = 0;
  *(void *)(v4 + 16) = v23 - 1;
  *(_DWORD *)(v4 + 4) += 2;
  int v10 = 1;
LABEL_38:
  MEMORY[0x19970E930](*(void *)(v4 + 8));
  compositionTable_discardUnusedAssets(v4);
  if (v10 && *DerivedStorage) {
    mutableComposition_postPossiblyDeferredTracksChangedNotification();
  }
  return v9;
}

uint64_t mutableComposition_SetTrackEditList(uint64_t a1, int a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a3 < 0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v8 = (void *)DerivedStorage;
    uint64_t v9 = *(void *)(DerivedStorage + 8);
    uint64_t v10 = compositionEditSegment_validateSegments((uint64_t)a4, a3, 1);
    if (v10) {
      return v10;
    }
    MEMORY[0x19970E910](*(void *)(v9 + 8));
    uint64_t v11 = *(void *)(v9 + 16);
    if (v11 < 1)
    {
LABEL_7:
      uint64_t v13 = FigSignalErrorAt();
      int v14 = 0;
    }
    else
    {
      uint64_t v12 = (uint64_t *)(*(void *)(v9 + 32) + 16);
      while (*((_DWORD *)v12 - 3) != a2)
      {
        v12 += 21;
        if (!--v11) {
          goto LABEL_7;
        }
      }
      compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag(*v12, *(v12 - 1), *(CFMutableBagRef *)(v9 + 40));
      if (v12[1] < a3)
      {
        free((void *)*v12);
        *uint64_t v12 = (uint64_t)malloc_type_calloc(a3, 0x6CuLL, 0x1060040CB727B4DuLL);
        v12[1] = a3;
      }
      *(v12 - 1) = a3;
      if (a3 >= 1)
      {
        compositionEditSegment_copySegmentsAndAddURLsToBag((CFTypeRef *)*v12, a4, a3, *(__CFBag **)(v9 + 40));
        uint64_t v16 = a3 - 1;
        if (a3 == 1)
        {
          uint64_t v17 = *(v12 - 1);
        }
        else
        {
          CFMutableArrayRef v18 = (long long *)*v12;
          *(v12 - 1) = 0;
          CFIndex v19 = v18;
          do
          {
            CFIndex v20 = (long long *)((char *)v18 + 108);
            if (!compositionEditSegment_combineEditSegmentsIfPossible((uint64_t)v18, (uint64_t)v18 + 108, (uint64_t)v18 + 108, *(__CFBag **)(v9 + 40)))
            {
              if (v18 != v19)
              {
                long long v21 = *v18;
                long long v22 = v18[2];
                v19[1] = v18[1];
                v19[2] = v22;
                *CFIndex v19 = v21;
                long long v23 = v18[3];
                long long v24 = v18[4];
                long long v25 = v18[5];
                *(long long *)((char *)v19 + 92) = *(long long *)((char *)v18 + 92);
                v19[4] = v24;
                v19[5] = v25;
                v19[3] = v23;
                v18[2] = 0u;
                v18[3] = 0u;
                v18[4] = 0u;
                v18[5] = 0u;
                *(long long *)((char *)v18 + 92) = 0u;
                *CFMutableArrayRef v18 = 0u;
                v18[1] = 0u;
              }
              CFIndex v19 = (long long *)((char *)v19 + 108);
              ++*(v12 - 1);
            }
            CFMutableArrayRef v18 = (long long *)((char *)v18 + 108);
            --v16;
          }
          while (v16);
          if (v20 != v19)
          {
            long long v26 = *v20;
            long long v27 = v20[2];
            v19[1] = v20[1];
            v19[2] = v27;
            *CFIndex v19 = v26;
            long long v28 = v20[3];
            long long v29 = v20[4];
            long long v30 = v20[5];
            *(long long *)((char *)v19 + 92) = *(long long *)((char *)v20 + 92);
            v19[4] = v29;
            v19[5] = v30;
            v19[3] = v28;
            v20[2] = 0u;
            v20[3] = 0u;
            v20[4] = 0u;
            v20[5] = 0u;
            *(long long *)((char *)v20 + 92) = 0u;
            *CFIndex v20 = 0u;
            v20[1] = 0u;
          }
          uint64_t v17 = *(v12 - 1) + 1;
          *(v12 - 1) = v17;
        }
        if (v17 >= 1)
        {
          uint64_t v31 = *v12 + 108 * v17;
          if ((*(_DWORD *)(v31 - 96) & 0x1D) != 1)
          {
            uint64_t v32 = (_OWORD *)(v31 - 108);
            *(_OWORD *)((char *)v32 + 92) = 0u;
            v32[4] = 0u;
            v32[5] = 0u;
            v32[2] = 0u;
            v32[3] = 0u;
            *uint64_t v32 = 0u;
            v32[1] = 0u;
            --*(v12 - 1);
          }
        }
      }
      uint64_t v13 = 0;
      ++*(_DWORD *)(v9 + 4);
      int v14 = 1;
    }
    MEMORY[0x19970E930](*(void *)(v9 + 8));
    if (v14)
    {
      if (*v8) {
        mutableComposition_postPossiblyDeferredTracksChangedNotification();
      }
    }
    compositionTable_discardUnusedAssets(v9);
    return v13;
  }
}

uint64_t mutableComposition_CopyTrackEditList(uint64_t a1, int a2, void *a3, uint64_t a4, CFTypeRef *a5)
{
  uint64_t v9 = *(void **)(CMBaseObjectGetDerivedStorage() + 8);
  MEMORY[0x19970E910](v9[1]);
  uint64_t v10 = v9[2];
  if (v10 >= 1)
  {
    uint64_t v11 = v9[4] + 8;
    while (*(_DWORD *)(v11 - 4) != a2)
    {
      v11 += 168;
      if (!--v10) {
        goto LABEL_5;
      }
    }
    if (a3) {
      *a3 = *(void *)v11;
    }
    if (!a5) {
      goto LABEL_17;
    }
    uint64_t v13 = *(void *)v11;
    if (*(void *)v11 <= a4)
    {
      if (v13 >= 1)
      {
        memcpy(a5, *(const void **)(v11 + 8), 108 * v13);
        uint64_t v13 = *(void *)v11;
        if (*(uint64_t *)v11 >= 1)
        {
          uint64_t v14 = 0;
          int64_t v15 = a5 + 12;
          do
          {
            if (*v15)
            {
              CFRetain(*v15);
              uint64_t v13 = *(void *)v11;
            }
            ++v14;
            int64_t v15 = (CFTypeRef *)((char *)v15 + 108);
          }
          while (v14 < v13);
        }
      }
      bzero((char *)a5 + 108 * v13, 108 * (a4 - v13));
LABEL_17:
      uint64_t v12 = 0;
      goto LABEL_18;
    }
  }
LABEL_5:
  uint64_t v12 = FigSignalErrorAt();
LABEL_18:
  MEMORY[0x19970E930](v9[1]);
  return v12;
}

uint64_t mutableComposition_AddFormatReaderForURL(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    if (a3)
    {
      uint64_t v6 = *(void *)(DerivedStorage + 8);
      if ((_UNKNOWN *)CMBaseObjectGetVTable() != &kComposite_FormatReader_VTable)
      {
        uint64_t v7 = *(void *)(v6 + 160);
        int64_t value = 0;
        MEMORY[0x19970E910](*(void *)(v7 + 32));
        if (CFDictionaryContainsKey(*(CFDictionaryRef *)(v7 + 40), a2))
        {
          uint64_t v8 = 0;
        }
        else
        {
          CFAllocatorRef v10 = CFGetAllocator(a3);
          uint64_t v8 = FigAssetCreateWithFormatReader((uint64_t)v10, a3, 0, 0, &value);
          if (value)
          {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v7 + 40), a2, value);
            uint64_t v11 = value;
            MEMORY[0x19970E930](*(void *)(v7 + 32));
            if (v11)
            {
              MEMORY[0x19970E910](*(void *)(v6 + 56));
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(v6 + 64), a2, v11);
              MEMORY[0x19970E930](*(void *)(v6 + 56));
              CFRelease(v11);
            }
            return v8;
          }
        }
        MEMORY[0x19970E930](*(void *)(v7 + 32));
        return v8;
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t mutableComposition_CopyTrackProperty(uint64_t a1, int a2, const void *a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(void **)(CMBaseObjectGetDerivedStorage() + 8);
  MEMORY[0x19970E910](v8[1]);
  uint64_t v9 = v8[2];
  if (v9 >= 1)
  {
    uint64_t v10 = v8[4] + 104;
    while (*(_DWORD *)(v10 - 100) != a2)
    {
      v10 += 168;
      if (!--v9) {
        goto LABEL_5;
      }
    }
    if (CFEqual(a3, @"MutableCompositionTrack_NaturalTimeScale") || CFEqual(a3, @"TrackTimescale"))
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 - 72);
      if (!v12)
      {
LABEL_10:
        uint64_t v11 = 0;
        *a5 = v12;
        goto LABEL_11;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_LanguageCode") || CFEqual(a3, @"TrackLanguageCode"))
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 - 64);
      if (!v12) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_AlternateGroupID") {
           || CFEqual(a3, @"AlternateGroupID")
    }
           || CFEqual(a3, @"MutableCompositionTrack_AlternateGroupID"))
    {
      CFTypeRef v12 = *(CFTypeRef *)v10;
      if (!*(void *)v10) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_ExtendedLanguageTag") {
           || CFEqual(a3, @"ExtendedLanguageTagString"))
    }
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 - 56);
      if (!v12) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_PreferredTransform") || CFEqual(a3, @"TrackMatrix"))
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 - 48);
      if (!v12) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_Volume"))
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 - 40);
      if (!v12) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_Metadata"))
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 - 32);
      if (!v12) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_Enabled") || CFEqual(a3, @"TrackEnabled"))
    {
      uint64_t v14 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      if (!*(unsigned char *)(v10 + 56)) {
        uint64_t v14 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
      }
      CFTypeRef v12 = *v14;
      if (!*v14) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_FormatDescriptionReplacementTable"))
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 + 8);
      if (!v12) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_Layer"))
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 + 16);
      if (!v12) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_CleanApertureDimensions"))
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 + 24);
      if (!v12) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_ProductionApertureDimensions"))
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 + 32);
      if (!v12) {
        goto LABEL_10;
      }
    }
    else if (CFEqual(a3, @"MutableCompositionTrack_EncodedPixelsDimensions"))
    {
      CFTypeRef v12 = *(CFTypeRef *)(v10 + 40);
      if (!v12) {
        goto LABEL_10;
      }
    }
    else
    {
      if (!CFEqual(a3, @"MutableCompositionTrack_LoadSettings"))
      {
        uint64_t v11 = 4294954512;
        goto LABEL_11;
      }
      CFTypeRef v12 = *(CFTypeRef *)(v10 + 48);
      if (!v12) {
        goto LABEL_10;
      }
    }
    CFTypeRef v12 = CFRetain(v12);
    goto LABEL_10;
  }
LABEL_5:
  uint64_t v11 = 4294954516;
LABEL_11:
  MEMORY[0x19970E930](v8[1]);
  return v11;
}

uint64_t mutableComposition_SetTrackProperty(uint64_t a1, uint64_t a2, const void *a3, const __CFString *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v8 = *(void **)(DerivedStorage + 8);
  CFTypeRef v77 = 0;
  if (a3)
  {
    uint64_t v9 = (uint64_t *)DerivedStorage;
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    MEMORY[0x19970E910](v8[1]);
    uint64_t v12 = v8[2];
    if (v12 < 1)
    {
LABEL_6:
      char v14 = 0;
      uint64_t v15 = 4294954516;
      goto LABEL_166;
    }
    uint64_t v13 = (BOOL *)(v8[4] + 160);
    while (*((_DWORD *)v13 - 39) != a2)
    {
      v13 += 168;
      if (!--v12) {
        goto LABEL_6;
      }
    }
    if (CFEqual(a3, @"MutableCompositionTrack_NaturalTimeScale") || CFEqual(a3, @"TrackTimescale"))
    {
      if (!a4)
      {
        CFMutableArrayRef v18 = (const void *)*((void *)v13 - 16);
        *((void *)v13 - 16) = 0;
LABEL_16:
        if (v18) {
          CFRelease(v18);
        }
        goto LABEL_32;
      }
      CFTypeID v17 = CFGetTypeID(a4);
      if (v17 == CFNumberGetTypeID())
      {
        CFMutableArrayRef v18 = (const void *)*((void *)v13 - 16);
        *((void *)v13 - 16) = a4;
        CFRetain(a4);
        goto LABEL_16;
      }
      goto LABEL_155;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_LanguageCode") || CFEqual(a3, @"TrackLanguageCode"))
    {
      if (!a4)
      {
        long long v21 = (const void *)*((void *)v13 - 15);
        *((void *)v13 - 15) = 0;
        goto LABEL_25;
      }
      CFTypeID v19 = CFGetTypeID(a4);
      if (v19 == CFStringGetTypeID())
      {
        CFStringRef Copy = CFStringCreateCopy(v10, a4);
        a4 = Copy;
        long long v21 = (const void *)*((void *)v13 - 15);
        *((void *)v13 - 15) = Copy;
        if (Copy)
        {
          CFRetain(Copy);
          char v22 = 0;
LABEL_26:
          if (v21) {
            CFRelease(v21);
          }
          if ((v22 & 1) == 0) {
            CFRelease(a4);
          }
          long long v23 = kFigTrackProperty_LanguageCode;
          goto LABEL_31;
        }
LABEL_25:
        char v22 = 1;
        goto LABEL_26;
      }
LABEL_155:
      uint64_t v15 = FigSignalErrorAt();
      goto LABEL_156;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_ExtendedLanguageTag")
      || CFEqual(a3, @"ExtendedLanguageTagString"))
    {
      if (a4)
      {
        CFTypeID v24 = CFGetTypeID(a4);
        if (v24 != CFStringGetTypeID()) {
          goto LABEL_155;
        }
        CFStringRef v25 = CFStringCreateCopy(v10, a4);
        a4 = v25;
        long long v26 = (const void *)*((void *)v13 - 14);
        *((void *)v13 - 14) = v25;
        if (v25)
        {
          CFRetain(v25);
          char v27 = 0;
LABEL_41:
          if (v26) {
            CFRelease(v26);
          }
          if ((v27 & 1) == 0) {
            CFRelease(a4);
          }
          long long v23 = kFigTrackProperty_ExtendedLanguageTagString;
          goto LABEL_31;
        }
      }
      else
      {
        long long v26 = (const void *)*((void *)v13 - 14);
        *((void *)v13 - 14) = 0;
      }
      char v27 = 1;
      goto LABEL_41;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_PreferredTransform") || CFEqual(a3, @"TrackMatrix"))
    {
      if (a4)
      {
        CFTypeID v28 = CFGetTypeID(a4);
        if (v28 != CFArrayGetTypeID()) {
          goto LABEL_155;
        }
        CFArrayRef v29 = CFArrayCreateCopy(v10, (CFArrayRef)a4);
        a4 = (const __CFString *)v29;
        long long v30 = (const void *)*((void *)v13 - 13);
        *((void *)v13 - 13) = v29;
        if (v29)
        {
          CFRetain(v29);
          char v31 = 0;
LABEL_54:
          if (v30) {
            CFRelease(v30);
          }
          if ((v31 & 1) == 0) {
            CFRelease(a4);
          }
          long long v23 = kFigTrackProperty_Matrix;
          goto LABEL_31;
        }
      }
      else
      {
        long long v30 = (const void *)*((void *)v13 - 13);
        *((void *)v13 - 13) = 0;
      }
      char v31 = 1;
      goto LABEL_54;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_Volume") || CFEqual(a3, @"Volume"))
    {
      if (a4)
      {
        CFTypeID v32 = CFGetTypeID(a4);
        if (v32 != CFNumberGetTypeID()) {
          goto LABEL_155;
        }
        uint64_t v33 = (const void *)*((void *)v13 - 12);
        *((void *)v13 - 12) = a4;
        CFRetain(a4);
      }
      else
      {
        uint64_t v33 = (const void *)*((void *)v13 - 12);
        *((void *)v13 - 12) = 0;
      }
      if (v33) {
        CFRelease(v33);
      }
      long long v23 = kFigTrackProperty_Volume;
      goto LABEL_31;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_AlternateGroupID") || CFEqual(a3, @"AlternateGroupID"))
    {
      if (!a4 || (CFTypeID v34 = CFGetTypeID(a4), v34 == CFNumberGetTypeID()))
      {
        LOWORD(valuePtr.width) = 0;
        CFNumberGetValue((CFNumberRef)a4, kCFNumberSInt16Type, &valuePtr);
        long long v35 = (const void *)*((void *)v13 - 7);
        if (LOWORD(valuePtr.width))
        {
          *((void *)v13 - 7) = a4;
          if (a4) {
            CFRetain(a4);
          }
          if (v35) {
            CFRelease(v35);
          }
        }
        else if (v35)
        {
          CFRelease(*((CFTypeRef *)v13 - 7));
          *((void *)v13 - 7) = 0;
        }
        long long v23 = kFigTrackProperty_AlternateGroupID;
        goto LABEL_31;
      }
      goto LABEL_155;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_Metadata"))
    {
      if (!a4) {
        goto LABEL_32;
      }
      CFTypeID v36 = CFGetTypeID(a4);
      if (v36 != CFArrayGetTypeID()) {
        goto LABEL_155;
      }
      CFIndex Count = CFArrayGetCount((CFArrayRef)a4);
      if (Count < 1) {
        goto LABEL_32;
      }
      CFIndex v37 = 0;
      int64_t value = (void *)*MEMORY[0x1E4F1CFD0];
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a4, v37);
        if (!ValueAtIndex) {
          goto LABEL_102;
        }
        CFDictionaryRef v39 = ValueAtIndex;
        CFTypeID v40 = CFGetTypeID(ValueAtIndex);
        if (v40 != CFDictionaryGetTypeID()) {
          goto LABEL_102;
        }
        CMTime v41 = CFDictionaryGetValue(v39, @"format");
        CFDictionaryRef v42 = CFDictionaryGetValue(v39, @"items");
        if (v41)
        {
          CFTypeID v43 = v42;
          if (v42)
          {
            CFDictionaryRef v44 = (const __CFDictionary *)*((void *)v13 - 11);
            if (v44)
            {
              CFDictionaryGetValue(v44, v41);
              if (FigCFEqual()) {
                goto LABEL_102;
              }
              uint64_t v45 = (__CFDictionary *)*((void *)v13 - 11);
            }
            else
            {
              uint64_t v45 = CFDictionaryCreateMutable(v10, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              *((void *)v13 - 11) = v45;
            }
            CFDictionarySetValue(v45, v41, v43);
          }
        }
        CFDictionarySetValue(Mutable, v41, value);
        CFDictionarySetValue(Mutable, @"MetadataReaderTypes", value);
        CFDictionarySetValue(Mutable, @"MetadataReaders", value);
        if (FigCFEqual())
        {
          uint64_t v46 = (CFTypeRef *)(v13 - 72);
          goto LABEL_100;
        }
        if (FigCFEqual())
        {
          uint64_t v46 = (CFTypeRef *)(v13 - 64);
          goto LABEL_100;
        }
        if (FigCFEqual())
        {
          uint64_t v46 = (CFTypeRef *)(v13 - 80);
LABEL_100:
          if (*v46)
          {
            CFRelease(*v46);
            *uint64_t v46 = 0;
          }
        }
LABEL_102:
        uint64_t v15 = 0;
        if (Count == ++v37) {
          goto LABEL_156;
        }
      }
    }
    if (CFEqual(a3, @"MutableCompositionTrack_Enabled") || CFEqual(a3, @"IsEnabled"))
    {
      if (a4)
      {
        CFTypeID v47 = CFGetTypeID(a4);
        if (v47 != CFBooleanGetTypeID()) {
          goto LABEL_155;
        }
      }
      *uint64_t v13 = CFBooleanGetValue((CFBooleanRef)a4) != 0;
      long long v23 = kFigTrackProperty_Enabled;
LABEL_31:
      CFDictionarySetValue(Mutable, *v23, (const void *)*MEMORY[0x1E4F1CFD0]);
LABEL_32:
      uint64_t v15 = 0;
      goto LABEL_156;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_FormatDescriptionReplacementTable"))
    {
      uint64_t v48 = compositionTableTrack_setFormatDescriptionReplacementTable((uint64_t)(v13 - 160), a4);
      uint64_t v15 = 0;
      if (v48)
      {
        char v14 = 0;
        uint64_t v15 = v48;
        goto LABEL_166;
      }
      goto LABEL_156;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_Layer"))
    {
      if (a4)
      {
        CFTypeID v49 = CFGetTypeID(a4);
        if (v49 != CFNumberGetTypeID()) {
          goto LABEL_155;
        }
        uint64_t v50 = (const void *)*((void *)v13 - 5);
        *((void *)v13 - 5) = a4;
        CFRetain(a4);
      }
      else
      {
        uint64_t v50 = (const void *)*((void *)v13 - 5);
        *((void *)v13 - 5) = 0;
      }
      if (v50) {
        CFRelease(v50);
      }
      long long v23 = kFigTrackProperty_Layer;
      goto LABEL_31;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_CleanApertureDimensions"))
    {
      if (!a4)
      {
        long long v59 = (const void *)*((void *)v13 - 4);
        if (v59)
        {
          CFRelease(v59);
          *((void *)v13 - 4) = 0;
        }
        goto LABEL_138;
      }
      CFTypeID v51 = CFGetTypeID(a4);
      if (v51 != CFDictionaryGetTypeID()) {
        goto LABEL_155;
      }
      valuePtr.width = 0.0;
      valuePtr.height = 0.0;
      if (!CGSizeMakeWithDictionaryRepresentation((CFDictionaryRef)a4, &valuePtr)) {
        goto LABEL_155;
      }
      CFDictionaryRef DictionaryRepresentation = CGSizeCreateDictionaryRepresentation(valuePtr);
      if (DictionaryRepresentation)
      {
        CFDictionaryRef v53 = DictionaryRepresentation;
        CMTime v54 = (const void *)*((void *)v13 - 4);
        *((void *)v13 - 4) = DictionaryRepresentation;
        CFRetain(DictionaryRepresentation);
        if (v54) {
          CFRelease(v54);
        }
        CFRelease(v53);
LABEL_138:
        long long v23 = kFigTrackProperty_CleanApertureDimensions;
        goto LABEL_31;
      }
LABEL_184:
      uint64_t v15 = FigSignalErrorAt();
      char v14 = 0;
      goto LABEL_166;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_ProductionApertureDimensions"))
    {
      if (a4)
      {
        CFTypeID v55 = CFGetTypeID(a4);
        if (v55 != CFDictionaryGetTypeID()) {
          goto LABEL_155;
        }
        valuePtr.width = 0.0;
        valuePtr.height = 0.0;
        if (!CGSizeMakeWithDictionaryRepresentation((CFDictionaryRef)a4, &valuePtr)) {
          goto LABEL_155;
        }
        CFDictionaryRef v56 = CGSizeCreateDictionaryRepresentation(valuePtr);
        if (!v56) {
          goto LABEL_184;
        }
        CFDictionaryRef v57 = v56;
        int v58 = (const void *)*((void *)v13 - 3);
        *((void *)v13 - 3) = v56;
        CFRetain(v56);
        if (v58) {
          CFRelease(v58);
        }
        CFRelease(v57);
      }
      else
      {
        CMTimeValue v64 = (const void *)*((void *)v13 - 3);
        if (v64)
        {
          CFRelease(v64);
          *((void *)v13 - 3) = 0;
        }
      }
      long long v23 = kFigTrackProperty_ProductionApertureDimensions;
      goto LABEL_31;
    }
    if (CFEqual(a3, @"MutableCompositionTrack_EncodedPixelsDimensions"))
    {
      if (a4)
      {
        CFTypeID v60 = CFGetTypeID(a4);
        if (v60 != CFDictionaryGetTypeID()) {
          goto LABEL_155;
        }
        valuePtr.width = 0.0;
        valuePtr.height = 0.0;
        if (!CGSizeMakeWithDictionaryRepresentation((CFDictionaryRef)a4, &valuePtr)) {
          goto LABEL_155;
        }
        CFDictionaryRef v61 = CGSizeCreateDictionaryRepresentation(valuePtr);
        if (!v61) {
          goto LABEL_184;
        }
        CFDictionaryRef v62 = v61;
        uint64_t v63 = (const void *)*((void *)v13 - 2);
        *((void *)v13 - 2) = v61;
        CFRetain(v61);
        if (v63) {
          CFRelease(v63);
        }
        CFRelease(v62);
      }
      else
      {
        int v73 = (const void *)*((void *)v13 - 2);
        if (v73)
        {
          CFRelease(v73);
          *((void *)v13 - 2) = 0;
        }
      }
      long long v23 = kFigTrackProperty_EncodedPixelsDimensions;
      goto LABEL_31;
    }
    if (!CFEqual(a3, @"MutableCompositionTrack_LoadSettings"))
    {
      uint64_t v15 = 4294954512;
LABEL_156:
      MEMORY[0x19970E930](v8[1]);
      if (CFDictionaryGetCount(Mutable))
      {
        uint64_t v69 = *v9;
        if (v69)
        {
          uint64_t v70 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v70) {
            uint64_t v71 = v70;
          }
          else {
            uint64_t v71 = 0;
          }
          signed int v72 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *, void))(v71 + 56);
          if (!v72)
          {
            char v14 = 1;
            uint64_t v15 = 4294954514;
            goto LABEL_166;
          }
          uint64_t v15 = v72(v69, a2, &v77, 0);
          if (!v15)
          {
            CMNotificationCenterGetDefaultLocalCenter();
            CMNotificationCenterPostNotification();
          }
        }
      }
      char v14 = 1;
LABEL_166:
      if (v77) {
        CFRelease(v77);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      if ((v14 & 1) == 0) {
        MEMORY[0x19970E930](v8[1]);
      }
      return v15;
    }
    if (a4)
    {
      CFTypeID v65 = CFGetTypeID(a4);
      if (v65 != CFDictionaryGetTypeID()) {
        goto LABEL_155;
      }
      CFDictionaryRef v66 = CFDictionaryCreateCopy(v10, (CFDictionaryRef)a4);
      a4 = (const __CFString *)v66;
      uint64_t v67 = (const void *)*((void *)v13 - 1);
      *((void *)v13 - 1) = v66;
      if (v66)
      {
        CFRetain(v66);
        char v68 = 0;
LABEL_179:
        if (v67) {
          CFRelease(v67);
        }
        if ((v68 & 1) == 0) {
          CFRelease(a4);
        }
        long long v23 = kFigTrackProperty_QTLoadSettings;
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v67 = (const void *)*((void *)v13 - 1);
      *((void *)v13 - 1) = 0;
    }
    char v68 = 1;
    goto LABEL_179;
  }

  return FigSignalErrorAt();
}

uint64_t mutableComposition_InsertAssetSegmentIntoTrack(uint64_t a1, int a2, uint64_t a3, int a4, CMTime *a5, CMTime *a6, uint64_t a7)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v14 = 4294954516;
  if (!a3) {
    return v14;
  }
  if (!a4) {
    return v14;
  }
  if ((a5->flags & 0x1D) != 1) {
    return v14;
  }
  uint64_t v15 = (void *)DerivedStorage;
  uint64_t v16 = *(void *)(DerivedStorage + 8);
  CMTime time1 = *a5;
  CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  if (CMTimeCompare(&time1, &time2) < 0) {
    return v14;
  }
  int v17 = *(_DWORD *)(a7 + 12);
  if (v17 & 0x1D) != 1 && (v17) {
    return v14;
  }
  MEMORY[0x19970E910](*(void *)(v16 + 8));
  uint64_t v19 = *(void *)(v16 + 16);
  if (v19 < 1)
  {
LABEL_12:
    MEMORY[0x19970E930](*(void *)(v16 + 8), v18);
    return v14;
  }
  uint64_t v18 = *(void *)(v16 + 32);
  while (*(_DWORD *)(v18 + 4) != a2)
  {
    v18 += 168;
    if (!--v19)
    {
      uint64_t v14 = 4294954516;
      goto LABEL_12;
    }
  }
  CMTime time1 = *a5;
  CMTime time2 = *a6;
  long long v22 = *(_OWORD *)a7;
  uint64_t v23 = *(void *)(a7 + 16);
  uint64_t inserted = compositionTable_insertAssetSegmentIntoTrack(v16, (void *)v18, a3, a4, (uint64_t)&time1, (uint64_t)&time2, &v22);
  if (inserted)
  {
    uint64_t v14 = inserted;
    goto LABEL_12;
  }
  ++*(_DWORD *)(v16 + 4);
  MEMORY[0x19970E930](*(void *)(v16 + 8));
  if (*v15) {
    mutableComposition_postPossiblyDeferredTracksChangedNotification();
  }
  return 0;
}

uint64_t mutableComposition_InsertAssetSegment(uint64_t a1, const void *a2, CMTime *a3, CMTime *a4, CMTime *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v10 = *(void *)(DerivedStorage + 8);
  uint64_t v59 = 0;
  v60[0] = 0;
  int v58 = 0;
  int v57 = 0;
  CFTypeRef v56 = 0;
  if (!a2)
  {
    CFIndex v20 = 0;
    uint64_t v39 = 4294954516;
    goto LABEL_61;
  }
  if ((a3->flags & 0x1D) != 1) {
    goto LABEL_66;
  }
  uint64_t v11 = (void *)DerivedStorage;
  CMTime time1 = *a3;
  long long v42 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&time2.int value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v12 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  time2.CMTimeEpoch epoch = v12;
  if (CMTimeCompare(&time1, &time2) < 0) {
    goto LABEL_66;
  }
  CMTime time1 = *a4;
  *(_OWORD *)&time2.int value = v42;
  time2.CMTimeEpoch epoch = v12;
  if (CMTimeCompare(&time1, &time2) < 1) {
    goto LABEL_66;
  }
  CMTimeFlags flags = a5->flags;
  if (flags & 0x1D) != 1 && (flags) {
    goto LABEL_66;
  }
  if ((flags & 0x1D) == 1)
  {
    CMTime time1 = *a5;
    *(_OWORD *)&time2.int value = v42;
    time2.CMTimeEpoch epoch = v12;
    if (CMTimeCompare(&time1, &time2) < 0)
    {
      uint64_t v14 = FigSignalErrorAt();
      goto LABEL_70;
    }
  }
  uint64_t v43 = *MEMORY[0x1E4F1CF80];
  uint64_t v14 = compositionSharedCache_copyFormatReaderForAssetURL(*(void *)(v10 + 160), a2, (const __CFAllocator *)*MEMORY[0x1E4F1CF80], (uint64_t)v60);
  if (v14)
  {
LABEL_70:
    uint64_t v39 = v14;
    CFIndex v20 = 0;
    goto LABEL_59;
  }
  CFTypeRef v15 = v60[0];
  if (!v60[0])
  {
LABEL_66:
    CFIndex v20 = 0;
    uint64_t v39 = 4294954516;
    goto LABEL_59;
  }
  uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v16) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v18 = *(uint64_t (**)(CFTypeRef, uint64_t *))(v17 + 8);
  if (!v18)
  {
    CFIndex v20 = 0;
    uint64_t v39 = 4294954514;
    goto LABEL_59;
  }
  uint64_t v14 = v18(v15, &v59);
  if (v14) {
    goto LABEL_70;
  }
  MEMORY[0x19970E910](*(void *)(v10 + 8));
  if ((a5->flags & 0x1D) != 1)
  {
    compositionTable_getDuration((CMTime *)v10, &time1);
    *a5 = time1;
  }
  uint64_t v19 = (uint64_t *)malloc_type_calloc(*(void *)(v10 + 16), 8uLL, 0x100004000313F17uLL);
  CFIndex v20 = v19;
  if (v19)
  {
    CMTime v41 = v11;
    uint64_t v21 = *(void *)(v10 + 16);
    uint64_t v54 = 0;
    if (v21 >= 1)
    {
      uint64_t v22 = 0;
      do
      {
        v19[v22] = v22;
        uint64_t v22 = v54 + 1;
        uint64_t v54 = v22;
      }
      while (v22 < *(void *)(v10 + 16));
    }
    if (v59 < 1)
    {
      uint64_t v37 = v21;
LABEL_55:
      CMTime time1 = *a5;
      CMTime time2 = *a4;
      uint64_t inserted = tableTrack_InsertEmptyEditsInTracks(a1, v20, v37, (uint64_t)&time1, &time2);
      if (!inserted)
      {
        ++*(_DWORD *)(v10 + 4);
        MEMORY[0x19970E930](*(void *)(v10 + 8));
        if (*v41) {
          mutableComposition_postPossiblyDeferredTracksChangedNotification();
        }
        uint64_t v39 = 0;
        goto LABEL_59;
      }
LABEL_67:
      uint64_t v39 = inserted;
    }
    else
    {
      uint64_t v23 = 0;
      while (1)
      {
        LODWORD(time2.value) = 0;
        CFTypeRef v24 = v60[0];
        uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v26 = v25 ? v25 : 0;
        char v27 = *(uint64_t (**)(CFTypeRef, uint64_t, CFTypeRef *, int *, CMTime *))(v26 + 48);
        if (!v27) {
          break;
        }
        uint64_t inserted = v27(v24, v23, &v56, &v57, &time2);
        if (inserted) {
          goto LABEL_67;
        }
        uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(v56);
        uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 8);
        uint64_t v31 = v30 ? v30 : 0;
        CFTypeID v32 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, const void **))(v31 + 48);
        if (!v32) {
          break;
        }
        uint64_t inserted = v32(FigBaseObject, @"TrackFormatDescriptionArray", v43, &v58);
        if (inserted) {
          goto LABEL_67;
        }
        long long v48 = *(_OWORD *)&a5->value;
        CMTimeEpoch epoch = a5->epoch;
        long long v50 = *(_OWORD *)&a4->value;
        CMTimeEpoch v51 = a4->epoch;
        *(_OWORD *)&time1.int value = *(_OWORD *)&a3->value;
        CMTimeEpoch v33 = a3->epoch;
        CMTimeEpoch v47 = v51;
        long long v46 = v50;
        time1.CMTimeEpoch epoch = v33;
        CMTime v52 = a2;
        int value = time2.value;
        uint64_t v54 = 0;
        uint64_t inserted = compositionTable_insertEditSegmentsFromAsset(a1, v20, v21, v58, v57, (uint64_t)&time1, 1, &v54);
        if (inserted) {
          goto LABEL_67;
        }
        if (v21 < 1)
        {
          uint64_t v37 = v21;
        }
        else
        {
          uint64_t v34 = 0;
          uint64_t v35 = 0;
          uint64_t v36 = v54;
          uint64_t v37 = v21;
          do
          {
            uint64_t v38 = v20[v35];
            if (v38 == v36)
            {
              --v37;
            }
            else
            {
              if (v35 != v34) {
                v20[v34] = v38;
              }
              ++v34;
            }
            ++v35;
          }
          while (v21 != v35);
        }
        if (v58)
        {
          CFRelease(v58);
          int v58 = 0;
        }
        if (v56)
        {
          CFRelease(v56);
          CFTypeRef v56 = 0;
        }
        ++v23;
        uint64_t v21 = v37;
        if (v23 >= v59) {
          goto LABEL_55;
        }
      }
      uint64_t v39 = 4294954514;
    }
  }
  else
  {
    uint64_t v39 = 4294954510;
  }
  MEMORY[0x19970E930](*(void *)(v10 + 8));
LABEL_59:
  if (v56) {
    CFRelease(v56);
  }
LABEL_61:
  if (v60[0]) {
    CFRelease(v60[0]);
  }
  if (v58) {
    CFRelease(v58);
  }
  free(v20);
  return v39;
}

uint64_t mutableComposition_InsertEmptyTrackSegment(uint64_t a1, int a2, CMTime *a3, CMTime *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if ((a3->flags & 0x1D) != 1) {
    return 4294954516;
  }
  uint64_t v8 = (void *)DerivedStorage;
  uint64_t v9 = *(void *)(DerivedStorage + 8);
  MEMORY[0x19970E910](*(void *)(v9 + 8));
  uint64_t v10 = *(void *)(v9 + 16);
  if (v10 < 1)
  {
LABEL_6:
    uint64_t v12 = 4294954516;
LABEL_7:
    MEMORY[0x19970E930](*(void *)(v9 + 8));
    return v12;
  }
  uint64_t v11 = *(void *)(v9 + 32);
  while (*(_DWORD *)(v11 + 4) != a2)
  {
    v11 += 168;
    if (!--v10) {
      goto LABEL_6;
    }
  }
  CMTime v16 = *a3;
  CMTime v15 = *a4;
  uint64_t inserted = compositionTable_insertEmptyTrackSegment(v9, (void *)v11, &v16, &v15);
  if (inserted)
  {
    uint64_t v12 = inserted;
    goto LABEL_7;
  }
  ++*(_DWORD *)(v9 + 4);
  MEMORY[0x19970E930](*(void *)(v9 + 8));
  if (*v8) {
    mutableComposition_postPossiblyDeferredTracksChangedNotification();
  }
  return 0;
}

uint64_t mutableComposition_InsertEmptySegment(uint64_t a1, uint64_t a2, CMTime *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if ((*(_DWORD *)(a2 + 12) & 0x1D) != 1) {
    return 4294954516;
  }
  uint64_t v6 = (void *)DerivedStorage;
  uint64_t v7 = *(void *)(DerivedStorage + 8);
  MEMORY[0x19970E910](*(void *)(v7 + 8));
  uint64_t v8 = *(void *)(v7 + 16);
  if (v8 < 1)
  {
    int v20 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = (CMTime *)MEMORY[0x1E4F1FA48];
    do
    {
      uint64_t v13 = *(void *)(v7 + 32);
      uint64_t v14 = (void *)(v13 + v9);
      if (*(uint64_t *)(v13 + v9 + 8) >= 1)
      {
        CMTime v24 = *v12;
        uint64_t v15 = v14[1];
        if (v15 >= 1)
        {
          uint64_t v16 = *(void *)(v13 + v9 + 16) + 108 * v15;
          long long v17 = *(_OWORD *)(v16 - 60);
          long long v18 = *(_OWORD *)(v16 - 28);
          *(_OWORD *)&range.start.CMTimeEpoch epoch = *(_OWORD *)(v16 - 44);
          *(_OWORD *)&range.duration.CMTimeScale timescale = v18;
          *(_OWORD *)&range.start.int value = v17;
          CMTimeRangeGetEnd(&v24, &range);
        }
        *(_OWORD *)&range.start.int value = *(_OWORD *)a2;
        range.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
        CMTime time2 = v24;
        if (CMTimeCompare(&range.start, &time2) < 0)
        {
          *(_OWORD *)&range.start.int value = *(_OWORD *)a2;
          range.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
          CMTime time2 = *a3;
          uint64_t inserted = compositionTable_insertEmptyTrackSegment(v7, v14, &range.start, &time2);
          if (inserted)
          {
            uint64_t v21 = inserted;
            MEMORY[0x19970E930](*(void *)(v7 + 8));
            return v21;
          }
          ++v11;
        }
        uint64_t v8 = *(void *)(v7 + 16);
      }
      ++v10;
      v9 += 168;
    }
    while (v10 < v8);
    if (v11 < 1)
    {
      int v20 = 0;
    }
    else
    {
      ++*(_DWORD *)(v7 + 4);
      int v20 = 1;
    }
  }
  MEMORY[0x19970E930](*(void *)(v7 + 8));
  uint64_t v21 = 0;
  if (v20 && *v6)
  {
    mutableComposition_postPossiblyDeferredTracksChangedNotification();
    return 0;
  }
  return v21;
}

uint64_t mutableComposition_DeleteTrackSegment(uint64_t a1, int a2, CMTime *a3, CMTime *a4)
{
  uint64_t v7 = *(void **)(CMBaseObjectGetDerivedStorage() + 8);
  MEMORY[0x19970E910](v7[1]);
  uint64_t v8 = v7[2];
  if (v8 < 1)
  {
LABEL_5:
    MEMORY[0x19970E930](v7[1]);
    return 4294954516;
  }
  else
  {
    uint64_t v9 = v7[4];
    while (*(_DWORD *)(v9 + 4) != a2)
    {
      v9 += 168;
      if (!--v8) {
        goto LABEL_5;
      }
    }
    CMTime v13 = *a3;
    CMTime v12 = *a4;
    uint64_t v10 = compositionTable_deleteTrackSegment((uint64_t)v7, (void *)v9, &v13, &v12);
    MEMORY[0x19970E930](v7[1]);
    compositionTable_discardUnusedAssets((uint64_t)v7);
  }
  return v10;
}

uint64_t mutableComposition_DeleteSegment(uint64_t a1, uint64_t a2, CMTime *a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v6 = DerivedStorage[1];
  MEMORY[0x19970E910](*(void *)(v6 + 8));
  uint64_t v7 = *(void *)(v6 + 16);
  if (v7 < 1)
  {
    int v19 = 0;
  }
  else
  {
    uint64_t v8 = 0;
    unint64_t v9 = v7 + 1;
    uint64_t v10 = 168 * v7;
    uint64_t v11 = (CMTime *)MEMORY[0x1E4F1FA48];
    do
    {
      uint64_t v12 = *(void *)(v6 + 32);
      uint64_t v13 = v12 + v10;
      if (*(uint64_t *)(v12 + v10 - 160) >= 1)
      {
        CMTime v23 = *v11;
        uint64_t v14 = *(void *)(v13 - 160);
        if (v14 >= 1)
        {
          uint64_t v15 = *(void *)(v12 + v10 - 152) + 108 * v14;
          long long v16 = *(_OWORD *)(v15 - 60);
          long long v17 = *(_OWORD *)(v15 - 28);
          *(_OWORD *)&range.start.CMTimeEpoch epoch = *(_OWORD *)(v15 - 44);
          *(_OWORD *)&range.duration.CMTimeScale timescale = v17;
          *(_OWORD *)&range.start.int value = v16;
          CMTimeRangeGetEnd(&v23, &range);
        }
        *(_OWORD *)&range.start.int value = *(_OWORD *)a2;
        range.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
        CMTime time2 = v23;
        if (CMTimeCompare(&range.start, &time2) < 0)
        {
          *(_OWORD *)&range.start.int value = *(_OWORD *)a2;
          range.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
          CMTime time2 = *a3;
          uint64_t v18 = compositionTable_deleteTrackSegment(v6, (void *)(v13 - 168), &range.start, &time2);
          if (v18)
          {
            uint64_t v20 = v18;
            MEMORY[0x19970E930](*(void *)(v6 + 8));
            return v20;
          }
          ++v8;
        }
      }
      --v9;
      v10 -= 168;
    }
    while (v9 > 1);
    if (v8 < 1)
    {
      int v19 = 0;
    }
    else
    {
      ++*(_DWORD *)(v6 + 4);
      int v19 = 1;
    }
  }
  MEMORY[0x19970E930](*(void *)(v6 + 8));
  compositionTable_discardUnusedAssets(v6);
  uint64_t v20 = 0;
  if (v19 && *DerivedStorage)
  {
    mutableComposition_postPossiblyDeferredTracksChangedNotification();
    return 0;
  }
  return v20;
}

uint64_t mutableComposition_ScaleTrackSegment(uint64_t a1, int a2, long long *a3, CMTime *a4, CMTime *a5)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v10 = DerivedStorage[1];
  MEMORY[0x19970E910](*(void *)(v10 + 8));
  uint64_t v11 = *(void *)(v10 + 16);
  if (v11 < 1)
  {
LABEL_5:
    uint64_t v13 = 4294954516;
LABEL_6:
    MEMORY[0x19970E930](*(void *)(v10 + 8));
    return v13;
  }
  uint64_t v12 = *(void *)(v10 + 32);
  while (*(_DWORD *)(v12 + 4) != a2)
  {
    v12 += 168;
    if (!--v11) {
      goto LABEL_5;
    }
  }
  long long v18 = *a3;
  uint64_t v19 = *((void *)a3 + 2);
  CMTime v17 = *a4;
  CMTime v16 = *a5;
  uint64_t v14 = compositionTable_scaleTrackSegment(v10, (void *)v12, (uint64_t)&v18, &v17, &v16);
  if (v14)
  {
    uint64_t v13 = v14;
    goto LABEL_6;
  }
  ++*(_DWORD *)(v10 + 4);
  MEMORY[0x19970E930](*(void *)(v10 + 8));
  if (*DerivedStorage) {
    mutableComposition_postPossiblyDeferredTracksChangedNotification();
  }
  return 0;
}

uint64_t mutableComposition_ScaleSegment(uint64_t a1, uint64_t a2, CMTime *a3, CMTime *a4)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v8 = DerivedStorage[1];
  MEMORY[0x19970E910](*(void *)(v8 + 8));
  uint64_t v9 = *(void *)(v8 + 16);
  if (v9 < 1)
  {
    int v21 = 0;
  }
  else
  {
    CMTime v24 = DerivedStorage;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = (CMTime *)MEMORY[0x1E4F1FA48];
    do
    {
      uint64_t v14 = *(void *)(v8 + 32);
      uint64_t v15 = (void *)(v14 + v10);
      if (*(uint64_t *)(v14 + v10 + 8) >= 1)
      {
        CMTime v27 = *v13;
        uint64_t v16 = v15[1];
        if (v16 >= 1)
        {
          uint64_t v17 = *(void *)(v14 + v10 + 16) + 108 * v16;
          long long v18 = *(_OWORD *)(v17 - 60);
          long long v19 = *(_OWORD *)(v17 - 28);
          *(_OWORD *)&range.start.CMTimeEpoch epoch = *(_OWORD *)(v17 - 44);
          *(_OWORD *)&range.duration.CMTimeScale timescale = v19;
          *(_OWORD *)&range.start.int value = v18;
          CMTimeRangeGetEnd(&v27, &range);
        }
        *(_OWORD *)&range.start.int value = *(_OWORD *)a2;
        range.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
        CMTime time2 = v27;
        if (CMTimeCompare(&range.start, &time2) < 0)
        {
          *(_OWORD *)&range.start.int value = *(_OWORD *)a2;
          range.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
          CMTime time2 = *a3;
          CMTime v25 = *a4;
          uint64_t v20 = compositionTable_scaleTrackSegment(v8, v15, (uint64_t)&range, &time2, &v25);
          if (v20)
          {
            uint64_t v22 = v20;
            MEMORY[0x19970E930](*(void *)(v8 + 8));
            return v22;
          }
          ++v12;
        }
        uint64_t v9 = *(void *)(v8 + 16);
      }
      ++v11;
      v10 += 168;
    }
    while (v11 < v9);
    if (v12 < 1)
    {
      int v21 = 0;
    }
    else
    {
      ++*(_DWORD *)(v8 + 4);
      int v21 = 1;
    }
    uint64_t DerivedStorage = v24;
  }
  MEMORY[0x19970E930](*(void *)(v8 + 8));
  uint64_t v22 = 0;
  if (v21 && *DerivedStorage)
  {
    mutableComposition_postPossiblyDeferredTracksChangedNotification();
    return 0;
  }
  return v22;
}

uint64_t mutableComposition_DeferTracksChangedNotifications()
{
  *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 16) = 1;
  return 0;
}

uint64_t mutableComposition_PostDeferredTracksChangedNotification()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(unsigned char *)(DerivedStorage + 16) = 0;
  if (*(unsigned char *)(DerivedStorage + 17))
  {
    uint64_t v1 = DerivedStorage;
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    *(unsigned char *)(v1 + 17) = 0;
  }
  return 0;
}

uint64_t mutableComposition_InsertSegmentArrayIntoTrack(uint64_t a1, int a2, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, const __CFArray *a6, CMTime *a7)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v11 = 0;
  uint64_t v12 = *(void *)(DerivedStorage + 8);
  CMTime v85 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  CMTime v84 = v85;
  long long v80 = *(_OWORD *)&v85.value;
  CMTime v83 = v85;
  CMTimeEpoch epoch = v85.epoch;
  uint64_t v13 = 4294954516;
  CFArrayRef theArray = a3;
  if (!a3 || !a4 || !a5)
  {
    uint64_t v14 = 0;
    goto LABEL_65;
  }
  uint64_t v14 = 0;
  if (a6)
  {
    uint64_t v15 = (void *)DerivedStorage;
    CMTimeFlags flags = a7->flags;
    if ((flags & 0x1D) == 1 || (flags & 1) == 0)
    {
      if ((flags & 0x1D) == 1
        && (*(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&a7->value,
            time1.start.CMTimeEpoch epoch = a7->epoch,
            CMTime time2 = v85,
            CMTimeCompare(&time1.start, &time2) < 0))
      {
        uint64_t v13 = FigSignalErrorAt();
      }
      else
      {
        int64_t Count = CFArrayGetCount(theArray);
        if (CFArrayGetCount(a4) == Count && CFArrayGetCount(a5) == Count && CFArrayGetCount(a6) == Count)
        {
          if (Count < 1)
          {
            uint64_t v11 = 0;
            uint64_t v14 = 0;
            uint64_t v13 = 0;
            goto LABEL_65;
          }
          uint64_t v14 = malloc_type_calloc(Count, 8uLL, 0x2004093837F09uLL);
          if (!v14)
          {
            uint64_t v11 = 0;
            uint64_t v13 = 4294954510;
            goto LABEL_65;
          }
          uint64_t v11 = malloc_type_calloc(Count, 8uLL, 0x100004000313F17uLL);
          if (!v11)
          {
            uint64_t v13 = 4294954510;
            goto LABEL_61;
          }
          uint64_t v69 = v15;
          uint64_t v70 = a7;
          uint64_t v72 = v12;
          CFIndex v18 = 0;
          CFArrayRef v74 = a4;
          int64_t v75 = Count;
          while (1)
          {
            int valuePtr = 0;
            CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v18);
            if (!ValueAtIndex)
            {
              uint64_t v22 = 0;
LABEL_83:
              int v47 = 0;
              uint64_t v13 = 4294954516;
              goto LABEL_51;
            }
            int v21 = ValueAtIndex;
            uint64_t v22 = CFArrayGetValueAtIndex(a4, v18);
            if (!v22) {
              goto LABEL_83;
            }
            CFTypeID TypeID = CFNumberGetTypeID();
            if (TypeID != CFGetTypeID(v22)) {
              goto LABEL_66;
            }
            CFNumberGetValue((CFNumberRef)v22, kCFNumberSInt32Type, &valuePtr);
            uint64_t v22 = CFArrayGetValueAtIndex(a5, v18);
            if (!v22) {
              goto LABEL_83;
            }
            CFTypeID v24 = CFDictionaryGetTypeID();
            if (v24 != CFGetTypeID(v22)) {
              goto LABEL_66;
            }
            CMTimeMakeFromDictionary(&time1.start, (CFDictionaryRef)v22);
            CMTimeValue value = time1.start.value;
            CMTimeFlags v25 = time1.start.flags;
            CMTimeScale timescale = time1.start.timescale;
            CMTimeEpoch v26 = time1.start.epoch;
            uint64_t v22 = CFArrayGetValueAtIndex(a6, v18);
            if (!v22) {
              goto LABEL_83;
            }
            CFTypeID v27 = CFDictionaryGetTypeID();
            if (v27 != CFGetTypeID(v22)) {
              goto LABEL_66;
            }
            CMTimeMakeFromDictionary(&time1.start, (CFDictionaryRef)v22);
            CMTimeValue v87 = time1.start.value;
            CMTimeFlags v28 = time1.start.flags;
            CMTimeScale v88 = time1.start.timescale;
            if ((time1.start.flags & 0x1D) != 1
              || (CMTimeEpoch v29 = time1.start.epoch,
                  time1.start.CMTimeValue value = v87,
                  time1.start.CMTimeScale timescale = v88,
                  *(_OWORD *)&time2.CMTimeValue value = v80,
                  time2.CMTimeEpoch epoch = epoch,
                  CMTimeCompare(&time1.start, &time2) < 0))
            {
LABEL_66:
              uint64_t v13 = FigSignalErrorAt();
              uint64_t v22 = 0;
              int v47 = 0;
LABEL_50:
              int64_t Count = v75;
              goto LABEL_51;
            }
            CFTypeID v30 = CFURLGetTypeID();
            if (v30 == CFGetTypeID(v21) || (CFTypeID v31 = CFNullGetTypeID(), v31 == CFGetTypeID(v21)))
            {
              v11[v18] = 1;
              CFTypeID v32 = malloc_type_calloc(1uLL, 0x6CuLL, 0x1060040CB727B4DuLL);
              v14[v18] = v32;
              if (!v32) {
                goto LABEL_66;
              }
              if ((v25 & 0x1D) == 1)
              {
                time1.start.CMTimeValue value = value;
                time1.start.CMTimeScale timescale = timescale;
                time1.start.CMTimeFlags flags = v25;
                time1.start.CMTimeEpoch epoch = v26;
                *(_OWORD *)&time2.CMTimeValue value = v80;
                time2.CMTimeEpoch epoch = epoch;
                if (CMTimeCompare(&time1.start, &time2) < 0) {
                  goto LABEL_66;
                }
                CFTypeID v33 = CFURLGetTypeID();
                if (v33 != CFGetTypeID(v21) || !valuePtr) {
                  goto LABEL_66;
                }
                *(void *)(v14[v18] + 96) = CFRetain(v21);
                uint64_t v34 = v14[v18];
                *(_DWORD *)(v34 + 104) = valuePtr;
                *(void *)uint64_t v34 = value;
                *(_DWORD *)(v34 + 8) = timescale;
                *(_DWORD *)(v34 + 12) = v25;
                *(void *)(v34 + 16) = v26;
                uint64_t v35 = v14[v18];
                CMTimeScale v36 = v88;
                *(void *)(v35 + 24) = v87;
                *(_DWORD *)(v35 + 32) = v36;
                *(_DWORD *)(v35 + 36) = v28;
                *(void *)(v35 + 40) = v29;
                CFTypeID v32 = (_OWORD *)v14[v18];
              }
              uint64_t v37 = MEMORY[0x1E4F1F9F8];
              v32[3] = *MEMORY[0x1E4F1F9F8];
              *((void *)v32 + 8) = *(void *)(v37 + 16);
              uint64_t v38 = v14[v18];
              *(void *)(v38 + 72) = v87;
              *(_DWORD *)(v38 + 80) = v88;
              *(_DWORD *)(v38 + 84) = v28;
              *(void *)(v38 + 88) = v29;
            }
            else
            {
              MEMORY[0x19970EE10](&FigMutableCompositionGetClassID_sRegisterFigMutableCompositionBaseTypeOnce, RegisterFigMutableCompositionBaseType);
              CFCFTypeID TypeID = CMBaseClassGetCFTypeID();
              if (CFTypeID != CFGetTypeID(v21)) {
                goto LABEL_66;
              }
              if ((_UNKNOWN *)CMBaseObjectGetVTable() != &kMutableComposition_VTable) {
                goto LABEL_66;
              }
              if ((v25 & 0x1D) != 1) {
                goto LABEL_66;
              }
              time1.start.CMTimeValue value = value;
              time1.start.CMTimeScale timescale = timescale;
              time1.start.CMTimeFlags flags = v25;
              time1.start.CMTimeEpoch epoch = v26;
              *(_OWORD *)&time2.CMTimeValue value = v80;
              time2.CMTimeEpoch epoch = epoch;
              if (CMTimeCompare(&time1.start, &time2) < 0 || !valuePtr) {
                goto LABEL_66;
              }
              uint64_t v22 = *(void **)(CMBaseObjectGetDerivedStorage() + 8);
              MEMORY[0x19970E910](v22[1]);
              uint64_t v40 = v22[2];
              if (v40 < 1)
              {
LABEL_49:
                int v47 = 1;
                uint64_t v13 = 4294954516;
                goto LABEL_50;
              }
              unint64_t v20 = v22[4];
              while (*(_DWORD *)(v20 + 4) != valuePtr)
              {
                v20 += 168;
                if (!--v40) {
                  goto LABEL_49;
                }
              }
              time1.start.CMTimeValue value = value;
              uint64_t v41 = (uint64_t)v22;
              long long v42 = &v14[v18];
              time1.start.CMTimeScale timescale = timescale;
              time1.start.CMTimeFlags flags = v25;
              time1.start.CMTimeEpoch epoch = v26;
              uint64_t v43 = (void *)v41;
              time2.CMTimeValue value = v87;
              time2.CMTimeScale timescale = v88;
              time2.CMTimeFlags flags = v28;
              CFDictionaryRef v44 = &v11[v18];
              time2.CMTimeEpoch epoch = v29;
              uint64_t v45 = compositionTable_copyAssetSegmentsFromTrackForTimeRange(v41, v20, &time1.start, (uint64_t)&time2, v42, v44);
              if (v45)
              {
                uint64_t v13 = v45;
                int v47 = 1;
                goto LABEL_81;
              }
              MEMORY[0x19970E930](v43[1]);
              uint64_t v46 = compositionEditSegment_validateSegments(*v42, *v44, 0);
              if (v46)
              {
                uint64_t v13 = v46;
                int v47 = 0;
LABEL_81:
                int64_t Count = v75;
                uint64_t v22 = v43;
LABEL_51:
                if (v47 && v22)
                {
                  uint64_t v48 = v22[1];
LABEL_60:
                  MEMORY[0x19970E930](v48, v20);
                }
LABEL_61:
                for (uint64_t i = 0; i != Count; ++i)
                {
                  uint64_t v52 = v14[i];
                  if (v52)
                  {
                    compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag(v52, v11[i], 0);
                    free((void *)v14[i]);
                  }
                }
                goto LABEL_65;
              }
              mutableComposition_addAssetsForURLsFromCompositionForSegments(a1, (uint64_t)v21, *v42, *v44);
            }
            a4 = v74;
            int64_t Count = v75;
            if (++v18 == v75)
            {
              MEMORY[0x19970E910](*(void *)(v72 + 8));
              uint64_t v49 = *(void *)(v72 + 16);
              if (v49 < 1)
              {
LABEL_58:
                uint64_t v13 = 4294954516;
LABEL_59:
                uint64_t v48 = *(void *)(v72 + 8);
                goto LABEL_60;
              }
              uint64_t v50 = *(void *)(v72 + 32);
              while (*(_DWORD *)(v50 + 4) != a2)
              {
                v50 += 168;
                if (!--v49) {
                  goto LABEL_58;
                }
              }
              *(_OWORD *)&time2.CMTimeValue value = v80;
              time2.CMTimeEpoch epoch = epoch;
              uint64_t v54 = *(void *)(v50 + 8);
              if (v54 >= 1)
              {
                uint64_t v55 = *(void *)(v50 + 16) + 108 * v54;
                long long v56 = *(_OWORD *)(v55 - 60);
                long long v57 = *(_OWORD *)(v55 - 28);
                *(_OWORD *)&time1.start.CMTimeEpoch epoch = *(_OWORD *)(v55 - 44);
                *(_OWORD *)&time1.duration.CMTimeScale timescale = v57;
                *(_OWORD *)&time1.start.CMTimeValue value = v56;
                CMTimeRangeGetEnd(&time2, &time1);
              }
              uint64_t v58 = 0;
              v83.CMTimeEpoch epoch = time2.epoch;
              int v59 = v70->flags & 0x1D;
              *(_OWORD *)&v83.CMTimeValue value = *(_OWORD *)&time2.value;
              BOOL v60 = v59 == 1;
              CFDictionaryRef v61 = &v83;
              if (v60) {
                CFDictionaryRef v61 = v70;
              }
              CMTime v84 = *v61;
              CMTime v85 = v84;
              do
              {
                CFDictionaryRef v62 = (CMTime *)v14[v58];
                uint64_t v63 = v11[v58];
                time1.CMTime start = v85;
                compositionEditSegment_adjustSegmentStartTimes(v62, v63, &time1.start);
                uint64_t inserted = compositionTable_insertEditSegmentsIntoTrack(v72, (void *)v50, v14[v58], v11[v58]);
                if (inserted)
                {
                  uint64_t v13 = inserted;
                  goto LABEL_59;
                }
                if ((uint64_t)v11[v58] >= 1)
                {
                  uint64_t v65 = 0;
                  uint64_t v66 = 72;
                  do
                  {
                    uint64_t v67 = v14[v58] + v66;
                    time1.CMTime start = v85;
                    long long v68 = *(_OWORD *)v67;
                    time2.CMTimeEpoch epoch = *(void *)(v67 + 16);
                    *(_OWORD *)&time2.CMTimeValue value = v68;
                    CMTimeAdd(&v85, &time1.start, &time2);
                    ++v65;
                    v66 += 108;
                  }
                  while (v65 < v11[v58]);
                }
                ++v58;
              }
              while (v58 != v75);
              ++*(_DWORD *)(v72 + 4);
              MEMORY[0x19970E930](*(void *)(v72 + 8));
              if (*v69) {
                mutableComposition_postPossiblyDeferredTracksChangedNotification();
              }
              uint64_t v13 = 0;
              goto LABEL_61;
            }
          }
        }
      }
    }
    uint64_t v11 = 0;
    uint64_t v14 = 0;
  }
LABEL_65:
  free(v14);
  free(v11);
  return v13;
}

uint64_t mutableComposition_AddAssetForURL(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage() + 8);
  int v19 = 0;
  CFTypeRef cf = 0;
  if (a2 && a3)
  {
    uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v6) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v8 = *(uint64_t (**)(const void *, __CFString *, int *, void, void))(v7 + 8);
    if (v8)
    {
      uint64_t v9 = v8(a3, @"assetProperty_FormatReader", &v19, 0, 0);
      if (v9) {
        return v9;
      }
      if (v19 != 2) {
        goto LABEL_15;
      }
      CFAllocatorRef v10 = CFGetAllocator(a3);
      uint64_t CMBaseObject = FigAssetGetCMBaseObject(a3);
      uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v12) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = 0;
      }
      uint64_t v14 = *(uint64_t (**)(uint64_t, __CFString *, CFAllocatorRef, CFTypeRef *))(v13 + 48);
      if (v14)
      {
        uint64_t v15 = v14(CMBaseObject, @"assetProperty_FormatReader", v10, &cf);
        CFTypeRef v16 = cf;
        if (v15) {
          goto LABEL_16;
        }
        if ((_UNKNOWN *)CMBaseObjectGetVTable() != &kComposite_FormatReader_VTable)
        {
LABEL_15:
          compositionTable_addAssetForURL(v5, a2, a3);
          uint64_t v15 = 0;
          CFTypeRef v16 = cf;
LABEL_16:
          if (v16) {
            CFRelease(v16);
          }
          return v15;
        }
        return FigSignalErrorAt();
      }
    }
    return 4294954514;
  }

  return FigSignalErrorAt();
}

uint64_t mutableComposition_InsertMutableCompositionSegmentIntoTrack(uint64_t a1, int a2, const void *a3, int a4, uint64_t a5, CMTime *a6, uint64_t a7)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v40 = *(void *)(DerivedStorage + 8);
  uint64_t v43 = 0;
  CFDictionaryRef v44 = 0;
  if (!a3)
  {
    uint64_t v17 = 0;
    int v19 = 0;
    uint64_t v18 = 4294954516;
    goto LABEL_27;
  }
  uint64_t v14 = (void *)DerivedStorage;
  uint64_t v38 = a6;
  MEMORY[0x19970EE10](&FigMutableCompositionGetClassID_sRegisterFigMutableCompositionBaseTypeOnce, RegisterFigMutableCompositionBaseType);
  CFCFTypeID TypeID = CMBaseClassGetCFTypeID();
  CFTypeID v16 = CFGetTypeID(a3);
  uint64_t v17 = 0;
  uint64_t v18 = 4294954516;
  int v19 = 0;
  if (a4 && CFTypeID == v16)
  {
    if ((*(_DWORD *)(a5 + 12) & 0x1D) == 1)
    {
      uint64_t v37 = v14;
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)a5;
      time1.start.CMTimeEpoch epoch = *(void *)(a5 + 16);
      long long v41 = *MEMORY[0x1E4F1FA48];
      *(_OWORD *)&time2.CMTimeValue value = *MEMORY[0x1E4F1FA48];
      CMTimeEpoch v20 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
      time2.CMTimeEpoch epoch = v20;
      if ((CMTimeCompare(&time1.start, &time2) & 0x80000000) == 0)
      {
        int v21 = *(_DWORD *)(a7 + 12);
        if ((v21 & 0x1D) == 1 || (v21 & 1) == 0)
        {
          if ((v21 & 0x1D) != 1
            || (*(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)a7,
                time1.start.CMTimeEpoch epoch = *(void *)(a7 + 16),
                *(_OWORD *)&time2.CMTimeValue value = v41,
                time2.CMTimeEpoch epoch = v20,
                (CMTimeCompare(&time1.start, &time2) & 0x80000000) == 0))
          {
            if ((_UNKNOWN *)CMBaseObjectGetVTable() == &kMutableComposition_VTable)
            {
              uint64_t v22 = *(void **)(CMBaseObjectGetDerivedStorage() + 8);
              MEMORY[0x19970E910](v22[1]);
              uint64_t v24 = v22[2];
              if (v24 < 1)
              {
                uint64_t v17 = 0;
                int v19 = 0;
              }
              else
              {
                unint64_t v23 = v22[4];
                while (*(_DWORD *)(v23 + 4) != a4)
                {
                  v23 += 168;
                  if (!--v24)
                  {
                    uint64_t v17 = 0;
                    int v19 = 0;
                    uint64_t v18 = 4294954516;
                    goto LABEL_17;
                  }
                }
                *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)a5;
                time1.start.CMTimeEpoch epoch = *(void *)(a5 + 16);
                CMTime time2 = *v38;
                uint64_t v26 = compositionTable_copyAssetSegmentsFromTrackForTimeRange((uint64_t)v22, v23, &time1.start, (uint64_t)&time2, &v44, &v43);
                if (!v26)
                {
                  MEMORY[0x19970E930](v22[1]);
                  uint64_t v17 = v43;
                  int v19 = v44;
                  uint64_t v27 = compositionEditSegment_validateSegments((uint64_t)v44, v43, 0);
                  if (v27)
                  {
                    uint64_t v18 = v27;
                    goto LABEL_27;
                  }
                  mutableComposition_addAssetsForURLsFromCompositionForSegments(a1, (uint64_t)a3, (uint64_t)v19, v17);
                  MEMORY[0x19970E910](*(void *)(v40 + 8));
                  uint64_t v28 = *(void *)(v40 + 16);
                  if (v28 < 1)
                  {
LABEL_24:
                    uint64_t v18 = 4294954516;
                  }
                  else
                  {
                    uint64_t v29 = *(void *)(v40 + 32);
                    while (*(_DWORD *)(v29 + 4) != a2)
                    {
                      v29 += 168;
                      if (!--v28) {
                        goto LABEL_24;
                      }
                    }
                    if ((*(_DWORD *)(a7 + 12) & 0x1D) != 1)
                    {
                      *(_OWORD *)&time2.CMTimeValue value = v41;
                      time2.CMTimeEpoch epoch = v20;
                      uint64_t v31 = *(void *)(v29 + 8);
                      if (v31 >= 1)
                      {
                        uint64_t v32 = *(void *)(v29 + 16) + 108 * v31;
                        long long v33 = *(_OWORD *)(v32 - 60);
                        long long v34 = *(_OWORD *)(v32 - 28);
                        *(_OWORD *)&time1.start.CMTimeEpoch epoch = *(_OWORD *)(v32 - 44);
                        *(_OWORD *)&time1.duration.CMTimeScale timescale = v34;
                        *(_OWORD *)&time1.start.CMTimeValue value = v33;
                        CMTimeRangeGetEnd(&time2, &time1);
                      }
                      time1.CMTime start = time2;
                      CMTimeEpoch epoch = time2.epoch;
                      *(_OWORD *)a7 = *(_OWORD *)&time2.value;
                      *(void *)(a7 + 16) = epoch;
                    }
                    *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)a7;
                    time1.start.CMTimeEpoch epoch = *(void *)(a7 + 16);
                    compositionEditSegment_adjustSegmentStartTimes(v19, v17, &time1.start);
                    uint64_t inserted = compositionTable_insertEditSegmentsIntoTrack(v40, (void *)v29, (uint64_t)v19, v17);
                    if (!inserted)
                    {
                      ++*(_DWORD *)(v40 + 4);
                      MEMORY[0x19970E930](*(void *)(v40 + 8));
                      if (*v37) {
                        mutableComposition_postPossiblyDeferredTracksChangedNotification();
                      }
                      uint64_t v18 = 0;
                      goto LABEL_27;
                    }
                    uint64_t v18 = inserted;
                  }
                  uint64_t v25 = *(void *)(v40 + 8);
LABEL_26:
                  MEMORY[0x19970E930](v25, v23);
                  goto LABEL_27;
                }
                uint64_t v18 = v26;
                uint64_t v17 = v43;
                int v19 = v44;
              }
LABEL_17:
              uint64_t v25 = v22[1];
              goto LABEL_26;
            }
          }
          uint64_t v18 = FigSignalErrorAt();
        }
      }
    }
    uint64_t v17 = 0;
    int v19 = 0;
  }
LABEL_27:
  compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag((uint64_t)v19, v17, 0);
  free(v19);
  return v18;
}

uint64_t mutableComposition_InsertMutableCompositionSegment(uint64_t a1, const void *a2, CMTime *a3, CMTime *a4, CMTime *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2) {
    goto LABEL_63;
  }
  uint64_t v9 = (void *)DerivedStorage;
  uint64_t v10 = *(void *)(DerivedStorage + 8);
  MEMORY[0x19970EE10](&FigMutableCompositionGetClassID_sRegisterFigMutableCompositionBaseTypeOnce, RegisterFigMutableCompositionBaseType);
  CFCFTypeID TypeID = CMBaseClassGetCFTypeID();
  if (CFTypeID != CFGetTypeID(a2)) {
    goto LABEL_63;
  }
  if ((a3->flags & 0x1D) != 1) {
    goto LABEL_63;
  }
  CMTime time1 = *a3;
  long long v60 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&time2.CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v12 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  time2.CMTimeEpoch epoch = v12;
  if (CMTimeCompare(&time1, &time2) < 0
    || (time1 = *a4, *(_OWORD *)&time2.value = v60, time2.CMTimeEpoch epoch = v12, CMTimeCompare(&time1, &time2) < 1)
    || (CMTimeFlags flags = a5->flags, (flags & 0x1D) != 1) && (flags & 1) != 0)
  {
LABEL_63:
    long long v33 = 0;
    uint64_t v18 = 0;
    uint64_t v17 = 0;
    CFTypeID v16 = 0;
    uint64_t v32 = 0;
    uint64_t v45 = 4294954516;
    goto LABEL_56;
  }
  if ((flags & 0x1D) == 1
    && (time1 = *a5, *(_OWORD *)&time2.value = v60, time2.CMTimeEpoch epoch = v12, CMTimeCompare(&time1, &time2) < 0)
    || (_UNKNOWN *)CMBaseObjectGetVTable() != &kMutableComposition_VTable)
  {
    uint64_t v45 = FigSignalErrorAt();
    long long v33 = 0;
    uint64_t v18 = 0;
    uint64_t v17 = 0;
    CFTypeID v16 = 0;
    uint64_t v32 = 0;
    goto LABEL_56;
  }
  uint64_t v14 = *(void *)(CMBaseObjectGetDerivedStorage() + 8);
  MEMORY[0x19970E910](*(void *)(v14 + 8));
  uint64_t v61 = v14;
  int64_t v15 = *(void *)(v14 + 16);
  CFTypeID v16 = malloc_type_calloc(v15, 8uLL, 0x2004093837F09uLL);
  if (!v16)
  {
    uint64_t v17 = 0;
    goto LABEL_66;
  }
  uint64_t v17 = malloc_type_calloc(v15, 8uLL, 0x100004000313F17uLL);
  if (!v17)
  {
LABEL_66:
    uint64_t v18 = 0;
LABEL_67:
    uint64_t v45 = FigSignalErrorAt();
    long long v33 = 0;
LABEL_62:
    MEMORY[0x19970E930](*(void *)(v61 + 8));
    uint64_t v32 = 0;
    goto LABEL_47;
  }
  uint64_t v18 = (const void **)malloc_type_calloc(v15, 8uLL, 0x6004044C4A2DFuLL);
  if (!v18) {
    goto LABEL_67;
  }
  int v19 = malloc_type_calloc(v15, 4uLL, 0x100004052888210uLL);
  if (!v19) {
    goto LABEL_67;
  }
  uint64_t v57 = (uint64_t)a2;
  uint64_t v50 = v9;
  uint64_t v51 = a1;
  CFDictionaryRef v53 = v19;
  uint64_t v54 = v10;
  uint64_t v52 = v15;
  if (v15 >= 1)
  {
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = v52;
    unint64_t v23 = v19;
    uint64_t v55 = v16;
    long long v56 = v18;
    while (1)
    {
      uint64_t v24 = (unsigned int *)(*(void *)(v61 + 32) + v20);
      uint64_t v25 = &v16[v21];
      uint64_t v26 = v17;
      uint64_t v27 = &v17[v21];
      CMTime time1 = *a3;
      CMTime time2 = *a4;
      uint64_t v28 = compositionTable_copyAssetSegmentsFromTrackForTimeRange(v61, (unint64_t)v24, &time1, (uint64_t)&time2, v25, v27);
      if (v28 || (uint64_t v28 = compositionEditSegment_validateSegments(*v25, *v27, 0), v28))
      {
        uint64_t v45 = v28;
        uint64_t v17 = v26;
        CFTypeID v16 = v55;
        uint64_t v18 = v56;
        goto LABEL_61;
      }
      *unint64_t v23 = *v24;
      uint64_t v18 = v56;
      uint64_t v29 = compositionTableTrack_copyTrackFormatDescriptionArrayForTrackCompatibility(v61, v24, &v56[v21]);
      uint64_t v17 = v26;
      if (v29) {
        break;
      }
      ++v21;
      ++v23;
      v20 += 168;
      --v22;
      CFTypeID v16 = v55;
      if (!v22) {
        goto LABEL_21;
      }
    }
    uint64_t v45 = v29;
    CFTypeID v16 = v55;
LABEL_61:
    int64_t v15 = v52;
    long long v33 = v53;
    goto LABEL_62;
  }
LABEL_21:
  MEMORY[0x19970E930](*(void *)(v61 + 8));
  uint64_t v30 = v54;
  MEMORY[0x19970E910](*(void *)(v54 + 8));
  if ((a5->flags & 0x1D) != 1)
  {
    compositionTable_getDuration((CMTime *)v54, &time1);
    *a5 = time1;
  }
  uint64_t v31 = (uint64_t *)malloc_type_calloc(*(void *)(v54 + 16), 8uLL, 0x100004000313F17uLL);
  uint64_t v32 = v31;
  int64_t v15 = v52;
  long long v33 = v53;
  if (v31)
  {
    uint64_t v34 = *(void *)(v54 + 16);
    uint64_t v62 = 0;
    if (v34 >= 1)
    {
      uint64_t v35 = 0;
      do
      {
        v31[v35] = v35;
        uint64_t v62 = ++v35;
      }
      while (v35 < *(void *)(v54 + 16));
    }
    if (v52 < 1)
    {
      uint64_t v43 = v34;
LABEL_43:
      CMTime time1 = *a5;
      CMTime time2 = *a4;
      uint64_t inserted = tableTrack_InsertEmptyEditsInTracks(v51, v32, v43, (uint64_t)&time1, &time2);
      if (!inserted)
      {
        ++*(_DWORD *)(v54 + 4);
        MEMORY[0x19970E930](*(void *)(v54 + 8));
        if (*v50) {
          mutableComposition_postPossiblyDeferredTracksChangedNotification();
        }
        uint64_t v45 = 0;
        goto LABEL_47;
      }
    }
    else
    {
      uint64_t v36 = 0;
      while (1)
      {
        uint64_t v62 = 0;
        mutableComposition_addAssetsForURLsFromCompositionForSegments(v51, v57, v16[v36], v17[v36]);
        uint64_t v37 = (CMTime *)v16[v36];
        uint64_t v38 = v17[v36];
        CMTime time1 = *a5;
        compositionEditSegment_adjustSegmentStartTimes(v37, v38, &time1);
        uint64_t inserted = compositionTable_insertEditSegmentsFromAsset(v51, v32, v34, v18[v36], *((_DWORD *)v53 + v36), v16[v36], v17[v36], &v62);
        if (inserted) {
          break;
        }
        if (v34 < 1)
        {
          uint64_t v43 = v34;
        }
        else
        {
          uint64_t v40 = 0;
          uint64_t v41 = 0;
          uint64_t v42 = v62;
          uint64_t v43 = v34;
          do
          {
            uint64_t v44 = v32[v41];
            if (v44 == v42)
            {
              --v43;
            }
            else
            {
              if (v41 != v40) {
                v32[v40] = v44;
              }
              ++v40;
            }
            ++v41;
          }
          while (v34 != v41);
        }
        ++v36;
        uint64_t v34 = v43;
        if (v36 == v52) {
          goto LABEL_43;
        }
      }
    }
    uint64_t v45 = inserted;
    uint64_t v30 = v54;
  }
  else
  {
    uint64_t v45 = 4294954510;
  }
  MEMORY[0x19970E930](*(void *)(v30 + 8));
LABEL_47:
  if (v16 && v15 >= 1)
  {
    for (uint64_t i = 0; i != v15; ++i)
    {
      uint64_t v47 = v16[i];
      if (v47)
      {
        compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag(v47, v17[i], 0);
        free((void *)v16[i]);
      }
      if (v18)
      {
        uint64_t v48 = v18[i];
        if (v48) {
          CFRelease(v48);
        }
      }
    }
  }
LABEL_56:
  free(v16);
  free(v17);
  free(v18);
  free(v33);
  free(v32);
  return v45;
}

uint64_t mutableComposition_GetTrackCompatibleWithMutableCompositionTrack(uint64_t a1, const void *a2, int a3, _DWORD *a4)
{
  uint64_t v7 = *(void **)(CMBaseObjectGetDerivedStorage() + 8);
  int v19 = 0;
  if (!a2) {
    return 4294954516;
  }
  if (!a3) {
    goto LABEL_20;
  }
  MEMORY[0x19970EE10](&FigMutableCompositionGetClassID_sRegisterFigMutableCompositionBaseTypeOnce, RegisterFigMutableCompositionBaseType);
  CFCFTypeID TypeID = CMBaseClassGetCFTypeID();
  if (CFTypeID != CFGetTypeID(a2)) {
    return 4294954516;
  }
  if ((_UNKNOWN *)CMBaseObjectGetVTable() == &kMutableComposition_VTable)
  {
    uint64_t v9 = *(void **)(CMBaseObjectGetDerivedStorage() + 8);
    MEMORY[0x19970E910](v9[1]);
    uint64_t v10 = v9[2];
    if (v10 < 1)
    {
LABEL_9:
      uint64_t v12 = FigSignalErrorAt();
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v11 = (unsigned int *)v9[4];
      while (v11[1] != a3)
      {
        v11 += 42;
        if (!--v10) {
          goto LABEL_9;
        }
      }
      int v14 = *v11;
      uint64_t v15 = compositionTableTrack_copyTrackFormatDescriptionArrayForTrackCompatibility((uint64_t)v9, v11, &v19);
      if (!v15)
      {
        MEMORY[0x19970E930](v9[1]);
        MEMORY[0x19970E910](v7[1]);
        uint64_t v13 = v19;
        CompatibleTrackForFormatDescriptionArrayAndCMMediaType MediaType = compositionTable_findCompatibleTrackForFormatDescriptionArrayAndMediaType((uint64_t)v7, 0, v7[2], v19, v14);
        if (CompatibleTrackForFormatDescriptionArrayAndMediaType < 0)
        {
          MEMORY[0x19970E930](v7[1]);
          uint64_t v12 = 4294954453;
          if (!v13) {
            return v12;
          }
        }
        else
        {
          int v17 = *(_DWORD *)(v7[4] + 168 * CompatibleTrackForFormatDescriptionArrayAndMediaType + 4);
          MEMORY[0x19970E930](v7[1]);
          uint64_t v12 = 0;
          if (a4) {
            *a4 = v17;
          }
          if (!v13) {
            return v12;
          }
        }
LABEL_17:
        CFRelease(v13);
        return v12;
      }
      uint64_t v12 = v15;
      uint64_t v13 = v19;
    }
    MEMORY[0x19970E930](v9[1]);
    if (!v13) {
      return v12;
    }
    goto LABEL_17;
  }
LABEL_20:

  return FigSignalErrorAt();
}

uint64_t mutableComposition_CopyAsset(const void *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v9 = CFGetAllocator(a1);
  CFTypeRef v19 = 0;
  if (!a4) {
    return 0;
  }
  uint64_t v10 = (uint64_t)v9;
  if (!a2)
  {
    uint64_t v13 = *(const void **)(DerivedStorage + 24);
    if (v13)
    {
      CFTypeRef v19 = CFRetain(v13);
LABEL_15:
      uint64_t v16 = 0;
      *a4 = v19;
      return v16;
    }
  }
  CFTypeRef cf = 0;
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  int v14 = *(uint64_t (**)(const void *, uint64_t, uint64_t, CFTypeRef *))(v12 + 16);
  if (!v14) {
    return 4294954514;
  }
  uint64_t v15 = v14(a1, a2, a3, &cf);
  if (v15) {
    return v15;
  }
  uint64_t v16 = FigAssetCreateWithFormatReader(v10, cf, 0, 0, &v19);
  CFRelease(cf);
  if (!a2 && !v16)
  {
    *(void *)(DerivedStorage + 24) = CFRetain(v19);
    goto LABEL_15;
  }
  if (!v16) {
    goto LABEL_15;
  }
  return v16;
}

uint64_t compositionTable_createCopy(const __CFAllocator *a1, uint64_t a2, void *a3)
{
  uint64_t v6 = malloc_type_calloc(0xA8uLL, 1uLL, 0x119764C8uLL);
  if ((const __CFAllocator *)*MEMORY[0x1E4F1CFB8] == a1) {
    a1 = CFGetAllocator(*(CFTypeRef *)(a2 + 64));
  }
  int v7 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)uint64_t v6 = 1;
  *((_DWORD *)v6 + 1) = v7;
  *((void *)v6 + 1) = FigSimpleMutexCreate();
  MEMORY[0x19970E910](*(void *)(a2 + 8));
  *((void *)v6 + 9) = FigSimpleMutexCreate();
  uint64_t v8 = *(void *)(a2 + 16);
  *((void *)v6 + 2) = v8;
  *((_DWORD *)v6 + 6) = *(_DWORD *)(a2 + 24);
  if (v8 < 1)
  {
    *((void *)v6 + 4) = 0;
  }
  else
  {
    CFAllocatorRef v9 = malloc_type_malloc(168 * v8, 0x1060040CA997719uLL);
    *((void *)v6 + 4) = v9;
    memcpy(v9, *(const void **)(a2 + 32), 168 * *((void *)v6 + 2));
    if (*((uint64_t *)v6 + 2) >= 1)
    {
      uint64_t v10 = 0;
      uint64_t v11 = *((void *)v6 + 4);
      do
      {
        uint64_t v12 = *(void *)(v11 + 24);
        if (v12 < 1)
        {
          *(void *)(v11 + 16) = 0;
        }
        else
        {
          uint64_t v13 = (char *)malloc_type_malloc(108 * v12, 0x1060040CB727B4DuLL);
          int v14 = v13;
          uint64_t v15 = *(void *)(v11 + 8);
          if (v15 <= 0)
          {
            *(void *)(v11 + 16) = v13;
          }
          else
          {
            memcpy(v13, *(const void **)(v11 + 16), 108 * v15);
            uint64_t v16 = *(void *)(v11 + 8);
            *(void *)(v11 + 16) = v14;
            if (v16 >= 1)
            {
              uint64_t v17 = 0;
              uint64_t v18 = (CFTypeRef *)(v14 + 96);
              do
              {
                if (*v18)
                {
                  CFRetain(*v18);
                  uint64_t v16 = *(void *)(v11 + 8);
                }
                ++v17;
                uint64_t v18 = (CFTypeRef *)((char *)v18 + 108);
              }
              while (v17 < v16);
            }
          }
        }
        CFTypeRef v19 = *(const void **)(v11 + 32);
        if (v19) {
          CFRetain(v19);
        }
        uint64_t v20 = *(const void **)(v11 + 40);
        if (v20) {
          CFRetain(v20);
        }
        uint64_t v21 = *(const void **)(v11 + 48);
        if (v21) {
          CFRetain(v21);
        }
        uint64_t v22 = *(const void **)(v11 + 56);
        if (v22) {
          CFRetain(v22);
        }
        unint64_t v23 = *(const void **)(v11 + 64);
        if (v23) {
          CFRetain(v23);
        }
        CFDictionaryRef v24 = *(const __CFDictionary **)(v11 + 72);
        if (v24) {
          *(void *)(v11 + 72) = CFDictionaryCreateMutableCopy(a1, 0, v24);
        }
        uint64_t v25 = *(const void **)(v11 + 96);
        if (v25) {
          CFRetain(v25);
        }
        uint64_t v26 = *(const void **)(v11 + 80);
        if (v26) {
          CFRetain(v26);
        }
        uint64_t v27 = *(const void **)(v11 + 88);
        if (v27) {
          CFRetain(v27);
        }
        uint64_t v28 = *(const void **)(v11 + 104);
        if (v28) {
          CFRetain(v28);
        }
        uint64_t v29 = *(const void **)(v11 + 112);
        if (v29) {
          CFRetain(v29);
        }
        ++v10;
        v11 += 168;
      }
      while (v10 < *((void *)v6 + 2));
    }
  }
  *((void *)v6 + 5) = CFBagCreateMutableCopy(a1, 0, *(CFBagRef *)(a2 + 40));
  CFDictionaryRef v30 = *(const __CFDictionary **)(a2 + 48);
  if (v30) {
    *((void *)v6 + 6) = CFDictionaryCreateMutableCopy(a1, 0, v30);
  }
  MEMORY[0x19970E930](*(void *)(a2 + 8));
  MEMORY[0x19970E910](*(void *)(a2 + 72));
  CFDictionaryRef v31 = *(const __CFDictionary **)(a2 + 80);
  if (v31) {
    *((void *)v6 + 10) = CFDictionaryCreateMutableCopy(a1, 0, v31);
  }
  uint64_t v32 = *(const void **)(a2 + 112);
  *((void *)v6 + 14) = v32;
  *((void *)v6 + 11) = *(void *)(a2 + 88);
  long long v33 = *(_OWORD *)(a2 + 96);
  *((_OWORD *)v6 + 6) = v33;
  if (v32)
  {
    CFRetain(v32);
    uint64_t v34 = (const void *)*((void *)v6 + 12);
    if (!v34) {
      goto LABEL_48;
    }
    goto LABEL_47;
  }
  uint64_t v34 = (const void *)v33;
  if ((void)v33) {
LABEL_47:
  }
    CFRetain(v34);
LABEL_48:
  uint64_t v35 = (const void *)*((void *)v6 + 11);
  if (v35) {
    CFRetain(v35);
  }
  uint64_t v36 = (const void *)*((void *)v6 + 13);
  if (v36) {
    CFRetain(v36);
  }
  MEMORY[0x19970E930](*(void *)(a2 + 72));
  *((void *)v6 + 7) = FigSimpleMutexCreate();
  MEMORY[0x19970E910](*(void *)(a2 + 56));
  *((void *)v6 + 8) = CFDictionaryCreateMutableCopy(a1, 0, *(CFDictionaryRef *)(a2 + 64));
  MEMORY[0x19970E930](*(void *)(a2 + 56));
  *((void *)v6 + 15) = FigSimpleMutexCreate();
  MEMORY[0x19970E910](*(void *)(a2 + 120));
  size_t v37 = *(void *)(a2 + 128);
  *((void *)v6 + 16) = v37;
  uint64_t v38 = malloc_type_calloc(v37, 0x10uLL, 0x1060040C2E02434uLL);
  *((void *)v6 + 17) = v38;
  memcpy(v38, *(const void **)(a2 + 136), 16 * *((void *)v6 + 16));
  uint64_t v39 = *(void *)(a2 + 144);
  *((void *)v6 + 18) = v39;
  if (v39 >= 2)
  {
    uint64_t v40 = 1;
    uint64_t v41 = 16;
    do
    {
      uint64_t v42 = *(const void **)(*((void *)v6 + 17) + v41);
      if (v42)
      {
        CFRetain(v42);
        uint64_t v39 = *((void *)v6 + 18);
      }
      ++v40;
      v41 += 16;
    }
    while (v40 < v39);
  }
  *((void *)v6 + 19) = CFDictionaryCreateMutableCopy(a1, 0, *(CFDictionaryRef *)(a2 + 152));
  MEMORY[0x19970E930](*(void *)(a2 + 120));
  *((void *)v6 + 20) = *(void *)(a2 + 160);
  uint64_t result = FigAtomicIncrement32();
  *a3 = v6;
  return result;
}

void composite_formatReader_Finalize()
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  compositionTable_releaseAndClear(DerivedStorage);
  if (DerivedStorage[1])
  {
    FigSimpleMutexDestroy();
    DerivedStorage[1] = 0;
  }
  uint64_t v1 = (__CFDictionary *)DerivedStorage[2];
  if (v1)
  {
    CFDictionaryRemoveAllValues(v1);
    uint64_t v2 = (const void *)DerivedStorage[2];
    if (v2)
    {
      CFRelease(v2);
      DerivedStorage[2] = 0;
    }
  }
}

__CFString *composite_formatReader_CopyDebugDescription()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v2 = *(void *)DerivedStorage;
  uint64_t v3 = *(void *)(*(void *)DerivedStorage + 32);
  CFStringAppend(Mutable, @"[Composite FigFormatReader]{\n");
  if (*(uint64_t *)(v2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = compositionTableTrack_CopyDebugDescription(v3);
      if (v4) {
        CFStringAppend(Mutable, @",\n");
      }
      CFStringAppend(Mutable, @"  ");
      CFStringAppend(Mutable, v5);
      if (v5) {
        CFRelease(v5);
      }
      ++v4;
      v3 += 168;
    }
    while (v4 < *(void *)(v2 + 16));
  }
  CFStringAppend(Mutable, @"\n}");
  return Mutable;
}

uint64_t composite_formatReader_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFMutableDictionaryRef *a4)
{
  uint64_t DerivedStorage = (void **)CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v9 = *DerivedStorage;
  uint64_t v36 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  long long v33 = 0;
  if (a2)
  {
    uint64_t v10 = DerivedStorage;
    if (CFEqual(a2, @"Identifier"))
    {
      uint64_t v11 = (CFTypeRef *)kFigFormatReaderIdentifier_Composite;
LABEL_4:
      uint64_t v12 = (__CFDictionary *)CFRetain(*v11);
LABEL_12:
      uint64_t v15 = 0;
      *a4 = v12;
      return v15;
    }
    if (CFEqual(a2, @"Duration")
      || CFEqual(a2, @"NominalDuration")
      || CFEqual(a2, @"EstimatedDuration"))
    {
      uint64_t v14 = *(void *)CMBaseObjectGetDerivedStorage();
      CMTime v32 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      MEMORY[0x19970E910](*(void *)(v14 + 8));
      compositionTable_getDuration((CMTime *)v14, &v32);
      MEMORY[0x19970E930](*(void *)(v14 + 8));
      CMTime v31 = v32;
      uint64_t v12 = CMTimeCopyAsDictionary(&v31, a3);
      goto LABEL_12;
    }
    if (CFEqual(a2, @"AccurateDurationIsKnown") || CFEqual(a2, @"SampleCursorTimeAccuracyIsExact"))
    {
      uint64_t v11 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      goto LABEL_4;
    }
    if (CFEqual(a2, @"TrackReferenceDictionary"))
    {
      MEMORY[0x19970E910](v9[1]);
      CFDictionaryRef v16 = (const __CFDictionary *)v9[6];
      if (v16) {
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(a3, 0, v16);
      }
      else {
        MutableCFStringRef Copy = 0;
      }
      *a4 = MutableCopy;
      MEMORY[0x19970E930](v9[1]);
      return 0;
    }
    if (CFEqual(a2, @"CanMutate"))
    {
      uint64_t v11 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      if (!*((unsigned char *)v10 + 24)) {
        uint64_t v11 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
      }
      goto LABEL_4;
    }
    if (CFEqual(a2, @"AlternateGroupArray"))
    {
      uint64_t v12 = compositeFormatReader_copyAlternateGroupArray(a1, a3);
      goto LABEL_12;
    }
    if (CFEqual(a2, @"QuickTimeUserDataReader"))
    {
      uint64_t v18 = compositionTable_copyQuickTimeUserDataReader(v9, a4);
      if (!v18) {
        goto LABEL_31;
      }
      return v18;
    }
    if (CFEqual(a2, @"QuickTimeMetadataReader"))
    {
      uint64_t v18 = compositionTable_copyQuickTimeMetadataReader(v9, a4);
      if (v18) {
        return v18;
      }
LABEL_31:
      if (*a4) {
        return 0;
      }
      else {
        return 4294954513;
      }
    }
    if (CFEqual(a2, @"ISOUserDataReader"))
    {
      uint64_t v18 = compositionTable_copyISOUserDataReader(v9, a4);
      if (v18) {
        return v18;
      }
      goto LABEL_31;
    }
    if (CFEqual(a2, @"iTunesMetadataReader"))
    {
      uint64_t v18 = compositionTable_copyiTunesMetadataReader(v9, a4);
      if (v18) {
        return v18;
      }
      goto LABEL_31;
    }
    if (CFEqual(a2, @"MetadataReaders"))
    {
      compositionTable_copyQuickTimeUserDataReader(v9, &v36);
      compositionTable_copyQuickTimeMetadataReader(v9, &v35);
      compositionTable_copyISOUserDataReader(v9, &v34);
      compositionTable_copyiTunesMetadataReader(v9, &v33);
      CFTypeRef v19 = v36;
      uint64_t v20 = v34;
      uint64_t v21 = v35;
      uint64_t v22 = v33;
      if (!v36 && !v34 && !v35 && !v33) {
        return 0;
      }
      CFDictionaryRef Mutable = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
      if (Mutable)
      {
        CFDictionaryRef v24 = Mutable;
        if (v21) {
          CFArrayAppendValue(Mutable, v21);
        }
        if (v22) {
          CFArrayAppendValue(v24, v22);
        }
        if (v19) {
          CFArrayAppendValue(v24, v19);
        }
        if (v20) {
          CFArrayAppendValue(v24, v20);
        }
        uint64_t v15 = 0;
        *a4 = v24;
        if (!v19) {
          goto LABEL_59;
        }
      }
      else
      {
        uint64_t v15 = FigSignalErrorAt();
        if (!v19) {
          goto LABEL_59;
        }
      }
      CFRelease(v19);
LABEL_59:
      if (v21) {
        CFRelease(v21);
      }
      if (v20) {
        CFRelease(v20);
      }
      if (v22) {
        CFRelease(v22);
      }
      return v15;
    }
    if (!CFEqual(a2, @"MetadataReaderTypes")) {
      return 4294954512;
    }
    CFMutableArrayRef v25 = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
    if (v25)
    {
      uint64_t v26 = v25;
      CFDictionaryRef v27 = (const __CFDictionary *)v9[10];
      if (v27)
      {
        if (CFDictionaryGetValue(v27, @"com.apple.itunes")) {
          CFArrayAppendValue(v26, @"iTunesMetadataReader");
        }
        CFDictionaryRef v28 = (const __CFDictionary *)v9[10];
        if (v28)
        {
          if (CFDictionaryGetValue(v28, @"com.apple.quicktime.mdta")) {
            CFArrayAppendValue(v26, @"QuickTimeMetadataReader");
          }
          CFDictionaryRef v29 = (const __CFDictionary *)v9[10];
          if (v29)
          {
            if (CFDictionaryGetValue(v29, @"com.apple.quicktime.udta")) {
              CFArrayAppendValue(v26, @"QuickTimeUserDataReader");
            }
            CFDictionaryRef v30 = (const __CFDictionary *)v9[10];
            if (v30 && CFDictionaryGetValue(v30, @"org.mp4ra")) {
              CFArrayAppendValue(v26, @"ISOUserDataReader");
            }
          }
        }
      }
      if (CFArrayGetCount(v26) >= 1)
      {
        uint64_t v15 = 0;
        *a4 = v26;
        return v15;
      }
      CFRelease(v26);
      return 0;
    }
  }

  return FigSignalErrorAt();
}

CFMutableArrayRef compositeFormatReader_copyAlternateGroupArray(uint64_t a1, const __CFAllocator *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(void **)DerivedStorage;
  MEMORY[0x19970E910](*(void *)(*(void *)DerivedStorage + 8));
  uint64_t v5 = v4[2];
  if (v5 < 1) {
    goto LABEL_19;
  }
  int v6 = 0;
  int v7 = (uint64_t *)(v4[4] + 104);
  do
  {
    uint64_t v8 = *v7;
    v7 += 21;
    if (v8) {
      int v6 = 1;
    }
    --v5;
  }
  while (v5);
  if (v6)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if ((uint64_t)v4[2] >= 1)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
      do
      {
        uint64_t v13 = v4[4] + v10;
        uint64_t v14 = *(const void **)(v13 + 104);
        if (v14)
        {
          if (CFDictionaryGetValue(Mutable, *(const void **)(v13 + 104)))
          {
            FigCFArrayAppendInt32();
          }
          else
          {
            CFMutableArrayRef v15 = CFArrayCreateMutable(a2, 0, v12);
            FigCFArrayAppendInt32();
            CFDictionarySetValue(Mutable, v14, v15);
            if (v15) {
              CFRelease(v15);
            }
          }
        }
        ++v11;
        v10 += 168;
      }
      while (v11 < v4[2]);
    }
    CFIndex Count = CFDictionaryGetCount(Mutable);
    CFMutableArrayRef v17 = CFArrayCreateMutable(a2, Count, MEMORY[0x1E4F1D510]);
    if (v17) {
      CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)copyValuesToArray, v17);
    }
    MEMORY[0x19970E930](v4[1]);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
LABEL_19:
    MEMORY[0x19970E930](v4[1]);
    return 0;
  }
  return v17;
}

uint64_t compositionTable_copyQuickTimeUserDataReader(void *a1, void *a2)
{
  MEMORY[0x19970E910](a1[9]);
  uint64_t v5 = (CFTypeRef *)(a1 + 11);
  CFTypeRef v4 = (CFTypeRef)a1[11];
  if (v4)
  {
    uint64_t v6 = 0;
LABEL_8:
    CFTypeRef v4 = CFRetain(v4);
    goto LABEL_9;
  }
  CFDictionaryRef v7 = (const __CFDictionary *)a1[10];
  if (v7 && (CFDictionaryRef Value = CFDictionaryGetValue(v7, @"com.apple.quicktime.udta")) != 0) {
    uint64_t v6 = FigMetadataReaderCreateForQuickTimeUserDataArray(*MEMORY[0x1E4F1CF80], Value, a1 + 11);
  }
  else {
    uint64_t v6 = 0;
  }
  CFTypeRef v4 = *v5;
  if (*v5) {
    goto LABEL_8;
  }
LABEL_9:
  *a2 = v4;
  MEMORY[0x19970E930](a1[9]);
  return v6;
}

uint64_t compositionTable_copyQuickTimeMetadataReader(void *a1, void *a2)
{
  MEMORY[0x19970E910](a1[9]);
  uint64_t v5 = (CFTypeRef *)(a1 + 12);
  CFTypeRef v4 = (CFTypeRef)a1[12];
  if (v4)
  {
    uint64_t v6 = 0;
LABEL_8:
    CFTypeRef v4 = CFRetain(v4);
    goto LABEL_9;
  }
  CFDictionaryRef v7 = (const __CFDictionary *)a1[10];
  if (v7 && (CFDictionaryRef Value = CFDictionaryGetValue(v7, @"com.apple.quicktime.mdta")) != 0) {
    uint64_t v6 = FigMetadataReaderCreateForQuickTimeMetadataArray(*MEMORY[0x1E4F1CF80], Value, a1 + 12);
  }
  else {
    uint64_t v6 = 0;
  }
  CFTypeRef v4 = *v5;
  if (*v5) {
    goto LABEL_8;
  }
LABEL_9:
  *a2 = v4;
  MEMORY[0x19970E930](a1[9]);
  return v6;
}

uint64_t compositionTable_copyISOUserDataReader(void *a1, void *a2)
{
  MEMORY[0x19970E910](a1[9]);
  uint64_t v5 = (CFTypeRef *)(a1 + 13);
  CFTypeRef v4 = (CFTypeRef)a1[13];
  if (v4)
  {
    uint64_t v6 = 0;
LABEL_8:
    CFTypeRef v4 = CFRetain(v4);
    goto LABEL_9;
  }
  CFDictionaryRef v7 = (const __CFDictionary *)a1[10];
  if (v7 && (CFDictionaryRef Value = CFDictionaryGetValue(v7, @"org.mp4ra")) != 0) {
    uint64_t v6 = FigMetadataReaderCreateForISOUserDataArray(*MEMORY[0x1E4F1CF80], Value, a1 + 13);
  }
  else {
    uint64_t v6 = 0;
  }
  CFTypeRef v4 = *v5;
  if (*v5) {
    goto LABEL_8;
  }
LABEL_9:
  *a2 = v4;
  MEMORY[0x19970E930](a1[9]);
  return v6;
}

uint64_t compositionTable_copyiTunesMetadataReader(void *a1, void *a2)
{
  MEMORY[0x19970E910](a1[9]);
  uint64_t v5 = (CFTypeRef *)(a1 + 14);
  CFTypeRef v4 = (CFTypeRef)a1[14];
  if (v4)
  {
    uint64_t ForiTunesMetadataArray = 0;
LABEL_8:
    CFTypeRef v4 = CFRetain(v4);
    goto LABEL_9;
  }
  CFDictionaryRef v7 = (const __CFDictionary *)a1[10];
  if (v7 && (CFDictionaryRef Value = CFDictionaryGetValue(v7, @"com.apple.itunes")) != 0) {
    uint64_t ForiTunesMetadataArray = FigMetadataReaderCreateForiTunesMetadataArray(*MEMORY[0x1E4F1CF80], Value, a1 + 14);
  }
  else {
    uint64_t ForiTunesMetadataArray = 0;
  }
  CFTypeRef v4 = *v5;
  if (*v5) {
    goto LABEL_8;
  }
LABEL_9:
  *a2 = v4;
  MEMORY[0x19970E930](a1[9]);
  return ForiTunesMetadataArray;
}

CMTime *compositionTable_getDuration@<X0>(CMTime *result@<X0>, CMTime *a2@<X8>)
{
  uint64_t v3 = MEMORY[0x1E4F1FA48];
  long long v12 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&a2->CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v4 = *(void *)(v3 + 16);
  a2->CMTimeEpoch epoch = v4;
  if (result->epoch >= 1)
  {
    uint64_t v5 = result;
    CMTimeEpoch v6 = 0;
    CFDictionaryRef v7 = (void *)(*(void *)&result[1].timescale + 16);
    do
    {
      *(_OWORD *)&v14.CMTimeValue value = v12;
      v14.CMTimeEpoch epoch = v4;
      uint64_t v8 = *(v7 - 1);
      if (v8 >= 1)
      {
        uint64_t v9 = *v7 + 108 * v8;
        long long v10 = *(_OWORD *)(v9 - 60);
        long long v11 = *(_OWORD *)(v9 - 28);
        *(_OWORD *)&range.start.CMTimeEpoch epoch = *(_OWORD *)(v9 - 44);
        *(_OWORD *)&range.duration.CMTimeScale timescale = v11;
        *(_OWORD *)&range.start.CMTimeValue value = v10;
        CMTimeRangeGetEnd(&v14, &range);
      }
      v7 += 21;
      *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)&a2->value;
      range.start.CMTimeEpoch epoch = a2->epoch;
      CMTime time2 = v14;
      uint64_t result = CMTimeMaximum(a2, &range.start, &time2);
      ++v6;
    }
    while (v6 < v5->epoch);
  }
  return result;
}

void copyValuesToArray(int a1, const void *a2, CFMutableArrayRef theArray)
{
}

uint64_t composite_formatReader_GetTrackCount(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(void *)DerivedStorage;
  MEMORY[0x19970E910](*(void *)(*(void *)DerivedStorage + 8));
  uint64_t v5 = *(void *)(v4 + 8);
  *a2 = *(void *)(v4 + 16);
  MEMORY[0x19970E930](v5);
  return 0;
}

uint64_t composite_formatReader_CopyTrackByIndex(const void *a1, uint64_t a2, void *a3, _DWORD *a4, int *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  long long v11 = *(void **)DerivedStorage;
  MEMORY[0x19970E910](*(void *)(*(void *)DerivedStorage + 8));
  if (a2 < 0 || v11[2] <= a2)
  {
    MEMORY[0x19970E930](v11[1]);
    return 4294954453;
  }
  else
  {
    int v12 = *(_DWORD *)(v11[4] + 168 * a2 + 4);
    MEMORY[0x19970E930](v11[1]);
    if (a5) {
      *a5 = v12;
    }
    return composite_formatReader_CopyTrackByID(a1, v12, a3, a4);
  }
}

uint64_t composite_formatReader_CopyTrackByID(const void *a1, int a2, void *a3, _DWORD *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v9 = *(void **)DerivedStorage;
  MEMORY[0x19970E910](*(void *)(*(void *)DerivedStorage + 8));
  uint64_t v10 = v9[2];
  if (v10 < 1)
  {
LABEL_5:
    MEMORY[0x19970E930](v9[1]);
    return 4294954453;
  }
  else
  {
    long long v11 = (_DWORD *)(v9[4] + 4);
    while (*v11 != a2)
    {
      v11 += 42;
      if (!--v10) {
        goto LABEL_5;
      }
    }
    if (a4) {
      *a4 = *(v11 - 1);
    }
    MEMORY[0x19970E930](v9[1]);
    if (!a3) {
      return 0;
    }
    MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
    CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 16), (const void *)a2);
    *a3 = Value;
    if (Value) {
      CFRetain(Value);
    }
    MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
    if (*a3) {
      return 0;
    }
    CFGetAllocator(a1);
    uint64_t v14 = CMBaseObjectGetDerivedStorage();
    CFMutableArrayRef v15 = *(void **)v14;
    MEMORY[0x19970E910](*(void *)(*(void *)v14 + 8));
    uint64_t v16 = v15[2];
    if (v16 < 1)
    {
LABEL_16:
      MEMORY[0x19970E930](v15[1]);
      uint64_t v12 = 4294954453;
    }
    else
    {
      CFMutableArrayRef v17 = (_DWORD *)(v15[4] + 4);
      while (*v17 != a2)
      {
        v17 += 42;
        if (!--v16) {
          goto LABEL_16;
        }
      }
      int v18 = *(v17 - 1);
      MEMORY[0x19970E930](v15[1]);
      FigTrackReaderGetClassID();
      uint64_t v19 = CMDerivedObjectCreate();
      if (v19) {
        goto LABEL_31;
      }
      uint64_t v20 = CMBaseObjectGetDerivedStorage();
      FigEditCursorServiceGetClassID();
      uint64_t v19 = CMDerivedObjectCreate();
      if (v19
        || (int v28 = v18,
            uint64_t v21 = CMBaseObjectGetDerivedStorage(),
            FigEditCursorServiceGetClassID(),
            uint64_t v19 = CMDerivedObjectCreate(),
            v19)
        || (uint64_t v27 = CMBaseObjectGetDerivedStorage(),
            FigSampleCursorServiceGetClassID(),
            uint64_t v19 = CMDerivedObjectCreate(),
            v19))
      {
LABEL_31:
        uint64_t v12 = v19;
      }
      else
      {
        uint64_t v22 = CMBaseObjectGetDerivedStorage();
        *(void *)uint64_t v20 = v15;
        FigAtomicIncrement32();
        *(_DWORD *)(v20 + 8) = a2;
        *(_DWORD *)(v20 + 12) = v28;
        *(void *)(v20 + 16) = 0;
        *(void *)(v20 + 24) = 0;
        *(void *)(v20 + 32) = 0;
        *(void *)uint64_t v21 = v15;
        FigAtomicIncrement32();
        *(_DWORD *)(v21 + 8) = a2;
        *(_DWORD *)(v21 + 12) = v28;
        *(void *)uint64_t v27 = v15;
        FigAtomicIncrement32();
        *(_DWORD *)(v27 + 8) = v28;
        *(void *)uint64_t v22 = v15;
        FigAtomicIncrement32();
        uint64_t v12 = 0;
        *(_DWORD *)(v22 + 8) = a2;
        *(_DWORD *)(v22 + 12) = v28;
      }
    }
    if (!v12)
    {
      MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
      int v23 = CFDictionaryContainsKey(*(CFDictionaryRef *)(DerivedStorage + 16), (const void *)a2);
      CFDictionaryRef v24 = *(const __CFDictionary **)(DerivedStorage + 16);
      if (v23)
      {
        CFMutableArrayRef v25 = CFDictionaryGetValue(v24, (const void *)a2);
      }
      else
      {
        CFDictionarySetValue(v24, (const void *)a2, 0);
        CFMutableArrayRef v25 = 0;
      }
      *a3 = v25;
      if (v25) {
        CFRetain(v25);
      }
      MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
      return 0;
    }
  }
  return v12;
}

uint64_t composite_formatReader_CopyTrackByType(const void *a1, uint64_t a2, int a3, void *a4, int *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  long long v11 = *(void **)DerivedStorage;
  MEMORY[0x19970E910](*(void *)(*(void *)DerivedStorage + 8));
  uint64_t v12 = v11[2];
  if (v12 < 1)
  {
LABEL_7:
    MEMORY[0x19970E930](v11[1]);
    return 4294954453;
  }
  uint64_t v13 = (int *)(v11[4] + 4);
  while (*(v13 - 1) != a3)
  {
LABEL_6:
    v13 += 42;
    if (!--v12) {
      goto LABEL_7;
    }
  }
  if (a2)
  {
    --a2;
    goto LABEL_6;
  }
  int v15 = *v13;
  MEMORY[0x19970E930](v11[1]);
  if (!v15) {
    return 4294954453;
  }
  if (a5) {
    *a5 = v15;
  }

  return composite_formatReader_CopyTrackByID(a1, v15, a4, 0);
}

void composite_trackReader_Finalize()
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  compositionTable_releaseAndClear(DerivedStorage);
  uint64_t v1 = (const void *)DerivedStorage[2];
  if (v1)
  {
    CFRelease(v1);
    DerivedStorage[2] = 0;
  }
  uint64_t v2 = (const void *)DerivedStorage[3];
  if (v2)
  {
    CFRelease(v2);
    DerivedStorage[3] = 0;
  }
  uint64_t v3 = (const void *)DerivedStorage[4];
  if (v3)
  {
    CFRelease(v3);
    DerivedStorage[4] = 0;
  }
}

__CFString *composite_trackReader_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  uint64_t v3 = DerivedStorage;
  uint64_t v4 = *(void *)DerivedStorage;
  uint64_t v5 = *(void *)(*(void *)DerivedStorage + 16);
  if (v5 < 1)
  {
LABEL_5:
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = *(void *)(v4 + 32);
    while (*(_DWORD *)(v6 + 4) != DerivedStorage[2])
    {
      v6 += 168;
      if (!--v5) {
        goto LABEL_5;
      }
    }
  }
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<Composite FigTrackReader %p>", a1);
  if (v6)
  {
    uint64_t v8 = compositionTableTrack_CopyDebugDescription(v6);
    CFStringAppend(Mutable, v8);
    if (v8) {
      CFRelease(v8);
    }
  }
  else
  {
    uint64_t v9 = v3[2];
    unsigned int v11 = bswap32(v3[3]);
    CFStringAppendFormat(Mutable, 0, @"{ trackID %d, mediaType %.4s, table %p, ", v9, &v11, v4);
    CFStringAppend(Mutable, @"trackID not found in table");
    CFStringAppendFormat(Mutable, 0, @" }");
  }
  return Mutable;
}

uint64_t composite_trackReader_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, __CFArray **a4)
{
  uint64_t DerivedStorage = (void **)CMBaseObjectGetDerivedStorage();
  if (!a2) {
    goto LABEL_4;
  }
  uint64_t v9 = DerivedStorage;
  uint64_t v10 = *DerivedStorage;
  if (CFEqual(a2, @"SecondaryEditCursorService"))
  {
    *a4 = (__CFArray *)v9[2];
    unsigned int v11 = v9[2];
LABEL_9:
    CFRetain(v11);
    return 0;
  }
  if (CFEqual(a2, @"EditCursorService"))
  {
    *a4 = (__CFArray *)v9[3];
    unsigned int v11 = v9[3];
    goto LABEL_9;
  }
  if (CFEqual(a2, @"TrackEnabled"))
  {
    MEMORY[0x19970E910](v10[1]);
    uint64_t v14 = v10[2];
    if (v14 >= 1)
    {
      int v15 = (unsigned char *)(v10[4] + 160);
      while (*((_DWORD *)v15 - 39) != *((_DWORD *)v9 + 2))
      {
        v15 += 168;
        if (!--v14) {
          goto LABEL_16;
        }
      }
      uint64_t v26 = (const void **)MEMORY[0x1E4F1CFD0];
      if (!*v15) {
        uint64_t v26 = (const void **)MEMORY[0x1E4F1CFC8];
      }
      uint64_t v27 = (void *)*v26;
      if (!*v26) {
        goto LABEL_31;
      }
      goto LABEL_30;
    }
    goto LABEL_16;
  }
  if (CFEqual(a2, @"TrackFormatDescriptionArray"))
  {
    uint64_t v17 = CMBaseObjectGetDerivedStorage();
    uint64_t v102 = *(void **)v17;
    *(void *)&valuePtr[0] = 0;
    int v18 = *(_DWORD *)(v17 + 8);
    unsigned int v100 = *(_DWORD *)(v17 + 12);
    CFTypeRef v106 = 0;
    uint64_t v19 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    CFDictionaryRef Mutable = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
    CFMutableArrayRef v21 = CFArrayCreateMutable(a3, 0, v19);
    CFMutableArrayRef v22 = v21;
    CMTimeValue value = 0;
    if (Mutable && v21)
    {
      unsigned int v104 = 0;
      MEMORY[0x19970E910](v102[1]);
      uint64_t v23 = v102[2];
      if (v23 >= 1)
      {
        uint64_t v24 = v102[4];
        while (*(_DWORD *)(v24 + 4) != v18)
        {
          v24 += 168;
          if (!--v23) {
            goto LABEL_25;
          }
        }
        CFArrayRef v25 = *(const __CFArray **)(v24 + 112);
        if (v25) {
          CFRetain(*(CFTypeRef *)(v24 + 112));
        }
        uint64_t v28 = *(void *)(v24 + 8);
        if (v28 >= 1)
        {
          uint64_t v29 = 0;
          for (uint64_t i = 0; i < v28; ++i)
          {
            uint64_t v31 = *(void *)(v24 + 16) + v29;
            if ((*(_DWORD *)(v31 + 12) & 0x1D) == 1)
            {
              CMTime v32 = *(const void **)(v31 + 96);
              unsigned int v104 = *(_DWORD *)(v31 + 104);
              CFArrayAppendValue(Mutable, v32);
              FigCFArrayAppendInt32();
              uint64_t v28 = *(void *)(v24 + 8);
            }
            v29 += 108;
          }
        }
        MEMORY[0x19970E930](v102[1]);
        goto LABEL_45;
      }
LABEL_25:
      MaxEditdouble Rate = FigSignalErrorAt();
      MEMORY[0x19970E930](v102[1]);
      CFArrayRef v25 = 0;
      if (!MaxEditRate)
      {
LABEL_45:
        if (CFArrayGetCount(Mutable))
        {
          BOOL v101 = v22;
          long long v33 = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
          if (CFArrayGetCount(Mutable) < 1)
          {
            uint64_t v35 = 0;
LABEL_70:
            MaxEditdouble Rate = 0;
            *a4 = v33;
            long long v33 = 0;
          }
          else
          {
            uint64_t v34 = 0;
            uint64_t v35 = 0;
            CFIndex v36 = 0;
            while (1)
            {
              CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v36);
              FigCFArrayGetInt32AtIndex();
              if (v35)
              {
                CFRelease(v35);
                *(void *)&valuePtr[0] = 0;
              }
              uint64_t v38 = compositionTable_copyConcreteTrackReaderForAssetURLTrackIDMediaType((uint64_t)v102, ValueAtIndex, v104, v100, a3, (CFTypeRef *)valuePtr);
              if (v38)
              {
                MaxEditdouble Rate = v38;
                uint64_t v35 = *(const void **)&valuePtr[0];
                goto LABEL_71;
              }
              if (v106)
              {
                CFRelease(v106);
                CFTypeRef v106 = 0;
              }
              uint64_t v35 = *(const void **)&valuePtr[0];
              uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(*(void *)&valuePtr[0]);
              uint64_t v40 = *(void *)(CMBaseObjectGetVTable() + 8);
              if (v40) {
                uint64_t v41 = v40;
              }
              else {
                uint64_t v41 = 0;
              }
              uint64_t v42 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, CFTypeRef *))(v41 + 48);
              if (!v42)
              {
                MaxEditdouble Rate = 4294954514;
                goto LABEL_71;
              }
              uint64_t v43 = v42(FigBaseObject, @"TrackFormatDescriptionArray", a3, &v106);
              if (v43) {
                break;
              }
              for (CFIndex j = 0; ; ++j)
              {
                CFIndex Count = (CFIndex)v106;
                if (v106) {
                  CFIndex Count = CFArrayGetCount((CFArrayRef)v106);
                }
                if (j >= Count) {
                  break;
                }
                uint64_t v46 = CFArrayGetValueAtIndex((CFArrayRef)v106, j);
                if (v34)
                {
                  CFRelease(v34);
                  CMTimeValue value = 0;
                }
                mutableComposition_copyReplacedFormatDescription(v25, v46, &value);
                uint64_t v34 = value;
                CFArrayAppendValue(v33, value);
              }
              if (++v36 >= CFArrayGetCount(Mutable)) {
                goto LABEL_70;
              }
            }
            MaxEditdouble Rate = v43;
          }
LABEL_71:
          if (v35) {
            CFRelease(v35);
          }
          if (v33) {
            CFRelease(v33);
          }
          CFMutableArrayRef v22 = v101;
        }
        else
        {
          MaxEditdouble Rate = 4294954775;
        }
      }
    }
    else
    {
      MaxEditdouble Rate = FigSignalErrorAt();
      CFArrayRef v25 = 0;
    }
    if (v106) {
      CFRelease(v106);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v22) {
      CFRelease(v22);
    }
    if (v25) {
      CFRelease(v25);
    }
    if (value) {
      CFRelease(value);
    }
    if (MaxEditRate == -12521)
    {
      MaxEditdouble Rate = 0;
      *a4 = 0;
    }
    return MaxEditRate;
  }
  if (CFEqual(a2, @"TrackDimensions"))
  {
    return composite_trackReader_copyPropertyFromFirstNonEmptyEdit(a1, (uint64_t)a2, a3, (uint64_t)a4);
  }
  if (CFEqual(a2, @"TrackTimescale"))
  {
    MEMORY[0x19970E910](v10[1]);
    uint64_t v47 = v10[2];
    if (v47 < 1) {
      goto LABEL_101;
    }
    uint64_t v48 = (const void **)(v10[4] + 32);
    while (*((_DWORD *)v48 - 7) != *((_DWORD *)v9 + 2))
    {
      v48 += 21;
      if (!--v47) {
        goto LABEL_101;
      }
    }
    uint64_t v27 = (void *)*v48;
    if (!*v48)
    {
LABEL_101:
      MEMORY[0x19970E930](v10[1]);
      int v51 = *((_DWORD *)v9 + 2);
      uint64_t v52 = *((unsigned int *)v9 + 3);
      return compositionTable_copyTrackMediaTimeScale(v10, v51, v52, a3, a4);
    }
LABEL_30:
    uint64_t v27 = (void *)CFRetain(v27);
LABEL_31:
    MaxEditdouble Rate = 0;
    *a4 = (__CFArray *)v27;
    goto LABEL_32;
  }
  if (CFEqual(a2, @"AlternateGroupID"))
  {
    MEMORY[0x19970E910](v10[1]);
    uint64_t v49 = v10[2];
    if (v49 >= 1)
    {
      uint64_t v50 = (const void **)(v10[4] + 104);
      while (*((_DWORD *)v50 - 25) != *((_DWORD *)v9 + 2))
      {
        v50 += 21;
        if (!--v49) {
          goto LABEL_16;
        }
      }
      goto LABEL_116;
    }
LABEL_16:
    uint64_t v16 = FigSignalErrorAt();
LABEL_17:
    MaxEditdouble Rate = v16;
LABEL_32:
    MEMORY[0x19970E930](v10[1]);
    return MaxEditRate;
  }
  if (CFEqual(a2, @"TrackLanguageCode"))
  {
    MEMORY[0x19970E910](v10[1]);
    uint64_t v53 = v10[2];
    if (v53 < 1) {
      goto LABEL_16;
    }
    uint64_t v50 = (const void **)(v10[4] + 40);
    while (*((_DWORD *)v50 - 9) != *((_DWORD *)v9 + 2))
    {
      v50 += 21;
      if (!--v53) {
        goto LABEL_16;
      }
    }
LABEL_116:
    uint64_t v27 = (void *)*v50;
    if (!*v50) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (CFEqual(a2, @"ExtendedLanguageTagString"))
  {
    MEMORY[0x19970E910](v10[1]);
    uint64_t v54 = v10[2];
    if (v54 < 1) {
      goto LABEL_16;
    }
    uint64_t v50 = (const void **)(v10[4] + 48);
    while (*((_DWORD *)v50 - 11) != *((_DWORD *)v9 + 2))
    {
      v50 += 21;
      if (!--v54) {
        goto LABEL_16;
      }
    }
    goto LABEL_116;
  }
  if (CFEqual(a2, @"TrackMatrix"))
  {
    MEMORY[0x19970E910](v10[1]);
    uint64_t v55 = v10[2];
    if (v55 < 1) {
      goto LABEL_133;
    }
    long long v56 = (const void **)(v10[4] + 56);
    while (*((_DWORD *)v56 - 13) != *((_DWORD *)v9 + 2))
    {
      v56 += 21;
      if (!--v55) {
        goto LABEL_133;
      }
    }
    uint64_t v27 = (void *)*v56;
    if (!*v56)
    {
LABEL_133:
      long long v59 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      valuePtr[0] = *MEMORY[0x1E4F1DAB8];
      valuePtr[1] = v59;
      valuePtr[2] = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
      uint64_t v27 = FigCreate3x3MatrixArrayFromCGAffineTransform(a3, valuePtr);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (CFEqual(a2, @"Volume"))
  {
    MEMORY[0x19970E910](v10[1]);
    uint64_t v57 = v10[2];
    if (v57 < 1) {
      goto LABEL_137;
    }
    uint64_t v58 = (const void **)(v10[4] + 64);
    while (*((_DWORD *)v58 - 15) != *((_DWORD *)v9 + 2))
    {
      v58 += 21;
      if (!--v57) {
        goto LABEL_137;
      }
    }
    uint64_t v27 = (void *)*v58;
    if (!*v58)
    {
LABEL_137:
      LODWORD(valuePtr[0]) = 1065353216;
      uint64_t v27 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, valuePtr);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (CFEqual(a2, @"UneditedSampleCount")) {
    return 4294954513;
  }
  if (CFEqual(a2, @"MediaCharacteristicArray"))
  {
    uint64_t v60 = *MEMORY[0x1E4F1CF80];
    return FigMediaCharacteristicsCopyMediaCharacteristicsForTrackReader(v60, a1, a4);
  }
  if (CFEqual(a2, @"NominalFrameRate"))
  {
    MEMORY[0x19970E910](v10[1]);
    uint64_t v61 = v10[2];
    if (v61 >= 1)
    {
      uint64_t v62 = (int *)(v10[4] + 4);
      while (*v62 != *((_DWORD *)v9 + 2))
      {
        v62 += 42;
        if (!--v61) {
          goto LABEL_153;
        }
      }
      MEMORY[0x19970E930](v10[1]);
      unsigned int v66 = *(v62 - 1);
      int v65 = *v62;
      CFAllocatorRef v67 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      return compositionTable_copyTrackNominalFrameRate(v10, v65, v66, v67, a4);
    }
    goto LABEL_153;
  }
  if (!CFEqual(a2, @"EstimatedDataRate"))
  {
    if (CFEqual(a2, @"QuickTimeUserDataReader"))
    {
      MEMORY[0x19970E910](v10[1]);
      uint64_t v68 = v10[2];
      if (v68 < 1) {
        goto LABEL_16;
      }
      uint64_t v69 = v10[4];
      while (*(_DWORD *)(v69 + 4) != *((_DWORD *)v9 + 2))
      {
        v69 += 168;
        if (!--v68) {
          goto LABEL_16;
        }
      }
      uint64_t v16 = compositionTableTrack_assureQuickTimeUserDataReaderCreated(v69);
      if (v16) {
        goto LABEL_17;
      }
      uint64_t v27 = *(void **)(v69 + 80);
      if (v27) {
        goto LABEL_30;
      }
LABEL_192:
      MaxEditdouble Rate = 4294954513;
      goto LABEL_32;
    }
    if (CFEqual(a2, @"ISOUserDataReader"))
    {
      MEMORY[0x19970E910](v10[1]);
      uint64_t v73 = v10[2];
      if (v73 < 1) {
        goto LABEL_16;
      }
      uint64_t v74 = v10[4];
      while (*(_DWORD *)(v74 + 4) != *((_DWORD *)v9 + 2))
      {
        v74 += 168;
        if (!--v73) {
          goto LABEL_16;
        }
      }
      uint64_t v16 = compositionTableTrack_assureISOUserDataReaderCreated(v74);
      if (v16) {
        goto LABEL_17;
      }
      uint64_t v27 = *(void **)(v74 + 88);
      if (v27) {
        goto LABEL_30;
      }
      goto LABEL_192;
    }
    if (CFEqual(a2, @"QuickTimeMetadataReader"))
    {
      MEMORY[0x19970E910](v10[1]);
      uint64_t v75 = v10[2];
      if (v75 < 1) {
        goto LABEL_16;
      }
      uint64_t v76 = v10[4];
      while (*(_DWORD *)(v76 + 4) != *((_DWORD *)v9 + 2))
      {
        v76 += 168;
        if (!--v75) {
          goto LABEL_16;
        }
      }
      uint64_t v16 = compositionTableTrack_assureQuickTimeMetadataReaderCreated(v76);
      if (v16) {
        goto LABEL_17;
      }
      uint64_t v27 = *(void **)(v76 + 96);
      if (v27) {
        goto LABEL_30;
      }
      goto LABEL_192;
    }
    if (CFEqual(a2, @"MetadataReaders"))
    {
      MEMORY[0x19970E910](v10[1]);
      uint64_t v77 = v10[2];
      if (v77 < 1) {
        goto LABEL_16;
      }
      int v78 = *((_DWORD *)v9 + 2);
      uint64_t v79 = v10[4];
      while (*(_DWORD *)(v79 + 4) != v78)
      {
        v79 += 168;
        if (!--v77) {
          goto LABEL_16;
        }
      }
      uint64_t v16 = compositionTableTrack_assureQuickTimeUserDataReaderCreated(v79);
      if (v16) {
        goto LABEL_17;
      }
      uint64_t v16 = compositionTableTrack_assureQuickTimeMetadataReaderCreated(v79);
      if (v16) {
        goto LABEL_17;
      }
      uint64_t v16 = compositionTableTrack_assureISOUserDataReaderCreated(v79);
      if (v16) {
        goto LABEL_17;
      }
      if (*(void *)(v79 + 80) || *(void *)(v79 + 88) || *(void *)(v79 + 96))
      {
        CMTime v83 = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
        if (v83)
        {
          CMTime v84 = v83;
          CMTime v85 = *(const void **)(v79 + 96);
          if (v85) {
            CFArrayAppendValue(v83, v85);
          }
          CFIndex v86 = *(const void **)(v79 + 80);
          if (v86) {
            CFArrayAppendValue(v84, v86);
          }
          CMTimeValue v87 = *(const void **)(v79 + 88);
          if (v87) {
            CFArrayAppendValue(v84, v87);
          }
          MaxEditdouble Rate = 0;
          *a4 = v84;
          goto LABEL_32;
        }
        goto LABEL_16;
      }
    }
    else if (CFEqual(a2, @"MetadataReaderTypes"))
    {
      MEMORY[0x19970E910](v10[1]);
      uint64_t v80 = v10[2];
      if (v80 < 1) {
        goto LABEL_16;
      }
      int v81 = *((_DWORD *)v9 + 2);
      int v82 = (CFDictionaryRef *)(v10[4] + 72);
      while (*((_DWORD *)v82 - 17) != v81)
      {
        v82 += 21;
        if (!--v80) {
          goto LABEL_16;
        }
      }
      CFMutableArrayRef v89 = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
      if (!v89) {
        goto LABEL_16;
      }
      CFIndex v90 = v89;
      if (*v82)
      {
        if (CFDictionaryGetValue(*v82, @"com.apple.quicktime.udta")) {
          CFArrayAppendValue(v90, @"QuickTimeUserDataReader");
        }
        if (*v82)
        {
          if (CFDictionaryGetValue(*v82, @"org.mp4ra")) {
            CFArrayAppendValue(v90, @"ISOUserDataReader");
          }
          if (*v82 && CFDictionaryGetValue(*v82, @"com.apple.quicktime.mdta")) {
            CFArrayAppendValue(v90, @"QuickTimeMetadataReader");
          }
        }
      }
      CFIndex v91 = CFArrayGetCount(v90);
      if (v91 <= 0) {
        unint64_t v92 = 0;
      }
      else {
        unint64_t v92 = v90;
      }
      *a4 = v92;
      if (v91 <= 0) {
        CFRelease(v90);
      }
    }
    else
    {
      if (CFEqual(a2, @"MinSampleDuration"))
      {
        int v88 = *((_DWORD *)v9 + 2);
        return compositionTable_copyTrackMinSampleDuration(v10, v88, a3, a4);
      }
      if (CFEqual(a2, @"MaxEditRate"))
      {
        LODWORD(valuePtr[0]) = 1065353216;
        MaxEditdouble Rate = compositionTable_getMaxEditRate(v10, *((_DWORD *)v9 + 2), (float *)valuePtr);
        if (!MaxEditRate) {
          *a4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, valuePtr);
        }
        return MaxEditRate;
      }
      if (CFEqual(a2, @"EditsExcludePrimingAndRemainderDuration"))
      {
        MaxEditdouble Rate = 0;
        *a4 = (__CFArray *)*MEMORY[0x1E4F1CFD0];
        return MaxEditRate;
      }
      if (CFEqual(a2, @"HasAudioSampleDependencyInformation"))
      {
        int v93 = *((_DWORD *)v9 + 2);
        return compositionTable_copyTrackHasAudioSampleDependencyInformation(v10, v93, a4);
      }
      if (CFEqual(a2, @"TrackLayer"))
      {
        MEMORY[0x19970E910](v10[1]);
        uint64_t v94 = v10[2];
        if (v94 < 1) {
          goto LABEL_232;
        }
        unint64_t v95 = (const void **)(v10[4] + 120);
        while (*((_DWORD *)v95 - 29) != *((_DWORD *)v9 + 2))
        {
          MaxEditdouble Rate = 0;
          v95 += 21;
          if (!--v94) {
            goto LABEL_32;
          }
        }
      }
      else if (CFEqual(a2, @"CleanApertureDimensions"))
      {
        MEMORY[0x19970E910](v10[1]);
        uint64_t v96 = v10[2];
        if (v96 < 1) {
          goto LABEL_232;
        }
        unint64_t v95 = (const void **)(v10[4] + 128);
        while (*((_DWORD *)v95 - 31) != *((_DWORD *)v9 + 2))
        {
          MaxEditdouble Rate = 0;
          v95 += 21;
          if (!--v96) {
            goto LABEL_32;
          }
        }
      }
      else if (CFEqual(a2, @"ProductionApertureDimensions"))
      {
        MEMORY[0x19970E910](v10[1]);
        uint64_t v97 = v10[2];
        if (v97 < 1) {
          goto LABEL_232;
        }
        unint64_t v95 = (const void **)(v10[4] + 136);
        while (*((_DWORD *)v95 - 33) != *((_DWORD *)v9 + 2))
        {
          MaxEditdouble Rate = 0;
          v95 += 21;
          if (!--v97) {
            goto LABEL_32;
          }
        }
      }
      else if (CFEqual(a2, @"EncodedPixelsDimensions"))
      {
        MEMORY[0x19970E910](v10[1]);
        uint64_t v98 = v10[2];
        if (v98 < 1) {
          goto LABEL_232;
        }
        unint64_t v95 = (const void **)(v10[4] + 144);
        while (*((_DWORD *)v95 - 35) != *((_DWORD *)v9 + 2))
        {
          MaxEditdouble Rate = 0;
          v95 += 21;
          if (!--v98) {
            goto LABEL_32;
          }
        }
      }
      else
      {
        if (!CFEqual(a2, @"TrackQTLoadSettings")) {
          return 4294954512;
        }
        MEMORY[0x19970E910](v10[1]);
        uint64_t v99 = v10[2];
        if (v99 < 1) {
          goto LABEL_232;
        }
        unint64_t v95 = (const void **)(v10[4] + 152);
        while (*((_DWORD *)v95 - 37) != *((_DWORD *)v9 + 2))
        {
          MaxEditdouble Rate = 0;
          v95 += 21;
          if (!--v99) {
            goto LABEL_32;
          }
        }
      }
      uint64_t v27 = (void *)*v95;
      if (*v95) {
        goto LABEL_30;
      }
    }
LABEL_232:
    MaxEditdouble Rate = 0;
    goto LABEL_32;
  }
  MEMORY[0x19970E910](v10[1]);
  uint64_t v63 = v10[2];
  if (v63 < 1)
  {
LABEL_153:
    MEMORY[0x19970E930](v10[1]);
LABEL_4:
    return FigSignalErrorAt();
  }
  CMTimeValue v64 = (int *)(v10[4] + 4);
  while (*v64 != *((_DWORD *)v9 + 2))
  {
    v64 += 42;
    if (!--v63) {
      goto LABEL_153;
    }
  }
  MEMORY[0x19970E930](v10[1]);
  unsigned int v71 = *(v64 - 1);
  int v70 = *v64;
  CFAllocatorRef v72 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];

  return compositionTable_copyTrackEstimatedDataRate(v10, v70, v71, v72, a4);
}

uint64_t composite_trackReader_copyPropertyFromFirstNonEmptyEdit(uint64_t a1, uint64_t a2, const __CFAllocator *a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  int v8 = *(_DWORD *)(DerivedStorage + 8);
  uint64_t v9 = *(unsigned int *)(DerivedStorage + 12);
  uint64_t v10 = *(void **)DerivedStorage;

  return compositionTable_copyTrackPropertyFromFirstNonEmptyEdit(v10, v8, v9, a2, a3, a4);
}

uint64_t compositionTable_copyTrackMediaTimeScale(void *a1, int a2, uint64_t a3, const __CFAllocator *a4, void *a5)
{
  int valuePtr = 0;
  CFNumberRef number = 0;
  int v10 = 600;
  uint64_t NonEmptyEdit = compositionTable_copyTrackPropertyFromFirstNonEmptyEdit(a1, a2, a3, @"TrackTimescale", a4, (uint64_t)&number);
  if (NonEmptyEdit == -12521) {
    goto LABEL_4;
  }
  uint64_t v7 = NonEmptyEdit;
  if (NonEmptyEdit) {
    goto LABEL_6;
  }
  CFNumberGetValue(number, kCFNumberIntType, &valuePtr);
  if (valuePtr <= 599)
  {
LABEL_4:
    int v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v10);
  }
  else
  {
    int v8 = number;
    if (number) {
      int v8 = (void *)CFRetain(number);
    }
  }
  uint64_t v7 = 0;
  *a5 = v8;
LABEL_6:
  if (number) {
    CFRelease(number);
  }
  return v7;
}

uint64_t compositionTable_copyTrackNominalFrameRate(void *a1, int a2, unsigned int a3, const __CFAllocator *a4, void *a5)
{
  int valuePtr = 0;
  CFTypeRef cf = 0;
  uint64_t v6 = compositionTable_copyAverageTrackPropertyFromNonEmptyEdits(a1, a2, a3, @"NominalFrameRate", a4, (CFNumberRef *)&cf);
  if (v6 == -12521)
  {
    uint64_t v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, &valuePtr);
LABEL_5:
    uint64_t result = 0;
    *a5 = v7;
    return result;
  }
  if (!v6)
  {
    uint64_t v7 = (void *)cf;
    goto LABEL_5;
  }
  uint64_t v9 = v6;
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t compositionTable_copyTrackEstimatedDataRate(void *a1, int a2, unsigned int a3, const __CFAllocator *a4, void *a5)
{
  int valuePtr = 0;
  CFTypeRef cf = 0;
  uint64_t v6 = compositionTable_copyAverageTrackPropertyFromNonEmptyEdits(a1, a2, a3, @"EstimatedDataRate", a4, (CFNumberRef *)&cf);
  if (v6 == -12521)
  {
    uint64_t v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, &valuePtr);
LABEL_5:
    uint64_t result = 0;
    *a5 = v7;
    return result;
  }
  if (!v6)
  {
    uint64_t v7 = (void *)cf;
    goto LABEL_5;
  }
  uint64_t v9 = v6;
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t compositionTableTrack_assureQuickTimeUserDataReaderCreated(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 80);
  if (*(void *)(a1 + 80)) {
    return 0;
  }
  CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 72);
  if (!v3) {
    return 0;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(v3, @"com.apple.quicktime.udta");
  if (!Value) {
    return 0;
  }
  uint64_t v5 = Value;
  uint64_t v6 = *MEMORY[0x1E4F1CF80];

  return FigMetadataReaderCreateForQuickTimeUserDataArray(v6, v5, v1);
}

uint64_t compositionTableTrack_assureISOUserDataReaderCreated(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 88);
  if (*(void *)(a1 + 88)) {
    return 0;
  }
  CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 72);
  if (!v3) {
    return 0;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(v3, @"org.mp4ra");
  if (!Value) {
    return 0;
  }
  uint64_t v5 = Value;
  uint64_t v6 = *MEMORY[0x1E4F1CF80];

  return FigMetadataReaderCreateForISOUserDataArray(v6, v5, v1);
}

uint64_t compositionTableTrack_assureQuickTimeMetadataReaderCreated(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 96);
  if (*(void *)(a1 + 96)) {
    return 0;
  }
  CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 72);
  if (!v3) {
    return 0;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(v3, @"com.apple.quicktime.mdta");
  if (!Value) {
    return 0;
  }
  uint64_t v5 = Value;
  uint64_t v6 = *MEMORY[0x1E4F1CF80];

  return FigMetadataReaderCreateForQuickTimeMetadataArray(v6, v5, v1);
}

uint64_t compositionTable_copyTrackMinSampleDuration(void *a1, int a2, const __CFAllocator *a3, CFDictionaryRef *a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  int v8 = (_OWORD *)MEMORY[0x1E4F1F9F8];
  CMTimeValue v9 = *MEMORY[0x1E4F1F9F8];
  CFTypeRef v43 = 0;
  CMTimeValue v44 = v9;
  CMTimeFlags v10 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
  CMTimeScale v36 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  CMTimeScale v45 = v36;
  CMTimeEpoch v11 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  uint64_t v12 = MEMORY[0x1E4F1FA10];
  CFDictionaryRef v42 = 0;
  CMTimeValue value = *MEMORY[0x1E4F1FA10];
  CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1FA10] + 8);
  MEMORY[0x19970E910](a1[1]);
  uint64_t v13 = a1[2];
  if (v13 < 1)
  {
LABEL_5:
    uint64_t v15 = FigSignalErrorAt();
    CMTimeFlags v16 = v10;
    CMTimeEpoch v17 = v11;
    goto LABEL_28;
  }
  CMTimeFlags flags = *(_DWORD *)(v12 + 12);
  uint64_t v14 = (void *)(a1[4] + 8);
  while (*((_DWORD *)v14 - 1) != a2)
  {
    v14 += 21;
    if (!--v13) {
      goto LABEL_5;
    }
  }
  CMTimeEpoch epoch = *(void *)(v12 + 16);
  CMTimeFlags v32 = v10;
  CFAllocatorRef v33 = a3;
  uint64_t v34 = a4;
  uint64_t v18 = *v14;
  if ((uint64_t)*v14 >= 1)
  {
    uint64_t v19 = 0;
    uint64_t v15 = 0;
    uint64_t v20 = 0;
    CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (1)
    {
      uint64_t v22 = v14[1] + v19;
      if ((*(_DWORD *)(v22 + 12) & 0x1D) == 1)
      {
        uint64_t v23 = *(const void **)(v22 + 96);
        uint64_t v24 = *(unsigned int *)(v22 + 104);
        *(_OWORD *)&time.CMTimeValue value = *v8;
        time.CMTimeEpoch epoch = v11;
        uint64_t v25 = compositionTable_copyConcreteTrackReaderForAssetURLTrackIDMediaType((uint64_t)a1, v23, v24, *((unsigned int *)v14 - 2), v21, &v43);
        if (v25)
        {
          uint64_t v15 = v25;
          CMTimeFlags v10 = v32;
          CMTimeFlags v16 = v32;
          CMTimeEpoch v17 = v11;
          a3 = v33;
          a4 = v34;
          goto LABEL_28;
        }
        CFTypeRef v26 = v43;
        uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(v43);
        uint64_t v28 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v28) {
          uint64_t v29 = v28;
        }
        else {
          uint64_t v29 = 0;
        }
        CFDictionaryRef v30 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, const __CFDictionary **))(v29 + 48);
        if (v30)
        {
          uint64_t v15 = v30(FigBaseObject, @"MinSampleDuration", v21, &v42);
          if (!v15)
          {
            CMTimeMakeFromDictionary(&time, v42);
            time1.CMTimeValue value = value;
            time1.CMTimeScale timescale = timescale;
            time1.CMTimeFlags flags = flags;
            time1.CMTimeEpoch epoch = epoch;
            CMTime time2 = time;
            CMTimeMinimum(&v40, &time1, &time2);
            CMTimeValue value = v40.value;
            CMTimeFlags flags = v40.flags;
            CMTimeScale timescale = v40.timescale;
            CMTimeEpoch epoch = v40.epoch;
          }
        }
        else
        {
          uint64_t v15 = 4294954514;
        }
        if (v42)
        {
          CFRelease(v42);
          CFDictionaryRef v42 = 0;
        }
        if (v26)
        {
          CFRelease(v26);
          CFTypeRef v43 = 0;
        }
        uint64_t v18 = *v14;
      }
      ++v20;
      v19 += 108;
      if (v20 >= v18) {
        goto LABEL_25;
      }
    }
  }
  uint64_t v15 = 0;
LABEL_25:
  CMTimeFlags v16 = flags;
  a3 = v33;
  a4 = v34;
  CMTimeFlags v10 = v32;
  CMTimeEpoch v17 = epoch;
  if ((~flags & 5) == 0)
  {
    CMTimeValue value = v9;
    CMTimeScale timescale = v36;
    CMTimeFlags v16 = v32;
    CMTimeEpoch v17 = v11;
  }
  CMTimeValue v44 = value;
  CMTimeScale v45 = timescale;
LABEL_28:
  MEMORY[0x19970E930](a1[1]);
  if (v42) {
    CFRelease(v42);
  }
  if (v43) {
    CFRelease(v43);
  }
  if (v15 == -12521)
  {
    CMTimeValue v44 = v9;
    CMTimeScale v45 = v36;
    CMTimeEpoch v17 = v11;
    CMTimeFlags v16 = v10;
LABEL_35:
    time.CMTimeValue value = v44;
    time.CMTimeScale timescale = v45;
    time.CMTimeFlags flags = v16;
    time.CMTimeEpoch epoch = v17;
    uint64_t v15 = 0;
    *a4 = CMTimeCopyAsDictionary(&time, a3);
    return v15;
  }
  if (!v15) {
    goto LABEL_35;
  }
  return v15;
}

uint64_t compositionTable_getMaxEditRate(void *a1, int a2, float *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  CFTypeRef v36 = 0;
  MEMORY[0x19970E910](a1[1]);
  uint64_t v6 = a1[2];
  if (v6 < 1)
  {
LABEL_5:
    uint64_t v8 = FigSignalErrorAt();
LABEL_6:
    uint64_t v9 = v8;
  }
  else
  {
    uint64_t v7 = (void *)(a1[4] + 8);
    while (*((_DWORD *)v7 - 1) != a2)
    {
      v7 += 21;
      if (!--v6) {
        goto LABEL_5;
      }
    }
    if ((uint64_t)*v7 < 1)
    {
      uint64_t v9 = 0;
      float v14 = 1.0;
    }
    else
    {
      uint64_t v10 = 0;
      uint64_t v9 = 0;
      int v11 = 0;
      uint64_t v12 = 0;
      CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      float v14 = 1.0;
      do
      {
        uint64_t v15 = v7[1] + v10;
        if ((*(_DWORD *)(v15 + 12) & 0x1D) == 1)
        {
          uint64_t v8 = compositionTable_copyConcreteTrackReaderForAssetURLTrackIDMediaType((uint64_t)a1, *(const void **)(v15 + 96), *(unsigned int *)(v15 + 104), *((unsigned int *)v7 - 2), v13, &v36);
          if (v8) {
            goto LABEL_6;
          }
          CFTypeRef v16 = v36;
          uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(v36);
          uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v18) {
            uint64_t v19 = v18;
          }
          else {
            uint64_t v19 = 0;
          }
          uint64_t v20 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, CFTypeRef *))(v19 + 48);
          if (v20)
          {
            uint64_t v21 = v20(FigBaseObject, @"MaxEditRate", v13, &cf);
            if (v21)
            {
              uint64_t v9 = v21;
            }
            else
            {
              int v32 = v11;
              float valuePtr = 1.0;
              CFNumberGetValue((CFNumberRef)cf, kCFNumberFloat32Type, &valuePtr);
              uint64_t v22 = (long long *)(v7[1] + v10);
              long long v23 = v22[1];
              long long v40 = *v22;
              long long v41 = v23;
              CMTimeFlags v24 = *((_DWORD *)v22 + 9);
              CMTimeScale v42 = *((_DWORD *)v22 + 8);
              CMTimeEpoch v25 = *((void *)v22 + 5);
              long long v26 = v22[4];
              long long v37 = v22[3];
              long long v38 = v26;
              CMTimeScale v39 = *((_DWORD *)v22 + 20);
              if ((v24 & 0x1D) == 1)
              {
                CMTimeFlags v27 = *((_DWORD *)v22 + 21);
                if ((v27 & 0x1D) == 1)
                {
                  CMTimeEpoch v31 = *((void *)v22 + 11);
                  time.CMTimeValue value = *((void *)&v41 + 1);
                  time.CMTimeScale timescale = v42;
                  time.CMTimeFlags flags = v24;
                  time.CMTimeEpoch epoch = v25;
                  if (CMTimeGetSeconds(&time) != 0.0)
                  {
                    time.CMTimeValue value = *((void *)&v38 + 1);
                    time.CMTimeScale timescale = v39;
                    time.CMTimeFlags flags = v27;
                    time.CMTimeEpoch epoch = v31;
                    if (CMTimeGetSeconds(&time) != 0.0)
                    {
                      time.CMTimeValue value = *((void *)&v41 + 1);
                      time.CMTimeScale timescale = v42;
                      time.CMTimeFlags flags = v24;
                      time.CMTimeEpoch epoch = v25;
                      double Seconds = CMTimeGetSeconds(&time);
                      time.CMTimeValue value = *((void *)&v38 + 1);
                      time.CMTimeScale timescale = v39;
                      time.CMTimeFlags flags = v27;
                      time.CMTimeEpoch epoch = v31;
                      float v29 = Seconds / CMTimeGetSeconds(&time);
                      float valuePtr = valuePtr * v29;
                    }
                  }
                }
              }
              if (!v32 || v14 < valuePtr) {
                float v14 = valuePtr;
              }
              uint64_t v9 = 0;
              int v11 = 1;
            }
          }
          else
          {
            uint64_t v9 = 4294954514;
          }
          if (cf)
          {
            CFRelease(cf);
            CFTypeRef cf = 0;
          }
          if (v16)
          {
            CFRelease(v16);
            CFTypeRef v36 = 0;
          }
        }
        ++v12;
        v10 += 108;
      }
      while (v12 < *v7);
    }
    *a3 = v14;
  }
  MEMORY[0x19970E930](a1[1]);
  if (cf) {
    CFRelease(cf);
  }
  if (v36) {
    CFRelease(v36);
  }
  return v9;
}

uint64_t compositionTable_copyTrackHasAudioSampleDependencyInformation(void *a1, int a2, void *a3)
{
  CFTypeRef v31 = 0;
  MEMORY[0x19970E910](a1[1]);
  uint64_t v6 = a1[2];
  if (v6 >= 1)
  {
    uint64_t v7 = (void *)(a1[4] + 8);
    while (*((_DWORD *)v7 - 1) != a2)
    {
      v7 += 21;
      if (!--v6) {
        goto LABEL_5;
      }
    }
    uint64_t v11 = *v7;
    if ((uint64_t)*v7 > 0)
    {
      uint64_t v12 = 0;
      uint64_t v8 = 0;
      CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFTypeRef v29 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
      uint64_t v14 = 1;
      while (1)
      {
        uint64_t v15 = v7[1] + v12;
        if ((*(_DWORD *)(v15 + 12) & 0x1D) == 1) {
          break;
        }
        int v9 = 0;
LABEL_31:
        if (v14 < v11)
        {
          v12 += 108;
          ++v14;
          if (!v9) {
            continue;
          }
        }
        goto LABEL_6;
      }
      CFTypeRef v16 = *(const void **)(v15 + 96);
      uint64_t v17 = *(unsigned int *)(v15 + 104);
      CFTypeRef cf = 0;
      uint64_t v18 = compositionTable_copyConcreteTrackReaderForAssetURLTrackIDMediaType((uint64_t)a1, v16, v17, *((unsigned int *)v7 - 2), v13, &v31);
      if (v18)
      {
        uint64_t v8 = v18;
        CFTypeRef v28 = v31;
        MEMORY[0x19970E930](a1[1]);
        if (v28) {
          CFRelease(v28);
        }
        return v8;
      }
      CFTypeRef v19 = v31;
      uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(v31);
      uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v21) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = 0;
      }
      long long v23 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, CFTypeRef *))(v22 + 48);
      if (v23)
      {
        uint64_t v8 = v23(FigBaseObject, @"HasAudioSampleDependencyInformation", v13, &cf);
        CFTypeRef v24 = cf;
        if (v8) {
          BOOL v25 = 0;
        }
        else {
          BOOL v25 = cf == v29;
        }
        int v9 = v25;
        if (!cf) {
          goto LABEL_28;
        }
      }
      else
      {
        int v9 = 0;
        uint64_t v8 = 4294954514;
        CFTypeRef v24 = cf;
        if (!cf)
        {
LABEL_28:
          if (v19)
          {
            CFRelease(v19);
            CFTypeRef v31 = 0;
          }
          uint64_t v11 = *v7;
          goto LABEL_31;
        }
      }
      CFRelease(v24);
      CFTypeRef cf = 0;
      goto LABEL_28;
    }
    MEMORY[0x19970E930](a1[1]);
    goto LABEL_35;
  }
LABEL_5:
  uint64_t v8 = FigSignalErrorAt();
  int v9 = 0;
LABEL_6:
  MEMORY[0x19970E930](a1[1]);
  if (!v8)
  {
    if (v9)
    {
      uint64_t v10 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
LABEL_36:
      CFTypeRef v26 = *v10;
      if (*v10) {
        CFTypeRef v26 = CFRetain(v26);
      }
      uint64_t v8 = 0;
      *a3 = v26;
      return v8;
    }
LABEL_35:
    uint64_t v10 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
    goto LABEL_36;
  }
  return v8;
}

uint64_t compositionTable_copyConcreteTrackReaderForAssetURLTrackIDMediaType(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const __CFAllocator *a5, CFTypeRef *a6)
{
  CFTypeRef cf = 0;
  uint64_t v22 = 0;
  uint64_t v9 = compositionTable_copyFormatReaderForAssetURL(a1, a2, a5, &v22);
  if (v9)
  {
    uint64_t v17 = v9;
    uint64_t v10 = v22;
    if (v22) {
      goto LABEL_20;
    }
    goto LABEL_21;
  }
  if (!a3)
  {
    uint64_t v10 = v22;
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v18 = *(uint64_t (**)(const void *, void, uint64_t, CFTypeRef *, void))(v14 + 64);
    if (v18)
    {
      uint64_t v16 = v18(v10, 0, a4, &cf, 0);
      if (v16)
      {
LABEL_12:
        uint64_t v17 = v16;
        if (!v10) {
          goto LABEL_21;
        }
LABEL_20:
        CFRelease(v10);
        goto LABEL_21;
      }
      goto LABEL_17;
    }
LABEL_19:
    uint64_t v17 = 4294954514;
    if (!v10) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  int v20 = 0;
  uint64_t v10 = v22;
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v15 = *(uint64_t (**)(const void *, uint64_t, CFTypeRef *, int *))(v12 + 56);
  if (!v15) {
    goto LABEL_19;
  }
  uint64_t v16 = v15(v10, a3, &cf, &v20);
  if (v16) {
    goto LABEL_12;
  }
  if (v20 != a4)
  {
    uint64_t v16 = FigSignalErrorAt();
    goto LABEL_12;
  }
LABEL_17:
  uint64_t v17 = 0;
  *a6 = cf;
  CFTypeRef cf = 0;
  if (v10) {
    goto LABEL_20;
  }
LABEL_21:
  if (cf) {
    CFRelease(cf);
  }
  return v17;
}

void mutableComposition_copyReplacedFormatDescription(CFArrayRef theArray, CFTypeRef cf, void *a3)
{
  if (cf) {
    CFRetain(cf);
  }
  CFIndex v6 = 0;
  do
  {
    if (theArray) {
      CFIndex Count = CFArrayGetCount(theArray);
    }
    else {
      CFIndex Count = 0;
    }
    if (v6 >= Count)
    {
      CFTypeRef v11 = cf;
      goto LABEL_14;
    }
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v6);
    CFDictionaryRef Value = (const opaqueCMFormatDescription *)CFDictionaryGetValue(ValueAtIndex, @"MutableCompositionFormatDescriptionReplacementTableKey_OldFormatDescription");
    MEMORY[0x19970EE10](&mutableComposition_ignoredKeysForFormatDescriptionEquality_once, mutableComposition_makeIgnoredKeysForFormatDescriptionEquality);
    ++v6;
  }
  while (!CMFormatDescriptionEqualIgnoringExtensionKeys(Value, (CMFormatDescriptionRef)cf, (CFTypeRef)sIgnoredKeysForFormatDescriptionEquality, 0));
  uint64_t v10 = CFDictionaryGetValue(ValueAtIndex, @"MutableCompositionFormatDescriptionReplacementTableKey_NewFormatDescription");
  CFTypeRef v11 = v10;
  if (v10) {
    CFRetain(v10);
  }
  if (cf) {
    CFRelease(cf);
  }
LABEL_14:
  *a3 = v11;
}

uint64_t compositionTable_copyFormatReaderForAssetURL(uint64_t a1, const void *a2, const __CFAllocator *a3, void *a4)
{
  uint64_t v18 = 0;
  MEMORY[0x19970E910](*(void *)(a1 + 56));
  uint64_t v8 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), a2);
  CMTimeValue value = v8;
  if (v8)
  {
    uint64_t v9 = v8;
    CFRetain(v8);
LABEL_5:
    MEMORY[0x19970E930](*(void *)(a1 + 56));
    uint64_t CMBaseObject = FigAssetGetCMBaseObject(v9);
    uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v12) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, uint64_t *))(v13 + 48);
    if (v14)
    {
      uint64_t v15 = v14(CMBaseObject, @"assetProperty_FormatReader", a3, &v18);
      uint64_t v16 = v18;
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v15 = 4294954514;
    }
    goto LABEL_11;
  }
  MEMORY[0x19970E930](*(void *)(a1 + 56));
  uint64_t v10 = compositionSharedCache_copyAssetForAssetURL(*(void *)(a1 + 160), a2, a3, &value);
  if (!v10)
  {
    MEMORY[0x19970E910](*(void *)(a1 + 56));
    uint64_t v9 = value;
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 64), a2, value);
    goto LABEL_5;
  }
  uint64_t v15 = v10;
  uint64_t v16 = 0;
  uint64_t v9 = value;
LABEL_11:
  *a4 = v16;
  if (v9) {
    CFRelease(v9);
  }
  return v15;
}

uint64_t compositionSharedCache_copyAssetForAssetURL(uint64_t a1, const void *a2, const __CFAllocator *a3, void *a4)
{
  CFTypeRef cf = 0;
  CFTypeRef Value = 0;
  CFTypeRef v18 = 0;
  compositionSharedCache_copyAssetForAssetURLFromCache(a1, a2, &Value);
  CFTypeRef v8 = Value;
  if (Value)
  {
    CFTypeRef v9 = 0;
LABEL_21:
    uint64_t v16 = 0;
    *a4 = v8;
    CFTypeRef Value = 0;
    goto LABEL_22;
  }
  uint64_t v10 = *(void *)(a1 + 8);
  if (!v10)
  {
    uint64_t v13 = FigAssetCreateWithURL((uint64_t)a3, (uint64_t)a2, *(void *)(a1 + 16), *(const void **)(a1 + 24), &Value);
    if (!v13) {
      goto LABEL_13;
    }
LABEL_29:
    uint64_t v16 = v13;
    goto LABEL_16;
  }
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v14 = *(uint64_t (**)(uint64_t, const void *, void, void, void, CFTypeRef *))(v12 + 8);
  if (v14)
  {
    uint64_t v13 = v14(v10, a2, 0, 0, *MEMORY[0x1E4F1CF80], &v18);
    if (!v13)
    {
      uint64_t v13 = FigFormatReaderCreateForStream((uint64_t)v18, a3, 0, &cf);
      if (!v13)
      {
        CFAllocatorRef v15 = CFGetAllocator(cf);
        uint64_t v13 = FigAssetCreateWithFormatReader((uint64_t)v15, cf, 0, 0, &Value);
        if (!v13)
        {
LABEL_13:
          MEMORY[0x19970E910](*(void *)(a1 + 32));
          if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 40), a2))
          {
            CFTypeRef v9 = Value;
            CFTypeRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
            CFRetain(Value);
          }
          else
          {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), a2, Value);
            CFTypeRef v9 = 0;
          }
          MEMORY[0x19970E930](*(void *)(a1 + 32));
          CFTypeRef v8 = Value;
          goto LABEL_21;
        }
      }
    }
    goto LABEL_29;
  }
  uint64_t v16 = 4294954514;
LABEL_16:
  if (Value) {
    CFRelease(Value);
  }
  CFTypeRef v9 = 0;
LABEL_22:
  if (cf) {
    CFRelease(cf);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v18) {
    CFRelease(v18);
  }
  return v16;
}

uint64_t compositionSharedCache_copyAssetForAssetURLFromCache(uint64_t result, const void *a2, void *a3)
{
  uint64_t v4 = a2;
  if (a2)
  {
    uint64_t v5 = result;
    MEMORY[0x19970E910](*(void *)(result + 32));
    CFTypeRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 40), v4);
    uint64_t v4 = Value;
    if (Value) {
      CFRetain(Value);
    }
    uint64_t result = MEMORY[0x19970E930](*(void *)(v5 + 32));
  }
  *a3 = v4;
  return result;
}

void mutableComposition_makeIgnoredKeysForFormatDescriptionEquality()
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, (const void *)*MEMORY[0x1E4F1EE58]);
  CFArrayAppendValue(Mutable, (const void *)*MEMORY[0x1E4F1EE50]);
  sIgnoredKeysForFormatDescriptionEquality = (uint64_t)Mutable;
}

uint64_t compositionTable_copyTrackPropertyFromFirstNonEmptyEdit(void *a1, int a2, uint64_t a3, uint64_t a4, const __CFAllocator *a5, uint64_t a6)
{
  CFTypeRef cf = 0;
  MEMORY[0x19970E910](a1[1]);
  uint64_t v12 = a1[2];
  if (v12 < 1)
  {
LABEL_5:
    unsigned int v14 = FigSignalErrorAt();
LABEL_11:
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    char v19 = 1;
    goto LABEL_12;
  }
  uint64_t v13 = (void *)(a1[4] + 8);
  while (*((_DWORD *)v13 - 1) != a2)
  {
    v13 += 21;
    if (!--v12) {
      goto LABEL_5;
    }
  }
  uint64_t v15 = *v13;
  if ((uint64_t)*v13 < 1)
  {
LABEL_10:
    unsigned int v14 = 0;
    goto LABEL_11;
  }
  uint64_t v16 = (unsigned int *)(v13[1] + 104);
  while ((*(v16 - 23) & 0x1D) != 1)
  {
    v16 += 27;
    if (!--v15) {
      goto LABEL_10;
    }
  }
  uint64_t v17 = (const void *)*((void *)v16 - 1);
  uint64_t v18 = *v16;
  if (v17) {
    CFRetain(*((CFTypeRef *)v16 - 1));
  }
  unsigned int v14 = 0;
  char v19 = 0;
LABEL_12:
  MEMORY[0x19970E930](a1[1]);
  if (v14) {
    uint64_t v20 = v14;
  }
  else {
    uint64_t v20 = 4294954775;
  }
  if (v14 || (v19 & 1) != 0) {
    goto LABEL_27;
  }
  uint64_t v21 = compositionTable_copyConcreteTrackReaderForAssetURLTrackIDMediaType((uint64_t)a1, v17, v18, a3, a5, &cf);
  CFTypeRef v22 = cf;
  if (!v21)
  {
    uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
    uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v24) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = 0;
    }
    CFTypeRef v26 = *(uint64_t (**)(uint64_t, uint64_t, const __CFAllocator *, uint64_t))(v25 + 48);
    if (!v26)
    {
      uint64_t v20 = 4294954514;
      if (!v22) {
        goto LABEL_27;
      }
      goto LABEL_26;
    }
    uint64_t v21 = v26(FigBaseObject, a4, a5, a6);
  }
  uint64_t v20 = v21;
  if (v22) {
LABEL_26:
  }
    CFRelease(v22);
LABEL_27:
  if (v17) {
    CFRelease(v17);
  }
  return v20;
}

uint64_t compositionTable_copyAverageTrackPropertyFromNonEmptyEdits(void *a1, int a2, unsigned int a3, uint64_t a4, const __CFAllocator *a5, CFNumberRef *a6)
{
  double valuePtr = 0.0;
  CFTypeRef v63 = 0;
  CMTime v61 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  CFNumberRef v60 = 0;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v10 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFAllocatorRef allocator = v9;
  CFMutableArrayRef v12 = CFArrayCreateMutable(v9, 0, v10);
  MEMORY[0x19970E910](a1[1]);
  uint64_t v13 = a1[2];
  if (v13 < 1)
  {
LABEL_5:
    FigSignalErrorAt();
LABEL_6:
    MEMORY[0x19970E930](a1[1]);
    uint64_t v15 = 4294954775;
    goto LABEL_7;
  }
  unsigned int v14 = (void *)(a1[4] + 16);
  while (*((_DWORD *)v14 - 3) != a2)
  {
    v14 += 21;
    if (!--v13) {
      goto LABEL_5;
    }
  }
  uint64_t v17 = *(v14 - 1);
  if (v17 <= 0) {
    goto LABEL_6;
  }
  uint64_t v48 = a6;
  CFArrayRef theArray = v12;
  uint64_t v50 = Mutable;
  uint64_t v18 = 0;
  int v19 = 0;
  uint64_t v20 = 0;
  int v21 = 0;
  if (v17 >= 100) {
    uint64_t v22 = 100;
  }
  else {
    uint64_t v22 = *(v14 - 1);
  }
  do
  {
    uint64_t v23 = *v14 + v18;
    if ((*(_DWORD *)(v23 + 12) & 0x1D) == 1)
    {
      CMTime v59 = *(CMTime *)(v23 + 24);
      uint64_t v24 = *(void *)(v23 + 96);
      int v25 = *(_DWORD *)(v23 + 104);
      if (v20 && (v20 == v24 ? (BOOL v26 = v19 == v25) : (BOOL v26 = 0), v26))
      {
        CFIndex v27 = CFArrayGetCount(theArray) - 1;
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v27);
        memset(&time, 0, sizeof(time));
        CMTimeMakeFromDictionary(&rhs, ValueAtIndex);
        CMTime lhs = v59;
        CMTimeAdd(&time, &lhs, &rhs);
        CMTime lhs = time;
        CFDictionaryRef v29 = CMTimeCopyAsDictionary(&lhs, allocator);
        CFArraySetValueAtIndex(theArray, v27, v29);
        CFTypeRef v30 = 0;
      }
      else
      {
        uint64_t v31 = compositionTable_copyConcreteTrackReaderForAssetURLTrackIDMediaType((uint64_t)a1, *(const void **)(v23 + 96), *(unsigned int *)(v23 + 104), a3, a5, &v63);
        if (v31)
        {
          uint64_t v15 = v31;
          MEMORY[0x19970E930](a1[1]);
          CFMutableArrayRef Mutable = v50;
          CFMutableArrayRef v12 = theArray;
          goto LABEL_7;
        }
        CFTypeRef v30 = v63;
        CFArrayAppendValue(v50, v63);
        CMTime time = v59;
        CFDictionaryRef v29 = CMTimeCopyAsDictionary(&time, allocator);
        CFArrayAppendValue(theArray, v29);
        uint64_t v20 = v24;
        int v19 = v25;
      }
      uint64_t v32 = *v14 + v18;
      CMTime time = v61;
      long long v33 = *(_OWORD *)(v32 + 72);
      lhs.CMTimeEpoch epoch = *(void *)(v32 + 88);
      *(_OWORD *)&lhs.CMTimeValue value = v33;
      CMTimeAdd(&v61, &time, &lhs);
      if (v29) {
        CFRelease(v29);
      }
      if (v30)
      {
        CFRelease(v30);
        CFTypeRef v63 = 0;
      }
      int v21 = 1;
    }
    v18 += 108;
    --v22;
  }
  while (v22);
  MEMORY[0x19970E930](a1[1]);
  CFMutableArrayRef v12 = theArray;
  if (v21)
  {
    CFMutableArrayRef Mutable = v50;
    CFIndex Count = CFArrayGetCount(v50);
    if (Count < 1)
    {
      double v37 = 0.0;
LABEL_51:
      CMTime v59 = v61;
      double valuePtr = v37 / CMTimeGetSeconds(&v59);
      uint64_t v15 = 0;
      *uint64_t v48 = CFNumberCreate(allocator, kCFNumberFloat64Type, &valuePtr);
    }
    else
    {
      CFIndex v35 = Count;
      CFIndex v36 = 0;
      double v37 = 0.0;
      long long v52 = *MEMORY[0x1E4F1F9F8];
      CMTimeEpoch v38 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
      while (1)
      {
        lhs.CMTimeValue value = 0;
        *(_OWORD *)&v59.CMTimeValue value = v52;
        v59.CMTimeEpoch epoch = v38;
        CMTimeScale v39 = CFArrayGetValueAtIndex(v50, v36);
        CFDictionaryRef v40 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v36);
        CMTimeMakeFromDictionary(&v59, v40);
        uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(v39);
        uint64_t v42 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v42) {
          uint64_t v43 = v42;
        }
        else {
          uint64_t v43 = 0;
        }
        CMTimeValue v44 = *(uint64_t (**)(uint64_t, uint64_t, const __CFAllocator *, const __CFNumber **))(v43 + 48);
        if (!v44)
        {
          uint64_t v15 = 4294954514;
          goto LABEL_7;
        }
        uint64_t v45 = v44(FigBaseObject, a4, a5, &v60);
        if (v45) {
          break;
        }
        CFNumberGetValue(v60, kCFNumberFloat64Type, &lhs);
        double v46 = *(double *)&lhs.value;
        CMTime time = v59;
        double Seconds = CMTimeGetSeconds(&time);
        if (v60)
        {
          CFRelease(v60);
          CFNumberRef v60 = 0;
        }
        double v37 = v37 + v46 * Seconds;
        if (v35 == ++v36) {
          goto LABEL_51;
        }
      }
      uint64_t v15 = v45;
    }
  }
  else
  {
    uint64_t v15 = 4294954775;
    CFMutableArrayRef Mutable = v50;
  }
LABEL_7:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v63) {
    CFRelease(v63);
  }
  if (v60) {
    CFRelease(v60);
  }
  return v15;
}

uint64_t composite_trackReader_GetTrackInfo(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2) {
    *a2 = *(_DWORD *)(DerivedStorage + 8);
  }
  if (a3) {
    *a3 = *(_DWORD *)(DerivedStorage + 12);
  }
  return 0;
}

uint64_t composite_trackReader_CopySampleCursorService(uint64_t a1, CFTypeRef *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *a2 = CFRetain(*(CFTypeRef *)(DerivedStorage + 32));
  return 0;
}

void compositeSuper_editCursorService_Finalize()
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();

  compositionTable_releaseAndClear(DerivedStorage);
}

__CFString *compositeSuper_editCursorService_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  CFDictionaryRef v3 = DerivedStorage;
  uint64_t v4 = *(void *)DerivedStorage;
  uint64_t v5 = *(void *)(*(void *)DerivedStorage + 16);
  if (v5 < 1)
  {
LABEL_5:
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = *(void *)(v4 + 32);
    while (*(_DWORD *)(v6 + 4) != DerivedStorage[2])
    {
      v6 += 168;
      if (!--v5) {
        goto LABEL_5;
      }
    }
  }
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<CompositeSuper FigEditCursorService %p>", a1);
  if (v6)
  {
    CFTypeRef v8 = compositionTableTrack_CopyDebugDescription(v6);
    CFStringAppend(Mutable, v8);
    if (v8) {
      CFRelease(v8);
    }
  }
  else
  {
    uint64_t v9 = v3[2];
    unsigned int v11 = bswap32(v3[3]);
    CFStringAppendFormat(Mutable, 0, @"{ trackID %d, mediaType %.4s, table %p, ", v9, &v11, v4);
    CFStringAppend(Mutable, @"trackID not found in table");
    CFStringAppendFormat(Mutable, 0, @" }");
  }
  return Mutable;
}

uint64_t compositeSuper_editCursorService_CreateCursorAtTrackTime(const void *a1, CMTime *a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = *(void *)DerivedStorage;
  uint64_t v22 = 0;
  MEMORY[0x19970E910](*(void *)(v7 + 8));
  uint64_t v8 = *(void *)(v7 + 16);
  if (v8 < 1)
  {
LABEL_5:
    uint64_t v11 = FigSignalErrorAt();
    int v12 = *(_DWORD *)(v7 + 4);
    MEMORY[0x19970E930](*(void *)(v7 + 8));
    if (v11) {
      return v11;
    }
    uint64_t v13 = 0;
  }
  else
  {
    int v9 = *(_DWORD *)(DerivedStorage + 8);
    uint64_t v10 = (uint64_t *)(*(void *)(v7 + 32) + 8);
    while (*((_DWORD *)v10 - 1) != v9)
    {
      v10 += 21;
      if (!--v8) {
        goto LABEL_5;
      }
    }
    if (*v10 < 1)
    {
      MEMORY[0x19970E930](*(void *)(v7 + 8));
      return 4294954775;
    }
    uint64_t v14 = 0;
    uint64_t v15 = 156;
    do
    {
      uint64_t v13 = v14++;
      if (v14 >= *v10) {
        break;
      }
      uint64_t v16 = v10[1] + v15;
      long long v17 = *(_OWORD *)v16;
      time1.CMTimeEpoch epoch = *(void *)(v16 + 16);
      *(_OWORD *)&time1.CMTimeValue value = v17;
      CMTime v20 = *a2;
      v15 += 108;
    }
    while (CMTimeCompare(&time1, &v20) < 1);
    int v12 = *(_DWORD *)(v7 + 4);
    MEMORY[0x19970E930](*(void *)(v7 + 8));
  }
  CFGetAllocator(a1);
  FigEditCursorGetClassID();
  uint64_t v11 = CMDerivedObjectCreate();
  if (!v11)
  {
    uint64_t v18 = CMBaseObjectGetDerivedStorage();
    *(void *)uint64_t v18 = a1;
    CFRetain(a1);
    *(void *)(v18 + 8) = v13;
    *(_DWORD *)(v18 + 16) = v12;
    *a3 = v22;
  }
  return v11;
}

void compositeSuper_editCursor_Finalize()
{
  uint64_t DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage)
  {
    CFRelease(*DerivedStorage);
    CFTypeRef *DerivedStorage = 0;
  }
}

__CFString *compositeSuper_editCursor_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<CompositeSuper FigEditCursor %p>{ service %p, editIndex %d }", a1, *DerivedStorage, DerivedStorage[1]);
  return Mutable;
}

uint64_t compositeSuper_editCursor_Copy(const void *a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFGetAllocator(a1);
  FigEditCursorGetClassID();
  uint64_t v5 = CMDerivedObjectCreate();
  if (!v5)
  {
    uint64_t v6 = CMBaseObjectGetDerivedStorage();
    uint64_t v7 = *(const void **)DerivedStorage;
    *(void *)uint64_t v6 = *(void *)DerivedStorage;
    CFRetain(v7);
    *(void *)(v6 + 8) = *(void *)(DerivedStorage + 8);
    *(_DWORD *)(v6 + 16) = *(_DWORD *)(DerivedStorage + 16);
    *a2 = 0;
  }
  return v5;
}

uint64_t compositeSuper_editCursor_Step(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = (_DWORD *)CMBaseObjectGetDerivedStorage();
  uint64_t v5 = *(void **)v4;
  MEMORY[0x19970E910](*(void *)(*(void *)v4 + 8));
  uint64_t v6 = v5[2];
  if (v6 < 1)
  {
LABEL_5:
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v7 = (void *)(v5[4] + 8);
    while (*((_DWORD *)v7 - 1) != v4[2])
    {
      v7 += 21;
      if (!--v6) {
        goto LABEL_5;
      }
    }
    uint64_t v8 = *v7;
  }
  MEMORY[0x19970E930](v5[1]);
  if (v8)
  {
    uint64_t v9 = *(void *)(DerivedStorage + 8) + a2;
    uint64_t result = 4294954776;
    if (v9 < 0)
    {
      uint64_t v9 = 0;
    }
    else
    {
      if (v9 >= v8) {
        uint64_t result = 4294954776;
      }
      else {
        uint64_t result = 0;
      }
      if (v9 >= v8) {
        uint64_t v9 = v8 - 1;
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t result = 4294954775;
  }
  *(void *)(DerivedStorage + 8) = v9;
  return result;
}

uint64_t compositeSuper_editCursor_GetEditSegment(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = (_DWORD *)CMBaseObjectGetDerivedStorage();
  uint64_t v5 = *(void *)v4;
  MEMORY[0x19970E910](*(void *)(*(void *)v4 + 8));
  if (*(_DWORD *)(v5 + 4) != *(_DWORD *)(DerivedStorage + 16)) {
    goto LABEL_6;
  }
  uint64_t v6 = *(void *)(v5 + 16);
  if (v6 < 1) {
    goto LABEL_6;
  }
  uint64_t v7 = (void *)(*(void *)(v5 + 32) + 8);
  while (*((_DWORD *)v7 - 1) != v4[2])
  {
    v7 += 21;
    if (!--v6) {
      goto LABEL_6;
    }
  }
  uint64_t v10 = *(void *)(DerivedStorage + 8);
  if (v10 < 0 || v10 >= *v7)
  {
LABEL_6:
    uint64_t v8 = (const void *)FigSignalErrorAt();
    MEMORY[0x19970E930](*(void *)(v5 + 8));
    if (!v8)
    {
      if ((*(_DWORD *)(a2 + 12) & 0x1D) == 1) {
        return 4294954511;
      }
      else {
        return 0;
      }
    }
  }
  else
  {
    uint64_t v11 = v7[1] + 108 * v10;
    long long v12 = *(_OWORD *)(v11 + 16);
    *(_OWORD *)a2 = *(_OWORD *)v11;
    *(_OWORD *)(a2 + 16) = v12;
    long long v13 = *(_OWORD *)(v11 + 32);
    long long v14 = *(_OWORD *)(v11 + 48);
    long long v15 = *(_OWORD *)(v11 + 80);
    *(_OWORD *)(a2 + 64) = *(_OWORD *)(v11 + 64);
    *(_OWORD *)(a2 + 80) = v15;
    *(_OWORD *)(a2 + 32) = v13;
    *(_OWORD *)(a2 + 48) = v14;
    uint64_t v8 = *(const void **)(v11 + 96);
    int v16 = *(_DWORD *)(v11 + 104);
    if (v8) {
      CFRetain(*(CFTypeRef *)(v11 + 96));
    }
    MEMORY[0x19970E930](*(void *)(v5 + 8));
    if ((*(_DWORD *)(a2 + 12) & 0x1D) == 1)
    {
      if (!v8) {
        return 4294954511;
      }
      int v17 = v4[3];
      MEMORY[0x19970E910](*(void *)(v5 + 120));
      uint64_t v18 = *(void *)(v5 + 144);
      if (v18 < 2)
      {
        uint64_t v20 = 1;
      }
      else
      {
        uint64_t v19 = 0;
        uint64_t v20 = 1;
        while (1)
        {
          int v21 = *(const void **)(*(void *)(v5 + 136) + v19 + 16);
          if (v21)
          {
            if (CFEqual(v21, v8))
            {
              uint64_t v22 = *(void *)(v5 + 136) + v19;
              if (*(_DWORD *)(v22 + 24) == v16 && *(_DWORD *)(v22 + 28) == v17) {
                break;
              }
            }
          }
          ++v20;
          uint64_t v18 = *(void *)(v5 + 144);
          v19 += 16;
          if (v20 >= v18) {
            goto LABEL_28;
          }
        }
        uint64_t v18 = *(void *)(v5 + 144);
      }
LABEL_28:
      if (v20 == v18)
      {
        *(void *)(v5 + 144) = v18 + 1;
        uint64_t v23 = *(void *)(v5 + 128);
        if (v18 >= v23)
        {
          uint64_t v24 = 2 * v23;
          int v25 = malloc_type_calloc(2 * v23, 0x10uLL, 0x1060040C2E02434uLL);
          memcpy(v25, *(const void **)(v5 + 136), 16 * *(void *)(v5 + 128));
          free(*(void **)(v5 + 136));
          *(void *)(v5 + 128) = v24;
          *(void *)(v5 + 136) = v25;
        }
        CFTypeRef v26 = CFRetain(v8);
        uint64_t v27 = *(void *)(v5 + 136) + 16 * v18;
        *(void *)uint64_t v27 = v26;
        *(_DWORD *)(v27 + 8) = v16;
        *(_DWORD *)(v27 + 12) = v17;
      }
      MEMORY[0x19970E930](*(void *)(v5 + 120));
      *(void *)(a2 + 16) = v20;
    }
    if (v8)
    {
      CFRelease(v8);
      return 0;
    }
  }
  return (uint64_t)v8;
}

void compositeProxy_editCursorService_Finalize()
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();

  compositionTable_releaseAndClear(DerivedStorage);
}

__CFString *compositeProxy_editCursorService_CopyDebugDescription(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<CompositeProxy FigEditCursorService %p>", a1);
  return Mutable;
}

uint64_t compositeProxy_editCursorService_CreateCursorAtTrackTime(const void *a1, long long *a2, void *a3)
{
  uint64_t DerivedStorage = (unsigned int *)CMBaseObjectGetDerivedStorage();
  CFTypeRef v56 = 0;
  CFTypeRef v57 = 0;
  CFTypeRef v54 = 0;
  CFTypeRef v55 = 0;
  CFTypeRef v53 = 0;
  long long v7 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  long long v51 = *MEMORY[0x1E4F1FA20];
  *(_OWORD *)long long v52 = v7;
  *(_OWORD *)&v52[16] = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  CFTypeRef cf = 0;
  *a3 = 0;
  uint64_t v8 = *((void *)a2 + 2);
  *((void *)a2 + 2) = 0;
  uint64_t v9 = *(void *)DerivedStorage;
  int v10 = *(_DWORD *)(*(void *)DerivedStorage + 4);
  uint64_t v11 = DerivedStorage[2];
  CFAllocatorRef v12 = CFGetAllocator(a1);
  uint64_t v13 = compositionTable_copyConcreteTrackReaderForEpoch(v9, v8, v11, v12, &v57);
  if (v13 == -12843)
  {
    CFTypeRef v14 = 0;
    uint64_t v15 = 4294954775;
    goto LABEL_45;
  }
  uint64_t v15 = v13;
  if (v13) {
    goto LABEL_44;
  }
  uint64_t v16 = (uint64_t)v57;
  CFAllocatorRef v17 = CFGetAllocator(a1);
  uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(v16);
  uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  int v21 = *(uint64_t (**)(uint64_t, __CFString *, CFAllocatorRef, CFTypeRef *))(v20 + 48);
  if (!v21) {
    goto LABEL_22;
  }
  uint64_t v22 = v21(FigBaseObject, @"EditCursorService", v17, &v56);
  if (v22 != -12784)
  {
    uint64_t v15 = v22;
    if (v22)
    {
LABEL_44:
      CFTypeRef v14 = 0;
      goto LABEL_45;
    }
    CFTypeRef v23 = v56;
    long long v48 = *a2;
    uint64_t v49 = *((void *)a2 + 2);
    uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v24) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = 0;
    }
    CFDictionaryRef v29 = *(uint64_t (**)(CFTypeRef, CFTypeRef *, CFTypeRef *))(v25 + 8);
    if (v29)
    {
      *(_OWORD *)uint64_t v45 = v48;
      *(void *)&long long v46 = v49;
      uint64_t v26 = v29(v23, v45, &v55);
      if (!v26)
      {
        CFGetAllocator(a1);
        FigEditCursorGetClassID();
        uint64_t v26 = CMDerivedObjectCreate();
        if (!v26)
        {
          CFTypeRef v30 = (void *)CMBaseObjectGetDerivedStorage();
          void *v30 = *(void *)DerivedStorage;
          FigAtomicIncrement32();
          CFTypeRef v31 = v55;
          CFTypeRef v55 = 0;
          v30[1] = v31;
          v30[2] = v8;
          CFTypeRef v28 = v30 + 3;
          goto LABEL_19;
        }
      }
      goto LABEL_43;
    }
LABEL_22:
    CFTypeRef v14 = 0;
    uint64_t v15 = 4294954514;
    goto LABEL_45;
  }
  CFGetAllocator(a1);
  FigEditCursorGetClassID();
  uint64_t v26 = CMDerivedObjectCreate();
  if (v26)
  {
LABEL_43:
    uint64_t v15 = v26;
    goto LABEL_44;
  }
  uint64_t v27 = (void *)CMBaseObjectGetDerivedStorage();
  *uint64_t v27 = *(void *)DerivedStorage;
  FigAtomicIncrement32();
  v27[1] = v8;
  CFTypeRef v28 = v27 + 2;
LABEL_19:
  *CFTypeRef v28 = v10;
  if (DerivedStorage[2] != 1936684398) {
    goto LABEL_39;
  }
  uint64_t v32 = FigTrackReaderGetFigBaseObject(v16);
  uint64_t v33 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v33) {
    uint64_t v34 = v33;
  }
  else {
    uint64_t v34 = 0;
  }
  CFIndex v35 = *(void (**)(uint64_t, __CFString *, void, CFTypeRef *))(v34 + 48);
  if (v35) {
    v35(v32, @"EditsExcludePrimingAndRemainderDuration", *MEMORY[0x1E4F1CF80], &v53);
  }
  if (v53 == (CFTypeRef)*MEMORY[0x1E4F1CFD0])
  {
LABEL_39:
    CFTypeRef v14 = 0;
    goto LABEL_40;
  }
  uint64_t v36 = *(void *)DerivedStorage;
  CFAllocatorRef v37 = CFGetAllocator(a1);
  v45[0] = 0;
  if (v8 < 1 || *(void *)(v36 + 144) <= v8)
  {
    uint64_t TrackGaplessSourceTimeRange = FigSignalErrorAt();
    CFTypeRef v14 = 0;
    if (TrackGaplessSourceTimeRange) {
      goto LABEL_61;
    }
    goto LABEL_30;
  }
  uint64_t v38 = compositionTable_copyFormatReaderForAssetURL(v36, *(const void **)(*(void *)(v36 + 136) + 16 * v8), v37, v45);
  CFTypeRef v14 = v45[0];
  if (v38)
  {
    uint64_t v15 = v38;
    if (v45[0]) {
      CFRelease(v45[0]);
    }
    goto LABEL_44;
  }
LABEL_30:
  uint64_t TrackGaplessSourceTimeRange = FigGaplessInfoGetTrackGaplessSourceTimeRange((uint64_t)v14, v16, &v51);
  if (!TrackGaplessSourceTimeRange)
  {
    if ((BYTE12(v51) & 0x1D) == 1 || (v52[20] & 0x1D) == 1)
    {
      if ((BYTE12(v51) & 1) == 0)
      {
        long long v51 = *MEMORY[0x1E4F1FA48];
        *(void *)long long v52 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
      }
      if ((v52[20] & 1) == 0)
      {
        *(_OWORD *)&v52[8] = *MEMORY[0x1E4F1FA10];
        *(void *)&v52[24] = *(void *)(MEMORY[0x1E4F1FA10] + 16);
      }
      *((void *)a2 + 2) = v8;
      CFTypeRef v40 = v54;
      CFAllocatorRef v41 = CFGetAllocator(a1);
      *(_OWORD *)uint64_t v45 = v51;
      long long v46 = *(_OWORD *)v52;
      long long v42 = *a2;
      long long v47 = *(_OWORD *)&v52[16];
      long long v48 = v42;
      uint64_t v49 = *((void *)a2 + 2);
      uint64_t TrackGaplessSourceTimeRange = FigGaplessAudioEditCursorCreate(v40, (uint64_t)v45, (uint64_t)&v48, v41, &cf);
      if (!TrackGaplessSourceTimeRange)
      {
        CFTypeRef v43 = cf;
LABEL_42:
        uint64_t v15 = 0;
        *a3 = v43;
        CFTypeRef cf = 0;
        goto LABEL_45;
      }
      goto LABEL_61;
    }
LABEL_40:
    CFTypeRef v43 = v54;
    if (v54) {
      CFTypeRef v43 = CFRetain(v54);
    }
    goto LABEL_42;
  }
LABEL_61:
  uint64_t v15 = TrackGaplessSourceTimeRange;
LABEL_45:
  if (v57) {
    CFRelease(v57);
  }
  if (v56) {
    CFRelease(v56);
  }
  if (v55) {
    CFRelease(v55);
  }
  if (v54) {
    CFRelease(v54);
  }
  if (v53) {
    CFRelease(v53);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v15;
}

uint64_t compositionTable_copyConcreteTrackReaderForEpoch(uint64_t a1, uint64_t a2, uint64_t a3, const __CFAllocator *a4, void *a5)
{
  MEMORY[0x19970E910](*(void *)(a1 + 120));
  int v10 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 152), (const void *)a2);
  CMTimeValue value = v10;
  if (v10)
  {
    uint64_t v11 = v10;
    CFRetain(v10);
    MEMORY[0x19970E930](*(void *)(a1 + 120));
    uint64_t v12 = 0;
    *a5 = v11;
    return v12;
  }
  if (a2 < 1 || *(void *)(a1 + 144) <= a2)
  {
    MEMORY[0x19970E930](*(void *)(a1 + 120));
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 136);
    uint64_t v15 = *(const void **)(v14 + 16 * a2);
    if (v15)
    {
      CFRetain(*(CFTypeRef *)(v14 + 16 * a2));
      uint64_t v14 = *(void *)(a1 + 136);
    }
    uint64_t v16 = *(unsigned int *)(v14 + 16 * a2 + 8);
    MEMORY[0x19970E930](*(void *)(a1 + 120));
    if (v15)
    {
      uint64_t v17 = compositionTable_copyConcreteTrackReaderForAssetURLTrackIDMediaType(a1, v15, v16, a3, a4, (CFTypeRef *)&value);
      if (!v17)
      {
        MEMORY[0x19970E910](*(void *)(a1 + 120));
        uint64_t v18 = value;
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 152), (const void *)a2, value);
        MEMORY[0x19970E930](*(void *)(a1 + 120));
        if (v18)
        {
          uint64_t v12 = 0;
          *a5 = v18;
LABEL_12:
          CFRelease(v15);
          return v12;
        }
        uint64_t v17 = FigSignalErrorAt();
      }
      uint64_t v12 = v17;
      goto LABEL_12;
    }
  }

  return FigSignalErrorAt();
}

void compositeProxy_editCursor_Finalize()
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  compositionTable_releaseAndClear(DerivedStorage);
  uint64_t v1 = (const void *)DerivedStorage[1];
  if (v1)
  {
    CFRelease(v1);
    DerivedStorage[1] = 0;
  }
}

__CFString *compositeProxy_editCursor_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<CompositeProxy FigEditCursor %p>{ concreteEditCursor %p, epoch %d }", a1, *(void *)(DerivedStorage + 8), *(void *)(DerivedStorage + 16));
  return Mutable;
}

uint64_t compositeProxy_editCursor_Copy(const void *a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  uint64_t v5 = *(void *)(DerivedStorage + 8);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, CFTypeRef *))(v7 + 8);
  if (v8)
  {
    uint64_t v9 = v8(v5, &cf);
    if (v9)
    {
      uint64_t v10 = v9;
    }
    else
    {
      CFGetAllocator(a1);
      FigEditCursorGetClassID();
      uint64_t v10 = CMDerivedObjectCreate();
      if (!v10)
      {
        uint64_t v11 = CMBaseObjectGetDerivedStorage();
        *(void *)uint64_t v11 = *(void *)DerivedStorage;
        FigAtomicIncrement32();
        *(void *)(v11 + 8) = cf;
        CFTypeRef cf = 0;
        *(void *)(v11 + 16) = *(void *)(DerivedStorage + 16);
        *(_DWORD *)(v11 + 24) = *(_DWORD *)(DerivedStorage + 24);
        *a2 = 0;
      }
    }
  }
  else
  {
    uint64_t v10 = 4294954514;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t compositeProxy_editCursor_Step(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 8);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 16);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t compositeProxy_editCursor_GetEditSegment(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(void *)(DerivedStorage + 8);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 24);
  if (!v7) {
    return 4294954514;
  }
  uint64_t result = v7(v4, a2);
  if (!result)
  {
    uint64_t v9 = *(void *)(DerivedStorage + 16);
    *(void *)(a2 + 64) = v9;
    *(void *)(a2 + 16) = v9;
  }
  return result;
}

void compositeSimple_editCursor_Finalize()
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();

  compositionTable_releaseAndClear(DerivedStorage);
}

__CFString *compositeSimple_editCursor_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<CompositeSimple FigEditCursor %p>{ epoch %d }", a1, *(void *)(DerivedStorage + 8));
  return Mutable;
}

uint64_t compositeSimple_editCursor_Copy(const void *a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFGetAllocator(a1);
  FigEditCursorGetClassID();
  uint64_t v5 = CMDerivedObjectCreate();
  if (!v5)
  {
    uint64_t v6 = CMBaseObjectGetDerivedStorage();
    *(void *)uint64_t v6 = *(void *)DerivedStorage;
    FigAtomicIncrement32();
    *(void *)(v6 + 8) = *(void *)(DerivedStorage + 8);
    *(_DWORD *)(v6 + 16) = *(_DWORD *)(DerivedStorage + 16);
    *a2 = 0;
  }
  return v5;
}

uint64_t compositeSimple_editCursor_Step()
{
  return 4294954776;
}

uint64_t compositeSimple_editCursor_GetEditSegment(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = MEMORY[0x1E4F1FA48];
  long long v5 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)(a2 + 48) = *MEMORY[0x1E4F1FA48];
  uint64_t v6 = *(void *)(v4 + 16);
  *(void *)(a2 + 64) = v6;
  uint64_t v7 = MEMORY[0x1E4F1FA10];
  long long v8 = *MEMORY[0x1E4F1FA10];
  *(_OWORD *)(a2 + 72) = *MEMORY[0x1E4F1FA10];
  uint64_t v9 = *(void *)(v7 + 16);
  *(void *)(a2 + 88) = v9;
  *(_OWORD *)a2 = v5;
  *(void *)(a2 + 16) = v6;
  *(void *)(a2 + 40) = v9;
  *(_OWORD *)(a2 + 24) = v8;
  uint64_t v10 = *(void *)(DerivedStorage + 8);
  *(void *)(a2 + 64) = v10;
  *(void *)(a2 + 16) = v10;
  return 0;
}

void compositeProxy_sampleCursorService_Finalize()
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();

  compositionTable_releaseAndClear(DerivedStorage);
}

CFTypeRef compositeProxy_sampleCursorService_CopyDebugDescription()
{
  return CFRetain(@"[CompositeProxy FigSampleCursorService]");
}

uint64_t compositeProxy_sampleCursorService_CreateCursorAtPresentationTimeStamp(const void *a1, long long *a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  CFTypeRef v37 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v36 = 0;
  *a3 = 0;
  uint64_t v11 = *((void *)a2 + 2);
  *((void *)a2 + 2) = 0;
  uint64_t v12 = *(void *)DerivedStorage;
  int v13 = *(_DWORD *)(*(void *)DerivedStorage + 4);
  uint64_t v14 = DerivedStorage[3];
  CFAllocatorRef v15 = CFGetAllocator(a1);
  uint64_t v16 = compositionTable_copyConcreteTrackReaderForEpoch(v12, v11, v14, v15, &cf);
  if (v16 == -12843)
  {
    uint64_t ProxySampleCursor = 4294954454;
    goto LABEL_22;
  }
  uint64_t ProxySampleCursor = v16;
  if (!v16)
  {
    CFTypeRef v18 = cf;
    uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v19) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = 0;
    }
    int v21 = *(unsigned int (**)(CFTypeRef, CFTypeRef *))(v20 + 32);
    if (!v21 || v21(v18, &v37))
    {
      CFAllocatorRef v22 = CFGetAllocator(a1);
      uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(v18);
      uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v24) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = 0;
      }
      uint64_t v26 = *(uint64_t (**)(uint64_t, __CFString *, CFAllocatorRef, CFTypeRef *))(v25 + 48);
      if (!v26) {
        goto LABEL_21;
      }
      uint64_t v27 = v26(FigBaseObject, @"CaptionSampleCursorService", v22, &v37);
      if (v27) {
        goto LABEL_29;
      }
    }
    CFTypeRef v28 = v37;
    long long v34 = *a2;
    uint64_t v35 = *((void *)a2 + 2);
    uint64_t v29 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v29) {
      uint64_t v30 = v29;
    }
    else {
      uint64_t v30 = 0;
    }
    CFTypeRef v31 = *(uint64_t (**)(CFTypeRef, long long *, CFTypeRef *, uint64_t, uint64_t))(v30 + 8);
    if (v31)
    {
      long long v39 = v34;
      uint64_t v40 = v35;
      uint64_t v27 = v31(v28, &v39, &v36, a4, a5);
      if (!v27)
      {
        CFGetAllocator(a1);
        uint64_t ProxySampleCursor = compositeProxy_createProxySampleCursor();
        if (!ProxySampleCursor)
        {
          uint64_t v32 = CMBaseObjectGetDerivedStorage();
          *(void *)uint64_t v32 = *(void *)DerivedStorage;
          FigAtomicIncrement32();
          *(void *)(v32 + 16) = v36;
          *(_DWORD *)(v32 + 8) = DerivedStorage[2];
          *(void *)(v32 + 24) = v11;
          *(_DWORD *)(v32 + 32) = v13;
          *a3 = 0;
          CFTypeRef v36 = 0;
        }
        goto LABEL_22;
      }
LABEL_29:
      uint64_t ProxySampleCursor = v27;
      goto LABEL_22;
    }
LABEL_21:
    uint64_t ProxySampleCursor = 4294954514;
  }
LABEL_22:
  if (cf) {
    CFRelease(cf);
  }
  if (v37) {
    CFRelease(v37);
  }
  if (v36) {
    CFRelease(v36);
  }
  return ProxySampleCursor;
}

uint64_t compositeProxy_sampleCursorService_CreateCursorNearPresentationTimeStamp(const void *a1, long long *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  CFTypeRef v34 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v33 = 0;
  *a4 = 0;
  uint64_t v13 = *((void *)a2 + 2);
  *((void *)a2 + 2) = 0;
  uint64_t v14 = *(void *)DerivedStorage;
  int v30 = *(_DWORD *)(*(void *)DerivedStorage + 4);
  uint64_t v15 = DerivedStorage[3];
  CFAllocatorRef v16 = CFGetAllocator(a1);
  uint64_t v17 = compositionTable_copyConcreteTrackReaderForEpoch(v14, v13, v15, v16, &cf);
  if (v17 == -12843)
  {
    uint64_t ProxySampleCursor = 4294954454;
    goto LABEL_17;
  }
  uint64_t ProxySampleCursor = v17;
  if (!v17)
  {
    CFTypeRef v19 = cf;
    uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v20) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = 0;
    }
    CFAllocatorRef v22 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(v21 + 32);
    if (v22)
    {
      uint64_t v23 = v22(v19, &v34);
      if (v23) {
        goto LABEL_24;
      }
      CFTypeRef v24 = v34;
      long long v31 = *a2;
      uint64_t v32 = *((void *)a2 + 2);
      uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v25) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = 0;
      }
      uint64_t v27 = *(uint64_t (**)(CFTypeRef, long long *, uint64_t, CFTypeRef *, uint64_t, uint64_t))(v26 + 16);
      if (v27)
      {
        long long v36 = v31;
        uint64_t v37 = v32;
        uint64_t v23 = v27(v24, &v36, a3, &v33, a5, a6);
        if (!v23)
        {
          CFGetAllocator(a1);
          uint64_t ProxySampleCursor = compositeProxy_createProxySampleCursor();
          if (!ProxySampleCursor)
          {
            uint64_t v28 = CMBaseObjectGetDerivedStorage();
            *(void *)uint64_t v28 = *(void *)DerivedStorage;
            FigAtomicIncrement32();
            *(void *)(v28 + 16) = v33;
            *(_DWORD *)(v28 + 8) = DerivedStorage[2];
            *(void *)(v28 + 24) = v13;
            *(_DWORD *)(v28 + 32) = v30;
            *a4 = 0;
            CFTypeRef v33 = 0;
          }
          goto LABEL_17;
        }
LABEL_24:
        uint64_t ProxySampleCursor = v23;
        goto LABEL_17;
      }
    }
    uint64_t ProxySampleCursor = 4294954514;
  }
LABEL_17:
  if (cf) {
    CFRelease(cf);
  }
  if (v34) {
    CFRelease(v34);
  }
  if (v33) {
    CFRelease(v33);
  }
  return ProxySampleCursor;
}

uint64_t compositeProxy_createProxySampleCursor()
{
  uint64_t v0 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v0) {
    uint64_t v1 = v0;
  }
  else {
    uint64_t v1 = 0;
  }
  unsigned int v2 = *(void *)(v1 + 72) != 0;
  uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (*(void *)(v4 + 64)) {
    v2 |= 2u;
  }
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  if (*(void *)(v6 + 80)) {
    v2 |= 4u;
  }
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  if (*(void *)(v8 + 144)) {
    v2 |= 8u;
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  if (*(void *)(v10 + 152)) {
    v2 |= 0x10u;
  }
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  if (*(void *)(v12 + 112)) {
    v2 |= 0x20u;
  }
  v14[1] = 0;
  v14[0] = v2;
  if (sCompositeProxySampleCursorVTableSetupOnce != -1) {
    dispatch_once_f(&sCompositeProxySampleCursorVTableSetupOnce, 0, (dispatch_function_t)compositeProxySampleCursorSetupOnce);
  }
  dispatch_sync_f((dispatch_queue_t)sCompositeProxySampleCursorVTableQueue, v14, (dispatch_function_t)compositeProxy_SampleCursor_getVTableWithOptionalMethodsWork);
  FigSampleCursorGetClassID();
  return CMDerivedObjectCreate();
}

CFMutableDictionaryRef compositeProxySampleCursorSetupOnce()
{
  sCompositeProxySampleCursorVTableQueue = (uint64_t)dispatch_queue_create("com.apple.coremedia.compositeproxysamplecursor.vtables", 0);
  CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
  sCompositeProxySampleCursorVTableDictionary = (uint64_t)result;
  return result;
}

void compositeProxy_SampleCursor_getVTableWithOptionalMethodsWork(int *a1)
{
  unsigned int v2 = (const void *)*a1;
  CFTypeRef Value = CFDictionaryGetValue((CFDictionaryRef)sCompositeProxySampleCursorVTableDictionary, v2);
  if (Value) {
    goto LABEL_19;
  }
  CFTypeRef Value = malloc_type_malloc(0x18uLL, 0x6004045F868BCuLL);
  uint64_t v4 = malloc_type_malloc(0xF0uLL, 0x10C004098B2CDEBuLL);
  __copy_assignment_4_8_t0w8_pa0_51792_8_t16w16_pa0_52214_32_pa0_24028_40_pa0_18179_48_pa0_57859_56_pa0_13550_64_pa0_54719_72_pa0_1935_80_t88w24_pa0_12_112_pa0_25791_120_pa0_51134_128_t136w8_pa0_25053_144_pa0_46486_152_pa0_25009_160_pa0_20936_168_pa0_50495_176_pa0_49003_184_pa0_11258_192_pa0_17621_200_pa0_49302_208_pa0_26204_216_pa0_58389_224_pa0_36478_232((uint64_t)v4, (uint64_t)&kCompositeProxy_SampleCursor_FigSampleCursorClass);
  if ((v2 & 2) != 0)
  {
    if (v2) {
      goto LABEL_4;
    }
  }
  else
  {
    v4[8] = 0;
    if (v2)
    {
LABEL_4:
      if ((v2 & 4) != 0) {
        goto LABEL_5;
      }
      goto LABEL_13;
    }
  }
  v4[9] = 0;
  if ((v2 & 4) != 0)
  {
LABEL_5:
    if ((v2 & 8) != 0) {
      goto LABEL_6;
    }
    goto LABEL_14;
  }
LABEL_13:
  v4[10] = 0;
  if ((v2 & 8) != 0)
  {
LABEL_6:
    if ((v2 & 0x10) != 0) {
      goto LABEL_7;
    }
LABEL_15:
    v4[19] = 0;
    if ((v2 & 0x20) != 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
LABEL_14:
  v4[18] = 0;
  if ((v2 & 0x10) == 0) {
    goto LABEL_15;
  }
LABEL_7:
  if ((v2 & 0x20) == 0) {
LABEL_8:
  }
    v4[14] = 0;
LABEL_9:
  void *Value = 0;
  Value[1] = &kCompositeProxy_SampleCursor_BaseClass;
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  Value[2] = v5;
  CFDictionarySetValue((CFMutableDictionaryRef)sCompositeProxySampleCursorVTableDictionary, v2, Value);
LABEL_19:
  *((void *)a1 + 1) = Value;
}

uint64_t compositeProxy_sampleCursor_Copy(const void *a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef v14 = 0;
  uint64_t v5 = *(void *)(DerivedStorage + 16);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, CFTypeRef *))(v7 + 8);
  if (!v8) {
    return 4294954514;
  }
  uint64_t v9 = v8(v5, &v14);
  CFTypeRef v10 = v14;
  if (v9)
  {
    uint64_t ProxySampleCursor = v9;
    if (!v14) {
      return ProxySampleCursor;
    }
    goto LABEL_11;
  }
  CFGetAllocator(a1);
  uint64_t ProxySampleCursor = compositeProxy_createProxySampleCursor();
  if (ProxySampleCursor)
  {
    CFTypeRef v10 = v14;
    if (!v14) {
      return ProxySampleCursor;
    }
LABEL_11:
    CFRelease(v10);
    return ProxySampleCursor;
  }
  uint64_t v12 = CMBaseObjectGetDerivedStorage();
  *(void *)uint64_t v12 = *(void *)DerivedStorage;
  FigAtomicIncrement32();
  *(void *)(v12 + 16) = v14;
  *(_DWORD *)(v12 + 8) = *(_DWORD *)(DerivedStorage + 8);
  *(void *)(v12 + 24) = *(void *)(DerivedStorage + 24);
  *(_DWORD *)(v12 + 32) = *(_DWORD *)(DerivedStorage + 32);
  *a2 = 0;
  return ProxySampleCursor;
}

uint64_t compositeProxy_sampleCursor_CompareInDecodeOrder()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = CMBaseObjectGetDerivedStorage();
  uint64_t v2 = *(void *)(DerivedStorage + 24);
  uint64_t v3 = *(void *)(v1 + 24);
  if (v2 < v3) {
    return -1;
  }
  if (v2 > v3) {
    return 1;
  }
  uint64_t v5 = *(void *)(DerivedStorage + 16);
  uint64_t v6 = *(void *)(v1 + 16);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (!v7)
  {
    uint64_t v8 = 0;
    if (v6) {
      goto LABEL_7;
    }
LABEL_9:
    uint64_t v9 = 0;
    goto LABEL_10;
  }
  uint64_t v8 = v7;
  if (!v6) {
    goto LABEL_9;
  }
LABEL_7:
  uint64_t v11 = v8;
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  uint64_t v8 = v11;
LABEL_10:
  if (v8 != v9) {
    return 0;
  }
  CFTypeRef v10 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 32);
  if (!v10) {
    return 0;
  }

  return v10(v5, v6);
}

uint64_t compositeProxy_sampleCursor_GetPresentationTimeStamp(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(void *)(DerivedStorage + 16);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 40);
  if (!v7) {
    return 4294954514;
  }
  uint64_t result = v7(v4, a2);
  if (!result) {
    *(void *)(a2 + 16) = *(void *)(DerivedStorage + 24);
  }
  return result;
}

uint64_t compositeProxy_sampleCursor_GetDecodeTimeStamp(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(void *)(DerivedStorage + 16);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 48);
  if (!v7) {
    return 4294954514;
  }
  uint64_t result = v7(v4, a2);
  if (!result) {
    *(void *)(a2 + 16) = *(void *)(DerivedStorage + 24);
  }
  return result;
}

uint64_t compositeProxy_sampleCursor_GetDuration(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 56);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t compositeProxy_sampleCursor_GetDependencyInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 64);
  if (!v12) {
    return 4294954514;
  }

  return v12(v9, a2, a3, a4, a5);
}

uint64_t compositeProxy_sampleCursor_GetMPEG2FrameType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 72);
  if (!v10) {
    return 4294954514;
  }

  return v10(v7, a2, a3, a4);
}

uint64_t compositeProxy_sampleCursor_TestReorderingBoundary(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = *(void *)(DerivedStorage + 24);
  uint64_t v7 = *(void *)(v5 + 24);
  if (v6 != v7)
  {
    if (a3 == 1) {
      return v6 > v7;
    }
    if (!a3) {
      return v6 < v7;
    }
  }
  uint64_t v9 = *(void *)(DerivedStorage + 16);
  uint64_t v10 = *(void *)(v5 + 16);
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (!v11)
  {
    uint64_t v12 = 0;
    if (v10) {
      goto LABEL_7;
    }
LABEL_9:
    uint64_t v13 = 0;
    goto LABEL_10;
  }
  uint64_t v12 = v11;
  if (!v10) {
    goto LABEL_9;
  }
LABEL_7:
  uint64_t v15 = v12;
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
  uint64_t v12 = v15;
LABEL_10:
  if (v12 != v13) {
    return 0;
  }
  CFTypeRef v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 80);
  if (!v14) {
    return 0;
  }

  return v14(v9, v10, a3);
}

uint64_t compositeProxy_sampleCursor_CreateSampleBuffer(uint64_t a1, uint64_t a2, void *a3)
{
  CMSampleBufferRef sampleBufferOut = 0;
  CMSampleBufferRef sbuf = 0;
  CMFormatDescriptionRef v30 = 0;
  CFTypeRef cf = 0;
  CMItemCount timingArrayEntriesNeededOut = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = DerivedStorage;
  if (a2)
  {
    uint64_t v7 = CMBaseObjectGetDerivedStorage();
    uint64_t v8 = *(void *)(v6 + 16);
    if (v7) {
      uint64_t v9 = *(void *)(v7 + 16);
    }
    else {
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v8 = *(void *)(DerivedStorage + 16);
  }
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, CMSampleBufferRef *))(v11 + 112);
  if (!v12)
  {
    CMFormatDescriptionRef v16 = 0;
    CFArrayRef v17 = 0;
    CFTypeRef v18 = 0;
    uint64_t v19 = 4294954514;
    goto LABEL_32;
  }
  uint64_t SampleTimingInfoArray = v12(v8, v9, &sbuf);
  if (SampleTimingInfoArray) {
    goto LABEL_28;
  }
  uint64_t SampleTimingInfoArray = CMSampleBufferGetSampleTimingInfoArray(sbuf, 0, 0, &timingArrayEntriesNeededOut);
  if (SampleTimingInfoArray) {
    goto LABEL_28;
  }
  if (timingArrayEntriesNeededOut)
  {
    if ((unint64_t)timingArrayEntriesNeededOut > 0x38E38E38E38E38ELL) {
      goto LABEL_27;
    }
    size_t v14 = 72 * timingArrayEntriesNeededOut;
    if (!(72 * timingArrayEntriesNeededOut)) {
      goto LABEL_27;
    }
    malloc_type_id_t v15 = 1556728742;
  }
  else
  {
    size_t v14 = 0;
    malloc_type_id_t v15 = 1270757447;
  }
  CFTypeRef v18 = (CMSampleTimingInfo *)malloc_type_malloc(v14, v15);
  if (!v18)
  {
LABEL_27:
    uint64_t SampleTimingInfoArray = FigSignalErrorAt();
LABEL_28:
    uint64_t v19 = SampleTimingInfoArray;
    CMFormatDescriptionRef v16 = 0;
    CFArrayRef v17 = 0;
    CFTypeRef v18 = 0;
    goto LABEL_32;
  }
  uint64_t v20 = CMSampleBufferGetSampleTimingInfoArray(sbuf, timingArrayEntriesNeededOut, v18, 0);
  if (v20) {
    goto LABEL_43;
  }
  CMItemCount v21 = timingArrayEntriesNeededOut;
  if (timingArrayEntriesNeededOut)
  {
    CMTimeEpoch v22 = *(void *)(v6 + 24);
    p_CMTimeEpoch epoch = &v18->presentationTimeStamp.epoch;
    do
    {
      *p_CMTimeEpoch epoch = v22;
      p_epoch[3] = v22;
      p_epoch += 9;
      --v21;
    }
    while (v21);
  }
  CFAllocatorRef v24 = CFGetAllocator(sbuf);
  uint64_t v20 = CMSampleBufferCreateCopyWithNewTiming(v24, sbuf, timingArrayEntriesNeededOut, v18, &sampleBufferOut);
  if (v20)
  {
LABEL_43:
    uint64_t v19 = v20;
    CMFormatDescriptionRef v16 = 0;
    CFArrayRef v17 = 0;
  }
  else
  {
    CFArrayRef v17 = (const __CFArray *)compositeProxy_sampleCursor_copyFormatDescriptionReplacementTable();
    CMFormatDescriptionRef FormatDescription = CMSampleBufferGetFormatDescription(sampleBufferOut);
    mutableComposition_copyReplacedFormatDescription(v17, FormatDescription, &v30);
    CMFormatDescriptionRef v16 = v30;
    if (v30 == FormatDescription)
    {
      uint64_t v27 = sampleBufferOut;
      if (sampleBufferOut) {
        CFRetain(sampleBufferOut);
      }
      goto LABEL_31;
    }
    CFGetAllocator(sbuf);
    CopyWithNewCMFormatDescriptionRef FormatDescription = FigSampleBufferCreateCopyWithNewFormatDescription();
    if (!CopyWithNewFormatDescription)
    {
      uint64_t v27 = (void *)cf;
LABEL_31:
      uint64_t v19 = 0;
      *a3 = v27;
      CFTypeRef cf = 0;
      goto LABEL_32;
    }
    uint64_t v19 = CopyWithNewFormatDescription;
  }
LABEL_32:
  if (sbuf) {
    CFRelease(sbuf);
  }
  if (sampleBufferOut) {
    CFRelease(sampleBufferOut);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
  free(v18);
  return v19;
}

uint64_t compositeProxy_sampleCursor_StepByDecodeTime(uint64_t a1, long long *a2)
{
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);
  long long v8 = *a2;
  uint64_t v9 = *((void *)a2 + 2);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, long long *))(v5 + 120);
  if (!v6) {
    return 4294954514;
  }
  long long v10 = v8;
  uint64_t v11 = v9;
  return v6(v3, &v10);
}

uint64_t compositeProxy_sampleCursor_StepByPresentationTime(uint64_t a1, long long *a2)
{
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);
  long long v8 = *a2;
  uint64_t v9 = *((void *)a2 + 2);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, long long *))(v5 + 128);
  if (!v6) {
    return 4294954514;
  }
  long long v10 = v8;
  uint64_t v11 = v9;
  return v6(v3, &v10);
}

uint64_t compositeProxy_sampleCursor_CopySampleLocation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 144);
  if (!v12) {
    return 4294954514;
  }

  return v12(v9, a2, a3, a4, a5);
}

uint64_t compositeProxy_sampleCursor_CopyChunkDetails(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v17 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);
  uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v18) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 152);
  if (!v20) {
    return 4294954514;
  }

  return v20(v17, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t compositeProxy_sampleCursor_CopyFormatDescription(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  CFTypeRef v12 = 0;
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, CFTypeRef *))(v5 + 160);
  if (v6)
  {
    uint64_t v7 = v6(v3, &v12);
    if (v7)
    {
      uint64_t v9 = v7;
    }
    else
    {
      CFArrayRef v8 = (const __CFArray *)compositeProxy_sampleCursor_copyFormatDescriptionReplacementTable();
      mutableComposition_copyReplacedFormatDescription(v8, v12, &cf);
      if (a2)
      {
        *a2 = cf;
        CFTypeRef cf = 0;
      }
      if (v8) {
        CFRelease(v8);
      }
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v9 = 4294954514;
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v9;
}

uint64_t compositeProxy_sampleCursor_StepInDecodeOrderAndReportStepsTaken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  CFArrayRef v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 168);
  if (!v8) {
    return 4294954514;
  }

  return v8(v5, a2, a3);
}

uint64_t compositeProxy_sampleCursor_StepInPresentationOrderAndReportStepsTaken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage() + 16);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  CFArrayRef v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 176);
  if (!v8) {
    return 4294954514;
  }

  return v8(v5, a2, a3);
}

CFTypeRef compositeProxy_sampleCursor_copyFormatDescriptionReplacementTable()
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(*(void *)DerivedStorage + 8));
  uint64_t v1 = *(void **)DerivedStorage;
  if (DerivedStorage[8] == *(_DWORD *)(*(void *)DerivedStorage + 4) && (uint64_t v2 = v1[2], v2 >= 1))
  {
    uint64_t v3 = (CFTypeRef *)(v1[4] + 112);
    while (*((_DWORD *)v3 - 27) != DerivedStorage[2])
    {
      v3 += 21;
      if (!--v2) {
        goto LABEL_6;
      }
    }
    CFTypeRef v4 = *v3;
    if (*v3)
    {
      CFRetain(*v3);
      uint64_t v1 = *(void **)DerivedStorage;
    }
  }
  else
  {
LABEL_6:
    CFTypeRef v4 = 0;
  }
  MEMORY[0x19970E930](v1[1]);
  return v4;
}

void compositeProxy_sampleCursor_Finalize()
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  compositionTable_releaseAndClear(DerivedStorage);
  uint64_t v1 = (const void *)DerivedStorage[2];
  if (v1)
  {
    CFRelease(v1);
    DerivedStorage[2] = 0;
  }
}

CFStringRef compositeProxy_sampleCursor_CopyDebugDescription()
{
  uint64_t v0 = *(const void **)(CMBaseObjectGetDerivedStorage() + 16);

  return CFCopyDescription(v0);
}

uint64_t compositeProxy_sampleCursor_CopyProperty(uint64_t a1, uint64_t a2, const __CFAllocator *a3, CFDictionaryRef *a4)
{
  CFDictionaryRef v21 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2 && a4)
  {
    uint64_t v8 = DerivedStorage;
    int v9 = FigCFEqual();
    uint64_t FigBaseObject = FigSampleCursorGetFigBaseObject(*(void *)(v8 + 16));
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v9)
    {
      if (v11) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = 0;
      }
      size_t v14 = *(uint64_t (**)(uint64_t, uint64_t, const __CFAllocator *, CFDictionaryRef *))(v12 + 48);
      if (v14)
      {
        uint64_t v15 = v14(FigBaseObject, a2, a3, &v21);
        CFDictionaryRef v16 = v21;
        if (!v15 && v21)
        {
          memset(&v20, 0, sizeof(v20));
          CMTimeRangeMakeFromDictionary(&v20, v21);
          if (!v20.start.epoch) {
            v20.start.CMTimeEpoch epoch = *(void *)(v8 + 24);
          }
          CMTimeRange v19 = v20;
          *a4 = CMTimeRangeCopyAsDictionary(&v19, a3);
          CFDictionaryRef v16 = v21;
        }
        if (v16) {
          CFRelease(v16);
        }
        return v15;
      }
      return 4294954514;
    }
    if (v11) {
      uint64_t v13 = v11;
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t, const __CFAllocator *, CFDictionaryRef *))(v13 + 48);
    if (!v17) {
      return 4294954514;
    }
    return v17(FigBaseObject, a2, a3, a4);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t compositionSharedCache_copyFormatReaderForAssetURL(uint64_t a1, const void *a2, const __CFAllocator *a3, uint64_t a4)
{
  CFTypeRef cf = 0;
  uint64_t v5 = compositionSharedCache_copyAssetForAssetURL(a1, a2, a3, &cf);
  CFTypeRef v6 = cf;
  if (v5)
  {
LABEL_7:
    uint64_t v12 = v5;
    if (!v6) {
      return v12;
    }
    goto LABEL_10;
  }
  CFAllocatorRef v7 = CFGetAllocator(cf);
  uint64_t CMBaseObject = FigAssetGetCMBaseObject(v6);
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, __CFString *, CFAllocatorRef, uint64_t))(v10 + 48);
  if (v11)
  {
    uint64_t v5 = v11(CMBaseObject, @"assetProperty_FormatReader", v7, a4);
    goto LABEL_7;
  }
  uint64_t v12 = 4294954514;
  if (v6) {
LABEL_10:
  }
    CFRelease(v6);
  return v12;
}

uint64_t compositionTable_findCompatibleTrackForFormatDescriptionArrayAndMediaType(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, int a5)
{
  if (a2 < a3)
  {
    cf1[9] = v5;
    cf1[10] = v6;
    uint64_t v10 = a2;
    uint64_t v12 = 168 * a2;
    uint64_t v13 = -1;
    while (1)
    {
      size_t v14 = (unsigned int *)(*(void *)(a1 + 32) + v12);
      cf1[0] = 0;
      if (*v14 == a5)
      {
        uint64_t result = v10;
        if (!a4) {
          goto LABEL_10;
        }
        int v16 = compositionTableTrack_copyTrackFormatDescriptionArrayForTrackCompatibility(a1, v14, cf1);
        CFTypeRef v17 = cf1[0];
        if (!v16)
        {
          uint64_t result = v10;
          if (cf1[0])
          {
            if (CFEqual(cf1[0], a4)) {
              uint64_t v13 = v10;
            }
LABEL_9:
            CFRelease(v17);
            uint64_t result = v13;
          }
LABEL_10:
          uint64_t v13 = result;
          if ((result & 0x8000000000000000) == 0) {
            return result;
          }
          goto LABEL_11;
        }
        if (cf1[0]) {
          goto LABEL_9;
        }
      }
LABEL_11:
      ++v10;
      v12 += 168;
      uint64_t result = v13;
      if (a3 == v10) {
        return result;
      }
    }
  }
  return -1;
}

uint64_t compositionTableTrack_copyTrackFormatDescriptionArrayForTrackCompatibility(uint64_t a1, unsigned int *a2, void *a3)
{
  CFTypeRef cf = 0;
  CFTypeRef v19 = 0;
  unint64_t v3 = *(void *)(a1 + 32);
  if (v3 > (unint64_t)a2) {
    return 4294954516;
  }
  if (v3 + 168 * *(void *)(a1 + 16) <= (unint64_t)a2)
  {
    uint64_t v16 = 4294954516;
  }
  else
  {
    uint64_t v5 = *((void *)a2 + 1);
    uint64_t v6 = v5 - 1;
    if (v5 < 1 || (v7 = *((void *)a2 + 2), (uint64_t v8 = *(const void **)(v7 + 108 * v6 + 96)) == 0))
    {
      CFTypeRef v14 = 0;
LABEL_12:
      uint64_t v16 = 0;
      *a3 = v14;
      CFTypeRef v19 = 0;
      goto LABEL_14;
    }
    uint64_t v9 = *MEMORY[0x1E4F1CF80];
    uint64_t v10 = compositionTable_copyConcreteTrackReaderForAssetURLTrackIDMediaType(a1, v8, *(unsigned int *)(v7 + 108 * v6 + 104), *a2, (const __CFAllocator *)*MEMORY[0x1E4F1CF80], &cf);
    if (v10)
    {
      uint64_t v16 = v10;
    }
    else
    {
      uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
      uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v12) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = 0;
      }
      uint64_t v15 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v13 + 48);
      if (v15)
      {
        uint64_t v16 = v15(FigBaseObject, @"TrackFormatDescriptionArray", v9, &v19);
        CFTypeRef v14 = v19;
        if (v16)
        {
          if (v19) {
            CFRelease(v19);
          }
          goto LABEL_14;
        }
        goto LABEL_12;
      }
      uint64_t v16 = 4294954514;
    }
  }
LABEL_14:
  if (cf) {
    CFRelease(cf);
  }
  return v16;
}

void compositionTable_addTrack(uint64_t a1, int a2, int a3, _DWORD *a4, uint64_t *a5)
{
  if (a3)
  {
    int v9 = a3;
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10 >= 1)
    {
      uint64_t v11 = (int *)(*(void *)(a1 + 32) + 4);
      uint64_t v12 = *(void *)(a1 + 16);
      while (1)
      {
        int v13 = *v11;
        v11 += 42;
        if (v13 == a3) {
          break;
        }
        if (!--v12) {
          goto LABEL_9;
        }
      }
      int v9 = *(_DWORD *)(a1 + 24);
    }
  }
  else
  {
    int v9 = *(_DWORD *)(a1 + 24);
    uint64_t v10 = *(void *)(a1 + 16);
  }
LABEL_9:
  *(void *)(a1 + 16) = v10 + 1;
  CFTypeRef v14 = (char *)malloc_type_calloc(0xA8uLL, v10 + 1, 0x75602335uLL);
  uint64_t v15 = v14;
  uint64_t v16 = *(const void **)(a1 + 32);
  if (v16)
  {
    memcpy(v14, v16, 168 * v10);
    free(*(void **)(a1 + 32));
  }
  *(void *)(a1 + 32) = v15;
  CFTypeRef v17 = &v15[168 * v10];
  *(_DWORD *)CFTypeRef v17 = a2;
  *((_DWORD *)v17 + 1) = v9;
  *(_OWORD *)(v17 + 8) = 0u;
  *(_OWORD *)(v17 + 24) = 0u;
  *(_OWORD *)(v17 + 40) = 0u;
  *(_OWORD *)(v17 + 56) = 0u;
  v17[160] = 1;
  *((void *)v17 + 14) = 0;
  if (v9 >= *(_DWORD *)(a1 + 24)) {
    *(_DWORD *)(a1 + 24) = v9 + 1;
  }
  if (a4) {
    *a4 = v9;
  }
  if (a5) {
    *a5 = v10;
  }
}

uint64_t mutableComposition_postPossiblyDeferredTracksChangedNotification()
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(result + 16))
  {
    *(unsigned char *)(result + 17) = 1;
  }
  else
  {
    CMNotificationCenterGetDefaultLocalCenter();
    return CMNotificationCenterPostNotification();
  }
  return result;
}

void compositionTable_discardUnusedAssets(uint64_t a1)
{
  MEMORY[0x19970E910](*(void *)(a1 + 56));
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 64));
  if (Count <= 0)
  {
    MEMORY[0x19970E930](*(void *)(a1 + 56));
    goto LABEL_38;
  }
  CFIndex v3 = Count;
  CFTypeRef v4 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 64), v4, 0);
  for (uint64_t i = 0; i != v3; ++i)
  {
    uint64_t v6 = v4[i];
    if (v6) {
      CFRetain(v6);
    }
  }
  MEMORY[0x19970E930](*(void *)(a1 + 56));
  MEMORY[0x19970E910](*(void *)(a1 + 8));
  for (uint64_t j = 0; j != v3; ++j)
  {
    if (CFBagContainsValue(*(CFBagRef *)(a1 + 40), v4[j]))
    {
      uint64_t v8 = v4[j];
      if (v8)
      {
        CFRelease(v8);
        v4[j] = 0;
      }
    }
  }
  MEMORY[0x19970E930](*(void *)(a1 + 8));
  MEMORY[0x19970E910](*(void *)(a1 + 56));
  for (uint64_t k = 0; k != v3; ++k)
  {
    uint64_t v10 = v4[k];
    if (v10) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 64), v10);
    }
  }
  MEMORY[0x19970E930](*(void *)(a1 + 56));
  uint64_t v11 = 0;
  while (1)
  {
    uint64_t v12 = v4[v11];
    if (v12)
    {
      MEMORY[0x19970E910](*(void *)(a1 + 120));
      uint64_t v13 = *(void *)(a1 + 144);
      if (v13 >= 2)
      {
        uint64_t v14 = 1;
        do
        {
          uint64_t v15 = *(const void **)(*(void *)(a1 + 136) + 16 * v14);
          if (v15)
          {
            if (CFEqual(v15, v12))
            {
              uint64_t v16 = *(void *)(a1 + 136);
              CFTypeRef v17 = *(const void **)(v16 + 16 * v14);
              if (v17)
              {
                CFRelease(v17);
                uint64_t v16 = *(void *)(a1 + 136);
                *(void *)(v16 + 16 * v14) = 0;
              }
              *(void *)(v16 + 16 * v14 + 8) = 0;
              CFTypeRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 152), (const void *)v14);
              if (Value)
              {
                CFTypeRef v19 = Value;
                CFRetain(Value);
                CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 152), (const void *)v14);
                MEMORY[0x19970E930](*(void *)(a1 + 120));
                CFRelease(v19);
              }
              else
              {
                MEMORY[0x19970E930](*(void *)(a1 + 120));
              }
              ++v14;
              MEMORY[0x19970E910](*(void *)(a1 + 120));
              uint64_t v13 = *(void *)(a1 + 144);
              continue;
            }
            uint64_t v13 = *(void *)(a1 + 144);
          }
          ++v14;
        }
        while (v14 < v13);
      }
      MEMORY[0x19970E930](*(void *)(a1 + 120));
    }
    if (++v11 == v3)
    {
      for (uint64_t m = 0; m != v3; ++m)
      {
        CFDictionaryRef v21 = v4[m];
        if (v21)
        {
          CFRelease(v21);
          v4[m] = 0;
        }
      }
      free(v4);
LABEL_38:
      uint64_t v22 = *(void *)(a1 + 160);
      MEMORY[0x19970E910](*(void *)(v22 + 32));
      CFIndex v23 = CFDictionaryGetCount(*(CFDictionaryRef *)(v22 + 40));
      if (v23 >= 1)
      {
        CFIndex v24 = v23;
        size_t v25 = 8 * v23;
        uint64_t v26 = (const void **)malloc_type_malloc(8 * v23, 0x6004044C4A2DFuLL);
        uint64_t v27 = (const void **)malloc_type_malloc(v25, 0x6004044C4A2DFuLL);
        CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(v22 + 40), v26, v27);
        for (uint64_t n = 0; n != v24; ++n)
        {
          if (CFGetRetainCount(v27[n]) == 1) {
            CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v22 + 40), v26[n]);
          }
        }
        free(v26);
        free(v27);
      }
      JUMPOUT(0x19970E930);
    }
  }
}

uint64_t compositionEditSegment_validateSegments(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a2 - 1;
  if (a2 < 1) {
    return 0;
  }
  if (a1)
  {
    unint64_t v5 = a2;
    if (!a3
      || (*(_OWORD *)&v19.start.CMTimeValue value = *(_OWORD *)(a1 + 48),
          v19.start.CMTimeEpoch epoch = *(void *)(a1 + 64),
          CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48],
          !CMTimeCompare(&v19.start, &time2)))
    {
      if (v5 < 2)
      {
LABEL_14:
        uint64_t v14 = (void *)(a1 + 64);
        unint64_t v15 = v5;
        while (!*v14 && !v14[3] && !*(v14 - 6) && !*(v14 - 3))
        {
          uint64_t v14 = (void *)((char *)v14 + 108);
          if (!--v15)
          {
            for (uint64_t i = (CFTypeRef *)(a1 + 96); ; uint64_t i = (CFTypeRef *)((char *)i + 108))
            {
              CFTypeRef v17 = *i;
              if ((*((_DWORD *)i - 21) & 0x1D) == 1)
              {
                if (!v17) {
                  return FigSignalErrorAt();
                }
                CFTypeID v18 = CFURLGetTypeID();
                if (v18 != CFGetTypeID(*i)) {
                  return FigSignalErrorAt();
                }
              }
              else if (v17)
              {
                return FigSignalErrorAt();
              }
              uint64_t result = 0;
              if (!--v5) {
                return result;
              }
            }
          }
        }
      }
      else
      {
        uint64_t v7 = a1 + 156;
        while (1)
        {
          memset(&v20, 0, sizeof(v20));
          long long v8 = *(_OWORD *)(v7 - 92);
          *(_OWORD *)&v19.start.CMTimeValue value = *(_OWORD *)(v7 - 108);
          *(_OWORD *)&v19.start.CMTimeEpoch epoch = v8;
          *(_OWORD *)&v19.duration.CMTimeScale timescale = *(_OWORD *)(v7 - 76);
          CMTimeRangeGetEnd(&v20, &v19);
          CMTimeValue v27 = *(void *)v7;
          CMTimeFlags v9 = *(_DWORD *)(v7 + 12);
          CMTimeScale v28 = *(_DWORD *)(v7 + 8);
          CMTimeEpoch v10 = *(void *)(v7 + 16);
          CMTimeValue value = v20.value;
          CMTimeFlags flags = v20.flags;
          CMTimeScale timescale = v20.timescale;
          CMTimeEpoch epoch = v20.epoch;
          if ((v9 & 0x1F) != 3 && (v20.flags & 0x1F) != 3) {
            goto LABEL_33;
          }
          memset(&v19, 0, 24);
          CMTimeValue v13 = *(void *)v7;
          rhs.CMTimeEpoch epoch = v20.epoch;
          lhs.CMTimeValue value = v13;
          lhs.CMTimeScale timescale = *(_DWORD *)(v7 + 8);
          lhs.CMTimeFlags flags = v9;
          lhs.CMTimeEpoch epoch = v10;
          rhs.CMTimeValue value = v20.value;
          rhs.CMTimeScale timescale = v20.timescale;
          rhs.CMTimeFlags flags = v20.flags;
          CMTimeSubtract(&time2, &lhs, &rhs);
          CMTimeAbsoluteValue(&v19.start, &time2);
          CMTimeMake(&v21, 1, 1000000000);
          CMTime lhs = v19.start;
          if (CMTimeCompare(&lhs, &v21) > 0)
          {
LABEL_33:
            v19.start.CMTimeValue value = v27;
            v19.start.CMTimeScale timescale = v28;
            v19.start.CMTimeFlags flags = v9;
            v19.start.CMTimeEpoch epoch = v10;
            lhs.CMTimeValue value = value;
            lhs.CMTimeScale timescale = timescale;
            lhs.CMTimeFlags flags = flags;
            lhs.CMTimeEpoch epoch = epoch;
            if (CMTimeCompare(&v19.start, &lhs)) {
              break;
            }
          }
          v7 += 108;
          if (!--v3) {
            goto LABEL_14;
          }
        }
      }
    }
    return FigSignalErrorAt();
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void compositionEditSegment_copySegmentsAndAddURLsToBag(CFTypeRef *a1, const void *a2, uint64_t a3, __CFBag *a4)
{
  uint64_t v5 = a3;
  memcpy(a1, a2, 108 * a3);
  if (v5 >= 1)
  {
    uint64_t v7 = a1 + 12;
    do
    {
      if ((*((_DWORD *)v7 - 21) & 0x1D) == 1)
      {
        if (*v7) {
          CFRetain(*v7);
        }
        if (a4)
        {
          if (*v7) {
            CFBagAddValue(a4, *v7);
          }
        }
      }
      else
      {
        *uint64_t v7 = 0;
      }
      uint64_t v7 = (CFTypeRef *)((char *)v7 + 108);
      --v5;
    }
    while (v5);
  }
}

uint64_t compositionEditSegment_combineEditSegmentsIfPossible(uint64_t a1, uint64_t a2, uint64_t a3, __CFBag *a4)
{
  long long v47 = *(_OWORD *)(a1 + 72);
  CMTimeEpoch v48 = *(void *)(a1 + 88);
  CMTime v46 = *(CMTime *)(a2 + 72);
  long long v44 = *(_OWORD *)(a1 + 24);
  CMTimeEpoch v45 = *(void *)(a1 + 40);
  CMTime v43 = *(CMTime *)(a2 + 24);
  *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(a1 + 72);
  time1.start.CMTimeEpoch epoch = *(void *)(a1 + 88);
  CMTime time2 = *(CMTime *)(a1 + 24);
  int32_t v8 = CMTimeCompare(&time1.start, &time2);
  time1.CMTime start = v46;
  CMTime time2 = v43;
  int32_t v9 = CMTimeCompare(&time1.start, &time2);
  CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  CMTime v41 = time2;
  long long v10 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&time1.start.CMTimeEpoch epoch = v10;
  *(_OWORD *)&time1.duration.CMTimeScale timescale = *(_OWORD *)(a1 + 80);
  CMTimeRangeGetEnd(&v37, &time1);
  *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(a2 + 48);
  time1.start.CMTimeEpoch epoch = *(void *)(a2 + 64);
  if (CMTimeCompare(&v37, &time1.start)) {
    return 0;
  }
  uint64_t v12 = *(const void **)(a1 + 96);
  CMTimeValue v13 = *(const void **)(a2 + 96);
  if (!v12)
  {
    if (!v13)
    {
      *(_OWORD *)&time1.start.CMTimeValue value = v47;
      time1.start.CMTimeEpoch epoch = v48;
      CMTime rhs = v46;
      CMTimeAdd(&time2, &time1.start, &rhs);
      long long v28 = *(_OWORD *)(a1 + 92);
      long long v29 = *(_OWORD *)(a1 + 48);
      long long v30 = *(_OWORD *)(a1 + 80);
      *(_OWORD *)(a3 + 64) = *(_OWORD *)(a1 + 64);
      *(_OWORD *)(a3 + 80) = v30;
      *(_OWORD *)(a3 + 92) = v28;
      long long v31 = *(_OWORD *)(a1 + 16);
      long long v32 = *(_OWORD *)(a1 + 32);
      *(_OWORD *)a3 = *(_OWORD *)a1;
      *(_OWORD *)(a3 + 16) = v31;
      *(_OWORD *)(a3 + 32) = v32;
      *(_OWORD *)(a3 + 48) = v29;
      *(CMTime *)(a3 + 72) = time2;
      return 1;
    }
    return 0;
  }
  if (!v13) {
    return 0;
  }
  uint64_t result = CFEqual(v12, v13);
  if (result)
  {
    if (*(_DWORD *)(a1 + 104) != *(_DWORD *)(a2 + 104)) {
      return 0;
    }
    long long v14 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)a1;
    *(_OWORD *)&time1.start.CMTimeEpoch epoch = v14;
    *(_OWORD *)&time1.duration.CMTimeScale timescale = *(_OWORD *)(a1 + 32);
    CMTimeRangeGetEnd(&v35, &time1);
    *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)a2;
    time1.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
    int32_t v15 = CMTimeCompare(&v35, &time1.start);
    uint64_t result = 0;
    if (!v15 && (v8 != 0) == (v9 != 0))
    {
      if (!v8) {
        goto LABEL_13;
      }
      if (!v9) {
        goto LABEL_13;
      }
      *(_OWORD *)&time1.start.CMTimeValue value = v47;
      time1.start.CMTimeEpoch epoch = v48;
      double Seconds = CMTimeGetSeconds(&time1.start);
      time1.CMTime start = v43;
      double v17 = Seconds * CMTimeGetSeconds(&time1.start);
      time1.CMTime start = v46;
      double v18 = CMTimeGetSeconds(&time1.start);
      *(_OWORD *)&time1.start.CMTimeValue value = v44;
      time1.start.CMTimeEpoch epoch = v45;
      if (v17 == v18 * CMTimeGetSeconds(&time1.start))
      {
LABEL_13:
        *(_OWORD *)&time1.start.CMTimeValue value = v47;
        time1.start.CMTimeEpoch epoch = v48;
        CMTime rhs = v46;
        CMTimeAdd(&time2, &time1.start, &rhs);
        *(_OWORD *)&time1.start.CMTimeValue value = v44;
        time1.start.CMTimeEpoch epoch = v45;
        CMTime rhs = v43;
        CMTimeAdd(&v41, &time1.start, &rhs);
        *(_OWORD *)&v40[28] = *(_OWORD *)(a1 + 92);
        long long v19 = *(_OWORD *)(a1 + 80);
        *(_OWORD *)uint64_t v40 = *(_OWORD *)(a1 + 64);
        *(_OWORD *)&v40[16] = v19;
        long long v20 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)a1;
        *(_OWORD *)&time1.start.CMTimeEpoch epoch = v20;
        long long v39 = *(_OWORD *)(a1 + 48);
        *(CMTime *)&v40[8] = time2;
        time1.duratiouint64_t n = v41;
        *(void *)(a1 + 96) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        long long v21 = *MEMORY[0x1E4F1F9F8];
        uint64_t v22 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
        *(void *)(a1 + 16) = v22;
        *(_OWORD *)a1 = v21;
        if ((*(_DWORD *)(a2 + 12) & 0x1D) == 1)
        {
          if (!a4) {
            goto LABEL_17;
          }
          CFIndex v23 = *(const void **)(a2 + 96);
          if (v23)
          {
            long long v33 = v21;
            CFBagRemoveValue(a4, v23);
            long long v21 = v33;
LABEL_17:
            CFIndex v24 = *(const void **)(a2 + 96);
            if (v24)
            {
              long long v34 = v21;
              CFRelease(v24);
              long long v21 = v34;
              *(void *)(a2 + 96) = 0;
            }
          }
        }
        *(_DWORD *)(a2 + 104) = 0;
        *(_OWORD *)a2 = v21;
        *(void *)(a2 + 16) = v22;
        long long v25 = *(_OWORD *)&v40[16];
        *(_OWORD *)(a3 + 64) = *(_OWORD *)v40;
        *(_OWORD *)(a3 + 80) = v25;
        *(_OWORD *)(a3 + 92) = *(_OWORD *)&v40[28];
        long long v26 = *(_OWORD *)&time1.start.epoch;
        *(_OWORD *)a3 = *(_OWORD *)&time1.start.value;
        *(_OWORD *)(a3 + 16) = v26;
        long long v27 = v39;
        uint64_t result = 1;
        *(_OWORD *)(a3 + 32) = *(_OWORD *)&time1.duration.timescale;
        *(_OWORD *)(a3 + 48) = v27;
        return result;
      }
      return 0;
    }
  }
  return result;
}

uint64_t compositionTableTrack_setFormatDescriptionReplacementTable(uint64_t a1, CFTypeRef cf)
{
  if (!cf)
  {
    double v18 = *(const void **)(a1 + 112);
    *(void *)(a1 + 112) = 0;
    if (v18) {
      CFRelease(v18);
    }
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFArrayGetTypeID())
  {
    uint64_t v22 = a1;
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v5, Count, MEMORY[0x1E4F1D510]);
    if (CFArrayGetCount((CFArrayRef)cf) < 1)
    {
      MutableCFStringRef Copy = 0;
LABEL_19:
      long long v20 = *(const void **)(v22 + 112);
      *(void *)(v22 + 112) = Mutable;
      if (Mutable) {
        CFRetain(Mutable);
      }
      if (v20) {
        CFRelease(v20);
      }
      uint64_t v19 = 0;
      if (!MutableCopy) {
        goto LABEL_25;
      }
    }
    else
    {
      CFIndex v8 = 0;
      MutableCFStringRef Copy = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)cf, v8);
        if (!ValueAtIndex) {
          break;
        }
        CFDictionaryRef v11 = ValueAtIndex;
        CFTypeID v12 = CFGetTypeID(ValueAtIndex);
        if (v12 != CFDictionaryGetTypeID()) {
          break;
        }
        CFTypeRef Value = CFDictionaryGetValue(v11, @"MutableCompositionFormatDescriptionReplacementTableKey_OldFormatDescription");
        long long v14 = CFDictionaryGetValue(v11, @"MutableCompositionFormatDescriptionReplacementTableKey_NewFormatDescription");
        if (!Value) {
          break;
        }
        int32_t v15 = v14;
        CFTypeID v16 = CFGetTypeID(Value);
        if (v16 != CMFormatDescriptionGetTypeID()) {
          break;
        }
        if (!v15) {
          break;
        }
        CFTypeID v17 = CFGetTypeID(v15);
        if (v17 != CMFormatDescriptionGetTypeID()) {
          break;
        }
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(v5, 0, v11);
        CFArrayAppendValue(Mutable, MutableCopy);
        if (++v8 >= CFArrayGetCount((CFArrayRef)cf)) {
          goto LABEL_19;
        }
      }
      uint64_t v19 = FigSignalErrorAt();
      if (!MutableCopy) {
        goto LABEL_25;
      }
    }
    CFRelease(MutableCopy);
LABEL_25:
    if (Mutable) {
      CFRelease(Mutable);
    }
    return v19;
  }

  return FigSignalErrorAt();
}

uint64_t compositionTable_insertAssetSegmentIntoTrack(uint64_t a1, void *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, long long *a7)
{
  memset(v29, 0, 44);
  long long v28 = 0u;
  memset(v27, 0, sizeof(v27));
  long long v14 = (long long *)MEMORY[0x1E4F1FA48];
  if ((*(_DWORD *)(a5 + 12) & 0x1D) == 1)
  {
    *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)a5;
    time1.start.CMTimeEpoch epoch = *(void *)(a5 + 16);
    CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    if (CMTimeCompare(&time1.start, &time2) < 0) {
      return 4294954516;
    }
  }
  *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)a6;
  time1.start.CMTimeEpoch epoch = *(void *)(a6 + 16);
  long long v25 = *v14;
  *(_OWORD *)&time2.CMTimeValue value = *v14;
  CMTimeEpoch v15 = *((void *)v14 + 2);
  time2.CMTimeEpoch epoch = v15;
  if (CMTimeCompare(&time1.start, &time2) < 1) {
    return 4294954516;
  }
  int v16 = *((_DWORD *)a7 + 3);
  if (v16 & 0x1D) != 1 && (v16) {
    return 4294954516;
  }
  if ((v16 & 0x1D) == 1)
  {
    *(_OWORD *)&time1.start.CMTimeValue value = *a7;
    time1.start.CMTimeEpoch epoch = *((void *)a7 + 2);
    *(_OWORD *)&time2.CMTimeValue value = v25;
    time2.CMTimeEpoch epoch = v15;
    if (CMTimeCompare(&time1.start, &time2) < 0) {
      return FigSignalErrorAt();
    }
  }
  unint64_t v17 = *(void *)(a1 + 32);
  if (v17 > (unint64_t)a2 || v17 + 168 * *(void *)(a1 + 16) <= (unint64_t)a2) {
    return 4294954516;
  }
  if ((*((_DWORD *)a7 + 3) & 0x1D) != 1)
  {
    *(_OWORD *)&time2.CMTimeValue value = v25;
    time2.CMTimeEpoch epoch = v15;
    uint64_t v18 = a2[1];
    if (v18 >= 1)
    {
      uint64_t v19 = a2[2] + 108 * v18;
      long long v20 = *(_OWORD *)(v19 - 60);
      long long v21 = *(_OWORD *)(v19 - 28);
      *(_OWORD *)&time1.start.CMTimeEpoch epoch = *(_OWORD *)(v19 - 44);
      *(_OWORD *)&time1.duration.CMTimeScale timescale = v21;
      *(_OWORD *)&time1.start.CMTimeValue value = v20;
      CMTimeRangeGetEnd(&time2, &time1);
    }
    time1.CMTime start = time2;
    CMTimeEpoch epoch = time2.epoch;
    *a7 = *(_OWORD *)&time2.value;
    *((void *)a7 + 2) = epoch;
  }
  long long v28 = *a7;
  *(void *)&v29[0] = *((void *)a7 + 2);
  *(_OWORD *)((char *)v29 + 8) = *(_OWORD *)a6;
  uint64_t v23 = *(void *)(a6 + 16);
  v27[0] = *(_OWORD *)a5;
  *(void *)&v27[1] = *(void *)(a5 + 16);
  *((void *)&v27[2] + 1) = v23;
  *(_OWORD *)((char *)&v27[1] + 8) = *(_OWORD *)((char *)v29 + 8);
  *((void *)&v29[1] + 1) = v23;
  *(void *)&v29[2] = a3;
  DWORD2(v29[2]) = a4;
  return compositionTable_insertEditSegmentsIntoTrack(a1, a2, (uint64_t)v27, 1);
}

uint64_t compositionTable_insertEditSegmentsIntoTrack(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(void *)(a1 + 32);
  if (v4 > (unint64_t)a2 || v4 + 168 * *(void *)(a1 + 16) <= (unint64_t)a2) {
    return 4294954516;
  }
  uint64_t v7 = a4;
  if (a4 < 1) {
    return 0;
  }
  CFIndex v8 = (_DWORD *)a3;
  uint64_t v9 = a2[1];
  CMTimeValue v69 = *(void *)(a3 + 48);
  CMTimeFlags v10 = *(_DWORD *)(a3 + 60);
  CMTimeScale v70 = *(_DWORD *)(a3 + 56);
  CMTimeEpoch v11 = *(void *)(a3 + 64);
  long long v57 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&time2.start.CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v12 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  time2.start.CMTimeEpoch epoch = v12;
  if (v9 >= 1)
  {
    uint64_t v13 = a2[2] + 108 * v9;
    long long v14 = *(_OWORD *)(v13 - 60);
    long long v15 = *(_OWORD *)(v13 - 28);
    *(_OWORD *)&range.start.CMTimeEpoch epoch = *(_OWORD *)(v13 - 44);
    *(_OWORD *)&range.duration.CMTimeScale timescale = v15;
    *(_OWORD *)&range.start.CMTimeValue value = v14;
    CMTimeRangeGetEnd(&time2.start, &range);
  }
  long long v67 = *(_OWORD *)&time2.start.value;
  CMTimeEpoch epoch = time2.start.epoch;
  if ((v10 & 1) == 0
    || (range.start.CMTimeValue value = v69,
        range.start.CMTimeScale timescale = v70,
        range.start.CMTimeFlags flags = v10,
        range.start.CMTimeEpoch epoch = v11,
        *(_OWORD *)&time2.start.CMTimeValue value = v67,
        time2.start.CMTimeEpoch epoch = epoch,
        !CMTimeCompare(&range.start, &time2.start)))
  {
    if ((uint64_t)a2[1] >= 1)
    {
      long long v65 = 0u;
      memset(v66, 0, sizeof(v66));
      long long v64 = 0u;
      memset(&range, 0, sizeof(range));
      compositionEditSegment_copySegmentsAndAddURLsToBag((CFTypeRef *)&range, v8, 1, 0);
      uint64_t v18 = a2[2] + 108 * a2[1] - 108;
      unsigned int v19 = compositionEditSegment_combineEditSegmentsIfPossible(v18, (uint64_t)&range, v18, 0);
      v8 += 27 * v19;
      v7 += (char)-(char)v19;
      compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag((uint64_t)&range, 1, 0);
    }
    uint64_t v20 = 108 * v7 - 96;
    while (1)
    {
      BOOL v17 = v7-- < 1;
      if (v17) {
        break;
      }
      int v21 = *(_DWORD *)((char *)v8 + v20) & 0x1D;
      v20 -= 108;
      if (v21 == 1)
      {
        uint64_t v22 = v7 + 1;
        uint64_t result = compositionTable_insertUninitializedEditsIntoTrack(a1, a2, a2[1], v22);
        if (result) {
          return result;
        }
        CFIndex v24 = (CFTypeRef *)(a2[2] + 108 * v9);
        long long v25 = *(__CFBag **)(a1 + 40);
        long long v26 = v8;
        uint64_t v27 = v22;
LABEL_47:
        compositionEditSegment_copySegmentsAndAddURLsToBag(v24, v26, v27, v25);
        return 0;
      }
    }
    return 0;
  }
  range.start.CMTimeValue value = v69;
  range.start.CMTimeScale timescale = v70;
  range.start.CMTimeFlags flags = v10;
  range.start.CMTimeEpoch epoch = v11;
  *(_OWORD *)&time2.start.CMTimeValue value = v67;
  time2.start.CMTimeEpoch epoch = epoch;
  if (CMTimeCompare(&range.start, &time2.start) >= 1)
  {
    int v16 = &v8[27 * v7];
    while ((v8[3] & 0x1D) != 1)
    {
      v8 += 27;
      BOOL v17 = v7-- <= 1;
      if (v17)
      {
        uint64_t v7 = 0;
        goto LABEL_42;
      }
    }
    int v16 = v8;
LABEL_42:
    uint64_t v42 = 108 * v7 - 96;
    while (1)
    {
      BOOL v17 = v7-- < 1;
      if (v17) {
        return 0;
      }
      int v43 = *(_DWORD *)((char *)v16 + v42) & 0x1D;
      v42 -= 108;
      if (v43 == 1)
      {
        CMTimeValue v69 = *((void *)v16 + 6);
        CMTimeFlags v44 = v16[15];
        CMTimeScale v70 = v16[14];
        CMTimeEpoch v45 = *((void *)v16 + 8);
        uint64_t result = compositionTable_insertUninitializedEditsIntoTrack(a1, a2, a2[1], v7 + 2);
        if (result) {
          return result;
        }
        uint64_t v46 = v7 + 1;
        uint64_t v47 = 108 * v9;
        uint64_t v48 = a2[2] + 108 * v9;
        long long v49 = v67;
        *(_OWORD *)(v48 + 48) = v67;
        CMTimeEpoch v50 = epoch;
        *(void *)(v48 + 64) = epoch;
        uint64_t v51 = a2[2] + 108 * v9;
        time2.start.CMTimeValue value = v69;
        time2.start.CMTimeScale timescale = v70;
        time2.start.CMTimeFlags flags = v44;
        time2.start.CMTimeEpoch epoch = v45;
        *(_OWORD *)&v62.CMTimeValue value = v49;
        v62.CMTimeEpoch epoch = v50;
        CMTimeSubtract(&range.start, &time2.start, &v62);
        long long v52 = *(_OWORD *)&range.start.value;
        *(void *)(v51 + 88) = range.start.epoch;
        *(_OWORD *)(v51 + 72) = v52;
        uint64_t v53 = a2[2] + v47;
        uint64_t v54 = MEMORY[0x1E4F1F9F8];
        *(_OWORD *)uint64_t v53 = *MEMORY[0x1E4F1F9F8];
        *(void *)(v53 + 16) = *(void *)(v54 + 16);
        uint64_t v55 = a2[2] + v47;
        *(_OWORD *)(v55 + 24) = v57;
        *(void *)(v55 + 40) = v12;
        uint64_t v56 = a2[2] + v47;
        *(void *)(v56 + 96) = 0;
        *(_DWORD *)(v56 + 104) = 0;
        CFIndex v24 = (CFTypeRef *)(v56 + 108);
        long long v25 = *(__CFBag **)(a1 + 40);
        long long v26 = v16;
        uint64_t v27 = v46;
        goto LABEL_47;
      }
    }
  }
  long long v65 = 0u;
  memset(v66, 0, sizeof(v66));
  long long v64 = 0u;
  memset(&range, 0, sizeof(range));
  *(_OWORD *)&v62.CMTimeValue value = v57;
  v62.CMTimeEpoch epoch = v12;
  *(_OWORD *)&v61.CMTimeValue value = v57;
  uint64_t v28 = 18;
  uint64_t v29 = v7;
  v61.CMTimeEpoch epoch = v12;
  do
  {
    time2.CMTime start = v61;
    CMTime rhs = *(CMTime *)&v8[v28];
    CMTimeAdd(&v61, &time2.start, &rhs);
    v28 += 27;
    --v29;
  }
  while (v29);
  time2.start.CMTimeValue value = v69;
  time2.start.CMTimeScale timescale = v70;
  time2.start.CMTimeFlags flags = v10;
  time2.start.CMTimeEpoch epoch = v11;
  uint64_t EditIndexStartingAtTimeInTrackSplitEditIfNecessary = compositionTable_findEditIndexStartingAtTimeInTrackSplitEditIfNecessary(a1, a2, &time2.start);
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary < 0) {
    return 4294954516;
  }
  uint64_t v31 = EditIndexStartingAtTimeInTrackSplitEditIfNecessary;
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary >= a2[1]) {
    return 4294954516;
  }
  uint64_t v32 = EditIndexStartingAtTimeInTrackSplitEditIfNecessary - 1;
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary) {
    uint64_t v33 = EditIndexStartingAtTimeInTrackSplitEditIfNecessary - 1;
  }
  else {
    uint64_t v33 = 0;
  }
  uint64_t v34 = a2[2] + 108 * EditIndexStartingAtTimeInTrackSplitEditIfNecessary;
  long long v35 = *(_OWORD *)(v34 + 48);
  rhs.CMTimeEpoch epoch = *(void *)(v34 + 64);
  *(_OWORD *)&rhs.CMTimeValue value = v35;
  CMTime v59 = v61;
  CMTimeAdd(&time2.start, &rhs, &v59);
  long long v36 = *(_OWORD *)&time2.start.value;
  *(void *)(v34 + 64) = time2.start.epoch;
  *(_OWORD *)(v34 + 48) = v36;
  if (!v31)
  {
LABEL_35:
    uint64_t v37 = v7 - 1;
    if (v7 >= 1)
    {
      compositionEditSegment_copySegmentsAndAddURLsToBag((CFTypeRef *)&range, &v8[27 * v37], 1, *(__CFBag **)(a1 + 40));
      int v38 = compositionEditSegment_combineEditSegmentsIfPossible((uint64_t)&range, a2[2] + 108 * v31, a2[2] + 108 * v31, *(__CFBag **)(a1 + 40));
      compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag((uint64_t)&range, 1, *(CFMutableBagRef *)(a1 + 40));
      if (!v38 || (--v7, v37))
      {
        uint64_t result = compositionTable_insertUninitializedEditsIntoTrack(a1, a2, v31, v7);
        if (result) {
          return result;
        }
        compositionEditSegment_copySegmentsAndAddURLsToBag((CFTypeRef *)(a2[2] + 108 * v31), v8, v7, *(__CFBag **)(a1 + 40));
        uint64_t v31 = v31 + v7 - 1;
      }
    }
    long long v39 = (_OWORD *)(a2[2] + 108 * v31);
    long long v40 = v39[3];
    long long v41 = v39[5];
    *(_OWORD *)&time2.start.CMTimeEpoch epoch = v39[4];
    *(_OWORD *)&time2.duration.CMTimeScale timescale = v41;
    *(_OWORD *)&time2.start.CMTimeValue value = v40;
    CMTimeRangeGetEnd(&v62, &time2);
    time2.CMTime start = v62;
    compositionTableTrack_updateTrackStartTimes((uint64_t)a2, v31 + 1, (long long *)&time2.start.value);
    compositionTable_deleteEditsWithZeroDuration(a1, (unint64_t)a2, v33, v31 + 1);
    return 0;
  }
  compositionEditSegment_copySegmentsAndAddURLsToBag((CFTypeRef *)&range, v8, 1, *(__CFBag **)(a1 + 40));
  if (!compositionEditSegment_combineEditSegmentsIfPossible(a2[2] + 108 * v32, (uint64_t)&range, a2[2] + 108 * v32, *(__CFBag **)(a1 + 40))|| (v8 += 27, --v7, v7))
  {
LABEL_34:
    compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag((uint64_t)&range, 1, *(CFMutableBagRef *)(a1 + 40));
    goto LABEL_35;
  }
  if (!compositionEditSegment_combineEditSegmentsIfPossible(a2[2] + 108 * v32, a2[2] + 108 * v31, a2[2] + 108 * v32, *(__CFBag **)(a1 + 40))|| (uint64_t result = compositionTable_deleteEditsFromTrack(a1, (unint64_t)a2, v31, 1), !result))
  {
    uint64_t v7 = 0;
    --v31;
    goto LABEL_34;
  }
  return result;
}

uint64_t compositionTable_insertUninitializedEditsIntoTrack(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (v4 > (unint64_t)a2) {
    return 4294954516;
  }
  uint64_t result = 4294954516;
  if ((a3 & 0x8000000000000000) == 0 && v4 + 168 * *(void *)(a1 + 16) > (unint64_t)a2)
  {
    uint64_t v9 = a2[1];
    uint64_t v10 = v9 - a3;
    if (v9 >= a3)
    {
      uint64_t v12 = a2[3];
      if (v12 - v9 >= a4)
      {
        if (v10 >= 1) {
          memmove((void *)(a2[2] + 108 * a3 + 108 * a4), (const void *)(a2[2] + 108 * a3), 108 * v10);
        }
        bzero((void *)(a2[2] + 108 * a3), 108 * a4);
      }
      else
      {
        uint64_t v13 = 5;
        if (a4 > 5) {
          uint64_t v13 = a4;
        }
        uint64_t v14 = v12 + v13;
        long long v15 = (char *)malloc_type_calloc(v12 + v13, 0x6CuLL, 0x1060040CB727B4DuLL);
        int v16 = v15;
        BOOL v17 = (char *)a2[2];
        if (v17)
        {
          uint64_t v18 = a2[1] - a3;
          if (a3)
          {
            memmove(v15, v17, 108 * a3);
            BOOL v17 = (char *)a2[2];
          }
          if (v18 >= 1)
          {
            memmove(&v16[108 * a3 + 108 * a4], &v17[108 * a3], 108 * v18);
            BOOL v17 = (char *)a2[2];
          }
          free(v17);
        }
        a2[2] = v16;
        a2[3] = v14;
      }
      uint64_t result = 0;
      a2[1] += a4;
    }
  }
  return result;
}

uint64_t compositionTable_findEditIndexStartingAtTimeInTrackSplitEditIfNecessary(uint64_t a1, void *a2, CMTime *a3)
{
  unint64_t v3 = *(void *)(a1 + 32);
  if (v3 > (unint64_t)a2 || v3 + 168 * *(void *)(a1 + 16) <= (unint64_t)a2) {
    return -1;
  }
  *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&a3->value;
  time1.start.CMTimeEpoch epoch = a3->epoch;
  uint64_t EditSegmentByTime = compositionTableTrack_findEditSegmentByTime((uint64_t)a2, (uint64_t)&time1);
  uint64_t v8 = EditSegmentByTime;
  if ((EditSegmentByTime & 0x8000000000000000) == 0)
  {
    uint64_t v9 = a2[2] + 108 * EditSegmentByTime;
    long long v10 = *(_OWORD *)(v9 + 48);
    time1.start.CMTimeEpoch epoch = *(void *)(v9 + 64);
    *(_OWORD *)&time1.start.CMTimeValue value = v10;
    *(_OWORD *)&v31.start.CMTimeValue value = *(_OWORD *)&a3->value;
    v31.start.CMTimeEpoch epoch = a3->epoch;
    if (CMTimeCompare(&time1.start, &v31.start))
    {
      CMTimeEpoch v11 = (long long *)(a2[2] + 108 * v8);
      CMTime v36 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      CMTime v35 = v36;
      CMTime v34 = v36;
      CMTime rhs = *a3;
      long long v12 = v11[3];
      long long v13 = v11[5];
      *(_OWORD *)&time1.start.CMTimeEpoch epoch = v11[4];
      *(_OWORD *)&time1.duration.CMTimeScale timescale = v13;
      *(_OWORD *)&time1.start.CMTimeValue value = v12;
      long long v14 = *v11;
      long long v15 = v11[2];
      *(_OWORD *)&v31.start.CMTimeEpoch epoch = v11[1];
      *(_OWORD *)&v31.duration.CMTimeScale timescale = v15;
      *(_OWORD *)&v31.start.CMTimeValue value = v14;
      CMTimeMapTimeFromRangeToRange(&v36, &rhs, &time1, &v31);
      uint64_t v16 = v8 + 1;
      if (compositionTable_insertUninitializedEditsIntoTrack(a1, a2, v8 + 1, 1)) {
        return -1;
      }
      uint64_t v17 = a2[2] + 108 * v8;
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&a3->value;
      time1.start.CMTimeEpoch epoch = a3->epoch;
      long long v18 = *(_OWORD *)(v17 + 48);
      v31.start.CMTimeEpoch epoch = *(void *)(v17 + 64);
      *(_OWORD *)&v31.start.CMTimeValue value = v18;
      CMTimeSubtract(&v35, &time1.start, &v31.start);
      time1.CMTime start = v36;
      long long v19 = *(_OWORD *)v17;
      v31.start.CMTimeEpoch epoch = *(void *)(v17 + 16);
      *(_OWORD *)&v31.start.CMTimeValue value = v19;
      CMTimeSubtract(&v34, &time1.start, &v31.start);
      long long v20 = *(_OWORD *)&a3->value;
      *(void *)(v17 + 172) = a3->epoch;
      *(_OWORD *)(v17 + 156) = v20;
      long long v21 = *(_OWORD *)(v17 + 72);
      v31.start.CMTimeEpoch epoch = *(void *)(v17 + 88);
      *(_OWORD *)&v31.start.CMTimeValue value = v21;
      CMTime rhs = v35;
      CMTimeSubtract(&time1.start, &v31.start, &rhs);
      long long v22 = *(_OWORD *)&time1.start.value;
      *(void *)(v17 + 196) = time1.start.epoch;
      *(_OWORD *)(v17 + 180) = v22;
      long long v23 = *(_OWORD *)&v36.value;
      *(void *)(v17 + 124) = v36.epoch;
      *(_OWORD *)(v17 + 108) = v23;
      long long v24 = *(_OWORD *)(v17 + 24);
      v31.start.CMTimeEpoch epoch = *(void *)(v17 + 40);
      *(_OWORD *)&v31.start.CMTimeValue value = v24;
      CMTime rhs = v34;
      CMTimeSubtract(&time1.start, &v31.start, &rhs);
      long long v25 = *(_OWORD *)&time1.start.value;
      *(void *)(v17 + 148) = time1.start.epoch;
      *(_OWORD *)(v17 + 132) = v25;
      long long v26 = *(const void **)(v17 + 96);
      *(void *)(v17 + 204) = v26;
      *(_DWORD *)(v17 + 212) = *(_DWORD *)(v17 + 104);
      CMTimeEpoch epoch = v35.epoch;
      *(_OWORD *)(v17 + 72) = *(_OWORD *)&v35.value;
      *(void *)(v17 + 88) = epoch;
      CMTimeEpoch v28 = v34.epoch;
      *(_OWORD *)(v17 + 24) = *(_OWORD *)&v34.value;
      *(void *)(v17 + 40) = v28;
      if ((*(_DWORD *)(v17 + 120) & 0x1D) == 1)
      {
        if (v26)
        {
          CFRetain(v26);
          uint64_t v29 = *(const void **)(v17 + 204);
          if (v29) {
            CFBagAddValue(*(CFMutableBagRef *)(a1 + 40), v29);
          }
        }
      }
      return v16;
    }
  }
  return v8;
}

uint64_t compositionTable_deleteEditsFromTrack(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (v4 > a2) {
    return 4294954516;
  }
  if (v4 + 168 * *(void *)(a1 + 16) <= a2) {
    return 4294954516;
  }
  uint64_t v8 = a4 + a3;
  if (a4 + a3 > *(void *)(a2 + 8)) {
    return 4294954516;
  }
  compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag(*(void *)(a2 + 16) + 108 * a3, a4, *(CFMutableBagRef *)(a1 + 40));
  uint64_t v9 = *(void *)(a2 + 8);
  if (v9 - v8 >= 1)
  {
    memmove((void *)(*(void *)(a2 + 16) + 108 * a3), (const void *)(*(void *)(a2 + 16) + 108 * v8), 108 * (v9 - v8));
    uint64_t v9 = *(void *)(a2 + 8);
  }
  uint64_t v10 = v9 - a4;
  *(void *)(a2 + 8) = v10;
  bzero((void *)(*(void *)(a2 + 16) + 108 * v10), 108 * a4);
  return 0;
}

double compositionTableTrack_updateTrackStartTimes(uint64_t a1, uint64_t a2, long long *a3)
{
  if (*(void *)(a1 + 8) > a2)
  {
    uint64_t v4 = a2;
    uint64_t v6 = 108 * a2 + 48;
    do
    {
      uint64_t v7 = *(void *)(a1 + 16) + v6;
      long long v8 = *a3;
      *(void *)(v7 + 16) = *((void *)a3 + 2);
      *(_OWORD *)uint64_t v7 = v8;
      uint64_t v9 = (long long *)(*(void *)(a1 + 16) + v6);
      long long v10 = *v9;
      long long v11 = v9[2];
      *(_OWORD *)&v13.start.CMTimeEpoch epoch = v9[1];
      *(_OWORD *)&v13.duration.CMTimeScale timescale = v11;
      *(_OWORD *)&v13.start.CMTimeValue value = v10;
      CMTimeRangeGetEnd(&v14, &v13);
      double result = *(double *)&v14.value;
      *(CMTime *)a3 = v14;
      ++v4;
      v6 += 108;
    }
    while (v4 < *(void *)(a1 + 8));
  }
  return result;
}

uint64_t compositionTable_deleteEditsWithZeroDuration(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((a3 & 0x8000000000000000) == 0)
  {
    uint64_t v4 = a4;
    uint64_t v5 = a3;
    uint64_t v7 = *(void *)(a2 + 8);
    BOOL v8 = v7 > a4 && a3 <= a4;
    if (v8 && v7 > a3)
    {
      uint64_t v10 = result;
      long long v14 = *MEMORY[0x1E4F1FA48];
      CMTimeEpoch v11 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
      do
      {
        uint64_t v12 = *(void *)(a2 + 16) + 108 * v5;
        long long v13 = *(_OWORD *)(v12 + 72);
        time1.CMTimeEpoch epoch = *(void *)(v12 + 88);
        *(_OWORD *)&time1.CMTimeValue value = v13;
        *(_OWORD *)&time2.CMTimeValue value = v14;
        time2.CMTimeEpoch epoch = v11;
        double result = CMTimeCompare(&time1, &time2);
        if (result)
        {
          ++v5;
        }
        else
        {
          double result = compositionTable_deleteEditsFromTrack(v10, a2, v5, 1);
          if (result) {
            return result;
          }
          --v4;
        }
      }
      while (v5 <= v4);
    }
  }
  return result;
}

uint64_t compositionTableTrack_findEditSegmentByTime(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return -1;
  }
  if (v2 >= 2)
  {
    uint64_t v5 = 0;
    uint64_t v6 = v2 - 1;
    while (1)
    {
      uint64_t v7 = (v6 + v5) >> 1;
      uint64_t v8 = *(void *)(a1 + 16) + 108 * v7;
      CMTime v15 = *(CMTime *)(v8 + 48);
      memset(&v14, 0, sizeof(v14));
      long long v9 = *(_OWORD *)(v8 + 48);
      long long v10 = *(_OWORD *)(v8 + 80);
      *(_OWORD *)&range.start.CMTimeEpoch epoch = *(_OWORD *)(v8 + 64);
      *(_OWORD *)&range.duration.CMTimeScale timescale = v10;
      *(_OWORD *)&range.start.CMTimeValue value = v9;
      CMTimeRangeGetEnd(&v14, &range);
      *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)a2;
      range.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
      CMTime v12 = v14;
      if (CMTimeCompare(&range.start, &v12) < 1)
      {
        *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)a2;
        range.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
        CMTime v12 = v14;
        if (!CMTimeCompare(&range.start, &v12)) {
          return v7 + 1;
        }
        *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)a2;
        range.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
        CMTime v12 = v15;
        if ((CMTimeCompare(&range.start, &v12) & 0x80000000) == 0) {
          return (v6 + v5) >> 1;
        }
        uint64_t v6 = v7 - 1;
      }
      else
      {
        uint64_t v5 = v7 + 1;
      }
      if (v5 >= v6) {
        return v5;
      }
    }
  }
  return 0;
}

uint64_t compositionTable_insertEditSegmentsFromAsset(uint64_t a1, uint64_t *a2, uint64_t a3, const void *a4, int a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v15 = *(void *)(CMBaseObjectGetDerivedStorage() + 8);
  uint64_t v16 = *(void *)(v15 + 16);
  uint64_t v17 = v15;
  uint64_t v18 = 0;
  while (1)
  {
    CompatibleTrackForFormatDescriptionArrayAndCMMediaType MediaType = compositionTable_findCompatibleTrackForFormatDescriptionArrayAndMediaType(v17, v18, v16, a4, a5);
    if (CompatibleTrackForFormatDescriptionArrayAndMediaType < 0)
    {
      uint64_t v24 = CompatibleTrackForFormatDescriptionArrayAndMediaType;
      compositionTable_addTrack(v15, a5, 0, 0, &v24);
      CompatibleTrackForFormatDescriptionArrayAndCMMediaType MediaType = v24;
      goto LABEL_9;
    }
    long long v20 = a2;
    uint64_t v21 = a3;
    if (a3 >= 1) {
      break;
    }
LABEL_6:
    uint64_t v18 = CompatibleTrackForFormatDescriptionArrayAndMediaType + 1;
    uint64_t v16 = *(void *)(v15 + 16);
    uint64_t v17 = v15;
  }
  while (1)
  {
    uint64_t v22 = *v20++;
    if (v22 == CompatibleTrackForFormatDescriptionArrayAndMediaType) {
      break;
    }
    if (!--v21) {
      goto LABEL_6;
    }
  }
  uint64_t v24 = CompatibleTrackForFormatDescriptionArrayAndMediaType;
LABEL_9:
  uint64_t result = compositionTable_insertEditSegmentsIntoTrack(v15, (void *)(*(void *)(v15 + 32) + 168 * CompatibleTrackForFormatDescriptionArrayAndMediaType), a6, a7);
  if (a8)
  {
    if (!result) {
      *a8 = v24;
    }
  }
  return result;
}

uint64_t tableTrack_InsertEmptyEditsInTracks(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, CMTime *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a3 < 1) {
    return 0;
  }
  uint64_t v10 = *(void *)(DerivedStorage + 8);
  CMTimeEpoch v11 = (CMTime *)MEMORY[0x1E4F1FA48];
  while (1)
  {
    uint64_t v13 = *a2++;
    uint64_t v12 = v13;
    uint64_t v14 = *(void *)(v10 + 32);
    uint64_t v15 = (void *)(v14 + 168 * v13);
    if ((uint64_t)v15[1] >= 1)
    {
      CMTime v22 = *v11;
      uint64_t v16 = v15[1];
      if (v16 >= 1)
      {
        uint64_t v17 = *(void *)(v14 + 168 * v12 + 16) + 108 * v16;
        long long v18 = *(_OWORD *)(v17 - 60);
        long long v19 = *(_OWORD *)(v17 - 28);
        *(_OWORD *)&range.start.CMTimeEpoch epoch = *(_OWORD *)(v17 - 44);
        *(_OWORD *)&range.duration.CMTimeScale timescale = v19;
        *(_OWORD *)&range.start.CMTimeValue value = v18;
        CMTimeRangeGetEnd(&v22, &range);
      }
      *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)a4;
      range.start.CMTimeEpoch epoch = *(void *)(a4 + 16);
      CMTime v21 = v22;
      if (CMTimeCompare(&range.start, &v21) < 0)
      {
        *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)a4;
        range.start.CMTimeEpoch epoch = *(void *)(a4 + 16);
        CMTime v21 = *a5;
        uint64_t result = compositionTable_insertEmptyTrackSegment(v10, v15, &range.start, &v21);
        if (result) {
          break;
        }
      }
    }
    if (!--a3) {
      return 0;
    }
  }
  return result;
}

uint64_t compositionTable_insertEmptyTrackSegment(uint64_t a1, void *a2, CMTime *a3, CMTime *a4)
{
  *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&a4->value;
  time1.start.CMTimeEpoch epoch = a4->epoch;
  long long v15 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&time2.CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v8 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  time2.CMTimeEpoch epoch = v8;
  if (CMTimeCompare(&time1.start, &time2) < 1) {
    return 4294954516;
  }
  *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&a3->value;
  time1.start.CMTimeEpoch epoch = a3->epoch;
  *(_OWORD *)&time2.CMTimeValue value = v15;
  time2.CMTimeEpoch epoch = v8;
  if (CMTimeCompare(&time1.start, &time2) < 0) {
    return 4294954516;
  }
  unint64_t v9 = *(void *)(a1 + 32);
  if (v9 > (unint64_t)a2) {
    return 4294954516;
  }
  if (v9 + 168 * *(void *)(a1 + 16) <= (unint64_t)a2) {
    return 4294954516;
  }
  uint64_t v10 = a2[1];
  if (v10 < 1) {
    return 4294954516;
  }
  *(_OWORD *)&time2.CMTimeValue value = v15;
  time2.CMTimeEpoch epoch = v8;
  uint64_t v11 = a2[2] + 108 * v10;
  long long v12 = *(_OWORD *)(v11 - 60);
  long long v13 = *(_OWORD *)(v11 - 28);
  *(_OWORD *)&time1.start.CMTimeEpoch epoch = *(_OWORD *)(v11 - 44);
  *(_OWORD *)&time1.duration.CMTimeScale timescale = v13;
  *(_OWORD *)&time1.start.CMTimeValue value = v12;
  CMTimeRangeGetEnd(&time2, &time1);
  time1.CMTime start = time2;
  CMTime time2 = *a3;
  CMTime start = time1.start;
  if ((CMTimeCompare(&time2, &start) & 0x80000000) == 0) {
    return 0;
  }
  CMTime time2 = *a4;
  CMTime start = *a3;
  return compositionTable_insertAssetSegmentIntoTrack(a1, a2, 0, 0, MEMORY[0x1E4F1F9F8], (uint64_t)&time2, (long long *)&start.value);
}

uint64_t compositionTable_deleteTrackSegment(uint64_t a1, void *a2, CMTime *a3, CMTime *a4)
{
  memset(&v27, 0, sizeof(v27));
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a3->value;
  lhs.start.CMTimeEpoch epoch = a3->epoch;
  CMTime rhs = *a4;
  CMTimeAdd(&v27, &lhs.start, &rhs);
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a4->value;
  lhs.start.CMTimeEpoch epoch = a4->epoch;
  long long v24 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&rhs.CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v8 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  rhs.CMTimeEpoch epoch = v8;
  if (!CMTimeCompare(&lhs.start, &rhs)) {
    return 0;
  }
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a4->value;
  lhs.start.CMTimeEpoch epoch = a4->epoch;
  *(_OWORD *)&rhs.CMTimeValue value = v24;
  rhs.CMTimeEpoch epoch = v8;
  if (CMTimeCompare(&lhs.start, &rhs) < 1) {
    return 4294954516;
  }
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a3->value;
  lhs.start.CMTimeEpoch epoch = a3->epoch;
  *(_OWORD *)&rhs.CMTimeValue value = v24;
  rhs.CMTimeEpoch epoch = v8;
  if (CMTimeCompare(&lhs.start, &rhs) < 0) {
    return 4294954516;
  }
  unint64_t v9 = *(void *)(a1 + 32);
  if (v9 > (unint64_t)a2 || v9 + 168 * *(void *)(a1 + 16) <= (unint64_t)a2) {
    return 4294954516;
  }
  uint64_t v10 = a2[1];
  if (v10 < 1) {
    return 0;
  }
  *(_OWORD *)&rhs.CMTimeValue value = v24;
  rhs.CMTimeEpoch epoch = v8;
  uint64_t v11 = a2[2] + 108 * v10;
  long long v12 = *(_OWORD *)(v11 - 60);
  long long v13 = *(_OWORD *)(v11 - 28);
  *(_OWORD *)&lhs.start.CMTimeEpoch epoch = *(_OWORD *)(v11 - 44);
  *(_OWORD *)&lhs.duration.CMTimeScale timescale = v13;
  *(_OWORD *)&lhs.start.CMTimeValue value = v12;
  CMTimeRangeGetEnd(&rhs, &lhs);
  lhs.CMTime start = rhs;
  CMTime rhs = *a3;
  CMTime time2 = lhs.start;
  if ((CMTimeCompare(&rhs, &time2) & 0x80000000) == 0) {
    return 0;
  }
  CMTime rhs = *a3;
  uint64_t EditIndexStartingAtTimeInTrackSplitEditIfNecessary = compositionTable_findEditIndexStartingAtTimeInTrackSplitEditIfNecessary(a1, a2, &rhs);
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary < 0) {
    return 4294954516;
  }
  uint64_t v15 = EditIndexStartingAtTimeInTrackSplitEditIfNecessary;
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary >= a2[1]) {
    return 4294954516;
  }
  CMTime rhs = v27;
  CMTime time2 = lhs.start;
  if (CMTimeCompare(&rhs, &time2) < 0)
  {
    CMTime rhs = v27;
    uint64_t v16 = compositionTable_findEditIndexStartingAtTimeInTrackSplitEditIfNecessary(a1, a2, &rhs);
    if ((v16 & 0x8000000000000000) == 0 && v16 < a2[1]) {
      goto LABEL_15;
    }
    return 4294954516;
  }
  uint64_t v16 = a2[1];
LABEL_15:
  uint64_t v18 = compositionTable_deleteEditsFromTrack(a1, (unint64_t)a2, v15, v16 - v15);
  if (v18) {
    return v18;
  }
  CMTime rhs = *a3;
  compositionTableTrack_updateTrackStartTimes((uint64_t)a2, v15, (long long *)&rhs.value);
  if (v15)
  {
    uint64_t v19 = a2[1];
    if (v15 >= v19) {
      goto LABEL_21;
    }
    if (compositionEditSegment_combineEditSegmentsIfPossible(a2[2] + 108 * v15 - 108, a2[2] + 108 * v15, a2[2] + 108 * v15 - 108, *(__CFBag **)(a1 + 40)))
    {
      uint64_t v18 = compositionTable_deleteEditsFromTrack(a1, (unint64_t)a2, v15, 1);
      if (v18) {
        return v18;
      }
    }
  }
  uint64_t v19 = a2[1];
LABEL_21:
  uint64_t v20 = v19 - 1;
  if (v19 < 1 || (*(_DWORD *)(a2[2] + 108 * v20 + 12) & 0x1D) == 1)
  {
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v17 = compositionTable_deleteEditsFromTrack(a1, (unint64_t)a2, v20, 1);
    uint64_t v19 = a2[1];
  }
  if (v15 >= v19) {
    uint64_t v21 = v19 - 1;
  }
  else {
    uint64_t v21 = v15;
  }
  if (v15) {
    uint64_t v22 = v15 - 1;
  }
  else {
    uint64_t v22 = 0;
  }
  if (v21 >= v22) {
    compositionTable_deleteEditsWithZeroDuration(a1, (unint64_t)a2, v22, v21);
  }
  return v17;
}

uint64_t compositionTable_scaleTrackSegment(uint64_t a1, void *a2, uint64_t a3, CMTime *a4, CMTime *a5)
{
  long long v35 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&v38.CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v10 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  v38.CMTimeEpoch epoch = v10;
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)a3;
  lhs.start.CMTimeEpoch epoch = *(void *)(a3 + 16);
  CMTime rhs = *a4;
  memset(&v37, 0, sizeof(v37));
  CMTimeAdd(&v37, &lhs.start, &rhs);
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a5->value;
  lhs.start.CMTimeEpoch epoch = a5->epoch;
  double Seconds = CMTimeGetSeconds(&lhs.start);
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a4->value;
  lhs.start.CMTimeEpoch epoch = a4->epoch;
  double v12 = CMTimeGetSeconds(&lhs.start);
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a4->value;
  lhs.start.CMTimeEpoch epoch = a4->epoch;
  CMTime rhs = *a5;
  uint64_t result = CMTimeCompare(&lhs.start, &rhs);
  if (!result) {
    return result;
  }
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a4->value;
  lhs.start.CMTimeEpoch epoch = a4->epoch;
  *(_OWORD *)&rhs.CMTimeValue value = v35;
  rhs.CMTimeEpoch epoch = v10;
  if (CMTimeCompare(&lhs.start, &rhs) < 1) {
    return 4294954516;
  }
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a5->value;
  lhs.start.CMTimeEpoch epoch = a5->epoch;
  *(_OWORD *)&rhs.CMTimeValue value = v35;
  rhs.CMTimeEpoch epoch = v10;
  if (CMTimeCompare(&lhs.start, &rhs) < 1) {
    return 4294954516;
  }
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)a3;
  lhs.start.CMTimeEpoch epoch = *(void *)(a3 + 16);
  *(_OWORD *)&rhs.CMTimeValue value = v35;
  rhs.CMTimeEpoch epoch = v10;
  if (CMTimeCompare(&lhs.start, &rhs) < 0) {
    return 4294954516;
  }
  unint64_t v14 = *(void *)(a1 + 32);
  if (v14 > (unint64_t)a2) {
    return 4294954516;
  }
  if (v14 + 168 * *(void *)(a1 + 16) <= (unint64_t)a2) {
    return 4294954516;
  }
  uint64_t v15 = a2[1];
  if (v15 < 1) {
    return 4294954516;
  }
  *(_OWORD *)&rhs.CMTimeValue value = v35;
  rhs.CMTimeEpoch epoch = v10;
  uint64_t v16 = a2[2] + 108 * v15;
  long long v17 = *(_OWORD *)(v16 - 60);
  long long v18 = *(_OWORD *)(v16 - 28);
  *(_OWORD *)&lhs.start.CMTimeEpoch epoch = *(_OWORD *)(v16 - 44);
  *(_OWORD *)&lhs.duration.CMTimeScale timescale = v18;
  *(_OWORD *)&lhs.start.CMTimeValue value = v17;
  CMTimeRangeGetEnd(&rhs, &lhs);
  CMTime v38 = rhs;
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)a3;
  lhs.start.CMTimeEpoch epoch = *(void *)(a3 + 16);
  if ((CMTimeCompare(&lhs.start, &rhs) & 0x80000000) == 0) {
    return 0;
  }
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)a3;
  lhs.start.CMTimeEpoch epoch = *(void *)(a3 + 16);
  uint64_t EditIndexStartingAtTimeInTrackSplitEditIfNecessary = compositionTable_findEditIndexStartingAtTimeInTrackSplitEditIfNecessary(a1, a2, &lhs.start);
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary < 0) {
    return 4294954516;
  }
  uint64_t v20 = EditIndexStartingAtTimeInTrackSplitEditIfNecessary;
  if (EditIndexStartingAtTimeInTrackSplitEditIfNecessary >= a2[1]) {
    return 4294954516;
  }
  lhs.CMTime start = v37;
  CMTime rhs = v38;
  if ((CMTimeCompare(&lhs.start, &rhs) & 0x80000000) == 0)
  {
    uint64_t v21 = a2[1];
    goto LABEL_15;
  }
  lhs.CMTime start = v37;
  uint64_t v22 = compositionTable_findEditIndexStartingAtTimeInTrackSplitEditIfNecessary(a1, a2, &lhs.start);
  if (v22 < 0) {
    return 4294954516;
  }
  uint64_t v21 = v22;
  if (v22 >= a2[1]) {
    return 4294954516;
  }
LABEL_15:
  if (v20 == v21 - 1
    && (uint64_t v23 = a2[2] + 108 * v20,
        long long v24 = *(_OWORD *)(v23 + 72),
        lhs.start.CMTimeEpoch epoch = *(void *)(v23 + 88),
        *(_OWORD *)&lhs.start.CMTimeValue value = v24,
        CMTime rhs = *a4,
        !CMTimeCompare(&lhs.start, &rhs)))
  {
    uint64_t v31 = a2[2] + 108 * v20;
    long long v32 = *(_OWORD *)&a5->value;
    *(void *)(v31 + 88) = a5->epoch;
    *(_OWORD *)(v31 + 72) = v32;
  }
  else
  {
    uint64_t v25 = v21 - v20;
    if (v21 > v20)
    {
      uint64_t v26 = 108 * v20 + 72;
      double v27 = Seconds / v12;
      do
      {
        uint64_t v28 = a2[2] + v26;
        long long v29 = *(_OWORD *)v28;
        rhs.CMTimeEpoch epoch = *(void *)(v28 + 16);
        *(_OWORD *)&rhs.CMTimeValue value = v29;
        CMTimeMultiplyByFloat64(&lhs.start, &rhs, v27);
        long long v30 = *(_OWORD *)&lhs.start.value;
        *(void *)(v28 + 16) = lhs.start.epoch;
        *(_OWORD *)uint64_t v28 = v30;
        v26 += 108;
        --v25;
      }
      while (v25);
    }
  }
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)a3;
  lhs.start.CMTimeEpoch epoch = *(void *)(a3 + 16);
  compositionTableTrack_updateTrackStartTimes((uint64_t)a2, v20, (long long *)&lhs.start.value);
  if (v20 < 1
    || v20 >= a2[1]
    || !compositionEditSegment_combineEditSegmentsIfPossible(a2[2] + 108 * v20 - 108, a2[2] + 108 * v20, a2[2] + 108 * v20 - 108, *(__CFBag **)(a1 + 40))|| (uint64_t result = compositionTable_deleteEditsFromTrack(a1, (unint64_t)a2, v20, 1), --v21, !result))
  {
    if (v21 < 1
      || v21 >= a2[1]
      || !compositionEditSegment_combineEditSegmentsIfPossible(a2[2] + 108 * v21 - 108, a2[2] + 108 * v21, a2[2] + 108 * v21 - 108, *(__CFBag **)(a1 + 40))|| (uint64_t result = compositionTable_deleteEditsFromTrack(a1, (unint64_t)a2, v21, 1), --v21, !result))
    {
      uint64_t v33 = a2[1];
      if (v21 >= v33) {
        uint64_t v34 = v33 - 1;
      }
      else {
        uint64_t v34 = v21;
      }
      compositionTable_deleteEditsWithZeroDuration(a1, (unint64_t)a2, v20 - (v20 > 0), v34);
      return 0;
    }
  }
  return result;
}

uint64_t compositionTable_copyAssetSegmentsFromTrackForTimeRange(uint64_t a1, unint64_t a2, CMTime *a3, uint64_t a4, void *a5, uint64_t *a6)
{
  CMTime v60 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  long long v49 = *(_OWORD *)&v60.value;
  CMTimeEpoch epoch = v60.epoch;
  memset(&v59, 0, sizeof(v59));
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a3->value;
  lhs.start.CMTimeEpoch epoch = a3->epoch;
  *(_OWORD *)&rhs.start.CMTimeValue value = *(_OWORD *)a4;
  rhs.start.CMTimeEpoch epoch = *(void *)(a4 + 16);
  CMTimeAdd(&v59, &lhs.start, &rhs.start);
  *(_OWORD *)&v58.CMTimeValue value = v49;
  v58.CMTimeEpoch epoch = epoch;
  if ((a3->flags & 0x1D) != 1) {
    goto LABEL_28;
  }
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a3->value;
  lhs.start.CMTimeEpoch epoch = a3->epoch;
  long long v50 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&rhs.start.CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v13 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  rhs.start.CMTimeEpoch epoch = v13;
  if (CMTimeCompare(&lhs.start, &rhs.start) < 0
    || (*(_DWORD *)(a4 + 12) & 0x1D) != 1
    || (*(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)a4,
        lhs.start.CMTimeEpoch epoch = *(void *)(a4 + 16),
        *(_OWORD *)&rhs.start.CMTimeValue value = v50,
        rhs.start.CMTimeEpoch epoch = v13,
        CMTimeCompare(&lhs.start, &rhs.start) < 1)
    || (unint64_t v14 = *(void *)(a1 + 32), v14 > a2)
    || v14 + 168 * *(void *)(a1 + 16) <= a2)
  {
LABEL_28:
    uint64_t v25 = 0;
    uint64_t v47 = 4294954516;
    goto LABEL_27;
  }
  if (*(uint64_t *)(a2 + 8) >= 1)
  {
    uint64_t v51 = a5;
    *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a3->value;
    lhs.start.CMTimeEpoch epoch = a3->epoch;
    uint64_t EditSegmentByTime = compositionTableTrack_findEditSegmentByTime(a2, (uint64_t)&lhs);
    lhs.CMTime start = v59;
    uint64_t v16 = compositionTableTrack_findEditSegmentByTime(a2, (uint64_t)&lhs);
    long long v17 = (_OWORD *)(*(void *)(a2 + 16) + 108 * EditSegmentByTime);
    long long v18 = v17[3];
    long long v19 = v17[5];
    *(_OWORD *)&lhs.start.CMTimeEpoch epoch = v17[4];
    *(_OWORD *)&lhs.duration.CMTimeScale timescale = v19;
    *(_OWORD *)&lhs.start.CMTimeValue value = v18;
    CMTimeRangeGetEnd(&v60, &lhs);
    uint64_t v20 = (_OWORD *)(*(void *)(a2 + 16) + 108 * v16);
    long long v21 = v20[3];
    long long v22 = v20[5];
    *(_OWORD *)&lhs.start.CMTimeEpoch epoch = v20[4];
    *(_OWORD *)&lhs.duration.CMTimeScale timescale = v22;
    *(_OWORD *)&lhs.start.CMTimeValue value = v21;
    CMTimeRangeGetEnd(&v58, &lhs);
    *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a3->value;
    lhs.start.CMTimeEpoch epoch = a3->epoch;
    rhs.CMTime start = v60;
    uint64_t v23 = v16 - EditSegmentByTime;
    if (CMTimeCompare(&lhs.start, &rhs.start) < 0) {
      uint64_t v24 = v23 + 1;
    }
    else {
      uint64_t v24 = 0;
    }
    lhs.CMTime start = v59;
    rhs.CMTime start = v58;
    if (CMTimeCompare(&lhs.start, &rhs.start) <= 0) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = v24 + 1;
    }
    if (v25 > 0)
    {
      uint64_t v26 = (CFTypeRef *)malloc_type_calloc(v25, 0x6CuLL, 0x1060040CB727B4DuLL);
      if (v26)
      {
        double v27 = (char *)v26;
        if (v24 < 1)
        {
          uint64_t v28 = v24;
        }
        else
        {
          uint64_t v28 = v23 + 1;
          compositionEditSegment_copySegmentsAndAddURLsToBag(v26, (const void *)(*(void *)(a2 + 16) + 108 * EditSegmentByTime), v24, 0);
          *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a3->value;
          lhs.start.CMTimeEpoch epoch = a3->epoch;
          *(_OWORD *)&rhs.start.CMTimeValue value = *((_OWORD *)v27 + 3);
          rhs.start.CMTimeEpoch epoch = *((void *)v27 + 8);
          if (CMTimeCompare(&lhs.start, &rhs.start) >= 1)
          {
            *(_OWORD *)&time2.CMTimeValue value = v49;
            time2.CMTimeEpoch epoch = epoch;
            *(_OWORD *)&v55.CMTimeValue value = v49;
            v55.CMTimeEpoch epoch = epoch;
            *(_OWORD *)&dur.CMTimeValue value = v49;
            dur.CMTimeEpoch epoch = epoch;
            *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&a3->value;
            lhs.start.CMTimeEpoch epoch = a3->epoch;
            *(_OWORD *)&rhs.start.CMTimeValue value = *((_OWORD *)v27 + 3);
            rhs.start.CMTimeEpoch epoch = *((void *)v27 + 8);
            CMTimeSubtract(&time2, &lhs.start, &rhs.start);
            CMTime v53 = *a3;
            long long v29 = *((_OWORD *)v27 + 4);
            *(_OWORD *)&lhs.start.CMTimeValue value = *((_OWORD *)v27 + 3);
            *(_OWORD *)&lhs.start.CMTimeEpoch epoch = v29;
            *(_OWORD *)&lhs.duration.CMTimeScale timescale = *((_OWORD *)v27 + 5);
            long long v30 = *(_OWORD *)v27;
            long long v31 = *((_OWORD *)v27 + 2);
            *(_OWORD *)&rhs.start.CMTimeEpoch epoch = *((_OWORD *)v27 + 1);
            *(_OWORD *)&rhs.duration.CMTimeScale timescale = v31;
            *(_OWORD *)&rhs.start.CMTimeValue value = v30;
            CMTimeMapTimeFromRangeToRange(&dur, &v53, &lhs, &rhs);
            lhs.CMTime start = dur;
            long long v32 = *(_OWORD *)v27;
            rhs.start.CMTimeEpoch epoch = *((void *)v27 + 2);
            *(_OWORD *)&rhs.start.CMTimeValue value = v32;
            CMTimeSubtract(&v55, &lhs.start, &rhs.start);
            long long v33 = *(_OWORD *)&a3->value;
            *((void *)v27 + 8) = a3->epoch;
            *((_OWORD *)v27 + 3) = v33;
            *(_OWORD *)&rhs.start.CMTimeValue value = *(_OWORD *)(v27 + 72);
            rhs.start.CMTimeEpoch epoch = *((void *)v27 + 11);
            CMTime v53 = time2;
            CMTimeSubtract(&lhs.start, &rhs.start, &v53);
            *(_OWORD *)(v27 + 72) = *(_OWORD *)&lhs.start.value;
            *((void *)v27 + 11) = lhs.start.epoch;
            long long v34 = *(_OWORD *)&dur.value;
            *((void *)v27 + 2) = dur.epoch;
            *(_OWORD *)double v27 = v34;
            *(_OWORD *)&rhs.start.CMTimeValue value = *(_OWORD *)(v27 + 24);
            rhs.start.CMTimeEpoch epoch = *((void *)v27 + 5);
            CMTime v53 = v55;
            CMTimeSubtract(&lhs.start, &rhs.start, &v53);
            *(_OWORD *)(v27 + 24) = *(_OWORD *)&lhs.start.value;
            *((void *)v27 + 5) = lhs.start.epoch;
          }
          lhs.CMTime start = v59;
          rhs.CMTime start = v58;
          if (CMTimeCompare(&lhs.start, &rhs.start) < 0)
          {
            memset(&time2, 0, sizeof(time2));
            long long v35 = &v27[108 * v24];
            lhs.CMTime start = v59;
            long long v36 = *(_OWORD *)(v35 - 60);
            rhs.start.CMTimeEpoch epoch = *(void *)(v35 - 44);
            *(_OWORD *)&rhs.start.CMTimeValue value = v36;
            CMTimeSubtract(&time2, &lhs.start, &rhs.start);
            memset(&v55, 0, sizeof(v55));
            CMTime dur = time2;
            long long v37 = *(_OWORD *)(v35 - 60);
            long long v38 = *(_OWORD *)(v35 - 28);
            *(_OWORD *)&lhs.start.CMTimeEpoch epoch = *(_OWORD *)(v35 - 44);
            *(_OWORD *)&lhs.duration.CMTimeScale timescale = v38;
            *(_OWORD *)&lhs.start.CMTimeValue value = v37;
            long long v39 = *(_OWORD *)(v35 - 108);
            long long v40 = *(_OWORD *)(v35 - 76);
            *(_OWORD *)&rhs.start.CMTimeEpoch epoch = *(_OWORD *)(v35 - 92);
            *(_OWORD *)&rhs.duration.CMTimeScale timescale = v40;
            *(_OWORD *)&rhs.start.CMTimeValue value = v39;
            CMTimeMapDurationFromRangeToRange(&v55, &dur, &lhs, &rhs);
            long long v41 = *(_OWORD *)&time2.value;
            *(void *)(v35 - 20) = time2.epoch;
            *(_OWORD *)(v35 - 36) = v41;
            long long v42 = *(_OWORD *)&v55.value;
            *(void *)(v35 - 68) = v55.epoch;
            *(_OWORD *)(v35 - 84) = v42;
          }
        }
        a5 = v51;
        if (v25 <= v28) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
    }
LABEL_29:
    uint64_t v47 = FigSignalErrorAt();
    goto LABEL_27;
  }
  *(_OWORD *)&v58.CMTimeValue value = v50;
  v58.CMTimeEpoch epoch = v13;
  uint64_t v25 = 1;
  double v27 = (char *)malloc_type_calloc(1uLL, 0x6CuLL, 0x1060040CB727B4DuLL);
  if (!v27) {
    goto LABEL_29;
  }
LABEL_25:
  int v43 = &v27[108 * v25];
  rhs.CMTime start = v58;
  CMTime time2 = *a3;
  CMTimeMaximum(&lhs.start, &rhs.start, &time2);
  long long v44 = *(_OWORD *)&lhs.start.value;
  *(void *)(v43 - 44) = lhs.start.epoch;
  *(_OWORD *)(v43 - 60) = v44;
  rhs.CMTime start = v59;
  long long v45 = *(_OWORD *)(v43 - 60);
  time2.CMTimeEpoch epoch = *(void *)(v43 - 44);
  *(_OWORD *)&time2.CMTimeValue value = v45;
  CMTimeSubtract(&lhs.start, &rhs.start, &time2);
  long long v46 = *(_OWORD *)&lhs.start.value;
  *(void *)(v43 - 20) = lhs.start.epoch;
  *(_OWORD *)(v43 - 36) = v46;
LABEL_26:
  uint64_t v47 = 0;
  *a6 = v25;
  *a5 = v27;
  uint64_t v25 = 0;
LABEL_27:
  compositionEditSegment_releaseSegmentsAndRemoveURLsFromBag(0, v25, 0);
  return v47;
}

void mutableComposition_addAssetsForURLsFromCompositionForSegments(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v9 = CMBaseObjectGetDerivedStorage();
  uint64_t v10 = *(void *)(DerivedStorage + 8);
  uint64_t v11 = *(void *)(v9 + 8);
  uint64_t v15 = 0;
  if (a1 != a2 && a4 >= 1)
  {
    double v12 = (const void **)(a3 + 96);
    do
    {
      if ((*((_DWORD *)v12 - 21) & 0x1D) == 1)
      {
        CMTimeEpoch v13 = *v12;
        if (*v12)
        {
          compositionSharedCache_copyAssetForAssetURLFromCache(*(void *)(v11 + 160), *v12, &v15);
          unint64_t v14 = v15;
          if (v15)
          {
            compositionTable_addAssetForURL(v10, v13, v15);
            CFRelease(v14);
            uint64_t v15 = 0;
          }
        }
      }
      double v12 = (const void **)((char *)v12 + 108);
      --a4;
    }
    while (a4);
  }
}

CMTime *compositionEditSegment_adjustSegmentStartTimes(CMTime *result, uint64_t a2, CMTime *a3)
{
  CMTime v7 = *a3;
  if (a2 >= 1)
  {
    uint64_t v3 = a2;
    uint64_t v4 = result + 2;
    do
    {
      *uint64_t v4 = v7;
      long long v5 = *(_OWORD *)&v4->epoch;
      *(_OWORD *)&v6.start.CMTimeValue value = *(_OWORD *)&v4->value;
      *(_OWORD *)&v6.start.CMTimeEpoch epoch = v5;
      *(_OWORD *)&v6.duration.CMTimeScale timescale = *(_OWORD *)&v4[1].timescale;
      uint64_t result = CMTimeRangeGetEnd(&v7, &v6);
      uint64_t v4 = (CMTime *)((char *)v4 + 108);
      --v3;
    }
    while (v3);
  }
  return result;
}

void compositionTable_addAssetForURL(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6 = *(void *)(a1 + 160);
  MEMORY[0x19970E910](*(void *)(v6 + 32));
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(v6 + 40), a2))
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v6 + 40), a2, a3);
    MEMORY[0x19970E930](*(void *)(v6 + 32));
    MEMORY[0x19970E910](*(void *)(a1 + 56));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 64), a2, a3);
  }

  JUMPOUT(0x19970E930);
}

uint64_t FigMetadataConverterGetClassID()
{
  return sFigMetadataConverterClassID;
}

uint64_t RegisterFigMetadataConverterBaseType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigMetadataConverterGetCFTypeID()
{
  MEMORY[0x19970EE10](&FigMetadataConverterGetClassID_sRegisterFigMetadataConverterBaseTypeOnce, RegisterFigMetadataConverterBaseType);

  return CMBaseClassGetCFTypeID();
}

uint64_t FigMetadataCreateConverter(CFTypeRef cf1, const void *a2, const __CFDictionary *a3, int a4, void *a5)
{
  if (!a5 || !cf1 || !a2) {
    goto LABEL_23;
  }
  if (CFEqual(cf1, @"com.apple.quicktime.udta")
    || CFEqual(cf1, @"org.mp4ra")
    || CFEqual(cf1, @"com.apple.quicktime.mdta"))
  {
    if (CFEqual(a2, @"com.apple.quicktime.udta")
      || CFEqual(a2, @"org.mp4ra")
      || CFEqual(a2, @"com.apple.quicktime.mdta"))
    {
      return FigMetadataConverterCreateForQuickTime(a4, cf1, a2, a3, a5);
    }
    CFTypeRef v11 = a2;
  }
  else
  {
    if (!CFEqual(cf1, @"com.apple.itunes")) {
      goto LABEL_23;
    }
    if (CFEqual(a2, @"com.apple.quicktime.udta")
      || CFEqual(a2, @"com.apple.quicktime.mdta")
      || CFEqual(a2, @"org.mp4ra"))
    {
      goto LABEL_20;
    }
    CFTypeRef v11 = cf1;
  }
  if (CFEqual(v11, @"com.apple.itunes"))
  {
LABEL_20:
    return FigMetadataConverterCreateForQuickTimeToFromiTunes(a4, cf1, a2, (uint64_t)a3, a5);
  }
LABEL_23:

  return FigSignalErrorAt();
}

CFStringRef FigMetadataConverterBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigMetadataConverter %p]", a1);
}

uint64_t FigPartialSampleTableBrokerGetTypeID()
{
  if (FigPartialSampleTableBrokerGetTypeID_sRegisterFigPartialSampleTableBrokerTypeOnce != -1) {
    dispatch_once_f(&FigPartialSampleTableBrokerGetTypeID_sRegisterFigPartialSampleTableBrokerTypeOnce, 0, (dispatch_function_t)registerFigPartialSampleTableBrokerType);
  }
  return sFigPartialSampleTableBrokerID;
}

uint64_t registerFigPartialSampleTableBrokerType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigPartialSampleTableBrokerID = result;
  return result;
}

uint64_t FigPartialSampleTableBrokerCreate(const __CFAllocator *a1, void *a2)
{
  if (!a2) {
    goto LABEL_10;
  }
  if (FigPartialSampleTableBrokerGetTypeID_sRegisterFigPartialSampleTableBrokerTypeOnce != -1) {
    dispatch_once_f(&FigPartialSampleTableBrokerGetTypeID_sRegisterFigPartialSampleTableBrokerTypeOnce, 0, (dispatch_function_t)registerFigPartialSampleTableBrokerType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    long long v5 = (void *)Instance;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
    v5[3] = Mutable;
    if (Mutable
      && (CFMutableArrayRef v7 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]), (v5[4] = v7) != 0)
      && (uint64_t v8 = FigSimpleMutexCreate(), (v5[2] = v8) != 0))
    {
      *a2 = v5;
      return 0;
    }
    else
    {
      uint64_t v10 = FigSignalErrorAt();
      CFRelease(v5);
      return v10;
    }
  }
  else
  {
LABEL_10:
    return FigSignalErrorAt();
  }
}

const void *FigPartialSampleTableBrokerOfferNewPartialSampleTable(uint64_t a1, const void *a2)
{
  long long v17 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  long long v18 = *MEMORY[0x1E4F1FA20];
  long long v24 = *MEMORY[0x1E4F1FA20];
  long long v25 = v17;
  long long v16 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  long long v26 = v16;
  uint64_t DecodeTimeRange = FigPartialSampleTableGetDecodeTimeRange((uint64_t)a2, &v24, 0);
  if (DecodeTimeRange) {
    return (const void *)DecodeTimeRange;
  }
  MEMORY[0x19970E910](*(void *)(a1 + 16));
  for (CFIndex i = 0; ; ++i)
  {
    CFArrayRef Count = *(const __CFArray **)(a1 + 24);
    if (Count) {
      CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
    }
    if (i >= (uint64_t)Count) {
      break;
    }
    CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
    uint64_t v7 = FigCFWeakReferenceHolderCopyReferencedObject();
    if (v7)
    {
      uint64_t v8 = (const void *)v7;
      long long v21 = v18;
      long long v22 = v17;
      long long v23 = v16;
      if ((const void *)v7 == a2)
      {
        uint64_t v10 = (const void *)FigSignalErrorAt();
        uint64_t v8 = a2;
        goto LABEL_16;
      }
      uint64_t v9 = FigPartialSampleTableGetDecodeTimeRange(v7, &v21, 0);
      if (v9)
      {
        uint64_t v10 = (const void *)v9;
        goto LABEL_16;
      }
      *(_OWORD *)&time1.CMTimeValue value = v21;
      time1.CMTimeEpoch epoch = v22;
      *(_OWORD *)&time2.CMTimeValue value = v24;
      time2.CMTimeEpoch epoch = v25;
      if (CMTimeCompare(&time1, &time2) > 0) {
        goto LABEL_14;
      }
      CFRelease(v8);
    }
    else
    {
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), i--);
    }
  }
  uint64_t v8 = 0;
LABEL_14:
  uint64_t v10 = (const void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
  CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), i, v10);
  if (v10)
  {
    CFRelease(v10);
    uint64_t v10 = 0;
  }
LABEL_16:
  MEMORY[0x19970E930](*(void *)(a1 + 16));
  if (v8) {
    CFRelease(v8);
  }
  if (!v10)
  {
    long long v24 = v18;
    long long v25 = v17;
    long long v26 = v16;
    uint64_t v10 = (const void *)FigPartialSampleTableGetDecodeTimeRange((uint64_t)a2, &v24, 0);
    if (!v10)
    {
      MEMORY[0x19970E910](*(void *)(a1 + 16));
      for (CFIndex j = 0; ; ++j)
      {
        CFArrayRef v12 = *(const __CFArray **)(a1 + 32);
        if (v12) {
          CFArrayRef v12 = (const __CFArray *)CFArrayGetCount(v12);
        }
        if (j >= (uint64_t)v12) {
          break;
        }
        CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), j);
        uint64_t v13 = FigCFWeakReferenceHolderCopyReferencedObject();
        if (v13)
        {
          unint64_t v14 = (CFMutableArrayRef *)v13;
          long long v21 = v24;
          long long v22 = v25;
          long long v23 = v26;
          if (pstBroker_tableTimeRangeIsRelevantToInterestToken(&v21, v13)) {
            CFArrayAppendValue(v14[9], a2);
          }
          CFRelease(v14);
        }
        else
        {
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 32), j--);
        }
      }
      MEMORY[0x19970E930](*(void *)(a1 + 16));
    }
  }
  return v10;
}

uint64_t FigPartialSampleTableBrokerFindAndRetainPartialSampleTableCoveringDecodeTime(uint64_t a1, uint64_t a2, void *a3)
{
  long long v3 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  *(_OWORD *)&v21.start.CMTimeValue value = *MEMORY[0x1E4F1FA20];
  *(_OWORD *)&v21.start.CMTimeEpoch epoch = v3;
  *(_OWORD *)&v21.duration.CMTimeScale timescale = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  if ((*(_DWORD *)(a2 + 12) & 0x1D) != 1 || (*(_DWORD *)(a2 + 36) & 0x1D) != 1 || !a3)
  {
    return FigSignalErrorAt();
  }
  MEMORY[0x19970E910](*(void *)(a1 + 16));
  for (CFIndex i = 0; ; ++i)
  {
    CFArrayRef Count = *(const __CFArray **)(a1 + 24);
    if (Count) {
      CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
    }
    if (i >= (uint64_t)Count)
    {
      uint64_t v10 = 0;
LABEL_17:
      *a3 = v10;
      MEMORY[0x19970E930](*(void *)(a1 + 16));
      return 0;
    }
    CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
    uint64_t v9 = FigCFWeakReferenceHolderCopyReferencedObject();
    if (!v9)
    {
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), i--);
      continue;
    }
    uint64_t v10 = (const void *)v9;
    uint64_t DecodeTimeRange = FigPartialSampleTableGetDecodeTimeRange(v9, &v21, 0);
    if (DecodeTimeRange) {
      break;
    }
    long long v12 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)a2;
    *(_OWORD *)&range.start.CMTimeEpoch epoch = v12;
    *(_OWORD *)&range.duration.CMTimeScale timescale = *(_OWORD *)(a2 + 32);
    CMTimeRangeGetEnd(&time2, &range);
    *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)&v21.start.value;
    range.start.CMTimeEpoch epoch = v21.start.epoch;
    if (CMTimeCompare(&range.start, &time2) > 0) {
      break;
    }
    CMTimeRange range = v21;
    long long v13 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)&otherRange.start.CMTimeValue value = *(_OWORD *)a2;
    *(_OWORD *)&otherRange.start.CMTimeEpoch epoch = v13;
    *(_OWORD *)&otherRange.duration.CMTimeScale timescale = *(_OWORD *)(a2 + 32);
    if (CMTimeRangeContainsTimeRange(&range, &otherRange))
    {
      CMTimeRange range = v21;
      CMTimeRangeGetEnd(&time1, &range);
      long long v14 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)a2;
      *(_OWORD *)&range.start.CMTimeEpoch epoch = v14;
      *(_OWORD *)&range.duration.CMTimeScale timescale = *(_OWORD *)(a2 + 32);
      CMTimeRangeGetEnd(&v16, &range);
      if (CMTimeCompare(&time1, &v16) > 0) {
        goto LABEL_17;
      }
    }
    CFRelease(v10);
  }
  MEMORY[0x19970E930](*(void *)(a1 + 16));
  CFRelease(v10);
  return DecodeTimeRange;
}

uint64_t FigPartialSampleTableBrokerCopyInterestTokenForAdjacentTables(uint64_t a1, uint64_t a2, __CFArray **a3)
{
  long long v24 = 0;
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v6, 2, MEMORY[0x1E4F1D510]);
  long long v8 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  *(_OWORD *)&v23.start.CMTimeValue value = *MEMORY[0x1E4F1FA20];
  *(_OWORD *)&v23.start.CMTimeEpoch epoch = v8;
  *(_OWORD *)&v23.duration.CMTimeScale timescale = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  long long v21 = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  if (!a3)
  {
    uint64_t DecodeTimeRange = FigSignalErrorAt();
LABEL_24:
    uint64_t v15 = DecodeTimeRange;
    goto LABEL_17;
  }
  uint64_t DecodeTimeRange = FigPartialSampleTableGetDecodeTimeRange(a2, &v23, (uint64_t)&v21);
  if (DecodeTimeRange) {
    goto LABEL_24;
  }
  CMTimeMake(&v19.start, 2, 1);
  long long v21 = *(_OWORD *)&v19.start.value;
  CMTimeEpoch epoch = v19.start.epoch;
  CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)a1);
  CMTimeRange v19 = v23;
  CMTimeRangeGetEnd(&v20, &v19);
  *(_OWORD *)&v19.start.CMTimeValue value = v21;
  v19.start.CMTimeEpoch epoch = epoch;
  uint64_t DecodeTimeRange = FigPartialSampleTableBrokerInterestTokenCreate(v10, (long long *)&v20.value, (long long *)&v19.start.value, 1, &v24);
  if (DecodeTimeRange) {
    goto LABEL_24;
  }
  MEMORY[0x19970E910](*(void *)(a1 + 16));
  CFTypeRef v11 = (const void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v11);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = pstBroker_associateRelevantTablesWithNewInterestToken(a1, (uint64_t)v24);
  if (v12) {
    goto LABEL_22;
  }
  CFArrayAppendValue(Mutable, v24);
  if (v24)
  {
    CFRelease(v24);
    long long v24 = 0;
  }
  CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)a1);
  *(_OWORD *)&v19.start.CMTimeValue value = *(_OWORD *)&v23.start.value;
  v19.start.CMTimeEpoch epoch = v23.start.epoch;
  long long v17 = v21;
  CMTimeEpoch v18 = epoch;
  uint64_t v12 = FigPartialSampleTableBrokerInterestTokenCreate(v13, (long long *)&v19.start.value, &v17, -1, &v24);
  if (v12) {
    goto LABEL_22;
  }
  long long v14 = (const void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v14);
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v12 = pstBroker_associateRelevantTablesWithNewInterestToken(a1, (uint64_t)v24);
  if (v12)
  {
LABEL_22:
    uint64_t v15 = v12;
  }
  else
  {
    CFArrayAppendValue(Mutable, v24);
    if (v24)
    {
      CFRelease(v24);
      long long v24 = 0;
    }
    uint64_t v15 = 0;
    *a3 = Mutable;
    CFMutableArrayRef Mutable = 0;
  }
  MEMORY[0x19970E930](*(void *)(a1 + 16));
LABEL_17:
  if (v24) {
    CFRelease(v24);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v15;
}

uint64_t FigPartialSampleTableBrokerInterestTokenCreate(const __CFAllocator *a1, long long *a2, long long *a3, char a4, void *a5)
{
  if (!a5) {
    goto LABEL_7;
  }
  if (FigPartialSampleTableBrokerInterestTokenGetTypeID_sRegisterFigPartialSampleTableBrokerInterestTokenTypeOnce != -1) {
    dispatch_once_f(&FigPartialSampleTableBrokerInterestTokenGetTypeID_sRegisterFigPartialSampleTableBrokerInterestTokenTypeOnce, 0, (dispatch_function_t)registerFigPartialSampleTableBrokerInterestTokenType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    CFTypeRef v11 = (void *)Instance;
    long long v12 = *a2;
    *(void *)(Instance + 32) = *((void *)a2 + 2);
    *(_OWORD *)(Instance + 16) = v12;
    long long v13 = *a3;
    *(void *)(Instance + 56) = *((void *)a3 + 2);
    *(_OWORD *)(Instance + 40) = v13;
    *(unsigned char *)(Instance + 64) = a4;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
    v11[9] = Mutable;
    if (Mutable)
    {
      *a5 = v11;
      return 0;
    }
    else
    {
      uint64_t v16 = FigSignalErrorAt();
      CFRelease(v11);
      return v16;
    }
  }
  else
  {
LABEL_7:
    return FigSignalErrorAt();
  }
}

uint64_t pstBroker_associateRelevantTablesWithNewInterestToken(uint64_t a1, uint64_t a2)
{
  CFIndex v4 = 0;
  long long v5 = (long long *)MEMORY[0x1E4F1FA20];
  while (1)
  {
    CFArrayRef Count = *(const __CFArray **)(a1 + 24);
    if (Count) {
      CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
    }
    if (v4 >= (uint64_t)Count) {
      return 0;
    }
    CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v4);
    uint64_t v7 = FigCFWeakReferenceHolderCopyReferencedObject();
    if (!v7)
    {
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), v4--);
      goto LABEL_11;
    }
    long long v8 = (const void *)v7;
    long long v9 = v5[1];
    long long v14 = *v5;
    long long v15 = v9;
    long long v16 = v5[2];
    uint64_t DecodeTimeRange = FigPartialSampleTableGetDecodeTimeRange(v7, &v14, 0);
    if (DecodeTimeRange) {
      break;
    }
    v13[0] = v14;
    v13[1] = v15;
    void v13[2] = v16;
    if (pstBroker_tableTimeRangeIsRelevantToInterestToken(v13, a2)) {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 72), v8);
    }
    CFRelease(v8);
LABEL_11:
    ++v4;
  }
  uint64_t v11 = DecodeTimeRange;
  CFRelease(v8);
  return v11;
}

void *FigPartialSampleTableBroker_Init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

uint64_t FigPartialSampleTableBroker_Finalize(void *a1)
{
  uint64_t v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  long long v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  uint64_t result = FigSimpleMutexDestroy();
  a1[2] = 0;
  return result;
}

__CFString *FigPartialSampleTableBroker_CopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<FigPartialSampleTableBroker %p>", a1);
  return Mutable;
}

uint64_t pstBroker_tableTimeRangeIsRelevantToInterestToken(long long *a1, uint64_t a2)
{
  if (*(char *)(a2 + 64) < 0)
  {
    CMTime start = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    *(_OWORD *)&end.CMTimeValue value = *(_OWORD *)(a2 + 16);
    CMTimeEpoch v4 = *(void *)(a2 + 32);
  }
  else
  {
    CMTime start = *(CMTime *)(a2 + 16);
    *(_OWORD *)&end.CMTimeValue value = *MEMORY[0x1E4F1FA10];
    CMTimeEpoch v4 = *(void *)(MEMORY[0x1E4F1FA10] + 16);
  }
  end.CMTimeEpoch epoch = v4;
  memset(&v22, 0, sizeof(v22));
  CMTimeRangeFromTimeToTime(&v22, &start, &end);
  long long v5 = *a1;
  long long v6 = a1[2];
  *(_OWORD *)&range.start.CMTimeEpoch epoch = a1[1];
  *(_OWORD *)&range.duration.CMTimeScale timescale = v6;
  memset(&v19, 0, sizeof(v19));
  CMTimeRange otherRange = v22;
  *(_OWORD *)&range.start.CMTimeValue value = v5;
  CMTimeRangeGetIntersection(&v19, &range, &otherRange);
  long long v7 = a1[1];
  *(_OWORD *)&range.start.CMTimeValue value = *a1;
  long long v8 = a1[2];
  *(_OWORD *)&range.start.CMTimeEpoch epoch = v7;
  *(_OWORD *)&range.duration.CMTimeScale timescale = v8;
  *(_OWORD *)&otherRange.start.CMTimeValue value = *(_OWORD *)(a2 + 16);
  otherRange.start.CMTimeEpoch epoch = *(void *)(a2 + 32);
  if (!CMTimeRangeContainsTime(&range, &otherRange.start))
  {
LABEL_10:
    CFAllocatorRef v10 = (_OWORD *)(a2 + 16);
    int v11 = *(char *)(a2 + 64);
    if (v11 < 1) {
      goto LABEL_18;
    }
    if ((v19.start.flags & 1) != 0
      && (v19.duration.flags & 1) != 0
      && !v19.duration.epoch
      && (v19.duration.value & 0x8000000000000000) == 0)
    {
      range.CMTime start = v19.duration;
      *(_OWORD *)&otherRange.start.CMTimeValue value = *MEMORY[0x1E4F1FA48];
      otherRange.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16);
      if (!CMTimeCompare(&range.start, &otherRange.start)) {
        goto LABEL_17;
      }
    }
    *(_OWORD *)&range.start.CMTimeValue value = *a1;
    range.start.CMTimeEpoch epoch = *((void *)a1 + 2);
    *(_OWORD *)&otherRange.start.CMTimeValue value = *v10;
    otherRange.start.CMTimeEpoch epoch = *(void *)(a2 + 32);
    CMTimeSubtract(&time1, &range.start, &otherRange.start);
    *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)(a2 + 40);
    range.start.CMTimeEpoch epoch = *(void *)(a2 + 56);
    if (CMTimeCompare(&time1, &range.start) >= 1)
    {
LABEL_17:
      LOBYTE(v11) = *(unsigned char *)(a2 + 64);
LABEL_18:
      if ((v11 & 0x80) == 0) {
        return 0;
      }
      if ((v19.start.flags & 1) != 0
        && (v19.duration.flags & 1) != 0
        && !v19.duration.epoch
        && (v19.duration.value & 0x8000000000000000) == 0)
      {
        range.CMTime start = v19.duration;
        *(_OWORD *)&otherRange.start.CMTimeValue value = *MEMORY[0x1E4F1FA48];
        otherRange.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16);
        if (!CMTimeCompare(&range.start, &otherRange.start)) {
          return 0;
        }
      }
      long long v12 = a1[1];
      *(_OWORD *)&range.start.CMTimeValue value = *a1;
      long long v13 = a1[2];
      *(_OWORD *)&range.start.CMTimeEpoch epoch = v12;
      *(_OWORD *)&range.duration.CMTimeScale timescale = v13;
      CMTimeRangeGetEnd(&rhs, &range);
      *(_OWORD *)&range.start.CMTimeValue value = *v10;
      range.start.CMTimeEpoch epoch = *(void *)(a2 + 32);
      CMTimeSubtract(&v15, &range.start, &rhs);
      *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)(a2 + 40);
      range.start.CMTimeEpoch epoch = *(void *)(a2 + 56);
      if (CMTimeCompare(&v15, &range.start) >= 1) {
        return 0;
      }
    }
    return 1;
  }
  if ((v19.start.flags & 1) == 0) {
    return 1;
  }
  uint64_t result = 1;
  if ((v19.duration.flags & 1) != 0 && !v19.duration.epoch && (v19.duration.value & 0x8000000000000000) == 0)
  {
    range.CMTime start = v19.duration;
    *(_OWORD *)&otherRange.start.CMTimeValue value = *MEMORY[0x1E4F1FA48];
    otherRange.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16);
    if (CMTimeCompare(&range.start, &otherRange.start)) {
      return 1;
    }
    goto LABEL_10;
  }
  return result;
}

uint64_t registerFigPartialSampleTableBrokerInterestTokenType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigPartialSampleTableBrokerInterestTokenID = result;
  return result;
}

double FigPartialSampleTableBrokerInterestToken_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void FigPartialSampleTableBrokerInterestToken_Finalize(uint64_t a1)
{
  CFAllocatorRef v2 = *(const void **)(a1 + 72);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 72) = 0;
  }
}

__CFString *FigPartialSampleTableBrokerInterestToken_CopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  CMTime time = *(CMTime *)(a1 + 16);
  Float64 Seconds = CMTimeGetSeconds(&time);
  CMTime time = *(CMTime *)(a1 + 40);
  double v5 = CMTimeGetSeconds(&time);
  char v6 = *(unsigned char *)(a1 + 64);
  CFArrayRef Count = *(const __CFArray **)(a1 + 72);
  if (Count) {
    CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
  }
  CFStringAppendFormat(Mutable, 0, @"<FigPartialSampleTableBrokerInterestToken %p - %.3f[%+.3f] - %ld candidates>", a1, *(void *)&Seconds, v5 * (double)v6, Count);
  return Mutable;
}

uint64_t FigMetadataConverterCreateForQuickTime(int a1, CFTypeRef cf1, const void *a3, const __CFDictionary *a4, void *a5)
{
  if (a5
    && cf1
    && a3
    && (CFEqual(cf1, @"com.apple.quicktime.udta")
     || CFEqual(cf1, @"org.mp4ra")
     || CFEqual(cf1, @"com.apple.quicktime.mdta"))
    && (CFEqual(a3, @"com.apple.quicktime.udta")
     || CFEqual(a3, @"org.mp4ra")
     || CFEqual(a3, @"com.apple.quicktime.mdta")))
  {
    if (CFEqual(cf1, @"com.apple.quicktime.udta") && CFEqual(a3, @"com.apple.quicktime.mdta")) {
      return 4294954814;
    }
    FigMetadataConverterGetClassID();
    uint64_t v9 = CMDerivedObjectCreate();
    if (!v9)
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
      void *DerivedStorage = CFRetain(cf1);
      DerivedStorage[1] = CFRetain(a3);
      if (a4)
      {
        CFTypeRef Value = CFDictionaryGetValue(a4, @"DestFileFormat");
        if (Value) {
          CFTypeRef Value = CFRetain(Value);
        }
        DerivedStorage[2] = Value;
      }
      uint64_t v9 = 0;
      *a5 = 0;
    }
    return v9;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void qtiso_FigMetadataConverterFinalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  uint64_t v1 = *(const void **)(DerivedStorage + 8);
  if (v1)
  {
    CFRelease(v1);
    *(void *)(DerivedStorage + 8) = 0;
  }
  CFAllocatorRef v2 = *(const void **)(DerivedStorage + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(DerivedStorage + 16) = 0;
  }
}

__CFString *qtiso_FigMetadataConverterCopyDebugDescription()
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFStringAppendFormat(Mutable, 0, @" FigQuickTimeISOMetadataConverter %p\n", DerivedStorage);
  if (*(void *)(DerivedStorage + 8)) {
    CFStringAppendFormat(Mutable, 0, @"  Destination Format = %@\n", *(void *)(DerivedStorage + 8));
  }
  return Mutable;
}

uint64_t qtiso_FigMetadataConverterCreateConvertedItem(const void *a1, const __CFDictionary *a2, const __CFAllocator *a3, __CFDictionary **a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    uint64_t v9 = DerivedStorage;
    CFStringRef v10 = (const __CFString *)CFDictionaryGetValue(a2, @"key");
    if (v10)
    {
      CFStringRef v11 = v10;
      long long v12 = (CFTypeRef *)CMBaseObjectGetDerivedStorage();
      if (CFEqual(*v12, @"com.apple.quicktime.mdta"))
      {
        uint64_t v13 = CMBaseObjectGetDerivedStorage();
        CFTypeID TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(v11))
        {
          if (CFEqual(*(CFTypeRef *)(v13 + 8), @"com.apple.quicktime.mdta"))
          {
            CFRetain(v11);
            CMTime v15 = v11;
LABEL_7:
            CFRetain(v15);
            goto LABEL_61;
          }
          if (!CFEqual(*(CFTypeRef *)(v13 + 8), @"com.apple.quicktime.udta")
            && CFEqual(*(CFTypeRef *)(v13 + 8), @"org.mp4ra")
            && (long long v32 = *(const void **)(v13 + 16)) != 0
            && (CFEqual(v32, @"iso.mp4")
             || (long long v34 = *(const void **)(v13 + 16)) != 0 && CFEqual(v34, @"iso.3gp")))
          {
            MEMORY[0x19970EE10](&gCreateKeyArrayOnce, qtiso_setUpKeyMapping);
            CMTime v15 = CFDictionaryGetValue((CFDictionaryRef)gQTMetadataKeyTo3GPKeyDict, v11);
            CFRetain(v11);
            if (v15) {
              goto LABEL_7;
            }
          }
          else
          {
            CFRetain(v11);
          }
          CFRelease(v11);
        }
        return 4294954813;
      }
      uint64_t v16 = v9;
      long long v17 = a4;
      if (CFEqual(*v12, @"org.mp4ra"))
      {
        CFMutableDictionaryRef theDict = a3;
        float valuePtr = 0.0;
        uint64_t v18 = CMBaseObjectGetDerivedStorage();
        CFDictionaryRef OSTypeKeyToStringKeyMapping = (const __CFDictionary *)FigISOUserDataGetOSTypeKeyToStringKeyMapping();
        CFTypeID v20 = CFGetTypeID(v11);
        if (v20 == CFNumberGetTypeID())
        {
          CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt32Type, &valuePtr);
          long long v21 = CFDictionaryGetValue(OSTypeKeyToStringKeyMapping, (const void *)LODWORD(valuePtr));
          a4 = v17;
          uint64_t v9 = v16;
          a3 = theDict;
          if (!v21 || (CFStringRef v11 = (const __CFString *)CFRetain(v21)) == 0)
          {
            float valuePtr = COERCE_FLOAT(bswap32(LODWORD(valuePtr)));
            CFAllocatorRef v22 = CFGetAllocator(a1);
            CFStringRef v11 = CFStringCreateWithFormat(v22, 0, @"%c%c%c%c", SLOBYTE(valuePtr), SBYTE1(valuePtr), SBYTE2(valuePtr), SHIBYTE(valuePtr));
            if (!v11) {
              goto LABEL_59;
            }
          }
LABEL_19:
          CMTime v15 = v11;
          if (CFEqual(*(CFTypeRef *)(v18 + 8), @"org.mp4ra")) {
            goto LABEL_50;
          }
          if (CFEqual(*(CFTypeRef *)(v18 + 8), @"com.apple.quicktime.udta"))
          {
            long long v26 = &g3GPKeyToUserDataKeyDict;
            goto LABEL_47;
          }
          if (CFEqual(*(CFTypeRef *)(v18 + 8), @"com.apple.quicktime.mdta"))
          {
            long long v26 = &g3GPKeyToQTMetadataKeyDict;
LABEL_47:
            MEMORY[0x19970EE10](&gCreateKeyArrayOnce, qtiso_setUpKeyMapping);
            CMTime v15 = CFDictionaryGetValue((CFDictionaryRef)*v26, v11);
            a3 = theDict;
            if (!v15) {
              goto LABEL_60;
            }
            goto LABEL_50;
          }
LABEL_59:
          CMTime v15 = 0;
          goto LABEL_60;
        }
        CFTypeID v25 = CFGetTypeID(v11);
        if (v25 == CFStringGetTypeID())
        {
          CFStringRef v11 = (const __CFString *)CFRetain(v11);
          a4 = v17;
          uint64_t v9 = v16;
          a3 = theDict;
          if (!v11) {
            goto LABEL_59;
          }
          goto LABEL_19;
        }
        CFStringRef v11 = 0;
      }
      else
      {
        if (!CFEqual(*v12, @"com.apple.quicktime.udta")) {
          return 4294954813;
        }
        CFMutableDictionaryRef theDict = a3;
        float valuePtr = 0.0;
        uint64_t v65 = CMBaseObjectGetDerivedStorage();
        CFDictionaryRef v23 = (const __CFDictionary *)FigUserDataGetOSTypeKeyToStringKeyMapping();
        CFTypeID v24 = CFGetTypeID(v11);
        if (v24 == CFNumberGetTypeID())
        {
          CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt32Type, &valuePtr);
        }
        else
        {
          CFTypeID v28 = CFGetTypeID(v11);
          if (v28 != CFStringGetTypeID()
            || !FigUserDataStringKeyToOSTypeKey(v11, (unsigned int *)&valuePtr))
          {
            CMTime v15 = 0;
            CFStringRef v11 = 0;
            goto LABEL_44;
          }
        }
        long long v29 = CFDictionaryGetValue(v23, (const void *)LODWORD(valuePtr));
        if (v29 && (CFStringRef v11 = (const __CFString *)CFRetain(v29)) != 0
          || (float valuePtr = COERCE_FLOAT(bswap32(LODWORD(valuePtr))),
              CFAllocatorRef v30 = CFGetAllocator(a1),
              (CFStringRef v11 = CFStringCreateWithFormat(v30, 0, @"%c%c%c%c", SLOBYTE(valuePtr), SBYTE1(valuePtr), SBYTE2(valuePtr), SHIBYTE(valuePtr))) != 0))
        {
          if (CFEqual(*(CFTypeRef *)(v65 + 8), @"org.mp4ra"))
          {
            long long v31 = *(const void **)(v65 + 16);
            a3 = theDict;
            if (!v31)
            {
              CMTime v15 = 0;
              uint64_t v9 = v16;
              goto LABEL_60;
            }
            uint64_t v9 = v16;
            if (!CFEqual(v31, @"iso.mp4"))
            {
              long long v33 = *(const void **)(v65 + 16);
              if (!v33 || !CFEqual(v33, @"iso.3gp")) {
                goto LABEL_59;
              }
            }
            MEMORY[0x19970EE10](&gCreateKeyArrayOnce, qtiso_setUpKeyMapping);
            CMTime v15 = CFDictionaryGetValue((CFDictionaryRef)gUserDataKeyTo3GPKeyDict, v11);
            if (!v15)
            {
LABEL_60:
              if (!v15)
              {
                MutableCFStringRef Copy = 0;
                uint64_t v27 = 4294954813;
                char v37 = 1;
                goto LABEL_96;
              }
LABEL_61:
              if (a4)
              {
                if (CFEqual(v11, v15))
                {
                  CFIndex Count = CFDictionaryGetCount(a2);
                  MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(a3, Count, a2);
LABEL_90:
                  if (CFEqual(*(CFTypeRef *)(v9 + 8), @"com.apple.quicktime.mdta"))
                  {
                    uint64_t v54 = kFigQuickTimeMetadataKeyspace;
                  }
                  else
                  {
                    int v55 = CFEqual(*(CFTypeRef *)(v9 + 8), @"com.apple.quicktime.udta");
                    uint64_t v54 = kFigUserDataKeyspace;
                    if (!v55) {
                      uint64_t v54 = kFigISOUserDataKeyspace;
                    }
                  }
                  CFDictionarySetValue(MutableCopy, @"keyspace", *v54);
                  char v37 = 0;
                  uint64_t v27 = 0;
                  *a4 = MutableCopy;
                  goto LABEL_95;
                }
                long long v64 = a4;
                uint64_t v66 = v9;
                theDicta = CFDictionaryCreateMutable(a3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                if (theDicta)
                {
                  CFStringRef v38 = (const __CFString *)CFDictionaryGetValue(a2, @"value");
                  long long v39 = CFDictionaryGetValue(a2, @"locale");
                  long long v40 = CFDictionaryGetValue(a2, @"languageCode");
                  if (CFEqual(v15, @"yrrc"))
                  {
                    CMTimeValue value = (void *)v15;
                    CFTypeID v41 = CFGetTypeID(v38);
                    if (v41 == CFNumberGetTypeID())
                    {
LABEL_83:
                      MutableCFStringRef Copy = theDicta;
                      CFDictionaryAddValue(theDicta, @"key", v15);
                      CFDictionaryAddValue(theDicta, @"value", v38);
                      a4 = v64;
                      goto LABEL_90;
                    }
                    CFTypeID v47 = CFGetTypeID(v38);
                    MutableCFStringRef Copy = theDicta;
                    if (v47 == CFStringGetTypeID())
                    {
                      float valuePtr = COERCE_FLOAT(CFStringGetIntValue(v38));
                      if ((LODWORD(valuePtr) & 0x80000000) != 0)
                      {
                        uint64_t v27 = 4294954813;
                      }
                      else
                      {
                        CFNumberRef v48 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
                        if (v48)
                        {
                          CFTypeRef v46 = v48;
                          CFDictionaryAddValue(theDicta, @"key", v15);
                          CFDictionaryAddValue(theDicta, @"value", v46);
LABEL_89:
                          CFRelease(v46);
                          goto LABEL_90;
                        }
                        uint64_t v27 = FigSignalErrorAt();
                      }
                      char v37 = 0;
                      goto LABEL_131;
                    }
LABEL_103:
                    char v37 = 0;
                    uint64_t v27 = 4294954813;
                    goto LABEL_96;
                  }
                  if (CFEqual(v15, @"com.apple.quicktime.year"))
                  {
                    CFAllocatorRef v42 = a3;
                    CFTypeID v43 = CFGetTypeID(v38);
                    if (v43 == CFNumberGetTypeID())
                    {
                      LOWORD(valuePtr) = 0;
                      MutableCFStringRef Copy = theDicta;
                      if (CFNumberGetValue((CFNumberRef)v38, kCFNumberSInt16Type, &valuePtr))
                      {
                        CFAllocatorRef v44 = v42;
                        CFStringRef v45 = CFStringCreateWithFormat(v42, 0, @"%d", SLOWORD(valuePtr));
                        if (v45)
                        {
                          CFTypeRef v46 = v45;
                          goto LABEL_86;
                        }
                        uint64_t v27 = FigSignalErrorAt();
                      }
                      else
                      {
                        uint64_t v27 = 4294954813;
                      }
                      char v37 = 0;
                      goto LABEL_96;
                    }
                    CFTypeID v51 = CFGetTypeID(v38);
                    MutableCFStringRef Copy = theDicta;
                    if (v51 != CFStringGetTypeID()) {
                      goto LABEL_103;
                    }
                    CFTypeRef v46 = CFRetain(v38);
                    CFAllocatorRef v44 = v42;
LABEL_86:
                    CFDictionaryAddValue(MutableCopy, @"key", v15);
                    CFDictionaryAddValue(MutableCopy, @"value", v46);
                    CFLocaleRef v52 = CFLocaleCreate(v44, @"en");
                    if (v52)
                    {
                      CFLocaleRef v53 = v52;
                      CFDictionaryAddValue(MutableCopy, @"locale", v52);
                      CFRelease(v53);
                    }
                    if (!v46) {
                      goto LABEL_90;
                    }
                    goto LABEL_89;
                  }
                  CFStringRef v49 = v38;
                  if (CFEqual(v15, @"com.apple.quicktime.rating.user") || CFEqual(v15, @"urat"))
                  {
                    float valuePtr = 0.0;
                    CFTypeID v50 = CFGetTypeID(v38);
                    if (v50 == CFNumberGetTypeID())
                    {
                      CFNumberGetValue((CFNumberRef)v38, kCFNumberFloat32Type, &valuePtr);
                      if (valuePtr >= 0.0 && valuePtr <= 5.0) {
                        goto LABEL_83;
                      }
                    }
                    char v37 = 0;
                    uint64_t v27 = 4294954813;
LABEL_132:
                    MutableCFStringRef Copy = theDicta;
                    goto LABEL_96;
                  }
                  CMTimeValue value = (void *)v15;
                  if (CFEqual(v15, @"com.apple.quicktime.artwork") || CFEqual(v15, @"thmb"))
                  {
                    long long v57 = CFDictionaryGetValue(a2, @"dataType");
                    CMTime v58 = CFDictionaryGetValue(a2, @"dataTypeNamespace");
                    CFTypeID v59 = CFGetTypeID(v49);
                    char v37 = 0;
                    uint64_t v27 = 4294954813;
                    MutableCFStringRef Copy = theDicta;
                    if (v59 != CFDataGetTypeID() || !v57) {
                      goto LABEL_96;
                    }
                    CFDictionaryAddValue(theDicta, @"dataType", v57);
                    if (v58) {
                      CFDictionaryAddValue(theDicta, @"dataTypeNamespace", v58);
                    }
                    CFDictionaryAddValue(theDicta, @"key", v15);
                    CFDictionaryAddValue(theDicta, @"value", v49);
                    a4 = v64;
                    uint64_t v9 = v66;
                    goto LABEL_90;
                  }
                  CFTypeID v60 = CFGetTypeID(v38);
                  if (v60 != CFStringGetTypeID())
                  {
                    char v37 = 0;
                    uint64_t v27 = 4294954813;
LABEL_131:
                    CMTime v15 = value;
                    goto LABEL_132;
                  }
                  CFDictionaryAddValue(theDicta, @"key", v15);
                  CFDictionaryAddValue(theDicta, @"value", v38);
                  if (v39)
                  {
                    CFDictionaryAddValue(theDicta, @"locale", v39);
                    a4 = v64;
                    CMTime v61 = v40;
                    if (!v40)
                    {
LABEL_126:
                      MutableCFStringRef Copy = theDicta;
                      goto LABEL_90;
                    }
                  }
                  else
                  {
                    a4 = v64;
                    CMTime v61 = v40;
                    if (!v40)
                    {
                      LOWORD(valuePtr) = FigMetadataGetPackedISO639_2T(@"und");
                      CFNumberRef v62 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt16Type, &valuePtr);
                      CFDictionaryAddValue(theDicta, @"languageCode", v62);
                      if (v62) {
                        CFRelease(v62);
                      }
                      a4 = v64;
                      goto LABEL_126;
                    }
                  }
                  MutableCFStringRef Copy = theDicta;
                  CFDictionaryAddValue(theDicta, @"languageCode", v61);
                  goto LABEL_90;
                }
                uint64_t v27 = FigSignalErrorAt();
                char v37 = 0;
              }
              else
              {
                char v37 = 0;
                uint64_t v27 = 0;
              }
LABEL_95:
              MutableCFStringRef Copy = 0;
LABEL_96:
              if (v11) {
                CFRelease(v11);
              }
              if ((v37 & 1) == 0) {
                CFRelease(v15);
              }
              if (MutableCopy) {
                CFRelease(MutableCopy);
              }
              return v27;
            }
LABEL_50:
            CFRetain(v15);
            goto LABEL_60;
          }
          CMTime v15 = v11;
          uint64_t v9 = v16;
          a3 = theDict;
          if (CFEqual(*(CFTypeRef *)(v65 + 8), @"com.apple.quicktime.udta")) {
            goto LABEL_50;
          }
          CFEqual(*(CFTypeRef *)(v65 + 8), @"com.apple.quicktime.mdta");
          goto LABEL_59;
        }
      }
      CMTime v15 = 0;
LABEL_44:
      a4 = v17;
      uint64_t v9 = v16;
      a3 = theDict;
      goto LABEL_60;
    }
  }

  return FigSignalErrorAt();
}

CFDictionaryRef qtiso_setUpKeyMapping()
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  keys[0] = @"@cpy";
  keys[1] = @"@day";
  values[0] = @"cprt";
  values[1] = @"date";
  v7[0] = @"cprt";
  v8[0] = @"com.apple.quicktime.copyright";
  v8[1] = @"com.apple.quicktime.creationdate";
  v7[1] = @"date";
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFAllocatorRef v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  gUserDataKeyToMP4KeyDict = (uint64_t)CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  gQTMetadataKeyToMP4KeyDict = (uint64_t)CFDictionaryCreate(v0, (const void **)v8, (const void **)v7, 2, v1, v2);
  uint64_t v54 = @"@cpy";
  int v55 = @"@aut";
  uint64_t v56 = @"@prf";
  long long v57 = @"@prd";
  CMTime v58 = @"@pub";
  CFTypeID v59 = @"@dir";
  CFTypeID v60 = @"@ART";
  CMTime v61 = @"@ope";
  CFNumberRef v62 = @"@gen";
  CFTypeRef v63 = @"@xyz";
  long long v64 = @"@nam";
  uint64_t v65 = @"tnam";
  uint64_t v66 = @"@des";
  long long v67 = @"@inf";
  uint64_t v68 = @"tagc";
  CMTimeValue v69 = @"@day";
  CMTimeScale v70 = @"ludt";
  long long v35 = @"cprt";
  long long v36 = @"auth";
  char v37 = @"perf";
  CFStringRef v38 = @"perf";
  long long v39 = @"perf";
  long long v40 = @"perf";
  CFTypeID v41 = @"perf";
  CFAllocatorRef v42 = @"perf";
  CFTypeID v43 = @"gnre";
  CFAllocatorRef v44 = @"loci";
  CFStringRef v45 = @"titl";
  CFTypeRef v46 = @"titl";
  CFTypeID v47 = @"dscp";
  CFNumberRef v48 = @"dscp";
  CFStringRef v49 = @"tagc";
  CFTypeID v50 = @"date";
  CFTypeID v51 = @"ludt";
  CFDictionaryRef v23 = @"cprt";
  CFTypeID v24 = @"auth";
  CFTypeID v25 = @"perf";
  long long v26 = @"gnre";
  uint64_t v27 = @"loci";
  CFTypeID v28 = @"titl";
  long long v29 = @"dscp";
  CFAllocatorRef v30 = @"tagc";
  long long v31 = @"date";
  long long v32 = @"ludt";
  CFStringRef v11 = @"@cpy";
  long long v12 = @"@aut";
  uint64_t v13 = @"@prf";
  long long v14 = @"@gen";
  CMTime v15 = @"@xyz";
  uint64_t v16 = @"@nam";
  long long v17 = @"@des";
  uint64_t v18 = @"tagc";
  CMTimeRange v19 = @"@day";
  CFTypeID v20 = @"ludt";
  long long v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CMTimeEpoch v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  gUserDataKeyTo3GPKeyDict = (uint64_t)CFDictionaryCreate(allocator, (const void **)&v54, (const void **)&v35, 17, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  g3GPKeyToUserDataKeyDict = (uint64_t)CFDictionaryCreate(allocator, (const void **)&v23, (const void **)&v11, 10, v3, v4);
  uint64_t v54 = @"com.apple.quicktime.copyright";
  int v55 = @"com.apple.quicktime.author";
  uint64_t v56 = @"com.apple.quicktime.genre";
  long long v57 = @"com.apple.quicktime.location.ISO6709";
  CMTime v58 = @"com.apple.quicktime.displayname";
  CFTypeID v59 = @"com.apple.quicktime.title";
  CFTypeID v60 = @"com.apple.quicktime.year";
  CMTime v61 = @"com.apple.quicktime.creationdate";
  CFNumberRef v62 = @"com.apple.quicktime.description";
  CFTypeRef v63 = @"com.apple.quicktime.information";
  long long v64 = @"com.apple.quicktime.performer";
  uint64_t v65 = @"com.apple.quicktime.producer";
  uint64_t v66 = @"com.apple.quicktime.publisher";
  long long v67 = @"com.apple.quicktime.director";
  uint64_t v68 = @"com.apple.quicktime.artist";
  CMTimeValue v69 = @"com.apple.quicktime.originalartist";
  CMTimeScale v70 = @"com.apple.quicktime.rating.user";
  uint64_t v71 = @"com.apple.quicktime.collection.user";
  CFAllocatorRef v72 = @"com.apple.quicktime.artwork";
  long long v35 = @"cprt";
  long long v36 = @"auth";
  char v37 = @"gnre";
  CFStringRef v38 = @"loci";
  long long v39 = @"titl";
  long long v40 = @"titl";
  CFTypeID v41 = @"yrrc";
  CFAllocatorRef v42 = @"date";
  CFTypeID v43 = @"dscp";
  CFAllocatorRef v44 = @"dscp";
  CFStringRef v45 = @"perf";
  CFTypeRef v46 = @"perf";
  CFTypeID v47 = @"perf";
  CFNumberRef v48 = @"perf";
  CFStringRef v49 = @"perf";
  CFTypeID v50 = @"perf";
  CFTypeID v51 = @"urat";
  CFLocaleRef v52 = @"coll";
  CFLocaleRef v53 = @"thmb";
  CFDictionaryRef v23 = @"cprt";
  CFTypeID v24 = @"auth";
  CFTypeID v25 = @"gnre";
  long long v26 = @"loci";
  uint64_t v27 = @"titl";
  CFTypeID v28 = @"yrrc";
  long long v29 = @"date";
  CFAllocatorRef v30 = @"dscp";
  long long v31 = @"perf";
  long long v32 = @"urat";
  long long v33 = @"coll";
  long long v34 = @"thmb";
  CFStringRef v11 = @"com.apple.quicktime.copyright";
  long long v12 = @"com.apple.quicktime.author";
  uint64_t v13 = @"com.apple.quicktime.genre";
  long long v14 = @"com.apple.quicktime.location.ISO6709";
  CMTime v15 = @"com.apple.quicktime.displayname";
  uint64_t v16 = @"com.apple.quicktime.year";
  long long v17 = @"com.apple.quicktime.creationdate";
  uint64_t v18 = @"com.apple.quicktime.description";
  CMTimeRange v19 = @"com.apple.quicktime.performer";
  CFTypeID v20 = @"com.apple.quicktime.rating.user";
  long long v21 = @"com.apple.quicktime.collection.user";
  CFAllocatorRef v22 = @"com.apple.quicktime.artwork";
  gQTMetadataKeyTo3GPKeyDict = (uint64_t)CFDictionaryCreate(allocator, (const void **)&v54, (const void **)&v35, 19, v3, v4);
  CFDictionaryRef result = CFDictionaryCreate(allocator, (const void **)&v23, (const void **)&v11, 12, v3, v4);
  g3GPKeyToQTMetadataKeyDict = (uint64_t)result;
  return result;
}

uint64_t FigCDSNotificationInputCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a1 && a2 && a3 && a5)
  {
    *a5 = 0;
    FigCDSInputGetClassID();
    CMDerivedObjectCreate();
  }
  return FigSignalErrorAt();
}

uint64_t FigCDSNotificationInputSetPlayer(uint64_t a1, uint64_t a2)
{
  v4[0] = CMBaseObjectGetDerivedStorage();
  v4[1] = a2;
  if (*(void *)v4[0]) {
    dispatch_sync_f(*(dispatch_queue_t *)v4[0], v4, (dispatch_function_t)setPlayerDo_1);
  }
  return 0;
}

void setPlayerDo_1(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFAllocatorRef v2 = (const void *)a1[1];
  if (*(void *)(*a1 + 8))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterRemoveListener();
    long long v3 = *(const void **)(v1 + 8);
  }
  else
  {
    long long v3 = 0;
  }
  *(void *)(v1 + 8) = v2;
  if (v2) {
    CFRetain(v2);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (*(void *)(v1 + 8))
  {
    uint64_t v8 = 0;
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterAddListener();
    uint64_t FigBaseObject = FigPlayerGetFigBaseObject(*(void *)(v1 + 8));
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    long long v7 = *(void (**)(uint64_t, __CFString *, void, uint64_t *))(v6 + 48);
    if (v7)
    {
      v7(FigBaseObject, @"LastSentSubtitleSample", *MEMORY[0x1E4F1CF80], &v8);
      if (v8)
      {
        v9[0] = v1;
        v9[1] = v8;
        digestSubtitleSampleDo_2(v9);
      }
    }
  }
}

uint64_t FigCDSNotificationInputSetNonForcedSubtitleDisplay(uint64_t a1, unsigned __int8 a2)
{
  v4[0] = CMBaseObjectGetDerivedStorage();
  v4[1] = a2;
  if (*(void *)v4[0]) {
    dispatch_sync_f(*(dispatch_queue_t *)v4[0], v4, (dispatch_function_t)SetNonForcedSubtitleDisplayEnabledDo);
  }
  return 0;
}

unsigned __int8 *SetNonForcedSubtitleDisplayEnabledDo(unsigned __int8 *result)
{
  int v1 = result[8];
  if (*(unsigned __int8 *)(*(void *)result + 40) != v1) {
    *(unsigned char *)(*(void *)result + 40) = v1;
  }
  return result;
}

void figCDSNotificationInput_Finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)(DerivedStorage + 8))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterRemoveListener();
    int v1 = *(const void **)(DerivedStorage + 8);
    if (v1)
    {
      CFRelease(v1);
      *(void *)(DerivedStorage + 8) = 0;
    }
  }
  if (*(void *)DerivedStorage)
  {
    dispatch_release(*(dispatch_object_t *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
}

__CFString *figCDSNotificationInput_CopyDebugDescription(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigCDSNotificationInput %p>", a1);
  return Mutable;
}

void subtitleChangedCallback_0(int a1, dispatch_queue_t *a2, int a3, int a4, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeRef v6 = CFRetain(cf);
    if (v6)
    {
      v7[0] = a2;
      v7[1] = v6;
      if (*a2) {
        dispatch_sync_f(*a2, v7, (dispatch_function_t)digestSubtitleSampleDo_2);
      }
    }
  }
}

void digestSubtitleSampleDo_2(uint64_t *a1)
{
  uint64_t v2 = *a1;
  CFDictionaryRef v1 = (const __CFDictionary *)a1[1];
  CFDictionaryRef theDict = 0;
  char v59 = 0;
  if (FigSubtitleSampleCreateFromPropertyListAndInsertInfoForRenderer(v1, &theDict, &v59, *MEMORY[0x1E4F1DB20], *(CGFloat *)(MEMORY[0x1E4F1DB20] + 8), *(CGFloat *)(MEMORY[0x1E4F1DB20] + 16), *(CGFloat *)(MEMORY[0x1E4F1DB20] + 24)))goto LABEL_56; {
  if (!theDict)
  }
    goto LABEL_55;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"SubtitleContentMetadata");
  if (Value)
  {
    CFDictionaryRef v4 = (const __CFDictionary *)CFDictionaryGetValue(Value, (const void *)*MEMORY[0x1E4F1F818]);
    int64_t Count = CFDictionaryGetCount(v4);
    if (Count >= 1)
    {
      size_t v6 = Count;
      long long v7 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
      uint64_t v8 = (const void **)malloc_type_calloc(v6, 8uLL, 0xC0040B8AA526DuLL);
      CFDictionaryGetKeysAndValues(v4, v7, v8);
      uint64_t v9 = 0;
      uint64_t v56 = (void *)*MEMORY[0x1E4F1F8A0];
      key = (void *)*MEMORY[0x1E4F1F888];
      int v55 = (void *)*MEMORY[0x1E4F1F890];
      do
      {
        CFStringRef v10 = v8[v9];
        if (v10)
        {
          CFTypeID v11 = CFGetTypeID(v10);
          if (v11 == CFDictionaryGetTypeID())
          {
            long long v12 = v7[v9];
            if (v12)
            {
              CFTypeID v13 = CFGetTypeID(v12);
              if (v13 == CFStringGetTypeID())
              {
                long long v14 = v7[v9];
                CFDictionaryRef v15 = (const __CFDictionary *)v8[v9];
                CFTypeRef cf = 0;
                FigCDSStackLayoutRegionCreate(&cf);
                double v66 = 0.0;
                unsigned int valuePtr = 0;
                double v63 = 0.0;
                double v64 = 0.0;
                double v61 = 0.0;
                double v62 = 0.0;
                CFTypeRef v16 = cf;
                FigCDSRegionProtocolGetProtocolID();
                Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
                if (ProtocolVTable)
                {
                  uint64_t v18 = *(void *)(ProtocolVTable + 16);
                  if (v18)
                  {
                    CMTimeRange v19 = *(void (**)(CFTypeRef, const void *))(v18 + 8);
                    if (v19) {
                      v19(v16, v14);
                    }
                  }
                }
                if (FigCFDictionaryGetCGFloatIfPresent())
                {
                  CFTypeRef v20 = cf;
                  double v21 = v66;
                  FigCDSRegionProtocolGetProtocolID();
                  uint64_t v22 = CMBaseObjectGetProtocolVTable();
                  if (v22)
                  {
                    uint64_t v23 = *(void *)(v22 + 16);
                    if (v23)
                    {
                      CFTypeID v24 = *(void (**)(CFTypeRef, void))(v23 + 24);
                      if (v24) {
                        v24(v20, (int)v21);
                      }
                    }
                  }
                  CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(v15, key);
                  if (v25)
                  {
                    CFNumberGetValue(v25, kCFNumberIntType, &valuePtr);
                    CFTypeRef v26 = cf;
                    uint64_t v27 = valuePtr;
                    FigCDSRegionProtocolGetProtocolID();
                    uint64_t v28 = CMBaseObjectGetProtocolVTable();
                    if (v28)
                    {
                      uint64_t v29 = *(void *)(v28 + 16);
                      if (v29)
                      {
                        CFAllocatorRef v30 = *(void (**)(CFTypeRef, uint64_t))(v29 + 40);
                        if (v30) {
                          v30(v26, v27);
                        }
                      }
                    }
                    if (CFDictionaryGetValue(v15, v56)
                      && FigCFDictionaryGetCGFloatIfPresent()
                      && FigCFDictionaryGetCGFloatIfPresent())
                    {
                      CFTypeRef v31 = cf;
                      double v33 = v63;
                      double v32 = v64;
                      FigCDSRegionProtocolGetProtocolID();
                      uint64_t v34 = CMBaseObjectGetProtocolVTable();
                      if (v34)
                      {
                        uint64_t v35 = *(void *)(v34 + 16);
                        if (v35)
                        {
                          long long v36 = *(void (**)(CFTypeRef, double, double))(v35 + 72);
                          if (v36) {
                            v36(v31, v32, 100.0 - v33);
                          }
                        }
                      }
                      if (CFDictionaryGetValue(v15, v55)
                        && FigCFDictionaryGetCGFloatIfPresent()
                        && FigCFDictionaryGetCGFloatIfPresent())
                      {
                        CFTypeRef v37 = cf;
                        double v39 = v61;
                        double v38 = v62;
                        FigCDSRegionProtocolGetProtocolID();
                        uint64_t v40 = CMBaseObjectGetProtocolVTable();
                        if (v40)
                        {
                          uint64_t v41 = *(void *)(v40 + 16);
                          if (v41)
                          {
                            CFAllocatorRef v42 = *(void (**)(CFTypeRef, double, double))(v41 + 56);
                            if (v42) {
                              v42(v37, v38, v39);
                            }
                          }
                        }
                        (*(void (**)(CFTypeRef, void))(v2 + 24))(cf, *(void *)(v2 + 32));
                      }
                    }
                  }
                }
                if (cf) {
                  CFRelease(cf);
                }
              }
            }
          }
        }
        ++v9;
      }
      while (v6 != v9);
      free(v7);
      free(v8);
    }
  }
  int v58 = 0;
  CFNumberRef v43 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"SubtitleFormat");
  CFNumberGetValue(v43, kCFNumberSInt32Type, &v58);
  if (((v58 - 2004251764) & 0xFEFFFFFF) != 0) {
    uint64_t v44 = 3;
  }
  else {
    uint64_t v44 = 4;
  }
  CFArrayRef v45 = (const __CFArray *)CFDictionaryGetValue(theDict, @"SubtitleTimeRange");
  CFTypeRef v46 = CFDictionaryGetValue(theDict, @"kFigSubtitleRenderer_TextBox");
  CFTypeID v47 = CFDictionaryGetValue(theDict, @"SubtitleExtendedLanguageTag");
  CFArrayRef v48 = (const __CFArray *)CFDictionaryGetValue(theDict, @"SubtitleContent");
  if (v48)
  {
    CFArrayRef v49 = v48;
    CFIndex v50 = CFArrayGetCount(v48);
    if (v50)
    {
      CFIndex v51 = v50;
      if (v50 >= 1)
      {
        for (CFIndex i = 0; i != v51; ++i)
        {
          CFAttributedStringRef ValueAtIndex = (const __CFAttributedString *)CFArrayGetValueAtIndex(v49, i);
          if (ValueAtIndex)
          {
            CFAttributedStringRef v54 = ValueAtIndex;
            if (CFAttributedStringGetLength(ValueAtIndex)) {
              outputCueAsFigCDSCaption_0(v2, v44, v45, (uint64_t)v47, v46, v54);
            }
          }
        }
      }
      goto LABEL_56;
    }
LABEL_55:
    outputCueAsFigCDSCaption_0(v2, 5, 0, 0, 0, 0);
  }
LABEL_56:
  if (theDict) {
    CFRelease(theDict);
  }
  if (v1) {
    CFRelease(v1);
  }
}

void outputCueAsFigCDSCaption_0(uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4, const void *a5, const __CFAttributedString *a6)
{
  effectiveRange.locatiouint64_t n = 0;
  effectiveRange.length = 0;
  CFTypeRef cf = 0;
  FigCDSCaptionCreate(&cf);
  CFTypeRef v12 = cf;
  FigCDSCaptionProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (ProtocolVTable)
  {
    uint64_t v15 = *(void *)(ProtocolVTable + 16);
    ProtocolVTable += 16;
    uint64_t v14 = v15;
    if (v15)
    {
      CFTypeRef v16 = *(uint64_t (**)(CFTypeRef, uint64_t))(v14 + 40);
      if (v16) {
        Protocoluint64_t VTable = v16(v12, a2);
      }
    }
  }
  if (a2 == 5)
  {
    (*(void (**)(CFTypeRef, void))(a1 + 16))(cf, *(void *)(a1 + 32));
LABEL_7:
    CFMutableArrayRef Mutable = 0;
    goto LABEL_45;
  }
  if (!a6) {
    goto LABEL_7;
  }
  if (a3)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, 0);
    CFDictionaryRef v19 = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, 1);
    memset(&v54, 0, sizeof(v54));
    CMTimeMakeFromDictionary(&v54, ValueAtIndex);
    memset(&v53, 0, sizeof(v53));
    CMTimeMakeFromDictionary(&v53, v19);
    CMTime v52 = v54;
    CMTimeGetSeconds(&v52);
    CMTime v52 = v53;
    CMTimeGetSeconds(&v52);
  }
  CFTypeRef v20 = cf;
  double FigBaseObject = FigBytePumpGetFigBaseObject(ProtocolVTable);
  double v23 = v22;
  FigCDSIntervalProtocolGetProtocolID();
  uint64_t v24 = CMBaseObjectGetProtocolVTable();
  if (v24)
  {
    uint64_t v25 = *(void *)(v24 + 16);
    if (v25)
    {
      CFTypeRef v26 = *(void (**)(CFTypeRef, double, double))(v25 + 16);
      if (v26) {
        v26(v20, FigBaseObject, v23);
      }
    }
  }
  CFTypeRef v27 = cf;
  FigCDSCaptionProtocolGetProtocolID();
  uint64_t v28 = CMBaseObjectGetProtocolVTable();
  if (v28)
  {
    uint64_t v29 = *(void *)(v28 + 16);
    if (v29)
    {
      CFAllocatorRef v30 = *(void (**)(CFTypeRef, uint64_t))(v29 + 56);
      if (v30) {
        v30(v27, a4);
      }
    }
  }
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFTypeRef v31 = cf;
  FigCDSCaptionProtocolGetProtocolID();
  uint64_t v32 = CMBaseObjectGetProtocolVTable();
  if (v32)
  {
    uint64_t v33 = *(void *)(v32 + 16);
    if (v33)
    {
      uint64_t v34 = *(void (**)(CFTypeRef, __CFDictionary *))(v33 + 8);
      if (v34) {
        v34(v31, Mutable);
      }
    }
  }
  CFTypeRef Attribute = CFAttributedStringGetAttribute(a6, 0, (CFStringRef)*MEMORY[0x1E4F1F690], &effectiveRange);
  if (Attribute) {
    CFDictionarySetValue(Mutable, @"region", Attribute);
  }
  if (a5) {
    CFDictionarySetValue(Mutable, @"textbox", a5);
  }
  if (a2 == 4)
  {
    long long v36 = (const void *)*MEMORY[0x1E4F1F720];
    CFTypeRef v37 = CFAttributedStringGetAttribute(a6, 0, (CFStringRef)*MEMORY[0x1E4F1F720], &effectiveRange);
    if (v37) {
      CFDictionarySetValue(Mutable, v36, v37);
    }
    double v38 = (const void *)*MEMORY[0x1E4F1F700];
    CFTypeRef v39 = CFAttributedStringGetAttribute(a6, 0, (CFStringRef)*MEMORY[0x1E4F1F700], &effectiveRange);
    if (v39) {
      CFDictionarySetValue(Mutable, v38, v39);
    }
    uint64_t v40 = (const void *)*MEMORY[0x1E4F1F668];
    CFTypeRef v41 = CFAttributedStringGetAttribute(a6, 0, (CFStringRef)*MEMORY[0x1E4F1F668], &effectiveRange);
    if (v41) {
      CFDictionarySetValue(Mutable, v40, v41);
    }
    CFAllocatorRef v42 = (const void *)*MEMORY[0x1E4F1F660];
    CFTypeRef v43 = CFAttributedStringGetAttribute(a6, 0, (CFStringRef)*MEMORY[0x1E4F1F660], &effectiveRange);
    if (v43) {
      CFDictionarySetValue(Mutable, v42, v43);
    }
    uint64_t v44 = (const void *)*MEMORY[0x1E4F1F5B8];
    CFTypeRef v45 = CFAttributedStringGetAttribute(a6, 0, (CFStringRef)*MEMORY[0x1E4F1F5B8], &effectiveRange);
    if (v45) {
      CFDictionarySetValue(Mutable, v44, v45);
    }
    CFTypeRef v46 = (const void *)*MEMORY[0x1E4F1F5C0];
    CFTypeRef v47 = CFAttributedStringGetAttribute(a6, 0, (CFStringRef)*MEMORY[0x1E4F1F5C0], &effectiveRange);
    if (v47) {
      CFDictionarySetValue(Mutable, v46, v47);
    }
  }
  CFTypeRef v48 = cf;
  FigCDSCaptionProtocolGetProtocolID();
  uint64_t v49 = CMBaseObjectGetProtocolVTable();
  if (v49)
  {
    uint64_t v50 = *(void *)(v49 + 16);
    if (v50)
    {
      CFIndex v51 = *(void (**)(CFTypeRef, const __CFAttributedString *))(v50 + 24);
      if (v51) {
        v51(v48, a6);
      }
    }
  }
  (*(void (**)(CFTypeRef, void))(a1 + 16))(cf, *(void *)(a1 + 32));
LABEL_45:
  if (cf) {
    CFRelease(cf);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

uint64_t start_1()
{
  return 0;
}

uint64_t stop_1()
{
  return 0;
}

uint64_t FigMetadataCreateSampleBuffer(const __CFAllocator *a1, uint64_t a2, uint64_t a3, CMFormatDescriptionRef desc, const CMSampleTimingInfo *a5, CMSampleBufferRef *a6)
{
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v20 = 0;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v17 = 0u;
  size_t sampleSizeArray = 0;
  if (CMFormatDescriptionGetMediaSubType(desc) == 1835360888)
  {
    uint64_t appended = CMBlockBufferCreateEmpty(a1, 8u, 0, &blockBufferOut);
    if (!appended)
    {
      uint64_t appended = FigAtomWriterInitWithBlockBuffer();
      if (!appended)
      {
        if (a2 < 1)
        {
LABEL_10:
          size_t sampleSizeArray = CMBlockBufferGetDataLength(blockBufferOut);
          uint64_t appended = CMSampleBufferCreate(a1, blockBufferOut, 1u, 0, 0, desc, 1, 1, a5, 1, &sampleSizeArray, a6);
        }
        else
        {
          CFTypeID v13 = (CFDataRef *)(a3 + 4);
          while (1)
          {
            uint64_t appended = FigAtomWriterBeginAtom();
            if (appended) {
              break;
            }
            CFDataGetBytePtr(*v13);
            CFDataGetLength(*v13);
            uint64_t appended = FigAtomWriterAppendData();
            if (appended) {
              break;
            }
            uint64_t appended = FigAtomWriterEndAtom();
            if (appended) {
              break;
            }
            CFTypeID v13 = (CFDataRef *)((char *)v13 + 12);
            if (!--a2) {
              goto LABEL_10;
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t appended = FigSignalErrorAt();
  }
  uint64_t v14 = appended;
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v14;
}

char *FigCaptionRendererLayoutDecouple_CreateTextObject(const void *a1)
{
  uint64_t v2 = (char *)malloc_type_calloc(1uLL, 0xD0uLL, 0x10200404F51ABCFuLL);
  if (v2)
  {
    if (a1) {
      CFTypeRef v3 = CFRetain(a1);
    }
    else {
      CFTypeRef v3 = 0;
    }
    *((void *)v2 + 25) = v3;
    *((_DWORD *)v2 + 48) = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    *((void *)v2 + 4) = Mutable;
    __asm { FMOV            V0.2D, #-1.0 }
    *(_OWORD *)(v2 + 40) = _Q0;
    *(_OWORD *)(v2 + 56) = _Q0;
    if (!Mutable)
    {
      free(v2);
      return 0;
    }
  }
  return v2;
}

void FigCaptionRendererLayoutDecouple_ReleaseTextObject(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[25];
    if (v2) {
      CFRelease(v2);
    }
    CFTypeRef v3 = (const void *)a1[4];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

uint64_t FigCaptionRendererLayoutDecouple_ApplyDecouplingAndSafeRegion(uint64_t a1, float64x2_t *a2)
{
  CFArrayRef v88 = 0;
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable || (uint64_t v5 = *(void *)(ProtocolVTable + 16)) == 0)
  {
    uint64_t v59 = 4294954508;
LABEL_43:
    FigSignalErrorAt();
    return v59;
  }
  size_t v6 = *(uint64_t (**)(uint64_t, CFArrayRef *))(v5 + 24);
  if (!v6)
  {
    uint64_t v59 = 4294954514;
    goto LABEL_43;
  }
  uint64_t v7 = v6(a1, &v88);
  if (v7)
  {
    uint64_t v59 = v7;
    goto LABEL_43;
  }
  CFIndex Count = CFArrayGetCount(v88);
  if (!Count) {
    return 0;
  }
  uint64_t v9 = Count;
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  if (!Mutable) {
    return 0;
  }
  CFTypeID v11 = Mutable;
  if (v9 >= 1)
  {
    uint64_t v12 = v9 + 1;
    CFTypeID v13 = (long long *)MEMORY[0x1E4F1DAD8];
    uint64_t v14 = (long long *)MEMORY[0x1E4F1DB30];
    while (1)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v88, v12 - 2);
      CMTimeValue v87 = 0;
      FigCaptionRendererBaseProtocolGetProtocolID();
      uint64_t v16 = CMBaseObjectGetProtocolVTable();
      if (!v16 || (uint64_t v17 = *(void *)(v16 + 16)) == 0)
      {
        uint64_t v59 = 4294954508;
        goto LABEL_49;
      }
      long long v18 = *(uint64_t (**)(const void *, const char **))(v17 + 8);
      if (!v18)
      {
        uint64_t v59 = 4294954514;
        goto LABEL_49;
      }
      uint64_t v19 = v18(ValueAtIndex, &v87);
      if (v19) {
        break;
      }
      if (v87 && !strcmp(v87, "FigCaptionRendererCaption"))
      {
        long long v20 = *v13;
        long long v85 = *v14;
        long long v86 = v20;
        FigCaptionRendererNodeProtocolGetProtocolID();
        uint64_t v21 = CMBaseObjectGetProtocolVTable();
        if (v21)
        {
          uint64_t v22 = *(void *)(v21 + 16);
          if (v22)
          {
            double v23 = *(void (**)(const void *, long long *))(v22 + 120);
            if (v23) {
              v23(ValueAtIndex, &v85);
            }
          }
        }
        FigCaptionRendererNodeProtocolGetProtocolID();
        uint64_t v24 = CMBaseObjectGetProtocolVTable();
        if (v24)
        {
          uint64_t v25 = *(void *)(v24 + 16);
          if (v25)
          {
            CFTypeRef v26 = *(void (**)(const void *, long long *))(v25 + 136);
            if (v26) {
              v26(ValueAtIndex, &v86);
            }
          }
        }
        long long v27 = v86;
        long long v28 = v85;
        TextObject = FigCaptionRendererLayoutDecouple_CreateTextObject(ValueAtIndex);
        if (!TextObject) {
          goto LABEL_68;
        }
        *(_OWORD *)TextObject = v27;
        *((_OWORD *)TextObject + 1) = v28;
        CFArrayAppendValue(v11, TextObject);
      }
      if ((unint64_t)--v12 <= 1) {
        goto LABEL_26;
      }
    }
    uint64_t v59 = v19;
LABEL_49:
    FigSignalErrorAt();
    goto LABEL_69;
  }
LABEL_26:
  long long v30 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
  float64x2_t v83 = *(float64x2_t *)MEMORY[0x1E4F1DB20];
  long long v84 = v30;
  FigCaptionRendererNodeProtocolGetProtocolID();
  uint64_t v31 = CMBaseObjectGetProtocolVTable();
  if (v31)
  {
    uint64_t v32 = *(void *)(v31 + 16);
    if (v32)
    {
      uint64_t v33 = *(void (**)(uint64_t, float64x2_t *))(v32 + 104);
      if (v33) {
        v33(a1, &v83);
      }
    }
  }
  double v34 = FCRGetOverscanSafeRectForViewport((uint64_t)a2);
  unsigned int v38 = fcr_applyDecouplingAndSafeRegion(v11, v83.f64[0], v83.f64[1], *(double *)&v84, *((double *)&v84 + 1), v34 - v83.f64[0], v35 - v83.f64[1], v36, v37);
  if (!CFPreferencesGetAppBooleanValue(@"disable_caption_repositioning", @"com.apple.coremedia", 0))
  {
    if (a2[24].f64[0] < -0.5 || a2[24].f64[1] < -0.5)
    {
      FCRGetVideoPresentationBounds(a2[23].f64[0], a2[23].f64[1], a2[21].f64[0], a2[21].f64[1], a2[22].f64[0], a2[22].f64[1]);
      v41.f64[0] = v40;
      v41.f64[1] = v39;
      if ((vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vclezq_f64(v41), (int32x4_t)vclezq_f64(a2[22])))) & 1) == 0)
      {
        float64x2_t v82 = v83;
        float64_t v77 = v39;
        float64x2_t v79 = a2[21];
        float64_t v75 = v40;
        float64x2_t v76 = a2[22];
        CFIndex v42 = CFArrayGetCount(v11);
        v43.f64[0] = v77;
        if (v42 >= 1)
        {
          CFIndex v44 = 0;
          __asm { FMOV            V0.2D, #0.5 }
          float64x2_t v81 = _Q0;
          v43.f64[1] = v75;
          float64x2_t v78 = vdivq_f64(v76, v43);
          float64x2_t v80 = vaddq_f64(vmulq_f64(v76, _Q0), v79);
          do
          {
            uint64_t v50 = (float64x2_t *)CFArrayGetValueAtIndex(v11, v44);
            float64x2_t v51 = vmulq_f64(v50[1], v81);
            *uint64_t v50 = vsubq_f64(vsubq_f64(vmlaq_f64(v80, v78, vsubq_f64(vaddq_f64(vaddq_f64(v82, *v50), v51), v80)), v51), v82);
            ++v44;
          }
          while (v44 < CFArrayGetCount(v11));
        }
      }
      if (a2[24].f64[0] < -0.5)
      {
        double v52 = FCRGetOverscanSafeRectAspectFill(a2[21].f64[0], a2[21].f64[1], a2[22].f64[0], a2[22].f64[1]);
        fcr_applyDecouplingAndSafeRegion(v11, v83.f64[0], v83.f64[1], *(double *)&v84, *((double *)&v84 + 1), v52, v53, v54, v55);
      }
      unsigned int v38 = 1;
    }
    double v56 = a2[28].f64[0];
    if (v56 <= 0.0)
    {
      double v58 = a2[29].f64[0];
      double v57 = a2[26].f64[0];
      if (v58 <= 0.0 && v57 <= 0.0 && a2[27].f64[0] <= 0.0) {
        goto LABEL_54;
      }
    }
    else
    {
      double v57 = a2[26].f64[0];
      double v58 = a2[29].f64[0];
    }
    if (fcr_moveIntoSafeRegion(v11, a2[21].f64[0] + v57, a2[21].f64[1] + v58, a2[22].f64[0] - (v57 + a2[27].f64[0]), a2[22].f64[1] - (v56 + v58)))goto LABEL_55; {
  }
    }
LABEL_54:
  if (v38)
  {
LABEL_55:
    CFIndex v61 = CFArrayGetCount(v11);
    if (v61 >= 1)
    {
      CFIndex v62 = v61;
      for (CFIndex i = 0; i != v62; ++i)
      {
        double v64 = (double *)CFArrayGetValueAtIndex(v11, i);
        if (v64)
        {
          uint64_t v65 = *((void *)v64 + 25);
          if (v65)
          {
            double v66 = *v64;
            double v67 = v64[1];
            FigCaptionRendererNodeProtocolGetProtocolID();
            uint64_t v68 = CMBaseObjectGetProtocolVTable();
            if (v68)
            {
              uint64_t v69 = *(void *)(v68 + 16);
              if (v69)
              {
                CMTimeScale v70 = *(void (**)(uint64_t, double, double))(v69 + 128);
                if (v70) {
                  v70(v65, v66, v67);
                }
              }
            }
            FigCaptionRendererNodeProtocolGetProtocolID();
            uint64_t v71 = CMBaseObjectGetProtocolVTable();
            if (v71)
            {
              uint64_t v72 = *(void *)(v71 + 16);
              if (v72)
              {
                uint64_t v73 = *(void (**)(uint64_t, uint64_t))(v72 + 232);
                if (v73) {
                  v73(v65, 1);
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_68:
  uint64_t v59 = 0;
LABEL_69:
  if (CFArrayGetCount(v11) >= 1)
  {
    do
    {
      uint64_t v74 = CFArrayGetValueAtIndex(v11, 0);
      CFArrayRemoveValueAtIndex(v11, 0);
      FigCaptionRendererLayoutDecouple_ReleaseTextObject(v74);
    }
    while (CFArrayGetCount(v11) > 0);
  }
  CFRelease(v11);
  return v59;
}

CFMutableDataRef fcr_applyDecouplingAndSafeRegion(const __CFArray *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  CFArrayRef v16 = a1;
  CFIndex Count = CFArrayGetCount(a1);
  CFIndex v18 = Count - 1;
  if (Count < 1)
  {
    LODWORD(result) = 0;
    goto LABEL_112;
  }
  CFIndex v19 = Count;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDataRef result = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (!result)
  {
LABEL_112:
    uint64_t v137 = 0;
    goto LABEL_108;
  }
  double v138 = a6;
  double v139 = a7;
  double v140 = a8;
  double v141 = a9;
  CFIndex v143 = v18 * v19;
  CFDataRef theData = result;
  if (v18 * v19 < 1)
  {
    uint64_t v146 = 0;
    goto LABEL_107;
  }
  uint64_t v146 = 0;
  double v21 = a2;
  double v22 = a2 + a4;
  double v23 = a3 + a5;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v152 = _Q0;
  double v28 = -1.0;
  double v29 = 1.0;
  CFArrayRef v149 = v16;
  double v142 = a3;
  double v147 = v23;
  double v148 = a2 + a4;
  do
  {
    if (!v16) {
      goto LABEL_106;
    }
    CFIndex v30 = CFArrayGetCount(v16);
    if (v30 >= 1)
    {
      CFIndex v31 = v30;
      for (CFIndex i = 0; i != v31; ++i)
      {
        CFDictionaryRef ValueAtIndex = (__CFArray **)CFArrayGetValueAtIndex(v16, i);
        if (ValueAtIndex)
        {
          double v34 = ValueAtIndex;
          double v35 = ValueAtIndex[4];
          if (v35) {
            CFArrayRemoveAllValues(v35);
          }
          *(_OWORD *)(v34 + 5) = v152;
          *(_OWORD *)(v34 + 7) = v152;
          v34[22] = 0;
          v34[23] = 0;
          v34[21] = 0;
          *(_OWORD *)(v34 + 9) = 0u;
          *(_OWORD *)(v34 + 11) = 0u;
          *(_OWORD *)(v34 + 13) = 0u;
          *(_OWORD *)(v34 + 15) = 0u;
          *(_OWORD *)(v34 + 17) = 0u;
          *(_OWORD *)(v34 + 19) = 0u;
        }
      }
    }
    CFIndex v36 = CFArrayGetCount(v16);
    if (v36 <= 1) {
      goto LABEL_106;
    }
    CFIndex v37 = v36;
    CFIndex v38 = 0;
    int v39 = 0;
    CFIndex v40 = v36 - 2;
    do
    {
      CFIndex v41 = v38;
      CFIndex v42 = CFArrayGetValueAtIndex(v16, v38++);
      if (v42 && v38 < v37)
      {
        float64x2_t v43 = v42;
        CFIndex v44 = v38;
        do
        {
          CFTypeRef v45 = (CFMutableArrayRef *)CFArrayGetValueAtIndex(v16, v44);
          if (v45)
          {
            CFTypeRef v46 = v45;
            long long v47 = *((_OWORD *)v43 + 11);
            v155[10] = *((_OWORD *)v43 + 10);
            v155[11] = v47;
            v155[12] = *((_OWORD *)v43 + 12);
            long long v48 = *((_OWORD *)v43 + 7);
            v155[6] = *((_OWORD *)v43 + 6);
            v155[7] = v48;
            long long v49 = *((_OWORD *)v43 + 9);
            v155[8] = *((_OWORD *)v43 + 8);
            v155[9] = v49;
            long long v50 = *((_OWORD *)v43 + 3);
            v155[2] = *((_OWORD *)v43 + 2);
            v155[3] = v50;
            long long v51 = *((_OWORD *)v43 + 5);
            v155[4] = *((_OWORD *)v43 + 4);
            v155[5] = v51;
            long long v52 = *((_OWORD *)v43 + 1);
            v155[0] = *(_OWORD *)v43;
            v155[1] = v52;
            long long v53 = *((_OWORD *)v45 + 11);
            v154[10] = *((_OWORD *)v45 + 10);
            v154[11] = v53;
            v154[12] = *((_OWORD *)v45 + 12);
            long long v54 = *((_OWORD *)v45 + 7);
            v154[6] = *((_OWORD *)v45 + 6);
            v154[7] = v54;
            long long v55 = *((_OWORD *)v45 + 9);
            v154[8] = *((_OWORD *)v45 + 8);
            v154[9] = v55;
            long long v56 = *((_OWORD *)v45 + 3);
            v154[2] = *((_OWORD *)v45 + 2);
            v154[3] = v56;
            long long v57 = *((_OWORD *)v45 + 5);
            v154[4] = *((_OWORD *)v45 + 4);
            v154[5] = v57;
            long long v58 = *((_OWORD *)v45 + 1);
            v154[0] = *(_OWORD *)v45;
            v154[1] = v58;
            if (fcr_isOverlap((double *)v155, (double *)v154))
            {
              CFArrayAppendValue(*((CFMutableArrayRef *)v43 + 4), v46);
              CFArrayAppendValue(v46[4], v43);
              int v39 = 1;
            }
          }
          ++v44;
        }
        while (v37 != v44);
      }
    }
    while (v41 != v40);
    if (!v39)
    {
LABEL_106:
      ++v146;
      break;
    }
    uint64_t v59 = CFArrayGetCount(v16);
    if (v59 >= 1)
    {
      for (CFIndex j = 0; j != v59; ++j)
      {
        CFIndex v61 = (double *)CFArrayGetValueAtIndex(v16, j);
        v61[5] = v21;
        v61[6] = v22;
        v61[7] = v23;
        v61[8] = a3;
      }
    }
    MutableCFStringRef Copy = CFArrayCreateMutableCopy(allocator, 0, v16);
    if (MutableCopy)
    {
      CFArrayRef v63 = MutableCopy;
      v156.locatioCFIndex n = 0;
      v156.length = v59;
      CFArraySortValues(MutableCopy, v156, (CFComparatorFunction)fcr_objComparatorX, 0);
      double v64 = (double *)CFArrayGetValueAtIndex(v63, 0);
      uint64_t v65 = v64;
      v64[5] = v21;
      if (v59 >= 2)
      {
        for (CFIndex k = 1; k != v59; ++k)
        {
          double v64 = (double *)CFArrayGetValueAtIndex(v63, k);
          double v67 = v64[2] * 0.5;
          double v68 = v65[2] * 0.5;
          v65[6] = v68 + *v64 + v67 + v28;
          v64[5] = v68 + *v65 + v29 - v67;
          uint64_t v65 = v64;
        }
      }
      v64[6] = v22;
      v157.locatioCFIndex n = 0;
      v157.length = v59;
      CFArraySortValues(v63, v157, (CFComparatorFunction)fcr_objComparatorY, 0);
      uint64_t v69 = (double *)CFArrayGetValueAtIndex(v63, 0);
      CMTimeScale v70 = v69;
      v69[8] = a3;
      if (v59 >= 2)
      {
        for (CFIndex m = 1; m != v59; ++m)
        {
          uint64_t v69 = (double *)CFArrayGetValueAtIndex(v63, m);
          double v72 = v69[3] * 0.5;
          double v73 = v70[3] * 0.5;
          v70[7] = v73 + v69[1] + v72 + v28;
          v69[8] = v73 + v70[1] + v29 - v72;
          CMTimeScale v70 = v69;
        }
      }
      v69[7] = v23;
      CFRelease(v63);
    }
    CFIndex v74 = CFArrayGetCount(v16);
    if (v74 < 1) {
      break;
    }
    CFIndex v75 = v74;
    int v153 = 0;
    CFIndex v76 = 0;
    CFIndex v77 = -1;
    double v78 = 0.0;
    CFIndex v151 = v74;
    do
    {
      float64x2_t v79 = (char *)CFArrayGetValueAtIndex(v16, v76);
      if (!v79) {
        goto LABEL_77;
      }
      float64x2_t v80 = v79;
      if (*((int *)v79 + 48) > 0)
      {
        int v153 = 1;
        goto LABEL_77;
      }
      double v82 = *((double *)v79 + 5);
      double v81 = *((double *)v79 + 6);
      double v83 = *((double *)v79 + 7);
      double v84 = *((double *)v79 + 8);
      CFIndex v85 = CFArrayGetCount(*((CFArrayRef *)v79 + 4));
      if (v85 >= 1)
      {
        CFIndex v86 = v85;
        CFIndex v87 = 0;
        double v88 = *(double *)v80 + *((double *)v80 + 2) * 0.5;
        CFMutableArrayRef v89 = (double *)(v80 + 96);
        CFIndex v90 = (double *)(v80 + 72);
        double v91 = *((double *)v80 + 1) + *((double *)v80 + 3) * 0.5;
        unint64_t v92 = (double *)(v80 + 128);
        int v93 = (double *)(v80 + 152);
        do
        {
          uint64_t v94 = (double *)CFArrayGetValueAtIndex(*((CFArrayRef *)v80 + 4), v87);
          double v95 = v94[3];
          double v96 = v94[2] * 0.5;
          double v97 = v94[1];
          double v98 = *v94 + v96;
          double v99 = *((double *)v80 + 3);
          double v100 = v96 + *((double *)v80 + 2) * 0.5 - vabdd_f64(v88, v98);
          if (v88 >= v98)
          {
            BOOL v101 = (double *)(v80 + 96);
            uint64_t v102 = (double *)(v80 + 112);
            if (*v89 == 0.0 || (BOOL v101 = (double *)(v80 + 96), v102 = (double *)(v80 + 112), v100 < *v89)) {
LABEL_48:
            }
              *BOOL v101 = v100;
          }
          else
          {
            BOOL v101 = (double *)(v80 + 72);
            uint64_t v102 = (double *)(v80 + 88);
            if (*v90 == 0.0) {
              goto LABEL_48;
            }
            BOOL v101 = (double *)(v80 + 72);
            uint64_t v102 = (double *)(v80 + 88);
            if (v100 < *v90) {
              goto LABEL_48;
            }
          }
          double v103 = v95 * 0.5;
          double v104 = v97 + v103;
          double v105 = v103 + v99 * 0.5 - vabdd_f64(v91, v97 + v103);
          *uint64_t v102 = v105 + *v102;
          if (v91 >= v104)
          {
            CFTypeRef v106 = (double *)(v80 + 128);
            unint64_t v107 = (double *)(v80 + 136);
            if (*v92 != 0.0)
            {
              CFTypeRef v106 = (double *)(v80 + 128);
              unint64_t v107 = (double *)(v80 + 136);
              if (v105 >= *v92) {
                goto LABEL_56;
              }
            }
          }
          else
          {
            CFTypeRef v106 = (double *)(v80 + 152);
            unint64_t v107 = (double *)(v80 + 160);
            if (*v93 != 0.0)
            {
              CFTypeRef v106 = (double *)(v80 + 152);
              unint64_t v107 = (double *)(v80 + 160);
              if (v105 >= *v93) {
                goto LABEL_56;
              }
            }
          }
          double *v106 = v105;
LABEL_56:
          *unint64_t v107 = v100 + *v107;
          ++v87;
        }
        while (v86 != v87);
      }
      CGFloat v108 = v81 - v82;
      CGFloat v109 = v83 - v84;
      *((double *)v80 + 9) = -*((double *)v80 + 9);
      *((double *)v80 + 19) = -*((double *)v80 + 19);
      fcr_validateMove((CGRect *)v80, (uint64_t)(v80 + 72), v82, v84, v108, v109);
      fcr_validateMove((CGRect *)v80, (uint64_t)(v80 + 96), v82, v84, v108, v109);
      fcr_validateMove((CGRect *)v80, (uint64_t)(v80 + 144), v82, v84, v108, v109);
      fcr_validateMove((CGRect *)v80, (uint64_t)(v80 + 120), v82, v84, v108, v109);
      double v110 = *((double *)v80 + 11);
      double v111 = *((double *)v80 + 14);
      BOOL v112 = v110 <= v111;
      if (v110 <= v111) {
        double v110 = *((double *)v80 + 14);
      }
      uint64_t v113 = 96;
      if (!v112) {
        uint64_t v113 = 72;
      }
      uint64_t v114 = *(void *)&v80[v113];
      double v115 = *((double *)v80 + 17);
      double v116 = *((double *)v80 + 20);
      BOOL v117 = v115 <= v116;
      if (v115 <= v116) {
        double v115 = *((double *)v80 + 20);
      }
      uint64_t v118 = 152;
      if (!v117) {
        uint64_t v118 = 128;
      }
      uint64_t v119 = *(void *)&v80[v118];
      if (v110 > 0.0 || v115 > 0.0)
      {
        _NF = v110 > 0.0 && *((double *)v80 + 2) < *((double *)v80 + 3);
        double v21 = a2;
        double v23 = v147;
        double v22 = v148;
        double v28 = -1.0;
        double v29 = 1.0;
        CFIndex v75 = v151;
        if (_NF)
        {
          *((void *)v80 + 21) = v114;
          *((void *)v80 + 22) = 0;
          *((double *)v80 + 23) = v110;
        }
        else
        {
          *((void *)v80 + 21) = 0;
          double v110 = v115;
          *((void *)v80 + 22) = v119;
          *((double *)v80 + 23) = v115;
        }
        CFArrayRef v16 = v149;
      }
      else
      {
        *((void *)v80 + 21) = 0;
        *((void *)v80 + 22) = 0;
        double v110 = 0.0;
        *((void *)v80 + 23) = 0;
        CFArrayRef v16 = v149;
        double v21 = a2;
        double v23 = v147;
        double v22 = v148;
        double v28 = -1.0;
        double v29 = 1.0;
        CFIndex v75 = v151;
      }
      if (v78 < v110)
      {
        CFIndex v77 = v76;
        double v78 = v110;
      }
LABEL_77:
      ++v76;
    }
    while (v76 != v75);
    if (v78 <= 0.0 || v77 < 0)
    {
      a3 = v142;
      if (!v153) {
        break;
      }
      CFIndex v134 = CFArrayGetCount(v16);
      if (v134 >= 1)
      {
        CFIndex v135 = v134;
        for (CFIndex n = 0; n != v135; ++n)
          *((_DWORD *)CFArrayGetValueAtIndex(v16, n) + 48) = 0;
      }
      uint64_t v133 = v146 - 1;
    }
    else
    {
      unint64_t v121 = (char *)CFArrayGetValueAtIndex(v16, v77);
      a3 = v142;
      if (v121)
      {
        *(float64x2_t *)unint64_t v121 = vaddq_f64(*(float64x2_t *)(v121 + 168), *(float64x2_t *)v121);
        ++*((_DWORD *)v121 + 48);
      }
      CFIndex v122 = CFArrayGetCount(v16);
      if (v122)
      {
        uint64_t v123 = v122;
        int64_t v124 = CFDataGetLength(theData) / (unint64_t)(208 * v122);
        if (v124 >= 1)
        {
          BytePtr = CFDataGetBytePtr(theData);
          for (iCFIndex i = 0; ii != v124; ++ii)
          {
            if (v123 < 1)
            {
              int v127 = 0;
            }
            else
            {
              int v127 = 0;
              CFIndex v128 = 0;
              CMTimeValue v129 = BytePtr;
              do
              {
                unint64_t v130 = CFArrayGetValueAtIndex(v16, v128);
                if (!memcmp(v129, v130, 0xD0uLL)) {
                  ++v127;
                }
                ++v128;
                v129 += 208;
              }
              while (v123 != v128);
            }
            if (v123 == v127) {
              goto LABEL_107;
            }
            BytePtr += 208 * v123;
          }
        }
        if (v123 >= 1)
        {
          for (jCFIndex j = 0; jj != v123; ++jj)
          {
            uint64_t v132 = (const UInt8 *)CFArrayGetValueAtIndex(v16, jj);
            CFDataAppendBytes(theData, v132, 208);
          }
        }
      }
      uint64_t v133 = v146;
    }
    uint64_t v146 = v133 + 1;
  }
  while (v133 + 1 < v143);
LABEL_107:
  CFRelease(theData);
  LODWORD(result) = fcr_moveIntoSafeRegion(v16, v138, v139, v140, v141);
  uint64_t v137 = v146;
LABEL_108:
  if (v137 > 1) {
    return (CFMutableDataRef)1;
  }
  else {
    return (CFMutableDataRef)result;
  }
}

uint64_t fcr_moveIntoSafeRegion(CFArrayRef theArray, double a2, double a3, double a4, double a5)
{
  char v5 = 0;
  if (a4 > 0.0 && a5 > 0.0)
  {
    MutableCFStringRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theArray);
    if (MutableCopy)
    {
      CFArrayRef v11 = MutableCopy;
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      char v12 = fcr_sweepBottomUp(MutableCopy, (double *)&v66, a3);
      double v13 = a3 + a5;
      uint64_t Count = CFArrayGetCount(v11);
      v93.locatioCFIndex n = 0;
      v93.length = Count;
      CFArraySortValues(v11, v93, (CFComparatorFunction)fcr_objComparatorTop, 0);
      if (Count < 1)
      {
        char v16 = 0;
      }
      else
      {
        CFIndex v15 = 0;
        char v16 = 0;
        double v17 = a3 + a5;
        do
        {
          CFDictionaryRef ValueAtIndex = (double *)CFArrayGetValueAtIndex(v11, v15);
          double v19 = ValueAtIndex[1];
          double v20 = ValueAtIndex[3];
          if (v19 + v20 > v13)
          {
            double v19 = v13 - v20;
            ValueAtIndex[1] = v13 - v20;
            char v16 = 1;
          }
          double v17 = fmin(v17, v19);
          ++v15;
        }
        while (Count != v15);
        if ((v16 & (Count > 1)) == 1)
        {
          CFIndex v21 = 1;
          do
          {
            double v22 = (double *)CFArrayGetValueAtIndex(v11, v21);
            CFIndex v23 = 0;
            do
            {
              uint64_t v24 = (double *)CFArrayGetValueAtIndex(v11, v23);
              long long v25 = *((_OWORD *)v22 + 11);
              long long v90 = *((_OWORD *)v22 + 10);
              long long v91 = v25;
              long long v92 = *((_OWORD *)v22 + 12);
              long long v26 = *((_OWORD *)v22 + 7);
              long long v86 = *((_OWORD *)v22 + 6);
              long long v87 = v26;
              long long v27 = *((_OWORD *)v22 + 9);
              long long v88 = *((_OWORD *)v22 + 8);
              long long v89 = v27;
              long long v28 = *((_OWORD *)v22 + 3);
              long long v82 = *((_OWORD *)v22 + 2);
              long long v83 = v28;
              long long v29 = *((_OWORD *)v22 + 5);
              long long v84 = *((_OWORD *)v22 + 4);
              long long v85 = v29;
              long long v30 = *((_OWORD *)v22 + 1);
              long long v80 = *(_OWORD *)v22;
              long long v81 = v30;
              long long v31 = *((_OWORD *)v24 + 11);
              long long v77 = *((_OWORD *)v24 + 10);
              long long v78 = v31;
              long long v79 = *((_OWORD *)v24 + 12);
              long long v32 = *((_OWORD *)v24 + 7);
              long long v73 = *((_OWORD *)v24 + 6);
              long long v74 = v32;
              long long v33 = *((_OWORD *)v24 + 9);
              long long v75 = *((_OWORD *)v24 + 8);
              long long v76 = v33;
              long long v34 = *((_OWORD *)v24 + 3);
              long long v69 = *((_OWORD *)v24 + 2);
              long long v70 = v34;
              long long v35 = *((_OWORD *)v24 + 5);
              long long v71 = *((_OWORD *)v24 + 4);
              long long v72 = v35;
              long long v36 = *((_OWORD *)v24 + 1);
              long long v67 = *(_OWORD *)v24;
              long long v68 = v36;
              if (fcr_isOverlap((double *)&v80, (double *)&v67))
              {
                double v37 = v24[1] - v22[3];
                v22[1] = v37;
                double v17 = fmin(v17, v37);
              }
              ++v23;
            }
            while (v21 != v23);
            ++v21;
          }
          while (v21 != Count);
          char v16 = 1;
        }
        double v13 = v17;
      }
      if (v13 < a3) {
        fcr_sweepBottomUp(v11, (double *)&v66, (a3 + v13) * 0.5);
      }
      char v38 = fcr_sweepLeftRight(v11, (double *)&v65, a2);
      double v39 = a2 + a4;
      uint64_t v40 = CFArrayGetCount(v11);
      v94.locatioCFIndex n = 0;
      v94.length = v40;
      CFArraySortValues(v11, v94, (CFComparatorFunction)fcr_objComparatorRight, 0);
      if (v40 < 1)
      {
        char v42 = 0;
      }
      else
      {
        CFIndex v41 = 0;
        char v42 = 0;
        double v43 = a2 + a4;
        do
        {
          CFIndex v44 = (double *)CFArrayGetValueAtIndex(v11, v41);
          double v45 = *v44;
          double v46 = v44[2];
          if (*v44 + v46 > v39)
          {
            double v45 = v39 - v46;
            *CFIndex v44 = v39 - v46;
            char v42 = 1;
          }
          double v43 = fmin(v43, v45);
          ++v41;
        }
        while (v40 != v41);
        if ((v42 & (v40 > 1)) == 1)
        {
          CFIndex v47 = 1;
          do
          {
            long long v48 = (double *)CFArrayGetValueAtIndex(v11, v47);
            CFIndex v49 = 0;
            do
            {
              long long v50 = (double *)CFArrayGetValueAtIndex(v11, v49);
              long long v51 = *((_OWORD *)v48 + 11);
              long long v90 = *((_OWORD *)v48 + 10);
              long long v91 = v51;
              long long v92 = *((_OWORD *)v48 + 12);
              long long v52 = *((_OWORD *)v48 + 7);
              long long v86 = *((_OWORD *)v48 + 6);
              long long v87 = v52;
              long long v53 = *((_OWORD *)v48 + 9);
              long long v88 = *((_OWORD *)v48 + 8);
              long long v89 = v53;
              long long v54 = *((_OWORD *)v48 + 3);
              long long v82 = *((_OWORD *)v48 + 2);
              long long v83 = v54;
              long long v55 = *((_OWORD *)v48 + 5);
              long long v84 = *((_OWORD *)v48 + 4);
              long long v85 = v55;
              long long v56 = *((_OWORD *)v48 + 1);
              long long v80 = *(_OWORD *)v48;
              long long v81 = v56;
              long long v57 = *((_OWORD *)v50 + 11);
              long long v77 = *((_OWORD *)v50 + 10);
              long long v78 = v57;
              long long v79 = *((_OWORD *)v50 + 12);
              long long v58 = *((_OWORD *)v50 + 7);
              long long v73 = *((_OWORD *)v50 + 6);
              long long v74 = v58;
              long long v59 = *((_OWORD *)v50 + 9);
              long long v75 = *((_OWORD *)v50 + 8);
              long long v76 = v59;
              long long v60 = *((_OWORD *)v50 + 3);
              long long v69 = *((_OWORD *)v50 + 2);
              long long v70 = v60;
              long long v61 = *((_OWORD *)v50 + 5);
              long long v71 = *((_OWORD *)v50 + 4);
              long long v72 = v61;
              long long v62 = *((_OWORD *)v50 + 1);
              long long v67 = *(_OWORD *)v50;
              long long v68 = v62;
              if (fcr_isOverlap((double *)&v80, (double *)&v67))
              {
                double v63 = *v50 - v48[2];
                *long long v48 = v63;
                double v43 = fmin(v43, v63);
              }
              ++v49;
            }
            while (v47 != v49);
            ++v47;
          }
          while (v47 != v40);
          char v42 = 1;
        }
        double v39 = v43;
      }
      char v5 = v42 | v38 | v16 | v12;
      if (v39 < a2) {
        fcr_sweepLeftRight(v11, (double *)&v65, (a2 + v39) * 0.5);
      }
      CFRelease(v11);
    }
    else
    {
      char v5 = 0;
    }
  }
  return v5 & 1;
}

BOOL fcr_isOverlap(double *a1, double *a2)
{
  return vabdd_f64(*a1 + a1[2] * 0.5, *a2 + a2[2] * 0.5) < a1[2] * 0.5 + a2[2] * 0.5 + -3.0
      && vabdd_f64(a1[1] + a1[3] * 0.5, a2[1] + a2[3] * 0.5) < a2[3] * 0.5 + a1[3] * 0.5 + -3.0;
}

uint64_t fcr_objComparatorX(double *a1, double *a2)
{
  double v2 = *a1 + a1[2] * 0.5;
  double v3 = *a2 + a2[2] * 0.5;
  if (v2 < v3) {
    return -1;
  }
  else {
    return v2 > v3;
  }
}

uint64_t fcr_objComparatorY(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a1 + 8) + *(double *)(a1 + 24) * 0.5;
  double v3 = *(double *)(a2 + 8) + *(double *)(a2 + 24) * 0.5;
  if (v2 < v3) {
    return -1;
  }
  else {
    return v2 > v3;
  }
}

void fcr_validateMove(CGRect *a1, uint64_t a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  double MinX = CGRectGetMinX(*a1);
  double MaxX = CGRectGetMaxX(*a1);
  double MinY = CGRectGetMinY(*a1);
  double MaxY = CGRectGetMaxY(*a1);
  v31.origin.x = a3;
  v31.origin.y = a4;
  v31.size.width = a5;
  v31.size.height = a6;
  double v13 = CGRectGetMinX(v31);
  v32.origin.x = a3;
  v32.origin.y = a4;
  v32.size.width = a5;
  v32.size.height = a6;
  double v14 = CGRectGetMaxX(v32);
  v33.origin.x = a3;
  v33.origin.y = a4;
  v33.size.width = a5;
  v33.size.height = a6;
  double v15 = CGRectGetMinY(v33);
  v34.origin.x = a3;
  v34.origin.y = a4;
  v34.size.width = a5;
  v34.size.height = a6;
  double v16 = CGRectGetMaxY(v34);
  double v17 = *(double *)a2;
  double v18 = MinX + *(double *)a2;
  if (v18 < v13) {
    double v17 = v13 - MinX;
  }
  double v19 = MaxX + v17;
  if (MaxX + v17 > v14) {
    double v17 = v14 - MaxX;
  }
  if (v18 < v13 || v19 > v14) {
    *(double *)a2 = v17;
  }
  double v21 = *(double *)(a2 + 8);
  double v22 = MinY + v21;
  if (MinY + v21 < v15) {
    double v21 = v15 - MinY;
  }
  double v23 = MaxY + v21;
  if (MaxY + v21 > v16) {
    double v21 = v16 - MaxY;
  }
  if (v22 < v15 || v23 > v16) {
    *(double *)(a2 + 8) = v21;
  }
  double v25 = fabs(v17);
  double v26 = fabs(v21);
  if (v25 <= 3.0 && v26 <= 3.0) {
    *(void *)(a2 + 16) = 0;
  }
}

uint64_t fcr_sweepBottomUp(const __CFArray *a1, double *a2, double a3)
{
  uint64_t Count = CFArrayGetCount(a1);
  *a2 = a3;
  v31.locatioCFIndex n = 0;
  v31.length = Count;
  CFArraySortValues(a1, v31, (CFComparatorFunction)fcr_objComparatorBottom, 0);
  if (Count < 1)
  {
    char v8 = 0;
  }
  else
  {
    CFIndex v7 = 0;
    char v8 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = (double *)CFArrayGetValueAtIndex(a1, v7);
      double v10 = ValueAtIndex[1];
      if (v10 < a3)
      {
        ValueAtIndex[1] = a3;
        char v8 = 1;
        double v10 = a3;
      }
      *a2 = fmax(*a2, v10 + ValueAtIndex[3]);
      ++v7;
    }
    while (Count != v7);
    if ((v8 & (Count > 1)) == 1)
    {
      CFIndex v11 = 1;
      do
      {
        char v12 = (double *)CFArrayGetValueAtIndex(a1, v11);
        CFIndex v13 = 0;
        do
        {
          double v14 = (double *)CFArrayGetValueAtIndex(a1, v13);
          long long v15 = *((_OWORD *)v12 + 11);
          v30[10] = *((_OWORD *)v12 + 10);
          v30[11] = v15;
          v30[12] = *((_OWORD *)v12 + 12);
          long long v16 = *((_OWORD *)v12 + 7);
          v30[6] = *((_OWORD *)v12 + 6);
          v30[7] = v16;
          long long v17 = *((_OWORD *)v12 + 9);
          v30[8] = *((_OWORD *)v12 + 8);
          v30[9] = v17;
          long long v18 = *((_OWORD *)v12 + 3);
          v30[2] = *((_OWORD *)v12 + 2);
          v30[3] = v18;
          long long v19 = *((_OWORD *)v12 + 5);
          v30[4] = *((_OWORD *)v12 + 4);
          v30[5] = v19;
          long long v20 = *((_OWORD *)v12 + 1);
          v30[0] = *(_OWORD *)v12;
          v30[1] = v20;
          long long v21 = *((_OWORD *)v14 + 11);
          v29[10] = *((_OWORD *)v14 + 10);
          v29[11] = v21;
          v29[12] = *((_OWORD *)v14 + 12);
          long long v22 = *((_OWORD *)v14 + 7);
          v29[6] = *((_OWORD *)v14 + 6);
          v29[7] = v22;
          long long v23 = *((_OWORD *)v14 + 9);
          v29[8] = *((_OWORD *)v14 + 8);
          v29[9] = v23;
          long long v24 = *((_OWORD *)v14 + 3);
          v29[2] = *((_OWORD *)v14 + 2);
          _OWORD v29[3] = v24;
          long long v25 = *((_OWORD *)v14 + 5);
          v29[4] = *((_OWORD *)v14 + 4);
          v29[5] = v25;
          long long v26 = *((_OWORD *)v14 + 1);
          v29[0] = *(_OWORD *)v14;
          v29[1] = v26;
          if (fcr_isOverlap((double *)v30, (double *)v29))
          {
            double v27 = v14[1] + v14[3];
            v12[1] = v27;
            *a2 = fmax(*a2, v27 + v12[3]);
          }
          ++v13;
        }
        while (v11 != v13);
        ++v11;
      }
      while (v11 != Count);
    }
  }
  return v8 & 1;
}

uint64_t fcr_sweepLeftRight(const __CFArray *a1, double *a2, double a3)
{
  uint64_t Count = CFArrayGetCount(a1);
  *a2 = a3;
  v31.locatioCFIndex n = 0;
  v31.length = Count;
  CFArraySortValues(a1, v31, (CFComparatorFunction)fcr_objComparatorLeft, 0);
  if (Count < 1)
  {
    char v8 = 0;
  }
  else
  {
    CFIndex v7 = 0;
    char v8 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = (double *)CFArrayGetValueAtIndex(a1, v7);
      double v10 = *ValueAtIndex;
      if (*ValueAtIndex < a3)
      {
        *CFDictionaryRef ValueAtIndex = a3;
        char v8 = 1;
        double v10 = a3;
      }
      *a2 = fmax(*a2, v10 + ValueAtIndex[2]);
      ++v7;
    }
    while (Count != v7);
    if ((v8 & (Count > 1)) == 1)
    {
      CFIndex v11 = 1;
      do
      {
        char v12 = (double *)CFArrayGetValueAtIndex(a1, v11);
        CFIndex v13 = 0;
        do
        {
          double v14 = (double *)CFArrayGetValueAtIndex(a1, v13);
          long long v15 = *((_OWORD *)v12 + 11);
          v30[10] = *((_OWORD *)v12 + 10);
          v30[11] = v15;
          v30[12] = *((_OWORD *)v12 + 12);
          long long v16 = *((_OWORD *)v12 + 7);
          v30[6] = *((_OWORD *)v12 + 6);
          v30[7] = v16;
          long long v17 = *((_OWORD *)v12 + 9);
          v30[8] = *((_OWORD *)v12 + 8);
          v30[9] = v17;
          long long v18 = *((_OWORD *)v12 + 3);
          v30[2] = *((_OWORD *)v12 + 2);
          v30[3] = v18;
          long long v19 = *((_OWORD *)v12 + 5);
          v30[4] = *((_OWORD *)v12 + 4);
          v30[5] = v19;
          long long v20 = *((_OWORD *)v12 + 1);
          v30[0] = *(_OWORD *)v12;
          v30[1] = v20;
          long long v21 = *((_OWORD *)v14 + 11);
          v29[10] = *((_OWORD *)v14 + 10);
          v29[11] = v21;
          v29[12] = *((_OWORD *)v14 + 12);
          long long v22 = *((_OWORD *)v14 + 7);
          v29[6] = *((_OWORD *)v14 + 6);
          v29[7] = v22;
          long long v23 = *((_OWORD *)v14 + 9);
          v29[8] = *((_OWORD *)v14 + 8);
          v29[9] = v23;
          long long v24 = *((_OWORD *)v14 + 3);
          v29[2] = *((_OWORD *)v14 + 2);
          _OWORD v29[3] = v24;
          long long v25 = *((_OWORD *)v14 + 5);
          v29[4] = *((_OWORD *)v14 + 4);
          v29[5] = v25;
          long long v26 = *((_OWORD *)v14 + 1);
          v29[0] = *(_OWORD *)v14;
          v29[1] = v26;
          if (fcr_isOverlap((double *)v30, (double *)v29))
          {
            double v27 = *v14 + v14[2];
            *char v12 = v27;
            *a2 = fmax(*a2, v27 + v12[2]);
          }
          ++v13;
        }
        while (v11 != v13);
        ++v11;
      }
      while (v11 != Count);
    }
  }
  return v8 & 1;
}

uint64_t fcr_objComparatorBottom(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a1 + 8);
  double v3 = *(double *)(a2 + 8);
  if (v2 < v3) {
    return -1;
  }
  else {
    return v2 > v3;
  }
}

uint64_t fcr_objComparatorTop(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a1 + 8) + *(double *)(a1 + 24);
  double v3 = *(double *)(a2 + 8) + *(double *)(a2 + 24);
  if (v2 > v3) {
    return -1;
  }
  else {
    return v2 < v3;
  }
}

uint64_t fcr_objComparatorLeft(double *a1, double *a2)
{
  if (*a1 < *a2) {
    return -1;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t fcr_objComparatorRight(double *a1, double *a2)
{
  double v2 = *a1 + a1[2];
  double v3 = *a2 + a2[2];
  if (v2 > v3) {
    return -1;
  }
  else {
    return v2 < v3;
  }
}

uint64_t FigMetadataConverterCreateForQuickTimeToFromiTunes(int a1, CFTypeRef cf1, CFTypeRef cf2, uint64_t a4, void *a5)
{
  if (!a5) {
    goto LABEL_21;
  }
  if (CFEqual(cf1, cf2))
  {
LABEL_8:
    FigMetadataConverterGetClassID();
    uint64_t v10 = CMDerivedObjectCreate();
    if (!v10)
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
      if (cf1) {
        CFTypeRef v12 = CFRetain(cf1);
      }
      else {
        CFTypeRef v12 = 0;
      }
      void *DerivedStorage = v12;
      if (cf2) {
        CFTypeRef v13 = CFRetain(cf2);
      }
      else {
        CFTypeRef v13 = 0;
      }
      uint64_t v10 = 0;
      DerivedStorage[1] = v13;
      *a5 = 0;
    }
    return v10;
  }
  if (CFEqual(cf1, @"com.apple.quicktime.udta")
    || CFEqual(cf1, @"org.mp4ra")
    || CFEqual(cf1, @"com.apple.quicktime.mdta"))
  {
    char v8 = @"com.apple.itunes";
    CFTypeRef v9 = cf2;
  }
  else
  {
    if (!CFEqual(cf1, @"com.apple.itunes")) {
      goto LABEL_21;
    }
    if (CFEqual(cf2, @"com.apple.quicktime.udta") || CFEqual(cf2, @"org.mp4ra")) {
      goto LABEL_8;
    }
    CFTypeRef v9 = cf2;
    char v8 = @"com.apple.quicktime.mdta";
  }
  if (CFEqual(v9, v8)) {
    goto LABEL_8;
  }
LABEL_21:

  return FigSignalErrorAt();
}

void qtitunes_FigMetadataConverterFinalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  CFDictionaryRef v1 = *(const void **)(DerivedStorage + 8);
  if (v1)
  {
    CFRelease(v1);
    *(void *)(DerivedStorage + 8) = 0;
  }
}

__CFString *qtitunes_FigMetadataConverterCopyDebugDescription()
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFStringAppendFormat(Mutable, 0, @" FigQuickTimeiTunesMetadataConverter %p\n", DerivedStorage);
  if (*(void *)(DerivedStorage + 8)) {
    CFStringAppendFormat(Mutable, 0, @"  Destination Format = %@\n", *(void *)(DerivedStorage + 8));
  }
  return Mutable;
}

uint64_t qtitunes_FigMetadataConverterCreateConvertedItem(uint64_t a1, const __CFDictionary *a2, const __CFAllocator *a3, CFDictionaryRef *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    CFTypeRef v9 = (CFTypeRef *)DerivedStorage;
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"key");
    if (Value)
    {
      CFStringRef v11 = Value;
      if (CFEqual(*v9, v9[1]))
      {
        if (a4)
        {
          uint64_t v12 = 0;
          *a4 = CFDictionaryCreateCopy(a3, a2);
          return v12;
        }
        return 0;
      }
      CFTypeRef v13 = (CFTypeRef *)CMBaseObjectGetDerivedStorage();
      if (CFEqual(*v13, @"com.apple.itunes"))
      {
        unsigned int valuePtr = 0;
        uint64_t v14 = CMBaseObjectGetDerivedStorage();
        CFDictionaryRef OSTypeKeyToShortStringKeyMapping = (const __CFDictionary *)FigiTunesMetadataGetOSTypeKeyToShortStringKeyMapping();
        CFTypeID v16 = CFGetTypeID(v11);
        if (v16 == CFNumberGetTypeID())
        {
          CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt32Type, &valuePtr);
        }
        else
        {
          CFTypeID v19 = CFGetTypeID(v11);
          if (v19 != CFStringGetTypeID() || !FigiTunesMetadataShortStringKeyToOSTypeKey(v11, &valuePtr)) {
            return 4294954813;
          }
        }
        CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(OSTypeKeyToShortStringKeyMapping, (const void *)valuePtr);
        if (!v11) {
          goto LABEL_36;
        }
        if (CFEqual(*(CFTypeRef *)(v14 + 8), @"com.apple.quicktime.udta"))
        {
          long long v20 = &giTunesKeyToUserDataKeyDict;
        }
        else if (CFEqual(*(CFTypeRef *)(v14 + 8), @"org.mp4ra"))
        {
          long long v20 = &giTunesKeyToISOUserDataKeyDict;
        }
        else
        {
          if (!CFEqual(*(CFTypeRef *)(v14 + 8), @"com.apple.quicktime.mdta")) {
            return 4294954813;
          }
          long long v20 = &giTunesKeyToQTMetadataKeyDict;
        }
        MEMORY[0x19970EE10](&gCreateKeyArrayOnce_0, qtitunes_setUpKeyMapping);
        CFDictionaryRef v24 = (const __CFDictionary *)*v20;
      }
      else if (CFEqual(*v13, @"com.apple.quicktime.udta"))
      {
        unsigned int valuePtr = 0;
        CFDictionaryRef OSTypeKeyToStringKeyMapping = (const __CFDictionary *)FigUserDataGetOSTypeKeyToStringKeyMapping();
        CFTypeID v18 = CFGetTypeID(v11);
        if (v18 == CFNumberGetTypeID())
        {
          CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt32Type, &valuePtr);
        }
        else
        {
          CFTypeID v23 = CFGetTypeID(v11);
          if (v23 != CFStringGetTypeID() || !FigUserDataStringKeyToOSTypeKey(v11, &valuePtr)) {
            return 4294954813;
          }
        }
        CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(OSTypeKeyToStringKeyMapping, (const void *)valuePtr);
        if (!v11) {
          goto LABEL_36;
        }
        MEMORY[0x19970EE10](&gCreateKeyArrayOnce_0, qtitunes_setUpKeyMapping);
        CFDictionaryRef v24 = (const __CFDictionary *)gUserDataKeyToiTunesKeyDict;
      }
      else if (CFEqual(*v13, @"org.mp4ra"))
      {
        unsigned int valuePtr = 0;
        CFDictionaryRef v21 = (const __CFDictionary *)FigISOUserDataGetOSTypeKeyToStringKeyMapping();
        CFTypeID v22 = CFGetTypeID(v11);
        if (v22 == CFNumberGetTypeID())
        {
          CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt32Type, &valuePtr);
        }
        else
        {
          CFTypeID v25 = CFGetTypeID(v11);
          if (v25 != CFStringGetTypeID() || !FigISOUserDataStringKeyToOSTypeKey(v11, &valuePtr)) {
            return 4294954813;
          }
        }
        CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(v21, (const void *)valuePtr);
        if (!v11) {
          goto LABEL_36;
        }
        MEMORY[0x19970EE10](&gCreateKeyArrayOnce_0, qtitunes_setUpKeyMapping);
        CFDictionaryRef v24 = (const __CFDictionary *)gISOUserDataKeyToiTunesKeyDict;
      }
      else
      {
        if (!CFEqual(*v13, @"com.apple.quicktime.mdta"))
        {
          CFStringRef v11 = 0;
          if (!a4) {
            return 0;
          }
          goto LABEL_38;
        }
        MEMORY[0x19970EE10](&gCreateKeyArrayOnce_0, qtitunes_setUpKeyMapping);
        CFDictionaryRef v24 = (const __CFDictionary *)gQTMetadataKeyToiTunesKeyDict;
      }
      CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(v24, v11);
LABEL_36:
      if (v11)
      {
        if (!a4) {
          return 0;
        }
LABEL_38:
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (!Mutable) {
          return FigSignalErrorAt();
        }
        double v27 = Mutable;
        if (CFEqual(v9[1], @"com.apple.quicktime.mdta"))
        {
          long long v28 = v27;
          long long v29 = (uint64_t *)CMBaseObjectGetDerivedStorage();
          unsigned int valuePtr = 1;
          long long v30 = CFDictionaryGetValue(a2, @"value");
          CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v11;
          int v31 = CFEqual(v11, @"com.apple.quicktime.artwork");
          CFTypeID v32 = CFGetTypeID(v30);
          if (v31)
          {
            if (v32 == CFDataGetTypeID()
              && !FigMetadataGetNumericalDataTypeForMetadataProperties(*v29, a2, @"com.apple.quicktime.mdta", &valuePtr, 0)&& valuePtr <= 0x1B&& ((1 << valuePtr) & 0x8006000) != 0)
            {
              CFLocaleRef v39 = 0;
              double v27 = v28;
LABEL_56:
              CFNumberRef v40 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
              if (v40)
              {
                CFNumberRef v41 = v40;
                CFDictionaryAddValue(v27, @"dataType", v40);
                CFDictionaryAddValue(v27, @"dataTypeNamespace", @"com.apple.quicktime.mdta");
                CFDictionaryAddValue(v27, @"key", theDict);
                CFDictionaryAddValue(v27, @"value", v30);
                CFDictionaryAddValue(v27, @"keyspace", @"mdta");
                CFRelease(v41);
                uint64_t v12 = 0;
              }
              else
              {
                uint64_t v12 = FigSignalErrorAt();
              }
              goto LABEL_58;
            }
          }
          else if (v32 == CFStringGetTypeID())
          {
            CFLocaleRef v38 = CFLocaleCreate(a3, @"en");
            double v27 = v28;
            if (!v38)
            {
              uint64_t v12 = FigSignalErrorAt();
              goto LABEL_60;
            }
            CFLocaleRef v39 = v38;
            CFDictionaryAddValue(v28, @"locale", v38);
            unsigned int valuePtr = 1;
            goto LABEL_56;
          }
          uint64_t v12 = 4294954813;
          double v27 = v28;
          goto LABEL_44;
        }
        if (CFEqual(v9[1], @"com.apple.quicktime.udta"))
        {
          CFStringRef v33 = v11;
          CGRect v34 = CFDictionaryGetValue(a2, @"value");
          CFTypeID v35 = CFGetTypeID(v34);
          if (v35 != CFStringGetTypeID())
          {
            uint64_t v12 = 4294954813;
            goto LABEL_44;
          }
          unsigned int valuePtr = 0;
          CFNumberRef v36 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
          if (v36)
          {
            CFNumberRef v37 = v36;
            CFDictionaryAddValue(v27, @"key", v33);
            CFDictionaryAddValue(v27, @"value", v34);
            CFDictionaryAddValue(v27, @"languageCode", v37);
            CFDictionaryAddValue(v27, @"keyspace", @"udta");
            CFRelease(v37);
LABEL_61:
            uint64_t v12 = 0;
            *a4 = v27;
            return v12;
          }
          uint64_t ConvertedItem_DestinationiTunes = FigSignalErrorAt();
          if (!ConvertedItem_DestinationiTunes) {
            goto LABEL_61;
          }
          goto LABEL_79;
        }
        if (!CFEqual(v9[1], @"org.mp4ra"))
        {
          if (CFEqual(v9[1], @"com.apple.itunes"))
          {
            uint64_t ConvertedItem_DestinationiTunes = qtitunes_FigMetadataConverterCreateConvertedItem_DestinationiTunes(a1, a2, v11, v27);
            if (!ConvertedItem_DestinationiTunes) {
              goto LABEL_61;
            }
          }
          else
          {
            uint64_t ConvertedItem_DestinationiTunes = FigSignalErrorAt();
          }
LABEL_79:
          uint64_t v12 = ConvertedItem_DestinationiTunes;
          goto LABEL_44;
        }
        theDicta = v27;
        char v42 = (uint64_t *)CMBaseObjectGetDerivedStorage();
        int v56 = 1;
        unsigned int valuePtr = 0;
        double v43 = CFDictionaryGetValue(a2, @"value");
        CFStringRef v44 = v11;
        int v45 = CFEqual(v11, @"thmb");
        CFTypeID v46 = CFGetTypeID(v43);
        if (v45)
        {
          if (v46 == CFDataGetTypeID()
            && !FigMetadataGetNumericalDataTypeForMetadataProperties(*v42, a2, @"com.apple.itunes", &v56, 0)&& v56 == 13)
          {
            double v27 = theDicta;
            CFDictionaryAddValue(theDicta, @"dataType", (const void *)*MEMORY[0x1E4F22610]);
            CFDictionaryAddValue(theDicta, @"dataTypeNamespace", @"com.apple.uti");
            CFNumberRef v47 = 0;
            CFLocaleRef v39 = 0;
            CFStringRef v48 = v44;
            goto LABEL_85;
          }
        }
        else if (v46 == CFStringGetTypeID())
        {
          CFNumberRef v50 = (const __CFNumber *)CFDictionaryGetValue(a2, @"languageCode");
          if (v50)
          {
            CFNumberRef v47 = v50;
            CFRetain(v50);
          }
          else
          {
            unsigned int valuePtr = 0;
            CFNumberRef v47 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
            if (!v47)
            {
              uint64_t v12 = FigSignalErrorAt();
              double v27 = theDicta;
              goto LABEL_60;
            }
          }
          CFDictionaryAddValue(theDicta, @"languageCode", v47);
          CFLocaleRef v52 = (const __CFLocale *)CFDictionaryGetValue(a2, @"locale");
          CFStringRef v48 = v44;
          if (v52)
          {
            CFLocaleRef v39 = v52;
            CFRetain(v52);
          }
          else
          {
            CFLocaleRef v39 = CFLocaleCreate(a3, @"en");
            if (!v39)
            {
              uint64_t v53 = FigSignalErrorAt();
              double v27 = theDicta;
LABEL_86:
              CFRelease(v47);
              uint64_t v12 = v53;
LABEL_58:
              if (v39) {
                CFRelease(v39);
              }
LABEL_60:
              if (!v12) {
                goto LABEL_61;
              }
LABEL_44:
              CFRelease(v27);
              return v12;
            }
          }
          double v27 = theDicta;
          CFDictionaryAddValue(theDicta, @"locale", v39);
LABEL_85:
          CFDictionaryAddValue(v27, @"key", v48);
          CFDictionaryAddValue(v27, @"value", v43);
          CFDictionaryAddValue(v27, @"keyspace", @"uiso");
          uint64_t v53 = 0;
          uint64_t v12 = 0;
          if (!v47) {
            goto LABEL_58;
          }
          goto LABEL_86;
        }
        uint64_t v12 = 4294954813;
        double v27 = theDicta;
        goto LABEL_44;
      }
      return 4294954813;
    }
  }

  return FigSignalErrorAt();
}

uint64_t qtitunes_FigMetadataConverterCreateConvertedItem_DestinationiTunes(uint64_t a1, const __CFDictionary *a2, const void *a3, __CFDictionary *a4)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  unsigned int v17 = 1;
  int valuePtr = 0;
  CFStringRef Value = CFDictionaryGetValue(a2, @"value");
  int v9 = CFEqual(a3, @"covr");
  CFTypeID v10 = CFGetTypeID(Value);
  if (!v9)
  {
    if (v10 != CFStringGetTypeID()) {
      return 4294954813;
    }
    CFLocaleRef v12 = (const __CFLocale *)CFDictionaryGetValue(a2, @"locale");
    CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(a2, @"languageCode");
    if (v13)
    {
      CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr && valuePtr != 5575) {
        return 4294954813;
      }
    }
    else if (v12)
    {
      CFStringRef v16 = (const __CFString *)CFLocaleGetValue(v12, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
      if (v16)
      {
        if (CFStringCompare(v16, @"en", 0)) {
          return 4294954813;
        }
      }
    }
LABEL_17:
    CFDictionaryAddValue(a4, @"key", a3);
    CFDictionaryAddValue(a4, @"value", Value);
    CFDictionaryAddValue(a4, @"keyspace", @"itsk");
    return 0;
  }
  if (v10 != CFDataGetTypeID()
    || FigMetadataGetNumericalDataTypeForMetadataProperties(*DerivedStorage, a2, @"com.apple.itunes", &v17, 0))
  {
    return 4294954813;
  }
  uint64_t result = 4294954813;
  if (v17 <= 0x1B && ((1 << v17) & 0x8006000) != 0)
  {
    CFNumberRef v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v17);
    if (!v14) {
      return FigSignalErrorAt();
    }
    CFNumberRef v15 = v14;
    CFDictionaryAddValue(a4, @"dataType", v14);
    CFDictionaryAddValue(a4, @"dataTypeNamespace", @"com.apple.itunes");
    CFRelease(v15);
    goto LABEL_17;
  }
  return result;
}

CFDictionaryRef qtitunes_setUpKeyMapping()
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  keys = @"com.apple.quicktime.arranger";
  long long v73 = @"com.apple.quicktime.album";
  long long v74 = @"com.apple.quicktime.artist";
  long long v75 = @"com.apple.quicktime.author";
  long long v76 = @"com.apple.quicktime.comment";
  long long v77 = @"com.apple.quicktime.copyright";
  long long v78 = @"com.apple.quicktime.artwork";
  long long v79 = @"com.apple.quicktime.creationdate";
  long long v80 = @"com.apple.quicktime.description";
  long long v81 = @"com.apple.quicktime.information";
  long long v82 = @"com.apple.quicktime.director";
  long long v83 = @"com.apple.quicktime.encodedby";
  long long v84 = @"com.apple.quicktime.displayname";
  long long v85 = @"com.apple.quicktime.title";
  long long v86 = @"com.apple.quicktime.genre";
  long long v87 = @"com.apple.quicktime.make";
  long long v88 = @"com.apple.quicktime.originalartist";
  long long v89 = @"com.apple.quicktime.performer";
  long long v90 = @"com.apple.quicktime.producer";
  long long v91 = @"com.apple.quicktime.publisher";
  long long v92 = @"com.apple.quicktime.composer";
  CFRange v93 = @"com.apple.quicktime.credits";
  CFRange v94 = @"com.apple.quicktime.phonogramrights";
  CFIndex v7 = @"com.apple.quicktime.arranger";
  char v8 = @"com.apple.quicktime.album";
  values = @"@arg";
  CFNumberRef v50 = @"@alb";
  int v9 = @"com.apple.quicktime.artist";
  long long v51 = @"@ART";
  CFLocaleRef v52 = @"@aut";
  CFTypeID v10 = @"com.apple.quicktime.author";
  CFStringRef v11 = @"com.apple.quicktime.comment";
  uint64_t v53 = @"@cmt";
  long long v54 = @"cprt";
  CFLocaleRef v12 = @"com.apple.quicktime.copyright";
  CFNumberRef v13 = @"com.apple.quicktime.artwork";
  CFNumberRef v14 = @"com.apple.quicktime.creationdate";
  long long v55 = @"covr";
  int v56 = @"@day";
  CFNumberRef v15 = @"com.apple.quicktime.description";
  long long v57 = @"@des";
  long long v58 = @"@des";
  CFStringRef v16 = @"com.apple.quicktime.director";
  long long v59 = @"@dir";
  long long v60 = @"@enc";
  unsigned int v17 = @"com.apple.quicktime.encodedby";
  long long v61 = @"@nam";
  long long v62 = @"@nam";
  CFTypeID v18 = @"com.apple.quicktime.displayname";
  CFTypeID v19 = @"com.apple.quicktime.genre";
  double v63 = @"@gen";
  double v64 = @"@mak";
  long long v20 = @"com.apple.quicktime.make";
  CFDictionaryRef v21 = @"com.apple.quicktime.originalartist";
  CFTypeID v22 = @"com.apple.quicktime.performer";
  uint64_t v65 = @"@ope";
  uint64_t v66 = @"@prf";
  CFTypeID v23 = @"com.apple.quicktime.producer";
  long long v67 = @"@prd";
  long long v68 = @"@pub";
  CFDictionaryRef v24 = @"com.apple.quicktime.publisher";
  CFTypeID v25 = @"com.apple.quicktime.composer";
  long long v69 = @"@wrt";
  long long v70 = @"@src";
  long long v26 = @"com.apple.quicktime.credits";
  long long v71 = @"@phg";
  long long v28 = @"@arg";
  long long v29 = @"@alb";
  long long v30 = @"@ART";
  int v31 = @"@aut";
  CFTypeID v32 = @"@cmt";
  CFStringRef v33 = @"cprt";
  CGRect v34 = @"covr";
  CFTypeID v35 = @"@day";
  CFNumberRef v36 = @"@des";
  CFNumberRef v37 = @"@dir";
  CFLocaleRef v38 = @"@enc";
  CFLocaleRef v39 = @"@nam";
  CFNumberRef v40 = @"@gen";
  CFNumberRef v41 = @"@mak";
  char v42 = @"@ope";
  double v43 = @"@prf";
  CFStringRef v44 = @"@prd";
  int v45 = @"@pub";
  CFTypeID v46 = @"@wrt";
  CFNumberRef v47 = @"@src";
  CFStringRef v48 = @"@phg";
  double v27 = @"com.apple.quicktime.phonogramrights";
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  double v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  gQTMetadataKeyToiTunesKeyDict = (uint64_t)CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 23, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  giTunesKeyToQTMetadataKeyDict = (uint64_t)CFDictionaryCreate(v0, (const void **)&v28, (const void **)&v7, 21, v1, v2);
  long long v80 = @"@inf";
  long long v84 = @"tnam";
  long long v28 = @"@arg";
  values = @"@arg";
  CFNumberRef v50 = @"@alb";
  long long v29 = @"@alb";
  uint64_t v53 = @"@cmt";
  CFTypeID v32 = @"@cmt";
  long long v59 = @"@enc";
  CFNumberRef v37 = @"@enc";
  long long v62 = @"@gen";
  CFLocaleRef v39 = @"@gen";
  CFNumberRef v40 = @"@mak";
  double v63 = @"@mak";
  long long v68 = @"@wrt";
  int v45 = @"@wrt";
  CFTypeID v46 = @"@src";
  long long v69 = @"@src";
  long long v70 = @"@phg";
  CFNumberRef v47 = @"@phg";
  CFIndex v7 = @"@arg";
  keys = @"@arg";
  long long v73 = @"@alb";
  char v8 = @"@alb";
  long long v74 = @"@ART";
  long long v75 = @"@aut";
  int v9 = @"@ART";
  CFTypeID v10 = @"@aut";
  long long v76 = @"@cmt";
  long long v77 = @"@cpy";
  CFStringRef v11 = @"@cmt";
  CFLocaleRef v12 = @"@cpy";
  long long v78 = @"@day";
  long long v79 = @"@des";
  long long v81 = @"@dir";
  CFNumberRef v13 = @"@day";
  CFNumberRef v14 = @"@des";
  CFNumberRef v15 = @"@dir";
  CFStringRef v16 = @"@enc";
  long long v82 = @"@enc";
  long long v83 = @"@nam";
  long long v85 = @"@gen";
  unsigned int v17 = @"@nam";
  CFTypeID v18 = @"@gen";
  CFTypeID v19 = @"@mak";
  long long v86 = @"@mak";
  long long v87 = @"@ope";
  long long v20 = @"@ope";
  long long v88 = @"@prf";
  long long v89 = @"@prd";
  CFDictionaryRef v21 = @"@prf";
  CFTypeID v22 = @"@prd";
  long long v90 = @"@pub";
  long long v91 = @"@wrt";
  CFTypeID v23 = @"@pub";
  CFDictionaryRef v24 = @"@wrt";
  CFTypeID v25 = @"@src";
  long long v26 = @"@phg";
  long long v92 = @"@src";
  CFRange v93 = @"@phg";
  long long v61 = @"@nam";
  long long v67 = @"@pub";
  CFNumberRef v36 = @"@dir";
  CFLocaleRef v38 = @"@nam";
  CFStringRef v44 = @"@pub";
  long long v51 = @"@ART";
  CFLocaleRef v52 = @"@aut";
  long long v54 = @"cprt";
  long long v55 = @"@day";
  int v56 = @"@des";
  long long v57 = @"@des";
  long long v58 = @"@dir";
  long long v60 = @"@nam";
  double v64 = @"@ope";
  uint64_t v65 = @"@prf";
  uint64_t v66 = @"@prd";
  long long v30 = @"@ART";
  int v31 = @"@aut";
  CFStringRef v33 = @"cprt";
  CGRect v34 = @"@day";
  CFTypeID v35 = @"@des";
  CFNumberRef v41 = @"@ope";
  char v42 = @"@prf";
  double v43 = @"@prd";
  double v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFDictionaryRef v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  gUserDataKeyToiTunesKeyDict = (uint64_t)CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 22, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  giTunesKeyToUserDataKeyDict = (uint64_t)CFDictionaryCreate(allocator, (const void **)&v7, (const void **)&v28, 20, v3, v4);
  long long v28 = @"cprt";
  long long v29 = @"perf";
  long long v30 = @"auth";
  int v31 = @"dscp";
  CFTypeID v32 = @"titl";
  CFStringRef v33 = @"yrrc";
  CGRect v34 = @"thmb";
  CFIndex v7 = @"cprt";
  char v8 = @"@prf";
  int v9 = @"@aut";
  CFTypeID v10 = @"@des";
  CFStringRef v11 = @"@nam";
  CFLocaleRef v12 = @"@day";
  CFNumberRef v13 = @"covr";
  keys = @"cprt";
  long long v73 = @"@prf";
  long long v74 = @"@pub";
  long long v75 = @"@prd";
  long long v76 = @"@dir";
  long long v77 = @"@ART";
  long long v78 = @"@ope";
  long long v79 = @"@aut";
  long long v80 = @"@des";
  long long v81 = @"@nam";
  long long v82 = @"@day";
  long long v83 = @"covr";
  values = @"cprt";
  CFNumberRef v50 = @"perf";
  long long v51 = @"perf";
  CFLocaleRef v52 = @"perf";
  uint64_t v53 = @"perf";
  long long v54 = @"perf";
  long long v55 = @"perf";
  int v56 = @"auth";
  long long v57 = @"dscp";
  long long v58 = @"titl";
  long long v59 = @"yrrc";
  long long v60 = @"thmb";
  gISOUserDataKeyToiTunesKeyDict = (uint64_t)CFDictionaryCreate(allocator, (const void **)&v28, (const void **)&v7, 7, v3, v4);
  CFDictionaryRef result = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 12, v3, v4);
  giTunesKeyToISOUserDataKeyDict = (uint64_t)result;
  return result;
}

uint64_t FigPhotoReleaseHardwareResources()
{
  return MEMORY[0x1F410DB40]();
}

uint64_t MTCopyStringsForMediaTypeAndSubType(unsigned int a1, uint64_t a2, CFStringRef *a3, CFStringRef *a4)
{
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.MediaToolbox");
  if (BundleWithIdentifier)
  {
    int v9 = BundleWithIdentifier;
    unsigned int v22 = bswap32(a1);
    if (a3)
    {
      uint64_t result = FigCopyMediaTypeString(BundleWithIdentifier, a1, a3);
      if (result) {
        return result;
      }
      CFStringRef v11 = *a3;
      if (!a4) {
        return 0;
      }
    }
    else
    {
      CFStringRef v11 = 0;
      if (!a4) {
        return 0;
      }
    }
    CFStringRef outPropertyData = 0;
    if (!a1) {
      return FigSignalErrorAt();
    }
    if (a2)
    {
      if (a1 == 1936684398)
      {
        uint64_t v19 = 0;
        memset(inSpecifier, 0, sizeof(inSpecifier));
        UInt32 ioPropertyDataSize = 8;
        DWORD2(inSpecifier[0]) = a2;
        OSStatus Property = AudioFormatGetProperty(0x666E616Du, 0x28u, inSpecifier, &ioPropertyDataSize, &outPropertyData);
        CFStringRef v13 = outPropertyData;
        if (Property)
        {
          if (!outPropertyData) {
            goto LABEL_19;
          }
          return 0;
        }
        *a4 = outPropertyData;
        if (v13) {
          return 0;
        }
      }
LABEL_19:
      LODWORD(inSpecifier[0]) = bswap32(a2);
      CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (a1 == 1986618469 && a2 <= 0x28) {
        CFStringRef v15 = CFStringCreateWithFormat(v14, 0, @"%.4s%d", &v22, a2, *(void *)&inSpecifier[0]);
      }
      else {
        CFStringRef v15 = CFStringCreateWithFormat(v14, 0, @"%.4s%.4s", &v22, inSpecifier, *(void *)&inSpecifier[0]);
      }
      CFStringRef v16 = v15;
      if (v15)
      {
        CFStringRef v17 = CFBundleCopyLocalizedString(v9, v15, v15, @"MediaAndSubtypes");
        *a4 = v17;
        if (v17 == v16)
        {
          CFRelease(v16);
          *a4 = CFStringCreateWithFormat(v14, 0, @"%.4s", inSpecifier);
        }
        CFRelease(v16);
        return 0;
      }
      return FigSignalErrorAt();
    }
    if (a1 != 1868720741 && a1 != 1936749172 && a1 != 1885433455) {
      return 0;
    }
    if (v11)
    {
      *a4 = (CFStringRef)CFRetain(v11);
      return 0;
    }
    uint64_t result = FigCopyMediaTypeString(v9, a1, a4);
    if (!result) {
      return 0;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t FigCopyMediaTypeString(__CFBundle *a1, unsigned int a2, CFStringRef *a3)
{
  unsigned int v8 = bswap32(a2);
  if (a2)
  {
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%.4s", &v8);
    if (v5)
    {
      CFStringRef v6 = v5;
      *a3 = CFBundleCopyLocalizedString(a1, v5, v5, @"MediaAndSubtypes");
      CFRelease(v6);
      return 0;
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
}

CFStringRef MTCopyLocalizedNameForMediaType(CMMediaType mediaType)
{
  CFStringRef v2 = 0;
  MTCopyStringsForMediaTypeAndSubType(mediaType, 0, &v2, 0);
  return v2;
}

CFStringRef MTCopyLocalizedNameForMediaSubType(CMMediaType mediaType, FourCharCode mediaSubType)
{
  CFStringRef v3 = 0;
  MTCopyStringsForMediaTypeAndSubType(mediaType, *(uint64_t *)&mediaSubType, 0, &v3);
  return v3;
}

__CFBundle *MTCopyLocalizedStringForVideoDynamicRange(int a1)
{
  uint64_t result = CFBundleGetBundleWithIdentifier(@"com.apple.MediaToolbox");
  if (result)
  {
    if ((a1 - 1) > 9) {
      CFStringRef v3 = @"VideoDynamicRangeUnknown";
    }
    else {
      CFStringRef v3 = off_1E57A1930[a1 - 1];
    }
    return (__CFBundle *)CFBundleCopyLocalizedString(result, v3, v3, @"MediaAndSubtypes");
  }
  return result;
}

uint64_t MTGetVideoDynamicRangeQualityGrade(int a1)
{
  if ((a1 - 1) > 9) {
    return 0;
  }
  else {
    return byte_194998754[a1 - 1];
  }
}

__CFString *MTCopyStringForColorInfo(int a1, CMFormatDescriptionRef desc)
{
  if (a1 != 1986618469) {
    return 0;
  }
  CFStringRef Extension = (const __CFString *)CMFormatDescriptionGetExtension(desc, (CFStringRef)*MEMORY[0x1E4F24A90]);
  CFStringRef v4 = (const __CFString *)CMFormatDescriptionGetExtension(desc, (CFStringRef)*MEMORY[0x1E4F24BC8]);
  CFStringRef v5 = (const __CFString *)CMFormatDescriptionGetExtension(desc, (CFStringRef)*MEMORY[0x1E4F24C18]);
  CFPropertyListRef v6 = CMFormatDescriptionGetExtension(desc, (CFStringRef)*MEMORY[0x1E4F1EE00]);
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(desc);
  int v8 = 0;
  if (MediaSubType <= 1685481572)
  {
    if (MediaSubType == 1667524657 || MediaSubType == 1684895096)
    {
LABEL_13:
      if (!Extension) {
        return 0;
      }
      goto LABEL_14;
    }
    int v10 = 1685481521;
  }
  else
  {
    if (MediaSubType > 1902405732)
    {
      if (MediaSubType == 1902405733) {
        goto LABEL_13;
      }
      unsigned __int16 v9 = 28024;
    }
    else
    {
      if (MediaSubType == 1685481573) {
        goto LABEL_13;
      }
      unsigned __int16 v9 = 26673;
    }
    int v10 = v9 | 0x71640000;
  }
  if (MediaSubType == v10) {
    goto LABEL_13;
  }
  int v8 = 1;
  if (!Extension) {
    return 0;
  }
LABEL_14:
  CFTypeID v11 = CFGetTypeID(Extension);
  if (v11 == CFStringGetTypeID() && v4 != 0)
  {
    CFTypeID v13 = CFGetTypeID(v4);
    if (v13 == CFStringGetTypeID() && v5 != 0)
    {
      CFTypeID v15 = CFGetTypeID(v5);
      if (v15 == CFStringGetTypeID())
      {
        CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
        int v17 = CFEqual(Extension, (CFTypeRef)*MEMORY[0x1E4F24AC8]);
        CFTypeID v18 = (CFTypeRef *)MEMORY[0x1E4F24AB0];
        if (v17 && CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F24AB0]) && CFEqual(v5, (CFTypeRef)*MEMORY[0x1E4F24C40]))
        {
          CFStringRef v19 = @"SD ";
          goto LABEL_60;
        }
        CFDictionaryRef v21 = (const void *)*MEMORY[0x1E4F24BE0];
        if (CFEqual(Extension, (CFTypeRef)*MEMORY[0x1E4F24BE0])
          && CFEqual(v4, v21)
          && CFEqual(v5, (CFTypeRef)*MEMORY[0x1E4F24C40]))
        {
          CFStringRef v19 = @"PAL ";
          goto LABEL_60;
        }
        if (CFEqual(Extension, *v18) && CFEqual(v4, v21))
        {
          int v22 = CFEqual(v5, (CFTypeRef)*MEMORY[0x1E4F24C48]);
          if (v22) {
            char v23 = 0;
          }
          else {
            char v23 = v8;
          }
          if (v22) {
            CFStringRef v19 = @"HD ";
          }
          else {
            CFStringRef v19 = @"Dolby Vision ";
          }
          if ((v23 & 1) == 0) {
            goto LABEL_60;
          }
        }
        else if (!v8)
        {
          CFStringRef v19 = @"Dolby Vision ";
          goto LABEL_60;
        }
        if (CFEqual(Extension, (CFTypeRef)*MEMORY[0x1E4F1ED00]))
        {
          CFStringRef v24 = @"P3 D65 ";
        }
        else if (CFEqual(Extension, (CFTypeRef)*MEMORY[0x1E4F1ECE8]))
        {
          CFStringRef v24 = @"BT.2020 ";
        }
        else
        {
          if (!CFEqual(Extension, (CFTypeRef)*MEMORY[0x1E4F1ECD8]))
          {
LABEL_53:
            CFTypeID v25 = (const void *)*MEMORY[0x1E4F1EF18];
            int v26 = CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F1EF18]);
            if (v6 && v26)
            {
              CFStringRef v19 = @"HDR10 ";
            }
            else if (CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F1EEF8]))
            {
              CFStringRef v19 = @"HLG ";
            }
            else
            {
              if (!CFEqual(v4, v25))
              {
LABEL_61:
                unsigned __int16 IntegerCodePointForString = CVColorPrimariesGetIntegerCodePointForString(Extension);
                unsigned __int16 v28 = CVTransferFunctionGetIntegerCodePointForString(v4);
                unsigned __int16 v29 = CVYCbCrMatrixGetIntegerCodePointForString(v5);
                CFStringRef v30 = CFStringCreateWithFormat(0, 0, @"(%d-%d-%d)", IntegerCodePointForString, v28, v29);
                CFStringAppend(Mutable, v30);
                CFRelease(v30);
                return Mutable;
              }
              CFStringRef v19 = @"PQ ";
            }
LABEL_60:
            CFStringAppend(Mutable, v19);
            goto LABEL_61;
          }
          CFStringRef v24 = @"DCI P3 ";
        }
        CFStringAppend(Mutable, v24);
        goto LABEL_53;
      }
    }
  }
  return 0;
}

uint64_t FigComputeMovieDimensions(uint64_t a1, CGRect *a2)
{
  memset(&v57, 0, sizeof(v57));
  CFTypeRef cf = 0;
  uint64_t v4 = *MEMORY[0x1E4F1CF80];
  uint64_t FigBaseObject = FigFormatReaderGetFigBaseObject(a1);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  CFArrayRef v58 = 0;
  uint64_t v56 = 0;
  int v8 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, const __CFArray **))(v7 + 48);
  unsigned __int16 v9 = (_OWORD *)MEMORY[0x1E4F1DAB8];
  if (v8 && !v8(FigBaseObject, @"MovieMatrix", v4, &v58))
  {
    MatrixArrayToCGAffineTransform(v58, &v57.a);
    CFRelease(v58);
  }
  else
  {
    long long v10 = v9[1];
    *(_OWORD *)&v57.a = *v9;
    *(_OWORD *)&v57.c = v10;
    *(_OWORD *)&v57.tCGFloat x = v9[2];
  }
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  CFTypeID v13 = *(uint64_t (**)(uint64_t, uint64_t *))(v12 + 8);
  if (!v13)
  {
LABEL_48:
    uint64_t v47 = 4294954514;
    goto LABEL_49;
  }
  uint64_t v14 = v13(a1, &v56);
  if (v14)
  {
LABEL_55:
    uint64_t v47 = v14;
  }
  else
  {
    if (v56 >= 1)
    {
      uint64_t v15 = 0;
      int v16 = 0;
      CGFloat v17 = 0.0;
      CGFloat v18 = 0.0;
      CGFloat v19 = 0.0;
      CGFloat v20 = 0.0;
      while (1)
      {
        int v54 = 0;
        BOOLeaCFIndex n = 0;
        uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v22 = v21 ? v21 : 0;
        char v23 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *, int *, void))(v22 + 48);
        if (!v23) {
          goto LABEL_48;
        }
        uint64_t v14 = v23(a1, v15, &cf, &v54, 0);
        if (v14) {
          goto LABEL_55;
        }
        uint64_t v24 = FigTrackReaderGetFigBaseObject(cf);
        uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 8);
        uint64_t v26 = v25 ? v25 : 0;
        double v27 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFBooleanRef *))(v26 + 48);
        if (!v27) {
          goto LABEL_48;
        }
        uint64_t v14 = v27(v24, @"TrackEnabled", v4, &BOOLean);
        if (v14) {
          goto LABEL_55;
        }
        int Value = CFBooleanGetValue(BOOLean);
        CFRelease(BOOLean);
        if (Value)
        {
          CFTypeRef v51 = 0;
          CFDictionaryRef theDict = 0;
          memset(&v50, 0, sizeof(v50));
          uint64_t v29 = FigTrackReaderGetFigBaseObject(cf);
          uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v30) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = 0;
          }
          CFTypeID v32 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFDictionaryRef *))(v31 + 48);
          if (!v32) {
            goto LABEL_48;
          }
          uint64_t v14 = v32(v29, @"TrackDimensions", v4, &theDict);
          if (v14) {
            goto LABEL_55;
          }
          CFDictionaryRef v33 = theDict;
          LODWORD(valuePtr.a) = 0;
          v59[0] = 0.0;
          CFNumberRef v34 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"Width");
          CFNumberGetValue(v34, kCFNumberFloat32Type, &valuePtr);
          CFNumberRef v35 = (const __CFNumber *)CFDictionaryGetValue(v33, @"Height");
          CFNumberGetValue(v35, kCFNumberFloat32Type, v59);
          float v36 = *(float *)&valuePtr.a;
          float v37 = v59[0];
          CFRelease(theDict);
          if (v36 == 0.0 || v37 == 0.0)
          {
            CGFloat height = v20;
            CGFloat width = v19;
            CGFloat y = v18;
            CGFloat x = v17;
          }
          else
          {
            uint64_t v38 = FigTrackReaderGetFigBaseObject(cf);
            uint64_t v39 = *(void *)(CMBaseObjectGetVTable() + 8);
            if (v39) {
              uint64_t v40 = v39;
            }
            else {
              uint64_t v40 = 0;
            }
            int v45 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v40 + 48);
            if (v45 && !v45(v38, @"TrackMatrix", v4, &v51))
            {
              MatrixArrayToCGAffineTransform((const __CFArray *)v51, &v50.a);
              CFRelease(v51);
            }
            else
            {
              long long v46 = v9[1];
              *(_OWORD *)&v50.a = *v9;
              *(_OWORD *)&v50.c = v46;
              *(_OWORD *)&v50.tCGFloat x = v9[2];
            }
            v60.size.CGFloat width = v36;
            v60.size.CGFloat height = v37;
            CGAffineTransform valuePtr = v50;
            v60.origin.CGFloat x = 0.0;
            v60.origin.CGFloat y = 0.0;
            CGRect v61 = CGRectApplyAffineTransform(v60, &valuePtr);
            CGFloat x = v61.origin.x;
            CGFloat y = v61.origin.y;
            CGFloat width = v61.size.width;
            CGFloat height = v61.size.height;
            if (v16)
            {
              v62.origin.CGFloat x = v17;
              v62.origin.CGFloat y = v18;
              v62.size.CGFloat width = v19;
              v62.size.CGFloat height = v20;
              CGRect v63 = CGRectUnion(v62, *(CGRect *)&x);
              CGFloat x = v63.origin.x;
              CGFloat y = v63.origin.y;
              CGFloat width = v63.size.width;
              CGFloat height = v63.size.height;
            }
            int v16 = 1;
          }
          CGFloat v20 = height;
          CGFloat v19 = width;
          CGFloat v18 = y;
          CGFloat v17 = x;
        }
        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0;
        }
        if (++v15 >= v56) {
          goto LABEL_54;
        }
      }
    }
    CGFloat v20 = 0.0;
    CGFloat v19 = 0.0;
    CGFloat v18 = 0.0;
    CGFloat v17 = 0.0;
LABEL_54:
    CGAffineTransform v50 = v57;
    v64.origin.CGFloat x = v17;
    v64.origin.CGFloat y = v18;
    v64.size.CGFloat width = v19;
    v64.size.CGFloat height = v20;
    uint64_t v47 = 0;
    *a2 = CGRectApplyAffineTransform(v64, &v50);
  }
LABEL_49:
  if (cf) {
    CFRelease(cf);
  }
  return v47;
}

double MatrixArrayToCGAffineTransform@<D0>(const __CFArray *a1@<X0>, double *a2@<X8>)
{
  float valuePtr = 0.0;
  float v18 = 0.0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 0);
  CFNumberGetValue(ValueAtIndex, kCFNumberFloat32Type, &valuePtr);
  CFNumberRef v5 = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 1);
  CFNumberGetValue(v5, kCFNumberFloat32Type, &v18);
  CFNumberRef v6 = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 3);
  CFNumberGetValue(v6, kCFNumberFloat32Type, (char *)&v17 + 4);
  CFNumberRef v7 = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 4);
  CFNumberGetValue(v7, kCFNumberFloat32Type, &v17);
  CFNumberRef v8 = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 6);
  CFNumberGetValue(v8, kCFNumberFloat32Type, (char *)&v16 + 4);
  CFNumberRef v9 = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 7);
  CFNumberGetValue(v9, kCFNumberFloat32Type, &v16);
  double result = valuePtr;
  double v11 = v18;
  double v12 = *((float *)&v17 + 1);
  double v13 = *(float *)&v17;
  double v14 = *((float *)&v16 + 1);
  double v15 = *(float *)&v16;
  *a2 = valuePtr;
  a2[1] = v11;
  a2[2] = v12;
  a2[3] = v13;
  a2[4] = v14;
  a2[5] = v15;
  return result;
}

uint64_t FigGetTrackUneditedDurationWithPossibleFallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFTypeRef v29 = 0;
  uint64_t v5 = *MEMORY[0x1E4F1CF80];
  uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(a2);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  CFNumberRef v9 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v8 + 48);
  if (!v9 || (v9(FigBaseObject, @"UneditedTrackDuration", v5, &v29), (CFTypeRef v10 = v29) == 0))
  {
    cf.CMTimeValue value = 0;
    uint64_t v11 = FigFormatReaderGetFigBaseObject(a1);
    uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v12) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    double v14 = *(void (**)(uint64_t, __CFString *, uint64_t, CMTime *))(v13 + 48);
    if (v14)
    {
      v14(v11, @"SampleCursorTimeAccuracyIsExact", v5, &cf);
      CMTimeValue value = cf.value;
    }
    else
    {
      CMTimeValue value = 0;
    }
    if (value != *MEMORY[0x1E4F1CFD0])
    {
      uint64_t v16 = FigFormatReaderGetFigBaseObject(a1);
      uint64_t v17 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v18 = v17 ? v17 : 0;
      CGFloat v19 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v18 + 48);
      if (v19) {
        v19(v16, @"EstimatedDuration", v5, &v29);
      }
    }
    if (!v29)
    {
      uint64_t v24 = FigFormatReaderGetFigBaseObject(a1);
      uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v26 = v25 ? v25 : 0;
      double v27 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v26 + 48);
      if (v27) {
        v27(v24, @"NominalDuration", v5, &v29);
      }
    }
    if (cf.value) {
      CFRelease((CFTypeRef)cf.value);
    }
    CFTypeRef v10 = v29;
    if (!v29) {
      goto LABEL_24;
    }
  }
  CFTypeID v20 = CFGetTypeID(v10);
  if (v20 == CFDictionaryGetTypeID())
  {
    CMTimeMakeFromDictionary(&cf, (CFDictionaryRef)v29);
    *(_OWORD *)a3 = *(_OWORD *)&cf.value;
    CMTimeEpoch epoch = cf.epoch;
  }
  else
  {
LABEL_24:
    uint64_t v22 = MEMORY[0x1E4F1FA48];
    *(_OWORD *)a3 = *MEMORY[0x1E4F1FA48];
    CMTimeEpoch epoch = *(void *)(v22 + 16);
  }
  *(void *)(a3 + 16) = epoch;
  if (v29) {
    CFRelease(v29);
  }
  return 0;
}

uint64_t FigCFStringIsISOExtension(CFStringRef theString2)
{
  if (!theString2) {
    return 0;
  }
  uint64_t v2 = 1;
  if (CFStringCompare(@"m4a", theString2, 1uLL))
  {
    uint64_t v2 = 1;
    if (CFStringCompare(@"m4p", theString2, 1uLL))
    {
      uint64_t v2 = 1;
      if (CFStringCompare(@"m4v", theString2, 1uLL))
      {
        uint64_t v2 = 1;
        if (CFStringCompare(@"m4b", theString2, 1uLL))
        {
          uint64_t v2 = 1;
          if (CFStringCompare(@"m4r", theString2, 1uLL))
          {
            uint64_t v2 = 1;
            if (CFStringCompare(@"mp4", theString2, 1uLL))
            {
              uint64_t v2 = 1;
              if (CFStringCompare(@"aax", theString2, 1uLL))
              {
                uint64_t v2 = 1;
                if (CFStringCompare(@"3gp", theString2, 1uLL))
                {
                  uint64_t v2 = 1;
                  if (CFStringCompare(@"3gpp", theString2, 1uLL))
                  {
                    uint64_t v2 = 1;
                    if (CFStringCompare(@"3g2", theString2, 1uLL))
                    {
                      uint64_t v2 = 1;
                      if (CFStringCompare(@"3gp2", theString2, 1uLL)) {
                        return 0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v2;
}

uint64_t FigCFStringIsHEIFExtension(CFStringRef theString2)
{
  if (!theString2) {
    return 0;
  }
  uint64_t v2 = 1;
  if (CFStringCompare(@"heic", theString2, 1uLL))
  {
    uint64_t v2 = 1;
    if (CFStringCompare(@"heics", theString2, 1uLL))
    {
      uint64_t v2 = 1;
      if (CFStringCompare(@"heif", theString2, 1uLL))
      {
        uint64_t v2 = 1;
        if (CFStringCompare(@"heifs", theString2, 1uLL))
        {
          uint64_t v2 = 1;
          if (CFStringCompare(@"hif", theString2, 1uLL))
          {
            uint64_t v2 = 1;
            if (CFStringCompare(@"avci", theString2, 1uLL))
            {
              uint64_t v2 = 1;
              if (CFStringCompare(@"avcs", theString2, 1uLL))
              {
                uint64_t v2 = 1;
                if (CFStringCompare(@"avif", theString2, 1uLL))
                {
                  uint64_t v2 = 1;
                  if (CFStringCompare(@"avis", theString2, 1uLL)) {
                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v2;
}

uint64_t FigFileTypeIsQTMovieFileType()
{
  if (FigCFEqual()) {
    return 1;
  }
  uint64_t result = FigCFEqual();
  if (result) {
    return 1;
  }
  return result;
}

uint64_t FigFileTypeIsISOFileType()
{
  if (FigCFEqual()) {
    return 1;
  }
  if (FigCFEqual()) {
    return 1;
  }
  if (FigCFEqual()) {
    return 1;
  }
  uint64_t result = FigCFEqual();
  if (result) {
    return 1;
  }
  return result;
}

__CFString *FigGetFileTypeForMovieFamilyExtension(CFStringRef theString2)
{
  if (!theString2) {
    return 0;
  }
  if (CFStringCompare(@"mov", theString2, 1uLL) == kCFCompareEqualTo) {
    return @"com.apple.quicktime-movie";
  }
  if (CFStringCompare(@"qta", theString2, 1uLL) == kCFCompareEqualTo) {
    return @"com.apple.quicktime-audio";
  }
  CFArrayRef AllIdentifiersForTag = UTTypeCreateAllIdentifiersForTag((CFStringRef)*MEMORY[0x1E4F224F8], theString2, (CFStringRef)*MEMORY[0x1E4F22548]);
  CFArrayRef v3 = AllIdentifiersForTag;
  if (AllIdentifiersForTag) {
    CFIndex Count = CFArrayGetCount(AllIdentifiersForTag);
  }
  else {
    CFIndex Count = 0;
  }
  if (FigGetFileTypeForMovieFamilyExtension_sMovieFamilyTypesOnce != -1) {
    dispatch_once(&FigGetFileTypeForMovieFamilyExtension_sMovieFamilyTypesOnce, &__block_literal_global_60);
  }
  if (Count < 1)
  {
LABEL_18:
    uint64_t v5 = 0;
    if (!v3) {
      return (__CFString *)v5;
    }
    goto LABEL_21;
  }
  CFIndex v6 = 0;
  while (1)
  {
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v3, v6);
    int Value = CFDictionaryGetValue((CFDictionaryRef)FigGetFileTypeForMovieFamilyExtension_sMovieFamilySubstitutions, ValueAtIndex);
    CFNumberRef v9 = Value ? Value : ValueAtIndex;
    v12.length = FigGetFileTypeForMovieFamilyExtension_sNumMovieFamilyTypes;
    v12.locatioCFIndex n = 0;
    FirstIndexOfint Value = CFArrayGetFirstIndexOfValue((CFArrayRef)FigGetFileTypeForMovieFamilyExtension_sMovieFamilyTypes, v12, v9);
    if (FirstIndexOfValue != -1) {
      break;
    }
    if (Count == ++v6) {
      goto LABEL_18;
    }
  }
  uint64_t v5 = CFArrayGetValueAtIndex((CFArrayRef)FigGetFileTypeForMovieFamilyExtension_sMovieFamilyTypes, FirstIndexOfValue);
  if (v3) {
LABEL_21:
  }
    CFRelease(v3);
  return (__CFString *)v5;
}

void __FigGetFileTypeForMovieFamilyExtension_block_invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 7, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, @"com.apple.quicktime-movie");
  CFArrayAppendValue(Mutable, @"public.mpeg-4");
  CFArrayAppendValue(Mutable, @"com.apple.m4v-video");
  CFArrayAppendValue(Mutable, @"com.apple.m4a-audio");
  CFArrayAppendValue(Mutable, @"public.3gpp");
  CFArrayAppendValue(Mutable, @"com.apple.immersive-video");
  CFArrayAppendValue(Mutable, @"com.apple.quicktime-audio");
  FigGetFileTypeForMovieFamilyExtension_sNumMovieFamilyTypes = CFArrayGetCount(Mutable);
  FigGetFileTypeForMovieFamilyExtension_sMovieFamilyTypes = (uint64_t)Mutable;
  uint64_t v2 = CFDictionaryCreateMutable(v0, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(v2, (const void *)*MEMORY[0x1E4F22518], @"com.apple.m4a-audio");
  CFDictionarySetValue(v2, @"com.apple.mpeg-4-ringtone", @"com.apple.m4a-audio");
  CFDictionarySetValue(v2, @"public.3gpp2", @"public.3gpp");
  FigGetFileTypeForMovieFamilyExtension_sMovieFamilySubstitutions = (uint64_t)v2;
}

CFStringRef FigCreateStringForLanguageCode(const __CFAllocator *a1, unsigned int a2, int a3)
{
  if (!a3 && (a2 < 0x401 || a2 == 0x7FFF))
  {
    if (a2 > 0x97) {
      unsigned int v3 = 21956;
    }
    else {
      unsigned int v3 = kQTCodeToISO639_2_T_LanguageBits[a2];
    }
  }
  else if (a2)
  {
    unsigned int v3 = a2;
  }
  else
  {
    unsigned int v3 = 21956;
  }
  return CFStringCreateWithFormat(a1, 0, @"%c%c%c", (v3 >> 10) | 0x60, (v3 >> 5) & 0x1F | 0x60, v3 & 0x1F | 0x60);
}

uint64_t FigGetISOLanguageCodeForString(const __CFString *a1)
{
  CharacterAtIndeCGFloat x = CFStringGetCharacterAtIndex(a1, 0);
  UniChar v3 = CFStringGetCharacterAtIndex(a1, 1);
  return (unsigned __int16)(CFStringGetCharacterAtIndex(a1, 2) + 32 * v3 + (CharacterAtIndex << 10) + 29600);
}

BOOL FigValidateRequiredFeaturesOfFormatDescription(const opaqueCMFormatDescription *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    CFIndex v3 = 0;
    uint64_t v11 = 0;
    CFIndex v8 = 0;
    return !v8 && v3 == v11;
  }
  CFPropertyListRef Extension = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E4F1F488]);
  CFIndex v3 = (CFIndex)Extension;
  if (!Extension)
  {
    CFArrayRef v7 = 0;
LABEL_8:
    CFIndex v8 = 0;
    goto LABEL_11;
  }
  CFTypeID v4 = CFGetTypeID(Extension);
  if (v4 != CFDictionaryGetTypeID())
  {
    CFArrayRef v7 = 0;
    CFIndex v3 = 0;
    goto LABEL_8;
  }
  CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v3);
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v3, (const void *)*MEMORY[0x1E4F1F4C0]);
  CFArrayRef v7 = Value;
  if (Value) {
    CFIndex v3 = CFArrayGetCount(Value);
  }
  else {
    CFIndex v3 = 0;
  }
  CFIndex v8 = Count - (v7 != 0);
LABEL_11:
  if (CMFormatDescriptionGetMediaType(a1) == 1952807028
    && ((FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(a1), MediaSubType == 1937142900)
     || MediaSubType == 2021028980
     || MediaSubType == 2004251764)
    && v3 >= 1)
  {
    CFIndex v10 = 0;
    uint64_t v11 = 0;
    do
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v10);
      uint64_t v13 = 0;
      while (!CFStringGetCString(ValueAtIndex, buffer, 256, 0x600u)
           || strncmp(buffer, sWebVTTSupportedFeatures[v13], 0x100uLL))
      {
        if (++v13 == 3) {
          goto LABEL_23;
        }
      }
      ++v11;
LABEL_23:
      ++v10;
    }
    while (v10 != v3);
  }
  else
  {
    uint64_t v11 = 0;
  }
  return !v8 && v3 == v11;
}

BOOL MTShouldPlayHDRVideo(const __CFArray *a1)
{
  int v4 = 0;
  int v2 = FPSupport_IsInLowPowerMode();
  BOOL result = 0;
  if (!v2)
  {
    FPSupport_GetCurrentDisplayModeVideoRangeAndSizeAndFrameRate(a1, &v4, 0, 0);
    return v4 > 1;
  }
  return result;
}

uint64_t FigCryptGetBlockSize(int a1)
{
  if ((a1 - 1) < 3) {
    return 16;
  }
  FigSignalErrorAt();
  return 0;
}

uint64_t FigCryptGetTagSize(int a1)
{
  if (a1 == 3) {
    return 16;
  }
  FigSignalErrorAt();
  return 0;
}

uint64_t FigCryptCreateForDecrypt(int a1, const void *a2, uint64_t a3, const void *a4, const void *a5, size_t a6, void *a7)
{
  if (a7
    && (*a7 = 0, (uint64_t BlockSize = FigCryptGetBlockSize(a1)) != 0)
    && (uint64_t v14 = BlockSize, (cryptorRef = malloc_type_calloc(1uLL, 0x38uLL, 0x10600408152BA4BuLL)) != 0))
  {
    uint64_t v16 = cryptorRef;
    *((_DWORD *)cryptorRef + 8) = a1;
    cryptorRef[1] = v14;
    if (a1 == 3)
    {
      if (CCCryptorCreateWithMode(1u, 0xBu, 0, 0, 0, a5, a6, 0, 0, 0, 0, (CCCryptorRef *)cryptorRef))
      {
LABEL_6:
        uint64_t v17 = FigSignalErrorAt();
        free(v16);
        return v17;
      }
    }
    else if (CCCryptorCreate(1u, 0, a1 == 1, a5, a6, 0, (CCCryptorRef *)cryptorRef))
    {
      goto LABEL_6;
    }
    if (a2) {
      CFTypeRef v19 = CFRetain(a2);
    }
    else {
      CFTypeRef v19 = (CFTypeRef)*MEMORY[0x1E4F1CF80];
    }
    v16[2] = v19;
    if (a4) {
      CFTypeRef v20 = CFRetain(a4);
    }
    else {
      CFTypeRef v20 = (CFTypeRef)*MEMORY[0x1E4F1CF80];
    }
    v16[3] = v20;
    *a7 = v16;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigCryptSetIV(uint64_t a1, void *iv)
{
  if (a1)
  {
    int v3 = *(_DWORD *)(a1 + 32);
    int v4 = *(_CCCryptor **)a1;
    if (v3 == 3)
    {
      if (CCCryptorGCMReset()) {
        goto LABEL_5;
      }
      uint64_t result = CCCryptorGCMSetIV();
    }
    else
    {
      uint64_t result = CCCryptorReset(v4, iv);
    }
    if (!result)
    {
      *(void *)(a1 + 40) = 0;
      *(void *)(a1 + 48) = 0;
      return result;
    }
  }
LABEL_5:

  return FigSignalErrorAt();
}

uint64_t FigCryptDecryptMemory(uint64_t a1, int a2, int a3, const void *a4, size_t a5, size_t *a6, char *a7, size_t a8, size_t *a9, unsigned char *a10)
{
  size_t dataOutMoved = 0;
  if (!a1 || !a10 || (size_t v13 = a5, !a2) && (!a5 || !a4 || !a6) || !a7 || !a9 || *(void *)(a1 + 8) > a8)
  {
    return FigSignalErrorAt();
  }
  *a10 = 0;
  if (a4) {
    size_t v17 = a5;
  }
  else {
    size_t v17 = 0;
  }
  if (v17)
  {
    Outputsize_t Length = CCCryptorGetOutputLength(*(CCCryptorRef *)a1, v17, a2 != 0);
    if (a2 && OutputLength > a8) {
      Outputsize_t Length = CCCryptorGetOutputLength(*(CCCryptorRef *)a1, v17, 0);
    }
    if (OutputLength > a8)
    {
      unint64_t v19 = *(void *)(a1 + 40);
      unint64_t v20 = *(void *)(a1 + 48);
      BOOL v21 = v19 >= v20;
      unint64_t v22 = v19 - v20;
      if (v21)
      {
        unint64_t v23 = *(void *)(a1 + 8);
        BOOL v21 = v23 >= v22;
        unint64_t v24 = v23 - v22;
        if (v21)
        {
          size_t v32 = (-(uint64_t)v23 & a8) + v24;
          if (v32 < v17) {
            size_t v13 = v32;
          }
          if (v13)
          {
LABEL_23:
            while (1)
            {
              CCCryptorStatus v26 = CCCryptorUpdate(*(CCCryptorRef *)a1, a4, v13, a7, a8, &dataOutMoved);
              if (v26 != -4301) {
                break;
              }
              size_t v27 = *(void *)(a1 + 8);
              BOOL v28 = v13 > v27;
              v13 -= v27;
              if (!v28) {
                return FigSignalErrorAt();
              }
            }
            if (v26) {
              return FigSignalErrorAt();
            }
          }
          goto LABEL_28;
        }
      }
      uint64_t result = FigSignalErrorAt();
      if (result) {
        return result;
      }
    }
    if (v13) {
      goto LABEL_23;
    }
  }
  else
  {
    size_t v13 = 0;
  }
LABEL_28:
  if (a2)
  {
    int v29 = *(_DWORD *)(a1 + 32);
    if (v29 != 2)
    {
      if (a4 && v29 == 3 && dataOutMoved == v17)
      {
        if (CCCryptorGCMFinalize()) {
          return FigSignalErrorAt();
        }
      }
      else if (v13 == v17 && a8 - dataOutMoved >= *(void *)(a1 + 8))
      {
        size_t v35 = 0;
        CCCryptorStatus v33 = CCCryptorFinal(*(CCCryptorRef *)a1, &a7[dataOutMoved], a8 - dataOutMoved, &v35);
        if (!a3 && v33) {
          return FigSignalErrorAt();
        }
        dataOutMoved += v35;
        *a10 = 0;
      }
      else
      {
        *a10 = 1;
      }
    }
  }
  size_t v30 = dataOutMoved;
  size_t v31 = *(void *)(a1 + 48) + dataOutMoved;
  *(void *)(a1 + 40) += v13;
  *(void *)(a1 + 48) = v31;
  if (a6) {
    *a6 = v13;
  }
  uint64_t result = 0;
  *a9 = v30;
  return result;
}

void FigCryptDispose(CCCryptorRef *a1)
{
  if (a1)
  {
    CCCryptorRef v2 = a1[2];
    if (v2) {
      CFRelease(v2);
    }
    CCCryptorRef v3 = a1[3];
    if (v3) {
      CFRelease(v3);
    }
    if (*a1) {
      CCCryptorRelease(*a1);
    }
    free(a1);
  }
}

uint64_t FigBufferedAirPlayOutputGetClassID()
{
  if (FigBufferedAirPlayOutputGetClassID_sRegisterFigBufferedAirPlayOutputBaseTypeOnce != -1) {
    dispatch_once(&FigBufferedAirPlayOutputGetClassID_sRegisterFigBufferedAirPlayOutputBaseTypeOnce, &__block_literal_global_61);
  }
  return FigBufferedAirPlayOutputGetClassID_sFigBufferedAirPlayOutputClassID;
}

CFStringRef FigBufferedAirPlayOutputBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigBufferedAirPlayOutput %p]", a1);
}

uint64_t __FigBufferedAirPlayOutputGetClassID_block_invoke()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigBufferedAirPlayOutputGetTypeID()
{
  if (FigBufferedAirPlayOutputGetClassID_sRegisterFigBufferedAirPlayOutputBaseTypeOnce != -1) {
    dispatch_once(&FigBufferedAirPlayOutputGetClassID_sRegisterFigBufferedAirPlayOutputBaseTypeOnce, &__block_literal_global_61);
  }

  return CMBaseClassGetCFTypeID();
}

uint64_t FigBufferedAirPlayOutputCreate(const __CFAllocator *a1, const void *a2, const void *a3, void *a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  FigNote_AllowInternalDefaultLogs();
  fig_note_initialize_category_with_default_work_cf();
  fig_note_initialize_category_with_default_work_cf();
  if (a2 && a3 && a4)
  {
    if (FigBufferedAirPlayOutputGetClassID_sRegisterFigBufferedAirPlayOutputBaseTypeOnce != -1) {
      dispatch_once(&FigBufferedAirPlayOutputGetClassID_sRegisterFigBufferedAirPlayOutputBaseTypeOnce, &__block_literal_global_61);
    }
    uint64_t v8 = CMDerivedObjectCreate();
    if (v8) {
      return v8;
    }
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    CFTypeRef v46 = 0;
    CFTypeRef cf = 0;
    uint64_t v10 = FigSimpleMutexCreate();
    *(void *)(DerivedStorage + 8) = v10;
    if (!v10) {
      goto LABEL_58;
    }
    uint64_t v11 = FigDispatchQueueCreateWithPriority();
    *(void *)(DerivedStorage + 16) = v11;
    if (!v11
      || (uint64_t v12 = FigDispatchQueueCreateWithPriority(), (*(void *)(DerivedStorage + 24) = v12) == 0)
      || (uint64_t v13 = FigDispatchQueueCreateWithPriority(), (*(void *)(DerivedStorage + 32) = v13) == 0)
      || (uint64_t v14 = FigDispatchQueueCreateWithPriority(), (*(void *)(DerivedStorage + 40) = v14) == 0))
    {
LABEL_58:
      uint64_t v25 = 4294954510;
      goto LABEL_40;
    }
    *(void *)(DerivedStorage + 48) = CFRetain(a2);
    *(void *)(DerivedStorage + 56) = CFRetain(a3);
    *(_DWORD *)(DerivedStorage + 140) = -998653952;
    *(unsigned char *)(DerivedStorage + 137) = 0;
    uint64_t CMBaseObject = FigEndpointGetCMBaseObject();
    uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v16) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v18 = *(uint64_t (**)(uint64_t, void, const __CFAllocator *, CFTypeRef *))(v17 + 48);
    if (v18)
    {
      uint64_t v19 = v18(CMBaseObject, *MEMORY[0x1E4F21088], a1, &cf);
      if (v19) {
        goto LABEL_64;
      }
      *(unsigned char *)(DerivedStorage + 136) = cf == (CFTypeRef)*MEMORY[0x1E4F1CFD0];
      if (_os_feature_enabled_impl())
      {
        uint64_t v19 = FigEndpointStreamAudioEngineCreateForEndpointStream(*(void *)(DerivedStorage + 56), DerivedStorage + 72);
        if (v19) {
          goto LABEL_64;
        }
        goto LABEL_25;
      }
      uint64_t v20 = FigEndpointStreamGetCMBaseObject();
      uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v21) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = 0;
      }
      unint64_t v23 = *(uint64_t (**)(uint64_t, void, const __CFAllocator *, uint64_t))(v22 + 48);
      if (v23)
      {
        uint64_t v19 = v23(v20, *MEMORY[0x1E4F21328], a1, DerivedStorage + 72);
        if (!v19)
        {
LABEL_25:
          sourceClocCFIndex k = 0;
          CMTimebaseRef timebaseOut = 0;
          if (CMTimeSyncClockCreateForSystemDomainClockIdentifier())
          {
            HostTimeClocCFIndex k = CMClockGetHostTimeClock();
            sourceClocCFIndex k = HostTimeClock;
            if (HostTimeClock) {
              CFRetain(HostTimeClock);
            }
          }
          uint64_t v25 = CMTimebaseCreateWithSourceClock(a1, sourceClock, &timebaseOut);
          if (v25)
          {
            if (sourceClock) {
              CFRelease(sourceClock);
            }
            if (timebaseOut) {
              CFRelease(timebaseOut);
            }
            goto LABEL_40;
          }
          CMTimebaseRef v26 = timebaseOut;
          *(void *)(DerivedStorage + 144) = sourceClock;
          *(void *)(DerivedStorage + 152) = v26;
          *(void *)(DerivedStorage + 176) = 0;
          *(_DWORD *)(DerivedStorage + 192) = -999;
          uint64_t v27 = MEMORY[0x1E4F1F9F8];
          long long v28 = *MEMORY[0x1E4F1F9F8];
          *(_OWORD *)(DerivedStorage + 84) = *MEMORY[0x1E4F1F9F8];
          uint64_t v29 = *(void *)(v27 + 16);
          *(void *)(DerivedStorage + 100) = v29;
          uint64_t v30 = MEMORY[0x1E4F1FA48];
          *(_OWORD *)(DerivedStorage + 112) = *MEMORY[0x1E4F1FA48];
          *(void *)(DerivedStorage + 128) = *(void *)(v30 + 16);
          *(unsigned char *)(DerivedStorage + 108) = 1;
          *(_OWORD *)(DerivedStorage + 240) = v28;
          *(void *)(DerivedStorage + 256) = v29;
          uint64_t v31 = FigEndpointStreamAudioEngineGetCMBaseObject(*(void *)(DerivedStorage + 72));
          uint64_t v32 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v32) {
            uint64_t v33 = v32;
          }
          else {
            uint64_t v33 = 0;
          }
          CFNumberRef v34 = *(uint64_t (**)(uint64_t, __CFString *, void, uint64_t))(v33 + 48);
          if (v34)
          {
            CFAllocatorRef v35 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            uint64_t v19 = v34(v31, @"inputSampleBufferConsumer", *MEMORY[0x1E4F1CF80], DerivedStorage + 176);
            if (!v19)
            {
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v35, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              *(void *)(DerivedStorage + 160) = Mutable;
              if (!Mutable)
              {
                uint64_t v25 = 4294950535;
                goto LABEL_40;
              }
              CMBaseObjectGetDerivedStorage();
              FigCFDictionarySetValue();
              uint64_t v19 = FigSampleBufferConsumerInputForBufferedAirPlayOutputCreate(0, *(const void **)(DerivedStorage + 176), "SBCInput4BAO", (void *)(DerivedStorage + 184));
              if (!v19)
              {
                random();
                uint64_t UInt32 = FigCFNumberCreateUInt32();
                *(void *)(DerivedStorage + 272) = UInt32;
                if (UInt32)
                {
                  *(unsigned char *)(DerivedStorage + 264) = FigGetCFPreferenceNumberWithDefault();
                  *(unsigned char *)(DerivedStorage + 265) = 1;
                  uint64_t v38 = FigEndpointStreamGetCMBaseObject();
                  uint64_t v39 = *(void *)(CMBaseObjectGetVTable() + 8);
                  if (v39) {
                    uint64_t v40 = v39;
                  }
                  else {
                    uint64_t v40 = 0;
                  }
                  char v42 = *(unsigned int (**)(uint64_t, void, const __CFAllocator *, CFTypeRef *))(v40 + 48);
                  if (v42 && !v42(v38, *MEMORY[0x1E4F21320], a1, &v46) && v46 == (CFTypeRef)*MEMORY[0x1E4F1CFC8]) {
                    *(unsigned char *)(DerivedStorage + 265) = 0;
                  }
                  if (dword_1E93512F0)
                  {
                    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
                    fig_log_call_emit_and_clean_up_after_send_and_compose();
                  }
                  uint64_t v44 = CMBaseObjectGetDerivedStorage();
                  if (*(void *)(v44 + 56) && *(void *)(v44 + 72))
                  {
                    CMNotificationCenterGetDefaultLocalCenter();
                    FigNotificationCenterAddWeakListeners();
                    CMNotificationCenterGetDefaultLocalCenter();
                    FigNotificationCenterAddWeakListeners();
                    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
                    CFNotificationCenterAddObserver(DarwinNotifyCenter, 0, (CFNotificationCallback)fbapo_airPlayPrefsChangedCallback, @"com.apple.airplay.bufferedAVAudioSessionOverrideChanged", 0, (CFNotificationSuspensionBehavior)0);
                  }
                }
                uint64_t v25 = 0;
                goto LABEL_40;
              }
            }
            goto LABEL_64;
          }
          goto LABEL_39;
        }
LABEL_64:
        uint64_t v25 = v19;
        goto LABEL_40;
      }
    }
LABEL_39:
    uint64_t v25 = 4294954514;
LABEL_40:
    if (cf) {
      CFRelease(cf);
    }
    if (v46) {
      CFRelease(v46);
    }
    if (!v25)
    {
      CMBaseObjectGetDerivedStorage();
      *a4 = 0;
    }
    return v25;
  }

  return FigSignalErrorAt();
}

uint64_t fbapo_invalidate(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (!*(unsigned char *)DerivedStorage)
  {
    uint64_t v3 = CMBaseObjectGetDerivedStorage();
    fbapo_amIActiveEndpointStreamClient();
    if (!*(unsigned char *)v3)
    {
      *(unsigned char *)uint64_t v3 = 1;
      fbapo_setAudioSessionID((uint64_t)a1, 0);
      uint64_t v4 = *(void *)(v3 + 72);
      if (v4)
      {
        uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v5) {
          uint64_t v6 = v5;
        }
        else {
          uint64_t v6 = 0;
        }
        CFArrayRef v7 = *(void (**)(uint64_t, void, void, void))(v6 + 16);
        if (v7) {
          v7(v4, 0, 0, 0);
        }
        *(unsigned char *)(v3 + 80) = 0;
      }
      *(_DWORD *)(v3 + 192) = -999;
      *(_DWORD *)(v3 + 140) = -998653952;
      uint64_t v8 = CMBaseObjectGetDerivedStorage();
      if (*(void *)(v8 + 56) && *(void *)(v8 + 72))
      {
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterRemoveWeakListeners();
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterRemoveWeakListeners();
        DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
        CFNotificationCenterRemoveObserver(DarwinNotifyCenter, a1, @"com.apple.airplay.bufferedAVAudioSessionOverrideChanged", 0);
      }
      uint64_t v10 = *(const void **)(v3 + 56);
      if (v10)
      {
        CFRelease(v10);
        *(void *)(v3 + 56) = 0;
      }
      uint64_t v11 = *(const void **)(v3 + 48);
      if (v11)
      {
        CFRelease(v11);
        *(void *)(v3 + 48) = 0;
      }
      uint64_t v12 = *(const void **)(v3 + 64);
      if (v12)
      {
        CFRelease(v12);
        *(void *)(v3 + 64) = 0;
      }
      uint64_t v13 = *(const void **)(v3 + 176);
      if (v13)
      {
        CFRelease(v13);
        *(void *)(v3 + 176) = 0;
      }
      uint64_t v14 = *(const void **)(v3 + 160);
      if (v14)
      {
        CFRelease(v14);
        *(void *)(v3 + 160) = 0;
      }
      double v15 = *(const void **)(v3 + 144);
      if (v15)
      {
        CFRelease(v15);
        *(void *)(v3 + 144) = 0;
      }
      uint64_t v16 = *(const void **)(v3 + 152);
      if (v16)
      {
        CFRelease(v16);
        *(void *)(v3 + 152) = 0;
      }
      uint64_t v17 = *(const void **)(v3 + 72);
      if (v17)
      {
        CFRelease(v17);
        *(void *)(v3 + 72) = 0;
      }
      uint64_t v18 = *(const void **)(v3 + 200);
      if (v18)
      {
        CFRelease(v18);
        *(void *)(v3 + 200) = 0;
      }
      uint64_t v19 = *(const void **)(v3 + 184);
      if (v19)
      {
        CFRelease(v19);
        *(void *)(v3 + 184) = 0;
      }
    }
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  return 0;
}

uint64_t fbapo_finalize(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  fbapo_invalidate(a1);
  uint64_t v3 = *(const void **)(DerivedStorage + 272);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(DerivedStorage + 272) = 0;
  }
  uint64_t v4 = *(NSObject **)(DerivedStorage + 16);
  if (v4)
  {
    dispatch_sync(v4, &__block_literal_global_154_0);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 16));
    *(void *)(DerivedStorage + 16) = 0;
  }
  uint64_t v5 = *(NSObject **)(DerivedStorage + 32);
  if (v5)
  {
    dispatch_sync(v5, &__block_literal_global_157);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 32));
    *(void *)(DerivedStorage + 32) = 0;
  }
  uint64_t v6 = *(NSObject **)(DerivedStorage + 24);
  if (v6)
  {
    dispatch_sync(v6, &__block_literal_global_160);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 24));
    *(void *)(DerivedStorage + 24) = 0;
  }
  CFArrayRef v7 = *(NSObject **)(DerivedStorage + 40);
  if (v7)
  {
    dispatch_sync(v7, &__block_literal_global_163);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 40));
    *(void *)(DerivedStorage + 40) = 0;
  }
  uint64_t result = *(void *)(DerivedStorage + 8);
  if (result)
  {
    uint64_t result = FigSimpleMutexDestroy();
    *(void *)(DerivedStorage + 8) = 0;
  }
  return result;
}

__CFString *fbapo_copyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigBufferedAirPlayOutput %p; endpointStream=%@>",
    a1,
    *(void *)(DerivedStorage + 56));
  return Mutable;
}

uint64_t fbapo_copyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, __CFString **a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  uint64_t v9 = CMBaseObjectGetDerivedStorage();
  CFBooleanRef v50 = 0;
  if (CFEqual(a2, @"EnableLocalPlayback") || CFEqual(a2, @"LocalPlaybackVolume"))
  {
    uint64_t v10 = FigSignalErrorAt();
LABEL_4:
    uint64_t v11 = v10;
    goto LABEL_5;
  }
  if (CFEqual(a2, @"PreferredClock"))
  {
    CMTimeValue value = *(__CFString **)(v9 + 144);
    if (!value) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  if (CFEqual(a2, @"ZeroBasedTimebase"))
  {
    CMTimeValue value = *(__CFString **)(v9 + 152);
    if (!value)
    {
LABEL_12:
      uint64_t v11 = 0;
      *a4 = value;
      goto LABEL_5;
    }
    goto LABEL_11;
  }
  if (CFEqual(a2, @"MaximumNumberOfOutputChannels"))
  {
    uint64_t CMBaseObject = FigEndpointStreamGetCMBaseObject();
    uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v15) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = 0;
    }
    uint64_t v20 = *(uint64_t (**)(uint64_t, void, void, __CFString **))(v16 + 48);
    if (v20)
    {
      uint64_t v10 = v20(CMBaseObject, *MEMORY[0x1E4F21378], *MEMORY[0x1E4F1CF80], a4);
      goto LABEL_4;
    }
LABEL_35:
    uint64_t v11 = 4294954514;
    goto LABEL_5;
  }
  if (!CFEqual(a2, @"AtmosIsSupported"))
  {
    if (!CFEqual(a2, @"PrerollDuration"))
    {
      if (CFEqual(a2, @"AudioMode"))
      {
        time.CMTimeValue value = 0;
        CFTypeID TypeID = CFStringGetTypeID();
        if (fbapo_getCachedValue(a1, TypeID, &time))
        {
          CMTimeValue value = @"AudioMode_Default";
        }
        else
        {
          CMTimeValue value = (__CFString *)time.value;
          if (!time.value) {
            goto LABEL_12;
          }
        }
        goto LABEL_11;
      }
      if (CFEqual(a2, @"IsActiveConfigurationInvalid"))
      {
        uint64_t v37 = CMBaseObjectGetDerivedStorage();
        LOBYTE(time.value) = 0;
        FigSimpleMutexCheckIsLockedOnThisThread();
        if (*(unsigned char *)(v37 + 80) || (fbapo_supportsFormatChangeWithoutReconfiguration(a1, &time), !LOBYTE(time.value))) {
          uint64_t v38 = (__CFString **)MEMORY[0x1E4F1CFD0];
        }
        else {
          uint64_t v38 = (__CFString **)MEMORY[0x1E4F1CFC8];
        }
      }
      else
      {
        if (CFEqual(a2, @"SupportsReceiverSideSoundCheck"))
        {
          CMBaseObjectGetDerivedStorage();
          time.CMTimeValue value = 0;
          uint64_t v44 = FigEndpointStreamGetCMBaseObject();
          uint64_t v45 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v45) {
            uint64_t v46 = v45;
          }
          else {
            uint64_t v46 = 0;
          }
          uint64_t v47 = *(void (**)(uint64_t, void, void, CMTime *))(v46 + 48);
          if (v47) {
            v47(v44, *MEMORY[0x1E4F213E0], *MEMORY[0x1E4F1CF80], &time);
          }
          CFStringRef v48 = (__CFString *)*MEMORY[0x1E4F1CFD0];
          int v49 = FigCFEqual();
          if (time.value) {
            CFRelease((CFTypeRef)time.value);
          }
          if (v49) {
            CMTimeValue value = v48;
          }
          else {
            CMTimeValue value = (__CFString *)*MEMORY[0x1E4F1CFC8];
          }
          goto LABEL_11;
        }
        if (CFEqual(a2, @"UniqueID"))
        {
          CMTimeValue value = *(__CFString **)(v9 + 272);
          goto LABEL_11;
        }
        if (!CFEqual(a2, @"ALACIsAllowed"))
        {
          if (!CFEqual(a2, @"SourceSampleBufferConsumer"))
          {
            if (!CFEqual(a2, @"LoggingID"))
            {
              uint64_t v11 = 4294954512;
              goto LABEL_5;
            }
            CMTimeValue value = (__CFString *)CFStringCreateWithCString(a3, (const char *)(v9 + 208), 0x8000100u);
            goto LABEL_12;
          }
          CMTimeValue value = *(__CFString **)(v9 + 184);
          goto LABEL_11;
        }
        uint64_t v38 = (__CFString **)MEMORY[0x1E4F1CFD0];
        if (!*(unsigned char *)(v9 + 265)) {
          uint64_t v38 = (__CFString **)MEMORY[0x1E4F1CFC8];
        }
      }
      CMTimeValue value = *v38;
LABEL_11:
      CMTimeValue value = (__CFString *)CFRetain(value);
      goto LABEL_12;
    }
    uint64_t v21 = CMBaseObjectGetDerivedStorage();
    CFDictionaryRef v52 = 0;
    BOOLeaCFIndex n = 0;
    if (*(void *)(v21 + 56))
    {
      uint64_t v22 = v21;
      if (fbapo_audioEngineIsResumed())
      {
        uint64_t v23 = FigEndpointStreamAudioEngineGetCMBaseObject(*(void *)(v22 + 72));
        uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v24) {
          uint64_t v25 = v24;
        }
        else {
          uint64_t v25 = 0;
        }
        uint64_t v39 = *(uint64_t (**)(uint64_t, __CFString *, void, const __CFDictionary **))(v25 + 48);
        if (!v39)
        {
          uint64_t v11 = 4294954514;
LABEL_71:
          CFBooleanRef v27 = BOOLean;
          goto LABEL_72;
        }
        uint64_t v11 = v39(v23, @"prerollDuration", *MEMORY[0x1E4F1CF80], &v52);
        CFDictionaryRef v40 = v52;
        if (!a4 || v11) {
          goto LABEL_67;
        }
        if (!v52)
        {
          CFNumberRef v41 = 0;
LABEL_66:
          uint64_t v11 = 0;
          *a4 = v41;
LABEL_67:
          if (!v40) {
            goto LABEL_71;
          }
          goto LABEL_70;
        }
LABEL_65:
        CFNumberRef v41 = (__CFString *)CFRetain(v40);
        CFDictionaryRef v40 = v52;
        goto LABEL_66;
      }
      CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v34 = FigEndpointStreamGetCMBaseObject();
      uint64_t v35 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v35) {
        uint64_t v36 = v35;
      }
      else {
        uint64_t v36 = 0;
      }
      char v42 = *(void (**)(uint64_t, void, const __CFAllocator *, CFBooleanRef *))(v36 + 48);
      if (v42 && (v42(v34, *MEMORY[0x1E4F21358], v33, &BOOLean), BOOLean) && CFBooleanGetValue(BOOLean)) {
        int64_t v43 = 5000;
      }
      else {
        int64_t v43 = 1000;
      }
      CMTimeMake(&time, v43, 1000);
      CFAllocatorRef v32 = v33;
    }
    else
    {
      CMTimeMake(&time, 1000, 1000);
      CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    }
    CFDictionaryRef v40 = CMTimeCopyAsDictionary(&time, v32);
    CFDictionaryRef v52 = v40;
    if (!v40)
    {
      uint64_t v11 = 4294951816;
      goto LABEL_71;
    }
    if (!a4)
    {
      uint64_t v11 = 0;
LABEL_70:
      CFRelease(v40);
      goto LABEL_71;
    }
    goto LABEL_65;
  }
  uint64_t v17 = FigEndpointStreamGetCMBaseObject();
  uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v18) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = 0;
  }
  CMTimebaseRef v26 = *(uint64_t (**)(uint64_t, void, void, const __CFBoolean **))(v19 + 48);
  if (!v26) {
    goto LABEL_35;
  }
  uint64_t v11 = v26(v17, *MEMORY[0x1E4F21378], *MEMORY[0x1E4F1CF80], &v50);
  CFBooleanRef v27 = v50;
  if (!v11)
  {
    unsigned int SInt32 = FigCFNumberGetSInt32();
    uint64_t v29 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
    if (SInt32 <= 7) {
      uint64_t v29 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
    }
    uint64_t v30 = (__CFString *)*v29;
    if (*v29) {
      uint64_t v30 = (__CFString *)CFRetain(v30);
    }
    *a4 = v30;
    CFBooleanRef v27 = v50;
  }
LABEL_72:
  if (v27) {
    CFRelease(v27);
  }
LABEL_5:
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  return v11;
}

uint64_t fbapo_setProperty(uint64_t a1, const void *a2, __CFString *a3)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  uint64_t v7 = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, @"Muted"))
  {
    if (a3)
    {
      CFTypeID TypeID = CFBooleanGetTypeID();
      if (TypeID == CFGetTypeID(a3))
      {
        uint64_t CMBaseObject = FigEndpointGetCMBaseObject();
        uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v10) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = 0;
        }
        uint64_t v16 = *(uint64_t (**)(uint64_t, void, __CFString *))(v11 + 56);
        if (!v16) {
          goto LABEL_137;
        }
        uint64_t v13 = v16(CMBaseObject, *MEMORY[0x1E4F20E98], a3);
        if (!v13)
        {
          uint64_t v17 = FigEndpointStreamGetCMBaseObject();
          uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v18) {
            uint64_t v19 = v18;
          }
          else {
            uint64_t v19 = 0;
          }
          uint64_t v20 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(v19 + 56);
          if (v20)
          {
            uint64_t v21 = (__CFString **)MEMORY[0x1E4F21380];
LABEL_29:
            uint64_t v13 = v20(v17, *v21, a3);
            goto LABEL_16;
          }
          goto LABEL_137;
        }
LABEL_16:
        uint64_t SInt32 = v13;
        goto LABEL_17;
      }
    }
LABEL_15:
    uint64_t v13 = FigSignalErrorAt();
    goto LABEL_16;
  }
  if (CFEqual(a2, @"Volume"))
  {
    if (!a3) {
      goto LABEL_15;
    }
    CFTypeID v12 = CFNumberGetTypeID();
    if (v12 != CFGetTypeID(a3)) {
      goto LABEL_15;
    }
    LODWORD(valuePtr[0].value) = 0;
    if (*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 136))
    {
      if (!CFNumberGetValue((CFNumberRef)a3, kCFNumberFloat32Type, valuePtr)
        || *(float *)&valuePtr[0].value < 0.0
        || *(float *)&valuePtr[0].value > 1.0)
      {
        FigSignalErrorAt();
        goto LABEL_39;
      }
      if (*(float *)&valuePtr[0].value != 0.0) {
        log(*(float *)&valuePtr[0].value);
      }
      uint64_t Float32 = FigCFNumberCreateFloat32();
      if (!Float32) {
        goto LABEL_39;
      }
      uint64_t v23 = (const void *)Float32;
      uint64_t v24 = FigEndpointGetCMBaseObject();
      uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v25) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = 0;
      }
      CFBooleanRef v27 = *(void (**)(uint64_t, void, const void *))(v26 + 56);
      if (v27) {
        v27(v24, *MEMORY[0x1E4F21098], v23);
      }
      long long v28 = v23;
      goto LABEL_38;
    }
LABEL_39:
    uint64_t SInt32 = 0;
    goto LABEL_17;
  }
  if (CFEqual(a2, @"EnableLocalPlayback") || CFEqual(a2, @"LocalPlaybackVolume")) {
    goto LABEL_15;
  }
  if (CFEqual(a2, @"AudioMode"))
  {
    if (a3)
    {
      CFTypeID v29 = CFGetTypeID(a3);
      if (v29 == CFStringGetTypeID())
      {
        uint64_t v13 = fbapo_setAndCacheAudioMode(a1, a3, 1);
        goto LABEL_16;
      }
    }
    goto LABEL_15;
  }
  if (CFEqual(a2, @"FigAudioSession"))
  {
    if (!a3 || (CFTypeID v30 = CFGetTypeID(a3), v30 == FigAudioSessionGetTypeID()))
    {
      uint64_t v13 = fbapo_setAndCacheFigAudioSession(a1, a3, 1);
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if (CFEqual(a2, @"ClientID"))
  {
    uint64_t v31 = *(const void **)(v7 + 200);
    *(void *)(v7 + 200) = a3;
    if (a3) {
      CFRetain(a3);
    }
    if (!v31) {
      goto LABEL_39;
    }
    long long v28 = v31;
    goto LABEL_38;
  }
  if (!CFEqual(a2, @"IsPiPMuted"))
  {
    if (CFEqual(a2, @"ClientPID"))
    {
      if (a3)
      {
        CFTypeID v37 = CFGetTypeID(a3);
        if (v37 == CFNumberGetTypeID())
        {
          uint64_t v17 = FigEndpointStreamAudioEngineGetCMBaseObject(*(void *)(v7 + 72));
          uint64_t v38 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v38) {
            uint64_t v39 = v38;
          }
          else {
            uint64_t v39 = 0;
          }
          uint64_t v20 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(v39 + 56);
          if (v20)
          {
            uint64_t v21 = kFigEndpointStreamAudioEngineProperty_ClientPID;
            goto LABEL_29;
          }
LABEL_137:
          uint64_t SInt32 = 4294954514;
          goto LABEL_17;
        }
      }
      goto LABEL_15;
    }
    if (CFEqual(a2, @"ClientAuditToken"))
    {
      if (!a3 || (CFTypeID v40 = CFGetTypeID(a3), v40 == CFDataGetTypeID()))
      {
        uint64_t v17 = FigEndpointStreamAudioEngineGetCMBaseObject(*(void *)(v7 + 72));
        uint64_t v41 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v41) {
          uint64_t v42 = v41;
        }
        else {
          uint64_t v42 = 0;
        }
        uint64_t v20 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(v42 + 56);
        if (v20)
        {
          uint64_t v21 = kFigEndpointStreamAudioEngineProperty_ClientAuditToken;
          goto LABEL_29;
        }
        goto LABEL_137;
      }
      goto LABEL_15;
    }
    if (CFEqual(a2, @"LoggingID"))
    {
      if (a3)
      {
        CFTypeID v43 = CFGetTypeID(a3);
        if (v43 == CFStringGetTypeID())
        {
          *(unsigned char *)(v7 + 208) = 0;
          uint64_t v44 = (char *)(v7 + 208);
          CFStringGetCString(a3, v44, 20, 0x600u);
          uint64_t v17 = FigEndpointStreamAudioEngineGetCMBaseObject(*((void *)v44 - 17));
          uint64_t v45 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v45) {
            uint64_t v46 = v45;
          }
          else {
            uint64_t v46 = 0;
          }
          uint64_t v20 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(v46 + 56);
          if (v20)
          {
            uint64_t v21 = kFigEndpointStreamAudioEngineProperty_LoggingID;
            goto LABEL_29;
          }
          goto LABEL_137;
        }
      }
      goto LABEL_15;
    }
    if (!CFEqual(a2, @"AudioProcessingTap"))
    {
      if (CFEqual(a2, @"CompressionLatency"))
      {
        if (a3)
        {
          CFTypeID v56 = CFGetTypeID(a3);
          if (v56 == CFNumberGetTypeID())
          {
            uint64_t v17 = FigEndpointStreamAudioEngineGetCMBaseObject(*(void *)(v7 + 72));
            uint64_t v57 = *(void *)(CMBaseObjectGetVTable() + 8);
            if (v57) {
              uint64_t v58 = v57;
            }
            else {
              uint64_t v58 = 0;
            }
            uint64_t v20 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(v58 + 56);
            if (v20)
            {
              uint64_t v21 = kFigEndpointStreamAudioEngineProperty_CompressionLatency;
              goto LABEL_29;
            }
            goto LABEL_137;
          }
        }
      }
      else
      {
        if (!CFEqual(a2, @"IsParticipatingInCoordinatedPlayback"))
        {
          uint64_t SInt32 = 4294954512;
          goto LABEL_17;
        }
        if (a3)
        {
          CFTypeID v65 = CFGetTypeID(a3);
          if (v65 == CFBooleanGetTypeID())
          {
            uint64_t v17 = FigEndpointStreamAudioEngineGetCMBaseObject(*(void *)(v7 + 72));
            uint64_t v66 = *(void *)(CMBaseObjectGetVTable() + 8);
            if (v66) {
              uint64_t v67 = v66;
            }
            else {
              uint64_t v67 = 0;
            }
            uint64_t v20 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(v67 + 56);
            if (v20)
            {
              uint64_t v21 = kFigEndpointStreamAudioEngineProperty_IsParticipatingInCoordinatedPlayback;
              goto LABEL_29;
            }
            goto LABEL_137;
          }
        }
      }
      goto LABEL_15;
    }
    if (a3 && (CFTypeID v54 = MTAudioProcessingTapGetTypeID(), v54 != CFGetTypeID(a3)))
    {
      uint64_t SInt32 = FigSignalErrorAt();
    }
    else
    {
      fbapo_setAndCacheAudioProcessingTap(a1, (uint64_t)a3, 1);
      uint64_t SInt32 = 0;
    }
    fbapo_setAndCacheAudioProcessingTap(a1, (uint64_t)a3, 1);
    goto LABEL_17;
  }
  if (!a3) {
    goto LABEL_15;
  }
  CFTypeID v32 = CFGetTypeID(a3);
  if (v32 != CFBooleanGetTypeID()) {
    goto LABEL_15;
  }
  int Value = CFBooleanGetValue((CFBooleanRef)a3);
  uint64_t v34 = CMBaseObjectGetDerivedStorage();
  if (*(unsigned __int8 *)(v34 + 168) == Value) {
    goto LABEL_39;
  }
  uint64_t v35 = v34;
  if (dword_1E93512F0)
  {
    LODWORD(v69.value) = 0;
    LOBYTE(type.value) = 0;
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (Value)
  {
    uint64_t v47 = *(void *)(v35 + 72);
    uint64_t v48 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v48) {
      uint64_t v49 = v48;
    }
    else {
      uint64_t v49 = 0;
    }
    CFDictionaryRef v52 = *(void (**)(uint64_t, void, void, void))(v49 + 24);
    if (v52) {
      v52(v47, 0, 0, 0);
    }
    if (dword_1E93512F0)
    {
      LODWORD(v69.value) = 0;
      LOBYTE(type.value) = 0;
      uint64_t v53 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    goto LABEL_97;
  }
  if (!fbapo_audioEngineIsResumed())
  {
LABEL_97:
    uint64_t SInt32 = 0;
    *(unsigned char *)(v35 + 168) = Value;
    goto LABEL_17;
  }
  memset(&v69, 0, sizeof(v69));
  HostTimeClocCFIndex k = CMClockGetHostTimeClock();
  CMSyncGetTime(&v69, HostTimeClock);
  if (*(void *)(v35 + 56))
  {
    if (dword_1E93512F0)
    {
      LODWORD(type.value) = 0;
      CFTypeRef v51 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    uint64_t v13 = FigEndpointStreamSuspendSync();
    if (v13) {
      goto LABEL_16;
    }
    CMClockRef v59 = CMClockGetHostTimeClock();
    CMSyncGetTime(&type, v59);
    CMTime rhs = v69;
    CMTimeSubtract(valuePtr, &type, &rhs);
    CMTime rhs = valuePtr[0];
    CMTimeConvertScale(valuePtr, &rhs, 1000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    if (6000 - LODWORD(valuePtr[0].value) <= 1) {
      unsigned int v55 = 1;
    }
    else {
      unsigned int v55 = 6000 - LODWORD(valuePtr[0].value);
    }
    if (v55 < 0x1F5)
    {
      uint64_t SInt32 = 0;
      goto LABEL_115;
    }
  }
  else
  {
    unsigned int v55 = 6000;
  }
  uint64_t SInt32 = FigCFNumberCreateSInt32();
  uint64_t v60 = FigEndpointStreamGetCMBaseObject();
  uint64_t v61 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v61) {
    uint64_t v62 = v61;
  }
  else {
    uint64_t v62 = 0;
  }
  CGRect v63 = *(void (**)(uint64_t, void, uint64_t))(v62 + 56);
  if (v63) {
    v63(v60, *MEMORY[0x1E4F213A8], SInt32);
  }
LABEL_115:
  if (dword_1E93512F0)
  {
    CGRect v64 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  FigEndpointStreamAudioEngineSetEndpointStreamSync(*(void *)(v35 + 72), *(void *)(v35 + 56), v55);
  *(unsigned char *)(v35 + 168) = 0;
  if (SInt32)
  {
    long long v28 = (const void *)SInt32;
LABEL_38:
    CFRelease(v28);
    goto LABEL_39;
  }
LABEL_17:
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  return SInt32;
}

uint64_t fbapo_amIActiveEndpointStreamClient()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  if (*(unsigned char *)DerivedStorage) {
    return 0;
  }
  uint64_t v1 = DerivedStorage;
  if (!*(void *)(DerivedStorage + 176) || !fbapo_audioEngineIsResumed()) {
    return 0;
  }
  uint64_t CMBaseObject = FigEndpointStreamAudioEngineGetCMBaseObject(*(void *)(v1 + 72));
  uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 8);
  uint64_t v4 = v3 ? v3 : 0;
  uint64_t v5 = *(unsigned int (**)(uint64_t, __CFString *, void, CFTypeRef *))(v4 + 48);
  if (!v5) {
    return 0;
  }
  if (v5(CMBaseObject, @"endpointStream", *MEMORY[0x1E4F1CF80], &cf)) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = cf == 0;
  }
  uint64_t v7 = !v6;
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

uint64_t fbapo_setAudioSessionID(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(CMBaseObjectGetDerivedStorage() + 56)) {
    return 0;
  }
  uint64_t result = fbapo_amIActiveEndpointStreamClient();
  if (result)
  {
    uint64_t CMBaseObject = FigEndpointStreamGetCMBaseObject();
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 56);
    if (v7)
    {
      uint64_t v8 = *MEMORY[0x1E4F21290];
      return v7(CMBaseObject, v8, a2);
    }
    else
    {
      return 4294954514;
    }
  }
  return result;
}

uint64_t fbapo_audioEngineIsResumed()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  BOOLeaCFIndex n = 0;
  uint64_t CMBaseObject = FigEndpointStreamAudioEngineGetCMBaseObject(*(void *)(DerivedStorage + 72));
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, __CFString *, void, CFBooleanRef *))(v3 + 48);
  if (!v4) {
    return 0;
  }
  int v5 = v4(CMBaseObject, @"isResumed", *MEMORY[0x1E4F1CF80], &BOOLean);
  CFBooleanRef v6 = BOOLean;
  if (v5)
  {
    uint64_t Value = 0;
    if (!BOOLean) {
      return Value;
    }
    goto LABEL_7;
  }
  uint64_t Value = CFBooleanGetValue(BOOLean);
  CFBooleanRef v6 = BOOLean;
  if (BOOLean) {
LABEL_7:
  }
    CFRelease(v6);
  return Value;
}

void fbapo_endpointStreamSupportedAudioFormatsChangedCallback(uint64_t a1, const void *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  char v5 = 0;
  if (dword_1E93512F0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (!*(unsigned char *)(DerivedStorage + 80)
    && !fbapo_supportsFormatChangeWithoutReconfiguration((uint64_t)a2, &v5)
    && !v5)
  {
    *(unsigned char *)(DerivedStorage + 80) = 1;
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  if (!v5) {
    fbapo_postNotificationInternal(a2, @"ActiveConfigurationDidBecomeInvalid", 0);
  }
}

void fbapo_endpointStreamInterruptionCallback(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    uint64_t v6 = Mutable;
    int v7 = CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F212F8]);
    if (v7 || CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F21300]))
    {
      if (dword_1E93512F0)
      {
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      if (v7)
      {
        if (*(void *)(DerivedStorage + 64))
        {
          CFDictionaryAddValue(v6, @"NotifyOthers", (const void *)*MEMORY[0x1E4F1CFD0]);
          uint64_t v9 = *(void *)(DerivedStorage + 64);
          if (v9)
          {
            uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v10)
            {
              uint64_t v11 = *(void (**)(uint64_t, __CFDictionary *))(v10 + 88);
              if (v11) {
                v11(v9, v6);
              }
            }
          }
        }
      }
    }
    CFRelease(v6);
  }
  else
  {
    FigSignalErrorAt();
  }
}

uint64_t fbapo_endpointStreamALACStreamingSupportChangedCallback()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (dword_1E93512F0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (FigCFDictionaryGetBooleanIfPresent()) {
    *(unsigned char *)(DerivedStorage + 265) = 1;
  }
  if (dword_1E93512F0)
  {
    uint64_t v2 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
}

uint64_t fbapo_supportsFormatChangeWithoutReconfiguration(uint64_t a1, unsigned char *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigSimpleMutexCheckIsLockedOnThisThread();
  if (!a2) {
    return 4294949976;
  }
  if (!*(void *)(DerivedStorage + 72)) {
    return 4294949976;
  }
  if (fbapo_audioEngineIsResumed())
  {
    fbapo_doesEndpointStreamSupportMixedSampleRates();
    if (dword_1E93512F0)
    {
      LODWORD(v13) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    uint64_t CMBaseObject = FigEndpointStreamAudioEngineGetCMBaseObject(*(void *)(DerivedStorage + 72));
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(uint64_t (**)(uint64_t))(v8 + 48);
    if (v9)
    {
      uint64_t v10 = v9(CMBaseObject);
      if (!v10) {
        return FigSignalErrorAt();
      }
      return v10;
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    uint64_t v5 = 0;
    *a2 = 0;
  }
  return v5;
}

void fbapo_postNotificationInternal(const void *a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a3) {
    CFRetain(a3);
  }
  CFRetain(a1);
  uint64_t v7 = *(NSObject **)(DerivedStorage + 24);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __fbapo_postNotificationInternal_block_invoke;
  block[3] = &__block_descriptor_tmp_145;
  block[4] = a2;
  block[5] = a1;
  block[6] = a3;
  dispatch_async(v7, block);
}

BOOL fbapo_doesEndpointStreamSupportMixedSampleRates()
{
  CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  uint64_t CMBaseObject = FigEndpointStreamGetCMBaseObject();
  uint64_t v1 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v1) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t v3 = *(unsigned int (**)(uint64_t, void, void, CFTypeRef *))(v2 + 48);
  BOOL v4 = v3 && !v3(CMBaseObject, *MEMORY[0x1E4F213D8], *MEMORY[0x1E4F1CF80], &cf) && FigCFEqual();
  if (cf) {
    CFRelease(cf);
  }
  return v4;
}

uint64_t fbapo_channelLayoutTagHash(int a1)
{
  if (a1 == 12845066) {
    int v1 = 64;
  }
  else {
    int v1 = 0;
  }
  if (a1 == 12779530) {
    int v2 = 32;
  }
  else {
    int v2 = v1;
  }
  if (a1 == 12713992) {
    int v3 = 16;
  }
  else {
    int v3 = v2;
  }
  if (a1 == 12648464) {
    int v4 = 256;
  }
  else {
    int v4 = 0;
  }
  if (a1 == 12582924) {
    int v5 = 128;
  }
  else {
    int v5 = v4;
  }
  if (a1 <= 12713991) {
    unsigned int v6 = v5;
  }
  else {
    unsigned int v6 = v3;
  }
  if (a1 == 8388616) {
    int v7 = 8;
  }
  else {
    int v7 = 0;
  }
  if (a1 == 8126470) {
    int v8 = 4;
  }
  else {
    int v8 = v7;
  }
  if (a1 == 6619138) {
    int v9 = 2;
  }
  else {
    int v9 = 0;
  }
  if (a1 == 6553601) {
    int v10 = 1;
  }
  else {
    int v10 = v9;
  }
  if (a1 <= 8126469) {
    unsigned int v11 = v10;
  }
  else {
    unsigned int v11 = v8;
  }
  if (a1 <= 12582923) {
    return v11;
  }
  else {
    return v6;
  }
}

void __fbapo_postNotificationInternal_block_invoke(uint64_t a1)
{
  CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification();
  int v2 = *(const void **)(a1 + 48);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(void *)(a1 + 40);

  fbapo_releaseAsync(v3);
}

void fbapo_releaseAsync(uint64_t a1)
{
  if (a1)
  {
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __fbapo_releaseAsync_block_invoke;
    block[3] = &__block_descriptor_tmp_146_0;
    block[4] = a1;
    dispatch_async(global_queue, block);
  }
}

void __fbapo_releaseAsync_block_invoke(uint64_t a1)
{
}

uint64_t fbapo_audioEngineEndpointStreamEvictedCallback()
{
  FigCFDictionaryGetValue();
  uint64_t result = FigCFEqual();
  if (!result)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    return CMNotificationCenterPostNotification();
  }
  return result;
}

uint64_t fbapo_audioEngineBufferingPriorityChangedCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  block[29] = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t Value = CFDictionaryGetValue(a5, @"bufferingPriority");
  int v8 = Value;
  if (Value) {
    CFRetain(Value);
  }
  int v9 = *(NSObject **)(DerivedStorage + 40);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __fbapo_audioEngineBufferingPriorityChangedCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_151;
  block[4] = DerivedStorage;
  void block[5] = v8;
  dispatch_async(v9, block);
  if (dword_1E93512F0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  CMNotificationCenterGetDefaultLocalCenter();
  return CMNotificationCenterPostNotification();
}

void fbapo_audioEnginePrerollDurationChangedCallback(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
  fbapo_postNotificationInternal(a2, @"prerollDurationChanged", a5);
  if (a5)
  {
    CFTypeID v6 = CFGetTypeID(a5);
    if (v6 == CFDictionaryGetTypeID()) {
      CMTimeMakeFromDictionary(&v7, (CFDictionaryRef)a5);
    }
  }
}

void fbapo_audioEngineActiveConfigurationDidBecomeInvalidCallback(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (*(void *)(DerivedStorage + 72) == a4
    && fbapo_audioEngineIsResumed()
    && !*(unsigned char *)(DerivedStorage + 80))
  {
    *(unsigned char *)(DerivedStorage + 80) = 1;
    fbapo_postNotificationInternal(a2, @"ActiveConfigurationDidBecomeInvalid", 0);
  }

  JUMPOUT(0x19970E930);
}

void fbapo_audioEngineDecryptionNotSupportedCallback(uint64_t a1, const void *a2)
{
  MutableCFStringRef Copy = FigCFDictionaryCreateMutableCopy();
  if (MutableCopy)
  {
    int v4 = (const void *)MutableCopy;
    if (dword_1E93512F0)
    {
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    fbapo_postNotificationInternal(a2, @"decryptionNotSupported", v4);
    CFRelease(v4);
  }
}

uint64_t fbapo_audioEngineFormatInfoChangedCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  uint64_t v7 = *(void *)(DerivedStorage + 64);
  if (v7)
  {
    if (!dword_1E93512F0
      || (os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(),
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT),
          fig_log_call_emit_and_clean_up_after_send_and_compose(),
          (uint64_t v7 = *(void *)(DerivedStorage + 64)) != 0))
    {
      uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v9)
      {
        int v10 = *(void (**)(uint64_t, void, uint64_t))(v9 + 56);
        if (v10) {
          v10(v7, *MEMORY[0x1E4F760C0], a5);
        }
      }
    }
  }
  return MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
}

void __fbapo_audioEngineBufferingPriorityChangedCallback_block_invoke(uint64_t a1)
{
  MEMORY[0x19970E910](*(void *)(*(void *)(a1 + 32) + 8));
  if (FigCFEqual())
  {
    int v2 = @"urgent";
  }
  else if (FigCFEqual())
  {
    int v2 = @"default";
  }
  else
  {
    if (!FigCFEqual()) {
      goto LABEL_8;
    }
    int v2 = @"relaxed";
  }
  *(void *)(*(void *)(a1 + 32) + 232) = v2;
LABEL_8:
  MEMORY[0x19970E930](*(void *)(*(void *)(a1 + 32) + 8));
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t fbapo_getCachedValue(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 160), @"AudioMode");
  if (!Value) {
    return 4294954513;
  }
  uint64_t v7 = Value;
  if (CFGetTypeID(Value) != a2) {
    return 4294954513;
  }
  uint64_t result = 0;
  *a3 = v7;
  return result;
}

uint64_t fbapo_setAndCacheAudioMode(uint64_t a1, __CFString *a2, int a3)
{
  CMBaseObjectGetDerivedStorage();
  if (!a2)
  {
    return FigSignalErrorAt();
  }
  CFPreferenceNumberWithuint64_t Default = FigGetCFPreferenceNumberWithDefault();
  if (CFPreferenceNumberWithDefault == 1)
  {
    CFTypeID v6 = @"AudioMode_Default";
    goto LABEL_6;
  }
  CFTypeID v6 = a2;
  if (CFPreferenceNumberWithDefault == 2)
  {
    CFTypeID v6 = @"AudioMode_MoviePlayback";
LABEL_6:
    if (v6 != a2 && dword_1E93512F0)
    {
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
  if (CFEqual(v6, @"AudioMode_Default"))
  {
    int v8 = (uint64_t *)MEMORY[0x1E4F212A0];
  }
  else if (CFEqual(v6, @"AudioMode_MoviePlayback"))
  {
    int v8 = (uint64_t *)MEMORY[0x1E4F212A8];
  }
  else
  {
    if (!CFEqual(v6, @"AudioMode_SpokenAudio")) {
      return 4294949976;
    }
    int v8 = (uint64_t *)MEMORY[0x1E4F212B0];
  }
  uint64_t v9 = *v8;
  if (!fbapo_amIActiveEndpointStreamClient())
  {
    if (!a3) {
      return 0;
    }
    goto LABEL_24;
  }
  uint64_t CMBaseObject = FigEndpointStreamGetCMBaseObject();
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  CFArrayRef v13 = *(uint64_t (**)(uint64_t, void, uint64_t))(v12 + 56);
  if (!v13) {
    return 4294954514;
  }
  uint64_t result = v13(CMBaseObject, *MEMORY[0x1E4F21330], v9);
  if (a3 && !result)
  {
LABEL_24:
    CMBaseObjectGetDerivedStorage();
    FigCFDictionarySetValue();
    return 0;
  }
  return result;
}

uint64_t fbapo_setAndCacheFigAudioSession(uint64_t a1, const void *a2, int a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  if (!a2) {
    return 4294948075;
  }
  uint64_t v7 = DerivedStorage;
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v8)
  {
    uint64_t v9 = *(uint64_t (**)(const void *, __CFString *, void, CFTypeRef *))(v8 + 8);
    if (v9)
    {
      uint64_t v10 = v9(a2, @"FAS_SourceSessionID", *MEMORY[0x1E4F1CF80], &cf);
      if (v10)
      {
        uint64_t v12 = v10;
      }
      else
      {
        uint64_t v11 = fbapo_setAudioSessionID(a1, (uint64_t)cf);
        uint64_t v12 = v11;
        if (a3 && !v11)
        {
          CMBaseObjectGetDerivedStorage();
          FigCFDictionarySetValue();
          CFArrayRef v13 = *(const void **)(v7 + 64);
          *(void *)(v7 + 64) = a2;
          CFRetain(a2);
          if (v13) {
            CFRelease(v13);
          }
          uint64_t v12 = 0;
        }
      }
    }
    else
    {
      uint64_t v12 = 4294948071;
    }
  }
  else
  {
    uint64_t v12 = 4294948075;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v12;
}

void fbapo_setAndCacheAudioProcessingTap(uint64_t a1, uint64_t a2, int a3)
{
  v14[24] = *MEMORY[0x1E4F143B8];
  v14[0] = 0;
  if (*(void *)(CMBaseObjectGetDerivedStorage() + 56) && fbapo_amIActiveEndpointStreamClient())
  {
    if (MTAudioProcessingTapIsProxyTap(a2))
    {
      if (MTProxyAudioProcessingTapGetObjectID(a2, v14))
      {
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        return;
      }
      UInt64 = (const void *)FigCFNumberCreateUInt64();
      if (UInt64) {
        BOOL v6 = v14[0] == 0;
      }
      else {
        BOOL v6 = 1;
      }
      if (v6)
      {
        FigSignalErrorAt();
        goto LABEL_23;
      }
    }
    else
    {
      if (a2)
      {
        uint64_t v7 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      UInt64 = 0;
    }
    uint64_t CMBaseObject = FigEndpointStreamGetCMBaseObject();
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(uint64_t (**)(uint64_t, void, const void *))(v10 + 56);
    if (!v11) {
      goto LABEL_23;
    }
    int v12 = v11(CMBaseObject, *MEMORY[0x1E4F21338], UInt64);
    if (!a3 || v12) {
      goto LABEL_23;
    }
  }
  else
  {
    if (!a3) {
      return;
    }
    UInt64 = 0;
  }
  CMBaseObjectGetDerivedStorage();
  FigCFDictionarySetValue();
LABEL_23:
  if (UInt64) {
    CFRelease(UInt64);
  }
}

uint64_t fbapo_setRateAndAnchorTime(const void *a1, char a2, CMTime *a3, long long *a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (dword_1E93512F0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (*(unsigned char *)DerivedStorage)
  {
    MutableCFStringRef Copy = 0;
    uint64_t v19 = 0;
    a8 = 4294954511;
  }
  else
  {
    if (a9 != 0.0)
    {
      if (*MEMORY[0x1E4F1EBA0])
      {
        uint64_t v17 = fig_log_handle();
        if (os_signpost_enabled(v17))
        {
          CMTime time = *a3;
          Float64 Seconds = CMTimeGetSeconds(&time);
          LODWORD(time.value) = 134218496;
          *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)a1;
          LOWORD(time.flags) = 2048;
          *(double *)((char *)&time.flags + 2) = a9;
          HIWORD(time.epoch) = 2048;
          Float64 v35 = Seconds;
          _os_signpost_emit_with_name_impl(&dword_193E8D000, v17, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "WHA_BAO_SetRateAndAnchorTime", " enableTelemetry=YES bao=%llu, rate=%1.2f, mediaTime=%1.3f", (uint8_t *)&time, 0x20u);
        }
      }
      if (*MEMORY[0x1E4F1EB90])
      {
        CMTime time = *a3;
        CMTimeGetSeconds(&time);
        fig_gm_ktrace_wrapper();
      }
    }
    uint64_t v19 = (char *)malloc_type_calloc(1uLL, 0x68uLL, 0x10A00400FDB3E6BuLL);
    if (v19)
    {
      if (a1) {
        CFTypeRef v20 = CFRetain(a1);
      }
      else {
        CFTypeRef v20 = 0;
      }
      *(void *)uint64_t v19 = v20;
      v19[8] = a2;
      *((double *)v19 + 2) = a9;
      long long v21 = *(_OWORD *)&a3->value;
      *((void *)v19 + 5) = a3->epoch;
      *(_OWORD *)(v19 + 24) = v21;
      long long v22 = *a4;
      *((void *)v19 + 8) = *((void *)a4 + 2);
      *((_OWORD *)v19 + 3) = v22;
      *((void *)v19 + 10) = a6;
      *((void *)v19 + 11) = a7;
      if (a5) {
        CFTypeRef v23 = CFRetain(a5);
      }
      else {
        CFTypeRef v23 = 0;
      }
      *((void *)v19 + 9) = v23;
      if (!a8)
      {
        MutableCFStringRef Copy = 0;
        goto LABEL_22;
      }
      MutableCFStringRef Copy = (const void *)FigCFDictionaryCreateMutableCopy();
      if (MutableCopy)
      {
        FigCFDictionaryGetValue();
        uint64_t v25 = FigCFDictionaryCreateMutableCopy();
        if (v25)
        {
          a8 = v25;
          FigCFDictionarySetValue();
          *((void *)v19 + 12) = CFRetain(MutableCopy);
LABEL_22:
          uint64_t v26 = CMBaseObjectGetDerivedStorage();
          FigSimpleMutexCheckIsLockedOnThisThread();
          if (dword_1E93512F0)
          {
            CFBooleanRef v27 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          if (a1) {
            dispatch_async_f(*(dispatch_queue_t *)(v26 + 16), v19, (dispatch_function_t)fbapo_setRateAndAnchorTimeDispatch);
          }
          if (a8)
          {
            CFRelease((CFTypeRef)a8);
            a8 = 0;
          }
          goto LABEL_28;
        }
      }
      a8 = 4294951816;
    }
    else
    {
      MutableCFStringRef Copy = 0;
      a8 = 4294949975;
    }
  }
  free(v19);
  if (a9 != 0.0)
  {
    if (*MEMORY[0x1E4F1EBA0])
    {
      CFTypeID v29 = fig_log_handle();
      if (os_signpost_enabled(v29))
      {
        CMTime time = *a3;
        Float64 v30 = CMTimeGetSeconds(&time);
        LODWORD(time.value) = 134218752;
        *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)a1;
        LOWORD(time.flags) = 2048;
        *(double *)((char *)&time.flags + 2) = a9;
        HIWORD(time.epoch) = 2048;
        Float64 v35 = v30;
        __int16 v36 = 2048;
        uint64_t v37 = (int)a8;
        _os_signpost_emit_with_name_impl(&dword_193E8D000, v29, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "WHA_BAO_SetRateAndAnchorTime", " enableTelemetry=YES bao=%llu, rate=%1.2f, mediaTime=%1.3f, error=%llu", (uint8_t *)&time, 0x2Au);
      }
    }
    if (*MEMORY[0x1E4F1EB90])
    {
      CMTime time = *a3;
      CMTimeGetSeconds(&time);
      fig_gm_ktrace_wrapper();
    }
  }
LABEL_28:
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  return a8;
}

uint64_t fbapo_flush()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (*(unsigned char *)DerivedStorage) {
    uint64_t v1 = 4294954511;
  }
  else {
    uint64_t v1 = fbapo_flushInternal();
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  return v1;
}

uint64_t fbapo_flushWithinTimeRange(uint64_t a1, long long *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v10 = 4294954511;
  }
  else
  {
    long long v12 = *a2;
    long long v13 = a2[1];
    long long v14 = a2[2];
    uint64_t v4 = CMBaseObjectGetDerivedStorage();
    *(_OWORD *)uint64_t v17 = v12;
    *(_OWORD *)&v17[16] = v13;
    long long v18 = v14;
    *(_OWORD *)CMTimeRange lhs = v12;
    *(void *)&lhs[16] = v13;
    *(_OWORD *)CMTime rhs = *(_OWORD *)(v4 + 112);
    *(void *)&rhs[16] = *(void *)(v4 + 128);
    CMTimeSubtract((CMTime *)v17, (CMTime *)lhs, (CMTime *)rhs);
    uint64_t v5 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)(v4 + 240) = *MEMORY[0x1E4F1F9F8];
    *(void *)(v4 + 256) = *(void *)(v5 + 16);
    uint64_t v6 = *(void *)(v4 + 72);
    *(_OWORD *)CMTime rhs = *(_OWORD *)v17;
    *(_OWORD *)&rhs[16] = *(_OWORD *)&v17[16];
    long long v16 = v18;
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(uint64_t (**)(uint64_t, unsigned char *))(v8 + 40);
    if (v9)
    {
      *(_OWORD *)CMTimeRange lhs = *(_OWORD *)rhs;
      *(_OWORD *)&lhs[16] = *(_OWORD *)&rhs[16];
      long long v20 = v16;
      uint64_t v10 = v9(v6, lhs);
    }
    else
    {
      uint64_t v10 = 4294954514;
    }
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  return v10;
}

uint64_t fbapo_reset(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v6 = 4294954511;
  }
  else if (a2 && (uint64_t v5 = fbapo_flushInternal(), v5))
  {
    uint64_t v6 = v5;
  }
  else
  {
    __n128 v4 = fbapo_resetInternal();
    uint64_t v6 = 0;
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8), v4);
  return v6;
}

uint64_t fbapo_setConnectionActive(const void *a1, int a2, int a3, const void *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v14 = 4294954511;
LABEL_13:
    MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
    return v14;
  }
  int v9 = *(_DWORD *)(DerivedStorage + 192);
  if (a2 == 1 && v9 == 1 || !a2 && !v9)
  {
    if (dword_1E93512F0)
    {
      int v24 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    uint64_t v14 = 0;
    goto LABEL_13;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], 0);
  if (!Mutable)
  {
    uint64_t v14 = 4294949975;
    goto LABEL_13;
  }
  CFMutableDictionaryRef v12 = Mutable;
  FigCFDictionarySetValue();
  fbapo_postNotificationInternal(a1, @"GoActive", v12);
  if (a2)
  {
    if (dword_1E93512F0)
    {
      int v24 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      long long v13 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (*(unsigned char *)(DerivedStorage + 264))
    {
      if (a1) {
        CFRetain(a1);
      }
      if (a4) {
        CFRetain(a4);
      }
      long long v16 = *(NSObject **)(DerivedStorage + 16);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __fbapo_setConnectionActive_block_invoke;
      block[3] = &__block_descriptor_tmp_182;
      block[4] = DerivedStorage;
      void block[5] = a1;
      block[6] = a4;
      dispatch_async(v16, block);
    }
    *(_DWORD *)(DerivedStorage + 192) = 1;
  }
  else
  {
    if (dword_1E93512F0)
    {
      int v24 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      uint64_t v15 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    fbapo_resetInternal();
    uint64_t v17 = *(void *)(DerivedStorage + 72);
    uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v18) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = 0;
    }
    long long v20 = *(void (**)(uint64_t, void, void, void))(v19 + 16);
    if (v20) {
      v20(v17, 0, 0, 0);
    }
    *(unsigned char *)(DerivedStorage + 80) = 0;
    *(_DWORD *)(DerivedStorage + 192) = 0;
    if (a3) {
      fbapo_postNotificationInternal(a1, @"PrerollLost", 0);
    }
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  CFRelease(v12);
  return 0;
}

uint64_t fbapo_stopForReconfiguration()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v9 = 4294954511;
    goto LABEL_16;
  }
  uint64_t v1 = CMBaseObjectGetDerivedStorage();
  if (dword_1E93512F0)
  {
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (*(void *)(v1 + 72))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable)
    {
      uint64_t v9 = 4294954510;
      goto LABEL_16;
    }
    CFMutableDictionaryRef v4 = Mutable;
    uint64_t v5 = FigEndpointStreamAudioEngineSuspendSync(*(void *)(v1 + 72), 0, 3000);
    if (!v5)
    {
      *(unsigned char *)(v1 + 80) = 0;
      uint64_t v6 = *(void *)(v1 + 72);
      uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v7) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v10 = *(uint64_t (**)(uint64_t, CFMutableDictionaryRef))(v8 + 32);
      if (!v10)
      {
        uint64_t v9 = 4294954514;
        goto LABEL_15;
      }
      uint64_t v5 = v10(v6, v4);
    }
    uint64_t v9 = v5;
LABEL_15:
    CFRelease(v4);
    goto LABEL_16;
  }
  uint64_t v9 = 0;
LABEL_16:
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  return v9;
}

uint64_t fbapo_setEndOfSiriTTSUtteranceMediaTime(uint64_t a1, long long *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v8 = 4294954511;
  }
  else
  {
    uint64_t v4 = *(void *)(DerivedStorage + 72);
    long long v10 = *a2;
    uint64_t v11 = *((void *)a2 + 2);
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(uint64_t (**)(uint64_t, long long *))(v6 + 56);
    if (v7)
    {
      long long v12 = v10;
      uint64_t v13 = v11;
      uint64_t v8 = v7(v4, &v12);
    }
    else
    {
      uint64_t v8 = 4294954514;
    }
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  return v8;
}

uint64_t fbapo_applyVolueFade(uint64_t a1, uint64_t a2, long long *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v9 = 4294954511;
  }
  else if ((a2 - 1) > 1)
  {
    uint64_t v9 = 4294949976;
  }
  else
  {
    uint64_t v6 = *(void *)(DerivedStorage + 72);
    long long v12 = *a3;
    uint64_t v13 = *((void *)a3 + 2);
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    long long v10 = *(uint64_t (**)(uint64_t, uint64_t, long long *))(v8 + 64);
    if (v10)
    {
      long long v14 = v12;
      uint64_t v15 = v13;
      uint64_t v9 = v10(v6, a2, &v14);
    }
    else
    {
      uint64_t v9 = 4294954514;
    }
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
  return v9;
}

uint64_t fbapo_copyTransportFormatDescriptionForSourceContentFormatDescription(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage() + 56);
  FigEndpointStreamAirPlayGetClassID();
  if (!CMBaseObjectIsMemberOfClass()) {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 24);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *))(v7 + 24);
  if (!v8 || (uint64_t result = v8(v5, a2, a3), result))
  {
    if (*a3) {
      CFRelease(*a3);
    }
    return FigEndpointStreamAudioFormatDescriptionCreate();
  }
  return result;
}

uint64_t fbapo_doesSupportPassthroughOfFormatDescription(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  char v22 = 0;
  if (!a3)
  {
    uint64_t result = FigSignalErrorAt();
    char v16 = 0;
    goto LABEL_31;
  }
  uint64_t v6 = DerivedStorage;
  CFStringRef theString = 0;
  uint64_t v7 = *(void *)(CMBaseObjectGetDerivedStorage() + 64);
  if (!v7) {
    goto LABEL_30;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (!v8) {
    goto LABEL_16;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, void, void, CFStringRef *))(v8 + 48);
  if (!v9) {
    goto LABEL_16;
  }
  int v10 = v9(v7, *MEMORY[0x1E4F761A0], *MEMORY[0x1E4F1CF80], &theString);
  CFStringRef v11 = theString;
  if (v10) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = theString == 0;
  }
  if (!v12)
  {
    if (FigCFEqual()
      || FigCFEqual()
      || FigCFEqual()
      || FigCFEqual()
      || FigCFEqual()
      || CFStringHasPrefix(theString, @"com.apple.cmta"))
    {
      int v13 = 1;
      goto LABEL_17;
    }
LABEL_16:
    int v13 = 0;
LABEL_17:
    CFStringRef v11 = theString;
    if (!theString) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  int v13 = 0;
  if (theString) {
LABEL_18:
  }
    CFRelease(v11);
LABEL_19:
  if (!v13) {
    goto LABEL_30;
  }
  uint64_t v14 = *(void *)(v6 + 56);
  FigEndpointStreamAirPlayGetClassID();
  int IsMemberOfClass = CMBaseObjectIsMemberOfClass();
  char v16 = 0;
  if (!IsMemberOfClass)
  {
    uint64_t result = 0;
    goto LABEL_31;
  }
  uint64_t result = 0;
  if (v14)
  {
    uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 24);
    if (v18) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = 0;
    }
    long long v20 = *(uint64_t (**)(uint64_t, uint64_t, char *))(v19 + 32);
    if (v20)
    {
      int v21 = v20(v14, a2, &v22);
      uint64_t result = 0;
      if (v21) {
        char v16 = 0;
      }
      else {
        char v16 = v22;
      }
      goto LABEL_31;
    }
LABEL_30:
    char v16 = 0;
    uint64_t result = 0;
  }
LABEL_31:
  *a3 = v16;
  return result;
}

void fbapo_setRateAndAnchorTimeDispatch(uint64_t a1)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  int v2 = *(void **)a1;
  int v3 = *(unsigned __int8 *)(a1 + 8);
  double v4 = *(double *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v37 = *(void *)(a1 + 88);
  uint64_t v38 = *(void *)(a1 + 80);
  uint64_t v36 = *(void *)(a1 + 96);
  CMTime v42 = *(CMTime *)(a1 + 24);
  CMTime v41 = *(CMTime *)(a1 + 48);
  uint64_t v6 = CMBaseObjectGetDerivedStorage();
  long long v35 = *MEMORY[0x1E4F1F9F8];
  *(_OWORD *)&v46.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v7 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  v46.CMTimeEpoch epoch = v7;
  MEMORY[0x19970E910](*(void *)(v6 + 8));
  if (dword_1E93512F0)
  {
    LODWORD(v49.value) = 0;
    LOBYTE(type.value) = 0;
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (*(unsigned char *)v6)
  {
    int v17 = -12785;
    goto LABEL_41;
  }
  if (v3)
  {
    if (v4 != 0.0)
    {
      HostTimeClocCFIndex k = CMClockGetHostTimeClock();
      CMClockGetTime(&v46, HostTimeClock);
      int active = fbapo_becomeActiveEndpointStreamAudioEngineClient(v2, v5);
      if (active)
      {
        int v17 = active;
        goto LABEL_41;
      }
    }
  }
  CMTime type = v42;
  CMTime v44 = v41;
  CMTime v43 = v46;
  uint64_t v11 = CMBaseObjectGetDerivedStorage();
  uint64_t v12 = v11;
  char flags = v42.flags;
  if (v42.flags)
  {
    p_CMTime type = &type;
  }
  else
  {
    p_CMTime type = (CMTime *)(v11 + 84);
    if ((*(unsigned char *)(v11 + 96) & 1) == 0) {
      p_CMTime type = (CMTime *)MEMORY[0x1E4F1FA48];
    }
  }
  CMTime v49 = *p_type;
  uint64_t v15 = (char *)malloc_type_calloc(1uLL, 0x68uLL, 0x10A0040D348C322uLL);
  if (v15)
  {
    if (v4 == 0.0)
    {
      *(_OWORD *)&v49.CMTimeValue value = v35;
      v49.CMTimeEpoch epoch = v7;
    }
    uint64_t v16 = *(void *)(v12 + 56);
    FigEndpointStreamAirPlayGetClassID();
    int v17 = -17324;
    if (CMBaseObjectIsMemberOfClass() && v16)
    {
      *(void *)uint64_t v15 = CFRetain(v2);
      *((double *)v15 + 1) = v4;
      *(CMTime *)(v15 + 16) = v42;
      *((void *)v15 + 5) = v38;
      *((void *)v15 + 6) = v37;
      uint64_t v18 = CMClockGetHostTimeClock();
      CMClockGetTime(&time, v18);
      *(CMTime *)(v15 + 80) = time;
      *(CMTime *)(v15 + 56) = v43;
      if (dword_1E93512F0)
      {
        unsigned int v48 = 0;
        os_log_type_t v47 = OS_LOG_TYPE_DEFAULT;
        uint64_t v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v20 = v48;
        if (os_log_type_enabled(v19, v47)) {
          unsigned int v21 = v20;
        }
        else {
          unsigned int v21 = v20 & 0xFFFFFFFE;
        }
        if (v21)
        {
          if (v2) {
            char v22 = (const char *)(CMBaseObjectGetDerivedStorage() + 208);
          }
          else {
            char v22 = "";
          }
          CMTime time = v49;
          Float64 Seconds = CMTimeGetSeconds(&time);
          CMTime time = v41;
          Float64 v24 = CMTimeGetSeconds(&time);
          LODWORD(v50.value) = 136317186;
          *(CMTimeValue *)((char *)&v50.value + 4) = (CMTimeValue)"fbapo_setRateAndAnchorTimeInternal";
          LOWORD(v50.flags) = 2048;
          *(void *)((char *)&v50.flags + 2) = v2;
          HIWORD(v50.epoch) = 2082;
          CFTypeRef v51 = v22;
          __int16 v52 = 2048;
          uint64_t v53 = v16;
          __int16 v54 = 2048;
          double v55 = v4;
          __int16 v56 = 2048;
          Float64 v57 = Seconds;
          __int16 v58 = 2048;
          Float64 v59 = v24;
          __int16 v60 = 2048;
          uint64_t v61 = fbapo_setRateAndAnchorTimeCallback;
          __int16 v62 = 2048;
          CGRect v63 = v15;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      uint64_t v25 = *(void *)(v12 + 72);
      if (v4 == 0.0) {
        double v26 = 0.0;
      }
      else {
        double v26 = 1.0;
      }
      uint64_t v27 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v27) {
        uint64_t v28 = v27;
      }
      else {
        uint64_t v28 = 0;
      }
      CFTypeID v29 = *(void (**)(uint64_t, CMTime *, CMTime *, void, char *, uint64_t, double))(v28 + 48);
      if (v29)
      {
        CMTime time = v49;
        CMTime v50 = v44;
        v29(v25, &time, &v50, fbapo_setRateAndAnchorTimeCallback, v15, v36, v26);
      }
      else
      {
        fbapo_setRateAndAnchorTimeCallback(v25, -12782, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], 0, (uint64_t *)v15, 0.0);
      }
      int v17 = 0;
      if (v4 != 0.0 && (flags & 1) != 0 && *(unsigned char *)(v12 + 108))
      {
        int v17 = 0;
        *(CMTime *)(v12 + 112) = type;
        *(unsigned char *)(v12 + 108) = 0;
      }
      goto LABEL_41;
    }
  }
  else
  {
    int v17 = -12786;
  }
  if (v38)
  {
    if (v2) {
      CFRetain(v2);
    }
    CFAllocatorRef v33 = *(NSObject **)(v12 + 24);
    time.CMTimeValue value = MEMORY[0x1E4F143A8];
    *(void *)&time.CMTimeScale timescale = 0x40000000;
    time.CMTimeEpoch epoch = (CMTimeEpoch)__fbapo_setRateAndAnchorTimeInternal_block_invoke;
    double v65 = COERCE_DOUBLE(&__block_descriptor_tmp_180);
    *(double *)&long long v66 = v4;
    CMTime v69 = v42;
    int v70 = v17;
    *((void *)&v66 + 1) = v2;
    uint64_t v67 = v38;
    uint64_t v68 = v37;
    CMTime v71 = v41;
    dispatch_async(v33, &time);
  }
  if (v15)
  {
    if (*(void *)v15) {
      CFRelease(*(CFTypeRef *)v15);
    }
    free(v15);
  }
LABEL_41:
  if (v4 == 0.0 || !v17)
  {
    MEMORY[0x19970E930](*(void *)(v6 + 8));
    if (!v17) {
      goto LABEL_52;
    }
  }
  else
  {
    if (*MEMORY[0x1E4F1EBA0])
    {
      Float64 v30 = fig_log_handle();
      if (os_signpost_enabled(v30))
      {
        CMTime time = v42;
        Float64 v31 = CMTimeGetSeconds(&time);
        LODWORD(time.value) = 134218752;
        *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)v2;
        LOWORD(time.flags) = 2048;
        *(double *)((char *)&time.flags + 2) = v4;
        HIWORD(time.epoch) = 2048;
        double v65 = v31;
        LOWORD(v66) = 2048;
        *(void *)((char *)&v66 + 2) = v17;
        _os_signpost_emit_with_name_impl(&dword_193E8D000, v30, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "WHA_BAO_SetRateAndAnchorTime", " enableTelemetry=YES bao=%llu, rate=%1.2f, mediaTime=%1.3f, error=%llu", (uint8_t *)&time, 0x2Au);
      }
    }
    if (*MEMORY[0x1E4F1EB90])
    {
      CMTime time = v42;
      CMTimeGetSeconds(&time);
      fig_gm_ktrace_wrapper();
    }
    MEMORY[0x19970E930](*(void *)(v6 + 8));
  }
  if (*(void *)(a1 + 80))
  {
    CFTypeID v32 = *(NSObject **)(DerivedStorage + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __fbapo_setRateAndAnchorTimeDispatch_block_invoke;
    block[3] = &__block_descriptor_tmp_177;
    block[4] = a1;
    int v40 = v17;
    dispatch_async(v32, block);
    return;
  }
LABEL_52:
  fbapo_setRateAndAnchorTimeDispatchContextDestroy((uint64_t *)a1);
}

void __fbapo_setRateAndAnchorTimeDispatch_block_invoke(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(double *)(v2 + 16) != 0.0)
  {
    if (*MEMORY[0x1E4F1EBA0])
    {
      int v3 = fig_log_handle();
      BOOL v4 = os_signpost_enabled(v3);
      uint64_t v2 = *(void *)(a1 + 32);
      if (v4)
      {
        CMTimeValue v5 = *(void *)v2;
        uint64_t v6 = *(void *)(v2 + 16);
        CMTime time = *(CMTime *)(v2 + 24);
        Float64 Seconds = CMTimeGetSeconds(&time);
        uint64_t v8 = *(int *)(a1 + 40);
        LODWORD(time.value) = 134218752;
        *(CMTimeValue *)((char *)&time.value + 4) = v5;
        LOWORD(time.flags) = 2048;
        *(void *)((char *)&time.flags + 2) = v6;
        HIWORD(time.epoch) = 2048;
        Float64 v16 = Seconds;
        __int16 v17 = 2048;
        uint64_t v18 = v8;
        _os_signpost_emit_with_name_impl(&dword_193E8D000, v3, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "WHA_BAO_SetRateAndAnchorTime", " enableTelemetry=YES bao=%llu, rate=%1.2f, mediaTime=%1.3f, error=%llu", (uint8_t *)&time, 0x2Au);
        uint64_t v2 = *(void *)(a1 + 32);
      }
    }
    if (*MEMORY[0x1E4F1EB90])
    {
      CMTime time = *(CMTime *)(v2 + 24);
      CMTimeGetSeconds(&time);
      fig_gm_ktrace_wrapper();
      uint64_t v2 = *(void *)(a1 + 32);
    }
  }
  int v10 = *(void (**)(uint64_t, uint64_t, CMTime *, long long *, void, float))(v2 + 80);
  uint64_t v9 = *(void *)(v2 + 88);
  uint64_t v11 = *(unsigned int *)(a1 + 40);
  float v12 = *(double *)(v2 + 16);
  CMTime time = *(CMTime *)(v2 + 24);
  long long v13 = *(_OWORD *)(v2 + 48);
  uint64_t v14 = *(void *)(v2 + 64);
  v10(v9, v11, &time, &v13, 0, v12);
  fbapo_setRateAndAnchorTimeDispatchContextDestroy(*(uint64_t **)(a1 + 32));
}

void fbapo_setRateAndAnchorTimeDispatchContextDestroy(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[12];
    if (v2)
    {
      CFRelease(v2);
      a1[12] = 0;
    }
    int v3 = (const void *)a1[9];
    if (v3)
    {
      CFRelease(v3);
      a1[9] = 0;
    }
    fbapo_releaseAsync(*a1);
    free(a1);
  }
}

uint64_t fbapo_becomeActiveEndpointStreamAudioEngineClient(void *a1, uint64_t a2)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (dword_1E93512F0)
  {
    LODWORD(v66.value) = 0;
    LOBYTE(type.value) = 0;
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  uint64_t v6 = (unsigned char *)MEMORY[0x1E4F1EBA0];
  if (*MEMORY[0x1E4F1EBA0])
  {
    CMTimeEpoch v7 = fig_log_handle();
    if (os_signpost_enabled(v7))
    {
      LODWORD(buf.value) = 134217984;
      *(CMTimeValue *)((char *)&buf.value + 4) = (CMTimeValue)a1;
      _os_signpost_emit_with_name_impl(&dword_193E8D000, v7, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "WHA_BAO_BecomeActiveEndpointStream", " enableTelemetry=YES bao=%llu", (uint8_t *)&buf, 0xCu);
    }
  }
  uint64_t v8 = (_DWORD *)MEMORY[0x1E4F1EB90];
  if (*MEMORY[0x1E4F1EB90]) {
    fig_gm_ktrace_wrapper();
  }
  FigSimpleMutexCheckIsLockedOnThisThread();
  if (fbapo_amIActiveEndpointStreamClient()
    || *(unsigned char *)(DerivedStorage + 168) && fbapo_audioEngineIsResumed())
  {
    goto LABEL_94;
  }
  uint64_t v9 = fbapo_setAudioSessionID((uint64_t)a1, 0);
  if (v9)
  {
    uint64_t v32 = v9;
    goto LABEL_95;
  }
  uint64_t v10 = *(void *)(DerivedStorage + 200);
  uint64_t CMBaseObject = FigEndpointStreamGetCMBaseObject();
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = *(void (**)(uint64_t, void, uint64_t))(v13 + 56);
  if (v14) {
    v14(CMBaseObject, *MEMORY[0x1E4F21350], v10);
  }
  uint64_t v15 = CMBaseObjectGetDerivedStorage();
  CFTypeRef v67 = 0;
  CFArrayRef theArray = 0;
  CMTime v66 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CFTypeRef cf = 0;
  if (dword_1E93512F0)
  {
    LODWORD(type.value) = 0;
    Float64 v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  BOOL doesEndpointStreamSupportMixedSampleRates = fbapo_doesEndpointStreamSupportMixedSampleRates();
  if (dword_1E93512F0)
  {
    LODWORD(type.value) = 0;
    uint64_t v18 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  uint64_t v19 = FigEndpointStreamGetCMBaseObject();
  uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v20) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = 0;
  }
  char v22 = *(uint64_t (**)(uint64_t, void, void, CFArrayRef *))(v21 + 48);
  if (!v22)
  {
    uint64_t SInt32 = 0;
    CFMutableDictionaryRef v31 = 0;
    CFMutableDictionaryRef Mutable = 0;
LABEL_33:
    uint64_t v32 = 4294954514;
    goto LABEL_81;
  }
  uint64_t v63 = v15;
  CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v24 = v22(v19, *MEMORY[0x1E4F213C0], *MEMORY[0x1E4F1CF80], &theArray);
  if (v24)
  {
LABEL_103:
    uint64_t v32 = v24;
    uint64_t SInt32 = 0;
    CFMutableDictionaryRef v31 = 0;
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_81;
  }
  if (!theArray)
  {
    uint64_t v24 = FigSignalErrorAt();
    goto LABEL_103;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    uint64_t SInt32 = 0;
    CFMutableDictionaryRef v31 = 0;
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v32 = 4294949976;
    goto LABEL_81;
  }
  CFIndex v26 = Count;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v23, 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    uint64_t SInt32 = 0;
    CFMutableDictionaryRef v31 = 0;
LABEL_109:
    uint64_t v32 = 4294954510;
    goto LABEL_81;
  }
  CFAllocatorRef allocator = v23;
  if (a2)
  {
    double v28 = *(double *)FigEndpointStreamAudioFormatDescriptionGetASBD();
    if (dword_1E93512F0)
    {
      LODWORD(type.value) = 0;
      CFTypeID v29 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    goto LABEL_42;
  }
  uint64_t v33 = FigEndpointStreamGetCMBaseObject();
  uint64_t v34 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v34) {
    uint64_t v35 = v34;
  }
  else {
    uint64_t v35 = 0;
  }
  uint64_t v36 = *(uint64_t (**)(uint64_t, void, const __CFAllocator *, CFTypeRef *))(v35 + 48);
  if (!v36)
  {
    uint64_t SInt32 = 0;
    CFMutableDictionaryRef v31 = 0;
    goto LABEL_33;
  }
  uint64_t v37 = v36(v33, *MEMORY[0x1E4F213A0], v23, &v67);
  if (v37)
  {
LABEL_107:
    uint64_t v32 = v37;
    uint64_t SInt32 = 0;
    CFMutableDictionaryRef v31 = 0;
    goto LABEL_81;
  }
  double v28 = *(double *)FigEndpointStreamAudioFormatDescriptionGetASBD();
  if (dword_1E93512F0)
  {
    LODWORD(type.value) = 0;
    uint64_t v38 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
LABEL_42:
  int v39 = 0;
  for (CFIndex i = 0; i != v26; ++i)
  {
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
    ASBD = (double *)FigEndpointStreamAudioFormatDescriptionGetASBD();
    if (doesEndpointStreamSupportMixedSampleRates || *ASBD == v28)
    {
      CFArrayAppendValue(Mutable, ValueAtIndex);
      int v39 = 1;
    }
  }
  if (dword_1E93512F0)
  {
    LODWORD(type.value) = 0;
    CMTime v43 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (!v39 || !*(void *)(v15 + 176))
  {
    uint64_t v37 = FigSignalErrorAt();
    goto LABEL_107;
  }
  CFMutableDictionaryRef v31 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v31)
  {
    uint64_t SInt32 = 0;
    goto LABEL_109;
  }
  FigCFDictionarySetValue();
  FigCFDictionarySetValue();
  FigCFDictionarySetValue();
  uint64_t v44 = *(void *)(v15 + 64);
  if (v44)
  {
    uint64_t v45 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v45)
    {
      CMTime v46 = *(void (**)(uint64_t, __CFString *, const __CFAllocator *, CFTypeRef *))(v45 + 8);
      if (v46) {
        v46(v44, @"FAS_CoreSessionID", allocator, &cf);
      }
    }
    if (dword_1E93512F0)
    {
      LODWORD(type.value) = 0;
      os_log_type_t v47 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    FigCFDictionarySetValue();
  }
  HostTimeClocCFIndex k = CMClockGetHostTimeClock();
  CMSyncGetTime(&v66, HostTimeClock);
  uint64_t Value = FigCFDictionaryGetValue();
  if (Value)
  {
    mach_absolute_time();
    FigCFDictionarySetInt64();
  }
  uint64_t v50 = FigEndpointStreamAudioEngineResumeSync(*(void *)(v15 + 72), (uint64_t)v31, 6000);
  if (v50)
  {
    uint64_t v32 = v50;
    uint64_t SInt32 = 0;
  }
  else
  {
    uint64_t v51 = v15;
    if (*(unsigned char *)(v15 + 168))
    {
      if (dword_1E93512F0)
      {
        LODWORD(type.value) = 0;
        __int16 v52 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      uint64_t SInt32 = 0;
      uint64_t v32 = 0;
    }
    else
    {
      CMClockRef v53 = CMClockGetHostTimeClock();
      CMSyncGetTime(&type, v53);
      CMTime rhs = v66;
      CMTimeSubtract(&buf, &type, &rhs);
      CMTime rhs = buf;
      CMTimeConvertScale(&buf, &rhs, 1000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      if (6000 - LODWORD(buf.value) <= 1) {
        unsigned int v54 = 1;
      }
      else {
        unsigned int v54 = 6000 - LODWORD(buf.value);
      }
      if (v54 < 0x1F5)
      {
        uint64_t SInt32 = 0;
      }
      else
      {
        uint64_t SInt32 = (const void *)FigCFNumberCreateSInt32();
        uint64_t v55 = FigEndpointStreamGetCMBaseObject();
        uint64_t v56 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v56) {
          uint64_t v57 = v56;
        }
        else {
          uint64_t v57 = 0;
        }
        __int16 v58 = *(void (**)(uint64_t, void, const void *))(v57 + 56);
        if (v58) {
          v58(v55, *MEMORY[0x1E4F213A8], SInt32);
        }
      }
      if (dword_1E93512F0)
      {
        Float64 v59 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        uint64_t v51 = v63;
      }
      if (Value)
      {
        mach_absolute_time();
        FigCFDictionarySetInt64();
      }
      uint64_t v32 = FigEndpointStreamAudioEngineSetEndpointStreamSync(*(void *)(v51 + 72), *(void *)(v51 + 56), v54);
    }
  }
LABEL_81:
  if (cf) {
    CFRelease(cf);
  }
  if (theArray) {
    CFRelease(theArray);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v31) {
    CFRelease(v31);
  }
  if (SInt32) {
    CFRelease(SInt32);
  }
  uint64_t v8 = (_DWORD *)MEMORY[0x1E4F1EB90];
  uint64_t v6 = (unsigned char *)MEMORY[0x1E4F1EBA0];
  if (v67) {
    CFRelease(v67);
  }
  if (!v32)
  {
LABEL_94:
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(DerivedStorage + 160), (CFDictionaryApplierFunction)fbapo_applyCachedPropertiesForBecomeActiveIterator, a1);
    uint64_t v32 = 0;
  }
LABEL_95:
  if (*v6)
  {
    __int16 v60 = fig_log_handle();
    if (os_signpost_enabled(v60))
    {
      LODWORD(buf.value) = 134218240;
      *(CMTimeValue *)((char *)&buf.value + 4) = (CMTimeValue)a1;
      LOWORD(buf.flags) = 2048;
      *(void *)((char *)&buf.flags + 2) = (int)v32;
      _os_signpost_emit_with_name_impl(&dword_193E8D000, v60, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "WHA_BAO_BecomeActiveEndpointStream", " enableTelemetry=YES bao=%llu, error=%llu", (uint8_t *)&buf, 0x16u);
    }
  }
  if (*v8) {
    fig_gm_ktrace_wrapper();
  }
  return v32;
}

void fbapo_applyCachedPropertiesForBecomeActiveIterator(const void *a1, __CFString *a2, uint64_t a3)
{
  if (CFEqual(a1, @"AudioMode"))
  {
    fbapo_setAndCacheAudioMode(a3, a2, 0);
  }
  else if (CFEqual(a1, @"FigAudioSession"))
  {
    if ((__CFString *)*MEMORY[0x1E4F1D260] == a2) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = a2;
    }
    fbapo_setAndCacheFigAudioSession(a3, v6, 0);
  }
  else if (CFEqual(a1, @"AudioProcessingTap"))
  {
    if ((__CFString *)*MEMORY[0x1E4F1D260] == a2) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = (uint64_t)a2;
    }
    fbapo_setAndCacheAudioProcessingTap(a3, v7, 0);
  }
}

void fbapo_setRateAndAnchorTimeCallback(uint64_t a1, int a2, CMTime *a3, CMTime *a4, const void *a5, uint64_t *a6, Float64 a7)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  CMTime v56 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CMTime v55 = v56;
  CMTime v54 = v56;
  uint64_t v8 = *a6;
  if (*a6)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    CMTime lhs = *(CMTime *)(a6 + 10);
    CMTime rhs = *(CMTime *)(a6 + 7);
    CMTimeSubtract(&v56, &lhs, &rhs);
    HostTimeClocCFIndex k = CMClockGetHostTimeClock();
    CMClockGetTime(&v53, HostTimeClock);
    CMTime lhs = *(CMTime *)(a6 + 10);
    CMTimeSubtract(&v55, &v53, &lhs);
    uint64_t v14 = CMClockGetHostTimeClock();
    CMClockGetTime(&v52, v14);
    CMTime lhs = *(CMTime *)(a6 + 7);
    CMTimeSubtract(&v54, &v52, &lhs);
    if (*(unsigned char *)(DerivedStorage + 252))
    {
      CMTime rhs = v54;
      CMTime v51 = *(CMTime *)(DerivedStorage + 240);
      CMTimeAdd(&lhs, &rhs, &v51);
      CMTime v54 = lhs;
    }
    if (dword_1E93512F0)
    {
      uint64_t v15 = a1;
      Float64 v16 = a4;
      LODWORD(v51.value) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int value = v51.value;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v19 = value;
      }
      else {
        unsigned int v19 = value & 0xFFFFFFFE;
      }
      if (v19)
      {
        uint64_t v20 = CMBaseObjectGetDerivedStorage() + 208;
        CMTime lhs = *a3;
        Float64 Seconds = CMTimeGetSeconds(&lhs);
        CMTime lhs = *v16;
        Float64 v22 = CMTimeGetSeconds(&lhs);
        LODWORD(rhs.value) = 136316930;
        *(CMTimeValue *)((char *)&rhs.value + 4) = (CMTimeValue)"fbapo_setRateAndAnchorTimeCallback";
        LOWORD(rhs.flags) = 2048;
        *(void *)((char *)&rhs.flags + 2) = v8;
        HIWORD(rhs.epoch) = 2082;
        uint64_t v58 = v20;
        __int16 v59 = 2048;
        *(void *)__int16 v60 = v15;
        *(_WORD *)&v60[8] = 2048;
        *(Float64 *)&v60[10] = a7;
        *(_WORD *)&v60[18] = 2048;
        *(Float64 *)&v60[20] = Seconds;
        *(_WORD *)&v60[28] = 2048;
        *(Float64 *)&v60[30] = v22;
        *(_WORD *)&v60[38] = 2048;
        *(void *)&v60[40] = a6;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      a4 = v16;
      if (dword_1E93512F0)
      {
        LODWORD(v51.value) = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        CFAllocatorRef v23 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v24 = v51.value;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          unsigned int v25 = v24;
        }
        else {
          unsigned int v25 = v24 & 0xFFFFFFFE;
        }
        if (v25)
        {
          uint64_t v26 = CMBaseObjectGetDerivedStorage() + 208;
          CMTime lhs = *v16;
          Float64 v27 = CMTimeGetSeconds(&lhs);
          CMTime lhs = *(CMTime *)(DerivedStorage + 240);
          Float64 v28 = CMTimeGetSeconds(&lhs);
          CMTime lhs = v56;
          Float64 v29 = CMTimeGetSeconds(&lhs);
          CMTime lhs = v55;
          Float64 v30 = CMTimeGetSeconds(&lhs);
          CMTime lhs = v54;
          Float64 v31 = CMTimeGetSeconds(&lhs);
          LODWORD(rhs.value) = 136317442;
          *(CMTimeValue *)((char *)&rhs.value + 4) = (CMTimeValue)"fbapo_setRateAndAnchorTimeCallback";
          LOWORD(rhs.flags) = 2048;
          *(void *)((char *)&rhs.flags + 2) = v8;
          HIWORD(rhs.epoch) = 2082;
          uint64_t v58 = v26;
          __int16 v59 = 1024;
          *(_DWORD *)__int16 v60 = a2;
          *(_WORD *)&v60[4] = 2048;
          *(Float64 *)&v60[6] = a7;
          *(_WORD *)&v60[14] = 2048;
          *(Float64 *)&v60[16] = v27;
          *(_WORD *)&v60[24] = 2048;
          *(Float64 *)&v60[26] = v28;
          *(_WORD *)&v60[34] = 2048;
          *(Float64 *)&v60[36] = v29;
          *(_WORD *)&v60[44] = 2048;
          *(Float64 *)&v60[46] = v30;
          __int16 v61 = 2048;
          Float64 v62 = v31;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
    }
    int v32 = a2;
    if (!a2)
    {
      MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
      if (!*(unsigned char *)DerivedStorage)
      {
        memset(&v51, 0, sizeof(v51));
        CMClockRef v33 = CMClockGetHostTimeClock();
        uint64_t v34 = *(const void **)(DerivedStorage + 144);
        CMTime lhs = *a4;
        CMSyncConvertTime(&v51, &lhs, v33, v34);
        if (dword_1E93512F0)
        {
          *(_DWORD *)CMTime type = 0;
          os_log_type_t v49 = OS_LOG_TYPE_DEFAULT;
          uint64_t v35 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          int v32 = 0;
        }
        uint64_t v36 = *(OpaqueCMTimebase **)(DerivedStorage + 152);
        CMTime lhs = *a3;
        CMTime rhs = v51;
        CMTimebaseSetRateAndAnchorTime(v36, a7, &lhs, &rhs);
      }
      MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
    }
    CFTypeRef v37 = a5;
    if (a5) {
      CFTypeRef v37 = CFRetain(a5);
    }
    uint64_t v38 = *(NSObject **)(DerivedStorage + 40);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __fbapo_setRateAndAnchorTimeCallback_block_invoke;
    block[3] = &__block_descriptor_tmp_181;
    long long v44 = *(_OWORD *)&a3->value;
    CMTimeEpoch epoch = a3->epoch;
    int v46 = v32;
    block[4] = DerivedStorage;
    *(Float64 *)&void block[5] = a7;
    block[6] = v8;
    void block[7] = a6;
    long long v47 = *(_OWORD *)&a4->value;
    CMTimeEpoch v48 = a4->epoch;
    block[8] = v37;
    dispatch_async(v38, block);
  }
  else if (dword_1E93512F0)
  {
    int v39 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
}

void __fbapo_setRateAndAnchorTimeInternal_block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  double v2 = *(double *)(a1 + 32);
  if (v2 != 0.0)
  {
    if (*MEMORY[0x1E4F1EBA0])
    {
      int v3 = fig_log_handle();
      if (os_signpost_enabled(v3))
      {
        uint64_t v5 = *(void *)(a1 + 32);
        CMTimeValue v4 = *(void *)(a1 + 40);
        CMTime time = *(CMTime *)(a1 + 64);
        Float64 Seconds = CMTimeGetSeconds(&time);
        uint64_t v7 = *(int *)(a1 + 88);
        LODWORD(time.value) = 134218752;
        *(CMTimeValue *)((char *)&time.value + 4) = v4;
        LOWORD(time.flags) = 2048;
        *(void *)((char *)&time.flags + 2) = v5;
        HIWORD(time.epoch) = 2048;
        Float64 v15 = Seconds;
        __int16 v16 = 2048;
        uint64_t v17 = v7;
        _os_signpost_emit_with_name_impl(&dword_193E8D000, v3, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "WHA_BAO_SetRateAndAnchorTime", " enableTelemetry=YES bao=%llu, rate=%1.2f, mediaTime=%1.3f, error=%llu", (uint8_t *)&time, 0x2Au);
      }
    }
    double v2 = *(double *)(a1 + 32);
    if (*MEMORY[0x1E4F1EB90])
    {
      CMTime time = *(CMTime *)(a1 + 64);
      CMTimeGetSeconds(&time);
      fig_gm_ktrace_wrapper();
      double v2 = *(double *)(a1 + 32);
    }
  }
  uint64_t v9 = *(void (**)(uint64_t, uint64_t, CMTime *, long long *, void, float))(a1 + 48);
  uint64_t v8 = *(void *)(a1 + 56);
  uint64_t v10 = *(unsigned int *)(a1 + 88);
  float v11 = v2;
  CMTime time = *(CMTime *)(a1 + 64);
  long long v12 = *(_OWORD *)(a1 + 92);
  uint64_t v13 = *(void *)(a1 + 108);
  v9(v8, v10, &time, &v12, 0, v11);
  fbapo_releaseAsync(*(void *)(a1 + 40));
}

void __fbapo_setRateAndAnchorTimeCallback_block_invoke(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CMTime v24 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  double v2 = (CMTime *)(a1 + 72);
  CMTime v23 = *(CMTime *)(a1 + 72);
  int v3 = *(_DWORD *)(a1 + 96);
  if (v3 <= -17581)
  {
    if (v3 == -17582)
    {
      uint64_t v4 = 4294949971;
      goto LABEL_18;
    }
    if (v3 == -17581)
    {
      uint64_t v4 = 4294949973;
      goto LABEL_18;
    }
    goto LABEL_10;
  }
  uint64_t v4 = 0;
  if (v3 != -17580 && v3)
  {
LABEL_10:
    uint64_t v4 = *(unsigned int *)(a1 + 96);
    goto LABEL_18;
  }
  if (!v3)
  {
    MEMORY[0x19970E910](*(void *)(*(void *)(a1 + 32) + 8));
    uint64_t v5 = *(void *)(a1 + 32);
    if (!*(unsigned char *)v5 && (*(double *)(a1 + 40) != 0.0 || (*(unsigned char *)(v5 + 96) & 1) != 0))
    {
      if (dword_1E93512F0)
      {
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        uint64_t v5 = *(void *)(a1 + 32);
      }
      long long v7 = *(_OWORD *)&v2->value;
      *(void *)(v5 + 100) = v2->epoch;
      *(_OWORD *)(v5 + 84) = v7;
      uint64_t v5 = *(void *)(a1 + 32);
    }
    MEMORY[0x19970E930](*(void *)(v5 + 8));
  }
LABEL_18:
  uint64_t v8 = *(void *)(a1 + 56);
  if (*(void *)(v8 + 40))
  {
    double v9 = *(double *)(v8 + 8);
    if (v9 != 0.0)
    {
      CMTime time = v23;
      CMTimeMultiplyByFloat64(&v23, &time, v9);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    if (*(unsigned char *)(v8 + 28))
    {
      *(_OWORD *)&time.unsigned int value = *(_OWORD *)(v8 + 16);
      CMTimeEpoch v11 = *(void *)(v8 + 32);
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 32);
      *(_OWORD *)&time.unsigned int value = *(_OWORD *)(v10 + 112);
      CMTimeEpoch v11 = *(void *)(v10 + 128);
    }
    time.CMTimeEpoch epoch = v11;
    CMTime rhs = v23;
    CMTimeAdd(&v24, &time, &rhs);
    double v12 = *(double *)(a1 + 40);
    if (v12 != 0.0)
    {
      if (*MEMORY[0x1E4F1EBA0])
      {
        uint64_t v13 = fig_log_handle();
        if (os_signpost_enabled(v13))
        {
          uint64_t v15 = *(void *)(a1 + 40);
          CMTimeValue v14 = *(void *)(a1 + 48);
          CMTime time = *v2;
          Float64 Seconds = CMTimeGetSeconds(&time);
          LODWORD(time.value) = 134218752;
          *(CMTimeValue *)((char *)&time.value + 4) = v14;
          LOWORD(time.flags) = 2048;
          *(void *)((char *)&time.flags + 2) = v15;
          HIWORD(time.epoch) = 2048;
          Float64 v27 = Seconds;
          __int16 v28 = 2048;
          uint64_t v29 = (int)v4;
          _os_signpost_emit_with_name_impl(&dword_193E8D000, v13, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "WHA_BAO_SetRateAndAnchorTime", " enableTelemetry=YES bao=%llu, rate=%1.2f, mediaTime=%1.3f, error=%llu", (uint8_t *)&time, 0x2Au);
        }
      }
      double v12 = *(double *)(a1 + 40);
      if (*MEMORY[0x1E4F1EB90])
      {
        CMTime time = *v2;
        CMTimeGetSeconds(&time);
        fig_gm_ktrace_wrapper();
        double v12 = *(double *)(a1 + 40);
      }
    }
    uint64_t v18 = *(void *)(a1 + 56);
    uint64_t v17 = *(void *)(a1 + 64);
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, CMTime *, CMTime *, uint64_t, float))(v18 + 40);
    uint64_t v19 = *(void *)(v18 + 48);
    float v21 = v12;
    CMTime time = v24;
    CMTime rhs = *(CMTime *)(a1 + 100);
    v20(v19, v4, &time, &rhs, v17, v21);
  }
  Float64 v22 = *(const void **)(a1 + 64);
  if (v22) {
    CFRelease(v22);
  }
  fbapo_releaseAsync(**(void **)(a1 + 56));
  **(void **)(a1 + 56) = 0;
  free(*(void **)(a1 + 56));
}

uint64_t fbapo_flushInternal()
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (dword_1E93512F0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  CMTimebaseSetRate(*(CMTimebaseRef *)(DerivedStorage + 152), 0.0);
  uint64_t v2 = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = *(void *)(v2 + 184);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t))(v5 + 72);
  if (!v6) {
    return 4294954514;
  }
  uint64_t v7 = v6(v3);
  if (v7) {
    return v7;
  }
  uint64_t v8 = *(void *)(v2 + 176);
  if (!v8) {
    goto LABEL_14;
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  uint64_t v10 = v9 ? v9 : 0;
  CMTimeEpoch v11 = *(uint64_t (**)(uint64_t))(v10 + 72);
  if (!v11) {
    return 4294954514;
  }
  uint64_t v7 = v11(v8);
  if (v7) {
    return v7;
  }
LABEL_14:
  if (!*(void *)(v2 + 56)) {
    return 0;
  }
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 4294954510;
  }
  CMTimeValue v14 = Mutable;
  CMTimeFlags v15 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
  if ((v15 & 0x1D) == 1)
  {
    CMTimeEpoch v16 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
    time.unsigned int value = *MEMORY[0x1E4F1F9F8];
    time.CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
    time.char flags = v15;
    time.CMTimeEpoch epoch = v16;
    CFDictionaryRef v17 = CMTimeCopyAsDictionary(&time, v12);
    if (v17)
    {
      CFDictionaryRef v18 = v17;
      CFDictionarySetValue(v14, @"AnchorTime", v17);
      CFDictionarySetValue(v14, @"TimelineReset", (const void *)*MEMORY[0x1E4F1CFD0]);
      CFRelease(v18);
      uint64_t v19 = 0;
    }
    else
    {
      uint64_t v19 = 4294954510;
    }
  }
  else
  {
    uint64_t v21 = *(void *)(v2 + 72);
    uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v22) {
      uint64_t v23 = v22;
    }
    else {
      uint64_t v23 = 0;
    }
    CMTime v24 = *(uint64_t (**)(uint64_t, __CFDictionary *))(v23 + 32);
    if (v24)
    {
      uint64_t v19 = v24(v21, v14);
      if (!v19) {
        *(unsigned char *)(v2 + 108) = 1;
      }
    }
    else
    {
      uint64_t v19 = 4294954514;
    }
  }
  CFRelease(v14);
  return v19;
}

__n128 fbapo_resetInternal()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (dword_1E93512F0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  *(_DWORD *)(DerivedStorage + 192) = -999;
  uint64_t v2 = MEMORY[0x1E4F1F9F8];
  __n128 result = *(__n128 *)MEMORY[0x1E4F1F9F8];
  *(_OWORD *)(DerivedStorage + 240) = *MEMORY[0x1E4F1F9F8];
  *(void *)(DerivedStorage + 256) = *(void *)(v2 + 16);
  return result;
}

void __fbapo_setConnectionActive_block_invoke(uint64_t a1)
{
  MEMORY[0x19970E910](*(void *)(*(void *)(a1 + 32) + 8));
  if (fbapo_becomeActiveEndpointStreamAudioEngineClient(*(void **)(a1 + 40), *(void *)(a1 + 48))) {
    BOOL v2 = dword_1E93512F0 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  MEMORY[0x19970E930](*(void *)(*(void *)(a1 + 32) + 8));
  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4) {
    CFRelease(v4);
  }
  fbapo_releaseAsync(*(void *)(a1 + 40));
}

void fbapo_airPlayPrefsChangedCallback(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = 0;
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
  CFTypeID TypeID = CFStringGetTypeID();
  if (fbapo_getCachedValue(a2, TypeID, &v6)) {
    uint64_t v5 = @"AudioMode_Default";
  }
  else {
    uint64_t v5 = v6;
  }
  fbapo_setAndCacheAudioMode(a2, v5, 0);

  JUMPOUT(0x19970E930);
}

uint64_t FigCaptionRendererLegibleOutputCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a1 && a2 && a3 && a5)
  {
    *a5 = 0;
    FigCaptionRendererOutputGetClassID();
    CMDerivedObjectCreate();
  }
  return FigSignalErrorAt();
}

__CFString *FigCaptionRendererLegibleOutput_CopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigCaptionRendererLegibleOutput %p>", a1);
  return Mutable;
}

uint64_t transactionBegin_2()
{
  return 0;
}

uint64_t transactionFlush_2()
{
  return 0;
}

uint64_t transactionCommit_2()
{
  return 0;
}

uint64_t setNeedsDisplayInRect_2()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)DerivedStorage) {
    (*(void (**)(void, void))(DerivedStorage + 88))(*(void *)DerivedStorage, *(void *)(DerivedStorage + 72));
  }
  return 0;
}

double getBounds_2()
{
  return *(double *)(CMBaseObjectGetDerivedStorage() + 8);
}

uint64_t setBounds_2(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(double *)(DerivedStorage + 8) = a1;
  *(double *)(DerivedStorage + 16) = a2;
  *(double *)(DerivedStorage + 24) = a3;
  *(double *)(DerivedStorage + 32) = a4;
  (*(void (**)(void, uint64_t, double, double, double, double))(DerivedStorage + 80))(*(void *)(DerivedStorage + 72), a6, a1, a2, a3, a4);
  return 0;
}

uint64_t setVideoBounds_2(double a1, double a2, double a3, double a4)
{
  uint64_t DerivedStorage = (double *)CMBaseObjectGetDerivedStorage();
  DerivedStorage[5] = a1;
  DerivedStorage[6] = a2;
  DerivedStorage[7] = a3;
  DerivedStorage[8] = a4;
  return 0;
}

int clear_2(void)
{
  return 0;
}

uint64_t FigCaptionStyleSegmentGetTypeID()
{
  return sFigCaptionStyleSegmentID;
}

uint64_t styleSegment_Register()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionStyleSegmentID = result;
  return result;
}

CFIndex FigCaptionStyleSegmentGetTextLength(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(v3 + 8);
  if (v4)
  {
    CFStringRef v5 = (const __CFString *)v4(v1);
    if (!v5) {
      return 0;
    }
  }
  else
  {
    CFStringRef v5 = &stru_1EE53F4B8;
  }

  return CFStringGetLength(v5);
}

uint64_t FigCaptionStyleSegmentCopyText(uint64_t a1, __CFString **a2)
{
  if (a1)
  {
    CFStringRef v5 = *(__CFString **)(a1 + 16);
    if (!v5)
    {
      uint64_t v7 = *(void *)(a1 + 24);
      if (!v7)
      {
        CFStringRef v5 = 0;
        goto LABEL_4;
      }
      uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v8) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = 0;
      }
      uint64_t v10 = *(uint64_t (**)(uint64_t))(v9 + 8);
      if (v10)
      {
        CFStringRef v5 = (__CFString *)v10(v7);
        if (!v5)
        {
          *(void *)(a1 + 16) = 0;
          goto LABEL_4;
        }
      }
      else
      {
        CFStringRef v5 = &stru_1EE53F4B8;
      }
      CFStringRef v5 = (__CFString *)CFRetain(v5);
      *(void *)(a1 + 16) = v5;
      if (!v5) {
        goto LABEL_4;
      }
    }
    CFStringRef v5 = (__CFString *)CFRetain(v5);
LABEL_4:
    *a2 = v5;
    return 0;
  }
  return FigSignalErrorAt();
}

uint64_t FigCaptionStyleSegmentCopyCaptionData(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    CFTypeRef v3 = *(CFTypeRef *)(a1 + 24);
    if (v3) {
      CFTypeRef v3 = CFRetain(v3);
    }
    *a2 = v3;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigCaptionStyleSegmentCopyAttributes(uint64_t a1, void *a2)
{
  if (a1)
  {
    CFTypeRef v4 = *(CFTypeRef *)(a1 + 32);
    if (v4) {
      CFTypeRef v4 = CFRetain(v4);
    }
    *a2 = v4;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigCaptionStyleSegmentGeneratorGetTypeID()
{
  return sFigCaptionStyleSegmentGeneratorID;
}

uint64_t fcstylesegmenter_Register()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionStyleSegmentGeneratorID = result;
  return result;
}

uint64_t FigCaptionStyleSegmentGeneratorPerform(uint64_t a1)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    uint64_t v1 = a1;
    uint64_t v2 = *(void *)(a1 + 64);
    theArray.start.unsigned int value = 0;
    uint64_t v56 = *MEMORY[0x1E4F1FF48];
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t CMBaseObject = FigCaptionDataGetCMBaseObject();
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, const __CFAllocator *, CMTimeRange *))(v6 + 48);
    CFAllocatorRef allocator = v3;
    if (v7)
    {
      uint64_t v8 = v7(CMBaseObject, v56, v3, &theArray);
      if (v8)
      {
        uint64_t v12 = v8;
        CFMutableArrayRef Mutable = 0;
      }
      else
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
        if (Mutable)
        {
          uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v10) {
            uint64_t v11 = v10;
          }
          else {
            uint64_t v11 = 0;
          }
          uint64_t v13 = *(uint64_t (**)(uint64_t))(v11 + 8);
          if (v13) {
            CFStringRef v14 = (const __CFString *)v13(v2);
          }
          else {
            CFStringRef v14 = &stru_1EE53F4B8;
          }
          CFIndex Length = CFStringGetLength(v14);
          CFIndex Count = CFArrayGetCount((CFArrayRef)theArray.start.value);
          if (Count)
          {
            CFIndex v17 = Count;
            CFIndex v18 = 0;
            while (1)
            {
              CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)theArray.start.value, v18);
              *(void *)CMTime start = 0;
              *(void *)&start[8] = 0;
              if (Length) {
                break;
              }
LABEL_25:
              if (++v18 == v17) {
                goto LABEL_26;
              }
            }
            uint64_t v20 = ValueAtIndex;
            uint64_t v21 = 0;
            while (1)
            {
              uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v22) {
                uint64_t v23 = v22;
              }
              else {
                uint64_t v23 = 0;
              }
              CMTime v24 = *(uint64_t (**)(uint64_t, uint64_t, const void *, CFAllocatorRef, void, unsigned char *))(v23 + 24);
              if (!v24)
              {
                uint64_t v12 = 4294954514;
                goto LABEL_28;
              }
              uint64_t v25 = v24(v2, v21, v20, allocator, 0, start);
              if (v25) {
                break;
              }
              uint64_t v21 = *(void *)&start[8] + *(void *)start;
              FigCFArrayAppendCFIndex();
              if (v21 == Length) {
                goto LABEL_25;
              }
            }
            uint64_t v12 = v25;
LABEL_28:
            CFRelease(Mutable);
            CFMutableArrayRef Mutable = 0;
          }
          else
          {
LABEL_26:
            v72.length = CFArrayGetCount(Mutable);
            v72.locatioCFIndex n = 0;
            CFArraySortValues(Mutable, v72, MEMORY[0x1E4F1C258], 0);
            uint64_t v12 = 0;
          }
          CFAllocatorRef v3 = allocator;
        }
        else
        {
          uint64_t v12 = FigSignalErrorAt();
        }
      }
    }
    else
    {
      CFMutableArrayRef Mutable = 0;
      uint64_t v12 = 4294954514;
    }
    if (theArray.start.value) {
      CFRelease((CFTypeRef)theArray.start.value);
    }
    if (v12)
    {
LABEL_92:
      if (!Mutable)
      {
LABEL_94:
        if (cf) {
          CFRelease(cf);
        }
        return v12;
      }
    }
    else
    {
      CFIndex v26 = CFArrayGetCount(Mutable);
      if (v26)
      {
        CFIndex v27 = v26;
        uint64_t v28 = 0;
        uint64_t v29 = 0;
        uint64_t v58 = v1 + 40;
        __int16 v59 = (CMTime *)(v1 + 16);
        uint64_t v30 = (const void *)*MEMORY[0x1E4F201C0];
        CFIndex v57 = v26;
        __int16 v60 = Mutable;
        while (1)
        {
          uint64_t v64 = 0;
          FigCFArrayGetCFIndexAtIndex();
          if (v64 != v29) {
            break;
          }
LABEL_80:
          if (++v28 == v27)
          {
            uint64_t v12 = 0;
            goto LABEL_92;
          }
        }
        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0;
        }
        uint64_t v31 = FigCaptionDataCopySubrange();
        if (v31) {
          goto LABEL_98;
        }
        CFTypeRef v32 = cf;
        *(CMTime *)CMTime start = *v59;
        *(_OWORD *)&theArray.start.unsigned int value = *(_OWORD *)v58;
        theArray.start.CMTimeEpoch epoch = *(void *)(v58 + 16);
        CMTimeRangeFromTimeToTime(&v63, (CMTime *)start, &theArray.start);
        *(void *)CMTime start = 0;
        uint64_t v33 = FigCaptionDataGetCMBaseObject();
        uint64_t v34 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v34) {
          uint64_t v35 = v34;
        }
        else {
          uint64_t v35 = 0;
        }
        uint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t, const __CFAllocator *, unsigned char *))(v35 + 48);
        if (v36)
        {
          uint64_t v37 = v36(v33, v56, v3, start);
          if (v37)
          {
            uint64_t v12 = v37;
            int v39 = 0;
          }
          else
          {
            CFIndex v38 = CFArrayGetCount(*(CFArrayRef *)start);
            int v39 = CFArrayCreateMutable(v3, v38, MEMORY[0x1E4F1D510]);
            if (v39)
            {
              CFIndex v40 = CFArrayGetCount(*(CFArrayRef *)start);
              if (v40)
              {
                CFIndex v41 = v40;
                for (CFIndex i = 0; i != v41; ++i)
                {
                  CMTime v43 = CFArrayGetValueAtIndex(*(CFArrayRef *)start, i);
                  if (!CFEqual(v43, v30)) {
                    CFArrayAppendValue(v39, v43);
                  }
                }
                uint64_t v12 = 0;
                CFAllocatorRef v3 = allocator;
              }
              else
              {
                uint64_t v12 = 0;
              }
            }
            else
            {
              uint64_t v12 = FigSignalErrorAt();
            }
          }
        }
        else
        {
          int v39 = 0;
          uint64_t v12 = 4294954514;
        }
        if (*(void *)start) {
          CFRelease(*(CFTypeRef *)start);
        }
        if (v12) {
          goto LABEL_76;
        }
        uint64_t v44 = v1;
        CMTimeRange theArray = v63;
        v70[0] = 0;
        CFDictionaryRef v45 = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFDictionaryRef v68 = v45;
        uint64_t v69 = 0;
        *(CMTimeRange *)&start[8] = theArray;
        *(void *)CMTime start = v32;
        v73.length = CFArrayGetCount(v39);
        v73.locatioCFIndex n = 0;
        CFArrayApplyFunction(v39, v73, (CFArrayApplierFunction)fcstylesegmenter_buildTimeToAttributesMap, start);
        if (v69)
        {
          CMTime v52 = 0;
          CMTimeEpoch v48 = 0;
          uint64_t v12 = 0;
        }
        else
        {
          CFIndex v46 = CFDictionaryGetCount(v45);
          if (v46 < 1)
          {
            CMTime v52 = 0;
            CMTimeEpoch v48 = 0;
            uint64_t v12 = 0;
          }
          else
          {
            size_t v47 = v46;
            CMTimeEpoch v48 = 0;
            if (!((unint64_t)v46 >> 61))
            {
              size_t v49 = 8 * v46;
              if (8 * v47) {
                CMTimeEpoch v48 = (const void **)malloc_type_malloc(v49, 0x5CC9CBA6uLL);
              }
            }
            CFDictionaryGetKeysAndValues(v45, v48, 0);
            qsort_r(v48, v47, 8uLL, 0, (int (__cdecl *)(void *, const void *, const void *))fcstylesegmenter_compareCFNumber);
            uint64_t v50 = figCaptionStyleSegmentCreate(v70);
            if (!v50)
            {
              uint64_t v51 = 0;
              CMTime v52 = (void *)v70[0];
              do
              {
                CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v45, v48[v51]);
                if (!v51) {
                  CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)fcstylesegmenter_addAttribute, v52);
                }
                ++v51;
              }
              while (v47 != v51);
              uint64_t v12 = figCaptionStyleSegmentSetCaptionData((uint64_t)v52, v32);
              CFAllocatorRef v3 = allocator;
              if (v12) {
                CMTime v52 = 0;
              }
              else {
                v70[0] = 0;
              }
              goto LABEL_67;
            }
            uint64_t v12 = v50;
            CMTime v52 = 0;
          }
          CFAllocatorRef v3 = allocator;
        }
LABEL_67:
        if (v45) {
          CFRelease(v45);
        }
        free(v48);
        if (v70[0]) {
          CFRelease(v70[0]);
        }
        uint64_t v1 = v44;
        if (v12)
        {
          CFIndex v27 = v57;
          if (!v52) {
            goto LABEL_76;
          }
        }
        else
        {
          CFIndex v27 = v57;
          if (!v52)
          {
            uint64_t v12 = fcstylesegmenter_setCaptionData((CFMutableArrayRef *)v1, v32);
            goto LABEL_76;
          }
          CFArrayAppendValue(*(CFMutableArrayRef *)(v1 + 72), v52);
        }
        CFRelease(v52);
LABEL_76:
        if (v39) {
          CFRelease(v39);
        }
        CFMutableArrayRef Mutable = v60;
        if (v12) {
          goto LABEL_92;
        }
        uint64_t v29 = v64;
        goto LABEL_80;
      }
      *(CMTime *)CMTime start = *(CMTime *)(v1 + 16);
      *(_OWORD *)&theArray.start.unsigned int value = *(_OWORD *)(v1 + 40);
      CMTime v55 = *(const void **)(v1 + 64);
      theArray.start.CMTimeEpoch epoch = *(void *)(v1 + 56);
      CMTimeRangeFromTimeToTime(&v62, (CMTime *)start, &theArray.start);
      uint64_t v31 = fcstylesegmenter_setCaptionData((CFMutableArrayRef *)v1, v55);
LABEL_98:
      uint64_t v12 = v31;
      if (!Mutable) {
        goto LABEL_94;
      }
    }
    CFRelease(Mutable);
    goto LABEL_94;
  }

  return FigSignalErrorAt();
}

uint64_t fcstylesegmenter_setCaptionData(CFMutableArrayRef *a1, const void *a2)
{
  *(void *)uint64_t v8 = 0;
  CFGetAllocator(a1);
  uint64_t v4 = figCaptionStyleSegmentCreate(v8);
  uint64_t v5 = *(const void **)v8;
  if (v4)
  {
    uint64_t v6 = v4;
    if (!*(void *)v8) {
      return v6;
    }
    goto LABEL_5;
  }
  uint64_t v6 = figCaptionStyleSegmentSetCaptionData(*(uint64_t *)v8, a2);
  if (!v6) {
    CFArrayAppendValue(a1[9], v5);
  }
  if (v5) {
LABEL_5:
  }
    CFRelease(v5);
  return v6;
}

CFIndex FigCaptionStyleSegmentGeneratorGetSegmentCount(uint64_t a1)
{
  if (a1 && (CFArrayRef v1 = *(const __CFArray **)(a1 + 72)) != 0) {
    return CFArrayGetCount(v1);
  }
  else {
    return 0;
  }
}

const void *FigCaptionStyleSegmentGeneratorGetSegmentAtIndex(uint64_t a1, CFIndex a2)
{
  if (!a1) {
    return 0;
  }
  CFArrayRef v3 = *(const __CFArray **)(a1 + 72);
  if (!v3) {
    return 0;
  }
  if (a2 < 0 || CFArrayGetCount(v3) <= a2)
  {
    FigSignalErrorAt();
    return 0;
  }
  CFArrayRef v5 = *(const __CFArray **)(a1 + 72);

  return CFArrayGetValueAtIndex(v5, a2);
}

uint64_t FigCaptionStyleSegmentGeneratorCreate(uint64_t a1, const void *a2, long long *a3, uint64_t *a4)
{
  if (a4 && a2)
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    MEMORY[0x19970EE10](&FigCaptionStyleSegmentGeneratorGetTypeID_sRegisterFigCaptionStyleSegmentGeneratorOnce, fcstylesegmenter_Register);
    uint64_t Instance = _CFRuntimeCreateInstance();
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFMutableArrayRef v10 = Mutable;
      *(void *)(Instance + 64) = CFRetain(a2);
      CMTimeMake(&v16.start, 0, 1000);
      CMTimeEpoch epoch = v16.start.epoch;
      *(_OWORD *)(Instance + 16) = *(_OWORD *)&v16.start.value;
      *(void *)(Instance + 32) = epoch;
      CMTimeMake(&v16.start, 10000, 1000);
      *(_OWORD *)(Instance + 40) = *(_OWORD *)&v16.start.value;
      *(void *)(Instance + 56) = v16.start.epoch;
      long long v12 = *a3;
      *(void *)(Instance + 32) = *((void *)a3 + 2);
      *(_OWORD *)(Instance + 16) = v12;
      long long v13 = a3[1];
      *(_OWORD *)&v16.start.unsigned int value = *a3;
      *(_OWORD *)&v16.start.CMTimeEpoch epoch = v13;
      *(_OWORD *)&v16.duration.CMTimeScale timescale = a3[2];
      CMTimeRangeGetEnd(&v17, &v16);
      uint64_t v14 = 0;
      *(CMTime *)(Instance + 40) = v17;
      *(void *)(Instance + 72) = v10;
      *a4 = Instance;
    }
    else
    {
      uint64_t v14 = FigSignalErrorAt();
      if (Instance) {
        CFRelease((CFTypeRef)Instance);
      }
    }
    return v14;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void *styleSegment_Init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void styleSegment_Finalize(void *a1)
{
  uint64_t v2 = (const void *)a1[4];
  if (v2) {
    CFRelease(v2);
  }
  CFArrayRef v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[2];
  if (v4)
  {
    CFRelease(v4);
  }
}

CFStringRef styleSegment_CopyFormattingDesc(uint64_t a1)
{
  CFStringRef v2 = *(const __CFString **)(a1 + 24);
  if (!v2)
  {
    CFIndex Length = 0;
    goto LABEL_11;
  }
  uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(const __CFString *))(v4 + 8);
  if (!v6)
  {
    CFStringRef v2 = &stru_1EE53F4B8;
    goto LABEL_10;
  }
  CFIndex Length = v6(v2);
  CFStringRef v2 = (const __CFString *)Length;
  if (Length) {
LABEL_10:
  }
    CFIndex Length = CFStringGetLength(v2);
LABEL_11:
  if (v2) {
    CFAllocatorRef v7 = (__CFString *)v2;
  }
  else {
    CFAllocatorRef v7 = &stru_1EE53F4B8;
  }
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionStyleSegment %p]  CaptionData: %p text:<%@> length:%ld\nattributes = %p", a1, *(void *)(a1 + 24), v7, Length, *(void *)(a1 + 32));
}

double fcstylesegmenter_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void fcstylesegmenter_Finalize(uint64_t a1)
{
  CFStringRef v2 = *(const void **)(a1 + 72);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    CFRelease(v3);
  }
}

__CFString *fcstylesegmenter_CopyDebugDesc(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"[FigCaptionStyleSegmentGenerator(%p) captionData:%p segments:%p]", a1, *(void *)(a1 + 64), *(void *)(a1 + 72));
  return Mutable;
}

void fcstylesegmenter_buildTimeToAttributesMap(const void *a1, uint64_t *a2)
{
  CFTypeRef v17 = 0;
  CFTypeRef cf = 0;
  if (*((_DWORD *)a2 + 16)) {
    goto LABEL_24;
  }
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  CFAllocatorRef v7 = *(uint64_t (**)(uint64_t, void, const void *, void, CFTypeRef *, void))(v6 + 24);
  if (!v7)
  {
    int v8 = -12782;
    goto LABEL_21;
  }
  int v8 = v7(v4, 0, a1, *MEMORY[0x1E4F1CF80], &cf, 0);
  if (v8)
  {
LABEL_21:
    *((_DWORD *)a2 + 16) = v8;
    goto LABEL_22;
  }
  if (!cf)
  {
LABEL_30:
    int v8 = FigSignalErrorAt();
    goto LABEL_31;
  }
  CFTypeID v9 = CFGetTypeID(cf);
  if (v9 != FigCaptionDynamicStyleGetTypeID())
  {
    if (cf)
    {
      AttributeDictionaryForAnimationTime = (__CFDictionary *)insertOrGetAttributeDictionaryForAnimationTime((const __CFDictionary *)a2[7]);
      if (AttributeDictionaryForAnimationTime)
      {
        CFDictionarySetValue(AttributeDictionaryForAnimationTime, a1, cf);
        goto LABEL_22;
      }
    }
    goto LABEL_30;
  }
  KeyFrameCFIndex Count = FigCaptionDynamicStyleGetKeyFrameCount();
  if (KeyFrameCount < 1) {
    goto LABEL_22;
  }
  uint64_t v11 = KeyFrameCount;
  uint64_t v12 = 0;
  while (1)
  {
    uint64_t v16 = 0;
    if (v17)
    {
      CFRelease(v17);
      CFTypeRef v17 = 0;
    }
    int v8 = FigCaptionDynamicStyleCopyKeyFrameValueAtIndex();
    if (v8) {
      break;
    }
    if ((*((_DWORD *)a2 + 11) & 0x1D) == 1)
    {
      CMTime v15 = *(CMTime *)(a2 + 4);
      CMTimeGetSeconds(&v15);
    }
    long long v13 = (__CFDictionary *)insertOrGetAttributeDictionaryForAnimationTime((const __CFDictionary *)a2[7]);
    if (!v13 || !v17) {
      goto LABEL_30;
    }
    CFDictionarySetValue(v13, a1, v17);
    if (v11 == ++v12) {
      goto LABEL_22;
    }
  }
LABEL_31:
  if (v8) {
    goto LABEL_21;
  }
LABEL_22:
  if (v17) {
    CFRelease(v17);
  }
LABEL_24:
  if (cf) {
    CFRelease(cf);
  }
}

CFComparisonResult fcstylesegmenter_compareCFNumber(uint64_t a1, CFNumberRef *a2, CFNumberRef *a3)
{
  return CFNumberCompare(*a2, *a3, 0);
}

uint64_t figCaptionStyleSegmentCreate(void *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  MEMORY[0x19970EE10](&FigCaptionStyleSegmentGetTypeID_sRegisterFigCaptionStyleSegmentOnce, styleSegment_Register);
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v4 = (void *)Instance;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      v4[4] = Mutable;
      *a1 = v4;
      return 0;
    }
    else
    {
      uint64_t v7 = FigSignalErrorAt();
      CFRelease(v4);
      return v7;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void fcstylesegmenter_addAttribute(void *key, void *value, void *cf)
{
  if (cf)
  {
    CFMutableDictionaryRef Mutable = (__CFDictionary *)cf[4];
    if (Mutable)
    {
      if (!value)
      {
        CFDictionaryRemoveValue(Mutable, key);
        return;
      }
    }
    else
    {
      if (!value) {
        return;
      }
      CFAllocatorRef v7 = CFGetAllocator(cf);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFTypeRef cf[4] = Mutable;
    }
    CFDictionarySetValue(Mutable, key, value);
  }
  else
  {
    FigSignalErrorAt();
  }
}

uint64_t figCaptionStyleSegmentSetCaptionData(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    uint64_t v3 = *(const void **)(a1 + 24);
    *(void *)(a1 + 24) = cf;
    if (cf) {
      CFRetain(cf);
    }
    if (v3) {
      CFRelease(v3);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigTTMLTreeGetTypeID()
{
  return sFigTTMLTreeID;
}

uint64_t figTTMLTreeRegisterFigTTMLTree()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigTTMLTreeID = result;
  return result;
}

uint64_t FigTTMLTreeCreate(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t valuePtr = 0;
  CFNumberRef number = 0;
  CFTypeRef cf = 0;
  uint64_t v23 = 0;
  uint64_t v5 = FigTTMLGetLibXMLAccess();
  if (!v5) {
    goto LABEL_28;
  }
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  CFTypeID v9 = *(uint64_t (**)(uint64_t, void, void, CFNumberRef *))(v8 + 48);
  if (!v9)
  {
    uint64_t v12 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 4294954514;
    goto LABEL_21;
  }
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v11 = v9(CMBaseObject, *MEMORY[0x1E4F1EC50], *MEMORY[0x1E4F1CF80], &number);
  if (v11) {
    goto LABEL_29;
  }
  CFNumberGetValue(number, kCFNumberSInt64Type, &valuePtr);
  if (valuePtr >= 0x7FFFFFFF)
  {
LABEL_28:
    uint64_t v11 = FigSignalErrorAt();
LABEL_29:
    uint64_t v17 = v11;
    uint64_t v12 = 0;
    goto LABEL_20;
  }
  uint64_t v12 = malloc_type_malloc(valuePtr + 1, 0xD511040BuLL);
  if (!v12
    || ((unint64_t v13 = valuePtr, (v14 = *(void *)(CMBaseObjectGetVTable() + 16)) == 0) ? (v15 = 0) : (v15 = v14),
        (CFIndex v18 = *(unsigned int (**)(uint64_t, unint64_t, void, unsigned char *, uint64_t *))(v15 + 8)) == 0
     || v18(a2, v13, 0, v12, &v23)
     || v23 != valuePtr))
  {
    uint64_t v17 = FigSignalErrorAt();
LABEL_20:
    uint64_t v16 = 0;
    goto LABEL_21;
  }
  v12[v23] = 0;
  uint64_t v16 = (*(uint64_t (**)(unsigned char *, void, void, void, void))(v5 + 128))(v12, valuePtr, 0, 0, 0);
  FigTTMLMoveCurrentNodeTo(v16, 1);
  uint64_t v19 = FigTTMLRootCreate(v10, v16, &cf);
  if (!v19)
  {
    MEMORY[0x19970EE10](&FigTTMLTreeGetTypeID_sRegisterFigTTMLTreeOnce, figTTMLTreeRegisterFigTTMLTree);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v17 = 0;
      *(void *)(Instance + 16) = cf;
      CFTypeRef cf = 0;
      *a3 = Instance;
      goto LABEL_21;
    }
    uint64_t v19 = FigSignalErrorAt();
  }
  uint64_t v17 = v19;
LABEL_21:
  free(v12);
  if (number) {
    CFRelease(number);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v16) {
    (*(void (**)(uint64_t))(v5 + 64))(v16);
  }
  return v17;
}

uint64_t FigTTMLTreeCreateWithCString(uint64_t a1, char *__s, uint64_t *a3)
{
  size_t v6 = strlen(__s);
  uint64_t result = FigCreateBlockBufferCopyingMemoryBlock();
  if (!result)
  {
    uint64_t result = CMBlockBufferReplaceDataBytes(__s, 0, 0, v6);
    if (!result)
    {
      uint64_t result = CMByteStreamCreateForBlockBuffer();
      if (!result) {
        return FigTTMLTreeCreate(a1, 0, a3);
      }
    }
  }
  return result;
}

uint64_t FigTTMLTreeGetParameters(uint64_t a1, void *a2)
{
  return FigTTMLRootGetParameters(*(void *)(a1 + 16), a2);
}

uint64_t FigTTMLTreeCopyFeatureAndExtensionSet(uint64_t a1, unsigned int a2, CFMutableSetRef *a3)
{
  HeadNode = (const void *)FigTTMLRootGetHeadNode();
  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
  v9[1] = Mutable;
  v9[0] = a2;
  if (a3)
  {
    uint64_t v7 = FigTTMLTreeWalkFromNode(HeadNode, 0, (uint64_t (*)(const void *, uint64_t))figTTMLTreeBuildFeatureAndExtensionSet, (uint64_t)v9);
    if (!v7)
    {
      *a3 = Mutable;
      return v7;
    }
  }
  else
  {
    uint64_t v7 = FigSignalErrorAt();
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v7;
}

uint64_t FigTTMLTreeWalkFromNode(const void *a1, uint64_t (*a2)(const void *, uint64_t), uint64_t (*a3)(const void *, uint64_t), uint64_t a4)
{
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFTypeID v9 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v11 = CFArrayCreateMutable(v8, 0, v9);
  CFArrayRef theArray = 0;
  CFArrayAppendValue(Mutable, a1);
  uint64_t v12 = (const void *)*MEMORY[0x1E4F1CFC8];
  CFArrayAppendValue(v11, (const void *)*MEMORY[0x1E4F1CFC8]);
  if (CFArrayGetCount(Mutable))
  {
    unint64_t v13 = (const void *)*MEMORY[0x1E4F1CFD0];
    do
    {
      CFIndex Count = CFArrayGetCount(Mutable);
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, Count - 1);
      CFIndex v16 = CFArrayGetCount(v11);
      CFBooleanRef v17 = (const __CFBoolean *)CFArrayGetValueAtIndex(v11, v16 - 1);
      if (CFBooleanGetValue(v17))
      {
        if (a3)
        {
          uint64_t v18 = a3(ValueAtIndex, a4);
          if (v18)
          {
LABEL_24:
            uint64_t v23 = v18;
            if (!Mutable) {
              goto LABEL_19;
            }
LABEL_18:
            CFRelease(Mutable);
            goto LABEL_19;
          }
        }
        CFIndex v19 = CFArrayGetCount(Mutable);
        CFArrayRemoveValueAtIndex(Mutable, v19 - 1);
        CFIndex v20 = CFArrayGetCount(v11);
        CFArrayRemoveValueAtIndex(v11, v20 - 1);
      }
      else
      {
        CFIndex v21 = CFArrayGetCount(v11);
        CFArraySetValueAtIndex(v11, v21 - 1, v13);
        if (a2)
        {
          uint64_t v22 = a2(ValueAtIndex, a4);
          if (v22 == -16573) {
            continue;
          }
          uint64_t v23 = v22;
          if (v22) {
            goto LABEL_17;
          }
        }
        uint64_t v18 = FigTTMLNodeCopyChildNodeArray((uint64_t)ValueAtIndex, (uint64_t)&theArray);
        if (v18) {
          goto LABEL_24;
        }
        CFIndex v24 = CFArrayGetCount(theArray);
        CFIndex v25 = v24 - 1;
        if (v24 >= 1)
        {
          do
          {
            CFIndex v26 = CFArrayGetValueAtIndex(theArray, v25);
            CFArrayAppendValue(Mutable, v26);
            CFArrayAppendValue(v11, v12);
            --v25;
          }
          while (v25 != -1);
        }
        if (theArray)
        {
          CFRelease(theArray);
          CFArrayRef theArray = 0;
        }
      }
    }
    while (CFArrayGetCount(Mutable));
  }
  uint64_t v23 = 0;
LABEL_17:
  if (Mutable) {
    goto LABEL_18;
  }
LABEL_19:
  if (v11) {
    CFRelease(v11);
  }
  if (theArray) {
    CFRelease(theArray);
  }
  return v23;
}

uint64_t figTTMLTreeBuildFeatureAndExtensionSet(uint64_t a1, uint64_t a2)
{
  int v20 = 0;
  unsigned int value = &stru_1EE53F4B8;
  CFDictionaryRef theDict = 0;
  CFTypeRef cf1 = @"required";
  uint64_t NodeType = FigTTMLNodeGetNodeType(a1, (uint64_t)&v20);
  if (!NodeType)
  {
    if ((v20 & 0xFFFFFFFE) != 0x12)
    {
LABEL_26:
      uint64_t v14 = 0;
      goto LABEL_27;
    }
    uint64_t ParentNode = FigTTMLNodeGetParentNode();
    uint64_t NodeType = FigTTMLNodeCopyAttributes(ParentNode, &theDict);
    if (!NodeType)
    {
      if (theDict)
      {
        CFDictionaryGetValueIfPresent(theDict, @"http://www.w3.org/XML/1998/namespace base", (const void **)&value);
        if (theDict)
        {
          CFRelease(theDict);
          CFDictionaryRef theDict = 0;
        }
      }
      uint64_t NodeType = FigTTMLNodeCopyAttributes(a1, &theDict);
      if (!NodeType)
      {
        size_t v6 = @"required";
        if (theDict)
        {
          CFDictionaryGetValueIfPresent(theDict, @"value", &cf1);
          size_t v6 = (__CFString *)cf1;
        }
        if (CFEqual(v6, @"optional"))
        {
          int v7 = 1;
        }
        else if (CFEqual(cf1, @"required"))
        {
          int v7 = 2;
        }
        else
        {
          int v7 = 4 * (CFEqual(cf1, @"use") != 0);
        }
        if ((*(_DWORD *)a2 & v7) == 0) {
          goto LABEL_26;
        }
        CFStringRef URLString = 0;
        uint64_t NodeType = FigTTMLNodeCopyNodeValue(a1, &URLString);
        if (!NodeType)
        {
          if (URLString)
          {
            CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFURLRef v9 = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)value, 0);
            CFURLRef v10 = CFURLCreateWithString(v8, URLString, v9);
            CFURLRef v11 = CFURLCopyAbsoluteURL(v10);
            uint64_t v12 = *(__CFSet **)(a2 + 8);
            CFStringRef v13 = CFURLGetString(v11);
            CFSetSetValue(v12, v13);
            if (URLString) {
              CFRelease(URLString);
            }
            if (v11) {
              CFRelease(v11);
            }
            if (v10) {
              CFRelease(v10);
            }
            if (v9) {
              CFRelease(v9);
            }
            goto LABEL_26;
          }
          uint64_t NodeType = FigSignalErrorAt();
        }
      }
    }
  }
  uint64_t v14 = NodeType;
LABEL_27:
  if (theDict) {
    CFRelease(theDict);
  }
  return v14;
}

uint64_t FigTTMLTreeCopySliceTimeRangeArray(uint64_t a1, __CFArray **a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v5 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFMutableArrayRef v7 = CFArrayCreateMutable(v4, 0, v5);
  CMTime v29 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  if (!a2)
  {
    uint64_t v8 = FigSignalErrorAt();
    goto LABEL_19;
  }
  uint64_t v8 = FigTTMLTreeWalkFromNode(*(const void **)(a1 + 16), 0, (uint64_t (*)(const void *, uint64_t))figTTMLTreeAppendSliceTimeToArray, (uint64_t)Mutable);
  if (v8)
  {
LABEL_19:
    uint64_t v21 = v8;
    goto LABEL_20;
  }
  uint64_t v23 = a2;
  CFArrayRef theArray = v7;
  v33.length = CFArrayGetCount(Mutable);
  v33.locatioCFIndex n = 0;
  CFArraySortValues(Mutable, v33, (CFComparatorFunction)figTTMLTreeCompareSliceTime, 0);
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count < 1)
  {
LABEL_13:
    uint64_t v21 = 0;
    *uint64_t v23 = theArray;
    goto LABEL_14;
  }
  CFIndex v10 = Count;
  CFIndex v11 = 0;
  uint64_t v12 = (CMTime *)MEMORY[0x1E4F1FA48];
  while (1)
  {
    memset(&v28, 0, sizeof(v28));
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v11);
    CMTimeMakeFromDictionary(&v28, ValueAtIndex);
    lhs.CMTime start = v28;
    CMTime rhs = v29;
    CMTimeSubtract(&duration, &lhs.start, &rhs);
    CMTime rhs = v29;
    CMTimeRangeMake(&lhs, &rhs, &duration);
    CMTimeValue value = lhs.start.value;
    CMTimeFlags flags = lhs.start.flags;
    CMTimeScale timescale = lhs.start.timescale;
    if ((lhs.start.flags & 1) == 0) {
      goto LABEL_12;
    }
    CMTimeFlags v15 = lhs.duration.flags;
    if ((lhs.duration.flags & 1) == 0) {
      goto LABEL_12;
    }
    if (lhs.duration.epoch) {
      goto LABEL_12;
    }
    CMTimeValue v16 = lhs.duration.value;
    if (lhs.duration.value < 0) {
      goto LABEL_12;
    }
    CMTimeEpoch epoch = lhs.start.epoch;
    CMTimeScale v18 = lhs.duration.timescale;
    lhs.start.CMTimeValue value = lhs.duration.value;
    lhs.start.CMTimeScale timescale = lhs.duration.timescale;
    lhs.start.CMTimeFlags flags = lhs.duration.flags;
    lhs.start.CMTimeEpoch epoch = 0;
    CMTime rhs = *v12;
    if (!CMTimeCompare(&lhs.start, &rhs)) {
      goto LABEL_12;
    }
    lhs.start.CMTimeValue value = value;
    lhs.start.CMTimeScale timescale = timescale;
    lhs.start.CMTimeFlags flags = flags;
    lhs.start.CMTimeEpoch epoch = epoch;
    lhs.duration.CMTimeValue value = v16;
    lhs.duration.CMTimeScale timescale = v18;
    lhs.duration.CMTimeFlags flags = v15;
    lhs.duration.CMTimeEpoch epoch = 0;
    CFDictionaryRef v19 = CMTimeRangeCopyAsDictionary(&lhs, v4);
    if (!v19) {
      break;
    }
    CFDictionaryRef v20 = v19;
    CFArrayAppendValue(theArray, v19);
    CFRelease(v20);
LABEL_12:
    CMTime v29 = v28;
    if (v10 == ++v11) {
      goto LABEL_13;
    }
  }
  uint64_t v21 = FigSignalErrorAt();
  CFMutableArrayRef v7 = theArray;
LABEL_20:
  if (v7) {
    CFRelease(v7);
  }
LABEL_14:
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v21;
}

uint64_t figTTMLTreeAppendSliceTimeToArray(uint64_t a1)
{
  memset(&v11, 0, sizeof(v11));
  int v10 = 0;
  uint64_t result = FigTTMLNodeGetNodeType(a1, (uint64_t)&v10);
  if (!result)
  {
    if ((v10 & 0xFFFFFFFB) != 0xA) {
      return 0;
    }
    uint64_t result = FigTTMLNodeGetActiveTimeRange(a1, (uint64_t)&v11);
    if (result) {
      return result;
    }
    if ((v11.start.flags & 1) == 0) {
      return 0;
    }
    uint64_t result = 0;
    if ((v11.duration.flags & 1) != 0 && !v11.duration.epoch && (v11.duration.value & 0x8000000000000000) == 0)
    {
      if (v10 == 10)
      {
        *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&v11.start.value;
        time1.start.CMTimeEpoch epoch = v11.start.epoch;
        CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
        if (CMTimeCompare(&time1.start, &time2))
        {
          *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&v11.start.value;
          time1.start.CMTimeEpoch epoch = v11.start.epoch;
          FigCFArrayAppendCMTime();
        }
        CMTimeRange time1 = v11;
        CMTimeRangeGetEnd(&v8, &time1);
        if ((v8.flags & 0x1D) != 1) {
          return 0;
        }
        CMTimeRange time1 = v11;
        uint64_t v3 = (CMTime *)&v6;
      }
      else
      {
        if ((v11.start.flags & 0x1D) == 1)
        {
          *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&v11.start.value;
          time1.start.CMTimeEpoch epoch = v11.start.epoch;
          FigCFArrayAppendCMTime();
        }
        CMTimeRange time1 = v11;
        CMTimeRangeGetEnd(&v5, &time1);
        if ((v5.flags & 0x1D) != 1) {
          return 0;
        }
        CMTimeRange time1 = v11;
        uint64_t v3 = &v4;
      }
      CMTimeRangeGetEnd(v3, &time1);
      FigCFArrayAppendCMTime();
      return 0;
    }
  }
  return result;
}

uint64_t figTTMLTreeCompareSliceTime(const __CFDictionary *a1, const __CFDictionary *a2)
{
  memset(&v7, 0, sizeof(v7));
  CMTimeMakeFromDictionary(&v7, a1);
  memset(&v6, 0, sizeof(v6));
  CMTimeMakeFromDictionary(&v6, a2);
  CMTime time1 = v7;
  CMTime v4 = v6;
  return CMTimeCompare(&time1, &v4);
}

uint64_t FigTTMLTreeCopyActiveRegionArray(uint64_t a1, long long *a2, CFMutableArrayRef *a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  long long v9 = *a2;
  uint64_t v10 = *((void *)a2 + 2);
  CFMutableArrayRef v11 = Mutable;
  uint64_t v7 = FigTTMLTreeWalkFromNode(*(const void **)(a1 + 16), figTTMLTreeAppendActiveRegionsForTime, 0, (uint64_t)&v9);
  if (v7)
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
    *a3 = Mutable;
  }
  return v7;
}

uint64_t figTTMLTreeAppendActiveRegionsForTime(const void *a1, uint64_t a2)
{
  int v10 = 0;
  uint64_t NodeType = FigTTMLNodeGetNodeType((uint64_t)a1, (uint64_t)&v10);
  if (NodeType) {
    return NodeType;
  }
  if (v10 == 2) {
    return 4294950723;
  }
  if (v10 != 10) {
    return 0;
  }
  memset(&v9, 0, sizeof(v9));
  uint64_t ActiveTimeRange = FigTTMLNodeGetActiveTimeRange((uint64_t)a1, (uint64_t)&v9);
  if (!ActiveTimeRange)
  {
    CMTimeRange range = v9;
    CMTime v7 = *(CMTime *)a2;
    if (CMTimeRangeContainsTime(&range, &v7)) {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), a1);
    }
  }
  return ActiveTimeRange;
}

uint64_t FigTTMLTreeGetRootNode(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t FigTTMLTreeGetBodyNode()
{
  return FigTTMLRootGetBodyNode();
}

const void *FigTTMLTreeGetNodeByID(uint64_t a1, void *key)
{
  CFMutableDictionaryRef v3 = *(CFMutableDictionaryRef *)(a1 + 24);
  if (!v3)
  {
    CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a1);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFMutableDictionaryRef v3 = Mutable;
      if (!FigTTMLTreeWalkFromNode(*(const void **)(a1 + 16), (uint64_t (*)(const void *, uint64_t))figTTMLTreeBuildIDToNodeDictionary, 0, (uint64_t)Mutable))
      {
        *(void *)(a1 + 24) = v3;
        goto LABEL_5;
      }
      CFRelease(v3);
    }
    else
    {
      FigSignalErrorAt();
    }
    return 0;
  }
LABEL_5:

  return CFDictionaryGetValue(v3, key);
}

uint64_t figTTMLTreeBuildIDToNodeDictionary(const void *a1, __CFDictionary *a2)
{
  XMLID = FigTTMLNodeGetXMLID();
  if (XMLID) {
    CFDictionaryAddValue(a2, XMLID, a1);
  }
  return 0;
}

uint64_t FigTTMLTreeAppendActiveNodesToArray(uint64_t *cf, uint64_t a2, __CFArray *a3)
{
  if (a3)
  {
    CMTime v8 = cf + 4;
    uint64_t v7 = cf[4];
    if (!v7)
    {
      CFAllocatorRef v9 = CFGetAllocator(cf);
      uint64_t result = FigTTMLIntervalTreeCreate((uint64_t)v9, (uint64_t)cf, v8);
      if (result) {
        return result;
      }
      uint64_t v7 = *v8;
    }
    long long v11 = *(_OWORD *)a2;
    uint64_t v12 = *(void *)(a2 + 16);
    return FigTTMLIntervalTreeAppendActiveNodesToArray(v7, &v11, a3);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void *figTTMLTree_Init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void figTTMLTree_Finalize(void *a1)
{
  uint64_t v2 = (const void *)a1[4];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  CMTime v4 = (const void *)a1[2];
  if (v4)
  {
    CFRelease(v4);
  }
}

CFStringRef figTTMLTree_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigTTMLTree %p]", a1);
}

CFStringRef figTTMLTree_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigTTMLTree %p]", a1);
}

uint64_t FigCaptionTimelineGeneratorGetTypeID()
{
  return sFigCaptionTimelineGeneratorID;
}

uint64_t fctg_registerFigCaptionTimelineGenerator()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionTimelineGeneratorID = result;
  return result;
}

uint64_t FigCaptionTimelineGeneratorCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (a2
    && a4
    && (MEMORY[0x19970EE10](&FigCaptionTimelineGeneratorGetTypeID_sRegisterFigCaptionTimelineGeneratorOnce, fctg_registerFigCaptionTimelineGenerator), (uint64_t Instance = _CFRuntimeCreateInstance()) != 0))
  {
    *(void *)(Instance + 24) = a2;
    *(void *)(Instance + 32) = a3;
    *a4 = Instance;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigCaptionTimelineGeneratorAddSampleBuffer(uint64_t a1, opaqueCMSampleBuffer *a2)
{
  if (a1 && a2)
  {
    if (FigSampleBufferGetCaptionGroup())
    {
      CFArrayRef v4 = *(const __CFArray **)(a1 + 16);
      if (v4)
      {
        CFIndex Count = CFArrayGetCount(v4);
        BOOL v24 = Count > 0;
        if (Count < 1)
        {
          BOOL v24 = 0;
        }
        else
        {
          for (CFIndex i = 0; i != Count; ++i)
            *((unsigned char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), i) + 129) = 0;
        }
      }
      else
      {
        BOOL v24 = 0;
        CFIndex Count = 0;
      }
      memset(&v44, 0, sizeof(v44));
      CMSampleBufferGetOutputPresentationTimeStamp(&start, a2);
      CMSampleBufferGetOutputDuration(&duration, a2);
      CMTimeRangeMake(&v44, &start, &duration);
      SliceCFIndex Count = FigCaptionGroupGetSliceCount();
      if (SliceCount)
      {
        uint64_t v7 = 0;
        CFStringRef v22 = (const __CFString *)*MEMORY[0x1E4F1F308];
        CFStringRef v21 = (const __CFString *)*MEMORY[0x1E4F1F300];
        do
        {
          CaptionData = (const void *)FigCaptionGroupGetCaptionData();
          memset(&v41, 0, sizeof(v41));
          fctg_getAttachmentTime(a2, v22, &v41);
          memset(&v40, 0, sizeof(v40));
          fctg_getAttachmentTime(a2, v21, &v40);
          memset(&v39, 0, sizeof(v39));
          CMSampleBufferGetPresentationTimeStamp(&lhs, a2);
          rhs.CMTime start = v41;
          CMTimeAdd(&v38, &lhs, &rhs.start);
          CMSampleBufferGetDuration(&v35, a2);
          rhs.CMTime start = v41;
          v29[0] = v40;
          CMTimeAdd(&v34, &rhs.start, v29);
          CMTimeSubtract(&v36, &v35, &v34);
          CMTimeRangeMake(&v39, &v38, &v36);
          memset(&v33, 0, sizeof(v33));
          FigCaptionGroupGetDurationBeforeSlice();
          rhs.CMTime start = v41;
          CMTimeAdd(&v33, &v32, &rhs.start);
          memset(&v31, 0, sizeof(v31));
          FigCaptionGroupGetDurationAfterSlice();
          rhs.CMTime start = v40;
          CMTimeAdd(&v31, &v30, &rhs.start);
          if (v24)
          {
            CFIndex v9 = 0;
            while (1)
            {
              CFDictionaryRef ValueAtIndex = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v9);
              *(_OWORD *)&v29[0].CMTimeValue value = *(_OWORD *)&v39.start.value;
              *(_OWORD *)&v29[0].CMTimeEpoch epoch = *(_OWORD *)&v39.start.epoch;
              *(_OWORD *)&v29[1].CMTimeScale timescale = *(_OWORD *)&v39.duration.timescale;
              CMTime v28 = v33;
              CMTime v27 = v31;
              CMTime v26 = v44.start;
              memset(&v51, 0, sizeof(v51));
              *(_OWORD *)&rhs.start.CMTimeValue value = *(_OWORD *)(ValueAtIndex + 56);
              rhs.start.CMTimeEpoch epoch = *((void *)ValueAtIndex + 9);
              CMTime v50 = *(CMTime *)(ValueAtIndex + 104);
              CMTimeAdd(&v51, &rhs.start, &v50);
              memset(&v50, 0, sizeof(v50));
              long long v11 = *(_OWORD *)(ValueAtIndex + 8);
              long long v12 = *(_OWORD *)(ValueAtIndex + 40);
              *(_OWORD *)&rhs.start.CMTimeEpoch epoch = *(_OWORD *)(ValueAtIndex + 24);
              *(_OWORD *)&rhs.duration.CMTimeScale timescale = v12;
              *(_OWORD *)&rhs.start.CMTimeValue value = v11;
              CMTimeRangeGetEnd(&v50, &rhs);
              if (!ValueAtIndex[128])
              {
                rhs.CMTime start = v51;
                CMTime time2 = v29[0];
                if (!CMTimeCompare(&rhs.start, &time2))
                {
                  rhs.CMTime start = v50;
                  CMTime time2 = v26;
                  if (!CMTimeCompare(&rhs.start, &time2))
                  {
                    memset(&v48, 0, sizeof(v48));
                    rhs.CMTime start = v29[0];
                    CMTime time2 = v28;
                    CMTimeSubtract(&v48, &rhs.start, &time2);
                    *(_OWORD *)&rhs.start.CMTimeValue value = *(_OWORD *)(ValueAtIndex + 56);
                    rhs.start.CMTimeEpoch epoch = *((void *)ValueAtIndex + 9);
                    CMTime time2 = v48;
                    if (!CMTimeCompare(&rhs.start, &time2))
                    {
                      memset(&v46, 0, sizeof(v46));
                      rhs.CMTime start = v28;
                      CMTime time2 = v29[1];
                      CMTimeAdd(&v45, &rhs.start, &time2);
                      rhs.CMTime start = v27;
                      CMTimeAdd(&v46, &v45, &rhs.start);
                      *(_OWORD *)&rhs.start.CMTimeValue value = *((_OWORD *)ValueAtIndex + 5);
                      rhs.start.CMTimeEpoch epoch = *((void *)ValueAtIndex + 12);
                      CMTime time2 = v46;
                      if (!CMTimeCompare(&rhs.start, &time2))
                      {
                        if (CFEqual(*(CFTypeRef *)ValueAtIndex, CaptionData)) {
                          break;
                        }
                      }
                    }
                  }
                }
              }
              if (Count == ++v9) {
                goto LABEL_22;
              }
            }
            CMTime v51 = v44.duration;
            CMTime v50 = v39.duration;
            v29[0] = *(CMTime *)(ValueAtIndex + 32);
            CMTimeAdd(&rhs.start, v29, &v51);
            *((_OWORD *)ValueAtIndex + 2) = *(_OWORD *)&rhs.start.value;
            *((void *)ValueAtIndex + 6) = rhs.start.epoch;
            v29[0] = *(CMTime *)(ValueAtIndex + 104);
            CMTime v51 = v50;
            CMTimeAdd(&rhs.start, v29, &v51);
            *(_OWORD *)(ValueAtIndex + 104) = *(_OWORD *)&rhs.start.value;
            *((void *)ValueAtIndex + 15) = rhs.start.epoch;
            ValueAtIndex[129] = 1;
          }
          else
          {
LABEL_22:
            CMTimeRange rhs = v44;
            *(_OWORD *)&v29[0].CMTimeValue value = *(_OWORD *)&v39.start.value;
            *(_OWORD *)&v29[0].CMTimeEpoch epoch = *(_OWORD *)&v39.start.epoch;
            *(_OWORD *)&v29[1].CMTimeScale timescale = *(_OWORD *)&v39.duration.timescale;
            CMTime v46 = v33;
            CMTime v45 = v31;
            CFStringRef v13 = (char *)malloc_type_calloc(1uLL, 0x90uLL, 0x1060040E0E536C3uLL);
            if (!v13)
            {
              FigSignalErrorAt();
              goto LABEL_40;
            }
            uint64_t v14 = v13;
            if (CaptionData) {
              CFTypeRef v15 = CFRetain(CaptionData);
            }
            else {
              CFTypeRef v15 = 0;
            }
            long long v16 = *(_OWORD *)&rhs.start.epoch;
            *(_OWORD *)(v14 + 8) = *(_OWORD *)&rhs.start.value;
            *(void *)uint64_t v14 = v15;
            *(_OWORD *)(v14 + 24) = v16;
            *(_OWORD *)(v14 + 40) = *(_OWORD *)&rhs.duration.timescale;
            CMTime v50 = v29[0];
            CMTime time2 = v46;
            CMTimeSubtract(&v51, &v50, &time2);
            *(CMTime *)(v14 + 56) = v51;
            CMTime v51 = v46;
            CMTime v50 = v29[1];
            CMTimeAdd(&v48, &v51, &v50);
            CMTime v50 = v45;
            CMTimeAdd(&v51, &v48, &v50);
            *(CMTime *)(v14 + 80) = v51;
            CMTime v50 = v29[1];
            CMTime time2 = v46;
            CMTimeAdd(&v51, &v50, &time2);
            *(CMTime *)(v14 + 104) = v51;
            v14[128] = 0;
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), v14);
          }
          ++v7;
        }
        while (v7 != SliceCount);
      }
      if (v24)
      {
        CFIndex v17 = 0;
        do
        {
          CMTimeScale v18 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v17);
          if (!v18[129]) {
            v18[128] = 1;
          }
          ++v17;
        }
        while (Count != v17);
      }
      memset(&v25, 0, sizeof(v25));
      CMTimeRange rhs = v44;
      CMTimeRangeGetEnd(&v25, &rhs);
      do
        rhs.CMTime start = v25;
      while ((fctg_generateAndOutputCaptions(a1, (uint64_t)&rhs) & 1) != 0);
    }
    uint64_t v19 = 0;
  }
  else
  {
LABEL_40:
    uint64_t v19 = FigSignalErrorAt();
  }
  fctg_freeBuddingCaption(0);
  return v19;
}

CMTime *fctg_getAttachmentTime@<X0>(const void *a1@<X0>, const __CFString *a2@<X1>, CMTime *a3@<X8>)
{
  uint64_t v4 = MEMORY[0x1E4F1FA48];
  *(_OWORD *)&a3->CMTimeValue value = *MEMORY[0x1E4F1FA48];
  a3->CMTimeEpoch epoch = *(void *)(v4 + 16);
  uint64_t result = (CMTime *)CMGetAttachment(a1, a2, 0);
  if (result)
  {
    CFDictionaryRef v6 = (const __CFDictionary *)result;
    CFTypeID v7 = CFGetTypeID(result);
    uint64_t result = (CMTime *)CFDictionaryGetTypeID();
    if ((CMTime *)v7 == result)
    {
      return CMTimeMakeFromDictionary(a3, v6);
    }
  }
  return result;
}

uint64_t fctg_generateAndOutputCaptions(uint64_t a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
  CFTypeRef v51 = 0;
  memset(&v50, 0, sizeof(v50));
  CFAllocatorRef v5 = (_OWORD *)(a1 + 40);
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)a2;
  lhs.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
  *(_OWORD *)&rhs.start.CMTimeValue value = *(_OWORD *)(a1 + 40);
  rhs.start.CMTimeEpoch epoch = *(void *)(a1 + 56);
  CMTimeSubtract(&duration, &lhs.start, &rhs.start);
  *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)(a1 + 40);
  lhs.start.CMTimeEpoch epoch = *(void *)(a1 + 56);
  CMTimeRangeMake(&v50, &lhs.start, &duration);
  if (Count)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFDictionaryRef ValueAtIndex = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), i);
      CMTimeRange lhs = *(CMTimeRange *)(ValueAtIndex + 8);
      *(_OWORD *)&rhs.start.CMTimeValue value = *v5;
      rhs.start.CMTimeEpoch epoch = *(void *)(a1 + 56);
      long long v8 = *(_OWORD *)(ValueAtIndex + 8);
      time2.CMTimeEpoch epoch = *((void *)ValueAtIndex + 3);
      *(_OWORD *)&time2.CMTimeValue value = v8;
      if (CMTimeCompare(&rhs.start, &time2))
      {
        CMTimeRange rhs = v50;
        CMTime time2 = lhs.start;
        if (CMTimeRangeContainsTime(&rhs, &time2))
        {
          CMTime time2 = lhs.start;
          *(_OWORD *)&v46.CMTimeValue value = *v5;
          v46.CMTimeEpoch epoch = *(void *)(a1 + 56);
          CMTimeSubtract(&rhs.start, &time2, &v46);
          v50.duratioCFIndex n = rhs.start;
        }
      }
    }
    for (CFIndex j = 0; j != Count; ++j)
    {
      int v10 = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), j);
      if (v10[128])
      {
        CMTimeRange lhs = *(CMTimeRange *)(v10 + 8);
        *(_OWORD *)&rhs.start.CMTimeValue value = *(_OWORD *)&lhs.start.value;
        *(_OWORD *)&rhs.start.CMTimeEpoch epoch = *(_OWORD *)&lhs.start.epoch;
        long long v11 = *v5;
        *(_OWORD *)&rhs.duration.CMTimeScale timescale = *(_OWORD *)&lhs.duration.timescale;
        *(_OWORD *)&time2.CMTimeValue value = v11;
        time2.CMTimeEpoch epoch = *(void *)(a1 + 56);
        if (CMTimeRangeContainsTime(&rhs, &time2))
        {
          CMTimeRange rhs = lhs;
          CMTimeRangeGetEnd(&time, &rhs);
          CMTimeRange rhs = v50;
          if (CMTimeRangeContainsTime(&rhs, &time))
          {
            CMTimeRange rhs = lhs;
            CMTimeRangeGetEnd(&v44, &rhs);
            CMTime time2 = v50.start;
            CMTimeSubtract(&rhs.start, &v44, &time2);
            v50.duratioCFIndex n = rhs.start;
          }
        }
      }
    }
    CFIndex v12 = 0;
    CFStringRef v13 = (CMTime *)MEMORY[0x1E4F1FA48];
    do
    {
      uint64_t v14 = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v12);
      if (!v14[128])
      {
        *(_OWORD *)&lhs.start.CMTimeValue value = *v5;
        lhs.start.CMTimeEpoch epoch = *(void *)(a1 + 56);
        long long v15 = *(_OWORD *)(v14 + 8);
        rhs.start.CMTimeEpoch epoch = *((void *)v14 + 3);
        *(_OWORD *)&rhs.start.CMTimeValue value = v15;
        if (!CMTimeCompare(&lhs.start, &rhs.start)) {
          v50.duratioCFIndex n = *v13;
        }
      }
      ++v12;
    }
    while (Count != v12);
  }
  CMTimeRange lhs = v50;
  CMTimeRangeGetEnd(&v43, &lhs);
  if (v43.flags)
  {
    CMTimeRange lhs = v50;
    CMTimeRangeGetEnd(&v42, &lhs);
    if ((v42.flags & 4) != 0) {
      v50.duratioCFIndex n = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    }
  }
  if ((v50.start.flags & 1) == 0
    || (v50.duration.flags & 1) == 0
    || v50.duration.epoch
    || v50.duration.value < 0
    || (lhs.CMTime start = v50.duration,
        *(_OWORD *)&rhs.start.CMTimeValue value = *MEMORY[0x1E4F1FA48],
        rhs.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16),
        CMTimeCompare(&lhs.start, &rhs.start)))
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (Count)
    {
      for (CFIndex k = 0; Count != k; ++k)
      {
        CMTimeScale v18 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), k);
        if (v18[128])
        {
          uint64_t v19 = v18;
          CMTimeRange lhs = v50;
          CMTimeRangeGetEnd(&v41, &lhs);
          long long v20 = *(_OWORD *)(v19 + 8);
          lhs.start.CMTimeEpoch epoch = *((void *)v19 + 3);
          *(_OWORD *)&lhs.start.CMTimeValue value = v20;
          if (CMTimeCompare(&lhs.start, &v41) < 0)
          {
            CFTypeRef v21 = (CFTypeRef)*((void *)v19 + 17);
            if (!v21)
            {
              if (v51)
              {
                CFRelease(v51);
                CFTypeRef v51 = 0;
              }
              CFAllocatorRef v22 = CFGetAllocator((CFTypeRef)a1);
              if (FigCaptionCreateMutable((uint64_t)v22, &v51)) {
                goto LABEL_56;
              }
              CFTypeRef v23 = v51;
              CMTimeRange rhs = *(CMTimeRange *)(v19 + 8);
              uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 16);
              uint64_t v25 = v24 ? v24 : 0;
              CMTime v26 = *(unsigned int (**)(CFTypeRef, CMTimeRange *))(v25 + 16);
              if (!v26) {
                goto LABEL_56;
              }
              CMTimeRange lhs = rhs;
              if (v26(v23, &lhs)) {
                goto LABEL_56;
              }
              uint64_t v27 = *(void *)v19;
              uint64_t CMBaseObject = FigCaptionGetCMBaseObject(v51);
              uint64_t v29 = *(void *)(CMBaseObjectGetVTable() + 8);
              uint64_t v30 = v29 ? v29 : 0;
              CMTime v31 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t))(v30 + 56);
              if (!v31 || v31(CMBaseObject, @"CaptionData", v27)) {
                goto LABEL_56;
              }
              CFTypeRef v21 = CFRetain(v51);
              *((void *)v19 + 17) = v21;
            }
            CFArrayAppendValue(Mutable, v21);
          }
        }
      }
    }
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 16)) >= 1)
    {
      CFIndex v32 = 0;
      do
      {
        CMTime v33 = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v32);
        memset(&rhs, 0, 24);
        long long v34 = *(_OWORD *)(v33 + 8);
        long long v35 = *(_OWORD *)(v33 + 40);
        *(_OWORD *)&lhs.start.CMTimeEpoch epoch = *(_OWORD *)(v33 + 24);
        *(_OWORD *)&lhs.duration.CMTimeScale timescale = v35;
        *(_OWORD *)&lhs.start.CMTimeValue value = v34;
        CMTimeRangeGetEnd(&rhs.start, &lhs);
        CMTimeRange lhs = v50;
        CMTimeRangeGetEnd(&v40, &lhs);
        *(_OWORD *)&lhs.start.CMTimeValue value = *(_OWORD *)&rhs.start.value;
        lhs.start.CMTimeEpoch epoch = rhs.start.epoch;
        if (CMTimeCompare(&lhs.start, &v40) <= 0)
        {
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 16), v32);
          fctg_freeBuddingCaption((const void **)v33);
        }
        else
        {
          ++v32;
        }
      }
      while (v32 < CFArrayGetCount(*(CFArrayRef *)(a1 + 16)));
    }
    uint64_t v37 = *(unsigned int (**)(__CFArray *, CMTimeRange *, uint64_t))(a1 + 24);
    uint64_t v36 = *(void *)(a1 + 32);
    CMTimeRange lhs = v50;
    if (!v37(Mutable, &lhs, v36))
    {
      CMTimeRange lhs = v50;
      CMTimeRangeGetEnd(&rhs.start, &lhs);
      *CFAllocatorRef v5 = *(_OWORD *)&rhs.start.value;
      *(void *)(a1 + 56) = rhs.start.epoch;
      uint64_t v38 = 1;
      goto LABEL_57;
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
  }
LABEL_56:
  uint64_t v38 = 0;
LABEL_57:
  if (v51) {
    CFRelease(v51);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v38;
}

void fctg_freeBuddingCaption(const void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = a1[17];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

uint64_t FigCaptionTimelineGeneratorFinish(uint64_t a1)
{
  if (a1)
  {
    CFArrayRef v3 = *(const __CFArray **)(a1 + 16);
    if (v3)
    {
      CFIndex Count = CFArrayGetCount(v3);
      if (Count >= 1)
      {
        CFIndex v5 = Count;
        for (CFIndex i = 0; i != v5; ++i)
          *((unsigned char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), i) + 128) = 1;
      }
    }
    uint64_t v7 = MEMORY[0x1E4F1FA10];
    while ((fctg_generateAndOutputCaptions(a1, v7) & 1) != 0)
      ;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

__n128 fctg_Init(uint64_t a1)
{
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  *(void *)(a1 + 16) = CFArrayCreateMutable(v2, 0, 0);
  uint64_t v3 = MEMORY[0x1E4F1FA48];
  __n128 result = *(__n128 *)MEMORY[0x1E4F1FA48];
  *(_OWORD *)(a1 + 40) = *MEMORY[0x1E4F1FA48];
  *(void *)(a1 + 56) = *(void *)(v3 + 16);
  return result;
}

void fctg_Finalize(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
  if (Count)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i != v3; ++i)
    {
      CFDictionaryRef ValueAtIndex = (const void **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), i);
      fctg_freeBuddingCaption(ValueAtIndex);
    }
  }
  CFDictionaryRef v6 = *(const void **)(a1 + 16);
  if (v6)
  {
    CFRelease(v6);
  }
}

CFStringRef fctg_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionTimelineGenerator %p]", a1);
}

CFStringRef fctg_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionTimelineGenerator %p]", a1);
}

uint64_t FigCaptionRendererLayoutContextCreate(void *a1)
{
  *a1 = 0;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  MEMORY[0x19970EE10](&FigCaptionRendererLayoutContextLocalGetTypeID_sRegisterFigCaptionRendererLayoutContextOnce, RegisterFigCaptionRendererLayoutContextClass);
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  Instance[3] = Mutable;
  if (Mutable)
  {
    *a1 = Instance;
    return 0;
  }
  else
  {
    uint64_t v6 = FigSignalErrorAt();
    CFRelease(Instance);
    return v6;
  }
}

uint64_t FigCaptionRendererLayoutContextSetSubtitleSample(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    CFIndex v3 = *(const void **)(a1 + 16);
    *(void *)(a1 + 16) = cf;
    if (cf) {
      CFRetain(cf);
    }
    if (v3) {
      CFRelease(v3);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigCaptionRendererLayoutContextGetSubtitleSample(uint64_t a1, void *a2)
{
  if (!a1 || !a2) {
    return FigSignalErrorAt();
  }
  *a2 = *(void *)(a1 + 16);
  return 0;
}

uint64_t FigCaptionRendererLayoutContextSetMapping(uint64_t a1, const void *a2, const void *a3)
{
  if (a1 && a2 && a3)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, a3);
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigCaptionRendererLayoutContextGetMapping(uint64_t a1, const void *a2, const void **a3)
{
  if (a1 && a2 && a3)
  {
    *a3 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t RegisterFigCaptionRendererLayoutContextClass()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionRendererLayoutContextID = result;
  return result;
}

uint64_t FigCaptionRendererLayoutContextInit(uint64_t result)
{
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

void FigCaptionRendererLayoutContext_Finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
  }
}

__CFString *FigCaptionRendererLayoutContextCopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigCaptionRendererLayoutContext %p>", a1);
  return Mutable;
}

uint64_t RegisterFigCrossTalkerBaseType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigCrossTalkerGetTypeID()
{
  MEMORY[0x19970EE10](&FigCrossTalkerGetClassID_sRegisterFigCrossTalkerBaseTypeOnce, RegisterFigCrossTalkerBaseType);

  return CMBaseClassGetCFTypeID();
}

uint64_t FigCrossTalkerCreate(uint64_t a1, void *a2)
{
  if (a2)
  {
    MEMORY[0x19970EE10](&FigCrossTalkerGetClassID_sRegisterFigCrossTalkerBaseTypeOnce, RegisterFigCrossTalkerBaseType);
    uint64_t v3 = CMDerivedObjectCreate();
    if (!v3)
    {
      MEMORY[0] = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (MEMORY[0])
      {
        uint64_t v3 = 0;
        MEMORY[8] = dispatch_queue_create("com.apple.coremedia.crosstalker", 0);
        *a2 = 0;
      }
      else
      {
        return FigSignalErrorAt();
      }
    }
    return v3;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

CFStringRef FigCrossTalkerCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCrossTalker %p]", a1);
}

void fct_Finalize(uint64_t a1)
{
  if (a1) {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  }
  else {
    uint64_t DerivedStorage = 0;
  }
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  uint64_t v2 = *(NSObject **)(DerivedStorage + 8);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(DerivedStorage + 8) = 0;
  }
}

__CFString *fct_CopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CMBaseObjectGetDerivedStorage();
  uint64_t v4 = (const void *)FigCFCopyCompactDescription();
  CFStringAppendFormat(Mutable, 0, @"<CrossTalker: %p %@>", a1, v4);
  if (v4) {
    CFRelease(v4);
  }
  return Mutable;
}

uint64_t fct_CopyProperty(uint64_t DerivedStorage, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v6 = DerivedStorage;
  if (DerivedStorage) {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  }
  v8[0] = 0;
  v8[1] = v6;
  int v8[2] = a2;
  CFTypeRef cf = 0;
  if (a2 && a4)
  {
    dispatch_sync_f(*(dispatch_queue_t *)(DerivedStorage + 8), v8, (dispatch_function_t)fct_CopyProperty_f);
    if (LODWORD(v8[0]))
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      *a4 = cf;
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t fct_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  if (a1) {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  }
  else {
    uint64_t DerivedStorage = 0;
  }
  v9[0] = 0;
  v9[1] = a1;
  void v9[2] = a2;
  v9[3] = a3;
  if (a2)
  {
    if (!a3)
    {
LABEL_8:
      dispatch_sync_f(*(dispatch_queue_t *)(DerivedStorage + 8), v9, (dispatch_function_t)fct_SetProperty_f);
      return LODWORD(v9[0]);
    }
    if (!CFEqual(a2, @"HDRVideoPlaybackActive")) {
      return 4294954512;
    }
    CFTypeID v7 = CFGetTypeID(a3);
    if (v7 == CFBooleanGetTypeID()) {
      goto LABEL_8;
    }
  }

  return FigSignalErrorAt();
}

CFTypeRef fct_CopyProperty_f(uint64_t a1)
{
  uint64_t DerivedStorage = (CFDictionaryRef *)CMBaseObjectGetDerivedStorage();
  uint64_t v3 = (CFTypeRef *)(a1 + 24);
  CFTypeRef result = (CFTypeRef)CFDictionaryGetValueIfPresent(*DerivedStorage, *(const void **)(a1 + 16), (const void **)(a1 + 24));
  if (result)
  {
    CFTypeRef result = *v3;
    if (*v3)
    {
      return CFRetain(result);
    }
  }
  else
  {
    *(_DWORD *)a1 = -12784;
  }
  return result;
}

void fct_SetProperty_f(uint64_t a1)
{
  uint64_t DerivedStorage = (CFDictionaryRef *)CMBaseObjectGetDerivedStorage();
  CFDictionaryRef Value = CFDictionaryGetValue(*DerivedStorage, *(const void **)(a1 + 16));
  uint64_t v4 = *DerivedStorage;
  CFIndex v5 = *(const void **)(a1 + 16);
  uint64_t v6 = *(const void **)(a1 + 24);
  if (v6)
  {
    CFDictionarySetValue(v4, v5, v6);
    if (!Value) {
      return;
    }
  }
  else
  {
    CFDictionaryRemoveValue(v4, v5);
    if (!Value) {
      return;
    }
  }
  CFTypeID v7 = *(const void **)(a1 + 24);

  CFEqual(Value, v7);
}

uint64_t FigSymptomsManagerTriggerScorecardsUpdate()
{
  return 4294949656;
}

uint64_t FigSymptomsManagerGetBandwidthPredictionFromLastUpdate(void *a1, _DWORD *a2)
{
  if (a1) {
    *a1 = 0;
  }
  if (a2) {
    *a2 = 0;
  }
  return 4294949656;
}

uint64_t FigSymptomsReportStreamingAssetDownloadStart(uint64_t a1, CMTime *a2, int a3, int a4, int a5, uuid_t out)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  memset(outa, 0, 37);
  if (!out) {
    return 4294954516;
  }
  uuid_generate_random(out);
  if (uuid_is_null(out)) {
    return 4294954510;
  }
  uuid_unparse(out, outa);
  ((void (*)(uint64_t))softLinksymptom_create[0])((uint64_t)"com.apple.coremedia.assetdownload.event");
  symptom_set_qualifier();
  symptom_set_additional_qualifier();
  if (a1)
  {
    v11.CMTimeValue value = 0;
    CStringPtrAndBufferToFree = (const char *)FigCFStringGetCStringPtrAndBufferToFree();
    if (CStringPtrAndBufferToFree)
    {
      strlen(CStringPtrAndBufferToFree);
      symptom_set_additional_qualifier();
    }
    free((void *)v11.value);
  }
  symptom_set_qualifier();
  if ((a2->flags & 0x1D) == 1)
  {
    CMTime v11 = *a2;
    CMTimeGetSeconds(&v11);
    symptom_set_qualifier();
  }
  symptom_send();
  return 0;
}

uint64_t FigSymptomsReportStreamingAssetDownloadEnd(const unsigned __int8 *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  memset(v3, 0, sizeof(v3));
  if (uuid_is_null(a1)) {
    return 4294954516;
  }
  uuid_unparse(a1, v3);
  ((void (*)(uint64_t))softLinksymptom_create[0])((uint64_t)"com.apple.coremedia.assetdownload.event");
  symptom_set_qualifier();
  symptom_set_additional_qualifier();
  symptom_send();
  return 0;
}

uint64_t FigSymptomsReportStreamingAssetDownloadPause(const unsigned __int8 *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  memset(v3, 0, sizeof(v3));
  if (uuid_is_null(a1)) {
    return 4294954516;
  }
  uuid_unparse(a1, v3);
  ((void (*)(uint64_t))softLinksymptom_create[0])((uint64_t)"com.apple.coremedia.assetdownload.event");
  symptom_set_qualifier();
  symptom_set_additional_qualifier();
  symptom_send();
  return 0;
}

uint64_t FigSymptomsReportStreamingAssetDownloadResume(const unsigned __int8 *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  memset(v3, 0, sizeof(v3));
  if (uuid_is_null(a1)) {
    return 4294954516;
  }
  uuid_unparse(a1, v3);
  ((void (*)(uint64_t))softLinksymptom_create[0])((uint64_t)"com.apple.coremedia.assetdownload.event");
  symptom_set_qualifier();
  symptom_set_additional_qualifier();
  symptom_send();
  return 0;
}

uint64_t initsymptom_create(uint64_t a1)
{
  if (SymptomReporterLibrary_sOnce != -1) {
    dispatch_once(&SymptomReporterLibrary_sOnce, &__block_literal_global_62);
  }
  CFAllocatorRef v2 = (uint64_t (*)())dlsym((void *)SymptomReporterLibrary_sLib, "symptom_create");
  softLinksymptom_create[0] = v2;

  return ((uint64_t (*)(uint64_t))v2)(a1);
}

void *__SymptomReporterLibrary_block_invoke()
{
  CFTypeRef result = dlopen("/System/Library/PrivateFrameworks/SymptomReporter.framework/SymptomReporter", 2);
  SymptomReporterLibrary_sLib = (uint64_t)result;
  return result;
}

uint64_t figCSSTokenizerRegisterFigCSSTokenizer()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCSSTokenizerID = result;
  return result;
}

uint64_t FigCSSTokenizerCreateWithTextContainer(uint64_t a1, const void *a2, uint64_t *a3)
{
  if (a2
    && a3
    && (MEMORY[0x19970EE10](&FigCSSTokenizerGetTypeID_sRegisterFigCSSTokenizerOnce, figCSSTokenizerRegisterFigCSSTokenizer), (uint64_t Instance = _CFRuntimeCreateInstance()) != 0))
  {
    uint64_t v6 = Instance;
    *(void *)(Instance + 16) = CFRetain(a2);
    *(void *)(v6 + 40) = -1;
    *(unsigned char *)(v6 + 56) = 0;
    *(_DWORD *)(v6 + 28) = 0;
    *(void *)(v6 + 64) = 0;
    uint64_t Length = FigTextContainerGetLength((uint64_t)a2, (void *)(v6 + 48));
    if (Length) {
      CFRelease((CFTypeRef)v6);
    }
    else {
      *a3 = v6;
    }
    return Length;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigCSSTokenizerProduceTokenArray(char *cf, void *a2)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (!cf || (CFAllocatorRef v2 = a2) == 0)
  {
    return FigSignalErrorAt();
  }
  if (*((_DWORD *)cf + 7))
  {
    uint64_t v4 = (const void *)*((void *)cf + 4);
    if (v4)
    {
      CFRelease(v4);
      *((void *)cf + 4) = 0;
    }
    *((_DWORD *)cf + 7) = 0;
    *((void *)cf + 5) = -1;
    cf[56] = 0;
    *((void *)cf + 8) = 0;
  }
  CFAllocatorRef v5 = CFGetAllocator(cf);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E4F1D510]);
  *((void *)cf + 4) = Mutable;
  if (!Mutable)
  {
    uint64_t TokenType = FigSignalErrorAt();
    goto LABEL_224;
  }
  __int16 v61 = v2;
  CFTypeRef v7 = 0;
  CMTimeRange v62 = (unsigned int *)(cf + 72);
  CMTimeRange v63 = (uint64_t *)(cf + 64);
  do
  {
    if (v7) {
      CFRelease(v7);
    }
    int v8 = 0;
    int v67 = 65533;
    double v65 = 0;
    CFTypeRef v66 = 0;
LABEL_12:
    if (!cf[26]) {
      goto LABEL_29;
    }
    uint64_t v9 = *((void *)cf + 2);
    uint64_t v10 = *((void *)cf + 5);
    uint64_t v11 = *((void *)cf + 6);
    CFAllocatorRef v12 = CFGetAllocator(cf);
    uint64_t v13 = CFStringCreateMutable(v12, 0);
    if (!v13 || (CFAllocatorRef v14 = CFGetAllocator(cf), (v15 = CFStringCreateMutable(v14, 0)) == 0))
    {
      FigSignalErrorAt();
      long long v16 = 0;
LABEL_76:
      CFStringRef i = 0;
      goto LABEL_23;
    }
    long long v16 = v15;
    v17.locatioCFIndex n = v10 & ~(v10 >> 63);
    if (v11 - v17.location < 1)
    {
      if (v10 < 1)
      {
        CFAllocatorRef v33 = CFGetAllocator(cf);
        CFStringRef v22 = CFStringCreateWithFormat(v33, 0, @"<empty text buffer>");
        CFStringRef i = 0;
        if (!v22) {
          goto LABEL_23;
        }
LABEL_22:
        CFShow(v22);
        CFRelease(v22);
        goto LABEL_23;
      }
      if (v17.location >= 5) {
        uint64_t v31 = 5;
      }
      else {
        uint64_t v31 = v10 & ~(v10 >> 63);
      }
      v72.locatioCFIndex n = v17.location - v31;
      v72.length = v31;
      if (FigTextContainerGetCharactersForRange(v9, v72, chars)) {
        goto LABEL_76;
      }
      CFAllocatorRef v32 = CFGetAllocator(cf);
      for (CFStringRef i = CFStringCreateWithCharacters(v32, chars, v31); v31; --v31)
      {
        CFStringAppendCString(v13, " ", 0x600u);
        CFStringAppendCString(v16, " ", 0x600u);
      }
    }
    else
    {
      if (v11 - v17.location >= 10) {
        CFIndex v18 = 10;
      }
      else {
        CFIndex v18 = v11 - v17.location;
      }
      v17.length = v18;
      if (FigTextContainerGetCharactersForRange(v9, v17, chars)) {
        goto LABEL_76;
      }
      CFAllocatorRef v19 = CFGetAllocator(cf);
      CFStringRef i = CFStringCreateWithCharacters(v19, chars, v18);
    }
    CFStringAppendCString(v13, "^", 0x600u);
    CFStringAppendCString(v16, "|", 0x600u);
    CFAllocatorRef v21 = CFGetAllocator(cf);
    CFStringRef v22 = CFStringCreateWithFormat(v21, 0, @"%@\n%@\n%@", i, v13, v16);
    if (v22) {
      goto LABEL_22;
    }
LABEL_23:
    if (v13) {
      CFRelease(v13);
    }
    if (v16) {
      CFRelease(v16);
    }
    if (i) {
      CFRelease(i);
    }
LABEL_29:
    int v67 = 0;
    do
    {
      uint64_t v23 = *((void *)cf + 6);
      if (!v23 || *((void *)cf + 5) >= v23) {
        goto LABEL_204;
      }
      int v24 = v8;
      if (_figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, &v67))
      {
        _figCSSTokenizer_PeekAheadBuffer((uint64_t)cf, 3, v62, 0xCuLL, v63);
        unsigned int v25 = v67;
        if (v67 == 10 || v67 == 9 || v67 == 32)
        {
          *(_DWORD *)chars = 0;
          while (1)
          {
            uint64_t v37 = *((void *)cf + 6);
            if (!v37
              || *((void *)cf + 5) >= v37
              || !_figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, chars))
            {
              break;
            }
            if (*(_DWORD *)chars != 10 && *(_DWORD *)chars != 9 && *(_DWORD *)chars != 32)
            {
              cf[56] = 1;
              break;
            }
          }
          CFAllocatorRef v35 = CFGetAllocator(cf);
          int v36 = 2;
          goto LABEL_155;
        }
        if (v67 == 34)
        {
          uint64_t v38 = (uint64_t)cf;
          int v39 = 34;
        }
        else
        {
          if (v67 == 35)
          {
            unint64_t v42 = *v63;
            if (*v63 >= 1)
            {
              if ((unsigned int v43 = *v62, *v62 >= 0x41) && v43 <= 0x5A
                || (v43 <= 0x7A ? (BOOL v44 = v43 < 0x61) : (BOOL v44 = 1),
                    !v44
                 || v43 >= 0x80
                 || v43 == 95
                 || (v43 <= 0x39 ? (BOOL v45 = v43 < 0x30) : (BOOL v45 = 1),
                     !v45 || v43 == 45 || v42 >= 2 && v43 == 92 && *((_DWORD *)cf + 19) != 10)))
              {
                unsigned int v46 = v42 >= 3
                   && _figCSSTokenizer_check_if_three_code_points_would_start_an_identifier(v43, *((_DWORD *)cf + 19), *((_DWORD *)cf + 20));
                uint64_t v41 = _figCSSTokenizer_consume_a_name((uint64_t)cf, &v65);
                if (v41) {
                  goto LABEL_213;
                }
                CFAllocatorRef v50 = CFGetAllocator(cf);
                uint64_t v41 = FigCSSHashTokenCreate(v50, v46, v65, &v66);
                if (v41) {
                  goto LABEL_213;
                }
                goto LABEL_205;
              }
            }
            goto LABEL_202;
          }
          if (v67 == 36)
          {
            if (*v63 < 0 || *v62 != 61) {
              goto LABEL_202;
            }
            _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
            CFAllocatorRef v35 = CFGetAllocator(cf);
            int v36 = 28;
            goto LABEL_155;
          }
          if (v67 != 39)
          {
            if (v67 == 40)
            {
              CFAllocatorRef v35 = CFGetAllocator(cf);
              int v36 = 16;
              goto LABEL_155;
            }
            if (v67 == 41)
            {
              CFAllocatorRef v35 = CFGetAllocator(cf);
              int v36 = 17;
              goto LABEL_155;
            }
            if (v67 == 42)
            {
              if (*v63 < 0 || *v62 != 61) {
                goto LABEL_202;
              }
              *(_DWORD *)chars = 0;
              _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, chars);
              CFAllocatorRef v35 = CFGetAllocator(cf);
              int v36 = 29;
              goto LABEL_155;
            }
            if (v67 == 43)
            {
              if (*v63 < 0) {
                goto LABEL_202;
              }
            }
            else
            {
              if (v67 == 44)
              {
                CFAllocatorRef v35 = CFGetAllocator(cf);
                int v36 = 12;
                goto LABEL_155;
              }
              if (v67 == 45)
              {
                unint64_t v47 = *v63;
                if (*v63 < 1) {
                  goto LABEL_202;
                }
                unsigned int v48 = *v62;
                if (*v62 < 0x30 || v48 > 0x39)
                {
                  if (v47 < 3)
                  {
                    if (v47 != 2 || v48 != 45) {
                      goto LABEL_202;
                    }
                    unsigned int v49 = *((_DWORD *)cf + 19);
                  }
                  else
                  {
                    unsigned int v49 = *((_DWORD *)cf + 19);
                    if (_figCSSTokenizer_check_if_three_code_points_would_start_an_identifier(*v62, v49, *((_DWORD *)cf + 20)))
                    {
                      goto LABEL_164;
                    }
                    if (v48 != 45) {
                      goto LABEL_202;
                    }
                  }
                  if (v49 != 62) {
                    goto LABEL_202;
                  }
                  _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                  _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                  CFAllocatorRef v35 = CFGetAllocator(cf);
                  int v36 = 25;
                  goto LABEL_155;
                }
LABEL_151:
                cf[56] = 1;
                uint64_t v41 = _figCSSTokenizer_consume_a_numeric_token(cf, &v66);
                if (!v41) {
                  goto LABEL_205;
                }
                goto LABEL_213;
              }
              if (v67 != 46)
              {
                if (v67 == 47)
                {
                  if (*v63 < 0 || *v62 != 42) {
                    goto LABEL_202;
                  }
                  uint64_t v64 = 0;
                  _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                  while (!_figCSSTokenizer_PeekAheadBuffer((uint64_t)cf, 2, chars, 8uLL, &v64))
                  {
                    uint64_t v26 = v64;
                    if (!v64) {
                      goto LABEL_12;
                    }
                    int v27 = *(_DWORD *)chars;
                    int v28 = v69;
                    _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                    if (v26 >= 2 && v27 == 42 && v28 == 47)
                    {
                      _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                      goto LABEL_12;
                    }
                  }
                  unsigned int v25 = v67;
                }
                switch(v25)
                {
                  case ':':
                    CFAllocatorRef v35 = CFGetAllocator(cf);
                    int v36 = 13;
                    goto LABEL_155;
                  case ';':
                    CFAllocatorRef v35 = CFGetAllocator(cf);
                    int v36 = 14;
                    goto LABEL_155;
                  case '<':
                    if (*v63 >= 3 && (*v62 == 33 || *((_DWORD *)cf + 19) == 45 || *((_DWORD *)cf + 20) == 45))
                    {
                      _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                      _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                      _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                      CFAllocatorRef v35 = CFGetAllocator(cf);
                      int v36 = 26;
                      goto LABEL_155;
                    }
LABEL_202:
                    CFAllocatorRef v53 = CFGetAllocator(cf);
                    uint64_t v41 = FigCSSCodePointTokenCreate(v53, 5, v67, &v66);
                    if (v41) {
                      goto LABEL_213;
                    }
                    goto LABEL_205;
                  case '@':
                    if (*v63 >= 3
                      && _figCSSTokenizer_check_if_three_code_points_would_start_an_identifier(*((_DWORD *)cf + 18), *((_DWORD *)cf + 19), *((_DWORD *)cf + 20)))
                    {
                      _figCSSTokenizer_consume_a_name((uint64_t)cf, &v65);
                      CFAllocatorRef v40 = CFGetAllocator(cf);
                      uint64_t v41 = FigCSSStringValueTokenCreate(v40, 8, v65, &v66);
                      if (!v41) {
                        goto LABEL_205;
                      }
                      goto LABEL_213;
                    }
LABEL_216:
                    CFAllocatorRef v55 = CFGetAllocator(cf);
                    FigCSSCodePointTokenCreate(v55, 5, v67, &v66);
                    goto LABEL_205;
                  case '[':
                    CFAllocatorRef v35 = CFGetAllocator(cf);
                    int v36 = 20;
                    goto LABEL_155;
                  case '\\':
                    if (*v63 < 1 || *v62 == 10) {
                      goto LABEL_202;
                    }
                    goto LABEL_164;
                  case ']':
                    CFAllocatorRef v35 = CFGetAllocator(cf);
                    int v36 = 21;
                    goto LABEL_155;
                  case '^':
                    if (*v63 < 0 || *v62 != 61) {
                      goto LABEL_202;
                    }
                    *(_DWORD *)chars = 0;
                    _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, chars);
                    CFAllocatorRef v35 = CFGetAllocator(cf);
                    int v36 = 27;
                    goto LABEL_155;
                  case '{':
                    CFAllocatorRef v35 = CFGetAllocator(cf);
                    int v36 = 18;
                    goto LABEL_155;
                  case '}':
                    CFAllocatorRef v35 = CFGetAllocator(cf);
                    int v36 = 19;
                    goto LABEL_155;
                }
                if (v25 < 0x30 || v25 > 0x39)
                {
                  if (v25 == 85 || v25 == 117)
                  {
                    if (*v63 >= 2 && *v62 == 43)
                    {
                      unsigned int v51 = *((_DWORD *)cf + 19);
                      if (FigCSSCodePointIs_hex_digit(v51) || v51 == 63)
                      {
                        uint64_t v41 = FigSignalErrorAt();
                        if (v41) {
                          goto LABEL_213;
                        }
                        goto LABEL_205;
                      }
                    }
                    goto LABEL_164;
                  }
                  if (FigCSSCodePointIs_name_start_code_point(v25))
                  {
LABEL_164:
                    cf[56] = 1;
                    uint64_t v41 = _figCSSTokenizer_consume_an_ident_like_token(cf, &v66);
                    if (v41) {
                      goto LABEL_213;
                    }
                    goto LABEL_205;
                  }
                  if (v25 == 124)
                  {
                    if (*v63 < 1) {
                      goto LABEL_216;
                    }
                    if (*v62 == 61)
                    {
                      _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                      CFAllocatorRef v35 = CFGetAllocator(cf);
                      int v36 = 31;
                    }
                    else
                    {
                      if (*v62 != 124) {
                        goto LABEL_216;
                      }
                      _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                      CFAllocatorRef v35 = CFGetAllocator(cf);
                      int v36 = 15;
                    }
                  }
                  else
                  {
                    if (v25 != 126)
                    {
                      uint64_t v52 = *((void *)cf + 6);
                      if (v52 && *((void *)cf + 5) < v52) {
                        goto LABEL_202;
                      }
LABEL_204:
                      CFAllocatorRef v54 = CFGetAllocator(cf);
                      uint64_t v41 = FigCSSEOFTokenCreate((uint64_t)v54, &v66);
                      if (!v41) {
                        goto LABEL_205;
                      }
LABEL_213:
                      uint64_t TokenType = v41;
                      goto LABEL_77;
                    }
                    if (*v63 < 1 || *v62 != 61) {
                      goto LABEL_202;
                    }
                    _figCSSTokenizer_consume_next_input_code_point((uint64_t)cf, 0);
                    CFAllocatorRef v35 = CFGetAllocator(cf);
                    int v36 = 30;
                  }
LABEL_155:
                  uint64_t v41 = FigCSSSimpleTokenCreate((uint64_t)v35, v36, &v66);
                  if (v41) {
                    goto LABEL_213;
                  }
LABEL_205:
                  uint64_t TokenType = 0;
                  CFTypeRef v7 = v66;
                  CFTypeRef v66 = 0;
                  goto LABEL_206;
                }
                goto LABEL_151;
              }
              if (*v63 < 1) {
                goto LABEL_202;
              }
            }
            if (*v62 < 0x30 || *v62 > 0x39) {
              goto LABEL_202;
            }
            goto LABEL_151;
          }
          uint64_t v38 = (uint64_t)cf;
          int v39 = 39;
        }
        uint64_t v41 = _figCSSTokenizer_consume_a_string_token(v38, v39, &v66);
        if (!v41) {
          goto LABEL_205;
        }
        goto LABEL_213;
      }
      int v8 = 1;
    }
    while (!v24);
    uint64_t TokenType = 4294949486;
LABEL_77:
    if (v66) {
      CFRelease(v66);
    }
    CFTypeRef v7 = 0;
LABEL_206:
    if (v65) {
      CFRelease(v65);
    }
    if (TokenType) {
      break;
    }
    if (!v7)
    {
      uint64_t TokenType = 0;
      break;
    }
    *(_DWORD *)chars = 0;
    CFArrayAppendValue(*((CFMutableArrayRef *)cf + 4), v7);
    uint64_t TokenType = FigCSSTokenGetTokenType((uint64_t)v7, chars);
    if (TokenType) {
      break;
    }
  }
  while (*(_DWORD *)chars != 1);
  if (cf[24])
  {
    CFAllocatorRef v56 = CFGetAllocator(cf);
    CFStringRef v57 = CFStringCreateWithFormat(v56, 0, @"tokens: %@", *((void *)cf + 4));
    if (v57) {
      CFRelease(v57);
    }
  }
  if (v7) {
    CFRelease(v7);
  }
  CFAllocatorRef v2 = v61;
LABEL_224:
  if (TokenType) {
    int v58 = 2;
  }
  else {
    int v58 = 1;
  }
  *((_DWORD *)cf + 7) = v58;
  if (!TokenType)
  {
    CFTypeRef v59 = (CFTypeRef)*((void *)cf + 4);
    if (v59) {
      CFTypeRef v59 = CFRetain(v59);
    }
    uint64_t TokenType = 0;
    *CFAllocatorRef v2 = v59;
  }
  return TokenType;
}

double figCSSTokenizer_Init(uint64_t a1)
{
  *(void *)(a1 + 80) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figCSSTokenizer_Finalize(uint64_t a1)
{
  CFAllocatorRef v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

CFStringRef figCSSTokenizer_CopyFormattingDesc(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"[FigCSSTokenizer <%p> textContainer:<%p> tokens:<%p> textLength:<%ld> currentIndex:%ld]", a1, a1[2], a1[4], a1[6], a1[5]);
}

CFStringRef figCSSTokenizer_CopyDebugDesc(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"[FigCSSTokenizer <%p> textContainer:<%p> tokens:<%p> textLength:<%ld> currentIndex:%ld]", a1, a1[2], a1[4], a1[6], a1[5]);
}

uint64_t _figCSSTokenizer_consume_next_input_code_point(uint64_t a1, _DWORD *a2)
{
  v3.locatioCFIndex n = *(void *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 56) || v3.location < 0) {
    *(void *)(a1 + 40) = ++v3.location;
  }
  uint64_t v4 = 0;
  *(unsigned char *)(a1 + 56) = 0;
  if (v3.location < *(void *)(a1 + 48))
  {
    UniChar buffer = 0;
    v3.length = (CFIndex)&buffer;
    if (FigTextContainerGetCharacterAtIndex(*(void *)(a1 + 16), v3))
    {
      return 0;
    }
    else
    {
      if (a2) {
        *a2 = buffer;
      }
      return 1;
    }
  }
  return v4;
}

uint64_t _figCSSTokenizer_consume_a_string_token(uint64_t a1, int a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  int v23 = 65533;
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v6, 0);
  if (Mutable)
  {
    uint64_t v8 = *(void *)(a1 + 48);
    if (v8)
    {
      while (1)
      {
        uint64_t v9 = *(void *)(a1 + 40);
        int v10 = _figCSSTokenizer_consume_next_input_code_point(a1, &v23);
        if (!v10 && v9 < v8)
        {
          uint64_t v17 = *(void *)(a1 + 48);
          if (!v17 || *(void *)(a1 + 40) >= v17) {
            goto LABEL_23;
          }
          goto LABEL_24;
        }
        if (v9 >= v8) {
          goto LABEL_23;
        }
        if (!v10) {
          goto LABEL_24;
        }
        if (v23 == a2) {
          goto LABEL_23;
        }
        if (v23 == 10)
        {
          *(unsigned char *)(a1 + 56) = 1;
          CFAllocatorRef v18 = CFGetAllocator((CFTypeRef)a1);
          uint64_t v14 = FigCSSSimpleTokenCreate((uint64_t)v18, 4, &cf);
          if (!v14) {
            goto LABEL_24;
          }
          goto LABEL_34;
        }
        if (v23 != 92) {
          break;
        }
        *(void *)chars = 0;
        _figCSSTokenizer_PeekAheadBuffer(a1, 1, &v22, 4uLL, (uint64_t *)chars);
        uint64_t v11 = *(void *)(a1 + 48);
        if (!v11 || *(void *)(a1 + 40) >= v11 || *(uint64_t *)chars < 1) {
          goto LABEL_17;
        }
        if (v22 != 10)
        {
          if (v23 != 92 || *(_DWORD *)(a1 + 72) == 10) {
            goto LABEL_17;
          }
          int v20 = 0;
          __int16 v19 = 0;
          _figCSSTokenizer_consume_an_escaped_code_point(a1, &v20);
          __int16 v19 = v20;
          CFAllocatorRef v12 = (UniChar *)&v19;
          goto LABEL_16;
        }
        _figCSSTokenizer_consume_next_input_code_point(a1, 0);
LABEL_17:
        uint64_t v8 = *(void *)(a1 + 48);
        if (!v8) {
          goto LABEL_22;
        }
      }
      chars[0] = v23;
      CFAllocatorRef v12 = chars;
LABEL_16:
      CFStringAppendCharacters(Mutable, v12, 1);
      goto LABEL_17;
    }
LABEL_22:
    _figCSSTokenizer_consume_next_input_code_point(a1, &v23);
LABEL_23:
    CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v14 = FigCSSStringValueTokenCreate(v13, 3, Mutable, &cf);
    if (!v14)
    {
LABEL_24:
      uint64_t v15 = 0;
      *a3 = cf;
      CFTypeRef cf = 0;
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v14 = FigSignalErrorAt();
  }
LABEL_34:
  uint64_t v15 = v14;
  if (cf) {
    CFRelease(cf);
  }
LABEL_25:
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v15;
}

BOOL _figCSSTokenizer_check_if_three_code_points_would_start_an_identifier(unsigned int a1, unsigned int a2, int a3)
{
  if (a1 != 45)
  {
    if (a1 < 0x41 || a1 > 0x5A)
    {
      BOOL v9 = a1 > 0x7A || a1 < 0x61;
      BOOL v10 = v9 && a1 < 0x80;
      if (v10 && a1 != 95) {
        return a1 == 92 && a2 != 10;
      }
    }
    return 1;
  }
  if (a2 >= 0x41 && a2 <= 0x5A) {
    return 1;
  }
  BOOL v4 = a2 > 0x7A || a2 < 0x61;
  BOOL v5 = v4 && a2 < 0x80;
  if (!v5 || a2 == 95) {
    return 1;
  }
  BOOL result = 0;
  if (a2 == 92 && a3 != 10) {
    return 1;
  }
  return result;
}

uint64_t _figCSSTokenizer_consume_a_name(uint64_t a1, __CFString **a2)
{
  unsigned int v17 = 65533;
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v4, 0);
  if (!Mutable)
  {
    return FigSignalErrorAt();
  }
  CFAllocatorRef v6 = Mutable;
  if (!_figCSSTokenizer_consume_next_input_code_point(a1, &v17)) {
    goto LABEL_28;
  }
  while (1)
  {
    UniChar chars = 0;
    _figCSSTokenizer_PeekAheadBuffer(a1, 3, (_DWORD *)(a1 + 72), 0xCuLL, (uint64_t *)(a1 + 64));
    UniChar v7 = v17;
    if (v17 >= 0x41 && v17 <= 0x5A) {
      goto LABEL_27;
    }
    BOOL v9 = v17 > 0x7A || v17 < 0x61;
    BOOL v10 = v9 && v17 < 0x80;
    if (!v10 || v17 == 95) {
      goto LABEL_27;
    }
    BOOL v12 = v17 > 0x39 || v17 < 0x30;
    if (!v12 || v17 == 45) {
      goto LABEL_27;
    }
    if (v17 != 92 || *(_DWORD *)(a1 + 72) == 10) {
      break;
    }
    int v15 = 0;
    _figCSSTokenizer_consume_an_escaped_code_point(a1, &v15);
    UniChar v7 = v15;
LABEL_27:
    UniChar chars = v7;
    CFStringAppendCharacters(v6, &chars, 1);
    if (!_figCSSTokenizer_consume_next_input_code_point(a1, &v17)) {
      goto LABEL_28;
    }
  }
  *(unsigned char *)(a1 + 56) = 1;
LABEL_28:
  *a2 = v6;
  return 0;
}

uint64_t _figCSSTokenizer_consume_a_numeric_token(const void *a1, CFTypeRef *a2)
{
  uint64_t v3 = (uint64_t)a1;
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  long long v74 = 0;
  CFTypeRef cf = 0;
  int v79 = 65533;
  long long v84 = xmmword_1949987D8;
  CFRange v85 = (CFRange)unk_1949987E8;
  long long v86 = xmmword_1949987F8;
  CFRange v80 = (CFRange)xmmword_194998798;
  long long v81 = unk_1949987A8;
  long long v82 = xmmword_1949987B8;
  long long v83 = unk_1949987C8;
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v4, 0);
  if (!Mutable)
  {
    FigSignalErrorAt();
    double v57 = 0.0;
    unsigned int v9 = 1;
    goto LABEL_106;
  }
  uint64_t v76 = 0;
  _figCSSTokenizer_PeekAheadBuffer(v3, 3, (_DWORD *)(v3 + 72), 0xCuLL, (uint64_t *)(v3 + 64));
  if (*(uint64_t *)(v3 + 64) >= 1 && ((int v6 = *(_DWORD *)(v3 + 72), v6 == 43) || v6 == 45))
  {
    int v68 = 1;
    v80.length = 1;
    _figCSSTokenizer_consume_next_input_code_point(v3, &v79);
    UniChar chars = v79;
    CFStringAppendCharacters(Mutable, &chars, 1);
    CFIndex range = 1;
  }
  else
  {
    CFIndex range = 0;
    int v68 = 0;
  }
  CFIndex v7 = 0;
  if (!_figCSSTokenizer_PeekAheadBuffer(v3, 1, &v87, 4uLL, &v76) && v76 >= 1)
  {
    CFIndex v7 = 0;
    do
    {
      if (v87 < 0x30 || v87 > 0x39) {
        break;
      }
      ++v7;
      _figCSSTokenizer_consume_next_input_code_point(v3, &v79);
      UniChar chars = v79;
      CFStringAppendCharacters(Mutable, &chars, 1);
      if (_figCSSTokenizer_PeekAheadBuffer(v3, 1, &v87, 4uLL, &v76)) {
        break;
      }
    }
    while (v76 > 0);
    *((void *)&v81 + 1) = v7;
  }
  unsigned int v9 = 0;
  uint64_t v10 = 0;
  if (!_figCSSTokenizer_PeekAheadBuffer(v3, 2, &v87, 8uLL, &v76) && v76 >= 2)
  {
    if (v87 == 46)
    {
      unsigned int v9 = 0;
      uint64_t v10 = 0;
      if (v88 >= 0x30 && v88 <= 0x39)
      {
        uint64_t v10 = 1;
        *((void *)&v82 + 1) = 1;
        _figCSSTokenizer_consume_next_input_code_point(v3, &v79);
        UniChar chars = v79;
        _figCSSTokenizer_consume_next_input_code_point(v3, &v79);
        __int16 v78 = v79;
        CFStringAppendCharacters(Mutable, &chars, 2);
        if (!_figCSSTokenizer_PeekAheadBuffer(v3, 1, &v87, 4uLL, &v76) && v76 >= 1)
        {
          uint64_t v10 = 1;
          do
          {
            if (v87 < 0x30 || v87 > 0x39) {
              break;
            }
            ++v10;
            _figCSSTokenizer_consume_next_input_code_point(v3, &v79);
            UniChar chars = v79;
            CFStringAppendCharacters(Mutable, &chars, 1);
            if (_figCSSTokenizer_PeekAheadBuffer(v3, 1, &v87, 4uLL, &v76)) {
              break;
            }
          }
          while (v76 > 0);
        }
        *((void *)&v83 + 1) = v10;
        unsigned int v9 = 1;
      }
    }
    else
    {
      uint64_t v10 = 0;
      unsigned int v9 = 0;
    }
  }
  uint64_t v12 = 0;
  CFRange v73 = a2;
  if (_figCSSTokenizer_PeekAheadBuffer(v3, 3, &v87, 0xCuLL, &v76) || v76 < 1) {
    goto LABEL_64;
  }
  if (v87 != 69 && v87 != 101) {
    goto LABEL_65;
  }
  if ((unint64_t)v76 >= 3)
  {
    unsigned int v14 = v88;
    if ((v88 == 43 || v88 == 45) && v89 >= 0x30 && v89 <= 0x39)
    {
      uint64_t v15 = 1;
      *((void *)&v84 + 1) = 1;
      v85.length = 1;
      *((void *)&v86 + 1) = 1;
      _figCSSTokenizer_consume_next_input_code_point(v3, &v79);
      UniChar chars = v79;
      _figCSSTokenizer_consume_next_input_code_point(v3, &v79);
      __int16 v78 = v79;
      CFIndex v16 = 3;
      uint64_t v17 = 2;
      goto LABEL_53;
    }
    goto LABEL_50;
  }
  if (v76 == 2)
  {
    unsigned int v14 = v88;
LABEL_50:
    uint64_t v12 = 0;
    if (v14 >= 0x30)
    {
      uint64_t v15 = 0;
      if (v14 > 0x39) {
        goto LABEL_66;
      }
      uint64_t v17 = 1;
      *((void *)&v84 + 1) = 1;
      *((void *)&v86 + 1) = 1;
      _figCSSTokenizer_consume_next_input_code_point(v3, &v79);
      uint64_t v15 = 0;
      UniChar chars = v79;
      CFIndex v16 = 2;
LABEL_53:
      _figCSSTokenizer_consume_next_input_code_point(v3, &v79);
      *(&chars + v17) = v79;
      CFStringAppendCharacters(Mutable, &chars, v16);
      uint64_t v12 = 1;
      unsigned int v9 = 1;
      if (!_figCSSTokenizer_PeekAheadBuffer(v3, 1, &v87, 4uLL, &v76) && v76 >= 1)
      {
        uint64_t v12 = 1;
        do
        {
          if (v87 < 0x30 || v87 > 0x39) {
            break;
          }
          ++v12;
          _figCSSTokenizer_consume_next_input_code_point(v3, &v79);
          UniChar chars = v79;
          CFStringAppendCharacters(Mutable, &chars, 1);
          if (_figCSSTokenizer_PeekAheadBuffer(v3, 1, &v87, 4uLL, &v76)) {
            break;
          }
        }
        while (v76 > 0);
        *((void *)&v86 + 1) = v12;
        unsigned int v9 = 1;
      }
      goto LABEL_66;
    }
LABEL_64:
    uint64_t v15 = 0;
    goto LABEL_66;
  }
LABEL_65:
  uint64_t v12 = 0;
  uint64_t v15 = 0;
LABEL_66:
  CFIndex v69 = v15;
  CFIndex v71 = v10;
  CFStringRef v19 = Mutable;
  uint64_t v20 = 0;
  CFIndex v21 = 0;
  do
  {
    uint64_t v22 = *(CFIndex *)((char *)&v80.length + v20);
    if (v22)
    {
      *(CFIndex *)((char *)&v80.location + v20) = v21;
      v21 += v22;
    }
    v20 += 16;
  }
  while (v20 != 112);
  CFIndex v70 = v12;
  CFRange v72 = (const void *)v3;
  if (*(unsigned char *)(v3 + 25)) {
    BOOL v23 = v7 <= 0;
  }
  else {
    BOOL v23 = 1;
  }
  if (!v23)
  {
    CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"repr: %@", Mutable);
    if (v25) {
      CFRelease(v25);
    }
    uint64_t v26 = 0;
    p_length = &v80.length;
    do
    {
      uint64_t v28 = *(p_length - 1);
      if ((v28 & 0x8000000000000000) == 0)
      {
        CFIndex v29 = *p_length;
        CFStringRef v30 = CFStringCreateWithSubstring(v24, v19, *(CFRange *)(p_length - 1));
        CFStringRef v31 = v30;
        if (v30) {
          CFAllocatorRef v32 = (__CFString *)v30;
        }
        else {
          CFAllocatorRef v32 = &stru_1EE53F4B8;
        }
        CFStringRef v33 = CFStringCreateWithFormat(v24, 0, @"[%d] {%ld, %ld} : %@", v26, v28, v29, v32);
        if (v33) {
          CFRelease(v33);
        }
        if (v31) {
          CFRelease(v31);
        }
      }
      ++v26;
      p_length += 2;
    }
    while (v26 != 7);
  }
  double v34 = 1.0;
  CFMutableStringRef Mutable = (__CFString *)v19;
  a2 = v73;
  if (v68)
  {
    v92.locatioCFIndex n = v80.location;
    v92.length = range;
    CFStringGetCharacters(v19, v92, buffer);
    if (buffer[0] == 45) {
      double v34 = -1.0;
    }
    else {
      double v34 = 1.0;
    }
  }
  double v35 = 0.0;
  double v36 = 0.0;
  uint64_t v3 = (uint64_t)v72;
  if (v7 >= 1)
  {
    CFIndex v37 = v81;
    CFAllocatorRef v38 = CFGetAllocator(v72);
    v93.locatioCFIndex n = v37;
    v93.length = v7;
    CFStringRef v39 = CFStringCreateWithSubstring(v38, v19, v93);
    if (v39)
    {
      CFStringRef v40 = v39;
      IntCFDictionaryRef Value = CFStringGetIntValue(v39);
      CFRelease(v40);
      double v36 = (double)IntValue;
    }
  }
  if (v71 >= 1
    && (CFIndex v42 = v83,
        CFAllocatorRef v43 = CFGetAllocator(v72),
        v94.locatioCFIndex n = v42,
        v94.length = v71,
        (CFStringRef v44 = CFStringCreateWithSubstring(v43, v19, v94)) != 0))
  {
    CFStringRef v45 = v44;
    SInt32 v46 = CFStringGetIntValue(v44);
    int Length = CFStringGetLength(v45);
    CFRelease(v45);
    double v35 = (double)v46;
  }
  else
  {
    int Length = 0;
  }
  v48.length = v69;
  if (v69 < 1)
  {
    double v49 = 1.0;
  }
  else
  {
    v48.locatioCFIndex n = v85.location;
    CFStringGetCharacters(v19, v48, buffer);
    if (buffer[0] == 45) {
      double v49 = -1.0;
    }
    else {
      double v49 = 1.0;
    }
  }
  double v50 = 0.0;
  if (v70 >= 1)
  {
    CFIndex v51 = v86;
    CFAllocatorRef v52 = CFGetAllocator(v72);
    v95.locatioCFIndex n = v51;
    v95.length = v70;
    CFStringRef v53 = CFStringCreateWithSubstring(v52, v19, v95);
    if (v53)
    {
      CFStringRef v54 = v53;
      SInt32 v55 = CFStringGetIntValue(v53);
      CFRelease(v54);
      double v50 = (double)v55;
    }
  }
  double v56 = v34 * (v36 + v35 * __exp10((double)-Length));
  double v57 = __exp10(v49 * v50) * v56;
LABEL_106:
  _figCSSTokenizer_PeekAheadBuffer(v3, 3, (_DWORD *)(v3 + 72), 0xCuLL, (uint64_t *)(v3 + 64));
  uint64_t v58 = *(void *)(v3 + 64);
  if (v58 < 3)
  {
    if (v58 < 1) {
      goto LABEL_115;
    }
    unsigned int v59 = *(_DWORD *)(v3 + 72);
  }
  else
  {
    unsigned int v59 = *(_DWORD *)(v3 + 72);
    if (_figCSSTokenizer_check_if_three_code_points_would_start_an_identifier(v59, *(_DWORD *)(v3 + 76), *(_DWORD *)(v3 + 80)))
    {
      _figCSSTokenizer_consume_a_name(v3, &v74);
      CFAllocatorRef v60 = CFGetAllocator((CFTypeRef)v3);
      __int16 v61 = v74;
      uint64_t v62 = FigCSSDimensionTokenCreate(v60, (uint64_t)Mutable, v9, v74, &cf, v57);
      if (v62) {
        goto LABEL_109;
      }
LABEL_117:
      uint64_t v63 = 0;
      *a2 = cf;
      CFTypeRef cf = 0;
      goto LABEL_118;
    }
  }
  if (v59 == 37)
  {
    _figCSSTokenizer_consume_next_input_code_point(v3, 0);
    CFAllocatorRef v64 = CFGetAllocator((CFTypeRef)v3);
    uint64_t v62 = FigCSSPercentageTokenCreate(v64, (uint64_t)Mutable, v9, &cf, v57);
    goto LABEL_116;
  }
LABEL_115:
  CFAllocatorRef v65 = CFGetAllocator((CFTypeRef)v3);
  uint64_t v62 = FigCSSNumberTokenCreate(v65, (uint64_t)Mutable, v9, &cf, v57);
LABEL_116:
  __int16 v61 = 0;
  if (!v62) {
    goto LABEL_117;
  }
LABEL_109:
  uint64_t v63 = v62;
  if (cf) {
    CFRelease(cf);
  }
LABEL_118:
  if (v61) {
    CFRelease(v61);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v63;
}

uint64_t _figCSSTokenizer_consume_an_ident_like_token(const void *a1, void *a2)
{
  CFTypeRef cf = 0;
  CFTypeRef v16 = 0;
  uint64_t v4 = _figCSSTokenizer_consume_a_name((uint64_t)a1, (__CFString **)&v16);
  if (v4)
  {
    uint64_t v8 = v4;
    goto LABEL_18;
  }
  CFStringRef v5 = (const __CFString *)v16;
  if (!v16)
  {
    CFTypeRef v9 = 0;
LABEL_17:
    uint64_t v8 = 0;
    *a2 = v9;
    CFTypeRef cf = 0;
    goto LABEL_18;
  }
  uint64_t v13 = 0;
  _figCSSTokenizer_PeekAheadBuffer((uint64_t)a1, 1, &v14, 4uLL, &v13);
  if (CFStringCompare(v5, @"url", 1uLL) || v13 < 1)
  {
    if (v13 < 1) {
      goto LABEL_14;
    }
    int v6 = v14;
  }
  else
  {
    int v6 = v14;
    if (v14 == 40)
    {
      _figCSSTokenizer_consume_next_input_code_point((uint64_t)a1, 0);
      uint64_t v7 = FigSignalErrorAt();
      if (v7) {
        goto LABEL_7;
      }
      goto LABEL_16;
    }
  }
  if (v6 == 40)
  {
    _figCSSTokenizer_consume_next_input_code_point((uint64_t)a1, 0);
    CFAllocatorRef v10 = CFGetAllocator(a1);
    int v11 = 32;
    goto LABEL_15;
  }
LABEL_14:
  CFAllocatorRef v10 = CFGetAllocator(a1);
  int v11 = 7;
LABEL_15:
  uint64_t v7 = FigCSSStringValueTokenCreate(v10, v11, v5, &cf);
  if (!v7)
  {
LABEL_16:
    CFTypeRef v9 = cf;
    goto LABEL_17;
  }
LABEL_7:
  uint64_t v8 = v7;
  if (cf) {
    CFRelease(cf);
  }
LABEL_18:
  if (v16) {
    CFRelease(v16);
  }
  return v8;
}

uint64_t _figCSSTokenizer_PeekAheadBuffer(uint64_t a1, uint64_t a2, _DWORD *a3, unint64_t a4, uint64_t *a5)
{
  if (a4 > 4 * a2) {
    return 4294949487;
  }
  uint64_t v7 = a3;
  CFIndex v9 = *(void *)(a1 + 40) - (*(unsigned char *)(a1 + 56) != 0) + 1;
  CFIndex v10 = *(void *)(a1 + 48) - v9;
  if (a2 >= 1)
  {
    int v11 = a3;
    uint64_t v12 = a2;
    do
    {
      *v11++ = 0;
      --v12;
    }
    while (v12);
  }
  if (v10 >= a2) {
    uint64_t v13 = a2;
  }
  else {
    uint64_t v13 = v10;
  }
  if (v13 <= 0)
  {
    if (!a5) {
      return 0;
    }
LABEL_25:
    uint64_t CharactersForRange = 0;
    *a5 = v13;
    return CharactersForRange;
  }
  if ((unint64_t)v13 < 4)
  {
    int v14 = (UniChar *)&v19;
LABEL_18:
    v21.locatioCFIndex n = v9;
    v21.length = v13;
    uint64_t CharactersForRange = FigTextContainerGetCharactersForRange(*(void *)(a1 + 16), v21, v14);
    if (!CharactersForRange)
    {
      CFTypeRef v16 = v14;
      uint64_t v17 = v13;
      do
      {
        int v18 = *v16++;
        *v7++ = v18;
        --v17;
      }
      while (v17);
    }
    if ((unint64_t)v13 >= 4) {
      free(v14);
    }
    if (!a5 || CharactersForRange) {
      return CharactersForRange;
    }
    goto LABEL_25;
  }
  int v14 = (UniChar *)malloc_type_calloc(2uLL, v13, 0x236E3B9FuLL);
  if (v14) {
    goto LABEL_18;
  }

  return FigSignalErrorAt();
}

BOOL FigCSSCodePointIs_hex_digit(unsigned int a1)
{
  if (a1 >= 0x30 && a1 <= 0x39) {
    return 1;
  }
  if (a1 >= 0x41 && a1 <= 0x46) {
    return 1;
  }
  return a1 >= 0x61 && a1 <= 0x66;
}

BOOL FigCSSCodePointIs_name_start_code_point(unsigned int a1)
{
  BOOL v1 = a1 >= 0x41 && a1 <= 0x5A;
  if (!v1 && (a1 <= 0x7A ? (BOOL v2 = a1 < 0x61) : (BOOL v2 = 1), v2 ? (v3 = a1 < 0x80) : (v3 = 0), v3)) {
    return a1 == 95;
  }
  else {
    return 1;
  }
}

uint64_t _figCSSTokenizer_consume_an_escaped_code_point(uint64_t a1, int *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  int v4 = 65533;
  unsigned int v31 = 65533;
  uint64_t v30 = 0;
  uint64_t v28 = 0;
  uint64_t result = _figCSSTokenizer_consume_next_input_code_point(a1, &v31);
  if ((v31 < 0x30 || v31 > 0x39) && (v31 < 0x41 || v31 > 0x46) && (v31 < 0x61 || v31 > 0x66))
  {
    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      if (*(void *)(a1 + 40) >= v9) {
        int v4 = 65533;
      }
      else {
        int v4 = v31;
      }
    }
    goto LABEL_70;
  }
  unsigned int v32 = v31;
  _figCSSTokenizer_PeekAheadBuffer(a1, 5, v33, 0x14uLL, &v30);
  uint64_t v10 = v30;
  if (v30 >= 5) {
    uint64_t v10 = 5;
  }
  if (v10 < 1)
  {
    uint64_t v17 = 1;
  }
  else
  {
    uint64_t v11 = 1;
    while (1)
    {
      unsigned int v12 = v33[v11 - 1];
      if ((v12 < 0x30 || v12 > 0x39) && (v12 < 0x41 || v12 > 0x46) && (v12 < 0x61 || v12 > 0x66)) {
        break;
      }
      uint64_t v17 = v11 + 1;
      _figCSSTokenizer_consume_next_input_code_point(a1, 0);
      uint64_t v16 = v30;
      if (v30 >= 5) {
        uint64_t v16 = 5;
      }
      BOOL v23 = v11++ < v16;
      if (!v23) {
        goto LABEL_39;
      }
    }
    uint64_t v17 = v11;
  }
LABEL_39:
  uint64_t result = _figCSSTokenizer_PeekAheadBuffer(a1, 1, &v29, 4uLL, &v28);
  if (!result && v28 >= 1 && (v29 == 10 || v29 == 9 || v29 == 32)) {
    uint64_t result = _figCSSTokenizer_consume_next_input_code_point(a1, 0);
  }
  unsigned int v18 = 0;
  char v19 = &v32;
  int v4 = 65533;
  while (1)
  {
    unsigned int v21 = *v19++;
    unsigned int v20 = v21;
    v18 *= 16;
    unsigned int v22 = v21 - 48;
    BOOL v23 = v21 < 0x30 || v20 > 0x39;
    if (!v23) {
      goto LABEL_61;
    }
    unsigned int v24 = v20 - 65;
    if (v20 < 0x41 || v20 > 0x46)
    {
      unsigned int v24 = v20 - 97;
      if (v20 < 0x61 || v20 > 0x66) {
        break;
      }
    }
    unsigned int v22 = v24 + 10;
LABEL_61:
    v18 += v22;
    if (!--v17)
    {
      if (!v18) {
        goto LABEL_70;
      }
      goto LABEL_63;
    }
  }
  uint64_t result = FigSignalErrorAt();
  if (!v18) {
    goto LABEL_70;
  }
LABEL_63:
  BOOL v27 = v18 > 0xD8FF || v18 < 0xD800;
  if (v27 && v18 <= 0x10FFFF) {
    int v4 = v18;
  }
LABEL_70:
  *a2 = v4;
  return result;
}

uint64_t FigSampleBufferAudioDeviceRendererProtocolGetProtocolID()
{
  return sFigSampleBufferAudioDeviceRendererProtocolID;
}

uint64_t registerFigSampleBufferAudioDeviceRendererProtocolType()
{
  return MEMORY[0x1F40DC660](&sFigSampleBufferAudioDeviceRendererProtocolDesc, 0, &sFigSampleBufferAudioDeviceRendererProtocolID);
}

void FigVideoCompositionInstructionGetNormalizedTime(const __CFDictionary *a1, CMTime *a2)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"StartTime");
  CMTimeMakeFromDictionary(&v11, Value);
  CFDictionaryRef v5 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"EndTime");
  CMTimeMakeFromDictionary(&v10, v5);
  CMTime lhs = v10;
  CMTime rhs = v11;
  CMTimeSubtract(&v9, &lhs, &rhs);
  CMTime rhs = *a2;
  CMTime v6 = v11;
  CMTimeSubtract(&lhs, &rhs, &v6);
  CMTime rhs = lhs;
  CMTimeGetSeconds(&rhs);
  CMTime rhs = v9;
  CMTimeGetSeconds(&rhs);
}

float FigVideoCompositionInstructionEvaluateTweenedOpacity(const void *a1, float a2)
{
  float v2 = 0.0;
  if (a1)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
      if (Count >= 4)
      {
        CFIndex v7 = Count;
        if ((Count & 1) == 0)
        {
          uint64_t v15 = 0;
          uint64_t valuePtr = 0;
          CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 0);
          CFNumberGetValue(ValueAtIndex, kCFNumberFloat32Type, (char *)&valuePtr + 4);
          CFNumberRef v9 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 1);
          CFNumberGetValue(v9, kCFNumberFloat32Type, (char *)&v15 + 4);
          if (*((float *)&valuePtr + 1) <= a2)
          {
            CFIndex v10 = 2;
            while (1)
            {
              CFNumberRef v11 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, v10);
              CFNumberGetValue(v11, kCFNumberFloat32Type, &valuePtr);
              CFIndex v12 = v10 + 1;
              CFNumberRef v13 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, v12);
              CFNumberGetValue(v13, kCFNumberFloat32Type, &v15);
              if (*(float *)&valuePtr > a2) {
                break;
              }
              HIDWORD(valuePtr) = valuePtr;
              float v2 = *(float *)&v15;
              HIDWORD(v15) = v15;
              CFIndex v10 = v12 + 1;
              if (v10 >= v7) {
                return v2;
              }
            }
            return *((float *)&v15 + 1)
                 + (float)((float)((float)(*(float *)&v15 - *((float *)&v15 + 1))
                                 * (float)(a2 - *((float *)&valuePtr + 1)))
                         / (float)(*(float *)&valuePtr - *((float *)&valuePtr + 1)));
          }
          else
          {
            return *((float *)&v15 + 1);
          }
        }
      }
    }
  }
  return v2;
}

void FigVideoCompositionInstructionEvaluateTweenedAffineMatrix(const __CFArray *a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  memset(&v34, 0, sizeof(v34));
  memset(&v33, 0, sizeof(v33));
  if (a1
    && (CFTypeID v6 = CFGetTypeID(a1), v6 == CFArrayGetTypeID())
    && (CFIndex Count = CFArrayGetCount(a1), Count >= 4)
    && (CFIndex v8 = Count, (Count & 1) == 0))
  {
    uint64_t valuePtr = 0;
    CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 0);
    CFNumberGetValue(ValueAtIndex, kCFNumberFloat32Type, (char *)&valuePtr + 4);
    CFArrayRef v10 = (const __CFArray *)CFArrayGetValueAtIndex(a1, 1);
    FigGetCGAffineTransformFrom3x2MatrixArray(v10, &v34.a);
    if (*((float *)&valuePtr + 1) <= a3)
    {
      CFIndex v15 = 2;
      while (1)
      {
        CFNumberRef v16 = (const __CFNumber *)CFArrayGetValueAtIndex(a1, v15);
        CFNumberGetValue(v16, kCFNumberFloat32Type, &valuePtr);
        CFIndex v17 = v15 + 1;
        CFArrayRef v18 = (const __CFArray *)CFArrayGetValueAtIndex(a1, v17);
        FigGetCGAffineTransformFrom3x2MatrixArray(v18, &v33.a);
        if (*(float *)&valuePtr > a3) {
          break;
        }
        HIDWORD(valuePtr) = valuePtr;
        CGAffineTransform v34 = v33;
        CFIndex v15 = v17 + 1;
        if (v15 >= v8)
        {
          long long v19 = *(_OWORD *)&v33.c;
          *(_OWORD *)a2 = *(_OWORD *)&v33.a;
          *(_OWORD *)(a2 + 16) = v19;
          long long v12 = *(_OWORD *)&v33.tx;
          goto LABEL_8;
        }
      }
      float v20 = a3 - *((float *)&valuePtr + 1);
      float v21 = *(float *)&valuePtr - *((float *)&valuePtr + 1);
      long long v38 = *(_OWORD *)&v34.a;
      __x[0] = *(_OWORD *)&v34.c;
      __x[1] = *(_OWORD *)&v34.tx;
      CGAffineTransform v37 = v33;
      vci_CGAffineTransformDecompose((uint64_t)&v38, (uint64_t)&v40, 1, 1);
      vci_CGAffineTransformDecompose((uint64_t)&v37, (uint64_t)&v38, 1, 1);
      if ((v40 >= 0.0 || *((double *)&v38 + 1) >= 0.0) && (v41 >= 0.0 || *(double *)&v38 >= 0.0))
      {
        double v22 = v42;
      }
      else
      {
        CGFloat v40 = -v40;
        double v41 = -v41;
        double v22 = v42 + dbl_194998810[v42 < 0.0];
      }
      float v23 = v20 / v21;
      double v24 = fmod(v22, 6.28318531);
      double v42 = v24;
      double v25 = fmod(*(long double *)__x, 6.28318531);
      *(double *)__CGFloat x = v25;
      if (vabdd_f64(v24, v25) > 3.14159265)
      {
        BOOL v26 = v24 <= v25;
        if (v24 > v25) {
          double v25 = v24;
        }
        BOOL v27 = (CGFloat *)&v38;
        if (!v26) {
          BOOL v27 = &v40;
        }
        v27[2] = v25 + -6.28318531;
      }
      for (uint64_t i = 0; i != 72; i += 8)
        *(CGFloat *)((char *)&v40 + i) = *(CGFloat *)((char *)&v40 + i)
                                       + v23 * (*(double *)((char *)&__x[-1] + i) - *(CGFloat *)((char *)&v40 + i));
      long long v29 = v44;
      *(_OWORD *)a2 = v43;
      *(_OWORD *)(a2 + 16) = v29;
      *(_OWORD *)(a2 + 32) = v45;
      long long v30 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)&v37.a = *(_OWORD *)a2;
      *(_OWORD *)&v37.c = v30;
      *(_OWORD *)&v37.tCGFloat x = *(_OWORD *)(a2 + 32);
      CGAffineTransformRotate((CGAffineTransform *)a2, &v37, v42);
      long long v31 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)&v36.a = *(_OWORD *)a2;
      *(_OWORD *)&v36.c = v31;
      *(_OWORD *)&v36.tCGFloat x = *(_OWORD *)(a2 + 32);
      CGAffineTransformScale(&v37, &v36, v40, v41);
      long long v32 = *(_OWORD *)&v37.c;
      *(_OWORD *)a2 = *(_OWORD *)&v37.a;
      *(_OWORD *)(a2 + 16) = v32;
      long long v12 = *(_OWORD *)&v37.tx;
    }
    else
    {
      long long v11 = *(_OWORD *)&v34.c;
      *(_OWORD *)a2 = *(_OWORD *)&v34.a;
      *(_OWORD *)(a2 + 16) = v11;
      long long v12 = *(_OWORD *)&v34.tx;
    }
  }
  else
  {
    uint64_t v13 = MEMORY[0x1E4F1DAB8];
    long long v14 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *(_OWORD *)a2 = *MEMORY[0x1E4F1DAB8];
    *(_OWORD *)(a2 + 16) = v14;
    long long v12 = *(_OWORD *)(v13 + 32);
  }
LABEL_8:
  *(_OWORD *)(a2 + 32) = v12;
}

uint64_t FigVideoCompositionInstructionEvaluateTweenedCropRectangle(uint64_t result, float a2)
{
  if (result)
  {
    CFArrayRef v3 = (const __CFArray *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFArrayGetTypeID();
    if (v4 == result)
    {
      uint64_t result = CFArrayGetCount(v3);
      if (result >= 4)
      {
        CFIndex v5 = result;
        if ((result & 1) == 0)
        {
          float valuePtr = 0.0;
          float v16 = 0.0;
          memset(&rect, 0, sizeof(rect));
          memset(&v14, 0, sizeof(v14));
          CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v3, 1);
          CFNumberRef v7 = (const __CFNumber *)CFArrayGetValueAtIndex(v3, 0);
          CFNumberGetValue(v7, kCFNumberFloat32Type, &valuePtr);
          CFTypeID TypeID = CFDictionaryGetTypeID();
          uint64_t result = CFGetTypeID(ValueAtIndex);
          if (TypeID == result)
          {
            uint64_t result = CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)ValueAtIndex, &rect);
            if (result)
            {
              if (valuePtr <= a2)
              {
                for (CFIndex i = 2; i < v5; CFIndex i = v11 + 1)
                {
                  CFNumberRef v10 = (const __CFNumber *)CFArrayGetValueAtIndex(v3, i);
                  CFNumberGetValue(v10, kCFNumberFloat32Type, &v16);
                  CFIndex v11 = i + 1;
                  long long v12 = CFArrayGetValueAtIndex(v3, v11);
                  CFTypeID v13 = CFDictionaryGetTypeID();
                  uint64_t result = CFGetTypeID(v12);
                  if (v13 == result)
                  {
                    uint64_t result = CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)v12, &v14);
                    if (result)
                    {
                      if (v16 > a2) {
                        return result;
                      }
                      float valuePtr = v16;
                      CGRect rect = v14;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t FigVideoCompositionInstructionArrayIsValid(uint64_t result, uint64_t a2, uint64_t a3)
{
  memset(&v26, 0, sizeof(v26));
  if (result)
  {
    CFArrayRef v5 = (const __CFArray *)result;
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 != CFArrayGetTypeID()) {
      return 0;
    }
    CFIndex Count = CFArrayGetCount(v5);
    if (Count)
    {
      CFIndex v8 = Count;
      CFIndex v9 = 0;
      CFIndex v10 = Count - 1;
      while (1)
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v5, v9);
        memset(&v25, 0, sizeof(v25));
        memset(&v24, 0, sizeof(v24));
        if (!ValueAtIndex) {
          break;
        }
        long long v12 = ValueAtIndex;
        CFTypeID TypeID = CFDictionaryGetTypeID();
        if (TypeID != CFGetTypeID(v12)) {
          break;
        }
        CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)v12, @"StartTime");
        if (!Value) {
          break;
        }
        CFIndex v15 = Value;
        CFTypeID v16 = CFDictionaryGetTypeID();
        if (v16 != CFGetTypeID(v15)) {
          break;
        }
        CFDictionaryRef v17 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v12, @"StartTime");
        CMTimeMakeFromDictionary(&v25, v17);
        CFArrayRef v18 = CFDictionaryGetValue((CFDictionaryRef)v12, @"EndTime");
        if (!v18) {
          break;
        }
        long long v19 = v18;
        CFTypeID v20 = CFDictionaryGetTypeID();
        if (v20 != CFGetTypeID(v19)) {
          break;
        }
        CFDictionaryRef v21 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v12, @"EndTime");
        CMTimeMakeFromDictionary(&v24, v21);
        if (!v9 && (*(unsigned char *)(a2 + 12) & 1) != 0)
        {
          CMTime time1 = v25;
          CMTime v22 = *(CMTime *)a2;
          if (CMTimeCompare(&time1, &v22) > 0) {
            break;
          }
        }
        if (v10 == v9 && (*(unsigned char *)(a3 + 12) & 1) != 0)
        {
          CMTime time1 = v24;
          CMTime v22 = *(CMTime *)a3;
          if (CMTimeCompare(&time1, &v22) < 0) {
            break;
          }
        }
        if (v9)
        {
          CMTime time1 = v26;
          CMTime v22 = v25;
          if (CMTimeCompare(&time1, &v22)) {
            break;
          }
        }
        CMTime time1 = v25;
        CMTime v22 = v24;
        if (CMTimeCompare(&time1, &v22) >= 1) {
          break;
        }
        CMTime v26 = v24;
        ++v9;
        uint64_t result = 1;
        if (v8 == v9) {
          return result;
        }
      }
      return 0;
    }
    return 1;
  }
  return result;
}

double FigVideoCompositionInstructionCGAffineTransformDecompose(_OWORD *a1, int a2, int a3, _OWORD *a4, double *a5, double *a6, double *a7)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  long long v11 = a1[1];
  v14[0] = *a1;
  v14[1] = v11;
  void v14[2] = a1[2];
  double result = vci_CGAffineTransformDecompose((uint64_t)v14, (uint64_t)&v15, a2, a3);
  if (a5)
  {
    double result = v15;
    *a5 = v15;
  }
  if (a6)
  {
    double result = v16;
    *a6 = v16;
  }
  if (a7)
  {
    double result = v17;
    *a7 = v17;
  }
  if (a4)
  {
    long long v13 = v19;
    *a4 = v18;
    a4[1] = v13;
    double result = *(double *)&v20;
    a4[2] = v20;
  }
  return result;
}

double vci_CGAffineTransformDecompose(uint64_t a1, uint64_t a2, int a3, int a4)
{
  double v8 = *(double *)(a1 + 8);
  double v9 = *(double *)(a1 + 16);
  double v10 = *(double *)(a1 + 24);
  double v11 = sqrt(v8 * v8 + *(double *)a1 * *(double *)a1);
  double v12 = sqrt(v10 * v10 + v9 * v9);
  double v13 = *(double *)a1 * v10 - v9 * v8;
  double v14 = -v12;
  double v15 = -v11;
  if (*(double *)a1 < v10) {
    double v14 = v12;
  }
  else {
    double v15 = v11;
  }
  if (v13 < 0.0) {
    double v16 = v15;
  }
  else {
    double v16 = v11;
  }
  if (v13 < 0.0) {
    double v17 = v14;
  }
  else {
    double v17 = v12;
  }
  double v18 = 1.0 / v16;
  double v19 = 0.0;
  if (v16 == 0.0) {
    double v18 = 0.0;
  }
  double v20 = 1.0 / v17;
  if (v17 == 0.0) {
    double v20 = 0.0;
  }
  long long v21 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v31.a = *(_OWORD *)a1;
  *(_OWORD *)&v31.c = v21;
  *(_OWORD *)&v31.tCGFloat x = *(_OWORD *)(a1 + 32);
  CGAffineTransformScale(&v32, &v31, v18, v20);
  long long v22 = *(_OWORD *)&v32.c;
  *(_OWORD *)a1 = *(_OWORD *)&v32.a;
  *(_OWORD *)(a1 + 16) = v22;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v32.tx;
  if (a4)
  {
    double v19 = atan2(*(long double *)(a1 + 8), *(long double *)a1);
    long long v23 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&v31.a = *(_OWORD *)a1;
    *(_OWORD *)&v31.c = v23;
    *(_OWORD *)&v31.tCGFloat x = *(_OWORD *)(a1 + 32);
    CGAffineTransformRotate(&v32, &v31, -v19);
    long long v24 = *(_OWORD *)&v32.c;
    *(_OWORD *)a1 = *(_OWORD *)&v32.a;
    *(_OWORD *)(a1 + 16) = v24;
    *(_OWORD *)(a1 + 32) = *(_OWORD *)&v32.tx;
  }
  if (!a3)
  {
    double v25 = -1.0;
    if (v17 < 0.0) {
      double v26 = -1.0;
    }
    else {
      double v26 = 1.0;
    }
    if (v17 < 0.0 || v16 < 0.0) {
      double v19 = -v19;
    }
    if (v16 >= 0.0) {
      double v25 = 1.0;
    }
    long long v28 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&v31.a = *(_OWORD *)a1;
    *(_OWORD *)&v31.c = v28;
    *(_OWORD *)&v31.tCGFloat x = *(_OWORD *)(a1 + 32);
    CGAffineTransformScale(&v32, &v31, v25, v26);
    long long v29 = *(_OWORD *)&v32.c;
    *(_OWORD *)a1 = *(_OWORD *)&v32.a;
    *(_OWORD *)(a1 + 16) = v29;
    *(_OWORD *)(a1 + 32) = *(_OWORD *)&v32.tx;
    double v16 = fabs(v16);
    double v17 = fabs(v17);
  }
  *(double *)a2 = v16;
  *(double *)(a2 + 8) = v17;
  *(double *)(a2 + 16) = v19;
  *(void *)(a2 + 24) = *(void *)a1;
  *(void *)(a2 + 32) = *(void *)(a1 + 8);
  *(void *)(a2 + 40) = *(void *)(a1 + 16);
  *(void *)(a2 + 48) = *(void *)(a1 + 24);
  *(void *)(a2 + 56) = *(void *)(a1 + 32);
  double result = *(double *)(a1 + 40);
  *(double *)(a2 + 64) = result;
  return result;
}

uint64_t FigVideoCompositionInstructionCopyRequiredTrackIDArrayForTime(const __CFAllocator *a1, CFTypeRef cf, CMTime *a3, __CFArray **a4)
{
  int v41 = 0;
  if (cf)
  {
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 == CFDictionaryGetTypeID())
    {
      if (a4)
      {
        double v9 = (const void *)*MEMORY[0x1E4F1CFD0];
        CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"ContainsTweening");
        float v11 = 0.0;
        if (v9 == Value)
        {
          CMTime v40 = *a3;
          FigVideoCompositionInstructionGetNormalizedTime((const __CFDictionary *)cf, &v40);
          float v11 = v12;
        }
        FigCFDictionaryGetInt32IfPresent();
        CFArrayRef v13 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, @"LayerStack");
        double v14 = CFDictionaryGetValue((CFDictionaryRef)cf, @"RequiredVideoTrackIDArray");
        if (v41)
        {
          CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
          if (Mutable)
          {
            MutableCFStringRef Copy = Mutable;
            FigCFArrayAppendInt32();
            goto LABEL_35;
          }
        }
        else
        {
          double v17 = v14;
          if (v13 && (CFTypeID v18 = CFGetTypeID(v13), v18 == CFArrayGetTypeID()))
          {
            CFMutableArrayRef v19 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
            if (v19)
            {
              MutableCFStringRef Copy = v19;
              CFIndex Count = CFArrayGetCount(v13);
              if (Count >= 1)
              {
                CFIndex v21 = Count;
                CFStringRef v39 = a4;
                CFIndex v22 = 0;
                long long v23 = @"ConstantOpacity";
                while (1)
                {
                  LODWORD(v40.value) = 1065353216;
                  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, v22);
                  if (!ValueAtIndex) {
                    break;
                  }
                  CFDictionaryRef v25 = ValueAtIndex;
                  CFTypeID v26 = CFGetTypeID(ValueAtIndex);
                  if (v26 != CFDictionaryGetTypeID()) {
                    break;
                  }
                  if (!FigCFDictionaryGetFloatIfPresent()) {
                    LODWORD(v40.value) = 1065353216;
                  }
                  if (v9 == Value
                    && (CGAffineTransform v31 = CFDictionaryGetValue(v25, @"TweenedOpacity")) != 0
                    && (CGAffineTransform v32 = v31, v33 = v23, v34 = CFGetTypeID(v31), v35 = v34 == CFArrayGetTypeID(), v23 = v33, v35))
                  {
                    float v27 = FigVideoCompositionInstructionEvaluateTweenedOpacity(v32, v11);
                    *(float *)&v40.CMTimeValue value = v27;
                  }
                  else
                  {
                    float v27 = *(float *)&v40.value;
                  }
                  if (v27 > 0.0)
                  {
                    long long v28 = CFDictionaryGetValue(v25, @"SourceVideoTrackID");
                    if (!v28) {
                      break;
                    }
                    long long v29 = v28;
                    CFTypeID v30 = CFGetTypeID(v28);
                    if (v30 != CFNumberGetTypeID()) {
                      break;
                    }
                    CFArrayAppendValue(MutableCopy, v29);
                  }
                  if (v21 == ++v22)
                  {
                    a4 = v39;
                    goto LABEL_35;
                  }
                }
                uint64_t v37 = FigSignalErrorAt();
                CFRelease(MutableCopy);
                return v37;
              }
              goto LABEL_35;
            }
          }
          else
          {
            if (!v17 || (CFTypeID v36 = CFGetTypeID(v17), v36 != CFArrayGetTypeID()))
            {
              MutableCFStringRef Copy = 0;
              goto LABEL_35;
            }
            MutableCFStringRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFArrayRef)v17);
            if (MutableCopy)
            {
LABEL_35:
              uint64_t v37 = 0;
              *a4 = MutableCopy;
              return v37;
            }
          }
        }
        return FigSignalErrorAt();
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t FigVideoCompositionInstructionCopyRequiredSampleDataTrackIDArrayForTime(int a1, CFTypeRef cf, uint64_t a3, const __CFArray **a4)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFDictionaryGetTypeID())
    {
      if (a4)
      {
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, @"RequiredSampleDataTrackIDArray");
        if (Value)
        {
          CFArrayRef v8 = Value;
          CFTypeID v9 = CFGetTypeID(Value);
          if (v9 == CFArrayGetTypeID())
          {
            CFArrayRef Value = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v8);
            if (!Value) {
              goto LABEL_10;
            }
          }
          else
          {
            CFArrayRef Value = 0;
          }
        }
        *a4 = Value;
        return 0;
      }
    }
  }
LABEL_10:

  return FigSignalErrorAt();
}

uint64_t FigVideoCompositionInstructionGetLayerCountExcludingBackground(const void *a1, CFIndex *a2)
{
  if (!a1 || (CFTypeID v4 = CFGetTypeID(a1), v4 != CFDictionaryGetTypeID()) || !a2)
  {
    uint64_t result = FigSignalErrorAt();
    goto LABEL_12;
  }
  FigCFDictionaryGetInt32IfPresent();
  CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"LayerStack");
  CFTypeID v6 = CFDictionaryGetValue((CFDictionaryRef)a1, @"RequiredVideoTrackIDArray");
  if (!Value || (CFTypeID v7 = CFGetTypeID(Value), v7 != CFArrayGetTypeID()))
  {
    if (v6)
    {
      CFTypeID v9 = CFGetTypeID(v6);
      if (v9 == CFArrayGetTypeID())
      {
        CFArrayRef v8 = (const __CFArray *)v6;
        goto LABEL_10;
      }
    }
    uint64_t result = 0;
LABEL_12:
    CFIndex Count = 0;
    goto LABEL_13;
  }
  CFArrayRef v8 = (const __CFArray *)Value;
LABEL_10:
  CFIndex Count = CFArrayGetCount(v8);
  uint64_t result = 0;
LABEL_13:
  *a2 = Count;
  return result;
}

uint64_t FigVirtualDisplayProcessorAccessoryCreate(uint64_t a1, uint64_t a2, void *a3)
{
  FigVirtualDisplayProcessorGetClassID();
  uint64_t v4 = CMDerivedObjectCreate();
  if (v4)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  else
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    *(_DWORD *)(DerivedStorage + 32) = 0;
    *(void *)(DerivedStorage + 8) = dispatch_semaphore_create(0);
    *(void *)uint64_t DerivedStorage = dispatch_queue_create("FVDProcessorAccessoryQueue", 0);
    *a3 = 0;
  }
  return v4;
}

void pa_finalize(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(_DWORD *)(DerivedStorage + 32))
  {
    int v11 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  CFArrayRef v3 = *(NSObject **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __pa_finalize_block_invoke;
    block[3] = &__block_descriptor_tmp_80;
    block[4] = a1;
    dispatch_sync(v3, block);
    if (*(void *)DerivedStorage)
    {
      dispatch_release(*(dispatch_object_t *)DerivedStorage);
      *(void *)uint64_t DerivedStorage = 0;
    }
  }
  uint64_t v4 = *(NSObject **)(DerivedStorage + 8);
  if (v4)
  {
    dispatch_release(v4);
    *(void *)(DerivedStorage + 8) = 0;
  }
  CFArrayRef v5 = *(const void **)(DerivedStorage + 24);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(DerivedStorage + 24) = 0;
  }
  CFTypeID v6 = *(const void **)(DerivedStorage + 16);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(DerivedStorage + 16) = 0;
  }
  CFTypeID v7 = *(const void **)(DerivedStorage + 48);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(DerivedStorage + 48) = 0;
  }
}

uint64_t pa_copyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, @"processorType"))
  {
    CFTypeID v7 = @"AccessoryProcessor";
LABEL_7:
    CFTypeRef v9 = CFRetain(v7);
    uint64_t result = 0;
    *a4 = v9;
    return result;
  }
  if (CFEqual(a2, @"IsIdle"))
  {
    CFArrayRef v8 = (__CFString **)MEMORY[0x1E4F1CFC8];
    if (*(_DWORD *)(DerivedStorage + 32) != 2) {
      CFArrayRef v8 = (__CFString **)MEMORY[0x1E4F1CFD0];
    }
    CFTypeID v7 = *v8;
    goto LABEL_7;
  }
  return 4294954512;
}

uint64_t pa_setProperty()
{
  return 4294954512;
}

void __pa_finalize_block_invoke(uint64_t a1)
{
}

void pa_cleanup(const void *a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  DistributedCenter = CFNotificationCenterGetDistributedCenter();
  CFNotificationCenterRemoveObserver(DistributedCenter, a1, 0, 0);
  uint64_t v4 = DerivedStorage[2];
  if (v4)
  {
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v6 = v5 ? v5 : 0;
    CFTypeID v7 = *(void (**)(uint64_t, void))(v6 + 72);
    if (v7) {
      v7(v4, 0);
    }
  }
  uint64_t v8 = DerivedStorage[3];
  if (v8)
  {
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    int v11 = *(void (**)(uint64_t, void))(v10 + 16);
    if (v11) {
      v11(v8, 0);
    }
    uint64_t v12 = (const void *)DerivedStorage[3];
    if (v12)
    {
      CFRelease(v12);
      DerivedStorage[3] = 0;
    }
  }
  CFArrayRef v13 = (const void *)DerivedStorage[6];
  if (v13)
  {
    CFRelease(v13);
    DerivedStorage[6] = 0;
  }
}

uint64_t pa_plugSink(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  int v14 = 0;
  uint64_t DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    uint64_t v4 = *DerivedStorage;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __pa_plugSink_block_invoke;
    block[3] = &unk_1E57A1D28;
    void block[5] = DerivedStorage;
    block[6] = a2;
    block[4] = &v11;
    dispatch_sync(v4, block);
    uint64_t v5 = *((unsigned int *)v12 + 6);
  }
  else
  {
    int v10 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    uint64_t v5 = 4294955226;
    *((_DWORD *)v12 + 6) = -12070;
  }
  _Block_object_dispose(&v11, 8);
  return v5;
}

uint64_t pa_unplugSink(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  uint64_t DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *DerivedStorage;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __pa_unplugSink_block_invoke;
  block[3] = &unk_1E57A1D50;
  void block[5] = DerivedStorage;
  block[6] = a2;
  block[4] = &v8;
  dispatch_sync(v4, block);
  uint64_t v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t pa_start(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  uint64_t v4 = *(NSObject **)CMBaseObjectGetDerivedStorage();
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __pa_start_block_invoke;
  block[3] = &unk_1E57A1D78;
  block[4] = &v8;
  void block[5] = a1;
  block[6] = a2;
  dispatch_sync(v4, block);
  uint64_t v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t pa_stop(uint64_t a1)
{
  uint64_t DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  CFArrayRef v3 = *DerivedStorage;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = __pa_stop_block_invoke;
  v5[3] = &__block_descriptor_tmp_39_1;
  v5[4] = DerivedStorage;
  v5[5] = a1;
  dispatch_sync(v3, v5);
  return 0;
}

uint64_t pa_suspend()
{
  uint64_t DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  BOOL v1 = *DerivedStorage;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __pa_suspend_block_invoke;
  block[3] = &__block_descriptor_tmp_40_2;
  block[4] = DerivedStorage;
  dispatch_sync(v1, block);
  return 0;
}

uint64_t pa_resume()
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  int v8 = 0;
  uint64_t DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  BOOL v1 = *DerivedStorage;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = __pa_resume_block_invoke;
  v4[3] = &unk_1E57A1E28;
  v4[4] = &v5;
  v4[5] = DerivedStorage;
  dispatch_sync(v1, v4);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

CFTypeRef *__pa_plugSink_block_invoke(CFTypeRef *result)
{
  BOOL v1 = result;
  uint64_t v2 = result[5];
  if (v2[8] || *((void *)v2 + 2))
  {
    *(_DWORD *)(*((void *)result[4] + 1) + 24) = -12070;
  }
  else
  {
    uint64_t result = (CFTypeRef *)CFRetain(result[6]);
    *((void *)v1[5] + 2) = v1[6];
  }
  return result;
}

void __pa_unplugSink_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (!*(_DWORD *)(v2 + 32) && (CFArrayRef v3 = *(const void **)(v2 + 16), v3 == (const void *)a1[6]))
  {
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1[5] + 16) = 0;
    }
  }
  else
  {
    *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = -12070;
  }
}

void __pa_start_block_invoke(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(const void **)(a1 + 40);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef v41 = 0;
  if (*(_DWORD *)(DerivedStorage + 32) || (uint64_t v4 = DerivedStorage, !*(void *)(DerivedStorage + 16)))
  {
    LODWORD(cf) = 0;
    v43[0] = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
LABEL_54:
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    int v29 = -12070;
    goto LABEL_34;
  }
  uint64_t v5 = CMBaseObjectGetDerivedStorage();
  CFPreferenceNumberWithuint64_t Default = FigGetCFPreferenceNumberWithDefault();
  *(_DWORD *)(v5 + 36) = CFPreferenceNumberWithDefault;
  if (CFPreferenceNumberWithDefault <= 63)
  {
    CGAffineTransform v32 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    LODWORD(cf) = 0;
    v43[0] = OS_LOG_TYPE_DEFAULT;
    CMTime v40 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
    goto LABEL_54;
  }
  *(_DWORD *)(v5 + 40) = CFPreferenceNumberWithDefault;
  if (!FigGetCFPreferenceNumberWithDefault()) {
    goto LABEL_26;
  }
  CFTypeRef cf = 0;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v8 = getpid();
  CFStringRef v9 = CFStringCreateWithFormat(v7, 0, @"/tmp/vdpaccessory-tap-%d-%d.mov", v8, ++tapSinkCreate_count);
  if (FigVirtualDisplaySinkFileWriterCreate((uint64_t)v7, &cf))
  {
    *(_DWORD *)long long v43 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    CFStringRef v39 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
LABEL_21:
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
    goto LABEL_23;
  }
  uint64_t CMBaseObject = FigVirtualDisplaySinkGetCMBaseObject(cf);
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(unsigned int (**)(uint64_t, __CFString *, CFStringRef))(v12 + 56);
  if (!v13)
  {
    uint64_t v17 = v1;
LABEL_14:
    *(_DWORD *)long long v43 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    CFTypeID v18 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    uint64_t v1 = v17;
    goto LABEL_21;
  }
  if (v13(CMBaseObject, @"Destination", v9))
  {
    uint64_t v17 = v1;
    goto LABEL_14;
  }
  CFTypeRef v14 = cf;
  uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v15) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  CFMutableArrayRef v19 = *(unsigned int (**)(CFTypeRef, void, void))(v16 + 8);
  if (!v19)
  {
    CFStringRef v20 = v9;
    uint64_t v21 = v1;
    goto LABEL_20;
  }
  if (v19(v14, 0, 0))
  {
    CFStringRef v20 = v9;
    uint64_t v21 = v1;
LABEL_20:
    *(_DWORD *)long long v43 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    CFIndex v22 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    uint64_t v1 = v21;
    CFStringRef v9 = v20;
    goto LABEL_21;
  }
LABEL_23:
  if (v9) {
    CFRelease(v9);
  }
  *(void *)(v5 + 24) = cf;
LABEL_26:
  FigGetCFPreferenceDoubleWithDefault();
  *(float *)&double v23 = v23;
  *(_DWORD *)(v5 + 56) = LODWORD(v23);
  v46[0] = 0;
  v46[1] = v46;
  v46[2] = 0x2000000000;
  int v47 = 0;
  uint64_t v24 = CMBaseObjectGetDerivedStorage();
  uint64_t v25 = *(void *)(v24 + 16);
  v45[0] = MEMORY[0x1E4F143A8];
  v45[1] = 0x40000000;
  CFTypeRef v45[2] = __pa_copySinkProperty_block_invoke;
  v45[3] = &unk_1E57A1DA0;
  v45[4] = v46;
  v45[5] = &v41;
  v45[6] = v24;
  uint64_t v26 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v26) {
    uint64_t v27 = v26;
  }
  else {
    uint64_t v27 = 0;
  }
  long long v28 = *(void (**)(uint64_t, __CFString *, void, void *))(v27 + 48);
  if (v28) {
    v28(v25, @"displayInfo", 0, v45);
  }
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v24 + 8), 0xFFFFFFFFFFFFFFFFLL);
  int v29 = *(_DWORD *)(v46[1] + 24);
  _Block_object_dispose(v46, 8);
  if (!v29)
  {
    if (v41)
    {
      FigCFDictionaryGetBooleanIfPresent();
      *(_DWORD *)(v4 + 32) = 2;
      DistributedCenter = CFNotificationCenterGetDistributedCenter();
      CFNotificationCenterAddObserver(DistributedCenter, v2, (CFNotificationCallback)pa_handleNotification, @"com.apple.stevenote.AudioDataValues", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      int v29 = 0;
      goto LABEL_34;
    }
    LODWORD(cf) = 0;
    v43[0] = OS_LOG_TYPE_DEFAULT;
    CFTypeID v36 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int v37 = cf;
    if (os_log_type_enabled(v36, v43[0])) {
      unsigned int v38 = v37;
    }
    else {
      unsigned int v38 = v37 & 0xFFFFFFFE;
    }
    if (v38)
    {
      LODWORD(v46[0]) = 136315394;
      *(void *)((char *)v46 + 4) = "pa_startInternal";
      WORD2(v46[1]) = 1024;
      *(_DWORD *)((char *)&v46[1] + 6) = 463;
      _os_log_send_and_compose_impl();
    }
    goto LABEL_54;
  }
  LODWORD(cf) = 0;
  v43[0] = OS_LOG_TYPE_DEFAULT;
  CGAffineTransform v33 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
  unsigned int v34 = cf;
  if (os_log_type_enabled(v33, v43[0])) {
    unsigned int v35 = v34;
  }
  else {
    unsigned int v35 = v34 & 0xFFFFFFFE;
  }
  if (v35)
  {
    LODWORD(v46[0]) = 136315650;
    *(void *)((char *)v46 + 4) = "pa_startInternal";
    WORD2(v46[1]) = 1024;
    *(_DWORD *)((char *)&v46[1] + 6) = 462;
    WORD1(v46[2]) = 1024;
    HIDWORD(v46[2]) = v29;
    _os_log_send_and_compose_impl();
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose();
LABEL_34:
  if (v41) {
    CFRelease(v41);
  }
  if (v29) {
    pa_cleanup(v2);
  }
  *(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = v29;
}

void pa_handleNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFAllocatorRef v7 = *(NSObject **)CMBaseObjectGetDerivedStorage();
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  int v8[2] = __pa_handleNotification_block_invoke;
  void v8[3] = &__block_descriptor_tmp_26_0;
  v8[4] = a2;
  v8[5] = a5;
  dispatch_sync(v7, v8);
}

intptr_t __pa_copySinkProperty_block_invoke(uint64_t a1, int a2, CFTypeRef cf)
{
  if (!a2)
  {
    if (cf) {
      CFTypeRef v5 = CFRetain(cf);
    }
    else {
      CFTypeRef v5 = 0;
    }
    **(void **)(a1 + 40) = v5;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  uint64_t v6 = *(NSObject **)(*(void *)(a1 + 48) + 8);

  return dispatch_semaphore_signal(v6);
}

void __pa_handleNotification_block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 40);
  CMSampleBufferRef sbuf = 0;
  int v5 = 0;
  uint64_t v4 = 0;
  memset(&v3, 0, sizeof(v3));
  if (*(_DWORD *)(CMBaseObjectGetDerivedStorage() + 32) == 2)
  {
    if (v1) {
      FigCFDictionaryGetInt32IfPresent();
    }
    LODWORD(sampleTimingArray.duration.value) = 0;
    LOBYTE(sampleBufferOut) = 0;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (sbuf) {
    CFRelease(sbuf);
  }
}

void __pa_stop_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(const void **)(a1 + 40);
  *(_DWORD *)(v1 + 32) = 0;
  pa_cleanup(v2);
}

uint64_t __pa_suspend_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_DWORD *)(v1 + 32) = 1;
  uint64_t v2 = *(void *)(v1 + 16);
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v6 = *(void *)(VTable + 16);
  uint64_t result = VTable + 16;
  uint64_t v5 = v6;
  if (v6) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, void))(v7 + 56);
  if (v8)
  {
    uint64_t v9 = *MEMORY[0x1E4F1CFD0];
    return v8(v2, @"clearScreen", v9, 0);
  }
  return result;
}

uint64_t __pa_resume_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  if (*(_DWORD *)(v1 + 32) == 1) {
    *(_DWORD *)(v1 + 32) = 2;
  }
  else {
    *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = -12070;
  }
  return result;
}

uint64_t FigCaptionRendererTTMLRegionCreate(void *a1)
{
  *a1 = 0;
  *(void *)&long long v14 = 0;
  MEMORY[0x19970EE10](&FigCaptionRendererTTMLRegionGetClassID_sRegisterFigCaptionRendererTTMLRegionBaseTypeOnce, RegisterFigCaptionRendererTTMLRegionBaseType);
  uint64_t v2 = CMDerivedObjectCreate();
  if (!v2)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    uint64_t v16 = 0;
    FigCaptionRendererNodeCreate(&v16);
    uint64_t v4 = v16;
    *(void *)uint64_t DerivedStorage = v16;
    FigCaptionRendererNodeProtocolGetProtocolID();
    Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
    if (ProtocolVTable)
    {
      uint64_t v6 = *(void *)(ProtocolVTable + 16);
      if (v6)
      {
        uint64_t v7 = *(void (**)(uint64_t, uint64_t))(v6 + 216);
        if (v7) {
          v7(v4, 1);
        }
      }
    }
    uint64_t v8 = *(void *)DerivedStorage;
    FigCaptionRendererNodeProtocolGetProtocolID();
    uint64_t v9 = CMBaseObjectGetProtocolVTable();
    if (v9)
    {
      uint64_t v10 = *(void *)(v9 + 16);
      if (v10)
      {
        uint64_t v11 = *(void (**)(uint64_t, uint64_t))(v10 + 232);
        if (v11) {
          v11(v8, 1);
        }
      }
    }
    FigGeometryDimensionMake();
    FigGeometryDimensionMake();
    FigGeometrySizeMake();
    *(_OWORD *)(DerivedStorage + 176) = v14;
    *(_OWORD *)(DerivedStorage + 192) = v15;
    CFTypeRef v12 = (CFTypeRef)*MEMORY[0x1E4F1F928];
    if (*MEMORY[0x1E4F1F928]) {
      CFTypeRef v12 = CFRetain(v12);
    }
    *(void *)(DerivedStorage + 152) = v12;
    *a1 = 0;
  }
  return v2;
}

uint64_t FigCaptionRendererTTMLRegionSetColor(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2) {
    CFTypeRef v4 = CFRetain(a2);
  }
  else {
    CFTypeRef v4 = 0;
  }
  *(void *)(DerivedStorage + 72) = v4;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetInvisible(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 144) = *MEMORY[0x1E4F1CFD0] == a2;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionGetInvisible(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef v4 = (void *)MEMORY[0x1E4F1CFD0];
  if (!*(unsigned char *)(DerivedStorage + 144)) {
    CFTypeRef v4 = (void *)MEMORY[0x1E4F1CFC8];
  }
  *a2 = *v4;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetWidth(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(void *)(DerivedStorage + 80) = a2;
  *(void *)(DerivedStorage + 88) = a3;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetHeight(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(void *)(DerivedStorage + 96) = a2;
  *(void *)(DerivedStorage + 104) = a3;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetPositionX(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(void *)(DerivedStorage + 112) = a2;
  *(void *)(DerivedStorage + 120) = a3;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetPositionY(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(void *)(DerivedStorage + 128) = a2;
  *(void *)(DerivedStorage + 136) = a3;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetShowBackground(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef v4 = *(const void **)(DerivedStorage + 152);
  *(void *)(DerivedStorage + 152) = a2;
  if (a2) {
    CFRetain(a2);
  }
  if (v4) {
    CFRelease(v4);
  }
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetWritingMode(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef v4 = *(const void **)(DerivedStorage + 160);
  *(void *)(DerivedStorage + 160) = a2;
  if (a2) {
    CFRetain(a2);
  }
  if (v4) {
    CFRelease(v4);
  }
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionGetWritingMode(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2) {
    *a2 = *(void *)(DerivedStorage + 160);
  }
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetCellResolution(uint64_t a1, _OWORD *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  long long v4 = a2[1];
  *(_OWORD *)(DerivedStorage + 176) = *a2;
  *(_OWORD *)(DerivedStorage + 192) = v4;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionGetCellResolution(uint64_t a1, _OWORD *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    long long v4 = *(_OWORD *)(DerivedStorage + 192);
    *a2 = *(_OWORD *)(DerivedStorage + 176);
    a2[1] = v4;
  }
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetClipOverflow(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 145) = *MEMORY[0x1E4F1CFD0] == a2;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetDisplayAlignment(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  long long v4 = *(const void **)(DerivedStorage + 168);
  *(void *)(DerivedStorage + 168) = a2;
  if (a2) {
    CFRetain(a2);
  }
  if (v4) {
    CFRelease(v4);
  }
  return 0;
}

uint64_t FigCaptionRendererTTMLRegionSetDisplayAspectRatio(uint64_t a1, uint64_t a2)
{
  *(void *)(CMBaseObjectGetDerivedStorage() + 208) = a2;
  return 0;
}

void FigCaptionRendererTTMLRegionFinalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = *(const void **)(DerivedStorage + 72);
  if (v1) {
    CFRelease(v1);
  }
  uint64_t v2 = *(const void **)(DerivedStorage + 24);
  if (v2) {
    CFRelease(v2);
  }
  CMTime v3 = *(const void **)(DerivedStorage + 152);
  if (v3) {
    CFRelease(v3);
  }
  long long v4 = *(const void **)(DerivedStorage + 160);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(DerivedStorage + 168);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    CFRelease(v6);
  }
}

__CFString *FigCaptionRendererTTMLRegionCopyDebugDescription(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"\tFigCaptionRendererTTMLRegion: <%p>", a1);
  return Mutable;
}

__CFString *FigCaptionRendererTTMLRegion_FigCaptionRendererBaseProtocol_CopyDebugDescription(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"\tFigCaptionRendererTTMLRegion <FigCaptionRendererBaseProtocol> on <%p>", a1);
  return Mutable;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererBaseProtocol_GetClassName(uint64_t a1, void *a2)
{
  *a2 = "FigCaptionRendererTTMLRegion";
  return 0;
}

__CFString *FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_CopyDebugDescription(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"\tFigCaptionRendererTTMLRegion <FigCaptionRendererNodeProtocol> on <%p>", a1);
  return Mutable;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetParentNode(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 8);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetParentNode(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 16);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetChildren(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 24);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_HasChildNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v7 = *(void *)(ProtocolVTable + 16);
  if (!v7) {
    return 4294954508;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 32);
  if (!v8) {
    return 4294954514;
  }

  return v8(v5, a2, a3);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_AddChildNode(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  __s1 = 0;
  FigCaptionRendererBaseProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable || (uint64_t v5 = *(void *)(ProtocolVTable + 16)) == 0)
  {
    uint64_t v13 = 4294954508;
LABEL_11:
    FigSignalErrorAt();
    return v13;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, char **))(v5 + 8);
  if (!v6)
  {
    uint64_t v13 = 4294954514;
    goto LABEL_11;
  }
  uint64_t v7 = v6(a2, &__s1);
  if (v7)
  {
    uint64_t v13 = v7;
    goto LABEL_11;
  }
  int v8 = strcmp(__s1, "FigCaptionRendererTTMLRegion");
  uint64_t v9 = *(void *)(DerivedStorage + 160);
  if (v8)
  {
    FigCaptionRendererCaptionProtocolGetProtocolID();
    uint64_t v10 = CMBaseObjectGetProtocolVTable();
    if (v10)
    {
      uint64_t v11 = *(void *)(v10 + 16);
      if (v11)
      {
        CFTypeRef v12 = *(void (**)(uint64_t, uint64_t))(v11 + 112);
        if (v12) {
          v12(a2, v9);
        }
      }
    }
  }
  else
  {
    FigCaptionRendererTTMLRegionSetWritingMode(a2, *(const void **)(DerivedStorage + 160));
  }
  uint64_t v15 = *(void *)DerivedStorage;
  FigCaptionRendererNodeProtocolGetProtocolID();
  uint64_t v16 = CMBaseObjectGetProtocolVTable();
  if (!v16) {
    return 4294954508;
  }
  uint64_t v17 = *(void *)(v16 + 16);
  if (!v17) {
    return 4294954508;
  }
  CFTypeID v18 = *(uint64_t (**)(uint64_t, uint64_t))(v17 + 40);
  if (v18) {
    return v18(v15, a2);
  }
  else {
    return 4294954514;
  }
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_RemoveChildNode(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 48);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_RemovelAllChildrenNodes()
{
  uint64_t v0 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v2 = *(void *)(ProtocolVTable + 16);
  if (!v2) {
    return 4294954508;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 56);
  if (!v3) {
    return 4294954514;
  }

  return v3(v0);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetViewport(double a1, double a2, double a3, double a4)
{
  uint64_t v8 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v14 = *(void *)(ProtocolVTable + 16);
  if (!v14) {
    return 4294954508;
  }
  uint64_t v15 = *(uint64_t (**)(uint64_t, __n128, __n128, __n128, __n128))(v14 + 64);
  if (!v15) {
    return 4294954514;
  }
  v10.n128_f64[0] = a1;
  v11.n128_f64[0] = a2;
  v12.n128_f64[0] = a3;
  v13.n128_f64[0] = a4;

  return v15(v8, v10, v11, v12, v13);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetViewport(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 72);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetFCRBounds(uint64_t a1, long long *a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  long long v8 = *a2;
  long long v9 = a2[1];
  long long v10 = a2[2];
  long long v11 = a2[3];
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, _OWORD *))(v5 + 80);
  if (!v6) {
    return 4294954514;
  }
  v12[0] = v8;
  v12[1] = v9;
  void v12[2] = v10;
  v12[3] = v11;
  return v6(v3, v12);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetFCRBounds(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 88);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetCGBounds(double a1, double a2, double a3, double a4)
{
  uint64_t v8 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v14 = *(void *)(ProtocolVTable + 16);
  if (!v14) {
    return 4294954508;
  }
  uint64_t v15 = *(uint64_t (**)(uint64_t, __n128, __n128, __n128, __n128))(v14 + 96);
  if (!v15) {
    return 4294954514;
  }
  v10.n128_f64[0] = a1;
  v11.n128_f64[0] = a2;
  v12.n128_f64[0] = a3;
  v13.n128_f64[0] = a4;

  return v15(v8, v10, v11, v12, v13);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetCGBounds(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 104);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetCGSize(double a1, double a2)
{
  uint64_t v4 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v8 = *(void *)(ProtocolVTable + 16);
  if (!v8) {
    return 4294954508;
  }
  long long v9 = *(uint64_t (**)(uint64_t, __n128, __n128))(v8 + 112);
  if (!v9) {
    return 4294954514;
  }
  v6.n128_f64[0] = a1;
  v7.n128_f64[0] = a2;

  return v9(v4, v6, v7);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetCGSize(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 120);
  if (!v6) {
    return 4294954508;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetCGOrigin(double a1, double a2)
{
  uint64_t v4 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v8 = *(void *)(ProtocolVTable + 16);
  if (!v8) {
    return 4294954508;
  }
  long long v9 = *(uint64_t (**)(uint64_t, __n128, __n128))(v8 + 128);
  if (!v9) {
    return 4294954514;
  }
  v6.n128_f64[0] = a1;
  v7.n128_f64[0] = a2;

  return v9(v4, v6, v7);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetCGOrigin(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 136);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetPaddings(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v15 = *(void *)(ProtocolVTable + 16);
  if (!v15) {
    return 4294954508;
  }
  uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v15 + 144);
  if (!v16) {
    return 4294954514;
  }

  return v16(v13, a2, a3, a4, a5, a6, a7);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetInsetCGBounds(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 152);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_PurgeImageCache()
{
  uint64_t v0 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v2 = *(void *)(ProtocolVTable + 16);
  if (!v2) {
    return 4294954508;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 160);
  if (!v3) {
    return 4294954514;
  }

  return v3(v0);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetImageCache(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 168);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetImageCache(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 176);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetImageCacheWidth(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 184);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetImageCacheHeight(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 192);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_AllocateImageBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v9 = *(void *)(ProtocolVTable + 16);
  if (!v9) {
    return 4294954508;
  }
  __n128 v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 200);
  if (!v10) {
    return 4294954514;
  }

  return v10(v7, a2, a3, a4);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetImageBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 208);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetNeedRedraw(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 216);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetNeedRedraw(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 224);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetNeedLayout(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 232);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetNeedLayout(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 240);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_HasActions(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 248);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetZOrder(double a1)
{
  uint64_t v2 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, __n128))(v5 + 256);
  if (!v6) {
    return 4294954514;
  }
  v4.n128_f64[0] = a1;

  return v6(v2, v4);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetZOrder(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  __n128 v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 264);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_ResetNodeTree()
{
  uint64_t v0 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v2 = *(void *)(ProtocolVTable + 16);
  if (!v2) {
    return 4294954508;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 272);
  if (!v3) {
    return 4294954514;
  }

  return v3(v0);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_Draw(const void *a1, uint64_t a2)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CGSize v7 = *(CGSize *)(MEMORY[0x1E4F1DB20] + 16);
  v84[0] = *MEMORY[0x1E4F1DB20];
  v84[1] = v7;
  CGSize v79 = v7;
  CGPoint v80 = (CGPoint)v84[0];
  v83[0] = v84[0];
  v83[1] = v7;
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (ProtocolVTable)
  {
    uint64_t v9 = *(void *)(ProtocolVTable + 16);
    if (v9)
    {
      __n128 v10 = *(void (**)(const void *, _OWORD *))(v9 + 72);
      if (v10) {
        v10(a1, v84);
      }
    }
  }
  FigCaptionRendererNodeProtocolGetProtocolID();
  uint64_t v11 = CMBaseObjectGetProtocolVTable();
  if (v11)
  {
    uint64_t v12 = *(void *)(v11 + 16);
    if (v12)
    {
      uint64_t v13 = *(void (**)(const void *, _OWORD *))(v12 + 104);
      if (v13) {
        v13(a1, v83);
      }
    }
  }
  CFStringRef v14 = *(const __CFString **)(DerivedStorage + 152);
  if (!v14) {
    goto LABEL_12;
  }
  if (CFStringCompare(v14, (CFStringRef)*MEMORY[0x1E4F1F920], 1uLL) == kCFCompareEqualTo)
  {
    uint64_t v16 = (unsigned char *)(DerivedStorage + 216);
    if (*(unsigned char *)(DerivedStorage + 216)) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (CFStringCompare(*(CFStringRef *)(DerivedStorage + 152), (CFStringRef)*MEMORY[0x1E4F1F928], 1uLL)) {
    goto LABEL_12;
  }
  v85.a = 0.0;
  FigCaptionRendererNodeProtocolGetProtocolID();
  uint64_t v37 = CMBaseObjectGetProtocolVTable();
  if (v37)
  {
    uint64_t v38 = *(void *)(v37 + 16);
    if (v38)
    {
      CFStringRef v39 = *(void (**)(const void *, CGAffineTransform *))(v38 + 24);
      if (v39) {
        v39(a1, &v85);
      }
    }
  }
  if (*(void *)&v85.a) {
    BOOL v15 = CFArrayGetCount(*(CFArrayRef *)&v85.a) > 0;
  }
  else {
LABEL_12:
  }
    BOOL v15 = 0;
  uint64_t v16 = (unsigned char *)(DerivedStorage + 216);
  if (*(unsigned char *)(DerivedStorage + 216)) {
    goto LABEL_18;
  }
  if (!v15) {
    goto LABEL_50;
  }
LABEL_17:
  if (!*(void *)(DerivedStorage + 72)) {
    goto LABEL_50;
  }
LABEL_18:
  v82.origiCFIndex n = v80;
  v82.CGSize size = v79;
  FigCaptionRendererNodeProtocolGetProtocolID();
  uint64_t v17 = CMBaseObjectGetProtocolVTable();
  if (v17)
  {
    uint64_t v18 = *(void *)(v17 + 16);
    if (v18)
    {
      CFMutableArrayRef v19 = *(void (**)(const void *, CGRect *))(v18 + 104);
      if (v19) {
        v19(a1, &v82);
      }
    }
  }
  CGSize size = v82.size;
  uint64_t v21 = *(unsigned int *)(a2 + 332);
  FigCaptionRendererNodeProtocolGetProtocolID();
  uint64_t v22 = CMBaseObjectGetProtocolVTable();
  if (!v22) {
    return 4294954508;
  }
  uint64_t v23 = *(void *)(v22 + 16);
  if (!v23) {
    return 4294954508;
  }
  uint64_t v24 = *(uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t))(v23 + 200);
  if (!v24) {
    return 4294954514;
  }
  LODWORD(v3) = vcvtpd_s64_f64(size.width);
  LODWORD(v2) = vcvtpd_s64_f64(size.height);
  uint64_t result = v24(a1, v3, v2, v21);
  if (!result)
  {
    data = 0;
    FigCaptionRendererNodeProtocolGetProtocolID();
    uint64_t v26 = CMBaseObjectGetProtocolVTable();
    if (v26)
    {
      uint64_t v27 = *(void *)(v26 + 16);
      if (v27)
      {
        long long v28 = *(void (**)(const void *, void **))(v27 + 208);
        if (v28) {
          v28(a1, &data);
        }
      }
    }
    if (!data)
    {
      FigSignalErrorAt();
      return 0;
    }
    CFStringRef v29 = (const __CFString *)*MEMORY[0x1E4F1DC98];
    CFTypeID v30 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
    if (!v30) {
      return FigSignalErrorAt();
    }
    CGAffineTransform v31 = v30;
    CGAffineTransform v32 = CGBitmapContextCreate(data, *(_DWORD *)(a2 + 332) * (int)v3, *(_DWORD *)(a2 + 332) * (int)v2, 8uLL, 4 * *(_DWORD *)(a2 + 332) * (int)v3, v30, 0x4001u);
    if (v32)
    {
      CGAffineTransform v33 = v32;
      CGContextScaleCTM(v32, (double)*(int *)(a2 + 332), (double)*(int *)(a2 + 332));
      long long v34 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      *(_OWORD *)&v85.a = *MEMORY[0x1E4F1DAB8];
      *(_OWORD *)&v85.double c = v34;
      *(_OWORD *)&v85.tCGFloat x = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
      CGContextSetTextMatrix(v33, &v85);
      CGColorSpaceRelease(v31);
      if (*v16)
      {
        unsigned int v35 = CGColorSpaceCreateWithName(v29);
        *(_OWORD *)&v85.a = xmmword_194998838;
        *(_OWORD *)&v85.double c = unk_194998848;
        CFTypeID v36 = CGColorCreate(v35, &v85.a);
      }
      else
      {
        unsigned int v35 = 0;
        CFTypeID v36 = *(CGColor **)(DerivedStorage + 72);
      }
      CGContextSaveGState(v33);
      CGSize v40 = v82.size;
      CGContextSetShadowWithColor(v33, *MEMORY[0x1E4F1DB30], 0.0, 0);
      CGContextSetFillColorWithColor(v33, v36);
      v87.origin.CGFloat x = 0.0;
      v87.origin.CGFloat y = 0.0;
      v87.CGSize size = v40;
      CGContextFillRect(v33, v87);
      CGContextRestoreGState(v33);
      if (*v16)
      {
        CGColorRelease(v36);
        CFRelease(v35);
      }
      CGImageRef Image = CGBitmapContextCreateImage(v33);
      if (Image)
      {
        double v42 = Image;
        FigCaptionRendererNodeProtocolGetProtocolID();
        uint64_t v43 = CMBaseObjectGetProtocolVTable();
        if (v43)
        {
          uint64_t v44 = *(void *)(v43 + 16);
          if (v44)
          {
            long long v45 = *(void (**)(const void *, CGImage *))(v44 + 168);
            if (v45) {
              v45(a1, v42);
            }
          }
        }
        CGImageRelease(v42);
        CGContextRelease(v33);
LABEL_50:
        if (*(void *)(a2 + 296))
        {
          *(CGPoint *)&v85.a = v80;
          *(CGSize *)&v85.double c = v79;
          FigCaptionRendererNodeProtocolGetProtocolID();
          uint64_t v46 = CMBaseObjectGetProtocolVTable();
          if (v46)
          {
            uint64_t v47 = *(void *)(v46 + 16);
            if (v47)
            {
              uint64_t v48 = *(void (**)(const void *, CGAffineTransform *))(v47 + 104);
              if (v48) {
                v48(a1, &v85);
              }
            }
          }
          CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 296), a1);
          if (*(_DWORD *)(a2 + 328))
          {
            double d = v85.d;
          }
          else
          {
            CGSize v51 = *(CGSize *)(MEMORY[0x1E4F1DB28] + 16);
            v82.origiCFIndex n = (CGPoint)*MEMORY[0x1E4F1DB28];
            v82.CGSize size = v51;
            FigCaptionRendererNodeProtocolGetProtocolID();
            uint64_t v52 = CMBaseObjectGetProtocolVTable();
            if (v52)
            {
              uint64_t v53 = *(void *)(v52 + 16);
              if (v53)
              {
                CFStringRef v54 = *(void (**)(const void *, CGRect *))(v53 + 72);
                if (v54) {
                  v54(a1, &v82);
                }
              }
            }
            v88.origin.CGFloat x = v85.a;
            v88.origin.CGFloat y = v85.b;
            v88.size.CGFloat width = v85.c;
            v88.size.CGFloat height = v85.d;
            double MidY = CGRectGetMidY(v88);
            CGFloat v56 = CGRectGetMidY(v82);
            CGFloat v57 = v56 + v56 - MidY;
            double d = v85.d;
            v85.b = v57 + v85.d * -0.5;
          }
          double c = v85.c;
          FigCaptionRendererOutputNodeProtocolGetProtocolID();
          uint64_t v59 = CMBaseObjectGetProtocolVTable();
          if (v59)
          {
            uint64_t v60 = *(void *)(v59 + 16);
            if (v60)
            {
              __int16 v61 = *(void (**)(const void *, double, double))(v60 + 88);
              if (v61) {
                v61(Value, c, d);
              }
            }
          }
          v89.origin.CGFloat x = v85.a;
          v89.origin.CGFloat y = v85.b;
          v89.size.CGFloat width = v85.c;
          v89.size.CGFloat height = v85.d;
          double MidX = CGRectGetMidX(v89);
          v90.origin.CGFloat x = v85.a;
          v90.origin.CGFloat y = v85.b;
          v90.size.CGFloat width = v85.c;
          v90.size.CGFloat height = v85.d;
          double v63 = CGRectGetMidY(v90);
          FigCaptionRendererOutputNodeProtocolGetProtocolID();
          uint64_t v64 = CMBaseObjectGetProtocolVTable();
          if (v64)
          {
            uint64_t v65 = *(void *)(v64 + 16);
            if (v65)
            {
              CFTypeRef v66 = *(void (**)(const void *, double, double))(v65 + 72);
              if (v66) {
                v66(Value, MidX, v63);
              }
            }
          }
          v82.origin.CGFloat x = 0.0;
          FigCaptionRendererNodeProtocolGetProtocolID();
          uint64_t v67 = CMBaseObjectGetProtocolVTable();
          if (v67
            && (uint64_t v68 = *(void *)(v67 + 16)) != 0
            && (CFIndex v69 = *(void (**)(const void *, CGRect *))(v68 + 176)) != 0)
          {
            v69(a1, &v82);
            CGFloat x = v82.origin.x;
          }
          else
          {
            CGFloat x = 0.0;
          }
          FigCaptionRendererOutputNodeProtocolGetProtocolID();
          uint64_t v71 = CMBaseObjectGetProtocolVTable();
          if (v71)
          {
            uint64_t v72 = *(void *)(v71 + 16);
            if (v72)
            {
              CFRange v73 = *(void (**)(const void *, void))(v72 + 120);
              if (v73) {
                v73(Value, *(void *)&x);
              }
            }
          }
        }
        uint64_t v74 = *(void *)DerivedStorage;
        FigCaptionRendererNodeProtocolGetProtocolID();
        uint64_t v75 = CMBaseObjectGetProtocolVTable();
        if (v75)
        {
          uint64_t v76 = *(void *)(v75 + 16);
          if (v76)
          {
            long long v77 = *(uint64_t (**)(uint64_t, uint64_t))(v76 + 280);
            if (v77) {
              return v77(v74, a2);
            }
            return 4294954514;
          }
        }
        return 4294954508;
      }
      uint64_t v78 = FigSignalErrorAt();
      CGContextRelease(v33);
    }
    else
    {
      uint64_t v78 = FigSignalErrorAt();
      CGColorSpaceRelease(v31);
    }
    return v78;
  }
  return result;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_Layout(uint64_t a1, float64x2_t *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = (uint64_t *)CMBaseObjectGetDerivedStorage();
  char v6 = 0;
  double v7 = -1.0;
  char v8 = 0;
  uint64_t v9 = v5[11];
  if ((int)v9 > 1886679839)
  {
    if (v9 == 1886679840 || v9 == 1886920736)
    {
      FigGeometryDimensionGetCGFloat();
      double v7 = v14;
      char v6 = 0;
    }
  }
  else if (v9 == 622862368)
  {
    FigGeometryDimensionGetCGFloat();
    char v6 = 1;
    double v7 = v15 / 100.0;
  }
  else if (v9 == 1667591276)
  {
    FigGeometryDimensionGetCGFloat();
    double v11 = v10;
    FigGeometryDimensionGetCGFloat();
    char v6 = 1;
    double v7 = v11 / v12;
  }
  char v16 = FCRRectNull;
  double v17 = -1.0;
  uint64_t v18 = v5[13];
  if ((int)v18 > 1886679839)
  {
    if (v18 == 1886679840 || v18 == 1886920736)
    {
      FigGeometryDimensionGetCGFloat();
      double v17 = v22;
      char v8 = 0;
    }
  }
  else if (v18 == 622862368)
  {
    FigGeometryDimensionGetCGFloat();
    char v8 = 1;
    double v17 = v23 / 100.0;
  }
  else if (v18 == 1667591276)
  {
    FigGeometryDimensionGetCGFloat();
    double v20 = v19;
    FigGeometryDimensionGetCGFloat();
    char v8 = 1;
    double v17 = v20 / v21;
  }
  char v24 = 0;
  double v25 = -1.0;
  uint64_t v26 = v5[15];
  if ((int)v26 > 1886679839)
  {
    if (v26 == 1886679840 || v26 == 1886920736)
    {
      FigGeometryDimensionGetCGFloat();
      double v25 = v30;
      char v16 = 0;
    }
  }
  else if (v26 == 622862368)
  {
    FigGeometryDimensionGetCGFloat();
    if (v44 / 100.0 < 0.0 || (FigGeometryDimensionGetCGFloat(), double v25 = 1.0, v45 / 100.0 <= 1.0))
    {
      FigGeometryDimensionGetCGFloat();
      if (v56 / 100.0 >= 0.0)
      {
        FigGeometryDimensionGetCGFloat();
        char v16 = 1;
        double v25 = v132 / 100.0;
      }
      else
      {
        char v16 = 1;
        double v25 = 0.0;
      }
    }
    else
    {
      char v16 = 1;
    }
  }
  else if (v26 == 1667591276)
  {
    FigGeometryDimensionGetCGFloat();
    double v28 = v27;
    FigGeometryDimensionGetCGFloat();
    char v16 = 1;
    double v25 = v28 / v29;
  }
  double v31 = -1.0;
  uint64_t v32 = v5[17];
  if ((int)v32 > 1886679839)
  {
    if (v32 == 1886679840 || v32 == 1886920736)
    {
      FigGeometryDimensionGetCGFloat();
      double v31 = v43;
      char v24 = 0;
    }
  }
  else
  {
    if (v32 == 622862368)
    {
      BOOL v46 = v18 == 1886920736 || v18 == 1886679840;
      double v31 = 1.0;
      if (v46) {
        double v47 = 1.0;
      }
      else {
        double v47 = v17;
      }
      FigGeometryDimensionGetCGFloat();
      double v49 = v48 / -100.0 + 1.0;
      double v50 = 0.0;
      if (v49 >= 0.0)
      {
        FigGeometryDimensionGetCGFloat();
        double v50 = v51 / -100.0 + 1.0;
      }
      if (v50 - v47 <= 1.0)
      {
        FigGeometryDimensionGetCGFloat();
        double v53 = v52 / -100.0 + 1.0;
        double v54 = 0.0;
        if (v53 >= 0.0)
        {
          FigGeometryDimensionGetCGFloat();
          double v54 = v55 / -100.0 + 1.0;
        }
        double v31 = v54 - v47;
      }
      goto LABEL_55;
    }
    if (v32 == 1667591276)
    {
      FigGeometryDimensionGetCGFloat();
      double v34 = v33;
      FigGeometryDimensionGetCGFloat();
      double v36 = v34 / v35;
      double v31 = 1.0;
      if (1.0 - v36 < 0.0
        || (FigGeometryDimensionGetCGFloat(), double v38 = v37, FigGeometryDimensionGetCGFloat(), 1.0 - v38 / v39 <= 1.0))
      {
        FigGeometryDimensionGetCGFloat();
        double v41 = v40;
        FigGeometryDimensionGetCGFloat();
        if (1.0 - v41 / v42 >= 0.0)
        {
          FigGeometryDimensionGetCGFloat();
          double v58 = v57;
          FigGeometryDimensionGetCGFloat();
          double v31 = 1.0 - v58 / v59;
        }
        else
        {
          double v31 = 0.0;
        }
      }
LABEL_55:
      char v24 = 1;
    }
  }
  uint64_t v60 = *v5;
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (ProtocolVTable)
  {
    uint64_t v62 = *(void *)(ProtocolVTable + 16);
    if (v62)
    {
      double v63 = *(void (**)(uint64_t, long long *))(v62 + 80);
      if (v63)
      {
        LOBYTE(v147) = v16;
        *(_DWORD *)((char *)&v147 + 1) = 0;
        DWORD1(v147) = 0;
        *((double *)&v147 + 1) = v25;
        LOBYTE(v148) = v24;
        *(_DWORD *)((char *)&v148 + 1) = 0;
        DWORD1(v148) = 0;
        *((double *)&v148 + 1) = v31;
        LOBYTE(v149) = v6;
        *(_DWORD *)((char *)&v149 + 1) = 0;
        DWORD1(v149) = 0;
        *((double *)&v149 + 1) = v7;
        LOBYTE(v150) = v8;
        DWORD1(v150) = 0;
        *(_DWORD *)((char *)&v150 + 1) = 0;
        *((double *)&v150 + 1) = v17;
        v63(v60, &v147);
      }
    }
  }
  uint64_t v64 = (uint64_t *)CMBaseObjectGetDerivedStorage();
  long long v147 = FCRRectNull;
  long long v148 = *(_OWORD *)&byte_1949966D8;
  long long v149 = xmmword_1949966E8;
  long long v150 = *(_OWORD *)&byte_1949966F8;
  FigCaptionRendererNodeProtocolGetProtocolID();
  uint64_t v65 = CMBaseObjectGetProtocolVTable();
  if (v65)
  {
    uint64_t v66 = *(void *)(v65 + 16);
    if (v66)
    {
      uint64_t v67 = *(void (**)(uint64_t, long long *))(v66 + 88);
      if (v67) {
        v67(a1, &v147);
      }
    }
  }
  double v68 = FCRGetVideoPresentationBounds(a2[23].f64[0], a2[23].f64[1], a2[21].f64[0], a2[21].f64[1], a2[22].f64[0], a2[22].f64[1]);
  if (*((double *)&v149 + 1) != -1.0)
  {
    double v118 = v68 + *((double *)&v147 + 1) * v70;
    double v119 = v68 + *((double *)&v147 + 1);
    if ((_BYTE)v147) {
      double v119 = v118;
    }
    double v120 = v69 + *((double *)&v148 + 1) * v71;
    double v121 = v69 + *((double *)&v148 + 1);
    if ((_BYTE)v148) {
      double v121 = v120;
    }
    if (!(_BYTE)v149) {
      double v70 = 1.0;
    }
    double v122 = *((double *)&v149 + 1) * v70;
    if (!(_BYTE)v150) {
      double v71 = 1.0;
    }
    double v123 = *((double *)&v150 + 1) * v71;
    CGRect v151 = CGRectIntegral(*(CGRect *)&v119);
    double x = v151.origin.x;
    double y = v151.origin.y;
    double width = v151.size.width;
    double height = v151.size.height;
    uint64_t v128 = *v64;
    FigCaptionRendererNodeProtocolGetProtocolID();
    uint64_t v129 = CMBaseObjectGetProtocolVTable();
    if (v129)
    {
      uint64_t v130 = *(void *)(v129 + 16);
      if (v130)
      {
        CMTimeValue v131 = *(void (**)(uint64_t, double, double, double, double))(v130 + 96);
        if (v131) {
          v131(v128, x, y, width, height);
        }
      }
    }
  }
  CFArrayRef theArray = 0;
  uint64_t v72 = *(void *)DerivedStorage;
  FigCaptionRendererNodeProtocolGetProtocolID();
  uint64_t v73 = CMBaseObjectGetProtocolVTable();
  if (v73)
  {
    uint64_t v74 = *(void *)(v73 + 16);
    if (v74)
    {
      uint64_t v75 = *(void (**)(uint64_t, CFArrayRef *))(v74 + 24);
      if (v75) {
        v75(v72, &theArray);
      }
    }
  }
  CFIndex Count = CFArrayGetCount(theArray);
  *(_OWORD *)cf2 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
  long long v139 = *MEMORY[0x1E4F1DB20];
  long long v147 = *MEMORY[0x1E4F1DB20];
  long long v148 = *(_OWORD *)cf2;
  uint64_t v77 = *(void *)DerivedStorage;
  FigCaptionRendererNodeProtocolGetProtocolID();
  uint64_t v78 = CMBaseObjectGetProtocolVTable();
  if (v78)
  {
    uint64_t v79 = *(void *)(v78 + 16);
    if (v79)
    {
      CGPoint v80 = *(void (**)(uint64_t, long long *))(v79 + 104);
      if (v80) {
        v80(v77, &v147);
      }
    }
  }
  long long v144 = v139;
  *(_OWORD *)uint64_t v145 = *(_OWORD *)cf2;
  uint64_t v81 = *(void *)DerivedStorage;
  FigCaptionRendererNodeProtocolGetProtocolID();
  uint64_t v82 = CMBaseObjectGetProtocolVTable();
  if (v82)
  {
    uint64_t v83 = *(void *)(v82 + 16);
    if (v83)
    {
      long long v84 = *(void (**)(uint64_t, long long *))(v83 + 152);
      if (v84) {
        v84(v81, &v144);
      }
    }
  }
  if (Count >= 1)
  {
    double v85 = *(double *)&v144 - *(double *)&v147;
    double v86 = *((double *)&v144 + 1) - *((double *)&v147 + 1);
    CFStringRef v87 = (const __CFString *)*MEMORY[0x1E4F1F798];
    CFStringRef v88 = (const __CFString *)*MEMORY[0x1E4F1F7A8];
    CFStringRef v89 = (const __CFString *)*MEMORY[0x1E4F1F7A0];
    CGRect v90 = (const void *)*MEMORY[0x1E4F1F538];
    cf2a = (const void *)*MEMORY[0x1E4F1F528];
    CFTypeRef v136 = (CFTypeRef)*MEMORY[0x1E4F1F508];
    CFTypeRef v135 = (CFTypeRef)*MEMORY[0x1E4F1F518];
    CFTypeRef v134 = (CFTypeRef)*MEMORY[0x1E4F1F510];
    unint64_t v91 = Count + 1;
    long long v140 = *MEMORY[0x1E4F1DB30];
    double v92 = *((double *)&v144 + 1) - *((double *)&v147 + 1);
    double v93 = *(double *)&v144 - *(double *)&v147;
    CFTypeRef v133 = (CFTypeRef)*MEMORY[0x1E4F1F520];
    do
    {
      long long v143 = v140;
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v91 - 2);
      FigCaptionRendererNodeProtocolGetProtocolID();
      uint64_t v95 = CMBaseObjectGetProtocolVTable();
      if (v95)
      {
        uint64_t v96 = *(void *)(v95 + 16);
        if (v96)
        {
          double v97 = *(void (**)(const void *, long long *))(v96 + 120);
          if (v97) {
            v97(ValueAtIndex, &v143);
          }
        }
      }
      CFStringRef v98 = *(const __CFString **)(DerivedStorage + 168);
      if (v98)
      {
        double v99 = v86;
        if (CFStringCompare(v98, v87, 1uLL))
        {
          if (CFStringCompare(*(CFStringRef *)(DerivedStorage + 168), v88, 1uLL) == kCFCompareEqualTo)
          {
            double v100 = (v145[1] - *((double *)&v143 + 1)) * 0.5;
            goto LABEL_90;
          }
          double v99 = v92;
          if (CFStringCompare(*(CFStringRef *)(DerivedStorage + 168), v89, 1uLL) == kCFCompareEqualTo)
          {
            double v100 = v145[1] - *((double *)&v143 + 1);
LABEL_90:
            double v99 = v86 + v100;
          }
        }
      }
      else
      {
        double v99 = v92;
      }
      __s1 = 0;
      FigCaptionRendererBaseProtocolGetProtocolID();
      uint64_t v101 = CMBaseObjectGetProtocolVTable();
      if (v101)
      {
        uint64_t v102 = *(void *)(v101 + 16);
        if (v102)
        {
          double v103 = *(void (**)(const void *, char **))(v102 + 8);
          if (v103) {
            v103(ValueAtIndex, &__s1);
          }
        }
      }
      if (!__s1 || strcmp(__s1, "FigCaptionRendererCaption")) {
        goto LABEL_97;
      }
      CFDictionaryRef theDict = 0;
      FigCaptionRendererCaptionProtocolGetProtocolID();
      uint64_t v110 = CMBaseObjectGetProtocolVTable();
      if (v110)
      {
        uint64_t v111 = *(void *)(v110 + 16);
        if (v111)
        {
          BOOL v112 = *(void (**)(const void *, CFDictionaryRef *))(v111 + 16);
          if (v112) {
            v112(ValueAtIndex, &theDict);
          }
        }
      }
      if (!theDict) {
        goto LABEL_97;
      }
      CFArrayRef Value = CFDictionaryGetValue(theDict, v90);
      if (!Value) {
        goto LABEL_97;
      }
      uint64_t v114 = Value;
      double v93 = v85;
      if (CFEqual(Value, cf2a)) {
        goto LABEL_97;
      }
      if (CFEqual(v114, v136))
      {
        double v115 = v145[0];
LABEL_116:
        double v93 = v85 + v115 - *(double *)&v143;
        goto LABEL_97;
      }
      if (CFEqual(v114, v135))
      {
        double v115 = v145[0];
LABEL_119:
        double v93 = v85 + (v115 - *(double *)&v143) * 0.5;
        goto LABEL_97;
      }
      double v93 = v85;
      if (!CFEqual(v114, v134))
      {
        int v116 = CFEqual(v114, v133);
        double v115 = v145[0];
        if (v116) {
          goto LABEL_116;
        }
        goto LABEL_119;
      }
LABEL_97:
      FigCaptionRendererNodeProtocolGetProtocolID();
      uint64_t v104 = CMBaseObjectGetProtocolVTable();
      if (v104)
      {
        uint64_t v105 = *(void *)(v104 + 16);
        if (v105)
        {
          CFTypeRef v106 = *(void (**)(const void *, double, double))(v105 + 128);
          if (v106) {
            v106(ValueAtIndex, v93, v99);
          }
        }
      }
      FigCaptionRendererNodeProtocolGetProtocolID();
      uint64_t v107 = CMBaseObjectGetProtocolVTable();
      if (v107)
      {
        uint64_t v108 = *(void *)(v107 + 16);
        if (v108)
        {
          CGFloat v109 = *(void (**)(const void *, uint64_t))(v108 + 232);
          if (v109) {
            v109(ValueAtIndex, 1);
          }
        }
      }
      double v92 = v99 + *((double *)&v143 + 1);
      --v91;
    }
    while (v91 > 1);
  }
  FigCaptionRendererLayoutDecouple_ApplyDecouplingAndSafeRegion(a1, a2);
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_ExecActions(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  char v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 296);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_Compose(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 144) == 1)
  {
    CFDictionaryRef v5 = *(const __CFDictionary **)(a2 + 296);
    if (v5)
    {
      CFArrayRef Value = CFDictionaryGetValue(v5, a1);
      FigCaptionRendererOutputNodeProtocolGetProtocolID();
      Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
      if (ProtocolVTable)
      {
        uint64_t v8 = *(void *)(ProtocolVTable + 16);
        if (v8)
        {
          uint64_t v9 = *(void (**)(const void *, void))(v8 + 120);
          if (v9) {
            v9(Value, 0);
          }
        }
      }
    }
    CFMutableArrayRef Mutable = 0;
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v12 = DerivedStorage;
    __int16 v55 = 0;
    FigCaptionRendererNodeProtocolGetProtocolID();
    uint64_t v13 = CMBaseObjectGetProtocolVTable();
    if (v13)
    {
      uint64_t v14 = *(void *)(v13 + 16);
      if (v14)
      {
        double v15 = *(void (**)(const void *, char *))(v14 + 248);
        if (v15)
        {
          v15(a1, (char *)&v55 + 1);
          if (HIBYTE(v55))
          {
            FigCaptionRendererNodeProtocolGetProtocolID();
            uint64_t v16 = CMBaseObjectGetProtocolVTable();
            if (v16)
            {
              uint64_t v17 = *(void *)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *(void (**)(const void *, uint64_t))(v17 + 296);
                if (v18) {
                  v18(a1, a2);
                }
              }
            }
          }
        }
      }
    }
    FigCaptionRendererNodeProtocolGetProtocolID();
    uint64_t v19 = CMBaseObjectGetProtocolVTable();
    if (v19)
    {
      uint64_t v20 = *(void *)(v19 + 16);
      if (v20)
      {
        double v21 = *(void (**)(const void *, __int16 *))(v20 + 240);
        if (v21) {
          v21(a1, &v55);
        }
      }
    }
    if ((_BYTE)v55)
    {
      FigCaptionRendererNodeProtocolGetProtocolID();
      uint64_t v22 = CMBaseObjectGetProtocolVTable();
      if (v22)
      {
        uint64_t v23 = *(void *)(v22 + 16);
        if (v23)
        {
          char v24 = *(void (**)(const void *, uint64_t))(v23 + 288);
          if (v24) {
            v24(a1, a2);
          }
        }
      }
    }
    FigCaptionRendererNodeProtocolGetProtocolID();
    uint64_t v25 = CMBaseObjectGetProtocolVTable();
    if (v25)
    {
      uint64_t v26 = *(void *)(v25 + 16);
      if (v26)
      {
        double v27 = *(void (**)(const void *, uint64_t))(v26 + 280);
        if (v27) {
          v27(a1, a2);
        }
      }
    }
    uint64_t v28 = *(void *)v12;
    FigCaptionRendererNodeProtocolGetProtocolID();
    uint64_t v29 = CMBaseObjectGetProtocolVTable();
    if (v29 && (uint64_t v30 = *(void *)(v29 + 16)) != 0)
    {
      double v31 = *(uint64_t (**)(uint64_t, uint64_t))(v30 + 304);
      if (v31) {
        uint64_t v11 = v31(v28, a2);
      }
      else {
        uint64_t v11 = 4294954514;
      }
    }
    else
    {
      uint64_t v11 = 4294954508;
    }
    if (!*(unsigned char *)(v12 + 145)) {
      goto LABEL_57;
    }
    if (*(void *)(a2 + 296))
    {
      CGSize v32 = *(CGSize *)(MEMORY[0x1E4F1DB20] + 16);
      v54.origiCFIndex n = (CGPoint)*MEMORY[0x1E4F1DB20];
      v54.CGSize size = v32;
      FigCaptionRendererNodeProtocolGetProtocolID();
      uint64_t v33 = CMBaseObjectGetProtocolVTable();
      if (v33)
      {
        uint64_t v34 = *(void *)(v33 + 16);
        if (v34)
        {
          double v35 = *(void (**)(const void *, CGRect *))(v34 + 104);
          if (v35) {
            v35(a1, &v54);
          }
        }
      }
      double v36 = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 296), a1);
      FigCaptionRendererOutputNodeProtocolGetProtocolID();
      uint64_t v37 = CMBaseObjectGetProtocolVTable();
      if (v37)
      {
        uint64_t v38 = *(void *)(v37 + 16);
        if (v38)
        {
          double v39 = *(void (**)(const void *, uint64_t))(v38 + 104);
          if (v39) {
            v39(v36, 1);
          }
        }
      }
    }
    if (*(void *)(a2 + 320))
    {
      CFMutableArrayRef Mutable = CGPathCreateMutable();
      CFArrayRef theArray = 0;
      FigCaptionRendererNodeProtocolGetProtocolID();
      uint64_t v40 = CMBaseObjectGetProtocolVTable();
      if (v40)
      {
        uint64_t v41 = *(void *)(v40 + 16);
        if (v41)
        {
          double v42 = *(void (**)(const void *, CFArrayRef *))(v41 + 24);
          if (v42)
          {
            v42(a1, &theArray);
            if (theArray)
            {
              CFIndex Count = CFArrayGetCount(theArray);
              if (Count >= 1)
              {
                CFIndex v44 = Count;
                CFIndex v45 = 0;
                CGSize v51 = *(CGSize *)(MEMORY[0x1E4F1DB28] + 16);
                CGPoint v52 = (CGPoint)*MEMORY[0x1E4F1DB28];
                do
                {
                  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v45);
                  v54.origiCFIndex n = v52;
                  v54.CGSize size = v51;
                  FigCaptionRendererNodeProtocolGetProtocolID();
                  uint64_t v47 = CMBaseObjectGetProtocolVTable();
                  if (v47)
                  {
                    uint64_t v48 = *(void *)(v47 + 16);
                    if (v48)
                    {
                      double v49 = *(void (**)(const void *, CGRect *))(v48 + 104);
                      if (v49) {
                        v49(ValueAtIndex, &v54);
                      }
                    }
                  }
                  CGPathAddRect(Mutable, 0, v54);
                  ++v45;
                }
                while (v44 != v45);
              }
              CGContextAddPath(*(CGContextRef *)(a2 + 320), Mutable);
              CGContextClip(*(CGContextRef *)(a2 + 320));
            }
          }
        }
      }
    }
    else
    {
LABEL_57:
      CFMutableArrayRef Mutable = 0;
    }
  }
  CGPathRelease(Mutable);
  return v11;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_OnChildUpdateDisplayRequest(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  __n128 v4 = *(void (**)(_OWORD *, uint64_t))(DerivedStorage + 16);
  if (v4)
  {
    uint64_t v5 = *(void *)(DerivedStorage + 8);
    long long v6 = *(_OWORD *)(a2 + 16);
    v8[0] = *(_OWORD *)a2;
    v8[1] = v6;
    uint64_t v9 = *(void *)(a2 + 32);
    v4(v8, v5);
  }
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_AddAction(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  long long v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 320);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_RemoveAllActions()
{
  uint64_t v0 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v2 = *(void *)(ProtocolVTable + 16);
  if (!v2) {
    return 4294954508;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 328);
  if (!v3) {
    return 4294954514;
  }

  return v3(v0);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SetActions(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  long long v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 336);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_GetActions(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  long long v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 344);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_SelectAt(double a1, double a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v11 = *(void *)(ProtocolVTable + 16);
  if (!v11) {
    return 4294954508;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, __n128, __n128))(v11 + 352);
  if (!v12) {
    return 4294954514;
  }
  v9.n128_f64[0] = a1;
  v10.n128_f64[0] = a2;

  return v12(v7, a4, v9, v10);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_UnselectAt(double a1, double a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v11 = *(void *)(ProtocolVTable + 16);
  if (!v11) {
    return 4294954508;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, __n128, __n128))(v11 + 360);
  if (!v12) {
    return 4294954514;
  }
  v9.n128_f64[0] = a1;
  v10.n128_f64[0] = a2;

  return v12(v7, a4, v9, v10);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_IsSelected(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  long long v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 368);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_BeginScene(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  long long v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 376);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererNodeProtocol_EndScene(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();
  FigCaptionRendererNodeProtocolGetProtocolID();
  Protocoluint64_t VTable = CMBaseObjectGetProtocolVTable();
  if (!ProtocolVTable) {
    return 4294954508;
  }
  uint64_t v5 = *(void *)(ProtocolVTable + 16);
  if (!v5) {
    return 4294954508;
  }
  long long v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 384);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

__CFString *FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_CopyDebugDescription(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"\tFigCaptionRendererTTMLRegion <FigCaptionRendererRegionProtocol> on <%p>", a1);
  return Mutable;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_SetRegionID(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  __n128 v4 = *(const void **)(DerivedStorage + 24);
  *(void *)(DerivedStorage + 24) = a2;
  if (a2) {
    CFRetain(a2);
  }
  if (v4) {
    CFRelease(v4);
  }
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_GetRegionID(uint64_t a1, void *a2)
{
  *a2 = *(void *)(CMBaseObjectGetDerivedStorage() + 24);
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_SetWidth(uint64_t a1, int a2)
{
  *(_DWORD *)(CMBaseObjectGetDerivedStorage() + 32) = a2;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_GetWidth(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(CMBaseObjectGetDerivedStorage() + 32);
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_SetLines(uint64_t a1, int a2)
{
  *(_DWORD *)(CMBaseObjectGetDerivedStorage() + 36) = a2;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_GetLines(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(CMBaseObjectGetDerivedStorage() + 36);
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_SetRegionAnchor(double a1, double a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(double *)(DerivedStorage + 40) = a1;
  *(double *)(DerivedStorage + 48) = a2;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_GetRegionAnchor(uint64_t a1, _OWORD *a2)
{
  *a2 = *(_OWORD *)(CMBaseObjectGetDerivedStorage() + 40);
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_SetViewportAnchor(double a1, double a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(double *)(DerivedStorage + 56) = a1;
  *(double *)(DerivedStorage + 64) = a2;
  return 0;
}

uint64_t FigCaptionRendererTTMLRegion_FigCaptionRendererRegionProtocol_GetViewportAnchor(uint64_t a1, _OWORD *a2)
{
  *a2 = *(_OWORD *)(CMBaseObjectGetDerivedStorage() + 56);
  return 0;
}

uint64_t RegisterFigCaptionRendererTTMLRegionBaseType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

CFTypeRef FigCaptionRendererTTMLRegionBaseCopyFormattingDesc()
{
  return CFRetain(@"[FigCaptionRendererTTMLRegion]");
}

uint64_t FigVideoCompositionProcessorGetTypeID()
{
  return sFigVideoCompositionProcessorTypeID;
}

uint64_t RegisterFigVideoCompositionProcessorType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigVideoCompositionProcessorCFTypeID TypeID = result;
  return result;
}

uint64_t FigVideoCompositionProcessorCreateWithImageQueue(const __CFAllocator *a1, char a2, const void *a3, CMTime *a4, int a5, void *a6, CMTime *a7, CMTime *a8, const void *a9, uint64_t *a10)
{
  values = a6;
  CFArrayRef v17 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
  CMTime v22 = *a4;
  CMTime v21 = *a7;
  CMTime v20 = *a8;
  uint64_t v18 = FigVideoCompositionProcessorCreateWithImageQueueArray(a1, a2, a3, &v22, a5, v17, &v21, &v20, a9, a10);
  if (v17) {
    CFRelease(v17);
  }
  return v18;
}

uint64_t FigVideoCompositionProcessorCreateWithImageQueueArray(const __CFAllocator *a1, char a2, const void *a3, CMTime *a4, int a5, const __CFArray *a6, CMTime *a7, CMTime *a8, const void *a9, uint64_t *a10)
{
  CFTypeRef v57 = 0;
  v58[0] = 0;
  CFTypeRef v55 = 0;
  CFTypeRef v56 = 0;
  CFTypeRef v53 = 0;
  CFTypeRef v54 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v52 = 0;
  CFNumberRef number = 0;
  int valuePtr = 0;
  fig_note_initialize_category_with_default_work_cf();
  uint64_t UInt32 = a3;
  fig_note_initialize_category_with_default_work_cf();
  if (!a3)
  {
    uint64_t v20 = FigSignalErrorAt();
LABEL_51:
    uint64_t Instance = 0;
    goto LABEL_53;
  }
  if ((a4->flags & 0x1D) != 1) {
    goto LABEL_24;
  }
  CMTime time1 = *a4;
  long long v46 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&time2.CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v16 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  time2.CMTimeEpoch epoch = v16;
  if (CMTimeCompare(&time1, &time2) <= 0) {
    goto LABEL_24;
  }
  if (!a6) {
    goto LABEL_24;
  }
  if (!CFArrayGetCount(a6)) {
    goto LABEL_24;
  }
  if ((a8->flags & 0x1D) != 1) {
    goto LABEL_24;
  }
  CMTime time1 = *a8;
  *(_OWORD *)&time2.CMTimeValue value = v46;
  time2.CMTimeEpoch epoch = v16;
  if (CMTimeCompare(&time1, &time2) < 0
    || (a7->flags & 0x1D) != 1
    || (time1 = *a7, *(_OWORD *)&time2.value = v46, time2.CMTimeEpoch epoch = v16, CMTimeCompare(&time1, &time2) <= 0)
    || (time1 = *a7, CMTime time2 = *a8, CMTimeCompare(&time1, &time2) < 0)
    || !a9)
  {
LABEL_24:
    uint64_t v20 = FigSignalErrorAt();
    uint64_t Instance = 0;
LABEL_25:
    uint64_t UInt32 = 0;
    goto LABEL_53;
  }
  MEMORY[0x19970EE10](&sRegisterFigVideoCompositionProcessorTypeOnce, RegisterFigVideoCompositionProcessorType);
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t Mutable = FigSignalErrorAt();
LABEL_79:
    uint64_t v20 = Mutable;
    goto LABEL_25;
  }
  uint64_t Mutable = FigVCPPreprocessParametersCreateMutable((uint64_t)a1, (uint64_t *)&v55);
  if (Mutable) {
    goto LABEL_79;
  }
  uint64_t Mutable = FigVCPSourceArrayCreateEmpty(a1, Instance, (uint64_t *)v58);
  if (Mutable) {
    goto LABEL_79;
  }
  uint64_t Mutable = FigVCPSourceArrayCreateEmpty(a1, Instance, (uint64_t *)&v57);
  if (Mutable) {
    goto LABEL_79;
  }
  CMTime time1 = *a4;
  uint64_t Mutable = FigVCPTimingCreate(a1, (uint64_t)&time1, a5, a2 & 2, (a2 & 1) == 0, Instance, (uint64_t *)&v56);
  if (Mutable) {
    goto LABEL_79;
  }
  CMTime time1 = *a7;
  CMTime time2 = *a8;
  uint64_t Mutable = FigVCPOutputCreate((uint64_t)a1, a6, &time1, &time2, Instance, &v54);
  if (Mutable) {
    goto LABEL_79;
  }
  uint64_t Mutable = FigVCPOutputConformerCreate((uint64_t)a1, Instance, &v53);
  if (Mutable) {
    goto LABEL_79;
  }
  uint64_t Mutable = FigVCPCompositorHostCreate(a1, a3, Instance, &v52);
  if (Mutable) {
    goto LABEL_79;
  }
  CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t Mutable = FigVCPCompositorHostCopyProperty((uint64_t)v52, @"VideoCompositionProcessor_SourcePixelBufferAttributes", *MEMORY[0x1E4F1CF80], (uint64_t)&cf);
  if (Mutable) {
    goto LABEL_79;
  }
  uint64_t Mutable = FigVCPPreprocessParametersSetProperty((uint64_t)v55, @"VideoCompositionProcessor_SourcePixelBufferAttributes", (uint64_t)cf);
  if (Mutable) {
    goto LABEL_79;
  }
  uint64_t Mutable = FigVCPCompositorHostCopyProperty((uint64_t)v52, @"SourceColorConformanceCapabilityLevel", (uint64_t)v19, (uint64_t)&number);
  if (Mutable) {
    goto LABEL_79;
  }
  CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
  uint64_t UInt32 = (const void *)FigCFNumberCreateUInt32();
  uint64_t v21 = FigVCPPreprocessParametersSetProperty((uint64_t)v55, @"FigVCPPreprocessParametersProperty_ColorConformanceLevel", (uint64_t)UInt32);
  if (v21) {
    goto LABEL_76;
  }
  *(unsigned char *)(Instance + 20) = 0;
  CFTypeRef v23 = v57;
  CFTypeRef v22 = v58[0];
  CFTypeRef v57 = 0;
  v58[0] = 0;
  *(void *)(Instance + 32) = v22;
  *(void *)(Instance + 40) = v23;
  CFTypeRef v25 = v55;
  CFTypeRef v24 = v56;
  CFTypeRef v55 = 0;
  CFTypeRef v56 = 0;
  *(void *)(Instance + 24) = v25;
  CFTypeRef v27 = v53;
  CFTypeRef v26 = v54;
  CFTypeRef v53 = 0;
  CFTypeRef v54 = 0;
  *(void *)(Instance + 112) = v27;
  *(void *)(Instance + 120) = v26;
  CFTypeRef v28 = v52;
  *(void *)(Instance + 96) = v24;
  *(void *)(Instance + 104) = v28;
  CFTypeRef v52 = 0;
  if ((a2 & 4) == 0)
  {
    int v29 = 1;
LABEL_31:
    *(_DWORD *)(Instance + 136) = v29;
    goto LABEL_32;
  }
  if (*(_DWORD *)(Instance + 136) != 3)
  {
    int v29 = 3;
    goto LABEL_31;
  }
LABEL_32:
  LODWORD(time1.value) = 0;
  CFNumberRef v30 = CFNumberCreate(v19, kCFNumberSInt32Type, &time1);
  uint64_t FigBaseObject = FigActivitySchedulerGetFigBaseObject(a9);
  uint64_t v32 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v32) {
    uint64_t v33 = v32;
  }
  else {
    uint64_t v33 = 0;
  }
  uint64_t v34 = *(void (**)(uint64_t, __CFString *, CFNumberRef))(v33 + 56);
  if (v34) {
    v34(FigBaseObject, @"ClientPID", v30);
  }
  CFRelease(v30);
  uint64_t v35 = FigActivitySchedulerGetFigBaseObject(a9);
  uint64_t v36 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v36) {
    uint64_t v37 = v36;
  }
  else {
    uint64_t v37 = 0;
  }
  uint64_t v38 = *(void (**)(uint64_t, __CFString *, void))(v37 + 56);
  if (v38) {
    v38(v35, @"ThrottleForBackground", *MEMORY[0x1E4F1CFC8]);
  }
  uint64_t v39 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v39) {
    uint64_t v40 = v39;
  }
  else {
    uint64_t v40 = 0;
  }
  uint64_t v41 = *(uint64_t (**)(const void *, void (*)(uint64_t), uint64_t))(v40 + 8);
  if (!v41)
  {
    uint64_t v20 = 4294954514;
    goto LABEL_53;
  }
  uint64_t v21 = v41(a9, videoprocessor_processUntilHighWaterMet, Instance);
  if (!v21)
  {
    *(void *)(Instance + 128) = CFRetain(a9);
    *(void *)(Instance + 216) = 0x7FFFFFFFLL;
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterAddWeakListener();
    uint64_t v21 = FigVCPCompositorHostSetOutputCallback(*(void *)(Instance + 104), (uint64_t)videoprocessor_frameCompleteCallback);
    if (!v21)
    {
      uint64_t v21 = FigVCPCompositorHostSetCompletePrerollCallback(*(void *)(Instance + 104), (uint64_t)videoprocessor_completePrerollCallback);
      if (!v21)
      {
        uint64_t v20 = FigVCPCompositorHostSetDidReachEndOfOutputCallback(*(void *)(Instance + 104), (uint64_t)videoprocessor_didReachEndOfOutputCallback);
        if (v20) {
          goto LABEL_53;
        }
        *a10 = Instance;
        goto LABEL_51;
      }
    }
  }
LABEL_76:
  uint64_t v20 = v21;
LABEL_53:
  if (cf) {
    CFRelease(cf);
  }
  if (number) {
    CFRelease(number);
  }
  if (UInt32) {
    CFRelease(UInt32);
  }
  if (v52) {
    CFRelease(v52);
  }
  if (v53) {
    CFRelease(v53);
  }
  if (v54) {
    CFRelease(v54);
  }
  if (v55) {
    CFRelease(v55);
  }
  if (v56) {
    CFRelease(v56);
  }
  if (v58[0]) {
    CFRelease(v58[0]);
  }
  if (v57) {
    CFRelease(v57);
  }
  if (Instance) {
    CFRelease((CFTypeRef)Instance);
  }
  return v20;
}

void videoprocessor_processUntilHighWaterMet(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  memset(v102, 0, sizeof(v102));
  long long v101 = 0u;
  memset(v100, 0, sizeof(v100));
  FigVCPTimingCopyProcessingState(*(void *)(a1 + 96), (uint64_t)v100);
  MEMORY[0x19970E910](*(void *)(v1 + 168));
  if (!*(unsigned char *)(v1 + 160))
  {
    MEMORY[0x19970E930](*(void *)(v1 + 168));
    goto LABEL_227;
  }
  CFTypeRef v113 = 0;
  CFTypeRef v114 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v111 = 0;
  CFTypeRef v110 = 0;
  uint64_t v2 = *(void *)(v1 + 96);
  BOOL v86 = FigVCPTimingUsesTimebase(v2);
  CFStringRef v88 = videoprocessor_loadAndRetainAtomically(v1, (CFTypeRef *)(v1 + 88));
  CFStringRef v87 = (CFTypeRef *)(v1 + 120);
  CFTypeRef v3 = videoprocessor_loadAndRetainAtomically(v1, (CFTypeRef *)(v1 + 120));
  uint64_t v82 = (uint64_t *)(v1 + 32);
  CFTypeRef v4 = videoprocessor_loadAndRetainAtomically(v1, (CFTypeRef *)(v1 + 32));
  CFTypeRef v5 = videoprocessor_loadAndRetainAtomically(v1, (CFTypeRef *)(v1 + 40));
  timebase = (OpaqueCMTimebase *)FigVCPTimingCopyTimebase(v2);
  int v99 = *(unsigned __int8 *)(v1 + 2256);
  int64_t Count = (int64_t)FigVCPSourceArrayGetCount((uint64_t)v4);
  uint64_t v7 = (CFTypeRef *)malloc_type_calloc(Count, 8uLL, 0x2004093837F09uLL);
  if (!v7)
  {
    int CanAccomodateFrame = FigSignalErrorAt();
    CFStringRef v98 = 0;
    CFMutableDictionaryRef v94 = 0;
    CFMutableDictionaryRef Mutable = 0;
    uint64_t SInt32 = 0;
    uint64_t v11 = 0;
    uint64_t v78 = 0;
    goto LABEL_199;
  }
  CGRect v90 = (__n128 *)v2;
  uint64_t v8 = malloc_type_calloc(Count, 4uLL, 0x100004052888210uLL);
  double v93 = v8;
  if (!v8)
  {
    int CanAccomodateFrame = FigSignalErrorAt();
    CFStringRef v98 = 0;
    CFMutableDictionaryRef v94 = 0;
    CFMutableDictionaryRef Mutable = 0;
    uint64_t SInt32 = 0;
    uint64_t v11 = 0;
    goto LABEL_186;
  }
  __n128 v9 = v8;
  CFArrayRef v10 = FigVCPSourceArrayGetCount((uint64_t)v5);
  uint64_t v11 = malloc_type_calloc((size_t)v10, 8uLL, 0x2004093837F09uLL);
  uint64_t v96 = (uint64_t)v10;
  if (!v11 || (CFStringRef v98 = malloc_type_calloc((size_t)v10, 4uLL, 0x100004052888210uLL)) == 0)
  {
    int CanAccomodateFrame = FigSignalErrorAt();
    CFStringRef v98 = 0;
    goto LABEL_9;
  }
  if (BYTE14(v102[1]))
  {
    int SourceTrackIDForFrameTiming = FigVCPTimingGetSourceTrackIDForFrameTiming((uint64_t)v90);
    SourceWithint TrackID = FigVCPSourceArrayGetSourceWithTrackID((uint64_t)v4, SourceTrackIDForFrameTiming);
    int v14 = FigVCPProcessingStateSetCurrentTimeWithSourceFrameTiming((uint64_t)v100, (uint64_t)SourceWithTrackID);
    if (v14)
    {
      int CanAccomodateFrame = v14;
LABEL_9:
      CFMutableDictionaryRef v94 = 0;
      CFMutableDictionaryRef Mutable = 0;
LABEL_178:
      uint64_t SInt32 = 0;
      goto LABEL_186;
    }
  }
  if (!*(unsigned char *)(v1 + 160))
  {
    CFMutableDictionaryRef v94 = 0;
    CFMutableDictionaryRef Mutable = 0;
    uint64_t SInt32 = 0;
    int CanAccomodateFrame = 0;
    goto LABEL_186;
  }
  CFMutableDictionaryRef v94 = 0;
  CFMutableDictionaryRef Mutable = 0;
  CMTimeFlags v84 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
  CMTimeEpoch v83 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  CGPoint v80 = (_DWORD *)(v1 + 240);
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  double v85 = (CFTypeRef *)(v1 + 144);
  uint64_t v79 = (const void *)*MEMORY[0x1E4F1CFD0];
  uint64_t v92 = v1;
  while (1)
  {
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
    if (v111)
    {
      CFRelease(v111);
      CFTypeRef v111 = 0;
    }
    if (v110)
    {
      CFRelease(v110);
      CFTypeRef v110 = 0;
    }
    if (BYTE14(v102[1]))
    {
LABEL_176:
      uint64_t SInt32 = 0;
      int CanAccomodateFrame = 0;
      goto LABEL_186;
    }
    HasReachedTheEndouble d = FigVCPProcessingStateHasReachedTheEnd((uint64_t)v100);
    if (HasReachedTheEnd)
    {
      if (v86) {
        goto LABEL_179;
      }
      if (FigVCPCompositorHostIsAcceptingRequest(*(void *)(v1 + 104)))
      {
        FigVCPCompositorHostStopAcceptingRequest(*(void *)(v1 + 104));
        videoprocessor_setUpcomingImageInfo(v1);
      }
      if (FigVCPSourceArrayNoMoreImagesOnAnySource((uint64_t)v4))
      {
LABEL_179:
        uint64_t SInt32 = 0;
        int CanAccomodateFrame = 0;
        *(unsigned char *)(v1 + 160) = 0;
        goto LABEL_186;
      }
    }
    if (*(unsigned char *)(v1 + 20))
    {
      updatedouble d = videoprocessor_updateCoreAnimationThrottling(v1, *(unsigned __int8 *)(v1 + 20));
      if (updated) {
        goto LABEL_184;
      }
    }
    if ((_BYTE)v101)
    {
      long long v109 = 0uLL;
      uint64_t v108 = 0;
      FigVCPTimingGetOutputFrameDuration(v90, (__n128 *)&v108);
      CMTime v107 = *(CMTime *)((char *)v102 + 4);
      uint64_t v17 = v108;
      int32_t v18 = v109;
      uint64_t v118 = *(void *)((char *)&v109 + 4);
      int v119 = HIDWORD(v109);
      float Rate = CMTimebaseGetRate(timebase);
      memset(&v117, 0, sizeof(v117));
      CMTimebaseGetTime(&v117, timebase);
      CMTimeValue v120 = *MEMORY[0x1E4F1F9F8];
      CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
      int32_t newTimescale = v18;
      if (Rate <= 0.0 || (*(CMTime *)time1 = v117, CMTime time2 = v107, CMTimeCompare((CMTime *)time1, &time2) < 1))
      {
        CMTimeEpoch epoch = v83;
        CMTimeFlags flags = v84;
        if (Rate >= 0.0) {
          goto LABEL_34;
        }
        *(CMTime *)CMTime time1 = v117;
        CMTime time2 = v107;
        CMTimeEpoch epoch = v83;
        CMTimeFlags flags = v84;
        if ((CMTimeCompare((CMTime *)time1, &time2) & 0x80000000) == 0) {
          goto LABEL_34;
        }
        *(CMTime *)CMTime time1 = v117;
        CMTimeConvertScale(&time2, (CMTime *)time1, newTimescale, kCMTimeRoundingMethod_RoundTowardNegativeInfinity);
        CMTimeFlags flags = time2.flags;
        CMTimeScale timescale = time2.timescale;
        CMTimeValue v120 = time2.value + (time2.value % v17 + v17) / v17 * v17 - (time2.value % v17 + v17);
        CMTimeEpoch epoch = time2.epoch;
        *(CMTime *)CMTime time1 = v107;
        double Seconds = CMTimeGetSeconds((CMTime *)time1);
        CMTime time2 = v107;
        rhs.CMTimeValue value = v120;
        rhs.CMTimeScale timescale = timescale;
        rhs.CMTimeFlags flags = flags;
        rhs.CMTimeEpoch epoch = epoch;
      }
      else
      {
        *(CMTime *)CMTime time1 = v117;
        CMTimeConvertScale(&time2, (CMTime *)time1, v18, kCMTimeRoundingMethod_RoundTowardPositiveInfinity);
        CMTimeFlags flags = time2.flags;
        CMTimeScale timescale = time2.timescale;
        CMTimeValue v120 = ((v17 - time2.value) % v17 + v17) % v17 + time2.value;
        CMTimeEpoch epoch = time2.epoch;
        *(CMTime *)CMTime time1 = v107;
        double Seconds = CMTimeGetSeconds((CMTime *)time1);
        time2.CMTimeValue value = v120;
        time2.CMTimeScale timescale = timescale;
        time2.CMTimeFlags flags = flags;
        time2.CMTimeEpoch epoch = epoch;
        CMTime rhs = v107;
      }
      CMTimeSubtract((CMTime *)time1, &time2, &rhs);
      double v23 = CMTimeGetSeconds((CMTime *)time1);
      time2.CMTimeValue value = v17;
      time2.CMTimeScale timescale = newTimescale;
      *(void *)&time2.CMTimeFlags flags = v118;
      HIDWORD(time2.epoch) = v119;
      double v24 = CMTimeGetSeconds(&time2);
      FigVCPTallyUpdateSkips(v80, Seconds, v23, v24);
LABEL_34:
      if (flags)
      {
        *(void *)((char *)v102 + 4) = v120;
        HIDWORD(v102[0]) = timescale;
        LODWORD(v102[1]) = flags;
        *(void *)((char *)&v102[1] + 4) = epoch;
      }
      uint64_t v1 = v92;
    }
    if (!HasReachedTheEnd)
    {
      LOBYTE(rhs.value) = 0;
      memset(&v117, 0, sizeof(v117));
      CMTime time2 = *(CMTime *)((char *)v102 + 4);
      *(_OWORD *)CMTime time1 = *(_OWORD *)&v100[24];
      *(_OWORD *)&time1[16] = *(_OWORD *)&v100[40];
      long long v106 = *(_OWORD *)&v100[56];
      FigVCPGetFoldedTime(&time2, (uint64_t)time1, &v117);
      *(CMTime *)CMTime time1 = v117;
      int v42 = FigVCPInstructionSourceCopyInstructionAtTime(v88, (uint64_t)time1, (BOOL *)&rhs, &cf);
      if (v42 == -12301)
      {
        if (BYTE12(v102[1]))
        {
          videoprocessor_sendSeekCompleteNotification();
          int CanAccomodateFrame = 0;
          BYTE12(v102[1]) = 0;
        }
        else
        {
          int CanAccomodateFrame = 0;
        }
        goto LABEL_178;
      }
      int CanAccomodateFrame = v42;
      if (v42) {
        goto LABEL_178;
      }
      if (LOBYTE(rhs.value))
      {
        HIBYTE(v102[1]) = 1;
        *(unsigned char *)(v1 + 200) = 0;
      }
    }
    if (FigVCPOutputWasJustFlushed()) {
      HIBYTE(v102[1]) = 1;
    }
    if (cf)
    {
      memset(&v117, 0, sizeof(v117));
      CMTime time2 = *(CMTime *)((char *)v102 + 4);
      *(_OWORD *)CMTime time1 = *(_OWORD *)&v100[24];
      *(_OWORD *)&time1[16] = *(_OWORD *)&v100[40];
      long long v106 = *(_OWORD *)&v100[56];
      FigVCPGetFoldedTime(&time2, (uint64_t)time1, &v117);
      *(CMTime *)CMTime time1 = v117;
      int v25 = FigVideoCompositionInstructionCopyRequiredTrackIDArrayForTime(allocator, cf, (CMTime *)time1, (__CFArray **)&v111);
      if (v111) {
        BOOL v26 = v25 == 0;
      }
      else {
        BOOL v26 = 0;
      }
      if (!v26 && v111)
      {
        CFRelease(v111);
        CFTypeRef v111 = 0;
      }
      *(CMTime *)CMTime time1 = v117;
      int v27 = FigVideoCompositionInstructionCopyRequiredSampleDataTrackIDArrayForTime((int)allocator, cf, (uint64_t)time1, (const __CFArray **)&v110);
      if (v110) {
        BOOL v28 = v27 == 0;
      }
      else {
        BOOL v28 = 0;
      }
      if (!v28 && v110)
      {
        CFRelease(v110);
        CFTypeRef v110 = 0;
      }
    }
    if ((uint64_t)FigVCPSourceArrayGetCount((uint64_t)v4) >= 1)
    {
      CFIndex v29 = 0;
      char v30 = 1;
      do
      {
        SourceAtIndedouble x = FigVCPSourceArrayGetSourceAtIndex((uint64_t)v4, v29);
        LOBYTE(v117.value) = 0;
        CFArrayRef v32 = (const __CFArray *)v111;
        int TrackID = FigVCPSourceGetTrackID();
        if (videoprocessor_isTrackRequired(v32, TrackID))
        {
          LOBYTE(time2.value) = 0;
          *(_OWORD *)CMTime time1 = *(_OWORD *)((char *)v102 + 4);
          *(void *)&time1[16] = *(void *)((char *)&v102[1] + 4);
          int v34 = FigVCPSourceCheckSampleAvailability((uint64_t)SourceAtIndex, *(unsigned int *)&v100[76], BYTE2(v101), (long long *)time1, (uint64_t)&v117, (uint64_t)&time2);
          if (v34) {
            goto LABEL_180;
          }
          if (!LOBYTE(time2.value)) {
            char v30 = 0;
          }
          if (LOBYTE(v117.value))
          {
            *(_OWORD *)CMTime time1 = *(_OWORD *)((char *)v102 + 4);
            *(void *)&time1[16] = *(void *)((char *)&v102[1] + 4);
            int v34 = FigVCPSourceSetCurrentTime((uint64_t)SourceAtIndex, *(unsigned int *)&v100[76], (long long *)time1);
            if (v34)
            {
LABEL_180:
              int CanAccomodateFrame = v34;
              uint64_t SInt32 = 0;
              goto LABEL_182;
            }
          }
        }
        ++v29;
      }
      while (v29 < (uint64_t)FigVCPSourceArrayGetCount((uint64_t)v4));
      BOOL v26 = v30 == 0;
      uint64_t v1 = v92;
      __n128 v9 = v93;
      if (v26) {
        goto LABEL_176;
      }
    }
    if ((uint64_t)FigVCPSourceArrayGetCount((uint64_t)v5) >= 1)
    {
      CFIndex v35 = 0;
      char v36 = 1;
      do
      {
        uint64_t v37 = FigVCPSourceArrayGetSourceAtIndex((uint64_t)v5, v35);
        LOBYTE(v117.value) = 0;
        CFArrayRef v38 = (const __CFArray *)v110;
        int v39 = FigVCPSourceGetTrackID();
        if (v38 && videoprocessor_isTrackRequired(v38, v39))
        {
          LOBYTE(time2.value) = 0;
          *(_OWORD *)CMTime time1 = *(_OWORD *)((char *)v102 + 4);
          *(void *)&time1[16] = *(void *)((char *)&v102[1] + 4);
          int v34 = FigVCPSourceCheckSampleAvailability((uint64_t)v37, *(unsigned int *)&v100[76], BYTE2(v101), (long long *)time1, (uint64_t)&v117, (uint64_t)&time2);
          if (v34) {
            goto LABEL_180;
          }
          if (!LOBYTE(time2.value)) {
            char v36 = 0;
          }
          if (LOBYTE(v117.value))
          {
            *(_OWORD *)CMTime time1 = *(_OWORD *)((char *)v102 + 4);
            *(void *)&time1[16] = *(void *)((char *)&v102[1] + 4);
            int v34 = FigVCPSourceSetCurrentTime((uint64_t)v37, *(unsigned int *)&v100[76], (long long *)time1);
            if (v34) {
              goto LABEL_180;
            }
          }
        }
        ++v35;
      }
      while (v35 < (uint64_t)FigVCPSourceArrayGetCount((uint64_t)v5));
      BOOL v26 = v36 == 0;
      uint64_t v1 = v92;
      __n128 v9 = v93;
      if (v26) {
        goto LABEL_176;
      }
    }
    if (!*(unsigned char *)(v1 + 200))
    {
      time2.CMTimeValue value = 0;
      updatedouble d = FigVideoCompositionInstructionGetLayerCountExcludingBackground(cf, &time2.value);
      if (updated) {
        goto LABEL_184;
      }
      CMTimeValue value = time2.value;
      *(void *)CMTime time1 = 0;
      v117.CMTimeValue value = 0;
      if (v4) {
        CFArrayRef v41 = FigVCPSourceArrayGetCount((uint64_t)v4);
      }
      else {
        CFArrayRef v41 = 0;
      }
      if (!FigVCPCompositorHostDoesRequireDifferentSourcePixelBufferAttributesForMultiSource(*(void *)(v1 + 104))
        || ((uint64_t v43 = *(void *)(v1 + 104), value > 1) || (uint64_t)v41 >= 2
          ? (int v45 = FigVCPCompositorHostCopySourcePixelBufferAttributesForMultiSource(*(void *)(v1 + 104), time1))
          : (CFAllocatorRef v44 = CFGetAllocator((CFTypeRef)v1),
             int v45 = FigVCPCompositorHostCopyProperty(v43, @"VideoCompositionProcessor_SourcePixelBufferAttributes", (uint64_t)v44, (uint64_t)time1)), v45))
      {
LABEL_98:
        if (*(void *)time1) {
          CFRelease(*(CFTypeRef *)time1);
        }
      }
      else if (*(void *)time1)
      {
        FigVCPPreprocessParametersSetProperty(*(void *)(v1 + 24), @"VideoCompositionProcessor_SourcePixelBufferAttributes", *(uint64_t *)time1);
        if ((uint64_t)FigVCPSourceArrayGetCount((uint64_t)v4) >= 1)
        {
          CFIndex v46 = 0;
          do
          {
            if (v117.value)
            {
              CFRelease((CFTypeRef)v117.value);
              v117.CMTimeValue value = 0;
            }
            if (FigVCPPreprocessParametersCreateCopy((uint64_t)allocator, *(void *)(v1 + 24), &v117.value))break; {
            uint64_t v47 = FigVCPSourceArrayGetSourceAtIndex((uint64_t)v4, v46);
            }
            FigVCPSourceSetPreprocessParameters((uint64_t)v47, (const void *)v117.value);
            if (v117.value)
            {
              CFRelease((CFTypeRef)v117.value);
              v117.CMTimeValue value = 0;
            }
            ++v46;
          }
          while (v46 < (uint64_t)FigVCPSourceArrayGetCount((uint64_t)v4));
        }
        goto LABEL_98;
      }
      if (v117.value) {
        CFRelease((CFTypeRef)v117.value);
      }
      *(unsigned char *)(v1 + 200) = 1;
      __n128 v9 = v93;
    }
    if (v99)
    {
      if (v114)
      {
        CFRelease(v114);
        CFTypeRef v114 = 0;
      }
      if (v113)
      {
        CFRelease(v113);
        CFTypeRef v113 = 0;
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (v94) {
        CFRelease(v94);
      }
      uint64_t v48 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      double v49 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFMutableDictionaryRef v94 = CFDictionaryCreateMutable(allocator, 0, v48, v49);
    }
    if ((uint64_t)FigVCPSourceArrayGetCount((uint64_t)v4) >= 1) {
      break;
    }
LABEL_129:
    if ((uint64_t)FigVCPSourceArrayGetCount((uint64_t)v5) >= 1)
    {
      CFIndex v57 = 0;
      do
      {
        double v58 = FigVCPSourceArrayGetSourceAtIndex((uint64_t)v5, v57);
        double v59 = (const void *)v11[v57];
        if (v59)
        {
          CFRelease(v59);
          v11[v57] = 0;
        }
        v98[v57] = FigVCPSourceGetTrackID();
        CFArrayRef v60 = (const __CFArray *)v110;
        int v61 = FigVCPSourceGetTrackID();
        if (v60 && videoprocessor_isTrackRequired(v60, v61))
        {
          *(void *)CMTime time1 = 0;
          if (v99)
          {
            FigVCPSourceGetTrackID();
            uint64_t SInt32 = (const void *)FigCFNumberCreateSInt32();
            int v56 = FigVCPSourceCopyTimedSampleBuffers((uint64_t)v58, *(unsigned int *)&v100[76], (uint64_t)&v113);
            if (v56) {
              goto LABEL_181;
            }
            FigCFDictionarySetValue();
            if (SInt32) {
              CFRelease(SInt32);
            }
            if (v113)
            {
              CFRelease(v113);
              CFTypeRef v113 = 0;
            }
          }
          else
          {
            int v34 = FigVCPSourceCopySampleBuffer((uint64_t)v58, (uint64_t)time1);
            if (v34) {
              goto LABEL_180;
            }
            v11[v57] = *(void *)time1;
          }
        }
        ++v57;
      }
      while (v57 < (uint64_t)FigVCPSourceArrayGetCount((uint64_t)v5));
    }
    uint64_t v1 = v92;
    CFTypeRef v62 = videoprocessor_loadAndRetainAtomically(v92, v85);
    if (v62)
    {
      CFRelease(v62);
      HIBYTE(v102[1]) = 1;
    }
    CFTypeRef v63 = videoprocessor_loadAndRetainAtomically(v92, v87);
    PendingFramesint64_t Count = FigVCPCompositorHostGetPendingFramesCount();
    int CanAccomodateFrame = FigVCPOutputAllOutputsCanAccomodateFrame((uint64_t)v63, PendingFramesCount);
    if (v63) {
      CFRelease(v63);
    }
    if (!CanAccomodateFrame) {
      goto LABEL_185;
    }
    if (!HasReachedTheEnd)
    {
      if (HIBYTE(v102[1])
        || FigVCPTimingRepeatIdenticalFrames((uint64_t)v90)
        || v79 == CFDictionaryGetValue((CFDictionaryRef)cf, @"ContainsTweening"))
      {
        char v65 = 0;
      }
      else
      {
        if (BYTE12(v102[1]))
        {
          videoprocessor_sendSeekCompleteNotification();
          BYTE12(v102[1]) = 0;
        }
        if (v86
          && FigVCPSourceArrayNoMoreImagesOnAnySource(*v82)
          && videoprocessor_willCompositionInstructionContinueForever((const __CFDictionary *)cf, *(int *)&v100[76]))
        {
          goto LABEL_176;
        }
        ++*(_DWORD *)(v92 + 2252);
        char v65 = 1;
      }
      uint64_t v66 = *(void *)(v92 + 104);
      CMTime v117 = *(CMTime *)((char *)v102 + 4);
      CMTime time2 = *(CMTime *)v100;
      *(_OWORD *)CMTime time1 = *(_OWORD *)&v100[24];
      *(_OWORD *)&time1[16] = *(_OWORD *)&v100[40];
      long long v106 = *(_OWORD *)&v100[56];
      updatedouble d = FigVCPCompositorHostAnticipateRendering(v66, &v117, (uint64_t)&time2, *(int *)&v100[76], (long long *)time1);
      if (updated) {
        goto LABEL_184;
      }
      if ((v65 & 1) == 0)
      {
        HIBYTE(v102[1]) = 0;
        uint64_t v67 = *(void *)(v92 + 104);
        CFTypeRef v68 = cf;
        if (v99)
        {
          CMTime v117 = *(CMTime *)((char *)v102 + 4);
          *(_OWORD *)CMTime time1 = *(_OWORD *)&v100[24];
          *(_OWORD *)&time1[16] = *(_OWORD *)&v100[40];
          long long v106 = *(_OWORD *)&v100[56];
          FigVCPGetFoldedTime(&v117, (uint64_t)time1, &v104);
          *(_OWORD *)CMTime time1 = *(_OWORD *)((char *)v102 + 4);
          *(void *)&time1[16] = *(void *)((char *)&v102[1] + 4);
          updatedouble d = FigVCPCompositorHostPrepareToComposeFromWindow(v67, v68, (long long *)time1, (long long *)&v104.value, SBYTE13(v102[1]), *(int *)&v100[72], *(int *)&v100[76], Mutable, v94);
          if (updated) {
            goto LABEL_184;
          }
        }
        else
        {
          CMTime v117 = *(CMTime *)((char *)v102 + 4);
          *(_OWORD *)CMTime time1 = *(_OWORD *)&v100[24];
          *(_OWORD *)&time1[16] = *(_OWORD *)&v100[40];
          long long v106 = *(_OWORD *)&v100[56];
          FigVCPGetFoldedTime(&v117, (uint64_t)time1, &v103);
          char v69 = BYTE13(v102[1]);
          uint64_t v70 = *(void *)&v100[72];
          CFArrayRef v71 = FigVCPSourceArrayGetCount((uint64_t)v4);
          CFArrayRef v72 = FigVCPSourceArrayGetCount((uint64_t)v5);
          *(_OWORD *)CMTime time1 = *(_OWORD *)((char *)v102 + 4);
          *(void *)&time1[16] = *(void *)((char *)&v102[1] + 4);
          uint64_t v73 = (uint64_t)v71;
          uint64_t v1 = v92;
          updatedouble d = FigVCPCompositorHostPrepareToCompose(v67, v68, (long long *)time1, (long long *)&v103.value, v69, v70, SHIDWORD(v70), v73, (uint64_t)v93, (uint64_t)v7, (uint64_t)v72, (uint64_t)v98, (uint64_t)v11);
          if (updated) {
            goto LABEL_184;
          }
        }
        updatedouble d = videoprocessor_setUpcomingImageInfo(v1);
        if (updated) {
          goto LABEL_184;
        }
        updatedouble d = FigVCPCompositorHostComposeFrameAsync(*(void *)(v1 + 104));
        if (updated) {
          goto LABEL_184;
        }
      }
      updatedouble d = FigVCPProcessingStateAdvanceCurrentTime((uint64_t)v100, (uint64_t)v4, (uint64_t)v90);
      if (updated)
      {
LABEL_184:
        int CanAccomodateFrame = updated;
LABEL_185:
        uint64_t SInt32 = 0;
        goto LABEL_186;
      }
      __n128 v9 = v93;
      if (!FigVCPTimingIsProcessingStateFresh((uint64_t)v90, (uint64_t)v100)) {
        goto LABEL_176;
      }
    }
    if (!*(unsigned char *)(v1 + 160)) {
      goto LABEL_176;
    }
  }
  CFIndex v50 = 0;
  while (2)
  {
    CGSize v51 = FigVCPSourceArrayGetSourceAtIndex((uint64_t)v4, v50);
    CFTypeRef v52 = v7[v50];
    if (v52)
    {
      CFRelease(v52);
      v7[v50] = 0;
    }
    v9[v50] = FigVCPSourceGetTrackID();
    CFArrayRef v53 = (const __CFArray *)v111;
    int v54 = FigVCPSourceGetTrackID();
    if (!videoprocessor_isTrackRequired(v53, v54)) {
      goto LABEL_128;
    }
    LOBYTE(v117.value) = 0;
    *(void *)CMTime time1 = 0;
    if (!v99)
    {
      int v34 = FigVCPSourceCopyConformedImage((uint64_t)v51, (uint64_t)&v117, (uint64_t)time1);
      if (v34) {
        goto LABEL_180;
      }
      v7[v50] = *(CFTypeRef *)time1;
LABEL_126:
      if (LOBYTE(v117.value)) {
        HIBYTE(v102[1]) = 1;
      }
LABEL_128:
      if (++v50 >= (uint64_t)FigVCPSourceArrayGetCount((uint64_t)v4)) {
        goto LABEL_129;
      }
      continue;
    }
    break;
  }
  FigVCPSourceGetTrackID();
  uint64_t SInt32 = (const void *)FigCFNumberCreateSInt32();
  int v56 = FigVCPSourceCopyConformedTimedImages((uint64_t)v51, *(unsigned int *)&v100[76], (uint64_t)&v117, (uint64_t)&v114);
  if (!v56)
  {
    FigCFDictionarySetValue();
    if (SInt32) {
      CFRelease(SInt32);
    }
    if (v114)
    {
      CFRelease(v114);
      CFTypeRef v114 = 0;
    }
    goto LABEL_126;
  }
LABEL_181:
  int CanAccomodateFrame = v56;
LABEL_182:
  uint64_t v1 = v92;
LABEL_186:
  if (Count >= 1)
  {
    uint64_t v74 = v7;
    do
    {
      if (*v74) {
        CFRelease(*v74);
      }
      ++v74;
      --Count;
    }
    while (Count);
  }
  if (!v11)
  {
    uint64_t v78 = v93;
LABEL_199:
    uint64_t v75 = v88;
    goto LABEL_200;
  }
  uint64_t v75 = v88;
  if (v96 >= 1)
  {
    for (uint64_t i = 0; i != v96; ++i)
    {
      uint64_t v77 = (const void *)v11[i];
      if (v77) {
        CFRelease(v77);
      }
    }
  }
  uint64_t v78 = v93;
LABEL_200:
  if (timebase) {
    CFRelease(timebase);
  }
  if (v75) {
    CFRelease(v75);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v111) {
    CFRelease(v111);
  }
  if (v110) {
    CFRelease(v110);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v114) {
    CFRelease(v114);
  }
  if (v113) {
    CFRelease(v113);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v94) {
    CFRelease(v94);
  }
  if (SInt32) {
    CFRelease(SInt32);
  }
  free(v78);
  free(v7);
  free(v98);
  free(v11);
  MEMORY[0x19970E930](*(void *)(v1 + 168));
  if (CanAccomodateFrame) {
    videoprocessor_reportProcessingError(v1);
  }
  else {
LABEL_227:
  }
    FigVCPTimingSaveProcessingState(*(void *)(v1 + 96), (uint64_t)v100);
}

uint64_t videoprocessor_OnLowOutputQueueLevel(uint64_t a1, uint64_t a2)
{
  return videoprocessor_triggerProcessing(a2);
}

void videoprocessor_frameCompleteCallback(__n128 *a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  long long v24 = *MEMORY[0x1E4F1F9F8];
  uint64_t v25 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  uint64_t CompositionStartTime = FigVCPPendingFrameGetCompositionStartTime((uint64_t)a1);
  UpTimeNanoFloat64 seconds = FigGetUpTimeNanoseconds();
  int CompletionStatus = FigVCPPendingFrameGetCompletionStatus((uint64_t)a1);
  uint64_t v7 = 0;
  if (CompletionStatus == -12508) {
    goto LABEL_41;
  }
  CFTypeRef v8 = 0;
  __n128 v9 = 0;
  if (!CompletionStatus)
  {
    FigVCPPendingFrameGetFrameTime(a1, (__n128 *)&v24);
    ComposedFrame = (__CVBuffer *)FigVCPPendingFrameGetComposedFrame((uint64_t)a1);
    FigVCPTallyUpdateTimingInfo(a2 + 208, CompositionStartTime, UpTimeNanoseconds);
    if (FigVCPPendingFrameSkipCoreAnimationPostProcessing((uint64_t)a1))
    {
      uint64_t v7 = 0;
      goto LABEL_21;
    }
    long long v22 = v24;
    uint64_t v23 = v25;
    CFIndex v29 = 0;
    CFTypeRef v30 = 0;
    CFTypeRef v11 = videoprocessor_loadAndRetainAtomically(a2, (CFTypeRef *)(a2 + 144));
    if (v11)
    {
      int v12 = FigVCPOutputConformerCopyProperty(*(void *)(a2 + 112), @"VideoCompositionProcessor_DestinationPixelBufferDesiredAttributes", *MEMORY[0x1E4F1CF80], &v30);
      if (v12)
      {
        int v14 = v12;
        goto LABEL_10;
      }
      long long v27 = v22;
      uint64_t v28 = v23;
      int v13 = FigVCPCoreAnimationPostProcessorCopyPixelBufferAtTime((uint64_t)v11, (uint64_t)&v27, ComposedFrame, (uint64_t)v30, (CFTypeRef *)&v29);
      uint64_t v7 = v29;
      if (v13)
      {
        int v14 = v13;
        if (!v29)
        {
LABEL_15:
          if (v30) {
            CFRelease(v30);
          }
          if (v11) {
            CFRelease(v11);
          }
          if (v14)
          {
            CFTypeRef v8 = 0;
LABEL_48:
            __n128 v9 = 0;
            goto LABEL_46;
          }
          ComposedFrame = v7;
LABEL_21:
          CFTypeRef v8 = videoprocessor_loadAndRetainAtomically(a2, (CFTypeRef *)(a2 + 120));
          if (!FigVCPOutputConformerCopyConformedPixelBuffer(*(void *)(a2 + 112), ComposedFrame, (CVPixelBufferRef *)&cf))
          {
            double v15 = (__CVBuffer *)cf;
            FigVCPPendingFrameSetRenderedFrame((uint64_t)a1, cf);
            int HDRStats = FigVCPPendingFrameShouldGenerateHDRStats((uint64_t)a1, v15);
            int IsImmediateFrame = FigVCPPendingFrameIsImmediateFrame((uint64_t)a1);
            if (HDRStats)
            {
              if (IsImmediateFrame) {
                FigVCPCompositorHostDropEarlierPendingFrames(*(void *)(a2 + 104), (uint64_t)a1);
              }
              if (!FigVCPOutputCalculateAndStoreHDRStats((uint64_t)v8, (uint64_t)v15, (uint64_t)a1))
              {
                __n128 v9 = 0;
                while (1)
                {
                  if (v9) {
                    CFRelease(v9);
                  }
                  int32_t v18 = (__n128 *)FigVCPCompositorHostRemoveRetainedPendingFrameForOutput(*(void *)(a2 + 104));
                  __n128 v9 = v18;
                  if (!v18) {
                    break;
                  }
                  uint64_t RenderedFrameWithHDRMetadata = FigVCPPendingFrameGetRenderedFrameWithHDRMetadata((uint64_t)v18);
                  FigVCPPendingFrameGetFrameTime(v9, &v21);
                  int v20 = FigVCPPendingFrameIsImmediateFrame((uint64_t)v9);
                  if (FigVCPOutputEnqueueImage((uint64_t)v8, RenderedFrameWithHDRMetadata, (long long *)&v21, v20))goto LABEL_46; {
                  FigVCPCompositorHostFinishOutputFrame(*(void *)(a2 + 104));
                  }
                  if (FigVCPPendingFrameIsImmediateFrame((uint64_t)v9))
                  {
                    FigVCPPendingFrameGetOrder((uint64_t)v9);
                    videoprocessor_sendSeekCompleteNotification();
                  }
                }
LABEL_37:
                if (!v8) {
                  goto LABEL_39;
                }
                goto LABEL_38;
              }
            }
            else
            {
              long long v27 = v24;
              uint64_t v28 = v25;
              if (!FigVCPOutputEnqueueImage((uint64_t)v8, (uint64_t)v15, &v27, IsImmediateFrame))
              {
                FigVCPCompositorHostRemovePendingFrame(*(void *)(a2 + 104), (uint64_t)a1);
                FigVCPPendingFrameSetRenderComplete();
                if (FigVCPPendingFrameIsImmediateFrame((uint64_t)a1))
                {
                  FigVCPPendingFrameGetOrder((uint64_t)a1);
                  videoprocessor_sendSeekCompleteNotification();
                }
                __n128 v9 = 0;
                goto LABEL_37;
              }
            }
          }
          goto LABEL_48;
        }
        CFRelease(v29);
LABEL_10:
        uint64_t v7 = 0;
        goto LABEL_15;
      }
    }
    else if (ComposedFrame)
    {
      uint64_t v7 = (__CVBuffer *)CFRetain(ComposedFrame);
    }
    else
    {
      uint64_t v7 = 0;
    }
    int v14 = 0;
    CFIndex v29 = 0;
    goto LABEL_15;
  }
LABEL_46:
  videoprocessor_reportProcessingError(a2);
  if (v8) {
LABEL_38:
  }
    CFRelease(v8);
LABEL_39:
  if (v9) {
    CFRelease(v9);
  }
LABEL_41:
  if (cf) {
    CFRelease(cf);
  }
  if (v7) {
    CFRelease(v7);
  }
}

void videoprocessor_completePrerollCallback()
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  CMNotificationCenterGetDefaultLocalCenter();
  FigDispatchAsyncPostNotification();
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

uint64_t videoprocessor_didReachEndOfOutputCallback(uint64_t a1)
{
  videoprocessor_setUpcomingImageInfo(a1);
  CMNotificationCenterGetDefaultLocalCenter();

  return CMNotificationCenterPostNotification();
}

uint64_t FigVideoCompositionProcessorHasAnySourceTracksInArray(uint64_t a1, CFArrayRef theArray)
{
  uint64_t v2 = (uint64_t)theArray;
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      CFIndex v5 = Count;
      CFTypeRef v6 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
      CFTypeRef v7 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 40));
      uint64_t v8 = 0;
      while (!FigCFArrayGetInt32AtIndex()
           || (!v6 || !FigVCPSourceArrayGetSourceWithTrackID((uint64_t)v6, 0))
           && (!v7 || !FigVCPSourceArrayGetSourceWithTrackID((uint64_t)v7, 0)))
      {
        if (v5 == ++v8)
        {
          uint64_t v2 = 0;
          if (!v6) {
            goto LABEL_12;
          }
          goto LABEL_11;
        }
      }
      uint64_t v2 = 1;
      if (v6) {
LABEL_11:
      }
        CFRelease(v6);
LABEL_12:
      if (v7) {
        CFRelease(v7);
      }
    }
  }
  return v2;
}

CFTypeRef videoprocessor_loadAndRetainAtomically(uint64_t a1, CFTypeRef *a2)
{
  MEMORY[0x19970E910](*(void *)(a1 + 176));
  if (*a2) {
    CFTypeRef v4 = CFRetain(*a2);
  }
  else {
    CFTypeRef v4 = 0;
  }
  MEMORY[0x19970E930](*(void *)(a1 + 176));
  return v4;
}

uint64_t FigVideoCompositionProcessorSetOutputDurationHighAndLowWaterLevels(uint64_t a1, CMTime *a2, CMTime *a3)
{
  CFTypeRef v5 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 120));
  if (!FigVCPIsValid()) {
    goto LABEL_11;
  }
  if ((a3->flags & 0x1D) != 1) {
    goto LABEL_11;
  }
  CMTime time1 = *a3;
  long long v10 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&time2.CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v6 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  time2.CMTimeEpoch epoch = v6;
  if (CMTimeCompare(&time1, &time2) < 0) {
    goto LABEL_11;
  }
  if ((a2->flags & 0x1D) == 1
    && (time1 = *a2, *(_OWORD *)&time2.value = v10, time2.CMTimeEpoch epoch = v6, CMTimeCompare(&time1, &time2) > 0)
    && (time1 = *a3, CMTime time2 = *a2, CMTimeCompare(&time1, &time2) < 1))
  {
    CMTime time1 = *a2;
    CMTime time2 = *a3;
    uint64_t v7 = FigVCPOutputSetOutputDurationHighAndLowWaterLevels((uint64_t)v5, &time1, &time2);
  }
  else
  {
LABEL_11:
    uint64_t v7 = FigSignalErrorAt();
  }
  uint64_t v8 = v7;
  if (v5) {
    CFRelease(v5);
  }
  return v8;
}

void FigVideoCompositionProcessorInvalidate(uint64_t a1)
{
  if (a1 && FigVCPInvalidatePrologue())
  {
    *(unsigned char *)(a1 + 160) = 0;
    CFTypeRef v2 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 120));
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    CFTypeRef v3 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
    CFTypeRef v4 = v3;
    if (v3) {
      FigVCPSourceArrayApplyFunction((uint64_t)v3, (uint64_t (*)(const void *, uint64_t))videoprocessor_invalidateSource, 0);
    }
    CFTypeRef v5 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 40));
    CMTimeEpoch v6 = v5;
    if (v5) {
      FigVCPSourceArrayApplyFunction((uint64_t)v5, (uint64_t (*)(const void *, uint64_t))videoprocessor_invalidateSource, 0);
    }
    FigVCPTimingInvalidate(*(void *)(a1 + 96));
    FigVCPCompositorHostInvalidate(*(void *)(a1 + 104));
    FigVCPOutputInvalidate((uint64_t)v2);
    uint64_t FigBaseObject = FigActivitySchedulerGetFigBaseObject(*(void *)(a1 + 128));
    if (FigBaseObject)
    {
      uint64_t v8 = FigBaseObject;
      uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v10 = v9 ? v9 : 0;
      CFTypeRef v11 = *(void (**)(uint64_t))(v10 + 24);
      if (v11) {
        v11(v8);
      }
    }
    FigVCPInvalidateEpilogue();
    if (v2) {
      CFRelease(v2);
    }
    if (v4) {
      CFRelease(v4);
    }
    if (v6)
    {
      CFRelease(v6);
    }
  }
}

uint64_t FigVideoCompositionProcessorStop(uint64_t a1)
{
  *(unsigned char *)(a1 + 160) = 0;
  return 0;
}

uint64_t FigVideoCompositionProcessorSetSourceVisualContext(uint64_t a1, int a2, int a3, long long *a4, const void *a5)
{
  uint64_t v28 = 0;
  CFIndex v29 = 0;
  if (!FigVCPIsValid())
  {
    uint64_t Copy = FigSignalErrorAt();
LABEL_16:
    uint64_t v20 = Copy;
    CFTypeRef v11 = 0;
    goto LABEL_8;
  }
  if (a3 == 1986618469)
  {
    uint64_t Copy = FigVCPPreprocessParametersCreateCopy(*MEMORY[0x1E4F1CF80], *(void *)(a1 + 24), (uint64_t *)&v28);
    if (Copy) {
      goto LABEL_16;
    }
  }
  CFTypeRef v11 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
  CFAllocatorRef v12 = CFGetAllocator(v11);
  long long v13 = a4[3];
  long long v24 = a4[2];
  long long v25 = v13;
  long long v14 = a4[5];
  long long v26 = a4[4];
  long long v27 = v14;
  long long v15 = a4[1];
  long long v22 = *a4;
  long long v23 = v15;
  uint64_t v16 = FigVCPSourceArrayCopyAndAddNewVisualContext(v12, (uint64_t)v11, a2, a3, a5, v28, &v22, (uint64_t)videoprocessor_AvailableTimeRangeChanged, a1, &v29);
  if (v16)
  {
    uint64_t v20 = v16;
  }
  else
  {
    videoprocessor_releaseAssignAndRetainAtomically(a1, (const void **)(a1 + 32), v29);
    long long v17 = a4[3];
    long long v24 = a4[2];
    long long v25 = v17;
    long long v18 = a4[5];
    long long v26 = a4[4];
    long long v27 = v18;
    long long v19 = a4[1];
    long long v22 = *a4;
    long long v23 = v19;
    if (!FigVideoCompositionTimeWindowDurationIsZero((uint64_t)&v22)) {
      *(unsigned char *)(a1 + 2256) = 1;
    }
    videoprocessor_triggerProcessing(a1);
    uint64_t v20 = 0;
  }
LABEL_8:
  if (v28) {
    CFRelease(v28);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v29) {
    CFRelease(v29);
  }
  return v20;
}

uint64_t videoprocessor_AvailableTimeRangeChanged(uint64_t a1, uint64_t a2)
{
  uint64_t result = FigVCPSourceShouldTriggerWhenAvailabilityChanges();
  if (result)
  {
    return videoprocessor_triggerProcessing(a2);
  }
  return result;
}

void videoprocessor_releaseAssignAndRetainAtomically(uint64_t a1, const void **a2, const void *a3)
{
  MEMORY[0x19970E910](*(void *)(a1 + 176));
  CFTypeRef v5 = *a2;
  *a2 = a3;
  if (a3) {
    CFRetain(a3);
  }
  if (v5) {
    CFRelease(v5);
  }

  JUMPOUT(0x19970E930);
}

uint64_t videoprocessor_triggerProcessing(uint64_t result)
{
  if (*(unsigned char *)(result + 160))
  {
    uint64_t v1 = *(void *)(result + 128);
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v4 = *(void *)(VTable + 16);
    uint64_t result = VTable + 16;
    uint64_t v3 = v4;
    uint64_t v5 = v4 ? v3 : 0;
    CMTimeEpoch v6 = *(uint64_t (**)(uint64_t))(v5 + 16);
    if (v6)
    {
      return v6(v1);
    }
  }
  return result;
}

uint64_t FigVideoCompositionProcessorSetSourceVisualContextGroup(uint64_t a1, int a2, int a3, long long *a4, uint64_t a5)
{
  uint64_t v28 = 0;
  CFIndex v29 = 0;
  if (!a1)
  {
    FigSignalErrorAt();
    uint64_t v20 = 0;
    goto LABEL_14;
  }
  if (a5)
  {
    CFDictionaryRef ValueAtIndex = (const void *)FigCFArrayGetValueAtIndex();
    if (FigVCPIsValid())
    {
      if (a3 != 1986618469
        || (uint64_t Copy = FigVCPPreprocessParametersCreateCopy(*MEMORY[0x1E4F1CF80], *(void *)(a1 + 24), (uint64_t *)&v28),
            !Copy))
      {
        CFTypeRef v11 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
        CFAllocatorRef v12 = CFGetAllocator(v11);
        long long v13 = a4[3];
        long long v24 = a4[2];
        long long v25 = v13;
        long long v14 = a4[5];
        long long v26 = a4[4];
        long long v27 = v14;
        long long v15 = a4[1];
        long long v22 = *a4;
        long long v23 = v15;
        uint64_t v16 = FigVCPSourceArrayCopyAndAddNewVisualContext(v12, (uint64_t)v11, a2, a3, ValueAtIndex, v28, &v22, (uint64_t)videoprocessor_AvailableTimeRangeChanged, a1, &v29);
        if (v16)
        {
          uint64_t v20 = v16;
        }
        else
        {
          videoprocessor_releaseAssignAndRetainAtomically(a1, (const void **)(a1 + 32), v29);
          long long v17 = a4[3];
          long long v24 = a4[2];
          long long v25 = v17;
          long long v18 = a4[5];
          long long v26 = a4[4];
          long long v27 = v18;
          long long v19 = a4[1];
          long long v22 = *a4;
          long long v23 = v19;
          if (!FigVideoCompositionTimeWindowDurationIsZero((uint64_t)&v22)) {
            *(unsigned char *)(a1 + 2256) = 1;
          }
          videoprocessor_triggerProcessing(a1);
          uint64_t v20 = 0;
        }
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t Copy = FigSignalErrorAt();
    }
    uint64_t v20 = Copy;
  }
  else
  {
    FigSignalErrorAt();
    uint64_t v20 = 0;
  }
  CFTypeRef v11 = 0;
LABEL_10:
  if (v28) {
    CFRelease(v28);
  }
  if (v11) {
    CFRelease(v11);
  }
LABEL_14:
  if (v29) {
    CFRelease(v29);
  }
  return v20;
}

uint64_t FigVideoCompositionProcessorSetAnimationLayer(uint64_t a1, int a2, const void *a3, const __CFArray *a4, uint64_t a5, const void *a6)
{
  CFTypeRef v20 = 0;
  CFTypeRef v21 = 0;
  CFTypeRef cf = 0;
  if (!FigVCPIsValid()
    || a2 && a4
    || a4 && CFArrayGetCount(a4) <= 0
    || a5
    || *(_DWORD *)(a1 + 136) == 1 && a3 && *(unsigned char *)(a1 + 20))
  {
    uint64_t RenderSize = FigSignalErrorAt();
    goto LABEL_28;
  }
  if (!a2)
  {
    uint64_t RenderSize = FigVCPCoreAnimationPostProcessorCreate(*MEMORY[0x1E4F1CF80], a3, a4, a6, &v20);
    if (!RenderSize)
    {
      videoprocessor_releaseAssignAndRetainAtomically(a1, (const void **)(a1 + 144), v20);
      CFTypeRef v13 = 0;
      goto LABEL_17;
    }
    goto LABEL_28;
  }
  v18.double width = 0.0;
  v18.double height = 0.0;
  uint64_t RenderSize = FigVCPCompositorHostGetRenderSize(*(void *)(a1 + 104), &v18);
  if (RenderSize
    || (uint64_t RenderSize = FigVCPPreprocessParametersCreateCopy(*MEMORY[0x1E4F1CF80], *(void *)(a1 + 24), (uint64_t *)&cf),
        RenderSize))
  {
LABEL_28:
    uint64_t v16 = RenderSize;
    CFTypeRef v13 = 0;
    goto LABEL_18;
  }
  CFTypeRef v13 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
  CFAllocatorRef v14 = CFGetAllocator(v13);
  uint64_t v15 = FigVCPSourceArrayCopyAndAddNewCoreAnimationSource(v14, (uint64_t)v13, a2, a3, a6, cf, &v21, v18.width, v18.height);
  if (!v15)
  {
    videoprocessor_releaseAssignAndRetainAtomically(a1, (const void **)(a1 + 32), v21);
LABEL_17:
    videoprocessor_triggerProcessing(a1);
    uint64_t v16 = 0;
    goto LABEL_18;
  }
  uint64_t v16 = v15;
LABEL_18:
  if (cf) {
    CFRelease(cf);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v16;
}

uint64_t FigVideoCompositionProcessorSetSourceBufferQueue(uint64_t a1, int a2, _OWORD *a3, opaqueCMBufferQueue *a4, uint64_t a5)
{
  CFIndex v29 = 0;
  if (!FigVCPIsValid())
  {
    uint64_t v10 = FigSignalErrorAt();
    goto LABEL_17;
  }
  *(_OWORD *)CMTime time = *MEMORY[0x1E4F1F9F8];
  *(void *)&time[16] = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  uint64_t v10 = CMBufferQueueInstallTrigger(a4, (CMBufferQueueTriggerCallback)videoprocessor_triggerProcessingByBufferQueue, (void *)a1, 7, (CMTime *)time, (CMBufferQueueTriggerToken *)(a1 + 56));
  if (v10)
  {
LABEL_17:
    uint64_t v17 = v10;
    goto LABEL_13;
  }
  CFTypeRef v11 = *(const void **)(a1 + 48);
  *(void *)(a1 + 48) = a4;
  if (a4) {
    CFRetain(a4);
  }
  if (v11) {
    CFRelease(v11);
  }
  CFTypeRef v12 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 40));
  CFAllocatorRef v13 = CFGetAllocator(v12);
  long long v27 = *(_OWORD *)a5;
  uint64_t v28 = *(void *)(a5 + 16);
  long long v14 = a3[3];
  long long v23 = a3[2];
  long long v24 = v14;
  long long v15 = a3[5];
  long long v25 = a3[4];
  long long v26 = v15;
  long long v16 = a3[1];
  *(_OWORD *)CMTime time = *a3;
  *(_OWORD *)&time[16] = v16;
  uint64_t v17 = FigVCPSourceArrayCopyAndAddNewBufferQueue(v13, (uint64_t)v12, a2, a4, &v27, time, (uint64_t)videoprocessor_AvailableTimeRangeChanged, a1, &v29);
  if (!v17)
  {
    videoprocessor_releaseAssignAndRetainAtomically(a1, (const void **)(a1 + 40), v29);
    long long v18 = a3[3];
    long long v23 = a3[2];
    long long v24 = v18;
    long long v19 = a3[5];
    long long v25 = a3[4];
    long long v26 = v19;
    long long v20 = a3[1];
    *(_OWORD *)CMTime time = *a3;
    *(_OWORD *)&time[16] = v20;
    if (!FigVideoCompositionTimeWindowDurationIsZero((uint64_t)time)) {
      *(unsigned char *)(a1 + 2256) = 1;
    }
    videoprocessor_triggerProcessing(a1);
  }
  if (v12) {
    CFRelease(v12);
  }
LABEL_13:
  if (v29) {
    CFRelease(v29);
  }
  return v17;
}

uint64_t FigVideoCompositionProcessorSetCompositionInstructionCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFTypeRef cf = 0;
  if (FigVCPIsValid())
  {
    uint64_t v6 = FigVCPInstructionSourceCreate(*MEMORY[0x1E4F1CF80], a2, a3, a1, &cf);
    CFTypeRef v7 = cf;
    if (!v6)
    {
      videoprocessor_releaseAssignAndRetainAtomically(a1, (const void **)(a1 + 88), cf);
      videoprocessor_triggerProcessing(a1);
      CFTypeRef v7 = cf;
    }
    if (v7) {
      CFRelease(v7);
    }
    return v6;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigVideoCompositionProcessorSetHDRDisplayMetadataPolicy(uint64_t a1, const void *a2)
{
  if (FigVCPIsValid())
  {
    FigVCPOutputSetHDRDisplayMetadataPolicy(*(void *)(a1 + 120), a2);
    FigVCPCompositorHostSetHDRDisplayMetadataPolicy(*(void *)(a1 + 104));
    videoprocessor_triggerProcessing(a1);
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigVideoCompositionProcessorResetCompositionInstruction(uint64_t a1, int a2, int a3)
{
  if (FigVCPIsValid())
  {
    CFTypeRef v6 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 88));
    if (v6) {
      FigVCPInstructionSourceInvalidateCache();
    }
    if (a3) {
      videoprocessor_flushOutput(a1);
    }
    if (a2
      && (uint64_t FrameTimeToCurrentTimebaseTime = FigVCPTimingResetNextFrameTimeToCurrentTimebaseTime(*(void *)(a1 + 96)),
          FrameTimeToCurrentTimebaseTime))
    {
      uint64_t v8 = FrameTimeToCurrentTimebaseTime;
      if (!v6) {
        return v8;
      }
    }
    else
    {
      *(unsigned char *)(a1 + 160) = 1;
      videoprocessor_triggerProcessing(a1);
      uint64_t v8 = 0;
      if (!v6) {
        return v8;
      }
    }
    CFRelease(v6);
    return v8;
  }

  return FigSignalErrorAt();
}

void videoprocessor_flushOutput(uint64_t a1)
{
  FigVCPCompositorHostCancelPendingFrames(*(void **)(a1 + 104));
  CFTypeRef v2 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 120));
  FigVCPOutputFlush((uint64_t)v2);
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t FigVideoCompositionProcessorCopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  CFTypeRef cf = 0;
  if (!FigVCPIsValid() || !a4)
  {
LABEL_30:
    uint64_t v11 = FigSignalErrorAt();
LABEL_31:
    uint64_t v9 = v11;
    goto LABEL_32;
  }
  if (CFEqual(a2, @"VideoCompositionProcessor_SourcePixelBufferAttributes"))
  {
    PixelBufferAttributes = (const void *)FigVCPPreprocessParametersGetPixelBufferAttributes(*(void *)(a1 + 24));
    if (!PixelBufferAttributes) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if (CFEqual(a2, @"VideoCompositionProcessor_CompositionYCbCrMatrix"))
  {
    PixelBufferAttributes = (const void *)FigVCPPreprocessParametersGetYCbCrMatrix(*(void *)(a1 + 24));
    if (!PixelBufferAttributes) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if (CFEqual(a2, @"VideoCompositionProcessor_CompositionColorPrimaries"))
  {
    PixelBufferAttributes = (const void *)FigVCPPreprocessParametersGetColorPrimaries(*(void *)(a1 + 24));
    if (!PixelBufferAttributes) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if (CFEqual(a2, @"VideoCompositionProcessor_CompositionTransferFunction"))
  {
    PixelBufferAttributes = (const void *)FigVCPPreprocessParametersGetTransferFunction(*(void *)(a1 + 24));
    if (!PixelBufferAttributes)
    {
LABEL_15:
      CFTypeRef cf = PixelBufferAttributes;
LABEL_16:
      uint64_t v9 = 0;
      *a4 = cf;
      return v9;
    }
LABEL_14:
    PixelBufferAttributes = CFRetain(PixelBufferAttributes);
    goto LABEL_15;
  }
  if (CFEqual(a2, @"VideoCompositionProcessor_DestinationPixelBufferDesiredAttributes")
    || CFEqual(a2, @"VideoCompositionProcessor_DestinationPixelTransferProperties")
    || CFEqual(a2, @"VideoCompositionProcessor_DestinationPixelBufferDesiredYCbCrMatrix")
    || CFEqual(a2, @"VideoCompositionProcessor_DestinationPixelBufferDesiredColorPrimaries")
    || CFEqual(a2, @"VideoCompositionProcessor_PixelBufferPoolSharingID")
    || CFEqual(a2, @"VideoCompositionProcessor_DestinationPixelBufferDesiredTransferFunction"))
  {
    uint64_t v11 = FigVCPOutputConformerCopyProperty(*(void *)(a1 + 112), a2, a3, &cf);
    if (!v11) {
      goto LABEL_16;
    }
    goto LABEL_31;
  }
  if (CFEqual(a2, @"VideoCompositionProcessorProperty_Timebase"))
  {
    if (FigVCPTimingUsesTimebase(*(void *)(a1 + 96)))
    {
      PixelBufferAttributes = FigVCPTimingCopyTimebase(*(void *)(a1 + 96));
      goto LABEL_15;
    }
    goto LABEL_30;
  }
  if (CFEqual(a2, @"VideoCompositionProcessor_RenderScale"))
  {
    if (!FigVCPCompositorHostSupportsRenderScale(*(void *)(a1 + 104)))
    {
      float valuePtr = FigVCPPreprocessParametersGetRenderScale(*(void *)(a1 + 24));
      PixelBufferAttributes = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
      goto LABEL_15;
    }
    uint64_t v11 = FigVCPCompositorHostCopyProperty(*(void *)(a1 + 104), @"VideoCompositionProcessor_RenderScale", a3, (uint64_t)&cf);
    if (!v11) {
      goto LABEL_16;
    }
    goto LABEL_31;
  }
  if (CFEqual(a2, @"VideoCompositionProcessor_ThrottleForBackground"))
  {
    CFTypeRef v12 = (const void **)MEMORY[0x1E4F1CFC8];
    if (*(unsigned char *)(a1 + 20)) {
      CFTypeRef v12 = (const void **)MEMORY[0x1E4F1CFD0];
    }
    PixelBufferAttributes = *v12;
    goto LABEL_14;
  }
  if (CFEqual(a2, @"VideoCompositionProcessor_PerformanceDictionary"))
  {
    CFTypeRef v13 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
    CFTypeRef v14 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 144));
    uint64_t v9 = FigVCPTallyCopyPerformanceDictionary(a1 + 208, (uint64_t)v13, *(void *)(a1 + 104), *(void *)(a1 + 112), (uint64_t)v14, (__CFDictionary **)&cf);
    if (v14) {
      CFRelease(v14);
    }
    if (v13) {
      CFRelease(v13);
    }
    if (!v9) {
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v9 = 4294954512;
  }
LABEL_32:
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t FigVideoCompositionProcessorSetProperty(uint64_t a1, const void *a2, void *a3)
{
  if (!FigVCPIsValid()
    || (MEMORY[0x19970EE10](&videoprocessor_getReadOnlyPropertyKeys_sReadOnlyPropertyKeysOnce, videoprocessor_initReadOnlyPropertyKeys), CFSetContainsValue((CFSetRef)videoprocessor_readOnlyPropertyKeys, a2)))
  {
LABEL_53:
    return FigSignalErrorAt();
  }
  MEMORY[0x19970EE10](&videoprocessor_getStaticPropertyKeys_sStaticPropertyKeysOnce, videoprocessor_initStaticPropertyKeys);
  if (CFSetContainsValue((CFSetRef)videoprocessor_staticPropertyKeys, a2)
    && (*(unsigned char *)(a1 + 160) || FigVCPCompositorHostGetPendingFramesCount()))
  {
    FigCFStringGetCStringPtrAndBufferToFree();
    return FigSignalErrorAt();
  }
  if (CFEqual(a2, @"VideoCompositionProcessorProperty_Timebase"))
  {
    if (FigVCPTimingUsesTimebase(*(void *)(a1 + 96)))
    {
      if (a3)
      {
        CFTypeID v7 = CFGetTypeID(a3);
        if (v7 == CMTimebaseGetTypeID())
        {
          MEMORY[0x19970E910](*(void *)(a1 + 168));
          uint64_t v8 = FigVCPTimingSetTimebase(*(void *)(a1 + 96), (OpaqueCMTimebase *)a3);
          MEMORY[0x19970E930](*(void *)(a1 + 168));
          return v8;
        }
      }
    }
    goto LABEL_53;
  }
  if (CFEqual(a2, @"VideoCompositionProcessorProperty_LoopTimeRange"))
  {
    long long v9 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
    *(_OWORD *)&valuePtr.start.CMTimeValue value = *MEMORY[0x1E4F1FA20];
    *(_OWORD *)&valuePtr.start.CMTimeEpoch epoch = v9;
    *(_OWORD *)&valuePtr.duration.CMTimeScale timescale = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
    if (!FigVCPTimingUsesTimebase(*(void *)(a1 + 96))) {
      return FigSignalErrorAt();
    }
    if (a3)
    {
      CFTypeID v10 = CFGetTypeID(a3);
      if (v10 != CFDictionaryGetTypeID()) {
        return FigSignalErrorAt();
      }
      CMTimeRangeMakeFromDictionary(&valuePtr, (CFDictionaryRef)a3);
    }
    uint64_t v11 = *(void *)(a1 + 96);
    CMTimeRange v13 = valuePtr;
    return FigVCPTimingSetLoopTimeRange(v11, (uint64_t)&v13);
  }
  else if (CFEqual(a2, @"VideoCompositionProcessor_RenderScale"))
  {
    if (!a3) {
      return FigSignalErrorAt();
    }
    CFTypeID v12 = CFGetTypeID(a3);
    if (v12 != CFNumberGetTypeID()) {
      return FigSignalErrorAt();
    }
    LODWORD(valuePtr.start.value) = 1065353216;
    CFNumberGetValue((CFNumberRef)a3, kCFNumberFloatType, &valuePtr);
    if (*(float *)&valuePtr.start.value <= 0.0
      || !FigVCPTimingUsesTimebase(*(void *)(a1 + 96)) && *(float *)&valuePtr.start.value != 1.0)
    {
      return FigSignalErrorAt();
    }
    if (FigVCPCompositorHostSupportsRenderScale(*(void *)(a1 + 104))) {
      return FigVCPCompositorHostSetProperty(*(void *)(a1 + 104), @"VideoCompositionProcessor_RenderScale", (uint64_t)a3);
    }
    else {
      return FigVCPPreprocessParametersSetProperty(*(void *)(a1 + 24), @"VideoCompositionProcessor_RenderScale", (uint64_t)a3);
    }
  }
  else if (CFEqual(a2, @"VideoCompositionProcessor_ClientPID"))
  {
    return videoprocessor_setClientPIDProperty(a1, (uint64_t)a3);
  }
  else if (CFEqual(a2, @"VideoCompositionProcessor_ThrottleForBackground"))
  {
    return videoprocessor_setThrottleForBackgroundProperty(a1, (const __CFBoolean *)a3);
  }
  else if (CFEqual(a2, @"VideoCompositionProcessorProperty_FigImageQueueArray"))
  {
    return videoprocessor_updateOutputImageQueueArray((CFTypeRef *)a1, a3);
  }
  else if (CFEqual(a2, @"VideoCompositionProcessor_HDRDisplayMetadataPolicy"))
  {
    if (FigIsDeviceCapableOfGeneratingStatisticsForHDR()) {
      goto LABEL_45;
    }
    if (overrideHDRMetadataGenerationByDefaultsWrite_onceToken != -1) {
      dispatch_once(&overrideHDRMetadataGenerationByDefaultsWrite_onceToken, &__block_literal_global_63);
    }
    if (overrideHDRMetadataGenerationByDefaultsWrite_sOverrideHDRMetadataGeneration == 1)
    {
LABEL_45:
      return FigVideoCompositionProcessorSetHDRDisplayMetadataPolicy(a1, a3);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return videoprocessor_propagatePropertyToSubcomponents((uint64_t *)a1, a2, (uint64_t)a3);
  }
}

uint64_t videoprocessor_setClientPIDProperty(uint64_t a1, uint64_t a2)
{
  uint64_t FigBaseObject = FigActivitySchedulerGetFigBaseObject(*(void *)(a1 + 128));
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  CFTypeID v7 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(v6 + 56);
  if (v7) {
    uint64_t v8 = v7(FigBaseObject, @"ClientPID", a2);
  }
  else {
    uint64_t v8 = 4294954514;
  }
  FigVCPCompositorHostSetProperty(*(void *)(a1 + 104), @"VideoCompositionProcessor_ClientPID", a2);
  return v8;
}

uint64_t videoprocessor_setThrottleForBackgroundProperty(uint64_t a1, const __CFBoolean *cf)
{
  if (cf && (CFTypeID v4 = CFGetTypeID(cf), v4 == CFBooleanGetTypeID()))
  {
    uint64_t Value = CFBooleanGetValue(cf);
    if (*(unsigned __int8 *)(a1 + 20) != Value)
    {
      *(unsigned char *)(a1 + 20) = Value;
      videoprocessor_updateCoreAnimationThrottling(a1, Value);
      if (*(_DWORD *)(a1 + 136) == 3) {
        FigVCPCompositorHostSetProperty(*(void *)(a1 + 104), @"VideoCompositionProcessor_ThrottleForBackground", (uint64_t)cf);
      }
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t videoprocessor_updateOutputImageQueueArray(CFTypeRef *a1, const void *a2)
{
  uint64_t v17 = 0;
  CFTypeID v4 = a1 + 15;
  CFTypeRef v5 = videoprocessor_loadAndRetainAtomically((uint64_t)a1, a1 + 15);
  CMTime v16 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CMTime v15 = v16;
  uint64_t OutputDurationWaterLevels = FigVCPOutputGetOutputDurationWaterLevels((uint64_t)v5, (uint64_t)&v16, (uint64_t)&v15);
  if (!OutputDurationWaterLevels)
  {
    CFAllocatorRef v7 = CFGetAllocator(a1);
    CMTime v14 = v16;
    CMTime v13 = v15;
    uint64_t OutputDurationWaterLevels = FigVCPOutputCreate((uint64_t)v7, a2, &v14, &v13, (uint64_t)a1, &v17);
    if (!OutputDurationWaterLevels)
    {
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterAddWeakListener();
      if (v5
        && (uint64_t v8 = (uint64_t)v17,
            HDRDisplayMetadataPolicdouble y = (const void *)FigVCPOutputGetHDRDisplayMetadataPolicy((uint64_t)v5),
            uint64_t v10 = FigVCPOutputSetHDRDisplayMetadataPolicy(v8, HDRDisplayMetadataPolicy),
            v10))
      {
        uint64_t v11 = v10;
      }
      else
      {
        FigVCPOutputInvalidate((uint64_t)v5);
        videoprocessor_releaseAssignAndRetainAtomically((uint64_t)a1, v4, v17);
        uint64_t v11 = 0;
        if (!v5) {
          goto LABEL_7;
        }
      }
      goto LABEL_6;
    }
  }
  uint64_t v11 = OutputDurationWaterLevels;
  if (v5) {
LABEL_6:
  }
    CFRelease(v5);
LABEL_7:
  if (v17) {
    CFRelease(v17);
  }
  return v11;
}

uint64_t videoprocessor_propagatePropertyToSubcomponents(uint64_t *a1, const void *a2, uint64_t a3)
{
  uint64_t result = FigVCPPreprocessParametersSetProperty(a1[3], a2, a3);
  int v7 = result;
  if (result) {
    BOOL v8 = result == -12784;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    uint64_t result = FigVCPCompositorHostSetProperty(a1[13], a2, a3);
    int v9 = result;
    if (!result || result == -12784)
    {
      uint64_t result = FigVCPOutputConformerSetProperty(a1[14], a2, a3);
      if (!result || result == -12784)
      {
        if (result) {
          BOOL v11 = v9 == 0;
        }
        else {
          BOOL v11 = 1;
        }
        if (v11 || v7 == 0) {
          return 0;
        }
        else {
          return 4294954512;
        }
      }
    }
  }
  return result;
}

uint64_t FigVideoCompositionProcessorGetVideoCompositor(uint64_t a1)
{
  if (FigVCPIsValid())
  {
    uint64_t v2 = *(void *)(a1 + 104);
    return FigVCPCompositorHostGetCompositor(v2);
  }
  else
  {
    FigSignalErrorAt();
    return 0;
  }
}

uint64_t FigVideoCompositionProcessorStartRenderingFramesForTimeRange(uint64_t a1, CMTime *a2, uint64_t a3)
{
  CFTypeRef cf = 0;
  if (!FigVCPIsValid() || FigVCPTimingUsesTimebase(*(void *)(a1 + 96)))
  {
    uint64_t started = FigSignalErrorAt();
    CFTypeRef v7 = 0;
    CFTypeRef v6 = 0;
  }
  else
  {
    CFTypeRef v6 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 88));
    FigVCPInstructionSourceInvalidateCache();
    CFTypeRef v7 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
    uint64_t Copy = FigVCPPreprocessParametersCreateCopy(*MEMORY[0x1E4F1CF80], *(void *)(a1 + 24), (uint64_t *)&cf);
    if (Copy) {
      goto LABEL_17;
    }
    if ((uint64_t)FigVCPSourceArrayGetCount((uint64_t)v7) >= 1)
    {
      CFIndex v9 = 0;
      do
      {
        SourceAtIndedouble x = FigVCPSourceArrayGetSourceAtIndex((uint64_t)v7, v9);
        FigVCPSourceStartOver((uint64_t)SourceAtIndex);
        FigVCPSourceSetPreprocessParameters((uint64_t)SourceAtIndex, cf);
        ++v9;
      }
      while (v9 < (uint64_t)FigVCPSourceArrayGetCount((uint64_t)v7));
    }
    uint64_t v11 = *(void *)(a1 + 96);
    CMTime v16 = *a2;
    long long v14 = *(_OWORD *)a3;
    uint64_t v15 = *(void *)(a3 + 16);
    uint64_t Copy = FigVCPTimingStartOver(v11, &v16, &v14, 0, 1);
    if (Copy)
    {
LABEL_17:
      uint64_t started = Copy;
    }
    else
    {
      videoprocessor_flushOutput(a1);
      uint64_t started = FigVCPCompositorHostStartAcceptingRequest(*(void *)(a1 + 104));
      if (!started) {
        FigVideoCompositionProcessorGo(a1);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (v7) {
    CFRelease(v7);
  }
  return started;
}

uint64_t FigVideoCompositionProcessorGo(uint64_t a1)
{
  if (FigVCPIsValid())
  {
    *(unsigned char *)(a1 + 160) = 1;
    FigMemoryBarrier();
    videoprocessor_triggerProcessing(a1);
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigVideoCompositionProcessorRequestPreroll(uint64_t a1, long long *a2, long long *a3, int a4, int a5)
{
  uint64_t v10 = (char *)malloc_type_malloc(0x70uLL, 0x1020040FDFAB857uLL);
  if (a1) {
    CFTypeRef v11 = CFRetain((CFTypeRef)a1);
  }
  else {
    CFTypeRef v11 = 0;
  }
  *(void *)uint64_t v10 = v11;
  long long v12 = *a2;
  *((void *)v10 + 3) = *((void *)a2 + 2);
  *(_OWORD *)(v10 + 8) = v12;
  long long v13 = *a3;
  *((void *)v10 + 6) = *((void *)a3 + 2);
  *((_OWORD *)v10 + 2) = v13;
  if (a5 < 1) {
    int v14 = -1;
  }
  else {
    int v14 = 1;
  }
  if (!a5) {
    int v14 = 0;
  }
  *((_DWORD *)v10 + 14) = v14;
  FigVCPTimingGetLoopTimeRange(*(void *)(a1 + 96), v17);
  long long v15 = v17[1];
  *(_OWORD *)(v10 + 60) = v17[0];
  *(_OWORD *)(v10 + 76) = v15;
  *(_OWORD *)(v10 + 92) = v17[2];
  *((_DWORD *)v10 + 27) = a4;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 192), v10, (dispatch_function_t)videoprocessor_requestPreroll);
  return 0;
}

void videoprocessor_requestPreroll(CFTypeRef *a1)
{
  uint64_t v2 = *((void *)*a1 + 13);
  int v3 = *((_DWORD *)a1 + 14);
  uint64_t v4 = *((unsigned int *)a1 + 27);
  CMTime v10 = *(CMTime *)(a1 + 1);
  long long v5 = *((_OWORD *)a1 + 2);
  CFTypeRef v9 = a1[6];
  long long v6 = *(_OWORD *)((char *)a1 + 76);
  v7[0] = *(_OWORD *)((char *)a1 + 60);
  v7[1] = v6;
  void v7[2] = *(_OWORD *)((char *)a1 + 92);
  long long v8 = v5;
  FigVCPCompositorHostPrerollForRendering(v2, &v10, (uint64_t)&v8, v3, v7, v4);
  if (*a1) {
    CFRelease(*a1);
  }
  free(a1);
}

uint64_t FigVideoCompositionProcessorSetPlaybackTimeRange(uint64_t a1, CMTime *a2, uint64_t a3, int a4, int a5)
{
  CFTypeRef cf = 0;
  if (!FigVCPIsValid() || !FigVCPTimingUsesTimebase(*(void *)(a1 + 96)))
  {
    uint64_t Copy = FigSignalErrorAt();
    goto LABEL_26;
  }
  uint64_t Copy = FigVCPPreprocessParametersCreateCopy(*MEMORY[0x1E4F1CF80], *(void *)(a1 + 24), (uint64_t *)&cf);
  if (Copy)
  {
LABEL_26:
    uint64_t started = Copy;
    CFTypeRef v16 = 0;
    CFTypeRef v11 = 0;
    goto LABEL_18;
  }
  CFTypeRef v11 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
  if ((uint64_t)FigVCPSourceArrayGetCount((uint64_t)v11) >= 1)
  {
    CFIndex v12 = 0;
    do
    {
      SourceAtIndedouble x = FigVCPSourceArrayGetSourceAtIndex((uint64_t)v11, v12);
      FigVCPSourceStartOver((uint64_t)SourceAtIndex);
      FigVCPSourceSetPreprocessParameters((uint64_t)SourceAtIndex, cf);
      ++v12;
    }
    while (v12 < (uint64_t)FigVCPSourceArrayGetCount((uint64_t)v11));
  }
  if ((a2->flags & 0x1D) == 1)
  {
    if (a5 < 1) {
      int v14 = -1;
    }
    else {
      int v14 = 1;
    }
    if (a5) {
      int v15 = v14;
    }
    else {
      int v15 = 0;
    }
    CFTypeRef v16 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 120));
    uint64_t v17 = FigVCPOutputSetDirection((uint64_t)v16, v15);
    if (v17)
    {
      uint64_t started = v17;
    }
    else
    {
      uint64_t v18 = *(void *)(a1 + 96);
      CMTime v23 = *a2;
      long long v21 = *(_OWORD *)a3;
      uint64_t v22 = *(void *)(a3 + 16);
      uint64_t started = FigVCPTimingStartOver(v18, &v23, &v21, a4, v15);
      if (!started)
      {
        videoprocessor_flushOutput(a1);
        FigVideoCompositionProcessorGo(a1);
      }
    }
  }
  else
  {
    CFTypeRef v16 = 0;
    uint64_t started = 0;
    *(unsigned char *)(a1 + 160) = 0;
  }
LABEL_18:
  if (cf) {
    CFRelease(cf);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v16) {
    CFRelease(v16);
  }
  return started;
}

uint64_t FigVideoCompositionProcessorWaitUntilCompletelyStopped(uint64_t a1)
{
  return 0;
}

BOOL FigVideoCompositionProcessorIsAtEndOfOutputData(uint64_t a1)
{
  if (!FigVCPIsValid() || FigVCPTimingUsesTimebase(*(void *)(a1 + 96)))
  {
    FigSignalErrorAt();
    return 0;
  }
  if (FigVCPCompositorHostIsAcceptingRequest(*(void *)(a1 + 104))) {
    return 0;
  }
  return FigVCPCompositorHostGetPendingFramesCount() == 0;
}

dispatch_queue_t videoprocessor_Init(void *a1)
{
  bzero(a1 + 2, 0x8C8uLL);
  a1[21] = FigSimpleMutexCreate();
  a1[22] = FigSimpleMutexCreate();
  a1[19] = FigSimpleMutexCreate();
  a1[23] = dispatch_queue_create("com.apple.coremedia.videocompositionprocessor.notification", 0);
  dispatch_queue_t result = dispatch_queue_create("com.apple.coremedia.videocompositionprocessor.preroll", 0);
  a1[24] = result;
  return result;
}

void videoprocessor_Finalize(uint64_t a1)
{
  FigVideoCompositionProcessorInvalidate(a1);
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    CFRelease(v2);
  }
  int v3 = *(const void **)(a1 + 32);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4) {
    CFRelease(v4);
  }
  long long v5 = *(const void **)(a1 + 96);
  if (v5) {
    CFRelease(v5);
  }
  long long v6 = *(const void **)(a1 + 88);
  if (v6) {
    CFRelease(v6);
  }
  CFTypeRef v7 = *(const void **)(a1 + 104);
  if (v7) {
    CFRelease(v7);
  }
  long long v8 = *(const void **)(a1 + 112);
  if (v8) {
    CFRelease(v8);
  }
  CFTypeRef v9 = *(const void **)(a1 + 120);
  if (v9) {
    CFRelease(v9);
  }
  CMTime v10 = *(const void **)(a1 + 128);
  if (v10) {
    CFRelease(v10);
  }
  videoprocessor_releaseAssignAndRetainAtomically(a1, (const void **)(a1 + 144), 0);
  FigSimpleMutexDestroy();
  FigSimpleMutexDestroy();
  FigSimpleMutexDestroy();
  CFTypeRef v11 = *(NSObject **)(a1 + 184);
  if (v11) {
    dispatch_release(v11);
  }
  CFIndex v12 = *(NSObject **)(a1 + 192);
  if (v12) {
    dispatch_release(v12);
  }
  long long v13 = *(opaqueCMBufferQueue **)(a1 + 48);
  if (v13)
  {
    CMBufferQueueRemoveTrigger(v13, *(CMBufferQueueTriggerToken *)(a1 + 56));
    int v14 = *(const void **)(a1 + 48);
    if (v14)
    {
      CFRelease(v14);
    }
  }
}

CFStringRef videoprocessor_CopyFormattingDesc(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  int v3 = FigVCPIsValid();
  uint64_t v4 = "";
  if (!v3) {
    uint64_t v4 = " (invalidated)";
  }
  return CFStringCreateWithFormat(v2, 0, @"[FigVideoCompositionProcessor %p%s]", a1, v4);
}

__CFString *videoprocessor_CopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFTypeRef v4 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 120));
  CFTypeRef v5 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
  CFTypeRef v6 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 144));
  CFIndex v7 = CFGetRetainCount((CFTypeRef)a1);
  if (FigVCPIsValid()) {
    long long v8 = "";
  }
  else {
    long long v8 = " (invalidated)";
  }
  CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)a1);
  if (FigVCPTimingUsesTimebase(*(void *)(a1 + 96))) {
    CMTime v10 = "realtime";
  }
  else {
    CMTime v10 = "non-realtime";
  }
  if (FigVCPTimingRepeatIdenticalFrames(*(void *)(a1 + 96))) {
    CFTypeRef v11 = "repeat-identical-frames";
  }
  else {
    CFTypeRef v11 = "do-not-repeat-identical-frames";
  }
  BOOL IsAcceptingRequest = FigVCPCompositorHostIsAcceptingRequest(*(void *)(a1 + 104));
  long long v13 = "is";
  if (!IsAcceptingRequest) {
    long long v13 = "is not";
  }
  CFStringAppendFormat(Mutable, 0, @"FigVideoCompositionProcessor %p retainCount: %d%s allocator: %p, %s, %s, compositor %s accepting input, ", a1, v7, v8, v9, v10, v11, v13);
  CFStringAppendFormat(Mutable, 0, @"sourceArray=%p, ", v5);
  CFStringAppendFormat(Mutable, 0, @"videoCompositor=%p, ", *(void *)(a1 + 104));
  CFStringAppendFormat(Mutable, 0, @"output=%p, ", v4);
  CFStringAppendFormat(Mutable, 0, @"instructionSource=%p, ", *(void *)(a1 + 88));
  CFStringAppendFormat(Mutable, 0, @"activityScheduler=%p, ", *(void *)(a1 + 128));
  CFStringAppendFormat(Mutable, 0, @"outputConformer=%p, ", *(void *)(a1 + 112));
  CFTypeRef cf = 0;
  FigVCPTallyCopyPerformanceDictionary(a1 + 208, (uint64_t)v5, *(void *)(a1 + 104), *(void *)(a1 + 112), (uint64_t)v6, (__CFDictionary **)&cf);
  if (cf)
  {
    int v14 = (const void *)FigCFCopyCompactDescription();
    CFStringAppendFormat(Mutable, 0, @"performanceDictionary=%@", v14);
    if (cf) {
      CFRelease(cf);
    }
    if (v6) {
      goto LABEL_16;
    }
  }
  else
  {
    int v14 = 0;
    if (v6) {
LABEL_16:
    }
      CFRelease(v6);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v14) {
    CFRelease(v14);
  }
  return Mutable;
}

void videoprocessor_reportProcessingError(uint64_t a1)
{
  *(unsigned char *)(a1 + 160) = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32();
  CMNotificationCenterGetDefaultLocalCenter();
  FigDispatchAsyncPostNotification();
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

uint64_t videoprocessor_setUpcomingImageInfo(uint64_t a1)
{
  long long v12 = *MEMORY[0x1E4F1F9F8];
  uint64_t v13 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  long long v10 = v12;
  uint64_t v11 = v13;
  CFTypeRef v2 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 120));
  uint64_t UpcomingImageInfo = FigVCPCompositorHostGetUpcomingImageInfo(*(void *)(a1 + 104), (uint64_t)&v12, (uint64_t)&v10);
  if (!UpcomingImageInfo)
  {
    uint64_t v4 = 0;
    if (!v2) {
      return v4;
    }
    goto LABEL_3;
  }
  long long v8 = v12;
  uint64_t v9 = v13;
  long long v6 = v10;
  uint64_t v7 = v11;
  uint64_t v4 = FigVCPOutputSetUpcomingImageInfo((uint64_t)v2, UpcomingImageInfo, &v8, &v6);
  if (v2) {
LABEL_3:
  }
    CFRelease(v2);
  return v4;
}

uint64_t videoprocessor_updateCoreAnimationThrottling(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  char v14 = a2;
  CFTypeRef v4 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
  CFTypeRef v5 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 144));
  int v6 = *(_DWORD *)(a1 + 136);
  if (v6 == 1)
  {
    if (v2)
    {
      BOOL v7 = FigVCPSourceArrayContainsCoreAnimationSource((uint64_t)v4);
      if (v5) {
        BOOL v8 = 0;
      }
      else {
        BOOL v8 = !v7;
      }
      if (v8) {
        uint64_t v2 = 0;
      }
      else {
        uint64_t v2 = 4294954993;
      }
    }
    goto LABEL_19;
  }
  if (v6 != 3)
  {
    if (v6 == 2)
    {
      if (v2)
      {
        if (FigVCPSourceArrayContainsCoreAnimationSource((uint64_t)v4) || v5)
        {
          uint64_t v2 = 0;
          *(unsigned char *)(a1 + 160) = 0;
          *(unsigned char *)(a1 + 140) = 1;
          goto LABEL_19;
        }
LABEL_24:
        uint64_t v2 = 0;
        if (!v4) {
          return v2;
        }
        goto LABEL_22;
      }
      if (!*(unsigned char *)(a1 + 160) && *(unsigned char *)(a1 + 140))
      {
        *(unsigned char *)(a1 + 160) = 1;
        *(unsigned char *)(a1 + 140) = 0;
        uint64_t v10 = *(void *)(a1 + 128);
        uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v11) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v13 = *(void (**)(uint64_t))(v12 + 16);
        if (v13) {
          v13(v10);
        }
      }
    }
    uint64_t v2 = 0;
LABEL_19:
    if (!v5) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  FigVCPSourceArrayApplyFunction((uint64_t)v4, (uint64_t (*)(const void *, uint64_t))videoprocessor_throttleSourceForBackground, (uint64_t)&v14);
  if (!v5) {
    goto LABEL_24;
  }
  FigVCPCoreAnimationPostProcessorThrottleForBackground((uint64_t)v5);
  uint64_t v2 = 0;
LABEL_20:
  CFRelease(v5);
LABEL_21:
  if (v4) {
LABEL_22:
  }
    CFRelease(v4);
  return v2;
}

void videoprocessor_sendSeekCompleteNotification()
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32();
  CMNotificationCenterGetDefaultLocalCenter();
  FigDispatchAsyncPostNotification();
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

uint64_t videoprocessor_isTrackRequired(const __CFArray *a1, int a2)
{
  int valuePtr = a2;
  if (!a1) {
    return 1;
  }
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  v7.length = CFArrayGetCount(a1);
  v7.locatioCFIndex n = 0;
  uint64_t v4 = CFArrayContainsValue(a1, v7, v3);
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

uint64_t videoprocessor_willCompositionInstructionContinueForever(const __CFDictionary *a1, int a2)
{
  if (FigVCPDirectionIsForwardOrPaused(a2))
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"EndTime");
    CMTimeMakeFromDictionary(&v9, Value);
    if (v9.flags)
    {
      CMTimeMakeFromDictionary(&v8, Value);
      return (LOBYTE(v8.flags) >> 2) & 1;
    }
    return 0;
  }
  CFDictionaryRef v5 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"StartTime");
  CMTimeMakeFromDictionary(&v7, v5);
  if ((v7.flags & 1) == 0) {
    return 0;
  }
  CMTimeMakeFromDictionary(&v6, v5);
  return (LOBYTE(v6.flags) >> 3) & 1;
}

uint64_t videoprocessor_throttleSourceForBackground(uint64_t a1, unsigned __int8 *a2)
{
  return FigVCPSourceThrottleForBackground(a1, *a2);
}

void videoprocessor_initReadOnlyPropertyKeys()
{
  CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
  CFSetAddValue(Mutable, @"VideoCompositionProcessor_SourcePixelBufferAttributes");
  videoprocessor_readOnlyPropertyKeys = (uint64_t)Mutable;
}

void videoprocessor_initStaticPropertyKeys()
{
  CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
  CFSetAddValue(Mutable, @"VideoCompositionProcessor_ClientPID");
  CFSetAddValue(Mutable, @"VideoCompositionProcessor_PixelBufferPoolSharingID");
  videoprocessor_staticPropertyKeys = (uint64_t)Mutable;
}

void __overrideHDRMetadataGenerationByDefaultsWrite_block_invoke()
{
  CFPropertyListRef v0 = CFPreferencesCopyValue(@"videoCompositionHDRDisplayMetadata", @"com.apple.avfoundation", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  if (v0)
  {
    uint64_t v1 = v0;
    CFTypeID v2 = CFGetTypeID(v0);
    if (v2 == CFStringGetTypeID() && FigCFEqual()) {
      overrideHDRMetadataGenerationByDefaultsWrite_sOverrideHDRMetadataGeneratioCFIndex n = 1;
    }
    CFRelease(v1);
  }
}

uint64_t FigVisualContextCreateRemote(int a1, CFTypeRef cf, void *a3)
{
  if (a3)
  {
    if (remoteXPCVisualContextClient_EnsureClientEstablished_gVisualContextRemoteClientSetupOnce != -1) {
      dispatch_once(&remoteXPCVisualContextClient_EnsureClientEstablished_gVisualContextRemoteClientSetupOnce, &__block_literal_global_64);
    }
    uint64_t v6 = remoteXPCVisualContextClient_EnsureClientEstablished_err;
    if (!remoteXPCVisualContextClient_EnsureClientEstablished_err)
    {
      if (cf && (CFTypeID v7 = CFGetTypeID(cf), v7 == CFDictionaryGetTypeID()))
      {
        FigVisualContextGetClassID();
        uint64_t v8 = CMDerivedObjectCreate();
        if (v8
          || (uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(),
              uint64_t v10 = FigReadWriteLockCreate(),
              (*(void *)(DerivedStorage + 16) = v10) == 0)
          && (uint64_t v8 = FigSignalErrorAt(), v8)
          || (uint64_t v8 = FigXPCCreateBasicMessage(), v8)
          || (uint64_t v8 = FigXPCMessageSetCFDictionary(), v8)
          || (uint64_t v8 = FigXPCRemoteClientSendSyncMessageCreatingReply(), v8))
        {
          uint64_t v6 = v8;
        }
        else
        {
          uint64_t uint64 = xpc_dictionary_get_uint64(0, (const char *)*MEMORY[0x1E4F20280]);
          *(void *) CMBaseObjectGetDerivedStorage() = uint64;
          uint64_t v6 = FigXPCRemoteClientAssociateObject();
          if (!v6) {
            *a3 = 0;
          }
        }
      }
      else
      {
        uint64_t v6 = FigSignalErrorAt();
      }
      FigXPCRelease();
      FigXPCRelease();
      FigXPCRemoteClientKillServerOnTimeout();
    }
    return v6;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigVisualContextXPCRemoteGetObjectID(const void *a1, void *a2)
{
  if (a1
    && (CFTypeID v4 = CFGetTypeID(a1), v4 == FigVisualContextGetTypeID())
    && (_UNKNOWN *)CMBaseObjectGetVTable() == &kRemoteXPCVisualContext_VTable
    && a2)
  {
    return remoteXPCVisualContext_GetObjectID((uint64_t)a1, a2);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t remoteXPCVisualContext_GetObjectID(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 8))
  {
    return FigSignalErrorAt();
  }
  else
  {
    *a2 = *(void *)DerivedStorage;
    return 0;
  }
}

uint64_t remoteXPCVisualContextClient_DeadConnectionCallback()
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  *(unsigned char *)(result + 8) = 1;
  return result;
}

uint64_t remoteXPCVisualContextClient_MessageHandler(const void *a1)
{
  if (a1 && (CFTypeID v1 = CFGetTypeID(a1), v1 == FigVisualContextGetTypeID()))
  {
    uint64_t result = FigXPCMessageGetOpCode();
    if (!result) {
      return 4294951138;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t rvcInvalidate(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  v7[0] = 0;
  v7[1] = 0;
  if (*(unsigned char *)(DerivedStorage + 9)) {
    return 0;
  }
  uint64_t v4 = DerivedStorage;
  uint64_t ObjectID = remoteXPCVisualContext_GetObjectID(a1, v7);
  if (ObjectID
    || v7[0]
    && ((uint64_t ObjectID = FigXPCCreateBasicMessage(), ObjectID)
     || (uint64_t ObjectID = FigXPCRemoteClientSendSyncMessage(), ObjectID)))
  {
    uint64_t v3 = ObjectID;
  }
  else
  {
    uint64_t v3 = 0;
    *(unsigned char *)(v4 + 9) = 1;
  }
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v3;
}

uint64_t rvcFinalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  rvcInvalidate(a1);
  FigReadWriteLockDestroy();
  FigXPCRemoteClientDisassociateObject();
  if (!*(unsigned char *)(DerivedStorage + 8) && !FigXPCCreateBasicMessage()) {
    FigXPCRemoteClientSendAsyncMessage();
  }
  FigXPCRelease();
  return FigXPCRemoteClientKillServerOnTimeout();
}

__CFString *rvcCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<FigVisualContext %p [%p] [%016llx]>{imageAvailableImmediate:%p, imageAvailableSequential:%p, noMoreImages:%p, }", a1, v5, *DerivedStorage, DerivedStorage[3], DerivedStorage[5], DerivedStorage[7]);
  return Mutable;
}

uint64_t rvcSetImageAvailableImmediateCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v10 = 0;
  xpc_object_t xdict = 0;
  FigReadWriteLockLockForWrite();
  if (a2 && *(void *)(DerivedStorage + 24))
  {
    uint64_t ObjectID = FigSignalErrorAt();
LABEL_4:
    uint64_t v8 = ObjectID;
    goto LABEL_9;
  }
  uint64_t ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v10);
  if (ObjectID) {
    goto LABEL_4;
  }
  uint64_t ObjectID = FigXPCCreateBasicMessage();
  if (ObjectID) {
    goto LABEL_4;
  }
  xpc_dictionary_set_BOOL(xdict, "CallbackIsSet", a2 != 0);
  uint64_t v8 = FigXPCRemoteClientSendSyncMessage();
  if (!v8)
  {
    *(void *)(DerivedStorage + 24) = a2;
    *(void *)(DerivedStorage + 32) = a3;
  }
LABEL_9:
  FigReadWriteLockUnlockForWrite();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v8;
}

uint64_t rvcSetImageAvailableSequentialCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v10 = 0;
  xpc_object_t xdict = 0;
  FigReadWriteLockLockForWrite();
  if (a2 && *(void *)(DerivedStorage + 40))
  {
    uint64_t ObjectID = FigSignalErrorAt();
LABEL_4:
    uint64_t v8 = ObjectID;
    goto LABEL_9;
  }
  uint64_t ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v10);
  if (ObjectID) {
    goto LABEL_4;
  }
  uint64_t ObjectID = FigXPCCreateBasicMessage();
  if (ObjectID) {
    goto LABEL_4;
  }
  xpc_dictionary_set_BOOL(xdict, "CallbackIsSet", a2 != 0);
  uint64_t v8 = FigXPCRemoteClientSendSyncMessage();
  if (!v8)
  {
    *(void *)(DerivedStorage + 40) = a2;
    *(void *)(DerivedStorage + 48) = a3;
  }
LABEL_9:
  FigReadWriteLockUnlockForWrite();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v8;
}

uint64_t rvcSetNoMoreImagesCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v10 = 0;
  xpc_object_t xdict = 0;
  FigReadWriteLockLockForWrite();
  if (a2 && *(void *)(DerivedStorage + 56))
  {
    uint64_t ObjectID = FigSignalErrorAt();
LABEL_4:
    uint64_t v8 = ObjectID;
    goto LABEL_9;
  }
  uint64_t ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v10);
  if (ObjectID) {
    goto LABEL_4;
  }
  uint64_t ObjectID = FigXPCCreateBasicMessage();
  if (ObjectID) {
    goto LABEL_4;
  }
  xpc_dictionary_set_BOOL(xdict, "CallbackIsSet", a2 != 0);
  uint64_t v8 = FigXPCRemoteClientSendSyncMessage();
  if (!v8)
  {
    *(void *)(DerivedStorage + 56) = a2;
    *(void *)(DerivedStorage + 64) = a3;
  }
LABEL_9:
  FigReadWriteLockUnlockForWrite();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v8;
}

uint64_t rvcSetBecameEmptyCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v10 = 0;
  xpc_object_t xdict = 0;
  FigReadWriteLockLockForWrite();
  if (a2 && *(void *)(DerivedStorage + 72))
  {
    uint64_t ObjectID = FigSignalErrorAt();
LABEL_4:
    uint64_t v8 = ObjectID;
    goto LABEL_9;
  }
  uint64_t ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v10);
  if (ObjectID) {
    goto LABEL_4;
  }
  uint64_t ObjectID = FigXPCCreateBasicMessage();
  if (ObjectID) {
    goto LABEL_4;
  }
  xpc_dictionary_set_BOOL(xdict, "CallbackIsSet", a2 != 0);
  uint64_t v8 = FigXPCRemoteClientSendSyncMessage();
  if (!v8)
  {
    *(void *)(DerivedStorage + 72) = a2;
    *(void *)(DerivedStorage + 80) = a3;
  }
LABEL_9:
  FigReadWriteLockUnlockForWrite();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v8;
}

BOOL rvcIsNewImageAvailable(uint64_t a1, uint64_t a2)
{
  xpc_object_t xdict = 0;
  uint64_t v6 = 0;
  uint64_t v4 = 0;
  if ((*(_DWORD *)(a2 + 12) & 0x1D) == 1)
  {
    BOOL v2 = !remoteXPCVisualContext_GetObjectID(a1, &v4)
      && !FigXPCCreateBasicMessage()
      && !FigXPCMessageSetCMTime()
      && !FigXPCRemoteClientSendSyncMessageCreatingReply()
      && xpc_dictionary_get_BOOL(xdict, "NewImageAvailable");
    FigXPCRelease();
    FigXPCRelease();
    FigXPCRemoteClientKillServerOnTimeout();
  }
  else
  {
    return FigSignalErrorAt();
  }
  return v2;
}

uint64_t rvcCopyImageForTime(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, void *a5, void *a6, uint64_t a7)
{
  xpc_object_t v23 = 0;
  uint64_t v21 = 0;
  xpc_object_t xdict = 0;
  long long v7 = *MEMORY[0x1E4F1F9F8];
  long long v19 = *MEMORY[0x1E4F1F9F8];
  uint64_t v8 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  uint64_t v20 = v8;
  if ((*(_DWORD *)(a3 + 12) & 0x1D) == 1)
  {
    if (a5) {
      *a5 = 0;
    }
    if (a6) {
      *a6 = 0;
    }
    if (a7)
    {
      *(_OWORD *)a7 = v7;
      *(void *)(a7 + 16) = v8;
    }
    uint64_t ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v21);
    if (!ObjectID)
    {
      uint64_t ObjectID = FigXPCCreateBasicMessage();
      if (!ObjectID)
      {
        uint64_t ObjectID = FigXPCMessageSetCMTime();
        if (!ObjectID)
        {
          xpc_dictionary_set_uint64(v23, "Flags", a4);
          xpc_dictionary_set_BOOL(v23, "WantsImage", a5 != 0);
          xpc_dictionary_set_BOOL(v23, "WantsImageBaggage", a6 != 0);
          xpc_dictionary_set_BOOL(v23, "WantsImageOriginalTime", a7 != 0);
          uint64_t ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply();
          if (!ObjectID)
          {
            if (!a5 || xpc_dictionary_get_BOOL(xdict, "IsNullImage"))
            {
              IOSurfaceRef v14 = 0;
LABEL_22:
              if (!a6 || (uint64_t CMTime = FigXPCMessageCopyCFDictionary(), !CMTime))
              {
                if (!a7 || (uint64_t CMTime = FigXPCMessageGetCMTime(), !CMTime))
                {
                  if (a5) {
                    *a5 = 0;
                  }
                  if (a6) {
                    *a6 = 0;
                  }
                  uint64_t v18 = 0;
                  if (a7)
                  {
                    *(_OWORD *)a7 = v19;
                    *(void *)(a7 + 16) = v20;
                  }
                  goto LABEL_32;
                }
              }
              goto LABEL_38;
            }
            xpc_object_t value = xpc_dictionary_get_value(xdict, "IOSurface");
            if (value)
            {
              IOSurfaceRef v14 = IOSurfaceLookupFromXPCObject(value);
              if (v14)
              {
                uint64_t CMTime = FigXPCMessageCreateBlockBufferData();
                if (!CMTime)
                {
                  uint64_t CMTime = FigRemote_CreatePixelBufferFromSerializedAtomDataAndSurface();
                  if (!CMTime) {
                    goto LABEL_22;
                  }
                }
              }
              else
              {
                uint64_t CMTime = FigSignalErrorAt();
              }
LABEL_38:
              uint64_t v18 = CMTime;
              goto LABEL_32;
            }
            uint64_t ObjectID = FigSignalErrorAt();
          }
        }
      }
    }
    uint64_t v18 = ObjectID;
    IOSurfaceRef v14 = 0;
LABEL_32:
    if (v14) {
      CFRelease(v14);
    }
    FigXPCRelease();
    FigXPCRelease();
    FigXPCRemoteClientKillServerOnTimeout();
    return v18;
  }

  return FigSignalErrorAt();
}

uint64_t rvcConvertHostTimeToImageTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[1] = 0;
  xpc_object_t xdict = 0;
  v7[0] = 0;
  if (a3 && (!a2 || (*(unsigned char *)(a2 + 64) & 2) != 0))
  {
    uint64_t ObjectID = remoteXPCVisualContext_GetObjectID(a1, v7);
    if (ObjectID || (uint64_t ObjectID = FigXPCCreateBasicMessage(), ObjectID))
    {
      uint64_t CMTime = ObjectID;
    }
    else
    {
      if (a2) {
        xpc_dictionary_set_uint64(xdict, "HostTime", *(void *)(a2 + 16));
      }
      uint64_t CMTime = FigXPCRemoteClientSendSyncMessageCreatingReply();
      if (!CMTime) {
        uint64_t CMTime = FigXPCMessageGetCMTime();
      }
    }
    FigXPCRelease();
    FigXPCRelease();
    FigXPCRemoteClientKillServerOnTimeout();
    return CMTime;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t rvcGetEarliestSequentialImageTimeAfterTime(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, BOOL *a5)
{
  xpc_object_t v14 = 0;
  xpc_object_t xdict = 0;
  uint64_t v13 = 0;
  if (a4)
  {
    uint64_t v8 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)a4 = *MEMORY[0x1E4F1F9F8];
    *(void *)(a4 + 16) = *(void *)(v8 + 16);
  }
  if (a5) {
    *a5 = 0;
  }
  uint64_t ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v13);
  if (ObjectID
    || (uint64_t ObjectID = FigXPCCreateBasicMessage(), ObjectID)
    || (xpc_dictionary_set_uint64(xdict, "Flags", a2), uint64_t ObjectID = FigXPCMessageSetCMTime(), ObjectID)
    || (uint64_t ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(), ObjectID))
  {
    uint64_t v11 = ObjectID;
    goto LABEL_16;
  }
  if (!a4)
  {
    if (!a5)
    {
      uint64_t v11 = 0;
      goto LABEL_16;
    }
    goto LABEL_14;
  }
  uint64_t CMTime = FigXPCMessageGetCMTime();
  uint64_t v11 = CMTime;
  if (a5 && !CMTime)
  {
LABEL_14:
    uint64_t v11 = 0;
    *a5 = xpc_dictionary_get_BOOL(v14, "NoMoreImages");
  }
LABEL_16:
  FigXPCRelease();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v11;
}

uint64_t rvcTask(uint64_t a1)
{
  v2[0] = 0;
  v2[1] = 0;
  if (!remoteXPCVisualContext_GetObjectID(a1, v2) && !FigXPCCreateBasicMessage()) {
    FigXPCRemoteClientSendSyncMessage();
  }
  FigXPCRelease();
  return FigXPCRemoteClientKillServerOnTimeout();
}

uint64_t FigVideoCompositorGetClassID()
{
  return sFigVideoCompositorClassID;
}

uint64_t RegisterFigVideoCompositorBaseType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigVideoCompositorGetTypeID()
{
  MEMORY[0x19970EE10](&FigVideoCompositorGetClassID_sRegisterFigVideoCompositorBaseTypeOnce, RegisterFigVideoCompositorBaseType);

  return CMBaseClassGetCFTypeID();
}

CFTypeID FigVideoCompositorUtilityGetPixelAspectRatio(CFTypeID result, _DWORD *a2, _DWORD *a3)
{
  if (result)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)result;
    CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)result, (const void *)*MEMORY[0x1E4F24B90]);
    uint64_t result = (CFTypeID)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x1E4F24BA0]);
    long long v7 = (const void *)result;
    if (a2)
    {
      *a2 = 1;
      if (Value)
      {
        CFTypeID TypeID = CFNumberGetTypeID();
        uint64_t result = CFGetTypeID(Value);
        if (TypeID == result) {
          uint64_t result = CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, a2);
        }
      }
    }
    if (a3)
    {
      *a3 = 1;
      if (v7)
      {
        CFTypeID v9 = CFNumberGetTypeID();
        uint64_t result = CFGetTypeID(v7);
        if (v9 == result)
        {
          return CFNumberGetValue((CFNumberRef)v7, kCFNumberIntType, a3);
        }
      }
    }
  }
  else
  {
    *a3 = 1;
    *a2 = 1;
  }
  return result;
}

uint64_t FigVideoCompositorUtilityGetEdgeProcessingPixels(uint64_t theArray, void *a2)
{
  if (a2)
  {
    BOOL v2 = a2;
    CFArrayRef v3 = (const __CFArray *)theArray;
    if (theArray && (CFArrayRef theArray = CFArrayGetCount((CFArrayRef)theArray), theArray == 4))
    {
      for (CFIndex i = 0; i != 4; ++i)
      {
        CFArrayRef theArray = (uint64_t)CFArrayGetValueAtIndex(v3, i);
        if (theArray)
        {
          CFDictionaryRef v5 = (const void *)theArray;
          CFTypeID TypeID = CFNumberGetTypeID();
          CFArrayRef theArray = CFGetTypeID(v5);
          if (TypeID == theArray) {
            CFArrayRef theArray = CFNumberGetValue((CFNumberRef)v5, kCFNumberIntType, v2);
          }
        }
        BOOL v2 = (void *)((char *)v2 + 4);
      }
    }
    else
    {
      *BOOL v2 = 0;
      v2[1] = 0;
    }
  }
  return theArray;
}

BOOL FigVideoCompositorUtilityAreCleanAperturesEqual(const __CFDictionary *a1, int a2, int a3, const __CFDictionary *a4, int a5, int a6)
{
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  if (a1 == a4) {
    return 1;
  }
  if (a1 && (CFTypeID TypeID = CFDictionaryGetTypeID(), TypeID != CFGetTypeID(a1))
    || a4 && (CFTypeID v13 = CFDictionaryGetTypeID(), v13 != CFGetTypeID(a4)))
  {
    FigSignalErrorAt();
  }
  else if (!vcu_getCleanApertureRational(a1, a2, a3, &v27, &v25, &v23, &v21) {
         && !vcu_getCleanApertureRational(a4, a5, a6, &v26, &v24, &v22, &v20))
  }
  {
    unint64_t v14 = vcu_simplifyRational(v27);
    if (v14 == vcu_simplifyRational(v26))
    {
      unint64_t v15 = vcu_simplifyRational(v25);
      if (v15 == vcu_simplifyRational(v24))
      {
        unint64_t v16 = vcu_simplifyRational(v23);
        if (v16 == vcu_simplifyRational(v22))
        {
          unint64_t v17 = vcu_simplifyRational(v21);
          unint64_t v18 = vcu_simplifyRational(v20);
          if (v17 == v18) {
            return HIDWORD(v17) == HIDWORD(v18);
          }
        }
      }
    }
  }
  return 0;
}

uint64_t vcu_getCleanApertureRational(const __CFDictionary *a1, int a2, int a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v16 = 0x100000000;
  uint64_t v17 = 0x100000000;
  uint64_t v14 = 0x100000000;
  uint64_t v15 = 0x100000000;
  if (!a1)
  {
    LODWORD(v17) = a2;
    LODWORD(v16) = a3;
    LODWORD(v15) = 0;
    LODWORD(v14) = 0;
    if (!a4) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    uint64_t result = vcu_getRationalFromDictionary(a1, (const void *)*MEMORY[0x1E4F24A88], (void *)*MEMORY[0x1E4F1EED8], (uint64_t)&v17);
    if (result) {
      return result;
    }
    uint64_t result = vcu_getRationalFromDictionary(a1, (const void *)*MEMORY[0x1E4F24A68], (void *)*MEMORY[0x1E4F1EEA8], (uint64_t)&v16);
    if (result) {
      return result;
    }
    uint64_t result = vcu_getRationalFromDictionary(a1, (const void *)*MEMORY[0x1E4F24A70], (void *)*MEMORY[0x1E4F1EEB8], (uint64_t)&v15);
    if (result) {
      return result;
    }
    uint64_t result = vcu_getRationalFromDictionary(a1, (const void *)*MEMORY[0x1E4F24A80], (void *)*MEMORY[0x1E4F1EEC8], (uint64_t)&v14);
    if (result) {
      return result;
    }
    if (!a4) {
      goto LABEL_9;
    }
LABEL_8:
    *a4 = v17;
LABEL_9:
    if (a5) {
      *a5 = v16;
    }
    if (a6) {
      *a6 = v15;
    }
    uint64_t result = 0;
    if (a7) {
      *a7 = v14;
    }
    return result;
  }

  return FigSignalErrorAt();
}

unint64_t vcu_simplifyRational(uint64_t a1)
{
  if ((int)a1 >= 0) {
    int v1 = a1;
  }
  else {
    int v1 = -(int)a1;
  }
  if (a1 >= 0) {
    int v2 = HIDWORD(a1);
  }
  else {
    int v2 = -HIDWORD(a1);
  }
  if (v1 <= v2) {
    unsigned int v3 = v2;
  }
  else {
    unsigned int v3 = v1;
  }
  if (v1 >= v2) {
    int v1 = v2;
  }
  if (v1)
  {
    if (v1 < 1)
    {
      int v4 = v3;
    }
    else
    {
      do
      {
        int v4 = v1;
        int v1 = (int)v3 % v1;
        unsigned int v3 = v4;
      }
      while (v1 > 0);
    }
  }
  else if (v3 <= 1)
  {
    int v4 = 1;
  }
  else
  {
    int v4 = v3;
  }
  return ((int)a1 / v4) | ((unint64_t)(SHIDWORD(a1) / v4) << 32);
}

BOOL FigVideoCompositorUtilityArePixelAspectRatiosEqual(CFTypeID a1, CFTypeID a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  FigVideoCompositorUtilityGetPixelAspectRatio(a1, (_DWORD *)&v8 + 1, &v8);
  FigVideoCompositorUtilityGetPixelAspectRatio(a2, (_DWORD *)&v7 + 1, &v7);
  uint64_t v4 = v7;
  uint64_t v3 = HIDWORD(v7);
  unint64_t v5 = vcu_simplifyRational(HIDWORD(v8) | ((unint64_t)v8 << 32));
  return v5 == vcu_simplifyRational(v3 | (v4 << 32));
}

float FigVideoCompositorUtilityGetCleanAperture(const __CFDictionary *a1, int a2, int a3, float *a4, float *a5, float *a6, float *a7)
{
  uint64_t v14 = 0x100000000;
  uint64_t v15 = 0x100000000;
  uint64_t v12 = 0x100000000;
  uint64_t v13 = 0x100000000;
  if (!vcu_getCleanApertureRational(a1, a2, a3, &v15, &v14, &v13, &v12))
  {
    if (a4)
    {
      float result = (float)(int)v15 / (float)SHIDWORD(v15);
      *a4 = result;
    }
    if (a5)
    {
      float result = (float)(int)v14 / (float)SHIDWORD(v14);
      *a5 = result;
    }
    if (a6)
    {
      float result = (float)(int)v13 / (float)SHIDWORD(v13);
      *a6 = result;
    }
    if (a7)
    {
      float result = (float)(int)v12 / (float)SHIDWORD(v12);
      *a7 = result;
    }
  }
  return result;
}

void vcu_addRationalToDictionary(unint64_t a1, __CFDictionary *a2, const void *a3, const void *a4)
{
  unint64_t v7 = HIDWORD(a1);
  unint64_t valuePtr = a1;
  double v13 = (double)(int)a1 / (double)SHIDWORD(a1);
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &v13);
  CFDictionaryAddValue(a2, a3, v9);
  CFRelease(v9);
  if (v7 != 1)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v8, 2, MEMORY[0x1E4F1D510]);
    CFNumberRef v11 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
    CFArrayAppendValue(Mutable, v11);
    CFRelease(v11);
    CFNumberRef v12 = CFNumberCreate(v8, kCFNumberIntType, (char *)&valuePtr + 4);
    CFArrayAppendValue(Mutable, v12);
    CFRelease(v12);
    CFDictionaryAddValue(a2, a4, Mutable);
    CFRelease(Mutable);
  }
}

uint64_t FigVideoCompositorUtilityCopyRenderPixelBufferDimensionsAndCleanAperture(CFTypeID a1, uint64_t theArray, void *a3, void *a4, uint64_t a5, __CFDictionary **a6, double a7, double a8, float a9)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  int v33 = 1;
  int v34 = 1;
  int32x4_t v35 = 0uLL;
  float v32 = a9;
  if (a1)
  {
    FigVideoCompositorUtilityGetPixelAspectRatio(a1, &v34, &v33);
    a9 = v32;
  }
  if (theArray)
  {
    FigVideoCompositorUtilityGetEdgeProcessingPixels(theArray, &v35);
    a9 = v32;
  }
  int32x4_t v35 = vcvtq_s32_f32(vmulq_n_f32(vcvtq_f32_s32(v35), a9));
  double v16 = (double)v33;
  if (a9 == 1.0)
  {
    int v17 = v34;
    unint64_t v18 = vcu_simplifyRational((int)(a7 * v16 + 0.5) | ((unint64_t)v34 << 32));
    unsigned __int32 v19 = v18;
    uint64_t v20 = HIDWORD(v18);
    if ((v18 & 0x8000000000000000) == 0) {
      int v21 = HIDWORD(v18);
    }
    else {
      int v21 = HIDWORD(v18) + 1;
    }
    int v22 = ((int)v18 + (v21 >> 1)) / SHIDWORD(v18);
    int v23 = v35.i32[0];
    signed __int32 v24 = v35.i32[0] + v35.i32[2] + v22;
    if ((float)((float)(int)v18 / (float)SHIDWORD(v18)) > (float)v24)
    {
      uint64_t v20 = 1;
      unsigned __int32 v19 = v24;
    }
    a9 = v32;
    if (a3) {
      goto LABEL_12;
    }
  }
  else
  {
    int v17 = v34;
    int v23 = v35.i32[0];
    signed __int32 v24 = (v35.i32[2] + v35.i32[0] + (int)(a7 * v16 * a9 / (double)v34 + 1.0)) & 0xFFFFFFFE;
    unsigned __int32 v19 = v24 - (v35.i32[2] + v35.i32[0]);
    uint64_t v20 = 1;
    if (a3) {
LABEL_12:
    }
      *a3 = v24;
  }
  if (a9 == 1.0)
  {
    unsigned int v25 = (int)(a8 + 0.5);
    int v26 = v35.i32[1];
    signed __int32 v27 = v35.i32[1] + v35.i32[3] + v25;
    if (!a4) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  int v26 = v35.i32[1];
  signed __int32 v27 = (v35.i32[3] + v35.i32[1] + (int)(a8 * a9 + 1.0)) & 0xFFFFFFFE;
  unsigned int v25 = v27 - (v35.i32[3] + v35.i32[1]);
  if (a4) {
LABEL_15:
  }
    *a4 = v27;
LABEL_16:
  if (a5)
  {
    *(double *)a5 = v16 / (double)v17;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    *(void *)(a5 + 24) = 0x3FF0000000000000;
    *(double *)(a5 + 32) = (double)v23;
    *(double *)(a5 + 40) = (double)v26;
  }
  if (a6)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    vcu_addRationalToDictionary(v19 | (unint64_t)(v20 << 32), Mutable, (const void *)*MEMORY[0x1E4F24A88], (const void *)*MEMORY[0x1E4F1EED8]);
    vcu_addRationalToDictionary(v25 | 0x100000000, Mutable, (const void *)*MEMORY[0x1E4F24A68], (const void *)*MEMORY[0x1E4F1EEA8]);
    unint64_t v29 = vcu_simplifyRational((v35.i32[0] - v35.i32[2]) | 0x200000000);
    vcu_addRationalToDictionary(v29, Mutable, (const void *)*MEMORY[0x1E4F24A70], (const void *)*MEMORY[0x1E4F1EEB8]);
    unint64_t v30 = vcu_simplifyRational((v35.i32[1] - v35.i32[3]) | 0x200000000);
    vcu_addRationalToDictionary(v30, Mutable, (const void *)*MEMORY[0x1E4F24A80], (const void *)*MEMORY[0x1E4F1EEC8]);
    *a6 = Mutable;
  }
  return 0;
}

uint64_t FigVideoCompositorUtilityCopyRenderDimensionsAndEdgeProcessingPixels(int a1, int a2, CFTypeID a3, const __CFDictionary *a4, double *a5, __CFArray **a6)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  int v26 = 1;
  int v27 = 1;
  int v24 = a1;
  int v25 = 1;
  int v22 = a2;
  int v23 = 1;
  uint64_t v20 = 0x100000000;
  uint64_t v21 = 0x100000000;
  if (a3) {
    FigVideoCompositorUtilityGetPixelAspectRatio(a3, &v27, &v26);
  }
  if (!a4
    || (uint64_t result = vcu_getRationalFromDictionary(a4, (const void *)*MEMORY[0x1E4F24A88], (void *)*MEMORY[0x1E4F1EED8], (uint64_t)&v24), !result)&& (uint64_t result = vcu_getRationalFromDictionary(a4, (const void *)*MEMORY[0x1E4F24A68], (void *)*MEMORY[0x1E4F1EEA8], (uint64_t)&v22), !result)&& (uint64_t result = vcu_getRationalFromDictionary(a4, (const void *)*MEMORY[0x1E4F24A70], (void *)*MEMORY[0x1E4F1EEB8], (uint64_t)&v21), !result)&& (uint64_t result = vcu_getRationalFromDictionary(a4,
                   (const void *)*MEMORY[0x1E4F24A80],
                   (void *)*MEMORY[0x1E4F1EEC8],
                   (uint64_t)&v20),
        !result))
  {
    if (a5)
    {
      double v12 = (double)v22 / (double)v23;
      *a5 = (double)v24 * (double)v27 / ((double)v25 * (double)v26);
      a5[1] = v12;
    }
    if (a6)
    {
      int v13 = a1 - v24 / v25;
      int v14 = a2 - v22 / v23;
      CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D510]);
      uint64_t v17 = 0;
      double v18 = (double)((int)v21 / SHIDWORD(v21));
      v28[0] = (int)(v18 + (double)v13 * 0.5);
      v28[1] = (int)(v18 + (double)v14 * 0.5);
      v28[2] = (int)-(v18 - (double)v13 * 0.5);
      v28[3] = (int)-(v18 - (double)v14 * 0.5);
      do
      {
        CFNumberRef v19 = CFNumberCreate(v15, kCFNumberIntType, &v28[v17]);
        CFArrayAppendValue(Mutable, v19);
        CFRelease(v19);
        ++v17;
      }
      while (v17 != 4);
      uint64_t result = 0;
      *a6 = Mutable;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t vcu_getRationalFromDictionary(const __CFDictionary *a1, const void *a2, void *key, uint64_t a4)
{
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a1, key);
  if (Value)
  {
    CFArrayRef v8 = Value;
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(v8) && CFArrayGetCount(v8) == 2)
    {
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v8, 0);
      CFNumberGetValue(ValueAtIndex, kCFNumberIntType, (void *)a4);
      CFNumberRef v11 = (const __CFNumber *)CFArrayGetValueAtIndex(v8, 1);
      CFNumberGetValue(v11, kCFNumberIntType, (void *)(a4 + 4));
      return 0;
    }
  }
  CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (v12)
  {
    CFNumberGetValue(v12, kCFNumberIntType, (void *)a4);
    *(_DWORD *)(a4 + 4) = 1;
    return 0;
  }

  return FigSignalErrorAt();
}

uint64_t FigVideoCompositorCopyDeviceSpecificCompositorName(int a1, void *a2)
{
  if (!a2) {
    goto LABEL_14;
  }
  if (a1)
  {
    if (a1 != 1) {
      goto LABEL_14;
    }
    uint64_t v3 = @"Remake";
  }
  else
  {
    uint64_t v3 = @"Playback";
  }
  uint64_t ModelSpecificPropertyList = FigCreateModelSpecificPropertyList();
  if (ModelSpecificPropertyList)
  {
    unint64_t v5 = (const void *)ModelSpecificPropertyList;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (TypeID != CFGetTypeID(v5)) {
      goto LABEL_32;
    }
    CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)v5, @"VideoCompositor");
    if (!Value) {
      goto LABEL_32;
    }
    CFArrayRef v8 = Value;
    CFTypeID v9 = CFDictionaryGetTypeID();
    if (v9 != CFGetTypeID(v8)) {
      goto LABEL_32;
    }
    uint64_t v10 = CFDictionaryGetValue((CFDictionaryRef)v8, v3);
    if (!v10) {
      goto LABEL_32;
    }
    CFNumberRef v11 = v10;
    CFTypeID v12 = CFStringGetTypeID();
    if (v12 != CFGetTypeID(v11)) {
      goto LABEL_32;
    }
    if (CFEqual(v11, @"vImage"))
    {
      int v13 = @"VideoCompositorvImage";
    }
    else if (CFEqual(v11, @"Metal"))
    {
      int v13 = @"VideoCompositorMetal";
    }
    else if (CFEqual(v11, @"OpenGL"))
    {
      int v13 = @"VideoCompositorOpenGL";
    }
    else if (CFEqual(v11, @"Custom"))
    {
      int v13 = @"VideoCompositorCustom";
    }
    else
    {
      int v13 = @"VideoCompositorBasic";
    }
    CFTypeRef v15 = CFRetain(v13);
    if (FigCFEqual() && !VTPixelTransferSessionCanUseMetalInTheBackground())
    {
      CFRetain(@"VideoCompositorvImage");
      if (v15) {
        CFRelease(v15);
      }
      uint64_t v16 = 0;
      *a2 = @"VideoCompositorvImage";
      goto LABEL_31;
    }
    *a2 = v15;
    if (v15) {
      uint64_t v16 = 0;
    }
    else {
LABEL_32:
    }
      uint64_t v16 = FigSignalErrorAt();
LABEL_31:
    CFRelease(v5);
    return v16;
  }
LABEL_14:

  return FigSignalErrorAt();
}

BOOL FigVideoCompositorIsPixelBufferOpaque(__CVBuffer *a1)
{
  CFTypeRef v2 = CVBufferCopyAttachment(a1, (CFStringRef)*MEMORY[0x1E4F249D0], 0);
  uint64_t v3 = v2;
  uint64_t v4 = (const void *)*MEMORY[0x1E4F1CFD0];
  if (v2 == (CFTypeRef)*MEMORY[0x1E4F1CFD0])
  {
    BOOL v6 = 1;
    if (!v2) {
      return v6;
    }
    goto LABEL_3;
  }
  CVPixelBufferGetPixelFormatType(a1);
  CFDictionaryRef DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  BOOL v6 = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E4F24E98]) != v4;
  if (v3) {
LABEL_3:
  }
    CFRelease(v3);
  return v6;
}

CFStringRef FigVideoCompositorCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigVideoCompositor %p]", a1);
}

uint64_t FigDataQueueServer_EnsureServerAndCopyXPCEndpoint()
{
  if (FigDataQueueServer_EnsureServerAndCopyXPCEndpoint_sFigDataQueueServerOnce != -1) {
    dispatch_once(&FigDataQueueServer_EnsureServerAndCopyXPCEndpoint_sFigDataQueueServerOnce, &__block_literal_global_65);
  }
  uint64_t result = FigDataQueueServer_EnsureServerAndCopyXPCEndpoint_sFigDataQueueServerStartError;
  if (!FigDataQueueServer_EnsureServerAndCopyXPCEndpoint_sFigDataQueueServerStartError)
  {
    return FigXPCServerCopyXPCEndpoint();
  }
  return result;
}

uint64_t FigDataQueueServer_AssociateObjectByPID(uint64_t a1, const void *a2, void *a3)
{
  if (FigDataQueueServerStateGetTypeID_sRegisterDataQueueServerStateTypeOnce != -1) {
    dispatch_once(&FigDataQueueServerStateGetTypeID_sRegisterDataQueueServerStateTypeOnce, &__block_literal_global_27);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    BOOL v6 = (void *)Instance;
    if (a2) {
      CFTypeRef v7 = CFRetain(a2);
    }
    else {
      CFTypeRef v7 = 0;
    }
    v6[3] = v7;
    uint64_t v8 = FigXPCServerAssociateObjectWithNeighborProcessByPID();
    if (v8)
    {
      CFRelease(v6);
    }
    else
    {
      v6[4] = 0;
      *a3 = 0;
    }
    return v8;
  }
  else
  {
    FigSignalErrorAt();
    return FigSignalErrorAt();
  }
}

uint64_t FigDataQueueServer_CopyDataQueueForID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F40DECB8](gFigDataQueueServer, a1, a2, a3);
}

uint64_t dqs_HandleRemoteMessage(uint64_t a1, void *a2)
{
  uint64_t OpCode = FigXPCMessageGetOpCode();
  if (OpCode) {
    return OpCode;
  }
  xpc_dictionary_get_uint64(a2, (const char *)*MEMORY[0x1E4F20280]);
  uint64_t OpCode = FigXPCServerLookupAndRetainAssociatedObject();
  if (OpCode) {
    return OpCode;
  }
  else {
    return 4294951138;
  }
}

uint64_t dqs_SetWaterLevelInMessage(uint64_t a1)
{
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void (**)(uint64_t))(v3 + 16);
  if (v4) {
    v4(a1);
  }

  return FigXPCMessageSetInt32();
}

void dqs_SendLowWaterMarkCallback()
{
  uint64_t v0 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v0)
  {
    int v1 = (xpc_connection_t *)v0;
    if (!FigXPCCreateBasicMessage()) {
      xpc_connection_send_message(v1[2], 0);
    }
    FigXPCRelease();
    CFRelease(v1);
  }
  else
  {
    FigSignalErrorAt();
    FigXPCRelease();
  }
}

uint64_t __FigDataQueueServerStateGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  FigDataQueueServerStateGetTypeID_sDataQueueServerStateCFTypeID TypeID = result;
  return result;
}

double DataQueueServerState_init(_OWORD *a1)
{
  double result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void DataQueueServerState_finalize(uint64_t a1)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 48))
    {
      uint64_t v2 = *(void *)(a1 + 24);
      uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v4 = v3 ? v3 : 0;
      unint64_t v5 = *(void (**)(uint64_t))(v4 + 32);
      if (v5) {
        v5(v2);
      }
    }
    BOOL v6 = *(const void **)(a1 + 56);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(a1 + 56) = 0;
    }
    CFTypeRef v7 = *(const void **)(a1 + 40);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(a1 + 40) = 0;
    }
    uint64_t v8 = *(const void **)(a1 + 24);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(a1 + 24) = 0;
    }
    CFTypeID v9 = *(const void **)(a1 + 64);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 64) = 0;
    }
    uint64_t v10 = *(const void **)(a1 + 72);
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a1 + 72) = 0;
    }
  }
}

CFStringRef DataQueueServerState_copyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (a1) {
    return CFStringCreateWithFormat(v2, 0, @"[DataQueueServerState %p] dataQueue:%p dataQueueObjectID:%llu", a1, *(void *)(a1 + 24), *(void *)(a1 + 32));
  }
  else {
    return CFStringCreateWithFormat(v2, 0, @"[DataQueueServerState %p]", 0);
  }
}

uint64_t FigAssetCacheInspectorCreate_Streaming(const void *a1, CFTypeRef cf, CFTypeRef *a3)
{
  if (!cf) {
    return FigSignalErrorAt();
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != FigAssetGetTypeID() || !a3) {
    return FigSignalErrorAt();
  }
  FigAssetCacheInspectorGetClassID();
  uint64_t v7 = CMDerivedObjectCreate();
  if (v7) {
    return v7;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  dispatch_queue_t v9 = dispatch_queue_create("com.apple.coremedia.streamingcacheinspector.statequeue", 0);
  *(void *)uint64_t DerivedStorage = v9;
  if (!v9) {
    return FigSignalErrorAt();
  }
  if (a1) {
    CFTypeRef v10 = CFRetain(a1);
  }
  else {
    CFTypeRef v10 = 0;
  }
  *(void *)(DerivedStorage + 16) = v10;
  *(void *)(DerivedStorage + 24) = CFRetain(cf);
  if (FigIsItOKToLogURLs()) {
    BOOL v11 = FPSupport_GetAssetDoNotLogURLs((uint64_t)cf) == 0;
  }
  else {
    BOOL v11 = 0;
  }
  *(unsigned char *)(DerivedStorage + 73) = v11;
  uint64_t v12 = *(void *)(DerivedStorage + 16);
  uint64_t CMBaseObject = FigAssetGetCMBaseObject(cf);
  uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, uint64_t))(v15 + 48);
  if (!v16) {
    return 4294954514;
  }
  uint64_t v7 = v16(CMBaseObject, @"assetProperty_CreationURL", v12, DerivedStorage + 32);
  if (v7) {
    return v7;
  }
  if (!*(void *)(DerivedStorage + 32)) {
    return FigSignalErrorAt();
  }
  CMBaseObjectGetDerivedStorage();
  CMNotificationCenterGetDefaultLocalCenter();
  uint64_t v7 = FigNotificationCenterAddWeakListener();
  if (v7) {
    return v7;
  }
  uint64_t v17 = sci_copyCacheURL(DerivedStorage, (void *)(DerivedStorage + 40));
  if (!v17) {
    *a3 = CFRetain(0);
  }
  return v17;
}

uint64_t sci_copyCacheURL(uint64_t a1, void *a2)
{
  CFTypeRef cf = 0;
  if (FigCFURLIsLocalResource())
  {
    CFTypeRef v4 = *(CFTypeRef *)(a1 + 32);
    if (v4) {
      CFTypeRef v4 = CFRetain(v4);
    }
    CFTypeRef cf = v4;
    goto LABEL_6;
  }
  uint64_t v5 = FigAssetDownloadCoordinatorCopyDestinationURLForAsset(*(void *)(a1 + 24), &cf);
  CFTypeRef v4 = cf;
  if (!v5)
  {
LABEL_6:
    if (v4)
    {
      CFTypeRef v6 = CFRetain(v4);
      CFTypeRef v4 = cf;
    }
    else
    {
      CFTypeRef v6 = 0;
    }
    uint64_t v5 = 0;
    *a2 = v6;
  }
  if (v4) {
    CFRelease(v4);
  }
  return v5;
}

uint64_t sci_invalidate(uint64_t a1)
{
  uint64_t v4 = 0;
  context[0] = CMBaseObjectGetDerivedStorage();
  context[1] = a1;
  dispatch_sync_f(*(dispatch_queue_t *)context[0], context, (dispatch_function_t)sci_invalidateDispatch);
  return v4;
}

void sci_finalize(uint64_t a1)
{
  uint64_t DerivedStorage = (dispatch_object_t *)CMBaseObjectGetDerivedStorage();
  if (a1)
  {
    uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 8);
    uint64_t v4 = v3 ? v3 : 0;
    uint64_t v5 = *(void (**)(uint64_t))(v4 + 24);
    if (v5) {
      v5(a1);
    }
  }
  if (*DerivedStorage)
  {
    dispatch_release(*DerivedStorage);
    dispatch_object_t *DerivedStorage = 0;
  }
}

uint64_t sci_copyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = 0;
  uint64_t DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage();
  if (a4)
  {
    v8[0] = DerivedStorage;
    v8[1] = a2;
    _OWORD v8[2] = a4;
    dispatch_sync_f(*DerivedStorage, v8, (dispatch_function_t)sci_copyPropertyDispatch);
    return v9;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void sci_invalidateDispatch(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v1 = *a1;
    if (*a1)
    {
      if (!*(unsigned char *)(v1 + 8))
      {
        *(unsigned char *)(v1 + 8) = 1;
        CMBaseObjectGetDerivedStorage();
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterRemoveWeakListener();
        CFAllocatorRef v2 = *(const void **)(v1 + 16);
        if (v2)
        {
          CFRelease(v2);
          *(void *)(v1 + 16) = 0;
        }
        uint64_t v3 = *(const void **)(v1 + 24);
        if (v3)
        {
          CFRelease(v3);
          *(void *)(v1 + 24) = 0;
        }
        uint64_t v4 = *(const void **)(v1 + 32);
        if (v4)
        {
          CFRelease(v4);
          *(void *)(v1 + 32) = 0;
        }
        uint64_t v5 = *(const void **)(v1 + 40);
        if (v5)
        {
          CFRelease(v5);
          *(void *)(v1 + 40) = 0;
        }
        CFTypeRef v6 = *(const void **)(v1 + 48);
        if (v6)
        {
          CFRelease(v6);
          *(void *)(v1 + 48) = 0;
        }
        uint64_t v7 = *(const void **)(v1 + 56);
        if (v7)
        {
          CFRelease(v7);
          *(void *)(v1 + 56) = 0;
        }
        uint64_t v8 = *(const void **)(v1 + 64);
        if (v8)
        {
          CFRelease(v8);
          *(void *)(v1 + 64) = 0;
        }
      }
    }
  }
}

uint64_t sci_assetBecameReadyForDownload()
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (!*(unsigned char *)(result + 8) && !*(void *)(result + 40))
  {
    return sci_copyCacheURL(result, (void *)(result + 40));
  }
  return result;
}

void sci_copyPropertyDispatch(uint64_t a1)
{
  if (!a1) {
    return;
  }
  uint64_t v2 = *(void *)a1;
  if (!*(void *)a1 || *(unsigned char *)(v2 + 8)) {
    return;
  }
  if (CFEqual(@"AssetCacheInspectorProperty_CacheURL", *(CFTypeRef *)(a1 + 8)))
  {
    CFTypeRef v3 = *(CFTypeRef *)(v2 + 40);
    if (v3) {
      CFTypeRef v3 = CFRetain(v3);
    }
    **(void **)(a1 + 16) = v3;
    return;
  }
  if (!CFEqual(@"AssetCacheInspectorProperty_PlayableOffline", *(CFTypeRef *)(a1 + 8))) {
    return;
  }
  uint64_t v4 = *(void **)(a1 + 16);
  char v9 = 0;
  CFTypeRef cf = 0;
  if (*(unsigned char *)(v2 + 72)) {
    goto LABEL_14;
  }
  if (!*(void *)(v2 + 40))
  {
LABEL_15:
    uint64_t v7 = (void *)MEMORY[0x1E4F1CFC8];
    goto LABEL_16;
  }
  int v5 = sci_createAndOpenHLSPersistentStore(v2, &cf);
  if (v5)
  {
    int isPlayableOffline = v5;
    goto LABEL_17;
  }
  int isPlayableOffline = sci_isPlayableOffline(v2, (uint64_t)cf, &v9);
  if (!isPlayableOffline)
  {
    if (v9)
    {
LABEL_14:
      uint64_t v7 = (void *)MEMORY[0x1E4F1CFD0];
LABEL_16:
      int isPlayableOffline = 0;
      *uint64_t v4 = *v7;
      goto LABEL_17;
    }
    goto LABEL_15;
  }
LABEL_17:
  if (cf) {
    CFRelease(cf);
  }
  *(_DWORD *)(a1 + 24) = isPlayableOffline;
}

uint64_t sci_createAndOpenHLSPersistentStore(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3) {
    return FigHLSPersistentStoreCreateAtURL(*(const void **)(a1 + 16), v3, 0, 0, a2);
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t sci_isPlayableOffline(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  char v24 = 0;
  if (*(unsigned char *)(a1 + 72))
  {
    CFArrayRef v18 = 0;
    CFArrayRef v19 = 0;
    LOBYTE(v5) = 1;
    goto LABEL_26;
  }
  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    CFArrayRef v18 = 0;
    CFArrayRef v19 = 0;
    goto LABEL_26;
  }
  uint64_t v7 = sci_ensureAlternateArrayAndMediaSelectionArray(a1, a2);
  if (v7) {
    return v7;
  }
  if (*(void *)(a1 + 56))
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 16), 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFMutableArrayRef v9 = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 16), 0, MEMORY[0x1E4F1D510]);
      if (v9)
      {
        CFTypeRef v10 = v9;
        for (CFIndex i = 0; ; ++i)
        {
          CFArrayRef Count = *(const __CFArray **)(a1 + 56);
          if (Count) {
            CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
          }
          if (i >= (uint64_t)Count) {
            break;
          }
          CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), i);
          CFURLRef PlaylistAlternateURL = (const __CFURL *)FigAlternateGetPlaylistAlternateURL((uint64_t)ValueAtIndex);
          uint64_t StableStreamIdentifier = FigAlternateGetStableStreamIdentifier((uint64_t)ValueAtIndex);
          if (PlaylistAlternateURL)
          {
            uint64_t v16 = (const void *)StableStreamIdentifier;
            CFTypeRef v17 = FigCFHTTPCreateURLString(PlaylistAlternateURL);
            CFArrayAppendValue(Mutable, v17);
            if (v17) {
              CFRelease(v17);
            }
            if (v16) {
              CFArrayAppendValue(v10, v16);
            }
          }
        }
        CFArrayAppendValue(Mutable, *(const void **)(a1 + 48));
        goto LABEL_18;
      }
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
  }
  uint64_t v20 = FigSignalErrorAt();
  CFTypeRef v10 = 0;
  CFArrayRef v18 = 0;
  CFArrayRef v19 = 0;
  uint64_t v21 = 0;
  if (!v20)
  {
LABEL_18:
    CFArrayRef v18 = (const __CFArray *)CFRetain(Mutable);
    CFArrayRef v19 = (const __CFArray *)CFRetain(v10);
    uint64_t v20 = 0;
    uint64_t v21 = v10;
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v20)
  {
LABEL_27:
    if (!v18) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  uint64_t v22 = sci_areAnyNetworkURLsOrStreamIDsCompletelyCached(a2, v18, v19, &v24);
  if (!v22)
  {
    LOBYTE(v5) = v24;
    *(unsigned char *)(a1 + 72) = v24;
LABEL_26:
    uint64_t v20 = 0;
    *a3 = v5;
    goto LABEL_27;
  }
  uint64_t v20 = v22;
  if (v18) {
LABEL_28:
  }
    CFRelease(v18);
LABEL_29:
  if (v19) {
    CFRelease(v19);
  }
  return v20;
}

uint64_t sci_ensureAlternateArrayAndMediaSelectionArray(uint64_t a1, uint64_t a2)
{
  CFTypeRef v26 = 0;
  CFTypeRef v27 = 0;
  int v25 = 0;
  int v24 = 0;
  CFTypeRef cf = 0;
  if (*(void *)(a1 + 64) || *(void *)(a1 + 56))
  {
    uint64_t v18 = 0;
    goto LABEL_20;
  }
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  CFTypeRef v6 = *(uint64_t (**)(uint64_t, __CFString *, CFTypeRef *, void, CFTypeRef *, OpaqueCMBlockBuffer **))(v5 + 48);
  if (!v6) {
    goto LABEL_19;
  }
  uint64_t v7 = v6(a2, @"NetworkPlaylist", &v27, 0, &v26, &v25);
  if (!v7)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    uint64_t FigBaseObject = FigHLSPersistentStoreGetFigBaseObject(a2);
    uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, uint64_t))(v11 + 48);
    if (v12)
    {
      int v13 = (CFStringRef *)(a1 + 48);
      uint64_t v7 = v12(FigBaseObject, @"MasterPlaylistNetworkURL", v8, a1 + 48);
      if (!v7)
      {
        if (*v13)
        {
          CFURLRef v14 = CFURLCreateWithString(*(CFAllocatorRef *)(a1 + 16), *v13, 0);
          if (v14)
          {
            CFURLRef v15 = v14;
            uint64_t v16 = FigStreamPlaylistParse(v25, v14, 0, &v24, 0, 0, 1, *(unsigned __int8 *)(a1 + 73), 0, 0, 0, 0, (uint64_t *)&cf, 0);
            if (v16)
            {
LABEL_38:
              uint64_t v18 = v16;
              goto LABEL_35;
            }
            if (cf && FigMultivariantPlaylistGetMediaSelectionArray((uint64_t)cf))
            {
              MediaSelectionArradouble y = (const void *)FigMultivariantPlaylistGetMediaSelectionArray((uint64_t)cf);
              *(void *)(a1 + 64) = CFRetain(MediaSelectionArray);
            }
            else
            {
              CFArrayRef v20 = CFArrayCreate(*(CFAllocatorRef *)(a1 + 16), 0, 0, MEMORY[0x1E4F1D510]);
              *(void *)(a1 + 64) = v20;
              if (!v20)
              {
LABEL_37:
                uint64_t v16 = FigSignalErrorAt();
                goto LABEL_38;
              }
            }
            if (cf && FigMultivariantPlaylistGetAlternates((uint64_t)cf))
            {
              Alternates = (const void *)FigMultivariantPlaylistGetAlternates((uint64_t)cf);
              uint64_t v18 = 0;
              *(void *)(a1 + 56) = CFRetain(Alternates);
LABEL_35:
              CFRelease(v15);
              goto LABEL_20;
            }
            CFArrayRef v22 = CFArrayCreate(*(CFAllocatorRef *)(a1 + 16), 0, 0, MEMORY[0x1E4F1D510]);
            *(void *)(a1 + 56) = v22;
            if (v22)
            {
              uint64_t v18 = 0;
              goto LABEL_35;
            }
            goto LABEL_37;
          }
        }
        uint64_t v7 = FigSignalErrorAt();
      }
      goto LABEL_40;
    }
LABEL_19:
    uint64_t v18 = 4294954514;
    goto LABEL_20;
  }
LABEL_40:
  uint64_t v18 = v7;
LABEL_20:
  if (v27) {
    CFRelease(v27);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v18;
}

uint64_t sci_areAnyNetworkURLsOrStreamIDsCompletelyCached(uint64_t a1, const __CFArray *a2, const __CFArray *a3, unsigned char *a4)
{
  char v33 = 0;
  xpc_object_t value = 0;
  CFArrayRef theArray = 0;
  CFTypeRef cf = 0;
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, CFArrayRef *))(v9 + 24);
  if (!v10)
  {
LABEL_42:
    uint64_t v28 = 4294954514;
    goto LABEL_43;
  }
  uint64_t v11 = v10(a1, &theArray);
  if (v11)
  {
LABEL_52:
    uint64_t v28 = v11;
    goto LABEL_43;
  }
  for (CFIndex i = 0; ; ++i)
  {
    CFIndex Count = (CFIndex)theArray;
    if (theArray) {
      CFIndex Count = CFArrayGetCount(theArray);
    }
    if (i >= Count) {
      break;
    }
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
    uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v15) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = 0;
    }
    CFTypeRef v17 = *(uint64_t (**)(uint64_t, const void *, CFTypeRef *))(v16 + 80);
    if (!v17) {
      goto LABEL_42;
    }
    uint64_t v11 = v17(a1, ValueAtIndex, &cf);
    if (v11) {
      goto LABEL_52;
    }
    uint64_t v18 = cf;
    if (cf)
    {
      if (a3)
      {
        v19.length = CFArrayGetCount(a3);
        uint64_t v18 = cf;
      }
      else
      {
        v19.length = 0;
      }
      CFArrayRef v22 = a3;
      goto LABEL_30;
    }
    uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v20) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = 0;
    }
    int v23 = *(uint64_t (**)(uint64_t, const void *, void **))(v21 + 72);
    if (!v23) {
      goto LABEL_42;
    }
    uint64_t v11 = v23(a1, ValueAtIndex, &value);
    if (v11) {
      goto LABEL_52;
    }
    uint64_t v18 = value;
    if (value)
    {
      if (a2)
      {
        v19.length = CFArrayGetCount(a2);
        uint64_t v18 = value;
      }
      else
      {
        v19.length = 0;
      }
      CFArrayRef v22 = a2;
LABEL_30:
      v19.locatioCFIndex n = 0;
      if (CFArrayContainsValue(v22, v19, v18))
      {
        uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v24) {
          uint64_t v25 = v24;
        }
        else {
          uint64_t v25 = 0;
        }
        CFTypeRef v26 = *(uint64_t (**)(uint64_t, const void *, char *))(v25 + 64);
        if (!v26) {
          goto LABEL_42;
        }
        uint64_t v11 = v26(a1, ValueAtIndex, &v33);
        if (v11) {
          goto LABEL_52;
        }
      }
    }
    char v27 = v33;
    if (v33) {
      goto LABEL_51;
    }
    if (value)
    {
      CFRelease(value);
      xpc_object_t value = 0;
    }
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
  }
  char v27 = v33;
LABEL_51:
  uint64_t v28 = 0;
  *a4 = v27;
LABEL_43:
  if (theArray) {
    CFRelease(theArray);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (value) {
    CFRelease(value);
  }
  return v28;
}

uint64_t sci_copyCompletelyCachedMediaSelectionOptionsInGroup(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  long long v11 = 0u;
  long long v12 = 0u;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2 && (v7 = (dispatch_queue_t *)DerivedStorage, CFTypeID v8 = CFGetTypeID(a2), v8 == CFDictionaryGetTypeID()) && a4)
  {
    CMTime context = v7;
    *((void *)&v11 + 1) = a2;
    *(void *)&long long v12 = a4;
    dispatch_sync_f(*v7, &context, (dispatch_function_t)sci_copyCompletelyCachedMediaSelectionOptionsInGroupDispatch);
    return DWORD2(v12);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void sci_copyCompletelyCachedMediaSelectionOptionsInGroupDispatch(uint64_t *a1)
{
  if (!a1) {
    return;
  }
  uint64_t v1 = a1;
  uint64_t v3 = *a1;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFTypeRef v4 = CFRetain(v2);
  }
  else {
    CFTypeRef v4 = 0;
  }
  CFTypeRef cf = v4;
  if (!v3
    || *(unsigned char *)(v3 + 8)
    || (CFMutableArrayRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(v3 + 16), 0, MEMORY[0x1E4F1D510])) == 0)
  {
    int v7 = FigSignalErrorAt();
    CFArrayRef v6 = 0;
    goto LABEL_73;
  }
  CFArrayRef v6 = Mutable;
  if (!*(void *)(v3 + 40))
  {
LABEL_67:
    *(void *)v1[3] = CFArrayCreateCopy(*(CFAllocatorRef *)(v3 + 16), v6);
    if (*(void *)v1[3]) {
      int v7 = 0;
    }
    else {
      int v7 = FigSignalErrorAt();
    }
    goto LABEL_74;
  }
  if (!v4)
  {
    int v7 = sci_createAndOpenHLSPersistentStore(v3, &cf);
    if (v7 || !cf)
    {
LABEL_73:
      if (v7) {
        goto LABEL_74;
      }
      goto LABEL_67;
    }
  }
  uint64_t v36 = v1;
  CFArrayRef theArray = v6;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v1[2], @"MediaSelectionGroupOptions");
  CFIndex v9 = 0;
  uint64_t v10 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFArrayRef v38 = Value;
  if (!Value) {
    goto LABEL_14;
  }
LABEL_13:
  for (CFIndex i = CFArrayGetCount(Value); ; CFIndex i = 0)
  {
    if (v9 >= i)
    {
      uint64_t v1 = v36;
      CFArrayRef v6 = theArray;
      goto LABEL_67;
    }
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v9);
    CFTypeRef v13 = cf;
    __int16 v44 = 0;
    int isPlayableOffline = sci_isPlayableOffline(v3, (uint64_t)cf, &v44);
    if (isPlayableOffline) {
      break;
    }
    if (!(_BYTE)v44) {
      goto LABEL_62;
    }
    int isPlayableOffline = sci_ensureAlternateArrayAndMediaSelectionArray(v3, (uint64_t)v13);
    if (isPlayableOffline) {
      break;
    }
    int v45 = 0;
    CFDictionaryRef v40 = ValueAtIndex;
    CFIndex v41 = v9;
    uint64_t v39 = (uint64_t)v13;
    if (*(void *)(v3 + 56)
      && (CFDictionaryGetValue(ValueAtIndex, @"MediaSelectionOptionsMediaType"),
          FigCFStringGetOSTypeValue())
      && (uint64_t v15 = CFDictionaryGetValue(ValueAtIndex, @"MediaSelectionOptionsPersistentID")) != 0)
    {
      uint64_t v16 = v15;
      CFTypeRef v17 = CFArrayCreateMutable(*(CFAllocatorRef *)(v3 + 16), 0, v10);
      if (v17)
      {
        uint64_t v18 = CFArrayCreateMutable(*(CFAllocatorRef *)(v3 + 16), 0, v10);
        if (v18)
        {
          if (v45 == 1935832172 || v45 == 1986618469 || v45 == 1936684398)
          {
            for (CFIndex j = 0; ; ++j)
            {
              CFArrayRef Count = *(const __CFArray **)(v3 + 56);
              if (Count) {
                CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
              }
              if (j >= (uint64_t)Count) {
                break;
              }
              uint64_t v21 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 56), j);
              if (!v21) {
                goto LABEL_43;
              }
              uint64_t v22 = (uint64_t)v21;
              CFDictionaryRef MediaGroupLocatorMap = (const __CFDictionary *)FigAlternateGetMediaGroupLocatorMap((uint64_t)v21, v45);
              if (!MediaGroupLocatorMap
                || (CFDictionaryRef v24 = (const __CFDictionary *)CFDictionaryGetValue(MediaGroupLocatorMap, v16)) == 0
                || (CFDictionaryRef v25 = v24,
                    CFURLRef PlaylistAlternateURL = (const __CFURL *)CFDictionaryGetValue(v24, @"FBPAEGLMK_URL"),
                    uint64_t StableStreamIdentifier = (uint64_t)CFDictionaryGetValue(v25, @"FBPAEGLMK_StableStreamIdentifier"), !PlaylistAlternateURL))
              {
                CFURLRef PlaylistAlternateURL = (const __CFURL *)FigAlternateGetPlaylistAlternateURL(v22);
                uint64_t StableStreamIdentifier = FigAlternateGetStableStreamIdentifier(v22);
                if (!PlaylistAlternateURL) {
                  continue;
                }
              }
              uint64_t v28 = (const void *)StableStreamIdentifier;
              CFTypeRef v29 = FigCFHTTPCreateURLString(PlaylistAlternateURL);
              if (!v29) {
                goto LABEL_43;
              }
              unint64_t v30 = v29;
              CFArrayAppendValue(v17, v29);
              CFRelease(v30);
              if (v28) {
                CFArrayAppendValue(v18, v28);
              }
            }
          }
LABEL_46:
          CFArrayRef v32 = (const __CFArray *)CFRetain(v17);
          CFArrayRef v33 = (const __CFArray *)CFRetain(v18);
          int v7 = 0;
          if (!v17) {
            goto LABEL_48;
          }
LABEL_47:
          CFRelease(v17);
          goto LABEL_48;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
    }
    else
    {
      CFTypeRef v17 = 0;
      uint64_t v18 = 0;
    }
LABEL_43:
    int v31 = FigSignalErrorAt();
    if (!v31) {
      goto LABEL_46;
    }
    int v7 = v31;
    CFArrayRef v32 = 0;
    CFArrayRef v33 = 0;
    if (v17) {
      goto LABEL_47;
    }
LABEL_48:
    if (v18) {
      CFRelease(v18);
    }
    if (v7 || (int v7 = sci_areAnyNetworkURLsOrStreamIDsCompletelyCached(v39, v32, v33, (unsigned char *)&v44 + 1)) != 0)
    {
      char v34 = 0;
      if (!v32) {
        goto LABEL_57;
      }
    }
    else
    {
      char v43 = 0;
      FigCFDictionaryGetBooleanIfPresent();
      if (v43) {
        char v34 = 1;
      }
      else {
        char v34 = HIBYTE(v44);
      }
      if (!v32) {
        goto LABEL_57;
      }
    }
    CFRelease(v32);
LABEL_57:
    if (v33) {
      CFRelease(v33);
    }
    if (v7) {
      goto LABEL_71;
    }
    BOOL v35 = v34 == 0;
    CFArrayRef Value = v38;
    CFIndex v9 = v41;
    uint64_t v10 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    if (!v35) {
      CFArrayAppendValue(theArray, v40);
    }
LABEL_62:
    ++v9;
    if (Value) {
      goto LABEL_13;
    }
LABEL_14:
    ;
  }
  int v7 = isPlayableOffline;
LABEL_71:
  uint64_t v1 = v36;
  CFArrayRef v6 = theArray;
LABEL_74:
  if (v6) {
    CFRelease(v6);
  }
  if (cf) {
    CFRelease(cf);
  }
  *((_DWORD *)v1 + 8) = v7;
}

uint64_t FigConvertCSSStyleSheetDataToTextMarkup(const __CFAllocator *a1, const __CFData *a2, __CFArray **a3, void *a4)
{
  BOOL v86 = 0;
  CFStringRef v87 = 0;
  CMTimeFlags v84 = 0;
  CFTypeRef v85 = 0;
  CFTypeRef v83 = 0;
  if (!a2)
  {
    uint64_t v54 = FigSignalErrorAt();
    goto LABEL_148;
  }
  if (!a3)
  {
    uint64_t v7 = FigSignalErrorAt();
LABEL_160:
    uint64_t v54 = v7;
    goto LABEL_146;
  }
  CFAllocatorRef v6 = a1;
  uint64_t v7 = FigTextContainerCreateWithCFData(a1, a2, 0x8000100u, 0, (uint64_t *)&v87);
  if (v7) {
    goto LABEL_160;
  }
  uint64_t v7 = FigCSSParserCreate((uint64_t)v6, v87, 0, &v86);
  if (v7) {
    goto LABEL_160;
  }
  uint64_t v7 = FigCSSParserProduceStyleSheet((uint64_t)v86, &v85);
  if (v7) {
    goto LABEL_160;
  }
  uint64_t v7 = FigCSSStyleSheetCopyRuleList((uint64_t)v85, &v83);
  if (v7) {
    goto LABEL_160;
  }
  uint64_t v66 = a3;
  uint64_t v67 = a4;
  CFIndex Length = FigCSSRuleListGetLength((uint64_t)v83);
  if (Length < 1)
  {
    long long v12 = 0;
    uint64_t v54 = 0;
    long long v11 = 0;
LABEL_142:
    *uint64_t v66 = v11;
    if (v67) {
      *uint64_t v67 = 0;
    }
    if (v12) {
      goto LABEL_145;
    }
    goto LABEL_146;
  }
  CFIndex v9 = Length;
  CFIndex v10 = 0;
  long long v11 = 0;
  long long v12 = 0;
  kedouble y = (void *)*MEMORY[0x1E4F1F810];
  double v58 = (const void *)*MEMORY[0x1E4F1F608];
  int v56 = (const void *)*MEMORY[0x1E4F1F5E0];
  double v59 = (const void *)*MEMORY[0x1E4F1F548];
  CFTypeRef v63 = (const void *)*MEMORY[0x1E4F1F718];
  uint64_t v75 = (__CFArray *)*MEMORY[0x1E4F1CFD0];
  uint64_t v79 = (__CFArray *)*MEMORY[0x1E4F1CFC8];
  CFArrayRef v60 = (__CFArray *)*MEMORY[0x1E4F1F8D0];
  int v61 = (__CFArray *)*MEMORY[0x1E4F1F8C8];
  CFTypeRef v62 = (__CFArray *)*MEMORY[0x1E4F1F8C0];
  uint64_t v64 = (__CFArray *)*MEMORY[0x1E4F1F8F0];
  CFArrayRef v72 = (const void *)*MEMORY[0x1E4F1F6D0];
  char v65 = (__CFArray *)*MEMORY[0x1E4F1F8F8];
  uint64_t v70 = (const void *)*MEMORY[0x1E4F1F6C0];
  CFArrayRef v71 = (__CFArray *)*MEMORY[0x1E4F1F900];
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  char v69 = (const void *)*MEMORY[0x1E4F1F618];
  uint64_t v74 = (const void *)*MEMORY[0x1E4F1F630];
  uint64_t v77 = (void *)*MEMORY[0x1E4F1F600];
  uint64_t v78 = (const void *)*MEMORY[0x1E4F1F558];
  CFIndex v57 = (const void *)*MEMORY[0x1E4F1F6B0];
  CFAllocatorRef alloc = v6;
  CFIndex v73 = Length;
  while (1)
  {
    int v82 = 0;
    uint64_t v13 = FigCSSRuleListCopyRuleAtIndex((uint64_t)v83, v10, (CFTypeRef *)&v84, &v82);
    if (v82 == 1) {
      break;
    }
    uint64_t v54 = v13;
LABEL_130:
    if (v84)
    {
      CFRelease(v84);
      CMTimeFlags v84 = 0;
    }
    if (++v10 == v9) {
      goto LABEL_142;
    }
  }
  if (v12) {
    CFRelease(v12);
  }
  long long v12 = (__CFDictionary *)v84;
  CFTypeRef v90 = 0;
  CFStringRef v91 = 0;
  CFStringRef v88 = 0;
  CFStringRef v89 = 0;
  if (!v84)
  {
    FigSignalErrorAt();
    CFMutableArrayRef Mutable = 0;
LABEL_137:
    CFTypeRef v17 = 0;
    goto LABEL_140;
  }
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    FigSignalErrorAt();
LABEL_136:
    long long v12 = 0;
    goto LABEL_137;
  }
  if (FigCSSStyleRuleCopySelector((uint64_t)v12, &v91) || !v91) {
    goto LABEL_136;
  }
  CFIndex v15 = CFStringGetLength(v91);
  Mutableuint64_t Copy = CFStringCreateMutableCopy(v6, v15, v91);
  CFTypeRef v17 = MutableCopy;
  if (!MutableCopy)
  {
    FigSignalErrorAt();
LABEL_139:
    long long v12 = 0;
LABEL_140:
    CFMutableStringRef v21 = 0;
    goto LABEL_111;
  }
  CFStringTrimWhitespace(MutableCopy);
  CFDictionarySetValue(Mutable, key, v17);
  if (FigCSSStyleRuleCopyDeclaration((uint64_t)v12, &v90)) {
    goto LABEL_139;
  }
  CFIndex v18 = FigCSSRuleListGetLength((uint64_t)v90);
  if (v18 < 1)
  {
    CFMutableStringRef v21 = 0;
    goto LABEL_110;
  }
  CFIndex v19 = v18;
  CGPoint v80 = v11;
  CFIndex v20 = 0;
  CFMutableStringRef v21 = 0;
  uint64_t v22 = 0;
  do
  {
    if (v89)
    {
      CFRelease(v89);
      CFStringRef v89 = 0;
    }
    if (v88)
    {
      CFRelease(v88);
      CFStringRef v88 = 0;
    }
    if (v21) {
      CFRelease(v21);
    }
    if (FigCSSStyleDeclarationCopyPropertyNameAtIndex((uint64_t)v90, v20, &v89)
      || FigCSSStyleDeclarationCopyPropertyValue((uint64_t)v90, v89, &v88))
    {
      CFMutableStringRef v21 = 0;
      goto LABEL_29;
    }
    CFStringRef v23 = v88;
    if (v88 && (v24 = CFGetTypeID(v88), TypeID = CFStringGetTypeID(), CFStringRef v23 = v88, v24 == TypeID))
    {
      CFIndex v26 = CFStringGetLength(v88);
      CFMutableStringRef v21 = CFStringCreateMutableCopy(alloc, v26, v88);
      CFStringTrimWhitespace(v21);
      CFStringRef v23 = v88;
    }
    else
    {
      CFMutableStringRef v21 = 0;
    }
    CFStringRef v27 = v89;
    if (v21) {
      CFStringRef v28 = v21;
    }
    else {
      CFStringRef v28 = v23;
    }
    uint64_t v92 = 0;
    if (CFStringCompare(@"color", v89, 1uLL) == kCFCompareEqualTo)
    {
      if (FigCSSParserUtilitiesParseColor(alloc, v28, &v92)) {
        goto LABEL_95;
      }
      unint64_t v30 = v92;
      CFTypeRef v29 = v77;
      goto LABEL_55;
    }
    if (CFStringCompare(@"font-weight", v27, 1uLL) == kCFCompareEqualTo)
    {
      CFComparisonResult v33 = CFStringCompare(@"normal", v28, 1uLL);
      CFTypeRef v29 = v78;
      unint64_t v30 = v79;
      if (v33 == kCFCompareEqualTo) {
        goto LABEL_55;
      }
      CFComparisonResult v34 = CFStringCompare(@"bold", v28, 1uLL);
      CFTypeRef v29 = v78;
      goto LABEL_62;
    }
    if (CFStringCompare(@"font-style", v27, 1uLL) == kCFCompareEqualTo)
    {
      CFComparisonResult v35 = CFStringCompare(@"normal", v28, 1uLL);
      CFTypeRef v29 = v74;
      unint64_t v30 = v79;
      if (v35 == kCFCompareEqualTo) {
        goto LABEL_55;
      }
      CFComparisonResult v34 = CFStringCompare(@"italic", v28, 1uLL);
      CFTypeRef v29 = v74;
      goto LABEL_62;
    }
    if (CFStringCompare(@"text-combine-upright", v27, 1uLL) == kCFCompareEqualTo)
    {
      if (CFStringCompare(v28, @"none", 1uLL) == kCFCompareEqualTo) {
        goto LABEL_95;
      }
      if (CFStringCompare(v28, @"all", 1uLL) == kCFCompareEqualTo
        || CFStringCompare(v28, @"digits", 1uLL) == kCFCompareEqualTo)
      {
        LODWORD(v94[0]) = -1;
        unint64_t v30 = CFNumberCreate(allocator, kCFNumberSInt32Type, v94);
        CFTypeRef v29 = v69;
        goto LABEL_55;
      }
      LODWORD(v94[0]) = 1;
      CFIndex v36 = CFStringGetLength(@"digits");
      v96.locatioCFIndex n = 0;
      v96.length = v36;
      if (CFStringCompareWithOptions(v28, @"digits", v96, 1uLL))
      {
        int v37 = FigCSSParseDigitsAsUInt32(v28, v94);
        CFArrayRef v38 = 0;
        if (!v37)
        {
LABEL_69:
          int valuePtr = v94[0];
          unint64_t v30 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
          int v31 = 0;
          if (!v38) {
            goto LABEL_91;
          }
          goto LABEL_90;
        }
      }
      else
      {
        CFAllocatorRef v48 = CFGetAllocator(v28);
        double v49 = CFStringCreateMutableCopy(v48, 0, v28);
        CFArrayRef v38 = v49;
        if (v49)
        {
          v95.locatioCFIndex n = 0;
          v95.length = v36;
          CFStringReplace(v49, v95, &stru_1EE53F4B8);
          CFIndex v50 = CFStringGetLength(v38);
          CFStringTrimWhitespace(v38);
          if (v50 > CFStringGetLength(v38))
          {
            int v51 = FigCSSParseDigitsAsUInt32(v38, v94);
            if (v51)
            {
              int v31 = v51;
              unint64_t v30 = 0;
              goto LABEL_90;
            }
            goto LABEL_69;
          }
        }
        int v37 = FigSignalErrorAt();
      }
      int v31 = v37;
      unint64_t v30 = 0;
      if (!v38)
      {
LABEL_91:
        CFTypeRef v29 = v69;
        if (v31) {
          goto LABEL_92;
        }
        goto LABEL_55;
      }
LABEL_90:
      CFRelease(v38);
      goto LABEL_91;
    }
    if (CFStringCompare(@"ruby-position", v27, 1uLL))
    {
      if (CFStringCompare(@"ruby-align", v27, 1uLL))
      {
        if (CFStringCompare(@"offset", v27, 1uLL) == kCFCompareEqualTo) {
          goto LABEL_95;
        }
        if (CFStringCompare(@"text-decoration", v27, 1uLL))
        {
          if (CFStringCompare(@"background-color", v27, 1uLL))
          {
            if (CFStringCompare(@"font-family", v27, 1uLL))
            {
              if (CFStringCompare(@"font-size", v27, 1uLL)) {
                goto LABEL_95;
              }
              v94[0] = *MEMORY[0x1E4F216B0];
              if (FigCSSParseFontSize(v28, (uint64_t *)v94)) {
                goto LABEL_95;
              }
              CFTypeRef v29 = 0;
              if ((BYTE12(v94[0]) & 0x1D) == 1)
              {
                unint64_t v30 = 0;
                if (DWORD2(v94[0]) == 622862368)
                {
                  int valuePtr = (int)*(double *)v94;
                  unint64_t v30 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
                  CFTypeRef v29 = v57;
                }
              }
              else
              {
                unint64_t v30 = 0;
              }
            }
            else
            {
              MEMORY[0x19970EE10](&convertFontFamilyFromCSSToCMTextMarkup_once, initMapFromCSSToCMTextMarkupFontFamily);
              CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)sMapFromCSSToCMTextMarkupFontFamily, v28);
              if (Value)
              {
                unint64_t v30 = (__CFArray *)CFRetain(Value);
                CFTypeRef v29 = v58;
              }
              else
              {
                if (CFStringGetLength(v28) < 1) {
                  goto LABEL_95;
                }
                unint64_t v30 = (__CFArray *)CFRetain(v28);
                CFTypeRef v29 = v56;
              }
            }
          }
          else
          {
            if (FigCSSParserUtilitiesParseColor(alloc, v28, &v92)) {
              goto LABEL_95;
            }
            unint64_t v30 = v92;
            CFTypeRef v29 = v59;
          }
          goto LABEL_55;
        }
        CFComparisonResult v47 = CFStringCompare(@"none", v28, 1uLL);
        CFTypeRef v29 = v63;
        unint64_t v30 = v79;
        if (v47 == kCFCompareEqualTo) {
          goto LABEL_55;
        }
        CFComparisonResult v34 = CFStringCompare(@"underline", v28, 1uLL);
        CFTypeRef v29 = v63;
LABEL_62:
        unint64_t v30 = v75;
        if (v34) {
          goto LABEL_95;
        }
        goto LABEL_55;
      }
      CFComparisonResult v43 = CFStringCompare(@"start", v28, 1uLL);
      CFTypeRef v29 = v70;
      unint64_t v30 = v64;
      if (v43)
      {
        CFComparisonResult v44 = CFStringCompare(@"center", v28, 1uLL);
        CFTypeRef v29 = v70;
        unint64_t v30 = v62;
        if (v44)
        {
          CFComparisonResult v45 = CFStringCompare(@"space-between", v28, 1uLL);
          CFTypeRef v29 = v70;
          unint64_t v30 = v61;
          if (v45)
          {
            CFComparisonResult v46 = CFStringCompare(@"space-around", v28, 1uLL);
            CFTypeRef v29 = v70;
            unint64_t v30 = v60;
            if (v46) {
              goto LABEL_95;
            }
          }
        }
      }
    }
    else
    {
      CFComparisonResult v39 = CFStringCompare(@"over", v28, 1uLL);
      unint64_t v30 = v71;
      CFTypeRef v29 = v72;
      if (v39)
      {
        CFComparisonResult v40 = CFStringCompare(@"right", v28, 1uLL);
        unint64_t v30 = v71;
        CFTypeRef v29 = v72;
        if (v40)
        {
          CFComparisonResult v41 = CFStringCompare(@"under", v28, 1uLL);
          CFTypeRef v29 = v72;
          unint64_t v30 = v65;
          if (v41)
          {
            CFComparisonResult v42 = CFStringCompare(@"left", v28, 1uLL);
            CFTypeRef v29 = v72;
            unint64_t v30 = v65;
            if (v42)
            {
LABEL_95:
              uint64_t v52 = 0;
              goto LABEL_96;
            }
          }
        }
      }
    }
LABEL_55:
    int v31 = 0;
    if (!v29 || !v30)
    {
LABEL_92:
      uint64_t v32 = 0;
      uint64_t v52 = 0;
      if (!v30) {
        goto LABEL_94;
      }
      goto LABEL_93;
    }
    CFDictionarySetValue(Mutable, v29, v30);
    int v31 = 0;
    uint64_t v32 = 1;
LABEL_93:
    CFRelease(v30);
    uint64_t v52 = v32;
LABEL_94:
    if (v31) {
      goto LABEL_95;
    }
LABEL_96:
    v22 += v52;
LABEL_29:
    ++v20;
  }
  while (v19 != v20);
  if (v22)
  {
    long long v12 = Mutable;
    CFMutableArrayRef Mutable = 0;
    long long v11 = v80;
    CFAllocatorRef v6 = alloc;
    CFIndex v9 = v73;
    goto LABEL_111;
  }
  long long v11 = v80;
  CFAllocatorRef v6 = alloc;
  CFIndex v9 = v73;
LABEL_110:
  CFRelease(Mutable);
  long long v12 = 0;
  CFMutableArrayRef Mutable = 0;
LABEL_111:
  if (v89) {
    CFRelease(v89);
  }
  if (v88) {
    CFRelease(v88);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v91) {
    CFRelease(v91);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v90) {
    CFRelease(v90);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (!v12)
  {
LABEL_129:
    uint64_t v54 = 0;
    goto LABEL_130;
  }
  if (v11 || (long long v11 = CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510])) != 0)
  {
    CFArrayAppendValue(v11, v12);
    goto LABEL_129;
  }
  uint64_t v54 = FigSignalErrorAt();
LABEL_145:
  CFRelease(v12);
LABEL_146:
  if (v83) {
    CFRelease(v83);
  }
LABEL_148:
  if (v84) {
    CFRelease(v84);
  }
  if (v85) {
    CFRelease(v85);
  }
  if (v86) {
    CFRelease(v86);
  }
  if (v87) {
    CFRelease(v87);
  }
  return v54;
}

uint64_t FigCSSParserUtilitiesParseColor(const __CFAllocator *a1, const __CFString *a2, __CFArray **a3)
{
  uint64_t v14 = 0;
  uint64_t valuePtr = 0;
  *a3 = 0;
  uint64_t v5 = FigCSSParseColor(a2, (float *)&valuePtr + 1, (float *)&valuePtr, (float *)&v14 + 1, (float *)&v14);
  CFAllocatorRef v6 = 0;
  CFNumberRef v7 = 0;
  CFNumberRef v8 = 0;
  CFNumberRef v9 = 0;
  CFNumberRef v10 = 0;
  if (v5)
  {
LABEL_4:
    *a3 = v6;
    if (!v10) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)&valuePtr + 4);
  CFNumberRef v8 = CFNumberCreate(v11, kCFNumberFloatType, &valuePtr);
  CFNumberRef v9 = CFNumberCreate(v11, kCFNumberFloatType, (char *)&v14 + 4);
  CFNumberRef v10 = CFNumberCreate(v11, kCFNumberFloatType, &v14);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFAllocatorRef v6 = Mutable;
    CFArrayAppendValue(Mutable, v10);
    CFArrayAppendValue(v6, v7);
    CFArrayAppendValue(v6, v8);
    CFArrayAppendValue(v6, v9);
    goto LABEL_4;
  }
  uint64_t v5 = FigSignalErrorAt();
  if (v10) {
LABEL_5:
  }
    CFRelease(v10);
LABEL_6:
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v9) {
    CFRelease(v9);
  }
  return v5;
}

void initMapFromCSSToCMTextMarkupFontFamily()
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(Mutable, @"default", (const void *)*MEMORY[0x1E4F1F7C0]);
  CFDictionaryAddValue(Mutable, @"serif", (const void *)*MEMORY[0x1E4F1F800]);
  CFDictionaryAddValue(Mutable, @"sans-serif", (const void *)*MEMORY[0x1E4F1F7F8]);
  CFDictionaryAddValue(Mutable, @"monospace", (const void *)*MEMORY[0x1E4F1F7D0]);
  CFDictionaryAddValue(Mutable, @"cursive", (const void *)*MEMORY[0x1E4F1F7B8]);
  CFDictionaryAddValue(Mutable, @"fantasy", (const void *)*MEMORY[0x1E4F1F7C8]);
  sMapFromCSSToCMTextMarkupFontFamildouble y = (uint64_t)Mutable;
}

uint64_t FigBufferedAirPlayAudioChainSubPipeTranscodeCreate(const __CFAllocator *a1, const void *a2, const void *a3, const void *a4, char a5, const void *a6, const __CFDictionary *a7, void *a8)
{
  uint64_t v195 = *MEMORY[0x1E4F143B8];
  xpc_object_t value = 0;
  FigNote_AllowInternalDefaultLogs();
  fig_note_initialize_category_with_default_work_cf();
  fig_note_initialize_category_with_default_work_cf();
  double v121 = a2;
  if (a2 && a3 && a4 && a8)
  {
    CFTypeRef v127 = a4;
    FigBufferedAirPlayAudioChainSubPipeGetClassID();
    CFAllocatorRef v13 = a1;
    uint64_t v14 = CMDerivedObjectCreate();
    if (v14) {
      return v14;
    }
    CFTypeRef v126 = a3;
    int v119 = a8;
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    *(unsigned char *)uint64_t DerivedStorage = 0;
    if (a7 && CFDictionaryGetValueIfPresent(a7, @"LoggingID", (const void **)&value)) {
      CFStringGetCString((CFStringRef)value, (char *)DerivedStorage, 20, 0x600u);
    }
    uint64_t v16 = FigSimpleMutexCreate();
    *(void *)(DerivedStorage + 24) = v16;
    if (!v16
      || (dispatch_queue_t v17 = dispatch_queue_create("com.apple.coremedia.bufferedAirPlayAudioChainTranscodeSubPipe.notificationQueue", 0), (*(void *)(DerivedStorage + 32) = v17) == 0))
    {
      CFNumberRef UInt32 = 0;
      goto LABEL_169;
    }
    uint64_t v123 = CMBaseObjectGetDerivedStorage();
    memset(&v130, 0, sizeof(v130));
    CMTimeMake(&v130, 2000, 1000);
    memset(&v129, 0, sizeof(v129));
    CMTimeMake(&v129, 10000, 1000);
    long long v118 = *MEMORY[0x1E4F1F9F8];
    *(_OWORD *)&time.xpc_object_t value = *MEMORY[0x1E4F1F9F8];
    CMTimeEpoch v117 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
    time.CMTimeEpoch epoch = v117;
    CFDictionaryRef v18 = CMTimeCopyAsDictionary(&time, a1);
    CMAudioFormatDescriptionRef formatDescriptionOut = 0;
    long long v134 = 0u;
    *(_OWORD *)CFTypeRef v133 = 0u;
    memset(&asbd, 0, sizeof(asbd));
    CFTypeRef cf = 0;
    Mutableuint64_t Copy = (__CFDictionary *)FigCFDictionaryCreateMutableCopy();
    CFIndex v20 = MutableCopy;
    if (!MutableCopy)
    {
      CFDictionaryRef v42 = 0;
      uint64_t v41 = 4294954443;
      goto LABEL_59;
    }
    CFDictionarySetValue(MutableCopy, @"BufferedAirPlayDecode", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionarySetValue(v20, @"PreparedQueueLowWaterLevel", v18);
    CFDictionarySetValue(v20, @"PreparedQueueHighWaterLevel", v18);
    if (a7)
    {
      CFMutableStringRef v21 = CFDictionaryGetValue(a7, @"DisallowMultiplePlayResources");
      if (v21) {
        CFDictionarySetValue(v20, @"DisallowMultiplePlayResources", v21);
      }
      uint64_t v22 = CFDictionaryGetValue(a7, @"AllowAudibleContent");
      if (v22) {
        CFDictionarySetValue(v20, @"AllowAudibleContent", v22);
      }
      CFStringRef v23 = CFDictionaryGetValue(a7, @"AllowAMRDecode");
      if (v23) {
        CFDictionarySetValue(v20, @"AllowAMRDecode", v23);
      }
      CFTypeID v24 = CFDictionaryGetValue(a7, @"AllowAtmosDecode");
      if (v24) {
        CFDictionarySetValue(v20, @"AllowAtmosDecode", v24);
      }
      CFDictionaryRef v25 = (const opaqueCMFormatDescription *)CFDictionaryGetValue(a7, @"FormatDescription");
      CMAudioFormatDescriptionRef formatDescriptionOut = v25;
      if (v25)
      {
        CFIndex v26 = v25;
        CFRetain(v25);
        CFDictionarySetValue(v20, @"FormatDescription", v26);
        FigCFDictionarySetValueFromKeyInDict();
        goto LABEL_33;
      }
      FigCFDictionarySetValueFromKeyInDict();
    }
    if (dword_1E9351330)
    {
      int valuePtr = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v28 = valuePtr;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0])) {
        unsigned int v29 = v28;
      }
      else {
        unsigned int v29 = v28 & 0xFFFFFFFE;
      }
      if (v29)
      {
        LODWORD(v191.value) = 136315650;
        *(CMTimeValue *)((char *)&v191.value + 4) = (CMTimeValue)"bapspTranscode_setupAudioRenderPipelineOptions";
        LOWORD(v191.flags) = 2048;
        *(void *)((char *)&v191.flags + 2) = 0;
        HIWORD(v191.epoch) = 2082;
        v192 = "";
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    asbd.mSamplefloat Rate = 44100.0;
    *(_OWORD *)&asbd.AudioFormatID mFormatID = xmmword_194998860;
    *(_OWORD *)&asbd.mBytesPerFrame = xmmword_194998870;
    uint64_t v30 = CMAudioFormatDescriptionCreate(a1, &asbd, 0, 0, 0, 0, 0, &formatDescriptionOut);
    if (v30) {
      goto LABEL_173;
    }
    CFDictionarySetValue(v20, @"FormatDescription", formatDescriptionOut);
LABEL_33:
    uint64_t RichestDecodableFormatAndChannelLayout = FigAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout();
    if (RichestDecodableFormatAndChannelLayout)
    {
      int v32 = *(_DWORD *)(RichestDecodableFormatAndChannelLayout + 8);
      if (v32 <= 1885547314)
      {
        if (v32 == 1667574579) {
          goto LABEL_41;
        }
        int v33 = 1700997939;
      }
      else
      {
        if (v32 == 1885547315 || v32 == 2053319475) {
          goto LABEL_41;
        }
        int v33 = 1902324531;
      }
      if (v32 != v33)
      {
LABEL_51:
        CFDictionarySetValue(v20, @"FormatDescription", v126);
        if (dword_1E9351330)
        {
          int valuePtr = 0;
          type[0] = OS_LOG_TYPE_DEFAULT;
          CFArrayRef v38 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v39 = valuePtr;
          if (os_log_type_enabled(v38, type[0])) {
            unsigned int v40 = v39;
          }
          else {
            unsigned int v40 = v39 & 0xFFFFFFFE;
          }
          if (v40)
          {
            LODWORD(v191.value) = 136315906;
            *(CMTimeValue *)((char *)&v191.value + 4) = (CMTimeValue)"bapspTranscode_setupAudioRenderPipelineOptions";
            LOWORD(v191.flags) = 2048;
            *(void *)((char *)&v191.flags + 2) = 0;
            HIWORD(v191.epoch) = 2082;
            v192 = "";
            __int16 v193 = 2112;
            CFTypeRef v194 = v126;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        uint64_t v41 = 0;
        CFDictionaryRef v42 = v20;
        CFIndex v20 = 0;
LABEL_59:
        if (formatDescriptionOut) {
          CFRelease(formatDescriptionOut);
        }
        if (v20) {
          CFRelease(v20);
        }
        if (cf) {
          CFRelease(cf);
        }
        if (v18) {
          CFRelease(v18);
        }
        CFComparisonResult v43 = (void *)(DerivedStorage + 112);
        if (!v41)
        {
          uint64_t v44 = FigAudioQueueRenderPipelineCreate(a1, v42, (void *)(DerivedStorage + 112));
          if (!v44)
          {
            uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(*v43);
            uint64_t v46 = *(void *)(CMBaseObjectGetVTable() + 8);
            if (v46) {
              uint64_t v47 = v46;
            }
            else {
              uint64_t v47 = 0;
            }
            CFAllocatorRef v48 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, uint64_t))(v47 + 48);
            if (!v48)
            {
              uint64_t v41 = 4294954514;
              if (!v42)
              {
LABEL_78:
                if (v41) {
                  goto LABEL_182;
                }
                uint64_t v50 = *v43;
                uint64_t v51 = *(void *)(CMBaseObjectGetVTable() + 16);
                if (v51) {
                  uint64_t v52 = v51;
                }
                else {
                  uint64_t v52 = 0;
                }
                CFArrayRef v53 = *(uint64_t (**)(uint64_t, uint64_t))(v52 + 64);
                if (!v53)
                {
                  CFNumberRef UInt32 = 0;
                  uint64_t v41 = 4294954514;
                  goto LABEL_97;
                }
                uint64_t v54 = v53(v50, 1);
                if (v54
                  || (uint64_t v54 = FigSampleBufferConsumerCreateForSampleBufferConsumer("bapspTranscode_SampleBufferConsumerFromMixer", (void *)(DerivedStorage + 96)), v54))
                {
                  uint64_t v41 = v54;
                  goto LABEL_182;
                }
                CFTypeRef v55 = *(const void **)(DerivedStorage + 96);
                v133[0] = 0;
                v130.xpc_object_t value = 0;
                v129.xpc_object_t value = 0;
                memset(&asbd, 0, 32);
                LODWORD(formatDescriptionOut) = 0;
                LODWORD(cf) = 0;
                CFPreferenceNumberWithuint64_t Default = FigGetCFPreferenceNumberWithDefault();
                int valuePtr = 0x8000;
                *(_DWORD *)os_log_type_t type = 0;
                int v138 = -1;
                CFIndex v57 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
                if (v55
                  && (int v58 = CFPreferenceNumberWithDefault,
                      *(void *)(DerivedStorage + 104) = 0,
                      (uint64_t v59 = FigAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout()) != 0)
                  && (uint64_t v60 = v59, v124 = v55, v116 = v58, (v61 = FigEndpointStreamAudioFormatDescriptionGetASBD()) != 0))
                {
                  uint64_t v62 = v61;
                  int ChannelLayoutTag = FigEndpointStreamAudioFormatDescriptionGetChannelLayoutTag();
                  LODWORD(asbd.mSampleRate) = ChannelLayoutTag;
                  if (dword_1E9351330)
                  {
                    int v64 = ChannelLayoutTag;
                    unsigned int v137 = 0;
                    os_log_type_t v136 = OS_LOG_TYPE_DEFAULT;
                    char v65 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                    unsigned int v66 = v137;
                    if (os_log_type_enabled(v65, v136)) {
                      unsigned int v67 = v66;
                    }
                    else {
                      unsigned int v67 = v66 & 0xFFFFFFFE;
                    }
                    if (v67)
                    {
                      uint64_t v69 = *(void *)v60;
                      uint64_t v70 = *(void *)v62;
                      int v72 = *(_DWORD *)(v60 + 16);
                      int v71 = *(_DWORD *)(v60 + 20);
                      int v74 = *(_DWORD *)(v62 + 16);
                      int v73 = *(_DWORD *)(v62 + 20);
                      int v75 = *(_DWORD *)(v60 + 24);
                      int v76 = *(_DWORD *)(v60 + 28);
                      int v77 = *(_DWORD *)(v62 + 24);
                      int v78 = *(_DWORD *)(v62 + 28);
                      unsigned int v79 = *(_DWORD *)(v60 + 8);
                      int v80 = *(_DWORD *)(v60 + 12);
                      unsigned int v82 = *(_DWORD *)(v62 + 8);
                      int v81 = *(_DWORD *)(v62 + 12);
                      unsigned int v83 = HIBYTE(v82);
                      int v84 = *(_DWORD *)(v60 + 32);
                      int v85 = *(_DWORD *)(v62 + 32);
                      int v113 = BYTE2(v82);
                      int v114 = BYTE1(v82);
                      int v115 = v82;
                      int v86 = v129.value;
                      if (v129.value) {
                        int v86 = *(_DWORD *)v129.value;
                      }
                      LODWORD(time.value) = 136321794;
                      *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"bapspTranscode_createMixer";
                      LOWORD(time.flags) = 2048;
                      *(void *)((char *)&time.flags + 2) = 0;
                      HIWORD(time.epoch) = 2082;
                      double v142 = "";
                      __int16 v143 = 2048;
                      uint64_t v144 = v69;
                      __int16 v145 = 2048;
                      uint64_t v146 = v70;
                      __int16 v147 = 1024;
                      int v148 = v76;
                      __int16 v149 = 1024;
                      int v150 = v78;
                      __int16 v151 = 1024;
                      int v152 = v72;
                      __int16 v153 = 1024;
                      int v154 = v74;
                      __int16 v155 = 1024;
                      int v156 = v71;
                      __int16 v157 = 1024;
                      int v158 = v73;
                      __int16 v159 = 1024;
                      int v160 = v75;
                      __int16 v161 = 1024;
                      int v162 = v77;
                      __int16 v163 = 1024;
                      int v164 = v84;
                      __int16 v165 = 1024;
                      int v166 = v85;
                      __int16 v167 = 1024;
                      int v168 = v80;
                      __int16 v169 = 1024;
                      int v170 = v81;
                      __int16 v171 = 1024;
                      unsigned int v172 = HIBYTE(v79);
                      __int16 v173 = 1024;
                      int v174 = BYTE2(v79);
                      __int16 v175 = 1024;
                      int v176 = BYTE1(v79);
                      __int16 v177 = 1024;
                      int v178 = v79;
                      __int16 v179 = 1024;
                      unsigned int v180 = v83;
                      __int16 v181 = 1024;
                      int v182 = v113;
                      __int16 v183 = 1024;
                      int v184 = v114;
                      __int16 v185 = 1024;
                      int v186 = v115;
                      __int16 v187 = 1024;
                      int v188 = v86;
                      __int16 v189 = 1024;
                      int v190 = v64;
                      _os_log_send_and_compose_impl();
                      CFIndex v57 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
                    }
                    fig_log_call_emit_and_clean_up_after_send_and_compose();
                  }
                  uint64_t v87 = FigActivitySchedulerCreateForNewThread((uint64_t)v13, 36, @"com.apple.coremedia.BAPSubPipeTranscode.mixer", &v130);
                  if (!v87)
                  {
                    CFAllocatorRef v88 = *v57;
                    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(*v57, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                    if (Mutable)
                    {
                      CFDictionaryRef v90 = Mutable;
                      CFNumberRef v91 = CFNumberCreate(v88, kCFNumberIntType, &valuePtr);
                      if (v91)
                      {
                        CFNumberRef v92 = v91;
                        FigCFDictionarySetValue();
                        int v93 = *(_DWORD *)(v62 + 8);
                        if (v93 != 1634754915 && v93 != 1902211171 && v93 != 1667330147)
                        {
LABEL_113:
                          FigCFDictionarySetValueFromKeyInDict();
                          uint64_t v97 = FigAudioQueueOfflineMixerCreate(v13, (long long *)v62, 0xCuLL, (const AudioChannelLayout *)&asbd, v90, v124, (const void *)v130.value, (uint64_t *)v133);
                          if (v97)
                          {
                            uint64_t v41 = v97;
                            double v100 = a6;
                            goto LABEL_142;
                          }
                          CFRelease(v92);
                          if (*(_DWORD *)(v62 + 28) >= 3u) {
                            int v98 = 32;
                          }
                          else {
                            int v98 = 64;
                          }
                          LODWORD(formatDescriptionOut) = v98;
                          CFNumberRef v99 = CFNumberCreate(v88, kCFNumberIntType, &formatDescriptionOut);
                          double v100 = a6;
                          if (v99)
                          {
                            CFNumberRef v92 = v99;
                            uint64_t v101 = FigAudioQueueOfflineMixerSetProperty((uint64_t)v133[0], @"AudioQueueOfflineMixer_CodecQuality", v99);
                            if (v101)
                            {
LABEL_180:
                              uint64_t v41 = v101;
LABEL_142:
                              CFRelease(v92);
LABEL_143:
                              CFRelease(v90);
                              goto LABEL_144;
                            }
                            int v102 = *(_DWORD *)(v62 + 8);
                            if (v102 > 1902928226)
                            {
                              if (v102 == 1902928227) {
                                goto LABEL_140;
                              }
                              int v103 = 2053923171;
                            }
                            else
                            {
                              if (v102 == 1634492771) {
                                goto LABEL_140;
                              }
                              int v103 = 1668047203;
                            }
                            if (v102 == v103)
                            {
LABEL_140:
                              uint64_t v41 = FigAudioQueueOfflineMixerSetProperty((uint64_t)v133[0], @"AudioQueueOfflineMixer_SampleBufferAllocator", a6);
                              if (!v41)
                              {
                                *(CFTypeRef *)(DerivedStorage + 104) = v133[0];
                                v133[0] = 0;
                              }
                              goto LABEL_142;
                            }
                            CFRelease(v92);
                            int v104 = *(_DWORD *)(v62 + 8);
                            if (v104 == 1634754915 || v104 == 1902211171 || v104 == 1667330147)
                            {
                              switch(*(_DWORD *)(v62 + 28))
                              {
                                case 6:
                                  int v105 = 512000;
                                  break;
                                case 8:
                                case 0xA:
                                  int v105 = 768000;
                                  break;
                                case 0xC:
                                  int v105 = 896000;
                                  break;
                                default:
                                  int v105 = 256000;
                                  break;
                              }
                            }
                            else if (*(_DWORD *)(v62 + 28) <= 2u)
                            {
                              int v105 = 256000;
                            }
                            else
                            {
                              int v105 = 512000;
                            }
                            LODWORD(cf) = v105;
                            if (v116) {
                              LODWORD(cf) = v116;
                            }
                            CFNumberRef v106 = CFNumberCreate(v88, kCFNumberIntType, &cf);
                            if (v106)
                            {
                              CFNumberRef v92 = v106;
                              uint64_t v101 = FigAudioQueueOfflineMixerSetProperty((uint64_t)v133[0], @"AudioQueueOfflineMixer_BitRateForVBR", v106);
                              if (!v101) {
                                goto LABEL_140;
                              }
                              goto LABEL_180;
                            }
                          }
                          uint64_t v41 = FigSignalErrorAt();
                          goto LABEL_143;
                        }
                        CFRelease(v92);
                        CFNumberRef v94 = CFNumberCreate(v88, kCFNumberIntType, type);
                        if (v94)
                        {
                          CFNumberRef v95 = v94;
                          FigCFDictionarySetValue();
                          CFRelease(v95);
                          CFNumberRef v96 = CFNumberCreate(v88, kCFNumberIntType, &v138);
                          if (v96)
                          {
                            CFNumberRef v92 = v96;
                            FigCFDictionarySetValue();
                            goto LABEL_113;
                          }
                        }
                      }
                      uint64_t v41 = FigSignalErrorAt();
                      double v100 = a6;
                      goto LABEL_143;
                    }
                    uint64_t v41 = 4294954443;
LABEL_185:
                    double v100 = a6;
LABEL_144:
                    if (v133[0]) {
                      CFRelease(v133[0]);
                    }
                    if (v130.value) {
                      CFRelease((CFTypeRef)v130.value);
                    }
                    if (!v41)
                    {
                      CFNumberRef UInt32 = (const __CFNumber *)FigCFNumberCreateUInt32();
                      if (UInt32)
                      {
                        bapspTranscode_setThreadPriorities(0, UInt32);
                        uint64_t v107 = FigSampleBufferConsumerSbufInspectorCreate((uint64_t)v13, *(const void **)(DerivedStorage + 64), (uint64_t)bapspTranscode_inspectSampleBuffer, 0, "sbcSbufInspectForTranscode", (void *)(DerivedStorage + 72));
                        if (!v107)
                        {
                          uint64_t v107 = FigSampleBufferConsumerOPTSAutoOrderCreate(v13, v121, "TranscodeOPTSAutoOrder", (void *)(DerivedStorage + 80));
                          if (!v107)
                          {
                            *(unsigned char *)(DerivedStorage + 128) = a5;
                            *(void *)(DerivedStorage + 48) = CFRetain(v127);
                            if (v100) {
                              CFTypeRef v108 = CFRetain(v100);
                            }
                            else {
                              CFTypeRef v108 = 0;
                            }
                            *(void *)(DerivedStorage + 56) = v108;
                            *(unsigned char *)(DerivedStorage + 168) = 0;
                            *(_DWORD *)(DerivedStorage + 40) = 0;
                            *(void *)(DerivedStorage + 136) = CFRetain(v126);
                            *(_OWORD *)(DerivedStorage + 144) = v118;
                            *(void *)(DerivedStorage + 160) = v117;
                            if (dword_1E9351330)
                            {
                              LODWORD(asbd.mSampleRate) = 0;
                              LOBYTE(v133[0]) = 0;
                              long long v109 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                              unsigned int mSampleRate_low = LODWORD(asbd.mSampleRate);
                              if (os_log_type_enabled(v109, (os_log_type_t)v133[0])) {
                                unsigned int v111 = mSampleRate_low;
                              }
                              else {
                                unsigned int v111 = mSampleRate_low & 0xFFFFFFFE;
                              }
                              if (v111)
                              {
                                LODWORD(v191.value) = 136315650;
                                *(CMTimeValue *)((char *)&v191.value + 4) = (CMTimeValue)"FigBufferedAirPlayAudioChainSub"
                                                                                         "PipeTranscodeCreate";
                                LOWORD(v191.flags) = 2048;
                                *(void *)((char *)&v191.flags + 2) = 0;
                                HIWORD(v191.epoch) = 2082;
                                v192 = "";
                                _os_log_send_and_compose_impl();
                              }
                              fig_log_call_emit_and_clean_up_after_send_and_compose();
                            }
                            uint64_t v41 = 0;
                            *int v119 = 0;
LABEL_163:
                            CFRelease(UInt32);
                            return v41;
                          }
                        }
                        uint64_t v41 = v107;
LABEL_97:
                        if (!UInt32) {
                          return v41;
                        }
                        goto LABEL_163;
                      }
LABEL_169:
                      uint64_t v41 = 4294954510;
                      goto LABEL_97;
                    }
LABEL_182:
                    CFNumberRef UInt32 = 0;
                    goto LABEL_97;
                  }
                }
                else
                {
                  uint64_t v87 = FigSignalErrorAt();
                }
                uint64_t v41 = v87;
                goto LABEL_185;
              }
LABEL_77:
              CFRelease(v42);
              goto LABEL_78;
            }
            uint64_t v44 = v48(FigBaseObject, @"SourceSampleBufferQueue", a1, v123 + 88);
            if (!v44)
            {
              uint64_t v49 = *(void *)(v123 + 88);
              CMTime time = v129;
              CMTime v191 = v130;
              uint64_t v44 = FigSampleBufferConsumerCreateForBufferQueue(v49, (long long *)&time.value, (long long *)&v191.value, (void *)(v123 + 64));
            }
          }
          uint64_t v41 = v44;
        }
        if (!v42) {
          goto LABEL_78;
        }
        goto LABEL_77;
      }
LABEL_41:
      if (FigEndpointStreamAudioFormatDescriptionGetASBD())
      {
        LODWORD(v133[0]) = FigEndpointStreamAudioFormatDescriptionGetChannelLayoutTag();
        uint64_t v34 = FigAudioRenderingPreferencesCreate();
        if (!v34)
        {
          if (dword_1E9351330)
          {
            int valuePtr = 0;
            type[0] = OS_LOG_TYPE_DEFAULT;
            CFComparisonResult v35 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v36 = valuePtr;
            if (os_log_type_enabled(v35, type[0])) {
              unsigned int v37 = v36;
            }
            else {
              unsigned int v37 = v36 & 0xFFFFFFFE;
            }
            if (v37)
            {
              LODWORD(v191.value) = 136315906;
              *(CMTimeValue *)((char *)&v191.value + 4) = (CMTimeValue)"bapspTranscode_setupAudioRenderPipelineOptions";
              LOWORD(v191.flags) = 2048;
              *(void *)((char *)&v191.flags + 2) = 0;
              HIWORD(v191.epoch) = 2082;
              v192 = "";
              __int16 v193 = 2112;
              CFTypeRef v194 = cf;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          CFDictionarySetValue(v20, @"AudioRenderingPreferences", cf);
          goto LABEL_51;
        }
      }
      else
      {
        uint64_t v34 = FigSignalErrorAt();
      }
      uint64_t v41 = v34;
      CFDictionaryRef v42 = 0;
      goto LABEL_59;
    }
    uint64_t v30 = FigSignalErrorAt();
LABEL_173:
    uint64_t v41 = v30;
    CFDictionaryRef v42 = 0;
    goto LABEL_59;
  }

  return FigSignalErrorAt();
}

uint64_t bapspTranscode_setThreadPriorities(uint64_t a1, const __CFNumber *a2)
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  int valuePtr = 0;
  if (a2)
  {
    uint64_t v4 = result;
    uint64_t result = CFNumberGetValue(a2, kCFNumberSInt32Type, &valuePtr);
    switch(valuePtr)
    {
      case '$':
        uint64_t v5 = kFigAudioRenderPipelineOfflineRenderPriority_BufferedAirPlayUrgent;
        break;
      case '+':
        uint64_t v5 = kFigAudioRenderPipelineOfflineRenderPriority_BufferedAirPlayRelaxed;
        break;
      case '%':
        uint64_t v5 = kFigAudioRenderPipelineOfflineRenderPriority_BufferedAirPlayDefault;
        break;
      default:
        return result;
    }
    uint64_t v6 = *(void *)(v4 + 112);
    if (v6)
    {
      CFNumberRef v7 = *v5;
      uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v6);
      uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v9) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = 0;
      }
      CFAllocatorRef v11 = *(void (**)(uint64_t, __CFString *, __CFString *))(v10 + 56);
      if (v11) {
        v11(FigBaseObject, @"OfflineRenderPriority", v7);
      }
    }
    uint64_t result = *(void *)(v4 + 104);
    if (result) {
      return FigAudioQueueOfflineMixerSetProperty(result, @"AudioQueueOfflineMixer_ThreadPriority", a2);
    }
  }
  return result;
}

uint64_t bapspTranscode_inspectSampleBuffer(opaqueCMSampleBuffer *a1, uint64_t a2)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a1) {
    return 1;
  }
  uint64_t v5 = (CMTime *)DerivedStorage;
  uint64_t v6 = CMBaseObjectGetDerivedStorage();
  target.CMTimeValue value = 0;
  CMFormatDescriptionRef FormatDescription = CMSampleBufferGetFormatDescription(a1);
  CFNumberRef v8 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
  uint64_t v9 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
  if (FormatDescription)
  {
    uint64_t v10 = *(const opaqueCMFormatDescription **)(v6 + 136);
    if (!v10 || !CMAudioFormatDescriptionEqual(FormatDescription, v10, 0xFu, 0) || !*(unsigned char *)(v6 + 168))
    {
      CFAllocatorRef v11 = *v8;
      CMFormatDescriptionRef v12 = CMSampleBufferGetFormatDescription(a1);
      CMSampleBufferGetOutputPresentationTimeStamp(&v54, a1);
      if (!FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker(v11, @"InputContentFormatDesc", v12, (long long *)&v54.value, &target))
      {
        CMSetAttachment((CMAttachmentBearerRef)target.value, @"SBUFForAutoOrder", *v9, 0);
        uint64_t v13 = *(void *)(v6 + 80);
        CMTimeValue value = target.value;
        uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v16 = v15 ? v15 : 0;
        dispatch_queue_t v17 = *(unsigned int (**)(uint64_t, CMTimeValue))(v16 + 8);
        if (v17)
        {
          if (!v17(v13, value)) {
            *(unsigned char *)(v6 + 168) = 1;
          }
        }
      }
    }
    if (target.value) {
      CFRelease((CFTypeRef)target.value);
    }
  }
  uint64_t v18 = CMBaseObjectGetDerivedStorage();
  target.CMTimeValue value = 0;
  CFTypeRef v19 = CMGetAttachment(a1, @"SbufTracer", 0);
  if (!v19)
  {
    int v27 = 0;
    goto LABEL_25;
  }
  CFIndex v20 = v19;
  CFAllocatorRef v21 = *v8;
  CMSampleBufferGetOutputPresentationTimeStamp(&v54, a1);
  int v22 = FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker(v21, @"SbufTracer", v20, (long long *)&v54.value, &target);
  if (v22) {
    goto LABEL_23;
  }
  CMSetAttachment((CMAttachmentBearerRef)target.value, @"SBUFForAutoOrder", *v9, 0);
  uint64_t v23 = *(void *)(v18 + 80);
  CMTimeValue v24 = target.value;
  uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v25) {
    uint64_t v26 = v25;
  }
  else {
    uint64_t v26 = 0;
  }
  unsigned int v28 = *(uint64_t (**)(uint64_t, CMTimeValue))(v26 + 8);
  if (v28)
  {
    int v22 = v28(v23, v24);
LABEL_23:
    int v27 = v22;
    goto LABEL_25;
  }
  int v27 = -12782;
LABEL_25:
  if (target.value) {
    CFRelease((CFTypeRef)target.value);
  }
  if (!v27)
  {
    unsigned int v29 = (CMTime *)CMBaseObjectGetDerivedStorage();
    CFStringRef v30 = (const __CFString *)*MEMORY[0x1E4F21A20];
    CFTypeRef v31 = CMGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F21A20], 0);
    if (v31)
    {
      CMTime v54 = v29[6];
      if (bapspTranscode_setLoudnessInfo(a2, v31, (uint64_t)&v54)) {
        return 1;
      }
      CMRemoveAttachment(a1, v30);
    }
    uint64_t v32 = CMBaseObjectGetDerivedStorage();
    CMAttachmentBearerRef cf = 0;
    CFStringRef v33 = (const __CFString *)*MEMORY[0x1E4F21A28];
    if (!CMGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F21A28], 0))
    {
      int v44 = 0;
      goto LABEL_45;
    }
    CMSampleBufferGetOutputPresentationTimeStamp(&v54, a1);
    CMTimeValue v58 = v54.value;
    CMTimeFlags flags = v54.flags;
    CMTimeScale timescale = v54.timescale;
    if (v54.flags)
    {
      CMTimeEpoch epoch = v54.epoch;
    }
    else
    {
      CMTimeValue v58 = *(void *)(v32 + 144);
      CMTimeFlags flags = *(_DWORD *)(v32 + 156);
      CMTimeScale timescale = *(_DWORD *)(v32 + 152);
      CMTimeEpoch epoch = *(void *)(v32 + 160);
    }
    CMSampleBufferGetOutputDuration(&v54, a1);
    CMTimeValue v56 = v54.value;
    CMTimeScale v57 = v54.timescale;
    if (v54.flags)
    {
      v52.CMTimeEpoch epoch = v54.epoch;
      target.CMTimeValue value = v58;
      target.CMTimeScale timescale = timescale;
      target.CMTimeFlags flags = flags;
      target.CMTimeEpoch epoch = epoch;
      v52.CMTimeValue value = v56;
      v52.CMTimeScale timescale = v57;
      v52.CMTimeFlags flags = v54.flags;
      CMTimeAdd(&v54, &target, &v52);
      CMTimeValue v58 = v54.value;
      CMTimeFlags flags = v54.flags;
      CMTimeScale timescale = v54.timescale;
      CMTimeEpoch epoch = v54.epoch;
    }
    CMRemoveAttachment(a1, v33);
    CFAllocatorRef v36 = *v8;
    CFTypeRef v37 = *v9;
    v54.CMTimeValue value = v58;
    v54.CMTimeScale timescale = timescale;
    v54.CMTimeFlags flags = flags;
    v54.CMTimeEpoch epoch = epoch;
    int v38 = FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker(v36, v33, v37, (long long *)&v54.value, &cf);
    if (!v38)
    {
      CMSetAttachment(cf, @"SBUFForAutoOrder", v37, 0);
      uint64_t v39 = *(void *)(v32 + 80);
      CMAttachmentBearerRef v40 = cf;
      uint64_t v41 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v41) {
        uint64_t v42 = v41;
      }
      else {
        uint64_t v42 = 0;
      }
      CFComparisonResult v43 = *(uint64_t (**)(uint64_t, CMAttachmentBearerRef))(v42 + 8);
      if (!v43)
      {
        int v44 = -12782;
        goto LABEL_45;
      }
      int v38 = v43(v39, v40);
      if (!v38)
      {
        MEMORY[0x19970E910](*(void *)(v32 + 24));
        int v44 = bapspTranscode_terminateQueueWithEndMarker();
        MEMORY[0x19970E930](*(void *)(v32 + 24));
LABEL_45:
        if (cf) {
          CFRelease(cf);
        }
        if (!v44)
        {
          CFComparisonResult v45 = CMSampleBufferGetFormatDescription(a1);
          if (v45)
          {
            uint64_t v46 = v45;
            uint64_t v47 = (const opaqueCMFormatDescription *)v5[5].epoch;
            if (v47)
            {
              if (!CMAudioFormatDescriptionEqual(v45, v47, 0xFu, 0))
              {
                CFAllocatorRef v48 = (const void *)v5[5].epoch;
                v5[5].CMTimeEpoch epoch = (CMTimeEpoch)v46;
                CFRetain(v46);
                if (v48) {
                  CFRelease(v48);
                }
              }
            }
            else
            {
              v5[5].CMTimeEpoch epoch = (CMTimeEpoch)v45;
              CFRetain(v45);
            }
          }
          CMSampleBufferGetOutputDuration(&v54, a1);
          CMTimeValue v56 = v54.value;
          CMTimeFlags v49 = v54.flags;
          CMTimeScale v57 = v54.timescale;
          CMTimeEpoch v50 = v54.epoch;
          CMSampleBufferGetOutputPresentationTimeStamp(&v54, a1);
          CMTimeValue v58 = v54.value;
          CMTimeScale timescale = v54.timescale;
          if (v54.flags)
          {
            v52.CMTimeEpoch epoch = v50;
            target.CMTimeValue value = v58;
            target.CMTimeScale timescale = timescale;
            target.CMTimeFlags flags = v54.flags;
            target.CMTimeEpoch epoch = v54.epoch;
            v52.CMTimeValue value = v56;
            v52.CMTimeScale timescale = v57;
            v52.CMTimeFlags flags = v49;
            CMTimeAdd(&v54, &target, &v52);
            void v5[6] = v54;
          }
        }
        return 1;
      }
    }
    int v44 = v38;
    goto LABEL_45;
  }
  return 1;
}

uint64_t bapspTranscode_invalidate(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!*(unsigned char *)(DerivedStorage + 42))
  {
    uint64_t v3 = DerivedStorage;
    bapspTranscode_breakAudioChain(a1);
    MEMORY[0x19970E910](*(void *)(v3 + 24));
    *(unsigned char *)(v3 + 42) = 1;
    FigAudioQueueOfflineMixerInvalidate(*(void *)(v3 + 104));
    uint64_t v4 = *(const void **)(v3 + 136);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(v3 + 136) = 0;
    }
    uint64_t v5 = *(const void **)(v3 + 48);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(v3 + 48) = 0;
    }
    uint64_t v6 = *(const void **)(v3 + 56);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(v3 + 56) = 0;
    }
    CFNumberRef v7 = *(const void **)(v3 + 64);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(v3 + 64) = 0;
    }
    CFNumberRef v8 = *(const void **)(v3 + 88);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(v3 + 88) = 0;
    }
    uint64_t v9 = *(const void **)(v3 + 72);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(v3 + 72) = 0;
    }
    uint64_t v10 = *(const void **)(v3 + 80);
    if (v10)
    {
      CFRelease(v10);
      *(void *)(v3 + 80) = 0;
    }
    CFAllocatorRef v11 = *(const void **)(v3 + 96);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(v3 + 96) = 0;
    }
    CMFormatDescriptionRef v12 = *(const void **)(v3 + 112);
    if (v12)
    {
      CFRelease(v12);
      *(void *)(v3 + 112) = 0;
    }
    uint64_t v13 = *(const void **)(v3 + 104);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(v3 + 104) = 0;
    }
    uint64_t v14 = *(const void **)(v3 + 120);
    if (v14)
    {
      CFRelease(v14);
      *(void *)(v3 + 120) = 0;
    }
    MEMORY[0x19970E930](*(void *)(v3 + 24));
  }
  return 0;
}

uint64_t bapspTranscode_finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  bapspTranscode_invalidate(a1);
  uint64_t v3 = *(NSObject **)(DerivedStorage + 32);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(DerivedStorage + 32) = 0;
  }
  uint64_t result = FigSimpleMutexDestroy();
  *(void *)(DerivedStorage + 24) = 0;
  return result;
}

__CFString *bapspTranscode_copyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigBufferedAirPlayAudioChainSubPipet %p>", a1);
  return Mutable;
}

uint64_t bapspTranscode_copyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 42)) {
    return 0;
  }
  uint64_t v8 = DerivedStorage;
  if (CFEqual(a2, @"SourceSampleBufferConsumer"))
  {
    uint64_t v9 = *(const void **)(v8 + 72);
    if (v9)
    {
LABEL_4:
      CFTypeRef v10 = CFRetain(v9);
LABEL_10:
      uint64_t result = 0;
      *a4 = v10;
      return result;
    }
LABEL_9:
    CFTypeRef v10 = 0;
    goto LABEL_10;
  }
  if (CFEqual(a2, @"IsStarted"))
  {
    CFAllocatorRef v11 = (const void **)MEMORY[0x1E4F1CFD0];
    if (!*(unsigned char *)(v8 + 41)) {
      CFAllocatorRef v11 = (const void **)MEMORY[0x1E4F1CFC8];
    }
LABEL_8:
    uint64_t v9 = *v11;
    if (*v11) {
      goto LABEL_4;
    }
    goto LABEL_9;
  }
  if (CFEqual(a2, @"CurrentFormatDescription"))
  {
    uint64_t v9 = *(const void **)(v8 + 136);
    if (v9) {
      goto LABEL_4;
    }
    goto LABEL_9;
  }
  if (CFEqual(a2, @"SubPipeType"))
  {
    CFAllocatorRef v11 = (const void **)kFigBufferedAirPlayAudioChainSubPipeSubPipeType_Transcode;
    goto LABEL_8;
  }
  uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(*(void *)(v8 + 112));
  uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *(uint64_t (**)(uint64_t, const void *, uint64_t, void *))(v15 + 48);
  if (!v16) {
    return 4294954514;
  }

  return v16(FigBaseObject, a2, a3, a4);
}

uint64_t bapspTranscode_setProperty(uint64_t a1, __CFString *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 42)) {
    return 0;
  }
  uint64_t v7 = DerivedStorage;
  if (CFEqual(@"LoudnessInfo", a2))
  {
    if (!a3 || (CFTypeID v8 = CFGetTypeID(a3), v8 == CFDictionaryGetTypeID()))
    {
      uint64_t v9 = MEMORY[0x1E4F1F9F8];
      return bapspTranscode_setLoudnessInfo(a1, a3, v9);
    }
    goto LABEL_18;
  }
  if (!CFEqual(@"AudioProcessingTap", a2))
  {
    if (!CFEqual(@"ThreadPriority", a2))
    {
      uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(*(void *)(v7 + 112));
      uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v20) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v16 = *(uint64_t (**)(uint64_t, __CFString *, const void *))(v21 + 56);
      if (v16)
      {
        uint64_t v18 = FigBaseObject;
        dispatch_queue_t v17 = a2;
        goto LABEL_29;
      }
      return 4294954514;
    }
    if (!a3 || (CFTypeID v15 = CFGetTypeID(a3), v15 != CFNumberGetTypeID()))
    {
LABEL_18:
      return FigSignalErrorAt();
    }
    bapspTranscode_setThreadPriorities(a1, (const __CFNumber *)a3);
    return 0;
  }
  if (a3)
  {
    CFTypeID TypeID = MTAudioProcessingTapGetTypeID();
    if (TypeID != CFGetTypeID(a3)) {
      return 0;
    }
  }
  uint64_t v12 = FigRenderPipelineGetFigBaseObject(*(void *)(v7 + 112));
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v16 = *(uint64_t (**)(uint64_t, __CFString *, const void *))(v14 + 56);
  if (!v16) {
    return 4294954514;
  }
  dispatch_queue_t v17 = @"AudioProcessingTap";
  uint64_t v18 = v12;
LABEL_29:

  return v16(v18, v17, a3);
}

uint64_t bapspTranscode_breakAudioChain(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!*(unsigned char *)(DerivedStorage + 40)) {
    return 0;
  }
  uint64_t v3 = DerivedStorage;
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 24));
  if (*(unsigned char *)(v3 + 42))
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v4 = *(void *)(v3 + 112);
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 64);
    if (v7)
    {
      uint64_t v8 = v7(v4, 1);
      if (v8
        || (uint64_t v8 = bapspTranscode_stopMixer(a1, 1), v8)
        || (CMNotificationCenterGetDefaultLocalCenter(), uint64_t v8 = FigNotificationCenterRemoveWeakListeners(), v8))
      {
        uint64_t v9 = v8;
      }
      else
      {
        CMNotificationCenterGetDefaultLocalCenter();
        uint64_t v9 = FigNotificationCenterRemoveWeakListeners();
        if (!v9) {
          *(unsigned char *)(v3 + 40) = 0;
        }
      }
    }
    else
    {
      uint64_t v9 = 4294954514;
    }
  }
  MEMORY[0x19970E930](*(void *)(v3 + 24));
  return v9;
}

uint64_t bapspTranscode_stopMixer(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(void *)(DerivedStorage + 104);
  if (a2)
  {
    uint64_t result = FigAudioQueueOfflineMixerInterruptAndStop(v4);
    if (result) {
      return result;
    }
  }
  else
  {
    uint64_t result = FigAudioQueueOfflineMixerStop(v4);
    if (result) {
      return result;
    }
  }
  uint64_t v6 = *(void *)(DerivedStorage + 104);

  return FigAudioQueueOfflineMixerWaitUntilCompletelyStopped(v6);
}

void bapspTranscode_decodeError(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
}

void bapspTranscode_ranDry(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
}

void bapspTranscode_playResourceReleased(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
  bapspTranscode_stopAudioChain((uint64_t)a2);

  bapspTranscode_postNotification(a2, @"PlayResourceReleased", a5);
}

void bapspTranscode_postNotification(const void *a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a3) {
    CFRetain(a3);
  }
  if (a1) {
    CFRetain(a1);
  }
  uint64_t v7 = *(NSObject **)(DerivedStorage + 32);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __bapspTranscode_postNotification_block_invoke;
  block[3] = &__block_descriptor_tmp_84;
  block[4] = a2;
  void block[5] = a1;
  block[6] = a3;
  dispatch_async(v7, block);
}

void __bapspTranscode_postNotification_block_invoke(uint64_t a1)
{
  CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification();
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t bapspTranscode_stopAudioChain(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 24));
  if (*(unsigned char *)(DerivedStorage + 42))
  {
    uint64_t v12 = 0;
    goto LABEL_15;
  }
  uint64_t v3 = bapspTranscode_stopMixer(a1, 0);
  if (v3) {
    goto LABEL_17;
  }
  uint64_t v4 = *(void *)(DerivedStorage + 112);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t))(v6 + 32);
  if (!v7) {
    goto LABEL_14;
  }
  uint64_t v3 = v7(v4);
  if (v3)
  {
LABEL_17:
    uint64_t v12 = v3;
    goto LABEL_15;
  }
  uint64_t v8 = *(void *)(DerivedStorage + 112);
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  CFAllocatorRef v11 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 64);
  if (!v11)
  {
LABEL_14:
    uint64_t v12 = 4294954514;
    goto LABEL_15;
  }
  uint64_t v12 = v11(v8, 1);
  if (!v12) {
    *(unsigned char *)(DerivedStorage + 41) = 0;
  }
LABEL_15:
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 24));
  return v12;
}

void bapspTranscode_offlineMixerMilestonePassed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a5)
  {
    FigCFDictionaryGetCMTimeIfPresent();
    if (dword_1E9351330)
    {
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
}

void bapspTranscode_offlineMixerDidReachEndOfOutputData(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
  cf[22] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  cf[0] = 0;
  if (dword_1E9351330)
  {
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 24));
  if (!*(unsigned char *)(DerivedStorage + 42))
  {
    FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1FA10], cf);
    CFTypeRef v9 = cf[0];
    if (cf[0])
    {
      uint64_t v10 = *(void *)(DerivedStorage + 80);
      uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v12 = v11 ? v11 : 0;
      uint64_t v13 = *(void (**)(uint64_t, CFTypeRef))(v12 + 8);
      if (v13) {
        v13(v10, v9);
      }
    }
    if (*(unsigned char *)(DerivedStorage + 43))
    {
      bapspTranscode_postNotification(a2, @"FinishedProcessingData", a5);
      *(unsigned char *)(DerivedStorage + 43) = 0;
    }
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 24));
  if (cf[0]) {
    CFRelease(cf[0]);
  }
}

uint64_t FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker(CFAllocatorRef allocator, const __CFString *a2, const void *a3, long long *a4, void *a5)
{
  CMAttachmentBearerRef target = 0;
  if (a5)
  {
    if (*((unsigned char *)a4 + 12))
    {
      uint64_t v12 = (char *)CFAllocatorAllocate(allocator, 72, 0);
      if (!v12)
      {
        uint64_t v16 = FigSignalErrorAt();
LABEL_14:
        if (target) {
          CFRelease(target);
        }
        return v16;
      }
      sampleTimingArradouble y = v12;
      CMItemCount v11 = 1;
      CMTimeMake(&v19, 0, 1);
      long long v13 = *(_OWORD *)&v19.value;
      *((void *)sampleTimingArray + 2) = v19.epoch;
      *(_OWORD *)sampleTimingArradouble y = v13;
      long long v14 = *a4;
      *((void *)sampleTimingArray + 5) = *((void *)a4 + 2);
      *(_OWORD *)(sampleTimingArray + 24) = v14;
      uint64_t v15 = MEMORY[0x1E4F1F9F8];
      *((_OWORD *)sampleTimingArray + 3) = *MEMORY[0x1E4F1F9F8];
      *((void *)sampleTimingArray + 8) = *(void *)(v15 + 16);
    }
    else
    {
      sampleTimingArradouble y = 0;
      CMItemCount v11 = 0;
    }
    uint64_t v16 = CMSampleBufferCreate(allocator, 0, 1u, 0, 0, 0, 0, v11, (const CMSampleTimingInfo *)sampleTimingArray, 0, 0, (CMSampleBufferRef *)&target);
    if (!v16)
    {
      if (a2) {
        CMSetAttachment(target, a2, a3, 1u);
      }
      CMAttachmentBearerRef v17 = target;
      if (target) {
        CMAttachmentBearerRef v17 = CFRetain(target);
      }
      *a5 = v17;
    }
    if (sampleTimingArray) {
      CFAllocatorDeallocate(allocator, sampleTimingArray);
    }
    goto LABEL_14;
  }

  return FigSignalErrorAt();
}

uint64_t bapspTranscode_setLoudnessInfo(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMAttachmentBearerRef target = 0;
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 24));
  StreamBasicDescriptioCFIndex n = CMAudioFormatDescriptionGetStreamBasicDescription(*(CMAudioFormatDescriptionRef *)(DerivedStorage + 136));
  uint64_t v7 = *(const void **)(DerivedStorage + 120);
  *(void *)(DerivedStorage + 120) = a2;
  if (a2) {
    CFRetain(a2);
  }
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = *(void *)(DerivedStorage + 120);
  if (!*(unsigned char *)(DerivedStorage + 128))
  {
    if (v8)
    {
      uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(*(void *)(DerivedStorage + 112));
      uint64_t v17 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v18 = v17 ? v17 : 0;
      CMTime v19 = *(void (**)(uint64_t, __CFString *, uint64_t))(v18 + 56);
      if (v19) {
        v19(FigBaseObject, @"LoudnessInfo", v8);
      }
    }
    goto LABEL_24;
  }
  CFTypeRef v9 = (const void *)*MEMORY[0x1E4F18A58];
  int v10 = CFDictionaryContainsKey(*(CFDictionaryRef *)(DerivedStorage + 120), (const void *)*MEMORY[0x1E4F18A58]);
  CMItemCount v11 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  CFDictionaryRef v12 = 0;
  if (!v10) {
    goto LABEL_40;
  }
  int mFormatID = StreamBasicDescription->mFormatID;
  if (mFormatID > 1885547314)
  {
    if (mFormatID > 1902469938)
    {
      if (mFormatID > 2053319474)
      {
        BOOL v14 = mFormatID == 2053464883;
        int v15 = 2053319475;
      }
      else
      {
        BOOL v14 = mFormatID == 1902469939;
        int v15 = 2053202739;
      }
    }
    else if (mFormatID > 1902207794)
    {
      BOOL v14 = mFormatID == 1902207795;
      int v15 = 1902324531;
    }
    else
    {
      BOOL v14 = mFormatID == 1885547315;
      int v15 = 1885692723;
    }
  }
  else if (mFormatID > 1667575090)
  {
    if (mFormatID > 1700998450)
    {
      BOOL v14 = mFormatID == 1700998451;
      int v15 = 1885430579;
    }
    else
    {
      BOOL v14 = mFormatID == 1667575091;
      int v15 = 1700997939;
    }
  }
  else if (mFormatID > 1667326770)
  {
    BOOL v14 = mFormatID == 1667326771;
    int v15 = 1667574579;
  }
  else
  {
    BOOL v14 = mFormatID == 1633889587;
    int v15 = 1667312947;
  }
  if (!v14 && mFormatID != v15) {
    goto LABEL_40;
  }
  *(void *)&long long v37 = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 120), v9);
  CFDictionaryRef v22 = CFDictionaryCreate(*v11, MEMORY[0x1E4F18A58], (const void **)&v37, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v22)
  {
LABEL_24:
    MEMORY[0x19970E930](*(void *)(DerivedStorage + 24));
    uint64_t v20 = 0;
    goto LABEL_50;
  }
  CFDictionaryRef v12 = v22;
  uint64_t v23 = FigRenderPipelineGetFigBaseObject(*(void *)(DerivedStorage + 112));
  uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v24) {
    uint64_t v25 = v24;
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v26 = *(void (**)(uint64_t, __CFString *, CFDictionaryRef))(v25 + 56);
  if (v26) {
    v26(v23, @"LoudnessInfo", v12);
  }
LABEL_40:
  CFAllocatorRef v27 = *v11;
  CFStringRef v28 = (const __CFString *)*MEMORY[0x1E4F21A20];
  unsigned int v29 = *(const void **)(DerivedStorage + 120);
  long long v37 = *(_OWORD *)a3;
  uint64_t v38 = *(void *)(a3 + 16);
  uint64_t v30 = FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker(v27, v28, v29, &v37, &target);
  if (v30)
  {
LABEL_46:
    uint64_t v20 = v30;
    goto LABEL_48;
  }
  CMSetAttachment(target, v28, *(CFTypeRef *)(DerivedStorage + 120), 0);
  CMSetAttachment(target, @"SBUFForAutoOrder", (CFTypeRef)*MEMORY[0x1E4F1CFD0], 0);
  uint64_t v31 = *(void *)(DerivedStorage + 80);
  CMAttachmentBearerRef v32 = target;
  uint64_t v33 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v33) {
    uint64_t v34 = v33;
  }
  else {
    uint64_t v34 = 0;
  }
  CFComparisonResult v35 = *(uint64_t (**)(uint64_t, CMAttachmentBearerRef))(v34 + 8);
  if (v35)
  {
    uint64_t v30 = v35(v31, v32);
    goto LABEL_46;
  }
  uint64_t v20 = 4294954514;
LABEL_48:
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 24));
  if (v12) {
    CFRelease(v12);
  }
LABEL_50:
  if (target) {
    CFRelease(target);
  }
  return v20;
}

uint64_t bapspTranscode_startAudioChain(uint64_t a1, CMTime *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 24));
  if (*(unsigned char *)(DerivedStorage + 42) || *(unsigned char *)(DerivedStorage + 41)) {
    goto LABEL_23;
  }
  if ((a2->flags & 0x1D) != 1)
  {
    uint64_t started = FigSignalErrorAt();
    goto LABEL_25;
  }
  if (dword_1E9351330)
  {
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  uint64_t Float32 = FigCFNumberCreateFloat32();
  if (!Float32)
  {
LABEL_23:
    uint64_t started = 0;
LABEL_25:
    MEMORY[0x19970E930](*(void *)(DerivedStorage + 24));
    return started;
  }
  uint64_t v6 = (const void *)Float32;
  uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(*(void *)(DerivedStorage + 112));
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  int v10 = *(uint64_t (**)(uint64_t, __CFString *, const void *))(v9 + 56);
  if (v10)
  {
    uint64_t v11 = v10(FigBaseObject, @"OfflineAudioQueueRate", v6);
    if (v11 || (uint64_t v11 = FigAudioQueueOfflineMixerReset(*(void *)(DerivedStorage + 104), 0), v11))
    {
LABEL_26:
      uint64_t started = v11;
      goto LABEL_21;
    }
    uint64_t v12 = *(void *)(DerivedStorage + 112);
    CMTime v20 = *a2;
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    int v15 = *(uint64_t (**)(uint64_t, CMTime *))(v14 + 24);
    if (v15)
    {
      CMTime time = v20;
      uint64_t v11 = v15(v12, &time);
      if (!v11)
      {
        *(_OWORD *)&v19.CMTimeValue value = *(_OWORD *)&a2->value;
        v19.CMTimeEpoch epoch = a2->epoch;
        uint64_t v16 = *(void *)(CMBaseObjectGetDerivedStorage() + 104);
        CMTime time = v19;
        CMTime v20 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F0];
        uint64_t started = FigAudioQueueOfflineMixerStartRenderingForTimeRange(v16, &time, &v20);
        if (!started) {
          *(unsigned char *)(DerivedStorage + 41) = 1;
        }
        goto LABEL_21;
      }
      goto LABEL_26;
    }
  }
  uint64_t started = 4294954514;
LABEL_21:
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 24));
  CFRelease(v6);
  return started;
}

uint64_t bapspTranscode_assembleAudioChain()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 24));
  if (*(unsigned char *)(DerivedStorage + 42) || *(unsigned char *)(DerivedStorage + 40))
  {
LABEL_29:
    uint64_t v23 = 0;
    goto LABEL_28;
  }
  uint64_t v1 = CMBaseObjectGetDerivedStorage();
  CMNotificationCenterGetDefaultLocalCenter();
  uint64_t v2 = FigNotificationCenterAddWeakListeners();
  if (v2
    || (CMNotificationCenterGetDefaultLocalCenter(), uint64_t v2 = FigNotificationCenterAddWeakListeners(), v2))
  {
LABEL_30:
    uint64_t v23 = v2;
    goto LABEL_28;
  }
  uint64_t v3 = *MEMORY[0x1E4F1CFD0];
  uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(*(void *)(v1 + 112));
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(void (**)(uint64_t, __CFString *, uint64_t))(v6 + 56);
  if (v7) {
    v7(FigBaseObject, @"HandleFormatDescriptionChanges", v3);
  }
  uint64_t v8 = FigRenderPipelineGetFigBaseObject(*(void *)(v1 + 112));
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(void (**)(uint64_t, __CFString *, uint64_t))(v10 + 56);
  if (v11) {
    v11(v8, @"DisconnectOfflineMixerWhileResetting", v3);
  }
  uint64_t v12 = *(void *)(v1 + 104);
  uint64_t v13 = FigRenderPipelineGetFigBaseObject(*(void *)(v1 + 112));
  uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(v15 + 56);
  if (v16)
  {
    uint64_t v2 = v16(v13, @"OfflineMixer", v12);
    if (v2) {
      goto LABEL_30;
    }
    uint64_t v17 = *(void *)(v1 + 96);
    uint64_t v18 = *(void *)(v1 + 80);
    uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 8);
    uint64_t v20 = v19 ? v19 : 0;
    uint64_t v21 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(v20 + 56);
    if (v21)
    {
      uint64_t v2 = v21(v17, @"DownstreamConsumer", v18);
      if (!v2)
      {
        *(unsigned char *)(v1 + 40) = 1;
        if (dword_1E9351330)
        {
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  uint64_t v23 = 4294954514;
LABEL_28:
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 24));
  return v23;
}

uint64_t bapspTranscode_flush(uint64_t a1, long long *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 24));
  if (*(unsigned char *)(DerivedStorage + 42))
  {
    uint64_t v13 = 0;
    goto LABEL_16;
  }
  uint64_t v5 = bapspTranscode_terminateQueueWithEndMarker();
  if (v5) {
    goto LABEL_15;
  }
  uint64_t v6 = *(void *)(DerivedStorage + 112);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t))(v8 + 32);
  if (v9)
  {
    uint64_t v5 = v9(v6);
    if (!v5)
    {
      uint64_t v10 = *(void *)(DerivedStorage + 112);
      long long v16 = *a2;
      uint64_t v17 = *((void *)a2 + 2);
      uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v11) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = 0;
      }
      uint64_t v14 = *(void (**)(uint64_t, long long *))(v12 + 88);
      if (v14)
      {
        long long v18 = v16;
        uint64_t v19 = v17;
        v14(v10, &v18);
      }
      uint64_t v5 = bapspTranscode_stopMixer(a1, 1);
    }
LABEL_15:
    uint64_t v13 = v5;
    goto LABEL_16;
  }
  uint64_t v13 = 4294954514;
LABEL_16:
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 24));
  return v13;
}

uint64_t bapspTranscode_terminateQueueWithEndMarker()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMSampleBufferRef v12 = 0;
  if (CMSampleBufferCreate(*(CFAllocatorRef *)(DerivedStorage + 56), 0, 1u, 0, 0, 0, 0, 0, 0, 0, 0, &v12))
  {
    uint64_t v7 = FigSignalErrorAt();
  }
  else
  {
    CMSetAttachment(v12, (CFStringRef)*MEMORY[0x1E4F1F238], (CFTypeRef)*MEMORY[0x1E4F1CFD0], 1u);
    CMTime start = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    CMTime end = start;
    CMTimeRangeFromTimeToTime(&range, &start, &end);
    CFDictionaryRef v1 = CMTimeRangeCopyAsDictionary(&range, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    CMSetAttachment(v12, (CFStringRef)*MEMORY[0x1E4F21A40], v1, 1u);
    uint64_t v2 = *(void *)(DerivedStorage + 64);
    CMSampleBufferRef v3 = v12;
    uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v4) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    uint64_t v6 = *(void (**)(uint64_t, CMSampleBufferRef))(v5 + 8);
    if (v6) {
      v6(v2, v3);
    }
    *(unsigned char *)(DerivedStorage + 43) = 1;
    if (v1) {
      CFRelease(v1);
    }
    uint64_t v7 = 0;
  }
  if (v12) {
    CFRelease(v12);
  }
  return v7;
}

uint64_t FigTTMLSetCreate(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a4)
  {
    FigTTMLNodeGetClassID();
    uint64_t v7 = CMDerivedObjectCreate();
    if (!v7)
    {
      FigBytePumpGetFigBaseObject(0);
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      uint64_t v9 = FigTTMLInitializeNodeBaseStorage(DerivedStorage, (long long *)a3);
      if (v9)
      {
        return v9;
      }
      else
      {
        uint64_t v7 = FigTTMLAddCurrentElementAttributesToDictionary(a2, *(__CFDictionary **)(DerivedStorage + 24));
        if (!v7)
        {
          *(void *)a3 = 0;
          *(void *)(a3 + 8) = 0;
          uint64_t v7 = FigTTMLParseNode(a2, (uint64_t (*)(uint64_t, uint64_t *, CFTypeRef *))figTTMLSetConsumeChildNode, (uint64_t *)a3);
          if (!v7) {
            *a4 = 0;
          }
        }
      }
    }
    return v7;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t figTTMLSetConsumeChildNode(uint64_t a1, uint64_t *a2, void *a3)
{
  FigBytePumpGetFigBaseObject(*a2);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = FigTTMLSkipNode(a1, a2, *(__CFArray **)(DerivedStorage + 128));
  if (a3)
  {
    if (!result) {
      *a3 = 0;
    }
  }
  return result;
}

void figTTMLSet_Finalize(uint64_t a1)
{
  FigBytePumpGetFigBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();

  FigTTMLReleaseNodeBaseStorage(DerivedStorage);
}

CFStringRef figTTMLSet_CopyDebugDesc(uint64_t a1)
{
  FigBytePumpGetFigBaseObject(a1);
  CMBaseObjectGetDerivedStorage();
  CFDictionaryRef v1 = (const void *)FigCFCopyCompactDescription();
  CFStringRef v2 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"set: %@", v1);
  if (v1) {
    CFRelease(v1);
  }
  return v2;
}

uint64_t figTTMLSet_CopyChildNodeArray(const void *a1, CFMutableArrayRef *a2)
{
  if (a2)
  {
    CFAllocatorRef v3 = CFGetAllocator(a1);
    *a2 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  }
  else
  {
    FigSignalErrorAt();
  }
  return 0;
}

uint64_t figTTMLSet_GetNodeType(uint64_t a1, _DWORD *a2)
{
  if (!a2) {
    return FigSignalErrorAt();
  }
  *a2 = 1;
  return 0;
}

uint64_t FigVideoCompositorCreateBasic(uint64_t a1, uint64_t a2, void *a3)
{
  FigVideoCompositorGetClassID();
  uint64_t v4 = CMDerivedObjectCreate();
  if (!v4)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    *(_DWORD *)(DerivedStorage + 80) = 1065353216;
    *(void *)(DerivedStorage + 384) = 0x7FFFFFFFLL;
    *(void *)(DerivedStorage + 416) = 0x7FFFFFFFLL;
    *(unsigned char *)(DerivedStorage + 96) = 1;
    *(_DWORD *)(DerivedStorage + 248) = 0;
    *(void *)(DerivedStorage + 256) = FigDispatchQueueCreateWithPriority();
    *(void *)(DerivedStorage + 264) = FigDispatchQueueCreateWithPriority();
    *(void *)(DerivedStorage + 272) = FigDispatchQueueCreateWithPriority();
    *(void *)(DerivedStorage + 280) = FigDispatchQueueCreateWithPriority();
    *(void *)(DerivedStorage + 288) = dispatch_group_create();
    *a3 = 0;
  }
  return v4;
}

void basicVideoCompositor_Finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFDictionaryRef v1 = *(NSObject **)(DerivedStorage + 256);
  if (v1)
  {
    dispatch_sync(v1, &__block_literal_global_66);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 256));
    *(void *)(DerivedStorage + 256) = 0;
  }
  CFStringRef v2 = *(NSObject **)(DerivedStorage + 264);
  if (v2)
  {
    dispatch_sync(v2, &__block_literal_global_7_0);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 264));
    *(void *)(DerivedStorage + 264) = 0;
  }
  CFAllocatorRef v3 = *(NSObject **)(DerivedStorage + 272);
  if (v3)
  {
    dispatch_sync(v3, &__block_literal_global_10);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 272));
    *(void *)(DerivedStorage + 272) = 0;
  }
  uint64_t v4 = *(NSObject **)(DerivedStorage + 280);
  if (v4)
  {
    dispatch_sync(v4, &__block_literal_global_13_0);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 280));
    *(void *)(DerivedStorage + 280) = 0;
  }
  uint64_t v5 = *(NSObject **)(DerivedStorage + 288);
  if (v5)
  {
    dispatch_release(v5);
    *(void *)(DerivedStorage + 288) = 0;
  }
  uint64_t v6 = *(const void **)(DerivedStorage + 32);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(DerivedStorage + 32) = 0;
  }
  uint64_t v7 = *(const void **)(DerivedStorage + 40);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(DerivedStorage + 40) = 0;
  }
  uint64_t v8 = *(const void **)(DerivedStorage + 48);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(DerivedStorage + 48) = 0;
  }
  uint64_t v9 = *(const void **)(DerivedStorage + 56);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(DerivedStorage + 56) = 0;
  }
  uint64_t v10 = *(const void **)(DerivedStorage + 64);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(DerivedStorage + 64) = 0;
  }
  uint64_t v11 = *(const void **)(DerivedStorage + 72);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(DerivedStorage + 72) = 0;
  }
  CMSampleBufferRef v12 = *(const void **)(DerivedStorage + 104);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(DerivedStorage + 104) = 0;
  }
  uint64_t v13 = *(const void **)(DerivedStorage + 160);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(DerivedStorage + 160) = 0;
  }
  uint64_t v14 = *(const void **)(DerivedStorage + 88);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(DerivedStorage + 88) = 0;
  }

  bvc_releaseLayerArrays();
}

__CFString *basicVideoCompositor_CopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFTypeRef cf = 0;
  CFIndex v4 = CFGetRetainCount(a1);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<FigVideoCompositor_Basic %p retainCount: %ld allocator: %p ", a1, v4, v5);
  bvc_copyPerformanceDictionary((uint64_t)a1, (CFDictionaryRef *)&cf);
  if (cf)
  {
    CFStringAppendFormat(Mutable, 0, @", performanceDictionary %@", cf);
    if (cf) {
      CFRelease(cf);
    }
  }
  CFStringAppendFormat(Mutable, 0, @">");
  return Mutable;
}

uint64_t basicVideoCompositor_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFDictionaryRef *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, @"RenderDimensions"))
  {
    CFDictionaryRef DictionaryRepresentation = CGSizeCreateDictionaryRepresentation(*(CGSize *)DerivedStorage);
LABEL_3:
    *a4 = DictionaryRepresentation;
    return 0;
  }
  if (CFEqual(a2, @"RenderPixelAspectRatio"))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 32);
    uint64_t v10 = *(const void **)(DerivedStorage + 32);
    if (!v10) {
      return 0;
    }
    goto LABEL_21;
  }
  if (CFEqual(a2, @"RenderEdgeProcessingPixels"))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 40);
    uint64_t v10 = *(const void **)(DerivedStorage + 40);
    if (!v10) {
      return 0;
    }
    goto LABEL_21;
  }
  if (CFEqual(a2, @"DestinationPixelBufferDesiredAttributes"))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 48);
    uint64_t v10 = *(const void **)(DerivedStorage + 48);
    if (!v10) {
      return 0;
    }
    goto LABEL_21;
  }
  if (CFEqual(a2, @"DestinationPixelBufferDesiredYCbCrMatrix"))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 56);
    uint64_t v10 = *(const void **)(DerivedStorage + 56);
    if (!v10) {
      return 0;
    }
    goto LABEL_21;
  }
  if (CFEqual(a2, @"DestinationPixelBufferDesiredColorPrimaries"))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 64);
    uint64_t v10 = *(const void **)(DerivedStorage + 64);
    if (!v10) {
      return 0;
    }
    goto LABEL_21;
  }
  if (CFEqual(a2, @"DestinationPixelBufferDesiredTransferFunction"))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 72);
    uint64_t v10 = *(const void **)(DerivedStorage + 72);
    if (!v10) {
      return 0;
    }
LABEL_21:
    CFRetain(v10);
    return 0;
  }
  if (CFEqual(a2, @"SourcePixelBufferAttributes"))
  {
    return bvc_createPixelBufferAttributesDictionary(a3, a4);
  }
  if (CFEqual(a2, @"RenderScale"))
  {
    CFDictionaryRef DictionaryRepresentation = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (const void *)(DerivedStorage + 80));
    goto LABEL_3;
  }
  if (CFEqual(a2, @"CanApplyRenderScale"))
  {
    CFDictionaryRef DictionaryRepresentation = (const __CFDictionary *)*MEMORY[0x1E4F1CFD0];
    if (!*MEMORY[0x1E4F1CFD0]) {
      goto LABEL_3;
    }
    goto LABEL_34;
  }
  if (CFEqual(a2, @"PixelBufferPoolSharingID"))
  {
    CFDictionaryRef DictionaryRepresentation = *(const __CFDictionary **)(DerivedStorage + 88);
    if (!DictionaryRepresentation) {
      goto LABEL_3;
    }
LABEL_34:
    CFDictionaryRef DictionaryRepresentation = (const __CFDictionary *)CFRetain(DictionaryRepresentation);
    goto LABEL_3;
  }
  if (CFEqual(a2, @"LoopTimeRange"))
  {
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    long long v13 = *(_OWORD *)(DerivedStorage + 328);
    *(_OWORD *)&v14.start.CMTimeValue value = *(_OWORD *)(DerivedStorage + 312);
    *(_OWORD *)&v14.start.CMTimeEpoch epoch = v13;
    *(_OWORD *)&v14.duration.CMTimeScale timescale = *(_OWORD *)(DerivedStorage + 344);
    CFDictionaryRef DictionaryRepresentation = CMTimeRangeCopyAsDictionary(&v14, v12);
    goto LABEL_3;
  }
  if (CFEqual(a2, @"PerformanceDictionary"))
  {
    bvc_copyPerformanceDictionary(a1, a4);
    return 0;
  }
  if (CFEqual(a2, @"SourceColorConformanceCapabilityLevel"))
  {
    CFDictionaryRef DictionaryRepresentation = (const __CFDictionary *)FigCFNumberCreateUInt32();
    goto LABEL_3;
  }

  return FigSignalErrorAt();
}

uint64_t basicVideoCompositor_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(@"RenderDimensions", a2))
  {
    size.start.CMTimeValue value = 0;
    *(void *)&size.start.CMTimeScale timescale = 0;
    if (a3)
    {
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(a3)
        && CGSizeMakeWithDictionaryRepresentation((CFDictionaryRef)a3, (CGSize *)&size)
        && *(double *)&size.start.value > 0.0
        && *(double *)&size.start.timescale > 0.0)
      {
        *(_OWORD *)uint64_t DerivedStorage = *(_OWORD *)&size.start.value;
LABEL_43:
        uint64_t v21 = *(const void **)(DerivedStorage + 104);
        if (v21)
        {
          CFRelease(v21);
          *(void *)(DerivedStorage + 104) = 0;
        }
        CMTimeRange v14 = 0;
        *(unsigned char *)(DerivedStorage + 96) = 1;
        return (uint64_t)v14;
      }
    }
    return FigSignalErrorAt();
  }
  if (CFEqual(@"RenderPixelAspectRatio", a2))
  {
    if (!a3)
    {
      long long v13 = *(const void **)(DerivedStorage + 32);
      *(void *)(DerivedStorage + 32) = 0;
      if (!v13) {
        goto LABEL_43;
      }
      goto LABEL_42;
    }
    CFTypeID v7 = CFDictionaryGetTypeID();
    if (v7 != CFGetTypeID(a3)) {
      return FigSignalErrorAt();
    }
    CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E4F24B90]);
    uint64_t v9 = CFDictionaryGetValue((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E4F24BA0]);
    LODWORD(size.start.value) = 0;
    int valuePtr = 0;
    if (!Value) {
      return FigSignalErrorAt();
    }
    uint64_t v10 = v9;
    CFTypeID v11 = CFNumberGetTypeID();
    if (v11 != CFGetTypeID(Value)) {
      return FigSignalErrorAt();
    }
    CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &size);
    if (SLODWORD(size.start.value) < 1) {
      return FigSignalErrorAt();
    }
    if (!v10) {
      return FigSignalErrorAt();
    }
    CFTypeID v12 = CFNumberGetTypeID();
    if (v12 != CFGetTypeID(v10)) {
      return FigSignalErrorAt();
    }
    CFNumberGetValue((CFNumberRef)v10, kCFNumberIntType, &valuePtr);
    if (valuePtr < 1) {
      return FigSignalErrorAt();
    }
    long long v13 = *(const void **)(DerivedStorage + 32);
    *(void *)(DerivedStorage + 32) = a3;
    goto LABEL_33;
  }
  if (CFEqual(@"RenderEdgeProcessingPixels", a2))
  {
    if (a3)
    {
      CFTypeID v15 = CFArrayGetTypeID();
      if (v15 == CFGetTypeID(a3) && CFArrayGetCount((CFArrayRef)a3) == 4)
      {
        CFIndex v16 = 0;
        while (1)
        {
          CFTypeID v17 = CFNumberGetTypeID();
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, v16);
          if (v17 != CFGetTypeID(ValueAtIndex)) {
            break;
          }
          if (++v16 == 4)
          {
            long long v13 = *(const void **)(DerivedStorage + 40);
            *(void *)(DerivedStorage + 40) = a3;
            goto LABEL_33;
          }
        }
      }
      goto LABEL_98;
    }
    long long v13 = *(const void **)(DerivedStorage + 40);
    *(void *)(DerivedStorage + 40) = 0;
    if (!v13) {
      goto LABEL_43;
    }
LABEL_42:
    CFRelease(v13);
    goto LABEL_43;
  }
  if (!CFEqual(@"DestinationPixelBufferDesiredAttributes", a2))
  {
    if (CFEqual(@"DestinationPixelBufferDesiredYCbCrMatrix", a2))
    {
      if (!a3)
      {
        CMTimeRange v14 = *(const void **)(DerivedStorage + 56);
        *(void *)(DerivedStorage + 56) = 0;
LABEL_65:
        if (!v14) {
          return (uint64_t)v14;
        }
        CFRelease(v14);
        return 0;
      }
      CFTypeID v20 = CFStringGetTypeID();
      if (v20 != CFGetTypeID(a3)) {
        goto LABEL_98;
      }
      CMTimeRange v14 = *(const void **)(DerivedStorage + 56);
      *(void *)(DerivedStorage + 56) = a3;
LABEL_56:
      CFRetain(a3);
      goto LABEL_65;
    }
    if (CFEqual(@"DestinationPixelBufferDesiredColorPrimaries", a2))
    {
      if (!a3)
      {
        CMTimeRange v14 = *(const void **)(DerivedStorage + 64);
        *(void *)(DerivedStorage + 64) = 0;
        goto LABEL_65;
      }
      CFTypeID v23 = CFStringGetTypeID();
      if (v23 != CFGetTypeID(a3)) {
        goto LABEL_98;
      }
      CMTimeRange v14 = *(const void **)(DerivedStorage + 64);
      *(void *)(DerivedStorage + 64) = a3;
      goto LABEL_56;
    }
    if (CFEqual(@"DestinationPixelBufferDesiredTransferFunction", a2))
    {
      if (!a3)
      {
        CMTimeRange v14 = *(const void **)(DerivedStorage + 72);
        *(void *)(DerivedStorage + 72) = 0;
        goto LABEL_65;
      }
      CFTypeID v24 = CFStringGetTypeID();
      if (v24 != CFGetTypeID(a3)) {
        goto LABEL_98;
      }
      CMTimeRange v14 = *(const void **)(DerivedStorage + 72);
      *(void *)(DerivedStorage + 72) = a3;
      goto LABEL_56;
    }
    if (CFEqual(@"RenderScale", a2))
    {
      LODWORD(size.start.value) = 1065353216;
      if (a3)
      {
        CFTypeID v25 = CFGetTypeID(a3);
        if (v25 != CFNumberGetTypeID()
          || (CFNumberGetValue((CFNumberRef)a3, kCFNumberFloatType, &size),
              float v26 = *(float *)&size.start.value,
              *(float *)&size.start.value <= 0.0))
        {
          CMTimeRange v14 = (const void *)FigSignalErrorAt();
          if (v14) {
            return (uint64_t)v14;
          }
          float v26 = *(float *)&size.start.value;
        }
      }
      else
      {
        float v26 = 1.0;
      }
      *(float *)(DerivedStorage + 80) = v26;
      goto LABEL_43;
    }
    if (CFEqual(@"ClientPID", a2))
    {
      if (!a3)
      {
        *(_DWORD *)(DerivedStorage + 252) = 0;
        goto LABEL_85;
      }
      CFTypeID v27 = CFGetTypeID(a3);
      if (v27 != CFNumberGetTypeID()) {
        return 0;
      }
      CFStringRef v28 = (void *)(DerivedStorage + 252);
    }
    else
    {
      if (!CFEqual(@"WorkerThreadPriority", a2))
      {
        if (CFEqual(@"HighQualityRendering", a2))
        {
          if (a3)
          {
            CFTypeID v30 = CFGetTypeID(a3);
            if (v30 == CFBooleanGetTypeID()) {
              CMTimeRange v14 = 0;
            }
            else {
              CMTimeRange v14 = (const void *)FigSignalErrorAt();
            }
            if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1CFD0]))
            {
              *(unsigned char *)(DerivedStorage + 172) = 1;
              return (uint64_t)v14;
            }
          }
          else
          {
            CMTimeRange v14 = 0;
          }
          *(unsigned char *)(DerivedStorage + 172) = 0;
          return (uint64_t)v14;
        }
        if (!CFEqual(@"PixelBufferPoolSharingID", a2))
        {
          if (CFEqual(@"LoopTimeRange", a2))
          {
            if (!a3)
            {
              CMTimeRange v14 = 0;
              uint64_t v34 = MEMORY[0x1E4F1FA20];
              long long v35 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
              *(_OWORD *)(DerivedStorage + 312) = *MEMORY[0x1E4F1FA20];
              *(_OWORD *)(DerivedStorage + 328) = v35;
              *(_OWORD *)(DerivedStorage + 344) = *(_OWORD *)(v34 + 32);
              return (uint64_t)v14;
            }
            CFTypeID v31 = CFGetTypeID(a3);
            if (v31 == CFDictionaryGetTypeID())
            {
              CMAttachmentBearerRef v32 = (_OWORD *)(DerivedStorage + 312);
              CMTimeRangeMakeFromDictionary(&size, (CFDictionaryRef)a3);
              CMTimeRange v14 = 0;
              long long v33 = *(_OWORD *)&size.start.epoch;
              *CMAttachmentBearerRef v32 = *(_OWORD *)&size.start.value;
              v32[1] = v33;
              v32[2] = *(_OWORD *)&size.duration.timescale;
              return (uint64_t)v14;
            }
          }
          goto LABEL_98;
        }
        CMTimeRange v14 = *(const void **)(DerivedStorage + 88);
        *(void *)(DerivedStorage + 88) = a3;
        if (!a3) {
          goto LABEL_65;
        }
        goto LABEL_56;
      }
      if (!a3)
      {
        *(_DWORD *)(DerivedStorage + 248) = 0;
        goto LABEL_85;
      }
      CFTypeID v29 = CFGetTypeID(a3);
      if (v29 != CFNumberGetTypeID()) {
        return 0;
      }
      CFStringRef v28 = (void *)(DerivedStorage + 248);
    }
    CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, v28);
LABEL_85:
    basicVideoCompositor_updateDispatchQueuesClientPidAndWorkerThreadPriority();
    return 0;
  }
  if (!a3)
  {
    long long v13 = *(const void **)(DerivedStorage + 48);
    *(void *)(DerivedStorage + 48) = 0;
    if (!v13) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  CFTypeID v19 = CFDictionaryGetTypeID();
  if (v19 == CFGetTypeID(a3))
  {
    long long v13 = *(const void **)(DerivedStorage + 48);
    *(void *)(DerivedStorage + 48) = a3;
LABEL_33:
    CFRetain(a3);
    if (!v13) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
LABEL_98:

  return FigSignalErrorAt();
}

void bvc_releaseLayerArrays()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = DerivedStorage;
  uint64_t v2 = *(void *)(DerivedStorage + 176);
  if (v2)
  {
    CFAllocatorRef v3 = *(CFTypeRef **)(DerivedStorage + 184);
    do
    {
      if (*v3)
      {
        CFRelease(*v3);
        *CFAllocatorRef v3 = 0;
      }
      ++v3;
      --v2;
    }
    while (v2);
    uint64_t v4 = *(void *)(v1 + 176);
    if (v4)
    {
      CFAllocatorRef v5 = *(CFTypeRef **)(v1 + 192);
      do
      {
        if (*v5)
        {
          CFRelease(*v5);
          *CFAllocatorRef v5 = 0;
        }
        ++v5;
        --v4;
      }
      while (v4);
      uint64_t v6 = *(void *)(v1 + 176);
      if (v6)
      {
        CFTypeID v7 = *(CFTypeRef **)(v1 + 200);
        do
        {
          if (*v7)
          {
            CFRelease(*v7);
            *CFTypeID v7 = 0;
          }
          ++v7;
          --v6;
        }
        while (v6);
        uint64_t v8 = *(void *)(v1 + 176);
        if (v8)
        {
          uint64_t v9 = *(CFTypeRef **)(v1 + 208);
          do
          {
            if (*v9)
            {
              CFRelease(*v9);
              *uint64_t v9 = 0;
            }
            ++v9;
            --v8;
          }
          while (v8);
          uint64_t v10 = *(void *)(v1 + 176);
          if (v10)
          {
            CFTypeID v11 = *(CFTypeRef **)(v1 + 232);
            do
            {
              if (*v11)
              {
                CFRelease(*v11);
                CFTypeRef *v11 = 0;
              }
              ++v11;
              --v10;
            }
            while (v10);
            uint64_t v12 = *(void *)(v1 + 176);
            if (v12)
            {
              long long v13 = *(CFTypeRef **)(v1 + 240);
              do
              {
                if (*v13)
                {
                  CFRelease(*v13);
                  *long long v13 = 0;
                }
                ++v13;
                --v12;
              }
              while (v12);
            }
          }
        }
      }
    }
  }
  free(*(void **)(v1 + 184));
  *(void *)(v1 + 184) = 0;
  free(*(void **)(v1 + 192));
  *(void *)(v1 + 192) = 0;
  free(*(void **)(v1 + 200));
  *(void *)(v1 + 200) = 0;
  free(*(void **)(v1 + 208));
  *(void *)(v1 + 208) = 0;
  free(*(void **)(v1 + 216));
  *(void *)(v1 + 216) = 0;
  free(*(void **)(v1 + 224));
  *(void *)(v1 + 224) = 0;
  free(*(void **)(v1 + 232));
  *(void *)(v1 + 232) = 0;
  free(*(void **)(v1 + 240));
  *(void *)(v1 + 240) = 0;
}

void bvc_copyPerformanceDictionary(uint64_t a1, CFDictionaryRef *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v25 = 0;
    long long v24 = 0u;
    long long v23 = 0u;
    long long v22 = 0u;
    long long v21 = 0u;
    long long v20 = 0u;
    long long v19 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    uint64_t v17 = 0;
    double v9 = 0.0;
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    keys[0] = @"NumberOfSourceFramesPassedThrough";
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(DerivedStorage + 360));
    keys[1] = @"NumberOfSinglePassCompositions";
    values[1] = CFNumberCreate(v4, kCFNumberIntType, (const void *)(DerivedStorage + 364));
    _OWORD keys[2] = @"NumberOfMultiPassCompositions";
    values[2] = CFNumberCreate(v4, kCFNumberIntType, (const void *)(DerivedStorage + 368));
    int valuePtr = *(_DWORD *)(DerivedStorage + 376) + *(_DWORD *)(DerivedStorage + 372) + *(_DWORD *)(DerivedStorage + 380);
    keys[3] = @"TotalNumberOfLayers";
    values[3] = CFNumberCreate(v4, kCFNumberIntType, &valuePtr);
    keys[4] = @"TotalNumberOfLayersSkipped";
    values[4] = CFNumberCreate(v4, kCFNumberIntType, (const void *)(DerivedStorage + 372));
    keys[5] = @"TotalNumberOfLayersComposedUsingFastPath";
    values[5] = CFNumberCreate(v4, kCFNumberIntType, (const void *)(DerivedStorage + 376));
    keys[6] = @"TotalNumberOfLayersComposedUsingSlowPath";
    values[6] = CFNumberCreate(v4, kCFNumberIntType, (const void *)(DerivedStorage + 380));
    if (*(int *)(DerivedStorage + 408) < 1)
    {
      unsigned int v5 = 7;
    }
    else
    {
      double v9 = (float)((float)*(uint64_t *)(DerivedStorage + 384) / 1000000.0);
      *(void *)&long long v19 = @"MinPreprocessingTime";
      *(void *)&long long v11 = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      double v9 = (float)((float)*(uint64_t *)(DerivedStorage + 392) / 1000000.0);
      *((void *)&v19 + 1) = @"MaxPreprocessingTime";
      *((void *)&v11 + 1) = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      double v9 = (float)((float)*(uint64_t *)(DerivedStorage + 400) / (float)((float)*(int *)(DerivedStorage + 408) * 1000000.0));
      *(void *)&long long v20 = @"AveragePreprocessingTime";
      *(void *)&long long v12 = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      unsigned int v5 = 10;
    }
    if (*(int *)(DerivedStorage + 440) >= 1)
    {
      double v9 = (float)((float)*(uint64_t *)(DerivedStorage + 416) / 1000000.0);
      keys[v5] = @"MinProcessingTime";
      values[v5] = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      double v9 = (float)((float)*(uint64_t *)(DerivedStorage + 424) / 1000000.0);
      keys[v5 + 1] = @"MaxProcessingTime";
      values[v5 + 1] = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      double v9 = (float)((float)*(uint64_t *)(DerivedStorage + 432) / (float)((float)*(int *)(DerivedStorage + 440) * 1000000.0));
      keys[v5 + 2] = @"AverageProcessingTime";
      values[v5 + 2] = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      v5 += 3;
    }
    CFIndex v6 = v5;
    CFTypeID v7 = values;
    *a2 = CFDictionaryCreate(v4, (const void **)keys, (const void **)values, v6, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    do
    {
      if (*v7) {
        CFRelease(*v7);
      }
      ++v7;
      --v6;
    }
    while (v6);
  }
}

uint64_t bvc_createPixelBufferAttributesDictionary(const __CFAllocator *a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v15 = *(_OWORD *)"v024f024ARGB ";
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return FigSignalErrorAt();
  }
  CFMutableDictionaryRef v5 = Mutable;
  CFMutableArrayRef v6 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  if (v6)
  {
    CFTypeID v7 = v6;
    uint64_t v8 = 0;
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      CFNumberRef v10 = CFNumberCreate(v9, kCFNumberSInt32Type, (char *)&v15 + v8);
      if (!v10)
      {
        uint64_t PixelBufferAttributesWithIOSurfaceSupport = FigSignalErrorAt();
        CFRelease(v5);
        long long v13 = v7;
        goto LABEL_9;
      }
      CFNumberRef v11 = v10;
      CFArrayAppendValue(v7, v10);
      CFRelease(v11);
      v8 += 4;
    }
    while (v8 != 16);
    CFDictionaryAddValue(v5, (const void *)*MEMORY[0x1E4F24D70], v7);
    CFRelease(v7);
    FigGetAlignmentForIOSurfaceOutput();
    uint64_t PixelBufferAttributesWithIOSurfaceSupport = FigCreatePixelBufferAttributesWithIOSurfaceSupport();
    if (!PixelBufferAttributesWithIOSurfaceSupport) {
      *a2 = 0;
    }
  }
  else
  {
    uint64_t PixelBufferAttributesWithIOSurfaceSupport = FigSignalErrorAt();
  }
  long long v13 = v5;
LABEL_9:
  CFRelease(v13);
  return PixelBufferAttributesWithIOSurfaceSupport;
}

uint64_t bvc_CFDictionarySetInt(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  if (v5)
  {
    CFDictionarySetValue(a1, a2, v5);
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = FigSignalErrorAt();
  }
  CFRelease(v5);
  return v6;
}

uint64_t basicVideoCompositor_updateDispatchQueuesClientPidAndWorkerThreadPriority()
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  if (DerivedStorage[32]) {
    FigDispatchQueueSetPriorityAndClientPID();
  }
  if (DerivedStorage[33]) {
    FigDispatchQueueSetPriorityAndClientPID();
  }
  if (DerivedStorage[34]) {
    FigDispatchQueueSetPriorityAndClientPID();
  }
  uint64_t result = DerivedStorage[35];
  if (result)
  {
    return FigDispatchQueueSetPriorityAndClientPID();
  }
  return result;
}

uint64_t basicVideoCompositor_RenderFrame(const void *a1, int a2, uint64_t a3, CVBufferRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, const __CFDictionary *a8, uint64_t a9, uint64_t a10)
{
  uint64_t v376 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v15 = DerivedStorage;
  long long v16 = *MEMORY[0x1E4F1DAB8];
  long long v17 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)&v363.CGFloat a = *MEMORY[0x1E4F1DAB8];
  *(_OWORD *)&v363.double c = v17;
  long long v18 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
  *(_OWORD *)&v363.tCGFloat x = v18;
  uint64_t v359 = 0;
  v360 = &v359;
  uint64_t v361 = 0x2000000000;
  int v362 = 0;
  uint64_t v355 = 0;
  v356 = &v355;
  uint64_t v357 = 0x2000000000;
  char v358 = 0;
  if (!DerivedStorage || !*(void *)(DerivedStorage + 296))
  {
    uint64_t v22 = FigSignalErrorAt();
    goto LABEL_380;
  }
  if (*(double *)DerivedStorage == 0.0 || *(double *)(DerivedStorage + 8) == 0.0)
  {
    uint64_t v107 = FigSignalErrorAt();
    goto LABEL_375;
  }
  long long v336 = v18;
  long long r1 = v17;
  long long v346 = v16;
  if (!*(unsigned char *)(DerivedStorage + 96)) {
    goto LABEL_10;
  }
  uint64_t v19 = CMBaseObjectGetDerivedStorage();
  long long v21 = (__CFDictionary **)(v19 + 160);
  long long v20 = *(const void **)(v19 + 160);
  if (v20)
  {
    CFRelease(v20);
    *long long v21 = 0;
  }
  v373.CGFloat a = 0.0;
  t1.CGFloat a = 0.0;
  uint64_t v22 = FigVideoCompositorUtilityCopyRenderPixelBufferDimensionsAndCleanAperture(*(void *)(v19 + 32), *(void *)(v19 + 40), &v373, &t1, v19 + 112, v21, *(double *)v19, *(double *)(v19 + 8), *(float *)(v19 + 80));
  if (v22)
  {
LABEL_380:
    uint64_t v107 = v22;
    v255 = 0;
    CFDictionaryRef v271 = 0;
    v272 = 0;
    v273 = 0;
    v274 = 0;
    long long v33 = 0;
    goto LABEL_362;
  }
  CGFloat a = t1.a;
  *(CGFloat *)(v19 + 16) = v373.a;
  *(CGFloat *)(v19 + 24) = a;
  *(_DWORD *)(v19 + 168) = 875704438;
  *(unsigned char *)(v15 + 96) = 0;
LABEL_10:
  long long v24 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFArrayRef Value = CFDictionaryGetValue(a8, @"ContainsTweening");
  float v26 = 0.0;
  if (v24 == Value)
  {
    *(_OWORD *)&v373.CGFloat a = *(_OWORD *)a9;
    v373.double c = *(CGFloat *)(a9 + 16);
    FigVideoCompositionInstructionGetNormalizedTime(a8, (CMTime *)&v373);
    float v26 = v27;
  }
  CFArrayRef v28 = (const __CFArray *)CFDictionaryGetValue(a8, @"LayerStack");
  uint64_t v323 = v15;
  CFTypeRef cf = a1;
  CFDictionaryRef v315 = a8;
  v316 = a4;
  if (v28 && (v29 = v28, v332 = Value, CFTypeID v30 = CFArrayGetTypeID(), v30 == CFGetTypeID(v29)))
  {
    v327 = v24;
    int64_t v31 = CFArrayGetCount(v29);
    CMAttachmentBearerRef v32 = (char *)malloc_type_calloc(v31, 0x160uLL, 0x1020040E645271BuLL);
    long long v33 = v32;
    if (!v32)
    {
      v255 = 0;
      CFDictionaryRef v271 = 0;
      v272 = 0;
      v273 = 0;
      v274 = 0;
      uint64_t v107 = 4294954510;
      goto LABEL_362;
    }
    if (v31 >= 1)
    {
      CFIndex v34 = 0;
      uint64_t v35 = 0;
      CFStringRef v321 = (CFStringRef)(v15 + 112);
      uint64_t v36 = (uint64_t)v32;
      v339 = v32;
      while (1)
      {
        LODWORD(valuePtr.a) = 0;
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v29, v34);
        if (!ValueAtIndex) {
          goto LABEL_359;
        }
        uint64_t v38 = ValueAtIndex;
        size_t count = v35;
        CFTypeID TypeID = CFDictionaryGetTypeID();
        if (TypeID != CFGetTypeID(v38)) {
          goto LABEL_359;
        }
        CMAttachmentBearerRef v40 = CFDictionaryGetValue((CFDictionaryRef)v38, @"SourceVideoTrackID");
        if (!v40) {
          goto LABEL_359;
        }
        uint64_t v41 = v40;
        CFTypeID v42 = CFNumberGetTypeID();
        if (v42 != CFGetTypeID(v41)) {
          goto LABEL_359;
        }
        CFNumberGetValue((CFNumberRef)v41, kCFNumberSInt32Type, &valuePtr);
        if (a2 < 1) {
          goto LABEL_359;
        }
        uint64_t v43 = 0;
        uint64_t v35 = count;
        while (*(_DWORD *)(a3 + 4 * v43) != LODWORD(valuePtr.a))
        {
          if (a2 == ++v43) {
            goto LABEL_359;
          }
        }
        CVBufferRef v44 = v316[v43];
        *(void *)uint64_t v36 = v44;
        *(void *)(v36 + 8) = v43;
        if (!v44)
        {
          long long v33 = v339;
          goto LABEL_73;
        }
        *(_OWORD *)(v36 + 32) = v346;
        *(_OWORD *)(v36 + 48) = r1;
        *(_OWORD *)(v36 + 64) = v336;
        *(_DWORD *)(v36 + 24) = 1065353216;
        long long v45 = *(_OWORD *)(MEMORY[0x1E4F1DB10] + 16);
        *(_OWORD *)(v36 + 128) = *MEMORY[0x1E4F1DB10];
        *(_OWORD *)(v36 + 144) = v45;
        *(void *)(v36 + 16) = v34;
        CFIndex v308 = v34;
        if (v327 != v332
          || (CFArrayRef v60 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v38, @"TweenedAffineMatrix")) == 0)
        {
LABEL_28:
          char v46 = 0;
          goto LABEL_29;
        }
        CFArrayRef v61 = v60;
        CFIndex v62 = CFArrayGetCount(v60);
        if (v62 < 4 || (v62 & 1) != 0)
        {
          uint64_t v106 = FigSignalErrorAt();
          if (!v106) {
            goto LABEL_30;
          }
          goto LABEL_360;
        }
        CFArrayRef theArray = v61;
        double v63 = 0.0;
        CFIndex v64 = 1;
        double v65 = 0.0;
        while (1)
        {
          CFIndex v66 = v62;
          t2.CGFloat a = 0.0;
          v370.CGFloat a = 0.0;
          memset(&v373, 0, sizeof(v373));
          CFArrayRef v67 = (const __CFArray *)CFArrayGetValueAtIndex(theArray, v64);
          FigGetCGAffineTransformFrom3x2MatrixArray(v67, &v373.a);
          CGAffineTransform t1 = v373;
          FigVideoCompositionInstructionCGAffineTransformDecompose(&t1, 1, 0, 0, &t2.a, &v370.a, 0);
          if (v65 == 0.0)
          {
            double v65 = t2.a;
            CFIndex v62 = v66;
          }
          else
          {
            CFIndex v62 = v66;
            if (vabdd_f64(v65, t2.a) > 0.001) {
              goto LABEL_77;
            }
          }
          if (v63 != 0.0) {
            break;
          }
          double v63 = v370.a;
LABEL_52:
          v64 += 2;
          if (v64 >= v62) {
            goto LABEL_28;
          }
        }
        if (vabdd_f64(v63, v370.a) <= 0.001) {
          goto LABEL_52;
        }
LABEL_77:
        char v46 = 1;
LABEL_29:
        *(unsigned char *)(v36 + 329) = v46;
LABEL_30:
        uint64_t v47 = (_OWORD *)(v36 + 32);
        CFArrayRef v48 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v38, @"ConstantAffineMatrix");
        if (v48)
        {
          CFArrayRef v49 = v48;
          CFTypeID v50 = CFArrayGetTypeID();
          if (v50 == CFGetTypeID(v49))
          {
            FigGetCGAffineTransformFrom3x2MatrixArray(v49, &v373.a);
            long long v52 = *(_OWORD *)&v373.c;
            long long v51 = *(_OWORD *)&v373.tx;
            *uint64_t v47 = *(_OWORD *)&v373.a;
            *(_OWORD *)(v36 + 48) = v52;
            *(_OWORD *)(v36 + 64) = v51;
            goto LABEL_33;
          }
LABEL_359:
          uint64_t v106 = FigSignalErrorAt();
LABEL_360:
          uint64_t v107 = v106;
          uint64_t v15 = v323;
          long long v33 = v339;
LABEL_361:
          v255 = 0;
          CFDictionaryRef v271 = 0;
          v272 = 0;
          v273 = 0;
          v274 = 0;
          goto LABEL_362;
        }
LABEL_33:
        CFNumberRef v53 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v38, @"ConstantOpacity");
        if (v53)
        {
          CFNumberRef v54 = v53;
          CFTypeID v55 = CFNumberGetTypeID();
          if (v55 == CFGetTypeID(v54))
          {
            LODWORD(v373.a) = 0;
            CFNumberGetValue(v54, kCFNumberFloat32Type, &v373);
            *(_DWORD *)(v36 + 24) = LODWORD(v373.a);
          }
        }
        CMTimeValue v56 = CFDictionaryGetValue((CFDictionaryRef)v38, @"ConstantCropRectangle");
        if (v56)
        {
          CMTimeScale v57 = v56;
          CFTypeID v58 = CFDictionaryGetTypeID();
          if (v58 == CFGetTypeID(v57)
            && !CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)v57, (CGRect *)(v36 + 128)))
          {
            goto LABEL_359;
          }
        }
        if (v327 == v332)
        {
          CFArrayRef v68 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v38, @"TweenedAffineMatrix");
          if (v68 && (CFArrayRef v69 = v68, v70 = CFArrayGetTypeID(), v70 == CFGetTypeID(v69)))
          {
            FigVideoCompositionInstructionEvaluateTweenedAffineMatrix(v69, (uint64_t)&v373, v26);
            long long v72 = *(_OWORD *)&v373.c;
            long long v71 = *(_OWORD *)&v373.tx;
            *uint64_t v47 = *(_OWORD *)&v373.a;
            *(_OWORD *)(v36 + 48) = v72;
            *(_OWORD *)(v36 + 64) = v71;
            char v73 = 1;
          }
          else
          {
            char v73 = 0;
          }
          int v74 = CFDictionaryGetValue((CFDictionaryRef)v38, @"TweenedOpacity");
          if (v74)
          {
            int v75 = v74;
            theArraydouble b = v73;
            CFTypeID v76 = CFArrayGetTypeID();
            BOOL v212 = v76 == CFGetTypeID(v75);
            char v73 = theArrayb;
            if (v212) {
              *(float *)(v36 + 24) = FigVideoCompositionInstructionEvaluateTweenedOpacity(v75, v26);
            }
          }
          int v77 = CFDictionaryGetValue((CFDictionaryRef)v38, @"TweenedCropRectangle");
          if (v77 && (v78 = v77, CFTypeID v79 = CFArrayGetTypeID(), v79 == CFGetTypeID(v78)))
          {
            FigVideoCompositionInstructionEvaluateTweenedCropRectangle((uint64_t)v78, v26);
            *(void *)(v36 + 128) = v80;
            *(void *)(v36 + 136) = v81;
            *(void *)(v36 + 144) = v82;
            *(void *)(v36 + 152) = v83;
            char v84 = 1;
          }
          else
          {
            char v84 = 0;
          }
          long long v33 = v339;
          char v59 = v84 | v73;
        }
        else
        {
          char v59 = 0;
          long long v33 = v339;
        }
        *(unsigned char *)(v36 + 328) = v59;
        updatedouble d = bvc_updateSourcebufferCharacteristics(v36);
        if (updated) {
          goto LABEL_384;
        }
        double v86 = (double)*(uint64_t *)(v36 + 184);
        double v87 = (double)*(uint64_t *)(v36 + 192);
        long long v88 = *(_OWORD *)(v36 + 48);
        *(_OWORD *)&t1.CGFloat a = *v47;
        *(_OWORD *)&t1.double c = v88;
        *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)(v36 + 64);
        CGAffineTransformScale(&v373, &t1, v86 / v87, 1.0);
        long long v90 = *(_OWORD *)&v373.c;
        long long v89 = *(_OWORD *)&v373.tx;
        *uint64_t v47 = *(_OWORD *)&v373.a;
        *(_OWORD *)(v36 + 48) = v90;
        *(_OWORD *)(v36 + 64) = v89;
        *(double *)&long long v89 = -*(double *)(v36 + 232);
        CGFloat v91 = -*(double *)(v36 + 240);
        long long v92 = *(_OWORD *)(v36 + 48);
        *(_OWORD *)&t1.CGFloat a = *v47;
        *(_OWORD *)&t1.double c = v92;
        *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)(v36 + 64);
        CGAffineTransformTranslate(&v373, &t1, *(CGFloat *)&v89, v91);
        long long v94 = *(_OWORD *)&v373.c;
        long long v93 = *(_OWORD *)&v373.tx;
        *uint64_t v47 = *(_OWORD *)&v373.a;
        *(_OWORD *)(v36 + 48) = v94;
        *(_OWORD *)(v36 + 64) = v93;
        CGAffineTransformMakeScale(&v363, *(float *)(v323 + 80), *(float *)(v323 + 80));
        long long v95 = *v47;
        long long v96 = *(_OWORD *)(v36 + 64);
        *(_OWORD *)&t1.double c = *(_OWORD *)(v36 + 48);
        *(_OWORD *)&t1.tCGFloat x = v96;
        CGAffineTransform t2 = v363;
        *(_OWORD *)&t1.CGFloat a = v95;
        CGAffineTransformConcat(&v373, &t1, &t2);
        long long v98 = *(_OWORD *)&v373.c;
        long long v97 = *(_OWORD *)&v373.tx;
        *uint64_t v47 = *(_OWORD *)&v373.a;
        *(_OWORD *)(v36 + 48) = v98;
        *(_OWORD *)(v36 + 64) = v97;
        long long v99 = *v47;
        long long v100 = *(_OWORD *)(v36 + 64);
        *(_OWORD *)&t1.double c = *(_OWORD *)(v36 + 48);
        *(_OWORD *)&t1.tCGFloat x = v100;
        long long v101 = *(_OWORD *)&v321->data;
        *(_OWORD *)&t2.CGFloat a = *(_OWORD *)&v321->isa;
        *(_OWORD *)&t2.double c = v101;
        *(_OWORD *)&t2.tCGFloat x = *(_OWORD *)&v321[1].isa;
        *(_OWORD *)&t1.CGFloat a = v99;
        CGAffineTransformConcat(&v373, &t1, &t2);
        long long v103 = *(_OWORD *)&v373.c;
        long long v102 = *(_OWORD *)&v373.tx;
        *uint64_t v47 = *(_OWORD *)&v373.a;
        *(_OWORD *)(v36 + 48) = v103;
        *(_OWORD *)(v36 + 64) = v102;
        float v104 = *(float *)(v36 + 24);
        float v105 = 0.0;
        if (v104 <= 0.0 || (float v105 = 1.0, v104 >= 1.0)) {
          *(float *)(v36 + 24) = v105;
        }
        updatedouble d = bvc_computeScaledTransformAndTransformedRect(*(void *)(v323 + 16), *(void *)(v323 + 24), *(const __CFDictionary **)(v323 + 160), v36);
        CFIndex v34 = v308;
        if (updated)
        {
LABEL_384:
          uint64_t v107 = updated;
          uint64_t v15 = v323;
          goto LABEL_361;
        }
        uint64_t v35 = count + 1;
        v36 += 352;
LABEL_73:
        if (++v34 == v31)
        {
          uint64_t v15 = v323;
          goto LABEL_80;
        }
      }
    }
    uint64_t v35 = 0;
  }
  else
  {
    int64_t v31 = 0;
    uint64_t v35 = 0;
    long long v33 = 0;
  }
LABEL_80:
  if (*(void *)(v15 + 176) != v31)
  {
    bvc_releaseLayerArrays();
    CFTypeRef v108 = (void *)CMBaseObjectGetDerivedStorage();
    v108[22] = v31;
    long long v109 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL);
    v108[23] = v109;
    if (!v109) {
      goto LABEL_377;
    }
    CFTypeRef v110 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL);
    v108[24] = v110;
    if (!v110) {
      goto LABEL_377;
    }
    unsigned int v111 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL);
    v108[25] = v111;
    if (!v111) {
      goto LABEL_377;
    }
    BOOL v112 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL);
    v108[26] = v112;
    if (!v112) {
      goto LABEL_377;
    }
    int v113 = malloc_type_calloc(v31, 4uLL, 0x100004052888210uLL);
    v108[27] = v113;
    if (!v113
      || (int v114 = malloc_type_calloc(v31, 0x20uLL, 0x1000040E0EAB150uLL), (v108[28] = v114) == 0)
      || (int v115 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL), (v108[29] = v115) == 0)
      || (int v116 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL), (v108[30] = v116) == 0))
    {
LABEL_377:
      uint64_t v307 = FigSignalErrorAt();
      if (v307)
      {
LABEL_382:
        uint64_t v107 = v307;
        goto LABEL_361;
      }
    }
  }
  countCGFloat a = v35;
  v340 = v33;
  if (v35 >= 1)
  {
    uint64_t v117 = 0;
    CFStringRef v322 = (const __CFString *)*MEMORY[0x1E4F24B98];
    v313 = *(void **)(MEMORY[0x1E4F1DB28] + 8);
    v314 = *(void **)MEMORY[0x1E4F1DB28];
    theArrayCGFloat a = *(CFArrayRef *)(MEMORY[0x1E4F1DB28] + 24);
    v312 = *(void **)(MEMORY[0x1E4F1DB28] + 16);
    long long v118 = (char *)v35;
    while (1)
    {
      uint64_t v119 = (uint64_t)&v33[v117];
      CMTimeValue v120 = *(__CVBuffer **)v119;
      if (*(void *)v119) {
        break;
      }
LABEL_193:
      v117 += 352;
      --v118;
      long long v33 = v340;
      if (!v118) {
        goto LABEL_197;
      }
    }
    v325 = v118;
    int v121 = *(unsigned __int8 *)(v119 + 329);
    int v122 = *(unsigned __int8 *)(v119 + 328);
    float v324 = *(float *)(v15 + 80);
    CFDictionaryRef v123 = *(const __CFDictionary **)(v15 + 160);
    CGAffineTransform v354 = *(CGAffineTransform *)(v119 + 32);
    CGFloat v125 = *(double *)(v119 + 264);
    CGFloat v124 = *(double *)(v119 + 272);
    CGFloat v126 = *(double *)(v119 + 280);
    CGFloat v127 = *(double *)(v119 + 288);
    CGFloat v128 = *(double *)(v119 + 200);
    CGFloat v129 = *(double *)(v119 + 208);
    CGFloat v130 = *(double *)(v119 + 216);
    CGFloat v131 = *(double *)(v119 + 224);
    unint64_t v328 = *(void *)(v15 + 16);
    keCGFloat y = v123;
    v326 = *(void **)(v15 + 24);
    CGAffineTransform v373 = v354;
    uint64_t v369 = 0;
    memset(&r2, 0, sizeof(r2));
    double v367 = 0.0;
    double v366 = 0.0;
    double v365 = 0.0;
    size_t Width = CVPixelBufferGetWidth(v120);
    size_t Height = CVPixelBufferGetHeight(v120);
    CFTypeRef v134 = CVBufferCopyAttachment(v120, v322, 0);
    FigVideoCompositorUtilityGetPixelAspectRatio((CFTypeID)v134, (_DWORD *)&v369 + 1, &v369);
    uint64_t v347 = SHIDWORD(v369);
    uint64_t v135 = (int)v369;
    if (v122)
    {
      r1CGFloat a = v127;
      double v136 = (double)Width;
      double v137 = (double)Height;
      double v333 = 0.0;
      double v337 = 0.0;
      int v138 = v134;
      double v139 = v124;
      uint64_t v140 = (int)v369;
      double v141 = v125;
      double v142 = v126;
      int v143 = v121;
    }
    else
    {
      CGAffineTransform t2 = v373;
      CGAffineTransformInvert(&t1, &t2);
      v377.origin.CGFloat x = v128;
      v377.origin.CGFloat y = v129;
      v377.size.double width = v130;
      v377.size.double height = v131;
      CGRect v378 = CGRectApplyAffineTransform(v377, &t1);
      v391.origin.CGFloat x = v125;
      r1double b = v124;
      v391.origin.CGFloat y = v124;
      v391.size.double width = v126;
      CGFloat v144 = v127;
      v391.size.double height = v127;
      CGRect v379 = CGRectIntersection(v378, v391);
      CGRect v380 = CGRectStandardize(v379);
      CGFloat x = v380.origin.x;
      CGFloat y = v380.origin.y;
      CGFloat v147 = v380.size.width;
      CGFloat v148 = v380.size.height;
      OSType v149 = (CVPixelBufferGetPixelFormatType(v120) - 875704422) & 0xFFFFFFEF;
      v381.origin.CGFloat x = x;
      v381.origin.CGFloat y = y;
      v381.size.double width = v147;
      v381.size.double height = v148;
      CGRect v382 = CGRectIntegral(v381);
      double v333 = v382.origin.x;
      double v337 = v382.origin.y;
      double v136 = v382.size.width;
      double v137 = v382.size.height;
      if (!v149)
      {
        if ((int)v382.origin.x) {
          double v150 = v382.origin.x + -1.0;
        }
        else {
          double v150 = v382.origin.x;
        }
        if ((int)v382.origin.x) {
          double v151 = v382.size.width + 1.0;
        }
        else {
          double v151 = v382.size.width;
        }
        double v152 = v382.origin.y;
        if ((int)v382.origin.y) {
          double v152 = v382.origin.y + -1.0;
        }
        double v333 = v150;
        double v337 = v152;
        if ((int)v382.origin.y) {
          double v153 = v382.size.height + 1.0;
        }
        else {
          double v153 = v382.size.height;
        }
        if ((int)v151) {
          double v136 = v151 + 1.0;
        }
        else {
          double v136 = v151;
        }
        if ((int)v153) {
          double v137 = v153 + 1.0;
        }
        else {
          double v137 = v153;
        }
      }
      int v138 = v134;
      int v143 = v121;
      v383.origin.CGFloat x = v125;
      v383.origin.CGFloat y = r1b;
      v383.size.double width = v126;
      v383.size.double height = v144;
      v392.origin.CGFloat x = v333;
      v392.origin.CGFloat y = v337;
      v392.size.double width = v136;
      v392.size.double height = v137;
      CGRect v384 = CGRectIntersection(v383, v392);
      double v142 = v384.size.width;
      r1CGFloat a = v384.size.height;
      double v141 = v384.origin.x - v333;
      double v139 = v384.origin.y - v337;
      CGAffineTransform v370 = v373;
      CGAffineTransformTranslate(&t2, &v370, v333, v337);
      CGAffineTransform v373 = t2;
      size_t Width = (uint64_t)v136;
      size_t Height = (uint64_t)v137;
      uint64_t v140 = v135;
    }
    long long v118 = v325;
    if (v143)
    {
      CGAffineTransform v370 = v373;
      CGAffineTransformScale(&t2, &v370, (float)(1.0 / v324), (float)(1.0 / v324));
      CGAffineTransform v373 = t2;
      double v154 = v324;
      double v367 = v324;
      double v366 = v324;
      double v155 = v324;
    }
    else
    {
      CGAffineTransform t2 = v373;
      FigVideoCompositionInstructionCGAffineTransformDecompose(&t2, 0, 0, &v373, &v367, &v366, 0);
      double b = 0.0;
      double v157 = 0.0;
      if (fabs(v373.a) >= 0.000001)
      {
        double v157 = 1.0;
        if (fabs(v373.a + -1.0) >= 0.000001)
        {
          double v157 = v373.a;
          if (fabs(v373.a + 1.0) < 0.000001) {
            double v157 = -1.0;
          }
        }
      }
      v373.CGFloat a = v157;
      if (fabs(v373.b) >= 0.000001)
      {
        double b = 1.0;
        if (fabs(v373.b + -1.0) >= 0.000001)
        {
          double b = v373.b;
          if (fabs(v373.b + 1.0) < 0.000001) {
            double b = -1.0;
          }
        }
      }
      v373.double b = b;
      double d = 0.0;
      double c = 0.0;
      if (fabs(v373.c) >= 0.000001)
      {
        double c = 1.0;
        if (fabs(v373.c + -1.0) >= 0.000001)
        {
          double c = v373.c;
          if (fabs(v373.c + 1.0) < 0.000001) {
            double c = -1.0;
          }
        }
      }
      v373.double c = c;
      if (fabs(v373.d) >= 0.000001)
      {
        double d = 1.0;
        if (fabs(v373.d + -1.0) >= 0.000001)
        {
          double d = v373.d;
          if (fabs(v373.d + 1.0) < 0.000001) {
            double d = -1.0;
          }
        }
      }
      v373.double d = d;
      double v155 = v367;
      double v154 = v366;
    }
    if (fabs(v155 + -1.0) <= 0.00001 && fabs(v154 + -1.0) <= 0.00001)
    {
      CGFloat v162 = v141;
      double v163 = v136;
      if (v143) {
        goto LABEL_135;
      }
    }
    else
    {
      float v160 = v155;
      size_t Width = (unint64_t)(v160 * v136 + 1.0) & 0xFFFFFFFFFFFFFFFELL;
      float v161 = v154;
      size_t Height = (unint64_t)(v161 * v137 + 1.0) & 0xFFFFFFFFFFFFFFFELL;
      CGAffineTransformMakeScale(&t2, (double)Width / v136, (double)Height / v137);
      CGAffineTransform v370 = t2;
      v385.origin.CGFloat x = v141;
      v385.origin.CGFloat y = v139;
      v385.size.double width = v142;
      v385.size.double height = r1a;
      CGRect v386 = CGRectApplyAffineTransform(v385, &v370);
      CGFloat v162 = v386.origin.x;
      double v139 = v386.origin.y;
      double v142 = v386.size.width;
      r1CGFloat a = v386.size.height;
      double v163 = v136;
      uint64_t v347 = (uint64_t)(v136 * (double)Height * (double)(int)v347);
      uint64_t v140 = (uint64_t)(v137 * (double)Width * (double)(int)v140);
      if (v143)
      {
LABEL_135:
        double v164 = v163;
        double v165 = v162;
        goto LABEL_186;
      }
    }
    CGAffineTransform v370 = v373;
    memset(&t2, 0, sizeof(t2));
    FigVideoCompositionInstructionCGAffineTransformDecompose(&v370, 0, 1, &t2, 0, 0, &v365);
    double v166 = fmod(v365 * 57.2957795 + 360.0, 360.0);
    double v167 = 0.0;
    double v164 = v163;
    if (fabs(v166) < 0.001)
    {
      double v168 = v162;
      double v165 = v139;
      goto LABEL_139;
    }
    double v167 = 90.0;
    double v168 = v162;
    double v165 = v139;
    if (fabs(v166 + -90.0) >= 0.001)
    {
      if (fabs(v166 + -180.0) >= 0.001)
      {
        if (fabs(v166 + -270.0) >= 0.001)
        {
          double v167 = v166;
          if (fabs(v166 + -360.0) < 0.001) {
            double v167 = 0.0;
          }
LABEL_139:
          double v365 = v167;
          BOOL v169 = v167 == 90.0;
          BOOL v170 = v167 == 270.0;
          if (v167 != 270.0 && v167 != 90.0 && v167 != 180.0)
          {
            double v365 = 0.0;
            double v171 = r1a;
            double v139 = v165;
            double v165 = v168;
            uint64_t v172 = v140;
            uint64_t v140 = v347;
            size_t v173 = Height;
            size_t Height = Width;
LABEL_185:
            size_t Width = Height;
            uint64_t v347 = v140;
            r1CGFloat a = v171;
            uint64_t v140 = v172;
            size_t Height = v173;
LABEL_186:
            bvc_getCleanApertureRect(key, v328, (unint64_t)v326, &r2.origin.x);
            int v182 = v181;
            if (!v181)
            {
              CGAffineTransform t2 = v373;
              v387.origin.CGFloat x = v165;
              v387.origin.CGFloat y = v139;
              v387.size.double width = v142;
              v387.size.double height = r1a;
              CGRect v388 = CGRectApplyAffineTransform(v387, &t2);
              CGRect v389 = CGRectIntersection(v388, r2);
              CGRect v390 = CGRectStandardize(v389);
              long long v184 = *(_OWORD *)&v373.c;
              long long v183 = *(_OWORD *)&v373.tx;
              *(_OWORD *)(v119 + 80) = *(_OWORD *)&v373.a;
              *(_OWORD *)(v119 + 96) = v184;
              *(void *)(v119 + 160) = Width;
              __int16 v185 = &v340[v117];
              *((void *)v185 + 21) = Height;
              *(double *)(v119 + 296) = v333;
              *((double *)v185 + 38) = v337;
              *((double *)v185 + 39) = v164;
              *((double *)v185 + 40) = v137;
              int v186 = (int)v365;
              *(_OWORD *)(v119 + 112) = v183;
              *(_DWORD *)(v119 + 176) = v186;
              *(void *)(v119 + 184) = v347;
              *((void *)v185 + 24) = v140;
              *(double *)(v119 + 264) = v165;
              *(double *)(v119 + 272) = v139;
              *(double *)(v119 + 280) = v142;
              *(double *)(v119 + 288) = r1a;
              *(CGRect *)(v119 + 200) = v390;
            }
            if (v138) {
              CFRelease(v138);
            }
            uint64_t v15 = v323;
            if (v182)
            {
              CFDictionaryRef v187 = *(const __CFDictionary **)(v323 + 160);
              unint64_t v188 = *(void *)(v323 + 16);
              unint64_t v189 = *(void *)(v323 + 24);
              uint64_t v190 = bvc_updateSourcebufferCharacteristics(v119);
              if (v190
                || (uint64_t v190 = bvc_computeScaledTransformAndTransformedRect(v188, v189, v187, v119), v190))
              {
                uint64_t v107 = v190;
                v255 = 0;
                CFDictionaryRef v271 = 0;
                v272 = 0;
                v273 = 0;
                v274 = 0;
                long long v33 = v340;
                goto LABEL_362;
              }
            }
            goto LABEL_193;
          }
LABEL_149:
          double v174 = 0.0;
          double v175 = 0.0;
          if (fabs(t2.a) >= 0.000001)
          {
            double v175 = 1.0;
            if (fabs(t2.a + -1.0) >= 0.000001)
            {
              double v175 = t2.a;
              if (fabs(t2.a + 1.0) < 0.000001) {
                double v175 = -1.0;
              }
            }
          }
          v373.CGFloat a = v175;
          if (fabs(t2.b) >= 0.000001)
          {
            double v174 = 1.0;
            if (fabs(t2.b + -1.0) >= 0.000001)
            {
              double v174 = t2.b;
              if (fabs(t2.b + 1.0) < 0.000001) {
                double v174 = -1.0;
              }
            }
          }
          v373.double b = v174;
          double v176 = 0.0;
          double v177 = 0.0;
          if (fabs(t2.c) >= 0.000001)
          {
            double v177 = 1.0;
            if (fabs(t2.c + -1.0) >= 0.000001)
            {
              double v177 = t2.c;
              if (fabs(t2.c + 1.0) < 0.000001) {
                double v177 = -1.0;
              }
            }
          }
          v373.double c = v177;
          if (fabs(t2.d) >= 0.000001)
          {
            double v176 = 1.0;
            if (fabs(t2.d + -1.0) >= 0.000001)
            {
              double v176 = t2.d;
              if (fabs(t2.d + 1.0) < 0.000001) {
                double v176 = -1.0;
              }
            }
          }
          v373.double d = v176;
          int v178 = (int)v167;
          if ((int)v167 > 179)
          {
            if (v178 != 180)
            {
              if (v178 == 270)
              {
                double v139 = (double)Width - v142 - v168;
                double v171 = v142;
                double v142 = r1a;
                goto LABEL_175;
              }
              goto LABEL_172;
            }
            double v139 = (double)Height - r1a - v165;
            double v165 = (double)Width - v142 - v168;
            double v171 = r1a;
          }
          else
          {
            if (v178)
            {
              if (v178 == 90)
              {
                double v165 = (double)Height - r1a - v165;
                double v171 = v142;
                double v142 = r1a;
                double v139 = v168;
                goto LABEL_175;
              }
LABEL_172:
              double v171 = *(double *)&theArraya;
              double v142 = *(double *)&v312;
              double v139 = *(double *)&v313;
              double v165 = *(double *)&v314;
              goto LABEL_175;
            }
            double v171 = r1a;
            double v139 = v165;
            double v165 = v168;
          }
LABEL_175:
          if (v170 || v169)
          {
            uint64_t v172 = v347;
            size_t v173 = Width;
          }
          else
          {
            uint64_t v172 = v140;
            uint64_t v140 = v347;
            size_t v173 = Height;
            size_t Height = Width;
          }
          switch(v178)
          {
            case 270:
              double v180 = (double)-(uint64_t)v173;
              CGAffineTransform valuePtr = v373;
              double v179 = 0.0;
              break;
            case 180:
              double v179 = (double)-(uint64_t)Height;
              double v180 = (double)-(uint64_t)v173;
              CGAffineTransform valuePtr = v373;
              break;
            case 90:
              double v179 = (double)-(uint64_t)Height;
              CGAffineTransform valuePtr = v373;
              double v180 = 0.0;
              break;
            default:
              goto LABEL_185;
          }
          CGAffineTransformTranslate(&v370, &valuePtr, v179, v180);
          CGAffineTransform v373 = v370;
          goto LABEL_185;
        }
        double v167 = 270.0;
      }
      else
      {
        double v167 = 180.0;
      }
    }
    double v365 = v167;
    BOOL v169 = v167 == 90.0;
    BOOL v170 = v167 == 270.0;
    goto LABEL_149;
  }
LABEL_197:
  CMTime v191 = v360;
  uint64_t v192 = CMBaseObjectGetDerivedStorage();
  uint64_t v193 = counta;
  CFTypeRef v194 = (uint64_t *)malloc_type_calloc(counta, 8uLL, 0x100004000313F17uLL);
  v338 = v194;
  if (!v194)
  {
    uint64_t v307 = FigSignalErrorAt();
    if (!v307)
    {
      uint64_t v199 = 0;
      keyCGFloat a = 1;
      goto LABEL_250;
    }
    goto LABEL_382;
  }
  r1double c = counta - 1;
  if (counta < 1)
  {
    uint64_t v199 = 0;
    int v200 = 3;
    keyCGFloat a = 1;
    goto LABEL_249;
  }
  uint64_t v195 = v194;
  uint64_t v196 = 0;
  v197 = v33 + 160;
  while (1)
  {
    float v198 = *((float *)v197 - 34);
    if (v198 != 0.0) {
      break;
    }
    ++v196;
    v197 += 352;
    if (counta == v196) {
      goto LABEL_205;
    }
  }
  if (v198 == 1.0)
  {
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType(*((CVPixelBufferRef *)v197 - 20));
    BOOL v299 = PixelFormatType == 846624121 || PixelFormatType == 875704438;
    if (v299 || PixelFormatType == 875704422)
    {
      long long v301 = *((_OWORD *)v197 - 5);
      long long v302 = *((_OWORD *)v197 - 3);
      *(_OWORD *)&v373.double c = *((_OWORD *)v197 - 4);
      *(_OWORD *)&v373.tCGFloat x = v302;
      *(_OWORD *)&v373.CGFloat a = v301;
      if (CGAffineTransformIsIdentity(&v373))
      {
        bvc_doesPixelBufferFillCanvasExactly(*(void *)v197, *((void *)v197 + 1), *(void *)(v192 + 16), *(void *)(v192 + 24), *(const __CFDictionary **)(v192 + 160), *((CGFloat *)v197 + 13), *((CGFloat *)v197 + 14), *((CGFloat *)v197 + 15), *((CGFloat *)v197 + 16));
        if (v303)
        {
          keyCGFloat a = 0;
          *uint64_t v195 = v196;
          uint64_t v199 = 1;
          int v200 = 1;
          goto LABEL_249;
        }
      }
    }
  }
LABEL_205:
  uint64_t v201 = 0;
  uint64_t v202 = 0;
  v203 = 0;
  v204 = v33;
  while (1)
  {
    float v205 = *((float *)v204 + 6);
    if (v205 != 0.0) {
      break;
    }
    v206 = v203;
    uint64_t v207 = v202;
LABEL_209:
    ++v201;
    v204 += 352;
    uint64_t v202 = v207;
    v203 = v206;
    if (counta == v201) {
      goto LABEL_210;
    }
  }
  v206 = v204;
  uint64_t v207 = v201;
  if (!v203) {
    goto LABEL_209;
  }
  if (v205 == 1.0)
  {
    OSType v288 = CVPixelBufferGetPixelFormatType(*(CVPixelBufferRef *)v204);
    BOOL v289 = v288 == 846624121 || v288 == 875704438;
    if (v289 || v288 == 875704422)
    {
      long long v291 = *((_OWORD *)v203 + 6);
      *(_OWORD *)&v373.CGFloat a = *((_OWORD *)v203 + 5);
      *(_OWORD *)&v373.double c = v291;
      *(_OWORD *)&v373.tCGFloat x = *((_OWORD *)v203 + 7);
      if (CGAffineTransformIsIdentity(&v373))
      {
        long long v292 = *((_OWORD *)v204 + 5);
        long long v293 = *((_OWORD *)v204 + 7);
        *(_OWORD *)&v373.double c = *((_OWORD *)v204 + 6);
        *(_OWORD *)&v373.tCGFloat x = v293;
        *(_OWORD *)&v373.CGFloat a = v292;
        if (CGAffineTransformIsIdentity(&v373))
        {
          CGFloat v294 = (double)CVPixelBufferGetWidth(*(CVPixelBufferRef *)v203);
          v393.size.double height = (double)CVPixelBufferGetHeight(*(CVPixelBufferRef *)v203);
          v393.origin.CGFloat x = 0.0;
          v393.origin.CGFloat y = 0.0;
          v393.size.double width = v294;
          if (CGRectContainsRect(*(CGRect *)(v203 + 296), v393))
          {
            CGFloat v295 = (double)CVPixelBufferGetWidth(*(CVPixelBufferRef *)v204);
            v394.size.double height = (double)CVPixelBufferGetHeight(*(CVPixelBufferRef *)v204);
            v394.origin.CGFloat x = 0.0;
            v394.origin.CGFloat y = 0.0;
            v394.size.double width = v295;
            if (CGRectContainsRect(*(CGRect *)(v204 + 296), v394))
            {
              bvc_doesPixelBufferFillCanvasExactly(*((void *)v203 + 20), *((void *)v203 + 21), *(void *)(v192 + 16), *(void *)(v192 + 24), *(const __CFDictionary **)(v192 + 160), *((CGFloat *)v203 + 33), *((CGFloat *)v203 + 34), *((CGFloat *)v203 + 35), *((CGFloat *)v203 + 36));
              if (v296)
              {
                bvc_doesPixelBufferFillCanvasExactly(*((void *)v204 + 20), *((void *)v204 + 21), *(void *)(v192 + 16), *(void *)(v192 + 24), *(const __CFDictionary **)(v192 + 160), *((CGFloat *)v204 + 33), *((CGFloat *)v204 + 34), *((CGFloat *)v204 + 35), *((CGFloat *)v204 + 36));
                if (v297)
                {
                  keyCGFloat a = 0;
                  uint64_t *v338 = v202;
                  v338[1] = v201;
                  uint64_t v199 = 2;
                  int v200 = 2;
                  goto LABEL_249;
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_210:
  v334 = v191;
  v208 = (CVPixelBufferRef *)&v33[352 * counta];
  keyCGFloat a = 1;
  int8x16_t v348 = (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFFELL);
  uint64_t v209 = counta - 1;
  do
  {
    v210 = v208;
    v208 -= 44;
    if (((CVPixelBufferGetPixelFormatType(*v208) - 875704422) & 0xFFFFFFEF) == 0) {
      *((int8x16_t *)v210 - 12) = vandq_s8(*((int8x16_t *)v210 - 12), v348);
    }
    if (*((float *)v210 - 82) == 1.0)
    {
      OSType v211 = CVPixelBufferGetPixelFormatType(*v208);
      BOOL v212 = v211 == 846624121 || v211 == 875704438;
      if (v212 || v211 == 875704422)
      {
        CFDictionaryRef v214 = *(const __CFDictionary **)(v192 + 160);
        double v215 = *((double *)v210 - 11);
        double v216 = *((double *)v210 - 10);
        double v217 = *((double *)v210 - 9);
        double v218 = *((double *)v210 - 8);
        unint64_t v219 = *(void *)(v192 + 16);
        unint64_t v220 = *(void *)(v192 + 24);
        long long v221 = *((_OWORD *)v210 - 17);
        long long v222 = *((_OWORD *)v210 - 15);
        *(_OWORD *)&v370.double c = *((_OWORD *)v210 - 16);
        *(_OWORD *)&v370.tCGFloat x = v222;
        *(_OWORD *)&v370.CGFloat a = v221;
        memset(&valuePtr, 0, 32);
        long long v223 = *((_OWORD *)v210 - 17);
        long long v224 = *((_OWORD *)v210 - 15);
        *(_OWORD *)&t1.double c = *((_OWORD *)v210 - 16);
        *(_OWORD *)&t1.tCGFloat x = v224;
        *(_OWORD *)&t1.CGFloat a = v223;
        if (BVCUtilityIsAffineTransformInvertible(&t1.a))
        {
          bvc_getCleanApertureRect(v214, v219, v220, &valuePtr.a);
          if (!v225)
          {
            CGAffineTransform t1 = v370;
            if (BVCUtilityIsAffineTransformInvertible(&t1.a))
            {
              CGAffineTransform t2 = v370;
              CGAffineTransformInvert(&t1, &t2);
              uint64_t v226 = 0;
              v373.CGFloat a = t1.tx + t1.c * valuePtr.b + t1.a * valuePtr.a;
              v373.double b = t1.ty + t1.d * valuePtr.b + t1.b * valuePtr.a;
              CGFloat v227 = t1.c * (valuePtr.b + valuePtr.d);
              CGFloat v228 = t1.d * (valuePtr.b + valuePtr.d);
              v373.double c = t1.tx + v227 + t1.a * valuePtr.a;
              v373.double d = t1.ty + v228 + t1.b * valuePtr.a;
              v373.tCGFloat x = t1.tx + v227 + t1.a * (valuePtr.a + valuePtr.c);
              v373.tCGFloat y = t1.ty + v228 + t1.b * (valuePtr.a + valuePtr.c);
              double v374 = t1.tx + t1.c * valuePtr.b + t1.a * (valuePtr.a + valuePtr.c);
              double v375 = t1.ty + t1.d * valuePtr.b + t1.b * (valuePtr.a + valuePtr.c);
              while (1)
              {
                double v229 = *(double *)((char *)&v373.a + v226);
                BOOL v230 = v229 >= v215 && v229 <= v215 + v217;
                if (!v230) {
                  break;
                }
                double v231 = *(double *)((char *)&v373.b + v226);
                if (v231 < v216 || v231 > v216 + v218) {
                  break;
                }
                v226 += 16;
                if (v226 == 64)
                {
                  keyCGFloat a = 0;
                  ++*(_DWORD *)(v192 + 372);
                  r1double c = v209;
                  break;
                }
              }
            }
          }
        }
      }
    }
    BOOL v230 = v209-- <= 0;
  }
  while (!v230);
  if (r1c < 0)
  {
    uint64_t v199 = 0;
    int v200 = 3;
    uint64_t v15 = v323;
    long long v33 = v340;
    uint64_t v193 = counta;
    CMTime v191 = v334;
  }
  else
  {
    uint64_t v199 = 0;
    uint64_t v233 = 0;
    long long v33 = v340;
    v234 = v340 + 224;
    uint64_t v15 = v323;
    uint64_t v193 = counta;
    CMTime v191 = v334;
    do
    {
      if (*((float *)v234 - 50) != 0.0)
      {
        long long v235 = *((_OWORD *)v234 - 9);
        long long v236 = *((_OWORD *)v234 - 7);
        *(_OWORD *)&v373.double c = *((_OWORD *)v234 - 8);
        *(_OWORD *)&v373.tCGFloat x = v236;
        *(_OWORD *)&v373.CGFloat a = v235;
        if (BVCUtilityIsAffineTransformInvertible(&v373.a) && !CGRectIsEmpty(*(CGRect *)(v234 - 24))) {
          v338[v199++] = v233;
        }
      }
      ++v233;
      v234 += 352;
    }
    while (r1c + 1 != v233);
    int v200 = 3;
  }
LABEL_249:
  *((_DWORD *)v191 + 6) = v200;
LABEL_250:
  uint64_t v237 = v199;
  if (v193 >= 1)
  {
    v238 = (CVBufferRef *)&v33[352 * v193 - 352];
    goto LABEL_253;
  }
  v238 = v316;
  if (a2 < 1)
  {
LABEL_257:
    BOOL v241 = 0;
    CFDictionaryRef v239 = 0;
    v240 = *(const void **)(v15 + 56);
    goto LABEL_258;
  }
LABEL_253:
  if (!*v238) {
    goto LABEL_257;
  }
  CFDictionaryRef v239 = CVBufferCopyAttachments(*v238, kCVAttachmentMode_ShouldPropagate);
  v240 = *(const void **)(v15 + 56);
  BOOL v241 = v239 != 0;
  if (!v240 && v239)
  {
    v240 = CFDictionaryGetValue(v239, (const void *)*MEMORY[0x1E4F24C18]);
    BOOL v241 = 1;
  }
LABEL_258:
  if (v240) {
    v242 = v240;
  }
  else {
    v242 = (const void *)*MEMORY[0x1E4F24C48];
  }
  if (v242) {
    CFRetain(v242);
  }
  v243 = *(const void **)(v15 + 64);
  if (v243) {
    BOOL v244 = 0;
  }
  else {
    BOOL v244 = v241;
  }
  if (v244) {
    v243 = CFDictionaryGetValue(v239, (const void *)*MEMORY[0x1E4F24A90]);
  }
  if (v243) {
    v245 = v243;
  }
  else {
    v245 = (const void *)*MEMORY[0x1E4F24AB0];
  }
  if (v245) {
    CFRetain(v245);
  }
  v246 = *(const void **)(v15 + 72);
  if (v246) {
    BOOL v247 = 0;
  }
  else {
    BOOL v247 = v241;
  }
  if (v247) {
    v246 = CFDictionaryGetValue(v239, (const void *)*MEMORY[0x1E4F24BC8]);
  }
  r1double d = v245;
  v349 = v242;
  CFDictionaryRef v329 = v239;
  if (v246) {
    v248 = v246;
  }
  else {
    v248 = (const void *)*MEMORY[0x1E4F24BE0];
  }
  if (v248) {
    CFRetain(v248);
  }
  uint64_t v15 = v323;
  uint64_t v335 = v237;
  if (v237)
  {
    uint64_t v249 = MEMORY[0x1E4F143A8];
    uint64_t v251 = v237;
    v250 = v338;
    do
    {
      uint64_t v252 = *v250++;
      v254 = *(NSObject **)(v323 + 280);
      v253 = *(NSObject **)(v323 + 288);
      block[0] = v249;
      block[1] = 0x40000000;
      block[2] = __basicVideoCompositor_RenderFrame_block_invoke;
      block[3] = &unk_1E57A2298;
      void block[7] = cf;
      block[8] = v323;
      void block[9] = v242;
      block[10] = r1d;
      block[11] = v248;
      block[4] = &v359;
      void block[5] = &v355;
      block[6] = &v340[352 * v252];
      dispatch_group_async(v253, v254, block);
      --v251;
    }
    while (v251);
  }
  dispatch_group_wait(*(dispatch_group_t *)(v323 + 288), 0xFFFFFFFFFFFFFFFFLL);
  if (*((unsigned char *)v356 + 24)) {
    *((_DWORD *)v360 + 6) = 3;
  }
  long long v33 = v340;
  uint64_t v256 = v237;
  v255 = v338;
  if (!v335)
  {
    if (*((_DWORD *)v360 + 6) != 1) {
      goto LABEL_307;
    }
    goto LABEL_302;
  }
  uint64_t v258 = *(void *)(v323 + 392);
  uint64_t v257 = *(void *)(v323 + 400);
  v259 = v338;
  uint64_t v260 = v335;
  uint64_t v261 = *(void *)(v323 + 384);
  do
  {
    uint64_t v262 = *v259++;
    uint64_t v263 = (*(void *)&v340[352 * v262 + 344] - *(void *)&v340[352 * v262 + 336]) / 1000;
    v257 += v263;
    if (v261 >= (int)v263) {
      uint64_t v261 = (int)v263;
    }
    if (v258 <= (int)v263) {
      uint64_t v258 = (int)v263;
    }
    --v260;
  }
  while (v260);
  *(_DWORD *)(v323 + 408) += v335;
  *(void *)(v323 + 392) = v258;
  *(void *)(v323 + 400) = v257;
  *(void *)(v323 + 384) = v261;
  if (*((_DWORD *)v360 + 6) == 1)
  {
LABEL_302:
    ++*(_DWORD *)(v323 + 360);
    CFTypeRef v268 = CFRetain(*(CFTypeRef *)&v340[352 * *v338]);
    if (*(unsigned char *)(v323 + 172))
    {
      v269 = *(const void **)(v323 + 104);
      if (v269)
      {
        CFRelease(v269);
        *(void *)(v323 + 104) = 0;
      }
    }
    dispatch_sync(*(dispatch_queue_t *)(v323 + 272), &__block_literal_global_24);
    v270 = *(NSObject **)(v323 + 272);
    v352[0] = MEMORY[0x1E4F143A8];
    v352[1] = 0x40000000;
    v352[2] = __basicVideoCompositor_RenderFrame_block_invoke_3;
    v352[3] = &__block_descriptor_tmp_25_3;
    v352[4] = v323;
    v352[5] = a10;
    v352[6] = v268;
    dispatch_async(v270, v352);
    uint64_t v107 = 0;
    CFDictionaryRef v271 = v329;
    v272 = v349;
LABEL_306:
    v273 = r1d;
    v274 = v248;
    goto LABEL_362;
  }
  v264 = v338;
  uint64_t v265 = v335;
  do
  {
    uint64_t v266 = *v264++;
    v267 = *(const void **)&v340[352 * v266];
    if (v267) {
      CFRetain(v267);
    }
    --v265;
  }
  while (v265);
LABEL_307:
  v275 = *(const void **)(v323 + 104);
  CFDictionaryRef v271 = v329;
  v272 = v349;
  if (v275)
  {
LABEL_327:
    CFTypeRef v286 = CFRetain(v275);
    goto LABEL_328;
  }
  uint64_t v276 = CMBaseObjectGetDerivedStorage();
  v373.CGFloat a = 0.0;
  t1.CGFloat a = 0.0;
  LODWORD(v354.a) = 0;
  LODWORD(r2.origin.x) = 0;
  LOBYTE(v367) = 0;
  CFAllocatorRef v277 = CFGetAllocator(cf);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v277, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  LODWORD(v370.a) = *(void *)(v276 + 16);
  CFAllocatorRef v279 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v280 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v370);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24E10], v280);
  CFRelease(v280);
  LODWORD(valuePtr.a) = *(void *)(v276 + 24);
  CFNumberRef v281 = CFNumberCreate(v279, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24D08], v281);
  CFRelease(v281);
  v282 = CFArrayCreateMutable(v279, 0, MEMORY[0x1E4F1D510]);
  if (!v282)
  {
    uint64_t PixelBufferAttributesWithIOSurfaceSupport = FigSignalErrorAt();
    goto LABEL_316;
  }
  LODWORD(t2.a) = *(_DWORD *)(v276 + 168);
  CFNumberRef v283 = CFNumberCreate(v279, kCFNumberSInt32Type, &t2);
  if (v283)
  {
    CFNumberRef v284 = v283;
    CFArrayAppendValue(v282, v283);
    CFRelease(v284);
    goto LABEL_311;
  }
  uint64_t v107 = FigSignalErrorAt();
  if (!v107)
  {
LABEL_311:
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24D70], v282);
    FigGetAlignmentForIOSurfaceOutput();
    uint64_t PixelBufferAttributesWithIOSurfaceSupport = bvc_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F24D78], SLODWORD(v354.a));
    if (!PixelBufferAttributesWithIOSurfaceSupport)
    {
      uint64_t PixelBufferAttributesWithIOSurfaceSupport = bvc_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F24C98], SLODWORD(r2.origin.x));
      if (!PixelBufferAttributesWithIOSurfaceSupport)
      {
        uint64_t PixelBufferAttributesWithIOSurfaceSupport = FigCreatePixelBufferAttributesWithIOSurfaceSupport();
        if (!PixelBufferAttributesWithIOSurfaceSupport)
        {
          uint64_t PixelBufferAttributesWithIOSurfaceSupport = VTCreatePixelBufferPoolAttributesWithName();
          if (!PixelBufferAttributesWithIOSurfaceSupport)
          {
            CFGetAllocator(cf);
            uint64_t PixelBufferAttributesWithIOSurfaceSupport = VTBuildPixelBufferPools2();
          }
        }
      }
    }
LABEL_316:
    uint64_t v107 = PixelBufferAttributesWithIOSurfaceSupport;
  }
  if (*(void *)&v373.a) {
    CFRelease(*(CFTypeRef *)&v373.a);
  }
  uint64_t v15 = v323;
  long long v33 = v340;
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (*(void *)&t1.a) {
    CFRelease(*(CFTypeRef *)&t1.a);
  }
  if (v282) {
    CFRelease(v282);
  }
  if (v107) {
    goto LABEL_306;
  }
  v275 = *(const void **)(v323 + 104);
  uint64_t v256 = v335;
  if (v275) {
    goto LABEL_327;
  }
  CFTypeRef v286 = 0;
LABEL_328:
  dispatch_sync(*(dispatch_queue_t *)(v15 + 264), &__block_literal_global_28_0);
  v287 = *(NSObject **)(v15 + 264);
  v350[0] = MEMORY[0x1E4F143A8];
  v350[1] = 0x40000000;
  v350[2] = __basicVideoCompositor_RenderFrame_block_invoke_5;
  v350[3] = &unk_1E57A2360;
  v350[6] = v286;
  v350[7] = v329;
  v350[8] = v15;
  v350[9] = v349;
  v350[10] = r1d;
  v350[11] = v248;
  v350[4] = &v359;
  v350[5] = cf;
  v350[12] = v338;
  v350[13] = v33;
  char v351 = keya;
  v350[14] = v256;
  v350[15] = v315;
  v350[16] = a10;
  dispatch_async(v287, v350);
  v255 = 0;
  CFDictionaryRef v271 = 0;
  v272 = 0;
  v273 = 0;
  v274 = 0;
  long long v33 = 0;
  uint64_t v107 = 0;
LABEL_362:
  if (*(void *)(v15 + 176))
  {
    unint64_t v304 = 0;
    do
    {
      CVPixelBufferPoolFlush(*(CVPixelBufferPoolRef *)(*(void *)(v15 + 184) + 8 * v304), 0);
      CVPixelBufferPoolFlush(*(CVPixelBufferPoolRef *)(*(void *)(v15 + 192) + 8 * v304++), 0);
    }
    while (v304 < *(void *)(v15 + 176));
  }
  v305 = *(__CVPixelBufferPool **)(v15 + 104);
  if (v305) {
    CVPixelBufferPoolFlush(v305, 0);
  }
  free(v33);
  free(v255);
  if (v271) {
    CFRelease(v271);
  }
  if (v272) {
    CFRelease(v272);
  }
  if (v273) {
    CFRelease(v273);
  }
  if (v274) {
    CFRelease(v274);
  }
LABEL_375:
  _Block_object_dispose(&v355, 8);
  _Block_object_dispose(&v359, 8);
  return v107;
}

uint64_t basicVideoCompositor_SetOutputCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  CFNumberRef v11 = &v10;
  uint64_t v12 = 0x2000000000;
  int v13 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = *(NSObject **)(DerivedStorage + 272);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  void v9[2] = __basicVideoCompositor_SetOutputCallback_block_invoke;
  v9[3] = &unk_1E57A23D8;
  v9[6] = a2;
  _OWORD v9[7] = a3;
  void v9[4] = &v10;
  v9[5] = DerivedStorage;
  dispatch_sync(v6, v9);
  uint64_t v7 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v7;
}

uint64_t bvc_updateSourcebufferCharacteristics(uint64_t a1)
{
  uint64_t v12 = 0;
  uint64_t v10 = 0;
  CFNumberRef v11 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v9 = 0;
  bvc_copyCVBufferProperties(*(__CVBuffer **)a1, &v11, &v10, (__CVBuffer **)&cf, (__CVBuffer **)&v9);
  FigVideoCompositorUtilityGetPixelAspectRatio((CFTypeID)cf, (_DWORD *)&v12 + 1, &v12);
  CFAllocatorRef v3 = v10;
  uint64_t v2 = v11;
  *(void *)(a1 + 160) = v11;
  *(void *)(a1 + 168) = v3;
  uint64_t v4 = (int)v12;
  *(void *)(a1 + 184) = SHIDWORD(v12);
  *(void *)(a1 + 192) = v4;
  bvc_getCleanApertureRect((const __CFDictionary *)v9, (unint64_t)v2, (unint64_t)v3, (double *)(a1 + 232));
  uint64_t v6 = v5;
  if (!v5)
  {
    v14.size.double width = *(CGFloat *)(a1 + 144);
    v14.size.double height = *(CGFloat *)(a1 + 152);
    CGRect v13 = *(CGRect *)(a1 + 232);
    v14.origin.CGFloat x = *(double *)(a1 + 128) + v13.origin.x;
    v14.origin.CGFloat y = *(double *)(a1 + 136) + v13.origin.y;
    *(CGRect *)(a1 + 264) = CGRectIntersection(v13, v14);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v9) {
    CFRelease(v9);
  }
  return v6;
}

uint64_t bvc_computeScaledTransformAndTransformedRect(unint64_t a1, unint64_t a2, const __CFDictionary *a3, uint64_t a4)
{
  memset(&v17, 0, sizeof(v17));
  bvc_getCleanApertureRect(a3, a1, a2, &v17.origin.x);
  uint64_t v6 = v5;
  if (!v5)
  {
    long long v7 = *(_OWORD *)(a4 + 48);
    long long v8 = *(_OWORD *)(a4 + 32);
    long long v9 = v7;
    *(_OWORD *)(a4 + 80) = v8;
    *(_OWORD *)(a4 + 96) = v7;
    *(_OWORD *)(a4 + 112) = *(_OWORD *)(a4 + 64);
    uint64_t v10 = *(void *)(a4 + 264);
    *(void *)&long long v7 = *(void *)(a4 + 272);
    uint64_t v11 = *(void *)(a4 + 280);
    uint64_t v12 = *(void *)(a4 + 288);
    *(_OWORD *)&v16.CGFloat a = v8;
    *(_OWORD *)&v16.double c = v9;
    *(_OWORD *)&v16.tCGFloat x = *(_OWORD *)(a4 + 64);
    CGRect v18 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v7 - 8), &v16);
    *(CGRect *)(a4 + 200) = v18;
    CGRect v19 = CGRectIntersection(v18, v17);
    *(CGRect *)(a4 + 200) = v19;
    *(CGRect *)(a4 + 200) = CGRectStandardize(v19);
    double Width = (double)CVPixelBufferGetWidth(*(CVPixelBufferRef *)a4);
    double Height = (double)CVPixelBufferGetHeight(*(CVPixelBufferRef *)a4);
    *(void *)(a4 + 296) = 0;
    *(void *)(a4 + 304) = 0;
    *(double *)(a4 + 312) = Width;
    *(double *)(a4 + 320) = Height;
  }
  return v6;
}

uint64_t bvc_mixBuffers(NSObject *a1, CVPixelBufferRef pixelBuffer, __CVBuffer *a3, __CVBuffer *a4, int a5, int a6, int a7, int a8, float a9, CGFloat a10, CGFloat a11, CGFloat a12, CGFloat a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  uint64_t v91 = 0;
  long long v92 = &v91;
  uint64_t v93 = 0x2000000000;
  int v94 = 0;
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  OSType v82 = CVPixelBufferGetPixelFormatType(a3);
  OSType v84 = CVPixelBufferGetPixelFormatType(a4);
  CFTypeRef v28 = CVBufferCopyAttachment(a4, (CFStringRef)*MEMORY[0x1E4F24C18], 0);
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  size_t Height = CVPixelBufferGetHeight(pixelBuffer);
  size_t v31 = CVPixelBufferGetWidth(a3);
  size_t v32 = CVPixelBufferGetHeight(a3);
  size_t v33 = CVPixelBufferGetWidth(a4);
  size_t v34 = CVPixelBufferGetHeight(a4);
  memset(v100, 0, sizeof(v100));
  memset(v99, 0, sizeof(v99));
  memset(v98, 0, sizeof(v98));
  memset(v97, 0, sizeof(v97));
  memset(v96, 0, sizeof(v96));
  memset(v95, 0, sizeof(v95));
  uint64_t v89 = 0;
  uint64_t v90 = 0;
  uint64_t v88 = 0;
  v108.size.double width = (double)Width;
  v108.size.double height = (double)Height;
  uint64_t v35 = v28;
  v108.origin.CGFloat x = 0.0;
  v108.origin.CGFloat y = 0.0;
  v102.origin.CGFloat x = a10;
  v102.origin.CGFloat y = a11;
  v102.size.double width = a12;
  v102.size.double height = a13;
  CGRect v103 = CGRectIntersection(v102, v108);
  double PixelRectangle = bvc_getPixelRectangle(v103.origin.x, v103.origin.y, v103.size.width, v103.size.height);
  double v79 = v37;
  double v80 = PixelRectangle;
  double v39 = v38;
  double v41 = v40;
  v109.size.double width = (double)v31;
  v109.size.double height = (double)v32;
  v109.origin.CGFloat x = 0.0;
  v109.origin.CGFloat y = 0.0;
  *(void *)&v104.origin.CGFloat x = a14;
  *(void *)&v104.origin.CGFloat y = a15;
  *(void *)&v104.size.double width = a16;
  *(void *)&v104.size.double height = a17;
  CGRect v105 = CGRectIntersection(v104, v109);
  double v42 = bvc_getPixelRectangle(v105.origin.x, v105.origin.y, v105.size.width, v105.size.height);
  double v44 = v43;
  double v46 = v45;
  double v48 = v47;
  v110.size.double width = (double)v33;
  v110.size.double height = (double)v34;
  v110.origin.CGFloat x = 0.0;
  v110.origin.CGFloat y = 0.0;
  *(void *)&v106.origin.CGFloat y = a19;
  *(void *)&v106.origin.CGFloat x = a18;
  *(void *)&v106.size.double height = a21;
  *(void *)&v106.size.double width = a20;
  CGRect v107 = CGRectIntersection(v106, v110);
  double v52 = bvc_getPixelRectangle(v107.origin.x, v107.origin.y, v107.size.width, v107.size.height);
  if (v39 < 1.0 || v41 < 1.0 || v46 < 1.0 || v48 < 1.0 || v50 < 1.0 || v51 < 1.0) {
    goto LABEL_37;
  }
  if (v39 >= v46) {
    double v53 = v46;
  }
  else {
    double v53 = v39;
  }
  if (v50 >= v53) {
    double v54 = v53;
  }
  else {
    double v54 = v50;
  }
  if (v41 >= v48) {
    double v55 = v48;
  }
  else {
    double v55 = v41;
  }
  if (v51 >= v55) {
    double v56 = v55;
  }
  else {
    double v56 = v51;
  }
  if (v84 != 875704438)
  {
    CFArrayRef v61 = v92;
    int v62 = -12503;
LABEL_36:
    *((_DWORD *)v61 + 6) = v62;
    goto LABEL_37;
  }
  double v57 = v49;
  if (PixelFormatType == 32)
  {
    if (v82 == 875704438)
    {
      if (v28 && CFEqual(v28, (CFTypeRef)*MEMORY[0x1E4F24C48]))
      {
        BOOL v58 = a9 == 1.0;
        char v59 = (uint64_t (*)())bvc_SimpleMixing_32ARGB_420v709_420v709;
        CFArrayRef v60 = (uint64_t (*)())bvc_SimpleMixingOpaque_32ARGB_420v709_420v709;
      }
      else
      {
        BOOL v58 = a9 == 1.0;
        char v59 = (uint64_t (*)())bvc_SimpleMixing_32ARGB_420v601_420v601;
        CFArrayRef v60 = (uint64_t (*)())bvc_SimpleMixingOpaque_32ARGB_420v601_420v601;
      }
      goto LABEL_41;
    }
    goto LABEL_35;
  }
  if (PixelFormatType == 1111970369)
  {
    if (v82 == 875704438)
    {
      if (!v28
        || (int v63 = CFEqual(v28, (CFTypeRef)*MEMORY[0x1E4F24C48]), v64 = bvc_SimpleMixing_32BGRA_420v709_420v709_vec, !v63))
      {
        CFIndex v64 = bvc_SimpleMixing_32BGRA_420v601_420v601_vec;
      }
      double v65 = v64;
      goto LABEL_44;
    }
    goto LABEL_35;
  }
  if (PixelFormatType != 875704438 || v82 != 875704438)
  {
LABEL_35:
    CFArrayRef v61 = v92;
    int v62 = -12502;
    goto LABEL_36;
  }
  BOOL v58 = a9 == 1.0;
  char v59 = bvc_SimpleMixing_420v_420v_420v_vec;
  CFArrayRef v60 = bvc_SimpleMixingOpaque_420v_420v_420v_vec;
LABEL_41:
  if (v58) {
    double v65 = v60;
  }
  else {
    double v65 = v59;
  }
LABEL_44:
  CVPixelBufferLockBaseAddress(a4, 0);
  if (pixelBuffer != a4) {
    CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
  }
  if (a3 != a4) {
    CVPixelBufferLockBaseAddress(a3, 1uLL);
  }
  int BufferCharacteristics = bvc_getBufferCharacteristics(pixelBuffer, &v90, (size_t *)v100, v97, v80, v79);
  *((_DWORD *)v92 + 6) = BufferCharacteristics;
  if (!BufferCharacteristics)
  {
    int v69 = bvc_getBufferCharacteristics(a3, &v89, (size_t *)v99, v96, v42, v44);
    *((_DWORD *)v92 + 6) = v69;
    if (!v69)
    {
      int v70 = bvc_getBufferCharacteristics(a4, &v88, (size_t *)v98, v95, v52, v57);
      *((_DWORD *)v92 + 6) = v70;
      if (!v70)
      {
        unint64_t v71 = (unint64_t)v54;
        unint64_t v72 = (unint64_t)v56;
        if (FigThreadGetMaxLogicalCoreCount() < 2)
        {
          int v77 = ((uint64_t (*)(unint64_t, unint64_t, _OWORD *, _OWORD *, _OWORD *, _OWORD *, _OWORD *, _OWORD *, float))v65)((unint64_t)v54, (unint64_t)v56, v100, v97, v99, v96, v98, v95, a9);
          *((_DWORD *)v92 + 6) = v77;
        }
        else
        {
          if ((v71 * v72) >> 9 <= 0x4A) {
            unint64_t v73 = 1;
          }
          else {
            unint64_t v73 = v71 * v72 / 0x4B00;
          }
          unint64_t v74 = v72 / v73;
          if (v74 <= 1) {
            unint64_t v74 = 1;
          }
          unint64_t v75 = (v74 & 1) + v74;
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 0x40000000;
          block[2] = __bvc_mixBuffers_block_invoke;
          block[3] = &unk_1E57A2388;
          if (v72 / v75 <= 1) {
            size_t v76 = 1;
          }
          else {
            size_t v76 = v72 / v75;
          }
          block[6] = v76;
          void block[7] = (unint64_t)v56;
          block[8] = v90;
          void block[9] = v97;
          OSType v86 = PixelFormatType;
          qmemcpy(v87, "v024v024", 8);
          block[10] = v100;
          block[11] = v89;
          void block[12] = v96;
          block[13] = v99;
          block[14] = v88;
          block[15] = v95;
          block[16] = v98;
          block[17] = v65;
          block[18] = (unint64_t)v54;
          *(float *)&v87[2] = a9;
          block[4] = &v91;
          void block[5] = v75;
          dispatch_apply(v76, a1, block);
        }
      }
    }
  }
  CVPixelBufferUnlockBaseAddress(a4, 0);
  if (pixelBuffer != a4) {
    CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
  }
  if (a3 != a4) {
    CVPixelBufferUnlockBaseAddress(a3, 1uLL);
  }
LABEL_37:
  if (v35) {
    CFRelease(v35);
  }
  uint64_t v66 = *((unsigned int *)v92 + 6);
  _Block_object_dispose(&v91, 8);
  return v66;
}

__CVBuffer *bvc_copyCVBufferProperties(__CVBuffer *pixelBuffer, __CVBuffer **a2, __CVBuffer **a3, __CVBuffer **a4, __CVBuffer **a5)
{
  long long v8 = pixelBuffer;
  if (a2)
  {
    pixelBuffer = (__CVBuffer *)CVPixelBufferGetWidth(pixelBuffer);
    *a2 = pixelBuffer;
  }
  if (a3)
  {
    pixelBuffer = (__CVBuffer *)CVPixelBufferGetHeight(v8);
    *a3 = pixelBuffer;
  }
  if (a4)
  {
    pixelBuffer = (__CVBuffer *)CVBufferCopyAttachment(v8, (CFStringRef)*MEMORY[0x1E4F24B98], 0);
    *a4 = pixelBuffer;
  }
  if (a5)
  {
    pixelBuffer = (__CVBuffer *)CVBufferCopyAttachment(v8, (CFStringRef)*MEMORY[0x1E4F24A78], 0);
    *a5 = pixelBuffer;
  }
  return pixelBuffer;
}

void bvc_getCleanApertureRect(const __CFDictionary *a1, unint64_t a2, unint64_t a3, double *a4)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  if (a4)
  {
    FigVideoCompositorUtilityGetCleanAperture(a1, a2, a3, (float *)&v14 + 1, (float *)&v14, (float *)&v13 + 1, (float *)&v13);
    if (!v7)
    {
      float v8 = (float)a2;
      float v9 = *((float *)&v14 + 1);
      if (*((float *)&v14 + 1) >= (float)((float)a2 + (float)(*((float *)&v13 + 1) * 2.0))) {
        float v9 = (float)a2 + (float)(*((float *)&v13 + 1) * 2.0);
      }
      if (v9 >= (float)(v8 + (float)(*((float *)&v13 + 1) * -2.0))) {
        float v9 = v8 + (float)(*((float *)&v13 + 1) * -2.0);
      }
      float v10 = (float)a3;
      float v11 = (float)a3 + (float)(*(float *)&v13 * 2.0);
      if (*(float *)&v14 < v11) {
        float v11 = *(float *)&v14;
      }
      if (v11 >= (float)(v10 + (float)(*(float *)&v13 * -2.0))) {
        float v11 = v10 + (float)(*(float *)&v13 * -2.0);
      }
      double v12 = (float)(*(float *)&v13 + (float)((float)(v10 - v11) * 0.5));
      *a4 = (float)(*((float *)&v13 + 1) + (float)((float)(v8 - v9) * 0.5));
      a4[1] = v12;
      a4[2] = v9;
      a4[3] = v11;
    }
  }
}

void bvc_doesPixelBufferFillCanvasExactly(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, const __CFDictionary *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  memset(&v18, 0, sizeof(v18));
  bvc_getCleanApertureRect(a5, a3, a4, &v18.origin.x);
  if (!v17 && a1 == a3 && a2 == a4)
  {
    v19.origin.CGFloat x = a6;
    v19.origin.CGFloat y = a7;
    v19.size.double width = a8;
    v19.size.double height = a9;
    CGRectEqualToRect(v19, v18);
  }
}

__CVPixelBufferPool *bvc_isPixelBufferPoolCompatibleWithDimensionsAndPixelFormat(__CVPixelBufferPool *result, uint64_t a2, uint64_t a3, int a4)
{
  if (result)
  {
    CFDictionaryRef PixelBufferAttributes = CVPixelBufferPoolGetPixelBufferAttributes(result);
    if (!PixelBufferAttributes) {
      goto LABEL_10;
    }
    CFDictionaryRef v8 = PixelBufferAttributes;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(PixelBufferAttributes, (const void *)*MEMORY[0x1E4F24E10]);
    if (!Value) {
      goto LABEL_10;
    }
    uint64_t valuePtr = 0;
    int v12 = 0;
    CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    CFNumberRef v10 = (const __CFNumber *)CFDictionaryGetValue(v8, (const void *)*MEMORY[0x1E4F24D08]);
    if (v10
      && (CFNumberGetValue(v10, kCFNumberSInt32Type, &valuePtr),
          (CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(v8, (const void *)*MEMORY[0x1E4F24D70])) != 0))
    {
      CFNumberGetValue(v11, kCFNumberSInt32Type, &v12);
      if (SHIDWORD(valuePtr) == a2 && (int)valuePtr == a3 && v12 == a4) {
        return (__CVPixelBufferPool *)1;
      }
    }
    else
    {
LABEL_10:
      FigSignalErrorAt();
    }
    return 0;
  }
  return result;
}

uint64_t bvc_createPixelBufferPoolForPreProcessing(int a1, int a2, int a3, CVPixelBufferPoolRef *a4)
{
  CFDictionaryRef theDict = 0;
  CVPixelBufferPoolRef poolOut = 0;
  if (!a4)
  {
    uint64_t v9 = FigSignalErrorAt();
    goto LABEL_16;
  }
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v9 = bvc_createPixelBufferAttributesDictionary((const __CFAllocator *)*MEMORY[0x1E4F1CF80], &theDict);
  if (v9)
  {
LABEL_16:
    uint64_t v14 = v9;
    goto LABEL_11;
  }
  CFDictionaryRef v10 = theDict;
  Mutableuint64_t Copy = CFDictionaryCreateMutableCopy(v8, 0, theDict);
  if (!MutableCopy)
  {
    uint64_t v14 = FigSignalErrorAt();
    if (!v10) {
      return v14;
    }
    goto LABEL_12;
  }
  CFDictionaryRef v12 = MutableCopy;
  uint64_t v13 = bvc_CFDictionarySetInt(MutableCopy, (const void *)*MEMORY[0x1E4F24E10], a1);
  if (v13
    || (uint64_t v13 = bvc_CFDictionarySetInt(v12, (const void *)*MEMORY[0x1E4F24D08], a2), v13)
    || (uint64_t v13 = bvc_CFDictionarySetInt(v12, (const void *)*MEMORY[0x1E4F24D70], a3), v13)
    || (uint64_t v13 = VTCreatePixelBufferPoolAttributesWithName(), v13))
  {
    uint64_t v14 = v13;
  }
  else
  {
    uint64_t v14 = CVPixelBufferPoolCreate(v8, 0, v12, &poolOut);
    if (v14)
    {
      if (poolOut) {
        CFRelease(poolOut);
      }
    }
    else
    {
      *a4 = poolOut;
      CVPixelBufferPoolRef poolOut = 0;
    }
  }
  CFRelease(v12);
LABEL_11:
  CFDictionaryRef v10 = theDict;
  if (theDict) {
LABEL_12:
  }
    CFRelease(v10);
  return v14;
}

double bvc_getPixelRectangle(double a1, double a2, double a3, double a4)
{
  return (double)(int)(COERCE_DOUBLE(CGRectStandardize(*(CGRect *)&a1)) + 0.5);
}

uint64_t bvc_SimpleMixingOpaque_32ARGB_420v709_420v709(unint64_t a1, unint64_t a2, uint64_t *a3, void *a4, void *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  if (a2 >= 2)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a7;
    uint64_t v54 = a7[1];
    uint64_t v55 = a5[1];
    unint64_t v53 = a2 >> 1;
    uint64_t v10 = a1 >> 1;
    uint64_t v12 = *a8;
    uint64_t v11 = a8[1];
    uint64_t v59 = *a3;
    uint64_t v51 = 2 * *a5;
    uint64_t v52 = 2 * *a3;
    if (a1 >> 1 <= 1) {
      uint64_t v10 = 1;
    }
    uint64_t v49 = v10;
    uint64_t v50 = 2 * v9;
    uint64_t v58 = *a4 + 3;
    uint64_t v13 = v12 + v9;
    uint64_t v14 = *a6;
    uint64_t v15 = a6[1];
    uint64_t v17 = v14 + *a5;
    do
    {
      uint64_t v57 = v8;
      if (a1 >= 2)
      {
        uint64_t v18 = 0;
        CGRect v19 = (unsigned __int8 *)v58;
        uint64_t v20 = v49;
        do
        {
          int v21 = *(v19 - 3);
          int v22 = *(v19 - 2);
          int v23 = *(v19 - 1);
          int v24 = *v19;
          if (*(v19 - 3)) {
            unsigned int v25 = (((16776959 * v21 + 0x10000) * *(unsigned __int8 *)(v14 + v18)) >> 16)
          }
                + ((2120 * v21 + 5983 * v22 + 20127 * v23 + 2032 * v24) >> 15);
          else {
            LOBYTE(v25) = *(unsigned char *)(v14 + v18);
          }
          int v26 = v19[1];
          int v27 = v19[v59 - 3];
          int v28 = v19[v59 + 1];
          int v29 = v19[2];
          int v30 = v19[v59 - 2];
          int v31 = v19[v59 + 2];
          int v32 = v19[3];
          int v33 = v19[v59 - 1];
          int v34 = v19[v59 + 3];
          int v35 = v19[4];
          int v36 = v19[v59];
          int v37 = v19[v59 + 4];
          *(unsigned char *)(v12 + v18) = v25;
          if (v26) {
            unsigned int v38 = (((16776959 * v26 + 0x10000) * *(unsigned __int8 *)(v14 + v18 + 1)) >> 16)
          }
                + ((2120 * v26 + 5983 * v29 + 20127 * v32 + 2032 * v35) >> 15);
          else {
            LOBYTE(v38) = *(unsigned char *)(v14 + v18 + 1);
          }
          *(unsigned char *)(v12 + v18 + 1) = v38;
          if (v27) {
            unsigned int v39 = (((16776959 * v27 + 0x10000) * *(unsigned __int8 *)(v17 + v18)) >> 16)
          }
                + ((2120 * v27 + 5983 * v30 + 20127 * v33 + 2032 * v36) >> 15);
          else {
            LOBYTE(v39) = *(unsigned char *)(v17 + v18);
          }
          *(unsigned char *)(v13 + v18) = v39;
          if (v28) {
            unsigned int v40 = (((16776959 * v28 + 0x10000) * *(unsigned __int8 *)(v17 + v18 + 1)) >> 16)
          }
                + ((2120 * v28 + 5983 * v31 + 20127 * v34 + 2032 * v37) >> 15);
          else {
            LOBYTE(v40) = *(unsigned char *)(v17 + v18 + 1);
          }
          *(unsigned char *)(v13 + v18 + 1) = v40;
          unsigned int v41 = v26 + v21 + v27 + v28;
          if (v41 > 3)
          {
            int v43 = 257 * (v41 >> 2);
            unsigned int v44 = (v29 + v22 + v30 + v31) >> 2;
            unsigned int v45 = (v32 + v23 + v33 + v34) >> 2;
            unsigned int v46 = (v35 + v24 + v36 + v37) >> 2;
            int v47 = 129 * (v41 >> 2);
            int v43 = 0x10000 - v43;
            *(unsigned char *)(v11 + v18) = ((v43 * *(unsigned __int8 *)(v15 + v18)) >> 16)
                                  + ((2147480350 * v44 + (v47 << 7) + 8377515 * v45 + 14392 * v46) >> 15);
            unsigned int v42 = ((v43 * *(unsigned __int8 *)(v15 + v18 + 1)) >> 16)
                + ((14392 * v44 + (v47 << 7) + 8375535 * v45 + 8387291 * v46) >> 15);
          }
          else
          {
            *(unsigned char *)(v11 + v18) = *(unsigned char *)(v15 + v18);
            LOBYTE(v42) = *(unsigned char *)(v15 + v18 + 1);
          }
          v19 += 8;
          *(unsigned char *)(v11 + v18 + 1) = v42;
          v18 += 2;
          --v20;
        }
        while (v20);
      }
      v14 += v51;
      v12 += v50;
      v15 += v55;
      v11 += v54;
      uint64_t v8 = v57 + 1;
      v58 += v52;
      v13 += v50;
      v17 += v51;
    }
    while (v57 + 1 != v53);
  }
  return 0;
}

uint64_t bvc_SimpleMixing_32ARGB_420v709_420v709(unint64_t a1, unint64_t a2, uint64_t *a3, void *a4, void *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, float a9)
{
  if (a2 >= 2)
  {
    uint64_t v9 = 0;
    unsigned int v10 = vcvts_n_s32_f32(a9, 8uLL);
    uint64_t v56 = a5[1];
    uint64_t v11 = *a7;
    uint64_t v55 = a7[1];
    unint64_t v54 = a2 >> 1;
    uint64_t v12 = a1 >> 1;
    uint64_t v14 = *a8;
    uint64_t v13 = a8[1];
    uint64_t v15 = (0x10101020000 * (v10 << 8)) >> 48;
    uint64_t v52 = 2 * *a5;
    uint64_t v53 = 2 * *a3;
    if (a1 >> 1 <= 1) {
      uint64_t v12 = 1;
    }
    uint64_t v50 = v12;
    uint64_t v51 = 2 * v11;
    uint64_t v59 = *a4 + 3;
    uint64_t v60 = *a3;
    uint64_t v16 = *a6;
    uint64_t v62 = a6[1];
    uint64_t v18 = v14 + v11;
    uint64_t v19 = v16 + *a5;
    do
    {
      uint64_t v58 = v9;
      if (a1 >= 2)
      {
        uint64_t v20 = 0;
        int v21 = (unsigned __int8 *)v59;
        uint64_t v22 = v50;
        uint64_t v61 = v13;
        do
        {
          int v23 = *(v21 - 3);
          int v24 = *(v21 - 2);
          int v25 = *(v21 - 1);
          int v26 = *v21;
          if (v15 * v23) {
            unsigned int v27 = (((2120 * v23 + 5983 * v24 + 20127 * v25 + 2032 * v26) >> 15) * v10
          }
                 + (((0x10000 - v15 * v23) * *(unsigned __int8 *)(v16 + v20)) >> 8)) >> 8;
          else {
            LOBYTE(v27) = *(unsigned char *)(v16 + v20);
          }
          int v28 = v21[1];
          int v29 = v21[v60 - 3];
          int v30 = v21[v60 + 1];
          int v31 = v21[2];
          int v32 = v21[v60 - 2];
          int v33 = v21[v60 + 2];
          int v34 = v21[3];
          int v35 = v21[v60 - 1];
          int v36 = v21[v60 + 3];
          int v37 = v21[4];
          int v38 = v21[v60];
          int v39 = v21[v60 + 4];
          *(unsigned char *)(v14 + v20) = v27;
          if (v15 * v28) {
            unsigned int v40 = (((2120 * v28 + 5983 * v31 + 20127 * v34 + 2032 * v37) >> 15) * v10
          }
                 + (((0x10000 - v15 * v28) * *(unsigned __int8 *)(v16 + v20 + 1)) >> 8)) >> 8;
          else {
            LOBYTE(v40) = *(unsigned char *)(v16 + v20 + 1);
          }
          *(unsigned char *)(v14 + v20 + 1) = v40;
          if (v15 * v29) {
            unsigned int v41 = (((2120 * v29 + 5983 * v32 + 20127 * v35 + 2032 * v38) >> 15) * v10
          }
                 + (((0x10000 - v15 * v29) * *(unsigned __int8 *)(v19 + v20)) >> 8)) >> 8;
          else {
            LOBYTE(v41) = *(unsigned char *)(v19 + v20);
          }
          *(unsigned char *)(v18 + v20) = v41;
          if (v15 * v30) {
            unsigned int v42 = (((2120 * v30 + 5983 * v33 + 20127 * v36 + 2032 * v39) >> 15) * v10
          }
                 + (((0x10000 - v15 * v30) * *(unsigned __int8 *)(v19 + v20 + 1)) >> 8)) >> 8;
          else {
            LOBYTE(v42) = *(unsigned char *)(v19 + v20 + 1);
          }
          uint64_t v13 = v61;
          *(unsigned char *)(v18 + v20 + 1) = v42;
          unsigned int v43 = (v28 + v23 + v29 + v30) >> 2;
          int v44 = v43 * v15;
          if (v43 * v15)
          {
            unsigned int v45 = (v31 + v24 + v32 + v33) >> 2;
            unsigned int v46 = (v34 + v25 + v35 + v36) >> 2;
            unsigned int v47 = (v37 + v26 + v38 + v39) >> 2;
            *(unsigned char *)(v61 + v20) = (unsigned __int16)(((2147480350 * v45 + 16512 * v43 + 2147472555 * v46 + 14392 * v47) >> 15)
                                                     * v10
                                                     + (((0x10000 - v44) * *(unsigned __int8 *)(v62 + v20)) >> 8)) >> 8;
            unsigned int v48 = (((14392 * v45 + 16512 * v43 + 2147470575 * v46 + 2147482331 * v47) >> 15) * v10
                 + (((0x10000 - v44) * *(unsigned __int8 *)(v62 + v20 + 1)) >> 8)) >> 8;
          }
          else
          {
            *(unsigned char *)(v61 + v20) = *(unsigned char *)(v62 + v20);
            LOBYTE(v48) = *(unsigned char *)(v62 + v20 + 1);
          }
          v21 += 8;
          *(unsigned char *)(v61 + v20 + 1) = v48;
          v20 += 2;
          --v22;
        }
        while (v22);
      }
      v16 += v52;
      v14 += v51;
      v62 += v56;
      v13 += v55;
      uint64_t v9 = v58 + 1;
      v59 += v53;
      v18 += v51;
      v19 += v52;
    }
    while (v58 + 1 != v54);
  }
  return 0;
}

uint64_t bvc_SimpleMixingOpaque_32ARGB_420v601_420v601(unint64_t a1, unint64_t a2, uint64_t *a3, void *a4, void *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  if (a2 >= 2)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a7;
    uint64_t v54 = a7[1];
    uint64_t v55 = a5[1];
    unint64_t v53 = a2 >> 1;
    uint64_t v10 = a1 >> 1;
    uint64_t v12 = *a8;
    uint64_t v11 = a8[1];
    uint64_t v59 = *a3;
    uint64_t v51 = 2 * *a5;
    uint64_t v52 = 2 * *a3;
    if (a1 >> 1 <= 1) {
      uint64_t v10 = 1;
    }
    uint64_t v49 = v10;
    uint64_t v50 = 2 * v9;
    uint64_t v58 = *a4 + 3;
    uint64_t v13 = v12 + v9;
    uint64_t v14 = *a6;
    uint64_t v15 = a6[1];
    uint64_t v17 = v14 + *a5;
    do
    {
      uint64_t v57 = v8;
      if (a1 >= 2)
      {
        uint64_t v18 = 0;
        uint64_t v19 = (unsigned __int8 *)v58;
        uint64_t v20 = v49;
        do
        {
          int v21 = *(v19 - 3);
          int v22 = *(v19 - 2);
          int v23 = *(v19 - 1);
          int v24 = *v19;
          if (*(v19 - 3)) {
            unsigned int v25 = (((16776959 * v21 + 0x10000) * *(unsigned __int8 *)(v14 + v18)) >> 16)
          }
                + ((2120 * v21 + 8412 * v22 + 16508 * v23 + 3219 * v24) >> 15);
          else {
            LOBYTE(v25) = *(unsigned char *)(v14 + v18);
          }
          int v26 = v19[1];
          int v27 = v19[v59 - 3];
          int v28 = v19[v59 + 1];
          int v29 = v19[2];
          int v30 = v19[v59 - 2];
          int v31 = v19[v59 + 2];
          int v32 = v19[3];
          int v33 = v19[v59 - 1];
          int v34 = v19[v59 + 3];
          int v35 = v19[4];
          int v36 = v19[v59];
          int v37 = v19[v59 + 4];
          *(unsigned char *)(v12 + v18) = v25;
          if (v26) {
            unsigned int v38 = (((16776959 * v26 + 0x10000) * *(unsigned __int8 *)(v14 + v18 + 1)) >> 16)
          }
                + ((2120 * v26 + 8412 * v29 + 16508 * v32 + 3219 * v35) >> 15);
          else {
            LOBYTE(v38) = *(unsigned char *)(v14 + v18 + 1);
          }
          *(unsigned char *)(v12 + v18 + 1) = v38;
          if (v27) {
            unsigned int v39 = (((16776959 * v27 + 0x10000) * *(unsigned __int8 *)(v17 + v18)) >> 16)
          }
                + ((2120 * v27 + 8412 * v30 + 16508 * v33 + 3219 * v36) >> 15);
          else {
            LOBYTE(v39) = *(unsigned char *)(v17 + v18);
          }
          *(unsigned char *)(v13 + v18) = v39;
          if (v28) {
            unsigned int v40 = (((16776959 * v28 + 0x10000) * *(unsigned __int8 *)(v17 + v18 + 1)) >> 16)
          }
                + ((2120 * v28 + 8412 * v31 + 16508 * v34 + 3219 * v37) >> 15);
          else {
            LOBYTE(v40) = *(unsigned char *)(v17 + v18 + 1);
          }
          *(unsigned char *)(v13 + v18 + 1) = v40;
          unsigned int v41 = v26 + v21 + v27 + v28;
          if (v41 > 3)
          {
            int v43 = 257 * (v41 >> 2);
            unsigned int v44 = (v29 + v22 + v30 + v31) >> 2;
            unsigned int v45 = (v32 + v23 + v33 + v34) >> 2;
            unsigned int v46 = (v35 + v24 + v36 + v37) >> 2;
            int v47 = 129 * (v41 >> 2);
            int v43 = 0x10000 - v43;
            *(unsigned char *)(v11 + v18) = ((v43 * *(unsigned __int8 *)(v15 + v18)) >> 16)
                                  + ((2147478790 * v44 + (v47 << 7) + 8379076 * v45 + 14392 * v46) >> 15);
            unsigned int v42 = ((v43 * *(unsigned __int8 *)(v15 + v18 + 1)) >> 16)
                + ((14392 * v44 + (v47 << 7) + 8376568 * v45 + 8386260 * v46) >> 15);
          }
          else
          {
            *(unsigned char *)(v11 + v18) = *(unsigned char *)(v15 + v18);
            LOBYTE(v42) = *(unsigned char *)(v15 + v18 + 1);
          }
          v19 += 8;
          *(unsigned char *)(v11 + v18 + 1) = v42;
          v18 += 2;
          --v20;
        }
        while (v20);
      }
      v14 += v51;
      v12 += v50;
      v15 += v55;
      v11 += v54;
      uint64_t v8 = v57 + 1;
      v58 += v52;
      v13 += v50;
      v17 += v51;
    }
    while (v57 + 1 != v53);
  }
  return 0;
}

uint64_t bvc_SimpleMixing_32ARGB_420v601_420v601(unint64_t a1, unint64_t a2, uint64_t *a3, void *a4, void *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, float a9)
{
  if (a2 >= 2)
  {
    uint64_t v9 = 0;
    unsigned int v10 = vcvts_n_s32_f32(a9, 8uLL);
    uint64_t v56 = a5[1];
    uint64_t v11 = *a7;
    uint64_t v55 = a7[1];
    unint64_t v54 = a2 >> 1;
    uint64_t v12 = a1 >> 1;
    uint64_t v14 = *a8;
    uint64_t v13 = a8[1];
    uint64_t v15 = (0x10101020000 * (v10 << 8)) >> 48;
    uint64_t v52 = 2 * *a5;
    uint64_t v53 = 2 * *a3;
    if (a1 >> 1 <= 1) {
      uint64_t v12 = 1;
    }
    uint64_t v50 = v12;
    uint64_t v51 = 2 * v11;
    uint64_t v59 = *a4 + 3;
    uint64_t v60 = *a3;
    uint64_t v16 = *a6;
    uint64_t v62 = a6[1];
    uint64_t v18 = v14 + v11;
    uint64_t v19 = v16 + *a5;
    do
    {
      uint64_t v58 = v9;
      if (a1 >= 2)
      {
        uint64_t v20 = 0;
        int v21 = (unsigned __int8 *)v59;
        uint64_t v22 = v50;
        uint64_t v61 = v13;
        do
        {
          int v23 = *(v21 - 3);
          int v24 = *(v21 - 2);
          int v25 = *(v21 - 1);
          int v26 = *v21;
          if (v15 * v23) {
            unsigned int v27 = (((2120 * v23 + 8412 * v24 + 16508 * v25 + 3219 * v26) >> 15) * v10
          }
                 + (((0x10000 - v15 * v23) * *(unsigned __int8 *)(v16 + v20)) >> 8)) >> 8;
          else {
            LOBYTE(v27) = *(unsigned char *)(v16 + v20);
          }
          int v28 = v21[1];
          int v29 = v21[v60 - 3];
          int v30 = v21[v60 + 1];
          int v31 = v21[2];
          int v32 = v21[v60 - 2];
          int v33 = v21[v60 + 2];
          int v34 = v21[3];
          int v35 = v21[v60 - 1];
          int v36 = v21[v60 + 3];
          int v37 = v21[4];
          int v38 = v21[v60];
          int v39 = v21[v60 + 4];
          *(unsigned char *)(v14 + v20) = v27;
          if (v15 * v28) {
            unsigned int v40 = (((2120 * v28 + 8412 * v31 + 16508 * v34 + 3219 * v37) >> 15) * v10
          }
                 + (((0x10000 - v15 * v28) * *(unsigned __int8 *)(v16 + v20 + 1)) >> 8)) >> 8;
          else {
            LOBYTE(v40) = *(unsigned char *)(v16 + v20 + 1);
          }
          *(unsigned char *)(v14 + v20 + 1) = v40;
          if (v15 * v29) {
            unsigned int v41 = (((2120 * v29 + 8412 * v32 + 16508 * v35 + 3219 * v38) >> 15) * v10
          }
                 + (((0x10000 - v15 * v29) * *(unsigned __int8 *)(v19 + v20)) >> 8)) >> 8;
          else {
            LOBYTE(v41) = *(unsigned char *)(v19 + v20);
          }
          *(unsigned char *)(v18 + v20) = v41;
          if (v15 * v30) {
            unsigned int v42 = (((2120 * v30 + 8412 * v33 + 16508 * v36 + 3219 * v39) >> 15) * v10
          }
                 + (((0x10000 - v15 * v30) * *(unsigned __int8 *)(v19 + v20 + 1)) >> 8)) >> 8;
          else {
            LOBYTE(v42) = *(unsigned char *)(v19 + v20 + 1);
          }
          uint64_t v13 = v61;
          *(unsigned char *)(v18 + v20 + 1) = v42;
          unsigned int v43 = (v28 + v23 + v29 + v30) >> 2;
          int v44 = v43 * v15;
          if (v43 * v15)
          {
            unsigned int v45 = (v31 + v24 + v32 + v33) >> 2;
            unsigned int v46 = (v34 + v25 + v35 + v36) >> 2;
            unsigned int v47 = (v37 + v26 + v38 + v39) >> 2;
            *(unsigned char *)(v61 + v20) = (unsigned __int16)(((2147478790 * v45 + 16512 * v43 + 2147474116 * v46 + 14392 * v47) >> 15)
                                                     * v10
                                                     + (((0x10000 - v44) * *(unsigned __int8 *)(v62 + v20)) >> 8)) >> 8;
            unsigned int v48 = (((14392 * v45 + 16512 * v43 + 2147471608 * v46 + 2147481300 * v47) >> 15) * v10
                 + (((0x10000 - v44) * *(unsigned __int8 *)(v62 + v20 + 1)) >> 8)) >> 8;
          }
          else
          {
            *(unsigned char *)(v61 + v20) = *(unsigned char *)(v62 + v20);
            LOBYTE(v48) = *(unsigned char *)(v62 + v20 + 1);
          }
          v21 += 8;
          *(unsigned char *)(v61 + v20 + 1) = v48;
          v20 += 2;
          --v22;
        }
        while (v22);
      }
      v16 += v52;
      v14 += v51;
      v62 += v56;
      v13 += v55;
      uint64_t v9 = v58 + 1;
      v59 += v53;
      v18 += v51;
      v19 += v52;
    }
    while (v58 + 1 != v54);
  }
  return 0;
}

uint64_t bvc_getBufferCharacteristics(__CVBuffer *a1, uint64_t *a2, size_t *a3, void *a4, double a5, double a6)
{
  if (a2 && a3 && a4)
  {
    signed int PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
    if (!CVPixelBufferIsPlanar(a1))
    {
      uint64_t v14 = 1;
      if (CVPixelBufferIsPlanar(a1))
      {
LABEL_10:
        size_t v15 = 0;
        while (1)
        {
          a3[v15] = CVPixelBufferGetBytesPerRowOfPlane(a1, v15);
          BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(a1, v15);
          if (PixelFormatType <= 875704421)
          {
            float v17 = 1.0;
            if (PixelFormatType != 32 && PixelFormatType != 846624121) {
              goto LABEL_23;
            }
          }
          else
          {
            if (PixelFormatType != 875704422)
            {
              float v17 = 1.0;
              if (PixelFormatType == 1111970369) {
                goto LABEL_24;
              }
              if (PixelFormatType != 875704438)
              {
LABEL_23:
                float v17 = -1.0;
                goto LABEL_24;
              }
            }
            if (v15 == 1) {
              float v17 = 0.5;
            }
            else {
              float v17 = -1.0;
            }
            if (!v15) {
              float v17 = 1.0;
            }
          }
LABEL_24:
          float v18 = 1.0;
          if (PixelFormatType <= 875704421)
          {
            if (PixelFormatType == 32) {
              goto LABEL_38;
            }
            if (PixelFormatType == 846624121)
            {
              double v19 = a5 * 0.5 + 0.5;
              goto LABEL_48;
            }
LABEL_37:
            float v18 = -1.0;
            goto LABEL_38;
          }
          if (PixelFormatType != 875704422)
          {
            if (PixelFormatType == 1111970369) {
              goto LABEL_38;
            }
            if (PixelFormatType != 875704438) {
              goto LABEL_37;
            }
          }
          if (v15 == 1) {
            float v18 = 0.5;
          }
          else {
            float v18 = -1.0;
          }
          if (!v15) {
            float v18 = 1.0;
          }
LABEL_38:
          double v19 = a5 * v18 + 0.5;
          if (PixelFormatType <= 875704421)
          {
            if (PixelFormatType != 32) {
              goto LABEL_51;
            }
          }
          else
          {
            if (PixelFormatType == 875704422) {
              goto LABEL_42;
            }
            if (PixelFormatType != 1111970369)
            {
              if (PixelFormatType == 875704438)
              {
LABEL_42:
                uint64_t v20 = 2;
                if (v15 != 1) {
                  uint64_t v20 = -1;
                }
                if (!v15) {
                  uint64_t v20 = 1;
                }
                goto LABEL_49;
              }
LABEL_51:
              uint64_t v20 = -1;
              goto LABEL_49;
            }
          }
LABEL_48:
          uint64_t v20 = 4;
LABEL_49:
          a4[v15] = &BaseAddressOfPlane[a3[v15] * (unint64_t)(a6 * v17 + 0.5) + v20 * (unint64_t)v19];
          if (v14 == ++v15) {
            goto LABEL_77;
          }
        }
      }
LABEL_52:
      *a3 = CVPixelBufferGetBytesPerRow(a1);
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
      double v22 = 1.0;
      if (PixelFormatType <= 875704421)
      {
        if (PixelFormatType == 32) {
          goto LABEL_60;
        }
        int v23 = 846624121;
      }
      else
      {
        if (PixelFormatType == 875704422 || PixelFormatType == 875704438) {
          goto LABEL_60;
        }
        int v23 = 1111970369;
      }
      if (PixelFormatType != v23) {
        double v22 = -1.0;
      }
LABEL_60:
      int v24 = &BaseAddress[*a3 * (unint64_t)(a6 * v22 + 0.5)];
      double v25 = 1.0;
      if (PixelFormatType <= 875704421)
      {
        if (PixelFormatType == 32)
        {
LABEL_69:
          double v26 = a5 * v25 + 0.5;
          uint64_t v27 = 4;
          if (PixelFormatType <= 875704421)
          {
            if (PixelFormatType == 32) {
              goto LABEL_76;
            }
            goto LABEL_75;
          }
          if (PixelFormatType == 875704422)
          {
LABEL_73:
            uint64_t v27 = 1;
            goto LABEL_76;
          }
          if (PixelFormatType != 1111970369)
          {
            if (PixelFormatType == 875704438) {
              goto LABEL_73;
            }
LABEL_75:
            uint64_t v27 = -1;
          }
LABEL_76:
          *a4 = &v24[v27 * (unint64_t)v26];
LABEL_77:
          *a2 = v14;
          return 0;
        }
        if (PixelFormatType == 846624121)
        {
          double v26 = a5 * 0.5 + 0.5;
          uint64_t v27 = 4;
          goto LABEL_76;
        }
      }
      else if (PixelFormatType == 875704422 || PixelFormatType == 875704438 || PixelFormatType == 1111970369)
      {
        goto LABEL_69;
      }
      double v25 = -1.0;
      goto LABEL_69;
    }
    PlaneCFArrayRef Count = CVPixelBufferGetPlaneCount(a1);
    if (PlaneCount < 5)
    {
      uint64_t v14 = PlaneCount;
      if (CVPixelBufferIsPlanar(a1))
      {
        if (!v14) {
          goto LABEL_77;
        }
        goto LABEL_10;
      }
      goto LABEL_52;
    }
  }

  return FigSignalErrorAt();
}

uint64_t __bvc_mixBuffers_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  memset(v27, 0, sizeof(v27));
  memset(v26, 0, sizeof(v26));
  memset(v25, 0, sizeof(v25));
  unint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = v4 * a2;
  if (*(void *)(a1 + 48) - 1 == a2) {
    unint64_t v4 = *(void *)(a1 + 56) - v5;
  }
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v7 = *(void *)(a1 + 80);
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = *(_DWORD *)(a1 + 152);
    uint64_t v10 = *(void *)(a1 + 72);
    while (v9 > 875704421)
    {
      if (v9 == 875704422) {
        goto LABEL_9;
      }
      float v11 = 1.0;
      if (v9 != 1111970369)
      {
        if (v9 == 875704438)
        {
LABEL_9:
          if (v8 == 1) {
            float v11 = 0.5;
          }
          else {
            float v11 = -1.0;
          }
          if (!v8) {
            float v11 = 1.0;
          }
          goto LABEL_18;
        }
LABEL_17:
        float v11 = -1.0;
      }
LABEL_18:
      *((void *)v27 + v8) = *(void *)(v10 + 8 * v8)
                            + *(void *)(v7 + 8 * v8) * (unint64_t)(float)(v11 * (float)v5);
      if (v6 == ++v8) {
        goto LABEL_19;
      }
    }
    float v11 = 1.0;
    if (v9 == 32 || v9 == 846624121) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_19:
  uint64_t v12 = *(void *)(a1 + 88);
  uint64_t v13 = *(void *)(a1 + 104);
  if (v12)
  {
    uint64_t v14 = 0;
    int v15 = *(_DWORD *)(a1 + 156);
    uint64_t v16 = *(void *)(a1 + 96);
    while (v15 > 875704421)
    {
      if (v15 == 875704422) {
        goto LABEL_25;
      }
      float v17 = 1.0;
      if (v15 != 1111970369)
      {
        if (v15 == 875704438)
        {
LABEL_25:
          if (v14 == 1) {
            float v17 = 0.5;
          }
          else {
            float v17 = -1.0;
          }
          if (!v14) {
            float v17 = 1.0;
          }
          goto LABEL_34;
        }
LABEL_33:
        float v17 = -1.0;
      }
LABEL_34:
      *((void *)v26 + v14) = *(void *)(v16 + 8 * v14)
                             + *(void *)(v13 + 8 * v14) * (unint64_t)(float)(v17 * (float)v5);
      if (v12 == ++v14) {
        goto LABEL_35;
      }
    }
    float v17 = 1.0;
    if (v15 == 32 || v15 == 846624121) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
LABEL_35:
  uint64_t v18 = *(void *)(a1 + 112);
  uint64_t v19 = *(void *)(a1 + 128);
  if (v18)
  {
    uint64_t v20 = 0;
    int v21 = *(_DWORD *)(a1 + 160);
    uint64_t v22 = *(void *)(a1 + 120);
    while (v21 > 875704421)
    {
      if (v21 == 875704422) {
        goto LABEL_41;
      }
      float v23 = 1.0;
      if (v21 != 1111970369)
      {
        if (v21 == 875704438)
        {
LABEL_41:
          if (v20 == 1) {
            float v23 = 0.5;
          }
          else {
            float v23 = -1.0;
          }
          if (!v20) {
            float v23 = 1.0;
          }
          goto LABEL_50;
        }
LABEL_49:
        float v23 = -1.0;
      }
LABEL_50:
      *((void *)v25 + v20) = *(void *)(v22 + 8 * v20)
                             + *(void *)(v19 + 8 * v20) * (unint64_t)(float)(v23 * (float)v5);
      if (v18 == ++v20) {
        goto LABEL_51;
      }
    }
    float v23 = 1.0;
    if (v21 == 32 || v21 == 846624121) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
LABEL_51:
  uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t, _OWORD *, uint64_t, _OWORD *, uint64_t, _OWORD *, float))(a1 + 136))(*(void *)(a1 + 144), v4, v7, v27, v13, v26, v19, v25, *(float *)(a1 + 164));
  if (result) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -12506;
  }
  return result;
}

uint64_t bvc_Fill_32ARGB_420v709(size_t __len, unint64_t a2, unsigned __int8 *a3, uint64_t *a4, char **a5)
{
  uint64_t v8 = *a4;
  uint64_t v7 = a4[1];
  uint64_t v10 = *a5;
  int v9 = a5[1];
  unsigned int v11 = a3[1];
  unsigned int v12 = a3[2];
  unsigned int v13 = 20127 * v12 + 5983 * v11 + 2032 * a3[3] + 540672;
  unsigned int v21 = a3[3];
  if (*a4 == __len)
  {
    memset(v10, v13 >> 15, __len * a2);
  }
  else
  {
    if (!a2) {
      return 0;
    }
    int v15 = v13 >> 15;
    unint64_t v16 = a2;
    do
    {
      memset(v10, v15, __len);
      v10 += v8;
      --v16;
    }
    while (v16);
  }
  if (a2 >= 2)
  {
    int16x4_t v17 = (int16x4_t)vshr_n_u32((uint32x2_t)vadd_s32(vmla_s32(vmla_s32(vmul_s32(vdup_n_s32(v12), (int32x2_t)0x7FCCEF007FD4ABLL), vdup_n_s32(v11), (int32x2_t)0x3838007FF31ELL), vdup_n_s32(v21), (int32x2_t)0x7FFADB00003838), vdup_n_s32(0x404000u)), 0xFuLL);
    size_t v18 = (__len + 1) & 0xFFFFFFFFFFFFFFFELL;
    *(int16x4_t *)v14.i8 = vuzp1_s16(v17, v17);
    if (a2 >> 1 <= 1) {
      uint64_t v19 = 1;
    }
    else {
      uint64_t v19 = a2 >> 1;
    }
    unsigned __int32 v22 = vmovn_s16(v14).u32[0];
    do
    {
      unsigned __int32 __pattern4 = v22;
      memset_pattern4(v9, &__pattern4, v18);
      v9 += v7;
      --v19;
    }
    while (v19);
  }
  return 0;
}

uint64_t bvc_Fill_32ARGB_420v601(size_t __len, unint64_t a2, unsigned __int8 *a3, uint64_t *a4, char **a5)
{
  uint64_t v8 = *a4;
  uint64_t v7 = a4[1];
  uint64_t v10 = *a5;
  int v9 = a5[1];
  unsigned int v11 = a3[1];
  unsigned int v12 = a3[2];
  unsigned int v13 = 16508 * v12 + 8412 * v11 + 3219 * a3[3] + 540672;
  unsigned int v21 = a3[3];
  if (*a4 == __len)
  {
    memset(v10, v13 >> 15, __len * a2);
  }
  else
  {
    if (!a2) {
      return 0;
    }
    int v15 = v13 >> 15;
    unint64_t v16 = a2;
    do
    {
      memset(v10, v15, __len);
      v10 += v8;
      --v16;
    }
    while (v16);
  }
  if (a2 >= 2)
  {
    int16x4_t v17 = (int16x4_t)vshr_n_u32((uint32x2_t)vadd_s32(vmla_s32(vmla_s32(vmul_s32(vdup_n_s32(v12), (int32x2_t)0x7FD0F8007FDAC4), vdup_n_s32(v11), (int32x2_t)0x3838007FED06), vdup_n_s32(v21), (int32x2_t)0x7FF6D400003838), vdup_n_s32(0x404000u)), 0xFuLL);
    size_t v18 = (__len + 1) & 0xFFFFFFFFFFFFFFFELL;
    *(int16x4_t *)v14.i8 = vuzp1_s16(v17, v17);
    if (a2 >> 1 <= 1) {
      uint64_t v19 = 1;
    }
    else {
      uint64_t v19 = a2 >> 1;
    }
    unsigned __int32 v22 = vmovn_s16(v14).u32[0];
    do
    {
      unsigned __int32 __pattern4 = v22;
      memset_pattern4(v9, &__pattern4, v18);
      v9 += v7;
      --v19;
    }
    while (v19);
  }
  return 0;
}

uint64_t bvc_FullCompositionOpaque_420v_420v(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v71 = *a3;
  uint64_t v72 = *a2;
  uint64_t v73 = a3[1];
  uint64_t v74 = a2[1];
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  uint64_t v20 = *a4;
  uint64_t v75 = a4[1];
  OSType v86 = 0;
  double v87 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v84 = 0;
    uint64_t v85 = 0;
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    uint64_t v80 = 0;
    uint64_t v81 = 0;
    long long v28 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v77.CGFloat a = *(_OWORD *)a1;
    *(_OWORD *)&v77.double c = v28;
    *(_OWORD *)&v77.tCGFloat x = *((_OWORD *)a1 + 2);
    if (BVCUtilityIsAffineTransformInvertible(&v77.a))
    {
      memset(&v76, 0, sizeof(v76));
      long long v29 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v77.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v77.double c = v29;
      *(_OWORD *)&v77.tCGFloat x = *((_OWORD *)a1 + 2);
      CGAffineTransformInvert(&v76, &v77);
      double v64 = a1[3];
      double v65 = *a1;
      double v62 = a1[4];
      double v63 = a1[2];
      double v66 = a1[5];
      double v68 = a1[1];
      long long v30 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v77.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v77.double c = v30;
      *(_OWORD *)&v77.tCGFloat x = *((_OWORD *)a1 + 2);
      VectorsFromTransforCFIndex m = BVCUtilityGetVectorsFromTransform(&v77.a, &v85, &v84);
      if (VectorsFromTransform)
      {
        uint64_t v36 = VectorsFromTransform;
        int v37 = 0;
      }
      else
      {
        unsigned int v32 = v85;
        if ((int)v85 < 0) {
          unsigned int v32 = -(int)v85;
        }
        unsigned int v33 = v84;
        if ((int)v84 < 0) {
          unsigned int v33 = -(int)v84;
        }
        if (v32 <= v33) {
          int v34 = v33;
        }
        else {
          int v34 = v32;
        }
        CGAffineTransform v77 = v76;
        BVCUtilityGetVectorsFromTransform(&v77.a, &v83, &v82);
        long long v35 = *((_OWORD *)a1 + 1);
        *(_OWORD *)&v77.CGFloat a = *(_OWORD *)a1;
        *(_OWORD *)&v77.double c = v35;
        *(_OWORD *)&v77.tCGFloat x = *((_OWORD *)a1 + 2);
        uint64_t v36 = BVCUtilityCreateEdgeLists((float64x2_t *)&v77, &v87, &v86, a6, a7, a8, a9, a10, a11, a12, a13);
        int v37 = v87;
        if (!v36)
        {
          if (v87)
          {
            int v38 = v86;
            if (v86)
            {
              unsigned __int16 v39 = vcvts_n_s32_f32(a14, 8uLL);
              unsigned int v40 = vcvtd_n_s64_f64(v62 + v63 * 0.0 + v65 * 0.0, 0x10uLL);
              unsigned int v41 = vcvtd_n_s64_f64(v66 + v64 * 0.0 + v68 * 0.0, 0x10uLL);
              LODWORD(v77.a) = 0;
              uint64_t v79 = 0;
              int v78 = 0;
              int v42 = *(_DWORD *)v87;
              if (*(_DWORD *)v87 <= *v86) {
                int v42 = *v86;
              }
              int v43 = v42 + 0x8000;
              int v44 = (v42 + 0x8000) >> 16;
              signed int v69 = v41;
              signed int v45 = ((v42 + 0x8000) & 0xFFFF0000) - v41 + 0x8000;
              signed int v67 = v40;
              LODWORD(v81) = ((unint64_t)((int)v82 * (uint64_t)v45) >> 16)
                           + ((unint64_t)((int)v83 * (uint64_t)(int)(0x8000 - v40)) >> 16)
                           - ((int)v82 > 0);
              HIDWORD(v81) = ((unint64_t)(SHIDWORD(v83) * (uint64_t)(int)(0x8000 - v40)) >> 16)
                           + ((unint64_t)(SHIDWORD(v82) * (uint64_t)v45) >> 16)
                           - (SHIDWORD(v82) > 0);
              bvc_extractEdgeParameters(v87, 0, v44, v34, 1, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
              bvc_extractEdgeParameters(v38, 1, v43 >> 16, v34, 1, &v80, (_DWORD *)&v79 + 1, &v78);
              int v70 = a5;
              uint64_t v89 = *a5 + v20 * ((uint64_t)v43 >> 16);
              do
              {
                int v47 = v78;
                int v48 = v79;
                if ((int)v79 >= v78) {
                  int v49 = v78;
                }
                else {
                  int v49 = v79;
                }
                if (v49 > v44)
                {
                  bvc_FullCompositionOpaqueYInner_420v_420v_arm((v49 - v44), v39, &v89, v20, v71, v72, (int *)&v80 + 1, (int *)&v80, v46, SLODWORD(v77.a), SHIDWORD(v79), (int *)&v81, (int *)&v81 + 1, v83, HIDWORD(v83), v82, SHIDWORD(v82));
                  int v44 = v49;
                }
                if (v44 >= v48)
                {
                  int v37 = *(char **)(v37 + 20);
                  if (v37) {
                    bvc_extractEdgeParameters(v37, 0, v44, v34, 1, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
                  }
                }
                if (v44 >= v47)
                {
                  int v38 = *(_DWORD **)(v38 + 5);
                  if (!v38) {
                    break;
                  }
                  bvc_extractEdgeParameters(v38, 1, v44, v34, 1, &v80, (_DWORD *)&v79 + 1, &v78);
                }
              }
              while (v37);
              uint64_t v50 = v86;
              uint64_t v51 = v87;
              int v52 = *(_DWORD *)v87 / 2;
              if (v52 <= *v86 / 2) {
                int v52 = *v86 / 2;
              }
              int v53 = v52 + 0x8000;
              int v54 = (v52 + 0x8000) >> 16;
              signed int v55 = ((v52 + 0x8000) & 0xFFFF0000) - v69 / 2 + 0x8000;
              int v56 = 0x8000 - v67 / 2;
              LODWORD(v81) = ((unint64_t)((int)v82 * (uint64_t)v55) >> 16)
                           + ((unint64_t)((int)v83 * (uint64_t)v56) >> 16)
                           - ((int)v82 > 0);
              HIDWORD(v81) = ((unint64_t)(SHIDWORD(v83) * (uint64_t)v56) >> 16)
                           + ((unint64_t)(SHIDWORD(v82) * (uint64_t)v55) >> 16)
                           - (SHIDWORD(v82) > 0);
              bvc_extractEdgeParameters(v87, 0, v54, v34, 2, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
              bvc_extractEdgeParameters(v50, 1, v53 >> 16, v34, 2, &v80, (_DWORD *)&v79 + 1, &v78);
              uint64_t v88 = v70[1] + v75 * ((uint64_t)v53 >> 16);
              do
              {
                int v58 = v78;
                int v59 = v79;
                if ((int)v79 >= v78) {
                  int v60 = v78;
                }
                else {
                  int v60 = v79;
                }
                if (v60 > v54)
                {
                  bvc_FullCompositionOpaqueCbCrInner_420v_420v_arm((v60 - v54), v39, &v88, v75, v73, v74, (int *)&v80 + 1, (int *)&v80, v57, SLODWORD(v77.a), SHIDWORD(v79), (int *)&v81, (int *)&v81 + 1, v83, HIDWORD(v83), v82, SHIDWORD(v82));
                  int v54 = v60;
                }
                if (v54 >= v59)
                {
                  uint64_t v51 = *(char **)(v51 + 20);
                  if (v51) {
                    bvc_extractEdgeParameters(v51, 0, v54, v34, 2, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
                  }
                }
                if (v54 >= v58)
                {
                  uint64_t v50 = *(_DWORD **)(v50 + 5);
                  if (!v50) {
                    break;
                  }
                  bvc_extractEdgeParameters(v50, 1, v54, v34, 2, &v80, (_DWORD *)&v79 + 1, &v78);
                }
              }
              while (v51);
              uint64_t v36 = 0;
              int v37 = v87;
            }
          }
        }
      }
    }
    else
    {
      int v37 = 0;
      uint64_t v36 = 0;
    }
    BVCUtilityDestroyEdgeList((uint64_t)v37);
    BVCUtilityDestroyEdgeList((uint64_t)v86);
    return v36;
  }
}

uint64_t bvc_FullComposition_420v_420v(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v71 = *a3;
  uint64_t v72 = *a2;
  uint64_t v73 = a3[1];
  uint64_t v74 = a2[1];
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  uint64_t v20 = *a4;
  uint64_t v75 = a4[1];
  OSType v86 = 0;
  double v87 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v84 = 0;
    uint64_t v85 = 0;
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    uint64_t v80 = 0;
    uint64_t v81 = 0;
    long long v28 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v77.CGFloat a = *(_OWORD *)a1;
    *(_OWORD *)&v77.double c = v28;
    *(_OWORD *)&v77.tCGFloat x = *((_OWORD *)a1 + 2);
    if (BVCUtilityIsAffineTransformInvertible(&v77.a))
    {
      memset(&v76, 0, sizeof(v76));
      long long v29 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v77.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v77.double c = v29;
      *(_OWORD *)&v77.tCGFloat x = *((_OWORD *)a1 + 2);
      CGAffineTransformInvert(&v76, &v77);
      double v64 = a1[3];
      double v65 = *a1;
      double v62 = a1[4];
      double v63 = a1[2];
      double v66 = a1[5];
      double v68 = a1[1];
      long long v30 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v77.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v77.double c = v30;
      *(_OWORD *)&v77.tCGFloat x = *((_OWORD *)a1 + 2);
      VectorsFromTransforCFIndex m = BVCUtilityGetVectorsFromTransform(&v77.a, &v85, &v84);
      if (VectorsFromTransform)
      {
        uint64_t v36 = VectorsFromTransform;
        int v37 = 0;
      }
      else
      {
        unsigned int v32 = v85;
        if ((int)v85 < 0) {
          unsigned int v32 = -(int)v85;
        }
        unsigned int v33 = v84;
        if ((int)v84 < 0) {
          unsigned int v33 = -(int)v84;
        }
        if (v32 <= v33) {
          int v34 = v33;
        }
        else {
          int v34 = v32;
        }
        CGAffineTransform v77 = v76;
        BVCUtilityGetVectorsFromTransform(&v77.a, &v83, &v82);
        long long v35 = *((_OWORD *)a1 + 1);
        *(_OWORD *)&v77.CGFloat a = *(_OWORD *)a1;
        *(_OWORD *)&v77.double c = v35;
        *(_OWORD *)&v77.tCGFloat x = *((_OWORD *)a1 + 2);
        uint64_t v36 = BVCUtilityCreateEdgeLists((float64x2_t *)&v77, &v87, &v86, a6, a7, a8, a9, a10, a11, a12, a13);
        int v37 = v87;
        if (!v36)
        {
          if (v87)
          {
            int v38 = v86;
            if (v86)
            {
              unsigned __int16 v39 = vcvts_n_s32_f32(a14, 8uLL);
              unsigned int v40 = vcvtd_n_s64_f64(v62 + v63 * 0.0 + v65 * 0.0, 0x10uLL);
              unsigned int v41 = vcvtd_n_s64_f64(v66 + v64 * 0.0 + v68 * 0.0, 0x10uLL);
              LODWORD(v77.a) = 0;
              uint64_t v79 = 0;
              int v78 = 0;
              int v42 = *(_DWORD *)v87;
              if (*(_DWORD *)v87 <= *v86) {
                int v42 = *v86;
              }
              int v43 = v42 + 0x8000;
              int v44 = (v42 + 0x8000) >> 16;
              signed int v69 = v41;
              signed int v45 = ((v42 + 0x8000) & 0xFFFF0000) - v41 + 0x8000;
              signed int v67 = v40;
              LODWORD(v81) = ((unint64_t)((int)v82 * (uint64_t)v45) >> 16)
                           + ((unint64_t)((int)v83 * (uint64_t)(int)(0x8000 - v40)) >> 16)
                           - ((int)v82 > 0);
              HIDWORD(v81) = ((unint64_t)(SHIDWORD(v83) * (uint64_t)(int)(0x8000 - v40)) >> 16)
                           + ((unint64_t)(SHIDWORD(v82) * (uint64_t)v45) >> 16)
                           - (SHIDWORD(v82) > 0);
              bvc_extractEdgeParameters(v87, 0, v44, v34, 1, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
              bvc_extractEdgeParameters(v38, 1, v43 >> 16, v34, 1, &v80, (_DWORD *)&v79 + 1, &v78);
              int v70 = a5;
              uint64_t v89 = *a5 + v20 * ((uint64_t)v43 >> 16);
              do
              {
                int v47 = v78;
                int v48 = v79;
                if ((int)v79 >= v78) {
                  int v49 = v78;
                }
                else {
                  int v49 = v79;
                }
                if (v49 > v44)
                {
                  bvc_FullCompositionYInner_420v_420v_arm((v49 - v44), v39, &v89, v20, v71, v72, (int *)&v80 + 1, (int *)&v80, v46, SLODWORD(v77.a), SHIDWORD(v79), (int *)&v81, (int *)&v81 + 1, v83, HIDWORD(v83), v82, SHIDWORD(v82));
                  int v44 = v49;
                }
                if (v44 >= v48)
                {
                  int v37 = *(char **)(v37 + 20);
                  if (v37) {
                    bvc_extractEdgeParameters(v37, 0, v44, v34, 1, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
                  }
                }
                if (v44 >= v47)
                {
                  int v38 = *(_DWORD **)(v38 + 5);
                  if (!v38) {
                    break;
                  }
                  bvc_extractEdgeParameters(v38, 1, v44, v34, 1, &v80, (_DWORD *)&v79 + 1, &v78);
                }
              }
              while (v37);
              uint64_t v50 = v86;
              uint64_t v51 = v87;
              int v52 = *(_DWORD *)v87 / 2;
              if (v52 <= *v86 / 2) {
                int v52 = *v86 / 2;
              }
              int v53 = v52 + 0x8000;
              int v54 = (v52 + 0x8000) >> 16;
              signed int v55 = ((v52 + 0x8000) & 0xFFFF0000) - v69 / 2 + 0x8000;
              int v56 = 0x8000 - v67 / 2;
              LODWORD(v81) = ((unint64_t)((int)v82 * (uint64_t)v55) >> 16)
                           + ((unint64_t)((int)v83 * (uint64_t)v56) >> 16)
                           - ((int)v82 > 0);
              HIDWORD(v81) = ((unint64_t)(SHIDWORD(v83) * (uint64_t)v56) >> 16)
                           + ((unint64_t)(SHIDWORD(v82) * (uint64_t)v55) >> 16)
                           - (SHIDWORD(v82) > 0);
              bvc_extractEdgeParameters(v87, 0, v54, v34, 2, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
              bvc_extractEdgeParameters(v50, 1, v53 >> 16, v34, 2, &v80, (_DWORD *)&v79 + 1, &v78);
              uint64_t v88 = v70[1] + v75 * ((uint64_t)v53 >> 16);
              do
              {
                int v58 = v78;
                int v59 = v79;
                if ((int)v79 >= v78) {
                  int v60 = v78;
                }
                else {
                  int v60 = v79;
                }
                if (v60 > v54)
                {
                  bvc_FullCompositionCbCrInner_420v_420v_arm((v60 - v54), v39, &v88, v75, v73, v74, (int *)&v80 + 1, (int *)&v80, v57, SLODWORD(v77.a), SHIDWORD(v79), (int *)&v81, (int *)&v81 + 1, v83, HIDWORD(v83), v82, SHIDWORD(v82));
                  int v54 = v60;
                }
                if (v54 >= v59)
                {
                  uint64_t v51 = *(char **)(v51 + 20);
                  if (v51) {
                    bvc_extractEdgeParameters(v51, 0, v54, v34, 2, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
                  }
                }
                if (v54 >= v58)
                {
                  uint64_t v50 = *(_DWORD **)(v50 + 5);
                  if (!v50) {
                    break;
                  }
                  bvc_extractEdgeParameters(v50, 1, v54, v34, 2, &v80, (_DWORD *)&v79 + 1, &v78);
                }
              }
              while (v51);
              uint64_t v36 = 0;
              int v37 = v87;
            }
          }
        }
      }
    }
    else
    {
      int v37 = 0;
      uint64_t v36 = 0;
    }
    BVCUtilityDestroyEdgeList((uint64_t)v37);
    BVCUtilityDestroyEdgeList((uint64_t)v86);
    return v36;
  }
}

uint64_t bvc_FullCompositionOpaque_ARGB_420v709(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v15 = *a2;
  uint64_t v16 = *a3;
  uint64_t v18 = *a4;
  uint64_t v17 = a4[1];
  double v154 = 0;
  double v155 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v152 = 0;
    uint64_t v153 = 0;
    uint64_t v151 = 0;
    uint64_t v150 = 0;
    long long v27 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
    *(_OWORD *)&v146.double c = v27;
    *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
    if (BVCUtilityIsAffineTransformInvertible(&v146.a))
    {
      memset(&v145, 0, sizeof(v145));
      long long v28 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v146.double c = v28;
      *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
      CGAffineTransformInvert(&v145, &v146);
      double v135 = *a1;
      double v140 = a1[1];
      double v130 = a1[3];
      double v118 = a1[4];
      double v121 = a1[2];
      double v124 = a1[5];
      long long v29 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v146.double c = v29;
      *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
      VectorsFromTransforCFIndex m = BVCUtilityGetVectorsFromTransform(&v146.a, &v153, &v152);
      if (VectorsFromTransform)
      {
        uint64_t v34 = VectorsFromTransform;
      }
      else
      {
        unsigned int v31 = v153;
        if ((int)v153 < 0) {
          unsigned int v31 = -(int)v153;
        }
        unsigned int v32 = v152;
        if ((int)v152 < 0) {
          unsigned int v32 = -(int)v152;
        }
        if (v31 <= v32) {
          unsigned int v31 = v32;
        }
        int v120 = v31;
        CGAffineTransform v146 = v145;
        BVCUtilityGetVectorsFromTransform(&v146.a, &v151, &v150);
        long long v33 = *((_OWORD *)a1 + 1);
        *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
        *(_OWORD *)&v146.double c = v33;
        *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
        uint64_t v34 = BVCUtilityCreateEdgeLists((float64x2_t *)&v146, &v155, &v154, a6, a7, a8, a9, a10, a11, a12, a13);
        if (!v34 && v155 && v154)
        {
          uint64_t v116 = v17;
          unsigned int v35 = vcvtd_n_s64_f64(v118 + v121 * 0.0 + v135 * 0.0, 0x10uLL);
          unsigned int v36 = vcvtd_n_s64_f64(v124 + v130 * 0.0 + v140 * 0.0, 0x10uLL);
          LODWORD(v146.a) = 0;
          uint64_t v148 = 0;
          uint64_t v149 = 0;
          int v147 = 0;
          int v37 = *(_DWORD *)v155;
          if (*(_DWORD *)v155 <= *v154) {
            int v37 = *v154;
          }
          signed int v114 = v35;
          signed int v115 = v36;
          signed int v38 = 0x8000 - v35;
          unsigned __int16 v39 = v154;
          int v141 = v37 + 0x8000;
          signed int v40 = ((v37 + 0x8000) & 0xFFFF0000) - v36 + 0x8000;
          int v41 = ((unint64_t)((int)v151 * (uint64_t)v38) >> 16)
              - ((int)v150 > 0)
              + ((unint64_t)((int)v150 * (uint64_t)v40) >> 16);
          uint64_t v42 = v18;
          int v43 = (v37 + 0x8000) >> 16;
          int v44 = ((unint64_t)(SHIDWORD(v151) * (uint64_t)v38) >> 16)
              - (SHIDWORD(v150) > 0)
              + ((unint64_t)(SHIDWORD(v150) * (uint64_t)v40) >> 16);
          signed int v45 = v155;
          bvc_extractEdgeParameters(v155, 0, v43, v120, 1, &v146, &v149, (int *)&v148);
          bvc_extractEdgeParameters(v39, 1, v43, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
          int v46 = v43;
          int v47 = v39;
          int v48 = v45;
          uint64_t v49 = *a5 + v42 * ((uint64_t)v141 >> 16);
          do
          {
            int v50 = v147;
            int v51 = v148;
            if ((int)v148 < v147) {
              int v50 = v148;
            }
            int v52 = v50 - v46;
            if (v50 > v46)
            {
              CGFloat v131 = v47;
              double v136 = v48;
              int v53 = 0;
              int v54 = HIDWORD(v148);
              int v55 = v149;
              int v56 = v151;
              int v57 = HIDWORD(v151);
              int v58 = v150;
              int v59 = HIDWORD(v150);
              int a_low = LODWORD(v146.a);
              int v122 = HIDWORD(v149);
              int v61 = HIDWORD(v149);
              do
              {
                LODWORD(v62) = a_low >> 16;
                if (a_low >> 16 < (v61 >> 16))
                {
                  unint64_t v62 = (int)v62;
                  int v63 = v44 + ((unint64_t)(v57 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                  int v64 = v41 + ((unint64_t)(v56 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                  do
                  {
                    double v65 = (unsigned __int8 *)(v16
                                            + (((uint64_t)v64 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                            + ((v63 >> 16) * v15));
                    int v66 = *v65;
                    if (*v65)
                    {
                      unsigned int v67 = (2120 * v66 + 2032 * v65[3] + 20127 * v65[2] + 5983 * v65[1]) >> 15;
                      if (v66 != 255) {
                        v67 += ((16776959 * v66 + 0x10000) * *(unsigned __int8 *)(v49 + v62)) >> 16;
                      }
                      *(unsigned char *)(v49 + v62) = v67;
                    }
                    v64 += v56;
                    v63 += v57;
                    ++v62;
                  }
                  while (v62 < (uint64_t)v61 >> 16);
                }
                a_low += v55;
                v61 += v54;
                v41 += v58;
                v44 += v59;
                v49 += v42;
                ++v53;
              }
              while (v53 != v52);
              LODWORD(v146.a) = a_low;
              HIDWORD(v149) = v122 + v54 * v52;
              int v51 = v148;
              int v46 = v50;
              int v47 = v131;
              int v48 = v136;
            }
            if (v46 >= v51)
            {
              int v48 = *(char **)(v48 + 20);
              if (v48)
              {
                int v125 = v46;
                double v132 = v47;
                double v137 = v48;
                bvc_extractEdgeParameters(v48, 0, v46, v120, 1, &v146, &v149, (int *)&v148);
                int v46 = v125;
                int v47 = v132;
                int v48 = v137;
              }
            }
            if (v46 >= v147)
            {
              double v68 = *(_DWORD **)(v47 + 5);
              if (!v68) {
                break;
              }
              int v126 = v46;
              CFTypeRef v133 = v68;
              int v138 = v48;
              bvc_extractEdgeParameters(v68, 1, v46, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
              int v46 = v126;
              int v47 = v133;
              int v48 = v138;
            }
          }
          while (v48);
          uint64_t v69 = 2 * (int)v151;
          BOOL v70 = (int)v150 > 0;
          uint64_t v71 = 2 * (int)v150;
          uint64_t v72 = 2 * SHIDWORD(v151);
          LODWORD(v151) = 2 * v151;
          HIDWORD(v151) *= 2;
          BOOL v73 = SHIDWORD(v150) > 0;
          uint64_t v74 = 2 * SHIDWORD(v150);
          LODWORD(v150) = 2 * v150;
          HIDWORD(v150) *= 2;
          uint64_t v75 = v154;
          CGAffineTransform v76 = v155;
          int v77 = *(_DWORD *)v155 / 2;
          if (v77 <= *v154 / 2) {
            int v77 = *v154 / 2;
          }
          int v78 = v77 + 0x8000;
          uint64_t v79 = (int)(((v77 + 0x8000) & 0xFFFF0000) - v115 / 2 + 0x8000);
          uint64_t v80 = 0x8000 - v114 / 2;
          int v81 = ((unint64_t)(v69 * v80) >> 16) - v70 + ((unint64_t)(v79 * v71) >> 16);
          int v82 = ((unint64_t)(v72 * v80) >> 16) - v73 + ((unint64_t)(v79 * v74) >> 16);
          bvc_extractEdgeParameters(v155, 0, (v77 + 0x8000) >> 16, v120, 2, &v146, &v149, (int *)&v148);
          CFDictionaryRef v123 = v75;
          bvc_extractEdgeParameters(v75, 1, v78 >> 16, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
          int v83 = v78 >> 16;
          uint64_t v84 = v76;
          uint64_t v85 = a5[1] + v116 * ((uint64_t)v78 >> 16);
          uint64_t v134 = v116;
          do
          {
            int v86 = v147;
            int v87 = v148;
            if ((int)v148 < v147) {
              int v86 = v148;
            }
            int v88 = v86 - v83;
            if (v86 > v83)
            {
              int v119 = v86;
              CGFloat v127 = v84;
              int v89 = 0;
              int v90 = HIDWORD(v148);
              int v142 = v149;
              int v91 = v151;
              int v92 = HIDWORD(v151);
              int v93 = HIDWORD(v150);
              int v139 = v150;
              int v94 = LODWORD(v146.a);
              int v117 = HIDWORD(v149);
              int v95 = HIDWORD(v149);
              do
              {
                int v96 = v94 >> 16;
                if (v94 >> 16 < (v95 >> 16))
                {
                  unint64_t v97 = v96;
                  uint64_t v98 = 2 * v96;
                  int v99 = v82 + ((unint64_t)(v92 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                  int v100 = v81 + ((unint64_t)(v91 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                  do
                  {
                    uint64_t v101 = (unsigned __int8 *)(v16
                                             + (((uint64_t)v100 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                             + ((v99 >> 16) * v15));
                    int v102 = *v101;
                    if (*v101)
                    {
                      int v103 = v101[3];
                      int v104 = v101[2];
                      int v105 = v101[1];
                      unsigned int v106 = (14392 * v103 + 16512 * v102 - 11093 * v104 - 3298 * v105) >> 15;
                      unsigned int v107 = (-1317 * v103 + 16512 * v102 - 13073 * v104 + 14392 * v105) >> 15;
                      if (v102 == 255)
                      {
                        CGRect v108 = (unsigned char *)(v85 + v98);
                        *CGRect v108 = v106;
                        v108[1] = v107;
                      }
                      else
                      {
                        CGRect v109 = (unsigned char *)(v85 + v98);
                        int v110 = 0x10000 - (v102 | (v102 << 8));
                        *CGRect v109 = v106 + ((v110 * *(unsigned __int8 *)(v85 + v98)) >> 16);
                        v109[1] = v107 + ((v110 * *(unsigned __int8 *)(v85 + v98 + 1)) >> 16);
                      }
                    }
                    v100 += v91;
                    v99 += v92;
                    ++v97;
                    v98 += 2;
                  }
                  while (v97 < (uint64_t)v95 >> 16);
                }
                v94 += v142;
                v95 += v90;
                v81 += v139;
                v82 += v93;
                v85 += v134;
                ++v89;
              }
              while (v89 != v88);
              LODWORD(v146.a) = v94;
              HIDWORD(v149) = v117 + v90 * v88;
              int v87 = v148;
              int v83 = v119;
              uint64_t v84 = v127;
            }
            if (v83 >= v87)
            {
              uint64_t v84 = *(char **)(v84 + 20);
              if (v84)
              {
                int v143 = v83;
                CGFloat v128 = v84;
                bvc_extractEdgeParameters(v84, 0, v83, v120, 2, &v146, &v149, (int *)&v148);
                int v83 = v143;
                uint64_t v84 = v128;
              }
            }
            if (v83 >= v147)
            {
              unsigned int v111 = *(_DWORD **)(v123 + 5);
              if (!v111) {
                goto LABEL_67;
              }
              CFDictionaryRef v123 = *(_DWORD **)(v123 + 5);
              CGFloat v129 = v84;
              int v144 = v83;
              bvc_extractEdgeParameters(v111, 1, v83, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
              int v83 = v144;
              uint64_t v84 = v129;
            }
            uint64_t v34 = 0;
          }
          while (v84 && v123);
        }
      }
    }
    else
    {
LABEL_67:
      uint64_t v34 = 0;
    }
    uint64_t v113 = v34;
    BVCUtilityDestroyEdgeList((uint64_t)v155);
    BVCUtilityDestroyEdgeList((uint64_t)v154);
    return v113;
  }
}

uint64_t bvc_FullComposition_ARGB_420v709(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v20 = *a2;
  uint64_t v21 = *a3;
  uint64_t v23 = *a4;
  uint64_t v22 = a4[1];
  uint64_t v149 = 0;
  uint64_t v150 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v147 = 0;
    uint64_t v148 = 0;
    uint64_t v146 = 0;
    uint64_t v145 = 0;
    long long v31 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
    *(_OWORD *)&v141.double c = v31;
    *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
    if (BVCUtilityIsAffineTransformInvertible(&v141.a))
    {
      memset(&v140, 0, sizeof(v140));
      long long v32 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v141.double c = v32;
      *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
      CGAffineTransformInvert(&v140, &v141);
      double v127 = *a1;
      double v131 = a1[1];
      double v124 = a1[3];
      double v118 = a1[4];
      double v120 = a1[2];
      double v122 = a1[5];
      long long v33 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v141.double c = v33;
      *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
      VectorsFromTransforCFIndex m = BVCUtilityGetVectorsFromTransform(&v141.a, &v148, &v147);
      if (VectorsFromTransform)
      {
        uint64_t v38 = VectorsFromTransform;
      }
      else
      {
        unsigned int v35 = v148;
        if ((int)v148 < 0) {
          unsigned int v35 = -(int)v148;
        }
        unsigned int v36 = v147;
        if ((int)v147 < 0) {
          unsigned int v36 = -(int)v147;
        }
        if (v35 <= v36) {
          unsigned int v35 = v36;
        }
        int v123 = v35;
        CGAffineTransform v141 = v140;
        BVCUtilityGetVectorsFromTransform(&v141.a, &v146, &v145);
        long long v37 = *((_OWORD *)a1 + 1);
        *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
        *(_OWORD *)&v141.double c = v37;
        *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
        uint64_t v38 = BVCUtilityCreateEdgeLists((float64x2_t *)&v141, &v150, &v149, a6, a7, a8, a9, a10, a11, a12, a13);
        if (!v38)
        {
          if (v150)
          {
            unsigned __int16 v39 = v149;
            if (v149)
            {
              uint64_t v117 = v22;
              unsigned int v40 = vcvts_n_s32_f32(a14, 8uLL);
              unsigned int v41 = vcvtd_n_s64_f64(v118 + v120 * 0.0 + v127 * 0.0, 0x10uLL);
              unsigned int v42 = vcvtd_n_s64_f64(v122 + v124 * 0.0 + v131 * 0.0, 0x10uLL);
              LODWORD(v141.a) = 0;
              uint64_t v143 = 0;
              uint64_t v144 = 0;
              int v142 = 0;
              int v43 = *(_DWORD *)v150;
              if (*(_DWORD *)v150 <= *v149) {
                int v43 = *v149;
              }
              signed int v115 = v41;
              signed int v116 = v42;
              signed int v44 = 0x8000 - v41;
              int v132 = v43 + 0x8000;
              uint64_t v135 = v23;
              signed int v45 = ((v43 + 0x8000) & 0xFFFF0000) - v42 + 0x8000;
              int v46 = ((unint64_t)((int)v146 * (uint64_t)v44) >> 16)
                  - ((int)v145 > 0)
                  + ((unint64_t)((int)v145 * (uint64_t)v45) >> 16);
              int v47 = (v43 + 0x8000) >> 16;
              int v48 = ((unint64_t)(SHIDWORD(v146) * (uint64_t)v44) >> 16)
                  - (SHIDWORD(v145) > 0)
                  + ((unint64_t)(SHIDWORD(v145) * (uint64_t)v45) >> 16);
              uint64_t v49 = v150;
              bvc_extractEdgeParameters(v150, 0, v47, v123, 1, &v141, &v144, (int *)&v143);
              bvc_extractEdgeParameters(v39, 1, v47, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
              int v50 = v47;
              int v51 = v39;
              int v52 = v49;
              int v119 = a5;
              uint64_t v53 = *a5 + v135 * ((uint64_t)v132 >> 16);
              uint64_t v54 = (0x10101020000 * (v40 << 8)) >> 48;
              uint64_t v133 = v135;
              do
              {
                int v55 = v142;
                int v56 = v143;
                if ((int)v143 < v142) {
                  int v55 = v143;
                }
                int v57 = v55 - v50;
                if (v55 > v50)
                {
                  CGFloat v128 = v52;
                  int v58 = 0;
                  int v59 = HIDWORD(v143);
                  int v136 = v144;
                  int v60 = v146;
                  int v61 = HIDWORD(v146);
                  int v62 = v145;
                  int v63 = HIDWORD(v145);
                  int a_low = LODWORD(v141.a);
                  int v121 = HIDWORD(v144);
                  int v65 = HIDWORD(v144);
                  do
                  {
                    LODWORD(v66) = a_low >> 16;
                    if (a_low >> 16 < (v65 >> 16))
                    {
                      unint64_t v66 = (int)v66;
                      int v67 = v48 + ((unint64_t)(v61 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                      int v68 = v46 + ((unint64_t)(v60 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                      do
                      {
                        uint64_t v69 = (unsigned __int8 *)(v21
                                                + (((uint64_t)v68 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                                + ((v67 >> 16) * v20));
                        int v70 = *v69;
                        if (v54 * v70) {
                          *(unsigned char *)(v53 + v66) = (unsigned __int16)(((2120 * v70
                        }
                                                                     + 2032 * v69[3]
                                                                     + 20127 * v69[2]
                                                                     + 5983 * v69[1]) >> 15)
                                                                   * v40
                                                                   + (((0x10000 - v54 * v70)
                                                                     * *(unsigned __int8 *)(v53 + v66)) >> 8)) >> 8;
                        v68 += v60;
                        v67 += v61;
                        ++v66;
                      }
                      while (v66 < (uint64_t)v65 >> 16);
                    }
                    a_low += v136;
                    v65 += v59;
                    v46 += v62;
                    v48 += v63;
                    v53 += v133;
                    ++v58;
                  }
                  while (v58 != v57);
                  LODWORD(v141.a) = a_low;
                  HIDWORD(v144) = v121 + v59 * v57;
                  int v56 = v143;
                  int v50 = v55;
                  int v52 = v128;
                }
                if (v50 >= v56)
                {
                  int v52 = *(char **)(v52 + 20);
                  if (v52)
                  {
                    int v137 = v50;
                    int v125 = v51;
                    CGFloat v129 = v52;
                    bvc_extractEdgeParameters(v52, 0, v50, v123, 1, &v141, &v144, (int *)&v143);
                    int v50 = v137;
                    int v51 = v125;
                    int v52 = v129;
                  }
                }
                if (v50 >= v142)
                {
                  uint64_t v71 = *(_DWORD **)(v51 + 5);
                  if (!v71) {
                    break;
                  }
                  int v138 = v50;
                  int v126 = v71;
                  double v130 = v52;
                  bvc_extractEdgeParameters(v71, 1, v50, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                  int v50 = v138;
                  int v51 = v126;
                  int v52 = v130;
                }
              }
              while (v52 && v51);
              uint64_t v72 = 2 * (int)v146;
              BOOL v73 = (int)v145 > 0;
              uint64_t v74 = 2 * (int)v145;
              uint64_t v75 = 2 * SHIDWORD(v146);
              LODWORD(v146) = 2 * v146;
              HIDWORD(v146) *= 2;
              BOOL v76 = SHIDWORD(v145) > 0;
              uint64_t v77 = 2 * SHIDWORD(v145);
              LODWORD(v145) = 2 * v145;
              HIDWORD(v145) *= 2;
              int v78 = v150;
              int v139 = v149;
              int v79 = *(_DWORD *)v150 / 2;
              if (v79 <= *v149 / 2) {
                int v79 = *v149 / 2;
              }
              int v80 = v79 + 0x8000;
              int v81 = (v79 + 0x8000) >> 16;
              uint64_t v82 = (int)(((v79 + 0x8000) & 0xFFFF0000) - v116 / 2 + 0x8000);
              uint64_t v83 = 0x8000 - v115 / 2;
              int v84 = ((unint64_t)(v72 * v83) >> 16) - v73 + ((unint64_t)(v82 * v74) >> 16);
              int v85 = ((unint64_t)(v75 * v83) >> 16) - v76 + ((unint64_t)(v82 * v77) >> 16);
              bvc_extractEdgeParameters(v150, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
              bvc_extractEdgeParameters(v139, 1, v80 >> 16, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
              int v86 = v78;
              uint64_t v87 = v119[1] + v117 * ((uint64_t)v80 >> 16);
              int32x2_t v88 = vdup_n_s32(v40);
              do
              {
                int v89 = v143;
                if ((int)v143 >= v142) {
                  int v90 = v142;
                }
                else {
                  int v90 = v143;
                }
                int v91 = v90 - v81;
                if (v90 > v81)
                {
                  uint64_t v134 = v86;
                  int v92 = 0;
                  int v93 = HIDWORD(v143);
                  int v94 = v144;
                  int v95 = v146;
                  int v96 = HIDWORD(v146);
                  int v97 = v145;
                  int v98 = HIDWORD(v145);
                  int v99 = LODWORD(v141.a);
                  int v100 = HIDWORD(v144);
                  int v101 = HIDWORD(v144);
                  do
                  {
                    LODWORD(v102) = v99 >> 16;
                    if (v99 >> 16 < (v101 >> 16))
                    {
                      unint64_t v102 = (int)v102;
                      int v103 = v85 + ((unint64_t)(v96 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                      int v104 = v84 + ((unint64_t)(v95 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                      do
                      {
                        int v105 = (unsigned __int8 *)(v21
                                                 + (((uint64_t)v104 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                                 + ((v103 >> 16) * v20));
                        int v106 = *v105;
                        if (v54 * v106)
                        {
                          uint32x2_t v107 = (uint32x2_t)vmul_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32(vmla_s32(vmla_s32(vdup_n_s32(16512 * v106), vdup_n_s32(v105[3]), (int32x2_t)0xFFFFFADB00003838), vdup_n_s32(v105[2]), (int32x2_t)0xFFFFCCEFFFFFD4ABLL), vdup_n_s32(v105[1]), (int32x2_t)0x3838FFFFF31ELL), 0xFuLL), v88);
                          CGRect v108 = (unsigned __int8 *)(v87 + 2 * v102);
                          v109.i32[0] = *v108;
                          v109.i32[1] = v108[1];
                          uint32x2_t v110 = vshr_n_u32(vsra_n_u32(v107, (uint32x2_t)vmul_s32(vdup_n_s32(0x10000 - (int)v54 * v106), v109), 8uLL), 8uLL);
                          *CGRect v108 = v110.i8[0];
                          v108[1] = v110.u8[4];
                        }
                        v104 += v95;
                        v103 += v96;
                        ++v102;
                      }
                      while (v102 < (uint64_t)v101 >> 16);
                    }
                    v99 += v94;
                    v101 += v93;
                    v84 += v97;
                    v85 += v98;
                    v87 += v117;
                    ++v92;
                  }
                  while (v92 != v91);
                  LODWORD(v141.a) = v99;
                  HIDWORD(v144) = v100 + v93 * v91;
                  int v89 = v143;
                  int v81 = v90;
                  int v86 = v134;
                }
                if (v81 >= v89)
                {
                  int v86 = *(char **)(v86 + 20);
                  if (v86)
                  {
                    unsigned int v111 = v86;
                    bvc_extractEdgeParameters(v86, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
                    int v86 = v111;
                  }
                }
                if (v81 >= v142)
                {
                  BOOL v112 = *(_DWORD **)(v139 + 5);
                  if (!v112) {
                    goto LABEL_65;
                  }
                  int v139 = *(_DWORD **)(v139 + 5);
                  uint64_t v113 = v86;
                  bvc_extractEdgeParameters(v112, 1, v81, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                  int v86 = v113;
                }
                uint64_t v38 = 0;
              }
              while (v86 && v139);
            }
          }
        }
      }
    }
    else
    {
LABEL_65:
      uint64_t v38 = 0;
    }
    BVCUtilityDestroyEdgeList((uint64_t)v150);
    BVCUtilityDestroyEdgeList((uint64_t)v149);
    return v38;
  }
}

uint64_t bvc_FullCompositionOpaque_ARGB_420v601(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v15 = *a2;
  uint64_t v16 = *a3;
  uint64_t v18 = *a4;
  uint64_t v17 = a4[1];
  double v154 = 0;
  double v155 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v152 = 0;
    uint64_t v153 = 0;
    uint64_t v151 = 0;
    uint64_t v150 = 0;
    long long v27 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
    *(_OWORD *)&v146.double c = v27;
    *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
    if (BVCUtilityIsAffineTransformInvertible(&v146.a))
    {
      memset(&v145, 0, sizeof(v145));
      long long v28 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v146.double c = v28;
      *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
      CGAffineTransformInvert(&v145, &v146);
      double v135 = *a1;
      double v140 = a1[1];
      double v130 = a1[3];
      double v118 = a1[4];
      double v121 = a1[2];
      double v124 = a1[5];
      long long v29 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v146.double c = v29;
      *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
      VectorsFromTransforCFIndex m = BVCUtilityGetVectorsFromTransform(&v146.a, &v153, &v152);
      if (VectorsFromTransform)
      {
        uint64_t v34 = VectorsFromTransform;
      }
      else
      {
        unsigned int v31 = v153;
        if ((int)v153 < 0) {
          unsigned int v31 = -(int)v153;
        }
        unsigned int v32 = v152;
        if ((int)v152 < 0) {
          unsigned int v32 = -(int)v152;
        }
        if (v31 <= v32) {
          unsigned int v31 = v32;
        }
        int v120 = v31;
        CGAffineTransform v146 = v145;
        BVCUtilityGetVectorsFromTransform(&v146.a, &v151, &v150);
        long long v33 = *((_OWORD *)a1 + 1);
        *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
        *(_OWORD *)&v146.double c = v33;
        *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
        uint64_t v34 = BVCUtilityCreateEdgeLists((float64x2_t *)&v146, &v155, &v154, a6, a7, a8, a9, a10, a11, a12, a13);
        if (!v34 && v155 && v154)
        {
          uint64_t v116 = v17;
          unsigned int v35 = vcvtd_n_s64_f64(v118 + v121 * 0.0 + v135 * 0.0, 0x10uLL);
          unsigned int v36 = vcvtd_n_s64_f64(v124 + v130 * 0.0 + v140 * 0.0, 0x10uLL);
          LODWORD(v146.a) = 0;
          uint64_t v148 = 0;
          uint64_t v149 = 0;
          int v147 = 0;
          int v37 = *(_DWORD *)v155;
          if (*(_DWORD *)v155 <= *v154) {
            int v37 = *v154;
          }
          signed int v114 = v35;
          signed int v115 = v36;
          signed int v38 = 0x8000 - v35;
          unsigned __int16 v39 = v154;
          int v141 = v37 + 0x8000;
          signed int v40 = ((v37 + 0x8000) & 0xFFFF0000) - v36 + 0x8000;
          int v41 = ((unint64_t)((int)v151 * (uint64_t)v38) >> 16)
              - ((int)v150 > 0)
              + ((unint64_t)((int)v150 * (uint64_t)v40) >> 16);
          uint64_t v42 = v18;
          int v43 = (v37 + 0x8000) >> 16;
          int v44 = ((unint64_t)(SHIDWORD(v151) * (uint64_t)v38) >> 16)
              - (SHIDWORD(v150) > 0)
              + ((unint64_t)(SHIDWORD(v150) * (uint64_t)v40) >> 16);
          signed int v45 = v155;
          bvc_extractEdgeParameters(v155, 0, v43, v120, 1, &v146, &v149, (int *)&v148);
          bvc_extractEdgeParameters(v39, 1, v43, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
          int v46 = v43;
          int v47 = v39;
          int v48 = v45;
          uint64_t v49 = *a5 + v42 * ((uint64_t)v141 >> 16);
          do
          {
            int v50 = v147;
            int v51 = v148;
            if ((int)v148 < v147) {
              int v50 = v148;
            }
            int v52 = v50 - v46;
            if (v50 > v46)
            {
              double v131 = v47;
              int v136 = v48;
              int v53 = 0;
              int v54 = HIDWORD(v148);
              int v55 = v149;
              int v56 = v151;
              int v57 = HIDWORD(v151);
              int v58 = v150;
              int v59 = HIDWORD(v150);
              int a_low = LODWORD(v146.a);
              int v122 = HIDWORD(v149);
              int v61 = HIDWORD(v149);
              do
              {
                LODWORD(v62) = a_low >> 16;
                if (a_low >> 16 < (v61 >> 16))
                {
                  unint64_t v62 = (int)v62;
                  int v63 = v44 + ((unint64_t)(v57 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                  int v64 = v41 + ((unint64_t)(v56 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                  do
                  {
                    int v65 = (unsigned __int8 *)(v16
                                            + (((uint64_t)v64 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                            + ((v63 >> 16) * v15));
                    int v66 = *v65;
                    if (*v65)
                    {
                      unsigned int v67 = (2120 * v66 + 3219 * v65[3] + 16508 * v65[2] + 8412 * v65[1]) >> 15;
                      if (v66 != 255) {
                        v67 += ((16776959 * v66 + 0x10000) * *(unsigned __int8 *)(v49 + v62)) >> 16;
                      }
                      *(unsigned char *)(v49 + v62) = v67;
                    }
                    v64 += v56;
                    v63 += v57;
                    ++v62;
                  }
                  while (v62 < (uint64_t)v61 >> 16);
                }
                a_low += v55;
                v61 += v54;
                v41 += v58;
                v44 += v59;
                v49 += v42;
                ++v53;
              }
              while (v53 != v52);
              LODWORD(v146.a) = a_low;
              HIDWORD(v149) = v122 + v54 * v52;
              int v51 = v148;
              int v46 = v50;
              int v47 = v131;
              int v48 = v136;
            }
            if (v46 >= v51)
            {
              int v48 = *(char **)(v48 + 20);
              if (v48)
              {
                int v125 = v46;
                int v132 = v47;
                int v137 = v48;
                bvc_extractEdgeParameters(v48, 0, v46, v120, 1, &v146, &v149, (int *)&v148);
                int v46 = v125;
                int v47 = v132;
                int v48 = v137;
              }
            }
            if (v46 >= v147)
            {
              int v68 = *(_DWORD **)(v47 + 5);
              if (!v68) {
                break;
              }
              int v126 = v46;
              uint64_t v133 = v68;
              int v138 = v48;
              bvc_extractEdgeParameters(v68, 1, v46, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
              int v46 = v126;
              int v47 = v133;
              int v48 = v138;
            }
          }
          while (v48);
          uint64_t v69 = 2 * (int)v151;
          BOOL v70 = (int)v150 > 0;
          uint64_t v71 = 2 * (int)v150;
          uint64_t v72 = 2 * SHIDWORD(v151);
          LODWORD(v151) = 2 * v151;
          HIDWORD(v151) *= 2;
          BOOL v73 = SHIDWORD(v150) > 0;
          uint64_t v74 = 2 * SHIDWORD(v150);
          LODWORD(v150) = 2 * v150;
          HIDWORD(v150) *= 2;
          uint64_t v75 = v154;
          BOOL v76 = v155;
          int v77 = *(_DWORD *)v155 / 2;
          if (v77 <= *v154 / 2) {
            int v77 = *v154 / 2;
          }
          int v78 = v77 + 0x8000;
          uint64_t v79 = (int)(((v77 + 0x8000) & 0xFFFF0000) - v115 / 2 + 0x8000);
          uint64_t v80 = 0x8000 - v114 / 2;
          int v81 = ((unint64_t)(v69 * v80) >> 16) - v70 + ((unint64_t)(v79 * v71) >> 16);
          int v82 = ((unint64_t)(v72 * v80) >> 16) - v73 + ((unint64_t)(v79 * v74) >> 16);
          bvc_extractEdgeParameters(v155, 0, (v77 + 0x8000) >> 16, v120, 2, &v146, &v149, (int *)&v148);
          int v123 = v75;
          bvc_extractEdgeParameters(v75, 1, v78 >> 16, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
          int v83 = v78 >> 16;
          int v84 = v76;
          uint64_t v85 = a5[1] + v116 * ((uint64_t)v78 >> 16);
          uint64_t v134 = v116;
          do
          {
            int v86 = v147;
            int v87 = v148;
            if ((int)v148 < v147) {
              int v86 = v148;
            }
            int v88 = v86 - v83;
            if (v86 > v83)
            {
              int v119 = v86;
              double v127 = v84;
              int v89 = 0;
              int v90 = HIDWORD(v148);
              int v142 = v149;
              int v91 = v151;
              int v92 = HIDWORD(v151);
              int v93 = HIDWORD(v150);
              int v139 = v150;
              int v94 = LODWORD(v146.a);
              int v117 = HIDWORD(v149);
              int v95 = HIDWORD(v149);
              do
              {
                int v96 = v94 >> 16;
                if (v94 >> 16 < (v95 >> 16))
                {
                  unint64_t v97 = v96;
                  uint64_t v98 = 2 * v96;
                  int v99 = v82 + ((unint64_t)(v92 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                  int v100 = v81 + ((unint64_t)(v91 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                  do
                  {
                    int v101 = (unsigned __int8 *)(v16
                                             + (((uint64_t)v100 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                             + ((v99 >> 16) * v15));
                    int v102 = *v101;
                    if (*v101)
                    {
                      int v103 = v101[3];
                      int v104 = v101[2];
                      int v105 = v101[1];
                      unsigned int v106 = (14392 * v103 + 16512 * v102 - 9532 * v104 - 4858 * v105) >> 15;
                      unsigned int v107 = (-2348 * v103 + 16512 * v102 - 12040 * v104 + 14392 * v105) >> 15;
                      if (v102 == 255)
                      {
                        CGRect v108 = (unsigned char *)(v85 + v98);
                        *CGRect v108 = v106;
                        v108[1] = v107;
                      }
                      else
                      {
                        int32x2_t v109 = (unsigned char *)(v85 + v98);
                        int v110 = 0x10000 - (v102 | (v102 << 8));
                        *int32x2_t v109 = v106 + ((v110 * *(unsigned __int8 *)(v85 + v98)) >> 16);
                        v109[1] = v107 + ((v110 * *(unsigned __int8 *)(v85 + v98 + 1)) >> 16);
                      }
                    }
                    v100 += v91;
                    v99 += v92;
                    ++v97;
                    v98 += 2;
                  }
                  while (v97 < (uint64_t)v95 >> 16);
                }
                v94 += v142;
                v95 += v90;
                v81 += v139;
                v82 += v93;
                v85 += v134;
                ++v89;
              }
              while (v89 != v88);
              LODWORD(v146.a) = v94;
              HIDWORD(v149) = v117 + v90 * v88;
              int v87 = v148;
              int v83 = v119;
              int v84 = v127;
            }
            if (v83 >= v87)
            {
              int v84 = *(char **)(v84 + 20);
              if (v84)
              {
                int v143 = v83;
                CGFloat v128 = v84;
                bvc_extractEdgeParameters(v84, 0, v83, v120, 2, &v146, &v149, (int *)&v148);
                int v83 = v143;
                int v84 = v128;
              }
            }
            if (v83 >= v147)
            {
              unsigned int v111 = *(_DWORD **)(v123 + 5);
              if (!v111) {
                goto LABEL_67;
              }
              int v123 = *(_DWORD **)(v123 + 5);
              CGFloat v129 = v84;
              int v144 = v83;
              bvc_extractEdgeParameters(v111, 1, v83, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
              int v83 = v144;
              int v84 = v129;
            }
            uint64_t v34 = 0;
          }
          while (v84 && v123);
        }
      }
    }
    else
    {
LABEL_67:
      uint64_t v34 = 0;
    }
    uint64_t v113 = v34;
    BVCUtilityDestroyEdgeList((uint64_t)v155);
    BVCUtilityDestroyEdgeList((uint64_t)v154);
    return v113;
  }
}

uint64_t bvc_FullComposition_ARGB_420v601(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v20 = *a2;
  uint64_t v21 = *a3;
  uint64_t v23 = *a4;
  uint64_t v22 = a4[1];
  uint64_t v149 = 0;
  uint64_t v150 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v147 = 0;
    uint64_t v148 = 0;
    uint64_t v146 = 0;
    uint64_t v145 = 0;
    long long v31 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
    *(_OWORD *)&v141.double c = v31;
    *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
    if (BVCUtilityIsAffineTransformInvertible(&v141.a))
    {
      memset(&v140, 0, sizeof(v140));
      long long v32 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v141.double c = v32;
      *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
      CGAffineTransformInvert(&v140, &v141);
      double v127 = *a1;
      double v131 = a1[1];
      double v124 = a1[3];
      double v118 = a1[4];
      double v120 = a1[2];
      double v122 = a1[5];
      long long v33 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v141.double c = v33;
      *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
      VectorsFromTransforCFIndex m = BVCUtilityGetVectorsFromTransform(&v141.a, &v148, &v147);
      if (VectorsFromTransform)
      {
        uint64_t v38 = VectorsFromTransform;
      }
      else
      {
        unsigned int v35 = v148;
        if ((int)v148 < 0) {
          unsigned int v35 = -(int)v148;
        }
        unsigned int v36 = v147;
        if ((int)v147 < 0) {
          unsigned int v36 = -(int)v147;
        }
        if (v35 <= v36) {
          unsigned int v35 = v36;
        }
        int v123 = v35;
        CGAffineTransform v141 = v140;
        BVCUtilityGetVectorsFromTransform(&v141.a, &v146, &v145);
        long long v37 = *((_OWORD *)a1 + 1);
        *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
        *(_OWORD *)&v141.double c = v37;
        *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
        uint64_t v38 = BVCUtilityCreateEdgeLists((float64x2_t *)&v141, &v150, &v149, a6, a7, a8, a9, a10, a11, a12, a13);
        if (!v38)
        {
          if (v150)
          {
            unsigned __int16 v39 = v149;
            if (v149)
            {
              uint64_t v117 = v22;
              unsigned int v40 = vcvts_n_s32_f32(a14, 8uLL);
              unsigned int v41 = vcvtd_n_s64_f64(v118 + v120 * 0.0 + v127 * 0.0, 0x10uLL);
              unsigned int v42 = vcvtd_n_s64_f64(v122 + v124 * 0.0 + v131 * 0.0, 0x10uLL);
              LODWORD(v141.a) = 0;
              uint64_t v143 = 0;
              uint64_t v144 = 0;
              int v142 = 0;
              int v43 = *(_DWORD *)v150;
              if (*(_DWORD *)v150 <= *v149) {
                int v43 = *v149;
              }
              signed int v115 = v41;
              signed int v116 = v42;
              signed int v44 = 0x8000 - v41;
              int v132 = v43 + 0x8000;
              uint64_t v135 = v23;
              signed int v45 = ((v43 + 0x8000) & 0xFFFF0000) - v42 + 0x8000;
              int v46 = ((unint64_t)((int)v146 * (uint64_t)v44) >> 16)
                  - ((int)v145 > 0)
                  + ((unint64_t)((int)v145 * (uint64_t)v45) >> 16);
              int v47 = (v43 + 0x8000) >> 16;
              int v48 = ((unint64_t)(SHIDWORD(v146) * (uint64_t)v44) >> 16)
                  - (SHIDWORD(v145) > 0)
                  + ((unint64_t)(SHIDWORD(v145) * (uint64_t)v45) >> 16);
              uint64_t v49 = v150;
              bvc_extractEdgeParameters(v150, 0, v47, v123, 1, &v141, &v144, (int *)&v143);
              bvc_extractEdgeParameters(v39, 1, v47, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
              int v50 = v47;
              int v51 = v39;
              int v52 = v49;
              int v119 = a5;
              uint64_t v53 = *a5 + v135 * ((uint64_t)v132 >> 16);
              uint64_t v54 = (0x10101020000 * (v40 << 8)) >> 48;
              uint64_t v133 = v135;
              do
              {
                int v55 = v142;
                int v56 = v143;
                if ((int)v143 < v142) {
                  int v55 = v143;
                }
                int v57 = v55 - v50;
                if (v55 > v50)
                {
                  CGFloat v128 = v52;
                  int v58 = 0;
                  int v59 = HIDWORD(v143);
                  int v136 = v144;
                  int v60 = v146;
                  int v61 = HIDWORD(v146);
                  int v62 = v145;
                  int v63 = HIDWORD(v145);
                  int a_low = LODWORD(v141.a);
                  int v121 = HIDWORD(v144);
                  int v65 = HIDWORD(v144);
                  do
                  {
                    LODWORD(v66) = a_low >> 16;
                    if (a_low >> 16 < (v65 >> 16))
                    {
                      unint64_t v66 = (int)v66;
                      int v67 = v48 + ((unint64_t)(v61 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                      int v68 = v46 + ((unint64_t)(v60 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                      do
                      {
                        uint64_t v69 = (unsigned __int8 *)(v21
                                                + (((uint64_t)v68 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                                + ((v67 >> 16) * v20));
                        int v70 = *v69;
                        if (v54 * v70) {
                          *(unsigned char *)(v53 + v66) = (unsigned __int16)(((2120 * v70
                        }
                                                                     + 3219 * v69[3]
                                                                     + 16508 * v69[2]
                                                                     + 8412 * v69[1]) >> 15)
                                                                   * v40
                                                                   + (((0x10000 - v54 * v70)
                                                                     * *(unsigned __int8 *)(v53 + v66)) >> 8)) >> 8;
                        v68 += v60;
                        v67 += v61;
                        ++v66;
                      }
                      while (v66 < (uint64_t)v65 >> 16);
                    }
                    a_low += v136;
                    v65 += v59;
                    v46 += v62;
                    v48 += v63;
                    v53 += v133;
                    ++v58;
                  }
                  while (v58 != v57);
                  LODWORD(v141.a) = a_low;
                  HIDWORD(v144) = v121 + v59 * v57;
                  int v56 = v143;
                  int v50 = v55;
                  int v52 = v128;
                }
                if (v50 >= v56)
                {
                  int v52 = *(char **)(v52 + 20);
                  if (v52)
                  {
                    int v137 = v50;
                    int v125 = v51;
                    CGFloat v129 = v52;
                    bvc_extractEdgeParameters(v52, 0, v50, v123, 1, &v141, &v144, (int *)&v143);
                    int v50 = v137;
                    int v51 = v125;
                    int v52 = v129;
                  }
                }
                if (v50 >= v142)
                {
                  uint64_t v71 = *(_DWORD **)(v51 + 5);
                  if (!v71) {
                    break;
                  }
                  int v138 = v50;
                  int v126 = v71;
                  double v130 = v52;
                  bvc_extractEdgeParameters(v71, 1, v50, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                  int v50 = v138;
                  int v51 = v126;
                  int v52 = v130;
                }
              }
              while (v52 && v51);
              uint64_t v72 = 2 * (int)v146;
              BOOL v73 = (int)v145 > 0;
              uint64_t v74 = 2 * (int)v145;
              uint64_t v75 = 2 * SHIDWORD(v146);
              LODWORD(v146) = 2 * v146;
              HIDWORD(v146) *= 2;
              BOOL v76 = SHIDWORD(v145) > 0;
              uint64_t v77 = 2 * SHIDWORD(v145);
              LODWORD(v145) = 2 * v145;
              HIDWORD(v145) *= 2;
              int v78 = v150;
              int v139 = v149;
              int v79 = *(_DWORD *)v150 / 2;
              if (v79 <= *v149 / 2) {
                int v79 = *v149 / 2;
              }
              int v80 = v79 + 0x8000;
              int v81 = (v79 + 0x8000) >> 16;
              uint64_t v82 = (int)(((v79 + 0x8000) & 0xFFFF0000) - v116 / 2 + 0x8000);
              uint64_t v83 = 0x8000 - v115 / 2;
              int v84 = ((unint64_t)(v72 * v83) >> 16) - v73 + ((unint64_t)(v82 * v74) >> 16);
              int v85 = ((unint64_t)(v75 * v83) >> 16) - v76 + ((unint64_t)(v82 * v77) >> 16);
              bvc_extractEdgeParameters(v150, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
              bvc_extractEdgeParameters(v139, 1, v80 >> 16, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
              int v86 = v78;
              uint64_t v87 = v119[1] + v117 * ((uint64_t)v80 >> 16);
              int32x2_t v88 = vdup_n_s32(v40);
              do
              {
                int v89 = v143;
                if ((int)v143 >= v142) {
                  int v90 = v142;
                }
                else {
                  int v90 = v143;
                }
                int v91 = v90 - v81;
                if (v90 > v81)
                {
                  uint64_t v134 = v86;
                  int v92 = 0;
                  int v93 = HIDWORD(v143);
                  int v94 = v144;
                  int v95 = v146;
                  int v96 = HIDWORD(v146);
                  int v97 = v145;
                  int v98 = HIDWORD(v145);
                  int v99 = LODWORD(v141.a);
                  int v100 = HIDWORD(v144);
                  int v101 = HIDWORD(v144);
                  do
                  {
                    LODWORD(v102) = v99 >> 16;
                    if (v99 >> 16 < (v101 >> 16))
                    {
                      unint64_t v102 = (int)v102;
                      int v103 = v85 + ((unint64_t)(v96 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                      int v104 = v84 + ((unint64_t)(v95 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                      do
                      {
                        int v105 = (unsigned __int8 *)(v21
                                                 + (((uint64_t)v104 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                                 + ((v103 >> 16) * v20));
                        int v106 = *v105;
                        if (v54 * v106)
                        {
                          uint32x2_t v107 = (uint32x2_t)vmul_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32(vmla_s32(vmla_s32(vdup_n_s32(16512 * v106), vdup_n_s32(v105[3]), (int32x2_t)0xFFFFF6D400003838), vdup_n_s32(v105[2]), (int32x2_t)0xFFFFD0F8FFFFDAC4), vdup_n_s32(v105[1]), (int32x2_t)0x3838FFFFED06), 0xFuLL), v88);
                          CGRect v108 = (unsigned __int8 *)(v87 + 2 * v102);
                          v109.i32[0] = *v108;
                          v109.i32[1] = v108[1];
                          uint32x2_t v110 = vshr_n_u32(vsra_n_u32(v107, (uint32x2_t)vmul_s32(vdup_n_s32(0x10000 - (int)v54 * v106), v109), 8uLL), 8uLL);
                          *CGRect v108 = v110.i8[0];
                          v108[1] = v110.u8[4];
                        }
                        v104 += v95;
                        v103 += v96;
                        ++v102;
                      }
                      while (v102 < (uint64_t)v101 >> 16);
                    }
                    v99 += v94;
                    v101 += v93;
                    v84 += v97;
                    v85 += v98;
                    v87 += v117;
                    ++v92;
                  }
                  while (v92 != v91);
                  LODWORD(v141.a) = v99;
                  HIDWORD(v144) = v100 + v93 * v91;
                  int v89 = v143;
                  int v81 = v90;
                  int v86 = v134;
                }
                if (v81 >= v89)
                {
                  int v86 = *(char **)(v86 + 20);
                  if (v86)
                  {
                    unsigned int v111 = v86;
                    bvc_extractEdgeParameters(v86, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
                    int v86 = v111;
                  }
                }
                if (v81 >= v142)
                {
                  BOOL v112 = *(_DWORD **)(v139 + 5);
                  if (!v112) {
                    goto LABEL_65;
                  }
                  int v139 = *(_DWORD **)(v139 + 5);
                  uint64_t v113 = v86;
                  bvc_extractEdgeParameters(v112, 1, v81, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                  int v86 = v113;
                }
                uint64_t v38 = 0;
              }
              while (v86 && v139);
            }
          }
        }
      }
    }
    else
    {
LABEL_65:
      uint64_t v38 = 0;
    }
    BVCUtilityDestroyEdgeList((uint64_t)v150);
    BVCUtilityDestroyEdgeList((uint64_t)v149);
    return v38;
  }
}

uint64_t bvc_FullCompositionOpaque_BGRA_420v709(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v15 = *a2;
  uint64_t v16 = *a3;
  uint64_t v18 = *a4;
  uint64_t v17 = a4[1];
  double v154 = 0;
  double v155 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v152 = 0;
    uint64_t v153 = 0;
    uint64_t v151 = 0;
    uint64_t v150 = 0;
    long long v27 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
    *(_OWORD *)&v146.double c = v27;
    *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
    if (BVCUtilityIsAffineTransformInvertible(&v146.a))
    {
      memset(&v145, 0, sizeof(v145));
      long long v28 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v146.double c = v28;
      *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
      CGAffineTransformInvert(&v145, &v146);
      double v135 = *a1;
      double v140 = a1[1];
      double v130 = a1[3];
      double v118 = a1[4];
      double v121 = a1[2];
      double v124 = a1[5];
      long long v29 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v146.double c = v29;
      *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
      VectorsFromTransforCFIndex m = BVCUtilityGetVectorsFromTransform(&v146.a, &v153, &v152);
      if (VectorsFromTransform)
      {
        uint64_t v34 = VectorsFromTransform;
      }
      else
      {
        unsigned int v31 = v153;
        if ((int)v153 < 0) {
          unsigned int v31 = -(int)v153;
        }
        unsigned int v32 = v152;
        if ((int)v152 < 0) {
          unsigned int v32 = -(int)v152;
        }
        if (v31 <= v32) {
          unsigned int v31 = v32;
        }
        int v120 = v31;
        CGAffineTransform v146 = v145;
        BVCUtilityGetVectorsFromTransform(&v146.a, &v151, &v150);
        long long v33 = *((_OWORD *)a1 + 1);
        *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
        *(_OWORD *)&v146.double c = v33;
        *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
        uint64_t v34 = BVCUtilityCreateEdgeLists((float64x2_t *)&v146, &v155, &v154, a6, a7, a8, a9, a10, a11, a12, a13);
        if (!v34 && v155 && v154)
        {
          uint64_t v116 = v17;
          unsigned int v35 = vcvtd_n_s64_f64(v118 + v121 * 0.0 + v135 * 0.0, 0x10uLL);
          unsigned int v36 = vcvtd_n_s64_f64(v124 + v130 * 0.0 + v140 * 0.0, 0x10uLL);
          LODWORD(v146.a) = 0;
          uint64_t v148 = 0;
          uint64_t v149 = 0;
          int v147 = 0;
          int v37 = *(_DWORD *)v155;
          if (*(_DWORD *)v155 <= *v154) {
            int v37 = *v154;
          }
          signed int v114 = v35;
          signed int v115 = v36;
          signed int v38 = 0x8000 - v35;
          unsigned __int16 v39 = v154;
          int v141 = v37 + 0x8000;
          signed int v40 = ((v37 + 0x8000) & 0xFFFF0000) - v36 + 0x8000;
          int v41 = ((unint64_t)((int)v151 * (uint64_t)v38) >> 16)
              - ((int)v150 > 0)
              + ((unint64_t)((int)v150 * (uint64_t)v40) >> 16);
          uint64_t v42 = v18;
          int v43 = (v37 + 0x8000) >> 16;
          int v44 = ((unint64_t)(SHIDWORD(v151) * (uint64_t)v38) >> 16)
              - (SHIDWORD(v150) > 0)
              + ((unint64_t)(SHIDWORD(v150) * (uint64_t)v40) >> 16);
          signed int v45 = v155;
          bvc_extractEdgeParameters(v155, 0, v43, v120, 1, &v146, &v149, (int *)&v148);
          bvc_extractEdgeParameters(v39, 1, v43, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
          int v46 = v43;
          int v47 = v39;
          int v48 = v45;
          uint64_t v49 = *a5 + v42 * ((uint64_t)v141 >> 16);
          do
          {
            int v50 = v147;
            int v51 = v148;
            if ((int)v148 < v147) {
              int v50 = v148;
            }
            int v52 = v50 - v46;
            if (v50 > v46)
            {
              double v131 = v47;
              int v136 = v48;
              int v53 = 0;
              int v54 = HIDWORD(v148);
              int v55 = v149;
              int v56 = v151;
              int v57 = HIDWORD(v151);
              int v58 = v150;
              int v59 = HIDWORD(v150);
              int a_low = LODWORD(v146.a);
              int v122 = HIDWORD(v149);
              int v61 = HIDWORD(v149);
              do
              {
                LODWORD(v62) = a_low >> 16;
                if (a_low >> 16 < (v61 >> 16))
                {
                  unint64_t v62 = (int)v62;
                  int v63 = v44 + ((unint64_t)(v57 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                  int v64 = v41 + ((unint64_t)(v56 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                  do
                  {
                    int v65 = (unsigned __int8 *)(v16 + ((v63 >> 16) * v15) + (int)((v64 >> 14) & 0xFFFFFFFC));
                    int v66 = v65[3];
                    if (v65[3])
                    {
                      unsigned int v67 = (2120 * v66 + 2032 * *v65 + 20127 * v65[1] + 5983 * v65[2]) >> 15;
                      if (v66 != 255) {
                        v67 += ((16776959 * v66 + 0x10000) * *(unsigned __int8 *)(v49 + v62)) >> 16;
                      }
                      *(unsigned char *)(v49 + v62) = v67;
                    }
                    v64 += v56;
                    v63 += v57;
                    ++v62;
                  }
                  while (v62 < (uint64_t)v61 >> 16);
                }
                a_low += v55;
                v61 += v54;
                v41 += v58;
                v44 += v59;
                v49 += v42;
                ++v53;
              }
              while (v53 != v52);
              LODWORD(v146.a) = a_low;
              HIDWORD(v149) = v122 + v54 * v52;
              int v51 = v148;
              int v46 = v50;
              int v47 = v131;
              int v48 = v136;
            }
            if (v46 >= v51)
            {
              int v48 = *(char **)(v48 + 20);
              if (v48)
              {
                int v125 = v46;
                int v132 = v47;
                int v137 = v48;
                bvc_extractEdgeParameters(v48, 0, v46, v120, 1, &v146, &v149, (int *)&v148);
                int v46 = v125;
                int v47 = v132;
                int v48 = v137;
              }
            }
            if (v46 >= v147)
            {
              int v68 = *(_DWORD **)(v47 + 5);
              if (!v68) {
                break;
              }
              int v126 = v46;
              uint64_t v133 = v68;
              int v138 = v48;
              bvc_extractEdgeParameters(v68, 1, v46, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
              int v46 = v126;
              int v47 = v133;
              int v48 = v138;
            }
          }
          while (v48);
          uint64_t v69 = 2 * (int)v151;
          BOOL v70 = (int)v150 > 0;
          uint64_t v71 = 2 * (int)v150;
          uint64_t v72 = 2 * SHIDWORD(v151);
          LODWORD(v151) = 2 * v151;
          HIDWORD(v151) *= 2;
          BOOL v73 = SHIDWORD(v150) > 0;
          uint64_t v74 = 2 * SHIDWORD(v150);
          LODWORD(v150) = 2 * v150;
          HIDWORD(v150) *= 2;
          uint64_t v75 = v154;
          BOOL v76 = v155;
          int v77 = *(_DWORD *)v155 / 2;
          if (v77 <= *v154 / 2) {
            int v77 = *v154 / 2;
          }
          int v78 = v77 + 0x8000;
          uint64_t v79 = (int)(((v77 + 0x8000) & 0xFFFF0000) - v115 / 2 + 0x8000);
          uint64_t v80 = 0x8000 - v114 / 2;
          int v81 = ((unint64_t)(v69 * v80) >> 16) - v70 + ((unint64_t)(v79 * v71) >> 16);
          int v82 = ((unint64_t)(v72 * v80) >> 16) - v73 + ((unint64_t)(v79 * v74) >> 16);
          bvc_extractEdgeParameters(v155, 0, (v77 + 0x8000) >> 16, v120, 2, &v146, &v149, (int *)&v148);
          int v123 = v75;
          bvc_extractEdgeParameters(v75, 1, v78 >> 16, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
          int v83 = v78 >> 16;
          int v84 = v76;
          uint64_t v85 = a5[1] + v116 * ((uint64_t)v78 >> 16);
          uint64_t v134 = v116;
          do
          {
            int v86 = v147;
            int v87 = v148;
            if ((int)v148 < v147) {
              int v86 = v148;
            }
            int v88 = v86 - v83;
            if (v86 > v83)
            {
              int v119 = v86;
              double v127 = v84;
              int v89 = 0;
              int v90 = HIDWORD(v148);
              int v142 = v149;
              int v91 = v151;
              int v92 = HIDWORD(v151);
              int v93 = HIDWORD(v150);
              int v139 = v150;
              int v94 = LODWORD(v146.a);
              int v117 = HIDWORD(v149);
              int v95 = HIDWORD(v149);
              do
              {
                int v96 = v94 >> 16;
                if (v94 >> 16 < (v95 >> 16))
                {
                  unint64_t v97 = v96;
                  uint64_t v98 = 2 * v96;
                  int v99 = v82 + ((unint64_t)(v92 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                  int v100 = v81 + ((unint64_t)(v91 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                  do
                  {
                    int v101 = (unsigned __int8 *)(v16 + ((v99 >> 16) * v15) + (int)((v100 >> 14) & 0xFFFFFFFC));
                    int v102 = v101[3];
                    if (v101[3])
                    {
                      int v103 = *v101;
                      int v104 = v101[1];
                      int v105 = v101[2];
                      unsigned int v106 = (14392 * v103 + 16512 * v102 - 11093 * v104 - 3298 * v105) >> 15;
                      unsigned int v107 = (-1317 * v103 + 16512 * v102 - 13073 * v104 + 14392 * v105) >> 15;
                      if (v102 == 255)
                      {
                        CGRect v108 = (unsigned char *)(v85 + v98);
                        *CGRect v108 = v106;
                        v108[1] = v107;
                      }
                      else
                      {
                        int32x2_t v109 = (unsigned char *)(v85 + v98);
                        int v110 = 0x10000 - (v102 | (v102 << 8));
                        *int32x2_t v109 = v106 + ((v110 * *(unsigned __int8 *)(v85 + v98)) >> 16);
                        v109[1] = v107 + ((v110 * *(unsigned __int8 *)(v85 + v98 + 1)) >> 16);
                      }
                    }
                    v100 += v91;
                    v99 += v92;
                    ++v97;
                    v98 += 2;
                  }
                  while (v97 < (uint64_t)v95 >> 16);
                }
                v94 += v142;
                v95 += v90;
                v81 += v139;
                v82 += v93;
                v85 += v134;
                ++v89;
              }
              while (v89 != v88);
              LODWORD(v146.a) = v94;
              HIDWORD(v149) = v117 + v90 * v88;
              int v87 = v148;
              int v83 = v119;
              int v84 = v127;
            }
            if (v83 >= v87)
            {
              int v84 = *(char **)(v84 + 20);
              if (v84)
              {
                int v143 = v83;
                CGFloat v128 = v84;
                bvc_extractEdgeParameters(v84, 0, v83, v120, 2, &v146, &v149, (int *)&v148);
                int v83 = v143;
                int v84 = v128;
              }
            }
            if (v83 >= v147)
            {
              unsigned int v111 = *(_DWORD **)(v123 + 5);
              if (!v111) {
                goto LABEL_67;
              }
              int v123 = *(_DWORD **)(v123 + 5);
              CGFloat v129 = v84;
              int v144 = v83;
              bvc_extractEdgeParameters(v111, 1, v83, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
              int v83 = v144;
              int v84 = v129;
            }
            uint64_t v34 = 0;
          }
          while (v84 && v123);
        }
      }
    }
    else
    {
LABEL_67:
      uint64_t v34 = 0;
    }
    uint64_t v113 = v34;
    BVCUtilityDestroyEdgeList((uint64_t)v155);
    BVCUtilityDestroyEdgeList((uint64_t)v154);
    return v113;
  }
}

uint64_t bvc_FullComposition_BGRA_420v709(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v20 = *a2;
  uint64_t v21 = *a3;
  uint64_t v23 = *a4;
  uint64_t v22 = a4[1];
  uint64_t v149 = 0;
  uint64_t v150 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v147 = 0;
    uint64_t v148 = 0;
    uint64_t v146 = 0;
    uint64_t v145 = 0;
    long long v31 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
    *(_OWORD *)&v141.double c = v31;
    *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
    if (BVCUtilityIsAffineTransformInvertible(&v141.a))
    {
      memset(&v140, 0, sizeof(v140));
      long long v32 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v141.double c = v32;
      *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
      CGAffineTransformInvert(&v140, &v141);
      double v127 = *a1;
      double v131 = a1[1];
      double v124 = a1[3];
      double v118 = a1[4];
      double v120 = a1[2];
      double v122 = a1[5];
      long long v33 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v141.double c = v33;
      *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
      VectorsFromTransforCFIndex m = BVCUtilityGetVectorsFromTransform(&v141.a, &v148, &v147);
      if (VectorsFromTransform)
      {
        uint64_t v38 = VectorsFromTransform;
      }
      else
      {
        unsigned int v35 = v148;
        if ((int)v148 < 0) {
          unsigned int v35 = -(int)v148;
        }
        unsigned int v36 = v147;
        if ((int)v147 < 0) {
          unsigned int v36 = -(int)v147;
        }
        if (v35 <= v36) {
          unsigned int v35 = v36;
        }
        int v123 = v35;
        CGAffineTransform v141 = v140;
        BVCUtilityGetVectorsFromTransform(&v141.a, &v146, &v145);
        long long v37 = *((_OWORD *)a1 + 1);
        *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
        *(_OWORD *)&v141.double c = v37;
        *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
        uint64_t v38 = BVCUtilityCreateEdgeLists((float64x2_t *)&v141, &v150, &v149, a6, a7, a8, a9, a10, a11, a12, a13);
        if (!v38)
        {
          if (v150)
          {
            unsigned __int16 v39 = v149;
            if (v149)
            {
              uint64_t v117 = v22;
              unsigned int v40 = vcvts_n_s32_f32(a14, 8uLL);
              unsigned int v41 = vcvtd_n_s64_f64(v118 + v120 * 0.0 + v127 * 0.0, 0x10uLL);
              unsigned int v42 = vcvtd_n_s64_f64(v122 + v124 * 0.0 + v131 * 0.0, 0x10uLL);
              LODWORD(v141.a) = 0;
              uint64_t v143 = 0;
              uint64_t v144 = 0;
              int v142 = 0;
              int v43 = *(_DWORD *)v150;
              if (*(_DWORD *)v150 <= *v149) {
                int v43 = *v149;
              }
              signed int v115 = v41;
              signed int v116 = v42;
              signed int v44 = 0x8000 - v41;
              int v132 = v43 + 0x8000;
              uint64_t v135 = v23;
              signed int v45 = ((v43 + 0x8000) & 0xFFFF0000) - v42 + 0x8000;
              int v46 = ((unint64_t)((int)v146 * (uint64_t)v44) >> 16)
                  - ((int)v145 > 0)
                  + ((unint64_t)((int)v145 * (uint64_t)v45) >> 16);
              int v47 = (v43 + 0x8000) >> 16;
              int v48 = ((unint64_t)(SHIDWORD(v146) * (uint64_t)v44) >> 16)
                  - (SHIDWORD(v145) > 0)
                  + ((unint64_t)(SHIDWORD(v145) * (uint64_t)v45) >> 16);
              uint64_t v49 = v150;
              bvc_extractEdgeParameters(v150, 0, v47, v123, 1, &v141, &v144, (int *)&v143);
              bvc_extractEdgeParameters(v39, 1, v47, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
              int v50 = v47;
              int v51 = v39;
              int v52 = v49;
              int v119 = a5;
              uint64_t v53 = *a5 + v135 * ((uint64_t)v132 >> 16);
              uint64_t v54 = (0x10101020000 * (v40 << 8)) >> 48;
              uint64_t v133 = v135;
              do
              {
                int v55 = v142;
                int v56 = v143;
                if ((int)v143 < v142) {
                  int v55 = v143;
                }
                int v57 = v55 - v50;
                if (v55 > v50)
                {
                  CGFloat v128 = v52;
                  int v58 = 0;
                  int v59 = HIDWORD(v143);
                  int v136 = v144;
                  int v60 = v146;
                  int v61 = HIDWORD(v146);
                  int v62 = v145;
                  int v63 = HIDWORD(v145);
                  int a_low = LODWORD(v141.a);
                  int v121 = HIDWORD(v144);
                  int v65 = HIDWORD(v144);
                  do
                  {
                    LODWORD(v66) = a_low >> 16;
                    if (a_low >> 16 < (v65 >> 16))
                    {
                      unint64_t v66 = (int)v66;
                      int v67 = v48 + ((unint64_t)(v61 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                      int v68 = v46 + ((unint64_t)(v60 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                      do
                      {
                        uint64_t v69 = (unsigned __int8 *)(v21
                                                + ((v67 >> 16) * v20)
                                                + (int)((v68 >> 14) & 0xFFFFFFFC));
                        int v70 = v69[3];
                        if (v54 * v70) {
                          *(unsigned char *)(v53 + v66) = (unsigned __int16)(((2120 * v70
                        }
                                                                     + 2032 * *v69
                                                                     + 20127 * v69[1]
                                                                     + 5983 * v69[2]) >> 15)
                                                                   * v40
                                                                   + (((0x10000 - v54 * v70)
                                                                     * *(unsigned __int8 *)(v53 + v66)) >> 8)) >> 8;
                        v68 += v60;
                        v67 += v61;
                        ++v66;
                      }
                      while (v66 < (uint64_t)v65 >> 16);
                    }
                    a_low += v136;
                    v65 += v59;
                    v46 += v62;
                    v48 += v63;
                    v53 += v133;
                    ++v58;
                  }
                  while (v58 != v57);
                  LODWORD(v141.a) = a_low;
                  HIDWORD(v144) = v121 + v59 * v57;
                  int v56 = v143;
                  int v50 = v55;
                  int v52 = v128;
                }
                if (v50 >= v56)
                {
                  int v52 = *(char **)(v52 + 20);
                  if (v52)
                  {
                    int v137 = v50;
                    int v125 = v51;
                    CGFloat v129 = v52;
                    bvc_extractEdgeParameters(v52, 0, v50, v123, 1, &v141, &v144, (int *)&v143);
                    int v50 = v137;
                    int v51 = v125;
                    int v52 = v129;
                  }
                }
                if (v50 >= v142)
                {
                  uint64_t v71 = *(_DWORD **)(v51 + 5);
                  if (!v71) {
                    break;
                  }
                  int v138 = v50;
                  int v126 = v71;
                  double v130 = v52;
                  bvc_extractEdgeParameters(v71, 1, v50, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                  int v50 = v138;
                  int v51 = v126;
                  int v52 = v130;
                }
              }
              while (v52 && v51);
              uint64_t v72 = 2 * (int)v146;
              BOOL v73 = (int)v145 > 0;
              uint64_t v74 = 2 * (int)v145;
              uint64_t v75 = 2 * SHIDWORD(v146);
              LODWORD(v146) = 2 * v146;
              HIDWORD(v146) *= 2;
              BOOL v76 = SHIDWORD(v145) > 0;
              uint64_t v77 = 2 * SHIDWORD(v145);
              LODWORD(v145) = 2 * v145;
              HIDWORD(v145) *= 2;
              int v78 = v150;
              int v139 = v149;
              int v79 = *(_DWORD *)v150 / 2;
              if (v79 <= *v149 / 2) {
                int v79 = *v149 / 2;
              }
              int v80 = v79 + 0x8000;
              int v81 = (v79 + 0x8000) >> 16;
              uint64_t v82 = (int)(((v79 + 0x8000) & 0xFFFF0000) - v116 / 2 + 0x8000);
              uint64_t v83 = 0x8000 - v115 / 2;
              int v84 = ((unint64_t)(v72 * v83) >> 16) - v73 + ((unint64_t)(v82 * v74) >> 16);
              int v85 = ((unint64_t)(v75 * v83) >> 16) - v76 + ((unint64_t)(v82 * v77) >> 16);
              bvc_extractEdgeParameters(v150, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
              bvc_extractEdgeParameters(v139, 1, v80 >> 16, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
              int v86 = v78;
              uint64_t v87 = v119[1] + v117 * ((uint64_t)v80 >> 16);
              int32x2_t v88 = vdup_n_s32(v40);
              do
              {
                int v89 = v143;
                if ((int)v143 >= v142) {
                  int v90 = v142;
                }
                else {
                  int v90 = v143;
                }
                int v91 = v90 - v81;
                if (v90 > v81)
                {
                  uint64_t v134 = v86;
                  int v92 = 0;
                  int v93 = HIDWORD(v143);
                  int v94 = v144;
                  int v95 = v146;
                  int v96 = HIDWORD(v146);
                  int v97 = v145;
                  int v98 = HIDWORD(v145);
                  int v99 = LODWORD(v141.a);
                  int v100 = HIDWORD(v144);
                  int v101 = HIDWORD(v144);
                  do
                  {
                    LODWORD(v102) = v99 >> 16;
                    if (v99 >> 16 < (v101 >> 16))
                    {
                      unint64_t v102 = (int)v102;
                      int v103 = v85 + ((unint64_t)(v96 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                      int v104 = v84 + ((unint64_t)(v95 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                      do
                      {
                        int v105 = (unsigned __int8 *)(v21
                                                 + ((v103 >> 16) * v20)
                                                 + (int)((v104 >> 14) & 0xFFFFFFFC));
                        int v106 = v105[3];
                        if (v54 * v106)
                        {
                          uint32x2_t v107 = (uint32x2_t)vmul_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32(vmla_s32(vmla_s32(vdup_n_s32(16512 * v106), vdup_n_s32(*v105), (int32x2_t)0xFFFFFADB00003838), vdup_n_s32(v105[1]), (int32x2_t)0xFFFFCCEFFFFFD4ABLL), vdup_n_s32(v105[2]), (int32x2_t)0x3838FFFFF31ELL), 0xFuLL), v88);
                          CGRect v108 = (unsigned __int8 *)(v87 + 2 * v102);
                          v109.i32[0] = *v108;
                          v109.i32[1] = v108[1];
                          uint32x2_t v110 = vshr_n_u32(vsra_n_u32(v107, (uint32x2_t)vmul_s32(vdup_n_s32(0x10000 - (int)v54 * v106), v109), 8uLL), 8uLL);
                          *CGRect v108 = v110.i8[0];
                          v108[1] = v110.u8[4];
                        }
                        v104 += v95;
                        v103 += v96;
                        ++v102;
                      }
                      while (v102 < (uint64_t)v101 >> 16);
                    }
                    v99 += v94;
                    v101 += v93;
                    v84 += v97;
                    v85 += v98;
                    v87 += v117;
                    ++v92;
                  }
                  while (v92 != v91);
                  LODWORD(v141.a) = v99;
                  HIDWORD(v144) = v100 + v93 * v91;
                  int v89 = v143;
                  int v81 = v90;
                  int v86 = v134;
                }
                if (v81 >= v89)
                {
                  int v86 = *(char **)(v86 + 20);
                  if (v86)
                  {
                    unsigned int v111 = v86;
                    bvc_extractEdgeParameters(v86, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
                    int v86 = v111;
                  }
                }
                if (v81 >= v142)
                {
                  BOOL v112 = *(_DWORD **)(v139 + 5);
                  if (!v112) {
                    goto LABEL_65;
                  }
                  int v139 = *(_DWORD **)(v139 + 5);
                  uint64_t v113 = v86;
                  bvc_extractEdgeParameters(v112, 1, v81, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                  int v86 = v113;
                }
                uint64_t v38 = 0;
              }
              while (v86 && v139);
            }
          }
        }
      }
    }
    else
    {
LABEL_65:
      uint64_t v38 = 0;
    }
    BVCUtilityDestroyEdgeList((uint64_t)v150);
    BVCUtilityDestroyEdgeList((uint64_t)v149);
    return v38;
  }
}

uint64_t bvc_FullCompositionOpaque_BGRA_420v601(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v15 = *a2;
  uint64_t v16 = *a3;
  uint64_t v18 = *a4;
  uint64_t v17 = a4[1];
  double v154 = 0;
  double v155 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v152 = 0;
    uint64_t v153 = 0;
    uint64_t v151 = 0;
    uint64_t v150 = 0;
    long long v27 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
    *(_OWORD *)&v146.double c = v27;
    *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
    if (BVCUtilityIsAffineTransformInvertible(&v146.a))
    {
      memset(&v145, 0, sizeof(v145));
      long long v28 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v146.double c = v28;
      *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
      CGAffineTransformInvert(&v145, &v146);
      double v135 = *a1;
      double v140 = a1[1];
      double v130 = a1[3];
      double v118 = a1[4];
      double v121 = a1[2];
      double v124 = a1[5];
      long long v29 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v146.double c = v29;
      *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
      VectorsFromTransforCFIndex m = BVCUtilityGetVectorsFromTransform(&v146.a, &v153, &v152);
      if (VectorsFromTransform)
      {
        uint64_t v34 = VectorsFromTransform;
      }
      else
      {
        unsigned int v31 = v153;
        if ((int)v153 < 0) {
          unsigned int v31 = -(int)v153;
        }
        unsigned int v32 = v152;
        if ((int)v152 < 0) {
          unsigned int v32 = -(int)v152;
        }
        if (v31 <= v32) {
          unsigned int v31 = v32;
        }
        int v120 = v31;
        CGAffineTransform v146 = v145;
        BVCUtilityGetVectorsFromTransform(&v146.a, &v151, &v150);
        long long v33 = *((_OWORD *)a1 + 1);
        *(_OWORD *)&v146.CGFloat a = *(_OWORD *)a1;
        *(_OWORD *)&v146.double c = v33;
        *(_OWORD *)&v146.tCGFloat x = *((_OWORD *)a1 + 2);
        uint64_t v34 = BVCUtilityCreateEdgeLists((float64x2_t *)&v146, &v155, &v154, a6, a7, a8, a9, a10, a11, a12, a13);
        if (!v34 && v155 && v154)
        {
          uint64_t v116 = v17;
          unsigned int v35 = vcvtd_n_s64_f64(v118 + v121 * 0.0 + v135 * 0.0, 0x10uLL);
          unsigned int v36 = vcvtd_n_s64_f64(v124 + v130 * 0.0 + v140 * 0.0, 0x10uLL);
          LODWORD(v146.a) = 0;
          uint64_t v148 = 0;
          uint64_t v149 = 0;
          int v147 = 0;
          int v37 = *(_DWORD *)v155;
          if (*(_DWORD *)v155 <= *v154) {
            int v37 = *v154;
          }
          signed int v114 = v35;
          signed int v115 = v36;
          signed int v38 = 0x8000 - v35;
          unsigned __int16 v39 = v154;
          int v141 = v37 + 0x8000;
          signed int v40 = ((v37 + 0x8000) & 0xFFFF0000) - v36 + 0x8000;
          int v41 = ((unint64_t)((int)v151 * (uint64_t)v38) >> 16)
              - ((int)v150 > 0)
              + ((unint64_t)((int)v150 * (uint64_t)v40) >> 16);
          uint64_t v42 = v18;
          int v43 = (v37 + 0x8000) >> 16;
          int v44 = ((unint64_t)(SHIDWORD(v151) * (uint64_t)v38) >> 16)
              - (SHIDWORD(v150) > 0)
              + ((unint64_t)(SHIDWORD(v150) * (uint64_t)v40) >> 16);
          signed int v45 = v155;
          bvc_extractEdgeParameters(v155, 0, v43, v120, 1, &v146, &v149, (int *)&v148);
          bvc_extractEdgeParameters(v39, 1, v43, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
          int v46 = v43;
          int v47 = v39;
          int v48 = v45;
          uint64_t v49 = *a5 + v42 * ((uint64_t)v141 >> 16);
          do
          {
            int v50 = v147;
            int v51 = v148;
            if ((int)v148 < v147) {
              int v50 = v148;
            }
            int v52 = v50 - v46;
            if (v50 > v46)
            {
              double v131 = v47;
              int v136 = v48;
              int v53 = 0;
              int v54 = HIDWORD(v148);
              int v55 = v149;
              int v56 = v151;
              int v57 = HIDWORD(v151);
              int v58 = v150;
              int v59 = HIDWORD(v150);
              int a_low = LODWORD(v146.a);
              int v122 = HIDWORD(v149);
              int v61 = HIDWORD(v149);
              do
              {
                LODWORD(v62) = a_low >> 16;
                if (a_low >> 16 < (v61 >> 16))
                {
                  unint64_t v62 = (int)v62;
                  int v63 = v44 + ((unint64_t)(v57 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                  int v64 = v41 + ((unint64_t)(v56 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                  do
                  {
                    int v65 = (unsigned __int8 *)(v16 + ((v63 >> 16) * v15) + (int)((v64 >> 14) & 0xFFFFFFFC));
                    int v66 = v65[3];
                    if (v65[3])
                    {
                      unsigned int v67 = (2120 * v66 + 3219 * *v65 + 16508 * v65[1] + 8412 * v65[2]) >> 15;
                      if (v66 != 255) {
                        v67 += ((16776959 * v66 + 0x10000) * *(unsigned __int8 *)(v49 + v62)) >> 16;
                      }
                      *(unsigned char *)(v49 + v62) = v67;
                    }
                    v64 += v56;
                    v63 += v57;
                    ++v62;
                  }
                  while (v62 < (uint64_t)v61 >> 16);
                }
                a_low += v55;
                v61 += v54;
                v41 += v58;
                v44 += v59;
                v49 += v42;
                ++v53;
              }
              while (v53 != v52);
              LODWORD(v146.a) = a_low;
              HIDWORD(v149) = v122 + v54 * v52;
              int v51 = v148;
              int v46 = v50;
              int v47 = v131;
              int v48 = v136;
            }
            if (v46 >= v51)
            {
              int v48 = *(char **)(v48 + 20);
              if (v48)
              {
                int v125 = v46;
                int v132 = v47;
                int v137 = v48;
                bvc_extractEdgeParameters(v48, 0, v46, v120, 1, &v146, &v149, (int *)&v148);
                int v46 = v125;
                int v47 = v132;
                int v48 = v137;
              }
            }
            if (v46 >= v147)
            {
              int v68 = *(_DWORD **)(v47 + 5);
              if (!v68) {
                break;
              }
              int v126 = v46;
              uint64_t v133 = v68;
              int v138 = v48;
              bvc_extractEdgeParameters(v68, 1, v46, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
              int v46 = v126;
              int v47 = v133;
              int v48 = v138;
            }
          }
          while (v48);
          uint64_t v69 = 2 * (int)v151;
          BOOL v70 = (int)v150 > 0;
          uint64_t v71 = 2 * (int)v150;
          uint64_t v72 = 2 * SHIDWORD(v151);
          LODWORD(v151) = 2 * v151;
          HIDWORD(v151) *= 2;
          BOOL v73 = SHIDWORD(v150) > 0;
          uint64_t v74 = 2 * SHIDWORD(v150);
          LODWORD(v150) = 2 * v150;
          HIDWORD(v150) *= 2;
          uint64_t v75 = v154;
          BOOL v76 = v155;
          int v77 = *(_DWORD *)v155 / 2;
          if (v77 <= *v154 / 2) {
            int v77 = *v154 / 2;
          }
          int v78 = v77 + 0x8000;
          uint64_t v79 = (int)(((v77 + 0x8000) & 0xFFFF0000) - v115 / 2 + 0x8000);
          uint64_t v80 = 0x8000 - v114 / 2;
          int v81 = ((unint64_t)(v69 * v80) >> 16) - v70 + ((unint64_t)(v79 * v71) >> 16);
          int v82 = ((unint64_t)(v72 * v80) >> 16) - v73 + ((unint64_t)(v79 * v74) >> 16);
          bvc_extractEdgeParameters(v155, 0, (v77 + 0x8000) >> 16, v120, 2, &v146, &v149, (int *)&v148);
          int v123 = v75;
          bvc_extractEdgeParameters(v75, 1, v78 >> 16, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
          int v83 = v78 >> 16;
          int v84 = v76;
          uint64_t v85 = a5[1] + v116 * ((uint64_t)v78 >> 16);
          uint64_t v134 = v116;
          do
          {
            int v86 = v147;
            int v87 = v148;
            if ((int)v148 < v147) {
              int v86 = v148;
            }
            int v88 = v86 - v83;
            if (v86 > v83)
            {
              int v119 = v86;
              double v127 = v84;
              int v89 = 0;
              int v90 = HIDWORD(v148);
              int v142 = v149;
              int v91 = v151;
              int v92 = HIDWORD(v151);
              int v93 = HIDWORD(v150);
              int v139 = v150;
              int v94 = LODWORD(v146.a);
              int v117 = HIDWORD(v149);
              int v95 = HIDWORD(v149);
              do
              {
                int v96 = v94 >> 16;
                if (v94 >> 16 < (v95 >> 16))
                {
                  unint64_t v97 = v96;
                  uint64_t v98 = 2 * v96;
                  int v99 = v82 + ((unint64_t)(v92 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                  int v100 = v81 + ((unint64_t)(v91 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                  do
                  {
                    int v101 = (unsigned __int8 *)(v16 + ((v99 >> 16) * v15) + (int)((v100 >> 14) & 0xFFFFFFFC));
                    int v102 = v101[3];
                    if (v101[3])
                    {
                      int v103 = *v101;
                      int v104 = v101[1];
                      int v105 = v101[2];
                      unsigned int v106 = (14392 * v103 + 16512 * v102 - 9532 * v104 - 4858 * v105) >> 15;
                      unsigned int v107 = (-2348 * v103 + 16512 * v102 - 12040 * v104 + 14392 * v105) >> 15;
                      if (v102 == 255)
                      {
                        CGRect v108 = (unsigned char *)(v85 + v98);
                        *CGRect v108 = v106;
                        v108[1] = v107;
                      }
                      else
                      {
                        int32x2_t v109 = (unsigned char *)(v85 + v98);
                        int v110 = 0x10000 - (v102 | (v102 << 8));
                        *int32x2_t v109 = v106 + ((v110 * *(unsigned __int8 *)(v85 + v98)) >> 16);
                        v109[1] = v107 + ((v110 * *(unsigned __int8 *)(v85 + v98 + 1)) >> 16);
                      }
                    }
                    v100 += v91;
                    v99 += v92;
                    ++v97;
                    v98 += 2;
                  }
                  while (v97 < (uint64_t)v95 >> 16);
                }
                v94 += v142;
                v95 += v90;
                v81 += v139;
                v82 += v93;
                v85 += v134;
                ++v89;
              }
              while (v89 != v88);
              LODWORD(v146.a) = v94;
              HIDWORD(v149) = v117 + v90 * v88;
              int v87 = v148;
              int v83 = v119;
              int v84 = v127;
            }
            if (v83 >= v87)
            {
              int v84 = *(char **)(v84 + 20);
              if (v84)
              {
                int v143 = v83;
                CGFloat v128 = v84;
                bvc_extractEdgeParameters(v84, 0, v83, v120, 2, &v146, &v149, (int *)&v148);
                int v83 = v143;
                int v84 = v128;
              }
            }
            if (v83 >= v147)
            {
              unsigned int v111 = *(_DWORD **)(v123 + 5);
              if (!v111) {
                goto LABEL_67;
              }
              int v123 = *(_DWORD **)(v123 + 5);
              CGFloat v129 = v84;
              int v144 = v83;
              bvc_extractEdgeParameters(v111, 1, v83, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
              int v83 = v144;
              int v84 = v129;
            }
            uint64_t v34 = 0;
          }
          while (v84 && v123);
        }
      }
    }
    else
    {
LABEL_67:
      uint64_t v34 = 0;
    }
    uint64_t v113 = v34;
    BVCUtilityDestroyEdgeList((uint64_t)v155);
    BVCUtilityDestroyEdgeList((uint64_t)v154);
    return v113;
  }
}

uint64_t bvc_FullComposition_BGRA_420v601(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v20 = *a2;
  uint64_t v21 = *a3;
  uint64_t v23 = *a4;
  uint64_t v22 = a4[1];
  uint64_t v149 = 0;
  uint64_t v150 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v147 = 0;
    uint64_t v148 = 0;
    uint64_t v146 = 0;
    uint64_t v145 = 0;
    long long v31 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
    *(_OWORD *)&v141.double c = v31;
    *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
    if (BVCUtilityIsAffineTransformInvertible(&v141.a))
    {
      memset(&v140, 0, sizeof(v140));
      long long v32 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v141.double c = v32;
      *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
      CGAffineTransformInvert(&v140, &v141);
      double v127 = *a1;
      double v131 = a1[1];
      double v124 = a1[3];
      double v118 = a1[4];
      double v120 = a1[2];
      double v122 = a1[5];
      long long v33 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
      *(_OWORD *)&v141.double c = v33;
      *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
      VectorsFromTransforCFIndex m = BVCUtilityGetVectorsFromTransform(&v141.a, &v148, &v147);
      if (VectorsFromTransform)
      {
        uint64_t v38 = VectorsFromTransform;
      }
      else
      {
        unsigned int v35 = v148;
        if ((int)v148 < 0) {
          unsigned int v35 = -(int)v148;
        }
        unsigned int v36 = v147;
        if ((int)v147 < 0) {
          unsigned int v36 = -(int)v147;
        }
        if (v35 <= v36) {
          unsigned int v35 = v36;
        }
        int v123 = v35;
        CGAffineTransform v141 = v140;
        BVCUtilityGetVectorsFromTransform(&v141.a, &v146, &v145);
        long long v37 = *((_OWORD *)a1 + 1);
        *(_OWORD *)&v141.CGFloat a = *(_OWORD *)a1;
        *(_OWORD *)&v141.double c = v37;
        *(_OWORD *)&v141.tCGFloat x = *((_OWORD *)a1 + 2);
        uint64_t v38 = BVCUtilityCreateEdgeLists((float64x2_t *)&v141, &v150, &v149, a6, a7, a8, a9, a10, a11, a12, a13);
        if (!v38)
        {
          if (v150)
          {
            unsigned __int16 v39 = v149;
            if (v149)
            {
              uint64_t v117 = v22;
              unsigned int v40 = vcvts_n_s32_f32(a14, 8uLL);
              unsigned int v41 = vcvtd_n_s64_f64(v118 + v120 * 0.0 + v127 * 0.0, 0x10uLL);
              unsigned int v42 = vcvtd_n_s64_f64(v122 + v124 * 0.0 + v131 * 0.0, 0x10uLL);
              LODWORD(v141.a) = 0;
              uint64_t v143 = 0;
              uint64_t v144 = 0;
              int v142 = 0;
              int v43 = *(_DWORD *)v150;
              if (*(_DWORD *)v150 <= *v149) {
                int v43 = *v149;
              }
              signed int v115 = v41;
              signed int v116 = v42;
              signed int v44 = 0x8000 - v41;
              int v132 = v43 + 0x8000;
              uint64_t v135 = v23;
              signed int v45 = ((v43 + 0x8000) & 0xFFFF0000) - v42 + 0x8000;
              int v46 = ((unint64_t)((int)v146 * (uint64_t)v44) >> 16)
                  - ((int)v145 > 0)
                  + ((unint64_t)((int)v145 * (uint64_t)v45) >> 16);
              int v47 = (v43 + 0x8000) >> 16;
              int v48 = ((unint64_t)(SHIDWORD(v146) * (uint64_t)v44) >> 16)
                  - (SHIDWORD(v145) > 0)
                  + ((unint64_t)(SHIDWORD(v145) * (uint64_t)v45) >> 16);
              uint64_t v49 = v150;
              bvc_extractEdgeParameters(v150, 0, v47, v123, 1, &v141, &v144, (int *)&v143);
              bvc_extractEdgeParameters(v39, 1, v47, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
              int v50 = v47;
              int v51 = v39;
              int v52 = v49;
              int v119 = a5;
              uint64_t v53 = *a5 + v135 * ((uint64_t)v132 >> 16);
              uint64_t v54 = (0x10101020000 * (v40 << 8)) >> 48;
              uint64_t v133 = v135;
              do
              {
                int v55 = v142;
                int v56 = v143;
                if ((int)v143 < v142) {
                  int v55 = v143;
                }
                int v57 = v55 - v50;
                if (v55 > v50)
                {
                  CGFloat v128 = v52;
                  int v58 = 0;
                  int v59 = HIDWORD(v143);
                  int v136 = v144;
                  int v60 = v146;
                  int v61 = HIDWORD(v146);
                  int v62 = v145;
                  int v63 = HIDWORD(v145);
                  int a_low = LODWORD(v141.a);
                  int v121 = HIDWORD(v144);
                  int v65 = HIDWORD(v144);
                  do
                  {
                    LODWORD(v66) = a_low >> 16;
                    if (a_low >> 16 < (v65 >> 16))
                    {
                      unint64_t v66 = (int)v66;
                      int v67 = v48 + ((unint64_t)(v61 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                      int v68 = v46 + ((unint64_t)(v60 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                      do
                      {
                        uint64_t v69 = (unsigned __int8 *)(v21
                                                + ((v67 >> 16) * v20)
                                                + (int)((v68 >> 14) & 0xFFFFFFFC));
                        int v70 = v69[3];
                        if (v54 * v70) {
                          *(unsigned char *)(v53 + v66) = (unsigned __int16)(((2120 * v70
                        }
                                                                     + 3219 * *v69
                                                                     + 16508 * v69[1]
                                                                     + 8412 * v69[2]) >> 15)
                                                                   * v40
                                                                   + (((0x10000 - v54 * v70)
                                                                     * *(unsigned __int8 *)(v53 + v66)) >> 8)) >> 8;
                        v68 += v60;
                        v67 += v61;
                        ++v66;
                      }
                      while (v66 < (uint64_t)v65 >> 16);
                    }
                    a_low += v136;
                    v65 += v59;
                    v46 += v62;
                    v48 += v63;
                    v53 += v133;
                    ++v58;
                  }
                  while (v58 != v57);
                  LODWORD(v141.a) = a_low;
                  HIDWORD(v144) = v121 + v59 * v57;
                  int v56 = v143;
                  int v50 = v55;
                  int v52 = v128;
                }
                if (v50 >= v56)
                {
                  int v52 = *(char **)(v52 + 20);
                  if (v52)
                  {
                    int v137 = v50;
                    int v125 = v51;
                    CGFloat v129 = v52;
                    bvc_extractEdgeParameters(v52, 0, v50, v123, 1, &v141, &v144, (int *)&v143);
                    int v50 = v137;
                    int v51 = v125;
                    int v52 = v129;
                  }
                }
                if (v50 >= v142)
                {
                  uint64_t v71 = *(_DWORD **)(v51 + 5);
                  if (!v71) {
                    break;
                  }
                  int v138 = v50;
                  int v126 = v71;
                  double v130 = v52;
                  bvc_extractEdgeParameters(v71, 1, v50, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                  int v50 = v138;
                  int v51 = v126;
                  int v52 = v130;
                }
              }
              while (v52 && v51);
              uint64_t v72 = 2 * (int)v146;
              BOOL v73 = (int)v145 > 0;
              uint64_t v74 = 2 * (int)v145;
              uint64_t v75 = 2 * SHIDWORD(v146);
              LODWORD(v146) = 2 * v146;
              HIDWORD(v146) *= 2;
              BOOL v76 = SHIDWORD(v145) > 0;
              uint64_t v77 = 2 * SHIDWORD(v145);
              LODWORD(v145) = 2 * v145;
              HIDWORD(v145) *= 2;
              int v78 = v150;
              int v139 = v149;
              int v79 = *(_DWORD *)v150 / 2;
              if (v79 <= *v149 / 2) {
                int v79 = *v149 / 2;
              }
              int v80 = v79 + 0x8000;
              int v81 = (v79 + 0x8000) >> 16;
              uint64_t v82 = (int)(((v79 + 0x8000) & 0xFFFF0000) - v116 / 2 + 0x8000);
              uint64_t v83 = 0x8000 - v115 / 2;
              int v84 = ((unint64_t)(v72 * v83) >> 16) - v73 + ((unint64_t)(v82 * v74) >> 16);
              int v85 = ((unint64_t)(v75 * v83) >> 16) - v76 + ((unint64_t)(v82 * v77) >> 16);
              bvc_extractEdgeParameters(v150, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
              bvc_extractEdgeParameters(v139, 1, v80 >> 16, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
              int v86 = v78;
              uint64_t v87 = v119[1] + v117 * ((uint64_t)v80 >> 16);
              int32x2_t v88 = vdup_n_s32(v40);
              do
              {
                int v89 = v143;
                if ((int)v143 >= v142) {
                  int v90 = v142;
                }
                else {
                  int v90 = v143;
                }
                int v91 = v90 - v81;
                if (v90 > v81)
                {
                  uint64_t v134 = v86;
                  int v92 = 0;
                  int v93 = HIDWORD(v143);
                  int v94 = v144;
                  int v95 = v146;
                  int v96 = HIDWORD(v146);
                  int v97 = v145;
                  int v98 = HIDWORD(v145);
                  int v99 = LODWORD(v141.a);
                  int v100 = HIDWORD(v144);
                  int v101 = HIDWORD(v144);
                  do
                  {
                    LODWORD(v102) = v99 >> 16;
                    if (v99 >> 16 < (v101 >> 16))
                    {
                      unint64_t v102 = (int)v102;
                      int v103 = v85 + ((unint64_t)(v96 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                      int v104 = v84 + ((unint64_t)(v95 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                      do
                      {
                        int v105 = (unsigned __int8 *)(v21
                                                 + ((v103 >> 16) * v20)
                                                 + (int)((v104 >> 14) & 0xFFFFFFFC));
                        int v106 = v105[3];
                        if (v54 * v106)
                        {
                          uint32x2_t v107 = (uint32x2_t)vmul_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32(vmla_s32(vmla_s32(vdup_n_s32(16512 * v106), vdup_n_s32(*v105), (int32x2_t)0xFFFFF6D400003838), vdup_n_s32(v105[1]), (int32x2_t)0xFFFFD0F8FFFFDAC4), vdup_n_s32(v105[2]), (int32x2_t)0x3838FFFFED06), 0xFuLL), v88);
                          CGRect v108 = (unsigned __int8 *)(v87 + 2 * v102);
                          v109.i32[0] = *v108;
                          v109.i32[1] = v108[1];
                          uint32x2_t v110 = vshr_n_u32(vsra_n_u32(v107, (uint32x2_t)vmul_s32(vdup_n_s32(0x10000 - (int)v54 * v106), v109), 8uLL), 8uLL);
                          *CGRect v108 = v110.i8[0];
                          v108[1] = v110.u8[4];
                        }
                        v104 += v95;
                        v103 += v96;
                        ++v102;
                      }
                      while (v102 < (uint64_t)v101 >> 16);
                    }
                    v99 += v94;
                    v101 += v93;
                    v84 += v97;
                    v85 += v98;
                    v87 += v117;
                    ++v92;
                  }
                  while (v92 != v91);
                  LODWORD(v141.a) = v99;
                  HIDWORD(v144) = v100 + v93 * v91;
                  int v89 = v143;
                  int v81 = v90;
                  int v86 = v134;
                }
                if (v81 >= v89)
                {
                  int v86 = *(char **)(v86 + 20);
                  if (v86)
                  {
                    unsigned int v111 = v86;
                    bvc_extractEdgeParameters(v86, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
                    int v86 = v111;
                  }
                }
                if (v81 >= v142)
                {
                  BOOL v112 = *(_DWORD **)(v139 + 5);
                  if (!v112) {
                    goto LABEL_65;
                  }
                  int v139 = *(_DWORD **)(v139 + 5);
                  uint64_t v113 = v86;
                  bvc_extractEdgeParameters(v112, 1, v81, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                  int v86 = v113;
                }
                uint64_t v38 = 0;
              }
              while (v86 && v139);
            }
          }
        }
      }
    }
    else
    {
LABEL_65:
      uint64_t v38 = 0;
    }
    BVCUtilityDestroyEdgeList((uint64_t)v150);
    BVCUtilityDestroyEdgeList((uint64_t)v149);
    return v38;
  }
}

uint64_t __bvc_blitLayer_block_invoke(uint64_t a1)
{
  double v2 = *(double *)(a1 + 40);
  CFAllocatorRef v3 = *(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, double, double, double, double, double))(a1 + 88);
  uint64_t v4 = *(void *)(a1 + 176);
  uint64_t v5 = *(void *)(a1 + 184);
  uint64_t v6 = *(void *)(a1 + 192);
  uint64_t v7 = *(void *)(a1 + 200);
  double v8 = *(double *)(a1 + 96);
  double v9 = *(double *)(a1 + 104);
  double v10 = *(double *)(a1 + 112);
  double v11 = *(double *)(a1 + 120);
  long long v12 = *(_OWORD *)(a1 + 144);
  v14[0] = *(_OWORD *)(a1 + 128);
  v14[1] = v12;
  void v14[2] = *(_OWORD *)(a1 + 160);
  uint64_t result = v3(v14, v4, v5, v6, v7, v8, v9, v10, v11, v2);
  if (result) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -12506;
  }
  return result;
}

_DWORD *bvc_extractEdgeParameters(_DWORD *result, int a2, int a3, int a4, int a5, _DWORD *a6, _DWORD *a7, int *a8)
{
  int v8 = result[3];
  int v9 = result[1];
  int v10 = result[2] / a5 + ((unint64_t)(v8 * (uint64_t)(((a3 << 16) | 0x8000) - *result / a5)) >> 16);
  unsigned int v12 = v10 + 0x8000;
  BOOL v11 = v10 + 0x8000 < 0;
  unsigned int v13 = -32768 - v10;
  if (!v11) {
    unsigned int v13 = v12;
  }
  unint64_t v14 = (unint64_t)((int)(a3 + HIWORD(v13)) * (uint64_t)a4 + 0xFFFF) >> 16;
  if (v8 >= 0) {
    int v15 = result[3];
  }
  else {
    int v15 = -v8;
  }
  if (a2) {
    LODWORD(v14) = -(int)v14;
  }
  int v16 = v14 + v12;
  if (a2) {
    int v17 = -(int)((unint64_t)((int)(((v15 + 0xFFFF) >> 16) + 1) * (uint64_t)a4 + 0xFFFF) >> 16);
  }
  else {
    int v17 = (unint64_t)((int)(((v15 + 0xFFFF) >> 16) + 1) * (uint64_t)a4 + 0xFFFF) >> 16;
  }
  *a7 = v17 + v8;
  *a6 = v16;
  *a8 = (v9 / a5 + 0x8000) >> 16;
  return result;
}

uint64_t FigSecureStopManagerGetClassID()
{
  return sFigSecureStopManagerClassID;
}

uint64_t RegisterFigSecureStopManagerType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigSecureStopManagerGetTypeID()
{
  MEMORY[0x19970EE10](&FigSecureStopManagerGetClassID_sRegisterFigSecureStopManagerTypeOnce, RegisterFigSecureStopManagerType);

  return CMBaseClassGetCFTypeID();
}

uint64_t FigSecureStopManagerCreate(uint64_t a1, void *a2)
{
  if (a2)
  {
    *a2 = 0;
    MEMORY[0x19970EE10](&FigSecureStopManagerGetClassID_sRegisterFigSecureStopManagerTypeOnce, RegisterFigSecureStopManagerType);
    uint64_t result = CMDerivedObjectCreate();
    if (!result) {
      return FigSignalErrorAt();
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t FigSecureStopManagerCopyDefaultRuntimeInstance(uint64_t a1, void *a2)
{
  uint64_t v12 = 0;
  unsigned int v13 = &v12;
  uint64_t v14 = 0x2000000000;
  int v15 = 0;
  uint64_t v8 = 0;
  int v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  if (a2)
  {
    *a2 = 0;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FigSecureStopManagerCopyDefaultRuntimeInstance_block_invoke;
    block[3] = &unk_1E57A2408;
    void block[5] = &v8;
    block[6] = a1;
    block[4] = &v12;
    if (FigSecureStopManagerCopyDefaultRuntimeInstance_once != -1) {
      dispatch_once(&FigSecureStopManagerCopyDefaultRuntimeInstance_once, block);
    }
    if (!*((_DWORD *)v13 + 6))
    {
      CFTypeRef v3 = (CFTypeRef)v9[3];
      if (v3)
      {
        FigSecureStopManagerCopyDefaultRuntimeInstance_defaultSingletonManager = v9[3];
        v9[3] = 0;
      }
      else
      {
        CFTypeRef v3 = (CFTypeRef)FigSecureStopManagerCopyDefaultRuntimeInstance_defaultSingletonManager;
        if (!FigSecureStopManagerCopyDefaultRuntimeInstance_defaultSingletonManager)
        {
LABEL_9:
          *a2 = v3;
          goto LABEL_10;
        }
      }
      CFTypeRef v3 = CFRetain(v3);
      goto LABEL_9;
    }
  }
  else
  {
    *((_DWORD *)v13 + 6) = FigSignalErrorAt();
  }
LABEL_10:
  uint64_t v4 = (const void *)v9[3];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *((unsigned int *)v13 + 6);
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  return v5;
}

uint64_t __FigSecureStopManagerCopyDefaultRuntimeInstance_block_invoke(void *a1)
{
  uint64_t result = FigSecureStopManagerCreate(a1[6], (void *)(*(void *)(a1[5] + 8) + 24));
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

CFStringRef FigSecureStopManagerCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigSecureStopManager %p]", a1);
}

void fssm_finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = *(const void **)(DerivedStorage + 16);
  if (v1)
  {
    CFRelease(v1);
    *(void *)(DerivedStorage + 16) = 0;
  }
  double v2 = *(const void **)(DerivedStorage + 24);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(DerivedStorage + 24) = 0;
  }
  dispatch_release(*(dispatch_object_t *)DerivedStorage);
  CFTypeRef v3 = *(NSObject **)(DerivedStorage + 8);

  dispatch_release(v3);
}

__CFString *fssm_copyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFIndex v4 = CFGetRetainCount(a1);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<FigSecureStopManager %p retainCount: %ld allocator: %p>", a1, v4, v5);
  return Mutable;
}

uint64_t fssm_fbo_initialize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  int v14 = 0;
  uint64_t DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a2 && a3)
  {
    uint64_t v7 = *DerivedStorage;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __fssm_fbo_initialize_block_invoke;
    block[3] = &unk_1E57A2430;
    block[4] = &v11;
    void block[5] = DerivedStorage;
    block[6] = a3;
    void block[7] = a1;
    block[8] = a2;
    dispatch_sync(v7, block);
    uint64_t v8 = *((unsigned int *)v12 + 6);
  }
  else
  {
    uint64_t v8 = FigSignalErrorAt();
    *((_DWORD *)v12 + 6) = v8;
  }
  _Block_object_dispose(&v11, 8);
  return v8;
}

uint64_t fssm_fbo_copyRecords(uint64_t a1, void *a2)
{
  uint64_t v8 = 0;
  int v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  uint64_t DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    *a2 = 0;
    CFIndex v4 = *DerivedStorage;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __fssm_fbo_copyRecords_block_invoke;
    block[3] = &unk_1E57A2458;
    block[4] = &v8;
    void block[5] = DerivedStorage;
    block[6] = a2;
    dispatch_sync(v4, block);
    uint64_t v5 = *((unsigned int *)v9 + 6);
  }
  else
  {
    uint64_t v5 = FigSignalErrorAt();
    *((_DWORD *)v9 + 6) = v5;
  }
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t fssm_fbo_removeRecords(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  int v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  uint64_t DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    CFIndex v4 = *DerivedStorage;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __fssm_fbo_removeRecords_block_invoke;
    block[3] = &unk_1E57A2480;
    block[4] = &v8;
    void block[5] = DerivedStorage;
    block[6] = a2;
    dispatch_sync(v4, block);
    uint64_t v5 = *((unsigned int *)v9 + 6);
  }
  else
  {
    uint64_t v5 = FigSignalErrorAt();
    *((_DWORD *)v9 + 6) = v5;
  }
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t fssm_fbo_updateRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000;
  int v23 = 0;
  uint64_t DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a3 | a4 && a8)
  {
    int v16 = *DerivedStorage;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __fssm_fbo_updateRecord_block_invoke;
    block[3] = &unk_1E57A24A8;
    block[4] = &v20;
    void block[5] = DerivedStorage;
    block[6] = a2;
    void block[7] = a3;
    block[8] = a4;
    void block[9] = a5;
    block[10] = a6;
    block[11] = a7;
    void block[12] = a8;
    dispatch_sync(v16, block);
    uint64_t v17 = *((unsigned int *)v21 + 6);
  }
  else
  {
    uint64_t v17 = FigSignalErrorAt();
    *((_DWORD *)v21 + 6) = v17;
  }
  _Block_object_dispose(&v20, 8);
  return v17;
}

uint64_t fssm_fbo_finalizeRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v19 = 0;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2000000000;
  int v22 = 0;
  uint64_t DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a3 | a4 && a6 && a4 | a7)
  {
    int v15 = *DerivedStorage;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __fssm_fbo_finalizeRecord_block_invoke;
    block[3] = &unk_1E57A24D0;
    block[4] = &v19;
    void block[5] = DerivedStorage;
    block[6] = a2;
    void block[7] = a3;
    block[8] = a4;
    void block[9] = a5;
    block[10] = a6;
    block[11] = a7;
    void block[12] = a1;
    dispatch_sync(v15, block);
    uint64_t v16 = *((unsigned int *)v20 + 6);
  }
  else
  {
    uint64_t v16 = FigSignalErrorAt();
    *((_DWORD *)v20 + 6) = v16;
  }
  _Block_object_dispose(&v19, 8);
  return v16;
}

void __fssm_fbo_initialize_block_invoke(uint64_t a1)
{
  CFTypeRef cf = 0;
  uint64_t v3 = *(void *)(a1 + 40);
  CFAllocatorRef v2 = *(const void **)(a1 + 48);
  CFIndex v4 = *(const void **)(v3 + 24);
  *(void *)(v3 + 24) = v2;
  if (v2) {
    CFRetain(v2);
  }
  if (v4) {
    CFRelease(v4);
  }
  CFURLRef v5 = CFURLCreateFilePathURL((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFURLRef *)(a1 + 48), 0);
  if (v5)
  {
    CFURLRef v6 = v5;
    CFAllocatorRef v7 = CFGetAllocator(*(CFTypeRef *)(a1 + 56));
    int v8 = FigSecureStopArchivistCopyInstance(v7, *(const __CFData **)(a1 + 64), v6, &cf);
    uint64_t v9 = *(void *)(a1 + 40);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v8;
    uint64_t v10 = *(const void **)(v9 + 16);
    CFTypeRef v11 = cf;
    *(void *)(v9 + 16) = cf;
    if (v11) {
      CFRetain(v11);
    }
    if (v10) {
      CFRelease(v10);
    }
    CFRelease(v6);
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigSignalErrorAt();
  }
}

uint64_t __fssm_fbo_copyRecords_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 40) + 16);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 48);
    uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v4) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    CFURLRef v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 16);
    if (v6) {
      uint64_t result = v6(v1, v3);
    }
    else {
      uint64_t result = 4294954514;
    }
    *(_DWORD *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t __fssm_fbo_removeRecords_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 40) + 16);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 48);
    uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v4) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    CFURLRef v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 24);
    if (v6) {
      uint64_t result = v6(v1, v3);
    }
    else {
      uint64_t result = 4294954514;
    }
    *(_DWORD *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t __fssm_fbo_updateRecord_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 40) + 16);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 48);
    uint64_t v4 = *(void *)(result + 56);
    uint64_t v5 = *(void *)(result + 64);
    uint64_t v6 = *(void *)(result + 72);
    uint64_t v7 = *(void *)(result + 80);
    uint64_t v8 = *(void *)(result + 88);
    uint64_t v9 = *(void *)(result + 96);
    uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 32);
    if (v12) {
      uint64_t result = v12(v1, v3, v4, v5, v6, v7, v8, v9);
    }
    else {
      uint64_t result = 4294954514;
    }
    *(_DWORD *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = result;
  }
  return result;
}

void *__fssm_fbo_finalizeRecord_block_invoke(void *result)
{
  uint64_t v1 = *(void *)(result[5] + 16);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = result[6];
    uint64_t v4 = result[7];
    uint64_t v5 = result[8];
    uint64_t v6 = result[9];
    uint64_t v7 = result[10];
    uint64_t v8 = result[11];
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v10 = v9 ? v9 : 0;
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 40);
    uint64_t result = (void *)(v11 ? v11(v1, v3, v4, v5, v6, v7, v8) : 4294954514);
    *(_DWORD *)(*(void *)(v2[4] + 8) + 24) = result;
    if (!*(_DWORD *)(*(void *)(v2[4] + 8) + 24))
    {
      CMNotificationCenterGetDefaultLocalCenter();
      return (void *)FigDispatchAsyncPostNotification();
    }
  }
  return result;
}

uint64_t FigXPCFormatReaderServerAssociateCopiedNeighborSampleCursor(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, void *a5)
{
  CFTypeRef v11 = 0;
  CFTypeRef v12 = 0;
  if (!a2)
  {
    if (a1)
    {
      uint64_t v8 = FigXPCServerLookupAndRetainAssociatedObject();
      if (!v8)
      {
        uint64_t v10 = 0;
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v8 = FigSignalErrorAt();
    }
    goto LABEL_16;
  }
  uint64_t v8 = FigXPCServerLookupAndRetainAssociatedObject();
  if (v8 || (uint64_t v8 = FigServedSampleCursorStateCreate(*MEMORY[0x1E4F1CF80], a3, v11, (uint64_t *)&v12), v8))
  {
LABEL_16:
    uint64_t v10 = v8;
    goto LABEL_10;
  }
  uint64_t v10 = FigXPCServerAssociateCopiedObjectWithNeighborProcess();
  if (!v10)
  {
    FigSampleCursorServer_SetSampleCursorProperties((uint64_t)v12, a4, 1, 2, MEMORY[0x1E4F1FA20], 0, a5);
    CFTypeRef v12 = 0;
  }
LABEL_10:
  if (v11) {
    CFRelease(v11);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v10;
}

uint64_t FigServedTrackReaderStateCreate(uint64_t a1, const void *a2, uint64_t *a3)
{
  if (!a3 || !a2) {
    goto LABEL_9;
  }
  if (FigServedTrackReaderStateGetTypeID_sRegisterFigServedTrackReaderStateTypeOnce != -1) {
    dispatch_once_f(&FigServedTrackReaderStateGetTypeID_sRegisterFigServedTrackReaderStateTypeOnce, 0, (dispatch_function_t)registerFigServedTrackReaderStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v7 = Instance;
    *(void *)(Instance + 16) = CFRetain(a2);
    *(_WORD *)(v7 + 32) = 1;
    uint64_t v8 = FigPartialSampleTableOutOfBandObjectRegistryCreate(a1, (void *)(v7 + 24));
    if (v8) {
      CFRelease((CFTypeRef)v7);
    }
    else {
      *a3 = v7;
    }
    return v8;
  }
  else
  {
LABEL_9:
    return FigSignalErrorAt();
  }
}

uint64_t FigServedSampleCursorStateCreate(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4)
{
  if (!a3 || !a3[3] || !a4) {
    goto LABEL_22;
  }
  if (FigServedSampleCursorStateGetTypeID_sRegisterFigServedSampleCursorStateTypeOnce != -1) {
    dispatch_once_f(&FigServedSampleCursorStateGetTypeID_sRegisterFigServedSampleCursorStateTypeOnce, 0, (dispatch_function_t)registerFigServedSampleCursorStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v7 = Instance;
    *(void *)(Instance + 16) = CFRetain(a3);
    CFTypeRef v8 = (CFTypeRef)a3[3];
    if (v8) {
      CFTypeRef v8 = CFRetain(v8);
    }
    *(void *)(v7 + 24) = v8;
    if (FigSampleCursorServer_copyMemoryPool_sOnceToken != -1) {
      dispatch_once(&FigSampleCursorServer_copyMemoryPool_sOnceToken, &__block_literal_global_94);
    }
    MEMORY[0x19970E910](FigSampleCursorServer_copyMemoryPool_sSharedMemoryPoolWeakRefMutex);
    if (!FigSampleCursorServer_copyMemoryPool_sSharedMemoryPoolWeakRef
      || (uint64_t v9 = FigCFWeakReferenceHolderCopyReferencedObject()) == 0)
    {
      CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      uint64_t v9 = (uint64_t)CMMemoryPoolCreate(Mutable);
      CFTypeRef v11 = (const void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
      CFTypeRef v12 = v11;
      uint64_t v13 = (const void *)FigSampleCursorServer_copyMemoryPool_sSharedMemoryPoolWeakRef;
      FigSampleCursorServer_copyMemoryPool_sSharedMemoryPoolWeakRef = (uint64_t)v11;
      if (v11) {
        CFRetain(v11);
      }
      if (v13) {
        CFRelease(v13);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (v12) {
        CFRelease(v12);
      }
    }
    MEMORY[0x19970E930](FigSampleCursorServer_copyMemoryPool_sSharedMemoryPoolWeakRefMutex);
    *(void *)(v7 + 40) = v9;
    FigXPCServerCopyMemoryOrigin();
    FigXPCServerCopyMemoryRecipient();
    *(unsigned char *)(v7 + 32) = 0;
    *a4 = v7;
    return 0;
  }
  else
  {
LABEL_22:
    return FigSignalErrorAt();
  }
}

void FigSampleCursorServer_SetSampleCursorProperties(uint64_t a1, CFTypeRef cf, int a3, char a4, long long *a5, int a6, void *a7)
{
  unsigned __int8 v8 = a6;
  CFTypeRef v84 = 0;
  int v85 = 0;
  CFTypeRef v83 = 0;
  if (a6)
  {
    if (FigSampleCursorServer_maximumStepsForBuildingPartialSampleTable_maximumStepsForBuildingPartialSampleTableOnce != -1) {
      dispatch_once(&FigSampleCursorServer_maximumStepsForBuildingPartialSampleTable_maximumStepsForBuildingPartialSampleTableOnce, &__block_literal_global_97);
    }
    int v14 = FigSampleCursorServer_maximumStepsForBuildingPartialSampleTable_maximumStepsForBuildingPartialSampleTable;
    int v15 = 20;
  }
  else
  {
    int v15 = 0;
    int v14 = 1;
  }
  CFTypeID v16 = CFGetTypeID(cf);
  if (v16 != FigSampleCursorGetTypeID())
  {
    FigSignalErrorAt();
    goto LABEL_120;
  }
  if (a3)
  {
    uint64_t v17 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v17) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = 0;
    }
    if (*(void *)(v18 + 64)) {
      unsigned int v19 = 2;
    }
    else {
      unsigned int v19 = 0;
    }
    uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v20) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = 0;
    }
    if (*(void *)(v21 + 80)) {
      v19 |= 4u;
    }
    uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v22) {
      uint64_t v23 = v22;
    }
    else {
      uint64_t v23 = 0;
    }
    if (*(void *)(v23 + 144)) {
      v19 |= 8u;
    }
    uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v24) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = 0;
    }
    if (*(void *)(v25 + 152)) {
      v19 |= 0x10u;
    }
    uint64_t v26 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v26) {
      uint64_t v27 = v26;
    }
    else {
      uint64_t v27 = 0;
    }
    if (*(void *)(v27 + 112)) {
      v19 |= 0x20u;
    }
    uint64_t v28 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v28) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = 0;
    }
    if (*(void *)(v29 + 72)) {
      v19 |= 0x40u;
    }
    xpc_dictionary_set_uint64(a7, "SampleCursorOptionalMethods", v19);
  }
  if (a4)
  {
    uint64_t v82 = 0;
    long long v80 = 0u;
    long long v81 = 0u;
    long long bytes = 0u;
    long long v79 = 0u;
    uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v30) {
      uint64_t v31 = v30;
    }
    else {
      uint64_t v31 = 0;
    }
    unsigned int v40 = *(unsigned int (**)(CFTypeRef, char *))(v31 + 40);
    if (v40 && !v40(cf, (char *)&v79 + 8))
    {
      uint64_t v41 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v42 = v41 ? v41 : 0;
      int v48 = *(unsigned int (**)(CFTypeRef, long long *))(v42 + 48);
      if (v48 && !v48(cf, &v81))
      {
        uint64_t v49 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v50 = v49 ? v49 : 0;
        int v65 = *(unsigned int (**)(CFTypeRef, long long *))(v50 + 56);
        if (v65 && !v65(cf, &bytes))
        {
          v74[0] = 0;
          uint64_t v66 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v67 = v66 ? v66 : 0;
          if (!*(void *)(v67 + 64)
            || ((uint64_t v68 = *(void *)(CMBaseObjectGetVTable() + 16)) == 0 ? (v69 = 0) : (v69 = v68),
                (int v70 = *(uint64_t (**)(CFTypeRef, char *, char *, void *, char *))(v69 + 64)) != 0
             && ((int v71 = v70(cf, (char *)v74 + 4, (char *)v74 + 5, v74, (char *)v74 + 6)) == 0 || v71 == -12840)))
          {
            xpc_dictionary_set_data(a7, "SampleCursorSampleTimingInfo", &bytes, 0x48uLL);
            xpc_dictionary_set_data(a7, "SampleCursorSyncInfo", v74, 8uLL);
          }
        }
      }
    }
    goto LABEL_120;
  }
  memset(capacity, 0, sizeof(capacity));
  int64_t value = 0;
  char v75 = 0;
  if (v14 != 1
    && FigSampleCursorServer_maximumStoragePagesForBuildingPartialSampleTable_maximumStoragePagesForBuildingPartialSampleTableOnce != -1)
  {
    dispatch_once(&FigSampleCursorServer_maximumStoragePagesForBuildingPartialSampleTable_maximumStoragePagesForBuildingPartialSampleTableOnce, &__block_literal_global_106);
  }
  if (FigMemoryPoolCreateBlockBuffer()
    || (v74[0] = 0,
        v74[1] = FigSampleCursorServer_TranslateByteStream,
        v74[2] = FigSampleCursorServer_TranslateDataSource,
        v74[3] = FigSampleCursorServer_TranslateFormatDescription,
        FigPartialSampleTableRecommendSampleTableFlagsForCursor(1023, (uint64_t)cf, (unint64_t *)&capacity[1])))
  {
LABEL_120:
    CFDictionaryRef Mutable = 0;
    goto LABEL_121;
  }
  v73[0] = a1;
  v73[1] = a7;
  uint64_t v32 = *(void *)(a1 + 16);
  if (!v32)
  {
    unint64_t v33 = *(void *)&capacity[1];
    if ((a4 & 4) != 0) {
      goto LABEL_56;
    }
    goto LABEL_55;
  }
  unint64_t v33 = *(void *)&capacity[1];
  if (!*(unsigned char *)(v32 + 33))
  {
    unint64_t v33 = *(void *)&capacity[1] & 0xFFFFFFFFFFFFFDFFLL;
    *(void *)&capacity[1] &= ~0x200uLL;
  }
  if (!*(unsigned char *)(v32 + 32))
  {
    v33 &= ~1uLL;
    *(void *)&capacity[1] = v33;
  }
  if ((a4 & 4) == 0)
  {
LABEL_55:
    v33 &= ~0x200uLL;
    *(void *)&capacity[1] = v33;
  }
LABEL_56:
  int v34 = *(unsigned __int8 *)(*(void *)(v32 + 16) + 32);
  long long v35 = a5[1];
  long long bytes = *a5;
  long long v79 = v35;
  long long v80 = a5[2];
  if (FigPartialSampleTableBuildFromFigSampleCursorAndWriteToBlockBuffer(cf, v85, v74, (uint64_t)v73, v33, v34, (uint64_t)&bytes, v8, v15, v14, &value, capacity, &v75))goto LABEL_120; {
  if (FigXPCMessageSetBlockBuffer())
  }
    goto LABEL_120;
  xpc_dictionary_set_int64(a7, "SampleCursorSampleIndex", value);
  if (!v75) {
    goto LABEL_120;
  }
  *(void *)&long long bytes = 0;
  uint64_t v36 = *MEMORY[0x1E4F1CF80];
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], capacity[0], MEMORY[0x1E4F1D510]);
  uint64_t v38 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v38) {
    uint64_t v39 = v38;
  }
  else {
    uint64_t v39 = 0;
  }
  int v43 = *(unsigned int (**)(CFTypeRef, CFTypeRef *))(v39 + 8);
  if (v43 && !v43(cf, &v84))
  {
    CFTypeRef v44 = v84;
    int64_t v45 = value;
    uint64_t v46 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v46) {
      uint64_t v47 = v46;
    }
    else {
      uint64_t v47 = 0;
    }
    int v51 = *(void (**)(CFTypeRef, int64_t, long long *))(v47 + 168);
    if (v51) {
      v51(v44, -v45, &bytes);
    }
    BOOL v52 = (void)bytes + value == 0;
    if (capacity[0] >= 1 && (void)bytes == -value)
    {
      uint64_t v53 = (const void *)*MEMORY[0x1E4F1D260];
      int v54 = 1;
      do
      {
        CFTypeRef cfa = 0;
        uint64_t FigBaseObject = FigSampleCursorGetFigBaseObject(v84);
        uint64_t v56 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v56) {
          uint64_t v57 = v56;
        }
        else {
          uint64_t v57 = 0;
        }
        int v58 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v57 + 48);
        if (v58) {
          v58(FigBaseObject, @"SampleDependencyAttributes", v36, &cfa);
        }
        CFTypeRef v59 = cfa;
        if (!cfa) {
          CFTypeRef v59 = v53;
        }
        CFArrayAppendValue(Mutable, v59);
        if (cfa) {
          CFRelease(cfa);
        }
        int v60 = capacity[0];
        if (v54 >= capacity[0])
        {
          BOOL v52 = 1;
        }
        else
        {
          CFTypeRef v61 = v84;
          uint64_t v62 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v62) {
            uint64_t v63 = v62;
          }
          else {
            uint64_t v63 = 0;
          }
          int v64 = *(void (**)(CFTypeRef, uint64_t, long long *))(v63 + 168);
          if (v64) {
            v64(v61, 1, &bytes);
          }
          BOOL v52 = (void)bytes == 1;
          int v60 = capacity[0];
        }
        if (v54 >= v60) {
          break;
        }
        ++v54;
      }
      while (v52);
    }
    if (v52 && !FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForCFType()) {
      FigXPCMessageSetBlockBuffer();
    }
  }
LABEL_121:
  if (v85) {
    CFRelease(v85);
  }
  if (v83) {
    CFRelease(v83);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v84) {
    CFRelease(v84);
  }
}

uint64_t FigXPCFormatReaderServerAssociateCopiedNeighborTrackReader(uint64_t a1, xpc_connection_t connection)
{
  CFTypeRef v8 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v7 = 0;
  if (a1)
  {
    uint64_t v2 = FigXPCServerLookupAndRetainAssociatedObject();
    if (!v2)
    {
      uint64_t v6 = 0;
      goto LABEL_9;
    }
    goto LABEL_15;
  }
  if (!connection)
  {
    uint64_t v2 = FigSignalErrorAt();
LABEL_15:
    uint64_t v6 = v2;
    goto LABEL_9;
  }
  pidouble d = xpc_connection_get_pid(connection);
  uint64_t v4 = *MEMORY[0x1E4F1CF80];
  uint64_t v2 = CreateServedFormatReaderState(*MEMORY[0x1E4F1CF80], pid, &v8);
  if (v2) {
    goto LABEL_15;
  }
  CFTypeRef cf = v8;
  uint64_t v2 = FigServedTrackReaderStateCreate(v4, v8, (uint64_t *)&v7);
  if (v2) {
    goto LABEL_15;
  }
  uint64_t v6 = FigXPCServerAssociateCopiedObjectWithNeighborProcess();
  if (!v6) {
    CFTypeRef v7 = 0;
  }
LABEL_9:
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  return v6;
}

uint64_t CreateServedFormatReaderState(uint64_t a1, uint64_t a2, void *a3)
{
  if (FigServedFormatReaderStateGetTypeID_sRegisterFigServedFormatReaderStateTypeOnce != -1) {
    dispatch_once(&FigServedFormatReaderStateGetTypeID_sRegisterFigServedFormatReaderStateTypeOnce, &__block_literal_global_67);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v5 = (void *)Instance;
    uint64_t v6 = FigSandboxAssertionCreateForPID();
    if (!v6)
    {
      uint64_t v7 = FigOSTransactionCreate();
      v5[3] = v7;
      if (v7)
      {
        uint64_t v8 = 0;
        *a3 = v5;
        return v8;
      }
      uint64_t v6 = FigSignalErrorAt();
    }
    uint64_t v8 = v6;
    CFRelease(v5);
    return v8;
  }

  return FigSignalErrorAt();
}

uint64_t FigXPCFormatReaderServerAssociateCopiedNeighborFormatReader(_xpc_connection_s *a1, uint64_t a2)
{
  uint64_t v9 = 0;
  pidouble d = xpc_connection_get_pid(a1);
  uint64_t v4 = CreateServedFormatReaderState(*MEMORY[0x1E4F1CF80], pid, &v9);
  if (v4)
  {
    uint64_t v7 = v4;
    uint64_t v6 = v9;
    if (!v9) {
      return v7;
    }
LABEL_5:
    CFRelease(v6);
    return v7;
  }
  BOOL v5 = mightFormatReaderBlockOnIOWhenStepping(a2);
  uint64_t v6 = v9;
  v9[32] = v5;
  uint64_t v7 = FigXPCServerAssociateCopiedObjectWithNeighborProcess();
  if (v7) {
    goto LABEL_5;
  }
  return v7;
}

BOOL mightFormatReaderBlockOnIOWhenStepping(uint64_t a1)
{
  CFTypeRef cf = 0;
  uint64_t FigBaseObject = FigFormatReaderGetFigBaseObject(a1);
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(unsigned int (**)(uint64_t, __CFString *, void, CFTypeRef *))(v3 + 48);
  BOOL v5 = v4
    && !v4(FigBaseObject, @"Identifier", *MEMORY[0x1E4F1CF80], &cf)
    && (FigCFEqual() || FigCFEqual() || FigCFEqual());
  if (cf) {
    CFRelease(cf);
  }
  return v5;
}

uint64_t FigXPCFormatReaderServerCopyFormatReaderForID()
{
  return FigXPCServerRetainNeighborObjectFromID();
}

uint64_t FigFormatReaderServerIsObjectIDLocallyServed(uint64_t a1)
{
  return MEMORY[0x1F40DE980](gFormatReaderServer, a1);
}

uint64_t FigFormatReaderServerStart()
{
  if (!FigServer_IsMediaparserd()) {
    FigServer_IsMediaplaybackd();
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return FigSignalErrorAt();
  }
  CFMutableDictionaryRef v1 = Mutable;
  FigCFDictionarySetValue();
  FigCFDictionarySetInt32();
  uint64_t v2 = FigXPCServerStart();
  CFRelease(v1);
  return v2;
}

uint64_t HandleFormatReaderMessage(uint64_t a1, void *a2)
{
  uint64_t OpCode = FigXPCMessageGetOpCode();
  if (OpCode) {
    return OpCode;
  }
  CFTypeRef cf = 0;
  xpc_dictionary_get_uint64(a2, (const char *)*MEMORY[0x1E4F20280]);
  uint64_t OpCode = FigXPCServerLookupAndRetainAssociatedObject();
  if (OpCode) {
    return OpCode;
  }
  CFTypeID v6 = CFGetTypeID(0);
  CFStringRef v7 = CFCopyTypeIDDescription(v6);
  if (v7) {
    CFRelease(v7);
  }
  return 0;
}

uint64_t HandleNoReplyFormatReaderMessage(uint64_t a1, void *a2)
{
  uint64_t OpCode = FigXPCMessageGetOpCode();
  if (OpCode) {
    return OpCode;
  }
  xpc_dictionary_get_uint64(a2, (const char *)*MEMORY[0x1E4F20280]);
  uint64_t OpCode = FigXPCServerLookupAndRetainAssociatedObject();
  if (OpCode) {
    return OpCode;
  }
  else {
    return 4294951138;
  }
}

uint64_t HandleServerSetupEventLink()
{
  return FigOSEventLinkServerSetCallbacks();
}

uint64_t FigFormatReaderServerStartLoopbackServerAndCopyXPCEndpoint()
{
  if (FigFormatReaderServerStartLoopbackServerAndCopyXPCEndpoint_sEndpointServer) {
    return FigSignalErrorAt();
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt();
  FigCFDictionarySetValue();
  uint64_t v1 = FigXPCServerStartWithNewXPCEndpoint();
  if (!v1) {
    uint64_t v1 = FigXPCServerCopyXPCEndpoint();
  }
  uint64_t v2 = v1;
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v2;
}

uint64_t FigXPCFormatReaderServerCopySampleCursorForID(uint64_t a1, void *a2)
{
  uint64_t result = FigXPCServerRetainNeighborObjectFromID();
  if (!result)
  {
    uint64_t result = 0;
    *a2 = 0;
  }
  return result;
}

uint64_t __FigServedFormatReaderStateGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  FigServedFormatReaderStateGetTypeID_sFigServedFormatReaderStateID = result;
  return result;
}

void *servedFormatReaderState_Init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void servedFormatReaderState_Finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    os_release(v3);
    *(void *)(a1 + 24) = 0;
  }
}

__CFString *servedFormatReaderState_CopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, @"FigServedFormatReaderState %p", a1);
  return Mutable;
}

uint64_t registerFigServedTrackReaderStateType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigServedTrackReaderStateID = result;
  return result;
}

void *FigServedTrackReaderState_Init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void FigServedTrackReaderState_Finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 16) = 0;
  }
}

__CFString *FigServedTrackReaderState_CopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<FigServedTrackReaderState %p>", a1);
  return Mutable;
}

uint64_t registerFigServedSampleCursorStateType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigServedSampleCursorStateID = result;
  return result;
}

double FigServedSampleCursorState_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void FigServedSampleCursorState_Finalize(void *a1)
{
  CFAllocatorRef v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  BOOL v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0;
  }
  CFTypeID v6 = (const void *)a1[7];
  if (v6)
  {
    CFRelease(v6);
    a1[7] = 0;
  }
}

__CFString *FigServedSampleCursorState_CopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<FigServedSampleCursorState %p>", a1);
  return Mutable;
}

uint64_t FigSampleCursorServer_TranslateByteStream(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = 0;
  if (FigServer_IsMediaparserd())
  {
    uint64_t result = FigByteStreamRemoteGetObjectID(a2, &v7);
    if (a3 && !result)
    {
      uint64_t v6 = v7;
LABEL_7:
      uint64_t result = 0;
      *a3 = v6;
    }
  }
  else
  {
    if (a3)
    {
      uint64_t v6 = 0;
      goto LABEL_7;
    }
    return 0;
  }
  return result;
}

uint64_t FigSampleCursorServer_TranslateDataSource(xpc_object_t *a1, CFTypeRef cf, uint64_t *a3)
{
  uint64_t value = 0;
  char v12 = 0;
  uint64_t IDForObjectOfType = FigPartialSampleTableOutOfBandObjectRegistryLookupOrMakeIDForObjectOfType(*((void *)*a1 + 3), @"DataSourceURL", cf, &value, &v12);
  if (IDForObjectOfType)
  {
    uint64_t v10 = IDForObjectOfType;
  }
  else
  {
    if (v12)
    {
      arraCGFloat y = xpc_dictionary_get_array(a1[1], "SampleCursorDataSourceArray");
      if (!array)
      {
        arraCGFloat y = xpc_array_create(0, 0);
        xpc_dictionary_set_value(a1[1], "SampleCursorDataSourceArray", array);
        FigXPCRelease();
      }
      uint64_t v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (!v7 || (empty = xpc_dictionary_create_empty(), (uint64_t v9 = empty) == 0))
      {
        uint64_t v10 = FigSignalErrorAt();
        goto LABEL_9;
      }
      xpc_dictionary_set_value(empty, "SampleCursorDataSourceURL", v7);
      xpc_dictionary_set_uint64(v9, "SampleCursorDataSourceOutOfBandID", value);
      xpc_array_append_value(array, v9);
    }
    uint64_t v10 = 0;
    *a3 = value;
  }
LABEL_9:
  FigXPCRelease();
  FigXPCRelease();
  return v10;
}

uint64_t FigSampleCursorServer_TranslateFormatDescription(xpc_object_t *a1, CFTypeRef cf, uint64_t *a3)
{
  uint64_t v23 = 0;
  uint64_t value = 0;
  char v21 = 0;
  uint64_t IDForObjectOfType = FigPartialSampleTableOutOfBandObjectRegistryLookupOrMakeIDForObjectOfType(*((void *)*a1 + 3), @"FormatDescription", cf, &value, &v21);
  if (IDForObjectOfType)
  {
    uint64_t v17 = IDForObjectOfType;
    uint64_t v13 = 0;
    goto LABEL_14;
  }
  if (!v21)
  {
    uint64_t v13 = 0;
    goto LABEL_13;
  }
  long long dataPointerOut = 0;
  arraCGFloat y = xpc_dictionary_get_array(a1[1], "SampleCursorFormatDescriptionArray");
  if (!array)
  {
    arraCGFloat y = xpc_array_create(0, 0);
    xpc_dictionary_set_value(a1[1], "SampleCursorFormatDescriptionArray", array);
    FigXPCRelease();
  }
  SerializedAtomDataBlockBufferForCMFormatDescriptionRef FormatDescription = FigRemote_CreateSerializedAtomDataBlockBufferForFormatDescription();
  if (SerializedAtomDataBlockBufferForFormatDescription) {
    goto LABEL_19;
  }
  uint64_t v8 = v23;
  DataCFIndex Length = CMBlockBufferGetDataLength(v23);
  if (CMBlockBufferIsRangeContiguous(v8, 0, DataLength))
  {
    SerializedAtomDataBlockBufferForCMFormatDescriptionRef FormatDescription = CMBlockBufferGetDataPointer(v23, 0, 0, 0, &dataPointerOut);
    if (!SerializedAtomDataBlockBufferForFormatDescription)
    {
      uint64_t v10 = dataPointerOut;
      size_t v11 = CMBlockBufferGetDataLength(v23);
      destructor[0] = MEMORY[0x1E4F143A8];
      destructor[1] = 0x40000000;
      destructor[2] = __FigSampleCursorServer_TranslateFormatDescription_block_invoke;
      destructor[3] = &__block_descriptor_tmp_110_2;
      destructor[4] = v23;
      char v12 = dispatch_data_create(v10, v11, 0, destructor);
      uint64_t v13 = v12;
      if (v12)
      {
        uint64_t v23 = 0;
        xpc_object_t v14 = xpc_data_create_with_dispatch_data(v12);
        if (v14)
        {
          emptCGFloat y = xpc_dictionary_create_empty();
          if (empty)
          {
            CFTypeID v16 = empty;
            xpc_dictionary_set_value(empty, "SampleCursorFormatDescription", v14);
            xpc_dictionary_set_uint64(v16, "SampleCursorFormatDescriptionOutOfBandID", value);
            xpc_array_append_value(array, v16);
LABEL_13:
            uint64_t v17 = 0;
            *a3 = value;
            goto LABEL_14;
          }
        }
      }
      goto LABEL_22;
    }
LABEL_19:
    uint64_t v17 = SerializedAtomDataBlockBufferForFormatDescription;
    uint64_t v13 = 0;
    goto LABEL_14;
  }
  uint64_t v13 = 0;
LABEL_22:
  uint64_t v17 = FigSignalErrorAt();
LABEL_14:
  FigXPCRelease();
  FigXPCRelease();
  if (v23) {
    CFRelease(v23);
  }
  if (v13) {
    dispatch_release(v13);
  }
  return v17;
}

uint64_t HandleSampleCursorMessage(int a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5, uint64_t a6, xpc_object_t xdict, void *a8)
{
  if (xpc_dictionary_get_uint64(xdict, "SampleCursorSecondSampleCursorID")) {
    xpc_dictionary_set_value(xdict, "SampleCursorSecondSampleCursorID", 0);
  }
  if (a1 > 1936159592)
  {
    if (a1 > 1936941670)
    {
      if (a1 > 1936944226)
      {
        if (a1 == 1936944227)
        {
          return HandleSampleCursorCopySampleLocationMessage(a3, a8);
        }
        else
        {
          if (a1 != 1936945268) {
            return 4294951138;
          }
          return HandleSampleCursorStepByPresentationTimeMessage(a3, a4, xdict, a8);
        }
      }
      else if (a1 == 1936941671)
      {
        return HandleSampleCursorGetBatchSampleTimingAndSizes(a3, a5, xdict, a8);
      }
      else
      {
        if (a1 != 1936942196) {
          return 4294951138;
        }
        return HandleSampleCursorStepByDecodeTimeMessage(a3, a4, xdict, a8);
      }
    }
    else if (a1 > 1936730999)
    {
      if (a1 == 1936731000)
      {
        return HandleSampleCursorStepInPresentationOrderAndReportStepsTakenMessage(a3, a4, xdict, a8);
      }
      else
      {
        if (a1 != 1936941670) {
          return 4294951138;
        }
        return HandleSampleCursorCreateSampleBufferMessage(a3, (uint64_t)a5);
      }
    }
    else if (a1 == 1936159593)
    {
      return HandleSampleCursorGetSampleSyncInfoMessage(a3, a8);
    }
    else
    {
      if (a1 != 1936159849) {
        return 4294951138;
      }
      return HandleSampleCursorGetSampleTimingInfoMessage(a3, a8);
    }
  }
  else if (a1 > 1935896690)
  {
    if (a1 > 1935944567)
    {
      if (a1 == 1935944568)
      {
        return HandleSampleCursorStepInDecodeOrderAndReportStepsTakenMessage(a3, a4, xdict, a8);
      }
      else
      {
        if (a1 != 1935962979) {
          return 4294951138;
        }
        return HandleSampleCursorCopyFormatDescriptionMessage(a3);
      }
    }
    else if (a1 == 1935896691)
    {
      return HandleSampleCursorCopyMessage(a2, a3, a4, xdict, a8);
    }
    else
    {
      if (a1 != 1935896697) {
        return 4294951138;
      }
      return HandleSampleCursorCopyPropertyMessage(a3);
    }
  }
  else if (a1 > 1935894634)
  {
    if (a1 == 1935894635)
    {
      return HandleSampleCursorCopyChunkDetailsMessage(a3, a8);
    }
    else
    {
      if (a1 != 1935895920) {
        return 4294951138;
      }
      return HandleSampleCursorCompareInDecodeOrderMessage(a3, a5, a8);
    }
  }
  else
  {
    if (a1 != 1668492075)
    {
      if (a1 == 1935830628)
      {
        return HandleSampleCursorTestReorderingBoundaryMessage(a3, a5, xdict, a8);
      }
      return 4294951138;
    }
    return HandleSampleCursorMaybeCopyAndStepCursorsThenPerformOperationWithCopiesMessage(a2, a3, a4, a5, a6, xdict, a8);
  }
}

uint64_t HandleSampleCursorCopyPropertyMessage(const void *a1)
{
  CFTypeID v1 = CFGetTypeID(a1);
  if (v1 != FigSampleCursorGetTypeID()) {
    return FigSignalErrorAt();
  }
  uint64_t result = FigXPCMessageCopyCFString();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleSampleCursorCopyMessage(uint64_t a1, CFTypeRef cf, uint64_t a3, void *a4, void *a5)
{
  CFTypeRef cfa = 0;
  uint64_t value = 0;
  CFTypeRef v14 = 0;
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 == FigSampleCursorGetTypeID())
  {
    uint64_t v11 = CopySampleCursorAndReturnObjectID(a1, cf, a3, &v14, &cfa, &value);
    if (!v11)
    {
      char v12 = FigSampleCursorServer_obtainCacheOption(a4);
      FigSampleCursorServer_SetSampleCursorProperties((uint64_t)cfa, v14, 0, v12, MEMORY[0x1E4F1FA20], 0, a5);
      xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E4F20280], value);
    }
  }
  else
  {
    uint64_t v11 = FigSignalErrorAt();
  }
  if (cfa) {
    CFRelease(cfa);
  }
  if (v14) {
    CFRelease(v14);
  }
  return v11;
}

uint64_t HandleSampleCursorGetSampleTimingInfoMessage(const void *a1, void *a2)
{
  long long v4 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 48);
  v18[1] = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 32);
  long long v19 = v4;
  uint64_t v20 = *(void *)(MEMORY[0x1E4F1FA70] + 64);
  long long v5 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 16);
  long long v17 = *MEMORY[0x1E4F1FA70];
  v18[0] = v5;
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == FigSampleCursorGetTypeID())
  {
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(uint64_t (**)(const void *, char *))(v8 + 40);
    if (!v9) {
      return 4294954514;
    }
    uint64_t result = v9(a1, (char *)v18 + 8);
    if (result) {
      return result;
    }
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v12 = v11 ? v11 : 0;
    uint64_t v13 = *(uint64_t (**)(const void *, long long *))(v12 + 48);
    if (!v13) {
      return 4294954514;
    }
    uint64_t result = v13(a1, &v19);
    if (result) {
      return result;
    }
    uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v15 = v14 ? v14 : 0;
    CFTypeID v16 = *(uint64_t (**)(const void *, long long *))(v15 + 56);
    if (v16)
    {
      uint64_t result = v16(a1, &v17);
      if (!result)
      {
        xpc_dictionary_set_data(a2, "SampleCursorSampleTimingInfo", &v17, 0x48uLL);
        return 0;
      }
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleSampleCursorGetSampleSyncInfoMessage(const void *a1, void *a2)
{
  uint64_t bytes = 0;
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == FigSampleCursorGetTypeID())
  {
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(uint64_t (**)(const void *, char *, char *, uint64_t *, char *))(v6 + 64);
    if (!v7) {
      return 4294954514;
    }
    uint64_t v8 = v7(a1, (char *)&bytes + 4, (char *)&bytes + 5, &bytes, (char *)&bytes + 6);
    uint64_t v9 = v8;
    if (!v8 || v8 == -12840) {
      xpc_dictionary_set_data(a2, "SampleCursorSyncInfo", &bytes, 8uLL);
    }
    return v9;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t HandleSampleCursorStepByDecodeTimeMessage(const void *a1, uint64_t a2, void *a3, void *a4)
{
  long long v14 = *MEMORY[0x1E4F1F9F8];
  uint64_t v15 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 == FigSampleCursorGetTypeID())
  {
    uint64_t result = FigXPCMessageGetCMTime();
    if (!result)
    {
      uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = *(uint64_t (**)(const void *, long long *))(v11 + 120);
      if (v12)
      {
        long long v16 = v14;
        uint64_t v17 = v15;
        uint64_t result = v12(a1, &v16);
        if (!result || result == -12840)
        {
          xpc_dictionary_set_BOOL(a4, "SampleCursorPositionWasPinned", result == -12840);
          char v13 = FigSampleCursorServer_obtainCacheOption(a3);
          FigSampleCursorServer_SetSampleCursorProperties(a2, a1, 0, v13, MEMORY[0x1E4F1FA20], 0, a4);
          return 0;
        }
      }
      else
      {
        return 4294954514;
      }
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleSampleCursorStepByPresentationTimeMessage(const void *a1, uint64_t a2, void *a3, void *a4)
{
  long long v14 = *MEMORY[0x1E4F1F9F8];
  uint64_t v15 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 == FigSampleCursorGetTypeID())
  {
    uint64_t result = FigXPCMessageGetCMTime();
    if (!result)
    {
      uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = *(uint64_t (**)(const void *, long long *))(v11 + 128);
      if (v12)
      {
        long long v16 = v14;
        uint64_t v17 = v15;
        uint64_t result = v12(a1, &v16);
        if (!result || result == -12840)
        {
          xpc_dictionary_set_BOOL(a4, "SampleCursorPositionWasPinned", result == -12840);
          char v13 = FigSampleCursorServer_obtainCacheOption(a3);
          FigSampleCursorServer_SetSampleCursorProperties(a2, a1, 0, v13, MEMORY[0x1E4F1FA20], 0, a4);
          return 0;
        }
      }
      else
      {
        return 4294954514;
      }
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleSampleCursorStepInDecodeOrderAndReportStepsTakenMessage(const void *a1, uint64_t a2, void *a3, void *a4)
{
  int64_t v22 = 0;
  long long v8 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  long long v19 = *MEMORY[0x1E4F1FA20];
  long long v20 = v8;
  long long v21 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  CFTypeID v9 = CFGetTypeID(a1);
  if (v9 == FigSampleCursorGetTypeID())
  {
    int64_t int64 = xpc_dictionary_get_int64(a3, "SampleCursorStepCount");
    FigXPCMessageGetCMTimeRange();
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v11) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0;
    }
    char v13 = *(uint64_t (**)(const void *, int64_t, int64_t *))(v12 + 168);
    if (v13)
    {
      uint64_t v14 = v13(a1, int64, &v22);
      if (!v14)
      {
        if (int64 > 0) {
          int v15 = 1;
        }
        else {
          int v15 = int64 >> 63;
        }
        char v16 = FigSampleCursorServer_obtainCacheOption(a3);
        v18[0] = v19;
        v18[1] = v20;
        _OWORD v18[2] = v21;
        FigSampleCursorServer_SetSampleCursorProperties(a2, a1, 0, v16, v18, v15, a4);
      }
    }
    else
    {
      uint64_t v14 = 4294954514;
    }
  }
  else
  {
    uint64_t v14 = FigSignalErrorAt();
  }
  xpc_dictionary_set_int64(a4, "SampleCursorStepsTaken", v22);
  return v14;
}

uint64_t HandleSampleCursorStepInPresentationOrderAndReportStepsTakenMessage(const void *a1, uint64_t a2, void *a3, void *a4)
{
  int64_t v22 = 0;
  long long v8 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  long long v19 = *MEMORY[0x1E4F1FA20];
  long long v20 = v8;
  long long v21 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  CFTypeID v9 = CFGetTypeID(a1);
  if (v9 == FigSampleCursorGetTypeID())
  {
    int64_t int64 = xpc_dictionary_get_int64(a3, "SampleCursorStepCount");
    FigXPCMessageGetCMTimeRange();
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v11) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0;
    }
    char v13 = *(uint64_t (**)(const void *, int64_t, int64_t *))(v12 + 176);
    if (v13)
    {
      uint64_t v14 = v13(a1, int64, &v22);
      if (!v14)
      {
        if (int64 > 0) {
          int v15 = 1;
        }
        else {
          int v15 = int64 >> 63;
        }
        char v16 = FigSampleCursorServer_obtainCacheOption(a3);
        v18[0] = v19;
        v18[1] = v20;
        _OWORD v18[2] = v21;
        FigSampleCursorServer_SetSampleCursorProperties(a2, a1, 0, v16, v18, v15, a4);
      }
    }
    else
    {
      uint64_t v14 = 4294954514;
    }
  }
  else
  {
    uint64_t v14 = FigSignalErrorAt();
  }
  xpc_dictionary_set_int64(a4, "SampleCursorStepsTaken", v22);
  return v14;
}

uint64_t HandleSampleCursorCompareInDecodeOrderMessage(const void *a1, const void *a2, void *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == FigSampleCursorGetTypeID() && a2 && (CFTypeID v8 = CFGetTypeID(a2), v8 == FigSampleCursorGetTypeID()))
  {
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    if (v10 == *(void *)(CMBaseObjectGetVTable() + 16)
      && (uint64_t v12 = *(uint64_t (**)(const void *, const void *))(v10 + 32)) != 0)
    {
      int64_t v11 = v12(a1, a2);
    }
    else
    {
      int64_t v11 = 0;
    }
    xpc_dictionary_set_int64(a3, "SampleCursorComparisonResult", v11);
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t HandleSampleCursorTestReorderingBoundaryMessage(const void *a1, const void *a2, void *a3, void *a4)
{
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 == FigSampleCursorGetTypeID() && a2 && (CFTypeID v10 = CFGetTypeID(a2), v10 == FigSampleCursorGetTypeID()))
  {
    int64_t int64 = xpc_dictionary_get_int64(a3, "SampleCursorReorderingBoundary");
    uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v12) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    BOOL v14 = v13 == *(void *)(CMBaseObjectGetVTable() + 16)
       && (int v15 = *(unsigned int (**)(const void *, const void *, int64_t))(v13 + 80)) != 0
       && v15(a1, a2, int64) != 0;
    xpc_dictionary_set_BOOL(a4, "SampleCursorTestReorderingBoundaryResult", v14);
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t HandleSampleCursorCopySampleLocationMessage(const void *a1, void *a2)
{
  CFTypeRef cf = 0;
  CFTypeRef v18 = 0;
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID())
  {
    uint64_t v8 = FigSignalErrorAt();
    goto LABEL_25;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(const void *, uint64_t *, uint64_t *, CFTypeRef *, CFTypeRef *))(v6 + 144);
  if (!v7)
  {
    uint64_t v9 = 4294954514;
    goto LABEL_13;
  }
  uint64_t v8 = v7(a1, &v15, &v16, &v18, &cf);
  if (v8)
  {
LABEL_25:
    uint64_t v9 = v8;
    goto LABEL_13;
  }
  xpc_dictionary_set_data(a2, "SampleCursorSampleStorageRange", &v15, 0x10uLL);
  if (v18)
  {
    if (!cf)
    {
      uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
      uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v13 = v12 ? v12 : 0;
      BOOL v14 = *(void (**)(uint64_t, void, void, CFTypeRef *))(v13 + 48);
      if (v14) {
        v14(CMBaseObject, *MEMORY[0x1E4F1EC78], *MEMORY[0x1E4F1CF80], &cf);
      }
    }
  }
  else if (!cf)
  {
    return 0;
  }
  FigXPCMessageSetCFURL();
  uint64_t v9 = 0;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v18) {
    CFRelease(v18);
  }
  return v9;
}

uint64_t HandleSampleCursorCopyChunkDetailsMessage(const void *a1, void *a2)
{
  CFTypeRef v20 = 0;
  int64_t v21 = 0;
  CFTypeRef cf = 0;
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID())
  {
    uint64_t v8 = FigSignalErrorAt();
    goto LABEL_25;
  }
  uint64_t bytes = 0;
  uint64_t v18 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(const void *, CFTypeRef *, CFTypeRef *, uint64_t *, uint64_t *, uint64_t *, int64_t *, uint64_t *, char *, char *))(v6 + 152);
  if (!v7)
  {
    uint64_t v9 = 4294954514;
    goto LABEL_13;
  }
  uint64_t v8 = v7(a1, &v20, &cf, &bytes, &v18, &v15, &v21, &v16, (char *)&v16 + 1, (char *)&v16 + 2);
  if (v8)
  {
LABEL_25:
    uint64_t v9 = v8;
    goto LABEL_13;
  }
  xpc_dictionary_set_data(a2, "SampleCursorSampleStorageRange", &bytes, 0x10uLL);
  xpc_dictionary_set_data(a2, "SampleCursorChunkInfo", &v15, 0x10uLL);
  xpc_dictionary_set_int64(a2, "SampleCursorSampleIndex", v21);
  if (v20)
  {
    if (!cf)
    {
      uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
      uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v13 = v12 ? v12 : 0;
      BOOL v14 = *(void (**)(uint64_t, void, void, CFTypeRef *))(v13 + 48);
      if (v14) {
        v14(CMBaseObject, *MEMORY[0x1E4F1EC78], *MEMORY[0x1E4F1CF80], &cf);
      }
    }
  }
  else if (!cf)
  {
    return 0;
  }
  FigXPCMessageSetCFURL();
  uint64_t v9 = 0;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v20) {
    CFRelease(v20);
  }
  return v9;
}

uint64_t HandleSampleCursorCopyFormatDescriptionMessage(const void *a1)
{
  CFTypeRef cf = 0;
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == FigSampleCursorGetTypeID())
  {
    uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v3) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = 0;
    }
    uint64_t v5 = *(uint64_t (**)(const void *, CFTypeRef *))(v4 + 160);
    if (!v5) {
      return 4294954514;
    }
    uint64_t v6 = v5(a1, &cf);
    CFTypeRef v7 = cf;
    if (v6)
    {
      uint64_t v8 = v6;
      if (!cf) {
        return v8;
      }
    }
    else
    {
      uint64_t v8 = FigXPCMessageSetFormatDescription();
      CFTypeRef v7 = cf;
      if (!cf) {
        return v8;
      }
    }
    CFRelease(v7);
    return v8;
  }

  return FigSignalErrorAt();
}

uint64_t HandleSampleCursorCreateSampleBufferMessage(const void *a1, uint64_t a2)
{
  CMBlockBufferRef theBuffer = 0;
  CFTypeRef cf = 0;
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID())
  {
    uint64_t SerializedAtomDataBlockBufferForSampleBuffer = FigSignalErrorAt();
    goto LABEL_14;
  }
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  CFTypeRef v7 = *(uint64_t (**)(const void *, uint64_t, CFTypeRef *))(v6 + 112);
  if (v7)
  {
    uint64_t SerializedAtomDataBlockBufferForSampleBuffer = v7(a1, a2, &cf);
    if (SerializedAtomDataBlockBufferForSampleBuffer) {
      goto LABEL_14;
    }
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t SerializedAtomDataBlockBufferForSampleBuffer = FigRemote_CreateSerializedAtomDataBlockBufferForSampleBuffer();
    if (SerializedAtomDataBlockBufferForSampleBuffer) {
      goto LABEL_14;
    }
    if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, 0))
    {
      CMBlockBufferRef blockBufferOut = 0;
      uint64_t SerializedAtomDataBlockBufferForSampleBuffer = CMBlockBufferCreateContiguous(v9, theBuffer, v9, 0, 0, 0, 0, &blockBufferOut);
      if (SerializedAtomDataBlockBufferForSampleBuffer)
      {
LABEL_14:
        uint64_t v10 = SerializedAtomDataBlockBufferForSampleBuffer;
        goto LABEL_16;
      }
      if (theBuffer) {
        CFRelease(theBuffer);
      }
      CMBlockBufferRef theBuffer = blockBufferOut;
    }
    uint64_t SerializedAtomDataBlockBufferForSampleBuffer = FigXPCMessageSetBlockBuffer();
    goto LABEL_14;
  }
  uint64_t v10 = 4294954514;
LABEL_16:
  if (cf) {
    CFRelease(cf);
  }
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return v10;
}

uint64_t HandleSampleCursorGetBatchSampleTimingAndSizes(const void *a1, const void *a2, void *a3, void *a4)
{
  long long dataPointerOut = 0;
  uint64_t v26 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  CMBlockBufferRef theBuffer = 0;
  int64_t value = 0;
  int64_t v22 = 0;
  int64_t v20 = 0;
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID()) {
    goto LABEL_35;
  }
  if (a2)
  {
    CFTypeID v9 = CFGetTypeID(a2);
    if (v9 != FigSampleCursorGetTypeID()) {
      goto LABEL_35;
    }
  }
  unint64_t int64 = xpc_dictionary_get_int64(a3, "SampleCursorBatchMaxSamplesToInclude");
  BOOL v11 = xpc_dictionary_get_BOOL(a3, "SampleCursorBatchRequiresSampleSizeEntries");
  if (xpc_dictionary_get_BOOL(a3, "SampleCursorBatchRequiresSampleTimingEntries")) {
    uint64_t v12 = &v20;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v11) {
    p_int64_t value = &value;
  }
  else {
    p_int64_t value = 0;
  }
  uint64_t BatchSampleTimingAndSizes = FigSampleCursorUtilityGetBatchSampleTimingAndSizes((uint64_t)a1, int64, (uint64_t)a2, 0, v12, 0, p_value, 0);
  if (BatchSampleTimingAndSizes) {
    goto LABEL_36;
  }
  int64_t v15 = v20;
  if (v20 > int64 || value > int64)
  {
LABEL_35:
    uint64_t BatchSampleTimingAndSizes = FigSignalErrorAt();
    goto LABEL_36;
  }
  uint64_t v16 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (value)
  {
    uint64_t BatchSampleTimingAndSizes = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 8 * value, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 8 * value, 1u, &theBuffer);
    if (BatchSampleTimingAndSizes) {
      goto LABEL_36;
    }
    uint64_t BatchSampleTimingAndSizes = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    if (BatchSampleTimingAndSizes) {
      goto LABEL_36;
    }
    int64_t v15 = v20;
  }
  if (v15)
  {
    uint64_t BatchSampleTimingAndSizes = CMBlockBufferCreateWithMemoryBlock(*v16, 0, 72 * v15, *v16, 0, 0, 72 * v15, 1u, &blockBufferOut);
    if (BatchSampleTimingAndSizes) {
      goto LABEL_36;
    }
    uint64_t BatchSampleTimingAndSizes = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v26);
    if (BatchSampleTimingAndSizes) {
      goto LABEL_36;
    }
    uint64_t v17 = v26;
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t BatchSampleTimingAndSizes = FigSampleCursorUtilityGetBatchSampleTimingAndSizes((uint64_t)a1, int64, (uint64_t)a2, &v22, v12, (uint64_t)v17, p_value, (uint64_t)dataPointerOut);
  if (!BatchSampleTimingAndSizes)
  {
    if (theBuffer)
    {
      uint64_t BatchSampleTimingAndSizes = FigXPCMessageSetBlockBuffer();
      if (BatchSampleTimingAndSizes) {
        goto LABEL_36;
      }
      xpc_dictionary_set_int64(a4, "SampleCursorBatchNumSampleSizeEntries", value);
    }
    if (!blockBufferOut)
    {
LABEL_29:
      xpc_dictionary_set_int64(a4, "SampleCursorBatchNumSamplesIncluded", v22);
      uint64_t v18 = 0;
      goto LABEL_30;
    }
    uint64_t BatchSampleTimingAndSizes = FigXPCMessageSetBlockBuffer();
    if (!BatchSampleTimingAndSizes)
    {
      xpc_dictionary_set_int64(a4, "SampleCursorBatchNumSampleTimingEntries", v20);
      goto LABEL_29;
    }
  }
LABEL_36:
  uint64_t v18 = BatchSampleTimingAndSizes;
LABEL_30:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v18;
}

uint64_t HandleSampleCursorMaybeCopyAndStepCursorsThenPerformOperationWithCopiesMessage(uint64_t a1, CFTypeRef cf, uint64_t a3, CFTypeRef a4, uint64_t a5, void *a6, void *a7)
{
  CFTypeRef v11 = cf;
  CFTypeRef v36 = 0;
  CFTypeRef v37 = 0;
  uint64_t v34 = 0;
  uint64_t value = 0;
  CFTypeID v13 = CFGetTypeID(cf);
  if (v13 != FigSampleCursorGetTypeID()) {
    goto LABEL_38;
  }
  BOOL v14 = xpc_dictionary_get_BOOL(a6, "SampleCursorCursorMustCopy");
  CFTypeRef int64 = (CFTypeRef)xpc_dictionary_get_int64(a6, "SampleCursorMatchCacheSteps");
  if (a4)
  {
    CFTypeID v16 = CFGetTypeID(a4);
    if (v16 != FigSampleCursorGetTypeID())
    {
LABEL_38:
      uint64_t v19 = FigSignalErrorAt();
      goto LABEL_39;
    }
    BOOL v17 = xpc_dictionary_get_BOOL(a6, "SampleCursorSecondCursorMustCopy");
    CFTypeRef v18 = (CFTypeRef)xpc_dictionary_get_int64(a6, "SampleCursorSecondCursorMatchCacheSteps");
    if (!v14) {
      goto LABEL_10;
    }
  }
  else
  {
    BOOL v17 = 0;
    CFTypeRef v18 = 0;
    if (!v14) {
      goto LABEL_10;
    }
  }
  CFTypeRef cfa = 0;
  uint64_t v19 = CopySampleCursorAndReturnObjectID(a1, v11, a3, &v37, &cfa, &value);
  if (v19) {
    goto LABEL_39;
  }
  xpc_dictionary_set_uint64(a7, (const char *)*MEMORY[0x1E4F20280], value);
  CFTypeRef v11 = v37;
  LODWORD(a3) = cfa;
  if (cfa) {
    CFRelease(cfa);
  }
LABEL_10:
  if (v17)
  {
    CFTypeRef cfa = 0;
    uint64_t v19 = CopySampleCursorAndReturnObjectID(a1, a4, a5, &v36, &cfa, &v34);
    if (v19) {
      goto LABEL_39;
    }
    xpc_dictionary_set_uint64(a7, "SampleCursorSecondSampleCursorID", v34);
    a4 = v36;
    LODWORD(a5) = cfa;
    if (cfa) {
      CFRelease(cfa);
    }
  }
  if (!int64) {
    goto LABEL_21;
  }
  CFTypeRef cfa = 0;
  uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v20) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = 0;
  }
  int64_t v22 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef *))(v21 + 168);
  if (!v22) {
    goto LABEL_31;
  }
  uint64_t v19 = v22(v11, int64, &cfa);
  if (v19)
  {
LABEL_39:
    uint64_t v30 = v19;
    goto LABEL_32;
  }
  if (int64 != cfa) {
    goto LABEL_38;
  }
LABEL_21:
  if (!v18) {
    goto LABEL_28;
  }
  CFTypeRef cfa = 0;
  uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v23) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = 0;
  }
  uint64_t v25 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef *))(v24 + 168);
  if (!v25)
  {
LABEL_31:
    uint64_t v30 = 4294954514;
    goto LABEL_32;
  }
  uint64_t v19 = v25(a4, v18, &cfa);
  if (v19) {
    goto LABEL_39;
  }
  if (v18 != cfa) {
    goto LABEL_38;
  }
LABEL_28:
  xpc_object_t v26 = xpc_dictionary_get_value(a6, "SampleCursorAdditionalOperation");
  if (v26)
  {
    uint64_t v27 = v26;
    int uint64 = xpc_dictionary_get_uint64(v26, (const char *)*MEMORY[0x1E4F20288]);
    emptCGFloat y = xpc_dictionary_create_empty();
    if (empty)
    {
      HandleSampleCursorMessage(uint64, a1, (int)v11, a3, (int)a4, a5, v27);
      FigXPCMessageSetOSStatus();
      xpc_dictionary_set_value(a7, "SampleCursorAdditionalReply", empty);
      uint64_t v30 = 0;
    }
    else
    {
      uint64_t v30 = FigSignalErrorAt();
    }
  }
  else
  {
    uint64_t v30 = 0;
  }
LABEL_32:
  FigXPCRelease();
  if (v37) {
    CFRelease(v37);
  }
  if (v36) {
    CFRelease(v36);
  }
  return v30;
}

uint64_t CopySampleCursorAndReturnObjectID(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4, CFTypeRef *a5, void *a6)
{
  CFTypeRef cf = 0;
  CFTypeRef v21 = 0;
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  BOOL v14 = *(uint64_t (**)(const void *, CFTypeRef *))(v13 + 8);
  if (v14)
  {
    uint64_t v15 = v14(a2, &v21);
    if (v15
      || (CFAllocatorRef v16 = CFGetAllocator(a2),
          uint64_t v15 = FigServedSampleCursorStateCreate((uint64_t)v16, a1, *(void **)(a3 + 16), (uint64_t *)&cf),
          v15)
      || (CFTypeRef v17 = cf,
          *((unsigned char *)cf + 32) = *(unsigned char *)(a3 + 32),
          *(unsigned char *)(a3 + 32) = 0,
          CFRetain(v17),
          uint64_t v15 = FigXPCServerAssociateObjectWithConnectionWithFlags(),
          v15))
    {
      uint64_t v18 = v15;
      if (!a5) {
        goto LABEL_19;
      }
      goto LABEL_17;
    }
    if (a4)
    {
      *a4 = v21;
      CFTypeRef v21 = 0;
    }
    if (a5) {
      *a5 = cf;
    }
    uint64_t v18 = 0;
    if (a6)
    {
      *a6 = 0;
      if (!a5) {
        goto LABEL_19;
      }
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v18 = 4294954514;
  }
  if (!a5) {
    goto LABEL_19;
  }
LABEL_17:
  if (*a5) {
    CFRetain(*a5);
  }
LABEL_19:
  if (cf) {
    CFRelease(cf);
  }
  if (v21) {
    CFRelease(v21);
  }
  return v18;
}

uint64_t FigSampleCursorServer_obtainCacheOption(void *a1)
{
  BOOL v1 = xpc_dictionary_get_BOOL(a1, "UseSimpleCache");
  if (FigSampleCursorServer_shouldCacheMinimumUpcomingPTSInPartialSampleTable_shouldCacheMinimumUpcomingPTSInPartialSampleTableOnce != -1) {
    dispatch_once(&FigSampleCursorServer_shouldCacheMinimumUpcomingPTSInPartialSampleTable_shouldCacheMinimumUpcomingPTSInPartialSampleTableOnce, &__block_literal_global_115_0);
  }
  if (v1) {
    unsigned int v2 = 1;
  }
  else {
    unsigned int v2 = 2;
  }
  if (FigSampleCursorServer_shouldCacheMinimumUpcomingPTSInPartialSampleTable_shouldCacheMinimumUpcomingPTSInPartialSampleTable) {
    return v2 | 4;
  }
  else {
    return v2;
  }
}

uint64_t HandleTrackReaderCopyPropertyMessage(const void *a1)
{
  CFTypeID v1 = CFGetTypeID(a1);
  if (v1 != FigTrackReaderGetTypeID()) {
    return FigSignalErrorAt();
  }
  uint64_t result = FigXPCMessageCopyCFString();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleTrackReaderCopyMetadataReaderForTypeMessage(int a1, CFTypeRef cf)
{
  CFTypeID v2 = CFGetTypeID(cf);
  if (v2 != FigTrackReaderGetTypeID()) {
    return FigSignalErrorAt();
  }
  uint64_t result = FigXPCMessageCopyCFString();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleTrackReaderCopyMetadataReadersMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFArrayRef theArray = 0;
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != FigTrackReaderGetTypeID())
  {
    uint64_t v12 = FigSignalErrorAt();
LABEL_22:
    uint64_t v19 = v12;
    goto LABEL_16;
  }
  uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  CFTypeRef v11 = *(uint64_t (**)(uint64_t, __CFString *, void, CFArrayRef *))(v10 + 48);
  if (!v11)
  {
    uint64_t v19 = 4294954514;
    goto LABEL_16;
  }
  uint64_t v12 = v11(FigBaseObject, @"MetadataReaders", *MEMORY[0x1E4F1CF80], &theArray);
  if (v12) {
    goto LABEL_22;
  }
  if (!theArray) {
    goto LABEL_15;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (!Count) {
    goto LABEL_15;
  }
  uint64_t v14 = Count;
  xpc_object_t v15 = xpc_array_create(0, 0);
  if (v14 < 1)
  {
LABEL_13:
    xpc_dictionary_set_value(a4, "ObjectIDArray", v15);
LABEL_15:
    uint64_t v19 = 0;
    goto LABEL_16;
  }
  CFIndex v16 = 0;
  while (1)
  {
    CFArrayGetValueAtIndex(theArray, v16);
    CFTypeRef v17 = CFRetain(a3);
    uint64_t v18 = FigXPCServerAssociateObjectWithConnection();
    if (v18) {
      break;
    }
    xpc_array_set_uint64(v15, 0xFFFFFFFFFFFFFFFFLL, 0);
    if (v14 == ++v16) {
      goto LABEL_13;
    }
  }
  uint64_t v19 = v18;
  if (v17) {
    CFRelease(v17);
  }
LABEL_16:
  FigXPCRelease();
  if (theArray) {
    CFRelease(theArray);
  }
  return v19;
}

uint64_t HandleTrackReaderCreatePrimaryEditCursorServiceMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeRef cfa = 0;
  uint64_t value = 0;
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != FigTrackReaderGetTypeID())
  {
    uint64_t v12 = FigSignalErrorAt();
LABEL_14:
    uint64_t v14 = v12;
    goto LABEL_10;
  }
  uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  CFTypeRef v11 = *(uint64_t (**)(uint64_t, __CFString *, void, CFTypeRef *))(v10 + 48);
  if (!v11)
  {
    uint64_t v14 = 4294954514;
    goto LABEL_10;
  }
  uint64_t v12 = v11(FigBaseObject, @"EditCursorService", *MEMORY[0x1E4F1CF80], &cfa);
  if (v12) {
    goto LABEL_14;
  }
  CFTypeRef v13 = CFRetain(a3);
  uint64_t v14 = FigXPCServerAssociateObjectWithConnection();
  if (v14)
  {
    if (v13) {
      CFRelease(v13);
    }
  }
  else
  {
    xpc_dictionary_set_uint64(a4, (const char *)*MEMORY[0x1E4F20280], value);
  }
LABEL_10:
  if (cfa) {
    CFRelease(cfa);
  }
  return v14;
}

uint64_t HandleTrackReaderCreateSecondaryEditCursorServiceMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeRef cfa = 0;
  uint64_t value = 0;
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != FigTrackReaderGetTypeID())
  {
    uint64_t v12 = FigSignalErrorAt();
LABEL_14:
    uint64_t v14 = v12;
    goto LABEL_10;
  }
  uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  CFTypeRef v11 = *(uint64_t (**)(uint64_t, __CFString *, void, CFTypeRef *))(v10 + 48);
  if (!v11)
  {
    uint64_t v14 = 4294954514;
    goto LABEL_10;
  }
  uint64_t v12 = v11(FigBaseObject, @"SecondaryEditCursorService", *MEMORY[0x1E4F1CF80], &cfa);
  if (v12) {
    goto LABEL_14;
  }
  CFTypeRef v13 = CFRetain(a3);
  uint64_t v14 = FigXPCServerAssociateObjectWithConnection();
  if (v14)
  {
    if (v13) {
      CFRelease(v13);
    }
  }
  else
  {
    xpc_dictionary_set_uint64(a4, (const char *)*MEMORY[0x1E4F20280], value);
  }
LABEL_10:
  if (cfa) {
    CFRelease(cfa);
  }
  return v14;
}

uint64_t HandleTrackReaderCreateSampleCursorServiceMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeRef cfa = 0;
  uint64_t value = 0;
  CFTypeRef v24 = 0;
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != FigTrackReaderGetTypeID())
  {
    uint64_t v11 = FigSignalErrorAt();
LABEL_31:
    uint64_t v15 = v11;
    goto LABEL_25;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(v9 + 32);
  if (!v10)
  {
    uint64_t v15 = 4294954514;
    goto LABEL_25;
  }
  uint64_t v11 = v10(cf, &cfa);
  if (v11) {
    goto LABEL_31;
  }
  uint64_t v12 = CFRetain(a3);
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  CFIndex v16 = v12 + 36;
  CFTypeRef v17 = *(void (**)(CFTypeRef, void, unsigned char *))(v14 + 8);
  if (v17) {
    v17(cf, 0, v12 + 36);
  }
  if (*v16 == 1986618469)
  {
    v12[33] = 1;
  }
  else if (*v16 == 1936684398)
  {
    uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
    uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v19) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = 0;
    }
    CFTypeRef v21 = *(void (**)(uint64_t, __CFString *, void, CFTypeRef *))(v20 + 48);
    if (v21)
    {
      v21(FigBaseObject, @"HasAudioSampleDependencyInformation", *MEMORY[0x1E4F1CF80], &v24);
      CFTypeRef v22 = v24;
    }
    else
    {
      CFTypeRef v22 = 0;
    }
    v12[32] = v22 == (CFTypeRef)*MEMORY[0x1E4F1CFD0];
  }
  uint64_t v15 = FigXPCServerAssociateObjectWithConnection();
  if (v15) {
    CFRelease(v12);
  }
  else {
    xpc_dictionary_set_uint64(a4, (const char *)*MEMORY[0x1E4F20280], value);
  }
LABEL_25:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v24) {
    CFRelease(v24);
  }
  return v15;
}

uint64_t HandleTrackReaderCreateCaptionCursorServiceMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeRef cfa = 0;
  uint64_t value = 0;
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != FigTrackReaderGetTypeID())
  {
    uint64_t v12 = FigSignalErrorAt();
LABEL_14:
    uint64_t v14 = v12;
    goto LABEL_10;
  }
  uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, __CFString *, void, CFTypeRef *))(v10 + 48);
  if (!v11)
  {
    uint64_t v14 = 4294954514;
    goto LABEL_10;
  }
  uint64_t v12 = v11(FigBaseObject, @"CaptionSampleCursorService", *MEMORY[0x1E4F1CF80], &cfa);
  if (v12) {
    goto LABEL_14;
  }
  CFTypeRef v13 = CFRetain(a3);
  uint64_t v14 = FigXPCServerAssociateObjectWithConnection();
  if (v14)
  {
    if (v13) {
      CFRelease(v13);
    }
  }
  else
  {
    xpc_dictionary_set_uint64(a4, (const char *)*MEMORY[0x1E4F20280], value);
  }
LABEL_10:
  if (cfa) {
    CFRelease(cfa);
  }
  return v14;
}

uint64_t HandleEditCursorServiceCreateCursorAtTrackTimeMessage(int a1, CFTypeRef cf, const void *a3, uint64_t a4, void *a5)
{
  CFTypeRef cfa = 0;
  long long v17 = *MEMORY[0x1E4F1F9F8];
  uint64_t v18 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 != FigEditCursorServiceGetTypeID())
  {
    uint64_t v12 = FigSignalErrorAt();
LABEL_14:
    uint64_t v14 = v12;
    goto LABEL_10;
  }
  FigXPCMessageGetCMTime();
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(CFTypeRef, long long *, CFTypeRef *))(v10 + 8);
  if (!v11)
  {
    uint64_t v14 = 4294954514;
    goto LABEL_10;
  }
  long long v19 = v17;
  uint64_t v20 = v18;
  uint64_t v12 = v11(cf, &v19, &cfa);
  if (v12) {
    goto LABEL_14;
  }
  CFTypeRef v13 = CFRetain(a3);
  uint64_t v14 = FigXPCServerAssociateObjectWithConnection();
  if (v14)
  {
    if (v13) {
      CFRelease(v13);
    }
  }
  else
  {
    xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E4F20280], 0);
  }
LABEL_10:
  if (cfa) {
    CFRelease(cfa);
  }
  return v14;
}

uint64_t HandleEditCursorCopyPropertyMessage(const void *a1)
{
  CFTypeID v1 = CFGetTypeID(a1);
  if (v1 != FigEditCursorGetTypeID()) {
    return FigSignalErrorAt();
  }
  uint64_t result = FigXPCMessageCopyCFString();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleEditCursorCopyMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeRef cfa = 0;
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != FigEditCursorGetTypeID())
  {
    uint64_t v11 = FigSignalErrorAt();
LABEL_14:
    uint64_t v13 = v11;
    goto LABEL_10;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(v9 + 8);
  if (!v10)
  {
    uint64_t v13 = 4294954514;
    goto LABEL_10;
  }
  uint64_t v11 = v10(cf, &cfa);
  if (v11) {
    goto LABEL_14;
  }
  CFTypeRef v12 = CFRetain(a3);
  uint64_t v13 = FigXPCServerAssociateObjectWithConnection();
  if (v13)
  {
    if (v12) {
      CFRelease(v12);
    }
  }
  else
  {
    xpc_dictionary_set_uint64(a4, (const char *)*MEMORY[0x1E4F20280], 0);
  }
LABEL_10:
  if (cfa) {
    CFRelease(cfa);
  }
  return v13;
}

uint64_t HandleEditCursorStepMessage(const void *a1, void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == FigEditCursorGetTypeID())
  {
    int64_t int64 = xpc_dictionary_get_int64(a2, "EditCursorStepCount");
    uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v6) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v8 = *(uint64_t (**)(const void *, int64_t))(v7 + 16);
    if (v8)
    {
      return v8(a1, int64);
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t HandleEditCursorGetEditSegmentMessage(const void *a1)
{
  memset(v7, 0, sizeof(v7));
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == FigEditCursorGetTypeID())
  {
    uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v3) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = 0;
    }
    uint64_t v5 = *(uint64_t (**)(const void *, _OWORD *))(v4 + 24);
    if (v5)
    {
      uint64_t result = v5(a1, v7);
      if (!result) {
        return FigXPCMessageSetCMTimeMapping();
      }
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleSampleCursorServiceCreateCursorAtPresentationTimeStampMessage(uint64_t a1, CFTypeRef cf, void *a3, void *a4, void *a5)
{
  CFTypeRef v22 = 0;
  long long v23 = *MEMORY[0x1E4F1F9F8];
  uint64_t v24 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  CFTypeRef cfa = 0;
  uint64_t value = 0;
  __int16 v19 = 0;
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorServiceGetTypeID())
  {
    uint64_t CMTime = FigSignalErrorAt();
LABEL_18:
    uint64_t v17 = CMTime;
    goto LABEL_12;
  }
  uint64_t CMTime = FigXPCMessageGetCMTime();
  if (CMTime) {
    goto LABEL_18;
  }
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = *(uint64_t (**)(CFTypeRef, long long *, CFTypeRef *, char *, __int16 *))(v13 + 8);
  if (!v14)
  {
    uint64_t v17 = 4294954514;
    goto LABEL_12;
  }
  long long v25 = v23;
  uint64_t v26 = v24;
  uint64_t CMTime = v14(cf, &v25, &v22, (char *)&v19 + 1, &v19);
  if (CMTime) {
    goto LABEL_18;
  }
  CFAllocatorRef v15 = CFGetAllocator(cf);
  uint64_t CMTime = FigServedSampleCursorStateCreate((uint64_t)v15, a1, a3, (uint64_t *)&cfa);
  if (CMTime) {
    goto LABEL_18;
  }
  char v16 = FigSampleCursorServer_obtainCacheOption(a4);
  FigSampleCursorServer_SetSampleCursorProperties((uint64_t)cfa, v22, 1, v16, MEMORY[0x1E4F1FA20], 0, a5);
  uint64_t v17 = FigXPCServerAssociateObjectWithConnectionWithFlags();
  if (!v17)
  {
    CFTypeRef cfa = 0;
    xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E4F20280], value);
    xpc_dictionary_set_BOOL(a5, "SampleCursorCreatedBeforeStart", HIBYTE(v19) != 0);
    xpc_dictionary_set_BOOL(a5, "SampleCursorCreatedAfterEnd", (_BYTE)v19 != 0);
  }
LABEL_12:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v22) {
    CFRelease(v22);
  }
  return v17;
}

uint64_t HandleSampleCursorServiceCreateCursorNearPresentationTimeStampMessage(uint64_t a1, CFTypeRef cf, void *a3, void *a4, void *a5)
{
  CFTypeRef v23 = 0;
  long long v24 = *MEMORY[0x1E4F1F9F8];
  uint64_t v25 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  CFTypeRef cfa = 0;
  uint64_t value = 0;
  __int16 v20 = 0;
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorServiceGetTypeID())
  {
    uint64_t CMTime = FigSignalErrorAt();
LABEL_18:
    uint64_t v18 = CMTime;
    goto LABEL_12;
  }
  uint64_t CMTime = FigXPCMessageGetCMTime();
  if (CMTime) {
    goto LABEL_18;
  }
  BOOL v12 = xpc_dictionary_get_BOOL(a4, "SampleCursorAllowCreationAfterPTS");
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  CFAllocatorRef v15 = *(uint64_t (**)(CFTypeRef, long long *, BOOL, CFTypeRef *, char *, __int16 *))(v14 + 16);
  if (!v15)
  {
    uint64_t v18 = 4294954514;
    goto LABEL_12;
  }
  long long v26 = v24;
  uint64_t v27 = v25;
  uint64_t CMTime = v15(cf, &v26, v12, &v23, (char *)&v20 + 1, &v20);
  if (CMTime) {
    goto LABEL_18;
  }
  CFAllocatorRef v16 = CFGetAllocator(cf);
  uint64_t CMTime = FigServedSampleCursorStateCreate((uint64_t)v16, a1, a3, (uint64_t *)&cfa);
  if (CMTime) {
    goto LABEL_18;
  }
  char v17 = FigSampleCursorServer_obtainCacheOption(a4);
  FigSampleCursorServer_SetSampleCursorProperties((uint64_t)cfa, v23, 1, v17, MEMORY[0x1E4F1FA20], 0, a5);
  uint64_t v18 = FigXPCServerAssociateObjectWithConnectionWithFlags();
  if (!v18)
  {
    CFTypeRef cfa = 0;
    xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E4F20280], value);
    xpc_dictionary_set_BOOL(a5, "SampleCursorCreatedBeforeStart", HIBYTE(v20) != 0);
    xpc_dictionary_set_BOOL(a5, "SampleCursorCreatedAfterEnd", (_BYTE)v20 != 0);
  }
LABEL_12:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v23) {
    CFRelease(v23);
  }
  return v18;
}

uint64_t HandleSampleCursorServiceCreateCursorAtFirstSampleInDecodeOrderMessage(uint64_t a1, CFTypeRef cf, void *a3, void *a4, void *a5)
{
  uint64_t value = 0;
  CFTypeRef v21 = 0;
  CFTypeRef cfa = 0;
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorServiceGetTypeID())
  {
    uint64_t v14 = FigSignalErrorAt();
LABEL_17:
    uint64_t v17 = v14;
    goto LABEL_11;
  }
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(v12 + 24);
  if (!v13)
  {
    uint64_t v17 = 4294954514;
    goto LABEL_11;
  }
  uint64_t v14 = v13(cf, &v21);
  if (v14) {
    goto LABEL_17;
  }
  CFAllocatorRef v15 = CFGetAllocator(cf);
  uint64_t v14 = FigServedSampleCursorStateCreate((uint64_t)v15, a1, a3, (uint64_t *)&cfa);
  if (v14) {
    goto LABEL_17;
  }
  char v16 = FigSampleCursorServer_obtainCacheOption(a4);
  FigSampleCursorServer_SetSampleCursorProperties((uint64_t)cfa, v21, 1, v16, MEMORY[0x1E4F1FA20], 0, a5);
  uint64_t v17 = FigXPCServerAssociateObjectWithConnectionWithFlags();
  if (!v17)
  {
    CFTypeRef cfa = 0;
    xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E4F20280], value);
  }
LABEL_11:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v21) {
    CFRelease(v21);
  }
  return v17;
}

uint64_t HandleSampleCursorServiceCreateCursorAtLastSampleInDecodeOrderMessage(uint64_t a1, CFTypeRef cf, void *a3, void *a4, void *a5)
{
  uint64_t value = 0;
  CFTypeRef v21 = 0;
  CFTypeRef cfa = 0;
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorServiceGetTypeID())
  {
    uint64_t v14 = FigSignalErrorAt();
LABEL_17:
    uint64_t v17 = v14;
    goto LABEL_11;
  }
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(v12 + 32);
  if (!v13)
  {
    uint64_t v17 = 4294954514;
    goto LABEL_11;
  }
  uint64_t v14 = v13(cf, &v21);
  if (v14) {
    goto LABEL_17;
  }
  CFAllocatorRef v15 = CFGetAllocator(cf);
  uint64_t v14 = FigServedSampleCursorStateCreate((uint64_t)v15, a1, a3, (uint64_t *)&cfa);
  if (v14) {
    goto LABEL_17;
  }
  char v16 = FigSampleCursorServer_obtainCacheOption(a4);
  FigSampleCursorServer_SetSampleCursorProperties((uint64_t)cfa, v21, 1, v16, MEMORY[0x1E4F1FA20], 0, a5);
  uint64_t v17 = FigXPCServerAssociateObjectWithConnectionWithFlags();
  if (!v17)
  {
    CFTypeRef cfa = 0;
    xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E4F20280], value);
  }
LABEL_11:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v21) {
    CFRelease(v21);
  }
  return v17;
}

uint64_t HandleMetadataReaderCopyPropertyMessage(const void *a1)
{
  CFTypeID v1 = CFGetTypeID(a1);
  if (v1 != FigMetadataReaderGetTypeID()) {
    return FigSignalErrorAt();
  }
  uint64_t result = FigXPCMessageCopyCFString();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleMetadataReaderCopyValueMessage(const void *a1, void *a2, void *a3)
{
  CFTypeRef v27 = 0;
  CFTypeRef cf = 0;
  CFDataRef theData = 0;
  CFTypeRef v26 = 0;
  CFTypeRef v24 = 0;
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != FigMetadataReaderGetTypeID())
  {
    uint64_t v7 = FigSignalErrorAt();
LABEL_36:
    MetadataPropertiesBinaryPListDatCGFloat a = v7;
    goto LABEL_24;
  }
  uint64_t v7 = FigXPCMessageCopyCFString();
  if (v7) {
    goto LABEL_36;
  }
  uint64_t v7 = FigXPCMessageCopyCFObject();
  if (v7) {
    goto LABEL_36;
  }
  BOOL v8 = xpc_dictionary_get_BOOL(a2, "MetadataPropertiesDesired");
  BOOL v9 = xpc_dictionary_get_BOOL(a2, "MetadataValueDesired");
  uint64_t uint64 = xpc_dictionary_get_uint64(a2, "MetadataValueType");
  CFTypeRef v12 = v27;
  CFTypeRef v11 = cf;
  if (v9) {
    uint64_t v13 = &v24;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v8) {
    uint64_t v14 = &v26;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v15) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *(uint64_t (**)(const void *, CFTypeRef, CFTypeRef, uint64_t, void, CFTypeRef *, CFTypeRef *))(v16 + 8);
  if (!v17)
  {
    MetadataPropertiesBinaryPListDatCGFloat a = 4294954514;
    goto LABEL_24;
  }
  CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v7 = v17(a1, v11, v12, uint64, *MEMORY[0x1E4F1CF80], v13, v14);
  if (v7) {
    goto LABEL_36;
  }
  if (v24)
  {
    MetadataPropertiesBinaryPListDatCGFloat a = FigXPCMessageSetCFObject();
    if (MetadataPropertiesBinaryPListData) {
      goto LABEL_24;
    }
    __int16 v20 = (void *)v26;
    if (!v26) {
      goto LABEL_24;
    }
  }
  else
  {
    __int16 v20 = (void *)v26;
    if (!v26)
    {
      MetadataPropertiesBinaryPListDatCGFloat a = 0;
      goto LABEL_24;
    }
  }
  MetadataPropertiesBinaryPListDatCGFloat a = FigRemote_CreateMetadataPropertiesBinaryPListData(v20, v18, (uint64_t)&theData);
  if (!MetadataPropertiesBinaryPListData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    size_t Length = CFDataGetLength(theData);
    xpc_dictionary_set_data(a3, "MetadataProperties", BytePtr, Length);
  }
LABEL_24:
  if (cf) {
    CFRelease(cf);
  }
  if (v27) {
    CFRelease(v27);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (theData) {
    CFRelease(theData);
  }
  return MetadataPropertiesBinaryPListData;
}

uint64_t HandleMetadataReaderGetItemCountMessage(const void *a1, uint64_t a2, void *a3)
{
  CFTypeID v5 = CFGetTypeID(a1);
  if (v5 != FigMetadataReaderGetTypeID()) {
    return FigSignalErrorAt();
  }
  uint64_t v6 = FigXPCMessageCopyCFString();
  if (v6) {
    return v6;
  }
  uint64_t v6 = FigXPCMessageCopyCFObject();
  if (v6) {
    return v6;
  }
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  BOOL v9 = *(uint64_t (**)(const void *, void, void))(v8 + 40);
  if (v9) {
    int64_t v10 = v9(a1, 0, 0);
  }
  else {
    int64_t v10 = 0;
  }
  xpc_dictionary_set_int64(a3, "MetadataItemCount", v10);
  return 0;
}

uint64_t HandleMetadataReaderCopyItemWithKeyAndIndexMessage(const void *a1, void *a2, void *a3)
{
  CFTypeRef v27 = 0;
  CFTypeRef cf = 0;
  CFDataRef theData = 0;
  CFTypeRef v26 = 0;
  CFTypeRef v24 = 0;
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != FigMetadataReaderGetTypeID())
  {
    uint64_t v7 = FigSignalErrorAt();
LABEL_36:
    MetadataPropertiesBinaryPListDatCGFloat a = v7;
    goto LABEL_24;
  }
  uint64_t v7 = FigXPCMessageCopyCFString();
  if (v7) {
    goto LABEL_36;
  }
  uint64_t v7 = FigXPCMessageCopyCFObject();
  if (v7) {
    goto LABEL_36;
  }
  BOOL v8 = xpc_dictionary_get_BOOL(a2, "MetadataPropertiesDesired");
  BOOL v9 = xpc_dictionary_get_BOOL(a2, "MetadataValueDesired");
  int64_t int64 = xpc_dictionary_get_int64(a2, "MetadataItemIndex");
  CFTypeRef v12 = v27;
  CFTypeRef v11 = cf;
  if (v9) {
    uint64_t v13 = &v24;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v8) {
    uint64_t v14 = &v26;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v15) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *(uint64_t (**)(const void *, CFTypeRef, CFTypeRef, int64_t, void, CFTypeRef *, CFTypeRef *))(v16 + 48);
  if (!v17)
  {
    MetadataPropertiesBinaryPListDatCGFloat a = 4294954514;
    goto LABEL_24;
  }
  CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v7 = v17(a1, v11, v12, int64, *MEMORY[0x1E4F1CF80], v13, v14);
  if (v7) {
    goto LABEL_36;
  }
  if (v24)
  {
    MetadataPropertiesBinaryPListDatCGFloat a = FigXPCMessageSetCFObject();
    if (MetadataPropertiesBinaryPListData) {
      goto LABEL_24;
    }
    __int16 v20 = (void *)v26;
    if (!v26) {
      goto LABEL_24;
    }
  }
  else
  {
    __int16 v20 = (void *)v26;
    if (!v26)
    {
      MetadataPropertiesBinaryPListDatCGFloat a = 0;
      goto LABEL_24;
    }
  }
  MetadataPropertiesBinaryPListDatCGFloat a = FigRemote_CreateMetadataPropertiesBinaryPListData(v20, v18, (uint64_t)&theData);
  if (!MetadataPropertiesBinaryPListData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    size_t Length = CFDataGetLength(theData);
    xpc_dictionary_set_data(a3, "MetadataProperties", BytePtr, Length);
  }
LABEL_24:
  if (cf) {
    CFRelease(cf);
  }
  if (v27) {
    CFRelease(v27);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (theData) {
    CFRelease(theData);
  }
  return MetadataPropertiesBinaryPListData;
}

uint64_t EventLinkServerMessageHandler(uint64_t a1, uint64_t a2, OpaqueCMBlockBuffer *a3, OpaqueCMBlockBuffer *a4)
{
  FigOSEventLinkServerGetAssociatedFigXPCServerXPCConnection();
  size_t lengthAtOffsetOut = 0;
  long long dataPointerOut = 0;
  uint64_t DataPointer = CMBlockBufferGetDataPointer(a3, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if (!DataPointer)
  {
    uint64_t DataPointer = 4294949526;
    if ((dataPointerOut & 7) == 0 && lengthAtOffsetOut > 0x197)
    {
      size_t lengthAtOffsetOut = 0;
      long long dataPointerOut = 0;
      uint64_t DataPointer = CMBlockBufferGetDataPointer(a4, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
      if (!DataPointer)
      {
        BOOL v8 = dataPointerOut;
        uint64_t DataPointer = 4294949526;
        if ((dataPointerOut & 7) == 0 && lengthAtOffsetOut > 0x197)
        {
          *((void *)dataPointerOut + 50) = 0;
          *((_OWORD *)v8 + 23) = 0u;
          *((_OWORD *)v8 + 24) = 0u;
          *((_OWORD *)v8 + 21) = 0u;
          *((_OWORD *)v8 + 22) = 0u;
          *((_OWORD *)v8 + 19) = 0u;
          *((_OWORD *)v8 + 20) = 0u;
          *((_OWORD *)v8 + 17) = 0u;
          *((_OWORD *)v8 + 18) = 0u;
          *((_OWORD *)v8 + 15) = 0u;
          *((_OWORD *)v8 + 16) = 0u;
          *((_OWORD *)v8 + 13) = 0u;
          *((_OWORD *)v8 + 14) = 0u;
          *((_OWORD *)v8 + 11) = 0u;
          *((_OWORD *)v8 + 12) = 0u;
          *((_OWORD *)v8 + 9) = 0u;
          *((_OWORD *)v8 + 10) = 0u;
          *((_OWORD *)v8 + 7) = 0u;
          *((_OWORD *)v8 + 8) = 0u;
          *((_OWORD *)v8 + 5) = 0u;
          *((_OWORD *)v8 + 6) = 0u;
          *((_OWORD *)v8 + 3) = 0u;
          *((_OWORD *)v8 + 4) = 0u;
          *((_OWORD *)v8 + 1) = 0u;
          *((_OWORD *)v8 + 2) = 0u;
          *(_OWORD *)BOOL v8 = 0u;
          FigOSEventLinkServerGetAssociatedFigXPCServerXPCConnection();
          return FigXPCServerLookupAndRetainAssociatedObjectAndCFTypeRefcon();
        }
      }
    }
  }
  return DataPointer;
}

uint64_t HandleSampleCursorCopyPropertyFromEventLink(const void *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID()) {
    return FigSignalErrorAt();
  }
  if (!*(void *)(a3 + 336)) {
    return FigSignalErrorAt();
  }
  uint64_t result = FigInMemoryDeserializerCopyCFString();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleSampleCursorSetPropertyFromEventLink(const void *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID()) {
    return FigSignalErrorAt();
  }
  if (!*(void *)(a3 + 336)) {
    return FigSignalErrorAt();
  }
  uint64_t result = FigInMemoryDeserializerCopyCFString();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleSampleCursorCopyFromEventLink(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4)
{
  CFTypeRef cfa = 0;
  uint64_t v13 = 0;
  CFTypeRef v11 = 0;
  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 == FigSampleCursorGetTypeID())
  {
    uint64_t v9 = CopySampleCursorAndReturnObjectID(a1, cf, a3, &v11, &cfa, &v13);
    if (!v9) {
      *(void *)(a4 + 336) = v13;
    }
  }
  else
  {
    uint64_t v9 = FigSignalErrorAt();
  }
  if (cfa) {
    CFRelease(cfa);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v9;
}

uint64_t HandleSampleCursorGetSampleTimingInfoFromEventLink(const void *a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 48);
  long long v21 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 32);
  long long v22 = v4;
  uint64_t v23 = *(void *)(MEMORY[0x1E4F1FA70] + 64);
  long long v5 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 16);
  long long v19 = *MEMORY[0x1E4F1FA70];
  long long v20 = v5;
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == FigSampleCursorGetTypeID())
  {
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(uint64_t (**)(const void *, char *))(v8 + 40);
    if (!v9) {
      return 4294954514;
    }
    uint64_t result = v9(a1, (char *)&v20 + 8);
    if (result) {
      return result;
    }
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v12 = v11 ? v11 : 0;
    uint64_t v13 = *(uint64_t (**)(const void *, long long *))(v12 + 48);
    if (!v13) {
      return 4294954514;
    }
    uint64_t result = v13(a1, &v22);
    if (result) {
      return result;
    }
    uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v15 = v14 ? v14 : 0;
    uint64_t v16 = *(uint64_t (**)(const void *, long long *))(v15 + 56);
    if (v16)
    {
      uint64_t result = v16(a1, &v19);
      if (!result)
      {
        long long v17 = v22;
        *(_OWORD *)(a2 + 368) = v21;
        *(_OWORD *)(a2 + 384) = v17;
        *(void *)(a2 + 400) = v23;
        long long v18 = v20;
        *(_OWORD *)(a2 + 336) = v19;
        *(_OWORD *)(a2 + 352) = v18;
      }
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleSampleCursorGetSampleSyncInfoFromEventLink(const void *a1, uint64_t a2)
{
  uint64_t v9 = 0;
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == FigSampleCursorGetTypeID())
  {
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(uint64_t (**)(const void *, char *, char *, uint64_t *, char *))(v6 + 64);
    if (v7)
    {
      uint64_t result = v7(a1, (char *)&v9 + 4, (char *)&v9 + 5, &v9, (char *)&v9 + 6);
      if (!result || result == -12840) {
        *(void *)(a2 + 336) = v9;
      }
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleSampleCursorStepByDecodeTimeFromEventLink(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeRef v21 = a3;
  CFTypeRef cfa = cf;
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorGetTypeID())
  {
    uint64_t v11 = FigSignalErrorAt();
    goto LABEL_17;
  }
  uint64_t v11 = FigSampleCursorServer_ResolveCopiedCursorObjectIDForEventLinkReplyAndCopyCursorToUse(a1, &cfa, (uint64_t *)&v21, a4, a5);
  if (v11)
  {
LABEL_17:
    uint64_t v17 = v11;
    goto LABEL_11;
  }
  CFTypeRef v12 = cfa;
  long long v19 = *(_OWORD *)(a4 + 336);
  uint64_t v20 = *(void *)(a4 + 352);
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(uint64_t (**)(CFTypeRef, long long *))(v14 + 120);
  if (v15)
  {
    long long v23 = v19;
    uint64_t v24 = v20;
    uint64_t v16 = v15(v12, &v23);
    uint64_t v17 = v16;
    if (!v16 || v16 == -12840)
    {
      *(unsigned char *)(a5 + 336) = v16 == -12840;
      FigSampleCursorServer_SetSampleCursorPropertiesFromEventLink((uint64_t)v21, a6, cfa, a5);
      uint64_t v17 = 0;
    }
  }
  else
  {
    uint64_t v17 = 4294954514;
  }
LABEL_11:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v21) {
    CFRelease(v21);
  }
  return v17;
}

uint64_t HandleSampleCursorStepByPresentationTimeFromEventLink(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeRef v21 = a3;
  CFTypeRef cfa = cf;
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorGetTypeID())
  {
    uint64_t v11 = FigSignalErrorAt();
    goto LABEL_17;
  }
  uint64_t v11 = FigSampleCursorServer_ResolveCopiedCursorObjectIDForEventLinkReplyAndCopyCursorToUse(a1, &cfa, (uint64_t *)&v21, a4, a5);
  if (v11)
  {
LABEL_17:
    uint64_t v17 = v11;
    goto LABEL_11;
  }
  CFTypeRef v12 = cfa;
  long long v19 = *(_OWORD *)(a4 + 336);
  uint64_t v20 = *(void *)(a4 + 352);
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(uint64_t (**)(CFTypeRef, long long *))(v14 + 128);
  if (v15)
  {
    long long v23 = v19;
    uint64_t v24 = v20;
    uint64_t v16 = v15(v12, &v23);
    uint64_t v17 = v16;
    if (!v16 || v16 == -12840)
    {
      *(unsigned char *)(a5 + 336) = v16 == -12840;
      FigSampleCursorServer_SetSampleCursorPropertiesFromEventLink((uint64_t)v21, a6, cfa, a5);
      uint64_t v17 = 0;
    }
  }
  else
  {
    uint64_t v17 = 4294954514;
  }
LABEL_11:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v21) {
    CFRelease(v21);
  }
  return v17;
}

uint64_t HandleSampleCursorStepInDecodeOrderAndReportStepsTakenFromEventLink(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeRef v20 = a3;
  CFTypeRef cfa = cf;
  uint64_t v19 = 0;
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorGetTypeID())
  {
    uint64_t v11 = FigSignalErrorAt();
    goto LABEL_16;
  }
  uint64_t v11 = FigSampleCursorServer_ResolveCopiedCursorObjectIDForEventLinkReplyAndCopyCursorToUse(a1, &cfa, (uint64_t *)&v20, a4, a5);
  if (v11)
  {
LABEL_16:
    uint64_t v17 = v11;
    goto LABEL_10;
  }
  uint64_t v12 = *(void *)(a4 + 336);
  CFTypeRef v13 = cfa;
  uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t *))(v15 + 168);
  if (v16)
  {
    uint64_t v17 = v16(v13, v12, &v19);
    if (!v17) {
      FigSampleCursorServer_SetSampleCursorPropertiesFromEventLink((uint64_t)v20, a6, cfa, a5);
    }
  }
  else
  {
    uint64_t v17 = 4294954514;
  }
LABEL_10:
  *(void *)(a5 + 336) = v19;
  if (cfa) {
    CFRelease(cfa);
  }
  if (v20) {
    CFRelease(v20);
  }
  return v17;
}

uint64_t HandleSampleCursorStepInPresentationOrderAndReportStepsTakenFromEventLink(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeRef v20 = a3;
  CFTypeRef cfa = cf;
  uint64_t v19 = 0;
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorGetTypeID())
  {
    uint64_t v11 = FigSignalErrorAt();
    goto LABEL_16;
  }
  uint64_t v11 = FigSampleCursorServer_ResolveCopiedCursorObjectIDForEventLinkReplyAndCopyCursorToUse(a1, &cfa, (uint64_t *)&v20, a4, a5);
  if (v11)
  {
LABEL_16:
    uint64_t v17 = v11;
    goto LABEL_10;
  }
  uint64_t v12 = *(void *)(a4 + 336);
  CFTypeRef v13 = cfa;
  uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t *))(v15 + 176);
  if (v16)
  {
    uint64_t v17 = v16(v13, v12, &v19);
    if (!v17) {
      FigSampleCursorServer_SetSampleCursorPropertiesFromEventLink((uint64_t)v20, a6, cfa, a5);
    }
  }
  else
  {
    uint64_t v17 = 4294954514;
  }
LABEL_10:
  *(void *)(a5 + 336) = v19;
  if (cfa) {
    CFRelease(cfa);
  }
  if (v20) {
    CFRelease(v20);
  }
  return v17;
}

uint64_t HandleSampleCursorCompareInDecodeOrderFromEventLink(const void *a1, const void *a2, uint64_t a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == FigSampleCursorGetTypeID() && a2 && (CFTypeID v8 = CFGetTypeID(a2), v8 == FigSampleCursorGetTypeID()))
  {
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    if (v10 == *(void *)(CMBaseObjectGetVTable() + 16)
      && (uint64_t v12 = *(uint64_t (**)(const void *, const void *))(v10 + 32)) != 0)
    {
      uint64_t v11 = v12(a1, a2);
    }
    else
    {
      uint64_t v11 = 0;
    }
    *(void *)(a3 + 336) = v11;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t HandleSampleCursorTestReorderingBoundaryFromEventLink(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 == FigSampleCursorGetTypeID() && a2 && (CFTypeID v10 = CFGetTypeID(a2), v10 == FigSampleCursorGetTypeID()))
  {
    uint64_t v11 = *(unsigned int *)(a3 + 336);
    uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v12) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    if (v13 == *(void *)(CMBaseObjectGetVTable() + 16)
      && (uint64_t v15 = *(uint64_t (**)(const void *, const void *, uint64_t))(v13 + 80)) != 0)
    {
      char v14 = v15(a1, a2, v11);
    }
    else
    {
      char v14 = 0;
    }
    *(unsigned char *)(a4 + 336) = v14;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t HandleSampleCursorCopySampleLocationFromEventLink(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef cf = 0;
  CFTypeRef v17 = 0;
  long long v15 = 0uLL;
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
  {
    uint64_t v12 = FigSignalErrorAt();
LABEL_10:
    uint64_t v13 = v12;
    goto LABEL_12;
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(const void *, long long *, char *, CFTypeRef *, CFTypeRef *))(v10 + 144);
  if (v11)
  {
    uint64_t v12 = v11(a1, &v15, (char *)&v15 + 8, &v17, &cf);
    if (!v12)
    {
      *(_OWORD *)(a3 + 24) = 0u;
      *(_OWORD *)(a3 + 296) = 0u;
      *(_OWORD *)(a3 + 312) = 0u;
      *(_OWORD *)(a3 + 264) = 0u;
      *(_OWORD *)(a3 + 280) = 0u;
      *(_OWORD *)(a3 + 232) = 0u;
      *(_OWORD *)(a3 + 248) = 0u;
      *(_OWORD *)(a3 + 200) = 0u;
      *(_OWORD *)(a3 + 216) = 0u;
      *(_OWORD *)(a3 + 168) = 0u;
      *(_OWORD *)(a3 + 184) = 0u;
      *(_OWORD *)(a3 + 136) = 0u;
      *(_OWORD *)(a3 + 152) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
      *(_OWORD *)(a3 + 120) = 0u;
      *(_OWORD *)(a3 + 72) = 0u;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 40) = 0u;
      *(_OWORD *)(a3 + 56) = 0u;
      *(void *)(a3 + 368) = 0;
      *(_OWORD *)(a3 + 352) = 0u;
      *(_OWORD *)(a3 + 336) = v15;
      if (!v17
        || (uint64_t v12 = FigSampleCursorServer_TranslateByteStream(v12, (uint64_t)v17, (void *)(a3 + 352)), !v12))
      {
        uint64_t v12 = FigSampleCursorServer_TranslateDataSourceFromEventLink(a2, *(void *)(a2 + 48), cf, a3, 0, a4, (void *)(a3 + 360), (void *)(a3 + 368));
      }
    }
    goto LABEL_10;
  }
  uint64_t v13 = 4294954514;
LABEL_12:
  if (cf) {
    CFRelease(cf);
  }
  if (v17) {
    CFRelease(v17);
  }
  return v13;
}

uint64_t HandleSampleCursorCopyChunkDetailsFromEventLink(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v18 = 0;
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
  {
    uint64_t v12 = FigSignalErrorAt();
LABEL_10:
    uint64_t v13 = v12;
    goto LABEL_12;
  }
  long long v16 = 0uLL;
  long long v15 = 0uLL;
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(const void *, CFTypeRef *, CFTypeRef *, long long *, char *, long long *, uint64_t *, char *, char *, char *))(v10 + 152);
  if (v11)
  {
    uint64_t v12 = v11(a1, &v18, &cf, &v16, (char *)&v16 + 8, &v15, &v19, (char *)&v15 + 8, (char *)&v15 + 9, (char *)&v15 + 10);
    if (!v12)
    {
      *(_OWORD *)(a3 + 24) = 0u;
      *(_OWORD *)(a3 + 296) = 0u;
      *(_OWORD *)(a3 + 312) = 0u;
      *(_OWORD *)(a3 + 264) = 0u;
      *(_OWORD *)(a3 + 280) = 0u;
      *(_OWORD *)(a3 + 232) = 0u;
      *(_OWORD *)(a3 + 248) = 0u;
      *(_OWORD *)(a3 + 200) = 0u;
      *(_OWORD *)(a3 + 216) = 0u;
      *(_OWORD *)(a3 + 168) = 0u;
      *(_OWORD *)(a3 + 184) = 0u;
      *(_OWORD *)(a3 + 136) = 0u;
      *(_OWORD *)(a3 + 152) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
      *(_OWORD *)(a3 + 120) = 0u;
      *(_OWORD *)(a3 + 72) = 0u;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 40) = 0u;
      *(_OWORD *)(a3 + 56) = 0u;
      *(_OWORD *)(a3 + 368) = 0u;
      *(_OWORD *)(a3 + 384) = 0u;
      *(_OWORD *)(a3 + 336) = v16;
      *(_OWORD *)(a3 + 352) = v15;
      *(void *)(a3 + 368) = v19;
      if (!v18
        || (uint64_t v12 = FigSampleCursorServer_TranslateByteStream(v12, (uint64_t)v18, (void *)(a3 + 376)), !v12))
      {
        uint64_t v12 = FigSampleCursorServer_TranslateDataSourceFromEventLink(a2, *(void *)(a2 + 48), cf, a3, 0, a4, (void *)(a3 + 384), (void *)(a3 + 392));
      }
    }
    goto LABEL_10;
  }
  uint64_t v13 = 4294954514;
LABEL_12:
  if (cf) {
    CFRelease(cf);
  }
  if (v18) {
    CFRelease(v18);
  }
  return v13;
}

uint64_t HandleSampleCursorCopyFormatDescriptionFromEventLink(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef cf = 0;
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
  {
    uint64_t v12 = FigSignalErrorAt();
LABEL_8:
    uint64_t v13 = v12;
    goto LABEL_10;
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(const void *, CFTypeRef *))(v10 + 160);
  if (v11)
  {
    uint64_t v12 = v11(a1, &cf);
    if (!v12)
    {
      *(_OWORD *)(a3 + 248) = 0u;
      *(_OWORD *)(a3 + 232) = 0u;
      *(_OWORD *)(a3 + 216) = 0u;
      *(_OWORD *)(a3 + 200) = 0u;
      *(_OWORD *)(a3 + 184) = 0u;
      *(_OWORD *)(a3 + 168) = 0u;
      *(_OWORD *)(a3 + 152) = 0u;
      *(_OWORD *)(a3 + 136) = 0u;
      *(_OWORD *)(a3 + 120) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 72) = 0u;
      *(_OWORD *)(a3 + 56) = 0u;
      *(_OWORD *)(a3 + 40) = 0u;
      *(_OWORD *)(a3 + 24) = 0u;
      *(_OWORD *)(a3 + 296) = 0u;
      *(_OWORD *)(a3 + 312) = 0u;
      *(_OWORD *)(a3 + 264) = 0u;
      *(_OWORD *)(a3 + 280) = 0u;
      *(void *)(a3 + 336) = 0;
      *(void *)(a3 + 344) = 0;
      uint64_t v12 = FigSampleCursorServer_TranslateFormatDescriptionFromEventLink(a2, *(void *)(a2 + 48), cf, a3, a4, (void *)(a3 + 336), (void *)(a3 + 344));
    }
    goto LABEL_8;
  }
  uint64_t v13 = 4294954514;
LABEL_10:
  if (cf) {
    CFRelease(cf);
  }
  return v13;
}

uint64_t HandleSampleCursorCreateSampleBufferFromEventLink(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef v15 = 0;
  CFTypeID v7 = CFGetTypeID(a1);
  if (v7 == FigSampleCursorGetTypeID())
  {
    uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v8) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v10 = *(uint64_t (**)(const void *, uint64_t, CFTypeRef *))(v9 + 112);
    if (!v10)
    {
      uint64_t appended = 4294954514;
      goto LABEL_9;
    }
    uint64_t v11 = v10(a1, a2, &v15);
    if (!v11)
    {
      *(_OWORD *)(a4 + 24) = 0u;
      uint64_t v12 = a4 + 24;
      *(_OWORD *)(v12 + 272) = 0u;
      *(_OWORD *)(v12 + 288) = 0u;
      *(_OWORD *)(v12 + 240) = 0u;
      *(_OWORD *)(v12 + 256) = 0u;
      *(_OWORD *)(v12 + 208) = 0u;
      *(_OWORD *)(v12 + 224) = 0u;
      *(_OWORD *)(v12 + 176) = 0u;
      *(_OWORD *)(v12 + 192) = 0u;
      *(_OWORD *)(v12 + 144) = 0u;
      *(_OWORD *)(v12 + 160) = 0u;
      *(_OWORD *)(v12 + 112) = 0u;
      *(_OWORD *)(v12 + 128) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      *(_OWORD *)(v12 + 48) = 0u;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 16) = 0u;
      *(_OWORD *)(v12 + 32) = 0u;
      *(void *)(v12 + 312) = 0;
      uint64_t appended = FigInMemorySerializerAppendCMSampleBuffer();
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = FigSignalErrorAt();
  }
  uint64_t appended = v11;
LABEL_9:
  if (v15) {
    CFRelease(v15);
  }
  return appended;
}

uint64_t HandleSampleCursorGetBatchSampleTimingAndSizesFromEventLink(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFTypeID v9 = CFGetTypeID(a1);
  if (v9 == FigSampleCursorGetTypeID())
  {
    unint64_t v10 = *(void *)(a4 + 336);
    *(void *)(a5 + 368) = 0;
    *(_OWORD *)(a5 + 336) = 0u;
    *(_OWORD *)(a5 + 352) = 0u;
    uint64_t v11 = (unint64_t *)(a5 + 352);
    uint64_t v12 = (unint64_t *)(a5 + 360);
    if (*(unsigned char *)(a4 + 344)) {
      uint64_t v13 = (uint64_t *)(a5 + 360);
    }
    else {
      uint64_t v13 = 0;
    }
    if (*(unsigned char *)(a4 + 345)) {
      char v14 = (uint64_t *)(a5 + 352);
    }
    else {
      char v14 = 0;
    }
    uint64_t BatchSampleTimingAndSizes = FigSampleCursorUtilityGetBatchSampleTimingAndSizes((uint64_t)a1, v10, a2, 0, v13, 0, v14, 0);
    if (BatchSampleTimingAndSizes) {
      return BatchSampleTimingAndSizes;
    }
    unint64_t v16 = *v12;
    if (*v12 <= v10)
    {
      unint64_t v17 = *v11;
      if (*v11 <= v10)
      {
        CFTypeRef v18 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
        if (!v17)
        {
          MutableBytePtr = 0;
          CFTypeRef v20 = 0;
          if (v16) {
            goto LABEL_14;
          }
          goto LABEL_17;
        }
        CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 8 * v17);
        if (Mutable)
        {
          CFTypeRef v20 = Mutable;
          CFDataSetLength(Mutable, 8 * *v11);
          MutableBytePtr = CFDataGetMutableBytePtr(v20);
          unint64_t v16 = *v12;
          if (*v12)
          {
LABEL_14:
            long long v22 = CFDataCreateMutable(*v18, 72 * v16);
            long long v23 = v22;
            if (!v22)
            {
              uint64_t v27 = FigSignalErrorAt();
              goto LABEL_31;
            }
            CFDataSetLength(v22, 72 * *v12);
            uint64_t v24 = CFDataGetMutableBytePtr(v23);
LABEL_18:
            if (*(unsigned char *)(a4 + 344)) {
              uint64_t v25 = (uint64_t *)(a5 + 360);
            }
            else {
              uint64_t v25 = 0;
            }
            if (*(unsigned char *)(a4 + 345)) {
              CFTypeRef v26 = (uint64_t *)(a5 + 352);
            }
            else {
              CFTypeRef v26 = 0;
            }
            uint64_t v27 = FigSampleCursorUtilityGetBatchSampleTimingAndSizes((uint64_t)a1, v10, a2, (uint64_t *)(a5 + 368), v25, (uint64_t)v24, v26, (uint64_t)MutableBytePtr);
            if (!v27)
            {
              if (v20)
              {
                uint64_t appended = FigInMemorySerializerAppendCFType();
                uint64_t v29 = appended;
                if (!v23 || appended)
                {
LABEL_32:
                  CFRelease(v20);
LABEL_33:
                  if (v23) {
                    CFRelease(v23);
                  }
                  return v29;
                }
                goto LABEL_30;
              }
              if (v23)
              {
LABEL_30:
                uint64_t v27 = FigInMemorySerializerAppendCFType();
                goto LABEL_31;
              }
              return 0;
            }
LABEL_31:
            uint64_t v29 = v27;
            if (!v20) {
              goto LABEL_33;
            }
            goto LABEL_32;
          }
LABEL_17:
          uint64_t v24 = 0;
          long long v23 = 0;
          goto LABEL_18;
        }
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t FigSampleCursorServer_TranslateSampleDependencyAttributesFromEventLink(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8)
{
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  char v11 = 0;
  uint64_t result = FigPartialSampleTableOutOfBandObjectRegistryLookupOrMakeIDForObjectOfType(*(void *)(a1 + 24), @"SampleDependencyAttributes", a3, &v13, &v11);
  if (!result)
  {
    if (v11)
    {
      uint64_t result = FigInMemorySerializerAppendCFType();
      if (result) {
        return result;
      }
      if (!a7) {
        goto LABEL_6;
      }
    }
    else
    {
      uint64_t v12 = 0;
      if (!a7)
      {
LABEL_6:
        uint64_t result = 0;
        if (a8) {
          *a8 = v12;
        }
        return result;
      }
    }
    *a7 = v13;
    goto LABEL_6;
  }
  return result;
}

uint64_t FigSampleCursorServer_ResolveCopiedCursorObjectIDForEventLinkReplyAndCopyCursorToUse(uint64_t a1, const void **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  CFTypeRef v11 = 0;
  CFTypeRef cf = 0;
  uint64_t v10 = 0;
  if (*(unsigned char *)(a4 + 328))
  {
    uint64_t v8 = CopySampleCursorAndReturnObjectID(a1, *a2, *a3, &cf, &v11, &v10);
    if (!v8)
    {
      *a2 = cf;
      *a3 = (uint64_t)v11;
      *(void *)(a5 + 328) = v10;
    }
  }
  else
  {
    uint64_t v8 = 0;
    *(void *)(a5 + 328) = 0;
    if (!a2) {
      goto LABEL_7;
    }
  }
  if (*a2) {
    CFRetain(*a2);
  }
LABEL_7:
  if (a3 && *a3) {
    CFRetain((CFTypeRef)*a3);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v8;
}

void FigSampleCursorServer_SetSampleCursorPropertiesFromEventLink(uint64_t a1, uint64_t a2, CFTypeRef cf, uint64_t a4)
{
  int v58 = 0;
  CFTypeRef v59 = 0;
  long long v57 = 0uLL;
  CFTypeRef v55 = 0;
  CFTypeRef cfa = 0;
  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 != FigSampleCursorGetTypeID())
  {
    FigSignalErrorAt();
    goto LABEL_68;
  }
  *(_OWORD *)(a4 + 24) = 0u;
  *(_OWORD *)(a4 + 296) = 0u;
  *(_OWORD *)(a4 + 312) = 0u;
  *(_OWORD *)(a4 + 264) = 0u;
  *(_OWORD *)(a4 + 280) = 0u;
  *(_OWORD *)(a4 + 232) = 0u;
  *(_OWORD *)(a4 + 248) = 0u;
  *(_OWORD *)(a4 + 200) = 0u;
  *(_OWORD *)(a4 + 216) = 0u;
  *(_OWORD *)(a4 + 168) = 0u;
  *(_OWORD *)(a4 + 184) = 0u;
  *(_OWORD *)(a4 + 136) = 0u;
  *(_OWORD *)(a4 + 152) = 0u;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_OWORD *)(a4 + 72) = 0u;
  *(_OWORD *)(a4 + 88) = 0u;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + 56) = 0u;
  uint64_t v54 = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  CFTypeRef v11 = *(unsigned int (**)(CFTypeRef, char *))(v10 + 40);
  if (v11 && !v11(cf, (char *)&v51 + 8))
  {
    uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v13 = v12 ? v12 : 0;
    char v14 = *(unsigned int (**)(CFTypeRef, long long *))(v13 + 48);
    if (v14 && !v14(cf, &v53))
    {
      uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v16 = v15 ? v15 : 0;
      unint64_t v17 = *(unsigned int (**)(CFTypeRef, long long *))(v16 + 56);
      if (v17)
      {
        if (!v17(cf, &v50))
        {
          uint64_t v49 = 0;
          if (*(unsigned char *)(*(void *)(a1 + 16) + 32))
          {
            uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 16);
            uint64_t v19 = v18 ? v18 : 0;
            if (*(void *)(v19 + 64))
            {
              uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v20) {
                uint64_t v21 = v20;
              }
              else {
                uint64_t v21 = 0;
              }
              long long v22 = *(void (**)(CFTypeRef, char *, char *, uint64_t *, char *))(v21 + 64);
              if (v22) {
                v22(cf, (char *)&v49 + 4, (char *)&v49 + 5, &v49, (char *)&v49 + 6);
              }
              *(void *)(a4 + 96) = v49;
            }
          }
          long long v23 = v53;
          *(_OWORD *)(a4 + 56) = v52;
          *(_OWORD *)(a4 + 72) = v23;
          *(void *)(a4 + 88) = v54;
          long long v24 = v51;
          *(_OWORD *)(a4 + 24) = v50;
          *(_OWORD *)(a4 + 40) = v24;
          uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v25) {
            uint64_t v26 = v25;
          }
          else {
            uint64_t v26 = 0;
          }
          uint64_t v27 = *(void (**)(CFTypeRef, CFTypeRef *))(v26 + 160);
          if (v27) {
            v27(cf, &cfa);
          }
          *(void *)(a4 + 104) = 0;
          if (!FigSampleCursorServer_TranslateFormatDescriptionFromEventLink(a1, *(void *)(a1 + 48), cfa, a4, a2, (void *)(a4 + 104), (void *)(a4 + 144)))
          {
            *(void *)(a4 + 152) = 0;
            *(void *)(a4 + 112) = 0;
            *(void *)(a4 + 120) = 0;
            *(void *)(a4 + 168) = 0;
            if (*(unsigned char *)(a1 + 32))
            {
              uint64_t FigBaseObject = FigSampleCursorGetFigBaseObject(cf);
              uint64_t v29 = *(void *)(CMBaseObjectGetVTable() + 8);
              if (v29) {
                uint64_t v30 = v29;
              }
              else {
                uint64_t v30 = 0;
              }
              uint64_t v31 = *(void (**)(uint64_t, __CFString *, void, CFTypeRef *))(v30 + 48);
              if (v31) {
                v31(FigBaseObject, @"SampleDependencyAttributes", *MEMORY[0x1E4F1CF80], &v55);
              }
              if (v55)
              {
                if (FigSampleCursorServer_TranslateSampleDependencyAttributesFromEventLink(a1, *(void *)(a1 + 48), v55, a4, *(void *)(a4 + 144), a2, (void *)(a4 + 112), (void *)(a4 + 152)))goto LABEL_68; {
              }
                }
              else
              {
                *(void *)(a4 + 112) = -1;
              }
            }
            uint64_t v32 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v32) {
              uint64_t v33 = v32;
            }
            else {
              uint64_t v33 = 0;
            }
            if (*(void *)(v33 + 144))
            {
              uint64_t v34 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v34) {
                uint64_t v35 = v34;
              }
              else {
                uint64_t v35 = 0;
              }
              CFTypeRef v36 = *(uint64_t (**)(CFTypeRef, long long *, char *, CFTypeRef *, const void **))(v35 + 144);
              if (v36)
              {
                uint64_t v37 = v36(cf, &v57, (char *)&v57 + 8, &v59, &v58);
                uint64_t v38 = (uint64_t)v59;
                *(_OWORD *)(a4 + 128) = v57;
                if (v38 && FigSampleCursorServer_TranslateByteStream(v37, v38, (void *)(a4 + 168))) {
                  goto LABEL_68;
                }
              }
              else
              {
                *(_OWORD *)(a4 + 128) = v57;
              }
              if (FigSampleCursorServer_TranslateDataSourceFromEventLink(a1, *(void *)(a1 + 48), v58, a4, *(void *)(a4 + 152) + *(void *)(a4 + 144), a2, (void *)(a4 + 120), (void *)(a4 + 160)))goto LABEL_68; {
            }
              }
            long long v40 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
            long long v39 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
            *(_OWORD *)(a4 + 176) = *MEMORY[0x1E4F1FA20];
            *(_OWORD *)(a4 + 192) = v40;
            uint64_t v41 = MEMORY[0x1E4F1F9F8];
            long long v42 = *MEMORY[0x1E4F1F9F8];
            *(_OWORD *)(a4 + 208) = v39;
            *(_OWORD *)(a4 + 224) = v42;
            uint64_t v43 = *(void *)(v41 + 16);
            *(void *)(a4 + 240) = v43;
            *(_OWORD *)(a4 + 248) = v42;
            *(void *)(a4 + 264) = v43;
            *(unsigned char *)(a4 + 272) = 0;
            *(void *)(a4 + 292) = v43;
            *(_OWORD *)(a4 + 276) = v42;
            *(void *)(a4 + 316) = v43;
            *(_OWORD *)(a4 + 300) = v42;
            if (*(_DWORD *)(*(void *)(a1 + 16) + 36) != 1936684398)
            {
              FigSampleCursorUtilityGetPresentationTimeRange(cf, (_OWORD *)(a4 + 176));
              uint64_t v44 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v44) {
                uint64_t v45 = v44;
              }
              else {
                uint64_t v45 = 0;
              }
              if (*(void *)(v45 + 200))
              {
                uint64_t v46 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v47 = v46 ? v46 : 0;
                int v48 = *(void (**)(CFTypeRef, uint64_t, uint64_t))(v47 + 200);
                if (v48) {
                  v48(cf, a4 + 224, a4 + 248);
                }
              }
              FigSampleCursorUtilityGetMinimumUpcomingPresentationTime((uint64_t)cf, 0, (CMTime *)(a4 + 276), (CMTime *)(a4 + 300));
              *(unsigned char *)(a4 + 272) = 1;
            }
          }
        }
      }
    }
  }
LABEL_68:
  if (v58) {
    CFRelease(v58);
  }
  if (v59) {
    CFRelease(v59);
  }
  if (cfa) {
    CFRelease(cfa);
  }
  if (v55) {
    CFRelease(v55);
  }
}

uint64_t FigSampleCursorServer_TranslateFormatDescriptionFromEventLink(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, void *a6, void *a7)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  char v10 = 0;
  uint64_t result = FigPartialSampleTableOutOfBandObjectRegistryLookupOrMakeIDForObjectOfType(*(void *)(a1 + 24), @"FormatDescription", a3, &v12, &v10);
  if (!result)
  {
    if (!v12) {
      return FigSignalErrorAt();
    }
    if (v10)
    {
      uint64_t result = FigInMemorySerializerAppendCMFormatDescription();
      if (result) {
        return result;
      }
      if (!a6) {
        goto LABEL_7;
      }
    }
    else
    {
      uint64_t v11 = 0;
      if (!a6)
      {
LABEL_7:
        uint64_t result = 0;
        if (a7) {
          *a7 = v11;
        }
        return result;
      }
    }
    *a6 = v12;
    goto LABEL_7;
  }
  return result;
}

uint64_t FigSampleCursorServer_TranslateDataSourceFromEventLink(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8)
{
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  if (!a3) {
    goto LABEL_6;
  }
  char v11 = 0;
  uint64_t result = FigPartialSampleTableOutOfBandObjectRegistryLookupOrMakeIDForObjectOfType(*(void *)(a1 + 24), @"DataSourceURL", a3, &v13, &v11);
  if (result) {
    return result;
  }
  if (!v13) {
    return FigSignalErrorAt();
  }
  if (v11)
  {
    uint64_t result = FigInMemorySerializerAppendCFURL();
    if (result) {
      return result;
    }
LABEL_6:
    if (!a7) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  uint64_t v12 = 0;
  if (a7) {
LABEL_7:
  }
    *a7 = v13;
LABEL_8:
  uint64_t result = 0;
  if (a8) {
    *a8 = v12;
  }
  return result;
}

uint64_t FigRemote_CreateEditArrayData(size_t a1, uint64_t a2, const __CFAllocator *a3, __CFData **a4)
{
  uint64_t v7 = a1;
  CFTypeID v8 = (CFURLRef *)malloc_type_calloc(a1, 8uLL, 0x6004044C4A2DFuLL);
  usedBufLeCFIndex n = 0;
  if (v8)
  {
    uint64_t v9 = v8;
    if (v7 < 1)
    {
      uint64_t v27 = 0;
    }
    else
    {
      uint64_t v33 = a4;
      uint64_t v10 = 0;
      char v11 = (CFURLRef *)(a2 + 96);
      uint64_t v12 = v8;
      uint64_t v13 = v7;
      do
      {
        if (*v11)
        {
          CFURLRef v14 = CFURLCopyAbsoluteURL(*v11);
          *uint64_t v12 = v14;
          if (!v14) {
            goto LABEL_23;
          }
          CFStringRef v15 = CFURLGetString(v14);
          v38.length = CFStringGetLength(v15);
          v38.locatioCFIndex n = 0;
          CFStringGetBytes(v15, v38, 0x8000100u, 0x2Au, 0, 0, 0, &usedBufLen);
          v10 += usedBufLen + (-(char)usedBufLen & 3);
        }
        ++v12;
        char v11 = (CFURLRef *)((char *)v11 + 108);
        --v13;
      }
      while (v13);
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(a3, v10 + 104 * v7);
      CFDataSetLength(Mutable, v10 + 104 * v7);
      if (!Mutable)
      {
LABEL_23:
        uint64_t v28 = FigSignalErrorAt();
        goto LABEL_17;
      }
      uint64_t v31 = Mutable;
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      uint64_t v18 = v9;
      uint64_t v19 = (_DWORD *)(a2 + 104);
      uint64_t v32 = v18;
      uint64_t v20 = v7;
      do
      {
        *(void *)uint64_t v35 = *((void *)v19 - 5);
        *(void *)&v35[24] = *((void *)v19 - 2);
        *(_OWORD *)&v35[8] = *((_OWORD *)v19 - 2);
        long long v21 = *(_OWORD *)(v19 - 26);
        *(void *)uint64_t v34 = *((void *)v19 - 11);
        *(void *)&v34[24] = *((void *)v19 - 8);
        *(_OWORD *)&v34[8] = *((_OWORD *)v19 - 5);
        long long v22 = *(_OWORD *)(v19 - 14);
        *((_OWORD *)MutableBytePtr + 2) = *(_OWORD *)&v34[16];
        *((_OWORD *)MutableBytePtr + 3) = v22;
        *((_OWORD *)MutableBytePtr + 4) = *(_OWORD *)v35;
        *((_OWORD *)MutableBytePtr + 5) = *(_OWORD *)&v35[16];
        *(_OWORD *)MutableBytePtr = v21;
        *((_OWORD *)MutableBytePtr + 1) = *(_OWORD *)v34;
        if (*((void *)v19 - 1))
        {
          CFStringRef v23 = CFURLGetString(*v18);
          v39.length = CFStringGetLength(v23);
          v39.locatioCFIndex n = 0;
          CFStringGetBytes(v23, v39, 0x8000100u, 0x2Au, 0, 0, 0, &usedBufLen);
          *((_DWORD *)MutableBytePtr + 24) = usedBufLen;
          long long v24 = MutableBytePtr + 100;
          v40.length = CFStringGetLength(v23);
          v40.locatioCFIndex n = 0;
          CFStringGetBytes(v23, v40, 0x8000100u, 0x2Au, 0, v24, usedBufLen, 0);
          uint64_t v25 = &v24[usedBufLen + (-(char)usedBufLen & 3)];
        }
        else
        {
          *((_DWORD *)MutableBytePtr + 24) = 0;
          uint64_t v25 = MutableBytePtr + 100;
        }
        int v26 = *v19;
        v19 += 27;
        *(_DWORD *)uint64_t v25 = v26;
        MutableBytePtr = v25 + 4;
        ++v18;
        --v20;
      }
      while (v20);
      uint64_t v9 = v32;
      a4 = v33;
      uint64_t v27 = v31;
    }
    uint64_t v28 = 0;
    *a4 = v27;
LABEL_17:
    if (v7 >= 1)
    {
      uint64_t v29 = (CFTypeRef *)v9;
      do
      {
        if (*v29) {
          CFRelease(*v29);
        }
        ++v29;
        --v7;
      }
      while (v7);
    }
    free(v9);
    return v28;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigRemote_CreateEditArrayFromData(const UInt8 *a1, unint64_t a2, CFAllocatorRef alloc, uint64_t a4, uint64_t a5)
{
  if (!a4) {
    return 0;
  }
  uint64_t v5 = a1;
  if (a1)
  {
    if (a2)
    {
      uint64_t v6 = a4;
      if (a4 >= 1)
      {
        CFTypeID v8 = (_DWORD *)(a5 + 104);
        while (a2 >= 0x68)
        {
          *(_OWORD *)uint64_t v19 = *((_OWORD *)v5 + 4);
          *(_OWORD *)&v19[16] = *((_OWORD *)v5 + 5);
          long long v17 = *(_OWORD *)v5;
          *(_OWORD *)uint64_t v18 = *((_OWORD *)v5 + 1);
          *(_OWORD *)&v18[16] = *((_OWORD *)v5 + 2);
          *(_OWORD *)(v8 - 14) = *((_OWORD *)v5 + 3);
          *((void *)v8 - 5) = *(void *)v19;
          *((_OWORD *)v8 - 2) = *(_OWORD *)&v19[8];
          *((void *)v8 - 2) = *(void *)&v19[24];
          *((void *)v8 - 11) = *(void *)v18;
          *(_OWORD *)(v8 - 26) = v17;
          *((void *)v8 - 8) = *(void *)&v18[24];
          *((_OWORD *)v8 - 5) = *(_OWORD *)&v18[8];
          CFIndex v9 = *((unsigned int *)v5 + 24);
          unint64_t v10 = a2 - 100;
          uint64_t v11 = (-(int)v9 & 3) + v9;
          if (a2 - 100 < v11 + 4) {
            break;
          }
          uint64_t v12 = v5 + 100;
          if (v9)
          {
            CFStringRef v13 = CFStringCreateWithBytes(alloc, v12, v9, 0x8000100u, 0);
            if (!v13) {
              break;
            }
            CFStringRef v14 = v13;
            *((void *)v8 - 1) = CFURLCreateWithString(alloc, v13, 0);
            CFRelease(v14);
            if (!*((void *)v8 - 1)) {
              break;
            }
            v12 += v11;
            v10 -= v11;
          }
          else
          {
            *((void *)v8 - 1) = 0;
          }
          int v15 = *(_DWORD *)v12;
          uint64_t v5 = v12 + 4;
          *CFTypeID v8 = v15;
          v8 += 27;
          a2 = v10 - 4;
          if (!--v6)
          {
            if (v10 != 4) {
              break;
            }
            return 0;
          }
        }
      }
    }
  }

  return FigSignalErrorAt();
}

CFArrayRef FigMutableCompositionClientServer_CreateFlattenedFormatDescriptionReplacementTable(const __CFArray *cf, __CFArray **a2)
{
  CFArrayRef v3 = cf;
  if (!cf)
  {
    *a2 = 0;
    return v3;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount(v3);
    if (Count)
    {
      uint64_t v6 = Count;
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2 * Count, MEMORY[0x1E4F1D510]);
      if (v6 < 1)
      {
LABEL_11:
        CFArrayRef v3 = 0;
        *a2 = Mutable;
      }
      else
      {
        CFIndex v8 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, v8);
          if (!ValueAtIndex) {
            break;
          }
          CFDictionaryRef v10 = ValueAtIndex;
          CFTypeID v11 = CFGetTypeID(ValueAtIndex);
          if (v11 != CFDictionaryGetTypeID()) {
            break;
          }
          CFNumberRef Value = CFDictionaryGetValue(v10, @"MutableCompositionFormatDescriptionReplacementTableKey_OldFormatDescription");
          if (!Value) {
            break;
          }
          CFStringRef v13 = Value;
          CFStringRef v14 = CFDictionaryGetValue(v10, @"MutableCompositionFormatDescriptionReplacementTableKey_NewFormatDescription");
          if (!v14) {
            break;
          }
          int v15 = v14;
          CFArrayAppendValue(Mutable, v13);
          CFArrayAppendValue(Mutable, v15);
          if (v6 == ++v8) {
            goto LABEL_11;
          }
        }
        CFArrayRef v3 = (const __CFArray *)FigSignalErrorAt();
        if (Mutable) {
          CFRelease(Mutable);
        }
      }
    }
    else
    {
      *a2 = v3;
      CFRetain(v3);
      return 0;
    }
    return v3;
  }

  return (const __CFArray *)FigSignalErrorAt();
}

uint64_t FigMutableCompositionClientServer_CreateUnflattenedFormatDescriptionReplacementTable(void *a1, CFMutableArrayRef *a2)
{
  if (!a1)
  {
    *a2 = 0;
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFArrayGetTypeID() && (CFArrayGetCount((CFArrayRef)a1) & 1) == 0)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 0) {
      uint64_t v6 = Count;
    }
    else {
      uint64_t v6 = Count + 1;
    }
    if ((unint64_t)(Count + 1) > 2)
    {
      uint64_t v7 = Count;
      uint64_t v8 = v6 >> 1;
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6 >> 1, MEMORY[0x1E4F1D510]);
      CFTypeID v11 = Mutable;
      if (v7 <= 1)
      {
        *a2 = Mutable;
      }
      else
      {
        CFMutableDictionaryRef v12 = 0;
        CFIndex v13 = 1;
        do
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v13 - 1);
          int v15 = CFArrayGetValueAtIndex((CFArrayRef)a1, v13);
          if (v12) {
            CFRelease(v12);
          }
          CFMutableDictionaryRef v12 = CFDictionaryCreateMutable(v9, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionarySetValue(v12, @"MutableCompositionFormatDescriptionReplacementTableKey_OldFormatDescription", ValueAtIndex);
          CFDictionarySetValue(v12, @"MutableCompositionFormatDescriptionReplacementTableKey_NewFormatDescription", v15);
          CFArrayAppendValue(v11, v12);
          v13 += 2;
          --v8;
        }
        while (v8);
        *a2 = v11;
        if (v12) {
          CFRelease(v12);
        }
      }
    }
    else
    {
      *a2 = (CFMutableArrayRef)a1;
      CFRetain(a1);
    }
    return 0;
  }

  return FigSignalErrorAt();
}

uint64_t FigBytePumpCreateForHTTPChunk(const void *a1, const __CFURL *a2, const void *a3, const __CFDictionary *a4, NSObject *a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v211 = *MEMORY[0x1E4F143B8];
  int valuePtr = -1;
  char v179 = 0;
  if (a2 && a6 && a8)
  {
    CFURLRef v10 = a2;
    int v181 = 0;
    CFTypeRef cf = FigCFHTTPCreateURLString(a2);
    CFPreferencesSynchronize(@"com.apple.coremedia", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
    FigNote_AllowInternalDefaultLogs();
    fig_note_initialize_category_with_default_work_cf();
    fig_note_initialize_category_with_default_work_cf();
    MTEnableCaption2015Behavior();
    FigBytePumpGetClassID();
    uint64_t v12 = CMDerivedObjectCreate();
    if (v12) {
      goto LABEL_25;
    }
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    uint64_t v14 = FigRetainProxyCreate();
    if (v14) {
      goto LABEL_43;
    }
    uint64_t v15 = DerivedStorage + 7904;
    if (a1) {
      *(void *)(DerivedStorage + 56) = CFRetain(a1);
    }
    *(unsigned char *)(DerivedStorage + 9032) = 1;
    int IsItOKToLogURLs = FigIsItOKToLogURLs();
    *(unsigned char *)(DerivedStorage + 339) = IsItOKToLogURLs;
    long long v17 = (const void **)MEMORY[0x1E4F1CFD0];
    if (a4)
    {
      uint64_t v18 = CFDictionaryGetValue(a4, @"FBPCreateOption_InheritURIQueryComponentFromReferencingURI");
      v183[0] = 0;
      uint64_t v19 = *v17;
      *(unsigned char *)(DerivedStorage + 320) = v18 == *v17;
      uint64_t v20 = CFDictionaryGetValue(a4, @"FBPCreateOption_HTTPRequestOptions");
      if (v20)
      {
        CFDictionaryRef v21 = (const __CFDictionary *)CFRetain(v20);
        *(void *)(DerivedStorage + 240) = v21;
        if (v21)
        {
          long long v22 = CFDictionaryGetValue(v21, @"FHRP_InterfaceName");
          if (v22) {
            long long v22 = CFRetain(v22);
          }
          *(void *)(DerivedStorage + 8880) = v22;
          CFStringRef v23 = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 240), @"FHRP_ClientAuditToken");
          if (v23) {
            CFStringRef v23 = CFRetain(v23);
          }
          *(void *)(DerivedStorage + 8888) = v23;
          *(void *)(DerivedStorage + 8896) = FigCFHTTPCopyClientProcessName((const __CFData *)v23);
          long long v24 = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 240), @"FHRP_StorageSession");
          if (v24) {
            long long v24 = CFRetain(v24);
          }
          *(void *)(DerivedStorage + 32) = v24;
          FigCFDictionaryGetBooleanIfPresent();
          *(unsigned char *)(DerivedStorage + 9633) = v183[0] == 0;
        }
      }
      else
      {
        *(void *)(DerivedStorage + 240) = 0;
      }
      uint64_t v25 = CFDictionaryGetValue(a4, @"FBPCreateOption_OutOfBandAlternateTracks");
      if (v25) {
        uint64_t v25 = CFRetain(v25);
      }
      *(void *)(DerivedStorage + 8384) = v25;
      int v26 = CFDictionaryGetValue(a4, @"FBPCreateOption_StreamingCache");
      if (v26)
      {
        CFTypeRef v27 = CFRetain(v26);
        *(void *)(DerivedStorage + 296) = v27;
        if (v27)
        {
          CMNotificationCenterGetDefaultLocalCenter();
          uint64_t v12 = FigNotificationCenterAddWeakListener();
          if (v12)
          {
LABEL_25:
            uint64_t v28 = v12;
LABEL_248:
            uint64_t v37 = cf;
LABEL_249:
            if (v37) {
              CFRelease(v37);
            }
            return v28;
          }
        }
      }
      else
      {
        *(void *)(DerivedStorage + 296) = 0;
      }
      CFDictionaryRef v29 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"FBPCreateOption_CPECryptors");
      if (v29)
      {
        long long context = (unint64_t)DerivedStorage;
        CFDictionaryApplyFunction(v29, (CFDictionaryApplierFunction)segPumpSetupInitialCryptorApplierFunction, &context);
        uint64_t v28 = DWORD2(context);
        if (DWORD2(context))
        {
LABEL_44:
          uint64_t v37 = cf;
LABEL_45:
          if (v181) {
            CFRelease(v181);
          }
          goto LABEL_249;
        }
      }
      *(unsigned char *)(DerivedStorage + 324) = v19 == CFDictionaryGetValue(a4, @"FBPCreateOption_DisallowCellularAccess");
      *(unsigned char *)(DerivedStorage + 325) = v19 == CFDictionaryGetValue(a4, @"FBPCreateOption_DisallowsExpensiveNetworkAccess");
      *(unsigned char *)(DerivedStorage + 326) = v19 == CFDictionaryGetValue(a4, @"FBPCreateOption_DisallowsConstrainedNetworkAccess");
      uint64_t v30 = CFDictionaryGetValue(a4, @"FBPCreateOption_iTunesRentalID");
      if (v30) {
        uint64_t v30 = CFRetain(v30);
      }
      *(void *)(DerivedStorage + 9448) = v30;
      uint64_t v31 = CFDictionaryGetValue(a4, @"FBPCreateOption_iTunesAccountID");
      if (v31) {
        uint64_t v31 = CFRetain(v31);
      }
      *(void *)(DerivedStorage + 9456) = v31;
      uint64_t v32 = CFDictionaryGetValue(a4, @"FBPCreateOption_PrimarySessionID");
      if (v32) {
        uint64_t v32 = CFRetain(v32);
      }
      *(void *)(DerivedStorage + 232) = v32;
      uint64_t v33 = CFDictionaryGetValue(a4, @"FBPCreateOption_CustomURLLoader");
      if (v33) {
        uint64_t v33 = CFRetain(v33);
      }
      *(void *)(DerivedStorage + 80) = v33;
      uint64_t v34 = CFDictionaryGetValue(a4, @"FBPCreateOption_DefaultContentKeySession");
      if (v34)
      {
        CFTypeRef v35 = CFRetain(v34);
        *(void *)(DerivedStorage + 9472) = v35;
        if (v35)
        {
          if (FigCFDictionaryGetBooleanIfPresent()) {
            char v36 = v179 == 0;
          }
          else {
            char v36 = PKDIsContentKeyBossEnabled();
          }
          *(unsigned char *)(DerivedStorage + 9480) = v36;
          CFRange v38 = CFDictionaryGetValue(a4, @"FBPCreateOption_ContentKeyBoss");
          if (v38) {
            CFRange v38 = CFRetain(v38);
          }
          *(void *)(DerivedStorage + 9488) = v38;
          *(unsigned char *)(DerivedStorage + 327) = CFDictionaryGetValue(a4, @"FBPCreateOption_DisableNativeHTTPReads") == v19;
          CFRange v39 = CFDictionaryGetValue(a4, @"FBPCreateOption_ParentNetworkActivity");
          if (v39) {
            CFRange v39 = CFRetain(v39);
          }
          *(void *)(DerivedStorage + 9104) = v39;
          if (v19 == CFDictionaryGetValue(a4, @"FBPCreateOption_DoNotLogURLs"))
          {
            int IsItOKToLogURLs = 0;
            *(unsigned char *)(DerivedStorage + 339) = 0;
          }
          else
          {
            int IsItOKToLogURLs = *(unsigned __int8 *)(DerivedStorage + 339);
          }
LABEL_55:
          double v175 = (const void *)*MEMORY[0x1E4F1CFC8];
          if (IsItOKToLogURLs) {
            CFRange v40 = v19;
          }
          else {
            CFRange v40 = (const void *)*MEMORY[0x1E4F1CFC8];
          }
          uint64_t v14 = segPumpSetHTTPRequestOptionsValue(DerivedStorage, @"FHRP_OKToLogURLs", v40);
          if (!v14)
          {
            uint64_t v14 = segPumpSetHTTPRequestOptionsValue(DerivedStorage, @"FHRP_NetworkHistory", *(const void **)(DerivedStorage + 88));
            if (!v14)
            {
              FigNetworkUrgencyMonitorCreate((uint64_t)a1, (uint64_t *)(DerivedStorage + 9512));
              if (a4)
              {
                CFDictionaryRef v41 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"FBPCreateOption_AlternativeConfigurationOptions");
                if (v41)
                {
                  FigCFDictionaryGetBooleanIfPresent();
                  char v165 = 0;
                  goto LABEL_65;
                }
              }
              else
              {
                CFDictionaryRef v41 = 0;
              }
              char v165 = 1;
LABEL_65:
              long long v42 = CFDictionaryGetValue(a4, @"FBPCreateOption_StoreBagSessionConfiguration");
              if (v42)
              {
                CFDictionaryRef v43 = (const __CFDictionary *)CFRetain(v42);
                uint64_t v44 = (CFMutableDictionaryRef *)(DerivedStorage + 9128);
                *(void *)(DerivedStorage + 9128) = v43;
                if (v43) {
                  goto LABEL_70;
                }
              }
              else
              {
                uint64_t v44 = (CFMutableDictionaryRef *)(DerivedStorage + 9128);
                *(void *)(DerivedStorage + 9128) = 0;
              }
              FigRCLCreateConfiguration(*(const void **)(DerivedStorage + 8896), @"kFigRemoteConfigurationLoaderStoreBagType_Pump", v41, v44);
              CFDictionaryRef v43 = *(const __CFDictionary **)(DerivedStorage + 9128);
LABEL_70:
              int v45 = FigRCLGetNumberWithDefault(v43, @"networkHistoryPredictorAlgorithm");
              LODWORD(v46) = v45 & ~(v45 >> 31);
              if (v46 >= 8) {
                uint64_t v46 = 8;
              }
              else {
                uint64_t v46 = v46;
              }
              *(void *)(DerivedStorage + 112) = v46;
              int v47 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"networkHistoryLowLatencyPredictorAlgorithm");
              LODWORD(v48) = v47 & ~(v47 >> 31);
              if (v48 >= 8) {
                uint64_t v48 = 8;
              }
              else {
                uint64_t v48 = v48;
              }
              *(void *)(DerivedStorage + 104) = v48;
              int v49 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"networkHistorySecondaryPredictorAlgorithm");
              if (v49 >= 8) {
                int v50 = 8;
              }
              else {
                int v50 = v49;
              }
              *(void *)(DerivedStorage + 120) = v50;
              *(void *)(DerivedStorage + 128) = (int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"minBytesForGlobalNetworkHistoryPrediction");
              *(void *)(DerivedStorage + 136) = (int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"minActiveNetworkTimeForGlobalNetworkHistoryPrediction");
              *(void *)(DerivedStorage + 144) = (int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"networkHistoryPredictorReportingInterval");
              *(_DWORD *)(DerivedStorage + 7944) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"minReserveSegments");
              *(_DWORD *)(DerivedStorage + 7976) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"highSegmentLatencyThresholdForRTCReporting");
              *(double *)(DerivedStorage + 7984) = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"minDownloadTimerInterval");
              *(double *)(DerivedStorage + 8056) = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"fastStartBandwidthAddend");
              double v51 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"fastStartBandwidthMultiplier");
              if (v51 < 1.0) {
                double v51 = 1.0;
              }
              *(double *)(DerivedStorage + 8048) = v51;
              double v52 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"slowDownloadBufferMaximum");
              if (v52 < 0.0) {
                double v52 = 0.0;
              }
              *(double *)(DerivedStorage + 8024) = v52;
              double v53 = (double)(int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"fastStartTargetDurationPercentage")/ 100.0;
              if (v53 < 0.1) {
                double v53 = 0.1;
              }
              *(double *)(DerivedStorage + 8040) = v53;
              double v54 = (double)(int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"startTargetDurationPercentage")/ 100.0;
              if (v54 < 0.2) {
                double v54 = 0.2;
              }
              *(double *)(DerivedStorage + 8032) = v54;
              *(unsigned char *)(DerivedStorage + 7993) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"allowAverageBandwidth") != 0;
              *(unsigned char *)(DerivedStorage + 8009) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"halveExpectedSwitchBandwidthWhenAudioIsActive") != 0;
              *(unsigned char *)(DerivedStorage + 8010) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"issueLowBandwidthAlertWhenNWPathUpdates") != 0;
              *(unsigned char *)(DerivedStorage + 8012) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"allowDownloadPerfReports") != 0;
              *(unsigned char *)(DerivedStorage + 9584) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"enableHTTP3Connection") != 0;
              *(unsigned char *)(DerivedStorage + 9633) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"enableL4S") != 0;
              *(unsigned char *)(DerivedStorage + 9632) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"disableHSHPBuffering") != 0;
              int v55 = MGGetSInt32Answer();
              int v56 = MGGetSInt32Answer();
              uint64_t value = DerivedStorage;
              uint64_t v172 = DerivedStorage + 7904;
              CFURLRef v170 = v10;
              CFDictionaryRef v166 = v41;
              if (v55 >= 1 && v56 >= 1)
              {
                uint64_t v57 = 0;
                if (v55 >= v56) {
                  int v55 = v56;
                }
                *(void *)&long long context = DerivedStorage + 192;
                *((void *)&context + 1) = DerivedStorage + 200;
                *(void *)&long long v198 = DerivedStorage + 208;
                double v174 = (void *)v19;
                int v58 = (char *)&unk_1949989EC;
                do
                {
                  CFTypeRef v59 = v44;
                  CFArrayRef v60 = (const __CFArray *)FigRCLCopyCFType(*v44, off_1E57A28B0[v57]);
                  CFArrayRef v61 = v60;
                  if (v60)
                  {
                    CFTypeID v62 = CFGetTypeID(v60);
                    if (v62 == CFArrayGetTypeID())
                    {
                      CFIndex Count = CFArrayGetCount(v61);
                      unsigned int v182 = 0;
                      *(_DWORD *)long long v183 = 0;
                      if (Count >= 1)
                      {
                        CFIndex v64 = Count;
                        for (CFIndex i = 0; i != v64; ++i)
                        {
                          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v61, i);
                          if (!ValueAtIndex) {
                            break;
                          }
                          CFTypeID v67 = CFGetTypeID(ValueAtIndex);
                          if (v67 != CFDictionaryGetTypeID()) {
                            break;
                          }
                          if (!FigCFDictionaryGetInt32IfPresent()) {
                            break;
                          }
                          if (!FigCFDictionaryGetInt32IfPresent()) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  uint64_t v68 = 0;
                  while (v55 > dword_1949989D8[v68])
                  {
                    if (++v68 == 5) {
                      goto LABEL_110;
                    }
                  }
                  if (*(int *)&v58[v68 * 4] >= 1)
                  {
                    uint64_t v69 = (CFTypeRef *)*((void *)&context + v57);
                    if (*v69) {
                      CFRelease(*v69);
                    }
                    AllocatorForMediCGFloat a = (const __CFAllocator *)FigGetAllocatorForMedia();
                    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                    *uint64_t v69 = Mutable;
                    if (Mutable)
                    {
                      FigCFDictionarySetInt32();
                      CFDictionaryAddValue((CFMutableDictionaryRef)*v69, @"FBPBTK_IsSetByStoreBag", v175);
                    }
                  }
LABEL_110:
                  if (v61) {
                    CFRelease(v61);
                  }
                  ++v57;
                  v58 += 20;
                  uint64_t v44 = v59;
                }
                while (v57 != 3);
                uint64_t v15 = v172;
                CFURLRef v10 = v170;
                uint64_t DerivedStorage = value;
                uint64_t v19 = v174;
              }
              *(double *)(DerivedStorage + 8080) = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"extraTargetDurationsReqToSwitchSecsAhead");
              FigGetCFPreferenceDoubleWithDefault();
              *(void *)(DerivedStorage + 8080) = v72;
              *(_DWORD *)(DerivedStorage + 8088) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"switchUpWalkBackMode");
              FigGetCFPreferenceDoubleWithDefault();
              *(_DWORD *)(DerivedStorage + 8088) = (int)v73;
              *(unsigned char *)(v15 + 288) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"budgetSwitchBackDownWhenCurveKnown");
              FigGetCFPreferenceDoubleWithDefault();
              *(unsigned char *)(v15 + 288) = (int)v74;
              FigGetCFPreferenceDoubleWithDefault();
              *(unsigned char *)(v15 + 289) = (int)v75;
              int v76 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"enableQUIC");
              if (v76 != -1)
              {
                if (v76 == 1) {
                  uint64_t v77 = v19;
                }
                else {
                  uint64_t v77 = v175;
                }
                segPumpSetHTTPRequestOptionsValue(DerivedStorage, @"FHRP_EnableQUIC", v77);
              }
              int valuePtr = FigGetCFPreferenceNumberWithDefault();
              if (valuePtr != -1
                || (int valuePtr = FigRCLGetNumberWithDefault(*v44, @"connectionCacheCellPurgeTimeout"), valuePtr != -1))
              {
                CFNumberRef v78 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
                segPumpSetHTTPRequestOptionsValue(DerivedStorage, @"FHRP_ConnectionCacheCellPurgeTimeout", v78);
                if (v78) {
                  CFRelease(v78);
                }
              }
              double v79 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"averageBWSwitchUpSafetyMargin");
              *(double *)(DerivedStorage + 8064) = v79;
              double v80 = 0.0;
              if (v79 < 0.0 || (double v80 = 5.0, v79 > 5.0)) {
                *(double *)(DerivedStorage + 8064) = v80;
              }
              *(_DWORD *)(DerivedStorage + 8072) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"increaseBitsRequiredToSwitchVODSecsBackMargin");
              if (*(void *)(DerivedStorage + 9128))
              {
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, @"networkPredictorCoefPredictionTimeInterval", (__CFArray **)(DerivedStorage + 9136));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, @"networkPredictorCoefBandwidth", (__CFArray **)(DerivedStorage + 9144));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, @"networkPredictorCoefBandwidthRelativeStdDev", (__CFArray **)(DerivedStorage + 9152));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, @"networkPredictorCoefBandwidthStdError", (__CFArray **)(DerivedStorage + 9160));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, @"networkPredictorCoefLatency", (__CFArray **)(DerivedStorage + 9176));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, @"networkPredictorCoefLatencyRelativeStdDev", (__CFArray **)(DerivedStorage + 9184));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, @"networkPredictorCoefLatencyStdError", (__CFArray **)(DerivedStorage + 9192));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, @"networkPredictorCoefActiveNetworkTime", (__CFArray **)(DerivedStorage + 9200));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, @"networkPredictorCoefBandwidthRelativeStdDev", (__CFArray **)(DerivedStorage + 9168));
                *(double *)(DerivedStorage + 9208) = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"networkPredictorCoefKonstant");
              }
              *(_DWORD *)(DerivedStorage + 8212) = FigGetCFPreferenceNumberWithDefault();
              *(unsigned char *)(v15 + 1681) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"enablePeriodicBandwidthReporting") != 0;
              *(unsigned char *)(DerivedStorage + 334) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"enablePairedLLABR");
              *(unsigned char *)(DerivedStorage + 334) = FigGetCFPreferenceNumberWithDefault();
              uint64_t v81 = DerivedStorage + 4056;
              for (uint64_t j = 392; j != 440; j += 16)
              {
                CFTypeRef v83 = (uint64_t *)(DerivedStorage + j);
                *(v83 - 1) = v81 - 3624;
                *CFTypeRef v83 = v81;
                v81 += 1208;
              }
              *(void *)(*(void *)(DerivedStorage + 384) + 16) = CFRetain(v10);
              *(void *)(*(void *)(DerivedStorage + 384) + 8) = CFRetain(v10);
              *(void *)(*(void *)(DerivedStorage + 384) + 24) = CFRetain(v10);
              *(void *)(DerivedStorage + 160) = a6;
              *(void *)(DerivedStorage + 176) = FigRetainProxyRetain();
              *(void *)(DerivedStorage + 8704) = 0x3FF0000000000000;
              *(_DWORD *)(DerivedStorage + 8696) = 1065353216;
              *(_WORD *)(v15 + 93) = 257;
              *(_DWORD *)(DerivedStorage + 8664) = 0;
              *(_WORD *)(DerivedStorage + 322) = 257;
              *(_WORD *)(v15 + 272) = 257;
              *(unsigned char *)(v15 + 336) = 1;
              *(void *)(DerivedStorage + 8200) = 0x4034000000000000;
              *(unsigned char *)uint64_t v15 = 1;
              *(unsigned char *)(DerivedStorage + 330) = 1;
              CFAllocatorRef v84 = (const __CFAllocator *)FigGetAllocatorForMedia();
              *(void *)(DerivedStorage + 8760) = CFStringCreateWithFormat(v84, 0, @"%p", v181);
              *(unsigned char *)(v15 + 96) = 1;
              uint64_t v14 = segPumpSetupNetworkHistory(DerivedStorage);
              if (!v14)
              {
                *(void *)(DerivedStorage + 352) = 0;
                *(void *)(DerivedStorage + 360) = DerivedStorage + 352;
                *(void *)(DerivedStorage + 8096) = 0;
                *(void *)(DerivedStorage + 8104) = DerivedStorage + 8096;
                *(void *)(DerivedStorage + 8112) = 0;
                *(void *)(DerivedStorage + 8120) = DerivedStorage + 8112;
                segPumpClearStatistics(DerivedStorage);
                if (a3)
                {
                  CFDictionaryRef v85 = (const __CFDictionary *)CFRetain(a3);
                  *(void *)(DerivedStorage + 216) = v85;
                  if (v85)
                  {
                    int v86 = CFDictionaryGetValue(v85, @"X-Playback-Session-Id");
                    CFTypeRef v87 = v86 ? CFRetain(v86) : 0;
                    *(void *)(DerivedStorage + 224) = v87;
                    uint64_t v88 = *(void *)(DerivedStorage + 96);
                    uint64_t v89 = *(void *)(CMBaseObjectGetVTable() + 8);
                    uint64_t v90 = v89 ? v89 : 0;
                    int v91 = *(void (**)(uint64_t, uint64_t, CFTypeRef))(v90 + 56);
                    if (v91) {
                      v91(v88, 0x1EE581D38, v87);
                    }
                  }
                }
                else
                {
                  *(void *)(DerivedStorage + 216) = 0;
                }
                *(void *)(DerivedStorage + 368) = -1;
                int v92 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), @"maxParallelConnectionCount");
                unsigned __int8 v93 = 0;
                if (v92 <= 1) {
                  int v94 = 1;
                }
                else {
                  int v94 = v92;
                }
                if (v94 >= 6) {
                  unsigned int v95 = 6;
                }
                else {
                  unsigned int v95 = v94;
                }
                if (v95 >= 2) {
                  unsigned __int8 v93 = FigRCLGetNumberWithDefault(*v44, @"startWithSingleConnection");
                }
                int v96 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(value + 9128), @"maxReadAheadConnectionCount");
                if (v96 >= 5) {
                  int v97 = 5;
                }
                else {
                  int v97 = v96;
                }
                int v98 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(value + 9128), @"maxStepAheadConnectionCount");
                uint64_t v99 = 0;
                if (v97 >= v98) {
                  int v100 = v98;
                }
                else {
                  int v100 = v97;
                }
                int v101 = (uint64_t *)(value + 392);
                do
                {
                  initedouble d = segPumpStreamInitStorage(value, *(v101 - 1), v99, v95, v97, v100, v93);
                  if (inited
                    || (initedouble d = segPumpStreamInitStorage(value, *v101, v99, v95, v97, v100, v93), inited))
                  {
                    uint64_t v28 = inited;
                    uint64_t v37 = cf;
                    goto LABEL_45;
                  }
                  ++v99;
                  v101 += 2;
                }
                while (v99 != 3);
                if (a5)
                {
                  Local = FigHTTPSchedulerRetain(a5);
                  uint64_t v104 = value;
                  *(void *)(value + 64) = Local;
                  CFURLRef v105 = v170;
                  CFDictionaryRef v106 = v166;
                }
                else
                {
                  Local = FigHTTPSchedulerCreateLocal(v181);
                  uint64_t v104 = value;
                  *(void *)(value + 64) = Local;
                  CFURLRef v105 = v170;
                  CFDictionaryRef v106 = v166;
                  if (!Local)
                  {
                    Local = FigHTTPSchedulerRetain(0);
                    *(void *)(value + 64) = Local;
                  }
                }
                *(void *)(v104 + 72) = FigHTTPSchedulerRetain(Local);
                *(unsigned char *)(v104 + 48) = 1;
                uint32x2_t v107 = v44;
                uint64_t v108 = v104;
                if (*(void *)(v104 + 32)
                  || (CFTypeRef v109 = FigURLStorageSessionCopyGlobalSession(), (*(void *)(v104 + 32) = v109) != 0))
                {
                  *(void *)(v104 + 312) = CFRetain(v105);
                  *(void *)(v104 + 9120) = FigNetworkInterfaceReporterCreate();
                  if (v165)
                  {
                    uint32x2_t v110 = 0;
                    unsigned int v111 = 0;
                    BOOL v112 = 0;
                    uint64_t v113 = 0;
                    signed int v114 = 0;
                    signed int v115 = 0;
                  }
                  else
                  {
                    signed int v116 = CFDictionaryGetValue(v106, @"ServiceIdentifier");
                    if (!v116 || (v110 = v116, CFTypeID v117 = CFGetTypeID(v116), v117 != CFStringGetTypeID())) {
                      uint32x2_t v110 = 0;
                    }
                    double v118 = CFDictionaryGetValue(v106, @"StorefrontID");
                    if (!v118 || (unsigned int v111 = v118, v119 = CFGetTypeID(v118), v119 != CFStringGetTypeID())) {
                      unsigned int v111 = 0;
                    }
                    double v120 = CFDictionaryGetValue(v106, @"MediaIdentifier");
                    if (!v120 || (uint64_t v113 = v120, v121 = CFGetTypeID(v120), v121 != CFStringGetTypeID())) {
                      uint64_t v113 = 0;
                    }
                    double v122 = CFDictionaryGetValue(v106, @"ContentProvider");
                    if (!v122 || (signed int v114 = v122, v123 = CFGetTypeID(v122), v123 != CFStringGetTypeID())) {
                      signed int v114 = 0;
                    }
                    double v124 = CFDictionaryGetValue(v106, @"ServiceInformationKey");
                    if (!v124 || (signed int v115 = v124, v125 = CFGetTypeID(v124), v125 != CFDictionaryGetTypeID())) {
                      signed int v115 = 0;
                    }
                    BOOL v112 = CFDictionaryGetValue(v106, @"HierarchyToken");
                  }
                  CFDictionaryRef v126 = *v107;
                  CFAllocatorRef v127 = (const __CFAllocator *)FigGetAllocatorForMedia();
                  CFMutableDictionaryRef v128 = CFDictionaryCreateMutable(v127, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  if (v128)
                  {
                    CGFloat v129 = v128;
                    size_t v173 = v112;
                    valueCGFloat a = v114;
                    double v130 = v113;
                    double v131 = v111;
                    for (uint64_t k = 0; k != 13; ++k)
                    {
                      uint64_t v133 = featureOptionsList[k];
                      uint64_t v134 = FigRCLCopyCFType(v126, *v133);
                      if (v134)
                      {
                        uint64_t v135 = v134;
                        CFDictionarySetValue(v129, *v133, v134);
                        CFRelease(v135);
                      }
                    }
                    CFDictionaryRef v136 = FigRCLCopyConfigurationGroupName(v126);
                    if (v136)
                    {
                      CFDictionaryRef v137 = v136;
                      CFDictionarySetValue(v129, @"configurationGroup", v136);
                      CFRelease(v137);
                    }
                    int v138 = CFDictionaryGetValue(*(CFDictionaryRef *)(v108 + 240), @"FHRP_ClientBundleIdentifier");
                    if (v130) {
                      CFDictionarySetValue(v129, @"MediaIdentifier", v130);
                    }
                    if (valuea) {
                      CFDictionarySetValue(v129, @"ContentProvider", valuea);
                    }
                    if (v131) {
                      CFDictionarySetValue(v129, @"StorefrontID", v131);
                    }
                    if (v115) {
                      CFDictionarySetValue(v129, @"ServiceInformationKey", v115);
                    }
                    int v139 = (uint64_t *)(v108 + 9048);
                    if (!FigReportingAgentCreate(*(const void **)(v108 + 224), *(const void **)(v108 + 8896), v110, v173, v138, 1, v129, *(unsigned char *)(v108 + 339), (void *)(v108 + 9048)))
                    {
                      uint64_t v140 = *v139;
                      if (*v139)
                      {
                        CFStringRef v141 = CFURLCopyHostName(*(CFURLRef *)(v108 + 312));
                        if (v141)
                        {
                          CFStringRef v142 = v141;
                          if (*(unsigned char *)(v172 + 1176))
                          {
                            uint64_t v143 = *(void *)(CMBaseObjectGetVTable() + 16);
                            uint64_t v144 = v143 ? v143 : 0;
                            uint64_t v145 = *(void (**)(uint64_t, uint64_t, uint64_t, CFStringRef, void))(v144 + 48);
                            if (v145) {
                              v145(v140, 0x1EE582B98, 0x1EE584CB8, v142, 0);
                            }
                          }
                          CFRelease(v142);
                        }
                        uint64_t v146 = *v139;
                        uint64_t v147 = *(void *)(CMBaseObjectGetVTable() + 8);
                        if (v147) {
                          uint64_t v148 = v147;
                        }
                        else {
                          uint64_t v148 = 0;
                        }
                        uint64_t v149 = *(void (**)(uint64_t, uint64_t, const void *))(v148 + 56);
                        if (v149) {
                          v149(v146, 0x1EE582B38, v175);
                        }
                      }
                    }
                    CFRelease(v129);
                  }
                  *(void *)(v108 + 9496) = nw_activity_create();
                  *(void *)(*(void *)(v108 + 384) + 1176) = nw_activity_create();
                  *(void *)(*(void *)(v108 + 400) + 1176) = nw_activity_create();
                  *(void *)(*(void *)(v108 + 416) + 1176) = nw_activity_create();
                  if (*(void *)(v108 + 9496))
                  {
                    if (!*(void *)(v108 + 9104) || (nw_activity_set_parent_activity(), *(void *)(v108 + 9496))) {
                      nw_activity_activate();
                    }
                  }
                  if (*(void *)(*(void *)(v108 + 384) + 1176) && *(void *)(v108 + 9496)) {
                    nw_activity_set_parent_activity();
                  }
                  if (*(void *)(*(void *)(v108 + 400) + 1176) && *(void *)(v108 + 9496)) {
                    nw_activity_set_parent_activity();
                  }
                  if (*(void *)(*(void *)(v108 + 416) + 1176) && *(void *)(v108 + 9496)) {
                    nw_activity_set_parent_activity();
                  }
                  if (*(void *)(*(void *)(v108 + 384) + 1176)) {
                    nw_activity_activate();
                  }
                  if (*(void *)(*(void *)(v108 + 400) + 1176)) {
                    nw_activity_activate();
                  }
                  if (*(void *)(*(void *)(v108 + 416) + 1176)) {
                    nw_activity_activate();
                  }
                  FigNetworkInterfaceReporterSamplePhysicalStatistics(*(void *)(v108 + 9120), 0, 0, 0, 0);
                  *(_DWORD *)(v108 + 288) = -1;
                  memset((char *)v178 + 8, 0, 216);
                  segPumpMakeNetworkPredictionInput(v108, (uint64_t)v178);
                  uint64_t v150 = *(void *)(v108 + 104);
                  uint64_t v151 = *(void *)(v108 + 112);
                  *(void *)&v178[0] = v151;
                  *(_OWORD *)((char *)&v178[2] + 8) = xmmword_194998970;
                  BOOL v152 = *(unsigned char *)(v108 + 334) != 0;
                  if (*(unsigned char *)(v108 + 334)) {
                    double v153 = 0.96;
                  }
                  else {
                    double v153 = 0.0;
                  }
                  if (dword_1E9351350)
                  {
                    unsigned int v182 = 0;
                    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                    unsigned int v155 = v182;
                    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT)) {
                      unsigned int v156 = v155;
                    }
                    else {
                      unsigned int v156 = v155 & 0xFFFFFFFE;
                    }
                    if (v156)
                    {
                      double v157 = *(__CFString **)(v108 + 8760);
                      uint64_t v158 = *(void *)(v108 + 120);
                      if (!v157) {
                        double v157 = &stru_1EE53F4B8;
                      }
                      *(_DWORD *)long long v183 = 136316418;
                      *(void *)&v183[4] = "FigBytePumpCreateForHTTPChunk";
                      *(_WORD *)&v183[12] = 2114;
                      *(void *)&v183[14] = v157;
                      *(_WORD *)&v183[22] = 1024;
                      LODWORD(v184) = v151;
                      WORD2(v184) = 1024;
                      *(_DWORD *)((char *)&v184 + 6) = v150;
                      WORD5(v184) = 1024;
                      HIDWORD(v184) = v158;
                      LOWORD(v185) = 1024;
                      *(_DWORD *)((char *)&v185 + 2) = 1;
                      _os_log_send_and_compose_impl();
                    }
                    fig_log_call_emit_and_clean_up_after_send_and_compose();
                  }
                  uint64_t v159 = FigGetAllocatorForMedia();
                  uint64_t v160 = *(void *)v108;
                  float v161 = *(const void **)(v108 + 96);
                  long long v208 = v178[11];
                  long long v209 = v178[12];
                  long long v210 = v178[13];
                  long long v204 = v178[7];
                  long long v205 = v178[8];
                  long long v206 = v178[9];
                  long long v207 = v178[10];
                  long long v200 = v178[3];
                  long long v201 = v178[4];
                  long long v202 = v178[5];
                  long long v203 = v178[6];
                  long long v198 = v178[1];
                  long long v199 = v178[2];
                  *(_OWORD *)&v183[8] = xmmword_194998980;
                  long long v184 = xmmword_194998990;
                  CGFloat v162 = *(const void **)(v108 + 9128);
                  *(void *)long long v183 = v150;
                  long long v185 = xmmword_194998970;
                  long long v186 = 0u;
                  long long v187 = 0u;
                  long long v188 = 0u;
                  long long v189 = 0u;
                  long long v190 = 0u;
                  long long v191 = 0u;
                  double v192 = v153;
                  BOOL v193 = v152;
                  long long v194 = 0u;
                  long long v195 = 0u;
                  memset(v196, 0, sizeof(v196));
                  long long context = v178[0];
                  uint64_t v28 = FigAlternateFilterMonitorCreateForPlaybackBitrate(v159, v160, (uint64_t)segPumpStallRiskCallback, v161, &context, v183, v162, (uint64_t)v181, (CFTypeRef *)(v108 + 9560));
                  if (!v28)
                  {
                    *(unsigned char *)(v172 + 1208) = FigDebugIsInternalBuild();
                    *(_DWORD *)(v108 + 9068) = FigGetCFPreferenceNumberWithDefault();
                    FigNetworkWirelessReportingInterfaceInit();
                    double v163 = (void *)FigRetainProxyRetain();
                    dispatch_async_f(*(dispatch_queue_t *)(v108 + 64), v163, (dispatch_function_t)segPumpAttemptNetworkMonitorSetupDispatch);
                    *a8 = v181;
                    int v181 = 0;
                    goto LABEL_248;
                  }
                }
                else
                {
                  uint64_t v28 = 4294954655;
                }
                goto LABEL_44;
              }
            }
          }
LABEL_43:
          uint64_t v28 = v14;
          goto LABEL_44;
        }
      }
      else
      {
        *(void *)(DerivedStorage + 9472) = 0;
      }
      uint64_t v14 = FigSignalErrorAt();
      goto LABEL_43;
    }
    uint64_t v19 = (const void *)*MEMORY[0x1E4F1CFD0];
    goto LABEL_55;
  }

  return FigSignalErrorAt();
}

uint64_t segPumpSetHTTPRequestOptionsValue(uint64_t a1, const void *a2, const void *a3)
{
  AllocatorForMediCGFloat a = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutableuint64_t Copy = CFDictionaryCreateMutableCopy(AllocatorForMedia, 0, *(CFDictionaryRef *)(a1 + 240));
  if (MutableCopy)
  {
    uint64_t v8 = MutableCopy;
    if (a3) {
      CFDictionarySetValue(MutableCopy, a2, a3);
    }
    else {
      CFDictionaryRemoveValue(MutableCopy, a2);
    }
    CFAllocatorRef v9 = *(const void **)(a1 + 240);
    *(void *)(a1 + 240) = v8;
    CFRetain(v8);
    if (v9) {
      CFRelease(v9);
    }
    CFRelease(v8);
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}