uint64_t FigReportingModeratorCreateForStreamingAssetDownloader(uint64_t a1, const void *a2, void *a3)
{
  uint64_t v5;
  uint64_t DerivedStorage;
  CFTypeRef v7;

  fig_note_initialize_category_with_default_work_cf();
  fig_note_initialize_category_with_default_work_cf();
  if (!a3) {
    return 4294949785;
  }
  FigReportingModeratorGetClassID();
  v5 = CMDerivedObjectCreate();
  if (!v5)
  {
    DerivedStorage = CMBaseObjectGetDerivedStorage();
    if (a2) {
      v7 = CFRetain(a2);
    }
    else {
      v7 = 0;
    }
    *(void *)DerivedStorage = v7;
    v5 = 0;
    *(void *)(DerivedStorage + 8) = FigGetUpTimeNanoseconds();
    *(unsigned char *)(DerivedStorage + 40) = 0;
    *a3 = 0;
  }
  return v5;
}

void downloaderFinalize()
{
  DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
  if (DerivedStorage)
  {
    v1 = *DerivedStorage;
    if (v1)
    {
      CFRelease(v1);
    }
  }
}

__CFString *downloaderCopyDebugDescription()
{
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"FigStreamingDownloaderReportingModerator:");
  return Mutable;
}

uint64_t downloaderModeratorProcessEventAndCopyKeyArray(uint64_t a1, int a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = 4294949785;
  if (a3 && DerivedStorage)
  {
    uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    uint64_t v8 = UpTimeNanoseconds;
    switch(a2)
    {
      case 701:
        uint64_t v13 = *(void *)DerivedStorage;
        uint64_t v14 = *(void *)(DerivedStorage + 24);
        uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v15) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = 0;
        }
        v18 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v16 + 88);
        if (v18) {
          v18(v13, 0x1EE582C58, 0x1EE558FF8, (v8 - v14) / 0xF4240uLL);
        }
        break;
      case 704:
        *(unsigned char *)(DerivedStorage + 41) = 1;
        *(void *)(DerivedStorage + 16) = UpTimeNanoseconds;
        break;
      case 705:
        if (!*(unsigned char *)(DerivedStorage + 40))
        {
          uint64_t v9 = *(void *)DerivedStorage;
          uint64_t v10 = *(void *)(DerivedStorage + 8);
          uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v11) {
            uint64_t v12 = v11;
          }
          else {
            uint64_t v12 = 0;
          }
          v19 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v12 + 88);
          if (v19) {
            v19(v9, 0x1EE582C58, 0x1EE558C18, (v8 - v10) / 0xF4240uLL);
          }
          *(unsigned char *)(DerivedStorage + 40) = 1;
          *(void *)(DerivedStorage + 24) = v8;
        }
        if (*(unsigned char *)(DerivedStorage + 41))
        {
          uint64_t v20 = *(void *)DerivedStorage;
          uint64_t v21 = *(void *)(DerivedStorage + 16);
          uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v22) {
            uint64_t v23 = v22;
          }
          else {
            uint64_t v23 = 0;
          }
          v24 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v23 + 88);
          if (v24) {
            v24(v20, 0x1EE582C58, 0x1EE558D78, (v8 - v21) / 0xF4240uLL);
          }
          uint64_t v25 = *(void *)DerivedStorage;
          uint64_t v26 = *(void *)(DerivedStorage + 16);
          uint64_t v27 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v27) {
            uint64_t v28 = v27;
          }
          else {
            uint64_t v28 = 0;
          }
          v29 = *(void (**)(uint64_t, uint64_t, __CFString *, unint64_t))(v28 + 64);
          if (v29) {
            v29(v25, 0x1EE582C58, @"PauseTime", (v8 - v26) / 0xF4240uLL);
          }
          *(unsigned char *)(DerivedStorage + 41) = 0;
        }
        else
        {
          *(void *)(DerivedStorage + 32) = v8;
        }
        uint64_t v30 = *(void *)DerivedStorage;
        uint64_t v31 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v31) {
          uint64_t v32 = v31;
        }
        else {
          uint64_t v32 = 0;
        }
        v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v32 + 104);
        if (v33) {
          v33(v30, 0x1EE582C58, 0x1EE558F38);
        }
        v17 = &kFigReportingEventKeysArray_DownloadStartEvent;
LABEL_41:
        MEMORY[0x19970EE10](&fsdrm_copyEventKeyArray_sCreateStaticKeyArrayFromEventKeysOnce, fsdrm_createStaticKeyArrayFromEventKeys);
        goto LABEL_42;
      default:
        MEMORY[0x19970EE10](&fsdrm_copyEventKeyArray_sCreateStaticKeyArrayFromEventKeysOnce, fsdrm_createStaticKeyArrayFromEventKeys);
        if (a2 != 707) {
          goto LABEL_44;
        }
        v17 = &kFigReportingEventKeysArray_DownloadErrorEvent;
LABEL_42:
        if (*v17)
        {
          CFTypeRef v34 = CFRetain((CFTypeRef)*v17);
LABEL_45:
          uint64_t result = 0;
          *a3 = v34;
          return result;
        }
LABEL_44:
        CFTypeRef v34 = 0;
        goto LABEL_45;
    }
    v17 = &kFigReportingEventKeysArray_DownloadEndedEvent;
    goto LABEL_41;
  }
  return result;
}

uint64_t downloaderModeratorPostProcessPayloadForEvent(int a1, int a2, CFDictionaryRef theDict)
{
  if (theDict && CFDictionaryGetCount(theDict) >= 1)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theDict);
    if (Copy)
    {
      CFDictionaryRef v6 = Copy;
      CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)fsdrm_stringifyArrayFunc, theDict);
      CFRelease(v6);
    }
    uint64_t v10 = 0;
    value = 0;
    CFDictionaryRef v7 = CFDictionaryCreateCopy(v4, theDict);
    if (v7)
    {
      CFDictionaryRef v8 = v7;
      CFDictionaryGetValueIfPresent(v7, @"TotBytesDown", (const void **)&value);
      if (value)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt64Type, &v10);
        uint64_t v10 = 1000000 * (v10 / 1000000);
        FigCFDictionarySetInt64();
      }
      CFRelease(v8);
    }
  }
  return 0;
}

CFArrayRef fsdrm_createStaticKeyArrayFromEventKeys()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  memcpy(v2, off_1E578A538, 0x168uLL);
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)v2, 45, 0);
  kFigReportingEventKeysArray_DownloadStartEvent = (uint64_t)result;
  if (result)
  {
    memcpy(v2, off_1E578A6A0, sizeof(v2));
    CFArrayRef result = CFArrayCreate(v0, (const void **)v2, 51, 0);
    kFigReportingEventKeysArray_DownloadEndedEvent = (uint64_t)result;
    if (result)
    {
      memcpy(v2, off_1E578A838, 0x138uLL);
      CFArrayRef result = CFArrayCreate(v0, (const void **)v2, 39, 0);
      kFigReportingEventKeysArray_DownloadErrorEvent = (uint64_t)result;
      if (result)
      {
        *(_OWORD *)&v2[160] = xmmword_1E578AA10;
        *(_OWORD *)&v2[176] = *(_OWORD *)&off_1E578AA20;
        *(_OWORD *)&v2[192] = xmmword_1E578AA30;
        *(void *)&v2[208] = &kFigReportingEventKey_PlaylistHasLosslessAudio;
        *(_OWORD *)&v2[96] = xmmword_1E578A9D0;
        *(_OWORD *)&v2[112] = *(_OWORD *)&off_1E578A9E0;
        *(_OWORD *)&v2[128] = xmmword_1E578A9F0;
        *(_OWORD *)&v2[144] = *(_OWORD *)&off_1E578AA00;
        *(_OWORD *)&v2[32] = xmmword_1E578A990;
        *(_OWORD *)&v2[48] = *(_OWORD *)&off_1E578A9A0;
        *(_OWORD *)&v2[64] = xmmword_1E578A9B0;
        *(_OWORD *)&v2[80] = *(_OWORD *)&off_1E578A9C0;
        *(_OWORD *)v2 = xmmword_1E578A970;
        *(_OWORD *)&v2[16] = *(_OWORD *)&off_1E578A980;
        CFArrayRef result = CFArrayCreate(v0, (const void **)v2, 27, 0);
        kFigReportingEventKeysArray_DownloadPausedEvent = (uint64_t)result;
      }
    }
  }
  return result;
}

void fsdrm_stringifyArrayFunc(const void *a1, const __CFArray *a2, __CFDictionary *a3)
{
  if (a3)
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(a2))
    {
      CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      if (Mutable)
      {
        CFDictionaryRef v8 = Mutable;
        if (CFArrayGetCount(a2) >= 1)
        {
          CFIndex v9 = 0;
          do
          {
            CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a2, v9);
            if (ValueAtIndex)
            {
              CFNumberRef v11 = ValueAtIndex;
              CFTypeID v12 = CFNumberGetTypeID();
              if (v12 == CFGetTypeID(v11))
              {
                uint64_t valuePtr = 0;
                CFNumberGetValue(v11, kCFNumberSInt64Type, &valuePtr);
                CFStringAppendFormat(v8, 0, @"%lld", valuePtr);
              }
              else
              {
                CFTypeID v13 = CFStringGetTypeID();
                if (v13 == CFGetTypeID(v11)) {
                  CFStringAppendFormat(v8, 0, @"%@", v11);
                }
              }
            }
            else
            {
              CFStringAppend(v8, @"-");
            }
            if (++v9 < CFArrayGetCount(a2)) {
              CFStringAppend(v8, @",");
            }
          }
          while (v9 < CFArrayGetCount(a2));
        }
        CFDictionarySetValue(a3, a1, v8);
        CFRelease(v8);
      }
    }
  }
}

void CEA608Parser::CEA608Parser(CEA608Parser *this, int a2, int (*a3)(uint64_t, uint64_t *, uint64_t *, __CFData *, __CFData *, void *), void *a4, CEA608Renderer *a5)
{
  TextParserBase::TextParserBase(this, a2, a3, a4);
  *(void *)uint64_t v6 = &unk_1EE4FF430;
  *(void *)(v6 + 64) = 0;
  *(void *)(v6 + 72) = 0;
  *(void *)(v6 + 56) = 0;
  *(unsigned char *)(v6 + 80) = 0;
  *(void *)(v6 + 88) = a5;
  *(_WORD *)(v6 + 96) = 0;
}

void CEA608Parser::~CEA608Parser(CEA608Parser *this)
{
  *(void *)this = &unk_1EE4FF430;
  uint64_t v2 = *((void *)this + 11);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  TextParserBase::~TextParserBase(this);
}

{
  uint64_t vars8;

  CEA608Parser::~CEA608Parser(this);

  JUMPOUT(0x199710860);
}

uint64_t CEA608Parser::NextInterestingTime(CEA608Parser *this, uint64_t a2, uint64_t *a3, int a4)
{
  if (a3)
  {
    uint64_t v4 = 1173985215403 * *((_DWORD *)this + 12);
    uint64_t v5 = (int)((v4 >> 45) + ((unint64_t)v4 >> 63));
    if (a4 < 0) {
      uint64_t v5 = -v5;
    }
    *a3 = v5 + a2;
  }
  return 0;
}

uint64_t CEA608Parser::AdvanceToTime(CFDataRef *this, uint64_t a2)
{
  uint64_t v4 = 30000 * a2;
  uint64_t v5 = *((int *)this + 12);
  CFIndex Length = CFDataGetLength(this[3]);
  BOOL v7 = Length > 0;
  CFIndex v9 = this + 4;
  CFDataRef v8 = this[4];
  BOOL v10 = (uint64_t)v8 <= a2 && (uint64_t)v8 + (uint64_t)this[5] > a2;
  uint64_t v11 = 0;
  uint64_t v12 = v4 / v5;
  if (Length < 1 || v10)
  {
    BOOL v13 = 0;
  }
  else
  {
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v11 = ((uint64_t (*)(char *, uint64_t *, uint64_t *, void, void, CFDataRef))this[1])((char *)v8 + (void)this[5], &v38, &v37, 0, 0, this[2]);
    if (v11)
    {
      BOOL v13 = 0;
    }
    else
    {
      uint64_t v14 = v37;
      if (v37 <= *((_DWORD *)this + 12) / 2) {
        uint64_t v14 = (uint64_t)(*((_DWORD *)this + 12) + (*((int *)this + 12) < 0)) >> 1;
      }
      uint64_t v15 = v14 + v38;
      BOOL v13 = v38 <= a2 && v15 > a2;
      BOOL v7 = 1;
    }
  }
  if (!v7 || v10 || v13)
  {
    if ((uint64_t)this[8] >= v12 || v11 != 0) {
      goto LABEL_57;
    }
    while (1)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(this[3]);
      CFIndex v20 = CFDataGetLength(this[3]);
      uint64_t v21 = (uint64_t)this[7];
      if (v21 >= v20)
      {
        uint64_t v11 = 0;
      }
      else
      {
        uint64_t v11 = 0;
        uint64_t v22 = (uint64_t)this[8];
        do
        {
          if (v22 >= v12 || v11) {
            break;
          }
          uint64_t v38 = v21;
          uint64_t v11 = CEA608Parser::ProcessCodePair((CEA608Parser *)this, MutableBytePtr, &v38, v20, 0);
          uint64_t v21 = v38;
          CFDataRef v23 = this[7];
          BOOL v24 = __OFSUB__(v38, v23);
          uint64_t v25 = v38 - (void)v23;
          if (v25 < 0 != v24) {
            ++v25;
          }
          uint64_t v22 = (uint64_t)this[8] + 1001 * (v25 >> 1);
          this[7] = (CFDataRef)v38;
          this[8] = (CFDataRef)v22;
        }
        while (v21 < v20);
      }
      uint64_t v26 = (char *)a2;
      if (!v7 || ((uint64_t v26 = (char *)this[5] + *v9, (uint64_t)v26 < a2) ? (v27 = v11 == 0) : (v27 = 0), v27))
      {
        uint64_t v28 = ((uint64_t (*)(char *, char *, char *, CFDataRef, void, CFDataRef))this[1])(v26, (char *)this + 32, (char *)this + 40, this[3], 0, this[2]);
        if (v28)
        {
          uint64_t v11 = v28;
          goto LABEL_57;
        }
        CFDataRef v29 = this[3];
        uint64_t v30 = 30000 * (uint64_t)this[4] / *((int *)this + 12);
        this[7] = 0;
        this[8] = (CFDataRef)v30;
        unint64_t v31 = CFDataGetLength(v29);
        if (v31 >= 8 && (int64_t v32 = v31, v33 = (unsigned int *)CFDataGetMutableBytePtr(this[3]), v33[1] == 1952539747))
        {
          signed int v34 = bswap32(*v33);
          if (v32 < v34) {
            signed int v34 = v32;
          }
          if (v32 > v34) {
            CFDataSetLength(this[3], v34);
          }
          uint64_t v11 = 0;
          this[7] = (CFDataRef)8;
        }
        else
        {
          uint64_t v11 = 0;
        }
      }
      else if (v21 == v20)
      {
        this[8] = (CFDataRef)v12;
      }
      if ((uint64_t)this[8] < v12)
      {
        LOBYTE(v7) = 1;
        if (!v11) {
          continue;
        }
      }
      goto LABEL_57;
    }
  }
  CFDataRef v17 = this[11];
  if (v17) {
    (*(void (**)(CFDataRef))(*(void *)v17 + 208))(v17);
  }
  CFDataSetLength(this[3], 0);
  *CFIndex v9 = 0;
  this[5] = 0;
  this[7] = 0;
  this[8] = 0;
LABEL_57:
  this[9] = (CFDataRef)v12;
  CFDataRef v35 = this[11];
  if (v35) {
    (*(void (**)(CFDataRef, uint64_t))(*(void *)v35 + 24))(v35, v12);
  }
  return v11;
}

uint64_t CEA608Parser::ProcessCodePair(CEA608Parser *this, const unsigned __int8 *a2, uint64_t *a3, uint64_t a4, int a5)
{
  uint64_t result = 4294967246;
  if (!a2) {
    return result;
  }
  if (!a3) {
    return result;
  }
  uint64_t v8 = a4;
  if (a4 < 1) {
    return result;
  }
  uint64_t v9 = *a3;
  if (*a3 >= a4) {
    return result;
  }
  while (1)
  {
    if ((v9 & 1) == 0)
    {
      uint64_t v12 = *((void *)this + 11);
      if (v12)
      {
        (*(void (**)(uint64_t, void))(*(void *)v12 + 24))(v12, *((void *)this + 8));
        uint64_t v9 = *a3;
      }
    }
    unsigned __int8 v13 = a2[v9];
    if ((v13 & 0x70) == 0x10) {
      break;
    }
    unsigned int v14 = v13 & 0x7F;
    if (v14 < 0x20)
    {
      if (a5 == 2 && v14 - 1 <= 0xE)
      {
        if (v9 + 1 < v8)
        {
          uint64_t result = 0;
          *((unsigned char *)this + 80) = 1;
          *a3 = v9 + 2;
          return result;
        }
        goto LABEL_29;
      }
LABEL_16:
      *a3 = v9 + 1;
      if (v9 + 1 >= v8) {
        return 0;
      }
      uint64_t v8 = v9 + 2;
      ++v9;
      goto LABEL_18;
    }
    if (*((unsigned char *)this + 80)) {
      goto LABEL_16;
    }
    *((_WORD *)this + 48) = 0;
    uint64_t result = CEA608Parser::ProcessStandardCharacterCode(this, a2, a3, v8);
    if (result) {
      return result;
    }
    uint64_t v9 = *a3;
    if (*a3 >= v8) {
      return 0;
    }
    uint64_t v8 = v9 + 1;
LABEL_18:
    uint64_t result = 4294967246;
    if (v8 < 1 || v9 >= v8) {
      return result;
    }
  }
  if (v9 + 1 >= v8)
  {
LABEL_29:
    return FigSignalErrorAt();
  }
  *((unsigned char *)this + 80) = 0;

  return CEA608Parser::ProcessControlCode(this, a2, a3, v8);
}

uint64_t CEA608Parser::Reset(uint64_t this)
{
  *(_WORD *)(this + 96) = 0;
  return this;
}

uint64_t CEA608Parser::ProcessControlCode(CEA608Parser *this, const unsigned __int8 *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = 4294967246;
  if (!a2) {
    return v4;
  }
  if (!a3) {
    return v4;
  }
  if (a4 < 1) {
    return v4;
  }
  uint64_t v5 = *a3;
  if (*a3 + 1 >= a4) {
    return v4;
  }
  int v6 = a2[v5];
  unsigned __int8 v7 = a2[v5 + 1];
  unsigned int v8 = v7 & 0x7F;
  if (__PAIR64__(*((unsigned __int8 *)this + 97), *((unsigned __int8 *)this + 96)) != __PAIR64__(v8, v6 & 0x7F))
  {
    *((unsigned char *)this + 96) = v6 & 0x7F;
    *((unsigned char *)this + 97) = v8;
    int v9 = v6 & 0x77777777;
    if ((v6 & 0x77777777) == 0x11)
    {
      int v11 = v7 & 0x70;
      if (v11 == 48) {
        return CEA608Parser::ProcessSpecialCharacterCode(this, a2, a3, a4);
      }
      if (v11 == 32) {
        return CEA608Parser::ProcessMidRowCode(this, a2, a3, a4);
      }
      if (v8 >= 0x40) {
        return CEA608Parser::ProcessPreambleAddressCode(this, a2, a3, a4);
      }
    }
    else
    {
      if (v9 != 16)
      {
        if ((v6 & 0x76 | 8) == 0x1A)
        {
          if ((v7 & 0x60) == 0x20) {
            return CEA608Parser::ProcessExtendedCharacterCode(this, a2, a3, a4);
          }
          if (v8 >= 0x40) {
            return CEA608Parser::ProcessPreambleAddressCode(this, a2, a3, a4);
          }
          goto LABEL_36;
        }
        if ((v6 & 0x76) == 0x14)
        {
          if ((v7 & 0x70) != 0x20)
          {
            if (v8 >= 0x40) {
              return CEA608Parser::ProcessPreambleAddressCode(this, a2, a3, a4);
            }
            goto LABEL_36;
          }
        }
        else
        {
          if (v9 == 22 && v8 >= 0x40) {
            return CEA608Parser::ProcessPreambleAddressCode(this, a2, a3, a4);
          }
          if (v9 != 23) {
            goto LABEL_36;
          }
          if (v8 - 33 > 2)
          {
            if (v8 - 45 <= 2) {
              return CEA608Parser::ProcessMidRowCode(this, a2, a3, a4);
            }
            if (v8 >= 0x40) {
              return CEA608Parser::ProcessPreambleAddressCode(this, a2, a3, a4);
            }
            goto LABEL_36;
          }
        }
        return CEA608Parser::ProcessMiscControlCode(this, a2, a3, a4);
      }
      if ((v7 & 0x70) == 0x20) {
        return CEA608Parser::ProcessMidRowCode(this, a2, a3, a4);
      }
      if ((v7 & 0x60) == 0x40) {
        return CEA608Parser::ProcessPreambleAddressCode(this, a2, a3, a4);
      }
    }
LABEL_36:
    uint64_t v4 = 0;
    goto LABEL_37;
  }
  uint64_t v4 = 0;
  *((_WORD *)this + 48) = 0;
LABEL_37:
  *a3 = v5 + 2;
  return v4;
}

uint64_t CEA608Parser::ProcessStandardCharacterCode(CEA608Parser *this, const unsigned __int8 *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result = 4294967246;
  if (a2)
  {
    if (a3)
    {
      if ((a4 & 0x8000000000000000) == 0)
      {
        uint64_t v6 = *a3;
        if (*a3 <= a4)
        {
          uint64_t result = 0;
          if (a4)
          {
            if (v6 != a4)
            {
              unsigned __int8 v7 = a2[v6];
              *a3 = v6 + 1;
              uint64_t result = *((void *)this + 11);
              if (result)
              {
                (*(void (**)(uint64_t, void, void, void))(*(void *)result + 112))(result, 0, (unsigned __int16)StandardCharacters[(v7 & 0x7F) - 32], 0);
                return 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t CEA608Parser::ProcessMidRowCode(CEA608Parser *this, const unsigned __int8 *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result = 4294967246;
  if (!a2) {
    return result;
  }
  if (!a3) {
    return result;
  }
  if (a4 < 1) {
    return result;
  }
  uint64_t v6 = *a3;
  if (*a3 + 1 >= a4) {
    return result;
  }
  int v7 = a2[v6];
  int v8 = v7 & 0x7F;
  unsigned int v9 = a2[v6 + 1] & 0x7F;
  *a3 = v6 + 2;
  int v10 = v7 & 0x7E;
  if (v8 == 31 || v10 == 24) {
    char v12 = 2;
  }
  else {
    char v12 = 1;
  }
  if (v8 == 23 || v10 == 16) {
    unsigned __int8 v14 = 1;
  }
  else {
    unsigned __int8 v14 = v12;
  }
  if ((v7 & 0x77777777) == 0x10 && v9 >= 0x20 && v9 <= 0x2F)
  {
    uint64_t v15 = (char *)&AttributeCodes1 + 32 * v9 - 1024;
LABEL_21:
    int v16 = 1;
    goto LABEL_34;
  }
  if ((v7 & 0x77) == 0x11 && v9 >= 0x20 && v9 <= 0x2F)
  {
    int v16 = 0;
    uint64_t v15 = (char *)(&MidRowCodes + 4 * v9 - 128);
  }
  else
  {
    int v16 = 0;
    BOOL v17 = v8 == 31 || v8 == 23;
    uint64_t v15 = (char *)&AttributeCodes1;
    if (v17 && v9 >= 0x2D && v9 <= 0x2F)
    {
      uint64_t v15 = (char *)&AttributeCodes2 + 32 * v9 - 1440;
      goto LABEL_21;
    }
  }
LABEL_34:
  uint64_t result = *((void *)this + 11);
  if (result)
  {
    if (v16)
    {
      (*(void (**)(uint64_t, void))(*(void *)result + 120))(result, v14);
      uint64_t result = *((void *)this + 11);
    }
    (*(void (**)(uint64_t, void, char *))(*(void *)result + 152))(result, v14, v15);
    return 0;
  }
  return result;
}

uint64_t CEA608Parser::ProcessPreambleAddressCode(CEA608Parser *this, const unsigned __int8 *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = 4294967246;
  if (a2)
  {
    if (a3)
    {
      if (a4 >= 1)
      {
        uint64_t v5 = *a3;
        if (*a3 + 1 < a4)
        {
          int v6 = a2[v5];
          uint64_t v7 = a2[v5 + 1] & 0x7F;
          *a3 = v5 + 2;
          if ((v6 & 0x78) == 0x18) {
            unsigned __int8 v8 = 2;
          }
          else {
            unsigned __int8 v8 = 1;
          }
          uint64_t v9 = -96;
          if (v7 < 0x60) {
            uint64_t v9 = -64;
          }
          int v10 = &(&(&PreambleAddressCodes)[2 * v9])[2 * v7];
          if (v7 <= 0x3F) {
            int v10 = &PreambleAddressCodes;
          }
          int v11 = (v6 & 0x77777777) - 16;
          unsigned __int8 v12 = 11;
          switch(v11)
          {
            case 0:
              break;
            case 1:
              BOOL v13 = v7 >= 0x60;
              unsigned __int8 v12 = 1;
              goto LABEL_20;
            case 2:
              BOOL v13 = v7 >= 0x60;
              unsigned __int8 v12 = 3;
              goto LABEL_20;
            case 3:
              BOOL v13 = v7 >= 0x60;
              unsigned __int8 v12 = 12;
              goto LABEL_20;
            case 4:
              BOOL v13 = v7 >= 0x60;
              unsigned __int8 v12 = 14;
              goto LABEL_20;
            case 5:
              BOOL v13 = v7 >= 0x60;
              unsigned __int8 v12 = 5;
              goto LABEL_20;
            case 6:
              BOOL v13 = v7 >= 0x60;
              unsigned __int8 v12 = 7;
              goto LABEL_20;
            case 7:
              BOOL v13 = v7 >= 0x60;
              unsigned __int8 v12 = 9;
LABEL_20:
              if (v13) {
                ++v12;
              }
              break;
            default:
              unsigned __int8 v12 = 1;
              break;
          }
          uint64_t v14 = *((void *)this + 11);
          if (v14) {
            (*(void (**)(uint64_t, void, void, void, void))(*(void *)v14 + 144))(v14, v8, v12, *v10, *((unsigned __int8 *)v10 + 8));
          }
          return 0;
        }
      }
    }
  }
  return v4;
}

uint64_t CEA608Parser::ProcessSpecialCharacterCode(CEA608Parser *this, const unsigned __int8 *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = 4294967246;
  if (!a2) {
    return v4;
  }
  if (!a3) {
    return v4;
  }
  if (a4 < 1) {
    return v4;
  }
  uint64_t v5 = *a3;
  if (*a3 + 1 >= a4) {
    return v4;
  }
  int v6 = a2[v5] & 0x7F;
  unsigned int v7 = a2[v5 + 1] & 0x7F;
  *a3 = v5 + 2;
  if (v6 == 17 && v7 >= 0x30 && v7 < 0x40)
  {
    uint64_t v8 = 1;
  }
  else
  {
    BOOL v9 = 0;
    uint64_t v10 = 32;
    uint64_t v8 = 1;
    if (v6 != 25 || v7 < 0x30 || v7 > 0x3F) {
      goto LABEL_14;
    }
    uint64_t v8 = 2;
  }
  unsigned int v11 = v7 - 48;
  uint64_t v10 = SpecialCharacters[v11];
  BOOL v9 = v11 == 9;
LABEL_14:
  uint64_t v12 = *((void *)this + 11);
  if (v12) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, BOOL))(*(void *)v12 + 112))(v12, v8, v10, v9);
  }
  return 0;
}

uint64_t CEA608Parser::ProcessExtendedCharacterCode(CEA608Parser *this, const unsigned __int8 *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result = 4294967246;
  if (a2)
  {
    if (a3)
    {
      if (a4 >= 1)
      {
        uint64_t v6 = *a3;
        if (*a3 + 1 < a4)
        {
          int v7 = a2[v6] & 0x7F;
          unsigned int v8 = a2[v6 + 1] & 0x7F;
          *a3 = v6 + 2;
          if (v7 == 18 && v8 >= 0x20 && v8 < 0x40)
          {
            uint64_t v9 = 1;
LABEL_9:
            uint64_t v10 = (unsigned __int16 *)&ExtendedCharacters1;
LABEL_23:
            uint64_t v11 = v10[v8 - 32];
LABEL_24:
            uint64_t result = *((void *)this + 11);
            if (result)
            {
              (*(void (**)(uint64_t, uint64_t))(*(void *)result + 120))(result, v9);
              (*(void (**)(void, uint64_t, uint64_t, void))(**((void **)this + 11) + 112))(*((void *)this + 11), v9, v11, 0);
              return 0;
            }
            return result;
          }
          if (v7 == 19 && v8 >= 0x20 && v8 < 0x40)
          {
            uint64_t v9 = 1;
          }
          else
          {
            if (v7 == 26 && v8 >= 0x20 && v8 < 0x40)
            {
              uint64_t v9 = 2;
              goto LABEL_9;
            }
            uint64_t v11 = 32;
            uint64_t v9 = 1;
            if (v7 != 27 || v8 < 0x20 || v8 > 0x3F) {
              goto LABEL_24;
            }
            uint64_t v9 = 2;
          }
          uint64_t v10 = (unsigned __int16 *)&ExtendedCharacters2;
          goto LABEL_23;
        }
      }
    }
  }
  return result;
}

uint64_t CEA608Parser::ProcessMiscControlCode(CEA608Parser *this, const unsigned __int8 *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result = 4294967246;
  if (a2)
  {
    if (a3)
    {
      if (a4 >= 1)
      {
        uint64_t v6 = *a3;
        if (*a3 + 1 < a4)
        {
          int v7 = a2[v6];
          unsigned __int8 v8 = a2[v6 + 1];
          *a3 = v6 + 2;
          int v9 = v7 & 0x7E;
          BOOL v10 = (v7 & 0x7F) == 0x1F || v9 == 28;
          char v11 = v10 ? 2 : 1;
          BOOL v12 = (v7 & 0x7F) == 0x17 || v9 == 20;
          unsigned __int8 v13 = v12 ? 1 : v11;
          uint64_t result = *((void *)this + 11);
          if (result)
          {
            int v14 = v8 & 0x7F;
            unsigned __int8 v15 = v14 - 32;
            switch(v14)
            {
              case ' ':
                (*(void (**)(uint64_t, void))(*(void *)result + 80))(result, v13);
                goto LABEL_39;
              case '!':
                if ((v7 & 0x77777777) == 0x14) {
                  (*(void (**)(uint64_t, void))(*(void *)result + 120))(result, v13);
                }
                goto LABEL_23;
              case '""':
              case '#':
LABEL_23:
                uint64_t result = 0;
                if (v7 > 150)
                {
                  if (v7 != 159 && v7 != 151) {
                    return result;
                  }
                }
                else if (v7 != 23 && v7 != 31)
                {
                  return result;
                }
                (*(void (**)(void, void, void))(**((void **)this + 11) + 160))(*((void *)this + 11), v13, v15);
LABEL_39:
                uint64_t result = 0;
                break;
              case '$':
                (*(void (**)(uint64_t, void))(*(void *)result + 136))(result, v13);
                goto LABEL_39;
              case '%':
              case '&':
              case '\'':
                (*(void (**)(uint64_t, void, void))(*(void *)result + 88))(result, v13, (v14 - 35));
                goto LABEL_39;
              case '(':
                (*(void (**)(uint64_t, void))(*(void *)result + 168))(result, v13);
                goto LABEL_39;
              case ')':
                (*(void (**)(uint64_t, void))(*(void *)result + 96))(result, v13);
                goto LABEL_39;
              case '*':
                (*(void (**)(uint64_t, void))(*(void *)result + 192))(result, v13);
                goto LABEL_39;
              case '+':
                (*(void (**)(uint64_t, void))(*(void *)result + 200))(result, v13);
                goto LABEL_39;
              case ',':
                (*(void (**)(uint64_t, void))(*(void *)result + 176))(result, v13);
                goto LABEL_39;
              case '-':
                (*(void (**)(uint64_t, void))(*(void *)result + 128))(result, v13);
                goto LABEL_39;
              case '.':
                (*(void (**)(uint64_t, void))(*(void *)result + 184))(result, v13);
                goto LABEL_39;
              case '/':
                (*(void (**)(uint64_t, void))(*(void *)result + 104))(result, v13);
                goto LABEL_39;
              default:
                goto LABEL_39;
            }
          }
        }
      }
    }
  }
  return result;
}

void CEA608Renderer::MemoryRow::MemoryRow(CEA608Renderer::MemoryRow *this, unsigned __int16 *a2)
{
  *((void *)this + 32) = a2;
  operator new();
}

BOOL CEA608Renderer::MemoryRow::IsDisplayable(CEA608Renderer::MemoryRow *this)
{
  if (*(unsigned char *)(*(void *)this + 16)) {
    return 1;
  }
  unint64_t v2 = 0;
  do
  {
    unint64_t v3 = v2;
    if (v2 == 31) {
      break;
    }
    ++v2;
  }
  while (!*(unsigned char *)(*((void *)this + v3 + 1) + 16));
  return v3 < 0x1F;
}

uint64_t CEA608Renderer::MemoryRow::GetStyleForCell(uint64_t result, unsigned int a2, uint64_t a3, unsigned char *a4, BOOL *a5)
{
  *(_OWORD *)a3 = DefaultStyle;
  *(_OWORD *)(a3 + 16) = unk_1E578B2B8;
  uint64_t v5 = *(void *)(result + 8 * a2 - 8);
  *a5 = *(void *)(v5 + 8) != 0;
  LODWORD(v5) = *(unsigned __int8 *)(v5 + 16);
  *a4 = v5;
  if (v5) {
    BOOL v6 = a2 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    unsigned __int8 v7 = 1;
    do
    {
      uint64_t v8 = v7 - 1;
      uint64_t v9 = *(void *)(result + 8 * v8);
      BOOL v10 = *(_OWORD **)v9;
      if (*(void *)v9)
      {
        long long v11 = v10[1];
        *(_OWORD *)a3 = *v10;
        *(_OWORD *)(a3 + 16) = v11;
        uint64_t v9 = *(void *)(result + 8 * v8);
      }
      uint64_t v12 = *(void *)(v9 + 8);
      if (v12)
      {
        if (*(void *)v12) {
          *(void *)a3 = *(void *)v12;
        }
        uint64_t v13 = *(void *)(v12 + 8);
        if (v13) {
          *(void *)(a3 + 8) = v13;
        }
        int v14 = *(_DWORD *)(v12 + 16);
        if (v14) {
          *(_DWORD *)(a3 + 16) = v14;
        }
        int v15 = *(_DWORD *)(v12 + 20);
        if (v15) {
          *(_DWORD *)(a3 + 20) = v15;
        }
        int v16 = *(_DWORD *)(v12 + 24);
        if (v16) {
          *(_DWORD *)(a3 + 24) = v16;
        }
      }
      ++v7;
    }
    while (a2 >= v7);
  }
  return result;
}

uint64_t CEA608Renderer::MemoryRow::GetNextStyleChange(CEA608Renderer::MemoryRow *this, unsigned int a2)
{
  unsigned __int8 v2 = a2;
  long long v15 = 0u;
  long long v16 = 0u;
  __int16 v14 = 0;
  CEA608Renderer::MemoryRow::GetStyleForCell((uint64_t)this, a2, (uint64_t)&v15, (unsigned char *)&v14 + 1, (BOOL *)&v14);
  while (++v2 <= 0x20u)
  {
    uint64_t v4 = *((void *)this + v2 - 1);
    uint64_t v5 = *(long long **)v4;
    if (*(void *)v4)
    {
      long long v6 = v5[1];
      long long v15 = *v5;
      long long v16 = v6;
    }
    uint64_t v7 = *(void *)(v4 + 8);
    if (v7)
    {
      uint64_t v8 = *(float **)v7;
      if (*(void *)v7) {
        BOOL v9 = (void)v15 == 0;
      }
      else {
        BOOL v9 = 1;
      }
      if (!v9
        && (*v8 != *(float *)v15
         || v8[1] != *(float *)(v15 + 4)
         || v8[2] != *(float *)(v15 + 8)
         || v8[3] != *(float *)(v15 + 12)))
      {
        return v2;
      }
      BOOL v10 = *(float **)(v7 + 8);
      BOOL v11 = !v10 || *((void *)&v15 + 1) == 0;
      if (!v11
        && (*v10 != **((float **)&v15 + 1)
         || v10[1] != *(float *)(*((void *)&v15 + 1) + 4)
         || v10[2] != *(float *)(*((void *)&v15 + 1) + 8)
         || v10[3] != *(float *)(*((void *)&v15 + 1) + 12)))
      {
        return v2;
      }
      if (*(_DWORD *)(v7 + 16) || *(_DWORD *)(v7 + 20)) {
        return v2;
      }
      if (*(_DWORD *)(v7 + 24) || v14 == 0) {
        return v2;
      }
    }
    else if ((_BYTE)v14)
    {
      return v2;
    }
    if (HIBYTE(v14) != *(unsigned __int8 *)(v4 + 16)) {
      return v2;
    }
  }
  return 33;
}

BOOL CEA608Renderer::MemoryRow::IsDirty(CEA608Renderer::MemoryRow *this)
{
  if (*(unsigned char *)(*(void *)this + 32)) {
    return 1;
  }
  unint64_t v2 = 0;
  do
  {
    unint64_t v3 = v2;
    if (v2 == 31) {
      break;
    }
    ++v2;
  }
  while (!*(unsigned char *)(*((void *)this + v3 + 1) + 32));
  return v3 < 0x1F;
}

void CEA608Renderer::Memory::Memory(CEA608Renderer::Memory *this)
{
  *(_WORD *)this = 271;
  operator new[]();
}

void sub_193F1EF5C(_Unwind_Exception *a1)
{
  MEMORY[0x199710860](v1, 0x30C408693532ALL);
  _Unwind_Resume(a1);
}

void CEA608Renderer::Memory::~Memory(CEA608Renderer::Memory *this)
{
  for (uint64_t i = 0; i != 15; ++i)
  {
    uint64_t v3 = *((void *)this + i + 2);
    if (v3)
    {
      for (uint64_t j = 0; j != 256; j += 8)
      {
        uint64_t v5 = *(void *)(v3 + j);
        if (v5) {
          MEMORY[0x199710860](v5, 0x1070C40BFE75829);
        }
      }
      MEMORY[0x199710860](v3, 0x30C408693532ALL);
    }
  }
  uint64_t v6 = *((void *)this + 1);
  if (v6) {
    MEMORY[0x199710850](v6, 0x1000C80BDFB0063);
  }
}

uint64_t CEA608Renderer::Memory::ShiftRows(uint64_t this, int a2)
{
  if (a2 >= 0) {
    LOBYTE(v2) = a2;
  }
  else {
    int v2 = -a2;
  }
  if ((char)v2 >= 1)
  {
    LOBYTE(v3) = 0;
    do
    {
      if (a2 < 0)
      {
        uint64_t v29 = *(void *)(this + 128);
        if (*(unsigned char *)(*(void *)v29 + 16)) {
          goto LABEL_51;
        }
        uint64_t v30 = 1;
        while (v30 != 32)
        {
          if (*(unsigned __int8 *)(*(void *)(v29 + 8 * v30++) + 16))
          {
            if ((unint64_t)(v30 - 2) < 0x1F) {
              goto LABEL_51;
            }
            break;
          }
        }
        if (*(unsigned char *)(*(void *)v29 + 32))
        {
LABEL_51:
          BOOL v32 = 1;
        }
        else
        {
          unint64_t v58 = 0;
          uint64_t v59 = v29 + 8;
          do
          {
            unint64_t v60 = v58;
            if (v58 == 31) {
              break;
            }
            ++v58;
          }
          while (!*(unsigned char *)(*(void *)(v59 + 8 * v60) + 32));
          BOOL v32 = v60 < 0x1F;
        }
        uint64_t v33 = 0;
        uint64_t v34 = *(void *)(this + 16);
        uint64_t v35 = 1;
        do
        {
          uint64_t v36 = this + 8 * v33;
          v39 = *(uint64_t **)(v36 + 16);
          uint64_t v37 = (void *)(v36 + 16);
          uint64_t v38 = v39;
          uint64_t v40 = *v39;
          if (*(unsigned char *)(*v39 + 16)) {
            goto LABEL_64;
          }
          uint64_t v41 = 1;
          while (v41 != 32)
          {
            if (*(unsigned __int8 *)(v38[v41++] + 16))
            {
              if ((unint64_t)(v41 - 2) < 0x1F) {
                goto LABEL_64;
              }
              break;
            }
          }
          uint64_t v43 = *(void *)(this + 8 * v35 + 16);
          if (*(unsigned char *)(*(void *)v43 + 16)) {
            goto LABEL_64;
          }
          uint64_t v44 = 1;
          while (v44 != 32)
          {
            if (*(unsigned __int8 *)(*(void *)(v43 + 8 * v44++) + 16))
            {
              if ((unint64_t)(v44 - 2) < 0x1F) {
                goto LABEL_64;
              }
              break;
            }
          }
          if (*(unsigned char *)(v40 + 32))
          {
LABEL_64:
            uint64_t v46 = 0;
            uint64_t v43 = *(void *)(this + 8 * v35 + 16);
            do
            {
              *(unsigned char *)(*(void *)(v43 + v46) + 32) = 1;
              v46 += 8;
            }
            while (v46 != 256);
          }
          else
          {
            uint64_t v47 = 1;
            while (v47 != 32)
            {
              if (*(unsigned __int8 *)(v38[v47++] + 32))
              {
                if ((unint64_t)(v47 - 2) <= 0x1E) {
                  goto LABEL_64;
                }
                break;
              }
            }
          }
          *uint64_t v37 = v43;
          ++v33;
          ++v35;
        }
        while (v33 != 14);
        uint64_t v49 = 0;
        *(void *)(this + 128) = v34;
        do
        {
          uint64_t v50 = *(void *)(v34 + v49);
          v51 = *(_WORD **)(v50 + 24);
          if (v51) {
            _WORD *v51 = 32;
          }
          if (*(unsigned char *)(v50 + 16)) {
            BOOL v52 = 1;
          }
          else {
            BOOL v52 = *(unsigned char *)(v50 + 32) != 0;
          }
          *(unsigned char *)(v50 + 32) = v52;
          *(void *)uint64_t v50 = 0;
          *(void *)(v50 + 8) = 0;
          *(unsigned char *)(v50 + 16) = 0;
          v49 += 8;
        }
        while (v49 != 256);
        if (v32)
        {
          uint64_t v53 = 0;
          uint64_t v54 = *(void *)(this + 128);
          do
          {
            *(unsigned char *)(*(void *)(v54 + v53) + 32) = 1;
            v53 += 8;
          }
          while (v53 != 256);
        }
      }
      else
      {
        uint64_t v4 = *(void *)(this + 16);
        if (*(unsigned char *)(*(void *)v4 + 16)) {
          goto LABEL_13;
        }
        uint64_t v5 = 1;
        while (v5 != 32)
        {
          if (*(unsigned __int8 *)(*(void *)(v4 + 8 * v5++) + 16))
          {
            if ((unint64_t)(v5 - 2) < 0x1F) {
              goto LABEL_13;
            }
            break;
          }
        }
        if (*(unsigned char *)(*(void *)v4 + 32))
        {
LABEL_13:
          BOOL v7 = 1;
        }
        else
        {
          unint64_t v55 = 0;
          uint64_t v56 = v4 + 8;
          do
          {
            unint64_t v57 = v55;
            if (v55 == 31) {
              break;
            }
            ++v55;
          }
          while (!*(unsigned char *)(*(void *)(v56 + 8 * v57) + 32));
          BOOL v7 = v57 < 0x1F;
        }
        uint64_t v8 = *(void *)(this + 128);
        uint64_t v9 = 14;
        uint64_t v10 = 13;
        do
        {
          uint64_t v11 = this + 8 * v9;
          __int16 v14 = *(uint64_t **)(v11 + 16);
          uint64_t v12 = (void *)(v11 + 16);
          uint64_t v13 = v14;
          uint64_t v15 = *v14;
          if (*(unsigned char *)(*v14 + 16)) {
            goto LABEL_26;
          }
          uint64_t v16 = 1;
          while (v16 != 32)
          {
            if (*(unsigned __int8 *)(v13[v16++] + 16))
            {
              if ((unint64_t)(v16 - 2) < 0x1F) {
                goto LABEL_26;
              }
              break;
            }
          }
          uint64_t v18 = *(void *)(this + 8 * v10 + 16);
          if (*(unsigned char *)(*(void *)v18 + 16)) {
            goto LABEL_26;
          }
          uint64_t v19 = 1;
          while (v19 != 32)
          {
            if (*(unsigned __int8 *)(*(void *)(v18 + 8 * v19++) + 16))
            {
              if ((unint64_t)(v19 - 2) < 0x1F) {
                goto LABEL_26;
              }
              break;
            }
          }
          if (*(unsigned char *)(v15 + 32))
          {
LABEL_26:
            uint64_t v21 = 0;
            uint64_t v18 = *(void *)(this + 8 * v10 + 16);
            do
            {
              *(unsigned char *)(*(void *)(v18 + v21) + 32) = 1;
              v21 += 8;
            }
            while (v21 != 256);
          }
          else
          {
            uint64_t v22 = 1;
            while (v22 != 32)
            {
              if (*(unsigned __int8 *)(v13[v22++] + 32))
              {
                if ((unint64_t)(v22 - 2) <= 0x1E) {
                  goto LABEL_26;
                }
                break;
              }
            }
          }
          *uint64_t v12 = v18;
          --v10;
          --v9;
        }
        while (v9);
        *(void *)(this + 16) = v8;
        do
        {
          uint64_t v24 = *(void *)(v8 + v9);
          uint64_t v25 = *(_WORD **)(v24 + 24);
          if (v25) {
            *uint64_t v25 = 32;
          }
          if (*(unsigned char *)(v24 + 16)) {
            BOOL v26 = 1;
          }
          else {
            BOOL v26 = *(unsigned char *)(v24 + 32) != 0;
          }
          *(unsigned char *)(v24 + 32) = v26;
          *(void *)uint64_t v24 = 0;
          *(void *)(v24 + 8) = 0;
          *(unsigned char *)(v24 + 16) = 0;
          v9 += 8;
        }
        while (v9 != 256);
        if (v7)
        {
          uint64_t v27 = 0;
          uint64_t v28 = *(void *)(this + 16);
          do
          {
            *(unsigned char *)(*(void *)(v28 + v27) + 32) = 1;
            v27 += 8;
          }
          while (v27 != 256);
        }
      }
      int v3 = (char)(v3 + 1);
    }
    while (v3 < (char)v2);
  }
  return this;
}

uint64_t CEA608Renderer::Memory::Erase(uint64_t this)
{
  for (uint64_t i = 0; i != 15; ++i)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)(this + 8 * i + 16);
    do
    {
      uint64_t v4 = *(void *)(v3 + v2);
      uint64_t v5 = *(_WORD **)(v4 + 24);
      if (v5) {
        *uint64_t v5 = 32;
      }
      if (*(unsigned char *)(v4 + 16)) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = *(unsigned char *)(v4 + 32) != 0;
      }
      *(unsigned char *)(v4 + 32) = v6;
      *(void *)uint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
      *(unsigned char *)(v4 + 16) = 0;
      v2 += 8;
    }
    while (v2 != 256);
  }
  return this;
}

uint64_t CEA608Renderer::Memory::SetDirty(uint64_t this, char a2)
{
  for (uint64_t i = 0; i != 15; ++i)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(this + 8 * i + 16);
    do
    {
      *(unsigned char *)(*(void *)(v4 + v3) + 32) = a2;
      v3 += 8;
    }
    while (v3 != 256);
  }
  return this;
}

BOOL CEA608Renderer::Memory::IsDirty(CEA608Renderer::Memory *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (*(unsigned char *)(*(void *)v1 + 32))
  {
    return 1;
  }
  else
  {
    unint64_t v4 = 0;
    BOOL v2 = 1;
    do
    {
      unint64_t v5 = 0;
      uint64_t v6 = v1 + 8;
      do
      {
        unint64_t v7 = v5;
        if (v5 == 31) {
          break;
        }
        ++v5;
      }
      while (!*(unsigned char *)(*(void *)(v6 + 8 * v7) + 32));
      if (v7 <= 0x1E) {
        break;
      }
      BOOL v2 = v4 < 0xE;
      if (v4 == 14) {
        break;
      }
      uint64_t v1 = *((void *)this + ++v4 + 2);
    }
    while (!*(unsigned char *)(*(void *)v1 + 32));
  }
  return v2;
}

void CEA608Renderer::CEA608Renderer(CEA608Renderer *this)
{
  TextRendererBase::TextRendererBase(this);
  *(void *)uint64_t v1 = &unk_1EE4FF478;
  *(_WORD *)(v1 + 48) = 0;
  *(unsigned char *)(v1 + 50) = 1;
  *(_DWORD *)(v1 + 52) = 0;
  *(_DWORD *)(v1 + 56) = 0;
  *(void *)(v1 + 64) = -1;
  *(unsigned char *)(v1 + 72) = 0;
  *(void *)(v1 + 80) = -1;
  operator new();
}

void sub_193F1F5CC(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  MEMORY[0x199710860](v3, 0x1030C4078BDD907);
  FigBytePumpGetFigBaseObject(v1);
  _Unwind_Resume(a1);
}

void CEA608Renderer::~CEA608Renderer(CEA608Renderer *this)
{
  *(void *)this = &unk_1EE4FF478;
  uint64_t v2 = (CEA608Renderer::Memory *)*((void *)this + 3);
  if (v2)
  {
    CEA608Renderer::Memory::~Memory(v2);
    MEMORY[0x199710860]();
  }
  uint64_t v3 = (CEA608Renderer::Memory *)*((void *)this + 4);
  if (v3)
  {
    CEA608Renderer::Memory::~Memory(v3);
    MEMORY[0x199710860]();
  }

  FigBytePumpGetFigBaseObject(this);
}

uint64_t CEA608Renderer::SetCurrentTime(uint64_t this, uint64_t a2)
{
  *(void *)(this + 16) = a2;
  return this;
}

uint64_t CEA608Renderer::SetTargetDataChannel(uint64_t this, char a2)
{
  *(unsigned char *)(this + 50) = a2;
  return this;
}

uint64_t CEA608Renderer::ResumeCaptionLoading(uint64_t this, int a2)
{
  *(unsigned char *)(this + 49) = a2;
  if (*(unsigned __int8 *)(this + 50) == a2)
  {
    *(void *)(this + 40) = *(void *)(this + 24);
    int v2 = *(_DWORD *)(this + 56);
    if (*(_DWORD *)(this + 52) != v2) {
      *(_DWORD *)(this + 52) = v2;
    }
    *(_DWORD *)(this + 56) = 2;
    *(unsigned char *)(this + 48) = 4;
  }
  return this;
}

unsigned __int8 *CEA608Renderer::RollUpCaptions(unsigned __int8 *this, uint64_t a2, unsigned int a3)
{
  this[49] = a2;
  if (this[50] == a2)
  {
    unint64_t v4 = this;
    this = (unsigned __int8 *)*((void *)this + 4);
    *((void *)v4 + 5) = this;
    int v5 = *((_DWORD *)v4 + 14);
    if (v5 == 1 || v5 == 4 && *((_DWORD *)v4 + 13) == 1)
    {
      unsigned int v7 = *this;
      if (a3 > v7)
      {
        CEA608Renderer::Memory::ShiftRows((uint64_t)this, (char)(a3 - v7));
        this = (unsigned __int8 *)*((void *)v4 + 5);
        *this = a3;
        unsigned int v7 = a3;
      }
      unsigned int v8 = v4[48];
      if (v8 > a3)
      {
        unsigned __int8 v9 = v7 - a3;
        if ((int)(v7 - v8) < (v7 - a3))
        {
          do
          {
            uint64_t v10 = 0;
            uint64_t v11 = *(void *)&this[8 * v9 + 8];
            do
            {
              uint64_t v12 = *(void *)(v11 + v10);
              uint64_t v13 = *(_WORD **)(v12 + 24);
              if (v13) {
                *uint64_t v13 = 32;
              }
              if (*(unsigned char *)(v12 + 16)) {
                BOOL v14 = 1;
              }
              else {
                BOOL v14 = *(unsigned char *)(v12 + 32) != 0;
              }
              *(unsigned char *)(v12 + 32) = v14;
              *(void *)uint64_t v12 = 0;
              *(void *)(v12 + 8) = 0;
              *(unsigned char *)(v12 + 16) = 0;
              v10 += 8;
            }
            while (v10 != 256);
            --v9;
            this = (unsigned __int8 *)*((void *)v4 + 5);
          }
          while (*this - v4[48] < v9);
        }
      }
    }
    else
    {
      (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v4 + 176))(v4, a2);
      this = (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *, uint64_t))(*(void *)v4 + 184))(v4, a2);
      **((_WORD **)v4 + 5) = 271;
      *((void *)v4 + 8) = -1;
    }
    int v15 = *((_DWORD *)v4 + 14);
    if (*((_DWORD *)v4 + 13) != v15) {
      *((_DWORD *)v4 + 13) = v15;
    }
    *((_DWORD *)v4 + 14) = 1;
    v4[48] = a3;
  }
  return this;
}

uint64_t CEA608Renderer::ResumeDirectCaptioning(uint64_t this, int a2)
{
  *(unsigned char *)(this + 49) = a2;
  if (*(unsigned __int8 *)(this + 50) == a2)
  {
    *(void *)(this + 40) = *(void *)(this + 32);
    int v2 = *(_DWORD *)(this + 56);
    if (*(_DWORD *)(this + 52) != v2) {
      *(_DWORD *)(this + 52) = v2;
    }
    *(_DWORD *)(this + 56) = 3;
    *(unsigned char *)(this + 48) = 4;
  }
  return this;
}

uint64_t CEA608Renderer::EndOfCaption(uint64_t this, int a2)
{
  *(unsigned char *)(this + 49) = a2;
  if (*(unsigned __int8 *)(this + 50) == a2)
  {
    uint64_t v2 = *(void *)(this + 32);
    for (uint64_t i = 1; i != 16; ++i)
    {
      uint64_t v4 = *(void *)(v2 + 8 * (i - 1) + 16);
      if (*(unsigned char *)(*(void *)v4 + 16)) {
        goto LABEL_9;
      }
      uint64_t v5 = 1;
      while (v5 != 32)
      {
        if (*(unsigned __int8 *)(*(void *)(v4 + 8 * v5++) + 16))
        {
          if ((unint64_t)(v5 - 2) < 0x1F) {
            goto LABEL_9;
          }
          break;
        }
      }
      if (*(unsigned char *)(*(void *)v4 + 32))
      {
LABEL_9:
        uint64_t v7 = 0;
        uint64_t v8 = *(void *)(*(void *)(this + 24) + 8 * (i - 1) + 16);
        do
        {
          *(unsigned char *)(*(void *)(v8 + v7) + 32) = 1;
          v7 += 8;
        }
        while (v7 != 256);
      }
      else
      {
        uint64_t v9 = 1;
        while (v9 != 32)
        {
          if (*(unsigned __int8 *)(*(void *)(v4 + 8 * v9++) + 32))
          {
            if ((unint64_t)(v9 - 2) <= 0x1E) {
              goto LABEL_9;
            }
            break;
          }
        }
      }
    }
    *(void *)(this + 32) = *(void *)(this + 24);
    *(void *)(this + 40) = v2;
    *(void *)(this + 24) = v2;
    int v11 = *(_DWORD *)(this + 56);
    if (*(_DWORD *)(this + 52) != v11) {
      *(_DWORD *)(this + 52) = v11;
    }
    *(_DWORD *)(this + 56) = 2;
    *(unsigned char *)(this + 48) = 4;
  }
  return this;
}

uint64_t CEA608Renderer::Character(uint64_t this, int a2, __int16 a3, char a4)
{
  if (a2) {
    *(unsigned char *)(this + 49) = a2;
  }
  else {
    a2 = *(unsigned __int8 *)(this + 49);
  }
  if (a2 == *(unsigned __int8 *)(this + 50) && (*(_DWORD *)(this + 56) | 4) != 4)
  {
    uint64_t v4 = *(unsigned __int8 **)(this + 40);
    unsigned int v5 = v4[1];
    uint64_t v6 = *(void *)(*(void *)&v4[8 * *v4 + 8] + 8 * v4[1] - 8);
    **(_WORD **)(v6 + 24) = a3;
    *(void *)(v6 + 8) = 0;
    *(unsigned char *)(v6 + 16) = a4 ^ 1;
    *(unsigned char *)(v6 + 32) = 1;
    if (v5 <= 0x1F) {
      v4[1] = v5 + 1;
    }
  }
  return this;
}

uint64_t CEA608Renderer::Backspace(uint64_t this, int a2)
{
  *(unsigned char *)(this + 49) = a2;
  if (*(unsigned __int8 *)(this + 50) == a2 && (*(_DWORD *)(this + 56) | 4) != 4)
  {
    uint64_t v2 = *(unsigned __int8 **)(this + 40);
    unsigned int v3 = v2[1];
    if (v3 >= 2)
    {
      uint64_t v4 = *v2 - 1;
      if (v3 == 32)
      {
        uint64_t v5 = *(void *)(*(void *)&v2[8 * v4 + 16] + 248);
        *(void *)(v5 + 8) = 0;
        **(_WORD **)(v5 + 24) = 32;
        *(unsigned char *)(v5 + 16) = 0;
        *(unsigned char *)(v5 + 32) = 1;
      }
      unsigned __int8 v6 = v3 - 1;
      v2[1] = v6;
      uint64_t v7 = *(void *)(*(void *)&v2[8 * v4 + 16] + 8 * v6 - 8);
      *(void *)(v7 + 8) = 0;
      **(_WORD **)(v7 + 24) = 32;
      *(unsigned char *)(v7 + 16) = 0;
      *(unsigned char *)(v7 + 32) = 1;
    }
  }
  return this;
}

uint64_t CEA608Renderer::CarriageReturn(uint64_t this, int a2)
{
  *(unsigned char *)(this + 49) = a2;
  if (*(unsigned __int8 *)(this + 50) == a2)
  {
    uint64_t v2 = (void *)this;
    if (*(_DWORD *)(this + 56) == 1)
    {
      uint64_t v3 = 0;
      uint64_t v4 = *(void *)(*(void *)(this + 40)
                     + 8 * (**(unsigned char **)(this + 40) - *(unsigned char *)(this + 48) + 1)
                     + 8);
      do
      {
        uint64_t v5 = *(void *)(v4 + v3);
        unsigned __int8 v6 = *(_WORD **)(v5 + 24);
        if (v6) {
          *unsigned __int8 v6 = 32;
        }
        if (*(unsigned char *)(v5 + 16)) {
          BOOL v7 = 1;
        }
        else {
          BOOL v7 = *(unsigned char *)(v5 + 32) != 0;
        }
        *(unsigned char *)(v5 + 32) = v7;
        *(void *)uint64_t v5 = 0;
        *(void *)(v5 + 8) = 0;
        *(unsigned char *)(v5 + 16) = 0;
        v3 += 8;
      }
      while (v3 != 256);
      this = CEA608Renderer::Memory::ShiftRows(*(void *)(this + 40), -1);
      v2[8] = v2[2];
      *(unsigned char *)(v2[5] + 1) = 1;
    }
  }
  return this;
}

uint64_t CEA608Renderer::DeleteToEndOfRow(uint64_t this, int a2)
{
  *(unsigned char *)(this + 49) = a2;
  if (*(unsigned __int8 *)(this + 50) == a2 && (*(_DWORD *)(this + 56) | 4) != 4)
  {
    uint64_t v2 = *(unsigned __int8 **)(this + 40);
    unint64_t v3 = v2[1];
    if (v3 < 2) {
      goto LABEL_7;
    }
    uint64_t v4 = *(void *)&v2[8 * *v2 + 8];
    if (*(unsigned char *)(*(void *)(v4 + 8 * (v3 - 1) - 8) + 16))
    {
      uint64_t v5 = *(void *)(v4 + 8 * v3 - 8);
      **(_WORD **)(v5 + 24) = 32;
      *(unsigned char *)(v5 + 16) = 0;
      *(unsigned char *)(v5 + 32) = 1;
      LOBYTE(v3) = v3 + 1;
    }
    if (v3 <= 0x20u)
    {
LABEL_7:
      uint64_t v6 = v3 - 1;
      do
      {
        uint64_t v7 = *(void *)(*(void *)(*(void *)(this + 40) + 8 * **(unsigned __int8 **)(this + 40) + 8) + 8 * v6);
        uint64_t v8 = *(_WORD **)(v7 + 24);
        if (v8) {
          *uint64_t v8 = 32;
        }
        if (*(unsigned char *)(v7 + 16)) {
          BOOL v9 = 1;
        }
        else {
          BOOL v9 = *(unsigned char *)(v7 + 32) != 0;
        }
        *(unsigned char *)(v7 + 32) = v9;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = 0;
        *(unsigned char *)(v7 + 16) = 0;
        uint64_t v10 = (v6++ + 2);
      }
      while (v10 != 33);
    }
  }
  return this;
}

unsigned __int8 *CEA608Renderer::PreambleAddressCode(unsigned __int8 *result, int a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  result[49] = a2;
  if (result[50] == a2)
  {
    uint64_t v5 = result;
    int v6 = *((_DWORD *)result + 14);
    if (v6 && v6 != 4)
    {
      unsigned int v10 = a3;
      if (v6 == 1)
      {
        if (result[48] <= a3) {
          unsigned int v10 = a3;
        }
        else {
          unsigned int v10 = result[48];
        }
        uint64_t result = (unsigned __int8 *)*((void *)result + 5);
        unsigned int v11 = v10 - *result;
        if (!v11) {
          goto LABEL_13;
        }
        CEA608Renderer::Memory::ShiftRows((uint64_t)result, (char)v11);
      }
      uint64_t result = (unsigned __int8 *)*((void *)v5 + 5);
      *uint64_t result = v10;
LABEL_13:
      result[1] = a5 + 1;
      uint64_t v12 = v10 - 1;
      if (!a5 || !*(unsigned char *)(*(void *)(*(void *)&result[8 * v12 + 16] + 8 * a5 - 8) + 16))
      {
        uint64_t v13 = *(void *)(*(void *)&result[8 * v12 + 16] + 8 * (a5 + 1) - 8);
        *(void *)uint64_t v13 = a4;
        *(unsigned char *)(v13 + 32) = 1;
      }
    }
  }
  return result;
}

uint64_t CEA608Renderer::MidRowCode(uint64_t result, int a2, uint64_t a3)
{
  *(unsigned char *)(result + 49) = a2;
  if (*(unsigned __int8 *)(result + 50) == a2)
  {
    uint64_t v3 = result;
    if ((*(_DWORD *)(result + 56) | 4) != 4)
    {
      uint64_t v5 = *(unsigned __int8 *)(*(void *)(result + 40) + 1);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 112))(result);
      uint64_t v6 = *(void *)(*(void *)(*(void *)(v3 + 40) + 8 * **(unsigned __int8 **)(v3 + 40) + 8) + 8 * v5 - 8);
      *(void *)(v6 + 8) = a3;
      *(unsigned char *)(v6 + 32) = 1;
    }
  }
  return result;
}

uint64_t CEA608Renderer::TabOffset(uint64_t this, int a2, char a3)
{
  *(unsigned char *)(this + 49) = a2;
  if (*(unsigned __int8 *)(this + 50) == a2 && (*(_DWORD *)(this + 56) | 4) != 4)
  {
    uint64_t v3 = *(void *)(this + 40);
    if (((*(unsigned char *)(v3 + 1) + a3) & 0xE0) != 0) {
      char v4 = 32;
    }
    else {
      char v4 = *(unsigned char *)(v3 + 1) + a3;
    }
    *(unsigned char *)(v3 + 1) = v4;
  }
  return this;
}

uint64_t CEA608Renderer::FlashOn(uint64_t this, int a2)
{
  *(unsigned char *)(this + 49) = a2;
  if (*(unsigned __int8 *)(this + 50) == a2)
  {
    uint64_t v2 = this;
    uint64_t v3 = *(unsigned __int8 *)(*(void *)(this + 40) + 1);
    this = (*(uint64_t (**)(uint64_t))(*(void *)this + 112))(this);
    uint64_t v4 = *(void *)(*(void *)(*(void *)(v2 + 40) + 8 * **(unsigned __int8 **)(v2 + 40) + 8) + 8 * v3 - 8);
    *(void *)(v4 + 8) = &FlashOnStyle;
    *(unsigned char *)(v4 + 32) = 1;
  }
  return this;
}

uint64_t CEA608Renderer::EraseDisplayedMemory(uint64_t this, int a2)
{
  *(unsigned char *)(this + 49) = a2;
  if (*(unsigned __int8 *)(this + 50) == a2) {
    return CEA608Renderer::Memory::Erase(*(void *)(this + 32));
  }
  return this;
}

uint64_t CEA608Renderer::EraseNonDisplayedMemory(uint64_t this, int a2)
{
  *(unsigned char *)(this + 49) = a2;
  if (*(unsigned __int8 *)(this + 50) == a2) {
    return CEA608Renderer::Memory::Erase(*(void *)(this + 24));
  }
  return this;
}

uint64_t CEA608Renderer::TextRestart(CEA608Renderer *this, uint64_t a2)
{
  int v4 = *((_DWORD *)this + 14);
  if (*((_DWORD *)this + 13) != v4) {
    *((_DWORD *)this + 13) = v4;
  }
  *((_DWORD *)this + 14) = 4;
  *((unsigned char *)this + 49) = a2;
  (*(void (**)(CEA608Renderer *, uint64_t))(*(void *)this + 176))(this, a2);
  uint64_t v5 = *(uint64_t (**)(CEA608Renderer *, uint64_t))(*(void *)this + 184);

  return v5(this, a2);
}

uint64_t CEA608Renderer::TextDisplay(uint64_t this, uint64_t a2)
{
  int v3 = *(_DWORD *)(this + 52);
  int v2 = *(_DWORD *)(this + 56);
  if (v3 != 1 || v2 != 1)
  {
    uint64_t v6 = this;
    if (v3 != v2) {
      *(_DWORD *)(this + 52) = v2;
    }
    *(_DWORD *)(this + 56) = 4;
    *(unsigned char *)(this + 49) = a2;
    (*(void (**)(uint64_t, uint64_t))(*(void *)this + 176))(this, a2);
    uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 184);
    return v7(v6, a2);
  }
  return this;
}

uint64_t CEA608Renderer::InvalidData(CEA608Renderer *this)
{
  (*(void (**)(CEA608Renderer *, void))(*(void *)this + 176))(this, *((unsigned __int8 *)this + 49));
  uint64_t result = (*(uint64_t (**)(CEA608Renderer *, void))(*(void *)this + 184))(this, *((unsigned __int8 *)this + 49));
  int v3 = *((_DWORD *)this + 14);
  if (*((_DWORD *)this + 13) != v3) {
    *((_DWORD *)this + 13) = v3;
  }
  *((_DWORD *)this + 14) = 0;
  return result;
}

BOOL CEA608Renderer::IsDisplayDirty(CEA608Renderer::Memory **this)
{
  if (*((unsigned __int8 *)this + 72) != *((unsigned __int8 *)this + 8)) {
    return 1;
  }
  if (*((unsigned char *)this + 72)) {
    return CEA608Renderer::Memory::IsDirty(this[4]);
  }
  return 0;
}

uint64_t FigCEA608DataGeneratorCaptionInfoCreate(int a1, int a2, long long *a3, CFAllocatorRef allocator, void *a5)
{
  if (((a1 - 1) < 2 || a1 == 3 && (a2 - 2) < 3)
    && (*((_DWORD *)a3 + 3) & 0x1D) == 1
    && (*((_DWORD *)a3 + 9) & 0x1D) == 1
    && (unsigned int v10 = CFAllocatorAllocate(allocator, 128, 0)) != 0)
  {
    unsigned int v11 = v10;
    v10[6] = 0u;
    v10[7] = 0u;
    v10[4] = 0u;
    v10[5] = 0u;
    v10[2] = 0u;
    v10[3] = 0u;
    *unsigned int v10 = 0u;
    v10[1] = 0u;
    if (allocator) {
      CFTypeRef v12 = CFRetain(allocator);
    }
    else {
      CFTypeRef v12 = 0;
    }
    uint64_t v13 = 0;
    *(void *)unsigned int v11 = v12;
    *((_DWORD *)v11 + 2) = a1;
    *((_DWORD *)v11 + 3) = a2;
    long long v14 = *a3;
    long long v15 = a3[2];
    v11[2] = a3[1];
    v11[3] = v15;
    v11[1] = v14;
    *a5 = v11;
  }
  else
  {
    uint64_t v13 = FigSignalErrorAt();
  }
  FigCEA608DataGeneratorCaptionInfoRelease(0);
  return v13;
}

void FigCEA608DataGeneratorCaptionInfoRelease(const __CFAllocator **ptr)
{
  if (ptr)
  {
    CFAllocatorRef v2 = *ptr;
    CFAllocatorRef v3 = ptr[14];
    if (v3) {
      CFRelease(v3);
    }
    CFAllocatorDeallocate(v2, ptr);
    if (v2)
    {
      CFRelease(v2);
    }
  }
}

uint64_t FigCEA608DataGeneratorCreate(uint64_t a1, uint64_t a2, CFAllocatorRef allocator, void *a4)
{
  v102[2] = *MEMORY[0x1E4F143B8];
  if (!a1 || !a4)
  {
    uint64_t v64 = FigSignalErrorAt();
    goto LABEL_95;
  }
  CFAllocatorRef v5 = allocator;
  uint64_t v8 = (char *)CFAllocatorAllocate(allocator, 160, 0);
  BOOL v9 = v8;
  if (!v8)
  {
    uint64_t v64 = FigSignalErrorAt();
    goto LABEL_96;
  }
  *((_OWORD *)v8 + 8) = 0u;
  *((_OWORD *)v8 + 9) = 0u;
  *((_OWORD *)v8 + 6) = 0u;
  *((_OWORD *)v8 + 7) = 0u;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_OWORD *)v8 + 2) = 0u;
  *((_OWORD *)v8 + 3) = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  v70 = a4;
  if (v5) {
    CFTypeRef v10 = CFRetain(v5);
  }
  else {
    CFTypeRef v10 = 0;
  }
  *(void *)BOOL v9 = v10;
  v9[9] = 1;
  long long start = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)allocatorb = start;
  *(void *)&long long start_16 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  uint64_t v11 = start_16;
  CMTime duration = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA10];
  CMTimeRangeMake(&v77, (CMTime *)&start, &duration);
  long long v12 = *(_OWORD *)&v77.start.value;
  long long v13 = *(_OWORD *)&v77.start.epoch;
  *(_OWORD *)(v9 + 44) = *(_OWORD *)&v77.duration.timescale;
  *(void *)(v9 + 76) = 0;
  *(_OWORD *)(v9 + 28) = v13;
  *(_OWORD *)(v9 + 12) = v12;
  *(_OWORD *)(v9 + 120) = *(_OWORD *)allocatorb;
  *(_OWORD *)(v9 + 60) = kFigCEA608DefaultFrameDuration;
  *((void *)v9 + 18) = a2;
  *((void *)v9 + 19) = a1;
  *((void *)v9 + 17) = v11;
  v88 = 0;
  v89 = 0;
  *(void *)&long long start = 0x1EE53C298;
  *((void *)&start + 1) = 0x1EE53C2B8;
  *(void *)&long long start_16 = 0x1EE53C2D8;
  *((void *)&start_16 + 1) = 0x1EE53C2F8;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v5, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFAllocatorRef allocatora = v5;
  v71 = v9;
  if (!Mutable)
  {
    uint64_t v64 = FigSignalErrorAt();
    if (v64) {
      goto LABEL_89;
    }
LABEL_40:
    duration.value = 0x1EE53C2D8;
    *(void *)&duration.timescale = 0x1EE53C2F8;
    v102[0] = 0x1EE53C318;
    v102[1] = 0x1EE53C338;
    theDict = CFDictionaryCreateMutable(v5, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (theDict)
    {
      uint64_t v36 = 0;
      char v37 = 1;
      while (1)
      {
        char v38 = v37;
        CFStringRef v39 = (const __CFString *)*(&duration.value + v36);
        uint64_t Length = CFStringGetLength(v39);
        CFStringRef v41 = (const __CFString *)v102[v36];
        if (Length != CFStringGetLength(v41)) {
          break;
        }
        long long v84 = 0uLL;
        long long v85 = 0u;
        long long theString = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v78 = 0u;
        memset(&v77, 0, sizeof(v77));
        uint64_t v101 = 0;
        long long v99 = 0u;
        long long v100 = 0u;
        long long v97 = 0u;
        long long v98 = 0u;
        long long v95 = 0u;
        long long v96 = 0u;
        long long v93 = 0u;
        long long v94 = 0u;
        long long start_16 = 0u;
        long long v92 = 0u;
        long long start = 0u;
        *(void *)&long long theString = v39;
        *(void *)&long long v85 = Length;
        uint64_t v86 = 0;
        CharactersPtr = CFStringGetCharactersPtr(v39);
        CStringPtr = 0;
        *((void *)&theString + 1) = CharactersPtr;
        if (!CharactersPtr) {
          CStringPtr = CFStringGetCStringPtr(v39, 0x600u);
        }
        *(void *)&long long v84 = CStringPtr;
        *((void *)&v85 + 1) = 0;
        uint64_t v86 = 0;
        *(void *)&long long v98 = v41;
        *((void *)&v99 + 1) = 0;
        *(void *)&long long v100 = Length;
        uint64_t v44 = CFStringGetCharactersPtr(v41);
        v45 = 0;
        *((void *)&v98 + 1) = v44;
        if (!v44) {
          v45 = CFStringGetCStringPtr(v41, 0x600u);
        }
        *(void *)&long long v99 = v45;
        *((void *)&v100 + 1) = 0;
        uint64_t v101 = 0;
        CFMutableDictionaryRef v46 = CFDictionaryCreateMutable(allocatora, Length, 0, 0);
        if (!v46) {
          break;
        }
        uint64_t v47 = v46;
        char v73 = v38;
        uint64_t v74 = v36;
        if (Length >= 1)
        {
          uint64_t v48 = 0;
          uint64_t v49 = 0;
          uint64_t v50 = 64;
          do
          {
            if ((unint64_t)v49 >= 4) {
              uint64_t v51 = 4;
            }
            else {
              uint64_t v51 = v49;
            }
            uint64_t v52 = v51 + v48;
            uint64_t v53 = v50 - v51;
            uint64_t v54 = -v51;
            uint64_t v55 = v85;
            if ((uint64_t)v85 <= v49)
            {
              unsigned __int16 v56 = 0;
            }
            else if (*((void *)&theString + 1))
            {
              unsigned __int16 v56 = *(_WORD *)(*((void *)&theString + 1) + 2 * (v49 + *((void *)&v84 + 1)));
            }
            else if ((void)v84)
            {
              unsigned __int16 v56 = *(char *)(v84 + *((void *)&v84 + 1) + v49);
            }
            else
            {
              uint64_t v59 = *((void *)&v85 + 1);
              if (v86 <= v49 || *((void *)&v85 + 1) > v49)
              {
                uint64_t v61 = v49 + v54 + 64;
                if (v61 >= (uint64_t)v85) {
                  uint64_t v61 = v85;
                }
                *((void *)&v85 + 1) = v49 + v54;
                uint64_t v86 = v61;
                if ((uint64_t)v85 >= v53) {
                  uint64_t v55 = v53;
                }
                v104.length = v55 + v52;
                v104.location = v49 + v54 + *((void *)&v84 + 1);
                CFStringGetCharacters((CFStringRef)theString, v104, (UniChar *)&v77);
                uint64_t v59 = *((void *)&v85 + 1);
              }
              unsigned __int16 v56 = *((_WORD *)&v77.start.value + v49 - v59);
            }
            uint64_t v57 = v100;
            if ((uint64_t)v100 <= v49)
            {
              unsigned __int16 v58 = 0;
            }
            else if (*((void *)&v98 + 1))
            {
              unsigned __int16 v58 = *(_WORD *)(*((void *)&v98 + 1) + 2 * (v49 + *((void *)&v99 + 1)));
            }
            else if ((void)v99)
            {
              unsigned __int16 v58 = *(char *)(v99 + *((void *)&v99 + 1) + v49);
            }
            else
            {
              if (v101 <= v49 || (uint64_t v62 = *((void *)&v100 + 1), *((uint64_t *)&v100 + 1) > v49))
              {
                uint64_t v63 = v49 + v54 + 64;
                if (v63 >= (uint64_t)v100) {
                  uint64_t v63 = v100;
                }
                *((void *)&v100 + 1) = v49 + v54;
                uint64_t v101 = v63;
                if ((uint64_t)v100 >= v53) {
                  uint64_t v57 = v53;
                }
                v105.length = v57 + v52;
                v105.location = v49 + v54 + *((void *)&v99 + 1);
                CFStringGetCharacters((CFStringRef)v98, v105, (UniChar *)&start);
                uint64_t v62 = *((void *)&v100 + 1);
              }
              unsigned __int16 v58 = *((_WORD *)&start + v49 - v62);
            }
            CFDictionaryAddValue(v47, (const void *)v56, (const void *)v58);
            ++v49;
            --v48;
            ++v50;
          }
          while (Length != v49);
        }
        CFDictionaryAddValue(theDict, off_1E578B310[v74], v47);
        CFRelease(v47);
        char v37 = 0;
        uint64_t v36 = 1;
        if ((v73 & 1) == 0)
        {
          v89 = theDict;
          BOOL v9 = v71;
          goto LABEL_87;
        }
      }
      uint64_t v64 = FigSignalErrorAt();
      CFRelease(theDict);
      BOOL v9 = v71;
      if (v64) {
        goto LABEL_89;
      }
    }
    else
    {
      uint64_t v64 = FigSignalErrorAt();
      if (v64) {
        goto LABEL_89;
      }
    }
LABEL_87:
    uint64_t v64 = FigCFCreateCombinedDictionary();
    if (!v64) {
      *((void *)v9 + 11) = 0;
    }
    goto LABEL_89;
  }
  long long v15 = Mutable;
  uint64_t v16 = 0;
  while (1)
  {
    CFStringRef v17 = (const __CFString *)*((void *)&start + v16);
    if (FigCFEqual()) {
      uint64_t v18 = 48;
    }
    else {
      uint64_t v18 = 32;
    }
    uint64_t v19 = CFStringGetLength(v17);
    long long v84 = 0u;
    long long v85 = 0u;
    uint64_t v86 = 0;
    long long theString = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v78 = 0u;
    memset(&v77, 0, sizeof(v77));
    *(void *)&long long theString = v17;
    *(void *)&long long v85 = v19;
    CFIndex v20 = CFStringGetCharactersPtr(v17);
    uint64_t v21 = 0;
    *((void *)&theString + 1) = v20;
    if (!v20) {
      uint64_t v21 = CFStringGetCStringPtr(v17, 0x600u);
    }
    *(void *)&long long v84 = v21;
    *((void *)&v85 + 1) = 0;
    uint64_t v86 = 0;
    CFMutableDictionaryRef v22 = CFDictionaryCreateMutable(v5, v19, 0, 0);
    if (!v22) {
      break;
    }
    CFDataRef v23 = v22;
    if (v19 >= 1)
    {
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      uint64_t v26 = 64;
      do
      {
        if ((unint64_t)v25 >= 4) {
          uint64_t v27 = 4;
        }
        else {
          uint64_t v27 = v25;
        }
        uint64_t v28 = v85;
        if ((uint64_t)v85 <= v25)
        {
          unsigned __int16 v29 = 0;
        }
        else if (*((void *)&theString + 1))
        {
          unsigned __int16 v29 = *(_WORD *)(*((void *)&theString + 1) + 2 * (v25 + *((void *)&v84 + 1)));
        }
        else if ((void)v84)
        {
          unsigned __int16 v29 = *(char *)(v84 + *((void *)&v84 + 1) + v25);
        }
        else
        {
          uint64_t v30 = *((void *)&v85 + 1);
          if (v86 <= v25 || *((void *)&v85 + 1) > v25)
          {
            uint64_t v32 = v27 + v24;
            uint64_t v33 = v26 - v27;
            uint64_t v34 = v25 - v27;
            uint64_t v35 = v34 + 64;
            if (v34 + 64 >= (uint64_t)v85) {
              uint64_t v35 = v85;
            }
            *((void *)&v85 + 1) = v34;
            uint64_t v86 = v35;
            if ((uint64_t)v85 >= v33) {
              uint64_t v28 = v33;
            }
            v103.length = v28 + v32;
            v103.location = *((void *)&v84 + 1) + v34;
            CFStringGetCharacters((CFStringRef)theString, v103, (UniChar *)&v77);
            uint64_t v30 = *((void *)&v85 + 1);
          }
          unsigned __int16 v29 = *((_WORD *)&v77.start.value + v25 - v30);
        }
        CFDictionaryAddValue(v23, (const void *)v29, (const void *)(v18 + v25++));
        --v24;
        ++v26;
      }
      while (v19 != v25);
    }
    CFDictionaryAddValue(v15, off_1E578B2F0[v16], v23);
    CFRelease(v23);
    ++v16;
    CFAllocatorRef v5 = allocatora;
    if (v16 == 4)
    {
      v88 = v15;
      BOOL v9 = v71;
      goto LABEL_40;
    }
  }
  uint64_t v64 = FigSignalErrorAt();
  CFRelease(v15);
  BOOL v9 = v71;
  if (!v64) {
    goto LABEL_40;
  }
LABEL_89:
  uint64_t v65 = 0;
  char v66 = 1;
  do
  {
    char v67 = v66;
    v68 = *(&v88 + v65);
    if (v68) {
      CFRelease(v68);
    }
    char v66 = 0;
    uint64_t v65 = 1;
  }
  while ((v67 & 1) != 0);
  if (!v64)
  {
    void *v70 = v9;
LABEL_95:
    BOOL v9 = 0;
  }
LABEL_96:
  FigCEA608DataGeneratorRelease(v9);
  return v64;
}

void FigCEA608DataGeneratorRelease(void *a1)
{
  if (a1)
  {
    CFAllocatorRef v2 = *(const __CFAllocator **)a1;
    FigCEA608DataGeneratorCaptionInfoRelease(*((const __CFAllocator ***)a1 + 13));
    FigCEA608DataGeneratorCaptionInfoRelease(*((const __CFAllocator ***)a1 + 14));
    CFAllocatorRef v3 = (const void *)*((void *)a1 + 11);
    if (v3) {
      CFRelease(v3);
    }
    CFAllocatorDeallocate(v2, a1);
    if (v2)
    {
      CFRelease(v2);
    }
  }
}

uint64_t FigCEA608DataGeneratorBeginCaption(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  CFAllocatorRef v4 = *(const __CFAllocator **)a1;
  long long v25 = *(_OWORD *)(a1 + 60);
  CMTimeEpoch v26 = *(void *)(a1 + 76);
  if (!a4 || (uint64_t v6 = (void *)(a1 + 112), *(void *)(a1 + 112)))
  {
LABEL_41:
    return FigSignalErrorAt();
  }
  int v10 = *(_DWORD *)(a1 + 96);
  if (v10)
  {
    if (v10 == 2) {
      goto LABEL_41;
    }
  }
  else
  {
    CMTime v28 = *(CMTime *)(a1 + 60);
    CMTime bytes = *(CMTime *)(a1 + 12);
    cea608dgCCDataGetQuantizedTimeByFrameDuration((uint64_t)&v28, &bytes, (uint64_t)&range);
    *(_OWORD *)(a1 + 120) = *(_OWORD *)&range.start.value;
    *(void *)(a1 + 136) = range.start.epoch;
  }
  if (*((unsigned char *)a2 + 12))
  {
    long long v11 = *a2;
    *(void *)(a1 + 136) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 120) = v11;
  }
  if (!a3
    || (FigCEA608DataGeneratorCaptionInfoRelease(*(const __CFAllocator ***)(a1 + 104)),
        *(_OWORD *)&range.start.value = v25,
        range.start.epoch = v26,
        uint64_t result = cea608dgCaptionInfoCopy((long long *)&range.start.value, a3, v4, (void *)(a1 + 104)),
        !result))
  {
    long long v13 = *(_OWORD **)(a1 + 104);
    if (v13)
    {
      long long v14 = v13[2];
      *(_OWORD *)&range.start.value = v13[1];
      *(_OWORD *)&range.start.epoch = v14;
      *(_OWORD *)&range.duration.timescale = v13[3];
      CMTimeRangeGetEnd(&time1, &range);
      *(_OWORD *)&range.start.value = *(_OWORD *)(a4 + 16);
      range.start.epoch = *(void *)(a4 + 32);
      if (CMTimeCompare(&time1, &range.start) >= 1) {
        return FigSignalErrorAt();
      }
    }
    *(_OWORD *)&range.start.value = v25;
    range.start.epoch = v26;
    uint64_t result = cea608dgCaptionInfoCopy((long long *)&range.start.value, a4, v4, v6);
    if (!result)
    {
      uint64_t v16 = *(void *)(a1 + 104);
      uint64_t v15 = *(void *)(a1 + 112);
      int v17 = *(unsigned __int8 *)(a1 + 101);
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)v15, 0);
      *(void *)(v15 + 112) = Mutable;
      if (!Mutable)
      {
        uint64_t result = FigSignalErrorAt();
        if (result) {
          return result;
        }
        goto LABEL_39;
      }
      LOWORD(bytes.value) = 0;
      int v19 = *(_DWORD *)(v15 + 8);
      switch(v19)
      {
        case 3:
          int v21 = *(_DWORD *)(v15 + 12);
          switch(v21)
          {
            case 4:
              __int16 v20 = 10004;
              break;
            case 3:
              __int16 v20 = 9748;
              break;
            case 2:
              __int16 v20 = 9492;
              break;
            default:
LABEL_35:
              LOWORD(range.start.value) = 11540;
LABEL_38:
              CFDataAppendBytes(Mutable, (const UInt8 *)&range, 2);
              goto LABEL_39;
          }
          break;
        case 2:
          if (v16 && *(_DWORD *)(v16 + 8) == 2)
          {
            long long v22 = *(_OWORD *)(v16 + 80);
            *(_OWORD *)&range.start.value = *(_OWORD *)(v16 + 64);
            *(_OWORD *)&range.start.epoch = v22;
            *(_OWORD *)&range.duration.timescale = *(_OWORD *)(v16 + 96);
            CMTimeRangeGetEnd(&v28, &range);
            *(_OWORD *)&range.start.value = *(_OWORD *)(v15 + 64);
            range.start.epoch = *(void *)(v15 + 80);
            if (!CMTimeCompare(&v28, &range.start))
            {
LABEL_31:
              int v19 = *(_DWORD *)(v15 + 8);
LABEL_32:
              if (v19 == 1)
              {
                if (v17)
                {
                  LOWORD(range.start.value) = 11796;
                  CFMutableDictionaryRef Mutable = *(__CFData **)(v15 + 112);
                  goto LABEL_38;
                }
              }
              else if (v19 == 3)
              {
                CFMutableDictionaryRef Mutable = *(__CFData **)(v15 + 112);
                goto LABEL_35;
              }
LABEL_39:
              uint64_t result = 0;
              *(_DWORD *)(a1 + 96) = 1;
              return result;
            }
            CFMutableDictionaryRef Mutable = *(__CFData **)(v15 + 112);
          }
          __int16 v20 = 10516;
          break;
        case 1:
          __int16 v20 = kFigCEA608MiscControlCodes;
          break;
        default:
          goto LABEL_32;
      }
      LOWORD(bytes.value) = v20;
      CFDataAppendBytes(Mutable, (const UInt8 *)&bytes, 2);
      goto LABEL_31;
    }
  }
  return result;
}

__n128 cea608dgCCDataGetQuantizedTimeByFrameDuration@<Q0>(uint64_t a1@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  if ((a2->flags & 0x1D) == 1)
  {
    CMTime time = *a2;
    float v6 = CMTimeGetSeconds(&time) * (float)((float)*(int *)(a1 + 8) / (float)*(uint64_t *)a1);
    CMTime v8 = *(CMTime *)a1;
    CMTimeMultiply(&time, &v8, llroundf(v6));
    *a2 = time;
  }
  __n128 result = *(__n128 *)&a2->value;
  *(_OWORD *)a3 = *(_OWORD *)&a2->value;
  *(void *)(a3 + 16) = a2->epoch;
  return result;
}

uint64_t cea608dgCaptionInfoCopy(long long *a1, uint64_t a2, CFAllocatorRef allocator, void *a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = CFAllocatorAllocate(allocator, 128, 0);
  if (v7)
  {
    CMTime v8 = v7;
    v7[6] = 0u;
    v7[7] = 0u;
    v7[4] = 0u;
    v7[5] = 0u;
    v7[2] = 0u;
    v7[3] = 0u;
    *uint64_t v7 = 0u;
    v7[1] = 0u;
    CFTypeRef v9 = *(CFTypeRef *)a2;
    if (*(void *)a2) {
      CFTypeRef v9 = CFRetain(v9);
    }
    *(void *)CMTime v8 = v9;
    *((void *)v8 + 1) = *(void *)(a2 + 8);
    long long v10 = *(_OWORD *)(a2 + 16);
    long long v11 = *(_OWORD *)(a2 + 48);
    v8[2] = *(_OWORD *)(a2 + 32);
    v8[3] = v11;
    v8[1] = v10;
    long long v20 = *a1;
    CMTimeEpoch v21 = *((void *)a1 + 2);
    CMTimeValue value = *(void *)(a2 + 16);
    CMTimeFlags flags = *(_DWORD *)(a2 + 28);
    CMTimeScale timescale = *(_DWORD *)(a2 + 24);
    CMTimeEpoch epoch = *(void *)(a2 + 32);
    CMTimeValue v26 = *(void *)(a2 + 40);
    CMTimeFlags v14 = *(_DWORD *)(a2 + 52);
    CMTimeScale v27 = *(_DWORD *)(a2 + 48);
    CMTimeEpoch v15 = *(void *)(a2 + 56);
    if ((flags & 0x1D) == 1 && (v14 & 0x1D) == 1)
    {
      memset(&v31, 0, sizeof(v31));
      *(_OWORD *)&range.start.CMTimeValue value = *a1;
      range.start.CMTimeEpoch epoch = *((void *)a1 + 2);
      v25.CMTimeValue value = *(void *)(a2 + 16);
      v25.CMTimeScale timescale = *(_DWORD *)(a2 + 24);
      v25.CMTimeFlags flags = flags;
      v25.CMTimeEpoch epoch = epoch;
      cea608dgCCDataGetQuantizedTimeByFrameDuration((uint64_t)&range, &v25, (uint64_t)&v31);
      memset(&v25, 0, sizeof(v25));
      range.start.CMTimeValue value = value;
      range.start.CMTimeScale timescale = timescale;
      range.start.CMTimeFlags flags = flags;
      range.start.CMTimeEpoch epoch = epoch;
      range.duration.CMTimeValue value = v26;
      range.duration.CMTimeScale timescale = v27;
      range.duration.CMTimeFlags flags = v14;
      range.duration.CMTimeEpoch epoch = v15;
      CMTimeRangeGetEnd(&v24, &range);
      *(_OWORD *)&range.start.CMTimeValue value = v20;
      range.start.CMTimeEpoch epoch = v21;
      cea608dgCCDataGetQuantizedTimeByFrameDuration((uint64_t)&range, &v24, (uint64_t)&v25);
      range.long long start = v25;
      CMTime rhs = v31;
      CMTimeSubtract(&duration, &range.start, &rhs);
      CMTime rhs = v31;
      CMTimeRangeMake(&range, &rhs, &duration);
      CMTimeValue value = range.start.value;
      CMTimeFlags flags = range.start.flags;
      CMTimeScale timescale = range.start.timescale;
      CMTimeEpoch epoch = range.start.epoch;
      CMTimeValue v26 = range.duration.value;
      CMTimeFlags v14 = range.duration.flags;
      CMTimeScale v27 = range.duration.timescale;
      CMTimeEpoch v15 = range.duration.epoch;
    }
    range.start.CMTimeValue value = value;
    CMTimeScale v16 = timescale;
    range.start.CMTimeScale timescale = timescale;
    CMTimeValue v17 = v26;
    v31.CMTimeValue value = v26;
    CMTimeScale v18 = v27;
    v31.CMTimeScale timescale = v27;
    *((void *)v8 + 8) = value;
    *((_DWORD *)v8 + 18) = v16;
    *((_DWORD *)v8 + 19) = flags;
    *((void *)v8 + 10) = epoch;
    *((void *)v8 + 11) = v17;
    *((_DWORD *)v8 + 24) = v18;
    *((_DWORD *)v8 + 25) = v14;
    *((void *)v8 + 13) = v15;
    *a4 = v8;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigCEA608DataGeneratorAddCaptionLine(uint64_t a1, unsigned int a2, unsigned int a3, CFAttributedStringRef aStr)
{
  if (a1
    && a2 - 16 > 0xFFFFFFF0
    && a3 - 33 > 0xFFFFFFDF
    && aStr
    && CFAttributedStringGetLength(aStr)
    && (uint64_t v7 = *(void *)(a1 + 112)) != 0)
  {
    CMTime v8 = *(__CFData **)(v7 + 112);
    uint64_t v69 = a1;
    CFDictionaryRef v9 = *(const __CFDictionary **)(a1 + 88);
    CFStringRef String = CFAttributedStringGetString(aStr);
    CFIndex Length = CFStringGetLength(String);
    longestEffectiveRange.CFIndex location = 0;
    longestEffectiveRange.length = 0;
    uint64_t Limit = FigCFRangeGetLimit();
    if (Limit < FigCFRangeGetLimit())
    {
      CFAttributedStringRef aStra = aStr;
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      LODWORD(v15) = 0;
      unsigned int v16 = a2 - 1;
      unsigned int v17 = a2 & 0xFFFFFFFE;
      if ((a2 & 0xFFFFFFFE) == 0xE) {
        char v18 = 20;
      }
      else {
        char v18 = 0;
      }
      BOOL v19 = v17 == 12;
      if (v17 == 12) {
        char v20 = 19;
      }
      else {
        char v20 = v18;
      }
      if ((v19 || a2 >= 0xC) && v16 >= 0xB) {
        char v23 = a2;
      }
      else {
        char v23 = a2 - 1;
      }
      int v72 = (a3 - 1) & 3;
      if (v16 < 2) {
        char v24 = 17;
      }
      else {
        char v24 = 18;
      }
      if (v16 >= 4) {
        char v24 = 21;
      }
      if (v16 >= 6) {
        char v24 = 22;
      }
      if (v16 >= 8) {
        char v24 = 23;
      }
      if (v16 >= 0xA) {
        char v24 = 16;
      }
      if (v16 >= 0xB) {
        UInt8 v25 = v20;
      }
      else {
        UInt8 v25 = v24;
      }
      UInt8 v71 = v25;
      char v70 = 32 * (v23 & 1);
      char v26 = 1;
      CFIndex v74 = Length;
      while (1)
      {
        CFIndex v27 = FigCFRangeGetLimit();
        v90.CFIndex location = 0;
        v90.length = Length;
        CFAttributedStringGetAttributesAndLongestEffectiveRange(aStra, v27, v90, &longestEffectiveRange);
        *(_OWORD *)CMTime bytes = xmmword_194992BE0;
        FigCFDictionaryGetInt32IfPresent();
        if (*(_DWORD *)bytes > 7u
          || (FigCFDictionaryGetInt32IfPresent(), *(_DWORD *)&bytes[4] > 7u)
          || (FigCFDictionaryGetInt32IfPresent(), *(_DWORD *)&bytes[8] > 2u))
        {
          uint64_t result = FigSignalErrorAt();
          uint64_t v29 = 0;
          unint64_t v28 = 0;
          if (result) {
            return result;
          }
        }
        else
        {
          FigCFDictionaryGetBooleanIfPresent();
          FigCFDictionaryGetBooleanIfPresent();
          unint64_t v28 = *(void *)bytes;
          uint64_t v29 = *(void *)&bytes[8];
        }
        uint64_t v76 = v29;
        unint64_t v77 = v28;
        if (v26)
        {
          BOOL v30 = (v29 & 0xFF00000000) != 0;
          if (HIDWORD(v28) != 7) {
            BOOL v30 = 0;
          }
          if (v29) {
            BOOL v31 = 0;
          }
          else {
            BOOL v31 = v30;
          }
          uint64_t v32 = v29 & 0xFF0000000000;
          BOOL v33 = (v29 & 0xFF0000000000) == 0 && v31;
          if (a3 > 4 || v28 == 7)
          {
            int v36 = 0;
            unsigned int v35 = ((((a3 - 1) >> 1) & 0x7E) + 16) | v33;
          }
          else
          {
            if ((v29 & 0xFF00000000) != 0) {
              char v34 = 15;
            }
            else {
              char v34 = 14;
            }
            unsigned int v35 = v33 | (2 * v28);
            int v36 = v28;
            if (!v28 && v32)
            {
              int v36 = 0;
              char v37 = 1;
              LOBYTE(v35) = v34;
LABEL_62:
              bytes[0] = v71;
              bytes[1] = v70 | v35 | 0x40;
              CFDataAppendBytes(v8, bytes, 2);
              if (v72)
              {
                *(_WORD *)v87 = kFigCEA608TabOffsetControlCodes[v72 - 1];
                CFDataAppendBytes(v8, v87, 2);
              }
              LODWORD(v78) = v36;
              *(void *)((char *)&v78 + 4) = 7;
              BYTE12(v78) = v33;
              BYTE13(v78) = v37;
              HIWORD(v78) = 0;
              uint64_t v13 = *((void *)&v78 + 1);
              unint64_t v14 = v78;
              uint64_t v29 = v76;
              goto LABEL_65;
            }
          }
          if (v35 <= 0x1F)
          {
            char v37 = 0;
            goto LABEL_62;
          }
          uint64_t result = FigSignalErrorAt();
          uint64_t v29 = v76;
          if (result) {
            return result;
          }
        }
LABEL_65:
        if ((HIDWORD(v14) != HIDWORD(v28) || v13 != v29) && (v13 != 2 || v29 != 2))
        {
          if (v29 == 2)
          {
            char v38 = kFigCEA608ForegroundAttributeCodes;
            if (v13 != 2) {
              goto LABEL_73;
            }
          }
          unsigned int v39 = v29 + 2 * HIDWORD(v28);
          if (v39 <= 0xF)
          {
            char v38 = &kFigCEA608BackgroundAttributeCodes[v39];
LABEL_73:
            *(_WORD *)CMTime bytes = *v38;
            v87[0] = 32;
            CFDataAppendBytes(v8, v87, 1);
            cea608dgCCDataAppendPaddingIfNeeded(v8);
            CFDataAppendBytes(v8, bytes, 2);
            goto LABEL_74;
          }
          uint64_t result = FigSignalErrorAt();
          if (result) {
            return result;
          }
        }
LABEL_74:
        if (v14 != v28 || BYTE4(v13) != BYTE4(v29) || BYTE5(v13) != BYTE5(v29))
        {
          BOOL v40 = BYTE4(v29) != BYTE4(v13);
          uint64_t v41 = v29 & 0xFF0000000000;
          BOOL v42 = (v29 & 0xFF0000000000) == 0 && (BYTE5(v13) ^ BYTE5(v29)) != 0;
          if ((v29 & 0xFF0000000000) != 0) {
            BOOL v40 = 0;
          }
          if (v14 != v28 || v40 || v42)
          {
            if (BYTE4(v29)) {
              BOOL v43 = v41 == 0;
            }
            else {
              BOOL v43 = 0;
            }
            int v44 = v43;
            if (v28 == 7)
            {
              BOOL v19 = v44 == 0;
              uint64_t v45 = 1;
              if (!v19) {
                uint64_t v45 = 2;
              }
              *(_WORD *)CMTime bytes = kFigCEA608ForegroundAttributeCodes[v45];
              v87[0] = 32;
              CFDataAppendBytes(v8, v87, 1);
              cea608dgCCDataAppendPaddingIfNeeded(v8);
            }
            else
            {
              unsigned int v46 = v44 | (2 * v28);
              if (v46 > 0xF)
              {
                uint64_t result = FigSignalErrorAt();
                if (result) {
                  return result;
                }
                goto LABEL_102;
              }
              *(_WORD *)CMTime bytes = kFigCEA608MidRowCodes[v46];
            }
            CFDataAppendBytes(v8, bytes, 2);
          }
          if (v41)
          {
            uint64_t v47 = 15;
            if (!BYTE4(v29)) {
              uint64_t v47 = 14;
            }
            *(_WORD *)CMTime bytes = kFigCEA608MidRowCodes[v47];
            CFDataAppendBytes(v8, bytes, 2);
          }
        }
LABEL_102:
        if (!v15)
        {
          unint64_t v48 = CFDataGetLength(v8);
          BytePtr = CFDataGetBytePtr(v8);
          if (v48 < 2)
          {
LABEL_107:
            unint64_t v15 = (unint64_t)CFDataGetLength(v8) >> 1;
          }
          else
          {
            unint64_t v15 = 0;
            while (1)
            {
              int v50 = *BytePtr;
              BytePtr += 2;
              if (v50 == 32) {
                break;
              }
              if (v48 >> 1 == ++v15) {
                goto LABEL_107;
              }
            }
          }
        }
        CFIndex location = longestEffectiveRange.location;
        *(_WORD *)buffer = 0;
        v52.CFIndex location = CFDataGetLength(v8) - 2;
        if (v52.location >= 0)
        {
          v52.length = 2;
          CFDataGetBytes(v8, v52, buffer);
        }
        if (location < FigCFRangeGetLimit())
        {
          CFIndex v53 = location;
          do
          {
            *(_WORD *)v83 = 0;
            int v82 = 0;
            __int16 v81 = 0;
            unsigned int CharacterAtIndex = CFStringGetCharacterAtIndex(String, v53);
            if (!cea608dgCharacterMappingGetControlCodeForCharacter(v9, CharacterAtIndex, (char *)v83, &v82, (char *)&v81 + 1, (char *)&v81))
            {
              v83[0] = 127;
              int v82 = 1;
            }
            if (HIBYTE(v81) && buffer[0] == v83[0])
            {
              if (buffer[1] == v83[1]) {
                int v55 = 2;
              }
              else {
                int v55 = 1;
              }
            }
            else
            {
              int v55 = 1;
            }
            if ((_BYTE)v81)
            {
              uint64_t v56 = 0;
              *(void *)CMTime bytes = 0;
              char v57 = 1;
              do
              {
                char v58 = v57;
                CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v9, off_1E578B310[v56]);
                int ValueIfPresent = CFDictionaryGetValueIfPresent(Value, (const void *)CharacterAtIndex, (const void **)bytes);
                if (ValueIfPresent == 1)
                {
                  unsigned __int16 v62 = *(_WORD *)bytes;
                  goto LABEL_128;
                }
                if (ValueIfPresent) {
                  break;
                }
                char v57 = 0;
                uint64_t v56 = 1;
              }
              while ((v58 & 1) != 0);
              uint64_t result = FigSignalErrorAt();
              unsigned __int16 v62 = 0;
              if (result) {
                return result;
              }
LABEL_128:
              *(_WORD *)v88 = 0;
              *(_DWORD *)v87 = 0;
              char v85 = 0;
              if (cea608dgCharacterMappingGetControlCodeForCharacter(v9, v62, (char *)v88, (int *)v87, &v86, &v85) == 1&& *(_DWORD *)v87 == 1&& v85 == 0)
              {
                CFDataAppendBytes(v8, v88, 1);
              }
              else
              {
                uint64_t result = FigSignalErrorAt();
                if (result) {
                  return result;
                }
              }
            }
            int v65 = v82;
            if (v82 == 1) {
              CFIndex v66 = 1;
            }
            else {
              CFIndex v66 = 2;
            }
            do
            {
              if (v65 == 2) {
                cea608dgCCDataAppendPaddingIfNeeded(v8);
              }
              CFDataAppendBytes(v8, v83, v66);
              --v55;
            }
            while (v55);
            *(_WORD *)buffer = *(_WORD *)v83;
            ++v53;
          }
          while (v53 < FigCFRangeGetLimit());
        }
        cea608dgCCDataAppendPaddingIfNeeded(v8);
        uint64_t v13 = v76;
        unint64_t v14 = v77;
        uint64_t v67 = FigCFRangeGetLimit();
        CFIndex Length = v74;
        char v26 = 0;
        if (v67 >= FigCFRangeGetLimit()) {
          goto LABEL_158;
        }
      }
    }
    LODWORD(v15) = 0;
LABEL_158:
    uint64_t v68 = *(void *)(v69 + 112);
    uint64_t result = 0;
    if (!*(_DWORD *)(v68 + 120)) {
      *(_DWORD *)(v68 + 120) = v15;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t FigCEA608DataGeneratorEndCaption(uint64_t a1, CMTime *a2, CMTime *a3, uint64_t a4)
{
  if (a1 && *(void *)(a1 + 112))
  {
    uint64_t result = cea608dgStoreCCDataSequentially(a1, a2, a3);
    if (a4)
    {
      if (!result)
      {
        long long v7 = *(_OWORD *)(a1 + 120);
        *(void *)(a4 + 16) = *(void *)(a1 + 136);
        *(_OWORD *)a4 = v7;
      }
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t cea608dgStoreCCDataSequentially(uint64_t a1, CMTime *a2, CMTime *a3)
{
  uint64_t v180 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef allocator = *(const __CFAllocator **)a1;
  long long v129 = *(_OWORD *)(a1 + 60);
  CMTimeEpoch v130 = *(void *)(a1 + 76);
  CFAllocatorRef v4 = (_OWORD *)MEMORY[0x1E4F1F9F8];
  CMTimeValue v164 = *MEMORY[0x1E4F1F9F8];
  CMTimeScale v165 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  CMTimeEpoch v5 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  uint64_t v6 = MEMORY[0x1E4F1FA20];
  CMTimeValue v7 = *MEMORY[0x1E4F1FA20];
  CMTimeValue v162 = v7;
  CMTimeScale v8 = *(_DWORD *)(MEMORY[0x1E4F1FA20] + 8);
  CMTimeScale v163 = v8;
  CMTimeValue v160 = v7;
  CMTimeScale v161 = v8;
  long long v9 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  long long v122 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  long long v123 = *MEMORY[0x1E4F1FA20];
  *(_OWORD *)&v128.start.CMTimeValue value = *MEMORY[0x1E4F1FA20];
  *(_OWORD *)&v128.start.CMTimeEpoch epoch = v122;
  long long v121 = v9;
  *(_OWORD *)&v128.duration.CMTimeScale timescale = v9;
  uint64_t v10 = *(void *)(a1 + 112);
  v108 = (CMTime *)(a1 + 60);
  if (v10)
  {
    *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(a1 + 60);
    time1.start.CMTimeEpoch epoch = *(void *)(a1 + 76);
    int v11 = *(_DWORD *)(v10 + 8);
    *(_OWORD *)v169 = *MEMORY[0x1E4F1F9F8];
    *(void *)&v169[16] = v5;
    if (v11 == 1 && (long long v12 = *(const void **)(v10 + 112)) != 0) {
      CFDataRef v13 = (const __CFData *)CFRetain(v12);
    }
    else {
      CFDataRef v13 = 0;
    }
    *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)&time1.start.value;
    range.start.CMTimeEpoch epoch = time1.start.epoch;
    uint64_t v14 = cea608dgCCDataGetDuration(v13, &range.start, (CMTime *)v169);
    if (v14)
    {
      uint64_t v31 = v14;
      goto LABEL_155;
    }
    CMTimeValue v164 = *(void *)v169;
    CMTimeFlags v107 = *(_DWORD *)&v169[12];
    CMTimeScale v165 = *(_DWORD *)&v169[8];
    CMTimeEpoch v106 = *(void *)&v169[16];
    if (v11 == 1 && v13) {
      *(unsigned char *)(a1 + 101) = 1;
    }
  }
  else
  {
    CFDataRef v13 = 0;
    CMTimeFlags v107 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
    CMTimeEpoch v106 = v5;
  }
  CFDataRef v116 = v13;
  CMTimeFlags v15 = *(_DWORD *)(v6 + 12);
  CMTimeEpoch v16 = *(void *)(v6 + 16);
  CMTimeValue v17 = *(void *)(v6 + 24);
  CMTimeScale v18 = *(_DWORD *)(v6 + 32);
  CMTimeFlags v19 = *(_DWORD *)(v6 + 36);
  CMTimeEpoch v20 = *(void *)(v6 + 40);
  uint64_t v21 = *(void *)(a1 + 104);
  CMTimeValue v99 = v17;
  CMTimeEpoch v100 = v16;
  CMTimeEpoch v98 = v20;
  CMTimeFlags v96 = v19;
  CMTimeScale v97 = v18;
  if (!v21)
  {
    CMTimeValue value = 0;
    CMTimeFlags v104 = v15;
    CMTimeEpoch v28 = v16;
    CMTimeValue v120 = v17;
    CMTimeScale v115 = v18;
    CMTimeFlags v29 = v19;
    CMTimeEpoch v111 = v20;
    goto LABEL_31;
  }
  uint64_t v22 = *(void *)(a1 + 112);
  int v23 = *(unsigned __int8 *)(a1 + 8);
  v149.CMTimeValue value = 0;
  *(_OWORD *)v169 = v123;
  *(_OWORD *)&v169[16] = v122;
  *(_OWORD *)&v169[32] = v121;
  if (v22)
  {
    long long v24 = *(_OWORD *)(v21 + 80);
    *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)(v21 + 64);
    *(_OWORD *)&range.start.CMTimeEpoch epoch = v24;
    *(_OWORD *)&range.duration.CMTimeScale timescale = *(_OWORD *)(v21 + 96);
    CMTimeRangeGetEnd(&time1.start, &range);
    *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)(v22 + 64);
    range.start.CMTimeEpoch epoch = *(void *)(v22 + 80);
    int32_t v25 = CMTimeCompare(&time1.start, &range.start);
    int v26 = *(_DWORD *)(v22 + 8);
    if (v26 == 3)
    {
      if (*(_DWORD *)(v21 + 8) != 3)
      {
        *(_OWORD *)&v148.start.CMTimeValue value = *v4;
        v148.start.CMTimeEpoch epoch = v5;
        uint64_t v33 = *(int *)(v22 + 120);
        *(_OWORD *)&range.start.CMTimeValue value = v129;
        range.start.CMTimeEpoch epoch = v130;
        uint64_t AheadDuration = cea608dgGetAheadDuration(&range.start, v33, &v148.start);
        if (AheadDuration)
        {
          uint64_t v31 = AheadDuration;
LABEL_172:
          CFDataRef v13 = v116;
          goto LABEL_155;
        }
        memset(&v147, 0, 24);
        *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)(v22 + 64);
        range.start.CMTimeEpoch epoch = *(void *)(v22 + 80);
        *(_OWORD *)&rhs.start.CMTimeValue value = *(_OWORD *)&v148.start.value;
        rhs.start.CMTimeEpoch epoch = v148.start.epoch;
        CMTimeSubtract(&v147.start, &range.start, &rhs.start);
        long long v35 = *(_OWORD *)(v21 + 80);
        *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)(v21 + 64);
        *(_OWORD *)&range.start.CMTimeEpoch epoch = v35;
        *(_OWORD *)&range.duration.CMTimeScale timescale = *(_OWORD *)(v21 + 96);
        CMTimeRangeGetEnd(&time2, &range);
        *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)&v147.start.value;
        range.start.CMTimeEpoch epoch = v147.start.epoch;
        int32_t v25 = CMTimeCompare(&range.start, &time2);
      }
      goto LABEL_26;
    }
    if (v26 != 2)
    {
      if (v26 != 1) {
        goto LABEL_27;
      }
      if (v23) {
        goto LABEL_21;
      }
LABEL_26:
      if (v25) {
        goto LABEL_21;
      }
LABEL_27:
      CMTimeValue value = 0;
      int v32 = 0;
      goto LABEL_28;
    }
    if (!v25 && *(_DWORD *)(v21 + 8) == 2) {
      goto LABEL_27;
    }
  }
LABEL_21:
  long long v30 = *(_OWORD *)(v21 + 80);
  *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)(v21 + 64);
  *(_OWORD *)&range.start.CMTimeEpoch epoch = v30;
  *(_OWORD *)&range.duration.CMTimeScale timescale = *(_OWORD *)(v21 + 96);
  CMTimeRangeGetEnd(&v151, &range);
  *(_OWORD *)&range.start.CMTimeValue value = v129;
  range.start.CMTimeEpoch epoch = v130;
  uint64_t v31 = cea608dgCreateEraseCCData((uint64_t)&range, &v151, allocator, (const __CFData **)&v149, v169);
  CMTimeValue value = v149.value;
  if (v31)
  {
    if (v149.value) {
      CFRelease((CFTypeRef)v149.value);
    }
    goto LABEL_172;
  }
  int v32 = 1;
LABEL_28:
  CMTimeValue v162 = *(void *)v169;
  CMTimeFlags v104 = *(_DWORD *)&v169[12];
  CMTimeScale v163 = *(_DWORD *)&v169[8];
  CMTimeEpoch v28 = *(void *)&v169[16];
  CMTimeValue v120 = *(void *)&v169[24];
  CMTimeScale v115 = *(_DWORD *)&v169[32];
  CMTimeFlags v29 = *(_DWORD *)&v169[36];
  CMTimeEpoch v111 = *(void *)&v169[40];
  if (value && v32) {
    *(unsigned char *)(a1 + 100) = 0;
  }
LABEL_31:
  CFDataRef theData = (const __CFData *)value;
  uint64_t v36 = *(void *)(a1 + 112);
  CMTimeFlags v95 = v15;
  if (!v36)
  {
    CMTimeEpoch v39 = v28;
    CFDataRef v117 = 0;
    CMTimeFlags v119 = v15;
    CMTimeEpoch v114 = v100;
    CMTimeScale v101 = v97;
    CMTimeFlags v113 = v96;
    CMTimeValue v109 = v99;
    CMTimeEpoch v110 = v98;
    CFDataRef v13 = v116;
    uint64_t v41 = v108;
    goto LABEL_50;
  }
  int v37 = *(_DWORD *)(v36 + 8);
  *(_OWORD *)v169 = v123;
  *(_OWORD *)&v169[16] = v122;
  *(_OWORD *)&v169[32] = v121;
  if ((v37 - 2) < 2)
  {
    char v38 = *(const void **)(v36 + 112);
    CMTimeEpoch v39 = v28;
    if (v38) {
      CFDataRef v40 = (const __CFData *)CFRetain(v38);
    }
    else {
      CFDataRef v40 = 0;
    }
    *(_OWORD *)&range.start.CMTimeValue value = *v4;
    range.start.CMTimeEpoch epoch = v5;
    uint64_t v44 = *(int *)(v36 + 120);
    *(_OWORD *)&time1.start.CMTimeValue value = v129;
    time1.start.CMTimeEpoch epoch = v130;
    uint64_t v45 = cea608dgGetAheadDuration(&time1.start, v44, &range.start);
    if (v45)
    {
      uint64_t v31 = v45;
      CFDataRef v13 = v116;
      goto LABEL_151;
    }
    *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(v36 + 64);
    time1.start.CMTimeEpoch epoch = *(void *)(v36 + 80);
    *(_OWORD *)&v148.start.CMTimeValue value = *(_OWORD *)&range.start.value;
    v148.start.CMTimeEpoch epoch = range.start.epoch;
    CMTimeSubtract((CMTime *)v169, &time1.start, &v148.start);
    goto LABEL_43;
  }
  CMTimeEpoch v39 = v28;
  if (v37 != 1)
  {
    CFDataRef v40 = 0;
LABEL_43:
    char v43 = 1;
    uint64_t v41 = v108;
    goto LABEL_44;
  }
  LOWORD(range.start.value) = 12052;
  CFDataRef v42 = CFDataCreate(allocator, (const UInt8 *)&range, 2);
  uint64_t v41 = v108;
  if (v42)
  {
    CFDataRef v40 = v42;
    char v43 = 0;
    *(_OWORD *)v169 = *(_OWORD *)(v36 + 64);
    *(void *)&v169[16] = *(void *)(v36 + 80);
LABEL_44:
    *(_OWORD *)&range.start.CMTimeValue value = v129;
    range.start.CMTimeEpoch epoch = v130;
    uint64_t v46 = cea608dgCCDataGetDuration(v40, &range.start, (CMTime *)&v169[24]);
    CFDataRef v13 = v116;
    if (v46) {
      goto LABEL_169;
    }
    CMTimeValue v160 = *(void *)v169;
    CMTimeFlags v119 = *(_DWORD *)&v169[12];
    CMTimeScale v161 = *(_DWORD *)&v169[8];
    CMTimeEpoch v114 = *(void *)&v169[16];
    CMTimeFlags v113 = *(_DWORD *)&v169[36];
    CMTimeScale v101 = *(_DWORD *)&v169[32];
    CMTimeValue v109 = *(void *)&v169[24];
    CMTimeEpoch v110 = *(void *)&v169[40];
    CFDataRef v117 = v40;
    if (v40)
    {
      if (v43)
      {
        *(unsigned char *)(a1 + 100) = 1;
      }
      else
      {
        char v47 = *(unsigned char *)(a1 + 100);
        *(unsigned char *)(a1 + 100) = *(unsigned char *)(a1 + 101);
        *(unsigned char *)(a1 + 101) = v47;
      }
    }
    else
    {
      CFDataRef v117 = 0;
    }
LABEL_50:
    unint64_t v48 = *(_OWORD **)(a1 + 112);
    if (v48)
    {
      long long v49 = v48[5];
      *(_OWORD *)v169 = v48[4];
      *(_OWORD *)&v169[16] = v49;
      *(_OWORD *)&v169[32] = v48[6];
      CMTimeRangeGetEnd(&v127, (CMTimeRange *)v169);
      *(_OWORD *)v169 = v129;
      *(void *)&v169[16] = v130;
      uint64_t v50 = cea608dgCreateEraseCCData((uint64_t)v169, &v127, allocator, 0, &v128);
      if (v50)
      {
        uint64_t v31 = v50;
        CFDataRef v40 = v117;
        goto LABEL_151;
      }
    }
    CMTimeValue v158 = v164;
    CMTimeScale v159 = v165;
    CMTimeValue v156 = v162;
    CMTimeScale timescale = v163;
    CMTimeValue v154 = v160;
    CMTimeScale v155 = v161;
    CMTimeRange rhs = v128;
    memset(&v149, 0, sizeof(v149));
    CMTimeMakeWithSeconds(&v149, 3.0, *(_DWORD *)(a1 + 68));
    *(_OWORD *)&v148.start.CMTimeValue value = v123;
    *(_OWORD *)&v148.start.CMTimeEpoch epoch = v122;
    *(_OWORD *)&v148.duration.CMTimeScale timescale = v121;
    *(_OWORD *)&v147.start.CMTimeValue value = v123;
    *(_OWORD *)&v147.start.CMTimeEpoch epoch = v122;
    *(_OWORD *)&v147.duration.CMTimeScale timescale = v121;
    long long v179 = 0u;
    long long v178 = 0u;
    long long v177 = 0u;
    long long v176 = 0u;
    memset(&v175, 0, sizeof(v175));
    long long v174 = 0u;
    long long v173 = 0u;
    long long v172 = 0u;
    long long v171 = 0u;
    long long v170 = 0u;
    memset(v169, 0, sizeof(v169));
    CMTimeValue v167 = v7;
    CMTimeScale v168 = v8;
    *(_OWORD *)&v146.CMTimeValue value = *MEMORY[0x1E4F1FA48];
    CMTimeEpoch v51 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
    v146.CMTimeEpoch epoch = v51;
    *(_OWORD *)&v145.CMTimeValue value = *(_OWORD *)&v146.value;
    v145.CMTimeEpoch epoch = v51;
    *(_OWORD *)CFAllocatorRef allocatora = *(_OWORD *)&v146.value;
    *(_OWORD *)&v144.CMTimeValue value = *(_OWORD *)&v146.value;
    v144.CMTimeEpoch epoch = v51;
    CMTimeFlags v52 = v29;
    CMTimeFlags flags = v104;
    if ((v104 & 1) == 0 || (v52 & 1) == 0 || v111 || (CMTimeEpoch epoch = v39, v112 = 0, v120 < 0))
    {
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(a1 + 120);
      time1.start.CMTimeEpoch epoch = *(void *)(a1 + 136);
      *(_OWORD *)&time2.CMTimeValue value = *(_OWORD *)&v146.value;
      time2.CMTimeEpoch epoch = v51;
      CMTimeRangeMake(&range, &time1.start, &time2);
      CMTimeValue v156 = range.start.value;
      CMTimeFlags flags = range.start.flags;
      CMTimeScale timescale = range.start.timescale;
      CMTimeEpoch epoch = range.start.epoch;
      CMTimeValue v120 = range.duration.value;
      CMTimeScale v115 = range.duration.timescale;
      CMTimeFlags v52 = range.duration.flags;
      CMTimeEpoch v112 = range.duration.epoch;
    }
    if (!*(unsigned char *)(a1 + 9)
      || (range.start.CMTimeValue value = v156,
          range.start.CMTimeScale timescale = timescale,
          range.start.CMTimeFlags flags = flags,
          range.start.CMTimeEpoch epoch = epoch,
          *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(a1 + 120),
          time1.start.CMTimeEpoch epoch = *(void *)(a1 + 136),
          (CMTimeCompare(&range.start, &time1.start) & 0x80000000) == 0))
    {
      memset(&v143, 0, sizeof(v143));
      range.start.CMTimeValue value = v156;
      range.start.CMTimeScale timescale = timescale;
      range.start.CMTimeFlags flags = flags;
      range.start.CMTimeEpoch epoch = epoch;
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(a1 + 120);
      time1.start.CMTimeEpoch epoch = *(void *)(a1 + 136);
      CMTimeSubtract(&v143, &range.start, &time1.start);
      CMTimeEpoch v105 = epoch;
      if ((v107 & 1) != 0
        && (range.start.CMTimeValue value = v164,
            range.start.CMTimeScale timescale = v165,
            range.start.CMTimeFlags flags = v107,
            range.start.CMTimeEpoch epoch = v106,
            *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)allocatora,
            time1.start.CMTimeEpoch epoch = v51,
            CMTimeCompare(&range.start, &time1.start)))
      {
        memset(&time1, 0, 24);
        range.start.CMTimeValue value = v156;
        range.start.CMTimeScale timescale = timescale;
        range.start.CMTimeFlags flags = flags;
        range.start.CMTimeEpoch epoch = epoch;
        range.duration.CMTimeValue value = v120;
        range.duration.CMTimeScale timescale = v115;
        range.duration.CMTimeFlags flags = v52;
        range.duration.CMTimeEpoch epoch = v112;
        CMTimeRangeGetEnd(&v142, &range);
        range.start.CMTimeValue value = v154;
        range.start.CMTimeScale timescale = v155;
        range.start.CMTimeFlags flags = v119;
        range.start.CMTimeEpoch epoch = v114;
        CMTimeSubtract(&time1.start, &range.start, &v142);
        range.start.CMTimeValue value = v158;
        range.start.CMTimeScale timescale = v159;
        range.start.CMTimeFlags flags = v107;
        range.start.CMTimeEpoch epoch = v106;
        CMTime time2 = v143;
        if (CMTimeCompare(&range.start, &time2) <= 0
          && (*(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)&time1.start.value,
              range.start.CMTimeEpoch epoch = time1.start.epoch,
              CMTime time2 = v149,
              CMTimeCompare(&range.start, &time2) <= 0))
        {
          range.start.CMTimeValue value = v156;
          range.start.CMTimeScale timescale = timescale;
          range.start.CMTimeFlags flags = flags;
          range.start.CMTimeEpoch epoch = epoch;
          time2.CMTimeValue value = v158;
          time2.CMTimeScale timescale = v159;
          time2.CMTimeFlags flags = v107;
          time2.CMTimeEpoch epoch = v106;
          CMTimeSubtract(&v141, &range.start, &time2);
          range.start.CMTimeValue value = v158;
          range.start.CMTimeScale timescale = v159;
          range.start.CMTimeFlags flags = v107;
          range.start.CMTimeEpoch epoch = v106;
          CMTimeRangeMake(&v148, &v141, &range.start);
          int v58 = 0;
        }
        else
        {
          range.start.CMTimeValue value = v158;
          range.start.CMTimeScale timescale = v159;
          range.start.CMTimeFlags flags = v107;
          range.start.CMTimeEpoch epoch = v106;
          CMTime time2 = time1.start;
          if (CMTimeCompare(&range.start, &time2) > 0)
          {
            CMTime time2 = time1.start;
            memset(&v151, 0, sizeof(v151));
            range.start.CMTimeValue value = v154;
            range.start.CMTimeScale timescale = v155;
            range.start.CMTimeFlags flags = v119;
            range.start.CMTimeEpoch epoch = v114;
            CMTime start = time1.start;
            CMTimeSubtract(&v151, &range.start, &start);
            CMTime start = v151;
            CMTime duration = time2;
            CMTimeRangeMake(&range, &start, &duration);
            CMTimeRange v147 = range;
            memset(&start, 0, sizeof(start));
            range.start.CMTimeValue value = v158;
            range.start.CMTimeScale timescale = v159;
            range.start.CMTimeFlags flags = v107;
            range.start.CMTimeEpoch epoch = v106;
            CMTime duration = time2;
            CMTimeSubtract(&start, &range.start, &duration);
            memset(&duration, 0, sizeof(duration));
            range.start.CMTimeValue value = v156;
            range.start.CMTimeScale timescale = timescale;
            range.start.CMTimeFlags flags = flags;
            range.start.CMTimeEpoch epoch = epoch;
            CMTime v138 = start;
            CMTimeSubtract(&duration, &range.start, &v138);
            CMTime v138 = duration;
            CMTime v137 = start;
            CMTimeRangeMake(&range, &v138, &v137);
            CMTimeRange v148 = range;
            range.CMTime start = range.duration;
            CMTime v138 = v143;
            CMTimeSubtract(&v146, &range.start, &v138);
            *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)allocatora;
            range.start.CMTimeEpoch epoch = v51;
            CMTime v138 = v146;
            if (CMTimeCompare(&range.start, &v138) < 0)
            {
              CMTime v145 = v146;
              if (*(unsigned char *)(a1 + 9))
              {
                CMTime v138 = v148.start;
                CMTime v137 = v146;
                CMTimeAdd(&range.start, &v138, &v137);
                *(_OWORD *)&v148.start.CMTimeValue value = *(_OWORD *)&range.start.value;
                v148.start.CMTimeEpoch epoch = range.start.epoch;
                CMTime v138 = v148.duration;
                CMTime v137 = v145;
                CMTimeSubtract(&range.start, &v138, &v137);
                v148.CMTime duration = range.start;
                CMTime v138 = v147.duration;
                CMTime v137 = v145;
                CMTimeAdd(&range.start, &v138, &v137);
                v147.CMTime duration = range.start;
                v138.CMTimeValue value = v154;
                v138.CMTimeScale timescale = v155;
                v138.CMTimeFlags flags = v119;
                v138.CMTimeEpoch epoch = v114;
                CMTime v137 = v145;
                CMTimeAdd(&range.start, &v138, &v137);
                CMTimeFlags v62 = range.start.flags;
                CMTimeScale v155 = range.start.timescale;
                CMTimeValue v154 = range.start.value;
                CMTimeEpoch v63 = range.start.epoch;
                *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)&rhs.start.value;
                range.start.CMTimeEpoch epoch = rhs.start.epoch;
                v138.CMTimeValue value = v154;
                v138.CMTimeScale timescale = v155;
                CMTimeFlags v119 = v62;
                v138.CMTimeFlags flags = v62;
                CMTimeEpoch v114 = v63;
                v138.CMTimeEpoch epoch = v63;
                int32_t v64 = CMTimeCompare(&range.start, &v138);
                if (v64 >= 1) {
                  CFDataRef v56 = v117;
                }
                else {
                  CFDataRef v56 = 0;
                }
                if (v64 >= 1) {
                  CFDataRef v55 = v116;
                }
                else {
                  CFDataRef v55 = 0;
                }
                long long v57 = *(_OWORD *)allocatora;
                goto LABEL_90;
              }
              CFDataRef v55 = v116;
              CFDataRef v56 = v117;
            }
            else
            {
              CFDataRef v55 = v13;
              CFDataRef v56 = v117;
            }
            long long v57 = *(_OWORD *)allocatora;
LABEL_90:
            int v58 = 0;
            goto LABEL_98;
          }
          range.start.CMTimeValue value = v154;
          range.start.CMTimeScale timescale = v155;
          range.start.CMTimeFlags flags = v119;
          range.start.CMTimeEpoch epoch = v114;
          time2.CMTimeValue value = v158;
          time2.CMTimeScale timescale = v159;
          time2.CMTimeFlags flags = v107;
          time2.CMTimeEpoch epoch = v106;
          CMTimeSubtract(&v140, &range.start, &time2);
          range.start.CMTimeValue value = v158;
          range.start.CMTimeScale timescale = v159;
          range.start.CMTimeFlags flags = v107;
          range.start.CMTimeEpoch epoch = v106;
          CMTimeRangeMake(&v147, &v140, &range.start);
          int v58 = 1;
        }
      }
      else
      {
        int v58 = 1;
        if (v119)
        {
          long long v57 = *(_OWORD *)allocatora;
          if ((v113 & 1) == 0 || v110 || v109 < 0)
          {
            CFDataRef v55 = v13;
            CFDataRef v56 = v117;
            goto LABEL_98;
          }
          range.start.CMTimeValue value = v156;
          range.start.CMTimeScale timescale = timescale;
          range.start.CMTimeFlags flags = flags;
          range.start.CMTimeEpoch epoch = epoch;
          range.duration.CMTimeValue value = v120;
          range.duration.CMTimeScale timescale = v115;
          range.duration.CMTimeFlags flags = v52;
          range.duration.CMTimeEpoch epoch = v112;
          CMTimeRangeGetEnd(&lhs, &range);
          time1.start.CMTimeValue value = v154;
          time1.start.CMTimeScale timescale = v155;
          time1.start.CMTimeFlags flags = v119;
          time1.start.CMTimeEpoch epoch = v114;
          CMTimeSubtract(&range.start, &lhs, &time1.start);
          CMTime v146 = range.start;
          memset(&time1, 0, 24);
          range.start.CMTimeValue value = v154;
          range.start.CMTimeScale timescale = v155;
          range.start.CMTimeFlags flags = v119;
          range.start.CMTimeEpoch epoch = v114;
          range.duration.CMTimeValue value = v109;
          range.duration.CMTimeScale timescale = v101;
          range.duration.CMTimeFlags flags = v113;
          range.duration.CMTimeEpoch epoch = 0;
          CMTimeRangeGetEnd(&v135, &range);
          *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)&rhs.start.value;
          range.start.CMTimeEpoch epoch = rhs.start.epoch;
          CMTimeSubtract(&time1.start, &v135, &range.start);
          *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)allocatora;
          range.start.CMTimeEpoch epoch = v51;
          CMTime time2 = v146;
          if (CMTimeCompare(&range.start, &time2) < 0)
          {
            CMTime v145 = v146;
            if (*(unsigned char *)(a1 + 9))
            {
              time2.CMTimeValue value = v154;
              time2.CMTimeScale timescale = v155;
              time2.CMTimeFlags flags = v119;
              time2.CMTimeEpoch epoch = v114;
              CMTime v151 = v146;
              CMTimeAdd(&range.start, &time2, &v151);
              CMTimeFlags v59 = range.start.flags;
              CMTimeScale v155 = range.start.timescale;
              CMTimeValue v154 = range.start.value;
              CMTimeEpoch v60 = range.start.epoch;
              *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)&rhs.start.value;
              range.start.CMTimeEpoch epoch = rhs.start.epoch;
              time2.CMTimeValue value = v154;
              time2.CMTimeScale timescale = v155;
              CMTimeFlags v119 = v59;
              time2.CMTimeFlags flags = v59;
              CMTimeEpoch v114 = v60;
              time2.CMTimeEpoch epoch = v60;
              int32_t v61 = CMTimeCompare(&range.start, &time2);
              if (v61 >= 1) {
                CFDataRef v56 = v117;
              }
              else {
                CFDataRef v56 = 0;
              }
              if (v61 >= 1) {
                CFDataRef v55 = v116;
              }
              else {
                CFDataRef v55 = 0;
              }
            }
            else
            {
              CFDataRef v55 = v116;
              CFDataRef v56 = v117;
            }
          }
          else
          {
            CFDataRef v55 = v13;
            CFDataRef v56 = v117;
          }
          *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)allocatora;
          range.start.CMTimeEpoch epoch = v51;
          CMTime time2 = time1.start;
          if (CMTimeCompare(&range.start, &time2) < 0) {
            CMTime v144 = time1.start;
          }
          int v58 = 1;
          goto LABEL_97;
        }
      }
      CFDataRef v55 = v13;
      CFDataRef v56 = v117;
LABEL_97:
      long long v57 = *(_OWORD *)allocatora;
LABEL_98:
      range.CMTime start = v145;
      *(_OWORD *)&time1.start.CMTimeValue value = v57;
      time1.start.CMTimeEpoch epoch = v51;
      CMTimeCompare(&range.start, &time1.start);
      uint64_t v134 = 0;
      range.CMTime start = v148.duration;
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&v41->value;
      time1.start.CMTimeEpoch epoch = v41->epoch;
      uint64_t ByteLengthFromDuration = cea608dgCCDataGetByteLengthFromDuration((uint64_t)&range, (uint64_t)&time1, &v134);
      if (ByteLengthFromDuration
        || (uint64_t v133 = 0,
            range.CMTime start = v147.duration,
            *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&v41->value,
            time1.start.CMTimeEpoch epoch = v41->epoch,
            uint64_t ByteLengthFromDuration = cea608dgCCDataGetByteLengthFromDuration((uint64_t)&range, (uint64_t)&time1, &v133),
            ByteLengthFromDuration))
      {
        uint64_t v31 = ByteLengthFromDuration;
      }
      else
      {
        if (v55)
        {
          *(void *)v169 = CFDataGetBytePtr(v55);
          *(void *)&v169[8] = v134;
          *(CMTimeRange *)&v169[16] = v148;
        }
        CFDataRef v66 = theData;
        if (!theData)
        {
          uint64_t v68 = 0;
          if (!v55) {
            goto LABEL_114;
          }
          goto LABEL_113;
        }
        if (!v58)
        {
          CMTimeEpoch v67 = v112;
          uint64_t v68 = 0;
          goto LABEL_112;
        }
        CMTimeEpoch v67 = v112;
        *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)allocatora;
        range.start.CMTimeEpoch epoch = v51;
        time1.CMTime start = v143;
        if ((CMTimeCompare(&range.start, &time1.start) & 0x80000000) == 0)
        {
          uint64_t v68 = 0;
          CFDataRef v66 = theData;
          goto LABEL_112;
        }
        CFAllocatorRef v69 = *(const __CFAllocator **)a1;
        duration.CMTimeValue value = v156;
        duration.CMTimeScale timescale = timescale;
        CMTime start = *v41;
        LOWORD(v138.value) = kFigCEA608MiscControlCodes;
        CFIndex Length = CFDataGetLength(theData);
        *(_OWORD *)&range.start.CMTimeValue value = v123;
        *(_OWORD *)&range.start.CMTimeEpoch epoch = v122;
        *(_OWORD *)&range.duration.CMTimeScale timescale = v121;
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(v69, Length + 2);
        uint64_t v68 = Mutable;
        if (Mutable)
        {
          CFDataAppendBytes(Mutable, (const UInt8 *)&v138, 2);
          BytePtr = CFDataGetBytePtr(theData);
          CFIndex v73 = CFDataGetLength(theData);
          CFDataAppendBytes(v68, BytePtr, v73);
          time1.start.CMTimeValue value = duration.value;
          time1.start.CMTimeScale timescale = duration.timescale;
          time1.start.CMTimeFlags flags = flags;
          time1.start.CMTimeEpoch epoch = v105;
          CMTime time2 = start;
          CMTimeSubtract(&range.start, &time1.start, &time2);
          time2.CMTimeValue value = v120;
          time2.CMTimeScale timescale = v115;
          time2.CMTimeFlags flags = v52;
          time2.CMTimeEpoch epoch = v112;
          CMTime v151 = start;
          CMTimeAdd(&time1.start, &time2, &v151);
          *(_OWORD *)&range.duration.CMTimeValue value = *(_OWORD *)&time1.start.value;
          CMTimeEpoch v74 = time1.start.epoch;
          CMTimeValue v167 = range.start.value;
          CMTimeFlags flags = range.start.flags;
          CMTimeScale v168 = range.start.timescale;
          CMTimeEpoch v75 = range.start.epoch;
          CMTimeValue v76 = time1.start.value;
          CMTimeScale v77 = time1.start.timescale;
          CMTimeFlags v52 = time1.start.flags;
LABEL_111:
          CMTimeValue v156 = v167;
          CMTimeEpoch v67 = v74;
          CMTimeScale v115 = v77;
          CMTimeScale timescale = v168;
          CMTimeValue v120 = v76;
          CMTimeEpoch v105 = v75;
          CFDataRef v66 = v68;
LABEL_112:
          *(void *)&long long v170 = CFDataGetBytePtr(v66);
          *((void *)&v170 + 1) = CFDataGetLength(v66);
          *(void *)&long long v171 = v156;
          *((void *)&v171 + 1) = __PAIR64__(flags, timescale);
          *(void *)&long long v172 = v105;
          *((void *)&v172 + 1) = v120;
          *(void *)&long long v173 = __PAIR64__(v52, v115);
          *((void *)&v173 + 1) = v67;
          if (!v55)
          {
LABEL_114:
            if (v56)
            {
              *(void *)&long long v176 = CFDataGetBytePtr(v56);
              *((void *)&v176 + 1) = CFDataGetLength(v56);
              *(void *)&long long v177 = v154;
              *((void *)&v177 + 1) = __PAIR64__(v119, v155);
              *(void *)&long long v178 = v114;
              *((void *)&v178 + 1) = v109;
              *(void *)&long long v179 = __PAIR64__(v113, v101);
              int v79 = 1;
              *((void *)&v179 + 1) = v110;
            }
            else
            {
              int v79 = 0;
            }
            long long v80 = *(_OWORD *)allocatora;
            uint64_t v81 = 0;
            int v82 = 0;
            *(_OWORD *)&range.start.CMTimeValue value = v123;
            *(_OWORD *)&range.start.CMTimeEpoch epoch = v122;
            *(_OWORD *)&range.duration.CMTimeScale timescale = v121;
            do
            {
              v83 = &v169[v81];
              if ((v169[v81 + 28] & 1) != 0 && (v83[52] & 1) != 0 && !*(void *)&v169[v81 + 56])
              {
                long long v84 = (CMTime *)(v83 + 40);
                if ((*((void *)v83 + 5) & 0x8000000000000000) == 0)
                {
                  *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&v84->value;
                  time1.start.CMTimeEpoch epoch = *((void *)v83 + 7);
                  *(_OWORD *)&time2.CMTimeValue value = v80;
                  time2.CMTimeEpoch epoch = v51;
                  if (CMTimeCompare(&time1.start, &time2))
                  {
                    CMTimeRange time1 = range;
                    CMTimeRangeGetEnd(&v151, &time1);
                    long long v86 = *((_OWORD *)v83 + 1);
                    char v85 = v83 + 16;
                    *(_OWORD *)&time1.start.CMTimeValue value = v86;
                    time1.start.CMTimeEpoch epoch = *((void *)v85 + 2);
                    if (CMTimeCompare(&v151, &time1.start))
                    {
                      if (v82)
                      {
                        CMTimeRange time1 = range;
                        cea608dgOutputCCData(a1, v82, &time1);
                        if (v87) {
                          goto LABEL_134;
                        }
                        CFRelease(v82);
                      }
                      v88 = CFDataCreateMutable(*(CFAllocatorRef *)a1, 0);
                      if (!v88)
                      {
                        uint64_t v31 = FigSignalErrorAt();
                        v91 = a2;
                        CFRange v90 = a3;
                        goto LABEL_135;
                      }
                      int v82 = v88;
                      CFDataAppendBytes(v88, *(const UInt8 **)&v169[v81], *(void *)&v169[v81 + 8]);
                      long long v89 = *((_OWORD *)v85 + 1);
                      *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)v85;
                      *(_OWORD *)&range.start.CMTimeEpoch epoch = v89;
                      *(_OWORD *)&range.duration.CMTimeScale timescale = *((_OWORD *)v85 + 2);
                    }
                    else
                    {
                      CFDataAppendBytes(v82, *(const UInt8 **)&v169[v81], *(void *)&v169[v81 + 8]);
                      time1.CMTime start = range.duration;
                      CMTime time2 = *v84;
                      CMTimeAdd(&range.duration, &time1.start, &time2);
                    }
                  }
                  long long v80 = *(_OWORD *)allocatora;
                }
              }
              v81 += 64;
            }
            while (v81 != 256);
            if (v82)
            {
              CMTimeRange time1 = range;
              cea608dgOutputCCData(a1, v82, &time1);
LABEL_134:
              uint64_t v31 = v87;
              v91 = a2;
              CFRange v90 = a3;
              CFRelease(v82);
LABEL_135:
              CFDataRef v13 = v116;
              long long v80 = *(_OWORD *)allocatora;
              if (v31)
              {
                int v79 = 0;
                CFDataRef v40 = v117;
                if (!v68) {
                  goto LABEL_147;
                }
                goto LABEL_146;
              }
              if (v91) {
                goto LABEL_137;
              }
            }
            else
            {
              CFDataRef v13 = v116;
              v91 = a2;
              CFRange v90 = a3;
              if (a2) {
LABEL_137:
              }
                CMTime *v91 = v145;
            }
            CFDataRef v40 = v117;
            if (v90)
            {
              range.CMTime start = v144;
              *(_OWORD *)&time1.start.CMTimeValue value = v80;
              time1.start.CMTimeEpoch epoch = v51;
              if (!CMTimeCompare(&range.start, &time1.start))
              {
                memset(&time1, 0, 24);
                CMTimeRange range = rhs;
                CMTimeRangeGetEnd(&v132, &range);
                long long v92 = *(_OWORD *)(a1 + 28);
                *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)(a1 + 12);
                *(_OWORD *)&range.start.CMTimeEpoch epoch = v92;
                *(_OWORD *)&range.duration.CMTimeScale timescale = *(_OWORD *)(a1 + 44);
                CMTimeRangeGetEnd(&v131, &range);
                CMTimeSubtract(&time1.start, &v132, &v131);
                if (time1.start.flags)
                {
                  *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)allocatora;
                  range.start.CMTimeEpoch epoch = v51;
                  CMTime time2 = time1.start;
                  if (CMTimeCompare(&range.start, &time2) < 0) {
                    CMTimeMake(&v144, -time1.start.value, time1.start.timescale);
                  }
                }
              }
              uint64_t v31 = 0;
              *CFRange v90 = v144;
              if (!v68)
              {
LABEL_147:
                if (v31) {
                  goto LABEL_151;
                }
                if (v79) {
                  goto LABEL_150;
                }
                goto LABEL_149;
              }
            }
            else
            {
              uint64_t v31 = 0;
              if (!v68) {
                goto LABEL_147;
              }
            }
LABEL_146:
            CFRelease(v68);
            goto LABEL_147;
          }
LABEL_113:
          long long v78 = CFDataGetBytePtr(v55);
          *(void *)&long long v174 = &v78[v134];
          *((void *)&v174 + 1) = v133;
          CMTimeRange v175 = v147;
          goto LABEL_114;
        }
        uint64_t v31 = FigSignalErrorAt();
        CMTimeFlags flags = v95;
        CMTimeFlags v52 = v96;
        CMTimeValue v76 = v99;
        CMTimeEpoch v75 = v100;
        CMTimeEpoch v74 = v98;
        CMTimeScale v77 = v97;
        if (!v31) {
          goto LABEL_111;
        }
      }
      CFDataRef v13 = v116;
      CFDataRef v40 = v117;
LABEL_151:
      if (v40) {
        CFRelease(v40);
      }
      goto LABEL_153;
    }
    uint64_t v46 = FigSignalErrorAt();
    CFDataRef v40 = v117;
    if (!v46)
    {
LABEL_149:
      FigCEA608DataGeneratorCaptionInfoRelease(*(const __CFAllocator ***)(a1 + 112));
      *(void *)(a1 + 112) = 0;
LABEL_150:
      FigCEA608DataGeneratorCaptionInfoRelease(*(const __CFAllocator ***)(a1 + 104));
      uint64_t v31 = 0;
      *(void *)(a1 + 104) = *(void *)(a1 + 112);
      *(void *)(a1 + 112) = 0;
      goto LABEL_151;
    }
LABEL_169:
    uint64_t v31 = v46;
    goto LABEL_151;
  }
  uint64_t v94 = FigSignalErrorAt();
  CFDataRef v117 = 0;
  CMTimeFlags v119 = v15;
  CMTimeEpoch v114 = v100;
  CMTimeScale v101 = v97;
  CMTimeFlags v113 = v96;
  CMTimeValue v109 = v99;
  CMTimeEpoch v110 = v98;
  CFDataRef v13 = v116;
  if (!v94) {
    goto LABEL_50;
  }
  uint64_t v31 = v94;
LABEL_153:
  if (theData) {
    CFRelease(theData);
  }
LABEL_155:
  if (v13) {
    CFRelease(v13);
  }
  return v31;
}

uint64_t FigCEA608DataGeneratorFinish(uint64_t a1)
{
  if (!a1 || *(void *)(a1 + 112))
  {
    return FigSignalErrorAt();
  }
  else if (!*(void *)(a1 + 104) || (uint64_t result = cea608dgStoreCCDataSequentially(a1, 0, 0), !result))
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 96) = 2;
  }
  return result;
}

uint64_t FigCEA608DataGeneratorSetShouldAdjustOverlappedDataTime(uint64_t a1, char a2)
{
  if (!a1 || *(_DWORD *)(a1 + 96)) {
    return FigSignalErrorAt();
  }
  *(unsigned char *)(a1 + 9) = a2;
  return 0;
}

uint64_t FigCEA608DataGeneratorGetTimeLineRange(uint64_t a1, _OWORD *a2)
{
  if (a1 && a2)
  {
    long long v2 = *(_OWORD *)(a1 + 12);
    long long v3 = *(_OWORD *)(a1 + 44);
    a2[1] = *(_OWORD *)(a1 + 28);
    a2[2] = v3;
    *a2 = v2;
  }
  else
  {
    FigSignalErrorAt();
  }
  return 0;
}

uint64_t FigCEA608DataGeneratorSetTimeLineRange(uint64_t a1, long long *a2)
{
  if (!a1 || *(_DWORD *)(a1 + 96)) {
    return FigSignalErrorAt();
  }
  long long v2 = *a2;
  long long v3 = a2[1];
  *(_OWORD *)(a1 + 44) = a2[2];
  *(_OWORD *)(a1 + 28) = v3;
  *(_OWORD *)(a1 + 12) = v2;
  return 0;
}

uint64_t FigCEA608DataGeneratorGetClosedCaptionChannel(uint64_t a1, _DWORD *a2)
{
  if (a1) {
    *a2 = 1;
  }
  else {
    FigSignalErrorAt();
  }
  return 0;
}

void cea608dgCCDataAppendPaddingIfNeeded(__CFData *a1)
{
  if (CFDataGetLength(a1))
  {
    UInt8 bytes = 0;
    CFDataAppendBytes(a1, &bytes, 1);
  }
}

uint64_t cea608dgCharacterMappingGetControlCodeForCharacter(CFDictionaryRef theDict, unsigned int a2, char *a3, int *a4, char *a5, char *a6)
{
  uint64_t v11 = 0;
  CMTimeValue value = 0;
  unint64_t v12 = a2;
  while (1)
  {
    CFDictionaryRef v13 = (const __CFDictionary *)CFDictionaryGetValue(theDict, off_1E578B2F0[v11]);
    uint64_t ValueIfPresent = CFDictionaryGetValueIfPresent(v13, (const void *)v12, (const void **)&value);
    if (ValueIfPresent) {
      break;
    }
    if (++v11 == 4) {
      goto LABEL_4;
    }
  }
  if (FigCFEqual())
  {
    char v15 = 0;
    char v17 = 0;
    char v18 = 0;
    int v16 = 1;
    char v19 = (char)value;
  }
  else
  {
    if (FigCFEqual())
    {
      char v18 = 0;
      char v19 = 17;
      char v17 = 1;
    }
    else
    {
      if (FigCFEqual())
      {
        char v17 = 0;
        char v19 = 18;
      }
      else
      {
        if (!FigCFEqual())
        {
LABEL_4:
          char v15 = 0;
          int v16 = 0;
          char v17 = 0;
          char v18 = 0;
          char v19 = 0;
          goto LABEL_15;
        }
        char v17 = 0;
        char v19 = 19;
      }
      char v18 = 1;
    }
    int v16 = 2;
    char v15 = (char)value;
  }
LABEL_15:
  *a3 = v19;
  a3[1] = v15;
  *a4 = v16;
  *a5 = v17;
  *a6 = v18;
  return ValueIfPresent;
}

uint64_t cea608dgCreateEraseCCData(uint64_t a1, CMTime *a2, CFAllocatorRef allocator, const __CFData **a4, _OWORD *a5)
{
  *(_WORD *)UInt8 bytes = 11284;
  CFDataRef v9 = CFDataCreate(allocator, bytes, 2);
  if (!v9) {
    return FigSignalErrorAt();
  }
  CFDataRef v10 = v9;
  CMTime v17 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  *(_OWORD *)&v16.start.CMTimeValue value = *(_OWORD *)a1;
  v16.start.CMTimeEpoch epoch = *(void *)(a1 + 16);
  uint64_t Duration = cea608dgCCDataGetDuration(v9, &v16.start, &v17);
  if (Duration) {
    goto LABEL_7;
  }
  if (a5)
  {
    CMTime start = *a2;
    CMTime v14 = v17;
    CMTimeRangeMake(&v16, &start, &v14);
    long long v12 = *(_OWORD *)&v16.start.epoch;
    *a5 = *(_OWORD *)&v16.start.value;
    a5[1] = v12;
    a5[2] = *(_OWORD *)&v16.duration.timescale;
  }
  if (!a4)
  {
LABEL_7:
    CFRelease(v10);
  }
  else
  {
    uint64_t Duration = 0;
    *a4 = v10;
  }
  return Duration;
}

uint64_t cea608dgCCDataGetDuration(const __CFData *a1, CMTime *a2, CMTime *a3)
{
  CMTime v8 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  if (!a1) {
    goto LABEL_4;
  }
  unint64_t Length = CFDataGetLength(a1);
  if ((Length & 1) == 0)
  {
    CMTime v7 = *a2;
    CMTimeMultiply(&v8, &v7, Length >> 1);
LABEL_4:
    *a3 = v8;
    return 0;
  }

  return FigSignalErrorAt();
}

uint64_t cea608dgGetAheadDuration(CMTime *a1, uint64_t a2, CMTime *a3)
{
  if (a2 < 0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    memset(&v7, 0, sizeof(v7));
    CMTime v6 = *a1;
    CMTimeMultiply(&v7, &v6, a2);
    *a3 = v7;
    return 0;
  }
}

uint64_t cea608dgCCDataGetByteLengthFromDuration(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if ((*(unsigned char *)(a1 + 12) & 1) != 0
    && (time1 = *(CMTime *)a1, CMTime v8 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48], CMTimeCompare(&time1, &v8)))
  {
    if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || *(uint64_t *)a1 % *(void *)a2) {
      return FigSignalErrorAt();
    }
    uint64_t v6 = 2 * (*(void *)a1 / *(uint64_t *)a2);
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t result = 0;
  *a3 = v6;
  return result;
}

double cea608dgOutputCCData(uint64_t a1, CFMutableDataRef theData, _OWORD *a3)
{
  if (!*(void *)(a1 + 152)) {
    goto LABEL_7;
  }
  MutableBytePtr = CFDataGetMutableBytePtr(theData);
  for (CFIndex i = CFDataGetLength(theData); i; --i)
  {
    unsigned int v8 = *MutableBytePtr;
    uint32x4_t v9 = (uint32x4_t)vdupq_n_s32(v8);
    unsigned long long v10 = *(_OWORD *)&vshlq_u32(v9, (uint32x4_t)xmmword_194992BC0) & __PAIR128__(0xFFFFFF01FFFFFF01, 0xFFFFFF01FFFFFF01);
    int32x4_t v11 = vaddq_s32((int32x4_t)(*(_OWORD *)&vshlq_u32(v9, (uint32x4_t)xmmword_194992BD0) & __PAIR128__(0xFFFFFF01FFFFFF01, 0xFFFFFF01FFFFFF01)), (int32x4_t)v10);
    v11.i32[3] = HIDWORD(v10);
    if ((vaddvq_s32(v11) & 1) == 0) {
      UInt8 *MutableBytePtr = v8 | 0x80;
    }
    ++MutableBytePtr;
  }
  uint64_t v12 = *(void *)(a1 + 144);
  CFDictionaryRef v13 = *(unsigned int (**)(CFMutableDataRef, CMTimeRange *, uint64_t))(a1 + 152);
  long long v14 = a3[1];
  *(_OWORD *)&range.start.CMTimeValue value = *a3;
  *(_OWORD *)&range.start.CMTimeEpoch epoch = v14;
  *(_OWORD *)&range.duration.CMTimeScale timescale = a3[2];
  if (!v13(theData, &range, v12))
  {
LABEL_7:
    long long v16 = a3[1];
    *(_OWORD *)&range.start.CMTimeValue value = *a3;
    *(_OWORD *)&range.start.CMTimeEpoch epoch = v16;
    *(_OWORD *)&range.duration.CMTimeScale timescale = a3[2];
    CMTimeRangeGetEnd(&v17, &range);
    double result = *(double *)&v17.value;
    *(CMTime *)(a1 + 120) = v17;
  }
  return result;
}

void FigByteRateHistoryClear(uint64_t a1)
{
  long long v2 = *(void **)a1;
  if (v2)
  {
    uint64_t v3 = *(unsigned int *)(a1 + 8);
    if ((int)v3 >= 1) {
      bzero(v2, 16 * v3);
    }
  }
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
}

uint64_t FigByteRateHistoryGetArraySize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t FigByteRateHistoryGetCurrentSampleDuration(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 16 * *(int *)(a1 + 12));
}

double FigByteRateHistoryReportMovingAverage(uint64_t a1, double *a2)
{
  if (a2)
  {
    double result = *(double *)(a1 + 40);
    *a2 = result;
  }
  return result;
}

uint64_t ParseReferenceMovieAtom(uint64_t a1, uint64_t a2)
{
  memset(v4, 0, sizeof(v4));
  if (!FigAtomStreamInitWithParent()) {
    ParseDescriptorAtoms((uint64_t)v4, (uint64_t)ParseReferenceMovieAtom_atomDispatch, 1, a2);
  }
  return 0;
}

uint64_t ParseDescriptorAtoms(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CMTime v7 = (uint64_t (**)(uint64_t, uint64_t))(a2 + 8);
  while (1)
  {
    uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
    if (result) {
      return result;
    }
    if (a3 >= 1)
    {
      uint32x4_t v9 = v7;
      unsigned long long v10 = v7;
      uint64_t v11 = a3;
      while (*((_DWORD *)v9 - 2))
      {
        v10 += 2;
        v9 += 2;
        if (!--v11) {
          goto LABEL_9;
        }
      }
      uint64_t result = (*v9)(a1, a4);
      if (result) {
        return result;
      }
    }
LABEL_9:
    LODWORD(result) = FigAtomStreamAdvanceToNextAtom();
    if (result)
    {
      if (result == -12890) {
        return 0;
      }
      else {
        return result;
      }
    }
  }
}

uint64_t ParseReferenceMovieDescriptorAtom(uint64_t a1, void *a2)
{
  memset(v6, 0, sizeof(v6));
  uint64_t v3 = malloc_type_calloc(1uLL, 0x20uLL, 0x20040DC1BFBCFuLL);
  if (v3)
  {
    if (!FigAtomStreamInitWithParent()
      && !ParseDescriptorAtoms((uint64_t)v6, (uint64_t)ParseReferenceMovieDescriptorAtom_atomDispatch, 3, (uint64_t)v3)&& v3[3])
    {
      CFAllocatorRef v4 = (void *)a2[1];
      if (v4) {
        *CFAllocatorRef v4 = v3;
      }
      else {
        *a2 = v3;
      }
      a2[1] = v3;
      uint64_t v3 = 0;
    }
  }
  else
  {
    FigSignalErrorAt();
  }
  DisposeReferenceMovieAlternate(v3);
  return 0;
}

uint64_t ParseReferenceMovieDataRefAtom(uint64_t a1, uint64_t a2)
{
  long long v2 = (CMBlockBufferRef *)(a2 + 24);
  if (*(void *)(a2 + 24)) {
    return 0;
  }
  dataPointerOut = 0;
  uint64_t result = FigAtomStreamReadCurrentAtomDataAndCreateBBuf();
  if (!result)
  {
    if (CMBlockBufferGetDataLength(*v2) <= 0xD) {
      return FigSignalErrorAt();
    }
    uint64_t result = CMBlockBufferGetDataPointer(*v2, 0, 0, 0, &dataPointerOut);
    if (!result)
    {
      if (*((_DWORD *)dataPointerOut + 1) == 543978101) {
        return 0;
      }
      uint64_t result = (uint64_t)*v2;
      if (*v2)
      {
        CFRelease((CFTypeRef)result);
        uint64_t result = 0;
        *long long v2 = 0;
      }
    }
  }
  return result;
}

uint64_t ParseReferenceMovieDataRateAtom(uint64_t a1, uint64_t a2)
{
  long long v2 = (CMBlockBufferRef *)(a2 + 8);
  if (*(void *)(a2 + 8)) {
    return 0;
  }
  uint64_t result = FigAtomStreamReadCurrentAtomDataAndCreateBBuf();
  if (result) {
    return result;
  }
  if (CMBlockBufferGetDataLength(*v2) == 8) {
    return 0;
  }

  return FigSignalErrorAt();
}

uint64_t ParseReferenceMovieVersionCheckAtom(uint64_t a1, uint64_t a2)
{
  uint64_t BBuf = FigAtomStreamReadCurrentAtomDataAndCreateBBuf();
  if (BBuf) {
    return BBuf;
  }
  if (CMBlockBufferGetDataLength(0) != 18) {
    return FigSignalErrorAt();
  }
  CFMutableDictionaryRef Mutable = *(__CFArray **)(a2 + 16);
  if (!Mutable)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    *(void *)(a2 + 16) = Mutable;
    if (!Mutable) {
      return FigSignalErrorAt();
    }
  }
  CFArrayAppendValue(Mutable, 0);
  return 0;
}

void DisposeReferenceMovieAlternate(void *a1)
{
  if (a1)
  {
    long long v2 = (const void *)a1[1];
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = (const void *)a1[3];
    if (v3) {
      CFRelease(v3);
    }
    CFAllocatorRef v4 = (const void *)a1[2];
    if (v4) {
      CFRelease(v4);
    }
    free(a1);
  }
}

uint64_t InitMobiGestaltOnce()
{
  uint64_t result = CelestialIsiPad();
  if (result)
  {
    int v1 = 16;
  }
  else
  {
    uint64_t result = CelestialIsiPhone();
    int v1 = 1;
  }
  sMobiGestaltCFDictionaryRef Value = v1;
  return result;
}

uint64_t FigBytePumpGetClassID()
{
  return sFigBytePumpClassID;
}

uint64_t RegisterFigBytePumpBaseType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigBytePumpGetTypeID()
{
  MEMORY[0x19970EE10](&FigBytePumpGetClassID_sRegisterFigBytePumpBaseTypeOnce, RegisterFigBytePumpBaseType);

  return CMBaseClassGetCFTypeID();
}

CFTypeRef FigBytePumpRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void FigBytePumpRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t FigBytePumpIsBytePumpProperty(__CFString *a1)
{
  uint64_t v1 = 0;
  while (*(&bytePumpProperties)[v1] != a1)
  {
    if (++v1 == 60) {
      return 0;
    }
  }
  return 1;
}

CFStringRef FigBytePumpBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigBytePump %p]", a1);
}

uint64_t FigNWActivitySubmitMetricsForInitialStartup(uint64_t a1, double a2, double a3, double a4)
{
  if (!a1) {
    return 4294954516;
  }
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  if (!v7) {
    return 4294954510;
  }
  unsigned int v8 = v7;
  xpc_dictionary_set_double(v7, "CMInitialStartup_ItemCreationToLTKU", a3 - a2);
  xpc_dictionary_set_double(v8, "CMInitialStartup_ItemCreationToReadyToPlay", a4 - a2);
  nw_activity_submit_metrics();
  xpc_release(v8);
  return 0;
}

CFDataRef FigNWActivityCreateToken(CFDataRef result)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  *(void *)uu = 0;
  uint64_t v2 = 0;
  if (result)
  {
    nw_activity_get_token();
    if (uuid_is_null(uu)) {
      return 0;
    }
    else {
      return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], uu, 16);
    }
  }
  return result;
}

CFDataRef FigNWActivityCreateFromToken(const __CFData *result)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *(void *)buffer = 0;
  uint64_t v3 = 0;
  if (result)
  {
    v5.CFIndex location = 0;
    v5.length = 16;
    CFDataGetBytes(result, v5, buffer);
    int is_null = uuid_is_null(buffer);
    uint64_t result = 0;
    if (!is_null) {
      return (const __CFData *)nw_activity_create_from_token();
    }
  }
  return result;
}

uint64_t FigBytePumpCreateForICY(const __CFAllocator *a1, const void *a2, const void *a3, const __CFDictionary *a4, NSObject *a5, uint64_t a6, uint64_t a7, void *a8)
{
  fig_note_initialize_category_with_default_work_cf();
  fig_note_initialize_category_with_default_work_cf();
  if (a2 && a8)
  {
    FigBytePumpGetClassID();
    uint64_t v13 = CMDerivedObjectCreate();
    if (v13) {
      return v13;
    }
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    uint64_t v15 = FigRetainProxyCreate();
    if (v15)
    {
      uint64_t v30 = v15;
      CFDataRef v21 = 0;
      goto LABEL_48;
    }
    CFAllocatorRef Default = a1;
    if (!a1) {
      CFAllocatorRef Default = CFAllocatorGetDefault();
    }
    *(void *)uint64_t DerivedStorage = CFRetain(Default);
    *(void *)(DerivedStorage + 72) = FigRetainProxyRetain();
    if (a5)
    {
      Local = a5;
    }
    else
    {
      Local = FigHTTPSchedulerCreateLocal(0);
      *(void *)(DerivedStorage + 80) = Local;
      if (Local)
      {
LABEL_11:
        if (a3)
        {
          CFDictionaryRef v18 = (const __CFDictionary *)CFRetain(a3);
          *(void *)(DerivedStorage + 104) = v18;
          if (v18)
          {
            CFDictionaryRef Value = CFDictionaryGetValue(v18, @"X-Playback-Session-Id");
            if (Value) {
              CFDictionaryRef Value = CFRetain(Value);
            }
            *(void *)(DerivedStorage + 112) = Value;
          }
          if (a4) {
            goto LABEL_17;
          }
        }
        else
        {
          *(void *)(DerivedStorage + 104) = 0;
          if (a4)
          {
LABEL_17:
            CFDataRef v20 = (const __CFData *)CFDictionaryGetValue(a4, @"FBPCreateOption_HTTPRequestOptions");
            CFDataRef v21 = v20;
            if (v20)
            {
              if (CFGetTypeID(v20) && CFDictionaryGetTypeID())
              {
                CFDictionaryRef v22 = (const __CFDictionary *)CFRetain(v21);
                *(void *)(DerivedStorage + 120) = v22;
                int v23 = CFDictionaryGetValue(v22, @"FHRP_StorageSession");
                if (v23) {
                  int v23 = CFRetain(v23);
                }
                *(void *)(DerivedStorage + 128) = v23;
                CFDataRef v24 = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 120), @"FHRP_ClientAuditToken");
                CFDataRef v21 = FigCFHTTPCopyClientProcessName(v24);
                CFDictionaryRef v25 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"FBPCreateOption_AlternativeConfigurationOptions");
                FigCFDictionaryGetBooleanIfPresent();
                *(unsigned char *)(DerivedStorage + 379) = 1;
              }
              else
              {
                CFDictionaryRef v25 = 0;
                CFDataRef v21 = 0;
              }
            }
            else
            {
              CFDictionaryRef v25 = 0;
            }
            int v26 = (const void *)*MEMORY[0x1E4F1CFD0];
            *(unsigned char *)(DerivedStorage + 32) = v26 == CFDictionaryGetValue(a4, @"FBPCreateOption_DisallowCellularAccess");
            *(unsigned char *)(DerivedStorage + 33) = v26 == CFDictionaryGetValue(a4, @"FBPCreateOption_DisallowsExpensiveNetworkAccess");
            *(unsigned char *)(DerivedStorage + 34) = v26 == CFDictionaryGetValue(a4, @"FBPCreateOption_DisallowsConstrainedNetworkAccess");
            *(unsigned char *)(DerivedStorage + 304) = CFDictionaryGetValue(a4, @"FBPCreateOption_DisableNativeHTTPReads") == v26;
            CFIndex v27 = CFDictionaryGetValue(a4, @"FBPCreateOption_CustomURLLoader");
            if (v27) {
              CFIndex v27 = CFRetain(v27);
            }
            *(void *)(DerivedStorage + 312) = v27;
LABEL_30:
            if (*(unsigned char *)(DerivedStorage + 304))
            {
              if (!*(void *)(DerivedStorage + 312)
                || (CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]),
                    (*(void *)(DerivedStorage + 360) = Mutable) == 0))
              {
                uint64_t v30 = FigSignalErrorAt();
                if (!v30)
                {
LABEL_36:
                  if (v21) {
                    CFRelease(v21);
                  }
                  return v30;
                }
LABEL_48:
                CFRelease(0);
                goto LABEL_36;
              }
            }
            else if (!*(void *)(DerivedStorage + 136))
            {
              CFTypeRef v32 = *(CFTypeRef *)(DerivedStorage + 128);
              if (!v32)
              {
                CFTypeRef v32 = FigURLStorageSessionCopyGlobalSession();
                *(void *)(DerivedStorage + 128) = v32;
                if (!v32)
                {
                  uint64_t v30 = 4294954655;
                  goto LABEL_48;
                }
              }
              uint64_t v33 = *(void *)(DerivedStorage + 80);
              uint64_t v34 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v34) {
                uint64_t v35 = v34;
              }
              else {
                uint64_t v35 = 0;
              }
              uint64_t v36 = *(uint64_t (**)(CFTypeRef, uint64_t, void, uint64_t))(v35 + 40);
              if (!v36)
              {
                uint64_t v30 = 4294954514;
                goto LABEL_48;
              }
              uint64_t v37 = v36(v32, v33, 0, DerivedStorage + 136);
              if (v37)
              {
                uint64_t v30 = v37;
                goto LABEL_48;
              }
            }
            FigRCLCreateConfiguration(v21, @"kFigRemoteConfigurationLoaderStoreBagType_Pump", v25, (CFMutableDictionaryRef *)(DerivedStorage + 296));
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            *(unsigned char *)(DerivedStorage + 378) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 296), @"enableHTTP3Connection") != 0;
            *(unsigned char *)(DerivedStorage + 379) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 296), @"enableL4S") != 0;
            *(void *)(DerivedStorage + 24) = 0;
            uint64_t v30 = 0;
            *(void *)(DerivedStorage + 96) = CFRetain(a2);
            *(void *)(DerivedStorage + 64) = a6;
            *a8 = 0;
            goto LABEL_36;
          }
        }
        CFDictionaryRef v25 = 0;
        CFDataRef v21 = 0;
        goto LABEL_30;
      }
    }
    *(void *)(DerivedStorage + 80) = FigHTTPSchedulerRetain(Local);
    goto LABEL_11;
  }

  return FigSignalErrorAt();
}

uint64_t FigICYBytePumpInvalidate(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyRetain();
  FigRetainProxyLockMutex();
  FigRetainProxyInvalidate();
  if (!*(unsigned char *)(DerivedStorage + 16))
  {
    *(unsigned char *)(DerivedStorage + 16) = 1;
    FigHTTPStopAndReleaseTimer((dispatch_object_t *)(DerivedStorage + 88));
    FigICY_InvalidateHTTP(DerivedStorage);
    uint64_t v3 = *(const void **)(DerivedStorage + 96);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(DerivedStorage + 96) = 0;
    }
    uint64_t v4 = *(const void **)(DerivedStorage + 104);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(DerivedStorage + 104) = 0;
    }
    CFRange v5 = *(const void **)(DerivedStorage + 112);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(DerivedStorage + 112) = 0;
    }
    uint64_t v6 = *(const void **)(DerivedStorage + 296);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(DerivedStorage + 296) = 0;
    }
    xpc_object_t v7 = *(const void **)(DerivedStorage + 160);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(DerivedStorage + 160) = 0;
    }
    unsigned int v8 = *(const void ***)(DerivedStorage + 168);
    if (v8)
    {
      PlaylistFileParserDestroy(v8);
      *(void *)(DerivedStorage + 168) = 0;
    }
    if (*(unsigned char *)(DerivedStorage + 18) && !*(unsigned char *)(DerivedStorage + 17))
    {
      FigBytePumpRetain(a1);
      if (dword_1E9350AB0)
      {
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      fbp_SendDataCallback((uint64_t)a1, DerivedStorage, *(void *)(DerivedStorage + 72), 0, 2, 0, MEMORY[0x1E4F1F9F8], 4294954511);
      FigBytePumpRelease(a1);
    }
    *(void *)(DerivedStorage + 64) = 0;
    *(unsigned char *)(DerivedStorage + 17) = 1;
  }
  FigRetainProxyUnlockMutex();
  FigRetainProxyRelease();
  return 0;
}

void FigICYBytePumpFinalize(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigICYBytePumpInvalidate(a1);
  FigRetainProxyRelease();
  uint64_t v3 = *(const void **)(DerivedStorage + 128);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(DerivedStorage + 128) = 0;
  }
  uint64_t v4 = *(const void **)(DerivedStorage + 136);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(DerivedStorage + 136) = 0;
  }
  CFRange v5 = *(const void **)(DerivedStorage + 312);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(DerivedStorage + 312) = 0;
  }
  uint64_t v6 = *(const void **)(DerivedStorage + 328);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(DerivedStorage + 328) = 0;
  }
  xpc_object_t v7 = *(const void **)(DerivedStorage + 360);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(DerivedStorage + 360) = 0;
  }
  unsigned int v8 = *(const void **)(DerivedStorage + 216);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(DerivedStorage + 216) = 0;
  }
  uint32x4_t v9 = *(const void **)(DerivedStorage + 184);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(DerivedStorage + 184) = 0;
  }
  FigRetainProxyRelease();
  *(void *)(DerivedStorage + 8) = 0;
  FigHTTPSchedulerRelease(*(dispatch_object_t *)(DerivedStorage + 80));
  *(void *)(DerivedStorage + 80) = 0;
  unsigned long long v10 = *(const void **)(DerivedStorage + 120);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(DerivedStorage + 120) = 0;
  }
  uint64_t v11 = *(const void **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    CFRelease(v11);
  }
}

__CFString *FigICYBytePumpCopyDebugDescription()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppend(Mutable, @"\tFigICYBytePump :");
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated())
  {
    CFStringAppend(Mutable, @"invalidated");
  }
  else
  {
    CFURLRef v2 = *(const __CFURL **)(DerivedStorage + 96);
    if (v2)
    {
      CFStringRef v3 = (const __CFString *)FigCFHTTPCreateURLString(v2);
      if (v3)
      {
        CFStringRef v4 = v3;
        CFStringAppend(Mutable, v3);
        CFRelease(v4);
      }
    }
  }
  FigRetainProxyUnlockMutex();
  return Mutable;
}

uint64_t FigICYBytePumpCopyProperty(uint64_t a1, __CFString *a2, const __CFAllocator *a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated()) {
    goto LABEL_26;
  }
  if (CFEqual(a2, @"FBP_CanContinueWithoutGapBitField"))
  {
    LODWORD(v13.value) = 7;
    if (!*(void *)(DerivedStorage + 208)
      && *(unsigned char *)(DerivedStorage + 19)
      && FigGetUpTimeNanoseconds() - *(void *)(DerivedStorage + 288) >= 0xDF8475801)
    {
      LODWORD(v13.value) = 0;
    }
    unsigned int v8 = CFNumberCreate(a3, kCFNumberSInt32Type, &v13);
    goto LABEL_18;
  }
  if (CFEqual(a2, @"FBP_PlaybackSessionID"))
  {
    unsigned int v8 = *(const void **)(DerivedStorage + 112);
    if (!v8) {
      goto LABEL_13;
    }
    goto LABEL_17;
  }
  if (CFEqual(a2, @"FBP_SessionConfiguration"))
  {
    unsigned int v8 = *(const void **)(DerivedStorage + 296);
    if (!v8) {
      goto LABEL_13;
    }
LABEL_17:
    unsigned int v8 = CFRetain(v8);
LABEL_18:
    uint64_t v9 = 0;
    *a4 = v8;
    goto LABEL_19;
  }
  if (CFEqual(a2, @"FBP_NetworkCostMonitor"))
  {
    uint64_t v11 = (uint64_t *)(DerivedStorage + 184);
    uint64_t v10 = *(void *)(DerivedStorage + 184);
    if (!v10)
    {
      uint64_t v9 = FigNetworkCostMonitorCreate((uint64_t)a3, DerivedStorage + 184);
      if (v9) {
        goto LABEL_19;
      }
      uint64_t v10 = *v11;
      if (!*v11)
      {
        uint64_t v9 = 0;
        goto LABEL_19;
      }
    }
    FigNetworkCostMonitorSetProperty(v10, 0x1EE57E4F8, *MEMORY[0x1E4F1CFC8]);
    unsigned int v8 = (const void *)*v11;
    if (!*v11) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (CFEqual(a2, @"FBP_Duration"))
  {
    CMTime v13 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F0];
    unsigned int v8 = CMTimeCopyAsDictionary(&v13, a3);
    goto LABEL_18;
  }
  if (!FigBytePumpIsBytePumpProperty(a2))
  {
LABEL_26:
    uint64_t v9 = FigSignalErrorAt();
    goto LABEL_19;
  }
LABEL_13:
  uint64_t v9 = 4294954513;
LABEL_19:
  FigRetainProxyUnlockMutex();
  return v9;
}

uint64_t FigICYBytePumpSetProperty(int a1, CFTypeRef cf1)
{
  if (CFEqual(cf1, @"FBP_SendToNero")) {
    return 0;
  }

  return FigSignalErrorAt();
}

void FigICY_InvalidateHTTP(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 304))
  {
    uint64_t v2 = *(void *)(a1 + 312);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 320);
      uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v4) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v9 = *(void (**)(uint64_t, uint64_t))(v5 + 32);
      if (v9) {
        v9(v2, v3);
      }
      *(void *)(a1 + 320) = 0;
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 360));
      *(void *)(a1 + 368) = 0;
      *(unsigned char *)(a1 + 376) = 0;
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 144);
    if (v6)
    {
      uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v7) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v10 = *(void (**)(uint64_t))(v8 + 24);
      if (v10) {
        v10(v6);
      }
      uint64_t v11 = *(const void **)(a1 + 144);
      if (v11)
      {
        CFRelease(v11);
        *(void *)(a1 + 144) = 0;
      }
    }
  }
  FigHTTPStopAndReleaseTimer((dispatch_object_t *)(a1 + 48));
  *(void *)(a1 + 48) = 0;
}

uint64_t fbp_SendDataCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, uint64_t a8)
{
  uint64_t v11 = a5;
  uint64_t v13 = a3;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, void, uint64_t, long long *, void, _DWORD, uint64_t, CFErrorRef, void, void))(a2 + 64);
  CFErrorRef v22 = 0;
  if ((a5 & 2) != 0)
  {
    if (dword_1E9350AB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      uint64_t v13 = a3;
    }
    *(unsigned char *)(a2 + 17) = 1;
  }
  if (*(unsigned char *)(a2 + 21))
  {
    uint64_t v11 = v11 | 1;
    ++*(void *)(a2 + 24);
    *(unsigned char *)(a2 + 21) = 0;
  }
  if (!v15) {
    return 0;
  }
  FigCreateErrorForOSStatus(a8, &v22);
  if (v22)
  {
    CMTime v17 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  FigRetainProxyUnlockAll();
  uint64_t v19 = *(void *)(a2 + 24);
  long long v23 = *a7;
  uint64_t v24 = *((void *)a7 + 2);
  v15(a1, v13, a4, v11, 0, 0, a6, &v23, 0, 0, v19, v22, 0, 0);
  FigRetainProxyRelock();
  if (FigRetainProxyIsInvalidated()) {
    return 4294954413;
  }
  else {
    return 0;
  }
}

uint64_t FigNetworkCostMonitorSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v9 = *(void *)(VTable + 8);
  uint64_t result = VTable + 8;
  uint64_t v8 = v9;
  if (v9) {
    uint64_t v10 = v8;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 56);
  if (v11)
  {
    return v11(a1, a2, a3);
  }
  return result;
}

uint64_t FigICYBytePumpClientHasEnough(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated())
  {
    uint64_t v9 = FigSignalErrorAt();
    goto LABEL_18;
  }
  if (!a2 && !*(unsigned char *)(DerivedStorage + 19))
  {
    if (*(unsigned char *)(DerivedStorage + 304))
    {
      if (!*(void *)(DerivedStorage + 312) || !*(void *)(DerivedStorage + 320))
      {
LABEL_15:
        *(unsigned char *)(DerivedStorage + 19) = 1;
        *(void *)(DerivedStorage + 288) = FigGetUpTimeNanoseconds();
        uint64_t v8 = *(NSObject **)(DerivedStorage + 48);
        if (v8) {
          FigHTTPRescheduleTimer(0.0, *(void *)(DerivedStorage + 80), v8);
        }
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v4 = *(void *)(DerivedStorage + 144);
      if (!v4) {
        goto LABEL_15;
      }
      uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v5) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t v7 = *(void (**)(uint64_t))(v6 + 8);
      if (v7) {
        v7(v4);
      }
    }
    FigHTTPCreateTimer(*(const void **)(DerivedStorage + 8), (uint64_t)fbp_PauseTimer, *(NSObject **)(DerivedStorage + 80), (dispatch_object_t *)(DerivedStorage + 88), 62.0);
    goto LABEL_15;
  }
LABEL_17:
  uint64_t v9 = 0;
LABEL_18:
  FigRetainProxyUnlockMutex();
  return v9;
}

uint64_t FigICYBytePumpClientNeedsMore(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated())
  {
    uint64_t v13 = FigSignalErrorAt();
    goto LABEL_29;
  }
  if (!a2)
  {
    if (*(unsigned char *)(DerivedStorage + 19))
    {
      uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      FigHTTPStopAndReleaseTimer((dispatch_object_t *)(DerivedStorage + 88));
      uint64_t v7 = *(NSObject **)(DerivedStorage + 48);
      if (v7)
      {
        *(void *)(DerivedStorage + 40) = UpTimeNanoseconds;
        FigHTTPRescheduleTimer(15.0, *(void *)(DerivedStorage + 80), v7);
      }
      if (*(unsigned char *)(DerivedStorage + 304))
      {
        if (*(void *)(DerivedStorage + 368) || *(void *)(DerivedStorage + 320))
        {
          if (UpTimeNanoseconds - *(void *)(DerivedStorage + 288) <= 60000000000)
          {
            if (*(unsigned char *)(DerivedStorage + 19))
            {
              uint64_t v8 = FigRetainProxyRetain();
              uint64_t v9 = *(NSObject **)(DerivedStorage + 80);
              block[0] = MEMORY[0x1E4F143A8];
              block[1] = 0x40000000;
              block[2] = __FigICY_ResumeHTTP_block_invoke;
              block[3] = &unk_1E578B978;
              block[4] = v8;
              dispatch_async(v9, block);
            }
LABEL_37:
            uint64_t HTTPRequest = 0;
            goto LABEL_38;
          }
LABEL_19:
          FigICY_InvalidateHTTP(DerivedStorage);
          uint64_t v10 = *(const void **)(DerivedStorage + 96);
          uint64_t v11 = a1;
          if (!*(void *)(DerivedStorage + 208))
          {
            uint64_t HTTPRequest = FigICY_CreateHTTPRequest(a1, v10, 0);
            *(unsigned char *)(DerivedStorage + 21) = 1;
            goto LABEL_38;
          }
          int v12 = 1;
LABEL_25:
          uint64_t HTTPRequest = FigICY_CreateHTTPRequest(v11, v10, v12);
LABEL_38:
          *(unsigned char *)(DerivedStorage + 19) = 0;
          goto LABEL_39;
        }
      }
      else if (*(void *)(DerivedStorage + 144))
      {
        if (UpTimeNanoseconds - *(void *)(DerivedStorage + 288) <= 60000000000)
        {
          uint64_t v14 = *(void *)(DerivedStorage + 144);
          if (v14)
          {
            uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
            uint64_t v16 = v15 ? v15 : 0;
            CMTime v17 = *(void (**)(uint64_t))(v16 + 16);
            if (v17) {
              v17(v14);
            }
          }
          goto LABEL_37;
        }
        goto LABEL_19;
      }
      if (!*(void *)(DerivedStorage + 208) && *(unsigned char *)(DerivedStorage + 376)) {
        *(unsigned char *)(DerivedStorage + 21) = 1;
      }
      *(unsigned char *)(DerivedStorage + 376) = 0;
      uint64_t v10 = *(const void **)(DerivedStorage + 96);
      uint64_t v11 = a1;
      int v12 = 0;
      goto LABEL_25;
    }
    if (*(unsigned char *)(DerivedStorage + 304))
    {
      if (*(void *)(DerivedStorage + 368) || *(void *)(DerivedStorage + 320)) {
        goto LABEL_3;
      }
    }
    else if (*(void *)(DerivedStorage + 144))
    {
      goto LABEL_3;
    }
    if (*(void *)(DerivedStorage + 208)) {
      goto LABEL_3;
    }
    *(unsigned char *)(DerivedStorage + 21) = 1;
    *(unsigned char *)(DerivedStorage + 376) = 0;
    uint64_t v13 = FigICY_CreateHTTPRequest(a1, *(const void **)(DerivedStorage + 96), 0);
LABEL_29:
    uint64_t HTTPRequest = v13;
    goto LABEL_39;
  }
LABEL_3:
  uint64_t HTTPRequest = 0;
LABEL_39:
  FigRetainProxyUnlockMutex();
  return HTTPRequest;
}

uint64_t FigICYBytePumpLikelyToKeepUp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float *a6, _OWORD *a7, _DWORD *a8, BOOL *a9)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(_OWORD *)&time.start.CMTimeValue value = *(_OWORD *)a2;
  time.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
  double Seconds = CMTimeGetSeconds(&time.start);
  float v15 = 1.0;
  if (!*(unsigned char *)(DerivedStorage + 17))
  {
    float v16 = Seconds / 5.0;
    if (v16 > 1.0) {
      float v16 = 1.0;
    }
    float v15 = fmaxf(v16, 0.0);
  }
  if (a6) {
    *a6 = v15;
  }
  if (a7)
  {
    CMTime start = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
    CMTime v19 = start;
    CMTimeRangeMake(&time, &start, &v19);
    long long v17 = *(_OWORD *)&time.start.epoch;
    *a7 = *(_OWORD *)&time.start.value;
    a7[1] = v17;
    a7[2] = *(_OWORD *)&time.duration.timescale;
  }
  if (a8) {
    *a8 = 2 * (v15 == 1.0);
  }
  if (a9) {
    *a9 = v15 == 1.0;
  }
  return 0;
}

uint64_t FigICYBytePumpLoadInformation()
{
  return 0;
}

uint64_t FigICYBytePumpOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, unsigned char *a7)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated())
  {
    uint64_t HTTPRequest = FigSignalErrorAt();
LABEL_9:
    uint64_t v12 = HTTPRequest;
    goto LABEL_7;
  }
  if (!*(unsigned char *)(DerivedStorage + 19) && !*(unsigned char *)(DerivedStorage + 18))
  {
    uint64_t HTTPRequest = FigICY_CreateHTTPRequest(a1, *(const void **)(DerivedStorage + 96), 0);
    if (HTTPRequest) {
      goto LABEL_9;
    }
  }
  *(unsigned char *)(DerivedStorage + 18) = 1;
  *a6 = 0;
  uint64_t v12 = 0;
  if (a7) {
    *a7 = 0;
  }
LABEL_7:
  FigRetainProxyUnlockMutex();
  return v12;
}

uint64_t FigICYBytePumpSetCallback(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated())
  {
    uint64_t v4 = FigSignalErrorAt();
  }
  else
  {
    *(void *)(DerivedStorage + 64) = a2;
    *(void *)(DerivedStorage + 72) = FigRetainProxyRetain();
    FigRetainProxyRelease();
    uint64_t v4 = 0;
  }
  FigRetainProxyUnlockMutex();
  return v4;
}

uint64_t FigICYBytePumpSetPlayerRate(float a1)
{
  CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated() || a1 > 1.0 || a1 < 0.0) {
    uint64_t v2 = FigSignalErrorAt();
  }
  else {
    uint64_t v2 = 0;
  }
  FigRetainProxyUnlockMutex();
  return v2;
}

uint64_t fbp_PauseTimer()
{
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    FigRetainProxyGetOwner();
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    uint64_t v2 = UpTimeNanoseconds - *(void *)(DerivedStorage + 288);
    if (v2 < 0xDF8475801) {
      FigHTTPRescheduleTimer((double)v2 / -1000000000.0 + 62.0, *(void *)(DerivedStorage + 80), *(NSObject **)(DerivedStorage + 88));
    }
    else {
      FigICY_InvalidateHTTP(DerivedStorage);
    }
  }

  return FigRetainProxyUnlockMutex();
}

uint64_t FigICY_CreateHTTPRequest(uint64_t a1, const void *a2, int a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = DerivedStorage;
  unsigned int v7 = 256;
  if (a3)
  {
    uint64_t v8 = *(void *)(DerivedStorage + 200);
    uint64_t v9 = v8 & ~(v8 >> 63);
    if (v8 <= 0) {
      unsigned int v7 = 256;
    }
    else {
      unsigned int v7 = 264;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (*(unsigned char *)(DerivedStorage + 32)) {
    v7 |= 0x80u;
  }
  if (*(unsigned char *)(DerivedStorage + 33)) {
    v7 |= 0x800u;
  }
  if (*(unsigned char *)(DerivedStorage + 34)) {
    v7 |= 0x1000u;
  }
  if (*(unsigned char *)(DerivedStorage + 378)) {
    v7 |= 0x8000u;
  }
  if (*(unsigned char *)(DerivedStorage + 379)) {
    uint64_t v10 = v7 | 0x10000;
  }
  else {
    uint64_t v10 = v7;
  }
  CFDictionaryRef v11 = *(const __CFDictionary **)(DerivedStorage + 104);
  if (v11) {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v11);
  }
  else {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  uint64_t v13 = MutableCopy;
  if (!MutableCopy)
  {
    uint64_t v25 = 4294954655;
    goto LABEL_54;
  }
  CFDictionaryAddValue(MutableCopy, @"icy-metadata", @"1");
  if (!*(unsigned char *)(v6 + 304))
  {
    if (dword_1E9350AB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    uint64_t v26 = *(void *)(v6 + 136);
    uint64_t v27 = *(void *)(v6 + 120);
    uint64_t v28 = *(void *)v6;
    uint64_t v29 = *(void *)(v6 + 8);
    uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v30) {
      uint64_t v31 = v30;
    }
    else {
      uint64_t v31 = 0;
    }
    CFTypeRef v32 = *(uint64_t (**)(uint64_t, uint64_t, void, const void *, void, __CFDictionary *, uint64_t, uint64_t, _OWORD *, uint64_t, void, void, uint64_t (*)(uint64_t, int, uint64_t, OpaqueCMBlockBuffer *, uint64_t, uint64_t, unsigned int, uint64_t), uint64_t, uint64_t, uint64_t))(v31 + 8);
    if (v32)
    {
      memset(v36, 0, 112);
      uint64_t v25 = v32(v26, v28, 0, a2, 0, v13, v27, v10, v36, v9, 0, 0, FigICY_HTTPPumpFn, v29, v6 + 144, v6 + 152);
      CFTypeRef v15 = 0;
      goto LABEL_43;
    }
    CFTypeRef v15 = 0;
LABEL_42:
    uint64_t v25 = 4294954514;
    goto LABEL_43;
  }
  *(_WORD *)(v6 + 336) = 0;
  *(void *)(v6 + 344) = 0;
  *(void *)(v6 + 352) = 0;
  uint64_t Mutable = FigCustomURLRequestInfoCreateMutable();
  if (Mutable || (uint64_t Mutable = FigCustomURLRequestInfoSetHTTPHeaders(), Mutable))
  {
    uint64_t v25 = Mutable;
    goto LABEL_54;
  }
  CFTypeRef v15 = FigCFHTTPCreateUserAgent();
  uint64_t v16 = FigCustomURLRequestInfoSetUserAgent();
  if (v16
    || v9
    && (*(unsigned char *)(v6 + 336) = 1, *(void *)(v6 + 344) = v9, uint64_t v16 = FigCustomURLRequestInfoSetByteRange(), v16))
  {
    uint64_t v25 = v16;
    if (v15) {
      goto LABEL_53;
    }
    goto LABEL_54;
  }
  long long v17 = *(const void **)(v6 + 328);
  if (v17)
  {
    CFRelease(v17);
    *(void *)(v6 + 328) = 0;
  }
  uint64_t v18 = *(void *)(v6 + 312);
  uint64_t v19 = *(void *)(v6 + 8);
  uint64_t v20 = *(void *)(v6 + 80);
  uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v21) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  uint64_t v24 = *(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, const void *, void *, char), uint64_t))(v22 + 24);
  if (!v24) {
    goto LABEL_42;
  }
  uint64_t v25 = v24(v18, 0, v19, v20, FigICY_CustomURLLoaderCallbackFn, v6 + 320);
LABEL_43:
  if (v9)
  {
    if (v25) {
      goto LABEL_45;
    }
  }
  else
  {
    *(void *)(v6 + 200) = 0;
    *(_DWORD *)(v6 + 224) = 0;
    *(void *)(v6 + 248) = 0;
    uint64_t v33 = *(const void **)(v6 + 216);
    if (v33)
    {
      CFRelease(v33);
      *(void *)(v6 + 216) = 0;
    }
    *(void *)(v6 + 232) = 0;
    if (v25)
    {
LABEL_45:
      if (!v15) {
        goto LABEL_54;
      }
LABEL_53:
      CFRelease(v15);
      goto LABEL_54;
    }
  }
  uint64_t v34 = *(const void **)(v6 + 96);
  if (v34) {
    CFRelease(v34);
  }
  *(void *)(v6 + 96) = CFRetain(a2);
  FigHTTPCreateTimer(*(const void **)(v6 + 8), (uint64_t)fbp_NetworkInactivityTimer, *(NSObject **)(v6 + 80), (dispatch_object_t *)(v6 + 48), 15.0);
  uint64_t v25 = 0;
  if (v15) {
    goto LABEL_53;
  }
LABEL_54:
  if (v13) {
    CFRelease(v13);
  }
  return v25;
}

uint64_t FigICY_CustomURLLoaderCallbackFn(uint64_t a1, uint64_t a2, const void *a3, void *a4, char a5)
{
  CMBlockBufferRef theBuffer = 0;
  uint64_t v8 = FigICY_LockAndCopyPump(a1, a2);
  if (!v8) {
    goto LABEL_45;
  }
  uint64_t v9 = v8;
  int v10 = a5 & 1;
  if (a4) {
    CFDictionaryRef v11 = (OpaqueCMBlockBuffer *)CFRetain(a4);
  }
  else {
    CFDictionaryRef v11 = 0;
  }
  CMBlockBufferRef theBuffer = v11;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v13 = DerivedStorage;
  int v14 = v10;
  if (a3)
  {
    int v14 = v10;
    if (!*(void *)(DerivedStorage + 328))
    {
      *(void *)(DerivedStorage + 328) = CFRetain(a3);
      CMTimeValue value = 0;
      CFDictionaryRef theDict = 0;
      if (*(unsigned char *)(v13 + 336))
      {
        uint64_t v29 = 0;
        *(unsigned char *)(v13 + 337) = 1;
        FigCustomURLResponseInfoCopyHTTPHeaders();
        if (theDict)
        {
          if (CFDictionaryGetValueIfPresent(theDict, @"Content-Range", (const void **)&value)
            && FigCFHTTPGetContentRangeFromHeaderString((uint64_t)value, &v29, 0, 0, 0)
            && v29 == *(void *)(v13 + 344))
          {
            *(unsigned char *)(v13 + 337) = 0;
          }
          if (theDict) {
            CFRelease(theDict);
          }
        }
      }
      int v14 = 1;
    }
  }
  uint64_t v15 = 0;
  if (a4 && *(unsigned char *)(v13 + 337))
  {
    if (*(void *)(v13 + 352) >= *(void *)(v13 + 344))
    {
      uint64_t v15 = 0;
      *(unsigned char *)(v13 + 337) = 0;
      if (v11) {
        goto LABEL_24;
      }
LABEL_30:
      BOOL v20 = 0;
      uint64_t v19 = 0;
      goto LABEL_31;
    }
    Dataunint64_t Length = CMBlockBufferGetDataLength((CMBlockBufferRef)a4);
    uint64_t v17 = *(void *)(v13 + 352);
    size_t v18 = *(void *)(v13 + 344) - v17;
    *(void *)(v13 + 352) = v17 + DataLength;
    if (v11)
    {
      CFRelease(v11);
      CMBlockBufferRef theBuffer = 0;
    }
    if (DataLength <= v18)
    {
      BOOL v20 = 0;
      uint64_t v19 = 0;
      uint64_t v15 = 0;
      if (v14) {
        goto LABEL_33;
      }
      goto LABEL_32;
    }
    uint64_t v15 = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CMBlockBufferRef)a4, v18, DataLength - v18, 0, &theBuffer);
    int v14 = 1;
    CFDictionaryRef v11 = theBuffer;
  }
  if (!v11) {
    goto LABEL_30;
  }
LABEL_24:
  CMBlockBufferGetDataLength(v11);
  uint64_t v19 = theBuffer;
  BOOL v20 = theBuffer != 0;
  if (*(unsigned char *)(v13 + 19) && theBuffer)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(v13 + 360), theBuffer);
    size_t v21 = *(void *)(v13 + 368) + CMBlockBufferGetDataLength(theBuffer);
    *(void *)(v13 + 368) = v21;
    if (v21 > 0x100000)
    {
      uint64_t v22 = *(void *)(v13 + 312);
      uint64_t v23 = *(void *)(v13 + 320);
      uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v24) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = 0;
      }
      uint64_t v26 = *(void (**)(uint64_t, uint64_t))(v25 + 32);
      if (v26) {
        v26(v22, v23);
      }
      *(void *)(v13 + 320) = 0;
      *(unsigned char *)(v13 + 376) = 1;
    }
    if (v10) {
      *(unsigned char *)(v13 + 377) = 1;
    }
    goto LABEL_42;
  }
LABEL_31:
  if (v14)
  {
LABEL_33:
    FigICY_HTTPCommonCallback((uint64_t)v9, v19, v10, v15);
    goto LABEL_42;
  }
LABEL_32:
  if (v20) {
    goto LABEL_33;
  }
LABEL_42:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  CFRelease(v9);
LABEL_45:
  FigRetainProxyUnlockMutex();
  return FigRetainProxyRelease();
}

uint64_t FigICY_HTTPPumpFn(uint64_t a1, int a2, uint64_t a3, OpaqueCMBlockBuffer *a4, uint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8)
{
  CFDictionaryRef v11 = FigICY_LockAndCopyPump(a3, a2);
  if (v11)
  {
    uint64_t v12 = v11;
    FigICY_HTTPCommonCallback((uint64_t)v11, a4, (a7 >> 1) & 1, a8);
    CFRelease(v12);
  }
  FigRetainProxyUnlockMutex();

  return FigRetainProxyRelease();
}

uint64_t fbp_NetworkInactivityTimer()
{
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    uint64_t Owner = FigRetainProxyGetOwner();
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    uint64_t v4 = DerivedStorage;
    unint64_t v5 = UpTimeNanoseconds - *(void *)(DerivedStorage + 40);
    if (v5 <= 0x37E11D5FFLL)
    {
      unsigned int v7 = *(NSObject **)(DerivedStorage + 48);
      if (v7)
      {
        double v8 = (double)(15000000000 - v5) / 1000000000.0;
        if (v8 < 1.0) {
          double v8 = 1.0;
        }
        FigHTTPRescheduleTimer(v8, *(void *)(DerivedStorage + 80), v7);
      }
    }
    else if (*(unsigned char *)(DerivedStorage + 19))
    {
      if (dword_1E9350AB0)
      {
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
    }
    else
    {
      if (dword_1E9350AB0)
      {
        uint64_t v9 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      fbp_CancelAndRetryRequest(Owner, v4, 4294950466);
    }
  }
  return FigRetainProxyUnlockMutex();
}

const void *FigICY_LockAndCopyPump(uint64_t a1, uint64_t a2)
{
  FigRetainProxyRetain();
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated()) {
    return 0;
  }
  uint64_t Owner = (const void *)FigRetainProxyGetOwner();
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 304))
  {
    uint64_t result = 0;
    if (!Owner) {
      return result;
    }
    uint64_t v6 = *(void *)(DerivedStorage + 320);
  }
  else
  {
    uint64_t result = 0;
    if (!Owner) {
      return result;
    }
    uint64_t v6 = *(int *)(DerivedStorage + 152);
  }
  if (v6 == a2)
  {
    CFRetain(Owner);
    return Owner;
  }
  return result;
}

void FigICY_HTTPCommonCallback(uint64_t a1, OpaqueCMBlockBuffer *a2, int a3, uint64_t a4)
{
  destination[16] = *(CMBlockBufferRef *)MEMORY[0x1E4F143B8];
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t appended = a4;
  int v104 = a4;
  if (a4) {
    goto LABEL_195;
  }
  *(void *)(DerivedStorage + 40) = FigGetUpTimeNanoseconds();
  *(_DWORD *)(DerivedStorage + 56) = 0;
  if (a3) {
    FigHTTPStopAndReleaseTimer((dispatch_object_t *)(DerivedStorage + 48));
  }
  if (*(unsigned char *)(DerivedStorage + 19)) {
    *(void *)(DerivedStorage + 288) = FigGetUpTimeNanoseconds();
  }
  if (!a2)
  {
    uint64_t appended = 0;
    if (a3) {
      goto LABEL_171;
    }
    goto LABEL_194;
  }
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t appended = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, 2u, &blockBufferOut);
  if (!appended) {
    a2 = blockBufferOut;
  }
  Dataunint64_t Length = CMBlockBufferGetDataLength(a2);
  size_t v11 = DataLength;
  uint64_t v12 = *(OpaqueCMBlockBuffer **)(DerivedStorage + 216);
  if (v12 && DataLength)
  {
    size_t v13 = CMBlockBufferGetDataLength(a2);
    uint64_t appended = CMBlockBufferAppendBufferReference(v12, a2, 0, v13, 0);
    size_t v11 = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(DerivedStorage + 216));
  }
  else
  {
    if (a2) {
      BOOL v14 = DataLength == 0;
    }
    else {
      BOOL v14 = 1;
    }
    if (!v14)
    {
      *(void *)(DerivedStorage + 216) = CFRetain(a2);
      *(void *)(DerivedStorage + 232) = 0;
    }
  }
  BOOL v16 = (v11 & 0xFFFFFFFFFFFF0000) != 0 && a3 == 0;
  BOOL v101 = v16;
  CFRange v103 = (CMBlockBufferRef *)(DerivedStorage + 160);
  CFStringRef inTagClass = (const __CFString *)*MEMORY[0x1E4F22500];
  while (2)
  {
    switch(*(_DWORD *)(DerivedStorage + 224))
    {
      case 0:
        CFURLRef url = 0;
        if (*(unsigned char *)(DerivedStorage + 304))
        {
          if (!*(void *)(DerivedStorage + 328))
          {
            uint64_t appended = 4294954651;
            goto LABEL_195;
          }
          uint64_t v17 = FigCustomURLResponseInfoCopyFinalURL();
        }
        else
        {
          uint64_t v48 = *(void *)(DerivedStorage + 144);
          uint64_t v49 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v49) {
            uint64_t v50 = v49;
          }
          else {
            uint64_t v50 = 0;
          }
          CFIndex v53 = *(uint64_t (**)(uint64_t, uint64_t, void, CFURLRef *))(v50 + 48);
          if (!v53)
          {
            uint64_t appended = 4294954514;
LABEL_195:
            uint64_t v87 = *(const void **)(DerivedStorage + 216);
            if (v87)
            {
              CFRelease(v87);
              *(void *)(DerivedStorage + 216) = 0;
            }
            *(void *)(DerivedStorage + 232) = 0;
            if (a3 || v104)
            {
              FigICY_InvalidateHTTP(DerivedStorage);
              if (v104)
              {
                fbp_CancelAndRetryRequest(a1, DerivedStorage, appended);
                goto LABEL_222;
              }
            }
            if (dword_1E9350AB0)
            {
              LODWORD(url) = 0;
              os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              unsigned int v89 = url;
              if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT)) {
                unsigned int v90 = v89;
              }
              else {
                unsigned int v90 = v89 & 0xFFFFFFFE;
              }
              if (v90)
              {
                *(_DWORD *)cf = 136315394;
                *(void *)&cf[4] = "FigICY_HTTPCommonCallback";
                __int16 v110 = 1024;
                int v111 = appended;
                _os_log_send_and_compose_impl();
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
            uint64_t v95 = *(void *)(DerivedStorage + 72);
            uint64_t v96 = *(void *)(DerivedStorage + 192);
            CMTimeScale v97 = (long long *)MEMORY[0x1E4F1F9F8];
            uint64_t v98 = a1;
            uint64_t v99 = DerivedStorage;
            uint64_t v100 = appended;
            goto LABEL_221;
          }
          uint64_t v17 = v53(v48, 0x1EE57B618, 0, &url);
        }
        uint64_t appended = v17;
        if (v17) {
          goto LABEL_195;
        }
        if (!url) {
          goto LABEL_98;
        }
        CFStringRef v54 = CFURLCopyPathExtension(url);
        CFRelease(url);
        if (!v54) {
          goto LABEL_98;
        }
        if (CFStringCompare(v54, @"pls", 1uLL) == kCFCompareEqualTo
          || CFStringCompare(v54, @"m3u8", 1uLL) == kCFCompareEqualTo
          || CFStringCompare(v54, @"m3u", 1uLL) == kCFCompareEqualTo)
        {
          CFRelease(v54);
          if (*(void *)(DerivedStorage + 168)) {
            goto LABEL_226;
          }
          uint64_t Empty = CMBlockBufferCreateEmpty(*(CFAllocatorRef *)DerivedStorage, 0, 0, v103);
          if (Empty) {
            goto LABEL_227;
          }
          unsigned int v57 = *(_DWORD *)(DerivedStorage + 280) + 1;
          *(_DWORD *)(DerivedStorage + 280) = v57;
          if (v57 > 1) {
            goto LABEL_226;
          }
          goto LABEL_128;
        }
        CFRelease(v54);
LABEL_98:
        destination[0] = 0;
        if (*(unsigned char *)(DerivedStorage + 304))
        {
          if (!*(void *)(DerivedStorage + 328)) {
            goto LABEL_121;
          }
          uint64_t appended = FigCustomURLResponseInfoCopyUniversalTypeIdentifier();
          CMBlockBufferRef v55 = destination[0];
          if (!appended)
          {
            CFStringRef v56 = UTTypeCopyPreferredTagWithClass((CFStringRef)destination[0], inTagClass);
            CMBlockBufferRef v55 = destination[0];
            if (!destination[0]) {
              goto LABEL_115;
            }
            goto LABEL_113;
          }
          CFStringRef v56 = 0;
          if (destination[0]) {
            goto LABEL_113;
          }
        }
        else
        {
          *(void *)cf = 0;
          uint64_t v58 = *(void *)(DerivedStorage + 144);
          uint64_t v59 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v59) {
            uint64_t v60 = v59;
          }
          else {
            uint64_t v60 = 0;
          }
          int32_t v61 = *(uint64_t (**)(uint64_t, uint64_t, void, unsigned char *))(v60 + 48);
          if (v61)
          {
            uint64_t appended = v61(v58, 0x1EE57B5F8, 0, cf);
            if (!appended)
            {
              CFStringRef v56 = FigCFHTTPCopyMimeTypeFromHTTPResponse(*(__CFHTTPMessage **)cf);
              CMBlockBufferRef v55 = *(CMBlockBufferRef *)cf;
LABEL_113:
              CFRelease(v55);
              goto LABEL_115;
            }
            CFStringRef v56 = 0;
          }
          else
          {
            CFStringRef v56 = 0;
            uint64_t appended = 4294954514;
          }
        }
LABEL_115:
        if (appended) {
          goto LABEL_195;
        }
        if (v56)
        {
          if (CFStringCompare(v56, @"audio/mpegurl", 1uLL)
            && CFStringCompare(v56, @"audio/x-mpegurl", 1uLL)
            && CFStringCompare(v56, @"audio/scpls", 1uLL))
          {
            CFComparisonResult v62 = CFStringCompare(v56, @"audio/x-scpls", 1uLL);
            CFRelease(v56);
            if (v62) {
              goto LABEL_121;
            }
          }
          else
          {
            CFRelease(v56);
          }
          if (*(void *)(DerivedStorage + 168))
          {
LABEL_226:
            uint64_t Empty = FigSignalErrorAt();
LABEL_227:
            uint64_t appended = Empty;
            if (!Empty) {
              goto LABEL_222;
            }
            goto LABEL_195;
          }
          uint64_t Empty = CMBlockBufferCreateEmpty(*(CFAllocatorRef *)DerivedStorage, 0, 0, v103);
          if (Empty) {
            goto LABEL_227;
          }
LABEL_128:
          uint64_t appended = 0;
          *(_DWORD *)(DerivedStorage + 224) = 5;
          continue;
        }
LABEL_121:
        *(void *)(DerivedStorage + 208) = 0;
        if (*(unsigned char *)(DerivedStorage + 304))
        {
          destination[0] = 0;
          if (*(void *)(DerivedStorage + 328) && !FigCustomURLResponseInfoGetContentLength()) {
            goto LABEL_124;
          }
        }
        else
        {
          destination[0] = 0;
          *(void *)cf = 0;
          uint64_t v63 = *(void *)(DerivedStorage + 144);
          uint64_t v64 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v64) {
            uint64_t v65 = v64;
          }
          else {
            uint64_t v65 = 0;
          }
          CFDataRef v66 = *(unsigned int (**)(uint64_t, __CFString *, void, unsigned char *))(v65 + 48);
          if (v66
            && !v66(v63, @"FHRP_PayloadLength", 0, cf)
            && CFNumberGetValue(*(CFNumberRef *)cf, kCFNumberSInt64Type, destination))
          {
LABEL_124:
            *(CMBlockBufferRef *)(DerivedStorage + 208) = destination[0];
          }
        }
        destination[0] = 0;
        *(void *)cf = 0;
        CFStringRef v106 = 0;
        if (*(unsigned char *)(DerivedStorage + 304))
        {
          if (*(void *)(DerivedStorage + 328) && !FigCustomURLResponseInfoCopyHTTPHeaders()) {
            FigCFDictionaryGetValueForCaseInsensitiveKeyIfPresent();
          }
        }
        else
        {
          uint64_t v67 = *(void *)(DerivedStorage + 144);
          uint64_t v68 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v68) {
            uint64_t v69 = v68;
          }
          else {
            uint64_t v69 = 0;
          }
          char v70 = *(unsigned int (**)(uint64_t, uint64_t, void, unsigned char *))(v69 + 48);
          if (v70 && !v70(v67, 0x1EE57B5F8, 0, cf)) {
            CFStringRef v106 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)cf, @"icy-metaint");
          }
        }
        if (destination[0]) {
          CFRelease(destination[0]);
        }
        if (*(void *)cf) {
          CFRelease(*(CFTypeRef *)cf);
        }
        if (v106)
        {
          *(unsigned char *)(DerivedStorage + 60) = 1;
          fbp_SetMetadataPeriod(DerivedStorage, v106);
          CFRelease(v106);
          int v71 = 0;
          *(_DWORD *)(DerivedStorage + 224) = 2;
        }
        else if (fbp_CopyChars(DerivedStorage, destination, 0xCuLL))
        {
          if (!strncasecmp((const char *)destination, "ICY 200 OK\r\n", 0xCuLL))
          {
            fbp_AdvanceChars(DerivedStorage, 0xCuLL);
            int v72 = 1;
          }
          else
          {
            int v72 = 2;
          }
          int v71 = 0;
          *(_DWORD *)(DerivedStorage + 224) = v72;
        }
        else
        {
          int v71 = 1;
        }
        uint64_t appended = 0;
        if (!v71) {
          continue;
        }
LABEL_164:
        CFIndex v73 = *(OpaqueCMBlockBuffer **)(DerivedStorage + 216);
        if (!v73) {
          goto LABEL_170;
        }
        size_t v74 = *(void *)(DerivedStorage + 232);
        if (v74 >= v11)
        {
          CFRelease(*(CFTypeRef *)(DerivedStorage + 216));
          *(void *)(DerivedStorage + 216) = 0;
          if (a3) {
            goto LABEL_171;
          }
          goto LABEL_194;
        }
        destination[0] = 0;
        uint64_t PlaylistFileParserFromData = CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)DerivedStorage, v73, v74, 0, 0, destination);
        if (PlaylistFileParserFromData)
        {
LABEL_229:
          uint64_t appended = PlaylistFileParserFromData;
          goto LABEL_195;
        }
        CMTimeEpoch v75 = *(const void **)(DerivedStorage + 216);
        if (v75) {
          CFRelease(v75);
        }
        uint64_t appended = 0;
        *(CMBlockBufferRef *)(DerivedStorage + 216) = destination[0];
        *(void *)(DerivedStorage + 232) = 0;
LABEL_170:
        if (!a3)
        {
LABEL_194:
          if (!appended) {
            goto LABEL_222;
          }
          goto LABEL_195;
        }
LABEL_171:
        if (*(_DWORD *)(DerivedStorage + 224) != 5) {
          goto LABEL_180;
        }
        destination[0] = 0;
        uint64_t PlaylistFileParserFromData = CreatePlaylistFileParserFromData(*(OpaqueCMBlockBuffer **)(DerivedStorage + 216), 0, (CFArrayRef **)destination);
        if (PlaylistFileParserFromData) {
          goto LABEL_229;
        }
        CMBlockBufferRef v76 = destination[0];
        if (destination[0])
        {
          CMTimeScale v77 = *(const void ***)(DerivedStorage + 168);
          if (v77)
          {
            PlaylistFileParserDestroy(v77);
            CMBlockBufferRef v76 = destination[0];
          }
          *(void *)(DerivedStorage + 168) = v76;
          *(void *)(DerivedStorage + 176) = 0;
        }
        long long v78 = *(const void **)(DerivedStorage + 216);
        if (v78) {
          CFRelease(v78);
        }
        *(void *)(DerivedStorage + 216) = 0;
        *(void *)(DerivedStorage + 232) = 0;
LABEL_180:
        int v79 = *(const __CFArray ***)(DerivedStorage + 168);
        if (!v79 || (CFArrayRef v80 = PlaylistFileParserItemCount(v79), (v81 = *(CFArrayRef **)(DerivedStorage + 168)) == 0))
        {
          if (dword_1E9350AB0)
          {
            LODWORD(url) = 0;
            long long v84 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v85 = url;
            if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT)) {
              unsigned int v86 = v85;
            }
            else {
              unsigned int v86 = v85 & 0xFFFFFFFE;
            }
            if (v86)
            {
              *(_DWORD *)cf = 136315138;
              *(void *)&cf[4] = "FigICY_HTTPCommonCallback";
              _os_log_send_and_compose_impl();
            }
            goto LABEL_219;
          }
LABEL_220:
          uint64_t v95 = *(void *)(DerivedStorage + 72);
          uint64_t v96 = *(void *)(DerivedStorage + 192);
          CMTimeScale v97 = (long long *)MEMORY[0x1E4F1F9F8];
          uint64_t v98 = a1;
          uint64_t v99 = DerivedStorage;
          uint64_t v100 = 0;
LABEL_221:
          fbp_SendDataCallback(v98, v99, v95, 0, 2, v96, v97, v100);
          goto LABEL_222;
        }
        CFIndex v82 = *(void *)(DerivedStorage + 176);
        if (v82 >= (uint64_t)v80)
        {
          if (dword_1E9350AB0)
          {
            LODWORD(url) = 0;
            v91 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v92 = url;
            if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT)) {
              unsigned int v93 = v92;
            }
            else {
              unsigned int v93 = v92 & 0xFFFFFFFE;
            }
            if (v93)
            {
              uint64_t v94 = *(void *)(DerivedStorage + 176);
              *(_DWORD *)cf = 136315650;
              *(void *)&cf[4] = "FigICY_HTTPCommonCallback";
              __int16 v110 = 1024;
              int v111 = v94;
              __int16 v112 = 1024;
              int v113 = (int)v80;
              _os_log_send_and_compose_impl();
            }
LABEL_219:
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            goto LABEL_220;
          }
          goto LABEL_220;
        }
        destination[0] = 0;
        uint64_t PlaylistFileParserFromData = PlaylistFileParserCopyItem(v81, v82, destination);
        if (PlaylistFileParserFromData) {
          goto LABEL_229;
        }
        ++*(void *)(DerivedStorage + 176);
        FigICY_InvalidateHTTP(DerivedStorage);
        *(unsigned char *)(DerivedStorage + 20) = 0;
        CFURLRef v83 = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)destination[0], 0);
        CFRelease(destination[0]);
        if (!v83)
        {
          *(_DWORD *)(DerivedStorage + 224) = 0;
          *(unsigned char *)(DerivedStorage + 21) = 1;
          goto LABEL_222;
        }
        uint64_t appended = FigICY_CreateHTTPRequest(a1, v83, 0);
        CFRelease(v83);
        *(_DWORD *)(DerivedStorage + 224) = 0;
        *(unsigned char *)(DerivedStorage + 21) = 1;
        if (appended) {
          goto LABEL_195;
        }
LABEL_222:
        if (blockBufferOut) {
          CFRelease(blockBufferOut);
        }
        return;
      case 1:
        *(void *)cf = 0;
        LOBYTE(url) = 0;
        do
        {
          if (!fbp_CopyChars(DerivedStorage, destination, 0x20uLL)) {
            goto LABEL_163;
          }
          if (!strncasecmp((const char *)destination, "icy-metaint:", 0xCuLL))
          {
            uint64_t appended = fbp_GrabHeaderPayload(DerivedStorage, 0xCuLL, (CFStringRef *)cf, &url);
            if (!appended)
            {
              CFStringRef v47 = *(const __CFString **)cf;
              if (*(void *)cf)
              {
                *(unsigned char *)(DerivedStorage + 60) = 1;
                fbp_SetMetadataPeriod(DerivedStorage, v47);
                CFRelease(*(CFTypeRef *)cf);
                uint64_t appended = 0;
              }
            }
          }
          else
          {
            if (!strncasecmp((const char *)destination, "\r\n", 2uLL))
            {
              fbp_AdvanceChars(DerivedStorage, 2uLL);
              *(_DWORD *)(DerivedStorage + 224) = 2;
              goto LABEL_87;
            }
            uint64_t appended = fbp_GrabHeaderPayload(DerivedStorage, 0, 0, &url);
          }
        }
        while (!(_BYTE)url && !appended);
        if (appended) {
          goto LABEL_195;
        }
        if ((_BYTE)url)
        {
LABEL_163:
          uint64_t appended = 0;
          *(int64x2_t *)(DerivedStorage + 192) = vaddq_s64(*(int64x2_t *)(DerivedStorage + 192), vdupq_n_s64(v11));
          goto LABEL_164;
        }
LABEL_87:
        uint64_t appended = 0;
        CMTimeEpoch v51 = (const double *)(DerivedStorage + 232);
        int64x2_t v52 = (int64x2_t)vld1q_dup_f64(v51);
        *(int64x2_t *)(DerivedStorage + 192) = vaddq_s64(*(int64x2_t *)(DerivedStorage + 192), v52);
        continue;
      case 2:
        uint64_t v30 = *(OpaqueCMBlockBuffer **)(DerivedStorage + 216);
        if (!v30) {
          goto LABEL_226;
        }
        size_t v31 = CMBlockBufferGetDataLength(v30);
        size_t v32 = *(void *)(DerivedStorage + 232);
        uint64_t v33 = *(void *)(DerivedStorage + 240);
        unint64_t v34 = v31 - v32;
        if (v33)
        {
          destination[0] = 0;
          size_t v35 = v33 - *(void *)(DerivedStorage + 248);
          if (v35 >= v34) {
            size_t v36 = v31 - v32;
          }
          else {
            size_t v36 = v35;
          }
          uint64_t PlaylistFileParserFromData = CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)DerivedStorage, *(CMBlockBufferRef *)(DerivedStorage + 216), v32, v36, 0, destination);
          if (PlaylistFileParserFromData) {
            goto LABEL_229;
          }
          int v37 = fbp_SendDataCallback(a1, DerivedStorage, *(void *)(DerivedStorage + 72), (uint64_t)destination[0], 0, *(void *)(DerivedStorage + 192), MEMORY[0x1E4F1F9F8], 0);
          if (destination[0]) {
            CFRelease(destination[0]);
          }
          if (v37) {
            goto LABEL_222;
          }
          size_t v38 = *(void *)(DerivedStorage + 240);
          size_t v39 = *(void *)(DerivedStorage + 248) + v36;
          *(void *)(DerivedStorage + 248) = v39;
          *(void *)(DerivedStorage + 232) += v36;
          *(int64x2_t *)(DerivedStorage + 192) = vaddq_s64(*(int64x2_t *)(DerivedStorage + 192), vdupq_n_s64(v36));
          if (v39 >= v38)
          {
            *(_DWORD *)(DerivedStorage + 224) = 3;
            *(void *)(DerivedStorage + 248) = 0;
          }
          unint64_t v40 = v34 - v36;
        }
        else
        {
          if (fbp_SendDataCallback(a1, DerivedStorage, *(void *)(DerivedStorage + 72), (uint64_t)a2, 0, *(void *)(DerivedStorage + 192), MEMORY[0x1E4F1F9F8], 0))goto LABEL_222; {
          unint64_t v40 = 0;
          }
          *(void *)(DerivedStorage + 232) += v34;
          *(int64x2_t *)(DerivedStorage + 192) = vaddq_s64(*(int64x2_t *)(DerivedStorage + 192), vdupq_n_s64(v34));
        }
        uint64_t appended = 0;
        if (!v40) {
          goto LABEL_164;
        }
        continue;
      case 3:
        LOBYTE(destination[0]) = 0;
        *(void *)(DerivedStorage + 248) = 0;
        uint64_t v41 = *(OpaqueCMBlockBuffer **)(DerivedStorage + 216);
        if (!v41) {
          goto LABEL_226;
        }
        uint64_t Empty = CMBlockBufferCopyDataBytes(v41, *(void *)(DerivedStorage + 232), 1uLL, destination);
        if (Empty) {
          goto LABEL_227;
        }
        uint64_t v43 = LOBYTE(destination[0]);
        *(void *)(DerivedStorage + 256) = LOBYTE(destination[0]);
        if (v43)
        {
          uint64_t v44 = *(void **)(DerivedStorage + 272);
          if (v44)
          {
            CFAllocatorDeallocate(v9, v44);
            *(void *)(DerivedStorage + 272) = 0;
            uint64_t v43 = *(void *)(DerivedStorage + 256);
          }
          *(void *)(DerivedStorage + 256) = 16 * v43;
          uint64_t v45 = CFAllocatorAllocate(v9, (16 * v43) | 1, 0);
          *(void *)(DerivedStorage + 272) = v45;
          if (v45) {
            v45[*(void *)(DerivedStorage + 256)] = 0;
          }
          *(void *)(DerivedStorage + 264) = 0;
          int v46 = 4;
        }
        else
        {
          int v46 = 2;
        }
        *(_DWORD *)(DerivedStorage + 224) = v46;
        unint64_t v25 = *(void *)(DerivedStorage + 232) + 1;
        *(void *)(DerivedStorage + 232) = v25;
        *(int64x2_t *)(DerivedStorage + 192) = vaddq_s64(*(int64x2_t *)(DerivedStorage + 192), vdupq_n_s64(1uLL));
        size_t v29 = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(DerivedStorage + 216));
        uint64_t appended = 0;
        goto LABEL_84;
      case 4:
        size_t v18 = *(OpaqueCMBlockBuffer **)(DerivedStorage + 216);
        if (!v18) {
          goto LABEL_226;
        }
        size_t v19 = CMBlockBufferGetDataLength(v18);
        size_t v20 = *(void *)(DerivedStorage + 232);
        size_t v21 = *(void *)(DerivedStorage + 256);
        uint64_t v22 = *(void *)(DerivedStorage + 264);
        if (v19 - v20 >= v21 - v22) {
          size_t v23 = v21 - v22;
        }
        else {
          size_t v23 = v19 - v20;
        }
        uint64_t v24 = *(void *)(DerivedStorage + 272);
        if (!v24) {
          goto LABEL_37;
        }
        uint64_t appended = CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(DerivedStorage + 216), v20, v23, (void *)(v24 + v22));
        if (appended) {
          goto LABEL_195;
        }
        size_t v20 = *(void *)(DerivedStorage + 232);
        size_t v21 = *(void *)(DerivedStorage + 256);
        uint64_t v22 = *(void *)(DerivedStorage + 264);
LABEL_37:
        unint64_t v25 = v20 + v23;
        *(void *)(DerivedStorage + 232) = v20 + v23;
        size_t v26 = v22 + v23;
        *(void *)(DerivedStorage + 264) = v26;
        if (v26 < v21) {
          goto LABEL_42;
        }
        *(_DWORD *)(DerivedStorage + 224) = 2;
        uint64_t v27 = *(void **)(DerivedStorage + 272);
        if (!v27) {
          goto LABEL_42;
        }
        destination[0] = 0;
        uint64_t PlaylistFileParserFromData = CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)DerivedStorage, v27, v21 + 1, v9, 0, 0, v21 + 1, 0, destination);
        if (PlaylistFileParserFromData) {
          goto LABEL_229;
        }
        *(void *)(DerivedStorage + 272) = 0;
        CMSetAttachment(destination[0], @"FBPAKey_TimedData", @"FBPA_TimedData_ICY", 0);
        uint64_t appended = fbp_SendDataCallback(a1, DerivedStorage, *(void *)(DerivedStorage + 72), (uint64_t)destination[0], 0, *(void *)(DerivedStorage + 192), MEMORY[0x1E4F1F9F8], 0);
        CFRelease(destination[0]);
        if (appended) {
          goto LABEL_222;
        }
        unint64_t v25 = *(void *)(DerivedStorage + 232);
LABEL_42:
        *(int64x2_t *)(DerivedStorage + 192) = vaddq_s64(*(int64x2_t *)(DerivedStorage + 192), vdupq_n_s64(v23));
        size_t v29 = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(DerivedStorage + 216));
LABEL_84:
        if (v25 >= v29) {
          goto LABEL_164;
        }
        continue;
      case 5:
        if (v101) {
          goto LABEL_226;
        }
        goto LABEL_164;
      default:
        continue;
    }
  }
}

void fbp_SetMetadataPeriod(uint64_t a1, CFStringRef str)
{
  IntCFDictionaryRef Value = CFStringGetIntValue(str);
  *(void *)(a1 + 240) = IntValue;
  if ((IntValue - 0x7FFFFFFF) <= 1) {
    *(void *)(a1 + 240) = (unint64_t)CFStringGetDoubleValue(str);
  }
}

uint64_t fbp_CancelAndRetryRequest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(int *)(a2 + 56) <= 1 && !*(void *)(a2 + 208) && !*(unsigned char *)(a2 + 19) && *(unsigned char *)(a2 + 60))
  {
    uint64_t result = FigICY_CreateHTTPRequest(a1, *(void *)(a2 + 96), 0);
    if (!result)
    {
      ++*(_DWORD *)(a2 + 56);
      *(unsigned char *)(a2 + 21) = 1;
      return result;
    }
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (dword_1E9350AB0)
  {
    double v8 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return fbp_SendDataCallback(a1, a2, *(void *)(a2 + 72), 0, 2, *(void *)(a2 + 192), MEMORY[0x1E4F1F9F8], a3);
}

uint64_t fbp_CopyChars(uint64_t result, void *a2, size_t a3)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = *(void *)(result + 216);
    if (result)
    {
      Dataunint64_t Length = CMBlockBufferGetDataLength((CMBlockBufferRef)result);
      size_t v7 = *(void *)(v3 + 232);
      if (DataLength - v7 < a3)
      {
        return 0;
      }
      else
      {
        if (DataLength != v7)
        {
          if (DataLength - v7 >= a3) {
            size_t v8 = a3;
          }
          else {
            size_t v8 = DataLength - v7;
          }
          CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v3 + 216), v7, v8, a2);
        }
        return 1;
      }
    }
  }
  return result;
}

void fbp_AdvanceChars(uint64_t a1, size_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(OpaqueCMBlockBuffer **)(a1 + 216);
    if (v3)
    {
      Dataunint64_t Length = CMBlockBufferGetDataLength(v3);
      uint64_t v6 = *(void *)(a1 + 232);
      if (DataLength - v6 <= a2)
      {
        size_t v8 = *(const void **)(a1 + 216);
        if (v8) {
          CFRelease(v8);
        }
        size_t v7 = 0;
        *(void *)(a1 + 216) = 0;
      }
      else
      {
        size_t v7 = v6 + a2;
      }
      *(void *)(a1 + 232) = v7;
    }
  }
}

uint64_t fbp_GrabHeaderPayload(uint64_t a1, size_t a2, CFStringRef *a3, unsigned char *a4)
{
  size_t v8 = *(OpaqueCMBlockBuffer **)(a1 + 216);
  uint64_t v9 = *(void *)(a1 + 232);
  size_t v10 = v9 + a2;
  Dataunint64_t Length = CMBlockBufferGetDataLength(v8);
  size_t v12 = DataLength - v10;
  if (DataLength != v10)
  {
    size_t v15 = 0;
    size_t v26 = 0;
    size_t lengthAtOffsetOut = 0;
    while (!CMBlockBufferGetDataPointer(v8, v15 + v10, &lengthAtOffsetOut, 0, &v26))
    {
      if (lengthAtOffsetOut)
      {
        uint64_t v16 = 0;
        while (v26[v16] != 13)
        {
          if (lengthAtOffsetOut == ++v16)
          {
            v15 += lengthAtOffsetOut;
            goto LABEL_12;
          }
        }
        uint64_t v17 = *(void *)(a1 + 232);
        size_t v18 = v9 + v15 - v17 + v16;
        size_t v19 = *(OpaqueCMBlockBuffer **)(a1 + 216);
        if (v19) {
          size_t v20 = CMBlockBufferGetDataLength(v19) - *(void *)(a1 + 232);
        }
        else {
          size_t v20 = 0;
        }
        if (v20 < v18 + 2) {
          goto LABEL_17;
        }
        *a4 = 0;
        fbp_AdvanceChars(a1, a2);
        if (a3)
        {
          uint64_t v22 = (char *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9 + v15 - v17 + v16 + 1, 0);
          if (!v22) {
            return FigSignalErrorAt();
          }
          size_t v23 = v22;
          fbp_CopyChars(a1, v22, v18);
        }
        else
        {
          size_t v23 = 0;
        }
        fbp_AdvanceChars(a1, v18);
        fbp_CopyChars(a1, &lengthAtOffsetOut, 2uLL);
        fbp_AdvanceChars(a1, 2uLL);
        if ((unsigned __int16)lengthAtOffsetOut != 2573)
        {
          if (v23) {
            CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v23);
          }
          return FigSignalErrorAt();
        }
        if (!v23) {
          return 0;
        }
        v23[v9 + v15 - v17 + v16] = 0;
        CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFStringRef v25 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v23, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
        uint64_t v14 = 0;
        *a3 = v25;
        if (!v25)
        {
          uint64_t v14 = FigSignalErrorAt();
          CFAllocatorDeallocate(v24, v23);
        }
        return v14;
      }
LABEL_12:
      if (v15 >= v12) {
        break;
      }
    }
  }
  size_t v13 = *(OpaqueCMBlockBuffer **)(a1 + 216);
  if (v13 && CMBlockBufferGetDataLength(v13) - *(void *)(a1 + 232) > 0x1000) {
    return FigSignalErrorAt();
  }
LABEL_17:
  uint64_t v14 = 0;
  *a4 = 1;
  return v14;
}

uint64_t MovieSampleDataWriterCreate(const void *a1, const void *a2, uint64_t a3, uint64_t a4, char a5, unsigned int a6, uint64_t *a7)
{
  if (a2 && a7)
  {
    if (sMovieSampleDataWriterRegisterTypeOnce != -1) {
      dispatch_once_f(&sMovieSampleDataWriterRegisterTypeOnce, 0, (dispatch_function_t)movieSampleDataWriterRegisterType);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v15 = Instance;
      if (a1) {
        CFTypeRef v16 = CFRetain(a1);
      }
      else {
        CFTypeRef v16 = 0;
      }
      *(void *)(v15 + 16) = v16;
      *(void *)(v15 + 24) = CFRetain(a2);
      uint64_t v17 = MediaDataChunkWriterCreate((const __CFAllocator *)a1, (uint64_t *)(v15 + 32));
      if (!v17)
      {
        uint64_t v18 = FigSimpleMutexCreate();
        *(void *)(v15 + 48) = v18;
        if (v18
          && (CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)a1, 0, 0), (*(void *)(v15 + 56) = Mutable) != 0))
        {
          *(unsigned char *)(v15 + 72) = a5 & 1;
          uint64_t v17 = MovieHeaderMakerCopyFileTypeMajorBrand((uint64_t)a1, (uint64_t)a2, a3, a4, (CFNumberRef *)(v15 + 80));
          if (!v17)
          {
            uint64_t v17 = MovieHeaderMakerCopyFileTypeMinorVersion((uint64_t)a1, (uint64_t)a2, a3, a4, (CFNumberRef *)(v15 + 88));
            if (!v17)
            {
              uint64_t v17 = MovieHeaderMakerCopyFileTypeCompatibleBrands((const __CFAllocator *)a1, (uint64_t)a2, a3, a4, (CFMutableArrayRef *)(v15 + 96));
              if (!v17)
              {
                if (a6 <= 3)
                {
                  *(unsigned char *)(v15 + 105) = 0x1010100u >> (8 * a6);
                  *(unsigned char *)(v15 + 104) = 0x1000100u >> (8 * a6);
                  *(unsigned char *)(v15 + 106) = 0x1000000u >> (8 * a6);
                }
                uint64_t v17 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0x4000uLL, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0x4000uLL, 1u, (CMBlockBufferRef *)(v15 + 144));
                if (!v17)
                {
                  uint64_t v20 = CMBlockBufferFillDataBytes(0, *(CMBlockBufferRef *)(v15 + 144), 0, 0);
                  if (!v20)
                  {
                    *a7 = v15;
                    return v20;
                  }
LABEL_23:
                  CFRelease((CFTypeRef)v15);
                  return v20;
                }
              }
            }
          }
        }
        else
        {
          uint64_t v17 = FigSignalErrorAt();
        }
      }
      uint64_t v20 = v17;
      goto LABEL_23;
    }
  }

  return FigSignalErrorAt();
}

uint64_t MovieSampleDataWriterAddTrack(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a1 && a3 && a5 && (size_t v10 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 16), 16, 0)) != 0)
  {
    size_t v11 = v10;
    *size_t v10 = 0;
    v10[1] = 0;
    *(_DWORD *)size_t v10 = a2;
    uint64_t v12 = MediaDataChunkWriterAddTrack(*(CFAllocatorRef **)(a1 + 32), a2, 0, a3, a4, v10 + 1);
    if (v12)
    {
      CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 16), v11);
    }
    else
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), v11);
      *a5 = v11;
    }
    return v12;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterSetThreadPriorityAndClientPID(uint64_t a1)
{
  if (a1)
  {
    if (!*(void *)(a1 + 64))
    {
      uint64_t v2 = FigDispatchQueueCreateWithPriorityAndClientPID();
      *(void *)(a1 + 64) = v2;
      if (v2) {
        return 0;
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t MovieSampleDataWriterFlushPendingAsynchronousTasks(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(NSObject **)(a1 + 64);
    if (v2) {
      dispatch_sync_f(v2, 0, (dispatch_function_t)doNothingFunc);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterPatchMediaDataAtomSizeIfNeeded(uint64_t *a1)
{
  if (a1)
  {
    MEMORY[0x19970E910](a1[6]);
    uint64_t v3 = a1[5];
    if (v3)
    {
      uint64_t v4 = MediaDataChunkWriterFlush(a1[4], v3);
      if (!v4) {
        uint64_t v4 = patchMediaDataAtomSizeIfNeeded((uint64_t)a1);
      }
    }
    else
    {
      uint64_t v4 = FigSignalErrorAt();
    }
    uint64_t v5 = v4;
    MEMORY[0x19970E930](a1[6]);
    return v5;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t patchMediaDataAtomSizeIfNeeded(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 108) != 1) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *(uint64_t (**)(uint64_t, void, uint64_t *))(v4 + 24);
  if (!v5) {
    return 4294954514;
  }
  uint64_t result = v5(v2, 0, &v7);
  if (!result) {
    return patchMediaDataAtomSize(a1, *(void *)(a1 + 112), v7 - *(void *)(a1 + 112), *(unsigned __int8 *)(a1 + 106));
  }
  return result;
}

uint64_t MovieSampleDataWriterGetFirstMediaDataAtomOffset(uint64_t a1, int a2, void *a3)
{
  if (a1 && a3)
  {
    MEMORY[0x19970E910](*(void *)(a1 + 48));
    if (*(unsigned char *)(a1 + 120) == 1)
    {
      if (a2)
      {
        uint64_t v6 = -8;
        if (!*(unsigned char *)(a1 + 104)) {
          uint64_t v6 = 0;
        }
      }
      else
      {
        uint64_t v6 = 0;
      }
      uint64_t v7 = 0;
      *a3 = v6 + *(void *)(a1 + 128);
    }
    else
    {
      uint64_t v7 = FigSignalErrorAt();
    }
    MEMORY[0x19970E930](*(void *)(a1 + 48));
    return v7;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterPatchFirstMediaDataAtomSize(uint64_t a1, unint64_t a2)
{
  if (!a1 || (a2 & 0x8000000000000000) != 0)
  {
    return FigSignalErrorAt();
  }
  else
  {
    MEMORY[0x19970E910](*(void *)(a1 + 48));
    if (*(void *)(a1 + 40) && *(unsigned char *)(a1 + 120) == 1) {
      uint64_t v4 = patchMediaDataAtomSize(a1, *(void *)(a1 + 128), a2, *(unsigned __int8 *)(a1 + 106));
    }
    else {
      uint64_t v4 = FigSignalErrorAt();
    }
    uint64_t v5 = v4;
    MEMORY[0x19970E930](*(void *)(a1 + 48));
    return v5;
  }
}

uint64_t patchMediaDataAtomSize(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v21 = 0;
  if (HIDWORD(a3) || a4)
  {
    if (*(unsigned char *)(a1 + 104) != 1)
    {
      return FigSignalErrorAt();
    }
    uint64_t v20 = 0x7461646D01000000;
    unint64_t v19 = bswap64(a3 + 8);
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *))(v11 + 16);
    if (v14)
    {
      uint64_t result = v14(v9, 8, a2 - 8, &v20, &v21);
      if (result) {
        return result;
      }
      if (v21 == 8)
      {
        uint64_t v15 = *(void *)(a1 + 40);
        uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v16) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = 0;
        }
        uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *, uint64_t *))(v17 + 16);
        if (!v18) {
          return 4294954514;
        }
        uint64_t result = v18(v15, 8, a2, &v19, &v21);
        if (result) {
          return result;
        }
        if (v21 == 8) {
          goto LABEL_23;
        }
      }
      return FigSignalErrorAt();
    }
    return 4294954514;
  }
  LODWORD(v20) = bswap32(a3);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *))(v8 + 16);
  if (!v12) {
    return 4294954514;
  }
  uint64_t result = v12(v6, 4, a2, &v20, &v21);
  if (!result)
  {
    if (v21 != 4) {
      return FigSignalErrorAt();
    }
LABEL_23:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 108) = 2;
  }
  return result;
}

uint64_t MovieSampleDataWriterSetPredeterminedMediaDataAtomSize(uint64_t a1, uint64_t a2)
{
  if (!a1 || a2 && a2 <= 7 || *(_DWORD *)(a1 + 108)) {
    return FigSignalErrorAt();
  }
  *(void *)(a1 + 136) = a2;
  return 0;
}

uint64_t MovieSampleDataWriterSetDefaultByteStream(uint64_t a1, const void *a2)
{
  if (a1 && a2)
  {
    MEMORY[0x19970E910](*(void *)(a1 + 48));
    uint64_t v4 = *(const void **)(a1 + 40);
    *(void *)(a1 + 40) = a2;
    CFRetain(a2);
    if (v4) {
      CFRelease(v4);
    }
    CFArrayRef started = startNewChunkForAllTracks(a1);
    if (!started) {
      *(_DWORD *)(a1 + 108) = 0;
    }
    MEMORY[0x19970E930](*(void *)(a1 + 48));
    return (uint64_t)started;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

CFArrayRef startNewChunkForAllTracks(uint64_t a1)
{
  CFArrayRef result = *(const __CFArray **)(a1 + 56);
  if (result)
  {
    CFIndex Count = CFArrayGetCount(result);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      CFIndex v4 = Count;
      CFIndex v5 = 0;
      while (1)
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v5);
        CFArrayRef result = (const __CFArray *)MediaDataChunkWriterTrackStartNewChunk(*(void *)(a1 + 32), ValueAtIndex[1]);
        if (result) {
          break;
        }
        if (v4 == ++v5) {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t MovieSampleDataWriterGetLengthOfDefaultByteStream(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  if (a1 && a2)
  {
    MEMORY[0x19970E910](a1[6]);
    uint64_t v4 = a1[5];
    if (v4)
    {
      Entireunint64_t Length = MediaDataChunkWriterGetEntireLength(a1[4], v4, &v7);
      if (!EntireLength) {
        *a2 = v7;
      }
    }
    else
    {
      Entireunint64_t Length = FigSignalErrorAt();
    }
    MEMORY[0x19970E930](a1[6]);
    return EntireLength;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterCopyURLOfDefaultByteStream(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v13 = 0;
  if (a1 && a3)
  {
    MEMORY[0x19970E910](*(void *)(a1 + 48));
    if (*(void *)(a1 + 40))
    {
      uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
      uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v7) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v9 = *(void (**)(uint64_t, void, uint64_t, uint64_t *))(v8 + 48);
      if (v9)
      {
        v9(CMBaseObject, *MEMORY[0x1E4F1EC78], a2, &v13);
        uint64_t v10 = v13;
      }
      else
      {
        uint64_t v10 = 0;
      }
      uint64_t v11 = 0;
      *a3 = v10;
    }
    else
    {
      uint64_t v11 = FigSignalErrorAt();
    }
    MEMORY[0x19970E930](*(void *)(a1 + 48));
    return v11;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterSynchronizeDefaultByteStream(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1) {
    goto LABEL_19;
  }
  uint64_t v3 = *(const void **)(a1 + 40);
  if (!v3) {
    goto LABEL_19;
  }
  uint64_t v6 = *(NSObject **)(a1 + 64);
  if (v6)
  {
    uint64_t v7 = malloc_type_calloc(1uLL, 0x10uLL, 0x10200403A5D3213uLL);
    if (v7)
    {
      uint64_t v8 = v7;
      *uint64_t v7 = CFRetain(v3);
      v8[2] = a2;
      if (a3) {
        dispatch_async_f(v6, v8, (dispatch_function_t)byteStreamSynchronizeFunc);
      }
      else {
        dispatch_sync_f(v6, v8, (dispatch_function_t)byteStreamSynchronizeFunc);
      }
      return 0;
    }
    goto LABEL_19;
  }
  if (a3)
  {
LABEL_19:
    return FigSignalErrorAt();
  }
  uint64_t v9 = *(void **)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  if (*v10 < 2uLL) {
    return 4294954514;
  }
  uint64_t v12 = (uint64_t (*)(const void *, uint64_t))v10[5];
  if (!v12) {
    return 4294954514;
  }

  return v12(v3, a2);
}

uint64_t MovieSampleDataWriterWriteData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 && (a3 & 0x8000000000000000) == 0 && a4)
  {
    MEMORY[0x19970E910](*(void *)(a1 + 48));
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8)
    {
      uint64_t v15 = 0;
      uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v9) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = 0;
      }
      uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(v10 + 16);
      if (!v11)
      {
        uint64_t v13 = 4294954514;
        goto LABEL_13;
      }
      uint64_t v12 = v11(v8, a2, a3, a4, &v15);
      if (v12)
      {
LABEL_18:
        uint64_t v13 = v12;
        goto LABEL_13;
      }
      if (v15 == a2)
      {
        uint64_t v13 = 0;
LABEL_13:
        MEMORY[0x19970E930](*(void *)(a1 + 48));
        return v13;
      }
    }
    uint64_t v12 = FigSignalErrorAt();
    goto LABEL_18;
  }

  return FigSignalErrorAt();
}

uint64_t MovieSampleDataWriterWriteFreeAtom(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1)
  {
    MEMORY[0x19970E910](*(void *)(a1 + 48));
    if (*(void *)(a1 + 40)) {
      uint64_t v7 = writeFreeAtom(a1, a2, a3);
    }
    else {
      uint64_t v7 = FigSignalErrorAt();
    }
    uint64_t v8 = v7;
    MEMORY[0x19970E930](*(void *)(a1 + 48));
    return v8;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t writeFreeAtom(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 <= 7)
  {
    return FigSignalErrorAt();
  }
  else
  {
    uint64_t v15 = v3;
    uint64_t v16 = v4;
    v14[0] = bswap32(a3);
    v14[1] = 1701147238;
    uint64_t v13 = 0;
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _DWORD *, uint64_t *))(v10 + 16);
    if (v11)
    {
      uint64_t result = v11(v8, 8, a2, v14, &v13);
      if (!result)
      {
        if (v13 == 8) {
          return writeZeroData(a1, *(void *)(a1 + 40), a2 + 8, a3 - 8);
        }
        else {
          return FigSignalErrorAt();
        }
      }
    }
    else
    {
      return 4294954514;
    }
  }
  return result;
}

uint64_t MovieSampleDataWriterAppendFreeAtom(uint64_t a1, unint64_t a2)
{
  if (a1)
  {
    MEMORY[0x19970E910](*(void *)(a1 + 48));
    if (*(void *)(a1 + 40))
    {
      uint64_t appended = appendFileTypeAtomIfNeeded(a1);
      if (!appended)
      {
        uint64_t v12 = 0;
        uint64_t v6 = *(void *)(a1 + 40);
        uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v7) {
          uint64_t v8 = v7;
        }
        else {
          uint64_t v8 = 0;
        }
        uint64_t v9 = *(uint64_t (**)(uint64_t, void, uint64_t *))(v8 + 24);
        if (!v9)
        {
          uint64_t v10 = 4294954514;
          goto LABEL_12;
        }
        uint64_t appended = v9(v6, 0, &v12);
        if (!appended) {
          uint64_t appended = writeFreeAtom(a1, v12, a2);
        }
      }
    }
    else
    {
      uint64_t appended = FigSignalErrorAt();
    }
    uint64_t v10 = appended;
LABEL_12:
    MEMORY[0x19970E930](*(void *)(a1 + 48));
    return v10;
  }
  return FigSignalErrorAt();
}

uint64_t appendFileTypeAtomIfNeeded(uint64_t a1)
{
  CMBlockBufferRef theBuffer = 0;
  uint64_t appended = createFileTypeAtomIfNeeded(a1, &theBuffer);
  CMBlockBufferRef v3 = theBuffer;
  if (!appended && theBuffer)
  {
    uint64_t appended = byteStreamAppendBlockBuffer(*(void *)(a1 + 40), theBuffer);
LABEL_5:
    CFRelease(v3);
    return appended;
  }
  if (theBuffer) {
    goto LABEL_5;
  }
  return appended;
}

uint64_t MovieSampleDataWriterAppendBlockBuffer(uint64_t *a1, OpaqueCMBlockBuffer *a2, void *a3)
{
  if (a1 && a2)
  {
    MEMORY[0x19970E910](a1[6]);
    if (a1[5])
    {
      appendFileTypeAtomAndMediaDataAtomHeaderAndPaddingIfNeeded((uint64_t)a1, 0);
      uint64_t v15 = 0;
      uint64_t v6 = a1[5];
      uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v7) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v9 = *(uint64_t (**)(uint64_t, void, uint64_t *))(v8 + 24);
      if (!v9)
      {
        uint64_t v13 = 4294954514;
LABEL_15:
        MEMORY[0x19970E930](a1[6]);
        return v13;
      }
      uint64_t appended = v9(v6, 0, &v15);
      if (appended
        || (Dataunint64_t Length = CMBlockBufferGetDataLength(a2), appended = CMByteStreamAppendBlockBuffer(), appended))
      {
LABEL_20:
        uint64_t v13 = appended;
        goto LABEL_15;
      }
      if (!DataLength)
      {
        uint64_t v12 = checkIfMediaDataAtomSizeExceededPredeterminedSizeIfNeeded(a1);
        uint64_t v13 = v12;
        if (a3)
        {
          if (!v12) {
            *a3 = v15;
          }
        }
        goto LABEL_15;
      }
    }
    uint64_t appended = FigSignalErrorAt();
    goto LABEL_20;
  }

  return FigSignalErrorAt();
}

uint64_t appendFileTypeAtomAndMediaDataAtomHeaderAndPaddingIfNeeded(uint64_t a1, CMBlockBufferRef a2)
{
  targetuint64_t BBuf = 0;
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v4 = CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u, 0, &blockBufferOut);
  if (v4)
  {
    uint64_t v21 = v4;
    goto LABEL_41;
  }
  uint64_t appended = createFileTypeAtomIfNeeded(a1, &targetBBuf);
  if (appended) {
    goto LABEL_31;
  }
  uint64_t v6 = targetBBuf;
  if (targetBBuf)
  {
    uint64_t appended = CMBlockBufferAppendBufferReference(blockBufferOut, targetBBuf, 0, 0, 0);
    if (appended) {
      goto LABEL_31;
    }
    Dataunint64_t Length = CMBlockBufferGetDataLength(v6);
  }
  else
  {
    Dataunint64_t Length = 0;
  }
  CMBlockBufferRef v27 = 0;
  if (*(unsigned char *)(a1 + 105) != 1 || *(_DWORD *)(a1 + 108))
  {
    uint64_t v10 = 0;
    goto LABEL_33;
  }
  uint64_t appended = MovieHeaderMakerCopyMediaDataAtomHeaderAsBlockBuffer(*(CFAllocatorRef *)(a1 + 16), *(unsigned __int8 *)(a1 + 104), *(void *)(a1 + 136), &v27);
  if (!appended)
  {
    BOOL v8 = *(unsigned char *)(a1 + 104) != 0;
    if (*(void *)(a1 + 136)) {
      int v9 = 2;
    }
    else {
      int v9 = 1;
    }
    *(_DWORD *)(a1 + 108) = v9;
    uint64_t v10 = v27;
    if (v27)
    {
      uint64_t v24 = 0;
      uint64_t v11 = *(void *)(a1 + 40);
      uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v12) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = 0;
      }
      uint64_t v14 = *(uint64_t (**)(uint64_t, void, uint64_t *))(v13 + 24);
      if (!v14)
      {
        uint64_t v21 = 4294954514;
        goto LABEL_37;
      }
      uint64_t PreferredChunkAlignment = v14(v11, 0, &v24);
      if (PreferredChunkAlignment) {
        goto LABEL_45;
      }
      size_t v16 = 8 * v8 + DataLength + v24;
      *(void *)(a1 + 112) = v16;
      if (!*(unsigned char *)(a1 + 120))
      {
        *(void *)(a1 + 128) = v16;
        *(unsigned char *)(a1 + 120) = 1;
      }
      uint64_t PreferredChunkAlignment = CMBlockBufferAppendBufferReference(blockBufferOut, v10, 0, 0, 0);
      if (PreferredChunkAlignment) {
        goto LABEL_45;
      }
      if (!a2) {
        goto LABEL_34;
      }
      size_t v17 = CMBlockBufferGetDataLength(v10);
      uint64_t v18 = v24;
      signed int v23 = 0;
      uint64_t PreferredChunkAlignment = MovieSampleDataWriterTrackGetPreferredChunkAlignment(a1, (uint64_t)a2, &v23);
      if (PreferredChunkAlignment)
      {
LABEL_45:
        uint64_t v21 = PreferredChunkAlignment;
LABEL_37:
        if (v10) {
          CFRelease(v10);
        }
        goto LABEL_39;
      }
      CMBlockBufferRef v27 = 0;
      if (v23 >= 2)
      {
        uint64_t v19 = (uint64_t)(v17 + DataLength + v18) % v23;
        if (v19)
        {
          uint64_t PreferredChunkAlignment = createPadding(a1, v23 - v19, &v27);
          if (!PreferredChunkAlignment)
          {
            a2 = v27;
            if (v27)
            {
              uint64_t v20 = CMBlockBufferAppendBufferReference(blockBufferOut, v27, 0, 0, 0);
              if (v20)
              {
LABEL_35:
                uint64_t v21 = v20;
                if (a2) {
                  CFRelease(a2);
                }
                goto LABEL_37;
              }
            }
LABEL_34:
            uint64_t v20 = byteStreamAppendBlockBuffer(*(void *)(a1 + 40), blockBufferOut);
            goto LABEL_35;
          }
          goto LABEL_45;
        }
      }
    }
LABEL_33:
    a2 = 0;
    goto LABEL_34;
  }
LABEL_31:
  uint64_t v21 = appended;
LABEL_39:
  if (targetBBuf) {
    CFRelease(targetBBuf);
  }
LABEL_41:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v21;
}

uint64_t checkIfMediaDataAtomSizeExceededPredeterminedSizeIfNeeded(uint64_t *a1)
{
  if (a1[17])
  {
    uint64_t v3 = 0;
    uint64_t result = MediaDataChunkWriterGetEntireLength(a1[4], a1[5], &v3);
    if (result) {
      return result;
    }
    if (v3 - a1[14] > a1[17]) {
      return FigSignalErrorAt();
    }
  }
  return 0;
}

uint64_t MovieSampleDataWriterAppendHeader(uint64_t a1, OpaqueCMBlockBuffer *a2, void *a3)
{
  if (a1 && a2)
  {
    MEMORY[0x19970E910](*(void *)(a1 + 48));
    if (!*(void *)(a1 + 40))
    {
LABEL_31:
      uint64_t appended = FigSignalErrorAt();
      goto LABEL_32;
    }
    uint64_t appended = appendFileTypeAtomIfNeeded(a1);
    if (appended) {
      goto LABEL_32;
    }
    uint64_t appended = MediaDataChunkWriterFlush(*(void *)(a1 + 32), *(void *)(a1 + 40));
    if (appended) {
      goto LABEL_32;
    }
    uint64_t appended = patchMediaDataAtomSizeIfNeeded(a1);
    if (appended) {
      goto LABEL_32;
    }
    if (*(void *)(a1 + 136))
    {
      uint64_t v22 = 0;
      uint64_t v7 = *(void *)(a1 + 40);
      uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v8) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = 0;
      }
      uint64_t v10 = *(uint64_t (**)(uint64_t, void, uint64_t *))(v9 + 24);
      if (!v10) {
        goto LABEL_26;
      }
      uint64_t appended = v10(v7, 0, &v22);
      if (appended)
      {
LABEL_32:
        uint64_t v14 = appended;
        goto LABEL_27;
      }
      uint64_t v11 = v22 - *(void *)(a1 + 112);
      uint64_t v12 = *(void *)(a1 + 136);
      if (v12 < v11) {
        uint64_t v13 = FigSignalErrorAt();
      }
      else {
        uint64_t v13 = writeZeroData(a1, *(void *)(a1 + 40), v22, v12 - v11);
      }
      uint64_t v14 = v13;
      if (v13) {
        goto LABEL_27;
      }
    }
    uint64_t v21 = 0;
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v16) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v18 = *(uint64_t (**)(uint64_t, void, uint64_t *))(v17 + 24);
    if (v18)
    {
      uint64_t appended = v18(v15, 0, &v21);
      if (appended) {
        goto LABEL_32;
      }
      Dataunint64_t Length = CMBlockBufferGetDataLength(a2);
      uint64_t appended = CMByteStreamAppendBlockBuffer();
      if (appended) {
        goto LABEL_32;
      }
      if (!DataLength)
      {
        uint64_t appended = (uint64_t)startNewChunkForAllTracks(a1);
        if (!appended)
        {
          *(_DWORD *)(a1 + 108) = 0;
          uint64_t v14 = 0;
          if (a3) {
            *a3 = v21;
          }
          goto LABEL_27;
        }
        goto LABEL_32;
      }
      goto LABEL_31;
    }
LABEL_26:
    uint64_t v14 = 4294954514;
LABEL_27:
    MEMORY[0x19970E930](*(void *)(a1 + 48));
    return v14;
  }

  return FigSignalErrorAt();
}

uint64_t MovieSampleDataWriterFlush(uint64_t *a1)
{
  if (a1)
  {
    MEMORY[0x19970E910](a1[6]);
    uint64_t v3 = a1[5];
    if (v3) {
      uint64_t v4 = MediaDataChunkWriterFlush(a1[4], v3);
    }
    else {
      uint64_t v4 = FigSignalErrorAt();
    }
    uint64_t v5 = v4;
    MEMORY[0x19970E930](a1[6]);
    return v5;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterTrackAppendSampleData(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t *a9, const __CFArray *a10, uint64_t a11)
{
  if (a1 && a2)
  {
    MEMORY[0x19970E910](a1[6]);
    if (a1[5])
    {
      uint64_t appended = appendFileTypeAtomAndMediaDataAtomHeaderAndPaddingIfNeeded((uint64_t)a1, (CMBlockBufferRef)a2);
      if (!appended)
      {
        uint64_t appended = MediaDataChunkWriterTrackAppendSampleData(a1[4], a2[1], a1[5], a3, a4, a5, a6, a7, a8, a9, a10, a11);
        if (!appended) {
          uint64_t appended = checkIfMediaDataAtomSizeExceededPredeterminedSizeIfNeeded(a1);
        }
      }
    }
    else
    {
      uint64_t appended = FigSignalErrorAt();
    }
    uint64_t v20 = appended;
    MEMORY[0x19970E930](a1[6]);
    return v20;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterTrackAppendSampleReference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t *a9, const __CFArray *a10, uint64_t a11)
{
  if (a1 && a2) {
    return MediaDataChunkWriterTrackAppendSampleReference(*(void *)(a1 + 32), *(void *)(a2 + 8), a3, a4, a5, a6, a7, a8, a9, a10, a11);
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterTrackSetPreferredChunkSize(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2) {
    return MediaDataChunkWriterTrackSetPreferredChunkSize(*(void *)(a1 + 32), *(void *)(a2 + 8), a3);
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterTrackGetPreferredChunkSize(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (a1 && a2 && a3) {
    return MediaDataChunkWriterTrackGetPreferredChunkSize(*(void *)(a1 + 32), *(void *)(a2 + 8), a3);
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterTrackSetPreferredChunkDuration(uint64_t a1, uint64_t a2, CMTime *a3)
{
  if (a1 && a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void *)(a2 + 8);
    CMTime v7 = *a3;
    return MediaDataChunkWriterTrackSetPreferredChunkDuration(v4, v5, &v7);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterTrackGetPreferredChunkDuration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && a3) {
    return MediaDataChunkWriterTrackGetPreferredChunkDuration(*(void *)(a1 + 32), *(void *)(a2 + 8), a3);
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterTrackSetPreferredChunkAlignment(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2) {
    return MediaDataChunkWriterTrackSetPreferredChunkAlignment(*(void *)(a1 + 32), *(void *)(a2 + 8), a3);
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterTrackGetPreferredChunkAlignment(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (a1 && a2 && a3) {
    return MediaDataChunkWriterTrackGetPreferredChunkAlignment(*(void *)(a1 + 32), *(void *)(a2 + 8), a3);
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterCopyFileTypeAtomAsBlockBuffer(const __CFNumber **a1, const __CFAllocator *a2, CMBlockBufferRef *a3)
{
  if (a1 && a3) {
    return MovieHeaderMakerCopyFileTypeAtomAsBlockBuffer(a2, a1[10], a1[11], a1[12], a3);
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterSetMajorBrand(uint64_t a1, CFTypeRef cf)
{
  if (a1 && cf && (CFTypeID v4 = CFGetTypeID(cf), v4 == CFNumberGetTypeID()))
  {
    uint64_t v5 = *(const void **)(a1 + 80);
    *(void *)(a1 + 80) = cf;
    CFRetain(cf);
    if (v5) {
      CFRelease(v5);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterCopyMajorBrand(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    CFTypeRef v3 = *(CFTypeRef *)(a1 + 80);
    if (v3) {
      CFTypeRef v3 = CFRetain(v3);
    }
    *a2 = v3;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterSetMinorVersion(uint64_t a1, CFTypeRef cf)
{
  if (a1 && cf && (CFTypeID v4 = CFGetTypeID(cf), v4 == CFNumberGetTypeID()))
  {
    uint64_t v5 = *(const void **)(a1 + 88);
    *(void *)(a1 + 88) = cf;
    CFRetain(cf);
    if (v5) {
      CFRelease(v5);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterCopyMinorVersion(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    CFTypeRef v3 = *(CFTypeRef *)(a1 + 88);
    if (v3) {
      CFTypeRef v3 = CFRetain(v3);
    }
    *a2 = v3;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterSetCompatibleBrands(uint64_t a1, CFTypeRef cf)
{
  if (a1 && cf && (CFTypeID v4 = CFGetTypeID(cf), v4 == CFArrayGetTypeID()))
  {
    uint64_t v5 = *(const void **)(a1 + 96);
    *(void *)(a1 + 96) = cf;
    CFRetain(cf);
    if (v5) {
      CFRelease(v5);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t MovieSampleDataWriterCopyCompatibleBrands(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    CFTypeRef v3 = *(CFTypeRef *)(a1 + 96);
    if (v3) {
      CFTypeRef v3 = CFRetain(v3);
    }
    *a2 = v3;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t movieSampleDataWriterRegisterType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sMovieSampleDataWriterID = result;
  return result;
}

double movieSampleDataWriter_Init(uint64_t a1)
{
  *(void *)(a1 + 144) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void movieSampleDataWriter_Finalize(uint64_t a1)
{
  CFAllocatorRef v2 = *(const __CFAllocator **)(a1 + 16);
  CFArrayRef v3 = *(const __CFArray **)(a1 + 56);
  if (v3)
  {
    CFIndex Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0; i != v5; ++i)
      {
        CFNumberRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), i);
        if (ValueAtIndex) {
          CFAllocatorDeallocate(v2, ValueAtIndex);
        }
      }
    }
    uint64_t v8 = *(const void **)(a1 + 56);
    if (v8) {
      CFRelease(v8);
    }
  }
  uint64_t v9 = *(const void **)(a1 + 80);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = *(const void **)(a1 + 88);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = *(const void **)(a1 + 96);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = *(const void **)(a1 + 144);
  if (v12) {
    CFRelease(v12);
  }
  uint64_t v13 = *(const void **)(a1 + 24);
  if (v13) {
    CFRelease(v13);
  }
  uint64_t v14 = *(const void **)(a1 + 40);
  if (v14) {
    CFRelease(v14);
  }
  FigSimpleMutexDestroy();
  MediaDataChunkWriterRelease(*(const __CFAllocator ***)(a1 + 32));
  uint64_t v15 = *(NSObject **)(a1 + 64);
  if (v15) {
    dispatch_release(v15);
  }
  if (v2)
  {
    CFRelease(v2);
  }
}

__CFString *movieSampleDataWriter_CopyDebugDescription(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<MovieSampleDataWriter %p>{fileType:%@}", a1, *(void *)(a1 + 24));
  return Mutable;
}

void byteStreamSynchronizeFunc(const void **a1)
{
  CFAllocatorRef v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  CFTypeID v4 = *(void **)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    CFIndex v5 = v4;
  }
  else {
    CFIndex v5 = 0;
  }
  if (*v5 >= 2uLL)
  {
    uint64_t v6 = (void (*)(const void *, uint64_t))v5[5];
    if (v6) {
      v6(v2, v3);
    }
  }
  if (v2) {
    CFRelease(v2);
  }

  free(a1);
}

uint64_t writeZeroData(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4)
{
  CMBlockBufferRef v8 = 0;
  if (!a4) {
    return 0;
  }
  uint64_t v4 = createPadding(a1, a4, &v8);
  CMBlockBufferRef v5 = v8;
  if (!v4)
  {
    uint64_t v4 = CMByteStreamWriteBlockBuffer();
    if (!v4) {
      uint64_t v4 = FigSignalErrorAt();
    }
  }
  uint64_t v7 = v4;
  if (v5) {
    CFRelease(v5);
  }
  return v7;
}

uint64_t createPadding(uint64_t a1, size_t a2, CMBlockBufferRef *a3)
{
  Dataunint64_t Length = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(a1 + 144));
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t appended = CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, &blockBufferOut);
  if (appended)
  {
LABEL_7:
    uint64_t v9 = appended;
    if (blockBufferOut) {
      CFRelease(blockBufferOut);
    }
  }
  else
  {
    while (a2)
    {
      if (a2 >= DataLength) {
        size_t v8 = DataLength;
      }
      else {
        size_t v8 = a2;
      }
      uint64_t appended = CMBlockBufferAppendBufferReference(blockBufferOut, *(CMBlockBufferRef *)(a1 + 144), 0, v8, 0);
      a2 -= v8;
      if (appended) {
        goto LABEL_7;
      }
    }
    uint64_t v9 = 0;
    *a3 = blockBufferOut;
  }
  return v9;
}

uint64_t createFileTypeAtomIfNeeded(uint64_t a1, CMBlockBufferRef *a2)
{
  CMBlockBufferRef v6 = 0;
  if (*(unsigned char *)(a1 + 72) != 1 || *(unsigned char *)(a1 + 73))
  {
    CMBlockBufferRef v5 = 0;
  }
  else
  {
    uint64_t result = MovieHeaderMakerCopyFileTypeAtomAsBlockBuffer(*(const __CFAllocator **)(a1 + 16), *(const __CFNumber **)(a1 + 80), *(const __CFNumber **)(a1 + 88), *(CFArrayRef *)(a1 + 96), &v6);
    if (result) {
      return result;
    }
    *(unsigned char *)(a1 + 73) = 1;
    CMBlockBufferRef v5 = v6;
  }
  uint64_t result = 0;
  *a2 = v5;
  return result;
}

uint64_t byteStreamAppendBlockBuffer(int a1, CMBlockBufferRef theBuffer)
{
  uint64_t result = CMBlockBufferGetDataLength(theBuffer);
  if (result)
  {
    uint64_t result = CMByteStreamAppendBlockBuffer();
    if (!result) {
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t FigCLCPCaptionFormatConformerCreate(uint64_t a1, const void *a2, void *a3)
{
  if (a3)
  {
    FigCaptionFormatConformerGetClassID();
    uint64_t v5 = CMDerivedObjectCreate();
    if (v5)
    {
      uint64_t v8 = v5;
      FigSignalErrorAt();
    }
    else
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
      if (a2) {
        CFTypeRef v7 = CFRetain(a2);
      }
      else {
        CFTypeRef v7 = 0;
      }
      uint64_t v8 = 0;
      *uint64_t DerivedStorage = v7;
      *a3 = 0;
    }
    return v8;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void clcpcfc_Finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = *(const void **)(DerivedStorage + 8);
  if (v1) {
    CFRelease(v1);
  }
  CFAllocatorRef v2 = *(const void **)(DerivedStorage + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    CFRelease(v3);
  }
}

__CFString *clcpcfc_CopyDebugDescription(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigCLCPCaptionFormatConformer %p>", a1);
  return Mutable;
}

uint64_t clcpcfc_CopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 && a4) {
    return 4294954512;
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t clcpcfc_SetProperty(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 4294954512;
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t clcpcfc_CreateConformedCaptionData(uint64_t a1, void *a2, long long *a3, CFTypeRef *a4, _OWORD *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2
    && (*((unsigned char *)a3 + 12) & 1) != 0
    && (*((unsigned char *)a3 + 36) & 1) != 0
    && !*((void *)a3 + 5)
    && (*((void *)a3 + 3) & 0x8000000000000000) == 0
    && a4
    && a5)
  {
    uint64_t v11 = DerivedStorage;
    uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v12) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = *(uint64_t (**)(void *))(v13 + 8);
    if (v14)
    {
      CFStringRef v15 = (const __CFString *)v14(a2);
      if (!v15) {
        goto LABEL_25;
      }
    }
    else
    {
      CFStringRef v15 = &stru_1EE53F4B8;
    }
    if (!CFStringGetLength(v15))
    {
LABEL_25:
      uint64_t v24 = 0;
      *a4 = CFRetain(a2);
      long long v26 = a3[1];
      long long v25 = a3[2];
      *a5 = *a3;
      a5[1] = v26;
      a5[2] = v25;
      return v24;
    }
    long long v42 = *a3;
    long long v43 = a3[1];
    long long v44 = a3[2];
    values = a2;
    uint64_t v16 = *(const void **)v11;
    *(void *)&long long v47 = clcpcfcFromSbufOutputCallback;
    *((void *)&v47 + 1) = v11;
    *(void *)&long long v46 = clcpcfcToSbufOutputCallback;
    *((void *)&v46 + 1) = v11;
    CFTypeRef v45 = 0;
    uint64_t v17 = (CFTypeRef *)(v11 + 8);
    uint64_t v18 = FigCLCPCaptionGroupConverterFromSampleBufferCreate(&v47, v16, (void *)(v11 + 8));
    if (v18 || (uint64_t v18 = FigCLCPCaptionGroupConverterToSampleBufferCreate(&v46, v16, &v45), v18))
    {
      uint64_t v24 = v18;
      CFArrayRef v19 = 0;
      goto LABEL_43;
    }
    CFArrayRef v19 = CFArrayCreate((CFAllocatorRef)v16, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    if (!v19)
    {
      uint64_t v20 = FigSignalErrorAt();
      goto LABEL_55;
    }
    uint64_t v20 = FigCaptionGroupCreate();
    if (!v20)
    {
      CFTypeRef v21 = v45;
      uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v22) {
        uint64_t v23 = v22;
      }
      else {
        uint64_t v23 = 0;
      }
      CMBlockBufferRef v27 = *(uint64_t (**)(CFTypeRef, void, _OWORD *))(v23 + 8);
      if (!v27) {
        goto LABEL_42;
      }
      v49[0] = v42;
      v49[1] = v43;
      v49[2] = v44;
      uint64_t v20 = v27(v21, 0, v49);
      if (v20) {
        goto LABEL_55;
      }
      CFTypeRef v28 = v45;
      uint64_t v29 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v30 = v29 ? v29 : 0;
      size_t v31 = *(uint64_t (**)(CFTypeRef))(v30 + 16);
      if (!v31)
      {
LABEL_42:
        uint64_t v24 = 4294954514;
LABEL_43:
        if (v19) {
          CFRelease(v19);
        }
        if (v45) {
          CFRelease(v45);
        }
        size_t v39 = *(const void **)(v11 + 16);
        if (v39)
        {
          CFRelease(v39);
          *(void *)(v11 + 16) = 0;
        }
        if (*v17)
        {
          CFRelease(*v17);
          CFTypeRef *v17 = 0;
        }
        uint64_t v40 = MEMORY[0x1E4F1FA20];
        long long v41 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
        *(_OWORD *)(v11 + 24) = *MEMORY[0x1E4F1FA20];
        *(_OWORD *)(v11 + 40) = v41;
        *(_OWORD *)(v11 + 56) = *(_OWORD *)(v40 + 32);
        return v24;
      }
      uint64_t v20 = v31(v28);
      if (!v20)
      {
        CFTypeRef v32 = *v17;
        uint64_t v33 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v33) {
          uint64_t v34 = v33;
        }
        else {
          uint64_t v34 = 0;
        }
        size_t v35 = *(uint64_t (**)(CFTypeRef))(v34 + 16);
        if (v35)
        {
          uint64_t v20 = v35(v32);
          if (!v20)
          {
            CFTypeRef v36 = *(CFTypeRef *)(v11 + 16);
            if (v36) {
              CFTypeRef v36 = CFRetain(v36);
            }
            uint64_t v24 = 0;
            *a4 = v36;
            long long v37 = *(_OWORD *)(v11 + 24);
            long long v38 = *(_OWORD *)(v11 + 56);
            a5[1] = *(_OWORD *)(v11 + 40);
            a5[2] = v38;
            *a5 = v37;
            goto LABEL_43;
          }
          goto LABEL_55;
        }
        goto LABEL_42;
      }
    }
LABEL_55:
    uint64_t v24 = v20;
    goto LABEL_43;
  }

  return FigSignalErrorAt();
}

uint64_t clcpcfcFromSbufOutputCallback(uint64_t a1, long long *a2, uint64_t a3)
{
  SliceCFIndex Count = FigCaptionGroupGetSliceCount();
  if (SliceCount == 1)
  {
    if (!*(void *)(a3 + 16))
    {
      CaptionData = (const void *)FigCaptionGroupGetCaptionData();
      if (CaptionData) {
        CaptionData = CFRetain(CaptionData);
      }
      *(void *)(a3 + 16) = CaptionData;
      long long v7 = *a2;
      long long v8 = a2[1];
      *(_OWORD *)(a3 + 56) = a2[2];
      *(_OWORD *)(a3 + 40) = v8;
      *(_OWORD *)(a3 + 24) = v7;
      return 0;
    }
  }
  else if (!SliceCount)
  {
    return 0;
  }

  return FigSignalErrorAt();
}

uint64_t clcpcfcToSbufOutputCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  CMBlockBufferRef v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 8);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a1);
}

uint64_t FigManifoldCreateForICY(const __CFAllocator *a1, CMBlockBufferRef theBuffer, uint64_t a3, uint64_t a4, uint64_t a5, void **a6)
{
  values = @"IcyManifoldMemoryPool";
  CMBlockBufferRef theBuffera = 0;
  if (!theBuffer || !CMBlockBufferGetDataLength(theBuffer))
  {
    return FigSignalErrorAt();
  }
  inClientData = 0;
  FigManifoldGetClassID();
  uint64_t v12 = CMDerivedObjectCreate();
  if (v12)
  {
LABEL_51:
    uint64_t v37 = v12;
    CFDictionaryRef v21 = 0;
    goto LABEL_39;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFAllocatorRef Default = a1;
  if (!a1) {
    CFAllocatorRef Default = CFAllocatorGetDefault();
  }
  *(void *)uint64_t DerivedStorage = CFRetain(Default);
  uint64_t v15 = FigReentrantMutexCreate();
  *(void *)(DerivedStorage + 8) = v15;
  if (!v15)
  {
    CFDictionaryRef v21 = 0;
    uint64_t v37 = 12;
    goto LABEL_38;
  }
  *(void *)(DerivedStorage + 464) = 0;
  *(void *)(DerivedStorage + 472) = DerivedStorage + 464;
  uint64_t v16 = MEMORY[0x1E4F1F9F8];
  long long v17 = *MEMORY[0x1E4F1F9F8];
  *(_OWORD *)(DerivedStorage + 280) = *MEMORY[0x1E4F1F9F8];
  uint64_t v18 = *(void *)(v16 + 16);
  *(void *)(DerivedStorage + 296) = v18;
  *(_OWORD *)(DerivedStorage + 480) = v17;
  *(void *)(DerivedStorage + 496) = v18;
  *(_OWORD *)(DerivedStorage + 576) = v17;
  *(void *)(DerivedStorage + 592) = v18;
  *(_OWORD *)(DerivedStorage + 600) = v17;
  *(void *)(DerivedStorage + 616) = v18;
  *(void *)(DerivedStorage + 528) = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  *(void *)(DerivedStorage + 560) = Mutable;
  if (!Mutable)
  {
    uint64_t v12 = FigSignalErrorAt();
    goto LABEL_51;
  }
  CFDictionaryRef v20 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], MEMORY[0x1E4F21788], (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryRef v21 = v20;
  if (!v20 || (CMMemoryPoolRef v22 = CMMemoryPoolCreate(v20), (*(void *)(DerivedStorage + 16) = v22) == 0))
  {
    uint64_t v37 = FigSignalErrorAt();
    goto LABEL_39;
  }
  if (CMBlockBufferIsRangeContiguous(theBuffer, 0, 0))
  {
    CMBlockBufferRef theBuffera = (CMBlockBufferRef)CFRetain(theBuffer);
  }
  else
  {
    uint64_t ContiguousBlockBuffer = FigMemoryPoolCreateContiguousBlockBuffer();
    if (ContiguousBlockBuffer) {
      return ContiguousBlockBuffer;
    }
  }
  uint64_t v40 = a3;
  uint64_t v41 = a4;
  uint64_t v42 = a5;
  CFDictionaryRef cf = v21;
  size_t v39 = a6;
  unint64_t v24 = 0;
  uint64_t v44 = 0;
  AudioFileTypeID v45 = 0;
  int v25 = 0;
  long long v26 = (_OWORD *)(DerivedStorage + 232);
  CMBlockBufferRef v27 = (void *)(DerivedStorage + 128);
  do
  {
    while (1)
    {
      *(unsigned char *)(DerivedStorage + 35) = 0;
      fim_DestroyAudioTrack(DerivedStorage + 72);
      *(void *)(DerivedStorage + 264) = 0;
      *long long v26 = 0u;
      *(_OWORD *)(DerivedStorage + 248) = 0u;
      *CMBlockBufferRef v27 = 0;
      *(void *)(DerivedStorage + 136) = 0;
      fim_DestroyMetaTrack((void *)(DerivedStorage + 392));
      *(void *)(DerivedStorage + 552) = 0;
      AudioFileTypeID v28 = possibleAudioTypes[v24];
      *(_DWORD *)(DerivedStorage + 144) = v28;
      uint64_t v29 = AudioFileStreamOpen(inClientData, (AudioFileStream_PropertyListenerProc)AudioFileStreamStartupPropertyListener, (AudioFileStream_PacketsProc)AudioFileStreamStartupPackets, v28, (AudioFileStreamID *)(DerivedStorage + 152));
      if (v29)
      {
        uint64_t v37 = v29;
        goto LABEL_37;
      }
      fim_ConfigureAudioFileStreamForID3(DerivedStorage);
      *(unsigned char *)(DerivedStorage + 33) = 1;
      FigIcyManifoldInjectData(inClientData, v30, v31, theBuffera);
      *(unsigned char *)(DerivedStorage + 33) = 0;
      if (!*(unsigned char *)(DerivedStorage + 35) || (uint64_t v32 = *(void *)(DerivedStorage + 136), v32 < 2))
      {
LABEL_23:
        if (v25) {
          goto LABEL_26;
        }
        goto LABEL_24;
      }
      AudioFileTypeID v33 = *(_DWORD *)(DerivedStorage + 144);
      if (v32 <= v44) {
        break;
      }
      if (v33 == v28)
      {
        int v25 = 1;
        uint64_t v44 = *(void *)(DerivedStorage + 136);
        AudioFileTypeID v45 = *(_DWORD *)(DerivedStorage + 144);
        BOOL v36 = v24++ >= 2;
        if (!v36) {
          continue;
        }
      }
      goto LABEL_34;
    }
    if (v32 != v44 || v33 == v45) {
      goto LABEL_23;
    }
LABEL_24:
    size_t v35 = *(void *)(DerivedStorage + 552);
    if (v35 > CMBlockBufferGetDataLength(theBuffera))
    {
      uint64_t v37 = 4294951248;
      goto LABEL_37;
    }
    int v25 = 0;
LABEL_26:
    BOOL v36 = v24++ >= 2;
  }
  while (!v36);
  AudioFileTypeID v33 = v45;
  if (!v25)
  {
    uint64_t v37 = 4294951252;
    goto LABEL_37;
  }
LABEL_34:
  *(void *)(DerivedStorage + 48) = v40;
  *(void *)(DerivedStorage + 56) = v41;
  *(void *)(DerivedStorage + 64) = v42;
  *(unsigned char *)(DerivedStorage + 35) = 0;
  fim_DestroyAudioTrack(DerivedStorage + 72);
  *(void *)(DerivedStorage + 264) = 0;
  *long long v26 = 0u;
  *(_OWORD *)(DerivedStorage + 248) = 0u;
  *CMBlockBufferRef v27 = 0;
  *(void *)(DerivedStorage + 136) = 0;
  fim_DestroyMetaTrack((void *)(DerivedStorage + 392));
  *(void *)(DerivedStorage + 552) = 0;
  uint64_t v37 = AudioFileStreamOpen(inClientData, (AudioFileStream_PropertyListenerProc)AudioFileStreamPropertyListener, (AudioFileStream_PacketsProc)AudioFileStreamPackets, v33, (AudioFileStreamID *)(DerivedStorage + 152));
  if (!v37)
  {
    fim_ConfigureAudioFileStreamForID3(DerivedStorage);
    const void *v39 = inClientData;
    CFDictionaryRef v21 = cf;
    goto LABEL_39;
  }
LABEL_37:
  CFDictionaryRef v21 = cf;
LABEL_38:
  CFRelease(inClientData);
LABEL_39:
  if (theBuffera) {
    CFRelease(theBuffera);
  }
  if (v21) {
    CFRelease(v21);
  }
  return v37;
}

uint64_t AudioFileStreamStartupPropertyListener(uint64_t a1, OpaqueAudioFileStreamID *a2, int a3, unsigned int *a4)
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = result;
  unsigned int outPropertyData = 0;
  switch(a3)
  {
    case 1684434292:
      UInt32 ioPropertyDataSize = 40;
      long long v8 = (double *)(result + 232);
      uint64_t result = AudioFileStreamGetProperty(*(AudioFileStreamID *)(result + 152), 0x64666D74u, &ioPropertyDataSize, (void *)(result + 232));
      if (!result && *v8 != 0.0 && *(_DWORD *)(v7 + 240)) {
        *(unsigned char *)(v7 + 35) = 1;
      }
      break;
    case 1768174437:
      UInt32 ioPropertyDataSize = 4;
      uint64_t result = AudioFileStreamGetProperty(*(AudioFileStreamID *)(result + 152), 0x69643365u, &ioPropertyDataSize, &outPropertyData);
      if (!result) {
        return ProcessID3HeaderTagFromAudioFileStream(a1, outPropertyData);
      }
      break;
    case 1717988724:
      UInt32 ioPropertyDataSize = 4;
      return AudioFileStreamGetProperty(*(AudioFileStreamID *)(result + 152), 0x66666D74u, &ioPropertyDataSize, (void *)(result + 144));
  }
  return result;
}

uint64_t AudioFileStreamStartupPackets(void *a1, unsigned int a2, unsigned int a3, const void *a4, AudioStreamPacketDescription *a5)
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  *(void *)(result + 136) += a3;
  return result;
}

uint64_t fim_ConfigureAudioFileStreamForID3(uint64_t a1)
{
  v3[1] = *MEMORY[0x1E4F143B8];
  LODWORD(v3[0]) = 1768174437;
  AudioFileStreamSetProperty(*(AudioFileStreamID *)(a1 + 152), 0x6F707470u, 4u, v3);
  v3[0] = 0x5052495669643365;
  return AudioFileStreamSetProperty(*(AudioFileStreamID *)(a1 + 152), 0x6F707470u, 8u, v3);
}

uint64_t FigIcyManifoldInjectData(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a4)
  {
    uint64_t v7 = DerivedStorage;
    CFRetain(a1);
    CFRetain(a4);
    MEMORY[0x19970E290](*(void *)(v7 + 8));
    ++*(void *)(v7 + 24);
    if (*(unsigned char *)(v7 + 32) || *(unsigned char *)(v7 + 36))
    {
      LODWORD(v9) = FigSignalErrorAt();
      goto LABEL_64;
    }
    *(_WORD *)(v7 + 36) = 1;
    *(_DWORD *)(v7 + 44) = 0;
    *(unsigned char *)(v7 + 39) = 1;
    CFTypeRef v8 = CMGetAttachment(a4, @"FBPAKey_TimedData", 0);
    if (v8)
    {
      if (CFEqual(v8, @"FBPA_TimedData_ICY"))
      {
        uint64_t v9 = fim_PushMetaData((uint64_t)a1, a4, 0x69637920u);
        if (!v9) {
          goto LABEL_63;
        }
LABEL_62:
        fim_EndAllTracks(a1, v9);
        goto LABEL_63;
      }
    }
    else
    {
      CFDictionaryRef cf = 0;
      CFTypeRef v10 = CMGetAttachment(a4, @"FMFD_BufferAudioDecryptor", 0);
      if (!v10) {
        CFTypeRef v10 = CMGetAttachment(a4, @"FMFD_BufferDecryptor", 0);
      }
      if (!FigCFEqual())
      {
        uint64_t v11 = *(const void **)(v7 + 568);
        if (!v11) {
          *(unsigned char *)(v7 + 272) = 1;
        }
        *(void *)(v7 + 568) = v10;
        if (v10) {
          CFRetain(v10);
        }
        if (v11) {
          CFRelease(v11);
        }
        *(unsigned char *)(v7 + 275) = 1;
      }
      if (CMBlockBufferGetDataLength((CMBlockBufferRef)a4))
      {
        BOOL v36 = a4;
        if (CMBlockBufferIsRangeContiguous((CMBlockBufferRef)a4, 0, 0))
        {
          uint64_t v12 = (OpaqueCMBlockBuffer *)CFRetain(a4);
          CFDictionaryRef cf = v12;
        }
        else
        {
          int ContiguousBlockBuffer = FigMemoryPoolCreateContiguousBlockBuffer();
          if (ContiguousBlockBuffer)
          {
            LODWORD(v9) = ContiguousBlockBuffer;
            goto LABEL_63;
          }
          uint64_t v12 = 0;
        }
        dataPointerOut = 0;
        size_t lengthAtOffsetOut = 0;
        uint64_t v14 = CMBaseObjectGetDerivedStorage();
        Dataunint64_t Length = CMBlockBufferGetDataLength(v12);
        if (DataLength)
        {
          size_t v16 = DataLength;
          size_t v17 = 0;
          uint64_t v18 = (void *)(v14 + 504);
          while (1)
          {
            CFArrayRef v19 = *(OpaqueCMBlockBuffer **)(v14 + 520);
            if (v19)
            {
              if (v16 >= *(void *)(v14 + 536)) {
                size_t v20 = *(void *)(v14 + 536);
              }
              else {
                size_t v20 = v16;
              }
              uint64_t appended = CMBlockBufferAppendBufferReference(v19, v12, v17, v20, 0);
              if (appended)
              {
LABEL_68:
                uint64_t v9 = appended;
                goto LABEL_71;
              }
              size_t v22 = *(void *)(v14 + 536) - v20;
              *(void *)(v14 + 536) = v22;
              if (!v22)
              {
                fim_PushMetaData((uint64_t)a1, *(void **)(v14 + 520), 0x69643320u);
                uint64_t v23 = *(const void **)(v14 + 520);
                if (v23) {
                  CFRelease(v23);
                }
                *(void *)(v14 + 520) = 0;
                *(void *)(v14 + 544) = 0;
              }
            }
            uint64_t appended = CMBlockBufferGetDataPointer(v12, v17, &lengthAtOffsetOut, 0, &dataPointerOut);
            if (appended) {
              goto LABEL_68;
            }
            unint64_t v24 = dataPointerOut;
            if (v16 >= lengthAtOffsetOut) {
              size_t v25 = lengthAtOffsetOut;
            }
            else {
              size_t v25 = v16;
            }
            *(void *)(v14 + 320) = dataPointerOut;
            *(void *)(v14 + 328) = v25;
            *(void *)(v14 + 336) = v12;
            *(void *)(v14 + 344) = v17;
            uint64_t v26 = *(void *)(v14 + 528);
            if (v26)
            {
              if (v26 + v25 < 0xA)
              {
                *(void *)(v14 + 528) = v26 + v25;
              }
              else
              {
                unsigned int v27 = -*(_DWORD *)(v14 + 528);
                *(void *)(v14 + 528) = 0;
                ProcessID3HeaderTagFromAudioFileStream((uint64_t)a1, v27);
                unint64_t v24 = dataPointerOut;
              }
            }
            uint64_t v9 = AudioFileStreamParseBytes(*(AudioFileStreamID *)(v14 + 152), v25, v24, *(unsigned char *)(v14 + 34) != 0);
            if (v25 > 9)
            {
              __int16 v28 = *(_WORD *)&dataPointerOut[v25 - 2];
              *uint64_t v18 = *(void *)&dataPointerOut[v25 - 10];
              *(_WORD *)(v14 + 512) = v28;
            }
            else
            {
              memmove((void *)(v14 + 504), (char *)v18 + v25, 10 - v25);
              memmove((char *)v18 + 10 - v25, dataPointerOut, v25);
            }
            *(unsigned char *)(v14 + 34) = 0;
            if (!*(unsigned char *)(v14 + 33) && v9) {
              goto LABEL_71;
            }
            if (*(_DWORD *)(v14 + 44)) {
              break;
            }
            v17 += v25;
            v16 -= v25;
            if (!v16) {
              goto LABEL_52;
            }
          }
          uint64_t v9 = *(unsigned int *)(v14 + 44);
LABEL_71:
          a4 = v36;
        }
        else
        {
          uint64_t v9 = 0;
LABEL_52:
          uint64_t v29 = *(void **)(v14 + 464);
          a4 = v36;
          if (v29)
          {
            uint64_t v30 = (void **)(v14 + 464);
            while (1)
            {
              uint64_t v31 = fim_PushMetaData((uint64_t)a1, (void *)v29[1], *((_DWORD *)v29 + 4));
              if (v31) {
                break;
              }
              uint64_t v32 = (void *)**v30;
              *uint64_t v30 = v32;
              if (!v32) {
                *(void *)(v14 + 472) = v30;
              }
              AudioFileTypeID v33 = (const void *)v29[1];
              if (v33) {
                CFRelease(v33);
              }
              free(v29);
              uint64_t v29 = *v30;
              if (!*v30)
              {
                uint64_t v9 = 0;
                goto LABEL_61;
              }
            }
            uint64_t v9 = v31;
          }
        }
LABEL_61:
        CFRelease(cf);
        if (!v9) {
          goto LABEL_63;
        }
        goto LABEL_62;
      }
    }
    LODWORD(v9) = 0;
LABEL_63:
    *(unsigned char *)(v7 + 36) = 0;
LABEL_64:
    if (v9 == -16045) {
      uint64_t v34 = 0;
    }
    else {
      uint64_t v34 = v9;
    }
    --*(void *)(v7 + 24);
    MEMORY[0x19970E2B0](*(void *)(v7 + 8));
    CFRelease(a4);
    CFRelease(a1);
    return v34;
  }

  return FigSignalErrorAt();
}

void AudioFileStreamPropertyListener(void *a1, OpaqueAudioFileStreamID *a2, int a3, unsigned int *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = DerivedStorage;
  unsigned int outPropertyData = 0;
  if (a3 == 1768174437)
  {
    UInt32 ioPropertyDataSize = 4;
    uint64_t Property = AudioFileStreamGetProperty(*(AudioFileStreamID *)(DerivedStorage + 152), 0x69643365u, &ioPropertyDataSize, &outPropertyData);
    if (Property
      || (uint64_t Property = ProcessID3HeaderTagFromAudioFileStream((uint64_t)a1, outPropertyData), Property))
    {
LABEL_8:
      fim_EndAllTracks(a1, Property);
    }
  }
  else if (a3 == 1684434292)
  {
    UInt32 ioPropertyDataSize = 40;
    uint64_t Property = AudioFileStreamGetProperty(*(AudioFileStreamID *)(DerivedStorage + 152), 0x64666D74u, &ioPropertyDataSize, (void *)(DerivedStorage + 232));
    if (!Property)
    {
      *(unsigned char *)(v7 + 272) = 1;
      return;
    }
    goto LABEL_8;
  }
}

void AudioFileStreamPackets(void *a1, unsigned int a2, unsigned int a3, unsigned char *a4, AudioStreamPacketDescription *a5)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  Boolean outWritable = 0;
  int v11 = *(unsigned __int8 *)(DerivedStorage + 275);
  CFTypeRef v136 = 0;
  values = 0;
  keys[0] = 0;
  if (*(unsigned char *)(DerivedStorage + 32)
    || (uint64_t v12 = DerivedStorage, *(unsigned char *)(DerivedStorage + 37))
    || *(_DWORD *)(DerivedStorage + 44))
  {
    CFDictionaryRef v118 = 0;
    CFDictionaryRef cf = 0;
    goto LABEL_204;
  }
  CMTimeEpoch v130 = a4;
  *(void *)(DerivedStorage + 128) += a3;
  uint64_t v13 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  long long v121 = a5;
  dataunint64_t Length = a2;
  if (!*(unsigned char *)(DerivedStorage + 272))
  {
    uint64_t v20 = *(unsigned int *)(DerivedStorage + 72);
    if (v20)
    {
      if (*(void *)(DerivedStorage + 120))
      {
        CFDictionaryRef v118 = 0;
        CFDictionaryRef cf = 0;
        if (!v11) {
          goto LABEL_69;
        }
        goto LABEL_57;
      }
    }
  }
  ioPropertyDataSize[0] = 32;
  outPropertyDataSize[0] = 0;
  OSStatus Property = AudioFileStreamGetProperty(*(AudioFileStreamID *)(DerivedStorage + 152), 0x636D6170u, ioPropertyDataSize, (void *)(DerivedStorage + 160));
  uint64_t v15 = 0;
  if (!AudioFileStreamGetPropertyInfo(*(AudioFileStreamID *)(v12 + 152), 0x6D676963u, outPropertyDataSize, &outWritable))
  {
    if (outPropertyDataSize[0])
    {
      uint64_t v15 = malloc_type_malloc(outPropertyDataSize[0], 0x4885D39BuLL);
      if (v15)
      {
        if (AudioFileStreamGetProperty(*(AudioFileStreamID *)(v12 + 152), 0x6D676963u, outPropertyDataSize, v15))
        {
          outPropertyDataSize[0] = 0;
          free(v15);
          uint64_t v15 = 0;
        }
      }
    }
  }
  size_t v16 = *(const void **)(v12 + 120);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(v12 + 120) = 0;
  }
  int64_t v17 = *(void *)(v12 + 136);
  if (v17 >= 1)
  {
    memset(&outPropertyData, 0, sizeof(outPropertyData));
    CMTimeMake(&outPropertyData, v17, (int)*(double *)(v12 + 192));
    uint64_t v18 = (_OWORD *)(v12 + 280);
    if (*(unsigned char *)(v12 + 292))
    {
      *(_OWORD *)&lhs.CMTimeValue value = *v18;
      lhs.CMTimeEpoch epoch = *(void *)(v12 + 296);
      CMTime rhs = outPropertyData;
      CMTimeAdd(&presentationTimeStamp, &lhs, &rhs);
      *uint64_t v18 = *(_OWORD *)&presentationTimeStamp.value;
      CMTimeEpoch epoch = presentationTimeStamp.epoch;
    }
    else
    {
      *uint64_t v18 = *(_OWORD *)&outPropertyData.value;
      CMTimeEpoch epoch = outPropertyData.epoch;
    }
    *(void *)(v12 + 296) = epoch;
  }
  *(void *)(v12 + 136) = 0;
  long long v21 = *(_OWORD *)(v12 + 248);
  *(_OWORD *)(v12 + 192) = *(_OWORD *)(v12 + 232);
  *(_OWORD *)(v12 + 208) = v21;
  *(void *)(v12 + 224) = *(void *)(v12 + 264);
  *(unsigned char *)(v12 + 276) = 0;
  if (*(void *)(v12 + 568))
  {
    FigBasicAESCPECryptorGetClassID();
    if (CMBaseObjectIsMemberOfClass())
    {
      *(unsigned char *)(v12 + 276) = 1;
      int v22 = *(_DWORD *)(v12 + 200);
      if (v22 > 2053202791)
      {
        switch(v22)
        {
          case 2053202792:
            int v24 = 72;
            break;
          case 2053202800:
            int v24 = 80;
            break;
          case 2053464883:
            int v23 = 1700998451;
LABEL_35:
            *(_DWORD *)(v12 + 200) = v23;
            goto LABEL_36;
          default:
LABEL_214:
            *(unsigned char *)(v12 + 276) = 0;
            goto LABEL_36;
        }
        int v23 = v24 | 0x61616320;
        goto LABEL_35;
      }
      if (v22 == 2053202275)
      {
        int v23 = 1633772320;
        goto LABEL_35;
      }
      if (v22 == 2053202739)
      {
        int v23 = 1633889587;
        goto LABEL_35;
      }
      goto LABEL_214;
    }
  }
LABEL_36:
  CFIndex v25 = 0;
  uint64_t v26 = *(unsigned int *)(v12 + 200);
  if ((int)v26 <= 2053202738)
  {
    if ((int)v26 > 1902212706)
    {
      if (v26 != 1902212707)
      {
        unsigned __int16 v27 = 24931;
        goto LABEL_46;
      }
    }
    else if (v26 != 1667331683)
    {
      int v28 = 1700886115;
      goto LABEL_47;
    }
  }
  else if (((v26 - 2053202739) > 0x3D {
          || ((1 << (v26 - 51)) & 0x2020000000000001) == 0)
  }
         && v26 != 2053464883)
  {
    unsigned __int16 v27 = 30307;
LABEL_46:
    int v28 = v27 | 0x7A610000;
LABEL_47:
    inited = 0;
    if (v26 != v28) {
      goto LABEL_50;
    }
  }
  inited = (__CFString *)PKDCreateTransportStreamEncryptionInitData(1936684398, v26);
  if (!inited)
  {
    CFDictionaryRef cf = 0;
    goto LABEL_219;
  }
  uint64_t v30 = (void *)*MEMORY[0x1E4F21660];
  values = inited;
  keys[0] = v30;
  CFIndex v25 = 1;
LABEL_50:
  CFDictionaryRef cf = inited;
  CFDictionaryRef v31 = CFDictionaryCreate(*v13, (const void **)keys, (const void **)&values, v25, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  if (!v31)
  {
LABEL_219:
    CFDictionaryRef v118 = 0;
    uint64_t v33 = 4294954510;
    goto LABEL_203;
  }
  if (Property) {
    uint64_t v32 = 0;
  }
  else {
    uint64_t v32 = (const AudioChannelLayout *)(v12 + 160);
  }
  CFDictionaryRef v118 = v31;
  uint64_t v33 = CMAudioFormatDescriptionCreate(*(CFAllocatorRef *)v12, (const AudioStreamBasicDescription *)(v12 + 192), 32 * (Property == 0), v32, outPropertyDataSize[0], v15, v31, (CMAudioFormatDescriptionRef *)(v12 + 120));
  free(v15);
  if (v33) {
    goto LABEL_203;
  }
  a5 = v121;
  if (!*(_DWORD *)(v12 + 72))
  {
    uint64_t v35 = CMBaseObjectGetDerivedStorage();
    *(unsigned char *)(v35 + 38) = 1;
    *(_DWORD *)(v35 + 72) = 100;
    BOOL v36 = *(uint64_t (**)(void *, void, uint64_t, uint64_t))(v35 + 48);
    if (v36)
    {
      uint64_t v37 = v35;
      uint64_t v38 = *(void *)(v35 + 24);
      *(void *)(v35 + 24) = 0;
      if (v38 < 1)
      {
        uint64_t v40 = v36(a1, *(void *)(v35 + 64), 1936684398, 100);
      }
      else
      {
        uint64_t v39 = v38;
        do
        {
          MEMORY[0x19970E2B0](*(void *)(v37 + 8));
          --v39;
        }
        while (v39);
        uint64_t v40 = (*(uint64_t (**)(void *, void, uint64_t, void))(v37 + 48))(a1, *(void *)(v37 + 64), 1936684398, *(unsigned int *)(v37 + 72));
      }
      uint64_t v33 = v40;
      do
      {
        MEMORY[0x19970E290](*(void *)(v37 + 8));
        uint64_t v46 = *(void *)(v37 + 24) + 1;
        *(void *)(v37 + 24) = v46;
      }
      while (v46 < v38);
      if (v33) {
        goto LABEL_203;
      }
      if (*(unsigned char *)(v37 + 32) || *(unsigned char *)(v37 + 37))
      {
        uint64_t v33 = 4294951251;
        goto LABEL_203;
      }
    }
  }
  LODWORD(outPropertyData.value) = 0;
  LODWORD(presentationTimeStamp.value) = 4;
  AudioFileStreamGetProperty(*(AudioFileStreamID *)(v12 + 152), 0x72726170u, (UInt32 *)&presentationTimeStamp, &outPropertyData);
  *(unsigned char *)(v12 + 352) = LODWORD(outPropertyData.value) != 0;
  uint64_t v20 = *(unsigned int *)(v12 + 72);
LABEL_57:
  if (*(void *)(v12 + 80)) {
    uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 80);
  }
  else {
    uint64_t v34 = 0;
  }
  uint64_t FormatDescriptionCallback = fim_MakeFormatDescriptionCallback((uint64_t)a1, v12, v20, v34, *(void *)(v12 + 104), *(void *)(v12 + 120), *(void *)(v12 + 568));
  if (FormatDescriptionCallback)
  {
    uint64_t v33 = FormatDescriptionCallback;
    *(_DWORD *)(v12 + 44) = FormatDescriptionCallback;
    goto LABEL_203;
  }
  if (*(_DWORD *)(v12 + 44)) {
    goto LABEL_204;
  }
  *(unsigned char *)(v12 + 275) = 0;
  *(unsigned char *)(v12 + 272) = 0;
LABEL_69:
  int v42 = *(_DWORD *)(v12 + 240);
  if (((v42 - 2053202739) > 0x3D || ((1 << (v42 - 51)) & 0x2020000000000001) == 0)
    && v42 != 2053464883
    && v42 != 2053202275)
  {
    goto LABEL_77;
  }
  uint64_t v43 = *(void *)(v12 + 568);
  if (*(unsigned char *)(v12 + 276))
  {
    uint64_t v44 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v44) {
      uint64_t v45 = v44;
    }
    else {
      uint64_t v45 = 0;
    }
    long long v47 = *(uint64_t (**)(uint64_t, void, CFAllocatorRef, CFTypeRef *))(v45 + 48);
    if (v47)
    {
      uint64_t v48 = v47(v43, *MEMORY[0x1E4F1FDF8], *v13, &v136);
      if (!v48) {
        goto LABEL_88;
      }
      uint64_t v33 = v48;
    }
    else
    {
      uint64_t v33 = 4294954514;
    }
LABEL_203:
    fim_EndAllTracks(a1, v33);
    goto LABEL_204;
  }
  if (v43) {
LABEL_77:
  }
    CFTypeRef v136 = CFRetain((CFTypeRef)*MEMORY[0x1E4F1CFD0]);
LABEL_88:
  CFTypeRef v117 = v136;
  uint64_t v49 = CMBaseObjectGetDerivedStorage();
  uint64_t v50 = v49;
  CMBlockBufferRef blockBufferOut = 0;
  CMTimeEpoch v51 = *(unsigned char **)(v49 + 320);
  if (v51 <= v130 && &v130[dataLength] <= &v51[*(void *)(v49 + 328)])
  {
    uint64_t v111 = *(void *)(v49 + 344);
    if (v51 != v130 || v111)
    {
      uint64_t v33 = CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)v49, *(CMBlockBufferRef *)(v49 + 336), v130 - v51 + v111, dataLength, 0, &blockBufferOut);
      CMBlockBufferRef v53 = blockBufferOut;
      CFStringRef v54 = blockBufferOut;
      if (v33) {
        goto LABEL_200;
      }
    }
    else
    {
      CMBlockBufferRef v53 = 0;
      CFStringRef v54 = *(OpaqueCMBlockBuffer **)(v49 + 336);
    }
LABEL_93:
    int v55 = *(_DWORD *)(v50 + 212);
    if (v55)
    {
      LODWORD(v56) = (*(double *)(v50 + 192) / (double)(2 * v55));
    }
    else if (a5)
    {
      if (!a3)
      {
LABEL_199:
        uint64_t v33 = 0;
        goto LABEL_200;
      }
      uint64_t v56 = 0;
      unint64_t v57 = 0;
      p_uint64_t mVariableFramesInPacket = &a5->mVariableFramesInPacket;
      while (1)
      {
        UInt32 v59 = *p_mVariableFramesInPacket;
        p_mVariableFramesInPacket += 4;
        v57 += v59;
        if (*(double *)(v50 + 192) * 0.5 < (double)v57) {
          break;
        }
        if (a3 == ++v56) {
          goto LABEL_101;
        }
      }
    }
    else
    {
LABEL_101:
      LODWORD(v56) = a3;
    }
    if (v56 <= 1) {
      LODWORD(v56) = 1;
    }
    unsigned int v120 = v56;
    if (a3)
    {
      unsigned int v60 = 0;
      CFTypeRef v116 = (CFTypeRef)*MEMORY[0x1E4F1CFC8];
      long long v123 = (unsigned int *)(v50 + 72);
      v124 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void, opaqueCMSampleBuffer *))(v50 + 88);
      CFStringRef v115 = (const __CFString *)*MEMORY[0x1E4F1F278];
      CMTime v127 = (const void **)(v50 + 360);
      CMTimeRange v128 = a1;
      CMTime v131 = (const void **)(v50 + 376);
      dataLengtha = (const void **)(v50 + 384);
      int32_t v61 = (void **)(v50 + 464);
      uint64_t v113 = *(void *)(v50 + 128) - a3;
      CMTimeEpoch v114 = (const void *)*MEMORY[0x1E4F1CFD0];
      __int16 v112 = &a5->mVariableFramesInPacket;
      long long v122 = v54;
      while (1)
      {
        unsigned int v125 = a3;
        if (v120 >= a3) {
          CMItemCount v62 = a3;
        }
        else {
          CMItemCount v62 = v120;
        }
        uint64_t v126 = v60;
        *(void *)outPropertyDataSize = 0;
        CMSampleBufferRef v143 = 0;
        CMItemCount v129 = v62;
        if (!a5)
        {
LABEL_187:
          uint64_t v71 = FigSignalErrorAt();
          goto LABEL_188;
        }
        uint64_t v63 = &a5[v60];
        uint64_t v64 = (v62 - 1);
        uint64_t v65 = &v63[v64];
        size_t mStartOffset = v63->mStartOffset;
        if (v63->mStartOffset)
        {
          size_t v67 = v65->mStartOffset + v63[v64].mDataByteSize;
        }
        else
        {
          size_t v68 = CMBlockBufferGetDataLength(v54);
          size_t v67 = v65->mStartOffset + v63[v64].mDataByteSize;
          if (v68 <= v67)
          {
            CMItemCount v76 = v129;
            size_t v74 = v63;
            CFIndex v73 = v54;
            goto LABEL_121;
          }
          size_t mStartOffset = v63->mStartOffset;
          LODWORD(v62) = v129;
        }
        if (*(_DWORD *)(v50 + 312) < v62)
        {
          int v69 = v62;
          char v70 = malloc_type_realloc(*(void **)(v50 + 304), 16 * v62, 0x1000040451B5BE8uLL);
          *(void *)(v50 + 304) = v70;
          if (!v70) {
            goto LABEL_187;
          }
          *(_DWORD *)(v50 + 312) = v69;
        }
        uint64_t v71 = CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)v50, v54, mStartOffset, v67 - mStartOffset, 0, (CMBlockBufferRef *)outPropertyDataSize);
        if (!v71)
        {
          uint64_t v72 = 0;
          CFIndex v73 = *(OpaqueCMBlockBuffer **)outPropertyDataSize;
          size_t v74 = *(const AudioStreamPacketDescription **)(v50 + 304);
          CMItemCount v75 = v129;
          do
          {
            v74[v72] = v63[v72];
            size_t v74 = *(const AudioStreamPacketDescription **)(v50 + 304);
            v74[v72].size_t mStartOffset = v63[v72].mStartOffset - mStartOffset;
            ++v72;
            --v75;
          }
          while (v75);
          CMItemCount v76 = v129;
LABEL_121:
          fim_GetCurrentAudioTime((uint64_t)v123, &presentationTimeStamp);
          CMTime outPropertyData = presentationTimeStamp;
          fim_AdjustPTS(v50, &outPropertyData);
          CFAllocatorRef v77 = *(const __CFAllocator **)v50;
          long long v78 = *(const opaqueCMFormatDescription **)(v50 + 120);
          CMTime presentationTimeStamp = outPropertyData;
          uint64_t v71 = CMAudioSampleBufferCreateWithPacketDescriptions(v77, v73, 1u, 0, 0, v78, v76, &presentationTimeStamp, v74, &v143);
          if (!v71)
          {
            if (*v124)
            {
              if (*(unsigned char *)(v50 + 274)) {
                CMSetAttachment(v143, v115, v114, 1u);
              }
              if (*(unsigned char *)(v50 + 352))
              {
                CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(v143, 1u);
                a5 = v121;
                if (SampleAttachmentsArray)
                {
                  CFArrayRef v80 = SampleAttachmentsArray;
                  CFIndex v81 = 0;
                  uint64_t v82 = v113 + v126;
                  while (1)
                  {
                    CFNumberRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v80, v81);
                    UInt32 v139 = 16;
                    *(void *)UInt32 ioPropertyDataSize = v82 + v81;
                    uint64_t v141 = 0;
                    if (!ValueAtIndex)
                    {
LABEL_183:
                      uint64_t v33 = FigSignalErrorAt();
LABEL_185:
                      a5 = v121;
                      CFStringRef v54 = v122;
                      goto LABEL_192;
                    }
                    long long v84 = ValueAtIndex;
                    uint64_t v85 = AudioFileStreamGetProperty(*(AudioFileStreamID *)(v50 + 152), 0x706B6470u, &v139, ioPropertyDataSize);
                    if (v85)
                    {
                      uint64_t v33 = v85;
                      FigSignalErrorAt();
                      goto LABEL_185;
                    }
                    int v86 = HIDWORD(v141);
                    if (!v141) {
                      break;
                    }
                    if (!HIDWORD(v141))
                    {
                      v88 = *v127;
                      if (*v127) {
                        goto LABEL_145;
                      }
                      unsigned int v89 = (const void **)(v50 + 360);
LABEL_139:
                      if (FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary()) {
                        goto LABEL_183;
                      }
                      goto LABEL_144;
                    }
                    uint64_t v87 = v50 + 376;
                    v88 = *v131;
                    if (*v131)
                    {
                      if (*(_DWORD *)(v50 + 368) == HIDWORD(v141))
                      {
                        a1 = v128;
                        goto LABEL_145;
                      }
                      CFRelease(v88);
                      uint64_t v87 = v50 + 376;
                      *CMTime v131 = 0;
                    }
                    CFArrayRef v90 = v80;
                    uint64_t v91 = v82;
                    unsigned int v92 = (const void **)v87;
                    if (FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary())
                    {
                      uint64_t v33 = FigSignalErrorAt();
                      a5 = v121;
                      CFStringRef v54 = v122;
                      a1 = v128;
                      goto LABEL_192;
                    }
                    *(_DWORD *)(v50 + 368) = v86;
                    unsigned int v89 = v92;
                    uint64_t v82 = v91;
                    CFArrayRef v80 = v90;
                    a1 = v128;
LABEL_144:
                    v88 = *v89;
                    if (!*v89) {
                      goto LABEL_183;
                    }
LABEL_145:
                    CFDictionaryApplyFunction((CFDictionaryRef)v88, (CFDictionaryApplierFunction)appendAttributesToDictionary, v84);
                    if (v76 == ++v81) {
                      goto LABEL_146;
                    }
                  }
                  v88 = *dataLengtha;
                  if (*dataLengtha) {
                    goto LABEL_145;
                  }
                  unsigned int v89 = (const void **)(v50 + 384);
                  goto LABEL_139;
                }
                uint64_t v103 = FigSignalErrorAt();
LABEL_190:
                uint64_t v33 = v103;
LABEL_191:
                CFStringRef v54 = v122;
                goto LABEL_192;
              }
LABEL_146:
              unsigned int v93 = *(__CFArray **)(v50 + 560);
              if (v117 == v116)
              {
                CFArrayAppendValue(v93, v143);
                a5 = v121;
                CFStringRef v54 = v122;
              }
              else
              {
                a5 = v121;
                CFStringRef v54 = v122;
                if (CFArrayGetCount(v93) >= 1)
                {
                  CFArrayRef v94 = *(const __CFArray **)(v50 + 560);
                  v148.length = CFArrayGetCount(v94);
                  v148.CFIndex location = 0;
                  CFArrayApplyFunction(v94, v148, (CFArrayApplierFunction)fim_emitSampleApplier, a1);
                  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v50 + 560));
                }
                if (*v124) {
                  uint64_t v95 = *v124;
                }
                else {
                  uint64_t v95 = 0;
                }
                uint64_t PushSampleBufferCallback = fim_MakePushSampleBufferCallback((uint64_t)a1, v50, *v123, v95, *(void *)(v50 + 104), v143);
                if (PushSampleBufferCallback)
                {
                  uint64_t v33 = PushSampleBufferCallback;
                  *(_DWORD *)(v50 + 44) = PushSampleBufferCallback;
                  goto LABEL_192;
                }
              }
              CMTimeScale v97 = *(void **)(v50 + 448);
              if (v97)
              {
                uint64_t v33 = fim_PushMetaData((uint64_t)a1, v97, 0x69637920u);
                uint64_t v98 = *(const void **)(v50 + 448);
                if (v98) {
                  CFRelease(v98);
                }
                *(void *)(v50 + 448) = 0;
                if (v33) {
                  goto LABEL_192;
                }
              }
              uint64_t v99 = *(void **)(v50 + 456);
              if (v99)
              {
                uint64_t v33 = fim_PushMetaData((uint64_t)a1, v99, 0x69643320u);
                uint64_t v100 = *(const void **)(v50 + 456);
                if (v100) {
                  CFRelease(v100);
                }
                *(void *)(v50 + 456) = 0;
                if (v33) {
                  goto LABEL_192;
                }
              }
            }
            *(unsigned char *)(v50 + 274) = 0;
            BOOL v101 = *(void **)(v50 + 464);
            if (v101)
            {
              uint64_t v102 = 0;
              do
              {
                if (v101)
                {
                  do
                  {
                    if (v63[v102].mStartOffset < *((int *)v101 + 5)) {
                      break;
                    }
                    uint64_t v103 = fim_PushMetaData((uint64_t)a1, (void *)v101[1], *((_DWORD *)v101 + 4));
                    if (v103) {
                      goto LABEL_190;
                    }
                    int v104 = (void *)**v61;
                    *int32_t v61 = v104;
                    if (!v104) {
                      *(void *)(v50 + 472) = v61;
                    }
                    CMTimeEpoch v105 = (const void *)v101[1];
                    if (v105) {
                      CFRelease(v105);
                    }
                    free(v101);
                    BOOL v101 = *v61;
                  }
                  while (*v61);
                }
                uint64_t mVariableFramesInPacket = *(unsigned int *)(v50 + 212);
                if (!mVariableFramesInPacket) {
                  uint64_t mVariableFramesInPacket = v63[v102].mVariableFramesInPacket;
                }
                *(void *)(v50 + 136) += mVariableFramesInPacket;
                ++v102;
              }
              while (v102 != v76);
              uint64_t v33 = 0;
            }
            else
            {
              int v107 = *(_DWORD *)(v50 + 212);
              if (!v107)
              {
                uint64_t v108 = *(void *)(v50 + 136);
                CMTimeValue v109 = &v112[4 * v126];
                CFStringRef v54 = v122;
                do
                {
                  UInt32 v110 = *v109;
                  v109 += 4;
                  v108 += v110;
                  --v76;
                }
                while (v76);
                uint64_t v33 = 0;
                *(void *)(v50 + 136) = v108;
                goto LABEL_192;
              }
              uint64_t v33 = 0;
              *(void *)(v50 + 136) += (v107 * v129);
            }
            goto LABEL_191;
          }
        }
LABEL_188:
        uint64_t v33 = v71;
LABEL_192:
        if (v143) {
          CFRelease(v143);
        }
        if (*(void *)outPropertyDataSize) {
          CFRelease(*(CFTypeRef *)outPropertyDataSize);
        }
        if (!v33)
        {
          unsigned int v60 = v129 + v126;
          a3 = v125 - v129;
          if (v125 != v129) {
            continue;
          }
        }
        CMBlockBufferRef v53 = blockBufferOut;
        goto LABEL_200;
      }
    }
    goto LABEL_199;
  }
  uint64_t v52 = CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)v49, 0, dataLength, *(CFAllocatorRef *)v49, 0, 0, dataLength, 1u, &blockBufferOut);
  CMBlockBufferRef v53 = blockBufferOut;
  if (!v52)
  {
    uint64_t v52 = CMBlockBufferReplaceDataBytes(v130, blockBufferOut, 0, dataLength);
    CMBlockBufferRef v53 = blockBufferOut;
    if (!v52)
    {
      CFStringRef v54 = blockBufferOut;
      goto LABEL_93;
    }
  }
  uint64_t v33 = v52;
LABEL_200:
  if (v53) {
    CFRelease(v53);
  }
  if (v33) {
    goto LABEL_203;
  }
LABEL_204:
  if (v136) {
    CFRelease(v136);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v118) {
    CFRelease(v118);
  }
}

uint64_t FigIcyManifoldInvalidate(void *a1)
{
  return 0;
}

uint64_t FigIcyManifoldFinalize(void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(unsigned char *)(DerivedStorage + 40) = 1;
  FigIcyManifoldInvalidateGuts(a1);
  fim_DestroyAudioTrack(DerivedStorage + 72);
  fim_DestroyMetaTrack((void *)(DerivedStorage + 392));
  uint64_t v3 = *(const void **)(DerivedStorage + 560);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(DerivedStorage + 560) = 0;
  }
  uint64_t v4 = *(const void **)(DerivedStorage + 568);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(DerivedStorage + 568) = 0;
  }
  uint64_t v5 = *(const void **)(DerivedStorage + 520);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(DerivedStorage + 520) = 0;
  }
  CMBlockBufferRef v6 = *(const void **)(DerivedStorage + 16);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(DerivedStorage + 16) = 0;
  }
  if (*(void *)DerivedStorage) {
    CFRelease(*(CFTypeRef *)DerivedStorage);
  }
  uint64_t result = *(void *)(DerivedStorage + 8);
  if (result)
  {
    uint64_t result = FigSimpleMutexDestroy();
    *(void *)(DerivedStorage + 8) = 0;
  }
  return result;
}

__CFString *FigIcyManifoldCopyDebugDescription()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
  ++*(void *)(DerivedStorage + 24);
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"\tFigIcyManifold :");
  --*(void *)(DerivedStorage + 24);
  MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
  return Mutable;
}

uint64_t FigIcyManifoldCopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
  ++*(void *)(DerivedStorage + 24);
  if (*(unsigned char *)(DerivedStorage + 32))
  {
    uint64_t v10 = FigSignalErrorAt();
    goto LABEL_12;
  }
  if (CFEqual(a2, @"FMFD_ParserState"))
  {
    int valuePtr = 0;
    if (*(unsigned char *)(DerivedStorage + 39))
    {
      if (*(void *)(DerivedStorage + 120)) {
        int v8 = 2;
      }
      else {
        int v8 = 1;
      }
      int valuePtr = v8;
    }
    uint64_t v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  }
  else
  {
    if (!CFEqual(a2, @"FMFD_Type"))
    {
      uint64_t v10 = 4294954512;
      goto LABEL_12;
    }
    uint64_t v9 = (void *)CFStringCreateWithCString(a3, "AAC", 0x8000100u);
  }
  uint64_t v10 = 0;
  *a4 = v9;
LABEL_12:
  --*(void *)(DerivedStorage + 24);
  MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
  return v10;
}

uint64_t FigIcyManifoldSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
  ++*(void *)(DerivedStorage + 24);
  if (CFEqual(a2, @"FMFD_HintForStartTime"))
  {
    if (a3
      && (CFTypeID v6 = CFGetTypeID(a3), v6 == CFDictionaryGetTypeID())
      && (CMTimeMakeFromDictionary(&v12, (CFDictionaryRef)a3),
          CMTimeValue value = v12.value,
          CMTimeFlags flags = v12.flags,
          CMTimeScale timescale = v12.timescale,
          (v12.flags & 0x1D) == 1))
    {
      uint64_t v8 = 0;
      CMTimeEpoch epoch = v12.epoch;
      *(void *)(DerivedStorage + 576) = value;
      *(_DWORD *)(DerivedStorage + 584) = timescale;
      *(_DWORD *)(DerivedStorage + 588) = flags;
      *(void *)(DerivedStorage + 592) = epoch;
      uint64_t v10 = MEMORY[0x1E4F1F9F8];
      *(_OWORD *)(DerivedStorage + 600) = *MEMORY[0x1E4F1F9F8];
      *(void *)(DerivedStorage + 616) = *(void *)(v10 + 16);
    }
    else
    {
      uint64_t v8 = FigSignalErrorAt();
    }
  }
  else
  {
    uint64_t v8 = 4294954512;
  }
  --*(void *)(DerivedStorage + 24);
  MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
  return v8;
}

void FigIcyManifoldInvalidateGuts(void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
  uint64_t v3 = *(void *)(DerivedStorage + 24);
  *(void *)(DerivedStorage + 24) = v3 + 1;
  if (!*(unsigned char *)(DerivedStorage + 32))
  {
    *(unsigned char *)(DerivedStorage + 32) = 1;
    *(void *)(DerivedStorage + 48) = 0;
    if (!*(unsigned char *)(DerivedStorage + 40))
    {
      fim_EndAllTracks(a1, 4294954511);
      uint64_t v3 = *(void *)(DerivedStorage + 24) - 1;
    }
  }
  *(void *)(DerivedStorage + 24) = v3;

  JUMPOUT(0x19970E2B0);
}

void fim_EndAllTracks(void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a1) {
    CFRetain(a1);
  }
  if (*(void *)(DerivedStorage + 96)) {
    uint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(DerivedStorage + 96);
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)(DerivedStorage + 96) = 0;
  if (a2)
  {
    if (!v5) {
      goto LABEL_19;
    }
  }
  else
  {
    FigIcyManifoldFlush(a1);
    if (!v5) {
      goto LABEL_19;
    }
  }
  uint64_t v6 = *(unsigned int *)(DerivedStorage + 72);
  uint64_t v7 = *(void *)(DerivedStorage + 104);
  uint64_t v8 = *(void *)(DerivedStorage + 24);
  *(void *)(DerivedStorage + 24) = 0;
  if (v8 >= 1)
  {
    uint64_t v9 = v8;
    do
    {
      MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
      --v9;
    }
    while (v9);
  }
  if (v7)
  {
    int v10 = v5(a1, v6, v7, a2);
    do
    {
      MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
      uint64_t v11 = *(void *)(DerivedStorage + 24) + 1;
      *(void *)(DerivedStorage + 24) = v11;
    }
    while (v11 < v8);
    if (v10) {
      goto LABEL_26;
    }
  }
  else
  {
    do
    {
      MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
      uint64_t v12 = *(void *)(DerivedStorage + 24) + 1;
      *(void *)(DerivedStorage + 24) = v12;
    }
    while (v12 < v8);
  }
LABEL_19:
  uint64_t v13 = (void *)(DerivedStorage + 416);
  uint64_t v14 = *(void (**)(void *, uint64_t, uint64_t, uint64_t))(DerivedStorage + 416);
  if (!v14)
  {
    *uint64_t v13 = 0;
    if (!a1) {
      return;
    }
    goto LABEL_27;
  }
  *uint64_t v13 = 0;
  uint64_t v15 = *(unsigned int *)(DerivedStorage + 392);
  uint64_t v16 = *(void *)(DerivedStorage + 424);
  uint64_t v17 = *(void *)(DerivedStorage + 24);
  *(void *)(DerivedStorage + 24) = 0;
  if (v17 >= 1)
  {
    uint64_t v18 = v17;
    do
    {
      MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
      --v18;
    }
    while (v18);
  }
  if (v16) {
    v14(a1, v15, v16, a2);
  }
  do
  {
    MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
    uint64_t v19 = *(void *)(DerivedStorage + 24) + 1;
    *(void *)(DerivedStorage + 24) = v19;
  }
  while (v19 < v17);
LABEL_26:
  if (!a1) {
    return;
  }
LABEL_27:

  CFRelease(a1);
}

uint64_t FigIcyManifoldFlush(void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
  ++*(void *)(DerivedStorage + 24);
  if (*(unsigned char *)(DerivedStorage + 32) || *(unsigned char *)(DerivedStorage + 36))
  {
    uint64_t v12 = FigSignalErrorAt();
    goto LABEL_24;
  }
  uint64_t v3 = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = v3;
  CFTypeRef cf = 0;
  uint64_t v5 = *(void *)(v3 + 568);
  if (v5)
  {
    if (*(unsigned char *)(v3 + 276))
    {
      uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v6) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = 0;
      }
      uint64_t v9 = *(unsigned int (**)(uint64_t, void, void, CFTypeRef *))(v7 + 48);
      if (!v9 || v9(v5, *MEMORY[0x1E4F1FDF8], *MEMORY[0x1E4F1CF80], &cf))
      {
LABEL_16:
        CFTypeRef v8 = cf;
        goto LABEL_17;
      }
      CFTypeRef v8 = cf;
    }
    else
    {
      CFTypeRef v8 = CFRetain((CFTypeRef)*MEMORY[0x1E4F1CFD0]);
      CFTypeRef cf = v8;
    }
  }
  else
  {
    CFTypeRef v8 = 0;
  }
  if (v8 == (CFTypeRef)*MEMORY[0x1E4F1CFD0])
  {
    if (CFArrayGetCount(*(CFArrayRef *)(v4 + 560)) >= 1)
    {
      CFArrayRef v10 = *(const __CFArray **)(v4 + 560);
      v15.length = CFArrayGetCount(v10);
      v15.CFIndex location = 0;
      CFArrayApplyFunction(v10, v15, (CFArrayApplierFunction)fim_emitSampleApplier, a1);
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v4 + 560));
    }
    goto LABEL_16;
  }
LABEL_17:
  if (v8) {
    CFRelease(v8);
  }
  if (*(unsigned char *)(DerivedStorage + 39))
  {
    uint64_t v11 = *(OpaqueAudioFileStreamID **)(DerivedStorage + 152);
    if (v11)
    {
      if (*(void *)(DerivedStorage + 120)) {
        AudioFileStreamParseBytes(v11, 0, 0, 0);
      }
    }
  }
  uint64_t v12 = 0;
  *(unsigned char *)(DerivedStorage + 37) = 1;
LABEL_24:
  --*(void *)(DerivedStorage + 24);
  MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
  return v12;
}

uint64_t fim_emitSampleApplier(opaqueCMSampleBuffer *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = DerivedStorage;
  if (*(void *)(DerivedStorage + 88)) {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void, opaqueCMSampleBuffer *))(DerivedStorage + 88);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t result = fim_MakePushSampleBufferCallback(a2, DerivedStorage, *(unsigned int *)(DerivedStorage + 72), v6, *(void *)(DerivedStorage + 104), a1);
  if (result) {
    *(_DWORD *)(v5 + 44) = result;
  }
  return result;
}

uint64_t fim_MakePushSampleBufferCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, void, void, opaqueCMSampleBuffer *), uint64_t a5, CMSampleBufferRef sbuf)
{
  if (!a4) {
    return 0;
  }
  uint64_t v6 = sbuf;
  uint64_t v12 = CMSampleBufferGetFormatDescription(sbuf);
  if (*(unsigned char *)(a2 + 276)) {
    BOOL v13 = v12 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13 && CMFormatDescriptionGetMediaType(v12) == 1936684398)
  {
    uint64_t v52 = a1;
    CMBlockBufferRef v60 = 0;
    CMBlockBufferRef v61 = 0;
    CMBlockBufferRef blockBufferOut = 0;
    packetDescriptionsPointerOut = 0;
    CMSampleBufferRef sampleBufferOut = 0;
    uint32_t v14 = CMSampleBufferGetNumSamples(v6);
    CMFormatDescriptionRef v15 = CMSampleBufferGetFormatDescription(v6);
    CMSampleBufferGetPresentationTimeStamp(&v59, v6);
    CMBlockBufferRef DataBuffer = CMSampleBufferGetDataBuffer(v6);
    if (DataBuffer)
    {
      uint64_t v17 = DataBuffer;
      formatDescription = v15;
      uint64_t AudioStreamPacketDescriptionsPtr = CMSampleBufferGetAudioStreamPacketDescriptionsPtr(v6, (const AudioStreamPacketDescription **)&packetDescriptionsPointerOut, 0);
      if (!AudioStreamPacketDescriptionsPtr)
      {
        unsigned int v51 = a3;
        CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v20 = CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v14, 0, &blockBufferOut);
        if (!v20)
        {
          CMItemCount numSamples = v14;
          packetDescriptions = (AudioStreamPacketDescription *)malloc_type_calloc(v14, 0x10uLL, 0x1000040451B5BE8uLL);
          if (packetDescriptions)
          {
            uint64_t v50 = a5;
            int v21 = *(_DWORD *)(a2 + 200);
            int v22 = (uint64_t *)MEMORY[0x1E4F1FCA0];
            if (v21 != 1700998451) {
              int v22 = (uint64_t *)MEMORY[0x1E4F1FC88];
            }
            if (v21 == 1633889587) {
              int v23 = (uint64_t *)MEMORY[0x1E4F1FC98];
            }
            else {
              int v23 = v22;
            }
            if (!v14)
            {
LABEL_36:
              CFAllocatorRef v42 = *(const __CFAllocator **)a2;
              CMTime presentationTimeStamp = v59;
              uint64_t v43 = CMAudioSampleBufferCreateWithPacketDescriptions(v42, blockBufferOut, 1u, 0, 0, formatDescription, numSamples, &presentationTimeStamp, packetDescriptions, &sampleBufferOut);
              a5 = v50;
              a3 = v51;
              a1 = v52;
              if (v43)
              {
                CMSampleBufferRef v44 = 0;
              }
              else
              {
                CMSampleBufferRef v44 = sampleBufferOut;
                CMSampleBufferRef sampleBufferOut = 0;
              }
LABEL_43:
              if (v61) {
                CFRelease(v61);
              }
              if (v60) {
                CFRelease(v60);
              }
              if (blockBufferOut) {
                CFRelease(blockBufferOut);
              }
              free(packetDescriptions);
              if (sampleBufferOut) {
                CFRelease(sampleBufferOut);
              }
              uint64_t v6 = v44;
              if (v43) {
                goto LABEL_61;
              }
              goto LABEL_52;
            }
            uint64_t v24 = 0;
            uint64_t v25 = *v23;
            uint64_t v26 = *MEMORY[0x1E4F1FCE8];
            while (1)
            {
              Dataunint64_t Length = CMBlockBufferGetDataLength(blockBufferOut);
              int v28 = &packetDescriptions[v24];
              v28->size_t mStartOffset = DataLength;
              uint64_t v29 = *(void *)&packetDescriptionsPointerOut[v24].mVariableFramesInPacket;
              *(void *)&v28->uint64_t mVariableFramesInPacket = v29;
              size_t v30 = HIDWORD(v29);
              uint64_t appended = CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)a2, 0, HIDWORD(v29), v19, 0, 0, HIDWORD(v29), 1u, &v60);
              if (appended) {
                break;
              }
              CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)a2, v17, packetDescriptionsPointerOut[v24].mStartOffset, v30, 0, &v61);
              uint64_t v32 = *(void *)(a2 + 568);
              uint64_t v33 = *(void *)(CMBaseObjectGetVTable() + 8);
              if (v33) {
                uint64_t v34 = v33;
              }
              else {
                uint64_t v34 = 0;
              }
              uint64_t v35 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v34 + 56);
              if (!v35) {
                goto LABEL_39;
              }
              uint64_t appended = v35(v32, v26, v25);
              if (appended) {
                break;
              }
              uint64_t v36 = *(void *)(a2 + 568);
              CMBlockBufferRef v38 = v60;
              CMBlockBufferRef v37 = v61;
              uint64_t v39 = *(void *)(CMBaseObjectGetVTable() + 16);
              uint64_t v40 = v39 ? (void *)v39 : 0;
              if (*v40 < 4uLL
                || (uint64_t v41 = (uint64_t (*)(uint64_t, CMBlockBufferRef, CMBlockBufferRef))v40[4]) == 0)
              {
LABEL_39:
                CMSampleBufferRef v44 = 0;
                uint64_t v43 = 4294954514;
                goto LABEL_40;
              }
              uint64_t appended = v41(v36, v37, v38);
              if (appended) {
                break;
              }
              uint64_t appended = CMBlockBufferAppendBufferReference(blockBufferOut, v60, 0, 0, 0);
              if (appended) {
                break;
              }
              if (v61)
              {
                CFRelease(v61);
                CMBlockBufferRef v61 = 0;
              }
              if (v60)
              {
                CFRelease(v60);
                CMBlockBufferRef v60 = 0;
              }
              if (numSamples == ++v24) {
                goto LABEL_36;
              }
            }
            uint64_t v43 = appended;
            CMSampleBufferRef v44 = 0;
LABEL_40:
            a5 = v50;
            goto LABEL_41;
          }
          uint64_t v20 = FigSignalErrorAt();
        }
        uint64_t v43 = v20;
        CMSampleBufferRef v44 = 0;
        packetDescriptions = 0;
LABEL_41:
        a3 = v51;
LABEL_42:
        a1 = v52;
        goto LABEL_43;
      }
      uint64_t v43 = AudioStreamPacketDescriptionsPtr;
      CMSampleBufferRef v44 = 0;
    }
    else
    {
      CMSampleBufferRef v44 = 0;
      uint64_t v43 = 0;
    }
    packetDescriptions = 0;
    goto LABEL_42;
  }
  CMSampleBufferRef v44 = 0;
LABEL_52:
  uint64_t v45 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v45 >= 1)
  {
    uint64_t v46 = v45;
    do
    {
      MEMORY[0x19970E2B0](*(void *)(a2 + 8));
      --v46;
    }
    while (v46);
  }
  uint64_t v43 = a4(a1, a3, a5, 0, 0, v6);
  do
  {
    MEMORY[0x19970E290](*(void *)(a2 + 8));
    uint64_t v47 = *(void *)(a2 + 24) + 1;
    *(void *)(a2 + 24) = v47;
  }
  while (v47 < v45);
  if (!v43)
  {
    if (!*(unsigned char *)(a2 + 32) && !*(unsigned char *)(a2 + 37))
    {
      uint64_t v43 = 0;
      if (!v44) {
        return v43;
      }
      goto LABEL_62;
    }
    uint64_t v43 = 4294951251;
  }
LABEL_61:
  if (v44) {
LABEL_62:
  }
    CFRelease(v44);
  return v43;
}

void fim_DestroyAudioTrack(uint64_t a1)
{
  FigFormatDescriptionRelease();
  *(void *)(a1 + 48) = 0;
  CFAllocatorRef v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 40) = 0;
  }
  uint64_t v3 = *(OpaqueAudioFileStreamID **)(a1 + 80);
  if (v3)
  {
    AudioFileStreamClose(v3);
    *(void *)(a1 + 80) = 0;
  }
  free(*(void **)(a1 + 232));
  *(unsigned char *)(a1 + 280) = 0;
  uint64_t v4 = *(const void **)(a1 + 304);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 304) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 288);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 288) = 0;
  }
  *(_DWORD *)(a1 + 296) = 0;
  uint64_t v6 = *(const void **)(a1 + 312);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 312) = 0;
  }
}

void fim_DestroyMetaTrack(void *a1)
{
  FigFormatDescriptionRelease();
  a1[5] = 0;
  FigFormatDescriptionRelease();
  a1[6] = 0;
  CFAllocatorRef v2 = (const void *)a1[7];
  if (v2) {
    CFRelease(v2);
  }
  a1[7] = 0;
  uint64_t v3 = (const void *)a1[8];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v5 = (uint64_t **)(a1 + 9);
  uint64_t v4 = (uint64_t *)a1[9];
  a1[8] = 0;
  if (v4)
  {
    do
    {
      uint64_t v6 = *v4;
      *uint64_t v5 = (uint64_t *)*v4;
      if (!v6) {
        a1[10] = v5;
      }
      uint64_t v7 = (const void *)v4[1];
      if (v7) {
        CFRelease(v7);
      }
      free(v4);
      uint64_t v4 = *v5;
    }
    while (*v5);
  }
}

uint64_t FigIcyManifoldNoteStreamEnd(void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFRetain(a1);
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
  ++*(void *)(DerivedStorage + 24);
  if (*(unsigned char *)(DerivedStorage + 32))
  {
    uint64_t v5 = FigSignalErrorAt();
  }
  else
  {
    *(unsigned char *)(DerivedStorage + 37) = 1;
    fim_EndAllTracks(a1, a2);
    uint64_t v5 = 0;
  }
  --*(void *)(DerivedStorage + 24);
  MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
  CFRelease(a1);
  return v5;
}

uint64_t FigIcyManifoldCopyCurrentFormatDescriptionForTrack(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
  ++*(void *)(DerivedStorage + 24);
  if (*(unsigned char *)(DerivedStorage + 32) || !a2) {
    goto LABEL_10;
  }
  if (*(_DWORD *)(DerivedStorage + 72) == a2)
  {
    if (!*(void *)(DerivedStorage + 120))
    {
LABEL_10:
      uint64_t v6 = FigSignalErrorAt();
      goto LABEL_11;
    }
  }
  else if (*(_DWORD *)(DerivedStorage + 392) != a2 {
         || !*(void *)(DerivedStorage + 432) && !*(void *)(DerivedStorage + 440))
  }
  {
    goto LABEL_10;
  }
  uint64_t v6 = 0;
  *a3 = FigFormatDescriptionRetain();
LABEL_11:
  --*(void *)(DerivedStorage + 24);
  MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
  return v6;
}

uint64_t FigIcyManifoldInstallCallbacksForTrack(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
  uint64_t v8 = *(void *)(DerivedStorage + 24);
  *(void *)(DerivedStorage + 24) = v8 + 1;
  if (a3 && *(unsigned char *)(DerivedStorage + 32))
  {
    uint64_t v9 = 4294954511;
    goto LABEL_15;
  }
  if (!a2) {
    goto LABEL_10;
  }
  if (*(_DWORD *)(DerivedStorage + 72) == a2)
  {
    if (a3)
    {
      *(void *)(DerivedStorage + 80) = *a3;
      *(void *)(DerivedStorage + 88) = a3[1];
      *(void *)(DerivedStorage + 96) = a3[2];
    }
    else
    {
      *(void *)(DerivedStorage + 80) = 0;
      *(void *)(DerivedStorage + 88) = 0;
      *(void *)(DerivedStorage + 96) = 0;
    }
    uint64_t v9 = 0;
    *(void *)(DerivedStorage + 104) = a4;
    goto LABEL_15;
  }
  if (*(_DWORD *)(DerivedStorage + 392) != a2)
  {
LABEL_10:
    uint64_t v9 = FigSignalErrorAt();
    uint64_t v8 = *(void *)(DerivedStorage + 24) - 1;
    goto LABEL_15;
  }
  if (a3)
  {
    *(void *)(DerivedStorage + 400) = *a3;
    *(void *)(DerivedStorage + 408) = a3[1];
    *(void *)(DerivedStorage + 416) = a3[2];
  }
  else
  {
    *(void *)(DerivedStorage + 400) = 0;
    *(void *)(DerivedStorage + 408) = 0;
    *(void *)(DerivedStorage + 416) = 0;
  }
  uint64_t v9 = 0;
  *(void *)(DerivedStorage + 424) = a4;
LABEL_15:
  *(void *)(DerivedStorage + 24) = v8;
  MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
  return v9;
}

uint64_t FigIcyManifoldCopyTrackProperty(uint64_t a1, int a2, const void *a3, uint64_t a4, CFNumberRef *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
  ++*(void *)(DerivedStorage + 24);
  if (*(unsigned char *)(DerivedStorage + 32))
  {
    uint64_t v11 = 4294954511;
  }
  else if (*(_DWORD *)(DerivedStorage + 72) == a2)
  {
    if (CFEqual(a3, @"FMFD_TrackEstimatedDataRate"))
    {
      UInt32 ioPropertyDataSize = 4;
      unsigned int outPropertyData = 0;
      uint64_t Property = AudioFileStreamGetProperty(*(AudioFileStreamID *)(DerivedStorage + 152), 0x62726174u, &ioPropertyDataSize, &outPropertyData);
      if (Property)
      {
        uint64_t v11 = Property;
      }
      else
      {
        outPropertyData >>= 3;
        CFNumberRef v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &outPropertyData);
        *a5 = v10;
        if (v10) {
          uint64_t v11 = 0;
        }
        else {
          uint64_t v11 = 4294954510;
        }
      }
    }
    else
    {
      uint64_t v11 = 4294954512;
    }
  }
  else if (*(_DWORD *)(DerivedStorage + 392) == a2)
  {
    uint64_t v11 = 4294954513;
  }
  else
  {
    uint64_t v11 = 4294951254;
  }
  --*(void *)(DerivedStorage + 24);
  MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
  return v11;
}

uint64_t FigIcyManifoldReannounceUnregisteredTracks(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
  ++*(void *)(DerivedStorage + 24);
  if (*(unsigned char *)(DerivedStorage + 32))
  {
    uint64_t v8 = FigSignalErrorAt();
    goto LABEL_15;
  }
  *(unsigned char *)(DerivedStorage + 37) = 0;
  if (!*(void *)(DerivedStorage + 48))
  {
LABEL_10:
    uint64_t v4 = 0;
    goto LABEL_11;
  }
  uint64_t v3 = *(unsigned int *)(DerivedStorage + 72);
  if (!v3
    || *(void *)(DerivedStorage + 80)
    || *(void *)(DerivedStorage + 88)
    || (uint64_t v4 = fim_ReannounceTrack(a1, v3, *(const opaqueCMFormatDescription **)(DerivedStorage + 120), 0), !v4))
  {
    uint64_t v5 = *(unsigned int *)(DerivedStorage + 392);
    if (!v5 || *(void *)(DerivedStorage + 400) || *(void *)(DerivedStorage + 408)) {
      goto LABEL_10;
    }
    uint64_t v7 = *(const opaqueCMFormatDescription **)(DerivedStorage + 432);
    if (!v7) {
      uint64_t v7 = *(const opaqueCMFormatDescription **)(DerivedStorage + 440);
    }
    uint64_t v8 = fim_ReannounceTrack(a1, v5, v7, 0);
LABEL_15:
    uint64_t v4 = v8;
  }
LABEL_11:
  --*(void *)(DerivedStorage + 24);
  MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
  return v4;
}

uint64_t fim_ReannounceTrack(uint64_t a1, uint64_t a2, const opaqueCMFormatDescription *a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v9 = *(void *)(DerivedStorage + 64);
  uint64_t v10 = *(void *)(DerivedStorage + 24);
  *(void *)(DerivedStorage + 24) = 0;
  if (v10 >= 1)
  {
    uint64_t v11 = v10;
    do
    {
      MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 8));
      --v11;
    }
    while (v11);
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(DerivedStorage + 48);
  uint64_t MediaType = CMFormatDescriptionGetMediaType(a3);
  uint64_t v14 = v12(a1, v9, MediaType, a2);
  do
  {
    MEMORY[0x19970E290](*(void *)(DerivedStorage + 8));
    uint64_t v15 = *(void *)(DerivedStorage + 24) + 1;
    *(void *)(DerivedStorage + 24) = v15;
  }
  while (v15 < v10);
  if (v14) {
    return v14;
  }
  if (*(unsigned char *)(DerivedStorage + 32) || *(unsigned char *)(DerivedStorage + 37)) {
    return 4294951251;
  }

  return fim_MakeFormatDescriptionCallback(a1, DerivedStorage, a2, a4, v9, (uint64_t)a3, 0);
}

uint64_t fim_MakeFormatDescriptionCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (!a4) {
    return 0;
  }
  uint64_t v14 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v14 >= 1)
  {
    uint64_t v15 = v14;
    do
    {
      MEMORY[0x19970E2B0](*(void *)(a2 + 8));
      --v15;
    }
    while (v15);
  }
  uint64_t v16 = a4(a1, a3, a5, a6, a7);
  do
  {
    MEMORY[0x19970E290](*(void *)(a2 + 8));
    uint64_t v17 = *(void *)(a2 + 24);
    *(void *)(a2 + 24) = v17 + 1;
  }
  while (v17 + 1 < v14);
  if (!v16)
  {
    if (!*(unsigned char *)(a2 + 32) && !*(unsigned char *)(a2 + 37))
    {
      if (!*(unsigned char *)(a2 + 38)) {
        return 0;
      }
      if (*(_DWORD *)(a2 + 72) != 100) {
        return 0;
      }
      *(unsigned char *)(a2 + 38) = 0;
      CFAllocatorRef v19 = *(void (**)(uint64_t, void))(a2 + 56);
      if (!v19) {
        return 0;
      }
      *(void *)(a2 + 24) = 0;
      if ((v17 & 0x8000000000000000) == 0)
      {
        uint64_t v20 = v17 + 1;
        do
        {
          MEMORY[0x19970E2B0](*(void *)(a2 + 8));
          --v20;
        }
        while (v20);
        CFAllocatorRef v19 = *(void (**)(uint64_t, void))(a2 + 56);
      }
      v19(a1, *(void *)(a2 + 64));
      do
      {
        MEMORY[0x19970E290](*(void *)(a2 + 8));
        uint64_t v21 = *(void *)(a2 + 24);
        *(void *)(a2 + 24) = v21 + 1;
      }
      while (v21 < v17);
      if (!*(unsigned char *)(a2 + 32) && !*(unsigned char *)(a2 + 37)) {
        return 0;
      }
    }
    return 4294951251;
  }
  return v16;
}

uint64_t ProcessID3HeaderTagFromAudioFileStream(uint64_t a1, unsigned int a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  CMBlockBufferRef theBuffer = 0;
  if (DerivedStorage[65]) {
    return 0;
  }
  uint64_t v5 = DerivedStorage;
  uint64_t outPropertyData = 0;
  if (DerivedStorage[66]) {
    goto LABEL_19;
  }
  if ((a2 & 0x80000000) != 0)
  {
    size_t v7 = -a2;
    memcpy(&__dst, (char *)DerivedStorage + 10 - v7 + 504, v7);
    memcpy((char *)&__dst + v7, (const void *)v5[40], 10 - v7);
    unint64_t v6 = v5[41];
  }
  else
  {
    unint64_t v6 = DerivedStorage[41] - a2;
    if (v6 < 0xA)
    {
      uint64_t v11 = 0;
      DerivedStorage[66] = v6;
      return v11;
    }
    size_t v7 = 0;
    uint64_t v8 = (uint64_t *)(DerivedStorage[40] + a2);
    __int16 v9 = *((_WORD *)v8 + 4);
    uint64_t __dst = *v8;
    __int16 v29 = v9;
  }
  HIDWORD(outPropertyData) = 4;
  uint64_t Property = AudioFormatGetProperty(0x69643373u, 0xAu, &__dst, (UInt32 *)&outPropertyData + 1, &outPropertyData);
  if (Property) {
    goto LABEL_29;
  }
  if (*((unsigned char *)v5 + 33))
  {
    uint64_t v11 = 0;
    v5[69] += outPropertyData;
    goto LABEL_32;
  }
  if (outPropertyData < 0xB)
  {
LABEL_19:
    uint64_t v11 = 0;
    goto LABEL_32;
  }
  unint64_t v12 = v6 + v7;
  if (v6 + v7 >= outPropertyData) {
    size_t v13 = outPropertyData;
  }
  else {
    size_t v13 = v6 + v7;
  }
  if (!v7)
  {
    uint64_t appended = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CMBlockBufferRef)v5[42], v5[43] + (int)a2, v13, 0, &theBuffer);
    goto LABEL_21;
  }
  uint64_t v14 = malloc_type_malloc(v7, 0x65D3CF0uLL);
  if (!v14)
  {
LABEL_36:
    uint64_t Property = FigSignalErrorAt();
    goto LABEL_29;
  }
  uint64_t v15 = v14;
  memcpy(v14, &__dst, v7);
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
  uint64_t Property = CMBlockBufferCreateWithMemoryBlock(v16, v15, v7, GlobalCFAllocatorFigMalloc, 0, 0, v7, 0, &theBuffer);
  if (!Property)
  {
    uint64_t appended = CMBlockBufferAppendBufferReference(theBuffer, (CMBlockBufferRef)v5[42], v5[43], v13 - v7, 0);
LABEL_21:
    uint64_t v11 = appended;
    if (appended) {
      goto LABEL_32;
    }
    uint64_t v19 = outPropertyData;
    if (v12 < outPropertyData)
    {
      uint64_t v20 = theBuffer;
      v5[65] = theBuffer;
      CMBlockBufferRef theBuffer = 0;
      v5[68] = v19;
      uint64_t v11 = 0;
      v5[67] = v19 - CMBlockBufferGetDataLength(v20);
      goto LABEL_32;
    }
    CMBlockBufferRef v21 = theBuffer;
    if (a2)
    {
      int v22 = malloc_type_malloc(0x18uLL, 0x102004062D53EE8uLL);
      if (v22)
      {
        int v23 = v22;
        if (v21) {
          CFTypeRef v24 = CFRetain(v21);
        }
        else {
          CFTypeRef v24 = 0;
        }
        uint64_t v11 = 0;
        v23[4] = 1768174368;
        v23[5] = a2;
        *(void *)int v23 = 0;
        *((void *)v23 + 1) = v24;
        *(void *)v5[59] = v23;
        v5[59] = v23;
        goto LABEL_32;
      }
      goto LABEL_36;
    }
    uint64_t Property = fim_PushMetaData(a1, theBuffer, 0x69643320u);
  }
LABEL_29:
  uint64_t v11 = Property;
LABEL_32:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return v11;
}

uint64_t fim_PushMetaData(uint64_t a1, void *a2, FourCharCode a3)
{
  char *returnedPointerOut;
  unsigned char temporaryBlock[4];
  size_t sampleSizeArray;
  CMTime duration;
  CMSampleBufferRef v45;
  CMSampleTimingInfo sampleTimingArray;
  uint64_t v47;

  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = DerivedStorage;
  uint64_t v45 = 0;
  sampleSizeArray = 0;
  if (a3 != 1768174368)
  {
    if (!*(void *)(DerivedStorage + 120))
    {
      if (a3 == 1768126752)
      {
        uint64_t v15 = *(const void **)(DerivedStorage + 448);
        if (v15) {
          CFRelease(v15);
        }
        if (a2) {
          CFTypeRef v16 = CFRetain(a2);
        }
        else {
          CFTypeRef v16 = 0;
        }
        uint64_t FormatDescriptionCallback = 0;
        *(void *)(v7 + 448) = v16;
        goto LABEL_63;
      }
      goto LABEL_26;
    }
    goto LABEL_10;
  }
  returnedPointerOut = 0;
  uint64_t v8 = CMBlockBufferAccessDataBytes((CMBlockBufferRef)a2, 0xAuLL, 4uLL, temporaryBlock, &returnedPointerOut);
  if (v8) {
    goto LABEL_72;
  }
  if (strncasecmp(returnedPointerOut, "PRIV", 4uLL)
    || CMBlockBufferAccessDataBytes((CMBlockBufferRef)a2, 0x14uLL, 0x2DuLL, &sampleTimingArray, &returnedPointerOut)
    || strcmp("com.apple.streaming.transportStreamTimestamp", returnedPointerOut)
    || (int64_t destination = 0, CMBlockBufferCopyDataBytes((CMBlockBufferRef)a2, 0x41uLL, 8uLL, &destination)))
  {
    if (!*(void *)(v7 + 120))
    {
LABEL_26:
      uint64_t v17 = *(const void **)(v7 + 456);
      if (v17) {
        CFRelease(v17);
      }
      if (a2) {
        CFTypeRef v18 = CFRetain(a2);
      }
      else {
        CFTypeRef v18 = 0;
      }
      uint64_t FormatDescriptionCallback = 0;
      *(void *)(v7 + 456) = v18;
      goto LABEL_63;
    }
LABEL_10:
    __int16 v9 = (CFAllocatorRef *)CMBaseObjectGetDerivedStorage();
    uint64_t v10 = (uint64_t)v9;
    if (a3 == 1768126752) {
      uint64_t v11 = 54;
    }
    else {
      uint64_t v11 = 55;
    }
    if (a3 == 1768126752) {
      unint64_t v12 = v9 + 54;
    }
    else {
      unint64_t v12 = v9 + 55;
    }
    if (v9[v11]) {
      goto LABEL_20;
    }
    uint64_t v8 = CMFormatDescriptionCreate(*v9, 0x6D657461u, a3, 0, v12);
    if (!v8)
    {
      size_t v13 = *(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v10 + 48);
      if (v13 && !*(_DWORD *)(v10 + 392))
      {
        uint64_t v19 = 101;
        *(_DWORD *)(v10 + 392) = 101;
        uint64_t v20 = *(void *)(v10 + 24);
        *(void *)(v10 + 24) = 0;
        if (v20 >= 1)
        {
          uint64_t v21 = v20;
          do
          {
            MEMORY[0x19970E2B0](*(void *)(v10 + 8));
            --v21;
          }
          while (v21);
          size_t v13 = *(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v10 + 48);
          uint64_t v19 = *(unsigned int *)(v10 + 392);
        }
        uint64_t FormatDescriptionCallback = v13(a1, *(void *)(v10 + 64), 1835365473, v19);
        do
        {
          MEMORY[0x19970E290](*(void *)(v10 + 8));
          uint64_t v22 = *(void *)(v10 + 24) + 1;
          *(void *)(v10 + 24) = v22;
        }
        while (v22 < v20);
        if (FormatDescriptionCallback) {
          goto LABEL_63;
        }
        if (*(unsigned char *)(v10 + 32) || *(unsigned char *)(v10 + 37))
        {
          uint64_t FormatDescriptionCallback = 4294951251;
LABEL_63:
          if (v45) {
            CFRelease(v45);
          }
          return FormatDescriptionCallback;
        }
        if (*(void *)(v10 + 400)) {
          int v23 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 400);
        }
        else {
          int v23 = 0;
        }
        uint64_t FormatDescriptionCallback = fim_MakeFormatDescriptionCallback(a1, v10, *(unsigned int *)(v10 + 392), v23, *(void *)(v10 + 424), *(void *)(v10 + v11 * 8), 0);
        goto LABEL_45;
      }
LABEL_20:
      uint64_t FormatDescriptionCallback = 0;
LABEL_45:
      CFTypeRef v24 = *(const opaqueCMFormatDescription **)(v10 + v11 * 8);
      if (v24) {
        BOOL v25 = FormatDescriptionCallback == 0;
      }
      else {
        BOOL v25 = 0;
      }
      if (!v25) {
        goto LABEL_63;
      }
      if (!*(void *)(v7 + 408))
      {
        uint64_t FormatDescriptionCallback = 0;
        goto LABEL_63;
      }
      fim_GetCurrentAudioTime(v7 + 72, &sampleTimingArray.duration);
      CMTime duration = sampleTimingArray.duration;
      uint64_t v26 = (_OWORD *)(v7 + 480);
      if (*(unsigned char *)(v7 + 492))
      {
        CMTime time1 = duration;
        *(_OWORD *)&time2.CMTimeValue value = *v26;
        time2.CMTimeEpoch epoch = *(void *)(v7 + 496);
        if (CMTimeCompare(&time1, &time2) <= 0)
        {
          *(_OWORD *)&duration.CMTimeValue value = *v26;
          duration.CMTimeEpoch epoch = *(void *)(v7 + 496);
        }
      }
      fim_AdjustPTS(v7, &duration);
      sampleTimingArray.decodeTimeStamp = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
      sampleTimingArray.CMTime presentationTimeStamp = duration;
      CMTimeMake(&sampleTimingArray.duration, 1, duration.timescale);
      sampleSizeArray = CMBlockBufferGetDataLength((CMBlockBufferRef)a2);
      uint64_t v8 = CMSampleBufferCreate(*(CFAllocatorRef *)v7, (CMBlockBufferRef)a2, 1u, 0, 0, v24, 1, 1, &sampleTimingArray, 1, &sampleSizeArray, &v45);
      if (!v8)
      {
        CMTime lhs = duration;
        CMTime rhs = sampleTimingArray.duration;
        CMTimeAdd(&v34, &lhs, &rhs);
        *uint64_t v26 = *(_OWORD *)&v34.value;
        *(void *)(v7 + 496) = v34.epoch;
        if (*(void *)(v7 + 408)) {
          unsigned __int16 v27 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void, opaqueCMSampleBuffer *))(v7 + 408);
        }
        else {
          unsigned __int16 v27 = 0;
        }
        uint64_t PushSampleBufferCallback = fim_MakePushSampleBufferCallback(a1, v7, *(unsigned int *)(v7 + 392), v27, *(void *)(v7 + 424), v45);
        uint64_t FormatDescriptionCallback = PushSampleBufferCallback;
        if (PushSampleBufferCallback) {
          *(_DWORD *)(v7 + 44) = PushSampleBufferCallback;
        }
        goto LABEL_63;
      }
    }
LABEL_72:
    uint64_t FormatDescriptionCallback = v8;
    goto LABEL_63;
  }
  int64_t v30 = bswap64(destination & 0xFFFFFFFF01000000);
  int64_t destination = v30;
  if (*(unsigned char *)(v7 + 273))
  {
    CMTime v39 = *(CMTime *)(v7 + 280);
    CMTimeMake(&v38, *(void *)(v7 + 136), (int)*(double *)(v7 + 192));
    CMTimeAdd(&duration, &v39, &v38);
    *(_OWORD *)&v34.CMTimeValue value = *(_OWORD *)&duration.timescale;
    CMTime time = duration;
    CMTimeConvertScale(&duration, &time, 90000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    unint64_t v31 = ((destination - duration.value) << 31 >> 63) & 0xFFFFFFFE00000000 | (destination - duration.value) & 0x1FFFFFFFFLL;
    if (v31 - 3 <= 0xFFFFFFFFFFFFFFFALL)
    {
      CMTimeMake(&duration, v31 + duration.value, 90000);
      *(CMTime *)(v7 + 280) = duration;
      *(void *)(v7 + 136) = 0;
      *(unsigned char *)(v7 + 274) = 1;
    }
  }
  else if (!*(void *)(v7 + 136))
  {
    *(unsigned char *)(v7 + 273) = 1;
    CMTimeMake(&duration, v30, 90000);
    *(CMTime *)(v7 + 280) = duration;
  }
  return 0;
}

double fim_GetCurrentAudioTime@<D0>(uint64_t a1@<X0>, CMTime *a2@<X8>)
{
  if (*(void *)(a1 + 48))
  {
    CMTimeMake(&v10, *(void *)(a1 + 64), (int)*(double *)(a1 + 120));
    *(void *)&long long v4 = v10.value;
    *(_OWORD *)&a2->CMTimeValue value = *(_OWORD *)&v10.value;
    CMTimeEpoch epoch = v10.epoch;
  }
  else
  {
    uint64_t v6 = MEMORY[0x1E4F1FA48];
    long long v4 = *MEMORY[0x1E4F1FA48];
    *(_OWORD *)&a2->CMTimeValue value = *MEMORY[0x1E4F1FA48];
    CMTimeEpoch epoch = *(void *)(v6 + 16);
  }
  a2->CMTimeEpoch epoch = epoch;
  if (*(unsigned char *)(a1 + 220))
  {
    CMTime lhs = *a2;
    CMTime v8 = *(CMTime *)(a1 + 208);
    CMTimeAdd(&v10, &lhs, &v8);
    *(void *)&long long v4 = v10.value;
    *a2 = v10;
  }
  return *(double *)&v4;
}

__n128 fim_AdjustPTS(uint64_t a1, CMTime *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  long long v4 = (__n128 *)(a1 + 576);
  if ((*(_DWORD *)(a1 + 588) & 0x1D) != 1)
  {
    uint64_t v5 = MEMORY[0x1E4F1FA48];
    __n128 result = *(__n128 *)MEMORY[0x1E4F1FA48];
    *long long v4 = *(__n128 *)MEMORY[0x1E4F1FA48];
    *(void *)(a1 + 592) = *(void *)(v5 + 16);
  }
  if (a2)
  {
    if ((a2->flags & 0x1D) == 1)
    {
      CMTime v22 = *a2;
      *(__n128 *)&v21.CMTimeValue value = *v4;
      v21.CMTimeEpoch epoch = *(void *)(a1 + 592);
      FigManifoldAdjustTimestampAndUpdateRefTime(&v21, &v22, v4);
      CMTimeValue value = a2->value;
      CMTimeFlags flags = a2->flags;
      CMTimeScale timescale = a2->timescale;
      CMTimeEpoch epoch = a2->epoch;
      CMTimeValue v31 = v22.value;
      CMTimeFlags v9 = v22.flags;
      CMTimeScale v32 = v22.timescale;
      CMTimeEpoch v10 = v22.epoch;
      if ((flags & 0x1F) != 3 && (v22.flags & 0x1F) != 3) {
        goto LABEL_8;
      }
      memset(&v30, 0, sizeof(v30));
      CMTimeValue v11 = a2->value;
      rhs.CMTimeEpoch epoch = v22.epoch;
      lhs.CMTimeValue value = v11;
      lhs.CMTimeScale timescale = a2->timescale;
      lhs.CMTimeFlags flags = flags;
      lhs.CMTimeEpoch epoch = epoch;
      *(_OWORD *)&rhs.CMTimeValue value = *(_OWORD *)&v22.value;
      CMTimeSubtract(&time, &lhs, &rhs);
      CMTimeAbsoluteValue(&v30, &time);
      CMTime time1 = v30;
      CMTimeMake(&time2, 1, 1000000000);
      if (CMTimeCompare(&time1, &time2) > 0)
      {
LABEL_8:
        v23.CMTimeEpoch epoch = v10;
        v24.CMTimeValue value = value;
        v24.CMTimeScale timescale = timescale;
        v24.CMTimeFlags flags = flags;
        v24.CMTimeEpoch epoch = epoch;
        v23.CMTimeValue value = v31;
        v23.CMTimeScale timescale = v32;
        v23.CMTimeFlags flags = v9;
        if (CMTimeCompare(&v24, &v23))
        {
          result.n128_u64[0] = v22.value;
          *a2 = v22;
        }
      }
    }
    unint64_t v12 = (_OWORD *)(a1 + 600);
    if ((*(_DWORD *)(a1 + 612) & 0x1D) != 1)
    {
      uint64_t v13 = MEMORY[0x1E4F1FA48];
      long long v14 = *MEMORY[0x1E4F1FA48];
      *unint64_t v12 = *MEMORY[0x1E4F1FA48];
      CMTimeEpoch v15 = *(void *)(v13 + 16);
      *(void *)(a1 + 616) = v15;
      CMTime v20 = *a2;
      *(_OWORD *)&v19.CMTimeValue value = v14;
      v19.CMTimeEpoch epoch = v15;
      if (CMTimeCompare(&v20, &v19) < 0)
      {
        CMTimeMake(&v30, 0x200000000, 90000);
        result.n128_u64[0] = v30.value;
        *unint64_t v12 = *(_OWORD *)&v30.value;
        *(void *)(a1 + 616) = v30.epoch;
      }
    }
    if ((a2->flags & 0x1D) == 1)
    {
      CMTime v18 = *a2;
      *(_OWORD *)&v17.CMTimeValue value = *v12;
      v17.CMTimeEpoch epoch = *(void *)(a1 + 616);
      CMTimeAdd(&v30, &v18, &v17);
      result.n128_u64[0] = v30.value;
      *a2 = v30;
    }
  }
  else if ((*(_DWORD *)(a1 + 612) & 0x1D) != 1)
  {
    uint64_t v16 = MEMORY[0x1E4F1FA48];
    __n128 result = *(__n128 *)MEMORY[0x1E4F1FA48];
    *(_OWORD *)(a1 + 600) = *MEMORY[0x1E4F1FA48];
    *(void *)(a1 + 616) = *(void *)(v16 + 16);
  }
  return result;
}

void appendAttributesToDictionary(const void *key, const void *value, CFMutableDictionaryRef theDict)
{
}

uint64_t FigStreamingLiveServerClockCreate(uint64_t a1, uint64_t a2, void *a3)
{
  CFTypeRef v13 = 0;
  if (a3)
  {
    CMClockGetHostTimeClock();
    CMTimeMake(&v12, 0, 1);
    uint64_t TimeCallback = FigDerivedClockCreateWithGetTimeCallback();
    if (TimeCallback)
    {
      if (v13) {
        CFRelease(v13);
      }
    }
    else
    {
      uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage();
      *(void *)uint64_t DerivedStorage = 0x3FF0000000000000;
      HostTimeClock = CMClockGetHostTimeClock();
      CMClockGetTime(&v11, HostTimeClock);
      long long v8 = *(_OWORD *)&v11.value;
      CMTimeEpoch epoch = v11.epoch;
      *(void *)(DerivedStorage + 24) = v11.epoch;
      *(_OWORD *)(DerivedStorage + 8) = v8;
      *(_OWORD *)(DerivedStorage + 32) = *(_OWORD *)(DerivedStorage + 8);
      *(void *)(DerivedStorage + 48) = epoch;
      *(void *)(DerivedStorage + 56) = a2;
      *(void *)(DerivedStorage + 64) = FigReentrantMutexCreate();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterAddWeakListener();
      uint64_t TimeCallback = 0;
      *a3 = v13;
    }
    return TimeCallback;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t fslscHandleRateDelta(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double v13 = 0.0;
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage();
  memset(&v12, 0, sizeof(v12));
  memset(&v11, 0, sizeof(v11));
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 64));
  if (a5)
  {
    fslscGetAnchorTime(a2, &v12, &v11);
    if (FigCFDictionaryGetDoubleIfPresent())
    {
      double v8 = v13;
    }
    else
    {
      if (!FigCFDictionaryGetDoubleIfPresent())
      {
LABEL_7:
        long long v9 = *(_OWORD *)&v12.value;
        *(void *)(DerivedStorage + 24) = v12.epoch;
        *(_OWORD *)(DerivedStorage + 8) = v9;
        *(CMTime *)(DerivedStorage + 32) = v11;
        return MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 64));
      }
      double v8 = v13 + *(double *)DerivedStorage;
    }
    *(double *)uint64_t DerivedStorage = v8;
    goto LABEL_7;
  }
  return MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 64));
}

CFStringRef fslscCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = (void *)FigDerivedClockGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v3, 0, @"LowLatencyServerClock(minder = %p, Rate = %f)", DerivedStorage[7], *DerivedStorage);
}

uint64_t fslscFinalize()
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  uint64_t result = *(void *)(DerivedStorage + 64);
  if (result)
  {
    return FigSimpleMutexDestroy();
  }
  return result;
}

BOOL fslscMightDrift()
{
  if (!FigDerivedClockVerifyCallbacksMatch()) {
    return 1;
  }
  if (!FigDerivedClockVerifyCallbacksMatch()) {
    return 1;
  }
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage();
  uint64_t v1 = FigDerivedClockGetDerivedStorage();
  uint64_t v2 = *(void *)(DerivedStorage + 56);
  if (!v2) {
    return 1;
  }
  uint64_t v3 = *(void *)(v1 + 56);
  if (v3) {
    BOOL v4 = v2 == v3;
  }
  else {
    BOOL v4 = 0;
  }
  return !v4;
}

double fslscGetRate()
{
  uint64_t DerivedStorage = (double *)FigDerivedClockGetDerivedStorage();
  MEMORY[0x19970E290](*((void *)DerivedStorage + 8));
  double v1 = *DerivedStorage;
  MEMORY[0x19970E2B0](*((void *)DerivedStorage + 8));
  return v1;
}

uint64_t fslscGetAnchorTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage();
  MEMORY[0x19970E290](*(void *)(DerivedStorage + 64));
  memset(&v13, 0, sizeof(v13));
  HostTimeClock = CMClockGetHostTimeClock();
  CMClockGetTime(&v13, HostTimeClock);
  if (a2)
  {
    CMTime lhs = v13;
    CMTime v9 = *(CMTime *)(DerivedStorage + 32);
    CMTimeSubtract(&time, &lhs, &v9);
    CMTimeMultiplyByFloat64(&rhs, &time, *(Float64 *)DerivedStorage);
    long long v7 = *(_OWORD *)(DerivedStorage + 8);
    v9.CMTimeEpoch epoch = *(void *)(DerivedStorage + 24);
    *(_OWORD *)&v9.CMTimeValue value = v7;
    CMTimeAdd(&lhs, &v9, &rhs);
    *a2 = lhs;
  }
  if (a3) {
    *a3 = v13;
  }
  MEMORY[0x19970E2B0](*(void *)(DerivedStorage + 64));
  return 0;
}

uint64_t FigContentKeySessionGetClassID()
{
  return sFigContentKeySessionClassID;
}

uint64_t RegisterFigContentKeySessionType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigContentKeySessionGetTypeID()
{
  MEMORY[0x19970EE10](&FigContentKeySessionGetClassID_sRegisterFigContentKeySessionTypeOnce, RegisterFigContentKeySessionType);

  return CMBaseClassGetCFTypeID();
}

uint64_t FigContentKeySessionCreateWithCallbacks(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  FigNote_AllowInternalDefaultLogs();
  fig_note_initialize_category_with_default_work_cf();
  fig_note_initialize_category_with_default_work_cf();
  if (!a6
    || (*a6 = 0,
        MEMORY[0x19970EE10](&FigContentKeySessionGetClassID_sRegisterFigContentKeySessionTypeOnce, RegisterFigContentKeySessionType), uint64_t v7 = CMDerivedObjectCreate(), !v7))
  {
    uint64_t v7 = FigSignalErrorAt();
  }
  uint64_t v10 = v7;
  if (dword_1E9350AD0)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return v10;
}

uint64_t FigContentKeySessionCreate(uint64_t a1, void *a2)
{
  return FigContentKeySessionCreateWithCallbacks(a1, 0, 0, 0, 0, a2);
}

CFStringRef FigContentKeySessionCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigContentKeySession %p]", a1);
}

uint64_t fcks_invalidate()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (dword_1E9350AD0)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
  if (!*(unsigned char *)DerivedStorage)
  {
    uint64_t v2 = *(void *)(DerivedStorage + 16);
    if (v2)
    {
      uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v3) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t v5 = *(void (**)(uint64_t))(v4 + 24);
      if (v5) {
        v5(v2);
      }
    }
    *(unsigned char *)uint64_t DerivedStorage = 1;
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 40));
  return 0;
}

uint64_t fcks_finalize(const void *a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](DerivedStorage[5]);
  fcks_freeAllCryptorEntries(a1);
  fcks_removeListenersForSecureStopGenerationOnDefaultManager((uint64_t)a1);
  if (a1 && DerivedStorage[21])
  {
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
  }
  uint64_t v3 = (const void *)DerivedStorage[1];
  if (v3)
  {
    CFRelease(v3);
    DerivedStorage[1] = 0;
  }
  uint64_t v4 = (const void *)DerivedStorage[2];
  if (v4)
  {
    CFRelease(v4);
    DerivedStorage[2] = 0;
  }
  uint64_t v5 = (const void *)DerivedStorage[3];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[3] = 0;
  }
  uint64_t v6 = (const void *)DerivedStorage[4];
  if (v6)
  {
    CFRelease(v6);
    DerivedStorage[4] = 0;
  }
  uint64_t v7 = (const void *)DerivedStorage[6];
  if (v7)
  {
    CFRelease(v7);
    DerivedStorage[6] = 0;
  }
  double v8 = DerivedStorage[8];
  if (v8)
  {
    dispatch_release(v8);
    DerivedStorage[8] = 0;
  }
  CMTime v9 = (const void *)DerivedStorage[15];
  if (v9)
  {
    CFRelease(v9);
    DerivedStorage[15] = 0;
  }
  uint64_t v10 = (const void *)DerivedStorage[18];
  if (v10)
  {
    CFRelease(v10);
    DerivedStorage[18] = 0;
  }
  uint64_t v11 = (const void *)DerivedStorage[19];
  if (v11)
  {
    CFRelease(v11);
    DerivedStorage[19] = 0;
  }
  CMTime v12 = (const void *)DerivedStorage[20];
  if (v12)
  {
    CFRelease(v12);
    DerivedStorage[20] = 0;
  }
  CMTime v13 = (const void *)DerivedStorage[21];
  if (v13)
  {
    CFRelease(v13);
    DerivedStorage[21] = 0;
  }
  long long v14 = (const void *)DerivedStorage[22];
  if (v14)
  {
    CFRelease(v14);
    DerivedStorage[22] = 0;
  }
  MEMORY[0x19970E930](DerivedStorage[5]);

  return FigSimpleMutexDestroy();
}

__CFString *fcks_copyDebugDescription(const void *a1)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v3, 0);
  CFIndex v5 = CFGetRetainCount(a1);
  if (*DerivedStorage) {
    uint64_t v6 = " (invalidated)";
  }
  else {
    uint64_t v6 = "";
  }
  CFAllocatorRef v7 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<FigContentKeySession %p retainCount: %ld%s allocator: %p, ", a1, v5, v6, v7);
  CFStringAppendFormat(Mutable, 0, @">");
  return Mutable;
}

uint64_t fcks_copyProperty(const void *a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2 || !a4)
  {
    return FigSignalErrorAt();
  }
  uint64_t v9 = DerivedStorage;
  *a4 = 0;
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
  if (*(unsigned char *)v9) {
    goto LABEL_38;
  }
  if (CFEqual((CFTypeRef)*MEMORY[0x1E4F1FC78], a2))
  {
    uint64_t v10 = *(void *)(v9 + 16);
    if (!v10)
    {
      uint64_t v14 = 0;
      goto LABEL_45;
    }
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v11) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0;
    }
    CMTimeEpoch v15 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, void *))(v12 + 48);
    if (!v15)
    {
      uint64_t v14 = 4294954514;
      goto LABEL_45;
    }
    uint64_t v16 = v15(v10, @"SessionID", a3, a4);
LABEL_15:
    uint64_t v14 = v16;
    goto LABEL_45;
  }
  if (CFEqual((CFTypeRef)*MEMORY[0x1E4F1FC70], a2))
  {
    if (!*(void *)(v9 + 16)) {
      goto LABEL_41;
    }
LABEL_10:
    CMTime v13 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
    goto LABEL_42;
  }
  if (CFEqual(@"kFigCKSPropertyKey_SecureStopManager", a2))
  {
    uint64_t v16 = fcks_ensureSecureStopManager(a1);
    if (!v16)
    {
      CFTypeRef v17 = *(CFTypeRef *)(v9 + 168);
      if (v17) {
        goto LABEL_43;
      }
      goto LABEL_44;
    }
    goto LABEL_15;
  }
  if (!CFEqual(@"kFigCKSPropertyKey_ShouldProvideFPSSecureStop", a2))
  {
LABEL_38:
    uint64_t v16 = FigSignalErrorAt();
    goto LABEL_15;
  }
  uint64_t v18 = CMBaseObjectGetDerivedStorage();
  uint64_t v19 = *(void *)(v18 + 152);
  LODWORD(v20) = v19 != 0;
  CFArrayRef v21 = *(const __CFArray **)(v18 + 8);
  if (!v21 || (Count = CFArrayGetCount(v21), v19) || (CFIndex v23 = Count, Count < 1))
  {
LABEL_36:
    if (!v20) {
      goto LABEL_41;
    }
    goto LABEL_10;
  }
  uint64_t v24 = *MEMORY[0x1E4F1CF80];
  CFTypeRef v25 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
  uint64_t v26 = 1;
  while (1)
  {
    CFArrayGetValueAtIndex(*(CFArrayRef *)(v18 + 8), v26 - 1);
    CMTime v20 = (const void *)FigCFWeakReferenceHolderCopyReferencedObject();
    if (!v20) {
      goto LABEL_34;
    }
    CFTypeRef cf = 0;
    uint64_t v27 = *(void *)(CMBaseObjectGetVTable() + 8);
    uint64_t v28 = v27 ? v27 : 0;
    __int16 v29 = *(uint64_t (**)(const void *, __CFString *, uint64_t, CFTypeRef *))(v28 + 48);
    if (!v29) {
      break;
    }
    int v30 = v29(v20, @"kFigCKSPropertyKey_ShouldProvideFPSSecureStop", v24, &cf);
    CFRelease(v20);
    if (v30) {
      goto LABEL_40;
    }
    LODWORD(v20) = v25 == cf;
    if (cf) {
      CFRelease(cf);
    }
LABEL_34:
    if (!v20 && v26++ < v23) {
      continue;
    }
    goto LABEL_36;
  }
  CFRelease(v20);
LABEL_40:
  FigSignalErrorAt();
LABEL_41:
  CMTime v13 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
LABEL_42:
  CFTypeRef v17 = *v13;
LABEL_43:
  CFTypeRef v17 = CFRetain(v17);
LABEL_44:
  uint64_t v14 = 0;
  *a4 = v17;
LABEL_45:
  MEMORY[0x19970E930](*(void *)(v9 + 40));
  return v14;
}

uint64_t fcks_setProperty(const void *a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2 && a3)
  {
    uint64_t v7 = DerivedStorage;
    MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
    if (*(unsigned char *)v7) {
      goto LABEL_42;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F1FC68]))
    {
      CFTypeID v8 = CFGetTypeID(a3);
      if (v8 == CFDataGetTypeID())
      {
        if (!FigCFEqual())
        {
          uint64_t v9 = *(const void **)(v7 + 48);
          *(void *)(v7 + 48) = a3;
          CFRetain(a3);
          if (v9) {
            CFRelease(v9);
          }
          fcks_resetSessionGuts(a1);
          CFArrayRef v10 = *(const __CFArray **)(CMBaseObjectGetDerivedStorage() + 8);
          if (v10)
          {
            CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v10);
            if (Copy)
            {
              CFArrayRef v12 = Copy;
              CFIndex Count = CFArrayGetCount(Copy);
              if (Count < 1)
              {
LABEL_16:
                uint64_t v18 = 0;
              }
              else
              {
                CFIndex v14 = Count;
                CFIndex v15 = 0;
                while (1)
                {
                  CFArrayGetValueAtIndex(v12, v15);
                  uint64_t v16 = FigCFWeakReferenceHolderCopyReferencedObject();
                  if (v16)
                  {
                    CFTypeRef v17 = (const void *)v16;
                    uint64_t v18 = fcks_setClientAuditTokenForChildSession((uint64_t)a1, v16, (uint64_t)a3);
                    CFRelease(v17);
                    if (v18) {
                      break;
                    }
                  }
                  if (v14 == ++v15) {
                    goto LABEL_16;
                  }
                }
              }
              CFRelease(v12);
              goto LABEL_41;
            }
            goto LABEL_42;
          }
        }
        goto LABEL_40;
      }
LABEL_42:
      uint64_t v25 = FigSignalErrorAt();
LABEL_46:
      uint64_t v18 = v25;
      goto LABEL_41;
    }
    if (CFEqual(a2, @"kFigCKSPropertyKey_SendToNero"))
    {
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(a3))
      {
        CFDictionaryGetValue((CFDictionaryRef)a3, @"kFigCKSPropertyKeySendToNero_Visuals");
        int v20 = FigCFEqual();
        if (v20 != *(unsigned __int8 *)(v7 + 56))
        {
          *(unsigned char *)(v7 + 56) = v20;
          if (v20)
          {
            CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)a3, @"kFigCKSPropertyKeySendToNero_NeroTransport");
            if (Value)
            {
              CMTime v22 = *(const void **)(v7 + 144);
              *(void *)(v7 + 144) = Value;
              CFRetain(Value);
              if (v22) {
                CFRelease(v22);
              }
            }
          }
          else
          {
            CMTimeScale v32 = *(const void **)(v7 + 144);
            if (v32)
            {
              CFRelease(v32);
              *(void *)(v7 + 144) = 0;
            }
          }
          fcks_resetSessionGuts(a1);
        }
      }
    }
    else
    {
      if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F1FC60]))
      {
        if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F1FC80]))
        {
          CFTypeID v31 = CFGetTypeID(a3);
          if (v31 == CFBooleanGetTypeID())
          {
            uint64_t v18 = 0;
            *(unsigned char *)(v7 + 184) = *MEMORY[0x1E4F1CFD0] == (void)a3;
LABEL_41:
            MEMORY[0x19970E930](*(void *)(v7 + 40));
            return v18;
          }
        }
        goto LABEL_42;
      }
      CFTypeID v23 = CFGetTypeID(a3);
      if (v23 != CFDataGetTypeID()) {
        goto LABEL_42;
      }
      if (!*(void *)(v7 + 160)) {
        goto LABEL_30;
      }
      if (!FigCFEqual()) {
        goto LABEL_42;
      }
      if (!*(void *)(v7 + 160))
      {
LABEL_30:
        *(void *)(v7 + 160) = CFRetain(a3);
        if (*(void *)(v7 + 152))
        {
          uint64_t v24 = (void *)CMBaseObjectGetDerivedStorage();
          uint64_t v25 = fcks_ensureSecureStopManager(a1);
          if (!v25)
          {
            uint64_t v27 = v24[20];
            uint64_t v26 = v24[21];
            uint64_t v28 = v24[19];
            uint64_t v29 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v29) {
              uint64_t v30 = v29;
            }
            else {
              uint64_t v30 = 0;
            }
            CMTime v34 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v30 + 8);
            if (!v34)
            {
              uint64_t v18 = 4294954514;
              goto LABEL_41;
            }
            uint64_t v25 = v34(v26, v27, v28);
          }
          goto LABEL_46;
        }
      }
    }
LABEL_40:
    uint64_t v18 = 0;
    goto LABEL_41;
  }

  return FigSignalErrorAt();
}

void fcks_freeAllCryptorEntries(const void *a1)
{
  uint64_t v2 = *(void *)(CMBaseObjectGetDerivedStorage() + 128);
  if (v2)
  {
    do
    {
      uint64_t v3 = *(void *)(v2 + 8);
      fcks_freeCryptorEntry(a1, v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t fcks_removeListenersForSecureStopGenerationOnDefaultManager(uint64_t a1)
{
  CFTypeRef cf = 0;
  if (!a1) {
    return 0;
  }
  uint64_t v1 = FigSecureStopManagerCopyDefaultRuntimeInstance(*MEMORY[0x1E4F1CF80], &cf);
  if (v1) {
    goto LABEL_5;
  }
  if (!cf) {
    return 0;
  }
  CMNotificationCenterGetDefaultLocalCenter();
  uint64_t v1 = FigNotificationCenterRemoveWeakListener();
LABEL_5:
  uint64_t v2 = v1;
  if (cf) {
    CFRelease(cf);
  }
  return v2;
}

void fcks_freeCryptorEntry(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = FigCFWeakReferenceHolderCopyReferencedObject();
  uint64_t v6 = (const void *)v5;
  if (a1 && v5)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    if (!FigNotificationCenterRemoveWeakListener())
    {
      CMNotificationCenterGetDefaultLocalCenter();
      if (!FigNotificationCenterRemoveWeakListener())
      {
        CMNotificationCenterGetDefaultLocalCenter();
        if (!FigNotificationCenterRemoveWeakListener())
        {
          CMNotificationCenterGetDefaultLocalCenter();
          FigNotificationCenterRemoveWeakListener();
        }
      }
    }
    goto LABEL_7;
  }
  if (v5) {
LABEL_7:
  }
    CFRelease(v6);
  if (*(void *)a2)
  {
    CFRelease(*(CFTypeRef *)a2);
    *(void *)a2 = 0;
  }
  uint64_t v7 = *(void *)(a2 + 8);
  CFTypeID v8 = *(void **)(a2 + 16);
  if (v7)
  {
    *(void *)(v7 + 16) = v8;
    CFTypeID v8 = *(void **)(a2 + 16);
  }
  else
  {
    *(void *)(DerivedStorage + 136) = v8;
  }
  *CFTypeID v8 = v7;
  CFAllocatorRef v9 = CFGetAllocator(a1);

  CFAllocatorDeallocate(v9, (void *)a2);
}

void fcks_persistentKeyUpdatedCallback(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, const __CFDictionary *a5)
{
  if (!a5) {
    return;
  }
  CFTypeRef v6 = a4;
  CFDictionaryRef theDict = 0;
  if (a4)
  {
    uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v8) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = 0;
    }
    CFArrayRef v10 = *(uint64_t (**)(CFTypeRef, void, void, CFDictionaryRef *))(v9 + 48);
    if (!v10) {
      return;
    }
    int v11 = v10(v6, *MEMORY[0x1E4F1FD90], *MEMORY[0x1E4F1CF80], &theDict);
    CFDictionaryRef v12 = theDict;
    if (v11)
    {
      CFTypeRef v6 = 0;
      if (theDict) {
LABEL_12:
      }
        CFRelease(v12);
    }
    else
    {
      CFDictionaryRef Value = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F1FC10]);
      if (Value) {
        CFTypeRef v6 = CFRetain(Value);
      }
      else {
        CFTypeRef v6 = 0;
      }
      CFDictionaryRef v12 = theDict;
      if (theDict) {
        goto LABEL_12;
      }
    }
  }
  else
  {
    int v11 = FigSignalErrorAt();
  }
  if (!v11)
  {
    CFIndex v14 = CFDictionaryGetValue(a5, (const void *)*MEMORY[0x1E4F1FD68]);
    if (v14)
    {
      CFTypeRef v15 = CFRetain(v14);
      if (v15)
      {
        uint64_t v16 = v15;
        uint64_t v17 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v17) {
          uint64_t v18 = v17;
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = *(void (**)(uint64_t, CFTypeRef, const void *))(v18 + 48);
        if (v19) {
          v19(a2, v6, v16);
        }
        goto LABEL_23;
      }
    }
    FigSignalErrorAt();
  }
  uint64_t v16 = 0;
LABEL_23:
  if (v6) {
    CFRelease(v6);
  }
  if (v16) {
    CFRelease(v16);
  }
}

void fcks_keyResponseErrorOccurredCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  CFTypeRef cf = 0;
  if (!a5) {
    return;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  CFArrayRef v10 = *(unsigned int (**)(uint64_t, void, void, CFTypeRef *))(v9 + 48);
  if (v10 && !v10(a4, *MEMORY[0x1E4F1FE10], *MEMORY[0x1E4F1CF80], &cf))
  {
    if (FigCFDictionaryGetInt64IfPresent())
    {
      CFDictionaryRef Value = CFDictionaryGetValue(a5, (const void *)*MEMORY[0x1E4F1FD08]);
      if (Value)
      {
        CFTypeRef v12 = CFRetain(Value);
        if (v12)
        {
          CMTime v13 = v12;
          CFTypeRef v14 = cf;
          uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v15) {
            uint64_t v16 = v15;
          }
          else {
            uint64_t v16 = 0;
          }
          uint64_t v17 = *(void (**)(uint64_t, CFTypeRef, void, const void *))(v16 + 32);
          if (v17) {
            v17(a2, v14, 0, v13);
          }
          goto LABEL_14;
        }
      }
    }
    FigSignalErrorAt();
  }
  CMTime v13 = 0;
LABEL_14:
  if (cf) {
    CFRelease(cf);
  }
  if (v13) {
    CFRelease(v13);
  }
}

void fcks_keyResponseSuccessfullyProcessedCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFTypeRef cf = 0;
  if (a5)
  {
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(unsigned int (**)(uint64_t, void, void, CFTypeRef *))(v8 + 48);
    if (v9 && !v9(a4, *MEMORY[0x1E4F1FE10], *MEMORY[0x1E4F1CF80], &cf))
    {
      if (FigCFDictionaryGetInt64IfPresent())
      {
        CFTypeRef v10 = cf;
        uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v11) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = 0;
        }
        CMTime v13 = *(void (**)(uint64_t, CFTypeRef, void))(v12 + 40);
        if (v13) {
          v13(a2, v10, 0);
        }
      }
      else
      {
        FigSignalErrorAt();
      }
    }
    if (cf) {
      CFRelease(cf);
    }
  }
}

void fcks_externalProtectionStateChangedCallback(int a1, int a2, int a3, CFTypeRef cf, uint64_t a5)
{
  CFTypeRef cfa = 0;
  if (a5)
  {
    if (cf && (CFTypeID v5 = CFGetTypeID(cf), v5 == FigCPECryptorGetTypeID())) {
      FigCFDictionaryGetInt32IfPresent();
    }
    else {
      FigSignalErrorAt();
    }
  }
}

uint64_t fcks_secureStopDidFinalizeRecordCallback(uint64_t a1, uint64_t a2)
{
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v6 = *(void *)(VTable + 16);
  uint64_t result = VTable + 16;
  uint64_t v5 = v6;
  if (v6) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t))(v7 + 56);
  if (v8)
  {
    return v8(a2);
  }
  return result;
}

uint64_t fcks_ensureSecureStopManager(const void *a1)
{
  uint64_t v2 = (void *)(CMBaseObjectGetDerivedStorage() + 168);
  if (*v2) {
    return 0;
  }
  CFAllocatorRef v3 = CFGetAllocator(a1);
  uint64_t result = FigSecureStopManagerCreate((uint64_t)v3, v2);
  if (!result)
  {
    if (!a1
      || !*v2
      || (CMNotificationCenterGetDefaultLocalCenter(), uint64_t result = FigNotificationCenterAddWeakListener(), !result))
    {
      return fcks_removeListenersForSecureStopGenerationOnDefaultManager((uint64_t)a1);
    }
  }
  return result;
}

void fcks_resetSessionGuts(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  fcks_freeAllCryptorEntries(a1);
  CFAllocatorRef v3 = *(const void **)(DerivedStorage + 16);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(DerivedStorage + 16) = 0;
  }
  uint64_t v4 = *(const void **)(DerivedStorage + 24);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(DerivedStorage + 24) = 0;
  }
}

uint64_t fcks_setClientAuditTokenForChildSession(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 40));
  if (FigCFEqual())
  {
    uint64_t v6 = 0;
    goto LABEL_15;
  }
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t))(v8 + 24);
  if (v9)
  {
    uint64_t v10 = v9(a2);
    if (v10)
    {
LABEL_13:
      uint64_t v6 = v10;
      goto LABEL_15;
    }
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v11) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0;
    }
    CMTime v13 = *(uint64_t (**)(uint64_t, void, uint64_t))(v12 + 56);
    if (v13)
    {
      uint64_t v10 = v13(a2, *MEMORY[0x1E4F1FC68], a3);
      goto LABEL_13;
    }
  }
  uint64_t v6 = 4294954514;
LABEL_15:
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
  if (!*(unsigned char *)DerivedStorage) {
    return v6;
  }

  return FigSignalErrorAt();
}

uint64_t fcks_addChildSession(const void *a1, uint64_t a2)
{
  cf[22] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  cf[0] = 0;
  if (a2 && a1 != (const void *)a2)
  {
    uint64_t v5 = DerivedStorage;
    MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
    if (!*(unsigned char *)v5)
    {
      uint64_t v6 = fcks_setClientAuditTokenForChildSession((uint64_t)a1, a2, *(void *)(v5 + 48));
      if (v6) {
        goto LABEL_25;
      }
      CFAllocatorRef v7 = CFGetAllocator(a1);
      uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v8) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = 0;
      }
      uint64_t v10 = *(uint64_t (**)(uint64_t, __CFString *, CFAllocatorRef, CFTypeRef *))(v9 + 48);
      if (!v10)
      {
        uint64_t v15 = 4294954514;
        goto LABEL_17;
      }
      uint64_t v6 = v10(a2, @"kFigCKSPropertyKey_SecureStopManager", v7, cf);
      if (v6)
      {
LABEL_25:
        uint64_t v15 = v6;
        goto LABEL_17;
      }
      uint64_t v11 = *(const void **)(v5 + 168);
      CFTypeRef v12 = cf[0];
      *(CFTypeRef *)(v5 + 168) = cf[0];
      if (v12) {
        CFRetain(v12);
      }
      if (v11) {
        CFRelease(v11);
      }
      CMTime v13 = (const void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
      if (v13)
      {
        CFTypeRef v14 = v13;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 8), v13);
        CFRelease(v14);
        uint64_t v15 = 0;
LABEL_17:
        MEMORY[0x19970E930](*(void *)(v5 + 40));
        goto LABEL_18;
      }
    }
    uint64_t v6 = FigSignalErrorAt();
    goto LABEL_25;
  }
  uint64_t v15 = FigSignalErrorAt();
LABEL_18:
  if (dword_1E9350AD0)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  return v15;
}

uint64_t fcks_copyCryptor(const void *a1, const __CFAllocator *a2, const __CFDictionary *a3, int a4, CFTypeRef *a5)
{
  cf[16] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a3 || !a5)
  {
    return FigSignalErrorAt();
  }
  uint64_t v10 = DerivedStorage;
  int v100 = a4;
  *a5 = 0;
  uint64_t v11 = (const void *)*MEMORY[0x1E4F1FC40];
  int v12 = CFDictionaryContainsKey(a3, (const void *)*MEMORY[0x1E4F1FC40]);
  CMTime v13 = (const void **)MEMORY[0x1E4F1FC30];
  uint64_t v103 = (uint64_t)a3;
  if (v12 || CFDictionaryContainsKey(a3, (const void *)*MEMORY[0x1E4F1FC30]))
  {
    MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(a2, 0, a3);
    if (!MutableCopy)
    {
      uint64_t v26 = FigSignalErrorAt();
      CFDictionaryRef v20 = 0;
      if (v26) {
        goto LABEL_153;
      }
      goto LABEL_31;
    }
    uint64_t v15 = MutableCopy;
    if (CFDictionaryContainsKey(MutableCopy, (const void *)*MEMORY[0x1E4F1FC28]))
    {
      CFTypeRef v16 = 0;
      goto LABEL_15;
    }
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a3, v11);
    uint64_t v18 = (const opaqueCMFormatDescription *)CFDictionaryGetValue(a3, *v13);
    cf[0] = 0;
    if (v18)
    {
      uint64_t v19 = PKDCopyDecryptFormatTypeFromFormatDescription(v18, cf);
      if (v19)
      {
LABEL_183:
        uint64_t v26 = v19;
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        CFDictionaryRef v20 = 0;
        goto LABEL_29;
      }
    }
    else if (Value)
    {
      uint64_t v19 = PKDCopyDecryptFormatTypeFromSinfArray(Value, cf);
      if (v19) {
        goto LABEL_183;
      }
    }
    CFTypeRef v16 = cf[0];
    FigCFDictionarySetValue();
LABEL_15:
    if (!CFDictionaryContainsKey(a3, v11))
    {
      CFTypeRef v23 = 0;
      CFTypeRef v25 = 0;
LABEL_22:
      CFDictionaryRemoveValue(v15, v11);
      CFDictionaryRemoveValue(v15, *v13);
      uint64_t v26 = 0;
      CFDictionaryRef v20 = v15;
      uint64_t v15 = 0;
      if (!v16) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
    CFArrayRef v21 = (const __CFArray *)CFDictionaryGetValue(a3, v11);
    cf[0] = 0;
    if (v21)
    {
      uint64_t v22 = PKDCopyDefaultKeyIDFromSinfArray(v21, (CFDataRef *)cf);
      CFTypeRef v23 = cf[0];
      if (v22)
      {
        uint64_t v26 = v22;
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        CFDictionaryRef v20 = 0;
        CFTypeRef v23 = 0;
        goto LABEL_173;
      }
      cf[0] = 0;
      if (v23)
      {
        uint64_t Base64EncodedStringFromCFData = FigCreateBase64EncodedStringFromCFData();
        CFTypeRef v25 = cf[0];
        if (!Base64EncodedStringFromCFData)
        {
LABEL_20:
          FigCFDictionarySetValue();
          goto LABEL_22;
        }
        uint64_t v26 = Base64EncodedStringFromCFData;
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        CFDictionaryRef v20 = 0;
LABEL_173:
        CFTypeRef v25 = 0;
        if (!v16)
        {
LABEL_24:
          if (v23) {
            CFRelease(v23);
          }
          if (v25) {
            CFRelease(v25);
          }
          if (!v15)
          {
LABEL_30:
            if (v26) {
              goto LABEL_153;
            }
            goto LABEL_31;
          }
LABEL_29:
          CFRelease(v15);
          goto LABEL_30;
        }
LABEL_23:
        CFRelease(v16);
        goto LABEL_24;
      }
    }
    else
    {
      CFTypeRef v23 = 0;
    }
    CFTypeRef v25 = 0;
    goto LABEL_20;
  }
  CFDictionaryRef v20 = (const __CFDictionary *)CFRetain(a3);
LABEL_31:
  MEMORY[0x19970E910](*(void *)(v10 + 40));
  if (*(unsigned char *)v10)
  {
    uint64_t v26 = FigSignalErrorAt();
    goto LABEL_161;
  }
  uint64_t v27 = CMBaseObjectGetDerivedStorage();
  *(void *)uint64_t v108 = 0;
  LOBYTE(v105) = 0;
  *a5 = 0;
  FigCFDictionaryGetBooleanIfPresent();
  if ((_BYTE)v105)
  {
    if (*(void *)(v27 + 24))
    {
      uint64_t v28 = FigCFWeakReferenceHolderCopyReferencedObject();
      *(void *)uint64_t v108 = v28;
      if (v28)
      {
        uint64_t v29 = (const void *)v28;
        uint64_t v26 = 0;
        goto LABEL_73;
      }
    }
  }
  CFArrayRef v30 = *(const __CFArray **)(v27 + 8);
  if (!v30)
  {
    uint64_t v26 = 0;
LABEL_56:
    uint64_t v42 = CMBaseObjectGetDerivedStorage();
    cf[0] = 0;
    uint64_t v43 = *(void *)(v42 + 128);
    if (v43)
    {
      uint64_t v44 = *MEMORY[0x1E4F1FD90];
      uint64_t v45 = *MEMORY[0x1E4F1CF80];
      do
      {
        uint64_t v46 = v43;
        uint64_t v43 = *(void *)(v43 + 8);
        uint64_t v47 = FigCFWeakReferenceHolderCopyReferencedObject();
        if (v47)
        {
          uint64_t v29 = (const void *)v47;
          uint64_t v48 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v48) {
            uint64_t v49 = v48;
          }
          else {
            uint64_t v49 = 0;
          }
          uint64_t v50 = *(unsigned int (**)(const void *, uint64_t, uint64_t, CFTypeRef *))(v49 + 48);
          if (v50 && !v50(v29, v44, v45, cf) && FigCFEqual()) {
            goto LABEL_70;
          }
          CFRelease(v29);
          if (cf[0])
          {
            CFRelease(cf[0]);
            cf[0] = 0;
          }
        }
        else
        {
          fcks_freeCryptorEntry(a1, v46);
        }
      }
      while (v43);
      uint64_t v29 = 0;
LABEL_70:
      if (cf[0]) {
        CFRelease(cf[0]);
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
LABEL_73:
    *a5 = v29;
    goto LABEL_74;
  }
  CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v30);
  if (!Copy)
  {
    uint64_t v26 = FigSignalErrorAt();
    goto LABEL_74;
  }
  CFArrayRef v32 = Copy;
  MEMORY[0x19970E930](*(void *)(v27 + 40));
  CFIndex Count = CFArrayGetCount(v32);
  if (Count < 1)
  {
LABEL_51:
    uint64_t v26 = 0;
    goto LABEL_54;
  }
  CFIndex v34 = Count;
  uint64_t v35 = 1;
  while (1)
  {
    CFArrayGetValueAtIndex(v32, v35 - 1);
    uint64_t v36 = FigCFWeakReferenceHolderCopyReferencedObject();
    if (v36) {
      break;
    }
LABEL_47:
    if (*(void *)v108) {
      BOOL v41 = 0;
    }
    else {
      BOOL v41 = v35 < v34;
    }
    ++v35;
    if (!v41) {
      goto LABEL_51;
    }
  }
  CMBlockBufferRef v37 = (const void *)v36;
  uint64_t v38 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v38) {
    uint64_t v39 = v38;
  }
  else {
    uint64_t v39 = 0;
  }
  uint64_t v40 = *(uint64_t (**)(const void *, void, const __CFDictionary *, void, unsigned char *))(v39 + 16);
  if (v40)
  {
    uint64_t v26 = v40(v37, 0, v20, 0, v108);
    CFRelease(v37);
    if (v26 && v26 != -17293) {
      goto LABEL_54;
    }
    goto LABEL_47;
  }
  CFRelease(v37);
  uint64_t v26 = 4294954514;
LABEL_54:
  CFRelease(v32);
  MEMORY[0x19970E910](*(void *)(v27 + 40));
  if (!*(unsigned char *)v27)
  {
    uint64_t v29 = *(const void **)v108;
    if (!*(void *)v108) {
      goto LABEL_56;
    }
    goto LABEL_73;
  }
  uint64_t v26 = FigSignalErrorAt();
LABEL_74:
  if (v26) {
    goto LABEL_161;
  }
  if (!v100 || *a5)
  {
    PKDLogPrivateData(v103);
    int v69 = (const void *)FigCFCopyCompactDescription();
    if (dword_1E9350AD0)
    {
      LODWORD(v105) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      goto LABEL_149;
    }
LABEL_150:
    MEMORY[0x19970E930](*(void *)(v10 + 40));
    if (v69) {
      CFRelease(v69);
    }
    uint64_t v26 = 0;
    goto LABEL_153;
  }
  *(_DWORD *)type = 1;
  char v106 = 0;
  CFTypeRef v105 = 0;
  uint64_t v51 = CMBaseObjectGetDerivedStorage();
  uint64_t v52 = CFDictionaryGetValue(v20, (const void *)*MEMORY[0x1E4F1FC38]);
  uint64_t v99 = v10;
  if (!v52) {
    goto LABEL_164;
  }
  CMBlockBufferRef v53 = v52;
  CFStringRef v54 = *(const void **)(v51 + 32);
  if (!v54) {
    goto LABEL_81;
  }
  if (!CFEqual(v52, v54))
  {
LABEL_164:
    uint64_t v26 = FigSignalErrorAt();
    uint64_t v58 = 0;
LABEL_188:
    CFDictionaryRef v65 = 0;
    CMBlockBufferRef v60 = 0;
    goto LABEL_134;
  }
  if (!*(void *)(v51 + 32)) {
LABEL_81:
  }
    *(void *)(v51 + 32) = CFRetain(v53);
  int v55 = CFDictionaryGetValue(v20, (const void *)*MEMORY[0x1E4F1FC28]);
  uint64_t v56 = v55;
  CFAllocatorRef v57 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (*(void *)(v51 + 16))
  {
    uint64_t v58 = 0;
    goto LABEL_84;
  }
  uint64_t v102 = v55;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v57, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v58 = Mutable;
  if (!Mutable)
  {
    uint64_t v74 = FigSignalErrorAt();
LABEL_187:
    uint64_t v26 = v74;
    goto LABEL_188;
  }
  uint64_t v72 = (const void *)*MEMORY[0x1E4F1CFC8];
  if (*(unsigned char *)(v51 + 56)) {
    CFIndex v73 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  else {
    CFIndex v73 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  CFDictionarySetValue(Mutable, @"ExternalProtectionMonitorPerCryptor", v73);
  if (!*(unsigned char *)(v51 + 184))
  {
    CFDictionarySetValue(v58, @"RequiresReencryptionContext", v72);
    if (!*(unsigned char *)(v51 + 184)) {
      CFDictionarySetValue(v58, @"RequiresReencryptionContext", v72);
    }
  }
  uint64_t v74 = FigCPEProtectorCreateForScheme((uint64_t)a2, v53, (uint64_t)v58, v51 + 16);
  if (v74) {
    goto LABEL_187;
  }
  uint64_t v75 = *(void *)(v51 + 16);
  uint64_t v76 = *(void *)(v51 + 144);
  uint64_t v77 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v77) {
    uint64_t v78 = v77;
  }
  else {
    uint64_t v78 = 0;
  }
  uint64_t v91 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(v78 + 56);
  if (!v91)
  {
    CFDictionaryRef v65 = 0;
    CMBlockBufferRef v60 = 0;
LABEL_133:
    uint64_t v26 = 4294954514;
    goto LABEL_134;
  }
  uint64_t v74 = v91(v75, @"NeroTransport", v76);
  if (v74) {
    goto LABEL_187;
  }
  if (dword_1E9350AD0 >= 2)
  {
    unsigned int v92 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  uint64_t v56 = v102;
LABEL_84:
  CMTime v59 = CFDictionaryCreateMutable(v57, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CMBlockBufferRef v60 = v59;
  if (!v59)
  {
    uint64_t v26 = FigSignalErrorAt();
    CFDictionaryRef v65 = 0;
    goto LABEL_134;
  }
  if (v56) {
    CFDictionarySetValue(v59, @"FormatType", v56);
  }
  BOOL v101 = v58;
  CMBlockBufferRef v61 = *(const void **)(v51 + 48);
  if (v61) {
    CFDictionarySetValue(v60, @"AuditToken", v61);
  }
  FigCFDictionarySetValueFromKeyInDict();
  FigCFDictionarySetValueFromKeyInDict();
  FigCFDictionarySetValueFromKeyInDict();
  FigCFDictionarySetValueFromKeyInDict();
  FigCFDictionaryGetInt32IfPresent();
  CMItemCount v62 = (void *)(CMBaseObjectGetDerivedStorage() + 168);
  if (!*v62)
  {
    CFAllocatorRef v63 = CFGetAllocator(a1);
    uint64_t v64 = FigSecureStopManagerCopyDefaultRuntimeInstance((uint64_t)v63, v62);
    if (v64)
    {
      uint64_t v26 = v64;
      CFDictionaryRef v65 = 0;
      goto LABEL_180;
    }
  }
  FigCFDictionarySetValue();
  CFDictionaryRef v65 = CFDictionaryCreateCopy(a2, v20);
  if (!v65)
  {
    uint64_t v26 = FigSignalErrorAt();
LABEL_180:
    uint64_t v58 = v101;
    goto LABEL_134;
  }
  FigCFDictionarySetValue();
  uint64_t v66 = *(void *)(v51 + 16);
  uint64_t v67 = *(void *)(CMBaseObjectGetVTable() + 16);
  uint64_t v58 = v101;
  if (v67) {
    uint64_t v68 = v67;
  }
  else {
    uint64_t v68 = 0;
  }
  int v79 = *(uint64_t (**)(uint64_t, const __CFAllocator *, void, __CFDictionary *, CFTypeRef *))(v68 + 104);
  if (!v79) {
    goto LABEL_133;
  }
  uint64_t v80 = v79(v66, a2, *(unsigned int *)type, v60, &v105);
  if (v80)
  {
    uint64_t v26 = v80;
  }
  else
  {
    FigCFDictionaryGetBooleanIfPresent();
    if (v106)
    {
      CFIndex v81 = *(const void **)(v51 + 24);
      if (v81) {
        CFRelease(v81);
      }
      *(void *)(v51 + 24) = FigCFWeakReferenceHolderCreateWithReferencedObject();
    }
    CFAllocatorRef v82 = CFGetAllocator(a1);
    CFURLRef v83 = (uint64_t *)CFAllocatorAllocate(v82, 24, 0);
    long long v84 = v83;
    if (v83)
    {
      uint64_t *v83 = 0;
      v83[1] = 0;
      UInt8 v83[2] = 0;
      uint64_t v85 = FigCFWeakReferenceHolderCreateWithReferencedObject();
      *long long v84 = v85;
      if (v85)
      {
        v84[1] = 0;
        int v86 = *(uint64_t ***)(v51 + 136);
        v84[2] = (uint64_t)v86;
        *int v86 = v84;
        *(void *)(v51 + 136) = v84 + 1;
        goto LABEL_116;
      }
    }
    uint64_t v98 = FigSignalErrorAt();
    if (v98)
    {
      uint64_t v26 = v98;
      CFAllocatorDeallocate(v82, v84);
      goto LABEL_134;
    }
LABEL_116:
    if (!a1 || !v105) {
      goto LABEL_126;
    }
    CMNotificationCenterGetDefaultLocalCenter();
    uint64_t v87 = FigNotificationCenterAddWeakListener();
    if (!v87 || (uint64_t v26 = v87, v87 == -12724))
    {
      CMNotificationCenterGetDefaultLocalCenter();
      uint64_t v88 = FigNotificationCenterAddWeakListener();
      if (!v88 || (uint64_t v26 = v88, v88 == -12724))
      {
        CMNotificationCenterGetDefaultLocalCenter();
        uint64_t v89 = FigNotificationCenterAddWeakListener();
        if (!v89 || (uint64_t v26 = v89, v89 == -12724))
        {
          CMNotificationCenterGetDefaultLocalCenter();
          uint64_t v90 = FigNotificationCenterAddWeakListener();
          if (!v90 || (uint64_t v26 = v90, v90 == -12724))
          {
LABEL_126:
            uint64_t v26 = 0;
            *a5 = v105;
            CFTypeRef v105 = 0;
            goto LABEL_137;
          }
        }
      }
    }
  }
LABEL_134:
  if (v105) {
    CFRelease(v105);
  }
  if (v60) {
LABEL_137:
  }
    CFRelease(v60);
  if (v58) {
    CFRelease(v58);
  }
  if (v65) {
    CFRelease(v65);
  }
  uint64_t v10 = v99;
  if (!v26)
  {
    PKDLogPrivateData(v103);
    int v69 = (const void *)FigCFCopyCompactDescription();
    if (dword_1E9350AD0)
    {
      LODWORD(v105) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      unsigned int v93 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v94 = v105;
      if (os_log_type_enabled(v93, type[0])) {
        unsigned int v95 = v94;
      }
      else {
        unsigned int v95 = v94 & 0xFFFFFFFE;
      }
      if (v95)
      {
        CFTypeRef v96 = *a5;
        *(_DWORD *)uint64_t v108 = 136316162;
        *(void *)&v108[4] = "fcks_copyCryptor";
        __int16 v109 = 2048;
        UInt32 v110 = a1;
        __int16 v111 = 2114;
        CFTypeRef v112 = v96;
        __int16 v113 = 2114;
        CMTimeEpoch v114 = v69;
        __int16 v115 = 1024;
        int v116 = 0;
        _os_log_send_and_compose_impl();
      }
LABEL_149:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    goto LABEL_150;
  }
LABEL_161:
  MEMORY[0x19970E930](*(void *)(v10 + 40));
LABEL_153:
  if (v20) {
    CFRelease(v20);
  }
  return v26;
}

uint64_t fcks_resetSession(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v3 = FigSignalErrorAt();
  }
  else
  {
    fcks_resetSessionGuts(a1);
    uint64_t v3 = 0;
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 40));
  if (dword_1E9350AD0)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return v3;
}

uint64_t fcks_invokeKeyResponseErrorCallbackAsync(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef v21 = 0;
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v19 = FigSignalErrorAt();
    if (v19) {
LABEL_23:
    }
      fcks_releaseAndClearFigContentKeySessionCallbackContext(&v21);
  }
  else
  {
    FigContentKeySessionCallbackContext = fcks_createFigContentKeySessionCallbackContext(DerivedStorage);
    CFArrayRef v21 = FigContentKeySessionCallbackContext;
    if (FigContentKeySessionCallbackContext)
    {
      uint64_t v9 = FigContentKeySessionCallbackContext;
      if (a2) {
        CFTypeRef v10 = CFRetain(a2);
      }
      else {
        CFTypeRef v10 = 0;
      }
      *uint64_t v9 = v10;
      if (a4) {
        CFTypeRef v11 = CFRetain(a4);
      }
      else {
        CFTypeRef v11 = 0;
      }
      v9[3] = v11;
      v9[1] = a3;
      dispatch_async_f(*(dispatch_queue_t *)(DerivedStorage + 64), v9, (dispatch_function_t)fcks_dispatchKeyResponseErrorCallback);
    }
    for (CFIndex i = 0; ; ++i)
    {
      CFArrayRef Count = *(const __CFArray **)(DerivedStorage + 8);
      if (Count) {
        CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
      }
      if (i >= (uint64_t)Count) {
        break;
      }
      CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 8), i);
      uint64_t v14 = FigCFWeakReferenceHolderCopyReferencedObject();
      if (v14)
      {
        uint64_t v15 = (const void *)v14;
        uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v16) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = 0;
        }
        uint64_t v18 = *(uint64_t (**)(const void *, const void *, const void *, const void *))(v17 + 32);
        if (!v18)
        {
          CFRelease(v15);
          uint64_t v19 = 4294954514;
LABEL_22:
          FigSignalErrorAt();
          goto LABEL_23;
        }
        uint64_t v19 = v18(v15, a2, a3, a4);
        CFRelease(v15);
        if (v19) {
          goto LABEL_22;
        }
      }
    }
    uint64_t v19 = 0;
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 40));
  return v19;
}

uint64_t fcks_invokeKeyResponseSuccessfullyProcessedCallbackAsync(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v18 = 0;
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v16 = FigSignalErrorAt();
    if (v16) {
LABEL_20:
    }
      fcks_releaseAndClearFigContentKeySessionCallbackContext(&v18);
  }
  else
  {
    FigContentKeySessionCallbackContext = fcks_createFigContentKeySessionCallbackContext(DerivedStorage);
    uint64_t v18 = FigContentKeySessionCallbackContext;
    if (FigContentKeySessionCallbackContext)
    {
      CFAllocatorRef v7 = FigContentKeySessionCallbackContext;
      if (a2) {
        CFTypeRef v8 = CFRetain(a2);
      }
      else {
        CFTypeRef v8 = 0;
      }
      *CFAllocatorRef v7 = v8;
      v7[1] = a3;
      dispatch_async_f(*(dispatch_queue_t *)(DerivedStorage + 64), v7, (dispatch_function_t)fcks_dispatchKeyResponseSuccessfullyProcessedCallback);
    }
    for (CFIndex i = 0; ; ++i)
    {
      CFArrayRef Count = *(const __CFArray **)(DerivedStorage + 8);
      if (Count) {
        CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
      }
      if (i >= (uint64_t)Count) {
        break;
      }
      CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 8), i);
      uint64_t v11 = FigCFWeakReferenceHolderCopyReferencedObject();
      if (v11)
      {
        int v12 = (const void *)v11;
        uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v13) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v15 = *(uint64_t (**)(const void *, const void *, const void *))(v14 + 40);
        if (!v15)
        {
          CFRelease(v12);
          uint64_t v16 = 4294954514;
LABEL_19:
          FigSignalErrorAt();
          goto LABEL_20;
        }
        uint64_t v16 = v15(v12, a2, a3);
        CFRelease(v12);
        if (v16) {
          goto LABEL_19;
        }
      }
    }
    uint64_t v16 = 0;
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 40));
  return v16;
}

uint64_t fcks_invokePersistentKeyUpdatedCallbackAsync(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v19 = 0;
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v17 = FigSignalErrorAt();
    if (v17) {
LABEL_23:
    }
      fcks_releaseAndClearFigContentKeySessionCallbackContext(&v19);
  }
  else
  {
    FigContentKeySessionCallbackContext = fcks_createFigContentKeySessionCallbackContext(DerivedStorage);
    uint64_t v19 = FigContentKeySessionCallbackContext;
    if (FigContentKeySessionCallbackContext)
    {
      CFAllocatorRef v7 = FigContentKeySessionCallbackContext;
      if (a2) {
        CFTypeRef v8 = CFRetain(a2);
      }
      else {
        CFTypeRef v8 = 0;
      }
      v7[2] = v8;
      if (a3) {
        CFTypeRef v9 = CFRetain(a3);
      }
      else {
        CFTypeRef v9 = 0;
      }
      v7[4] = v9;
      dispatch_async_f(*(dispatch_queue_t *)(DerivedStorage + 64), v7, (dispatch_function_t)fcks_dispatchPersistentKeyUpdatedCallback);
    }
    for (CFIndex i = 0; ; ++i)
    {
      CFArrayRef Count = *(const __CFArray **)(DerivedStorage + 8);
      if (Count) {
        CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
      }
      if (i >= (uint64_t)Count) {
        break;
      }
      CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 8), i);
      uint64_t v12 = FigCFWeakReferenceHolderCopyReferencedObject();
      if (v12)
      {
        uint64_t v13 = (const void *)v12;
        uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v14) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = 0;
        }
        uint64_t v16 = *(uint64_t (**)(const void *, const void *, const void *))(v15 + 48);
        if (!v16)
        {
          CFRelease(v13);
          uint64_t v17 = 4294954514;
LABEL_22:
          FigSignalErrorAt();
          goto LABEL_23;
        }
        uint64_t v17 = v16(v13, a2, a3);
        CFRelease(v13);
        if (v17) {
          goto LABEL_22;
        }
      }
    }
    uint64_t v17 = 0;
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 40));
  return v17;
}

uint64_t fcks_invokeSecureStopDidFinalizeRecordCallbackAsync()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
  FigContentKeySessionCallbackContext = fcks_createFigContentKeySessionCallbackContext(DerivedStorage);
  if (FigContentKeySessionCallbackContext) {
    dispatch_async_f(*(dispatch_queue_t *)(DerivedStorage + 64), FigContentKeySessionCallbackContext, (dispatch_function_t)fcks_dispatchSecureStopDidFinalizeRecordCallback);
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 40));
  return 0;
}

uint64_t fcks_invokeDispatchExternalProtectionStateChangedCallbackAsync(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v15 = 0;
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v13 = FigSignalErrorAt();
    if (v13) {
LABEL_20:
    }
      fcks_releaseAndClearFigContentKeySessionCallbackContext(&v15);
  }
  else
  {
    FigContentKeySessionCallbackContext = fcks_createFigContentKeySessionCallbackContext(DerivedStorage);
    uint64_t v15 = FigContentKeySessionCallbackContext;
    if (FigContentKeySessionCallbackContext)
    {
      uint64_t v5 = FigContentKeySessionCallbackContext;
      if (a2) {
        CFTypeRef v6 = CFRetain(a2);
      }
      else {
        CFTypeRef v6 = 0;
      }
      *uint64_t v5 = v6;
      dispatch_async_f(*(dispatch_queue_t *)(DerivedStorage + 64), v5, (dispatch_function_t)fcks_dispatchExternalProtectionStateChangedCallback);
    }
    for (CFIndex i = 0; ; ++i)
    {
      CFArrayRef Count = *(const __CFArray **)(DerivedStorage + 8);
      if (Count) {
        CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
      }
      if (i >= (uint64_t)Count) {
        break;
      }
      CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 8), i);
      uint64_t v9 = FigCFWeakReferenceHolderCopyReferencedObject();
      if (v9)
      {
        CFTypeRef v10 = (const void *)v9;
        uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v11) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = 0;
        }
        if (!*(void *)(v12 + 56))
        {
          CFRelease(v10);
          uint64_t v13 = 4294954514;
LABEL_19:
          FigSignalErrorAt();
          goto LABEL_20;
        }
        uint64_t v13 = (*(uint64_t (**)(const void *, const void *))(v12 + 64))(v10, a2);
        CFRelease(v10);
        if (v13) {
          goto LABEL_19;
        }
      }
    }
    uint64_t v13 = 0;
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 40));
  return v13;
}

uint64_t fcks_setAuthorizationToken(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2 && a3)
  {
    uint64_t v6 = DerivedStorage;
    MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
    if (*(unsigned char *)v6)
    {
      uint64_t v7 = FigSignalErrorAt();
    }
    else
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v6 + 176), a2, a3);
      uint64_t v7 = 0;
    }
    MEMORY[0x19970E930](*(void *)(v6 + 40));
    return v7;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t fcks_copyAuthorizationToken(uint64_t a1, const void *a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  if (a2 && a3)
  {
    uint64_t v6 = DerivedStorage;
    *a3 = 0;
    MEMORY[0x19970E910](*(void *)(DerivedStorage + 40));
    if (*(unsigned char *)v6)
    {
      uint64_t v17 = FigSignalErrorAt();
LABEL_22:
      MEMORY[0x19970E930](*(void *)(v6 + 40));
      CFTypeRef v9 = cf;
      if (!v17) {
        goto LABEL_23;
      }
    }
    else
    {
      CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 176), a2);
      if (Value)
      {
        CFTypeRef v8 = CFRetain(Value);
        CFTypeRef cf = v8;
        if (v8)
        {
          CFTypeRef v9 = v8;
          MEMORY[0x19970E930](*(void *)(v6 + 40));
LABEL_23:
          uint64_t v17 = 0;
          *a3 = v9;
          return v17;
        }
      }
      else
      {
        CFTypeRef cf = 0;
      }
      for (CFIndex i = 0; ; ++i)
      {
        CFArrayRef Count = *(const __CFArray **)(v6 + 8);
        if (Count) {
          CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
        }
        if (i >= (uint64_t)Count) {
          goto LABEL_20;
        }
        CFArrayGetValueAtIndex(*(CFArrayRef *)(v6 + 8), i);
        uint64_t v12 = FigCFWeakReferenceHolderCopyReferencedObject();
        if (v12)
        {
          uint64_t v13 = (const void *)v12;
          uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v14) {
            uint64_t v15 = v14;
          }
          else {
            uint64_t v15 = 0;
          }
          uint64_t v16 = *(uint64_t (**)(const void *, const void *, CFTypeRef *))(v15 + 80);
          if (!v16)
          {
            CFRelease(v13);
            uint64_t v17 = 4294954514;
            goto LABEL_26;
          }
          uint64_t v17 = v16(v13, a2, &cf);
          CFRelease(v13);
          if (v17 != -17295) {
            break;
          }
        }
      }
      if (v17)
      {
LABEL_26:
        FigSignalErrorAt();
        goto LABEL_27;
      }
LABEL_20:
      if (cf)
      {
        uint64_t v17 = 0;
        goto LABEL_22;
      }
      uint64_t v17 = 4294950001;
LABEL_27:
      MEMORY[0x19970E930](*(void *)(v6 + 40));
      CFTypeRef v9 = cf;
    }
    if (v9) {
      CFRelease(v9);
    }
    return v17;
  }

  return FigSignalErrorAt();
}

uint64_t fcsk_externalProtectionStatusForCryptor(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  cf[26] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  cf[0] = 0;
  int v30 = 0;
  char v29 = 0;
  if (!a2 || !a4 || !a3)
  {
    uint64_t v10 = FigSignalErrorAt();
    goto LABEL_45;
  }
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  CFTypeRef v9 = *(uint64_t (**)(uint64_t, void, void, CFTypeRef *))(v8 + 48);
  if (!v9) {
    goto LABEL_36;
  }
  uint64_t v10 = v9(a2, *MEMORY[0x1E4F1FE00], *MEMORY[0x1E4F1CF80], cf);
  if (v10) {
    goto LABEL_45;
  }
  CFTypeRef v11 = cf[0];
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = *(uint64_t (**)(uint64_t, void, CFTypeRef))(v13 + 56);
  if (!v14) {
    goto LABEL_36;
  }
  uint64_t v10 = v14(a2, *MEMORY[0x1E4F1FDA0], v11);
  if (v10) {
    goto LABEL_45;
  }
  uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v15) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(v16 + 56);
  if (!v17) {
    goto LABEL_36;
  }
  uint64_t v10 = v17(a2, @"DisplayList", a3);
  if (v10) {
    goto LABEL_45;
  }
  uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v18) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = 0;
  }
  CFDictionaryRef v20 = *(uint64_t (**)(uint64_t, void, int *))(v19 + 24);
  if (!v20) {
    goto LABEL_36;
  }
  uint64_t v10 = v20(a2, 0, &v30);
  if (v10)
  {
LABEL_45:
    uint64_t v26 = v10;
    goto LABEL_37;
  }
  uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 16);
  uint64_t v22 = v21 ? v21 : 0;
  CFTypeRef v23 = *(uint64_t (**)(uint64_t, char *))(v22 + 192);
  if (!v23)
  {
LABEL_36:
    uint64_t v26 = 4294954514;
    goto LABEL_37;
  }
  uint64_t v10 = v23(a2, &v29);
  if (v10) {
    goto LABEL_45;
  }
  if (v29)
  {
    if (v30 == 1 || v30 == 4) {
      int v25 = 2;
    }
    else {
      int v25 = 3;
    }
  }
  else
  {
    int v25 = 1;
  }
  if (dword_1E9350AD0)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  uint64_t v26 = 0;
  *a4 = v25;
LABEL_37:
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  return v26;
}

CFTypeRef *fcks_createFigContentKeySessionCallbackContext(uint64_t a1)
{
  uint64_t v5 = 0;
  if (!*(void *)(a1 + 64)) {
    goto LABEL_6;
  }
  if (!*(void *)(a1 + 120)) {
    goto LABEL_6;
  }
  uint64_t v2 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x60uLL, 0x10E0040C7BBEF1CuLL);
  uint64_t v5 = v2;
  *(_OWORD *)uint64_t v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  uint64_t v3 = FigCFWeakReferenceHolderCopyReferencedObject();
  v2[5] = (CFTypeRef)v3;
  if (v3)
  {
    __copy_assignment_8_8_t0w4_pa0_52572_8_pa0_57120_16_pa0_14239_24_pa0_30190_32_pa0_41757_40((uint64_t)(v2 + 6), a1 + 72);
  }
  else
  {
LABEL_6:
    fcks_releaseAndClearFigContentKeySessionCallbackContext(&v5);
    return v5;
  }
  return v2;
}

void fcks_dispatchKeyResponseErrorCallback(CFTypeRef *a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = (void (*)(CFTypeRef, CFTypeRef, CFTypeRef, CFTypeRef))a1[7];
  if (v1) {
    v1(a1[5], *a1, a1[1], a1[3]);
  }
  fcks_releaseAndClearFigContentKeySessionCallbackContext(&v2);
}

void fcks_releaseAndClearFigContentKeySessionCallbackContext(CFTypeRef **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2)
    {
      if (*v2)
      {
        CFRelease(*v2);
        uint64_t v2 = *a1;
      }
      if (v2[2])
      {
        CFRelease(v2[2]);
        uint64_t v2 = *a1;
      }
      if (v2[3])
      {
        CFRelease(v2[3]);
        uint64_t v2 = *a1;
      }
      if (v2[4])
      {
        CFRelease(v2[4]);
        uint64_t v2 = *a1;
      }
      if (v2[5])
      {
        CFRelease(v2[5]);
        uint64_t v2 = *a1;
      }
      free(v2);
      *a1 = 0;
    }
  }
}

void fcks_dispatchKeyResponseSuccessfullyProcessedCallback(CFTypeRef *a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = (void (*)(CFTypeRef, CFTypeRef, CFTypeRef))a1[8];
  if (v1) {
    v1(a1[5], *a1, a1[1]);
  }
  fcks_releaseAndClearFigContentKeySessionCallbackContext(&v2);
}

void fcks_dispatchPersistentKeyUpdatedCallback(uint64_t a1)
{
  uint64_t v2 = (CFTypeRef *)a1;
  uint64_t v1 = *(void (**)(void, void, void))(a1 + 72);
  if (v1) {
    v1(*(void *)(a1 + 40), *(void *)(a1 + 16), *(void *)(a1 + 32));
  }
  fcks_releaseAndClearFigContentKeySessionCallbackContext(&v2);
}

void fcks_dispatchSecureStopDidFinalizeRecordCallback(uint64_t a1)
{
  uint64_t v2 = (CFTypeRef *)a1;
  uint64_t v1 = *(void (**)(void))(a1 + 80);
  if (v1) {
    v1(*(void *)(a1 + 40));
  }
  fcks_releaseAndClearFigContentKeySessionCallbackContext(&v2);
}

void fcks_dispatchExternalProtectionStateChangedCallback(CFTypeRef *a1)
{
  uint64_t v1 = a1;
  if (a1[10]) {
    ((void (*)(CFTypeRef, CFTypeRef))a1[11])(a1[5], *a1);
  }
  fcks_releaseAndClearFigContentKeySessionCallbackContext(&v1);
}

uint64_t FigAssetWriterCreateWithURL(const __CFAllocator *a1, const __CFURL *a2, uint64_t a3, const __CFDictionary *a4, const __CFDictionary *a5, void *a6)
{
  CFPreferenceBooleanWithCFAllocatorRef Default = 0;
  CFTypeRef v17 = 0;
  CFTypeRef cf = 0;
  FigKTraceInit();
  if (!a2 || !remakerFamily_CFURLSchemeIsFile(a2) || FigFileDoesFileExist() || !a6) {
    goto LABEL_20;
  }
  FigCFDictionaryGetBooleanIfPresent();
  CFPreferenceBooleanWithCFAllocatorRef Default = FigGetCFPreferenceBooleanWithDefault();
  int v11 = CMByteStreamCreateForFileURL();
  if (v11 != -12204 && v11 != 0) {
    int v11 = -12143;
  }
  if (v11)
  {
LABEL_20:
    uint64_t v13 = FigSignalErrorAt();
    goto LABEL_21;
  }
  uint64_t v13 = assetWriter_CreateWithByteStreamOrFormatWriterSegmentCallback(a1, cf, 0, a4, a5, &v17);
  if (v13)
  {
LABEL_21:
    uint64_t v15 = v13;
    goto LABEL_15;
  }
  CFTypeRef v14 = v17;
  if (*MEMORY[0x1E4F1EBA8] == 1) {
    kdebug_trace();
  }
  uint64_t v15 = 0;
  *a6 = v14;
  CFTypeRef v17 = 0;
LABEL_15:
  if (cf) {
    CFRelease(cf);
  }
  if (v17) {
    CFRelease(v17);
  }
  return v15;
}

uint64_t assetWriter_CreateWithByteStreamOrFormatWriterSegmentCallback(const __CFAllocator *a1, const void *a2, uint64_t a3, const __CFDictionary *a4, const __CFDictionary *a5, CFTypeRef *a6)
{
  CFTypeRef cf = 0;
  CFTypeRef v31 = 0;
  int IsServerProcess = FigServer_IsServerProcess();
  if (IsServerProcess)
  {
    uint64_t v13 = (void *)FigOSTransactionCreate();
    if (!v13) {
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  FigAssetWriterGetClassID();
  uint64_t LoggingIdentifier = CMDerivedObjectCreate();
  if (LoggingIdentifier) {
    goto LABEL_36;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t LoggingIdentifier = remakerFamily_generateLoggingIdentifier(87, (char *)(DerivedStorage + 41));
  if (LoggingIdentifier) {
    goto LABEL_36;
  }
  uint64_t v16 = MEMORY[0x1E4F1FA48];
  *(_OWORD *)(DerivedStorage + 88) = *MEMORY[0x1E4F1FA48];
  *(void *)(DerivedStorage + 104) = *(void *)(v16 + 16);
  uint64_t v17 = MEMORY[0x1E4F1FA10];
  *(_OWORD *)(DerivedStorage + 112) = *MEMORY[0x1E4F1FA10];
  *(void *)(DerivedStorage + 128) = *(void *)(v17 + 16);
  *(_DWORD *)(DerivedStorage + 456) = -1;
  *(void *)(DerivedStorage + 8) = FigReentrantMutexCreate();
  *(void *)(DerivedStorage + 64) = FigReentrantMutexCreate();
  remakerFamily_initializePowerLog((uint64_t)v31);
  if (IsServerProcess)
  {
    *(void *)(DerivedStorage + 448) = v13;
    uint64_t v13 = 0;
  }
  remakerFamily_SetRemakerState((uint64_t)v31, 1, 0);
  *(void *)(DerivedStorage + 24) = FigSemaphoreCreate();
  FigCFDictionaryGetBooleanIfPresent();
  FigCFDictionaryGetBooleanIfPresent();
  FigCFDictionaryGetInt64IfPresent();
  *(void *)(DerivedStorage + 56) = FigDispatchQueueCreateWithPriorityAndClientPID();
  FigCFDictionaryGetBooleanIfPresent();
  if (a4)
  {
    CFArrayRef Value = CFDictionaryGetValue(a4, @"Remaker_TemporaryDirectoryURL");
    if (Value) {
      CFArrayRef Value = CFRetain(Value);
    }
    *(void *)(DerivedStorage + 232) = Value;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  *(void *)(DerivedStorage + 80) = Mutable;
  if (!Mutable)
  {
LABEL_35:
    uint64_t LoggingIdentifier = FigSignalErrorAt();
LABEL_36:
    uint64_t v28 = LoggingIdentifier;
    goto LABEL_28;
  }
  if (a2)
  {
    *(void *)(DerivedStorage + 168) = CFRetain(a2);
    uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
    uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v21) {
      uint64_t v22 = v21;
    }
    else {
      uint64_t v22 = 0;
    }
    CFTypeRef v23 = *(void (**)(uint64_t, void, void, CFTypeRef *))(v22 + 48);
    if (v23 && (v23(CMBaseObject, *MEMORY[0x1E4F1EC78], *MEMORY[0x1E4F1CF80], &cf), cf))
    {
      CFTypeRef v24 = CFRetain(cf);
      CFURLRef v25 = (const __CFURL *)cf;
      *(void *)(DerivedStorage + 160) = v24;
      if (v25)
      {
        CFURLRef v26 = CFURLCopyAbsoluteURL(v25);
        if (v26)
        {
          CFURLRef v27 = v26;
          *(unsigned char *)(DerivedStorage + 176) = FigFileIsFileOnExternalStorageDevice();
          CFRelease(v27);
        }
      }
    }
    else
    {
      *(void *)(DerivedStorage + 160) = 0;
    }
  }
  else
  {
    *(void *)(DerivedStorage + 168) = 0;
  }
  FigCFDictionaryGetBooleanIfPresent();
  *(_DWORD *)(DerivedStorage + 360) = -1;
  uint64_t LoggingIdentifier = remakerFamily_createFormatWriter(v31, a1, 0, a3, a5, (CFTypeRef *)(DerivedStorage + 184));
  if (LoggingIdentifier) {
    goto LABEL_36;
  }
  *(void *)(DerivedStorage + 192) = FigCFWeakReferenceHolderCreateWithReferencedObject();
  CMNotificationCenterGetDefaultLocalCenter();
  uint64_t v28 = FigNotificationCenterAddWeakListeners();
  if (!v28)
  {
    *a6 = v31;
    CFTypeRef v31 = 0;
  }
LABEL_28:
  if (cf) {
    CFRelease(cf);
  }
  if (v31) {
    CFRelease(v31);
  }
  if (v13) {
    os_release(v13);
  }
  return v28;
}

uint64_t FigAssetWriterCreateForWritingFragmentedData(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5, const __CFDictionary *a6, void *a7)
{
  CFTypeRef cf = 0;
  FigKTraceInit();
  if (a7)
  {
    uint64_t v14 = assetWriter_CreateWithByteStreamOrFormatWriterSegmentCallback(a1, 0, (uint64_t)assetWriter_FormatWriterSegmentCallback, a5, a6, &cf);
    CFTypeRef v15 = cf;
    if (v14)
    {
      uint64_t v17 = v14;
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      *(unsigned char *)(DerivedStorage + 304) = 1;
      *(void *)(DerivedStorage + 312) = a2;
      *(void *)(DerivedStorage + 320) = a3;
      *(void *)(DerivedStorage + 328) = a4;
      if (*MEMORY[0x1E4F1EBA8] == 1) {
        kdebug_trace();
      }
      uint64_t v17 = 0;
      *a7 = v15;
    }
    return v17;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t assetWriter_FormatWriterSegmentCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = DerivedStorage;
  CFTypeRef cf = 0;
  if (*(void *)(DerivedStorage + 312) && !*(unsigned char *)(DerivedStorage + 305))
  {
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v12 = v11 ? v11 : 0;
    if (*(void *)(v12 + 80))
    {
      uint64_t v13 = *(void *)(v6 + 184);
      uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v14) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v16 = *(uint64_t (**)(uint64_t, void, CFTypeRef *))(v15 + 80);
      if (!v16)
      {
        uint64_t v9 = 4294954514;
        goto LABEL_7;
      }
      uint64_t v8 = v16(v13, 0, &cf);
      if (v8) {
        goto LABEL_5;
      }
      uint64_t v8 = (*(uint64_t (**)(CFTypeRef, void))(v6 + 312))(cf, *(void *)(v6 + 328));
      if (v8) {
        goto LABEL_5;
      }
      *(unsigned char *)(v6 + 305) = 1;
    }
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, void))(v6 + 320);
  if (v7)
  {
    uint64_t v8 = v7(a2, a3, *(void *)(v6 + 328));
LABEL_5:
    uint64_t v9 = v8;
    goto LABEL_7;
  }
  uint64_t v9 = 0;
LABEL_7:
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t assetWriter_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, void *a4)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage < 7u)
  {
    if (a4)
    {
      uint64_t v8 = DerivedStorage;
      if (!CFEqual(a2, @"AssetWriter_RealTime"))
      {
        if (CFEqual(a2, @"AssetWriter_MaximizePowerEfficiency"))
        {
          uint64_t v10 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
          int v11 = *((unsigned __int8 *)v8 + 424);
LABEL_9:
          if (!v11) {
            uint64_t v10 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
          }
          uint64_t v12 = (void *)CFRetain(*v10);
          goto LABEL_15;
        }
        if (CFEqual(a2, @"AssetWriter_ClientPID"))
        {
          CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t v14 = v8 + 9;
          CFNumberType v15 = kCFNumberSInt32Type;
        }
        else
        {
          if (CFEqual(a2, @"AssetWriter_ThrottleForBackground"))
          {
            uint64_t v10 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
            int v11 = *((unsigned __int8 *)v8 + 40);
            goto LABEL_9;
          }
          if (!CFEqual(a2, @"AssetWriter_IOPolicy"))
          {
            if (CFEqual(a2, @"AssetWriter_PreferredOutputSegmentInterval"))
            {
              uint64_t v17 = v8 + 67;
              long long v18 = *(_OWORD *)(v8 + 67);
            }
            else
            {
              if (!CFEqual(a2, @"AssetWriter_InitialSegmentStartTime")) {
                return 4294954512;
              }
              uint64_t v17 = v8 + 61;
              long long v18 = *(_OWORD *)(v8 + 61);
            }
            *(_OWORD *)&v19.CMTimeValue value = v18;
            v19.CMTimeEpoch epoch = *((void *)v17 + 2);
            uint64_t v12 = CMTimeCopyAsDictionary(&v19, a3);
LABEL_15:
            uint64_t v16 = v12;
            uint64_t result = 0;
            *a4 = v16;
            return result;
          }
          CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t v14 = v8 + 114;
          CFNumberType v15 = kCFNumberIntType;
        }
        uint64_t v12 = CFNumberCreate(v13, v15, v14);
        goto LABEL_15;
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t assetWriter_SetProperty(const void *a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage >= 7u) {
    goto LABEL_18;
  }
  uint64_t v7 = DerivedStorage;
  if (!CFEqual(a2, @"AssetWriter_ClientSecTask"))
  {
    if (CFEqual(a2, @"AssetWriter_Metadata"))
    {
      if (*v7 >= 5u)
      {
        FigSignalErrorAt();
        return 0;
      }
      if (!a3)
      {
        uint64_t result = *((void *)v7 + 50);
        if (result)
        {
          CFRelease((CFTypeRef)result);
          uint64_t result = 0;
          *((void *)v7 + 50) = 0;
        }
        return result;
      }
      CFTypeID v11 = CFGetTypeID(a3);
      if (v11 == CFArrayGetTypeID())
      {
        uint64_t v12 = (const void *)*((void *)v7 + 50);
        if (v12)
        {
          CFRelease(v12);
          *((void *)v7 + 50) = 0;
        }
        CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFArrayRef)a3);
        uint64_t result = 0;
        *((void *)v7 + 50) = Copy;
        return result;
      }
      goto LABEL_18;
    }
    if (CFEqual(a2, @"AssetWriter_RealTime")) {
      goto LABEL_18;
    }
    if (CFEqual(a2, @"AssetWriter_ClientPID"))
    {
      if (a3)
      {
        CFTypeID v14 = CFGetTypeID(a3);
        if (v14 == CFNumberGetTypeID())
        {
          CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, v7 + 9);
          return remakerfamily_updateClientPID();
        }
      }
      goto LABEL_18;
    }
    if (CFEqual(a2, @"AssetWriter_ThrottleForBackground"))
    {
      if (a3)
      {
        CFTypeID v15 = CFGetTypeID(a3);
        if (v15 == CFBooleanGetTypeID())
        {
          *((unsigned char *)v7 + 40) = CFBooleanGetValue((CFBooleanRef)a3);
          return remakerfamily_updateThrottleForBackground(a1);
        }
      }
      goto LABEL_18;
    }
    if (CFEqual(a2, @"AssetWriter_IOPolicy"))
    {
      if (a3)
      {
        CFTypeID v16 = CFGetTypeID(a3);
        if (v16 == CFNumberGetTypeID())
        {
          CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, v7 + 114);
          return remakerfamily_updateIOPolicy();
        }
      }
LABEL_18:
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, @"AssetWriter_MaximizePowerEfficiency"))
    {
      if (a3)
      {
        CFTypeID v17 = CFGetTypeID(a3);
        if (v17 == CFBooleanGetTypeID())
        {
          Boolean Value = CFBooleanGetValue((CFBooleanRef)a3);
          uint64_t result = 0;
          *((unsigned char *)v7 + 424) = Value;
          return result;
        }
      }
      goto LABEL_18;
    }
    if (CFEqual(a2, @"AssetWriter_PreferredOutputSegmentInterval"))
    {
      if (*((unsigned char *)v7 + 304) != 1) {
        goto LABEL_18;
      }
      memset(&v22, 0, sizeof(v22));
      CMTimeMakeFromDictionary(&v22, (CFDictionaryRef)a3);
      if ((~v22.flags & 0x11) == 0
        || (v22.flags & 0x1D) == 1
        && (time1 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48], CMTime v20 = v22, CMTimeCompare(&time1, &v20) < 0))
      {
        uint64_t result = FigFormatWriterSetProperty(*((void *)v7 + 23), @"PreferredOutputSegmentInterval", (uint64_t)a3);
        if (result) {
          return result;
        }
        CMTime v19 = v7 + 67;
        *(_OWORD *)(v7 + 67) = *(_OWORD *)&v22.value;
        goto LABEL_59;
      }
    }
    else
    {
      if (!CFEqual(a2, @"AssetWriter_InitialSegmentStartTime")) {
        return 4294954512;
      }
      if (*((unsigned char *)v7 + 304) != 1) {
        goto LABEL_18;
      }
      memset(&v22, 0, sizeof(v22));
      CMTimeMakeFromDictionary(&v22, (CFDictionaryRef)a3);
      if ((v22.flags & 0x1D) == 1)
      {
        uint64_t result = FigFormatWriterSetProperty(*((void *)v7 + 23), @"InitialSegmentStartTime", (uint64_t)a3);
        if (result) {
          return result;
        }
        CMTime v19 = v7 + 61;
        *(_OWORD *)(v7 + 61) = *(_OWORD *)&v22.value;
LABEL_59:
        *((void *)v19 + 2) = v22.epoch;
        return result;
      }
    }
    return FigSignalErrorAt();
  }
  if (a3)
  {
    CFTypeID v8 = CFGetTypeID(a3);
    if (v8 == SecTaskGetTypeID())
    {
      uint64_t v9 = (const void *)*((void *)v7 + 55);
      *((void *)v7 + 55) = a3;
      CFRetain(a3);
      if (v9) {
        CFRelease(v9);
      }
      return 0;
    }
    goto LABEL_18;
  }
  uint64_t result = *((void *)v7 + 55);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    uint64_t result = 0;
    *((void *)v7 + 55) = 0;
  }
  return result;
}

uint64_t FigFormatWriterSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigBaseObject = FigFormatWriterGetFigBaseObject(a1);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  CFTypeID v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
  if (!v8) {
    return 4294954514;
  }

  return v8(FigBaseObject, a2, a3);
}

uint64_t assetWriter_AddNativeTrack(const void *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  intptr_t v33 = 0;
  if (*DerivedStorage != 1 || !a3)
  {
    uint64_t v8 = FigSignalErrorAt();
    goto LABEL_31;
  }
  uint64_t v7 = DerivedStorage;
  uint64_t v8 = remakerFamily_createChannel(a1, 0, a2, &v33);
  if (v8) {
    goto LABEL_31;
  }
  uint64_t v9 = *((void *)v7 + 23);
  intptr_t v10 = v33;
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  CFAllocatorRef v13 = *(uint64_t (**)(uint64_t, uint64_t, void, intptr_t))(v12 + 8);
  if (!v13)
  {
    uint64_t v20 = 4294954514;
    goto LABEL_29;
  }
  uint64_t v8 = v13(v9, a2, 0, v10 + 300);
  if (v8) {
    goto LABEL_31;
  }
  uint64_t v8 = remakerFamily_setFormatWriterTrackProperties((uint64_t)a1, *(unsigned int *)(v33 + 300));
  if (v8) {
    goto LABEL_31;
  }
  uint64_t v8 = remakerFamily_setFormatWriterProperties((uint64_t)a1, 0);
  if (v8) {
    goto LABEL_31;
  }
  uint64_t v14 = *((void *)v7 + 23);
  uint64_t v15 = *(unsigned int *)(v33 + 300);
  CFAllocatorRef v16 = CFGetAllocator(a1);
  uint64_t v17 = *(void *)(v33 + 160);
  uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 16);
  uint64_t v19 = v18 ? v18 : 0;
  uint64_t v21 = *(unsigned int (**)(uint64_t, uint64_t, __CFString *, CFAllocatorRef, uint64_t))(v19 + 16);
  if (v21 && !v21(v14, v15, @"SourceSampleBufferQueue", v16, v17 + 32))
  {
    CMTime v22 = (CMTime *)(*(void *)(v33 + 160) + 40);
    int64_t v23 = *((unsigned char *)v7 + 32) ? 8 : 1;
    CMTimeMake(&v32, v23, 1);
    *CMTime v22 = v32;
    CFTypeRef v24 = (CMTime *)(*(void *)(v33 + 160) + 64);
    int64_t v25 = *((unsigned char *)v7 + 32) ? 10 : 2;
    CMTimeMake(&v32, v25, 1);
    *CFTypeRef v24 = v32;
    uint64_t v26 = *(void *)(v33 + 160);
    CFURLRef v27 = *(opaqueCMBufferQueue **)(v26 + 32);
    CMTime v32 = *(CMTime *)(v26 + 40);
    uint64_t v8 = CMBufferQueueInstallTrigger(v27, (CMBufferQueueTriggerCallback)assetWriterTrack_reachedLowWater, (void *)v26, 2, &v32, (CMBufferQueueTriggerToken *)(v26 + 88));
    if (v8)
    {
LABEL_31:
      uint64_t v20 = v8;
      goto LABEL_29;
    }
  }
  uint64_t v28 = v33;
  if (*(_DWORD *)(v33 + 32) == 1936684398)
  {
    char v29 = (const void *)*((void *)v7 + 25);
    if (v29)
    {
      int v30 = CFEqual(v29, @"AudioPrimingFormat_Manual");
      uint64_t v28 = v33;
      if (!v30) {
        *(unsigned char *)(*(void *)(v33 + 160) + 176) = 1;
      }
    }
  }
  *a3 = *(_DWORD *)(v28 + 300);
  remakerFamily_commitChannel((uint64_t)a1, v28);
  uint64_t v20 = 0;
  intptr_t v33 = 0;
LABEL_29:
  remakerFamily_discardChannel((uint64_t)a1, v33);
  return v20;
}

uint64_t assetWriter_AddAudioTrackWithCompression(const void *a1, uint64_t a2, size_t a3, const void *a4, const void *a5, const __CFDictionary *a6, _DWORD *a7)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  intptr_t v42 = 0;
  if (*DerivedStorage != 1) {
    goto LABEL_35;
  }
  if (!a2) {
    goto LABEL_35;
  }
  if (!a7) {
    goto LABEL_35;
  }
  uint64_t v15 = DerivedStorage;
  if (!remakerFamily_checkClientHasAudioEncoderAccess((uint64_t)a1, a2)) {
    goto LABEL_35;
  }
  uint64_t v16 = remakerFamily_createChannel(a1, 0, 1936684398, &v42);
  if (v16) {
    goto LABEL_36;
  }
  uint64_t v17 = *((void *)v15 + 23);
  intptr_t v18 = v42;
  uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t, void, intptr_t))(v20 + 8);
  if (v21)
  {
    uint64_t v16 = v21(v17, 1936684398, 0, v18 + 300);
    if (v16) {
      goto LABEL_36;
    }
    uint64_t v16 = remakerFamily_setFormatWriterTrackProperties((uint64_t)a1, *(unsigned int *)(v42 + 300));
    if (v16) {
      goto LABEL_36;
    }
    uint64_t v16 = remakerFamily_setFormatWriterProperties((uint64_t)a1, *(_DWORD *)(a2 + 8));
    if (v16) {
      goto LABEL_36;
    }
    CFAllocatorRef v22 = CFGetAllocator(a1);
    CallbacksForUnsortedSampleBuffers = CMBufferQueueGetCallbacksForUnsortedSampleBuffers();
    uint64_t v16 = CMBufferQueueCreate(v22, 0, CallbacksForUnsortedSampleBuffers, (CMBufferQueueRef *)(*(void *)(v42 + 160) + 32));
    if (v16) {
      goto LABEL_36;
    }
    CFTypeRef v24 = (CMTime *)(*(void *)(v42 + 160) + 40);
    int64_t v25 = *((unsigned char *)v15 + 32) ? 8 : 1;
    CMTimeMake(&v41, v25, 1);
    *CFTypeRef v24 = v41;
    CFURLRef v27 = (CMTime *)(*(void *)(v42 + 160) + 64);
    int64_t v28 = *((unsigned char *)v15 + 32) ? 10 : 2;
    CMTimeMake(&v41, v28, 1);
    *CFURLRef v27 = v41;
    uint64_t v29 = *(void *)(v42 + 160);
    int v30 = *(opaqueCMBufferQueue **)(v29 + 32);
    CMTime v41 = *(CMTime *)(v29 + 40);
    uint64_t v16 = CMBufferQueueInstallTrigger(v30, (CMBufferQueueTriggerCallback)assetWriterTrack_reachedLowWater, (void *)v29, 2, &v41, (CMBufferQueueTriggerToken *)(v29 + 88));
    if (v16) {
      goto LABEL_36;
    }
    intptr_t v31 = v42;
    uint64_t v32 = *(void *)(v42 + 160);
    uint64_t v33 = *(void *)(a2 + 32);
    long long v34 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(v32 + 112) = *(_OWORD *)a2;
    *(_OWORD *)(v32 + 128) = v34;
    *(void *)(v32 + 144) = v33;
    *(void *)(*(void *)(v31 + 160) + 152) = a3;
    if (!a3 || !a4) {
      goto LABEL_26;
    }
    uint64_t v35 = malloc_type_malloc(a3, 0xC070E024uLL);
    *(void *)(*(void *)(v42 + 160) + 160) = v35;
    if (v35)
    {
      memcpy(v35, a4, a3);
LABEL_26:
      if (a5) {
        CFTypeRef v36 = CFRetain(a5);
      }
      else {
        CFTypeRef v36 = 0;
      }
      uint64_t v37 = v42;
      uint64_t v38 = *(void *)(v42 + 160);
      *(void *)(v38 + 168) = v36;
      *(unsigned char *)(v38 + 104) = 1;
      if (!a6) {
        goto LABEL_33;
      }
      Boolean Value = CFDictionaryGetValue(a6, @"AssetWriterAudioTrackProcessingOption_SourceAudioFormatDescriptionHint");
      uint64_t v37 = v42;
      if (!Value) {
        goto LABEL_33;
      }
      uint64_t v16 = assetWriter_finishBuildingAudioTrackWithSourceFormatDescription(a1, *(void *)(v42 + 160), Value);
      if (!v16)
      {
        uint64_t v37 = v42;
LABEL_33:
        *a7 = *(_DWORD *)(v37 + 300);
        remakerFamily_commitChannel((uint64_t)a1, v37);
        uint64_t v26 = 0;
        intptr_t v42 = 0;
        goto LABEL_34;
      }
LABEL_36:
      uint64_t v26 = v16;
      goto LABEL_34;
    }
LABEL_35:
    uint64_t v16 = FigSignalErrorAt();
    goto LABEL_36;
  }
  uint64_t v26 = 4294954514;
LABEL_34:
  remakerFamily_discardChannel((uint64_t)a1, v42);
  return v26;
}

uint64_t assetWriter_AddAudioTrackWithPresetCompression(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)CMBaseObjectGetDerivedStorage() == 1 && a2)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t result = FigAudioCompressionOptionsGetPreset(a2, &v19, &v18, &v17, &v16);
    if (!result)
    {
      uint64_t v10 = v18;
      uint64_t v9 = v19;
      uint64_t v12 = v16;
      uint64_t v11 = v17;
      uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v13) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = 0;
      }
      uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 16);
      if (v15) {
        return v15(a1, v9, v10, v11, v12, a3, a4);
      }
      else {
        return 4294954514;
      }
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t assetWriter_AddVideoTrackWithCompression(const void *a1, int a2, int a3, uint64_t a4, int a5, const __CFDictionary *a6, const void *a7, uint64_t a8, uint64_t a9, const __CFDictionary *a10, _DWORD *a11)
{
  long long v12 = *(_OWORD *)a9;
  uint64_t v13 = *(void *)(a9 + 16);
  return assetWriter_AddVideoTrackWithCompressionAndMediaType(a1, a2, a3, a4, 1986618469, a5, a6, a7, a8, &v12, a10, a11);
}

uint64_t assetWriter_SetTrackProperty(uint64_t a1, int a2, const void *a3, const void *a4)
{
  if (*(_DWORD *)CMBaseObjectGetDerivedStorage() == 1)
  {
    uint64_t ChannelByWriterTrackID = assetWriter_getChannelByWriterTrackID(a1, a2);
    if (ChannelByWriterTrackID)
    {
      uint64_t v9 = ChannelByWriterTrackID;
      if (*(void *)(ChannelByWriterTrackID + 16))
      {
        uint64_t v10 = FigCFWeakReferenceHolderCopyReferencedObject();
        if (v10)
        {
          uint64_t v11 = (void *)v10;
          if (CFEqual(a3, @"AssetWriterTrack_Metadata"))
          {
            if (!a4)
            {
              uint64_t v19 = (const void *)v11[24];
              if (v19)
              {
                CFRelease(v19);
                uint64_t v15 = 0;
                v11[24] = 0;
              }
              else
              {
                uint64_t v15 = 0;
              }
              goto LABEL_22;
            }
            CFTypeID v12 = CFGetTypeID(a4);
            if (v12 == CFArrayGetTypeID())
            {
              uint64_t v13 = (const void *)v11[24];
              if (v13)
              {
                CFRelease(v13);
                v11[24] = 0;
              }
              CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFArrayRef)a4);
              uint64_t v15 = 0;
              v11[24] = Copy;
              goto LABEL_22;
            }
            goto LABEL_25;
          }
          if (CFEqual(a3, @"AssetWriterTrack_ShouldVerifyFirstAudioSampleBufferPriming"))
          {
            if (!a4 || (CFTypeID v17 = CFGetTypeID(a4), v17 != CFBooleanGetTypeID()))
            {
LABEL_25:
              uint64_t v15 = FigSignalErrorAt();
              goto LABEL_22;
            }
            Boolean Value = CFBooleanGetValue((CFBooleanRef)a4);
            uint64_t v15 = 0;
            *(unsigned char *)(v9 + 176) = Value;
          }
          else
          {
            uint64_t v15 = 4294954512;
          }
LABEL_22:
          CFRelease(v11);
          return v15;
        }
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t assetWriter_CopyTrackProperty(const void *a1, int a2, const void *a3, uint64_t a4, void *a5)
{
  if (*(_DWORD *)CMBaseObjectGetDerivedStorage() < 7u)
  {
    if (a5)
    {
      uint64_t ChannelByWriterTrackID = assetWriter_getChannelByWriterTrackID((uint64_t)a1, a2);
      if (ChannelByWriterTrackID)
      {
        uint64_t v10 = ChannelByWriterTrackID;
        if (*(void *)(ChannelByWriterTrackID + 16))
        {
          uint64_t v11 = FigCFWeakReferenceHolderCopyReferencedObject();
          if (v11)
          {
            uint64_t v12 = v11;
            if (CFEqual(a3, @"AssetWriterTrack_PixelBufferPool"))
            {
              if (*(unsigned char *)(v10 + 104))
              {
                uint64_t v13 = assetWriter_finishBuildingVideoTrackWithPixelBufferAttributes(a1, v10, 0);
                if (v13) {
                  goto LABEL_30;
                }
              }
              uint64_t v14 = *(void *)(v12 + 288);
              if (v14)
              {
                int v15 = *(_DWORD *)(v12 + 32);
                if (v15 == 1986618469 || v15 == 1635088502)
                {
                  PixelBufferPool = FigMediaProcessorGetPixelBufferPool(v14);
                  if (!PixelBufferPool)
                  {
LABEL_14:
                    uint64_t v17 = 0;
                    *a5 = PixelBufferPool;
LABEL_31:
                    CFRelease((CFTypeRef)v12);
                    return v17;
                  }
LABEL_13:
                  PixelBufferPool = CFRetain(PixelBufferPool);
                  goto LABEL_14;
                }
              }
            }
            else
            {
              if (!CFEqual(a3, @"AssetWriterTrack_EncoderSupportsMultiPass"))
              {
                if (!CFEqual(a3, @"AssetWriterTrack_ShouldVerifyFirstAudioSampleBufferPriming"))
                {
                  uint64_t v17 = 4294954512;
                  goto LABEL_31;
                }
                CFTypeRef v24 = (const void **)MEMORY[0x1E4F1CFD0];
                if (!*(unsigned char *)(v10 + 176)) {
                  CFTypeRef v24 = (const void **)MEMORY[0x1E4F1CFC8];
                }
                PixelBufferPool = *v24;
                if (!*v24) {
                  goto LABEL_14;
                }
                goto LABEL_13;
              }
              if (*(unsigned char *)(v10 + 104))
              {
                uint64_t v13 = assetWriter_finishBuildingVideoTrackWithPixelBufferAttributes(a1, v10, 0);
                if (v13)
                {
LABEL_30:
                  uint64_t v17 = v13;
                  goto LABEL_31;
                }
              }
              uint64_t v19 = *(void *)(v12 + 288);
              if (v19)
              {
                int v20 = *(_DWORD *)(v12 + 32);
                if (v20 == 1986618469 || v20 == 1635088502)
                {
                  CFTypeRef propertyValueOut = 0;
                  VTCompressionSession = (const void *)FigMediaProcessorGetVTCompressionSession(v19);
                  OSStatus v22 = VTSessionCopyProperty(VTCompressionSession, (CFStringRef)*MEMORY[0x1E4F44A10], (CFAllocatorRef)*MEMORY[0x1E4F1CF80], &propertyValueOut);
                  int64_t v23 = (void *)MEMORY[0x1E4F1CFD0];
                  if (v22) {
                    int64_t v23 = (void *)MEMORY[0x1E4F1CFC8];
                  }
                  *a5 = *v23;
                  if (propertyValueOut) {
                    CFRelease(propertyValueOut);
                  }
                  uint64_t v17 = 0;
                  goto LABEL_31;
                }
              }
            }
            uint64_t v13 = FigSignalErrorAt();
            goto LABEL_30;
          }
        }
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t assetWriter_BeginSession(const void *a1, CMTime *a2)
{
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  char v76 = 0;
  if (*DerivedStorage < 4u && (a2->flags & 0x1D) == 1)
  {
    uint64_t v5 = DerivedStorage;
    if (*MEMORY[0x1E4F1EBA8] == 1)
    {
      CMTime time = *a2;
      CMTimeGetSeconds(&time);
      kdebug_trace();
    }
    if (*((unsigned char *)v5 + 32))
    {
      uint64_t v68 = a2;
      int v69 = v5;
      uint64_t v6 = CMBaseObjectGetDerivedStorage();
      uint64_t v7 = MEMORY[0x1E4F1F9F8];
      CMTimeValue v94 = *MEMORY[0x1E4F1F9F8];
      CMTimeScale v95 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
      CMTimeEpoch v8 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
      CMTimeValue v92 = v94;
      CMTimeScale v93 = v95;
      long long v73 = *MEMORY[0x1E4F1F9F8];
      *(_OWORD *)&v81.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
      CMTimeEpoch v74 = v8;
      v81.CMTimeEpoch epoch = v8;
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v6 + 80));
      if (Count >= 2)
      {
        CFIndex v10 = Count;
        CFIndex v75 = 0;
        CFIndex v11 = 0;
        CMTimeFlags v12 = *(_DWORD *)(v7 + 12);
        CMTimeEpoch v13 = v74;
        CMTimeEpoch v14 = v74;
        CMTimeFlags v15 = v12;
        CFIndex v72 = Count;
        do
        {
          assetWriter_GetInputQueueLengthBeforeFormatWriterForTrackIndex(a1, v11, (uint64_t)&time);
          CMTimeValue value = time.value;
          CMTimeFlags flags = time.flags;
          CMTimeScale timescale = time.timescale;
          if (time.flags)
          {
            CMTimeEpoch epoch = time.epoch;
            time.CMTimeValue value = value;
            time.CMTimeScale timescale = timescale;
            time2.CMTimeValue value = v94;
            time2.CMTimeScale timescale = v95;
            time2.CMTimeFlags flags = v12;
            time2.CMTimeEpoch epoch = v14;
            if (CMTimeCompare(&time, &time2) < 0)
            {
              CMTimeValue v92 = v94;
              CMTimeScale v93 = v95;
              CMTimeValue v94 = value;
              CFIndex v75 = v11;
              CMTimeScale v95 = timescale;
              CMTimeFlags v15 = v12;
              CMTimeEpoch v13 = v14;
              CMTimeFlags v12 = flags;
              CMTimeEpoch v14 = epoch;
            }
            else
            {
              time2.CMTimeValue value = v92;
              time2.CMTimeScale timescale = v93;
              time2.CMTimeFlags flags = v15;
              time2.CMTimeEpoch epoch = v13;
              v83.CMTimeValue value = value;
              v83.CMTimeScale timescale = timescale;
              v83.CMTimeFlags flags = flags;
              v83.CMTimeEpoch epoch = epoch;
              CMTimeMinimum(&time, &time2, &v83);
              CMTimeValue v92 = time.value;
              CMTimeFlags v15 = time.flags;
              CMTimeScale v93 = time.timescale;
              CMTimeEpoch v13 = time.epoch;
            }
            CFIndex v10 = v72;
          }
          ++v11;
        }
        while (v10 != v11);
        if (v12)
        {
          *(_OWORD *)&time.CMTimeValue value = v73;
          time.CMTimeEpoch epoch = v74;
          uint64_t v18 = CMBaseObjectGetDerivedStorage();
          time2.CMTimeValue value = 0;
          uint64_t v19 = *(void *)(v18 + 184);
          CFAllocatorRef v20 = CFGetAllocator(a1);
          uint64_t FigBaseObject = FigFormatWriterGetFigBaseObject(v19);
          uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v22) {
            uint64_t v23 = v22;
          }
          else {
            uint64_t v23 = 0;
          }
          CFTypeRef v24 = *(uint64_t (**)(uint64_t, __CFString *, CFAllocatorRef, CMTime *))(v23 + 48);
          if (v24)
          {
            int v25 = v24(FigBaseObject, @"InterleavingPeriod", v20, &time2);
            uint64_t v26 = (const void *)time2.value;
            if (!v25)
            {
              CMTimeMakeFromDictionary(&time, (CFDictionaryRef)time2.value);
              uint64_t v26 = (const void *)time2.value;
            }
            if (v26) {
              CFRelease(v26);
            }
          }
          CMTime v82 = time;
          CMTimeMake(&rhs, 1, 1);
          time2.CMTimeValue value = v94;
          time2.CMTimeScale timescale = v95;
          time2.CMTimeFlags flags = v12;
          time2.CMTimeEpoch epoch = v14;
          CMTimeSubtract(&time, &time2, &rhs);
          CMTimeScale v91 = time.timescale;
          CMTimeValue v90 = time.value;
          CMTime time2 = time;
          CMTime v83 = v82;
          CMTimeMaximum(&time, &time2, &v83);
          CMTimeValue v90 = time.value;
          CMTimeFlags v27 = time.flags;
          CMTimeScale v91 = time.timescale;
          CMTimeEpoch v28 = time.epoch;
          CMTimeMake(&v79, 1, 1);
          time2.CMTimeValue value = v92;
          time2.CMTimeScale timescale = v93;
          time2.CMTimeFlags flags = v15;
          time2.CMTimeEpoch epoch = v13;
          CMTimeSubtract(&time, &time2, &v79);
          CMTimeScale v89 = time.timescale;
          CMTimeValue v88 = time.value;
          CMTime time2 = time;
          CMTime v83 = v82;
          CMTimeMaximum(&time, &time2, &v83);
          CMTimeValue v88 = time.value;
          CMTimeFlags v29 = time.flags;
          CMTimeScale v89 = time.timescale;
          CMTimeEpoch v30 = time.epoch;
          CMTimeMake(&v78, 1, 1);
          CMTime time = v82;
          CMTimeAdd(&v81, &time, &v78);
          CFIndex v31 = 0;
          CMTimeEpoch v70 = v30;
          CMTimeFlags v71 = v29;
          while (1)
          {
            uint64_t v32 = v75 == v31 ? &v88 : &v90;
            CMTimeFlags v33 = v75 == v31 ? v29 : v27;
            CMTimeEpoch v34 = v75 == v31 ? v30 : v28;
            CMTimeValue v86 = *v32;
            CMTimeScale v87 = *((_DWORD *)v32 + 2);
            if (v33) {
              break;
            }
LABEL_55:
            if (v10 == ++v31) {
              goto LABEL_56;
            }
          }
          *(_OWORD *)&time.CMTimeValue value = v73;
          time.CMTimeEpoch epoch = v74;
          uint64_t v35 = CMBaseObjectGetDerivedStorage();
          time2.CMTimeValue value = 0;
          CFNumberRef ValueAtIndex = (unsigned int *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v35 + 80), v31);
          uint64_t v37 = *(void *)(v35 + 184);
          uint64_t v38 = ValueAtIndex[75];
          CFAllocatorRef v39 = CFGetAllocator(a1);
          uint64_t v40 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v40) {
            uint64_t v41 = v40;
          }
          else {
            uint64_t v41 = 0;
          }
          intptr_t v42 = *(uint64_t (**)(uint64_t, uint64_t, __CFString *, CFAllocatorRef, CMTime *))(v41 + 16);
          if (v42)
          {
            int v43 = v42(v37, v38, @"InterleavingAdvance", v39, &time2);
            uint64_t v44 = (const void *)time2.value;
            if (!v43)
            {
              CMTimeMakeFromDictionary(&time, (CFDictionaryRef)time2.value);
              uint64_t v44 = (const void *)time2.value;
            }
            if (v44) {
              CFRelease(v44);
            }
          }
          CMTime time2 = time;
          time.CMTimeValue value = v86;
          time.CMTimeScale timescale = v87;
          time.CMTimeFlags flags = v33;
          time.CMTimeEpoch epoch = v34;
          if (CMTimeCompare(&time2, &time) < 1)
          {
LABEL_52:
            CMTime v77 = v81;
            uint64_t v55 = CMBaseObjectGetDerivedStorage();
            *(_OWORD *)&time.CMTimeValue value = v73;
            time.CMTimeEpoch epoch = v74;
            assetWriter_GetInputQueueLengthBeforeFormatWriterForTrackIndex(a1, v31, (uint64_t)&time);
            CMTime time2 = time;
            CMTime v83 = v77;
            CFIndex v10 = v72;
            CMTimeEpoch v30 = v70;
            if (CMTimeCompare(&time2, &v83) < 0) {
              *(CMTime *)(*((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v55 + 80), v31) + 20) + 64) = v77;
            }
            CMTimeFlags v29 = v71;
            goto LABEL_55;
          }
          uint64_t v45 = CMBaseObjectGetDerivedStorage();
          CFAllocatorRef v46 = CFGetAllocator(a1);
          time.CMTimeValue value = v86;
          time.CMTimeScale timescale = v87;
          time.CMTimeFlags flags = v33;
          time.CMTimeEpoch epoch = v34;
          CFDictionaryRef v47 = CMTimeCopyAsDictionary(&time, v46);
          uint64_t v48 = (unsigned int *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v45 + 80), v31);
          uint64_t v49 = *(void *)(v45 + 184);
          uint64_t v50 = v48[75];
          uint64_t v51 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v51) {
            uint64_t v52 = v51;
          }
          else {
            uint64_t v52 = 0;
          }
          CMBlockBufferRef v53 = *(uint64_t (**)(uint64_t, uint64_t, __CFString *, CFDictionaryRef))(v52 + 24);
          if (v53)
          {
            uint64_t v54 = v53(v49, v50, @"InterleavingAdvance", v47);
            if (!v47)
            {
LABEL_51:
              if (v54) {
                return v54;
              }
              goto LABEL_52;
            }
          }
          else
          {
            uint64_t v54 = 4294954514;
            if (!v47) {
              goto LABEL_51;
            }
          }
          CFRelease(v47);
          goto LABEL_51;
        }
      }
LABEL_56:
      a2 = v68;
      uint64_t v5 = v69;
    }
    uint64_t updated = remakerfamily_updateClientPID();
    if (updated) {
      return updated;
    }
    uint64_t updated = remakerfamily_updateThrottleForBackground(a1);
    if (updated) {
      return updated;
    }
    uint64_t updated = remakerfamily_updateJoinWritingThreadToNewWorkgroup();
    if (updated) {
      return updated;
    }
    uint64_t v57 = *((void *)v5 + 23);
    CMTime time2 = *a2;
    uint64_t v58 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v58) {
      uint64_t v59 = v58;
    }
    else {
      uint64_t v59 = 0;
    }
    CMBlockBufferRef v60 = *(uint64_t (**)(uint64_t, CMTime *))(v59 + 56);
    if (v60)
    {
      CMTime time = time2;
      uint64_t updated = v60(v57, &time);
      if (updated) {
        return updated;
      }
      remakerFamily_transferMetadata(a1);
      if (*v5 == 3)
      {
LABEL_66:
        remakerFamily_SetRemakerState((uint64_t)a1, 3, 0);
        return 0;
      }
      uint64_t updated = remakerFamily_startAllMultiPassTracks((uint64_t)a1, &v76);
      if (updated) {
        return updated;
      }
      if (!v76)
      {
        uint64_t updated = remakerFamily_startAllSinglePassTracks((uint64_t)a1);
        if (updated) {
          return updated;
        }
      }
      uint64_t v61 = *((void *)v5 + 42);
      if (!v61)
      {
LABEL_75:
        uint64_t v65 = CMBaseObjectGetDerivedStorage();
        if (!remakerFamily_hasTrackForMediaType((uint64_t)a1, 1986618469) || *(void *)(v65 + 352)) {
          goto LABEL_66;
        }
        CFStringRef v66 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"com.apple.coremedia.figassetwriter.writing-video-%d", *(unsigned int *)(v65 + 36));
        *(void *)(v65 + 352) = v66;
        if (!v66)
        {
          uint64_t v54 = FigSignalErrorAt();
          if (v54) {
            return v54;
          }
          goto LABEL_66;
        }
        uint64_t updated = remakerFamily_registerDarwinNotification((uint64_t)v66, (int *)(v65 + 360));
        if (!updated)
        {
          uint64_t updated = remakerFamily_postDarwinNotificationWithState(*(void *)(v65 + 352), *(_DWORD *)(v65 + 360), 1uLL);
          if (!updated)
          {
            *(void *)(v65 + 368) = 1;
            goto LABEL_66;
          }
        }
        return updated;
      }
      uint64_t v62 = 56;
      if (!*((unsigned char *)v5 + 240)) {
        uint64_t v62 = 40;
      }
      uint64_t v63 = *(void *)&v5[v62];
      uint64_t v64 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(CMBaseObjectGetVTable() + 16) + 16);
      if (v64)
      {
        uint64_t v54 = v64(v61, v63);
        if (v54) {
          return v54;
        }
        goto LABEL_75;
      }
    }
    return 4294954514;
  }

  return FigSignalErrorAt();
}

uint64_t assetWriter_AddSampleBuffer(const void *a1, uint64_t a2, opaqueCMSampleBuffer *a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage < 7u)
  {
    uint64_t v7 = DerivedStorage;
    if (!DerivedStorage[5] && *DerivedStorage == 3)
    {
      if (a3)
      {
        uint64_t ChannelByWriterTrackID = assetWriter_getChannelByWriterTrackID((uint64_t)a1, a2);
        if (ChannelByWriterTrackID)
        {
          uint64_t v9 = ChannelByWriterTrackID;
          if (*(void *)(ChannelByWriterTrackID + 16))
          {
            uint64_t v10 = FigCFWeakReferenceHolderCopyReferencedObject();
            if (v10)
            {
              CFIndex v11 = (_DWORD *)v10;
              if (CMSampleBufferGetNumSamples(a3)
                && !assetWriter_IsTrackNativeTrack(a1, v9)
                && (CMBlockBufferRef DataBuffer = CMSampleBufferGetDataBuffer(a3),
                    CVImageBufferRef ImageBuffer = CMSampleBufferGetImageBuffer(a3),
                    uint64_t CaptionGroup = FigSampleBufferGetCaptionGroup(),
                    !DataBuffer)
                && !ImageBuffer
                && !CaptionGroup
                || (CMSampleBufferGetDuration(&time1, a3), (time1.flags & 1) != 0)
                && (CMSampleBufferGetDuration(&lhs, a3), (lhs.flags & 8) != 0))
              {
                uint64_t v32 = FigSignalErrorAt();
                if (v32) {
                  goto LABEL_58;
                }
              }
              if (v11[8] == 1936684398)
              {
                if (!*(unsigned char *)(v9 + 104)) {
                  goto LABEL_69;
                }
                CMFormatDescriptionRef FormatDescription = CMSampleBufferGetFormatDescription(a3);
                uint64_t v16 = assetWriter_finishBuildingAudioTrackWithSourceFormatDescription(a1, v9, FormatDescription);
                if (v16) {
                  goto LABEL_51;
                }
                if (v11[8] == 1936684398)
                {
LABEL_69:
                  if (*(unsigned char *)(v9 + 176))
                  {
                    if (CMSampleBufferGetNumSamples(a3) >= 1)
                    {
                      CMTime v39 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
                      if (!*(unsigned char *)(v9 + 177))
                      {
                        CFDictionaryRef v17 = (const __CFDictionary *)CMGetAttachment(a3, (CFStringRef)*MEMORY[0x1E4F1F308], 0);
                        CMTimeMakeFromDictionary(&time1, v17);
                        CMTimeValue value = time1.value;
                        CMTimeFlags flags = time1.flags;
                        CMTimeScale timescale = time1.timescale;
                        if (time1.flags)
                        {
                          CMTimeEpoch epoch = time1.epoch;
                        }
                        else
                        {
                          CMTimeValue value = *MEMORY[0x1E4F1FA48];
                          CMTimeFlags flags = *(_DWORD *)(MEMORY[0x1E4F1FA48] + 12);
                          CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1FA48] + 8);
                          CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16);
                        }
                        uint64_t v21 = (_OWORD *)(v9 + 180);
                        if (*(unsigned char *)(v9 + 192))
                        {
                          *(_OWORD *)&lhs.CMTimeValue value = *v21;
                          lhs.CMTimeEpoch epoch = *(void *)(v9 + 196);
                          rhs.CMTimeValue value = value;
                          rhs.CMTimeScale timescale = timescale;
                          rhs.CMTimeFlags flags = flags;
                          rhs.CMTimeEpoch epoch = epoch;
                          CMTimeAdd(&time1, &lhs, &rhs);
                          *uint64_t v21 = *(_OWORD *)&time1.value;
                          *(void *)(v9 + 196) = time1.epoch;
                        }
                        else
                        {
                          *(void *)uint64_t v21 = value;
                          *(_DWORD *)(v9 + 188) = timescale;
                          *(_DWORD *)(v9 + 192) = flags;
                          *(void *)(v9 + 196) = epoch;
                        }
                        CMSampleBufferGetDuration(&v39, a3);
                        CMTime time1 = v39;
                        lhs.CMTimeValue value = value;
                        lhs.CMTimeScale timescale = timescale;
                        lhs.CMTimeFlags flags = flags;
                        lhs.CMTimeEpoch epoch = epoch;
                        if (CMTimeCompare(&time1, &lhs) >= 1)
                        {
                          uint64_t v22 = CMSampleBufferGetFormatDescription(a3);
                          *(_OWORD *)&v38.CMTimeValue value = *v21;
                          v38.CMTimeEpoch epoch = *(void *)(v9 + 196);
                          MostCompatibleFormat = CMAudioFormatDescriptionGetMostCompatibleFormat(v22);
                          if (MostCompatibleFormat)
                          {
                            memset(&time1, 0, sizeof(time1));
                            CMTimeMake(&time1, MostCompatibleFormat->mASBD.mFramesPerPacket, (int)MostCompatibleFormat->mASBD.mSampleRate);
                            GradualDecoderRefresh = (const void *)FigGaplessInfoCreateGradualDecoderRefresh(v22);
                            int32_t SInt32 = FigCFNumberGetSInt32();
                            memset(&lhs, 0, sizeof(lhs));
                            CMTime rhs = time1;
                            CMTimeMultiply(&lhs, &rhs, SInt32);
                            memset(&rhs, 0, sizeof(rhs));
                            FigGaplessInfoGetDefaultAudioPrimingDuration(v22, &rhs);
                            memset(&v42, 0, sizeof(v42));
                            CMTime time = lhs;
                            CMTime time2 = rhs;
                            CMTimeMinimum(&v42, &time, &time2);
                            CMTime time = v38;
                            CMTime time2 = v42;
                            if (CMTimeCompare(&time, &time2) < 0)
                            {
                              CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                              CMTime time = v38;
                              CFStringRef v27 = CMTimeCopyDescription(v26, &time);
                              CMTime time = rhs;
                              CFStringRef v28 = CMTimeCopyDescription(v26, &time);
                              CMTime time = time1;
                              CFStringRef v29 = CMTimeCopyDescription(v26, &time);
                              if (v29) {
                                CFRelease(v29);
                              }
                              if (v28) {
                                CFRelease(v28);
                              }
                              if (v27) {
                                CFRelease(v27);
                              }
                            }
                            if (GradualDecoderRefresh) {
                              CFRelease(GradualDecoderRefresh);
                            }
                          }
                          *(unsigned char *)(v9 + 177) = 1;
                        }
                      }
                    }
                  }
                }
              }
              if (*(unsigned char *)(v9 + 104))
              {
                time1.CMTimeValue value = 0;
                CMTimeEpoch v30 = CMSampleBufferGetImageBuffer(a3);
                if (!v30)
                {
                  uint64_t v16 = FigSignalErrorAt();
                  goto LABEL_51;
                }
                uint64_t v16 = assetWriter_copyPixelBufferAttributesForHintingEncoder(v30, (CFDictionaryRef *)&time1);
                if (v16)
                {
LABEL_51:
                  uint64_t v32 = v16;
LABEL_58:
                  CFRelease(v11);
                  return v32;
                }
                CFIndex v31 = (const void *)time1.value;
                uint64_t v32 = assetWriter_finishBuildingVideoTrackWithPixelBufferAttributes(a1, v9, (const __CFDictionary *)time1.value);
                if (v31) {
                  CFRelease(v31);
                }
                if (v32) {
                  goto LABEL_58;
                }
              }
              CMTimeFlags v33 = *(opaqueCMBufferQueue **)(v9 + 32);
              if (v33)
              {
                uint64_t v16 = CMBufferQueueEnqueue(v33, a3);
              }
              else
              {
                uint64_t v34 = *((void *)v7 + 23);
                uint64_t v35 = *(void *)(CMBaseObjectGetVTable() + 16);
                if (v35) {
                  uint64_t v36 = v35;
                }
                else {
                  uint64_t v36 = 0;
                }
                uint64_t v37 = *(uint64_t (**)(uint64_t, uint64_t, opaqueCMSampleBuffer *))(v36 + 32);
                if (!v37)
                {
                  uint64_t v32 = 4294954514;
                  goto LABEL_58;
                }
                uint64_t v16 = v37(v34, a2, a3);
              }
              goto LABEL_51;
            }
          }
        }
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t assetWriter_AddPixelBuffer(const void *a1, int a2, __CVBuffer *a3, CMTime *a4)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  CMSampleBufferRef sampleBufferOut = 0;
  memset(&sampleTiming, 0, sizeof(sampleTiming));
  if (*DerivedStorage >= 7u
    || DerivedStorage[5]
    || *DerivedStorage != 3
    || !a3
    || (a4->flags & 0x1D) != 1
    || (uint64_t ChannelByWriterTrackID = assetWriter_getChannelByWriterTrackID((uint64_t)a1, a2)) == 0
    || (uint64_t v10 = ChannelByWriterTrackID, !*(void *)(ChannelByWriterTrackID + 16))
    || (uint64_t v11 = FigCFWeakReferenceHolderCopyReferencedObject()) == 0)
  {
    uint64_t v20 = FigSignalErrorAt();
    CMTimeFlags v12 = 0;
    goto LABEL_26;
  }
  CMTimeFlags v12 = (const void *)v11;
  int v13 = *(_DWORD *)(v11 + 32);
  if (v13 != 1635088502 && v13 != 1986618469)
  {
    uint64_t v17 = FigSignalErrorAt();
    goto LABEL_25;
  }
  CMTimeFlags v15 = (CFTypeRef *)(v10 + 96);
  CMTimeEpoch v14 = *(const opaqueCMFormatDescription **)(v10 + 96);
  if (v14)
  {
    if (CMVideoFormatDescriptionMatchesImageBuffer(v14, a3)) {
      goto LABEL_16;
    }
    if (*v15)
    {
      CFRelease(*v15);
      *CMTimeFlags v15 = 0;
    }
  }
  CFAllocatorRef v16 = CFGetAllocator(a1);
  uint64_t v17 = CMVideoFormatDescriptionCreateForImageBuffer(v16, a3, (CMVideoFormatDescriptionRef *)(v10 + 96));
  if (v17) {
    goto LABEL_25;
  }
LABEL_16:
  *(_OWORD *)&sampleTiming.duration.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  sampleTiming.duration.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  sampleTiming.CMTime presentationTimeStamp = *a4;
  sampleTiming.decodeTimeStamp = sampleTiming.duration;
  CFAllocatorRef v18 = CFGetAllocator(a1);
  uint64_t v17 = CMSampleBufferCreateForImageBuffer(v18, a3, 1u, 0, 0, (CMVideoFormatDescriptionRef)*v15, &sampleTiming, &sampleBufferOut);
  if (v17) {
    goto LABEL_25;
  }
  if (!*(unsigned char *)(v10 + 104))
  {
LABEL_22:
    uint64_t v17 = CMBufferQueueEnqueue(*(CMBufferQueueRef *)(v10 + 32), sampleBufferOut);
    goto LABEL_25;
  }
  CFDictionaryRef v22 = 0;
  uint64_t v17 = assetWriter_copyPixelBufferAttributesForHintingEncoder(a3, &v22);
  if (v17)
  {
LABEL_25:
    uint64_t v20 = v17;
    goto LABEL_26;
  }
  CFDictionaryRef v19 = v22;
  uint64_t v20 = assetWriter_finishBuildingVideoTrackWithPixelBufferAttributes(a1, v10, v22);
  if (v19) {
    CFRelease(v19);
  }
  if (!v20) {
    goto LABEL_22;
  }
LABEL_26:
  if (sampleBufferOut) {
    CFRelease(sampleBufferOut);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v20;
}

opaqueCMBufferQueue *assetWriter_IsTrackQueueAboveHighWaterLevel(uint64_t a1, int a2)
{
  if (*(_DWORD *)CMBaseObjectGetDerivedStorage() < 7u
    && (uint64_t ChannelByWriterTrackID = assetWriter_getChannelByWriterTrackID(a1, a2)) != 0)
  {
    uint64_t v5 = ChannelByWriterTrackID;
    uint64_t result = *(opaqueCMBufferQueue **)(ChannelByWriterTrackID + 32);
    if (result)
    {
      memset(&v9, 0, sizeof(v9));
      CMBufferQueueGetDuration(&v9, result);
      CMTime time1 = v9;
      CMTime v7 = *(CMTime *)(v5 + 64);
      return (opaqueCMBufferQueue *)(CMTimeCompare(&time1, &v7) > 0);
    }
  }
  else
  {
    FigSignalErrorAt();
    return 0;
  }
  return result;
}

uint64_t assetWriter_MarkEndOfDataForTrack(uint64_t a1, int a2)
{
  unsigned int v4 = *(_DWORD *)CMBaseObjectGetDerivedStorage();
  if (v4 < 7
    && v4 > 2
    && (uint64_t ChannelByWriterTrackID = assetWriter_getChannelByWriterTrackID(a1, a2)) != 0
    && *(void *)(ChannelByWriterTrackID + 16)
    && (uint64_t v6 = FigCFWeakReferenceHolderCopyReferencedObject()) != 0)
  {
    CMTime v7 = (const void *)v6;
    uint64_t v8 = remakerFamily_MarkEndOfDataForTrack(v6, 1);
    CFRelease(v7);
    return v8;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t assetWriter_EndSession(uint64_t a1, CMTime *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*MEMORY[0x1E4F1EBA8] == 1)
  {
    CMTime time = *a2;
    CMTimeGetSeconds(&time);
    kdebug_trace();
  }
  unsigned int v4 = *(_DWORD *)DerivedStorage;
  if (*(_DWORD *)DerivedStorage >= 7u
    || *(_DWORD *)(DerivedStorage + 20)
    || v4 >= 5
    || v4 <= 2
    || (a2->flags & 0x1D) != 1)
  {
    return FigSignalErrorAt();
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 80));
  if (Count < 1)
  {
LABEL_15:
    uint64_t v12 = *(void *)(DerivedStorage + 184);
    *(_OWORD *)&v16.CMTimeValue value = *(_OWORD *)&a2->value;
    v16.CMTimeEpoch epoch = a2->epoch;
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    CMTimeFlags v15 = *(uint64_t (**)(uint64_t, CMTime *))(v14 + 64);
    if (v15)
    {
      CMTime time = v16;
      return v15(v12, &time);
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    CFIndex v6 = Count;
    for (CFIndex i = 0; i != v6; ++i)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 80), i);
      CMBufferQueueMarkEndOfData(*(CMBufferQueueRef *)(ValueAtIndex[20] + 32));
    }
    CFIndex v9 = 0;
    while (1)
    {
      uint64_t v10 = *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 80), v9) + 36);
      if (v10)
      {
        uint64_t result = FigMediaProcessorFlush(v10);
        if (result) {
          break;
        }
      }
      if (v6 == ++v9) {
        goto LABEL_15;
      }
    }
  }
  return result;
}

uint64_t assetWriter_Finish(void *a1)
{
  uint64_t DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage();
  if (*(_DWORD *)DerivedStorage >= 7u
    || (uint64_t v3 = DerivedStorage, *((_DWORD *)DerivedStorage + 5))
    || *(_DWORD *)DerivedStorage <= 2u)
  {
    return FigSignalErrorAt();
  }
  else
  {
    if (*MEMORY[0x1E4F1EBA8] == 1) {
      kdebug_trace();
    }
    FigAtomicCompareAndSwap32();
    dispatch_sync_f(v3[7], a1, (dispatch_function_t)assetWriter_finishAsyncDispatch);
    FigSemaphoreWaitRelative();
    FigSemaphoreSignal();
    return *((unsigned int *)v3 + 5);
  }
}

uint64_t assetWriter_FinishAsync(void *a1)
{
  uint64_t DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage();
  if (*(_DWORD *)DerivedStorage >= 7u
    || (uint64_t v3 = DerivedStorage, *((_DWORD *)DerivedStorage + 5))
    || *(_DWORD *)DerivedStorage <= 2u)
  {
    return FigSignalErrorAt();
  }
  else
  {
    if (*MEMORY[0x1E4F1EBA8] == 1) {
      kdebug_trace();
    }
    FigAtomicCompareAndSwap32();
    remakerFamily_safeDispatchAsync(v3[7], a1, (dispatch_function_t)assetWriter_finishAsyncDispatch);
    return 0;
  }
}

uint64_t assetWriter_BeginPass(uint64_t a1, int a2)
{
  CFIndex v13 = 0;
  uint64_t v14 = 0;
  if (*(_DWORD *)CMBaseObjectGetDerivedStorage() == 3)
  {
    if (*MEMORY[0x1E4F1EBA8] == 1) {
      kdebug_trace();
    }
    uint64_t ChannelByWriterTrackID = assetWriter_getChannelByWriterTrackID(a1, a2);
    if (ChannelByWriterTrackID)
    {
      uint64_t v5 = ChannelByWriterTrackID;
      if (*(void *)(ChannelByWriterTrackID + 16))
      {
        uint64_t v6 = FigCFWeakReferenceHolderCopyReferencedObject();
        if (v6)
        {
          uint64_t v7 = v6;
          if (!*(unsigned char *)(v6 + 360)) {
            goto LABEL_24;
          }
          *(unsigned char *)(v6 + 432) = 0;
          if (*(unsigned char *)(v5 + 104))
          {
            uint64_t v8 = 0;
            *(unsigned char *)(v5 + 204) = 1;
LABEL_21:
            free(v14);
            CFRelease((CFTypeRef)v7);
            return v8;
          }
          if (*(void *)(v6 + 288))
          {
            CFArrayRef v10 = *(const __CFArray **)(v6 + 408);
            if (!v10
              || CFArrayGetCount(v10) < 1
              || (uint64_t Pass = remakerFamily_createTimeRangesCArray(*(CFArrayRef *)(v7 + 408), &v13, &v14), !Pass)
              && (uint64_t Pass = VTFrameSiloSetTimeRangesForNextPass(*(VTFrameSiloRef *)(v7 + 368), v13, (const CMTimeRange *)v14), !Pass))
            {
              VTCompressionSession = (OpaqueVTCompressionSession *)FigMediaProcessorGetVTCompressionSession(*(void *)(v7 + 288));
              uint64_t Pass = VTCompressionSessionBeginPass(VTCompressionSession, 0, 0);
              if (!Pass)
              {
                *(unsigned char *)(v7 + 296) = 0;
                uint64_t Pass = CMBufferQueueReset(*(CMBufferQueueRef *)(v5 + 32));
              }
            }
          }
          else
          {
LABEL_24:
            uint64_t Pass = FigSignalErrorAt();
          }
          uint64_t v8 = Pass;
          goto LABEL_21;
        }
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t assetWriter_EndPass(uint64_t a1, int a2)
{
  if (*(_DWORD *)CMBaseObjectGetDerivedStorage() != 3) {
    goto LABEL_10;
  }
  if (*MEMORY[0x1E4F1EBA8] == 1) {
    kdebug_trace();
  }
  uint64_t ChannelByWriterTrackID = assetWriter_getChannelByWriterTrackID(a1, a2);
  if (ChannelByWriterTrackID
    && *(void *)(ChannelByWriterTrackID + 16)
    && (uint64_t v5 = FigCFWeakReferenceHolderCopyReferencedObject()) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)v5;
    int v7 = *(unsigned __int8 *)(v5 + 360);
    if (!*(unsigned char *)(v5 + 360))
    {
      FigSignalErrorAt();
      int v7 = v6[360];
    }
    uint64_t v8 = remakerFamily_MarkEndOfDataForTrack((uint64_t)v6, v7 == 0);
    CFRelease(v6);
    return v8;
  }
  else
  {
LABEL_10:
    return FigSignalErrorAt();
  }
}

uint64_t assetWriter_AddCaptionTrack(const void *a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  v53[0] = 0;
  CMTime v52 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  char v51 = 0;
  if (*DerivedStorage != 1 || !a5)
  {
    uint64_t Channel = FigSignalErrorAt();
    goto LABEL_42;
  }
  CFArrayRef v10 = DerivedStorage;
  uint64_t Channel = remakerFamily_createChannel(a1, 0, a2, v53);
  if (Channel) {
    goto LABEL_42;
  }
  uint64_t v12 = *((void *)v10 + 23);
  intptr_t v13 = v53[0];
  uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  CMTime v16 = *(uint64_t (**)(uint64_t, uint64_t, void, intptr_t))(v15 + 8);
  if (!v16)
  {
    uint64_t v25 = 4294954514;
LABEL_16:
    remakerFamily_discardChannel((uint64_t)a1, v53[0]);
    return v25;
  }
  uint64_t Channel = v16(v12, a2, 0, v13 + 300);
  if (Channel
    || (uint64_t Channel = remakerFamily_setFormatWriterTrackProperties((uint64_t)a1, *(unsigned int *)(v53[0] + 300)),
        Channel)
    || (uint64_t Channel = remakerFamily_setFormatWriterProperties((uint64_t)a1, a3), Channel))
  {
LABEL_42:
    uint64_t v25 = Channel;
    goto LABEL_16;
  }
  int CMTimeIfPresent = FigCFDictionaryGetCMTimeIfPresent();
  CFAllocatorRef v18 = (uint64_t *)MEMORY[0x1E4F1CF80];
  if (CMTimeIfPresent && (v52.flags & 0x1D) == 1)
  {
    CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CMTime time = v52;
    CFDictionaryRef v20 = CMTimeCopyAsDictionary(&time, v19);
    uint64_t v21 = *((void *)v10 + 23);
    uint64_t v22 = *(unsigned int *)(v53[0] + 300);
    uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v23) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = 0;
    }
    CFDictionaryRef v47 = *(void (**)(uint64_t, uint64_t, __CFString *, CFDictionaryRef))(v24 + 24);
    if (v47) {
      v47(v21, v22, @"CaptionTimeCodeFrameDuration", v20);
    }
  }
  else
  {
    CFDictionaryRef v20 = 0;
  }
  if (FigCFDictionaryGetBooleanIfPresent())
  {
    uint64_t v26 = *((void *)v10 + 23);
    uint64_t v27 = *(unsigned int *)(v53[0] + 300);
    CFStringRef v28 = (void *)(v51 ? MEMORY[0x1E4F1CFD0] : MEMORY[0x1E4F1CFC8]);
    uint64_t v29 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v30 = v29 ? v29 : 0;
    CFIndex v31 = *(void (**)(uint64_t, uint64_t, __CFString *, void))(v30 + 24);
    if (v31) {
      v31(v26, v27, @"UseDropFrameTimeCode", *v28);
    }
  }
  CFAllocatorRef v32 = CFGetAllocator(a1);
  CallbacksForUnsortedSampleBuffers = CMBufferQueueGetCallbacksForUnsortedSampleBuffers();
  uint64_t v34 = CMBufferQueueCreate(v32, 0, CallbacksForUnsortedSampleBuffers, (CMBufferQueueRef *)(*(void *)(v53[0] + 160) + 32));
  uint64_t v35 = v53[0];
  if (v34) {
    goto LABEL_43;
  }
  uint64_t v36 = *(void *)(v53[0] + 160);
  remakerFamily_getLowWaterLevel(*((unsigned __int8 *)v10 + 32), (uint64_t)&time);
  *(CMTime *)(v36 + 40) = time;
  uint64_t v37 = *(void *)(v53[0] + 160);
  remakerFamily_getHighWaterLevel(*((unsigned __int8 *)v10 + 32), (uint64_t)&time);
  *(CMTime *)(v37 + 64) = time;
  uint64_t v38 = *(void *)(v53[0] + 160);
  CMTime v39 = *(opaqueCMBufferQueue **)(v38 + 32);
  CMTime time = *(CMTime *)(v38 + 40);
  uint64_t v34 = CMBufferQueueInstallTrigger(v39, (CMBufferQueueTriggerCallback)assetWriterTrack_reachedLowWater, (void *)v38, 2, &time, (CMBufferQueueTriggerToken *)(v38 + 88));
  uint64_t v35 = v53[0];
  if (v34)
  {
LABEL_43:
    uint64_t v25 = v34;
  }
  else
  {
    uint64_t v40 = *v18;
    uint64_t v41 = *(const void **)(*(void *)(v53[0] + 160) + 32);
    CMTime v42 = (const void *)*((void *)v10 + 23);
    uint64_t v43 = *(unsigned int *)(v53[0] + 300);
    CMTimeMake(&v49, 2, 1);
    CMTimeMake(&v48, 1, 1);
    if (*((unsigned char *)v10 + 32)) {
      int v44 = 0;
    }
    else {
      int v44 = 31;
    }
    uint64_t v45 = FigMediaProcessorCreateForCaptionConversionWithFormatWriter(v40, a2, a3, v41, v42, v43, (long long *)&v49.value, 0, (long long *)&v48.value, 0, v44, (uint64_t *)(v53[0] + 288));
    if (v45)
    {
      uint64_t v25 = v45;
      uint64_t v35 = v53[0];
    }
    else
    {
      CMNotificationCenterGetDefaultLocalCenter();
      uint64_t v25 = FigNotificationCenterAddWeakListeners();
      uint64_t v35 = v53[0];
      if (!v25)
      {
        *a5 = *(_DWORD *)(v53[0] + 300);
        remakerFamily_commitChannel((uint64_t)a1, v35);
        uint64_t v35 = 0;
        v53[0] = 0;
      }
    }
  }
  remakerFamily_discardChannel((uint64_t)a1, v35);
  if (v20) {
    CFRelease(v20);
  }
  return v25;
}

uint64_t assetWriter_Flush()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(_DWORD *)(DerivedStorage + 20)
    || *(_DWORD *)DerivedStorage >= 5u
    || *(_DWORD *)DerivedStorage <= 2u
    || *(unsigned char *)(DerivedStorage + 304) != 1)
  {
    return FigSignalErrorAt();
  }
  else
  {
    if (*MEMORY[0x1E4F1EBA8] == 1) {
      kdebug_trace();
    }
    uint64_t v1 = *(void *)(DerivedStorage + 184);
    uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v2) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = 0;
    }
    unsigned int v4 = *(uint64_t (**)(uint64_t, void))(v3 + 40);
    if (v4)
    {
      return v4(v1, 0);
    }
    else
    {
      return 4294954514;
    }
  }
}

uint64_t assetWriter_AddTaggedBufferGroup(const void *a1, int a2, OpaqueCMTaggedBufferGroup *a3, long long *a4)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  CMBufferRef buf = 0;
  if (*DerivedStorage < 7u)
  {
    if (DerivedStorage[5]
      || *DerivedStorage != 3
      || !a3
      || (*((_DWORD *)a4 + 3) & 0x1D) != 1
      || (uint64_t ChannelByWriterTrackID = assetWriter_getChannelByWriterTrackID((uint64_t)a1, a2)) == 0
      || (uint64_t v10 = ChannelByWriterTrackID, !*(void *)(ChannelByWriterTrackID + 16))
      || (uint64_t v11 = FigCFWeakReferenceHolderCopyReferencedObject()) == 0)
    {
      uint64_t v18 = FigSignalErrorAt();
      uint64_t v12 = 0;
LABEL_25:
      if (buf) {
        CFRelease(buf);
      }
      if (v12) {
        CFRelease(v12);
      }
      return v18;
    }
    uint64_t v12 = (const void *)v11;
    int v13 = *(_DWORD *)(v11 + 32);
    if (v13 != 1986618469 && v13 != 1635088502) {
      goto LABEL_23;
    }
    if (CMTaggedBufferGroupGetCount(a3) >= 1)
    {
      CFIndex v14 = 0;
      while (CMTaggedBufferGroupGetCVPixelBufferAtIndex(a3, v14))
      {
        if (++v14 >= CMTaggedBufferGroupGetCount(a3)) {
          goto LABEL_15;
        }
      }
LABEL_23:
      uint64_t v15 = FigSignalErrorAt();
      goto LABEL_24;
    }
LABEL_15:
    CFGetAllocator(a1);
    long long v20 = *a4;
    uint64_t v21 = *((void *)a4 + 2);
    uint64_t v15 = FigSampleBufferCreateForTaggedBufferGroup();
    if (!v15)
    {
      if (!*(unsigned char *)(v10 + 104))
      {
LABEL_21:
        uint64_t v15 = CMBufferQueueEnqueue(*(CMBufferQueueRef *)(v10 + 32), buf);
        goto LABEL_24;
      }
      *(void *)&long long v20 = 0;
      CVPixelBufferAtIndex = (__CVBuffer *)FigTaggedBufferGroupGetCVPixelBufferAtIndex();
      uint64_t v15 = assetWriter_copyPixelBufferAttributesForHintingEncoder(CVPixelBufferAtIndex, (CFDictionaryRef *)&v20);
      if (!v15)
      {
        uint64_t v17 = (const void *)v20;
        uint64_t v18 = assetWriter_finishBuildingVideoTrackWithPixelBufferAttributes(a1, v10, (const __CFDictionary *)v20);
        if (v17) {
          CFRelease(v17);
        }
        if (v18) {
          goto LABEL_25;
        }
        goto LABEL_21;
      }
    }
LABEL_24:
    uint64_t v18 = v15;
    goto LABEL_25;
  }

  return FigSignalErrorAt();
}

uint64_t assetWriter_AddVideoTrackWithCompressionAndMediaType(const void *a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, const __CFDictionary *a7, const void *a8, uint64_t a9, long long *a10, const __CFDictionary *a11, _DWORD *a12)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage();
  CFTypeRef v54 = 0;
  uint64_t v55 = 0;
  if (*DerivedStorage != 1 || (long long v20 = DerivedStorage, !a6) || !a12)
  {
    uint64_t v21 = FigSignalErrorAt();
    goto LABEL_59;
  }
  uint64_t v21 = remakerFamily_createChannel(a1, 0, a5, &v55);
  if (v21) {
    goto LABEL_59;
  }
  int v51 = a2;
  int v52 = a3;
  uint64_t v22 = *((void *)v20 + 23);
  uint64_t v23 = v55;
  uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v24) {
    uint64_t v25 = v24;
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v26 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v25 + 8);
  if (!v26)
  {
    uint64_t v34 = 4294954514;
    goto LABEL_20;
  }
  uint64_t v21 = v26(v22, a5, 0, v23 + 300);
  if (v21) {
    goto LABEL_59;
  }
  uint64_t v21 = remakerFamily_setFormatWriterTrackProperties((uint64_t)a1, *(unsigned int *)(v55 + 300));
  if (v21) {
    goto LABEL_59;
  }
  uint64_t v21 = remakerFamily_setFormatWriterProperties((uint64_t)a1, a6);
  if (v21) {
    goto LABEL_59;
  }
  CFAllocatorRef v27 = CFGetAllocator(a1);
  CallbacksForUnsortedSampleBuffers = CMBufferQueueGetCallbacksForUnsortedSampleBuffers();
  uint64_t v21 = CMBufferQueueCreate(v27, 0, CallbacksForUnsortedSampleBuffers, (CMBufferQueueRef *)(*(void *)(v55 + 160) + 32));
  if (v21) {
    goto LABEL_59;
  }
  uint64_t v29 = *(void *)(v55 + 160);
  remakerFamily_getLowWaterLevel(*((unsigned __int8 *)v20 + 32), (uint64_t)&time);
  *(CMTime *)(v29 + 40) = time;
  uint64_t v30 = *(void *)(v55 + 160);
  remakerFamily_getHighWaterLevel(*((unsigned __int8 *)v20 + 32), (uint64_t)&time);
  *(CMTime *)(v30 + 64) = time;
  uint64_t v31 = *(void *)(v55 + 160);
  CFAllocatorRef v32 = *(opaqueCMBufferQueue **)(v31 + 32);
  CMTime time = *(CMTime *)(v31 + 40);
  uint64_t v21 = CMBufferQueueInstallTrigger(v32, (CMBufferQueueTriggerCallback)assetWriterTrack_reachedLowWater, (void *)v31, 2, &time, (CMBufferQueueTriggerToken *)(v31 + 88));
  if (v21)
  {
LABEL_59:
    uint64_t v34 = v21;
    goto LABEL_20;
  }
  *(unsigned char *)(*(void *)(v55 + 160) + 104) = 1;
  if (a6 <= 1634743415)
  {
    if (a6 == 1634742376 || a6 == 1634742888) {
      goto LABEL_27;
    }
    unsigned __int16 v33 = 13416;
  }
  else
  {
    if ((a6 - 1634755432) <= 0xB && ((1 << (a6 - 104)) & 0x8C1) != 0
      || (a6 - 1634759272) <= 6 && ((1 << (a6 - 104)) & 0x51) != 0)
    {
      goto LABEL_27;
    }
    unsigned __int16 v33 = 13432;
  }
  if (a6 == (v33 | 0x61700000))
  {
LABEL_27:
    if (hasProResHWEncoder_pred != -1) {
      dispatch_once(&hasProResHWEncoder_pred, &__block_literal_global_3);
    }
    if (hasProResHWEncoder_hasProResHW == 1)
    {
      if (doesProResHWEncoderSupportInterlaced_pred != -1) {
        dispatch_once(&doesProResHWEncoderSupportInterlaced_pred, &__block_literal_global_12);
      }
      if ((doesProResHWEncoderSupportInterlaced_proResHWSupportsInterlaced & 1) == 0) {
        FigCFDictionaryGetInt32IfPresent();
      }
    }
  }
  uint64_t RemakerVideoEncoderSpecification = remakerFamily_createRemakerVideoEncoderSpecification(a1, a7, (__CFDictionary **)&v54);
  if (RemakerVideoEncoderSpecification) {
    goto LABEL_60;
  }
  uint64_t RemakerVideoEncoderSpecification = remakerFamily_setupMultiPassTrackIfNecessary(a1, v55);
  if (RemakerVideoEncoderSpecification) {
    goto LABEL_60;
  }
  CFTypeRef v36 = v54;
  uint64_t v37 = v55;
  uint64_t v38 = *(void *)(v55 + 160);
  *(_DWORD *)(v38 + 212) = v51;
  *(_DWORD *)(v38 + 216) = v52;
  *(_DWORD *)(v38 + 220) = a6;
  if (v36)
  {
    CFTypeRef v36 = CFRetain(v36);
    uint64_t v37 = v55;
    uint64_t v38 = *(void *)(v55 + 160);
  }
  *(void *)(v38 + 224) = v36;
  long long v39 = *a10;
  *(void *)(v38 + 248) = *((void *)a10 + 2);
  *(_OWORD *)(v38 + 232) = v39;
  CFTypeRef v40 = a8;
  if (a8)
  {
    CFTypeRef v40 = CFRetain(a8);
    uint64_t v37 = v55;
  }
  uint64_t v41 = *(void *)(v37 + 160);
  *(void *)(v41 + 256) = v40;
  if (a11)
  {
    uint64_t RemakerVideoEncoderSpecification = assetWriter_finishBuildingVideoTrackWithPixelBufferAttributes(a1, v41, a11);
    if (RemakerVideoEncoderSpecification) {
      goto LABEL_60;
    }
  }
  else
  {
    uint64_t RemakerVideoEncoderSpecification = VTSelectAndCreateVideoEncoderInstance();
    if (RemakerVideoEncoderSpecification)
    {
LABEL_60:
      uint64_t v34 = RemakerVideoEncoderSpecification;
      goto LABEL_20;
    }
  }
  uint64_t v42 = v55;
  *a12 = *(_DWORD *)(v55 + 300);
  if ((*((_DWORD *)a10 + 3) & 0x1D) == 1)
  {
    int v43 = *((_DWORD *)a10 + 2);
    if (v43 <= 600) {
      int v43 = 600;
    }
    LODWORD(time.CFDictionarySetValue(theDict, key, value) = v43;
    CFNumberRef v44 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &time);
    uint64_t v45 = *((void *)v20 + 23);
    uint64_t v46 = *(unsigned int *)(v55 + 300);
    uint64_t v47 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v47) {
      uint64_t v48 = v47;
    }
    else {
      uint64_t v48 = 0;
    }
    CMTime v49 = *(void (**)(uint64_t, uint64_t, __CFString *, CFNumberRef))(v48 + 24);
    if (v49) {
      v49(v45, v46, @"MediaTimeScale", v44);
    }
    remakerFamily_setFormatWriterMovieTimeScaleIfAppropriate((uint64_t)a1, (uint64_t)v44, a5);
    CFRelease(v44);
    uint64_t v42 = v55;
  }
  remakerFamily_commitChannel((uint64_t)a1, v42);
  uint64_t v34 = 0;
  uint64_t v55 = 0;
LABEL_20:
  remakerFamily_discardChannel((uint64_t)a1, v55);
  if (v54) {
    CFRelease(v54);
  }
  return v34;
}

void assetWriterTrack_reachedLowWater(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject();
      if (v2)
      {
        uint64_t v3 = (const void *)v2;
        if (*(void *)(a1 + 16) && (uint64_t v4 = FigCFWeakReferenceHolderCopyReferencedObject()) != 0)
        {
          uint64_t v5 = (void *)v4;
          uint64_t v6 = FigCFWeakReferenceHolderCopyReferencedObject();
          if (v6)
          {
            int v7 = (const void *)v6;
            if (*(_DWORD *)remakerFamily_getStorage(v6) > 6u)
            {
              CFMutableDictionaryRef Mutable = 0;
            }
            else
            {
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF90], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              FigCFDictionarySetInt32();
              remakerFamily_safelyPostNotification(v7, 1, @"AssetWriter_TrackQueueNowBelowLowWaterLevel", (uint64_t)Mutable, v7);
            }
            CFRelease(v5);
            CFRelease(v7);
            if (!Mutable) {
              goto LABEL_16;
            }
            CFMutableDictionaryRef v9 = Mutable;
          }
          else
          {
            CFMutableDictionaryRef v9 = (CFMutableDictionaryRef)v5;
          }
          CFRelease(v9);
        }
        else
        {
          FigSignalErrorAt();
        }
LABEL_16:
        CFRelease(v3);
        return;
      }
    }
  }

  FigSignalErrorAt();
}

uint64_t assetWriter_finishBuildingAudioTrackWithSourceFormatDescription(const void *a1, uint64_t a2, const void *a3)
{
  CMBaseObjectGetDerivedStorage();
  if (a2 && *(void *)(a2 + 16) && (uint64_t v6 = FigCFWeakReferenceHolderCopyReferencedObject()) != 0)
  {
    int v7 = (void *)v6;
    uint64_t v8 = 0;
    if (!a3 || !*(unsigned char *)(a2 + 104)) {
      goto LABEL_15;
    }
    CFTypeID v9 = CFGetTypeID(a3);
    if (v9 == CMFormatDescriptionGetTypeID()
      && (*(unsigned char *)(a2 + 104) = 0, CMFormatDescriptionGetMediaSubType((CMFormatDescriptionRef)a3) == 1819304813))
    {
      uint64_t v10 = remakerFamily_buildMediaProcessorForAudioCompressionFromLPCMWithFormatWriter(a1, (uint64_t)v7, (const opaqueCMFormatDescription *)a3, (double *)(a2 + 112), *(void *)(a2 + 152), *(AudioChannelLayout **)(a2 + 160), *(void *)(a2 + 168), *(const void **)(a2 + 32));
      if (!v10)
      {
        uint64_t v11 = v7[36];
        if (v11) {
          FigMediaProcessorGo(v11);
        }
        uint64_t v8 = 0;
        goto LABEL_15;
      }
      uint64_t v8 = v10;
    }
    else
    {
      uint64_t v8 = FigSignalErrorAt();
      if (!v8) {
        goto LABEL_15;
      }
    }
    char v12 = 0;
  }
  else
  {
    uint64_t v8 = FigSignalErrorAt();
    if (!v8) {
      return v8;
    }
    int v7 = 0;
    char v12 = 1;
  }
  remakerfamily_setFailureStatusIfError((uint64_t)a1, v8);
  remakerFamily_invalidateAllMediaProcessors();
  if ((v12 & 1) == 0) {
LABEL_15:
  }
    CFRelease(v7);
  return v8;
}

uint64_t assetWriter_getChannelByWriterTrackID(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 80));
  if (Count < 1) {
    return 0;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  while (1)
  {
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 80), v6);
    if (ValueAtIndex[75] == a2) {
      break;
    }
    if (v5 == ++v6) {
      return 0;
    }
  }
  return *((void *)ValueAtIndex + 20);
}

uint64_t assetWriter_finishBuildingVideoTrackWithPixelBufferAttributes(const void *a1, uint64_t a2, const __CFDictionary *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFIndex v30 = 0;
  timeRangeArray = 0;
  if (a2)
  {
    int v7 = (_DWORD *)DerivedStorage;
    if (*(void *)(a2 + 16))
    {
      uint64_t v8 = FigCFWeakReferenceHolderCopyReferencedObject();
      if (v8)
      {
        uint64_t v9 = v8;
        int v10 = *(_DWORD *)(v8 + 32);
        if (v10 != 1635088502 && v10 != 1986618469)
        {
          uint64_t v25 = FigSignalErrorAt();
LABEL_31:
          free(timeRangeArray);
LABEL_32:
          CFRelease((CFTypeRef)v9);
          return v25;
        }
        if (!*(unsigned char *)(a2 + 104))
        {
LABEL_26:
          uint64_t v25 = 0;
          goto LABEL_31;
        }
        *(unsigned char *)(a2 + 104) = 0;
        int32_t v12 = *(_DWORD *)(a2 + 212);
        int32_t v13 = *(_DWORD *)(a2 + 216);
        CMVideoCodecType v14 = *(_DWORD *)(a2 + 220);
        CFDictionaryRef v15 = *(const __CFDictionary **)(a2 + 224);
        CMTime v16 = *(const void **)(a2 + 32);
        long long v27 = *(_OWORD *)(a2 + 232);
        CFDictionaryRef v17 = *(const __CFDictionary **)(a2 + 256);
        uint64_t v28 = *(void *)(a2 + 248);
        uint64_t Pass = remakerFamily_setupCompressionMediaProcessorAndFileOutput(a1, v12, v13, v14, &v27, v15, a3, v8, v16, 0, v17);
        if (!Pass)
        {
          CFAllocatorRef v19 = *(const void **)(a2 + 224);
          if (v19)
          {
            CFRelease(v19);
            *(void *)(a2 + 224) = 0;
          }
          if (!*(unsigned char *)(v9 + 360) || !*(unsigned char *)(a2 + 204)) {
            goto LABEL_21;
          }
          CFArrayRef v20 = *(const __CFArray **)(v9 + 408);
          if (!v20
            || CFArrayGetCount(v20) < 1
            || (uint64_t Pass = remakerFamily_createTimeRangesCArray(*(CFArrayRef *)(v9 + 408), &v30, &timeRangeArray),
                !Pass)
            && (uint64_t Pass = VTFrameSiloSetTimeRangesForNextPass(*(VTFrameSiloRef *)(v9 + 368), v30, timeRangeArray),
                !Pass))
          {
            VTCompressionSession = (OpaqueVTCompressionSession *)FigMediaProcessorGetVTCompressionSession(*(void *)(v9 + 288));
            uint64_t Pass = VTCompressionSessionBeginPass(VTCompressionSession, *(_DWORD *)(a2 + 208), 0);
            if (!Pass)
            {
              *(unsigned char *)(a2 + 204) = 0;
              *(_DWORD *)(a2 + 208) = 0;
LABEL_21:
              uint64_t v22 = *(const void **)(a2 + 256);
              if (v22)
              {
                CFRelease(v22);
                *(void *)(a2 + 256) = 0;
              }
              if (*v7 == 3)
              {
                uint64_t v23 = *(void *)(v9 + 288);
                if (v23) {
                  FigMediaProcessorGo(v23);
                }
              }
              goto LABEL_26;
            }
          }
        }
        uint64_t v25 = Pass;
        char v24 = 0;
LABEL_29:
        remakerfamily_setFailureStatusIfError((uint64_t)a1, v25);
        remakerFamily_invalidateAllMediaProcessors();
        free(timeRangeArray);
        if (v24) {
          return v25;
        }
        goto LABEL_32;
      }
    }
  }
  uint64_t v25 = FigSignalErrorAt();
  if (v25)
  {
    uint64_t v9 = 0;
    char v24 = 1;
    goto LABEL_29;
  }
  return v25;
}

BOOL assetWriter_GetInputQueueLengthBeforeFormatWriterForTrackIndex@<W0>(const void *a1@<X0>, CFIndex a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 80), a2);
  BOOL result = assetWriter_IsTrackNativeTrack(a1, ValueAtIndex[20]);
  if (result)
  {
    uint64_t v9 = ValueAtIndex[20];
    *(_OWORD *)a3 = *(_OWORD *)(v9 + 64);
    uint64_t v10 = *(void *)(v9 + 80);
  }
  else
  {
    uint64_t v11 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)a3 = *MEMORY[0x1E4F1F9F8];
    uint64_t v10 = *(void *)(v11 + 16);
  }
  *(void *)(a3 + 16) = v10;
  return result;
}

BOOL assetWriter_IsTrackNativeTrack(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  if (a2)
  {
    uint64_t v5 = DerivedStorage;
    if (*(void *)(a2 + 16))
    {
      uint64_t v6 = FigCFWeakReferenceHolderCopyReferencedObject();
      if (v6)
      {
        int v7 = (const void *)v6;
        uint64_t v8 = *(void *)(v5 + 184);
        uint64_t v9 = *(unsigned int *)(v6 + 300);
        CFAllocatorRef v10 = CFGetAllocator(a1);
        uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v11) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = 0;
        }
        CMVideoCodecType v14 = *(uint64_t (**)(uint64_t, uint64_t, __CFString *, CFAllocatorRef, CFTypeRef *))(v12 + 16);
        if (!v14)
        {
          BOOL v13 = 0;
          goto LABEL_13;
        }
        int v15 = v14(v8, v9, @"SourceSampleBufferQueue", v10, &cf);
        CFTypeRef v16 = cf;
        if (v15)
        {
          BOOL v13 = 0;
          if (!cf) {
            goto LABEL_13;
          }
        }
        else
        {
          BOOL v13 = FigCFEqual() != 0;
          CFTypeRef v16 = cf;
          if (!cf)
          {
LABEL_13:
            CFRelease(v7);
            return v13;
          }
        }
        CFRelease(v16);
        goto LABEL_13;
      }
    }
  }
  FigSignalErrorAt();
  return 0;
}

uint64_t assetWriter_copyPixelBufferAttributesForHintingEncoder(__CVBuffer *a1, CFDictionaryRef *a2)
{
  OSType valuePtr = CVPixelBufferGetPixelFormatType(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFTypeRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  if (cf
    && (CFDictionaryRef v4 = CFDictionaryCreate(v3, MEMORY[0x1E4F24D70], &cf, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) != 0)
  {
    uint64_t v5 = 0;
    *a2 = v4;
  }
  else
  {
    uint64_t v5 = FigSignalErrorAt();
  }
  if (cf) {
    CFRelease(cf);
  }
  return v5;
}

uint64_t assetWriter_finishAsyncDispatch(const void *a1)
{
  if (*(_DWORD *)CMBaseObjectGetDerivedStorage() != 4)
  {
    return FigSignalErrorAt();
  }
  if (*MEMORY[0x1E4F1EBA8] == 1) {
    kdebug_trace();
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(_DWORD *)DerivedStorage > 6u)
  {
    uint64_t result = FigSignalErrorAt();
    if (result) {
      return result;
    }
    goto LABEL_10;
  }
  uint64_t v3 = DerivedStorage;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 80));
  if (Count < 1)
  {
LABEL_9:
    *(unsigned char *)(v3 + 384) = 1;
LABEL_10:
    return remakerFamily_performLastStepIfComplete(a1);
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  while (1)
  {
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 80), v6);
    uint64_t result = remakerFamily_MarkEndOfDataForTrack((uint64_t)ValueAtIndex, 1);
    if (result) {
      return result;
    }
    if (v5 == ++v6) {
      goto LABEL_9;
    }
  }
}

void __hasProResHWEncoder_block_invoke()
{
  CFArrayRef listOfVideoEncodersOut = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F45608], (const void *)*MEMORY[0x1E4F1CFD0]);
  if (VTCopyVideoEncoderList(Mutable, &listOfVideoEncodersOut)) {
    BOOL v1 = 1;
  }
  else {
    BOOL v1 = listOfVideoEncodersOut == 0;
  }
  if (!v1)
  {
    if (CFArrayGetCount(listOfVideoEncodersOut) >= 1)
    {
      CFIndex v2 = 0;
      do
      {
        CFArrayGetValueAtIndex(listOfVideoEncodersOut, v2);
        FigCFDictionaryGetBooleanIfPresent();
        ++v2;
      }
      while (v2 < CFArrayGetCount(listOfVideoEncodersOut));
    }
    CFRelease(listOfVideoEncodersOut);
  }
}

void __doesProResHWEncoderSupportInterlaced_block_invoke()
{
  VTSessionRef session = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    BOOL v1 = Mutable;
    CFIndex v2 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F45648], (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionarySetValue(v1, (const void *)*MEMORY[0x1E4F45660], v2);
    if (!VTCompressionSessionCreate(0, 1920, 1080, 0x6170636Eu, v1, 0, 0, 0, 0, (VTCompressionSessionRef *)&session))
    {
      int32_t SInt32 = (const void *)FigCFNumberCreateSInt32();
      if (SInt32)
      {
        CFDictionaryRef v4 = SInt32;
        if (!VTSessionSetProperty(session, (CFStringRef)*MEMORY[0x1E4F448F8], SInt32)) {
          doesProResHWEncoderSupportInterlaced_proResHWSupportsInterlaced = 1;
        }
        CFRelease(v4);
      }
      CFRelease(session);
    }
    CFRelease(v1);
  }
}

uint64_t FigManifoldGetClassID()
{
  return sFigManifoldClassID;
}

uint64_t RegisterFigManifoldBaseType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigManifoldGetCFTypeID()
{
  MEMORY[0x19970EE10](&FigManifoldGetClassID_sRegisterFigManifoldBaseTypeOnce, RegisterFigManifoldBaseType);

  return CMBaseClassGetCFTypeID();
}

CFTypeRef FigManifoldRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void FigManifoldRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CMTime *fmi_CalculateMPEG2WrapForTime@<X0>(CMTime *result@<X0>, CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  uint64_t v4 = MEMORY[0x1E4F1F9F8];
  *(_OWORD *)&a3->CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  a3->CMTimeEpoch epoch = *(void *)(v4 + 16);
  if ((result->flags & 0x1D) == 1 && (a2->flags & 0x1D) == 1)
  {
    CMTime v10 = *result;
    CMTimeConvertScale(&v11, &v10, 90000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    CMTimeValue value = v11.value;
    CMTime v10 = *a2;
    CMTimeConvertScale(&v11, &v10, 90000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    unint64_t v7 = value & 0xFFFFFFFE00000000 | v11.value & 0x1FFFFFFFFLL;
    uint64_t v8 = value - v7;
    if ((uint64_t)(value - v7) < 0 && ((v7 - value) & 0x100000000) != 0)
    {
      v7 -= 0x200000000;
    }
    else if ((v8 & 0x100000000) != 0 && v8 >= 1)
    {
      v7 += 0x200000000;
    }
    return CMTimeMake(a3, v7 - v11.value, 90000);
  }
  return result;
}

__n128 FigManifoldAdjustTimestampAndUpdateRefTime(CMTime *a1, CMTime *a2, __n128 *a3)
{
  memset(&v12, 0, sizeof(v12));
  if (a2 && (a1->flags & 0x1D) == 1 && (a2->flags & 0x1D) == 1)
  {
    CMTime lhs = *a2;
    CMTime rhs = *a1;
    CMTimeSubtract(&v12, &lhs, &rhs);
    CMTime lhs = v12;
    CMTimeAbsoluteValue(&time1, &lhs);
    *(_OWORD *)&lhs.CMTimeValue value = FigManifoldAdjustTimestampAndUpdateRefTime_kAlmostHalfWrap;
    lhs.CMTimeEpoch epoch = 0;
    if (CMTimeCompare(&time1, &lhs) >= 1)
    {
      memset(&lhs, 0, sizeof(lhs));
      CMTime rhs = *a1;
      CMTime v8 = *a2;
      fmi_CalculateMPEG2WrapForTime(&rhs, &v8, &lhs);
      CMTime v8 = *a2;
      CMTime v7 = lhs;
      CMTimeAdd(&rhs, &v8, &v7);
      result.n128_u64[0] = rhs.value;
      *a2 = rhs;
    }
    if (a3)
    {
      __n128 result = *(__n128 *)&a2->value;
      a3[1].n128_u64[0] = a2->epoch;
      *a3 = result;
    }
  }
  return result;
}

CFStringRef FigManifoldBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigManifold %p]", a1);
}

uint64_t FigCaptionGroupConverterFromSampleBufferGetClassID()
{
  return sFigCaptionGroupConverterFromSampleBufferClassID;
}

uint64_t RegisterFigCaptionGroupConverterFromSampleBufferBaseType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigCaptionGroupConverterFromSampleBufferGetTypeID()
{
  MEMORY[0x19970EE10](&FigCaptionGroupConverterFromSampleBufferGetClassID_sRegisterFigCaptionGroupConverterFromSampleBufferBaseTypeOnce, RegisterFigCaptionGroupConverterFromSampleBufferBaseType);

  return CMBaseClassGetCFTypeID();
}

CFStringRef FigCaptionGroupConverterFromSampleBufferCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionGroupConverterFromSampleBuffer %p]", a1);
}

uint64_t FigAIOClientCreate(uint64_t a1, uint64_t a2, const void *a3, void *a4)
{
  MEMORY[0x19970EE10](&gFigAIOInitOnce, figAIOInitOnce);
  if (gInitResult) {
    return 0;
  }
  uint64_t v7 = MEMORY[0x19970E290](gFigAIOClientListLock);
  if (v7) {
    return v7;
  }
  CMTime v8 = (void *)gFigAIOClientList;
  if (gFigAIOClientList)
  {
    while (*v8 != a2 || (const void *)v8[1] != a3)
    {
      CMTime v8 = (void *)v8[2];
      if (!v8) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_7:
    uint64_t v9 = malloc_type_malloc(0x20uLL, 0x10E004028FE4D45uLL);
    if (v9)
    {
      CMTime v10 = v9;
      *uint64_t v9 = a2;
      if (a3) {
        CFRetain(a3);
      }
      uint64_t v11 = 0;
      v10[2] = 0;
      v10[1] = a3;
      *(void *)qword_1E934D330 = v10;
      qword_1E934D330 = (uint64_t)(v10 + 2);
      *a4 = v10;
    }
    else
    {
      uint64_t v11 = FigSignalErrorAt();
    }
  }
  MEMORY[0x19970E2B0](gFigAIOClientListLock);
  return v11;
}

void figAIOInitOnce()
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F21EA0], (const void *)*MEMORY[0x1E4F1CFC8]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F21EA8], @"com.apple.coremedia.asyncio");
  gFigAIOClientListLock = FigReentrantMutexCreate();
  if (gFigAIOClientListLock
    && (gFigAIOClientList = 0,
        qword_1E934D330 = (uint64_t)&gFigAIOClientList,
        (gFigAIORequestListLock = FigReentrantMutexCreate()) != 0))
  {
    gFigAIOPendingRequestList = 0;
    gFigAIOCompletedRequestList = 0;
    gFigAIORequestThreadWakeupSem = FigSemaphoreCreate();
    int v1 = FigThreadCreate();
  }
  else
  {
    int v1 = -1;
  }
  gInitResult = v1;
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

uint64_t FigAIOClientRelease(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x19970E290](gFigAIOClientListLock);
  if (!v2)
  {
    uint64_t v3 = &gFigAIOClientList;
    uint64_t v4 = &gFigAIOClientList;
    do
    {
      CFIndex v5 = (void *)*v4;
      uint64_t v4 = (uint64_t *)(*v4 + 16);
      if (v5) {
        BOOL v6 = v5 == (void *)a1;
      }
      else {
        BOOL v6 = 1;
      }
    }
    while (!v6);
    if (!v5) {
      goto LABEL_16;
    }
    FinalizeClientRequestsOnList(a1, &gFigAIOPendingRequestList, 1);
    FinalizeClientRequestsOnList(a1, &gFigAIOCompletedRequestList, 0);
    uint64_t v7 = gFigAIOClientList;
    if ((void *)gFigAIOClientList == v5)
    {
      gFigAIOClientList = *v4;
      if (gFigAIOClientList) {
        goto LABEL_13;
      }
    }
    else
    {
      do
      {
        uint64_t v8 = v7;
        uint64_t v7 = *(void *)(v7 + 16);
      }
      while ((void *)v7 != v5);
      uint64_t v9 = *v4;
      *(void *)(v8 + 16) = *v4;
      uint64_t v3 = (uint64_t *)(v8 + 16);
      if (v9)
      {
LABEL_13:
        CMTime v10 = (const void *)v5[1];
        if (v10)
        {
          CFRelease(v10);
          v5[1] = 0;
        }
        free(v5);
LABEL_16:
        MEMORY[0x19970E2B0](gFigAIOClientListLock);
        return v2;
      }
    }
    qword_1E934D330 = (uint64_t)v3;
    goto LABEL_13;
  }
  return v2;
}

void FinalizeClientRequestsOnList(uint64_t a1, uint64_t *a2, int a3)
{
  while (1)
  {
    MEMORY[0x19970E290](gFigAIORequestListLock);
    uint64_t v6 = *a2;
    if (!*a2) {
      break;
    }
    while (*(void *)(v6 + 80) != a1)
    {
      uint64_t v6 = *(void *)(v6 + 88);
      if (!v6) {
        goto LABEL_8;
      }
    }
    int v7 = MEMORY[0x19970E2B0](gFigAIORequestListLock);
    int v9 = 0;
    ssize_t v8 = 0;
    if (a3) {
      int v7 = FigAIOBlockUntilReady(v7, (aiocb *)v6, 1);
    }
    FigAIOTryToComplete(v7, (aiocb *)v6, &v9, &v8);
  }
LABEL_8:

  JUMPOUT(0x19970E2B0);
}

uint64_t FigAIOIssueRead(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v11 = malloc_type_calloc(1uLL, 0x70uLL, 0x10A20409309F963uLL);
  if (!v11) {
    return 4294949775;
  }
  uint64_t v12 = (uint64_t)v11;
  *uint64_t v11 = FigFileGetDarwinFileDesc();
  *(void *)(v12 + 8) = a3;
  *(void *)(v12 + 16) = a5;
  *(void *)(v12 + 24) = a4;
  if (aio_read((aiocb *)v12))
  {
    uint64_t v13 = *__error();
    free((void *)v12);
  }
  else
  {
    *(void *)(v12 + 80) = a1;
    AddPendingRequest(v12);
    uint64_t v13 = 0;
    *a6 = v12;
  }
  return v13;
}

void AddPendingRequest(uint64_t a1)
{
  MEMORY[0x19970E290](gFigAIORequestListLock);
  uint64_t v2 = gFigAIOPendingRequestList;
  *(void *)(a1 + 88) = gFigAIOPendingRequestList;
  if (v2) {
    *(void *)(v2 + 96) = a1 + 88;
  }
  gFigAIOPendingRequestList = a1;
  *(void *)(a1 + 96) = &gFigAIOPendingRequestList;
  FigSemaphoreSignal();

  JUMPOUT(0x19970E2B0);
}

uint64_t FigAIOIssueWrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v11 = malloc_type_calloc(1uLL, 0x70uLL, 0x10A20409309F963uLL);
  if (!v11) {
    return 4294949775;
  }
  uint64_t v12 = (uint64_t)v11;
  *uint64_t v11 = FigFileGetDarwinFileDesc();
  *(void *)(v12 + 8) = a3;
  *(void *)(v12 + 16) = a5;
  *(void *)(v12 + 24) = a4;
  if (aio_write((aiocb *)v12))
  {
    uint64_t v13 = *__error();
    free((void *)v12);
  }
  else
  {
    *(void *)(v12 + 80) = a1;
    AddPendingRequest(v12);
    uint64_t v13 = 0;
    *a6 = v12;
  }
  return v13;
}

uint64_t FigAIOTryToComplete(int a1, aiocb *aiocbp, int *a3, ssize_t *a4)
{
  *a3 = -1;
  *a4 = 0;
  if (aio_error(aiocbp) == 36) {
    return 0;
  }
  MEMORY[0x19970E290](gFigAIORequestListLock);
  ssize_t v8 = &gFigAIOCompletedRequestList;
  do
  {
    int v9 = (aiocb *)*v8;
    ssize_t v8 = (uint64_t *)(*v8 + 88);
    if (v9) {
      BOOL v10 = v9 == aiocbp;
    }
    else {
      BOOL v10 = 1;
    }
  }
  while (!v10);
  if (v9)
  {
    off_t aio_offset = aiocbp[1].aio_offset;
    if (aio_offset) {
      *(void *)(aio_offset + 96) = aiocbp[1].aio_buf;
    }
    *(void *)aiocbp[1].aio_CMBufferRef buf = aio_offset;
    int v12 = 1;
  }
  else
  {
    uint64_t v13 = &gFigAIOPendingRequestList;
    do
    {
      CMVideoCodecType v14 = (aiocb *)*v13;
      uint64_t v13 = (uint64_t *)(*v13 + 88);
      if (v14) {
        BOOL v15 = v14 == aiocbp;
      }
      else {
        BOOL v15 = 1;
      }
    }
    while (!v15);
    if (!v14)
    {
      MEMORY[0x19970E2B0](gFigAIORequestListLock);
      return 0;
    }
    int v12 = 0;
    LOBYTE(aiocbp[1].aio_nbytes) = 1;
  }
  MEMORY[0x19970E2B0](gFigAIORequestListLock);
  *a4 = 0;
  int v16 = aio_error(aiocbp);
  if (v16 == 36)
  {
    *a3 = 36;
  }
  else
  {
    int v17 = v16;
    ssize_t v18 = aio_return(aiocbp);
    *a4 = v18;
    if (v17 == -1 || v18 == -1) {
      int v17 = *__error();
    }
    *a3 = v17;
    if (v17 == 22)
    {
      if (v9)
      {
        int v12 = 1;
      }
      else
      {
        MEMORY[0x19970E290](gFigAIORequestListLock);
        CFAllocatorRef v19 = &gFigAIOPendingRequestList;
        do
        {
          CFArrayRef v20 = (aiocb *)*v19;
          CFAllocatorRef v19 = (uint64_t *)(*v19 + 88);
          if (v20) {
            BOOL v21 = v20 == aiocbp;
          }
          else {
            BOOL v21 = 1;
          }
        }
        while (!v21);
        if (!v20)
        {
          uint64_t v22 = &gFigAIOCompletedRequestList;
          do
          {
            uint64_t v23 = (aiocb *)*v22;
            uint64_t v22 = (uint64_t *)(*v22 + 88);
            if (v23) {
              BOOL v24 = v23 == aiocbp;
            }
            else {
              BOOL v24 = 1;
            }
          }
          while (!v24);
          if (!v23) {
            goto LABEL_48;
          }
        }
        if (LOBYTE(aiocbp[1].aio_nbytes))
        {
          off_t v25 = aiocbp[1].aio_offset;
          if (v25) {
            *(void *)(v25 + 96) = aiocbp[1].aio_buf;
          }
          *(void *)aiocbp[1].aio_CMBufferRef buf = v25;
          int v12 = 1;
        }
        else
        {
LABEL_48:
          int v12 = 0;
        }
        MEMORY[0x19970E2B0](gFigAIORequestListLock);
      }
      int v26 = FigAtomicIncrement32();
      if (v26 == 1)
      {
        beartrap_for_37975981_sBeartrapStartTime = FigGetUpTimeNanoseconds();
      }
      else if (v26 >= 20)
      {
        if ((unint64_t)(FigGetUpTimeNanoseconds() - beartrap_for_37975981_sBeartrapStartTime) <= 0x12A05F200) {
          FigUserCrash();
        }
        FigAtomicCompareAndSwap32();
      }
    }
  }
  if (v12) {
    free(aiocbp);
  }
  return 1;
}

uint64_t FigAIOBlockUntilReady(int a1, aiocb *aiocbp, int a3)
{
  aiocblist[1] = *(aiocb **)MEMORY[0x1E4F143B8];
  if (aio_error(aiocbp) != 36) {
    return 0;
  }
  aiocblist[0] = aiocbp;
  long long v7 = xmmword_194992CA0;
  if (a3) {
    aio_cancel(aiocbp->aio_fildes, aiocbp);
  }
  for (int i = 0; ; int i = aio_suspend((const aiocb *const *)aiocblist, 1, (const timespec *)&v7))
  {
    if (i != 4)
    {
      uint64_t result = aio_error(aiocbp);
      if (result != 36) {
        break;
      }
    }
  }
  return result;
}

void FigAIORequestThread()
{
  CFAllocatorRef v0 = malloc_type_malloc(0x40uLL, 0x2004093837F09uLL);
  int v1 = 8;
  while (1)
  {
    MEMORY[0x19970E290](gFigAIORequestListLock);
    off_t aio_offset = (const aiocb *)gFigAIOPendingRequestList;
    if (!gFigAIOPendingRequestList)
    {
      MEMORY[0x19970E2B0](gFigAIORequestListLock);
      goto LABEL_33;
    }
    int v3 = 0;
    int v4 = 0;
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (uint64_t)aio_offset;
        int v6 = aio_error(aio_offset);
        p_off_t aio_offset = &aio_offset[1].aio_offset;
        off_t aio_offset = (const aiocb *)aio_offset[1].aio_offset;
        if (v6 == 36) {
          break;
        }
        if (aio_offset) {
          aio_offset[1].aio_CMBufferRef buf = *(void **)(v5 + 96);
        }
        **(void **)(v5 + 96) = aio_offset;
        if (*(unsigned char *)(v5 + 104))
        {
          free((void *)v5);
          if (!aio_offset) {
            goto LABEL_21;
          }
        }
        else
        {
          uint64_t v9 = gFigAIOCompletedRequestList;
          *p_off_t aio_offset = gFigAIOCompletedRequestList;
          if (v9) {
            *(void *)(v9 + 96) = p_aio_offset;
          }
          gFigAIOCompletedRequestList = v5;
          *(void *)(v5 + 96) = &gFigAIOCompletedRequestList;
          *(unsigned char *)(*(void *)(v5 + 80) + 24) = 1;
          ++v3;
          if (!aio_offset) {
            goto LABEL_21;
          }
        }
      }
      if (v4 == v1) {
        break;
      }
LABEL_8:
      v0[v4++] = v5;
      if (!aio_offset) {
        goto LABEL_21;
      }
    }
    ssize_t v8 = malloc_type_realloc(v0, 8 * (v1 + 4), 0x2004093837F09uLL);
    if (v8) {
      break;
    }
    int v4 = v1;
LABEL_21:
    MEMORY[0x19970E2B0](gFigAIORequestListLock);
    if (v3 >= 1)
    {
      MEMORY[0x19970E290](gFigAIOClientListLock);
      do
      {
        uint64_t v10 = gFigAIOClientList;
        if (!gFigAIOClientList) {
          break;
        }
        while (1)
        {
          if (*(unsigned char *)(v10 + 24))
          {
            *(unsigned char *)(v10 + 24) = 0;
            if (*(void *)v10) {
              break;
            }
          }
          uint64_t v10 = *(void *)(v10 + 16);
          if (!v10) {
            goto LABEL_30;
          }
        }
        (*(void (**)(uint64_t, void))v10)(v10, *(void *)(v10 + 8));
      }
      while (v3-- > 0);
LABEL_30:
      MEMORY[0x19970E2B0](gFigAIOClientListLock);
    }
    if (v4)
    {
      timespec timeoutp = (timespec)xmmword_194992CA0;
      aio_suspend((const aiocb *const *)v0, v4, &timeoutp);
      continue;
    }
LABEL_33:
    FigSemaphoreWaitRelative();
  }
  v1 += 4;
  CFAllocatorRef v0 = v8;
  goto LABEL_8;
}

uint64_t FPSupport_CheckPlayerPerformanceTrace()
{
  fig_note_initialize_category_with_default_work_cf();

  return fig_note_initialize_category_with_default_work_cf();
}

BOOL FPSupport_IsPlayerPerformanceTraceEnabled()
{
  return dword_1E9350AF0 != 0;
}

void FPSupport_TracePlayerPerformanceDictionary(uint64_t a1, void *a2)
{
  id v2 = FPSupport_CopyDictionaryDescriptionAsCFString(a2);
  if (dword_1E9350AF0)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (v2) {
    CFRelease(v2);
  }
}

uint64_t FigByteFlumeGetTypeID()
{
  MEMORY[0x19970EE10](&FigByteFlumeGetClassID_sRegisterFigByteFlumeBaseTypeOnce, RegisterFigByteFlumeBaseType);

  return CMBaseClassGetCFTypeID();
}

CFStringRef FigByteFlumeBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigByteFlume %p]", a1);
}

uint64_t FigTTMLFeaturesCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a4)
  {
    FigTTMLNodeGetClassID();
    uint64_t v8 = CMDerivedObjectCreate();
    if (!v8)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      uint64_t v8 = FigTTMLInitializeNodeBaseStorage(DerivedStorage, (long long *)a3);
      if (!v8)
      {
        uint64_t v8 = FigTTMLAddCurrentElementAttributesToDictionary(a2, *(__CFDictionary **)(DerivedStorage + 24));
        if (!v8)
        {
          CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
          *(void *)(DerivedStorage + 144) = Mutable;
          if (Mutable)
          {
            *(void *)a3 = 0;
            *(void *)(a3 + 8) = 0;
            uint64_t v11 = FigTTMLParseNode(a2, (uint64_t (*)(uint64_t, uint64_t *, CFTypeRef *))figTTMLFeaturesConsumeChildNode, (uint64_t *)a3);
            if (!v11) {
              *a4 = 0;
            }
            return v11;
          }
          return FigSignalErrorAt();
        }
      }
    }
    return v8;
  }

  return FigSignalErrorAt();
}

uint64_t figTTMLFeaturesConsumeChildNode(uint64_t a1, CFTypeRef *a2, void **a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef v13 = 0;
  CMTimeValue value = 0;
  CFTypeRef cf = 0;
  uint64_t v7 = FigTTMLGetLibXMLAccess();
  if (!v7)
  {
    uint64_t v10 = FigSignalErrorAt();
    goto LABEL_13;
  }
  if ((*(unsigned int (**)(uint64_t))(v7 + 72))(a1) != 1) {
    goto LABEL_8;
  }
  uint64_t v8 = FigTTMLCopyNamespaceAndLocalNameOfCurrentNode(a1, (const char **)&v13, (CFStringRef *)&cf);
  if (v8) {
    goto LABEL_18;
  }
  if (FigCFEqual() && FigCFEqual())
  {
    CFAllocatorRef v9 = CFGetAllocator(*a2);
    uint64_t v8 = FigTTMLFeatureCreate(v9, a1, (long long *)a2, &value);
    if (!v8)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 144), value);
      goto LABEL_9;
    }
  }
  else
  {
LABEL_8:
    uint64_t v8 = FigTTMLSkipNode(a1, (uint64_t *)a2, *(__CFArray **)(DerivedStorage + 128));
    if (!v8)
    {
LABEL_9:
      uint64_t v10 = 0;
      if (a3)
      {
        *a3 = value;
        CMTimeValue value = 0;
      }
      goto LABEL_11;
    }
  }
LABEL_18:
  uint64_t v10 = v8;
LABEL_11:
  if (cf) {
    CFRelease(cf);
  }
LABEL_13:
  if (v13) {
    CFRelease(v13);
  }
  if (value) {
    CFRelease(value);
  }
  return v10;
}

void figTTMLFeatures_Finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  int v1 = *(const void **)(DerivedStorage + 144);
  if (v1) {
    CFRelease(v1);
  }

  FigTTMLReleaseNodeBaseStorage(DerivedStorage);
}

CFStringRef figTTMLFeatures_CopyDebugDesc()
{
  CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v0 = (const void *)FigCFCopyCompactDescription();
  CFStringRef v1 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"features: %@", v0);
  if (v0) {
    CFRelease(v0);
  }
  return v1;
}

uint64_t figTTMLFeatures_CopyChildNodeArray(const void *a1, __CFArray **a2)
{
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    CFArrayRef v6 = *(const __CFArray **)(DerivedStorage + 144);
    if (v6) {
      v7.length = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 144));
    }
    else {
      v7.length = 0;
    }
    v7.CFIndex location = 0;
    CFArrayAppendArray(Mutable, v6, v7);
    uint64_t v8 = 0;
    *a2 = Mutable;
  }
  else
  {
    uint64_t v8 = FigSignalErrorAt();
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  return v8;
}

uint64_t figTTMLFeatures_GetNodeType(uint64_t a1, _DWORD *a2)
{
  if (!a2) {
    return FigSignalErrorAt();
  }
  *a2 = 16;
  return 0;
}

uint64_t FigAssetImageGeneratorCreateFromAssetRemote(uint64_t a1, uint64_t a2, void *a3)
{
  return FigAssetImageGeneratorCreateRemoteFromAssetWithOptions(a1, a2, 0, a3);
}

uint64_t FigAssetImageGeneratorCreateRemoteFromAssetWithOptions(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  xpc_object_t v14 = 0;
  xpc_object_t xdict = 0;
  uint64_t value = 0;
  uint64_t v17 = 0;
  ssize_t v18 = &v17;
  uint64_t v19 = 0x2000000000;
  int v20 = 0;
  block[0] = (CFTypeRef)MEMORY[0x1E4F143A8];
  block[1] = (CFTypeRef)0x40000000;
  block[2] = __remoteXPCAIG_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E578BC10;
  block[4] = &v17;
  if (remoteXPCAIG_EnsureClientEstablished_gAIGRemoteClientSetupOnce != -1) {
    dispatch_once(&remoteXPCAIG_EnsureClientEstablished_gAIGRemoteClientSetupOnce, block);
  }
  uint64_t started = *((unsigned int *)v18 + 6);
  _Block_object_dispose(&v17, 8);
  if (started) {
    goto LABEL_13;
  }
  uint64_t ObjectID = FigAssetXPCRemoteGetObjectID(a2, &value);
  if (ObjectID) {
    goto LABEL_19;
  }
  if (!a4)
  {
    uint64_t ObjectID = FigSignalErrorAt();
LABEL_19:
    uint64_t started = ObjectID;
LABEL_13:
    CFTypeRef v9 = 0;
    goto LABEL_14;
  }
  block[0] = 0;
  FigAssetImageGeneratorGetClassID();
  uint64_t v8 = CMDerivedObjectCreate();
  CFTypeRef v9 = block[0];
  if (v8)
  {
    uint64_t started = v8;
    if (block[0]) {
      CFRelease(block[0]);
    }
    goto LABEL_13;
  }
  uint64_t v10 = FigXPCCreateBasicMessage();
  if (!v10)
  {
    xpc_dictionary_set_uint64(xdict, "Asset", value);
    uint64_t v10 = FigXPCMessageSetCFDictionary();
    if (!v10)
    {
      uint64_t v10 = FigXPCRemoteClientSendSyncMessageCreatingReply();
      if (!v10)
      {
        uint64_t uint64 = xpc_dictionary_get_uint64(v14, (const char *)*MEMORY[0x1E4F20280]);
        *(void *)CMBaseObjectGetDerivedStorage() = uint64;
        uint64_t v10 = FigXPCRemoteClientAssociateObject();
        if (!v10)
        {
          uint64_t started = FigStartMonitoringMediaServicesProcessDeath();
          if (started) {
            goto LABEL_14;
          }
          *a4 = v9;
          goto LABEL_13;
        }
      }
    }
  }
  uint64_t started = v10;
LABEL_14:
  FigXPCRelease();
  FigXPCRelease();
  if (v9) {
    CFRelease(v9);
  }
  FigXPCRemoteClientKillServerOnTimeout();
  return started;
}

uint64_t remoteXPCAIG_DeadConnectionCallback()
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  *(unsigned char *)(result + 9) = 1;
  return result;
}

uint64_t remoteXPCAIG_NotificationFilter(int a1, CFTypeRef cf1, void *a3, uint64_t a4, CFDictionaryRef *a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!CFEqual(cf1, @"AIGDidGenerateCGImage")) {
    return 0;
  }
  memset(&v17[1], 0, sizeof(CMTime));
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  CFDictionaryRef v20 = 0;
  uint64_t v21 = 0;
  if (!remoteXPCAIG_CopyCGImageFromMessage(a3))
  {
    keys = @"CGImage";
    values = (void *)cf;
    int CMTime = FigXPCMessageGetCMTime();
    uint64_t v8 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (CMTime)
    {
      CFDictionaryRef v9 = 0;
      CFIndex v10 = 1;
    }
    else
    {
      CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      v17[0] = v17[1];
      CFDictionaryRef v9 = CMTimeCopyAsDictionary(v17, v12);
      uint64_t v23 = @"FigTime";
      CFDictionaryRef v20 = v9;
      CFIndex v10 = 2;
    }
    xpc_object_t value = xpc_dictionary_get_value(a3, "RequestID");
    if (value)
    {
      v17[0].xpc_object_t value = xpc_int64_get_value(value);
      CFAllocatorRef v14 = *v8;
      CFNumberRef v15 = CFNumberCreate(v14, kCFNumberSInt64Type, v17);
      *(&keys + v10) = @"RequestID";
      *(&values + v10) = v15;
      *a5 = CFDictionaryCreate(v14, (const void **)&keys, (const void **)&values, v10 + 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v15) {
        CFRelease(v15);
      }
      if (!v9) {
        goto LABEL_12;
      }
    }
    else
    {
      *a5 = CFDictionaryCreate(*v8, (const void **)&keys, (const void **)&values, v10, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (!v9) {
        goto LABEL_12;
      }
    }
    CFRelease(v9);
LABEL_12:
    uint64_t v11 = 4;
    goto LABEL_13;
  }
  uint64_t v11 = 1;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t remoteXPCAIG_CopyCGImageFromMessage(void *a1)
{
  size_t length = 0;
  if (xpc_dictionary_get_data(a1, "ImageParams", &length)) {
    BOOL v2 = length == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2 || (uint64_t v3 = MEMORY[0x19970E350](), !v3))
  {
    FigXPCMessageCreateBlockBufferData();
    xpc_object_t value = xpc_dictionary_get_value(a1, "IOSurface");
    if (value)
    {
      IOSurfaceRef v5 = IOSurfaceLookupFromXPCObject(value);
      if (v5)
      {
        FigCFDictionaryGetNumberValue();
        uint64_t CGImageFromIOSurfaceAndAttributes = FigCreateCGImageFromIOSurfaceAndAttributes();
      }
      else
      {
        uint64_t CGImageFromIOSurfaceAndAttributes = FigSignalErrorAt();
      }
      uint64_t v7 = CGImageFromIOSurfaceAndAttributes;
      goto LABEL_12;
    }
    uint64_t v3 = FigSignalErrorAt();
  }
  uint64_t v7 = v3;
  IOSurfaceRef v5 = 0;
LABEL_12:
  if (v5) {
    CFRelease(v5);
  }
  return v7;
}

uint64_t remoteXPCAIG_Invalidate()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 8)
    || (uint64_t v1 = DerivedStorage,
        FigStopMonitoringMediaServicesProcessDeath(),
        *(unsigned char *)(v1 + 8) = 1,
        FigXPCRemoteClientDisassociateObject(),
        *(unsigned char *)(v1 + 9)))
  {
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v3 = FigXPCCreateBasicMessage();
    if (v3) {
      uint64_t v2 = v3;
    }
    else {
      uint64_t v2 = FigXPCRemoteClientSendAsyncMessage();
    }
  }
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v2;
}

__CFString *remoteXPCAIG_CopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v3, 0);
  CFIndex v5 = CFGetRetainCount(a1);
  CFArrayRef v6 = "";
  if (*(unsigned char *)(DerivedStorage + 8)) {
    uint64_t v7 = " (invalidated)";
  }
  else {
    uint64_t v7 = "";
  }
  if (*(unsigned char *)(DerivedStorage + 9)) {
    CFArrayRef v6 = "SERVER DIED";
  }
  CFStringAppendFormat(Mutable, 0, @"<FigAssetImageGeneratorRemote(XPC) %p retainCount: %ld%s ObjectID: %016llx%s>", a1, v5, v7, *(void *)DerivedStorage, v6);
  return Mutable;
}

uint64_t remoteXPCAIG_SetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CMBaseObjectGetDerivedStorage();
  uint64_t result = 4294954863;
  if (a2)
  {
    if (a3) {
      return remoteXPCAIG_GetObjectID(a1, &v7);
    }
  }
  return result;
}

uint64_t remoteXPCAIG_GetObjectID(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 8) || *(unsigned char *)(DerivedStorage + 9))
  {
    return FigSignalErrorAt();
  }
  else
  {
    *a2 = *(void *)DerivedStorage;
    return 0;
  }
}

uint64_t remoteXPCAIG_CopyCGImageAtTime(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFAllocatorRef v12 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  uint64_t ObjectID = remoteXPCAIG_GetObjectID(a1, &v11);
  if (ObjectID
    || (uint64_t ObjectID = FigXPCCreateBasicMessage(), ObjectID)
    || (FigXPCMessageSetCMTime(), a3) && (uint64_t ObjectID = FigXPCMessageSetCFDictionary(), ObjectID))
  {
    uint64_t v9 = ObjectID;
  }
  else
  {
    uint64_t v9 = FigXPCRemoteClientSendSyncMessageCreatingReply();
    if (!v9)
    {
      uint64_t v9 = remoteXPCAIG_CopyCGImageFromMessage(v12);
      if (a6)
      {
        if (!v9) {
          FigXPCMessageGetCMTime();
        }
      }
    }
  }
  FigXPCRelease();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v9;
}

uint64_t remoteXPCAIG_RequestCGImageAtTimeAsync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[0] = 0;
  v7[1] = 0;
  uint64_t ObjectID = remoteXPCAIG_GetObjectID(a1, v7);
  if (!ObjectID)
  {
    uint64_t ObjectID = FigXPCCreateBasicMessage();
    if (!ObjectID)
    {
      FigXPCMessageSetCMTime();
      if (!a3 || (uint64_t ObjectID = FigXPCMessageSetCFDictionary(), !ObjectID)) {
        uint64_t ObjectID = FigXPCRemoteClientSendSyncMessage();
      }
    }
  }
  uint64_t v5 = ObjectID;
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v5;
}

uint64_t remoteXPCAIG_CancelAllCGImageAsyncRequests(uint64_t a1)
{
  v5[0] = 0;
  v5[1] = 0;
  uint64_t ObjectID = remoteXPCAIG_GetObjectID(a1, v5);
  if (ObjectID)
  {
    uint64_t v3 = ObjectID;
  }
  else
  {
    uint64_t v2 = FigXPCCreateBasicMessage();
    if (v2) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = FigXPCRemoteClientSendAsyncMessage();
    }
  }
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v3;
}

uint64_t crabsUpdateLength(uint64_t a1, uint64_t a2)
{
  CFNumberRef number = 0;
  uint64_t FigBaseObject = FigByteFlumeGetFigBaseObject(a2);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  CFArrayRef v6 = *(uint64_t (**)(uint64_t, __CFString *, void, CFNumberRef *))(v5 + 48);
  if (!v6) {
    return 4294954514;
  }
  uint64_t v7 = v6(FigBaseObject, @"FBF_EntireLength", *MEMORY[0x1E4F1CF80], &number);
  CFNumberRef v8 = number;
  if (v7) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = number == 0;
  }
  if (v9)
  {
    uint64_t v10 = 0;
    if (number) {
LABEL_14:
    }
      CFRelease(v8);
  }
  else
  {
    uint64_t v12 = 0;
    CFNumberGetValue(number, kCFNumberSInt64Type, &v12);
    CFNumberRef v8 = number;
    uint64_t v10 = v12 & ~(v12 >> 63);
    uint64_t v7 = (v12 >> 63) & 0xFFFFCE11;
    if (number) {
      goto LABEL_14;
    }
  }
  if (!v7) {
    *(void *)(a1 + 56) = v10;
  }
  return v7;
}

uint64_t crabsDiskBackingIsBusy(uint64_t a1, int a2)
{
  uint64_t result = *(unsigned __int8 *)(a1 + 24);
  if (result | a2)
  {
    CFTypeRef cf = 0;
    *(unsigned char *)(a1 + 24) = 0;
    uint64_t FigBaseObject = FigDiskCacheProviderGetFigBaseObject(*(void *)(a1 + 8));
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(uint64_t (**)(uint64_t, __CFString *, void, CFTypeRef *))(v6 + 48);
    if (v7)
    {
      int v8 = v7(FigBaseObject, @"CacheIsBusy", *MEMORY[0x1E4F1CF80], &cf);
      CFTypeRef v9 = cf;
      if (v8) {
        BOOL v10 = 0;
      }
      else {
        BOOL v10 = cf == (CFTypeRef)*MEMORY[0x1E4F1CFD0];
      }
      if (v10) {
        *(unsigned char *)(a1 + 24) = 1;
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    return *(unsigned __int8 *)(a1 + 24);
  }
  return result;
}

uint64_t crabsInitialize(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3 == -1) {
    return 0;
  }
  uint64_t v4 = 0x10000;
  if (v3 < 6291456) {
    uint64_t v4 = 0x4000;
  }
  *(void *)(a1 + 96) = v4;
  size_t v5 = (v3 + v4 - 1) / v4;
  uint64_t v6 = malloc_type_calloc(v5, 8uLL, 0x2004093837F09uLL);
  *(void *)(a1 + 80) = v6;
  if (v6)
  {
    *(void *)(a1 + 88) = v5;
    if (*(void *)(a1 + 168) || (uint64_t v7 = FigReadWriteLockCreate(), (*(void *)(a1 + 168) = v7) != 0))
    {
      int v8 = malloc_type_calloc(1uLL, *(void *)(a1 + 96), 0xE6C46140uLL);
      *(void *)(a1 + 152) = v8;
      if (v8)
      {
        *(void *)(a1 + 160) = -1;
        uint64_t v9 = *(void *)(a1 + 88);
        *(void *)(a1 + 232) = v9;
        *(void *)(a1 + 360) = v9;
        if (*(uint64_t *)(a1 + 184) >= 1)
        {
          uint64_t v10 = 0;
          uint64_t v11 = *(void *)(a1 + 192);
          do
            *(void *)(v11 + 8 * v10++) = *(void *)(a1 + 88);
          while (v10 < *(void *)(a1 + 184));
        }
        *(void *)&long long v12 = -1;
        *((void *)&v12 + 1) = -1;
        *(_OWORD *)(a1 + 424) = v12;
        *(_OWORD *)(a1 + 440) = v12;
        *(void *)(a1 + 472) = (*(void *)(a1 + 96) + 0x3FFFFFLL) / *(void *)(a1 + 96);
        *(void *)(a1 + 480) = 4;
        if (!*(void *)(a1 + 8)) {
          return 0;
        }
        CFTypeRef v48 = 0;
        CFTypeRef cf = 0;
        CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        SInt64 = (const void *)FigCFNumberCreateSInt64();
        uint64_t FigBaseObject = FigDiskCacheProviderGetFigBaseObject(*(void *)(a1 + 8));
        uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v16) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = 0;
        }
        ssize_t v18 = *(void (**)(uint64_t, __CFString *, const void *))(v17 + 56);
        if (v18) {
          v18(FigBaseObject, @"CacheSize", SInt64);
        }
        uint64_t v19 = FigCFNumberCreateSInt64();
        if (v19)
        {
          CFDictionaryRef v20 = (const void *)v19;
          uint64_t v21 = FigDiskCacheProviderGetFigBaseObject(*(void *)(a1 + 8));
          uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v22) {
            uint64_t v23 = v22;
          }
          else {
            uint64_t v23 = 0;
          }
          uint64_t v24 = *(void (**)(uint64_t, __CFString *, const void *))(v23 + 56);
          if (v24) {
            v24(v21, @"CacheBlockSize", v20);
          }
          CFRelease(v20);
        }
        int valuePtr = 16;
        CFNumberRef v25 = CFNumberCreate(v13, kCFNumberSInt32Type, &valuePtr);
        if (v25)
        {
          CFNumberRef v26 = v25;
          uint64_t v27 = FigDiskCacheProviderGetFigBaseObject(*(void *)(a1 + 8));
          uint64_t v28 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v28) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = 0;
          }
          CFIndex v30 = *(void (**)(uint64_t, __CFString *, CFNumberRef))(v29 + 56);
          if (v30) {
            v30(v27, @"CacheMapEntrySize", v26);
          }
          CFRelease(v26);
        }
        if ((*(unsigned char *)(a1 + 504) & 4) == 0)
        {
          uint64_t v31 = FigDiskCacheProviderGetFigBaseObject(*(void *)(a1 + 8));
          uint64_t v32 = *(void *)(CMBaseObjectGetVTable() + 8);
          uint64_t v33 = v32 ? v32 : 0;
          uint64_t v34 = *(unsigned int (**)(uint64_t, __CFString *, const __CFAllocator *, CFTypeRef *))(v33 + 48);
          if (v34)
          {
            if (!v34(v31, @"CacheIdentifier", v13, &cf))
            {
              uint64_t v35 = *(void *)(a1 + 32);
              CFTypeRef v36 = cf;
              uint64_t v37 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v37) {
                uint64_t v38 = v37;
              }
              else {
                uint64_t v38 = 0;
              }
              long long v39 = *(unsigned int (**)(uint64_t, CFTypeRef))(v38 + 32);
              if (v39 && v39(v35, v36))
              {
                if (!FigDiskCacheProviderCopyProperty(*(void *)(a1 + 8), @"CacheMap", (uint64_t)v13, (uint64_t)&v48))
                {
                  uint64_t BackingFile = FigDiskCacheProviderGetBackingFile(*(void *)(a1 + 8));
                  if (BackingFile)
                  {
                    if (crabsRestoreCache(a1, (CFDataRef)v48, BackingFile, *(void *)(a1 + 56))) {
                      FigDiskCacheProviderSetProperty(*(void *)(a1 + 8), @"CacheMap", 0);
                    }
                  }
                }
LABEL_56:
                if (cf) {
                  CFRelease(cf);
                }
                if (v48) {
                  CFRelease(v48);
                }
                if (SInt64) {
                  CFRelease(SInt64);
                }
                return 0;
              }
              FigDiskCacheProviderSetProperty(*(void *)(a1 + 8), @"CacheMap", 0);
            }
          }
        }
        uint64_t v42 = (void *)(a1 + 144);
        uint64_t v41 = *(const void **)(a1 + 144);
        if (v41)
        {
          CFRelease(v41);
          *uint64_t v42 = 0;
        }
        uint64_t v43 = *(void *)(a1 + 32);
        uint64_t v44 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v44) {
          uint64_t v45 = v44;
        }
        else {
          uint64_t v45 = 0;
        }
        uint64_t v46 = *(void (**)(uint64_t, void *))(v45 + 24);
        if (v46) {
          v46(v43, v42);
        }
        goto LABEL_56;
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t FigReportingAgentStatsSetIntValue(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v7 = result;
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v10 = *(void *)(VTable + 16);
    uint64_t result = VTable + 16;
    uint64_t v9 = v10;
    uint64_t v11 = v10 ? v9 : 0;
    long long v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v11 + 56);
    if (v12)
    {
      return v12(v7, a2, a3, a4, 0);
    }
  }
  return result;
}

uint64_t FigCRABSPrintWorkingSet()
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  printf("FigCRABSPrintWorkingSet stream [%p]", DerivedStorage);
  uint64_t v1 = DerivedStorage[39];
  if (!v1) {
    return printf("<%d>\n", DerivedStorage[28]);
  }
  int v2 = 0;
  do
  {
    if (*(void *)(v1 + 80) && DerivedStorage[28] == *(_DWORD *)v1)
    {
      int v2 = 1;
      printf("[%d] ");
    }
    else
    {
      printf("%d ");
    }
    uint64_t v1 = *(void *)(v1 + 32);
  }
  while (v1);
  if (!v2) {
    return printf("<%d>\n", DerivedStorage[28]);
  }

  return putchar(10);
}

void gdbShowCRABSStats()
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v4 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  keys[0] = (void *)CFRetain(@"cacheMemAllotted");
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values[0] = (void *)FigCFNumberCreateSInt64();
  keys[1] = (void *)CFRetain(@"diskCacheAllotted");
  values[1] = (void *)FigCFNumberCreateSInt64();
  CFDictionaryRef v1 = CFDictionaryCreate(v0, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  for (uint64_t i = 1; i != -1; --i)
  {
    CFRelease(keys[i]);
    CFRelease(values[i]);
  }
  puts(" Statistics for FigByteStream_CRABS:");
  CFShow(v1);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t *gdbDumpCRABSWorkingSet(uint64_t *result)
{
  for (uint64_t i = *result; i; uint64_t i = *(void *)(i + 32))
    uint64_t result = (uint64_t *)printf(" Mem block %d has MemIsland <%p>\n", *(_DWORD *)i, *(const void **)(i + 80));
  return result;
}

__CFString *FigCRABSCopyDebugDescription()
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  FigRetainProxyLockMutex();
  if (DerivedStorage[7] == -1 || (int v2 = (int **)DerivedStorage[10]) == 0)
  {
    CFStringAppendFormat(Mutable, 0, @"FigByteStream_CRABS: Uninitialized");
  }
  else
  {
    uint64_t v3 = DerivedStorage[11];
    if (v3 < 1)
    {
      uint64_t v9 = 0;
      uint64_t v8 = 0;
      uint64_t v7 = 0;
      uint64_t v6 = 0;
      uint64_t v5 = 0;
      uint64_t v4 = 0;
    }
    else
    {
      uint64_t v4 = 0;
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      do
      {
        long long v10 = *v2;
        if (*v2)
        {
          uint64_t v11 = *((void *)v10 + 10);
          if (v11)
          {
            uint64_t v5 = (v5 + 1);
            if (*(int *)(v11 + 24) <= 0) {
              uint64_t v8 = v8;
            }
            else {
              uint64_t v8 = (v8 + 1);
            }
          }
          unsigned int v12 = *((unsigned __int16 *)v10 + 4);
          if ((v12 & 0x200) != 0) {
            int v13 = (v12 >> 8) & 1;
          }
          else {
            int v13 = *((void *)v10 + 11) != 0;
          }
          uint64_t v9 = (v9 + 1);
          uint64_t v4 = (v13 + v4);
          if (DerivedStorage[28] <= *v10) {
            uint64_t v6 = (v6 + 1);
          }
          else {
            uint64_t v7 = (v7 + 1);
          }
        }
        ++v2;
        --v3;
      }
      while (v3);
    }
    CFStringAppendFormat(Mutable, 0, @"FigByteStream_CRABS: \n\t\t# active cache blocks <%d>\n\t\t# in-memory cache blocks <%d>\n\t\t# referenced cache blocks <%d>\n\t\t# on disk <%d>\n\t\t# in state Backfill <%d>\n\t\t# in state Follows Hints <%d>", v9, v5, v8, v4, v7, v6);
  }
  FigRetainProxyUnlockMutex();
  return Mutable;
}

uint64_t crabsCompleteLazySync(uint64_t a1, int a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unsigned int v12 = 0;
  if (!*(void *)(a1 + 728)) {
    return 0;
  }
  if (a2) {
    FigAIOBlockUntilReady(*(void *)(a1 + 720), *(aiocb **)(a1 + 736), 0);
  }
  ssize_t v11 = 0;
  int v3 = FigAIOTryToComplete(*(void *)(a1 + 720), *(aiocb **)(a1 + 736), (int *)&v12, &v11);
  uint64_t result = v12;
  if (v3)
  {
    uint64_t v5 = a1 + 728;
    if (v12)
    {
      if (v12 == 69 || v12 == 28)
      {
        *(unsigned char *)(a1 + 135) = 1;
        if (*(unsigned char *)(a1 + 112))
        {
          *(unsigned char *)(a1 + 112) = 0;
          *(_WORD *)(a1 + 176) |= 8u;
          if (dword_1E9350B10)
          {
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
        }
      }
      *(_WORD *)(*(void *)v5 + 8) |= 8u;
      FigSignalErrorAt();
    }
    uint64_t v7 = *(void **)v5;
    if ((*(_WORD *)(*(void *)v5 + 8) & 8) != 0)
    {
      int v10 = 1;
    }
    else
    {
      uint64_t v8 = *(int *)v7;
      uint64_t v9 = *(void *)(a1 + 224);
      int v10 = v9 <= v8 && v9 + *(void *)(a1 + 344) / 4 > v8;
    }
    crabsReleaseWorking((void *)a1, v7, v10, 1);
    *(void *)uint64_t v5 = 0;
    *(void *)(a1 + 736) = 0;
    return v12;
  }
  return result;
}

uint64_t crabsCompleteLazyPagein(uint64_t a1, int a2)
{
  unsigned int v7 = 0;
  if (!*(void *)(a1 + 744)) {
    return 0;
  }
  if (a2) {
    FigAIOBlockUntilReady(*(void *)(a1 + 720), *(aiocb **)(a1 + 752), 0);
  }
  ssize_t v6 = 0;
  int v3 = FigAIOTryToComplete(*(void *)(a1 + 720), *(aiocb **)(a1 + 752), (int *)&v7, &v6);
  uint64_t result = v7;
  if (v3)
  {
    if (v7) {
      crabsMarkBlockUnbacked(a1, *(int **)(a1 + 744), *(void *)(a1 + 224) <= **(int **)(a1 + 744));
    }
    crabsReleaseWorking((void *)a1, *(void **)(a1 + 744), 1, 1);
    uint64_t v5 = *(void *)(a1 + 744);
    if ((~*(unsigned __int16 *)(v5 + 8) & 5) == 0) {
      crabsUnhint(a1, v5);
    }
    *(void *)(a1 + 744) = 0;
    *(void *)(a1 + 752) = 0;
    return v7;
  }
  return result;
}

uint64_t crabsSyncCache(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 504);
  if ((v2 & 5) == 4 && !*(unsigned char *)(a1 + 136)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 88);
  if ((v2 & 1) == 0)
  {
    if (v3 >= 1)
    {
      uint64_t v4 = 0;
      unsigned int v5 = 0;
      while (1)
      {
        ssize_t v6 = *(int **)(*(void *)(a1 + 80) + 8 * v4);
        if (v6) {
          break;
        }
LABEL_36:
        if (v3 <= ++v4) {
          goto LABEL_59;
        }
      }
      __int16 v7 = *((_WORD *)v6 + 4);
      if ((v7 & 0x80) != 0 && ((v7 & 0x40) != 0 || *(unsigned char *)(a1 + 136)))
      {
        crabsMakeBackingNonvolatile((void *)a1, (uint64_t)v6, *(void *)(a1 + 224) <= *v6);
        __int16 v7 = *((_WORD *)v6 + 4);
      }
      if ((v7 & 0x10) != 0)
      {
        if ((v7 & 0x100) != 0) {
          goto LABEL_23;
        }
      }
      else if ((v7 & 0x100) != 0 || !*(unsigned char *)(a1 + 136))
      {
        goto LABEL_23;
      }
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {
        uint64_t v9 = *(void *)(a1 + 96);
        uint64_t v10 = *v6;
        uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v12 = v11 ? v11 : 0;
        uint64_t v13 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(v12 + 8);
        if (v13)
        {
          if (v13(v8, v9, v9 * v10, a1 + 16, v6 + 24)) {
            *((_WORD *)v6 + 4) |= 0x140u;
          }
        }
      }
LABEL_23:
      unsigned int v14 = *((unsigned __int16 *)v6 + 4);
      if ((v14 & 0x40) != 0)
      {
        if (*((void *)v6 + 10)) {
          goto LABEL_29;
        }
        if ((v14 & 0x200) == 0)
        {
          if (!*((void *)v6 + 11)) {
            goto LABEL_35;
          }
LABEL_29:
          uint64_t v15 = v6[1];
          uint64_t v16 = FigFileForkWrite();
          if (v16) {
            BOOL v17 = 0;
          }
          else {
            BOOL v17 = v15 == 0;
          }
          if (!v17) {
            goto LABEL_85;
          }
          unsigned int v14 = v6[2] & 0xFFBF;
          *((_WORD *)v6 + 4) &= ~0x40u;
          goto LABEL_35;
        }
        if ((v14 >> 8)) {
          goto LABEL_29;
        }
      }
LABEL_35:
      v5 += (v14 >> 8) & 1;
      uint64_t v3 = *(void *)(a1 + 88);
      goto LABEL_36;
    }
    goto LABEL_58;
  }
  if (v3 >= 1)
  {
    uint64_t v18 = 0;
    unsigned int v5 = 0;
    while (1)
    {
      uint64_t v19 = *(void *)(*(void *)(a1 + 80) + 8 * v18);
      if (v19) {
        break;
      }
LABEL_56:
      if (v3 <= ++v18) {
        goto LABEL_59;
      }
    }
    if (!*(void *)(v19 + 80)) {
      goto LABEL_55;
    }
    unsigned int v20 = *(unsigned __int16 *)(v19 + 8);
    if ((v20 & 8) == 0 && v19 != *(void *)(a1 + 728)) {
      goto LABEL_55;
    }
    if ((v20 & 0x200) != 0)
    {
      if (((v20 >> 8) & 1) == 0) {
        goto LABEL_48;
      }
    }
    else if (!*(void *)(v19 + 88))
    {
LABEL_48:
      if (crabsAllocBacking(a1, (int *)v19)) {
        crabsAddBlockToBackedList((uint64_t *)a1, (int *)v19);
      }
    }
    unsigned int v21 = *(unsigned __int16 *)(v19 + 8);
    if ((v21 & 0x200) == 0)
    {
      if (!*(void *)(v19 + 88)) {
        goto LABEL_55;
      }
LABEL_54:
      uint64_t v16 = crabsSyncBlock(a1, v19);
      if (v16) {
        goto LABEL_85;
      }
      goto LABEL_55;
    }
    if ((v21 >> 8)) {
      goto LABEL_54;
    }
LABEL_55:
    v5 += HIBYTE(*(unsigned __int16 *)(v19 + 8)) & 1;
    uint64_t v3 = *(void *)(a1 + 88);
    goto LABEL_56;
  }
LABEL_58:
  unsigned int v5 = 0;
LABEL_59:
  uint64_t v22 = (char *)malloc_type_malloc(16 * (int)(v5 - 1) + 32, 0xEEE1D236uLL);
  if (v22)
  {
    uint64_t v23 = v22;
    *(void *)uint64_t v22 = 0x6261726305000000;
    *((_DWORD *)v22 + 2) = bswap32(*(_DWORD *)(a1 + 96));
    *((_DWORD *)v22 + 3) = bswap32(v5);
    uint64_t v24 = *(void *)(a1 + 88);
    if (v24 >= 1)
    {
      uint64_t v25 = 0;
      CFNumberRef v26 = v22 + 16;
      uint64_t v27 = *(void *)(a1 + 80);
      do
      {
        uint64_t v28 = *(void *)(v27 + 8 * v25);
        if (v28 && (*(_WORD *)(v28 + 8) & 0x100) != 0)
        {
          *((void *)v26 + 1) = bswap64(*(void *)(v28 + 96));
          unsigned int v29 = bswap32(*(_DWORD *)(v28 + 4));
          *(_DWORD *)CFNumberRef v26 = bswap32(v25);
          *((_DWORD *)v26 + 1) = v29;
          v26 += 16;
        }
        ++v25;
      }
      while (v24 != v25);
    }
    CFDataRef v30 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v22, 16 * (int)(v5 - 1) + 32);
    if (v30) {
      uint64_t v31 = 0;
    }
    else {
      uint64_t v31 = FigSignalErrorAt();
    }
    free(v23);
  }
  else
  {
    uint64_t v16 = FigSignalErrorAt();
LABEL_85:
    uint64_t v31 = v16;
    CFDataRef v30 = 0;
  }
  uint64_t v32 = *(void *)(a1 + 144);
  if (v32)
  {
    uint64_t FigBaseObject = FigDiskCacheProviderGetFigBaseObject(*(void *)(a1 + 8));
    uint64_t v34 = *(void *)(CMBaseObjectGetVTable() + 8);
    uint64_t v35 = v34 ? v34 : 0;
    CFTypeRef v36 = *(void (**)(uint64_t, __CFString *, uint64_t))(v35 + 56);
    if (v36) {
      v36(FigBaseObject, @"CacheIdentifier", v32);
    }
  }
  uint64_t v37 = FigDiskCacheProviderGetFigBaseObject(*(void *)(a1 + 8));
  uint64_t v38 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v38) {
    uint64_t v39 = v38;
  }
  else {
    uint64_t v39 = 0;
  }
  CFTypeRef v40 = *(void (**)(uint64_t, __CFString *, CFDataRef))(v39 + 56);
  if (v40) {
    v40(v37, @"CacheMap", v30);
  }
  if (v30) {
    CFRelease(v30);
  }
  return v31;
}

void crabsReleaseDiskCacheProviderAsync(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3) {
    os_release(v3);
  }

  free(a1);
}

uint64_t crabsRetainProxyUnlockWithActions()
{
  if (FigRetainProxyIsInvalidated())
  {
    return FigRetainProxyUnlockMutex();
  }
  else
  {
    FigRetainProxyGetOwner();
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    return crabsUnlockWithActions(DerivedStorage);
  }
}

uint64_t FigReportingAgentStatsAddToCountValue(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v7 = result;
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v10 = *(void *)(VTable + 16);
    uint64_t result = VTable + 16;
    uint64_t v9 = v10;
    uint64_t v11 = v10 ? v9 : 0;
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 32);
    if (v12)
    {
      return v12(v7, a2, a3, a4);
    }
  }
  return result;
}

uint64_t crabsDeferredUnlockWithActions()
{
  cf[16] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  FigRetainProxyLockMutex();
  uint64_t Owner = (const void *)FigRetainProxyGetOwner();
  if (FigRetainProxyIsInvalidated())
  {
    FigRetainProxyUnlockMutex();
    goto LABEL_46;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  int v2 = (const void **)DerivedStorage;
  if (*(unsigned char *)(DerivedStorage + 104)) {
    __int16 v3 = *(_WORD *)(DerivedStorage + 176);
  }
  else {
    LOBYTE(v3) = 0;
  }
  int v4 = *(unsigned __int8 *)(DerivedStorage + 24);
  int v5 = *(unsigned __int8 *)(DerivedStorage + 135);
  *(_WORD *)(DerivedStorage + 176) = 0;
  FigRetainProxyUnlockMutex();
  if ((v3 & 4) != 0)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
  }
  ssize_t v6 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if ((v3 & 3) != 0)
  {
    CFDictionaryRef v7 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, 0, 0);
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    if (v7) {
      CFRelease(v7);
    }
  }
  if ((v3 & 8) != 0)
  {
    values = 0;
    int valuePtr = 0;
    if (v4)
    {
      uint64_t v8 = @"Cache is Busy";
      int v9 = -12542;
    }
    else
    {
      if (!v5)
      {
        CFDictionaryRef v11 = 0;
        goto LABEL_17;
      }
      uint64_t v8 = @"Disk is Full";
      int v9 = -12541;
    }
    int valuePtr = v9;
    CFAllocatorRef v10 = *v6;
    values = CFNumberCreate(*v6, kCFNumberSInt32Type, &valuePtr);
    CFDictionaryRef v11 = CFDictionaryCreate(v10, (const void **)kFigCachedReadAheadByteStreamParameter_StatusCode, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    crabsReportingReportError((uint64_t)v2, @"CoreMediaErrorDomain", (uint64_t)v8, valuePtr);
LABEL_17:
    crabsReportingIssueEvent((uint64_t)v2, 401);
    crabsReportingIssueIRATEventIfNeeded((uint64_t)v2, 801);
    if (dword_1E9350B10)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      ssize_t v6 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    }
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    if (values) {
      CFRelease(values);
    }
    if (v11) {
      CFRelease(v11);
    }
  }
  if ((v3 & 0x20) != 0)
  {
    if (dword_1E9350B10)
    {
      LODWORD(values) = 0;
      LOBYTE(valuePtr) = 0;
      uint64_t v13 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v14 = values;
      if (os_log_type_enabled(v13, (os_log_type_t)valuePtr)) {
        unsigned int v15 = v14;
      }
      else {
        unsigned int v15 = v14 & 0xFFFFFFFE;
      }
      if (v15)
      {
        int v25 = 136315394;
        CFNumberRef v26 = "crabsDeferredUnlockWithActions";
        __int16 v27 = 2048;
        uint64_t v28 = v2;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    uint64_t v16 = v2[119];
    if (*((_DWORD *)v2 + 236))
    {
      if (!v16)
      {
        CFAllocatorRef v17 = *v6;
        cf[0] = CFNumberCreate(*v6, kCFNumberIntType, v2 + 118);
        CFDictionaryRef v18 = CFDictionaryCreate(v17, (const void **)kFigCachedReadAheadByteStreamParameter_ReadResult, cf, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        goto LABEL_37;
      }
LABEL_36:
      CFDictionaryRef v18 = CFDictionaryCreate(*v6, (const void **)kFigCachedReadAheadByteStreamParameter_ReadCFError, v2 + 119, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
LABEL_37:
      CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification();
      crabsReportingReportError((uint64_t)v2, @"CoreMediaErrorDomain", @"CRABS Read Error", *((_DWORD *)v2 + 236));
      uint64_t v19 = v2[119];
      if (v19)
      {
        CFRelease(v19);
        v2[119] = 0;
      }
      *((_DWORD *)v2 + 236) = 0;
      if (v18) {
        CFRelease(v18);
      }
      goto LABEL_41;
    }
    if (v16) {
      goto LABEL_36;
    }
  }
LABEL_41:
  if ((v3 & 0x40) != 0)
  {
    CFAllocatorRef v20 = *v6;
    cf[0] = CFNumberCreate(*v6, kCFNumberSInt32Type, (char *)v2 + 108);
    CFDictionaryRef v21 = CFDictionaryCreate(v20, (const void **)kFigCachedReadAheadByteStreamParameter_ConnectionState, cf, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    if (v21) {
      CFRelease(v21);
    }
  }
LABEL_46:
  if (Owner) {
    CFRelease(Owner);
  }
  return FigRetainProxyRelease();
}

uint64_t crabsReportingReportError(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (!result) {
    return result;
  }
  int v4 = (void *)result;
  uint64_t v5 = *(void *)(result + 920);
  if (!v5) {
    return result;
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  CFDictionaryRef v11 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v10 + 48);
  if (v11) {
    v11(v5, 0x1EE582BF8, 0x1EE55E5B8, a3, 0);
  }
  uint64_t v12 = v4[115];
  if (!v12) {
    goto LABEL_37;
  }
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  unsigned int v15 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v14 + 56);
  if (v15) {
    v15(v12, 0x1EE582BF8, 0x1EE55E598, a4, 0);
  }
  uint64_t v16 = v4[115];
  if (v16)
  {
    uint64_t v17 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v17) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = 0;
    }
    uint64_t v19 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v18 + 48);
    if (v19) {
      v19(v16, 0x1EE582BF8, 0x1EE55E5D8, a2, 0);
    }
    uint64_t v20 = v4[115];
  }
  else
  {
LABEL_37:
    uint64_t v20 = 0;
  }
  if (v4[7] != -1)
  {
    if (v4[10]) {
      uint64_t v21 = 2;
    }
    else {
      uint64_t v21 = 1;
    }
    if (!v20) {
      goto LABEL_34;
    }
LABEL_29:
    uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v22) {
      uint64_t v23 = v22;
    }
    else {
      uint64_t v23 = 0;
    }
    uint64_t v24 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v23 + 56);
    if (v24) {
      v24(v20, 0x1EE582BF8, 0x1EE55E618, v21, 0);
    }
    goto LABEL_34;
  }
  uint64_t v21 = 1;
  if (v20) {
    goto LABEL_29;
  }
LABEL_34:

  return crabsReportingIssueEvent((uint64_t)v4, 402);
}

uint64_t crabsReportingIssueEvent(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 920);
    if (v2)
    {
      uint64_t VTable = CMBaseObjectGetVTable();
      uint64_t v6 = *(void *)(VTable + 16);
      uint64_t result = VTable + 16;
      uint64_t v5 = v6;
      uint64_t v7 = v6 ? v5 : 0;
      uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void))(v7 + 8);
      if (v8)
      {
        return v8(v2, 0x1EE582BF8, a2, 0, 0);
      }
    }
  }
  return result;
}

uint64_t crabsReportingIssueIRATEventIfNeeded(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a2 == 800) {
      int v4 = 1;
    }
    else {
      int v4 = 2;
    }
    int v5 = *(_DWORD *)(result + 928);
    if (!v5)
    {
      uint64_t v6 = *(void *)(result + 920);
      if (v6)
      {
        uint64_t VTable = CMBaseObjectGetVTable();
        uint64_t v9 = *(void *)(VTable + 16);
        uint64_t result = VTable + 16;
        uint64_t v8 = v9;
        if (v9) {
          uint64_t v10 = v8;
        }
        else {
          uint64_t v10 = 0;
        }
        CFDictionaryRef v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v10 + 56);
        if (v11) {
          uint64_t result = v11(v6, 0x1EE582BF8, 0x1EE584778, 300, 0);
        }
      }
    }
    if (v4 != v5)
    {
      uint64_t result = crabsReportingIssueEvent(v3, a2);
      *(_DWORD *)(v3 + 928) = v4;
    }
  }
  return result;
}

uint64_t crabsMarkBlockUnbacked(uint64_t a1, int *a2, int a3)
{
  int v6 = a2[1];
  uint64_t result = crabsMarkBlockUnfilled(a1, (uint64_t)a2);
  *((void *)a2 + 12) = -1;
  __int16 v8 = *((_WORD *)a2 + 4);
  *((_WORD *)a2 + 4) = v8 & 0xFEFF;
  ++*(void *)(a1 + 408);
  if ((v8 & 0x11) == 0)
  {
    if (a3) {
      uint64_t v9 = a1 + 264;
    }
    else {
      uint64_t v9 = a1 + 280;
    }
    uint64_t result = removeFromList(a1, v9, (uint64_t)a2, 0);
  }
  uint64_t v10 = *a2;
  uint64_t v11 = *(void *)(a1 + 224);
  if (v11 <= v10)
  {
    uint64_t v12 = *(void *)(a1 + 240);
    if (v12 < v11 || v12 > v10) {
      *(void *)(a1 + 240) = v10;
    }
  }
  if (v6)
  {
    if (*(unsigned char *)(a1 + 128)) {
      BOOL v14 = 1;
    }
    else {
      BOOL v14 = v11 <= v10;
    }
    if (v14) {
      __int16 v15 = 2;
    }
    else {
      __int16 v15 = 1;
    }
    *(_WORD *)(a1 + 176) |= v15;
    *(unsigned char *)(a1 + 128) = 0;
  }
  return result;
}

uint64_t FigDiskCacheProviderSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigBaseObject = FigDiskCacheProviderGetFigBaseObject(a1);
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v9 = *(void *)(VTable + 8);
  uint64_t result = VTable + 8;
  uint64_t v8 = v9;
  if (v9) {
    uint64_t v10 = v8;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 56);
  if (v11)
  {
    return v11(FigBaseObject, a2, a3);
  }
  return result;
}

uint64_t crabsEnsureInitialized(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  BOOL v3 = *(void *)(DerivedStorage + 56) != -1 && *(void *)(DerivedStorage + 80) != 0;
  FigRetainProxyUnlockMutex();
  int IsInvalidated = FigRetainProxyIsInvalidated();
  if (IsInvalidated) {
    uint64_t result = 4294954511;
  }
  else {
    uint64_t result = 0;
  }
  if (!IsInvalidated && !v3)
  {
    LODWORD(result) = readOrRef(a1, 1uLL, 0, 0, 0, 0, -1);
    if (result == -12873) {
      return 0;
    }
    else {
      return result;
    }
  }
  return result;
}

void crabsReleaseReadAheadAssertion(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!FigRetainProxyLockMutex())
  {
    if (dword_1E9350B10)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    int v4 = *(_DWORD *)(DerivedStorage + 116) - 1;
    *(_DWORD *)(DerivedStorage + 116) = v4;
    if (!v4) {
      crabsReportingIssueIRATEventIfNeeded(DerivedStorage, 801);
    }
    FigRetainProxyUnlockMutex();
  }
  if (a1) {
    CFRelease(a1);
  }
}

BOOL crabsIsEntireLengthAvailableInCache(uint64_t a1)
{
  int v4 = 0;
  int v2 = crabsSelectNextFill(a1, &v4);
  BOOL result = 0;
  if (!v2 && !v4) {
    return *(unsigned char *)(a1 + 130) != 0;
  }
  return result;
}

uint64_t crabsCreateReadStatsDictionary(uint64_t a1, uint64_t a2, void *a3)
{
  CFTypeRef cf = 0;
  if (!a3) {
    return 4294954516;
  }
  uint64_t FigBaseObject = FigByteFlumeGetFigBaseObject(*(void *)(a1 + 32));
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(void (**)(uint64_t, __CFString *, void, CFTypeRef *))(v6 + 48);
  if (v7) {
    v7(FigBaseObject, @"FBF_URL", *MEMORY[0x1E4F1CF80], &cf);
  }
  StatsDictionary = (const void *)FigByteStreamStatsCreateStatsDictionary();
  MutableCFArrayRef Copy = (const void *)FigCFDictionaryCreateMutableCopy();
  if (!MutableCopy)
  {
    uint64_t v10 = FigSignalErrorAt();
    if (!StatsDictionary) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated())
  {
    FigRetainProxyUnlockMutex();
    uint64_t v10 = 4294954511;
    if (!StatsDictionary) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt64();
  FigCFDictionarySetInt64();
  FigCFDictionarySetInt64();
  FigCFDictionarySetInt64();
  FigCFDictionarySetInt64();
  FigCFDictionarySetInt64();
  FigCFDictionarySetInt64();
  FigCFDictionarySetInt64();
  FigRetainProxyUnlockMutex();
  uint64_t v10 = 0;
  *a3 = MutableCopy;
  MutableCFArrayRef Copy = 0;
  if (StatsDictionary) {
LABEL_12:
  }
    CFRelease(StatsDictionary);
LABEL_13:
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t crabsShouldStartFirehose(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 134)) {
    return 1;
  }
  uint64_t v4 = *(void *)(a1 + 88);
  uint64_t v5 = 0x200000 / *(void *)(a1 + 96);
  if (v5 < 1 || v4 <= a2)
  {
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    while (1)
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 80) + 8 * a2 + 8 * v9);
      if (v10)
      {
        if ((*(_WORD *)(v10 + 8) & 4) != 0) {
          break;
        }
      }
      uint64_t v7 = v9 + 1;
      if (a2 + 1 + v9 < v4)
      {
        ++v9;
        if (v7 < v5) {
          continue;
        }
      }
      goto LABEL_15;
    }
    uint64_t v7 = v9;
  }
LABEL_15:
  if ((*(unsigned char *)(a1 + 504) & 3) != 0) {
    goto LABEL_22;
  }
  uint64_t v11 = 2 * *(void *)(a1 + 480);
  if (v11 >= *(void *)(a1 + 472)) {
    uint64_t v11 = *(void *)(a1 + 472);
  }
  uint64_t v12 = v11 + v7;
  uint64_t v13 = v4 - a2;
  uint64_t v7 = v12 >= v13 ? v13 : v12;
  uint64_t result = crabsEnsureSafetyMargin((void *)a1, a2);
  if (result) {
LABEL_22:
  }
    uint64_t result = crabsAllocateMoreBacking(a1, a2, v7, *(void *)(a1 + 224) > a2);
  *(unsigned char *)(a1 + 134) = result ^ 1;
  return result;
}

uint64_t crabsWaitForLoadAbort(uint64_t a1)
{
  if (dword_1E9350B10)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  FigRetainProxyLockMutex();
  *(_DWORD *)(a1 + 16) = -12871;
  MEMORY[0x19970CC00](*(void *)a1);
  return FigRetainProxyUnlockMutex();
}

BOOL crabsRangeInBlockIsCached(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 96);
  if (v3 == 0x4000)
  {
    uint64_t v4 = a2 >> 14;
  }
  else if (v3 == 0x10000)
  {
    uint64_t v4 = a2 >> 16;
  }
  else
  {
    uint64_t v4 = a2 / v3;
  }
  uint64_t v5 = *(int **)(*(void *)(a1 + 80) + 8 * v4);
  return v5 && v5[1] + v3 * *v5 >= a3 + a2;
}

uint64_t crabsAIOCallback()
{
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    FigRetainProxyGetOwner();
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    if (*(unsigned char *)(DerivedStorage + 104))
    {
      uint64_t v1 = DerivedStorage;
      if (crabsTaskHints(DerivedStorage, 0) != -12785) {
        crabsRebalanceWorkingSet(v1);
      }
    }
  }

  return crabsRetainProxyUnlockWithActions();
}

BOOL crabsEnsureSafetyMargin(void *a1, uint64_t a2)
{
  uint64_t v4 = 2 * a1[60];
  uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  crabsPurgeCompletionSweep(a1);
  if (v4 >= a1[11] + ~a2) {
    uint64_t v4 = a1[11] + ~a2;
  }
  if (crabsHasSafetyMargin(a1, a2, v4)) {
    return 1;
  }
  uint64_t v7 = a1[61];
  if (v7 && UpTimeNanoseconds < v7) {
    return 0;
  }
  if (a1[59] >= a1[11] + ~a2) {
    uint64_t v8 = a1[11] + ~a2;
  }
  else {
    uint64_t v8 = a1[59];
  }
  if (crabsAllocateMoreBacking((uint64_t)a1, a2, v8, a1[28] > a2))
  {
    a1[61] = 0;
    return 1;
  }
  a1[61] = UpTimeNanoseconds + 1090000000;

  return crabsHasSafetyMargin(a1, a2, v4);
}

void crabsRebalanceWorkingSet(uint64_t a1)
{
  int IsBusy = crabsDiskBackingIsBusy(a1, 0);
  flushPendingReleaseSet((void *)a1);
  int v3 = 0;
  if (*(unsigned char *)(a1 + 504)) {
    int v3 = crabsCompleteLazySync(a1, 0);
  }
  while (*(void *)(a1 + 352) < *(void *)(a1 + 344) / 2)
  {
    uint64_t v4 = **(int ***)(*(void *)(a1 + 320) + 8);
    if (!v4) {
      return;
    }
    unsigned int v5 = *((unsigned __int16 *)v4 + 4);
    if ((v5 & 8) == 0)
    {
LABEL_6:
      removeFromWorkingSet((void *)a1, (uint64_t)v4);
      uint64_t v6 = *v4;
      uint64_t v7 = *(void *)(a1 + 224);
      int v8 = v7 <= v6 && v7 + *(void *)(a1 + 344) / 4 > v6;
      addToWorkingSet((void *)a1, (uint64_t)v4, v8, 1);
      continue;
    }
    if ((v5 & 0x200) != 0)
    {
      if ((v5 >> 8)) {
        goto LABEL_16;
      }
    }
    else if (*((void *)v4 + 11))
    {
      goto LABEL_16;
    }
    if (!crabsAllocBacking(a1, v4)) {
      goto LABEL_6;
    }
    crabsAddBlockToBackedList((uint64_t *)a1, v4);
LABEL_16:
    if ((*(unsigned char *)(a1 + 504) & 1) == 0)
    {
      unsigned int v9 = *((unsigned __int16 *)v4 + 4);
      if ((v9 & 0x200) != 0)
      {
        if (((v9 >> 8) & 1) == 0) {
          goto LABEL_28;
        }
      }
      else if (!*((void *)v4 + 11))
      {
LABEL_28:
        if (v3) {
          return;
        }
        continue;
      }
      int v3 = crabsSyncBlock(a1, (uint64_t)v4);
      goto LABEL_28;
    }
    if (*(void *)(a1 + 728)) {
      return;
    }
    uint64_t v10 = *(void *)(a1 + 720);
    if (!v10 || *(unsigned __int8 *)(a1 + 135) | IsBusy) {
      return;
    }
    int v11 = FigAIOIssueWrite(v10, *(void *)(a1 + 16), *((void *)v4 + 12), v4[1], *(void *)(*((void *)v4 + 10) + 16), (uint64_t *)(a1 + 736));
    int v3 = v11;
    if (v11)
    {
      if (v11 == 35) {
        return;
      }
    }
    else
    {
      *((_WORD *)v4 + 4) &= ~8u;
      crabsRetainWorking((void *)a1, (uint64_t)v4);
      *(void *)(a1 + 728) = v4;
    }
  }
}

BOOL crabsBlockIsAKeeper(void *a1, int *a2)
{
  if ((a2[2] & 0x10) != 0) {
    return 1;
  }
  uint64_t v2 = a1[28];
  uint64_t v3 = *a2;
  if (**(void **)(a1[36] + 8) && v2 <= v3) {
    return 1;
  }
  unsigned int v5 = **(_DWORD ***)(a1[34] + 8);
  if (!v5) {
    return 1;
  }
  if (v2 <= v3) {
    return (int)v3 <= *v5;
  }
  return 0;
}

uint64_t crabsSwipeBacking(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = **(int ***)(*(void *)(a1 + 288) + 8);
  if (!v6)
  {
LABEL_6:
    if (a3 || (uint64_t v6 = **(int ***)(*(void *)(a1 + 272) + 8)) == 0)
    {
LABEL_7:
      return FigSignalErrorAt();
    }
    while (1)
    {
      uint64_t v12 = **(int ***)(*((void *)v6 + 7) + 8);
      __int16 v13 = *((_WORD *)v6 + 4);
      if ((v13 & 0x400) == 0
        && ((v13 & 0x80) == 0 || crabsMakeBackingNonvolatile((void *)a1, (uint64_t)v6, 1)))
      {
        break;
      }
      uint64_t v6 = v12;
      if (!v12) {
        goto LABEL_7;
      }
    }
    uint64_t v14 = *((void *)v6 + 6);
    __int16 v15 = (void *)*((void *)v6 + 7);
    if (v14)
    {
      *(void *)(v14 + 56) = v15;
      __int16 v15 = (void *)*((void *)v6 + 7);
    }
    else
    {
      if (!v15) {
        goto LABEL_26;
      }
      *(void *)(a1 + 272) = v15;
    }
    *__int16 v15 = v14;
    *((void *)v6 + 6) = 0;
    *((void *)v6 + 7) = 0;
    *((_WORD *)v6 + 4) &= ~0x1000u;
    goto LABEL_26;
  }
  while (1)
  {
    uint64_t v7 = **(int ***)(*((void *)v6 + 7) + 8);
    __int16 v8 = *((_WORD *)v6 + 4);
    if ((v8 & 0x400) == 0
      && ((v8 & 0x80) == 0 || crabsMakeBackingNonvolatile((void *)a1, (uint64_t)v6, 0)))
    {
      break;
    }
    uint64_t v6 = v7;
    if (!v7) {
      goto LABEL_6;
    }
  }
  uint64_t v10 = *((void *)v6 + 6);
  int v11 = (void *)*((void *)v6 + 7);
  if (v10)
  {
    *(void *)(v10 + 56) = v11;
    int v11 = (void *)*((void *)v6 + 7);
LABEL_20:
    *int v11 = v10;
    *((void *)v6 + 6) = 0;
    *((void *)v6 + 7) = 0;
    goto LABEL_26;
  }
  if (v11)
  {
    *(void *)(a1 + 288) = v11;
    goto LABEL_20;
  }
LABEL_26:
  int v16 = *(_DWORD *)(a1 + 504);
  if (v16)
  {
    if (v6 == *(int **)(a1 + 728))
    {
      crabsSyncBlock(a1, (uint64_t)v6);
      int v16 = *(_DWORD *)(a1 + 504);
    }
    *(void *)(a2 + 96) = *((void *)v6 + 12);
    *(_WORD *)(a2 + 8) |= 0x100u;
    *((void *)v6 + 12) = -1;
    *((_WORD *)v6 + 4) &= ~0x100u;
  }
  else
  {
    *(void *)(a2 + 88) = *((void *)v6 + 11);
    *((void *)v6 + 11) = 0;
  }
  uint64_t v17 = *(void *)(a1 + 224);
  *(void *)(a1 + 240) = (int)v17;
  ++*(void *)(a1 + 408);
  if ((v16 & 1) == 0) {
    *(unsigned char *)(a1 + 132) = 0;
  }
  if (v6[1] >= 1)
  {
    if (*((void *)v6 + 10)) {
      *((_WORD *)v6 + 4) |= 8u;
    }
    if (*(unsigned char *)(a1 + 128))
    {
      __int16 v18 = 2;
    }
    else if (v17 > *v6)
    {
      __int16 v18 = 1;
    }
    else
    {
      __int16 v18 = 2;
    }
    *(_WORD *)(a1 + 176) |= v18;
    *(unsigned char *)(a1 + 128) = 0;
  }
  crabsCleanupOrphan((void *)a1, v6);
  return 0;
}

BOOL crabsHasSafetyMargin(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(int **)(a1[10] + 8 * a2);
  if (!v6)
  {
    if (crabsInitBlock((uint64_t)a1, a2)) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = *(int **)(a1[10] + 8 * a2);
    }
  }
  unsigned int v7 = *((unsigned __int16 *)v6 + 4);
  if ((v7 & 0x200) == 0)
  {
    if (*((void *)v6 + 11)) {
      goto LABEL_7;
    }
    return 0;
  }
  if (((v7 >> 8) & 1) == 0) {
    return 0;
  }
LABEL_7:
  uint64_t v8 = a1[28];
  if (v8 <= a2)
  {
    uint64_t v9 = *((void *)v6 + 6);
    BOOL v10 = a3 > 0;
    if (v9) {
      BOOL v11 = a3 < 1;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      do
      {
        a3 += *(unsigned __int16 *)(v9 + 8) << 24 >> 31;
        uint64_t v9 = *(void *)(v9 + 48);
        BOOL v10 = a3 != 0;
        if (v9) {
          BOOL v12 = a3 == 0;
        }
        else {
          BOOL v12 = 1;
        }
      }
      while (!v12);
    }
    if (!v10) {
      return a3 == 0;
    }
    uint64_t v6 = (int *)a1[35];
  }
  if (a3 >= 1 && v6)
  {
    if (v8 <= *v6)
    {
      a3 = 1;
    }
    else
    {
      do
      {
        a3 += *((unsigned __int16 *)v6 + 4) << 24 >> 31;
        uint64_t v6 = (int *)*((void *)v6 + 6);
        if (v6) {
          BOOL v13 = a3 == 0;
        }
        else {
          BOOL v13 = 1;
        }
      }
      while (!v13);
    }
  }
  return a3 == 0;
}

uint64_t crabsAllocateMoreBacking(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  uint64_t v6 = *(void *)(a1 + 224);
  if (v6 != a2 && a3 >= 1)
  {
    do
    {
      uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 8 * v5);
      if (!v11)
      {
        if (crabsInitBlock(a1, v5)) {
          uint64_t v11 = 0;
        }
        else {
          uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 8 * v5);
        }
      }
      unsigned int v12 = *(unsigned __int16 *)(v11 + 8);
      if ((v12 & 0x200) != 0)
      {
        if ((v12 >> 8)) {
          goto LABEL_16;
        }
      }
      else if (*(void *)(v11 + 88))
      {
        goto LABEL_16;
      }
      if (!crabsAllocBacking(a1, (int *)v11))
      {
        uint64_t v6 = *(void *)(a1 + 224);
        if (v5 < v6 || !crabsBlockIsAKeeper((void *)a1, (int *)v11)) {
          return v5 == v6;
        }
        if (crabsSwipeBacking(a1, v11, a4))
        {
          uint64_t v6 = *(void *)(a1 + 224);
          return v5 == v6;
        }
      }
      crabsAddBlockToBackedList((uint64_t *)a1, (int *)v11);
      if ((*(_WORD *)(v11 + 8) & 0x11) == 0 && !*(void *)(v11 + 80))
      {
        if ((*(unsigned char *)(a1 + 504) & 3) == 0) {
          crabsMakeBlockVolatileRelativeToAnchor((void *)a1, (int *)v11);
        }
LABEL_16:
        --v4;
      }
      uint64_t v5 = (v5 + 1) % *(void *)(a1 + 88);
      uint64_t v6 = *(void *)(a1 + 224);
    }
    while (v5 != v6 && v4 > 0);
  }
  if (v4) {
    return v5 == v6;
  }
  return 1;
}

void flushPendingReleaseSet(void *a1)
{
  MEMORY[0x19970E290](a1[48]);
  for (uint64_t i = **(void ***)(a1[47] + 8); i; uint64_t i = **(void ***)(a1[47] + 8))
  {
    uint64_t v3 = i[8];
    uint64_t v4 = (void *)i[9];
    if (v3)
    {
      *(void *)(v3 + 72) = v4;
      uint64_t v4 = (void *)i[9];
    }
    else
    {
      a1[47] = v4;
    }
    *uint64_t v4 = v3;
    i[8] = 0;
    i[9] = 0;
    uint64_t v5 = i[10];
    if (v5 && !*(_DWORD *)(v5 + 24))
    {
      addToWorkingSet(a1, (uint64_t)i, 1, 1);
      uint64_t v6 = a1[12];
      gCRABS_Stats_1 += v6;
      a1[106] += v6;
    }
  }

  JUMPOUT(0x19970E2B0);
}

void crabsMakeCacheInFrontListVolatile(void *a1)
{
  uint64_t v1 = **(void **)(a1[34] + 8);
  if (v1)
  {
    do
    {
      uint64_t v3 = **(void **)(*(void *)(v1 + 56) + 8);
      crabsMakeBlockVolatileRelativeToAnchor(a1, (int *)v1);
      uint64_t v1 = v3;
    }
    while (v3);
  }
}

float crabsMakeCacheInFrontListNonvolatile(void *a1)
{
  uint64_t v2 = a1[33];
  if (v2)
  {
    do
    {
      uint64_t v3 = *(void *)(v2 + 48);
      if ((*(_WORD *)(v2 + 8) & 0x80) != 0 && !crabsMakeBackingNonvolatile(a1, v2, 1)) {
        break;
      }
      uint64_t v2 = v3;
    }
    while (v3);
  }

  return crabsPurgeCompletionSweep(a1);
}

uint64_t FigCRABSWrite(const void *a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  if (!a4) {
    goto LABEL_67;
  }
  uint64_t v10 = DerivedStorage;
  uint64_t v11 = a3;
  uint64_t v12 = crabsEnsureInitialized(a1);
  if (v12) {
    return v12;
  }
  uint64_t v13 = *(void *)(v10 + 96);
  if (v13 == 0x4000)
  {
    uint64_t v14 = a3;
    uint64_t v15 = a3 >> 14;
  }
  else
  {
    uint64_t v14 = a3;
    uint64_t v15 = v13 == 0x10000 ? a3 >> 16 : a3 / v13;
  }
  if (v15 >= *(void *)(v10 + 88) || !*(unsigned char *)(v10 + 104)) {
    goto LABEL_67;
  }
  uint64_t v16 = v15 * v13;
  if (v14 <= v15 * v13) {
    goto LABEL_15;
  }
  if (v14 - v15 * v13 < 0)
  {
LABEL_67:
    return FigSignalErrorAt();
  }
  uint64_t v12 = readOrRef(a1, v14 - v15 * v13, v15 * v13, 0, (CMBlockBufferRef *)&cf, 0, -1);
  if (v12) {
    return v12;
  }
  if (cf) {
    CFRelease(cf);
  }
LABEL_15:
  uint64_t v12 = FigRetainProxyLockMutex();
  if (v12) {
    return v12;
  }
  if (FigRetainProxyIsInvalidated())
  {
    unint64_t v17 = 0;
    uint64_t v35 = 4294954511;
    goto LABEL_59;
  }
  MEMORY[0x19970E290](*(void *)(v10 + 72));
  if (!a2)
  {
    uint64_t v35 = 0;
    unint64_t v17 = 0;
    goto LABEL_59;
  }
  unint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v38 = a4;
  uint64_t v37 = a5;
  uint64_t v19 = v11;
  while (v15 < *(void *)(v10 + 88))
  {
    uint64_t v20 = *(void *)(*(void *)(v10 + 80) + 8 * v15);
    if (!v20)
    {
      if (crabsInitBlock(v10, v15)) {
        break;
      }
      uint64_t v20 = *(void *)(*(void *)(v10 + 80) + 8 * v15);
      if (!v20) {
        break;
      }
    }
    uint64_t v21 = *(void *)(v20 + 80);
    if (!v21)
    {
      if (!crabsReadyBlockForLoad(v10, (int *)v20, 1)) {
        break;
      }
      uint64_t v21 = *(void *)(v20 + 80);
    }
    uint64_t v22 = v19 - v16;
    if (a2 - v17 >= *(void *)(v10 + 96) - (v19 - v16)) {
      size_t v23 = *(void *)(v10 + 96) - (v19 - v16);
    }
    else {
      size_t v23 = a2 - v17;
    }
    memcpy((void *)(*(void *)(v21 + 16) + v22), (const void *)(a4 + v18), v23);
    int v24 = *(_DWORD *)(v20 + 4);
    unint64_t v25 = v23 + v22;
    if (v25 > v24)
    {
      uint64_t v39 = v19;
      unint64_t v26 = *(void *)(v10 + 64) + v25 - v24;
      *(void *)(v10 + 64) = v26;
      uint64_t v27 = *(void *)(v10 + 920);
      if (v27)
      {
        uint64_t v28 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v29 = v28 ? v28 : 0;
        CFDataRef v30 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, void))(v29 + 56);
        if (v30) {
          v30(v27, 0x1EE582BF8, 0x1EE583C98, v26, 0);
        }
      }
      *(_DWORD *)(v20 + 4) = v25;
      int v24 = v25;
      a4 = v38;
      uint64_t v19 = v39;
    }
    __int16 v31 = *(_WORD *)(v20 + 8);
    __int16 v32 = v31 | 8;
    *(_WORD *)(v20 + 8) = v31 | 8;
    if ((*(unsigned char *)(v10 + 504) & 1) == 0 && (v31 & 0x100) != 0)
    {
      __int16 v32 = v31 | 0x48;
      *(_WORD *)(v20 + 8) = v31 | 0x48;
    }
    if (*(void *)(v10 + 96) == v24 || v15 + 1 == *(void *)(v10 + 88) && *(void *)(v10 + 56) - v16 == v24)
    {
      LOBYTE(v33) = v32 | 4;
      *(_WORD *)(v20 + 8) = v32 | 4;
      if (v32)
      {
        crabsUnhint(v10, v20);
        __int16 v33 = *(_WORD *)(v20 + 8);
      }
      if ((v33 & 0x20) == 0) {
        goto LABEL_47;
      }
    }
    else if ((v32 & 0x20) == 0)
    {
      goto LABEL_47;
    }
    crabsRetainWorking((void *)v10, v20);
    crabsReleaseWorking((void *)v10, (void *)v20, 1, 1);
LABEL_47:
    v19 += v23;
    *(_WORD *)(v10 + 176) |= 1u;
    uint64_t v34 = *(void *)(v10 + 96);
    if (v34 == 0x4000)
    {
      uint64_t v15 = v19 >> 14;
    }
    else if (v34 == 0x10000)
    {
      uint64_t v15 = v19 >> 16;
    }
    else
    {
      uint64_t v15 = v19 / v34;
    }
    v17 += v23;
    v18 += v23;
    uint64_t v16 = v15 * v34;
    if (v17 >= a2)
    {
      uint64_t v35 = 0;
      goto LABEL_58;
    }
  }
  uint64_t v35 = FigSignalErrorAt();
LABEL_58:
  a5 = v37;
LABEL_59:
  MEMORY[0x19970E2B0](*(void *)(v10 + 72));
  crabsUnlockWithActions(v10);
  if (a5) {
    *a5 = v17;
  }
  return v35;
}

uint64_t FigCRABSReadAndCreateBlockBuffer(const void *a1, size_t a2, uint64_t a3, CMBlockBufferRef *a4, void *a5)
{
  uint64_t v12 = 0;
  CMBaseObjectGetDerivedStorage();
  *a4 = 0;
  FigGetUpTimeNanoseconds();
  uint64_t v10 = readOrRef(a1, a2, a3, 0, a4, &v12, -1);
  if (a5) {
    *a5 = v12;
  }
  FigGetUpTimeNanoseconds();
  FigByteStreamStatsLogOneRead();
  return v10;
}

uint64_t FigCRABS_UnhintActiveRanges(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t result = crabsEnsureInitialized(a1);
  if (!result)
  {
    uint64_t result = FigRetainProxyLockMutex();
    if (!result)
    {
      if (a2 >= 1)
      {
        uint64_t v8 = 0;
        uint64_t v9 = DerivedStorage[12];
        do
        {
          uint64_t v10 = (uint64_t *)(a3 + 16 * v8);
          uint64_t v11 = *v10;
          if (v9 == 0x4000)
          {
            uint64_t v12 = v11 >> 14;
          }
          else if (v9 == 0x10000)
          {
            uint64_t v12 = v11 >> 16;
          }
          else
          {
            uint64_t v12 = v11 / v9;
          }
          while (1)
          {
            uint64_t v13 = v11 + *(void *)(a3 + 16 * v8 + 8) - 1;
            if (v9 == 0x4000) {
              uint64_t v14 = v13 >> 14;
            }
            else {
              uint64_t v14 = v9 == 0x10000 ? v13 >> 16 : v13 / v9;
            }
            if (v12 > v14 || v12 >= DerivedStorage[11]) {
              break;
            }
            uint64_t v15 = *(void *)(DerivedStorage[10] + 8 * v12);
            if (v15)
            {
              if (*(_WORD *)(v15 + 8))
              {
                crabsUnhint((uint64_t)DerivedStorage, v15);
                uint64_t v11 = *v10;
                uint64_t v9 = DerivedStorage[12];
              }
            }
            ++v12;
          }
          ++v8;
        }
        while (v8 != a2);
      }
      if (!a2)
      {
        while (1)
        {
          uint64_t v16 = DerivedStorage[31];
          if (!v16) {
            break;
          }
          crabsUnhint((uint64_t)DerivedStorage, v16);
        }
      }
      crabsUnlockWithActions((uint64_t)DerivedStorage);
      return 0;
    }
  }
  return result;
}

uint64_t FigCRABS_SyncCache(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = crabsEnsureInitialized(a1);
  if (!result)
  {
    uint64_t result = FigRetainProxyLockMutex();
    if (!result)
    {
      uint64_t v4 = crabsSyncCache(DerivedStorage);
      crabsUnlockWithActions(DerivedStorage);
      return v4;
    }
  }
  return result;
}

uint64_t FigCRABS_IterateCache(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v8 = *(const void **)(DerivedStorage + 760);
  if (v8) {
    CFTypeRef v9 = CFRetain(v8);
  }
  else {
    CFTypeRef v9 = 0;
  }
  uint64_t v28 = 0;
  char v27 = 0;
  if (a1) {
    CFRetain(a1);
  }
  if (a4)
  {
    uint64_t v10 = crabsEnsureInitialized(a1);
    if (v10) {
      goto LABEL_52;
    }
    unint64_t v25 = malloc_type_calloc(1uLL, *(void *)(DerivedStorage + 96), 0x8D01563FuLL);
    if (v25)
    {
      uint64_t v11 = FigRetainProxyLockMutex();
      if (v11)
      {
        uint64_t v17 = v11;
        goto LABEL_42;
      }
      int IsBusy = crabsDiskBackingIsBusy(DerivedStorage, 0);
      if (*(uint64_t *)(DerivedStorage + 88) < 1)
      {
        uint64_t v17 = 0;
        goto LABEL_41;
      }
      CFTypeRef v24 = v9;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      while (1)
      {
        uint64_t v28 = 0;
        char v27 = 1;
        uint64_t v14 = *(int **)(*(void *)(DerivedStorage + 80) + 8 * v13);
        if (v14)
        {
          uint64_t v15 = v14[1];
          if (v15)
          {
            if (*((void *)v14 + 10))
            {
              crabsRetainWorking((void *)DerivedStorage, (uint64_t)v14);
              uint64_t v16 = crabsCallCacheIterationCallback(DerivedStorage, *(void *)(*((void *)v14 + 10) + 16), v12, v15, a4, a2, &v27);
              if (v16 == -12785) {
                goto LABEL_50;
              }
              uint64_t v17 = v16;
              crabsReleaseWorking((void *)DerivedStorage, v14, 1, v16 == 0);
              if (v17) {
                goto LABEL_48;
              }
            }
            else
            {
              unsigned int v18 = *((unsigned __int16 *)v14 + 4);
              if ((v18 & 0x200) != 0) {
                int v19 = (v18 >> 8) & 1;
              }
              else {
                int v19 = *((void *)v14 + 11) != 0;
              }
              if (v19) {
                BOOL v20 = IsBusy == 0;
              }
              else {
                BOOL v20 = 0;
              }
              if (v20)
              {
                if (*(unsigned char *)(DerivedStorage + 504))
                {
                  FigFileForkRead();
                  if (v28 == v15)
                  {
                    uint64_t v22 = crabsCallCacheIterationCallback(DerivedStorage, (uint64_t)v25, v12, v15, a4, a2, &v27);
                    if (v22)
                    {
                      uint64_t v17 = v22;
LABEL_48:
                      CFTypeRef v9 = v24;
                      if (!v27)
                      {
LABEL_42:
                        free(v25);
                        if (v9) {
                          goto LABEL_43;
                        }
                        goto LABEL_44;
                      }
LABEL_41:
                      crabsUnlockWithActions(DerivedStorage);
                      goto LABEL_42;
                    }
                  }
                }
                else if ((v18 & 0x80) == 0 {
                       || crabsMakeBackingNonvolatile((void *)DerivedStorage, (uint64_t)v14, *(void *)(DerivedStorage + 224) <= *v14))
                }
                {
                  uint64_t v21 = crabsCallCacheIterationCallback(DerivedStorage, *((void *)v14 + 11), v12, v15, a4, a2, &v27);
                  if (v21 == -12785)
                  {
LABEL_50:
                    uint64_t v17 = 4294954511;
                    goto LABEL_39;
                  }
                  uint64_t v17 = v21;
                  if ((v18 & 0x80) != 0 && v27) {
                    crabsMakeBlockVolatileRelativeToAnchor((void *)DerivedStorage, v14);
                  }
                  if (v17) {
                    goto LABEL_48;
                  }
                }
              }
            }
          }
        }
        ++v13;
        v12 += *(void *)(DerivedStorage + 96);
        if (v13 >= *(void *)(DerivedStorage + 88))
        {
          uint64_t v17 = 0;
LABEL_39:
          CFTypeRef v9 = v24;
          goto LABEL_41;
        }
      }
    }
  }
  uint64_t v10 = FigSignalErrorAt();
LABEL_52:
  uint64_t v17 = v10;
  if (v9) {
LABEL_43:
  }
    CFRelease(v9);
LABEL_44:
  if (a1) {
    CFRelease(a1);
  }
  return v17;
}

uint64_t crabsCallCacheIterationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7)
{
  uint64_t v13 = *(const void **)(a1 + 760);
  if (v13)
  {
    CFTypeRef v14 = CFRetain(v13);
    if (a4) {
      goto LABEL_3;
    }
LABEL_10:
    a5 = 0;
    char v16 = 1;
    if (!a7) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  CFTypeRef v14 = 0;
  if (!a4) {
    goto LABEL_10;
  }
LABEL_3:
  FigRetainProxyUnlockMutex();
  LODWORD(a5) = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))a5)(a6, a4, a3, a2);
  unsigned int v15 = FigRetainProxyLockMutex();
  if (v15)
  {
    char v16 = 0;
    if (a5) {
      a5 = a5;
    }
    else {
      a5 = v15;
    }
    if (!a7) {
      goto LABEL_12;
    }
  }
  else
  {
    if (FigRetainProxyIsInvalidated()) {
      a5 = 4294954511;
    }
    else {
      a5 = a5;
    }
    char v16 = 1;
    if (!a7) {
      goto LABEL_12;
    }
  }
LABEL_11:
  *a7 = v16;
LABEL_12:
  if (v14) {
    CFRelease(v14);
  }
  return a5;
}

uint64_t FigDiskCacheProviderCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t FigBaseObject = FigDiskCacheProviderGetFigBaseObject(a1);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 48);
  if (!v10) {
    return 4294954514;
  }

  return v10(FigBaseObject, a2, a3, a4);
}

uint64_t FigDiskCacheProviderGetBackingFile(uint64_t a1)
{
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(v3 + 16);
  if (!v4) {
    return 0;
  }

  return v4(a1);
}

uint64_t crabsRestoreCache(uint64_t a1, CFDataRef theData, uint64_t a3, uint64_t a4)
{
  if (!theData) {
    goto LABEL_44;
  }
  BytePtr = CFDataGetBytePtr(theData);
  if (!BytePtr) {
    goto LABEL_44;
  }
  unsigned int v7 = BytePtr;
  if (*(_DWORD *)BytePtr != 83886080) {
    goto LABEL_44;
  }
  if (*((_DWORD *)BytePtr + 1) != 1650553443) {
    goto LABEL_44;
  }
  uint64_t v8 = *(void *)(a1 + 96);
  if (bswap32(v8) != *((_DWORD *)BytePtr + 2)) {
    goto LABEL_44;
  }
  uint64_t v9 = (int)bswap32(*((_DWORD *)BytePtr + 3));
  uint64_t v10 = *(void *)(a1 + 920);
  if (v10)
  {
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v12 = v11 ? v11 : 0;
    uint64_t v13 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v12 + 56);
    if (v13) {
      v13(v10, 0x1EE582BF8, 0x1EE585EB8, v8 * v9, 0);
    }
  }
  if (CFDataGetLength(theData) != 16 * v9 + 16)
  {
LABEL_44:
    return FigSignalErrorAt();
  }
  *(void *)(a1 + 16) = a3;
  MEMORY[0x19970E290](*(void *)(a1 + 72));
  if ((int)v9 < 1)
  {
    uint64_t v18 = 0;
LABEL_40:
    MEMORY[0x19970E2B0](*(void *)(a1 + 72));
    return v18;
  }
  CFTypeRef v14 = (unint64_t *)(v7 + 24);
  while (1)
  {
    uint64_t v15 = bswap32(*((_DWORD *)v14 - 2));
    if (*(void *)(a1 + 88) <= v15 || *(void *)(*(void *)(a1 + 80) + 8 * v15)) {
      return FigSignalErrorAt();
    }
    uint64_t inited = crabsInitBlock(a1, v15);
    if (inited) {
      return inited;
    }
    uint64_t v17 = *(void *)(*(void *)(a1 + 80) + 8 * v15);
    *(_WORD *)(v17 + 8) |= 0x100u;
    *(void *)(v17 + 96) = bswap64(*v14);
    if (*(unsigned char *)(a1 + 504))
    {
      crabsAddBlockToBackedList((uint64_t *)a1, (int *)v17);
      signed int v23 = bswap32(*((_DWORD *)v14 - 1));
      *(_DWORD *)(v17 + 4) = v23;
      uint64_t v24 = *(void *)(a1 + 64) + v23;
      *(void *)(a1 + 64) = v24;
      uint64_t v25 = *(void *)(a1 + 920);
      if (v25)
      {
        uint64_t v26 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v27 = v26 ? v26 : 0;
        uint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v27 + 56);
        if (v28) {
          v28(v25, 0x1EE582BF8, 0x1EE583C98, v24, 0);
        }
      }
    }
    else if (crabsAllocBacking(a1, (int *)v17))
    {
      signed int v35 = bswap32(*((_DWORD *)v14 - 1));
      uint64_t v18 = FigFileForkRead();
      crabsAddBlockToBackedList((uint64_t *)a1, (int *)v17);
      *(_DWORD *)(v17 + 4) = v35;
      uint64_t v19 = *(void *)(a1 + 64) + v35;
      *(void *)(a1 + 64) = v19;
      uint64_t v20 = *(void *)(a1 + 920);
      if (v20)
      {
        uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v22 = v21 ? v21 : 0;
        __int16 v31 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v22 + 56);
        if (v31) {
          v31(v20, 0x1EE582BF8, 0x1EE583C98, v19, 0);
        }
      }
      goto LABEL_30;
    }
    uint64_t v18 = 0;
LABEL_30:
    uint64_t v29 = *(int *)(v17 + 4);
    uint64_t v30 = *(void *)(a1 + 96);
    if (v30 == v29 || v15 + 1 == *(void *)(a1 + 88) && a4 - v30 * v15 == v29) {
      *(_WORD *)(v17 + 8) |= 4u;
    }
    v14 += 2;
    if (!--v9) {
      goto LABEL_40;
    }
  }
}

uint64_t crabsFlumeHostUnavailable()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    if (!*(_DWORD *)(DerivedStorage + 108))
    {
      *(_DWORD *)(DerivedStorage + 108) = 1;
      *(_WORD *)(DerivedStorage + 176) |= 0x40u;
    }
    *(unsigned char *)(DerivedStorage + 608) = 0;
  }

  return crabsRetainProxyUnlockWithActions();
}

uint64_t crabsFlumeHostAvailable()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    *(unsigned char *)(DerivedStorage + 608) = 0;
    if (*(_DWORD *)(DerivedStorage + 108))
    {
      *(_DWORD *)(DerivedStorage + 108) = 0;
      *(_WORD *)(DerivedStorage + 176) |= 0x40u;
      crabsStartIdleRead(DerivedStorage);
    }
  }

  return crabsRetainProxyUnlockWithActions();
}

uint64_t crabsFlumeConnectionToHostLost(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    *(_DWORD *)(DerivedStorage + 108) = 2;
    *(_WORD *)(DerivedStorage + 176) |= 0x40u;
    if (a5 && (Boolean Value = (__CFError *)CFDictionaryGetValue(a5, @"NotePayload_LastError")) != 0)
    {
      uint64_t v8 = Value;
      uint64_t v9 = *(const void **)(DerivedStorage + 952);
      *(void *)(DerivedStorage + 952) = Value;
      CFRetain(Value);
      if (v9) {
        CFRelease(v9);
      }
      int Code = CFErrorGetCode(v8);
    }
    else
    {
      int Code = -1004;
    }
    *(_DWORD *)(DerivedStorage + 944) = Code;
    if ((*(unsigned char *)(DerivedStorage + 504) & 1) == 0 || !crabsIsEntireLengthAvailableInCache(DerivedStorage)) {
      *(_WORD *)(DerivedStorage + 176) |= 0x20u;
    }
  }

  return crabsRetainProxyUnlockWithActions();
}

uint64_t crabsFlumeHostAvailableOnBetterInterface()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated() && *(_DWORD *)(DerivedStorage + 560) == 1)
  {
    if (*(uint64_t *)(DerivedStorage + 568) < 1)
    {
      if (crabsCancelRead((void *)DerivedStorage, (uint64_t *)(DerivedStorage + 512), -12932) != -12785)
      {
        uint64_t v1 = *(void *)(DerivedStorage + 920);
        if (v1)
        {
          uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v3 = v2 ? v2 : 0;
          uint64_t v4 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v3 + 32);
          if (v4) {
            v4(v1, 0x1EE582BF8, 0x1EE55E1D8, 1);
          }
        }
        crabsStartIdleRead(DerivedStorage);
      }
    }
    else
    {
      *(unsigned char *)(DerivedStorage + 608) = 1;
    }
  }

  return FigRetainProxyUnlockMutex();
}

uint64_t FigCRABSScheduledIOEqual()
{
  uint64_t DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
  uint64_t v1 = *(const void **)CMBaseObjectGetDerivedStorage();
  uint64_t v2 = *DerivedStorage;

  return CFEqual(v2, v1);
}

uint64_t FigCRABSScheduledIOCopyProperty(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  CMBaseObjectGetDerivedStorage();
  if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F21AB0])) {
    return 4294954512;
  }
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 48);
  if (!v11) {
    return 4294954514;
  }
  uint64_t v12 = *MEMORY[0x1E4F1FB78];

  return v11(CMBaseObject, v12, a3, a4);
}

uint64_t siocrabsFinishUnlocked(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = a3;
  if (!a2)
  {
    if (!a3 && *(unsigned char *)(a1 + 12))
    {
      uint64_t v21 = *(void *)a1;
      uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 24);
      uint64_t v23 = v22 ? v22 : 0;
      uint64_t v25 = *(void (**)(uint64_t, long long *))(v23 + 24);
      if (v25)
      {
        long long v26 = *MEMORY[0x1E4F1FA48];
        uint64_t v27 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
        v25(v21, &v26);
      }
    }
    uint64_t v10 = MEMORY[0x19970E910](*(void *)(a1 + 16));
    if (!v10)
    {
      int v11 = 0;
      uint64_t v12 = (uint64_t *)(a1 + 24);
      while (1)
      {
        if (v11 == -12871 && v3 == 0) {
          int v3 = 2;
        }
        uint64_t v14 = *v12;
        if (!*v12) {
          break;
        }
        uint64_t v15 = *(void *)(v14 + 16);
        *uint64_t v12 = v15;
        if (!v15) {
          *(void *)(a1 + 32) = v12;
        }
        MEMORY[0x19970E930](*(void *)(a1 + 16));
        int v16 = siocrabsFinish((uint64_t *)a1, v14, v3, 1);
        int v11 = v16;
        if (!v10) {
          LODWORD(v10) = v16;
        }
        unsigned int v17 = MEMORY[0x19970E910](*(void *)(a1 + 16));
        if (v10) {
          uint64_t v10 = v10;
        }
        else {
          uint64_t v10 = v17;
        }
        if (v17) {
          return v10;
        }
      }
      MEMORY[0x19970E930](*(void *)(a1 + 16));
    }
    return v10;
  }
  uint64_t v6 = MEMORY[0x19970E910](*(void *)(a1 + 16));
  if (v6) {
    return v6;
  }
  unsigned int v7 = (void *)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 24);
  if (!v8)
  {
LABEL_7:
    MEMORY[0x19970E930](*(void *)(a1 + 16));
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 24);
  while (*(_DWORD *)(v9 + 8) != a2)
  {
    uint64_t v9 = *(void *)(v9 + 16);
    if (!v9) {
      goto LABEL_7;
    }
  }
  if (v8 == v9)
  {
    uint64_t v24 = *(void *)(v8 + 16);
    *unsigned int v7 = v24;
    if (v24) {
      goto LABEL_32;
    }
  }
  else
  {
    do
    {
      uint64_t v19 = v8;
      uint64_t v8 = *(void *)(v8 + 16);
    }
    while (v8 != v9);
    uint64_t v20 = *(void *)(v9 + 16);
    *(void *)(v19 + 16) = v20;
    unsigned int v7 = (void *)(v19 + 16);
    if (v20) {
      goto LABEL_32;
    }
  }
  *(void *)(a1 + 32) = v7;
LABEL_32:
  MEMORY[0x19970E930](*(void *)(a1 + 16));

  return siocrabsFinish((uint64_t *)a1, v9, v3, 1);
}

uint64_t FigCRABSScheduledIOGetEOF(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  CFNumberRef number = 0;
  *a2 = 0;
  FigCRABSGetByteStream(*DerivedStorage);
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  unsigned int v7 = *(uint64_t (**)(uint64_t, void, void, CFNumberRef *))(v6 + 48);
  if (!v7) {
    return 4294954514;
  }
  uint64_t result = v7(CMBaseObject, *MEMORY[0x1E4F1EC50], *MEMORY[0x1E4F1CF80], &number);
  if (!result)
  {
    CFNumberGetValue(number, kCFNumberSInt64Type, a2);
    CFRelease(number);
    return 0;
  }
  return result;
}

uint64_t FigCRABSScheduledIOGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v6 = FigCRABSGetByteStream(*DerivedStorage);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 24);
  if (!v9) {
    return 4294954514;
  }

  return v9(v6, a2, a3);
}

uint64_t FigTTMLFormatReaderCreateFromStream(uint64_t a1, int a2, CFAllocatorRef allocator, CFTypeRef *a4)
{
  CFTypeRef cf = 0;
  CFTypeRef v31 = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
  char v29 = 0;
  CFURLRef url = 0;
  if (a1)
  {
    if (a4)
    {
      FigFormatReaderGetClassID();
      uint64_t v7 = CMDerivedObjectCreate();
      if (v7)
      {
        uint64_t v19 = v7;
        FigSignalErrorAt();
        goto LABEL_50;
      }
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
      uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
      uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = *(uint64_t (**)(uint64_t, void, void, CFURLRef *))(v11 + 48);
      if (!v12)
      {
        unsigned int v17 = 0;
        CFMutableArrayRef v18 = 0;
        uint64_t v19 = 4294954514;
        goto LABEL_30;
      }
      CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v14 = v12(CMBaseObject, *MEMORY[0x1E4F1EC78], *MEMORY[0x1E4F1CF80], &url);
      if (!v14)
      {
        if (url)
        {
          CFStringRef v15 = CFURLCopyPathExtension(url);
          CFStringRef v16 = v15;
          if (v15 && CFStringCompare(v15, @"itt", 1uLL) == kCFCompareEqualTo)
          {
            unsigned int v17 = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CFDictionarySetValue(v17, @"FixUpiTTLeftRegionOrigin", (const void *)*MEMORY[0x1E4F1CFC8]);
            LOBYTE(v27) = 0;
            FigCFDictionaryGetBooleanIfPresent();
            MEMORY[0x19970EE10](&ttmlFormatReader_isSDKVersionBeforeJazz_sOnce, ttmlFormatReader_initIsSDKVersionBeforeJazz);
            if (sTTMLFormatReader_IsSDKVersionBeforeJazz) {
              CFDictionarySetValue(v17, @"ConsolidateiTTRegions", (const void *)*MEMORY[0x1E4F1CFD0]);
            }
          }
          else
          {
            unsigned int v17 = 0;
          }
        }
        else
        {
          unsigned int v17 = 0;
          CFStringRef v16 = 0;
        }
        uint64_t v20 = TTMLParserCreate((uint64_t)Mutable, (uint64_t)ttmlFormatReader_appendSampleBuffer, v17, &cf);
        if (!v20)
        {
          FigCFDictionaryGetBooleanIfPresent();
          if (v29)
          {
            CFMutableArrayRef v18 = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]);
            *(void *)&long long v27 = ttmlFormatReader_reportSkippedSyntaxElement;
            *((void *)&v27 + 1) = ttmlFormatReader_reportUnsupportedFeatures;
            uint64_t v21 = TTMLParserRegisterReportingCallbacks((uint64_t)cf, (uint64_t)v18, &v27);
            if (v21) {
              goto LABEL_18;
            }
          }
          else
          {
            CFMutableArrayRef v18 = 0;
          }
          uint64_t v21 = TTMLParserParseStream((uint64_t)cf, a1);
          if (!v21)
          {
            if (CFArrayGetCount(Mutable))
            {
              *(void *)&long long v27 = 0;
              FigTrackReaderGetClassID();
              uint64_t v22 = CMDerivedObjectCreate();
              if (v22)
              {
                uint64_t v19 = v22;
                FigSignalErrorAt();
                if (!v16)
                {
LABEL_30:
                  if (url) {
                    CFRelease(url);
                  }
                  if (v17) {
                    CFRelease(v17);
                  }
                  if (v18) {
                    CFRelease(v18);
                  }
                  if (Mutable) {
                    goto LABEL_37;
                  }
                  goto LABEL_38;
                }
LABEL_29:
                CFRelease(v16);
                goto LABEL_30;
              }
              uint64_t v23 = CMBaseObjectGetDerivedStorage();
              if (Mutable) {
                CFTypeRef v24 = CFRetain(Mutable);
              }
              else {
                CFTypeRef v24 = 0;
              }
              uint64_t v19 = 0;
              *(void *)(v23 + 8) = v24;
              uint64_t v25 = v27;
              DerivedStorage[1] = Mutable;
              DerivedStorage[2] = v18;
              *uint64_t DerivedStorage = v25;
              *a4 = v31;
              CFTypeRef v31 = 0;
              CFMutableArrayRef Mutable = 0;
LABEL_28:
              CFMutableArrayRef v18 = 0;
              if (!v16) {
                goto LABEL_30;
              }
              goto LABEL_29;
            }
            uint64_t v21 = FigSignalErrorAt();
          }
LABEL_18:
          uint64_t v19 = v21;
          if (!v16) {
            goto LABEL_30;
          }
          goto LABEL_29;
        }
        uint64_t v19 = v20;
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v14 = FigSignalErrorAt();
    }
    uint64_t v19 = v14;
LABEL_50:
    unsigned int v17 = 0;
    CFMutableArrayRef v18 = 0;
    goto LABEL_30;
  }
  uint64_t v19 = FigSignalErrorAt();
  if (Mutable) {
LABEL_37:
  }
    CFRelease(Mutable);
LABEL_38:
  if (cf) {
    CFRelease(cf);
  }
  if (v31) {
    CFRelease(v31);
  }
  return v19;
}

uint64_t ttmlFormatReader_appendSampleBuffer(__CFArray *a1, const void *a2)
{
  return 0;
}

void ttmlFormatReader_reportSkippedSyntaxElement(__CFArray *a1, CFArrayRef theArray)
{
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      CFIndex v3 = 0;
      CFMutableDictionaryRef Mutable = 0;
      CFStringRef v5 = 0;
      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v3);
        if (Mutable) {
          CFRelease(Mutable);
        }
        if (v5) {
          CFRelease(v5);
        }
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFStringRef v5 = CFStringCreateWithFormat(v6, 0, @"The parser skipped a syntax element: %@", ValueAtIndex);
        FigCFDictionarySetInt32();
        FigCFDictionarySetInt32();
        FigCFDictionarySetValue();
        FigCFDictionarySetValue();
        CFArrayAppendValue(a1, Mutable);
        ++v3;
      }
      while (Count != v3);
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (v5)
      {
        CFRelease(v5);
      }
    }
  }
}

void ttmlFormatReader_reportUnsupportedFeatures(__CFArray *a1, CFArrayRef theArray)
{
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      CFIndex v3 = 0;
      CFMutableDictionaryRef Mutable = 0;
      CFStringRef v5 = 0;
      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v3);
        if (Mutable) {
          CFRelease(Mutable);
        }
        if (v5) {
          CFRelease(v5);
        }
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFStringRef v5 = CFStringCreateWithFormat(v6, 0, @"The parser doesn't support a feature/extension: %@", ValueAtIndex);
        FigCFDictionarySetInt32();
        FigCFDictionarySetInt32();
        FigCFDictionarySetValue();
        FigCFDictionarySetValue();
        CFArrayAppendValue(a1, Mutable);
        ++v3;
      }
      while (Count != v3);
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (v5)
      {
        CFRelease(v5);
      }
    }
  }
}

void ttmlFormatReader_Finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)DerivedStorage) {
    CFRelease(*(CFTypeRef *)DerivedStorage);
  }
  uint64_t v1 = *(const void **)(DerivedStorage + 8);
  if (v1) {
    CFRelease(v1);
  }
  uint64_t v2 = *(const void **)(DerivedStorage + 16);
  if (v2)
  {
    CFRelease(v2);
  }
}

__CFString *ttmlFormatReader_CopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<TTMLFormatReader %p>", a1);
  return Mutable;
}

uint64_t ttmlFormatReader_CopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2 && a4)
  {
    uint64_t v8 = (void *)DerivedStorage;
    if (FigCFEqual() || FigCFEqual())
    {
      uint64_t FigBaseObject = FigTrackReaderGetFigBaseObject(*v8);
      uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, void *))(v11 + 48);
      if (!v12) {
        return 4294954514;
      }
      return v12(FigBaseObject, @"UneditedTrackDuration", a3, a4);
    }
    if (FigCFEqual())
    {
      uint64_t v14 = @"com.apple.coremedia.formatreader.ttml";
    }
    else
    {
      if (FigCFEqual())
      {
        uint64_t result = 0;
        if (v8[2]) {
          CFStringRef v16 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
        }
        else {
          CFStringRef v16 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
        }
        CFTypeRef v15 = *v16;
        goto LABEL_22;
      }
      if (!FigCFEqual()) {
        return 4294954512;
      }
      uint64_t v14 = (__CFString *)v8[2];
      if (!v14)
      {
        CFTypeRef v15 = 0;
        goto LABEL_16;
      }
    }
    CFTypeRef v15 = CFRetain(v14);
LABEL_16:
    uint64_t result = 0;
LABEL_22:
    *a4 = v15;
    return result;
  }

  return FigSignalErrorAt();
}

uint64_t ttmlFormatReader_GetTrackCount(uint64_t a1, void *a2)
{
  *a2 = 1;
  return 0;
}

uint64_t ttmlFormatReader_CopyTrackByIndex(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    return FigSignalErrorAt();
  }
  else
  {
    if (a3)
    {
      CFTypeRef v10 = *DerivedStorage;
      if (v10) {
        CFTypeRef v10 = CFRetain(v10);
      }
      *a3 = v10;
    }
    if (a4) {
      *a4 = 1952807028;
    }
    if (a5) {
      *a5 = 1;
    }
    return 0;
  }
}

uint64_t ttmlFormatReader_CopyTrackByID(uint64_t a1, int a2, void *a3, _DWORD *a4)
{
  uint64_t DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage();
  if (a2 == 1)
  {
    if (a3)
    {
      CFTypeRef v8 = *DerivedStorage;
      if (v8) {
        CFTypeRef v8 = CFRetain(v8);
      }
      *a3 = v8;
    }
    if (a4) {
      *a4 = 1952807028;
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t ttmlFormatReader_CopyTrackByType(uint64_t a1, uint64_t a2, int a3, void *a4, _DWORD *a5)
{
  uint64_t DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage();
  if (a2) {
    return 4294954453;
  }
  if (a3 != 1952807028) {
    return 4294954452;
  }
  if (a4)
  {
    CFTypeRef v10 = *DerivedStorage;
    if (v10) {
      CFTypeRef v10 = CFRetain(v10);
    }
    *a4 = v10;
  }
  uint64_t result = 0;
  if (a5) {
    *a5 = 1;
  }
  return result;
}

uint64_t ttmlFormatReader_initIsSDKVersionBeforeJazz()
{
  uint64_t result = _CFExecutableLinkedOnOrAfter();
  sTTMLFormatReader_IsSDKVersionBeforeJazz = result == 0;
  return result;
}

void ttmlCaptionTrackReader_Finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)DerivedStorage) {
    CFRelease(*(CFTypeRef *)DerivedStorage);
  }
  uint64_t v1 = *(const void **)(DerivedStorage + 8);
  if (v1) {
    CFRelease(v1);
  }
  uint64_t v2 = *(const void **)(DerivedStorage + 16);
  if (v2)
  {
    CFRelease(v2);
  }
}

__CFString *ttmlCaptionTrackReader_CopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<TTMLCaptionTrackReader %p>", a1);
  return Mutable;
}

uint64_t ttmlCaptionTrackReader_CopyProperty(const void *a1, uint64_t a2, const __CFAllocator *a3, CFArrayRef *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2 && a4)
  {
    uint64_t v9 = (CFArrayRef *)DerivedStorage;
    if (FigCFEqual() || FigCFEqual())
    {
      CMTime v28 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      if (CFArrayGetCount(v9[1]))
      {
        CFNumberRef ValueAtIndex = (opaqueCMSampleBuffer *)CFArrayGetValueAtIndex(v9[1], 0);
        CFArrayRef v11 = v9[1];
        CFIndex Count = CFArrayGetCount(v11);
        CFAllocatorRef v13 = (opaqueCMSampleBuffer *)CFArrayGetValueAtIndex(v11, Count - 1);
        memset(&time, 0, sizeof(time));
        CMSampleBufferGetPresentationTimeStamp(&time, ValueAtIndex);
        memset(&v26, 0, sizeof(v26));
        CMSampleBufferGetPresentationTimeStamp(&v26, v13);
        memset(&v25, 0, sizeof(v25));
        CMSampleBufferGetDuration(&v25, v13);
        memset(&v24, 0, sizeof(v24));
        CMTime lhs = v26;
        CMTime v22 = v25;
        CMTimeAdd(&v24, &lhs, &v22);
        CMTime lhs = v24;
        CMTime v22 = time;
        CMTimeSubtract(&v28, &lhs, &v22);
      }
      CMTime time = v28;
      CFArrayRef value = CMTimeCopyAsDictionary(&time, a3);
      goto LABEL_8;
    }
    if (FigCFEqual())
    {
      CFArrayRef value = v9[2];
      if (!value)
      {
        CFArrayRef v17 = v9[1];
        CFGetAllocator(a1);
        v28.CFArrayRef value = 0;
        FigSampleCursorServiceGetClassID();
        uint64_t v18 = CMDerivedObjectCreate();
        if (v18)
        {
          uint64_t v15 = v18;
          FigSignalErrorAt();
          return v15;
        }
        uint64_t v19 = (void *)CMBaseObjectGetDerivedStorage();
        *uint64_t v19 = CFRetain(v17);
        CFArrayRef value = (CFArrayRef)v28.value;
        v9[2] = (CFArrayRef)v28.value;
        if (!value) {
          goto LABEL_8;
        }
      }
    }
    else
    {
      if (!FigCFEqual()) {
        return 4294954512;
      }
      CFArrayRef value = *v9;
      if (!*v9)
      {
        CFAllocatorRef v20 = CFGetAllocator(a1);
        uint64_t FormatDescriptionArray = ttmlFormatReader_createFormatDescriptionArray(v20, v9);
        if (FormatDescriptionArray) {
          return FormatDescriptionArray;
        }
        CFArrayRef value = *v9;
        if (!*v9)
        {
LABEL_8:
          uint64_t v15 = 0;
          *a4 = value;
          return v15;
        }
      }
    }
    CFArrayRef value = (CFArrayRef)CFRetain(value);
    goto LABEL_8;
  }

  return FigSignalErrorAt();
}

uint64_t ttmlFormatReader_createFormatDescriptionArray(const __CFAllocator *a1, CFArrayRef *a2)
{
  CMFormatDescriptionRef formatDescriptionOut = 0;
  if (a2)
  {
    uint64_t v4 = CMFormatDescriptionCreate(a1, 0x74657874u, 0x61697474u, 0, &formatDescriptionOut);
    if (!v4)
    {
      CFArrayRef v5 = CFArrayCreate(a1, (const void **)&formatDescriptionOut, 1, MEMORY[0x1E4F1D510]);
      if (v5)
      {
        uint64_t v6 = 0;
        *a2 = v5;
LABEL_5:
        if (formatDescriptionOut) {
          CFRelease(formatDescriptionOut);
        }
        return v6;
      }
      uint64_t v4 = FigSignalErrorAt();
    }
    uint64_t v6 = v4;
    goto LABEL_5;
  }

  return FigSignalErrorAt();
}

void ttmlCursorService_Finalize()
{
  CFAllocatorRef v0 = *(const void **)CMBaseObjectGetDerivedStorage();
  if (v0)
  {
    CFRelease(v0);
  }
}

__CFString *ttmlCursorService_CopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<TTMLSampleCursorService %p>", a1);
  return Mutable;
}

uint64_t ttmlSampleCursorService_CreateCursorAtTime(const void *a1, CMTime *a2, void *a3, char *a4, char *a5)
{
  CFTypeRef cf = 0;
  uint64_t v9 = ttmlSampleCursorService_CreateCursorAtFirstSample(a1, &cf);
  CFTypeRef v10 = cf;
  if (!v9 && (CMTime v12 = *a2, ttmlSampleCursor_MoveToTime((uint64_t)cf, &v12, a4, a5), a3))
  {
    *a3 = v10;
  }
  else if (v10)
  {
    CFRelease(v10);
  }
  return v9;
}

uint64_t ttmlSampleCursorService_CreateCursorNearTime(const void *a1, CMTime *a2, uint64_t a3, void *a4, char *a5, char *a6)
{
  CMTime v7 = *a2;
  return ttmlSampleCursorService_CreateCursorAtTime(a1, &v7, a4, a5, a6);
}

uint64_t ttmlSampleCursorService_CreateCursorAtFirstSample(const void *a1, CFTypeRef *a2)
{
  uint64_t DerivedStorage = (CFArrayRef *)CMBaseObjectGetDerivedStorage();
  int v5 = CFGetAllocator(a1);
  CFTypeRef cf = 0;
  uint64_t v6 = ttmlSampleCursorCreate(v5, *DerivedStorage, 0, &cf);
  if (v6)
  {
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    *a2 = cf;
  }
  return v6;
}

uint64_t ttmlSampleCursorService_CreateCursorAtLastSample(const void *a1, CFTypeRef *a2)
{
  uint64_t DerivedStorage = (const __CFArray **)CMBaseObjectGetDerivedStorage();
  LODWORD(a1) = CFGetAllocator(a1);
  CFTypeRef cf = 0;
  CFArrayRef v5 = *DerivedStorage;
  CFIndex Count = CFArrayGetCount(v5);
  uint64_t v7 = ttmlSampleCursorCreate((int)a1, v5, Count - 1, &cf);
  if (v7)
  {
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    *a2 = cf;
  }
  return v7;
}

CFIndex ttmlSampleCursor_MoveToTime(uint64_t a1, CMTime *a2, char *a3, char *a4)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  CFArrayRef v8 = (const __CFArray *)DerivedStorage[1];
  CFIndex Count = CFArrayGetCount(v8);
  CFNumberRef ValueAtIndex = (opaqueCMSampleBuffer *)CFArrayGetValueAtIndex(v8, 0);
  CFArrayRef v11 = (opaqueCMSampleBuffer *)CFArrayGetValueAtIndex(v8, Count - 1);
  memset(&v29, 0, sizeof(v29));
  CMSampleBufferGetPresentationTimeStamp(&v29, ValueAtIndex);
  memset(&v28, 0, sizeof(v28));
  CMSampleBufferGetPresentationTimeStamp(&lhs, v11);
  CMSampleBufferGetDuration(&rhs, v11);
  CMTimeAdd(&v28, &lhs, &rhs);
  CMTime time1 = *a2;
  CMTime time2 = v29;
  CFIndex result = CMTimeCompare(&time1, &time2);
  if ((result & 0x80000000) != 0)
  {
    char v20 = 0;
    *uint64_t DerivedStorage = 0;
    char v19 = 1;
    if (!a3) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  CMTime time1 = v28;
  CMTime time2 = *a2;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    for (uint64_t i = 0; ; Count = v17 - i)
    {
      uint64_t v14 = Count + i;
      if (i >= 0) {
        uint64_t v15 = i;
      }
      else {
        uint64_t v15 = i + 1;
      }
      if (v14 >= 0) {
        uint64_t v16 = Count + i;
      }
      else {
        uint64_t v16 = v14 + 1;
      }
      CFIndex v17 = (v16 >> 1) + (v15 >> 1);
      uint64_t v18 = (opaqueCMSampleBuffer *)CFArrayGetValueAtIndex(v8, v17);
      memset(&time1, 0, sizeof(time1));
      CMSampleBufferGetPresentationTimeStamp(&time1, v18);
      memset(&time2, 0, sizeof(time2));
      CMSampleBufferGetDuration(&v23, v18);
      CMTime v22 = time1;
      CMTimeAdd(&time2, &v22, &v23);
      CMTime v22 = *a2;
      CMTime v21 = time1;
      if ((CMTimeCompare(&v22, &v21) & 0x80000000) == 0)
      {
        CMTime v22 = time2;
        CMTime v21 = *a2;
        CFIndex result = CMTimeCompare(&v22, &v21);
        if ((int)result > 0)
        {
          char v19 = 0;
          char v20 = 0;
          *uint64_t DerivedStorage = v17;
          if (!a3) {
            goto LABEL_18;
          }
LABEL_17:
          *a3 = v19;
          goto LABEL_18;
        }
        uint64_t i = v17 + 1;
        CFIndex v17 = v14;
      }
    }
  }
  CFIndex result = CFArrayGetCount(v8);
  char v19 = 0;
  *uint64_t DerivedStorage = result - 1;
  char v20 = 1;
  if (a3) {
    goto LABEL_17;
  }
LABEL_18:
  if (a4) {
    *a4 = v20;
  }
  return result;
}

uint64_t ttmlSampleCursorCreate(int a1, CFArrayRef theArray, uint64_t a3, void *a4)
{
  if (theArray && CFArrayGetCount(theArray))
  {
    FigSampleCursorGetClassID();
    uint64_t v7 = CMDerivedObjectCreate();
    if (v7)
    {
      FigSignalErrorAt();
    }
    else
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
      CFTypeRef v9 = CFRetain(theArray);
      *uint64_t DerivedStorage = a3;
      DerivedStorage[1] = v9;
      *a4 = 0;
    }
    return v7;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void ttmlSampleCursor_Finalize()
{
  CFAllocatorRef v0 = *(const void **)(CMBaseObjectGetDerivedStorage() + 8);
  if (v0)
  {
    CFRelease(v0);
  }
}

__CFString *ttmlSampleCursor_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<TTMLSampleCursor %p>{currentIndex:%ld}", a1, *DerivedStorage);
  return Mutable;
}

uint64_t ttmlSampleCursor_CopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 && a4) {
    return 4294954512;
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t ttmlSampleCursor_Copy(const void *a1, void *a2)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  CFGetAllocator(a1);
  FigSampleCursorGetClassID();
  uint64_t v5 = CMDerivedObjectCreate();
  if (v5)
  {
    FigSignalErrorAt();
  }
  else
  {
    uint64_t v6 = (void *)CMBaseObjectGetDerivedStorage();
    CFTypeRef v7 = (CFTypeRef)DerivedStorage[1];
    *uint64_t v6 = *DerivedStorage;
    if (v7) {
      CFTypeRef v7 = CFRetain(v7);
    }
    v6[1] = v7;
    *a2 = 0;
  }
  return v5;
}

uint64_t ttmlSampleCursor_CompareInDecodeOrder()
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v1 = (void *)CMBaseObjectGetDerivedStorage();
  if (*DerivedStorage < *v1) {
    return -1;
  }
  else {
    return *DerivedStorage > *v1;
  }
}

uint64_t ttmlSampleCursor_GetStartTime(uint64_t a1, CMTime *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFNumberRef ValueAtIndex = (opaqueCMSampleBuffer *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 8), *(void *)DerivedStorage);
  memset(&v6, 0, sizeof(v6));
  CMSampleBufferGetPresentationTimeStamp(&v6, ValueAtIndex);
  *a2 = v6;
  return 0;
}

uint64_t ttmlSampleCursor_GetDuration(uint64_t a1, CMTime *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFNumberRef ValueAtIndex = (opaqueCMSampleBuffer *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 8), *(void *)DerivedStorage);
  memset(&v6, 0, sizeof(v6));
  CMSampleBufferGetDuration(&v6, ValueAtIndex);
  *a2 = v6;
  return 0;
}

uint64_t ttmlSampleCursor_GetDependencyInfo(uint64_t a1, unsigned char *a2, unsigned char *a3, _DWORD *a4, unsigned char *a5)
{
  if (a2) {
    *a2 = 1;
  }
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  return 0;
}

uint64_t ttmlSampleCursor_CreateSample(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 8), *(void *)DerivedStorage);
  *a3 = CFRetain(ValueAtIndex);
  return 0;
}

uint64_t ttmlSampleCursor_StepByTime(uint64_t a1, CMTime *a2)
{
  CMTime v9 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CMTime v8 = v9;
  __int16 v7 = 0;
  ttmlSampleCursor_GetStartTime(a1, &v9);
  CMTime lhs = v9;
  CMTime v5 = *a2;
  CMTimeAdd(&v8, &lhs, &v5);
  CMTime lhs = v8;
  ttmlSampleCursor_MoveToTime(a1, &lhs, (char *)&v7 + 1, (char *)&v7);
  if (HIBYTE(v7) | v7) {
    return 4294954456;
  }
  else {
    return 0;
  }
}

uint64_t ttmlSampleCursor_CopyFormatDescription(const void *a1, CMFormatDescriptionRef *a2)
{
  CMFormatDescriptionRef formatDescriptionOut = 0;
  CFAllocatorRef v3 = CFGetAllocator(a1);
  uint64_t v4 = CMFormatDescriptionCreate(v3, 0x63706772u, 0, 0, &formatDescriptionOut);
  if (!a2 || v4)
  {
    if (formatDescriptionOut) {
      CFRelease(formatDescriptionOut);
    }
  }
  else
  {
    *a2 = formatDescriptionOut;
  }
  return v4;
}

uint64_t ttmlSampleCursor_StepAndReportStepsTaken(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = *(void *)DerivedStorage;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 8));
  uint64_t v8 = Count - 1;
  if (Count < 1) {
    return 4294954454;
  }
  if (((v6 + a2) & (unint64_t)~((v6 + a2) >> 63)) < Count) {
    uint64_t v8 = (v6 + a2) & ~((v6 + a2) >> 63);
  }
  *(void *)uint64_t DerivedStorage = v8;
  uint64_t result = 0;
  if (a3) {
    *a3 = v8 - v6;
  }
  return result;
}

uint64_t ttmlCaptionTrackReader_GetTrackInfo(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (a2) {
    *a2 = 1;
  }
  if (a3) {
    *a3 = 1952807028;
  }
  return 0;
}

uint64_t QTMovieCacheMemReallocateCallBack()
{
  return 0;
}

uint64_t fpm_StallWarningProc()
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    memset(v15, 0, sizeof(v15));
    memset(&v14, 0, sizeof(v14));
    memset(&v13, 0, sizeof(v13));
    CMTime v12 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
    uint64_t Owner = (__CFData *)FigRetainProxyGetOwner();
    MutableBytePtr = CFDataGetMutableBytePtr(Owner);
    MEMORY[0x19970E290](*((void *)MutableBytePtr + 6));
    os_retain(*((void **)MutableBytePtr + 1070));
    voucher_adopt();
    if (CMTimebaseGetRate(*((CMTimebaseRef *)MutableBytePtr + 3)) > 0.0)
    {
      FigPlayabilityMonitorGetPlayableRange((uint64_t)MutableBytePtr, (uint64_t)v15, &v14);
      CMTimebaseGetTime(&v13, *((CMTimebaseRef *)MutableBytePtr + 3));
      CMTime lhs = v14;
      CMTime rhs = v13;
      CMTimeSubtract(&time, &lhs, &rhs);
      double Seconds = CMTimeGetSeconds(&time);
      FigFormatReaderUtilityGetDuration(*((void *)MutableBytePtr + 1), 1, &v12);
      CMTime lhs = v12;
      CMTime rhs = v13;
      double v3 = 0.0;
      if (CMTimeCompare(&lhs, &rhs) >= 1)
      {
        CMTime lhs = v12;
        CMTime rhs = v13;
        CMTimeSubtract(&v10, &lhs, &rhs);
        double v3 = CMTimeGetSeconds(&v10);
      }
      double v4 = fmax(Seconds, 0.0);
      if (dword_1E9350B30)
      {
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      if (*((_DWORD *)MutableBytePtr + 26) != 3 && v3 > v4)
      {
        if (v4 >= 0.1)
        {
          if (dword_1E9350B30)
          {
            __int16 v7 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          fpm_updateCache((uint64_t)MutableBytePtr);
        }
        else
        {
          *((void *)MutableBytePtr + 13) = 3;
          if (dword_1E9350B30)
          {
            uint64_t v6 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          FigRetainProxyRetain();
          CMNotificationCenterGetDefaultLocalCenter();
          FigDeferNotificationToDispatchQueue();
        }
      }
    }
    uint64_t v8 = (void *)voucher_adopt();
    os_release(v8);
    MEMORY[0x19970E2B0](*((void *)MutableBytePtr + 6));
  }
  return FigRetainProxyUnlockMutex();
}

uint64_t fpm_prepareDataRateProfile(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFMutableArrayRef v3 = Mutable;
    if (*(uint64_t *)(a1 + 80) >= 1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 0;
      while (!FigCFArrayAppendInt32())
      {
        ++v5;
        v4 += 48;
        if (v5 >= *(void *)(a1 + 80)) {
          goto LABEL_6;
        }
      }
      uint64_t v6 = (const void *)FigSignalErrorAt();
      goto LABEL_15;
    }
LABEL_6:
    if (!FigFormatReaderUtilityEstablishCombinedDataRateProfileForTracks(*(void *)(a1 + 8), v3, (void *)(a1 + 336), 1024, (CMTime *)(a1 + 8528)))
    {
      uint64_t v6 = 0;
      *(unsigned char *)(a1 + 8552) = 1;
LABEL_15:
      CFRelease(v3);
      return (uint64_t)v6;
    }
    uint64_t v6 = (const void *)MGCopyAnswer();
    if (FigCFEqual())
    {
      int v7 = 1;
    }
    else
    {
      if (*(_DWORD *)(a1 + 112) == 3) {
        goto LABEL_13;
      }
      int v7 = 0;
    }
    *(_DWORD *)(a1 + 112) = v7;
LABEL_13:
    if (v6)
    {
      CFRelease(v6);
      uint64_t v6 = 0;
    }
    goto LABEL_15;
  }

  return FigSignalErrorAt();
}

uint64_t fpm_timebaseRateChangedCallback()
{
  long long v0 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  long long v7 = *MEMORY[0x1E4F1FA20];
  long long v8 = v0;
  long long v9 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    uint64_t Owner = (__CFData *)FigRetainProxyGetOwner();
    MutableBytePtr = CFDataGetMutableBytePtr(Owner);
    MEMORY[0x19970E290](*((void *)MutableBytePtr + 6));
    if (CMTimebaseGetRate(*((CMTimebaseRef *)MutableBytePtr + 3)) != 0.0 && *((_DWORD *)MutableBytePtr + 26) == 3) {
      *((void *)MutableBytePtr + 13) = 0;
    }
    Float64 Rate = CMTimebaseGetRate(*((CMTimebaseRef *)MutableBytePtr + 3));
    uint64_t v4 = MutableBytePtr + 8553;
    if (Rate >= 0.0)
    {
      if (MutableBytePtr[8553])
      {
        *uint64_t v4 = 0;
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterRemoveWeakListener();
      }
    }
    else if (!MutableBytePtr[8553])
    {
      *uint64_t v4 = 1;
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterAddWeakListener();
    }
    fpm_durationAhead((uint64_t)MutableBytePtr, &v7);
    v6[0] = v7;
    v6[1] = v8;
    v6[2] = v9;
    fpm_updateStreamBufferDurationAhead((uint64_t)MutableBytePtr, (uint64_t)v6);
    MEMORY[0x19970E2B0](*((void *)MutableBytePtr + 6));
  }
  return FigRetainProxyUnlockMutex();
}

uint64_t fpm_streamCacheMissCallback()
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  memset(&v13, 0, sizeof(v13));
  memset(&v12, 0, sizeof(v12));
  memset(&v11, 0, sizeof(v11));
  memset(&v10, 0, sizeof(v10));
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    uint64_t Owner = (__CFData *)FigRetainProxyGetOwner();
    MutableBytePtr = CFDataGetMutableBytePtr(Owner);
    MEMORY[0x19970E290](*((void *)MutableBytePtr + 6));
    if (*((_DWORD *)MutableBytePtr + 26) != 3)
    {
      CMTimeMake(&v11, 2000, 1000);
      CMTimebaseGetTime(&time1, *((CMTimebaseRef *)MutableBytePtr + 3));
      CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      long long v7 = *(_OWORD *)&time2.value;
      CMTimeEpoch epoch = time2.epoch;
      CMTimeMaximum(&v13, &time1, &time2);
      CMTime time1 = v13;
      CMTime time2 = v11;
      CMTimeSubtract(&v9, &time1, &time2);
      *(_OWORD *)&time1.unsigned int value = v7;
      time1.CMTimeEpoch epoch = epoch;
      CMTimeMaximum(&v12, &time1, &v9);
      CMTime time1 = v12;
      if (!fpm_getPlayableDurationFromTime((uint64_t)MutableBytePtr, &time1, (uint64_t)&v10, 0, 0, 0))
      {
        CMTime time2 = v12;
        CMTime rhs = v10;
        CMTimeAdd(&time1, &time2, &rhs);
        CMTime v12 = time1;
        CMTime time2 = v13;
        if (CMTimeCompare(&time1, &time2) < 0)
        {
          *((void *)MutableBytePtr + 13) = 3;
          if (dword_1E9350B30)
          {
            LODWORD(rhs.CFDictionarySetValue(theDict, key, value) = 0;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int value = rhs.value;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT)) {
              unsigned int v5 = value;
            }
            else {
              unsigned int v5 = value & 0xFFFFFFFE;
            }
            if (v5)
            {
              LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136315394;
              *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_streamCacheMissCallback";
              LOWORD(time2.flags) = 2048;
              *(void *)((char *)&time2.flags + 2) = MutableBytePtr;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          FigRetainProxyRetain();
          CMNotificationCenterGetDefaultLocalCenter();
          FigDeferNotificationToDispatchQueue();
        }
      }
    }
    MEMORY[0x19970E2B0](*((void *)MutableBytePtr + 6));
  }
  return FigRetainProxyUnlockMutex();
}

uint64_t FigPlayabilityMonitorCanReuse(void *a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5)
{
  MEMORY[0x19970E290](a1[6]);
  if (a1[10] == a4 && a1[1] == a2 && a1[2] == a5)
  {
    if (a4 < 1)
    {
      uint64_t v10 = 1;
      goto LABEL_5;
    }
    CMTime v12 = (int *)a1[11];
    uint64_t v10 = 1;
    while (1)
    {
      int v14 = *v12;
      v12 += 12;
      int v13 = v14;
      int v15 = *a3++;
      if (v13 != v15) {
        break;
      }
      if (!--a4) {
        goto LABEL_5;
      }
    }
  }
  uint64_t v10 = 0;
LABEL_5:
  MEMORY[0x19970E2B0](a1[6]);
  return v10;
}

uint64_t FigPlayabilityMonitorSetRenderPipelines(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x19970E290](a1[6]);
  if (!a2)
  {
    a2 = a1[10];
    goto LABEL_5;
  }
  if (a1[10] == a2)
  {
LABEL_5:
    if (a2 < 1)
    {
LABEL_16:
      uint64_t v6 = 1;
      goto LABEL_17;
    }
    uint64_t v7 = 0;
    uint64_t v8 = 32;
    while (1)
    {
      uint64_t v9 = a1[11];
      uint64_t v10 = *(const void **)(v9 + v8);
      if (a3)
      {
        CMTime v11 = *(const void **)(a3 + 8 * v7);
        *(void *)(v9 + v8) = v11;
        if (v11) {
          CFRetain(v11);
        }
        if (!v10) {
          goto LABEL_12;
        }
      }
      else
      {
        *(void *)(v9 + v8) = 0;
        if (!v10) {
          goto LABEL_12;
        }
      }
      CFRelease(v10);
LABEL_12:
      ++v7;
      v8 += 48;
      if (v7 >= a1[10]) {
        goto LABEL_16;
      }
    }
  }
  uint64_t v6 = 0;
LABEL_17:
  MEMORY[0x19970E2B0](a1[6]);
  return v6;
}

uint64_t FigPlayabilityMonitorSetPlaybackTimebase(uint64_t a1, const void *a2)
{
  MEMORY[0x19970E290](*(void *)(a1 + 48));
  uint64_t v4 = *(const void **)(a1 + 24);
  if (v4 != a2)
  {
    if (v4)
    {
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      unsigned int v5 = *(NSObject **)(a1 + 304);
      if (v5) {
        CMTimebaseRemoveTimerDispatchSource(*(CMTimebaseRef *)(a1 + 24), v5);
      }
      uint64_t v6 = (OpaqueCMTimebase *)CFRetain(*(CFTypeRef *)(a1 + 24));
      MEMORY[0x19970E2B0](*(void *)(a1 + 48));
      CMTimebaseNotificationBarrier(v6);
      MEMORY[0x19970E290](*(void *)(a1 + 48));
      CFRelease(v6);
      if (*(int *)(a1 + 64) >= 1)
      {
        do
          FigConditionVariableWaitRelative();
        while (*(int *)(a1 + 64) > 0);
      }
      uint64_t v7 = *(const void **)(a1 + 24);
    }
    else
    {
      uint64_t v7 = 0;
    }
    *(void *)(a1 + 24) = a2;
    if (a2) {
      CFRetain(a2);
    }
    if (v7) {
      CFRelease(v7);
    }
    uint64_t v8 = *(OpaqueCMTimebase **)(a1 + 24);
    if (v8)
    {
      uint64_t v9 = *(NSObject **)(a1 + 304);
      if (v9) {
        CMTimebaseAddTimerDispatchSource(v8, v9);
      }
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterAddWeakListener();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterAddWeakListener();
    }
  }
  MEMORY[0x19970E2B0](*(void *)(a1 + 48));
  return 1;
}

uint64_t fpm_updateCacheAndNotify(uint64_t a1)
{
  uint64_t v163 = *MEMORY[0x1E4F143B8];
  long long v2 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  long long v137 = *MEMORY[0x1E4F1FA20];
  *(_OWORD *)CMTime v138 = v2;
  *(_OWORD *)&v138[16] = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
  CFMutableArrayRef v3 = (const void **)MEMORY[0x1E4F1CFC8];
  uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  *(unsigned char *)(a1 + 312) = 0;
  if (*(_DWORD *)(a1 + 96) == *(_DWORD *)(a1 + 184) && !*(unsigned char *)(a1 + 313))
  {
    fpm_durationAhead(a1, &v137);
    *(_OWORD *)CMTime time = *(_OWORD *)&v138[8];
    *(void *)&time[16] = *(void *)&v138[24];
    double Seconds = CMTimeGetSeconds((CMTime *)time);
    double v5 = Seconds;
    uint64_t updated = 0;
  }
  else
  {
    fpm_durationAhead(a1, &v137);
    *(_OWORD *)CMTime time = *(_OWORD *)&v138[8];
    *(void *)&time[16] = *(void *)&v138[24];
    double v5 = CMTimeGetSeconds((CMTime *)time);
    uint64_t updated = fpm_updateCache(a1);
    fpm_durationAhead(a1, &v137);
    *(_OWORD *)CMTime time = *(_OWORD *)&v138[8];
    *(void *)&time[16] = *(void *)&v138[24];
    double Seconds = CMTimeGetSeconds((CMTime *)time);
  }
  double v8 = Seconds;
  uint64_t v9 = *v3;
  if (v5 != Seconds) {
    *(unsigned char *)(a1 + 316) = 1;
  }
  if (v5 < Seconds && !*(unsigned char *)(a1 + 315))
  {
    *(unsigned char *)(a1 + 314) = 0;
    uint64_t v9 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  if (*(unsigned char *)(a1 + 316) && (*(unsigned char *)(a1 + 315) || UpTimeNanoseconds - *(void *)(a1 + 208) >= 500000000))
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable) {
      CFDictionarySetValue(Mutable, @"FPM_IsFilling", v9);
    }
    FigRetainProxyRetain();
    CMNotificationCenterGetDefaultLocalCenter();
    FigDeferNotificationToDispatchQueue();
    *(void *)(a1 + 208) = UpTimeNanoseconds;
    *(unsigned char *)(a1 + 316) = 0;
  }
  if (UpTimeNanoseconds - *(void *)(a1 + 200) > 449999999 || fpm_shouldUpdateAggressively(a1))
  {
    int v11 = *(unsigned __int8 *)(a1 + 314);
    switch(*(_DWORD *)(a1 + 112))
    {
      case 0:
        CMTime v148 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
        CFDictionaryRef theDict = 0;
        CFBooleanRef BOOLean = 0;
        double valuePtr = 0.0;
        *(double *)&CFNumberRef number = 0.0;
        double v142 = 0.0;
        double v143 = 0.0;
        if (FigFormatReaderUtilityGetDuration(*(void *)(a1 + 8), 1, &v148) || (v148.flags & 0x1D) != 1) {
          goto LABEL_264;
        }
        uint64_t v12 = *MEMORY[0x1E4F1CF80];
        uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
        uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v14) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = 0;
        }
        CMTime v26 = *(unsigned int (**)(uint64_t, void, uint64_t, CFBooleanRef *))(v15 + 48);
        if (v26 && !v26(CMBaseObject, *MEMORY[0x1E4F1EC58], v12, &BOOLean))
        {
          int Value = CFBooleanGetValue(BOOLean);
          CFRelease(BOOLean);
        }
        else
        {
          int Value = 0;
        }
        CMTimebaseGetTime((CMTime *)time, *(CMTimebaseRef *)(a1 + 24));
        CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
        CMTimeMaximum(&v141, (CMTime *)time, &time2);
        double v28 = CMTimeGetSeconds(&v141);
        *(CMTime *)CMTime time = v148;
        double v29 = CMTimeGetSeconds((CMTime *)time);
        double v30 = v29 - v28;
        double v31 = 0.0;
        if (v29 <= v28) {
          double v30 = 0.0;
        }
        if (v30 <= 900.0) {
          double v32 = v30;
        }
        else {
          double v32 = 900.0;
        }
        if (Value
          || v29 <= 0.0
          || ((v33 = CMByteStreamGetCMBaseObject(), (uint64_t v34 = *(void *)(CMBaseObjectGetVTable() + 8)) == 0)
            ? (uint64_t v35 = 0)
            : (uint64_t v35 = v34),
              (CFStringRef v66 = *(unsigned int (**)(uint64_t, void, uint64_t, CFNumberRef *))(v35 + 48)) == 0))
        {
          double v67 = 0.0;
        }
        else
        {
          double v67 = 0.0;
          if (!v66(v33, *MEMORY[0x1E4F1EC50], v12, &number))
          {
            CFNumberGetValue(number, kCFNumberFloat64Type, &valuePtr);
            CFRelease(number);
            double v31 = valuePtr / v29;
            double v67 = (v32 - v8) * (valuePtr / v29);
          }
        }
        uint64_t v68 = CMByteStreamGetCMBaseObject();
        uint64_t v69 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v69) {
          uint64_t v70 = v69;
        }
        else {
          uint64_t v70 = 0;
        }
        CMTimeFlags v71 = *(unsigned int (**)(uint64_t, void, uint64_t, CFDictionaryRef *))(v70 + 48);
        if (v71 && !v71(v68, *MEMORY[0x1E4F1EC70], v12, &theDict))
        {
          FigCFDictionaryGetDoubleIfPresent();
          int DoubleIfPresent = FigCFDictionaryGetDoubleIfPresent();
          BOOL v88 = v142 > 0.0 && DoubleIfPresent != 0;
          *(unsigned char *)(a1 + 8555) = v88;
          CMTimeScale v89 = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F1FB80]);
          if (v89) {
            CFTypeRef v53 = CFRetain(v89);
          }
          else {
            CFTypeRef v53 = 0;
          }
          CFRelease(theDict);
        }
        else
        {
          CFTypeRef v53 = 0;
        }
        if ((v148.flags & 0x1D) != 1) {
          goto LABEL_242;
        }
        if (v67 < 1.0 || (double v72 = v32 * v142, v32 * v142 >= v67 + v67))
        {
          if (*(_DWORD *)(a1 + 104) == 1) {
            goto LABEL_242;
          }
          if (v8 < 10.0 && v32 > 10.0)
          {
            float v74 = v8 / 10.0;
            *(float *)(a1 + 108) = v74;
            goto LABEL_242;
          }
          fpm_createDurationDictionary(v8);
          *(void *)(a1 + 104) = 0x3F80000000000001;
          if (dword_1E9350B30)
          {
            unsigned int v140 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v98 = v140;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
              unsigned int v99 = v98;
            }
            else {
              unsigned int v99 = v98 & 0xFFFFFFFE;
            }
            if (v99)
            {
              float v100 = *(float *)(a1 + 108);
              LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316418;
              *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingLegacyAlgorithm";
              LOWORD(time2.flags) = 2048;
              *(void *)((char *)&time2.flags + 2) = a1;
              HIWORD(time2.epoch) = 2048;
              double v150 = v142 * 8.0 / 1000.0;
              __int16 v151 = 2048;
              double v152 = v67 / 1000.0;
              __int16 v153 = 2048;
              double v154 = v32;
              __int16 v155 = 2048;
              double v156 = v100;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
        }
        else
        {
          if (!*(unsigned char *)(a1 + 8555))
          {
            fpm_likelyToKeepUpUsingLivePlaybackAlgorithm(a1, v11, v8);
            goto LABEL_242;
          }
          int v73 = *(_DWORD *)(a1 + 104);
          if (v73 == 1)
          {
            if (v72 >= v67)
            {
LABEL_242:
              if (v11)
              {
                if (*(_DWORD *)(a1 + 104) != 1)
                {
                  *(void *)(a1 + 104) = 2;
                  int v128 = *(_DWORD *)(a1 + 96);
                  if (*(_DWORD *)(a1 + 100) != v128)
                  {
                    *(_DWORD *)(a1 + 100) = v128;
                    if (dword_1E9350B30)
                    {
                      unsigned int v140 = 0;
                      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                      CMItemCount v129 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                      unsigned int v130 = v140;
                      if (os_log_type_enabled(v129, type)) {
                        unsigned int v131 = v130;
                      }
                      else {
                        unsigned int v131 = v130 & 0xFFFFFFFE;
                      }
                      if (v131)
                      {
                        float v132 = *(float *)(a1 + 108);
                        LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316418;
                        *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingLegacyAlgorithm";
                        LOWORD(time2.flags) = 2048;
                        *(void *)((char *)&time2.flags + 2) = a1;
                        HIWORD(time2.epoch) = 2048;
                        double v150 = v142 * 8.0 / 1000.0;
                        __int16 v151 = 2048;
                        double v152 = v67 / 1000.0;
                        __int16 v153 = 2048;
                        double v154 = v32;
                        __int16 v155 = 2048;
                        double v156 = v132;
                        _os_log_send_and_compose_impl();
                      }
                      fig_log_call_emit_and_clean_up_after_send_and_compose();
                    }
                    FigRetainProxyRetain();
                    CMNotificationCenterGetDefaultLocalCenter();
                    FigDeferNotificationToDispatchQueue();
                  }
                }
              }
              MEMORY[0x19970E290](*(void *)(a1 + 8632));
              *(double *)(a1 + 8576) = v67;
              *(double *)(a1 + 8584) = v32;
              double v133 = v142;
              double v134 = v143;
              *(double *)(a1 + 8592) = v142;
              *(double *)(a1 + 8600) = v134;
              *(void *)(a1 + 8608) = 0x4000000000000000;
              double v119 = (v67 + v67) / v133 - v32;
              goto LABEL_254;
            }
          }
          else
          {
            float v114 = v8 / (v32 * (1.0 - v142 / (v31 + v31)));
            *(float *)(a1 + 108) = v114;
            if (v72 >= v67 || v73 == 2) {
              goto LABEL_242;
            }
          }
          *(_DWORD *)(a1 + 104) = 2;
          if (dword_1E9350B30)
          {
            unsigned int v140 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            __int16 v115 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v116 = v140;
            if (os_log_type_enabled(v115, type)) {
              unsigned int v117 = v116;
            }
            else {
              unsigned int v117 = v116 & 0xFFFFFFFE;
            }
            if (v117)
            {
              float v118 = *(float *)(a1 + 108);
              LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316418;
              *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingLegacyAlgorithm";
              LOWORD(time2.flags) = 2048;
              *(void *)((char *)&time2.flags + 2) = a1;
              HIWORD(time2.epoch) = 2048;
              double v150 = v142 * 8.0 / 1000.0;
              __int16 v151 = 2048;
              double v152 = v67 / 1000.0;
              __int16 v153 = 2048;
              double v154 = v32;
              __int16 v155 = 2048;
              double v156 = v118;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
        }
        FigRetainProxyRetain();
        CMNotificationCenterGetDefaultLocalCenter();
        FigDeferNotificationToDispatchQueue();
        goto LABEL_242;
      case 1:
        CMTime v148 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
        CFDictionaryRef theDict = 0;
        CFBooleanRef BOOLean = 0;
        double valuePtr = 0.0;
        *(double *)&CFNumberRef number = 0.0;
        double v142 = 0.0;
        double v143 = 0.0;
        double v16 = *(double *)(a1 + 144);
        float v17 = *(float *)(a1 + 116);
        if (FigFormatReaderUtilityGetDuration(*(void *)(a1 + 8), 1, &v148) || (v148.flags & 0x1D) != 1) {
          goto LABEL_264;
        }
        uint64_t v18 = *MEMORY[0x1E4F1CF80];
        uint64_t v19 = CMByteStreamGetCMBaseObject();
        uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v20) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = 0;
        }
        CFTypeRef v36 = *(unsigned int (**)(uint64_t, void, uint64_t, CFBooleanRef *))(v21 + 48);
        if (v36 && !v36(v19, *MEMORY[0x1E4F1EC58], v18, &BOOLean))
        {
          int v37 = CFBooleanGetValue(BOOLean);
          CFRelease(BOOLean);
        }
        else
        {
          int v37 = 0;
        }
        *(CMTime *)CMTime time = v148;
        double v38 = CMTimeGetSeconds((CMTime *)time);
        CMTimebaseGetTime((CMTime *)time, *(CMTimebaseRef *)(a1 + 24));
        CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
        CMTimeMaximum(&v141, (CMTime *)time, &time2);
        double v39 = CMTimeGetSeconds(&v141);
        if (v38 <= v39) {
          double v40 = 0.0;
        }
        else {
          double v40 = v38 - v39;
        }
        uint64_t v41 = CMByteStreamGetCMBaseObject();
        uint64_t v42 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v42) {
          uint64_t v43 = v42;
        }
        else {
          uint64_t v43 = 0;
        }
        int v52 = *(unsigned int (**)(uint64_t, void, uint64_t, CFNumberRef *))(v43 + 48);
        if (v52 && !v52(v41, *MEMORY[0x1E4F1EC70], v18, &number))
        {
          FigCFDictionaryGetDoubleIfPresent();
          FigCFDictionaryGetDoubleIfPresent();
          long long v84 = CFDictionaryGetValue(number, (const void *)*MEMORY[0x1E4F1FB80]);
          if (v84) {
            CFTypeRef v53 = CFRetain(v84);
          }
          else {
            CFTypeRef v53 = 0;
          }
          CFRelease(number);
        }
        else
        {
          CFTypeRef v53 = 0;
        }
        uint64_t v54 = 0;
        double v55 = 0.0;
        if (v37 || v38 <= 0.0) {
          goto LABEL_114;
        }
        uint64_t v56 = CMByteStreamGetCMBaseObject();
        uint64_t v57 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v57) {
          uint64_t v58 = v57;
        }
        else {
          uint64_t v58 = 0;
        }
        CFIndex v75 = *(unsigned int (**)(uint64_t, void, uint64_t, CFDictionaryRef *))(v58 + 48);
        if (v75 && !v75(v56, *MEMORY[0x1E4F1EC50], v18, &theDict))
        {
          CFNumberGetValue(theDict, kCFNumberFloat64Type, &valuePtr);
          CFRelease(theDict);
          uint64_t v54 = 0;
          double v55 = valuePtr / v38;
          double v106 = v40 - v8;
          if (v40 - v8 < 0.0) {
            double v106 = 0.0;
          }
          double v76 = v106 * v55;
          if (v142 > 0.0 && v55 > 0.0)
          {
            double v107 = v142 / v55;
            if (v142 / v55 >= *(float *)(a1 + 124))
            {
              if (v107 <= *(float *)(a1 + 128))
              {
                if (*(_DWORD *)(a1 + 104) != 1)
                {
                  double v16 = *(double *)(a1 + 136);
                  double v76 = 0.0;
                }
                uint64_t v54 = 2;
              }
              else if (v107 <= *(float *)(a1 + 132))
              {
                if (v107 <= *(float *)(a1 + 128))
                {
                  uint64_t v54 = 0;
                }
                else
                {
                  if (*(_DWORD *)(a1 + 104) != 1)
                  {
                    double v16 = *(double *)(a1 + 144);
                    double v76 = 0.0;
                  }
                  uint64_t v54 = 3;
                }
              }
              else
              {
                if (*(_DWORD *)(a1 + 104) != 1)
                {
                  double v16 = *(double *)(a1 + 152);
                  double v76 = 0.0;
                }
                uint64_t v54 = 4;
              }
            }
            else
            {
              if (v38 > 300.0) {
                float v17 = *(float *)(a1 + 120);
              }
              uint64_t v54 = 1;
            }
          }
        }
        else
        {
          uint64_t v54 = 0;
LABEL_114:
          double v76 = 0.0;
        }
        if ((v148.flags & 0x1D) != 1) {
          goto LABEL_228;
        }
        if (v76 < 1.0 || (double v77 = v40 * v142, v40 * v142 >= v76 * v17))
        {
          if (*(_DWORD *)(a1 + 104) == 1) {
            goto LABEL_228;
          }
          if (v16 >= v40) {
            double v79 = v40;
          }
          else {
            double v79 = v16;
          }
          if (v79 > v8)
          {
            float v80 = v8 / v79;
            *(float *)(a1 + 108) = v80;
            goto LABEL_228;
          }
          fpm_createDurationDictionary(v8);
          *(void *)(a1 + 104) = 0x3F80000000000001;
          if (dword_1E9350B30)
          {
            unsigned int v140 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            BOOL v101 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v102 = v140;
            if (os_log_type_enabled(v101, type)) {
              unsigned int v103 = v102;
            }
            else {
              unsigned int v103 = v102 & 0xFFFFFFFE;
            }
            if (v103)
            {
              int v104 = fpm_likelyToKeepUpUsingBucketAlgorithm_bandwidthType[v54];
              LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316930;
              float v105 = *(float *)(a1 + 108);
              *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingBucketAlgorithm";
              LOWORD(time2.flags) = 2048;
              *(void *)((char *)&time2.flags + 2) = a1;
              HIWORD(time2.epoch) = 2082;
              double v150 = *(double *)&v104;
              __int16 v151 = 2048;
              double v152 = v142 * 8.0 / 1000.0;
              __int16 v153 = 2048;
              double v154 = v76 / 1000.0;
              __int16 v155 = 2048;
              double v156 = v40 * (v142 / 1000.0);
              __int16 v157 = 2048;
              double v158 = v40;
              __int16 v159 = 2048;
              double v160 = v105;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          goto LABEL_227;
        }
        int v78 = *(_DWORD *)(a1 + 104);
        if (v78 == 1)
        {
          if (v77 >= v76) {
            goto LABEL_228;
          }
          goto LABEL_189;
        }
        float v108 = v8 / (v40 * (1.0 - v142 / (v55 * v17)));
        *(float *)(a1 + 108) = v108;
        if (v77 < v76 && v78 != 2)
        {
LABEL_189:
          *(void *)(a1 + 104) = 2;
          if (dword_1E9350B30)
          {
            unsigned int v140 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            __int16 v109 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v110 = v140;
            if (os_log_type_enabled(v109, type)) {
              unsigned int v111 = v110;
            }
            else {
              unsigned int v111 = v110 & 0xFFFFFFFE;
            }
            if (v111)
            {
              CFTypeRef v112 = fpm_likelyToKeepUpUsingBucketAlgorithm_bandwidthType[v54];
              LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316930;
              float v113 = *(float *)(a1 + 108);
              *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingBucketAlgorithm";
              LOWORD(time2.flags) = 2048;
              *(void *)((char *)&time2.flags + 2) = a1;
              HIWORD(time2.epoch) = 2082;
              double v150 = *(double *)&v112;
              __int16 v151 = 2048;
              double v152 = v142 * 8.0 / 1000.0;
              __int16 v153 = 2048;
              double v154 = v76 / 1000.0;
              __int16 v155 = 2048;
              double v156 = v40 * (v142 / 1000.0);
              __int16 v157 = 2048;
              double v158 = v40;
              __int16 v159 = 2048;
              double v160 = v113;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
LABEL_227:
          FigRetainProxyRetain();
          CMNotificationCenterGetDefaultLocalCenter();
          FigDeferNotificationToDispatchQueue();
        }
LABEL_228:
        if (v11)
        {
          if (*(_DWORD *)(a1 + 104) != 1)
          {
            *(void *)(a1 + 104) = 2;
            int v120 = *(_DWORD *)(a1 + 96);
            if (*(_DWORD *)(a1 + 100) != v120)
            {
              *(_DWORD *)(a1 + 100) = v120;
              if (dword_1E9350B30)
              {
                unsigned int v140 = 0;
                os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                long long v121 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                unsigned int v122 = v140;
                if (os_log_type_enabled(v121, type)) {
                  unsigned int v123 = v122;
                }
                else {
                  unsigned int v123 = v122 & 0xFFFFFFFE;
                }
                if (v123)
                {
                  v124 = fpm_likelyToKeepUpUsingBucketAlgorithm_bandwidthType[v54];
                  LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316930;
                  float v125 = *(float *)(a1 + 108);
                  *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingBucketAlgorithm";
                  LOWORD(time2.flags) = 2048;
                  *(void *)((char *)&time2.flags + 2) = a1;
                  HIWORD(time2.epoch) = 2082;
                  double v150 = *(double *)&v124;
                  __int16 v151 = 2048;
                  double v152 = v142 * 8.0 / 1000.0;
                  __int16 v153 = 2048;
                  double v154 = v76 / 1000.0;
                  __int16 v155 = 2048;
                  double v156 = v40 * (v142 / 1000.0);
                  __int16 v157 = 2048;
                  double v158 = v40;
                  __int16 v159 = 2048;
                  double v160 = v125;
                  _os_log_send_and_compose_impl();
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose();
              }
              FigRetainProxyRetain();
              CMNotificationCenterGetDefaultLocalCenter();
              FigDeferNotificationToDispatchQueue();
            }
          }
        }
        MEMORY[0x19970E290](*(void *)(a1 + 8632));
        *(double *)(a1 + 8576) = v76;
        *(double *)(a1 + 8584) = v40;
        double v126 = v142;
        double v127 = v143;
        *(double *)(a1 + 8592) = v142;
        *(double *)(a1 + 8600) = v127;
        *(double *)(a1 + 8608) = v17;
        double v119 = v76 * v17 / v126 - v40;
LABEL_254:
        if (v119 < 0.0) {
          double v119 = 0.0;
        }
        *(double *)(a1 + 8616) = v119;
        CFTypeRef v135 = *(CFTypeRef *)(a1 + 8624);
        if (v135 != v53)
        {
          *(void *)(a1 + 8624) = v53;
          if (v53) {
            CFRetain(v53);
          }
          if (v135) {
            CFRelease(v135);
          }
        }
        if (v53) {
          CFRelease(v53);
        }
        MEMORY[0x19970E2B0](*(void *)(a1 + 8632));
LABEL_264:
        *(void *)(a1 + 200) = UpTimeNanoseconds;
        break;
      case 2:
        CMTime v148 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
        CFDictionaryRef theDict = 0;
        CFBooleanRef BOOLean = 0;
        double valuePtr = 0.0;
        *(double *)&CFNumberRef number = 0.0;
        double v142 = 0.0;
        double v143 = 0.0;
        if (FigFormatReaderUtilityGetDuration(*(void *)(a1 + 8), 1, &v148) || (v148.flags & 0x1D) != 1) {
          goto LABEL_264;
        }
        uint64_t v22 = *MEMORY[0x1E4F1CF80];
        uint64_t v23 = CMByteStreamGetCMBaseObject();
        uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v24) {
          uint64_t v25 = v24;
        }
        else {
          uint64_t v25 = 0;
        }
        uint64_t v44 = *(unsigned int (**)(uint64_t, void, uint64_t, CFBooleanRef *))(v25 + 48);
        if (v44 && !v44(v23, *MEMORY[0x1E4F1EC58], v22, &BOOLean))
        {
          int v45 = CFBooleanGetValue(BOOLean);
          CFRelease(BOOLean);
        }
        else
        {
          int v45 = 0;
        }
        CMTimebaseGetTime((CMTime *)time, *(CMTimebaseRef *)(a1 + 24));
        CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
        CMTimeMaximum(&v141, (CMTime *)time, &time2);
        double v46 = CMTimeGetSeconds(&v141);
        *(CMTime *)CMTime time = v148;
        double v47 = CMTimeGetSeconds((CMTime *)time);
        if (v47 <= v46) {
          double v48 = 0.0;
        }
        else {
          double v48 = v47 - v46;
        }
        uint64_t v49 = CMByteStreamGetCMBaseObject();
        uint64_t v50 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v50) {
          uint64_t v51 = v50;
        }
        else {
          uint64_t v51 = 0;
        }
        uint64_t v59 = *(unsigned int (**)(uint64_t, void, uint64_t, CFDictionaryRef *))(v51 + 48);
        float v60 = 1.0;
        if (v59 && !v59(v49, *MEMORY[0x1E4F1EC70], v22, &theDict))
        {
          FigCFDictionaryGetDoubleIfPresent();
          FigCFDictionaryGetDoubleIfPresent();
          FigCFDictionaryGetDoubleIfPresent();
          uint64_t v85 = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F1FB80]);
          if (v85) {
            CFTypeRef v53 = CFRetain(v85);
          }
          else {
            CFTypeRef v53 = 0;
          }
          if (*(double *)&number != 0.0) {
            float v60 = v143 / *(double *)&number + 1.0;
          }
          int v61 = v11;
          CFRelease(theDict);
        }
        else
        {
          int v61 = v11;
          CFTypeRef v53 = 0;
        }
        if (v45
          || v48 - v8 <= 0.1
          || (valuePtr <= 0.0 ? (CFNumberRef v62 = number) : COERCE_CFNUMBERREF(*(double *)&CFNumberRef v62 = valuePtr),
              fpm_isLikelyToKeepUp(a1, &v142, v46, v8, *(double *)&v62, v60)))
        {
          if (*(_DWORD *)(a1 + 104) == 1) {
            goto LABEL_151;
          }
          fpm_createDurationDictionary(v8);
          *(void *)(a1 + 104) = 0x3F80000000000001;
          if (dword_1E9350B30)
          {
            unsigned int v140 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            uint64_t v63 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v64 = v140;
            if (os_log_type_enabled(v63, type)) {
              unsigned int v65 = v64;
            }
            else {
              unsigned int v65 = v64 & 0xFFFFFFFE;
            }
            if (v65)
            {
              LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136315906;
              *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingDynamicAlgorithm";
              LOWORD(time2.flags) = 2048;
              *(void *)((char *)&time2.flags + 2) = a1;
              HIWORD(time2.epoch) = 2048;
              double v150 = valuePtr * 8.0 / 1000.0;
              __int16 v151 = 2048;
              double v152 = v48;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
        }
        else
        {
          if (*(_DWORD *)(a1 + 104) == 2) {
            goto LABEL_151;
          }
          *(void *)(a1 + 104) = 2;
          if (dword_1E9350B30)
          {
            unsigned int v140 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            CMTime v81 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v82 = v140;
            if (os_log_type_enabled(v81, type)) {
              unsigned int v83 = v82;
            }
            else {
              unsigned int v83 = v82 & 0xFFFFFFFE;
            }
            if (v83)
            {
              LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316162;
              *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingDynamicAlgorithm";
              LOWORD(time2.flags) = 2048;
              *(void *)((char *)&time2.flags + 2) = a1;
              HIWORD(time2.epoch) = 2048;
              double v150 = valuePtr * 8.0 / 1000.0;
              __int16 v151 = 2048;
              double v152 = v48;
              __int16 v153 = 2048;
              double v154 = v142;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
        }
        FigRetainProxyRetain();
        CMNotificationCenterGetDefaultLocalCenter();
        FigDeferNotificationToDispatchQueue();
LABEL_151:
        if (dword_1E9350B30)
        {
          unsigned int v140 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          CMTimeValue v90 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v91 = v140;
          if (os_log_type_enabled(v90, type)) {
            unsigned int v92 = v91;
          }
          else {
            unsigned int v92 = v91 & 0xFFFFFFFE;
          }
          if (v92)
          {
            LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316930;
            *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingDynamicAlgorithm";
            LOWORD(time2.flags) = 2048;
            *(void *)((char *)&time2.flags + 2) = a1;
            HIWORD(time2.epoch) = 2048;
            double v150 = *(double *)&number * 8.0 / 1000.0;
            __int16 v151 = 2048;
            double v152 = valuePtr * 8.0 / 1000.0;
            __int16 v153 = 2048;
            double v154 = v60;
            __int16 v155 = 2048;
            double v156 = v47 - v48;
            __int16 v157 = 2048;
            double v158 = v8;
            __int16 v159 = 2048;
            double v160 = v142;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        uint64_t updated = updated;
        if (v61)
        {
          if (*(_DWORD *)(a1 + 104) != 1)
          {
            *(void *)(a1 + 104) = 2;
            int v93 = *(_DWORD *)(a1 + 96);
            if (*(_DWORD *)(a1 + 100) != v93)
            {
              *(_DWORD *)(a1 + 100) = v93;
              if (dword_1E9350B30)
              {
                unsigned int v140 = 0;
                os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                CMTimeValue v94 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                unsigned int v95 = v140;
                if (os_log_type_enabled(v94, type)) {
                  unsigned int v96 = v95;
                }
                else {
                  unsigned int v96 = v95 & 0xFFFFFFFE;
                }
                if (v96)
                {
                  LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316162;
                  *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingDynamicAlgorithm";
                  LOWORD(time2.flags) = 2048;
                  *(void *)((char *)&time2.flags + 2) = a1;
                  HIWORD(time2.epoch) = 2048;
                  double v150 = valuePtr * 8.0 / 1000.0;
                  __int16 v151 = 2048;
                  double v152 = v48;
                  __int16 v153 = 2048;
                  double v154 = v142;
                  _os_log_send_and_compose_impl();
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose();
              }
              FigRetainProxyRetain();
              CMNotificationCenterGetDefaultLocalCenter();
              FigDeferNotificationToDispatchQueue();
            }
          }
        }
        MEMORY[0x19970E290](*(void *)(a1 + 8632));
        *(double *)(a1 + 8584) = v48;
        *(double *)(a1 + 8592) = valuePtr;
        *(double *)(a1 + 8600) = *(double *)&number;
        *(double *)(a1 + 8608) = v60;
        double v119 = v142;
        goto LABEL_254;
      case 3:
        fpm_likelyToKeepUpUsingLivePlaybackAlgorithm(a1, *(unsigned __int8 *)(a1 + 314), v8);
        goto LABEL_264;
      default:
        goto LABEL_264;
    }
  }
  *(_OWORD *)CMTime time = v137;
  *(_OWORD *)&time[16] = *(_OWORD *)v138;
  long long v162 = *(_OWORD *)&v138[16];
  fpm_updateStreamBufferDurationAhead(a1, (uint64_t)time);
  *(unsigned char *)(a1 + 315) = 0;
  return updated;
}

uint64_t FigPlayabilityMonitorGetPlaythroughInfo(uint64_t a1, _DWORD *a2, BOOL *a3, _DWORD *a4)
{
  if (a2) {
    *a2 = *(_DWORD *)(a1 + 104);
  }
  if (a3) {
    *a3 = *(unsigned char *)(a1 + 314) == 0;
  }
  if (a4) {
    *a4 = *(_DWORD *)(a1 + 108);
  }
  MEMORY[0x19970E2B0](*(void *)(a1 + 48));
  return 0;
}

uint64_t FigPlayabilityMonitorGetProgressToPlayThrough(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 108);
  return 0;
}

uint64_t FigPlayabilityMonitorGetPlayabilityMetrics(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  *a2 = a1[1072];
  *a3 = a1[1073];
  *a4 = a1[1074];
  *a5 = a1[1075];
  *a6 = a1[1076];
  *a7 = a1[1077];
  MEMORY[0x19970E2B0](a1[1079]);
  return 0;
}

uint64_t FigPlayabilityMonitorCopyRemoteIPAddress(uint64_t a1, void *a2)
{
  MEMORY[0x19970E290](*(void *)(a1 + 8632));
  CFTypeRef v4 = *(CFTypeRef *)(a1 + 8624);
  if (v4) {
    CFTypeRef v4 = CFRetain(v4);
  }
  *a2 = v4;
  MEMORY[0x19970E2B0](*(void *)(a1 + 8632));
  return 0;
}

void fpm_postDeferredNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    uint64_t Owner = (__CFData *)FigRetainProxyGetOwner();
    CFDataGetMutableBytePtr(Owner);
    CMNotificationCenterPostNotification();
  }
  FigRetainProxyUnlockMutex();
  FigRetainProxyRelease();
  if (a5)
  {
    CFRelease(a5);
  }
}

uint64_t fpm_getPlayableDurationFromTime(uint64_t a1, CMTime *a2, uint64_t a3, char *a4, CMTimeValue *a5, CMTimeValue *a6)
{
  uint64_t v6 = a6;
  uint64_t v7 = a5;
  double v8 = a4;
  uint64_t v9 = a3;
  uint64_t v10 = a2;
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  CMTimeScale timescale = 0;
  CMTimeValue value = 0;
  CMTimeScale v124 = 0;
  CMTimeValue v123 = 0;
  memset(&v111, 0, sizeof(v111));
  CMTimeValue v121 = *MEMORY[0x1E4F1F9F0];
  CMTimeFlags v11 = *(_DWORD *)(MEMORY[0x1E4F1F9F0] + 12);
  CMTimeScale v122 = *(_DWORD *)(MEMORY[0x1E4F1F9F0] + 8);
  CMTimeEpoch v12 = *(void *)(MEMORY[0x1E4F1F9F0] + 16);
  int v13 = (_OWORD *)MEMORY[0x1E4F1FA48];
  CMTimeValue v14 = *MEMORY[0x1E4F1FA48];
  CMTimeValue v119 = *MEMORY[0x1E4F1FA48];
  CMTimeScale v15 = *(_DWORD *)(MEMORY[0x1E4F1FA48] + 8);
  CMTimeFlags v16 = *(_DWORD *)(MEMORY[0x1E4F1FA48] + 12);
  CMTimeScale v120 = v15;
  CMTimeEpoch v17 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  __int16 v110 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v108 = 0;
  memset(v107, 0, sizeof(v107));
  *(_OWORD *)newTimescale = 0u;
  memset(v105, 0, sizeof(v105));
  CMTimeValue v103 = 0;
  CFDictionaryRef dictionaryRepresentation = 0;
  uint64_t v101 = 0;
  CMTimeValue v102 = 0;
  uint64_t v18 = *(void *)(a1 + 80);
  if (v18 < 1)
  {
    CMTimeValue v69 = 0;
    CMTimeValue v87 = 0x7FFFFFFFFFFFFFFFLL;
    CMTimeEpoch v88 = v17;
    CMTimeFlags v89 = v16;
    char v83 = 1;
    CMTimeEpoch v70 = v12;
    if (!v18) {
      goto LABEL_93;
    }
    goto LABEL_94;
  }
  CMTimeScale v74 = v15;
  CMTimeValue v75 = v14;
  CMTimeFlags v81 = v11;
  CMTimeValue v84 = 0;
  uint64_t v20 = 0;
  uint64_t v86 = *MEMORY[0x1E4F1CF80];
  CMTimeValue v87 = 0x7FFFFFFFFFFFFFFFLL;
  CMTimeEpoch v88 = v17;
  char v83 = 1;
  CMTimeEpoch v85 = v12;
  CMTimeEpoch v21 = v12;
  CMTimeEpoch v76 = v17;
  CMTimeFlags v73 = v16;
  CMTimeFlags v89 = v16;
  do
  {
    uint64_t v22 = *(const void **)(*(void *)(a1 + 88) + 48 * v20 + 32);
    CMTimeEpoch v90 = v21;
    if (v22) {
      CFTypeRef v23 = CFRetain(v22);
    }
    else {
      CFTypeRef v23 = 0;
    }
    CMTimeValue value = v10->value;
    CMTimeFlags flags = v10->flags;
    CMTimeScale timescale = v10->timescale;
    CMTimeEpoch epoch = v10->epoch;
    ++*(_DWORD *)(a1 + 64);
    MEMORY[0x19970E2B0](*(void *)(a1 + 48));
    if (v23)
    {
      uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v23);
      uint64_t v27 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v28 = v27 ? v27 : 0;
      double v29 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CFDictionaryRef *))(v28 + 48);
      if (v29)
      {
        if (!v29(FigBaseObject, @"EndPresentationTimeForQueuedSamples", v86, &dictionaryRepresentation))
        {
          CMTimeMakeFromDictionary(&time1, dictionaryRepresentation);
          CMTimeValue v123 = time1.value;
          CMTimeFlags v30 = time1.flags;
          CMTimeScale v124 = time1.timescale;
          CMTimeEpoch v31 = time1.epoch;
          if (dictionaryRepresentation) {
            CFRelease(dictionaryRepresentation);
          }
          if (v30)
          {
            time1.CMTimeValue value = value;
            time1.CMTimeScale timescale = timescale;
            time1.CMTimeFlags flags = flags;
            time1.CMTimeEpoch epoch = epoch;
            time2.CMTimeValue value = v123;
            time2.CMTimeScale timescale = v124;
            time2.CMTimeFlags flags = v30;
            time2.CMTimeEpoch epoch = v31;
            if (CMTimeCompare(&time1, &time2) < 0)
            {
              CMTimeValue value = v123;
              CMTimeScale timescale = v124;
              CMTimeFlags flags = v30;
              CMTimeEpoch epoch = v31;
            }
          }
        }
      }
    }
    MEMORY[0x19970E290](*(void *)(a1 + 48));
    int v32 = *(_DWORD *)(a1 + 64) - 1;
    *(_DWORD *)(a1 + 64) = v32;
    if (v32)
    {
      if (!v23) {
        goto LABEL_20;
      }
LABEL_19:
      CFRelease(v23);
      goto LABEL_20;
    }
    MEMORY[0x19970CC00](*(void *)(a1 + 72));
    if (v23) {
      goto LABEL_19;
    }
LABEL_20:
    uint64_t v33 = *(void *)(*(void *)(a1 + 88) + 48 * v20 + 8);
    uint64_t v34 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v34) {
      uint64_t v35 = v34;
    }
    else {
      uint64_t v35 = 0;
    }
    CFTypeRef v36 = *(void (**)(uint64_t, char *, uint64_t *))(v35 + 8);
    if (v36) {
      v36(v33, (char *)&v101 + 4, &v101);
    }
    uint64_t v37 = FigTrackReaderGetFigBaseObject(*(void *)(*(void *)(a1 + 88) + 48 * v20 + 8));
    uint64_t v38 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v38) {
      uint64_t v39 = v38;
    }
    else {
      uint64_t v39 = 0;
    }
    double v40 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v39 + 48);
    if (v40) {
      v40(v37, @"EditCursorService", v86, &cf);
    }
    CFTypeRef v41 = cf;
    if (cf)
    {
      uint64_t v42 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v43 = v42 ? v42 : 0;
      uint64_t v44 = *(void (**)(CFTypeRef, CMTime *, CFTypeRef *))(v43 + 8);
      if (v44)
      {
        CMTime time1 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA08];
        v44(v41, &time1, &v108);
      }
    }
    if (v108)
    {
      CMTimeValue v115 = value;
      CMTimeScale v116 = timescale;
      int v114 = 0;
      uint64_t v113 = 0;
      memset(&time1, 0, sizeof(time1));
      memset(&time2, 0, sizeof(time2));
      long long v45 = *MEMORY[0x1E4F1F9F0];
      v111.CMTimeEpoch epoch = v85;
      *(_OWORD *)&v111.CMTimeValue value = v45;
      HIBYTE(v110) = 1;
      while (1)
      {
        CFTypeRef v46 = v108;
        uint64_t v47 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v47) {
          uint64_t v48 = v47;
        }
        else {
          uint64_t v48 = 0;
        }
        uint64_t v49 = *(uint64_t (**)(CFTypeRef, CMTime *))(v48 + 24);
        if (!v49)
        {
          uint64_t v68 = 4294954514;
          goto LABEL_106;
        }
        uint64_t PlayableDurationForTrack = v49(v46, v105);
        if (PlayableDurationForTrack) {
          goto LABEL_113;
        }
        *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)newTimescale;
        lhs.CMTimeEpoch epoch = *(void *)&v107[0];
        CMTime rhs = *(CMTime *)((char *)v107 + 8);
        CMTimeAdd(&time, &lhs, &rhs);
        CMTimeValue v51 = time.value;
        int32_t v52 = time.timescale;
        uint64_t v117 = *(void *)&time.flags;
        int epoch_high = HIDWORD(time.epoch);
        time.CMTimeValue value = v115;
        time.CMTimeScale timescale = v116;
        time.CMTimeFlags flags = flags;
        time.CMTimeEpoch epoch = epoch;
        CMTimeConvertScale(&v96, &time, newTimescale[2], kCMTimeRoundingMethod_RoundHalfAwayFromZero);
        *(_OWORD *)&time.CMTimeValue value = *(_OWORD *)newTimescale;
        time.CMTimeEpoch epoch = *(void *)&v107[0];
        if (CMTimeCompare(&time, &v96) <= 0)
        {
          time.CMTimeValue value = v115;
          time.CMTimeScale timescale = v116;
          time.CMTimeFlags flags = flags;
          time.CMTimeEpoch epoch = epoch;
          CMTimeConvertScale(&v95, &time, v52, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
          time.CMTimeValue value = v51;
          time.CMTimeScale timescale = v52;
          *(void *)&time.CMTimeFlags flags = v117;
          HIDWORD(time.epoch) = epoch_high;
          if (CMTimeCompare(&v95, &time) < 0) {
            break;
          }
        }
LABEL_61:
        CFTypeRef v59 = v108;
        uint64_t v60 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v60) {
          uint64_t v61 = v60;
        }
        else {
          uint64_t v61 = 0;
        }
        CFNumberRef v62 = *(unsigned int (**)(CFTypeRef, uint64_t))(v61 + 16);
        if (!v62 || v62(v59, 1)) {
          goto LABEL_72;
        }
      }
      if (v105[0].flags)
      {
        CMTime time = v105[1];
        CMTime lhs = *(CMTime *)((char *)v107 + 8);
        if (CMTimeCompare(&time, &lhs)) {
          double v55 = (double)v105[1].value
        }
              / (double)v105[1].timescale
              * (double)SLODWORD(v107[1])
              / (double)*((uint64_t *)&v107[0] + 1);
        else {
          double v55 = 1.0;
        }
        uint64_t v56 = *(OpaqueCMTimebase **)(a1 + 40);
        CMTime time = v105[0];
        *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)newTimescale;
        lhs.CMTimeEpoch epoch = *(void *)&v107[0];
        uint64_t PlayableDurationForTrack = CMTimebaseSetRateAndAnchorTime(v56, v55, &time, &lhs);
        if (PlayableDurationForTrack) {
          goto LABEL_113;
        }
        time.CMTimeValue value = v115;
        time.CMTimeScale timescale = v116;
        time.CMTimeFlags flags = flags;
        time.CMTimeEpoch epoch = epoch;
        *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)newTimescale;
        lhs.CMTimeEpoch epoch = *(void *)&v107[0];
        if (CMTimeCompare(&time, &lhs))
        {
          uint64_t v57 = *(const void **)(a1 + 32);
          uint64_t v58 = *(const void **)(a1 + 40);
          time.CMTimeValue value = v115;
          time.CMTimeScale timescale = v116;
          time.CMTimeFlags flags = flags;
          time.CMTimeEpoch epoch = epoch;
          CMSyncConvertTime(&time1, &time, v57, v58);
        }
        else
        {
          CMTime time1 = v105[0];
        }
        CMTime time = time1;
        uint64_t PlayableDurationForTrack = fpm_getPlayableDurationForTrack(a1, v20, &time, &time2, (Boolean *)&v110, &v103, &v102);
        if (PlayableDurationForTrack) {
          goto LABEL_113;
        }
        if ((_BYTE)v110)
        {
          uint64_t v113 = v117;
          int v114 = epoch_high;
          CMTimeValue v53 = v51;
          CMTimeScale v54 = v52;
          goto LABEL_59;
        }
        RelativeFloat64 Rate = CMSyncGetRelativeRate(*(CMClockOrTimebaseRef *)(a1 + 32), *(CMClockOrTimebaseRef *)(a1 + 40));
        CMTime lhs = time2;
        CMTimeMultiplyByFloat64(&time, &lhs, RelativeRate);
        CMTimeValue v53 = time.value;
        CMTimeScale v54 = time.timescale;
        uint64_t v113 = *(void *)&time.flags;
        int v114 = HIDWORD(time.epoch);
        CMTime time = time2;
        CMTime lhs = v105[1];
        if (CMTimeCompare(&time, &lhs))
        {
          time.CMTimeValue value = v115;
          time.CMTimeScale timescale = v116;
          time.CMTimeFlags flags = flags;
          time.CMTimeEpoch epoch = epoch;
          lhs.CMTimeValue value = v53;
          lhs.CMTimeScale timescale = v54;
          *(void *)&lhs.CMTimeFlags flags = v113;
          HIDWORD(lhs.epoch) = v114;
          CMTimeAdd(&v93, &time, &lhs);
          CMTimeConvertScale(&v94, &v93, v52, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
          time.CMTimeValue value = v51;
          time.CMTimeScale timescale = v52;
          *(void *)&time.CMTimeFlags flags = v117;
          HIDWORD(time.epoch) = epoch_high;
          if (CMTimeCompare(&v94, &time) < 1) {
            goto LABEL_59;
          }
        }
      }
      lhs.CMTimeValue value = v51;
      lhs.CMTimeScale timescale = v52;
      *(void *)&lhs.CMTimeFlags flags = v117;
      HIDWORD(lhs.epoch) = epoch_high;
      rhs.CMTimeValue value = v115;
      rhs.CMTimeScale timescale = v116;
      rhs.CMTimeFlags flags = flags;
      rhs.CMTimeEpoch epoch = epoch;
      CMTimeSubtract(&time, &lhs, &rhs);
      CMTimeValue v53 = time.value;
      CMTimeScale v54 = time.timescale;
      uint64_t v113 = *(void *)&time.flags;
      int v114 = HIDWORD(time.epoch);
LABEL_59:
      lhs.CMTimeValue value = v115;
      lhs.CMTimeScale timescale = v116;
      lhs.CMTimeFlags flags = flags;
      lhs.CMTimeEpoch epoch = epoch;
      rhs.CMTimeValue value = v53;
      rhs.CMTimeScale timescale = v54;
      *(void *)&rhs.CMTimeFlags flags = v113;
      HIDWORD(rhs.epoch) = v114;
      CMTimeAdd(&time, &lhs, &rhs);
      CMTimeFlags flags = time.flags;
      CMTimeScale v116 = time.timescale;
      CMTimeValue v115 = time.value;
      CMTimeEpoch epoch = time.epoch;
      CMTimeConvertScale(&v92, &time, v52, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      time.CMTimeValue value = v51;
      time.CMTimeScale timescale = v52;
      *(void *)&time.CMTimeFlags flags = v117;
      HIDWORD(time.epoch) = epoch_high;
      if (CMTimeCompare(&v92, &time) < 0)
      {
        time.CMTimeValue value = v115;
        time.CMTimeScale timescale = v116;
        time.CMTimeFlags flags = flags;
        time.CMTimeEpoch epoch = epoch;
        uint64_t v10 = a2;
        CMTime lhs = *a2;
        CMTimeSubtract(&v111, &time, &lhs);
        HIBYTE(v110) = 0;
        goto LABEL_72;
      }
      uint64_t v10 = a2;
      goto LABEL_61;
    }
    time1.CMTimeValue value = value;
    time1.CMTimeScale timescale = timescale;
    time1.CMTimeFlags flags = flags;
    time1.CMTimeEpoch epoch = epoch;
    uint64_t PlayableDurationForTrack = fpm_getPlayableDurationForTrack(a1, v20, &time1, &v111, (Boolean *)&v110 + 1, &v103, &v102);
    if (PlayableDurationForTrack)
    {
LABEL_113:
      uint64_t v68 = PlayableDurationForTrack;
      goto LABEL_106;
    }
    time1.CMTimeValue value = value;
    time1.CMTimeScale timescale = timescale;
    time1.CMTimeFlags flags = flags;
    time1.CMTimeEpoch epoch = epoch;
    CMTime time2 = *v10;
    CMTimeSubtract(&v91, &time1, &time2);
    CMTime time2 = v111;
    CMTimeAdd(&time1, &time2, &v91);
    CMTime v111 = time1;
LABEL_72:
    CMTimeEpoch v21 = v90;
    if (HIBYTE(v110))
    {
      time1.CMTimeValue value = v119;
      time1.CMTimeScale timescale = v120;
      time1.CMTimeFlags flags = v89;
      time1.CMTimeEpoch epoch = v88;
      CMTime time2 = v111;
      if (CMTimeCompare(&time1, &time2) < 0)
      {
        CMTimeValue v119 = v111.value;
        CMTimeFlags v89 = v111.flags;
        CMTimeScale v120 = v111.timescale;
        CMTimeEpoch v88 = v111.epoch;
      }
    }
    else
    {
      CMTimeValue v64 = v87;
      BOOL v65 = v87 <= v103;
      if (v87 >= v103) {
        CMTimeValue v64 = v103;
      }
      CMTimeValue v87 = v64;
      CMTimeValue v66 = v84;
      if (!v65) {
        CMTimeValue v66 = v102;
      }
      CMTimeValue v84 = v66;
      if ((v101 == 1986618469 || v101 == 1936684398)
        && (time1.CMTimeValue value = v121,
            time1.CMTimeScale timescale = v122,
            time1.CMTimeFlags flags = v81,
            time1.CMTimeEpoch epoch = v90,
            CMTime time2 = v111,
            CMTimeCompare(&time1, &time2) >= 1))
      {
        char v83 = 0;
        CMTimeValue v121 = v111.value;
        CMTimeFlags v81 = v111.flags;
        CMTimeScale v122 = v111.timescale;
        CMTimeEpoch v21 = v111.epoch;
      }
      else
      {
        char v83 = 0;
      }
    }
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
    if (v108)
    {
      CFRelease(v108);
      CFTypeRef v108 = 0;
    }
    ++v20;
    uint64_t v67 = *(void *)(a1 + 80);
  }
  while (v20 < v67);
  CMTimeEpoch v70 = v21;
  uint64_t v7 = a5;
  uint64_t v6 = a6;
  uint64_t v9 = a3;
  double v8 = a4;
  CMTimeValue v69 = v84;
  CMTimeFlags v11 = v81;
  int v13 = (_OWORD *)MEMORY[0x1E4F1FA48];
  CMTimeValue v14 = v75;
  CMTimeEpoch v17 = v76;
  CMTimeFlags v16 = v73;
  CMTimeScale v15 = v74;
  if (!v67)
  {
LABEL_93:
    CMTimeValue v121 = v14;
    CMTimeScale v122 = v15;
    CMTimeFlags v11 = v16;
    CMTimeEpoch v70 = v17;
  }
LABEL_94:
  if ((v11 & 0x1D) != 1)
  {
    CMTimeValue v121 = v119;
    CMTimeScale v122 = v120;
    CMTimeFlags v11 = v89;
    CMTimeEpoch v70 = v88;
  }
  CMTime time1 = *v10;
  *(_OWORD *)&time2.CMTimeValue value = *v13;
  time2.CMTimeEpoch epoch = v17;
  if (CMTimeCompare(&time1, &time2))
  {
    int32_t v71 = v10->timescale;
    time2.CMTimeValue value = v121;
    time2.CMTimeScale timescale = v122;
    time2.CMTimeFlags flags = v11;
    time2.CMTimeEpoch epoch = v70;
    CMTimeConvertScale(&time1, &time2, v71, kCMTimeRoundingMethod_RoundAwayFromZero);
    CMTimeValue v121 = time1.value;
    CMTimeFlags v11 = time1.flags;
    CMTimeScale v122 = time1.timescale;
    CMTimeEpoch v70 = time1.epoch;
  }
  if (v9)
  {
    *(void *)uint64_t v9 = v121;
    *(_DWORD *)(v9 + 8) = v122;
    *(_DWORD *)(v9 + 12) = v11;
    *(void *)(v9 + 16) = v70;
  }
  if (v8) {
    *double v8 = v83;
  }
  if (v7) {
    *uint64_t v7 = v87;
  }
  uint64_t v68 = 0;
  if (v6) {
    *uint64_t v6 = v69;
  }
LABEL_106:
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0;
  }
  if (v108) {
    CFRelease(v108);
  }
  return v68;
}

uint64_t fpm_getPlayableDurationForTrack(uint64_t a1, uint64_t a2, CMTime *a3, CMTime *a4, Boolean *a5, CMTimeValue *a6, CMTimeValue *a7)
{
  uint64_t v11 = *(void *)(a1 + 8);
  CFBooleanRef BOOLean = 0;
  CFDictionaryRef dictionaryRepresentation = 0;
  memset(&v76, 0, sizeof(v76));
  memset(&v75, 0, sizeof(v75));
  uint64_t v12 = *(void *)(a1 + 80);
  uint64_t v13 = *(void *)(a1 + 88);
  CMTimeValue v14 = (long long *)MEMORY[0x1E4F1F9F0];
  CMTimeEpoch v15 = *(void *)(MEMORY[0x1E4F1F9F0] + 16);
  a4->CMTimeEpoch epoch = v15;
  long long v70 = *v14;
  *(_OWORD *)&a4->CMTimeValue value = *v14;
  ++*(_DWORD *)(a1 + 64);
  MEMORY[0x19970E2B0](*(void *)(a1 + 48));
  MEMORY[0x19970E290](*(void *)(a1 + 56));
  uint64_t v16 = v13 + 48 * a2;
  uint64_t v19 = *(void *)(v16 + 16);
  CMTimeEpoch v17 = (void *)(v16 + 16);
  uint64_t v18 = v19;
  uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v20) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v22 = *(uint64_t (**)(uint64_t, CMTime *))(v21 + 40);
  if (!v22) {
    goto LABEL_15;
  }
  uint64_t v23 = v22(v18, &v75);
  if (v23) {
    goto LABEL_16;
  }
  CMTime time1 = v75;
  CMTime time2 = *a3;
  if (!CMTimeCompare(&time1, &time2)) {
    goto LABEL_13;
  }
  uint64_t v24 = *v17;
  CMTime time1 = *a3;
  CMTime time2 = v75;
  CMTimeSubtract(&v74, &time1, &time2);
  uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
  uint64_t v26 = v25 ? v25 : 0;
  uint64_t v27 = *(uint64_t (**)(uint64_t, CMTime *))(v26 + 128);
  if (!v27)
  {
LABEL_15:
    uint64_t v23 = 4294954514;
    goto LABEL_16;
  }
  CMTime time1 = v74;
  uint64_t v28 = v27(v24, &time1);
  if (v28)
  {
    uint64_t v23 = v28;
    if (v28 != -12840) {
      goto LABEL_16;
    }
  }
LABEL_13:
  uint64_t v69 = *MEMORY[0x1E4F1CF80];
  uint64_t FigBaseObject = FigSampleCursorGetFigBaseObject(*v17);
  uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v30) {
    uint64_t v31 = v30;
  }
  else {
    uint64_t v31 = 0;
  }
  uint64_t v34 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFDictionaryRef *))(v31 + 48);
  if (v34)
  {
    uint64_t v23 = v34(FigBaseObject, @"CursorPlayableHorizon", v69, &dictionaryRepresentation);
    if (!v23)
    {
      CMTimeMakeFromDictionary(&time1, dictionaryRepresentation);
      *a4 = time1;
      CFRelease(dictionaryRepresentation);
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v23 = 4294954514;
  }
  *(unsigned char *)(a1 + 8554) = 0;
LABEL_25:
  if (a5)
  {
    uint64_t v68 = FigSampleCursorGetFigBaseObject(*v17);
    uint64_t v35 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v35) {
      uint64_t v36 = v35;
    }
    else {
      uint64_t v36 = 0;
    }
    uint64_t v37 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CFBooleanRef *))(v36 + 48);
    if (v37 && !v37(v68, @"CursorPlayableThroughEndOfTrack", v69, &BOOLean))
    {
      *a5 = CFBooleanGetValue(BOOLean);
      CFRelease(BOOLean);
      int v42 = *a5;
      goto LABEL_59;
    }
    if ((~a4->flags & 0x11) != 0)
    {
      uint64_t v38 = *(void *)(v13 + 48 * a2 + 24);
      *(_OWORD *)&v76.CMTimeValue value = v70;
      v76.CMTimeEpoch epoch = v15;
      if (v12 == 1)
      {
        BOOL v39 = FigFormatReaderUtilityGetDuration(v11, 0, &v76) == 0;
      }
      else
      {
        memset(&time2, 0, sizeof(time2));
        uint64_t v40 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v40) {
          uint64_t v41 = v40;
        }
        else {
          uint64_t v41 = 0;
        }
        uint64_t v43 = *(void (**)(uint64_t, CMTime *))(v41 + 128);
        if (v43)
        {
          CMTime time1 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA10];
          v43(v38, &time1);
        }
        uint64_t v44 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v44) {
          uint64_t v45 = v44;
        }
        else {
          uint64_t v45 = 0;
        }
        CFTypeRef v46 = *(void (**)(uint64_t, CMTime *))(v45 + 40);
        if (v46) {
          v46(v38, &v76);
        }
        uint64_t v47 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v47) {
          uint64_t v48 = v47;
        }
        else {
          uint64_t v48 = 0;
        }
        if (*(void *)(v48 + 56))
        {
          uint64_t v49 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v50 = v49 ? v49 : 0;
          CMTimeValue v51 = *(unsigned int (**)(uint64_t, CMTime *))(v50 + 56);
          if (v51)
          {
            if (!v51(v38, &time2))
            {
              CMTime lhs = v76;
              CMTime rhs = time2;
              CMTimeAdd(&time1, &lhs, &rhs);
              CMTime v76 = time1;
            }
          }
        }
        BOOL v39 = 1;
      }
      if ((v76.flags & 0x1D) == 1 && v39)
      {
        CMTime time2 = v76;
        CMTime lhs = *a3;
        CMTimeSubtract(&time1, &time2, &lhs);
        CMTime v76 = time1;
        CMTimeEpoch epoch = time1.epoch;
        long long v53 = *(_OWORD *)&time1.value;
        CMTime time1 = *a4;
        *(_OWORD *)&time2.CMTimeValue value = v53;
        time2.CMTimeEpoch epoch = epoch;
        int v42 = CMTimeCompare(&time1, &time2) >= 0;
        *a5 = v42;
LABEL_59:
        double v55 = a6;
        CMTimeScale v54 = a7;
        if (v42) {
          uint64_t v23 = 0;
        }
        goto LABEL_63;
      }
    }
    *a5 = 0;
  }
  double v55 = a6;
  CMTimeScale v54 = a7;
LABEL_63:
  if (v55 && v54)
  {
    *double v55 = 0x7FFFFFFFFFFFFFFFLL;
    *CMTimeScale v54 = 0;
    uint64_t v56 = *v17;
    CMTime time2 = *a4;
    uint64_t v57 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v58 = v57 ? v57 : 0;
    CFTypeRef v59 = *(unsigned int (**)(uint64_t, CMTime *))(v58 + 128);
    if (!v59 || (CMTime time1 = time2, v59(v56, &time1) != -12840))
    {
      time1.CMTimeValue value = 0;
      time2.CMTimeValue value = 0;
      uint64_t v60 = *v17;
      uint64_t v61 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v61) {
        uint64_t v62 = v61;
      }
      else {
        uint64_t v62 = 0;
      }
      uint64_t v63 = *(unsigned int (**)(uint64_t, void, void, CMTime *, CMTime *, void, void, void, void, void))(v62 + 152);
      if (v63 && !v63(v60, 0, 0, &time1, &time2, 0, 0, 0, 0, 0))
      {
        *double v55 = time1.value;
        *CMTimeScale v54 = time2.value;
      }
      else
      {
        uint64_t v64 = *v17;
        uint64_t v65 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v65) {
          uint64_t v66 = v65;
        }
        else {
          uint64_t v66 = 0;
        }
        uint64_t v67 = *(void (**)(uint64_t, CMTimeValue *, CMTimeValue *, void, void))(v66 + 144);
        if (v67) {
          v67(v64, v55, v54, 0, 0);
        }
      }
    }
  }
LABEL_16:
  MEMORY[0x19970E2B0](*(void *)(a1 + 56));
  MEMORY[0x19970E290](*(void *)(a1 + 48));
  int v32 = *(_DWORD *)(a1 + 64) - 1;
  *(_DWORD *)(a1 + 64) = v32;
  if (!v32) {
    MEMORY[0x19970CC00](*(void *)(a1 + 72));
  }
  return v23;
}

BOOL fpm_shouldUpdateAggressively(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 104);
  if (!v1) {
    return 1;
  }
  int v2 = *(_DWORD *)(a1 + 112);
  if (v2 == 3) {
    return v1 != 1 || *(unsigned char *)(a1 + 315);
  }
  if (*(unsigned char *)(a1 + 315)) {
    return 1;
  }
  if (v1 == 1 || v2 != 0) {
    return 0;
  }
  return *(unsigned char *)(a1 + 8555) == 0;
}

uint64_t fpm_deferredTimebaseJumpedCallback()
{
  FigRetainProxyLockMutex();
  if (!FigRetainProxyIsInvalidated())
  {
    uint64_t Owner = (__CFData *)FigRetainProxyGetOwner();
    MutableBytePtr = CFDataGetMutableBytePtr(Owner);
    MEMORY[0x19970E290](*((void *)MutableBytePtr + 6));
    fpm_ensureUpdatePrimed((uint64_t)MutableBytePtr);
    MEMORY[0x19970E2B0](*((void *)MutableBytePtr + 6));
  }
  FigRetainProxyUnlockMutex();

  return FigRetainProxyRelease();
}

double fpm_durationAhead(uint64_t a1, _OWORD *a2)
{
  memset(&v10, 0, sizeof(v10));
  if (a2)
  {
    CMTimebaseGetTime(&time1.start, *(CMTimebaseRef *)(a1 + 24));
    CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    CMTimeMaximum(&v10, &time1.start, &time2);
    time1.CMTime start = v10;
    CMTime time2 = *(CMTime *)(a1 + 216);
    if ((CMTimeCompare(&time1.start, &time2) & 0x80000000) == 0
      && (time1.CMTime start = v10, time2 = *(CMTime *)(a1 + 240), CMTimeCompare(&time1.start, &time2) < 0))
    {
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(a1 + 240);
      time1.start.CMTimeEpoch epoch = *(void *)(a1 + 256);
      CMTime time2 = v10;
      CMTimeSubtract(&duration, &time1.start, &time2);
      CMTime time2 = v10;
      p_CMTime duration = &duration;
    }
    else
    {
      CMTimeMake(&v7, 0, 1000000000);
      CMTime time2 = v10;
      p_CMTime duration = &v7;
    }
    CMTimeRangeMake(&time1, &time2, p_duration);
    long long v5 = *(_OWORD *)&time1.start.epoch;
    *a2 = *(_OWORD *)&time1.start.value;
    a2[1] = v5;
    double result = *(double *)&time1.duration.timescale;
    a2[2] = *(_OWORD *)&time1.duration.timescale;
  }
  return result;
}

uint64_t fpm_updateStreamBufferDurationAhead(uint64_t result, uint64_t a2)
{
  CFBooleanRef v14 = 0;
  if (*(void *)(result + 8640))
  {
    uint64_t v2 = result;
    double result = *(void *)(result + 16);
    if (result)
    {
      CMByteStreamGetCMBaseObject();
      FigCRABSGetClassID();
      double result = CMBaseObjectIsMemberOfClass();
      if (result)
      {
        uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
        uint64_t VTable = CMBaseObjectGetVTable();
        uint64_t v7 = *(void *)(VTable + 8);
        double result = VTable + 8;
        uint64_t v6 = v7;
        uint64_t v8 = v7 ? v6 : 0;
        uint64_t v9 = *(uint64_t (**)(uint64_t, void, void, const __CFBoolean **))(v8 + 48);
        if (!v9) {
          goto LABEL_19;
        }
        double result = v9(CMBaseObject, *MEMORY[0x1E4F1EC58], *MEMORY[0x1E4F1CF80], &v14);
        if (result) {
          goto LABEL_19;
        }
        int Value = CFBooleanGetValue(v14);
        if (v14) {
          CFRelease(v14);
        }
        double result = FigNetworkUrgencyMonitorSetStreamFullyAvailable(*(void *)(v2 + 8640), Value);
        if (!Value)
        {
LABEL_19:
          if ((*(unsigned char *)(a2 + 12) & 1) != 0
            && (*(unsigned char *)(a2 + 36) & 1) != 0
            && !*(void *)(a2 + 40)
            && (*(void *)(a2 + 24) & 0x8000000000000000) == 0)
          {
            uint64_t v11 = *(void *)(v2 + 8640);
            long long v12 = *(_OWORD *)(a2 + 16);
            v13[0] = *(_OWORD *)a2;
            v13[1] = v12;
            v13[2] = *(_OWORD *)(a2 + 32);
            return FigNetworkUrgencyMonitorSetPlayableRange(v11, v13);
          }
        }
      }
    }
  }
  return result;
}

void fpm_likelyToKeepUpUsingLivePlaybackAlgorithm(uint64_t a1, int a2, double a3)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  CMTime v46 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CFTypeRef cf = 0;
  CFBooleanRef BOOLean = 0;
  double valuePtr = 0.0;
  CFNumberRef number = 0;
  double v40 = 0.0;
  double v41 = 0.0;
  if (FigFormatReaderUtilityGetDuration(*(void *)(a1 + 8), 1, &v46) || (v46.flags & 0x1D) != 1) {
    return;
  }
  if (*(_DWORD *)(a1 + 104) != 1)
  {
    CMTimebaseGetTime(&time1, *(CMTimebaseRef *)(a1 + 24));
    CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    CMTimeMaximum(&v39, &time1, &time2);
    CMTimeValue value = v39.value;
    CMTimeScale timescale = v39.timescale;
    if ((v39.flags & 0x1D) != 1) {
      return;
    }
    time1.CMTimeValue value = value;
    time1.CMTimeScale timescale = timescale;
    time1.CMTimeFlags flags = v39.flags;
    time1.CMTimeEpoch epoch = v39.epoch;
    double Seconds = CMTimeGetSeconds(&time1);
    CMTime time1 = v46;
    double v7 = CMTimeGetSeconds(&time1);
    double v8 = 0.0;
    if (v7 <= Seconds) {
      double v9 = 0.0;
    }
    else {
      double v9 = v7 - Seconds;
    }
    uint64_t v10 = *MEMORY[0x1E4F1CF80];
    if (*(_DWORD *)(a1 + 104) == 1) {
      goto LABEL_9;
    }
    uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
    uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v16) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v24 = *(unsigned int (**)(uint64_t, void, uint64_t, CFBooleanRef *))(v17 + 48);
    if (v24 && !v24(CMBaseObject, *MEMORY[0x1E4F1EC58], v10, &BOOLean))
    {
      int v11 = CFBooleanGetValue(BOOLean);
      CFRelease(BOOLean);
    }
    else
    {
      int v11 = 0;
    }
    if (v7 > 0.0 && !v11)
    {
      uint64_t v25 = CMByteStreamGetCMBaseObject();
      uint64_t v26 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v26) {
        uint64_t v27 = v26;
      }
      else {
        uint64_t v27 = 0;
      }
      uint64_t v35 = *(unsigned int (**)(uint64_t, void, uint64_t, CFNumberRef *))(v27 + 48);
      if (!v35 || v35(v25, *MEMORY[0x1E4F1EC50], v10, &number))
      {
LABEL_9:
        int v11 = 0;
        goto LABEL_10;
      }
      CFNumberGetValue(number, kCFNumberFloat64Type, &valuePtr);
      CFRelease(number);
      int v11 = 0;
      double v8 = valuePtr / v7;
    }
LABEL_10:
    uint64_t v12 = CMByteStreamGetCMBaseObject();
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v18 = *(unsigned int (**)(uint64_t, void, uint64_t, CFTypeRef *))(v14 + 48);
    float v19 = 1.0;
    if (v18 && !v18(v12, *MEMORY[0x1E4F1EC70], v10, &cf))
    {
      FigCFDictionaryGetDoubleIfPresent();
      FigCFDictionaryGetDoubleIfPresent();
      if (v41 != 0.0) {
        float v19 = v40 / v41 + 1.0;
      }
      CFRelease(cf);
    }
    if (*(_DWORD *)(a1 + 104) == 1) {
      goto LABEL_44;
    }
    if (v11 || v9 - a3 <= 0.1) {
      goto LABEL_28;
    }
    BOOL v20 = a3 >= 3.33333333;
    if (v8 * 1.5 > v41) {
      BOOL v20 = 0;
    }
    if (a3 >= 5.0 || v20 || fpm_isLikelyToKeepUp(a1, 0, Seconds, a3, v41, v19))
    {
LABEL_28:
      fpm_createDurationDictionary(a3);
      *(void *)(a1 + 104) = 0x3F80000000000001;
      if (dword_1E9350B30)
      {
        LODWORD(v39.CFDictionarySetValue(theDict, key, value) = 0;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v22 = v39.value;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT)) {
          unsigned int v23 = v22;
        }
        else {
          unsigned int v23 = v22 & 0xFFFFFFFE;
        }
        if (v23)
        {
          LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136315650;
          *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingLivePlaybackAlgorithm";
          LOWORD(time2.flags) = 2048;
          *(void *)((char *)&time2.flags + 2) = a1;
          HIWORD(time2.epoch) = 2048;
          double v48 = a3;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 104) == 2)
      {
LABEL_44:
        if (dword_1E9350B30)
        {
          LODWORD(v39.CFDictionarySetValue(theDict, key, value) = 0;
          uint64_t v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v29 = v39.value;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
            unsigned int v30 = v29;
          }
          else {
            unsigned int v30 = v29 & 0xFFFFFFFE;
          }
          if (v30)
          {
            LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316674;
            *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingLivePlaybackAlgorithm";
            LOWORD(time2.flags) = 2048;
            *(void *)((char *)&time2.flags + 2) = a1;
            HIWORD(time2.epoch) = 2048;
            double v48 = v41 * 8.0 / 1000.0;
            __int16 v49 = 2048;
            double v50 = 0.0;
            __int16 v51 = 2048;
            double v52 = v19;
            __int16 v53 = 2048;
            double v54 = v7 - v9;
            __int16 v55 = 2048;
            double v56 = a3;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        goto LABEL_51;
      }
      *(void *)(a1 + 104) = 2;
      if (dword_1E9350B30)
      {
        LODWORD(v39.CFDictionarySetValue(theDict, key, value) = 0;
        uint64_t v36 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v37 = v39.value;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
          unsigned int v38 = v37;
        }
        else {
          unsigned int v38 = v37 & 0xFFFFFFFE;
        }
        if (v38)
        {
          LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136315906;
          *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingLivePlaybackAlgorithm";
          LOWORD(time2.flags) = 2048;
          *(void *)((char *)&time2.flags + 2) = a1;
          HIWORD(time2.epoch) = 2048;
          double v48 = 0.0;
          __int16 v49 = 2048;
          double v50 = v9;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
    }
    FigRetainProxyRetain();
    CMNotificationCenterGetDefaultLocalCenter();
    FigDeferNotificationToDispatchQueue();
    goto LABEL_44;
  }
LABEL_51:
  if (a2)
  {
    if (*(_DWORD *)(a1 + 104) != 1)
    {
      *(void *)(a1 + 104) = 2;
      int v31 = *(_DWORD *)(a1 + 96);
      if (*(_DWORD *)(a1 + 100) != v31)
      {
        *(_DWORD *)(a1 + 100) = v31;
        if (dword_1E9350B30)
        {
          LODWORD(v39.CFDictionarySetValue(theDict, key, value) = 0;
          int v32 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v33 = v39.value;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
            unsigned int v34 = v33;
          }
          else {
            unsigned int v34 = v33 & 0xFFFFFFFE;
          }
          if (v34)
          {
            LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136315394;
            *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpm_likelyToKeepUpUsingLivePlaybackAlgorithm";
            LOWORD(time2.flags) = 2048;
            *(void *)((char *)&time2.flags + 2) = a1;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        FigRetainProxyRetain();
        CMNotificationCenterGetDefaultLocalCenter();
        FigDeferNotificationToDispatchQueue();
      }
    }
  }
}

CFDictionaryRef fpm_createDurationDictionary(double a1)
{
  double valuePtr = a1;
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFTypeRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &valuePtr);
  if (!cf) {
    return 0;
  }
  CFDictionaryRef v2 = CFDictionaryCreate(v1, (const void **)&kFigPlayabilityMonitorPayload_Duration, &cf, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(cf);
  return v2;
}

uint64_t fpm_isLikelyToKeepUp(uint64_t a1, double *a2, double a3, double a4, double a5, float a6)
{
  if (a5 <= 0.0)
  {
    LOBYTE(v23) = 0;
  }
  else
  {
    uint64_t v31 = v11;
    uint64_t v32 = v10;
    uint64_t v33 = v9;
    uint64_t v34 = v8;
    uint64_t v35 = v6;
    uint64_t v36 = v7;
    if (!*(unsigned char *)(a1 + 8552) && fpm_prepareDataRateProfile(a1)
      || (CMTime v30 = *(CMTime *)(a1 + 8528), Seconds = CMTimeGetSeconds(&v30), Seconds == 0.0))
    {
      LOBYTE(v23) = 0;
    }
    else
    {
      uint64_t v19 = 0;
      double v20 = 0.0;
      do
      {
        double v20 = Seconds + v20;
        if (v20 > a3) {
          break;
        }
        ++v19;
      }
      while (v19 != 1023);
      unint64_t v21 = 0;
      double v22 = 0.0;
      while (1)
      {
        double v22 = Seconds + v22;
        if (v22 > a3 + a4) {
          break;
        }
        if (++v21 == 1023) {
          goto LABEL_15;
        }
      }
      if (v21 > 0x3FF)
      {
        double v24 = 0.0;
        LOBYTE(v23) = 1;
        if (a2) {
LABEL_24:
        }
          *a2 = v24;
      }
      else
      {
LABEL_15:
        double v24 = 0.0;
        double v25 = Seconds * (double)(uint64_t)(v21 - v19) * a5 + 0.0;
        uint64_t v26 = 8 * v21;
        int v23 = 1;
        do
        {
          uint64_t v27 = *(void *)(a1 + 336 + v26);
          if (!v27) {
            break;
          }
          double v28 = (float)((float)v27 * a6);
          if (v23 && v25 > v28)
          {
            int v23 = 1;
          }
          else
          {
            int v23 = 0;
            if (v25 < v28)
            {
              double v24 = v24 + (v28 - v25) / a5;
              double v25 = (float)((float)v27 * a6);
            }
          }
          v26 += 8;
          double v25 = v25 - ((double)v27 - Seconds * a5);
        }
        while (v26 != 0x2000);
        if (a2) {
          goto LABEL_24;
        }
      }
    }
  }
  return v23;
}

uint64_t FigTTMLNodeGetClassID()
{
  return sFigTTMLNodeClassID;
}

uint64_t figTTMLNodeRegisterFigTTMLNodeBaseType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

uint64_t FigTTMLNodeGetTypeID()
{
  MEMORY[0x19970EE10](&FigTTMLNodeGetClassID_sRegisterFigTTMLNodeBaseTypeOnce, figTTMLNodeRegisterFigTTMLNodeBaseType);

  return CMBaseClassGetCFTypeID();
}

uint64_t FigTTMLNodeGetParentNode()
{
  return *(void *)CMBaseObjectGetDerivedStorage();
}

uint64_t FigTTMLNodeGetPrecedingNode()
{
  return *(void *)(CMBaseObjectGetDerivedStorage() + 8);
}

uint64_t FigTTMLNodeGetDocumentOrderIndex()
{
  return *(void *)(CMBaseObjectGetDerivedStorage() + 16);
}

const void *FigTTMLNodeGetXMLID()
{
  CFDictionaryRef v0 = *(const __CFDictionary **)(CMBaseObjectGetDerivedStorage() + 24);

  return CFDictionaryGetValue(v0, @"http://www.w3.org/XML/1998/namespace id");
}

uint64_t FigTTMLNodeGetActiveTimeRange(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    uint64_t v5 = DerivedStorage;
    memset(&v23, 0, sizeof(v23));
    uint64_t v6 = DerivedStorage + 32;
    if ((*(unsigned char *)(DerivedStorage + 44) & 1) != 0
      && (*(unsigned char *)(DerivedStorage + 68) & 1) != 0
      && !*(void *)(DerivedStorage + 72)
      && (*(void *)(DerivedStorage + 56) & 0x8000000000000000) == 0)
    {
      uint64_t result = 0;
      long long v17 = *(_OWORD *)v6;
      long long v18 = *(_OWORD *)(v6 + 32);
      *(_OWORD *)(a2 + 16) = *(_OWORD *)(v6 + 16);
      *(_OWORD *)(a2 + 32) = v18;
      *(_OWORD *)a2 = v17;
      return result;
    }
    uint64_t result = figTTMLNodeGetUnclippedTimeRange(a1, (uint64_t)&v23);
    if (!result)
    {
      uint64_t v8 = *(void *)CMBaseObjectGetDerivedStorage();
      if (v8)
      {
        memset(&v22, 0, sizeof(v22));
        uint64_t result = FigTTMLNodeGetActiveTimeRange(v8, &v22);
        if (result) {
          return result;
        }
        CMTimeRange range = v23;
        CMTimeRange otherRange = v22;
        CMTimeRangeGetIntersection(&v21, &range, &otherRange);
        otherRange.start.CMTimeValue value = v21.start.value;
        CMTimeFlags flags = v21.start.flags;
        otherRange.start.CMTimeScale timescale = v21.start.timescale;
        CMTimeEpoch epoch = v21.start.epoch;
        CMTimeValue value = v21.duration.value;
        CMTimeScale timescale = v21.duration.timescale;
        CMTimeFlags v13 = v21.duration.flags;
        CMTimeEpoch v14 = v21.duration.epoch;
        if ((v21.start.flags & 1) != 0
          && (v21.duration.flags & 1) != 0
          && !v21.duration.epoch
          && (v21.duration.value & 0x8000000000000000) == 0)
        {
          v21.start.CMTimeValue value = v21.duration.value;
          v21.start.CMTimeScale timescale = v21.duration.timescale;
          v21.start.CMTimeFlags flags = v21.duration.flags;
          v21.start.CMTimeEpoch epoch = 0;
          *(_OWORD *)&range.start.CMTimeValue value = *MEMORY[0x1E4F1FA48];
          range.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16);
          if (!CMTimeCompare(&v21.start, &range.start))
          {
            *(_OWORD *)&v21.start.CMTimeValue value = *(_OWORD *)&v23.start.value;
            v21.start.CMTimeEpoch epoch = v23.start.epoch;
            *(_OWORD *)&range.start.CMTimeValue value = *(_OWORD *)&v22.start.value;
            range.start.CMTimeEpoch epoch = v22.start.epoch;
            if (CMTimeCompare(&v21.start, &range.start) <= 0)
            {
              otherRange.start.CMTimeValue value = v22.start.value;
              CMTimeFlags flags = v22.start.flags;
              otherRange.start.CMTimeScale timescale = v22.start.timescale;
              CMTimeEpoch epoch = v22.start.epoch;
            }
            else
            {
              CMTimeRange v21 = v22;
              CMTimeRangeGetEnd(&time1, &v21);
              *(_OWORD *)&v21.start.CMTimeValue value = *(_OWORD *)&v23.start.value;
              v21.start.CMTimeEpoch epoch = v23.start.epoch;
              if (CMTimeCompare(&time1, &v21.start) < 0)
              {
                CMTimeRange v21 = v22;
                CMTimeRangeGetEnd(&range.start, &v21);
                otherRange.start.CMTimeValue value = range.start.value;
                CMTimeFlags flags = range.start.flags;
                otherRange.start.CMTimeScale timescale = range.start.timescale;
                CMTimeEpoch epoch = range.start.epoch;
              }
              else
              {
                otherRange.start.CMTimeValue value = v23.start.value;
                CMTimeFlags flags = v23.start.flags;
                otherRange.start.CMTimeScale timescale = v23.start.timescale;
                CMTimeEpoch epoch = v23.start.epoch;
              }
            }
          }
        }
      }
      else
      {
        *(_OWORD *)&v21.start.CMTimeValue value = *MEMORY[0x1E4F1FA48];
        v21.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16);
        *(_OWORD *)&range.start.CMTimeValue value = *MEMORY[0x1E4F1F9F0];
        range.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F0] + 16);
        CMTimeRangeMake(&v22, &v21.start, &range.start);
        otherRange.start.CMTimeValue value = v22.start.value;
        CMTimeFlags flags = v22.start.flags;
        otherRange.start.CMTimeScale timescale = v22.start.timescale;
        CMTimeEpoch epoch = v22.start.epoch;
        CMTimeValue value = v22.duration.value;
        CMTimeScale timescale = v22.duration.timescale;
        CMTimeFlags v13 = v22.duration.flags;
        CMTimeEpoch v14 = v22.duration.epoch;
      }
      uint64_t result = 0;
      CMTimeScale v15 = otherRange.start.timescale;
      *(_DWORD *)(v6 + 8) = otherRange.start.timescale;
      CMTimeValue v16 = otherRange.start.value;
      *(void *)uint64_t v6 = otherRange.start.value;
      *(_DWORD *)(v5 + 44) = flags;
      *(void *)(v5 + 48) = epoch;
      *(void *)(v5 + 56) = value;
      *(_DWORD *)(v5 + 64) = timescale;
      *(_DWORD *)(v5 + 68) = v13;
      *(void *)(v5 + 72) = v14;
      *(void *)a2 = v16;
      *(_DWORD *)(a2 + 8) = v15;
      *(_DWORD *)(a2 + 12) = flags;
      *(void *)(a2 + 16) = epoch;
      *(void *)(a2 + 24) = value;
      *(_DWORD *)(a2 + 32) = timescale;
      *(_DWORD *)(a2 + 36) = v13;
      *(void *)(a2 + 40) = v14;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t figTTMLNodeGetUnclippedTimeRange(uint64_t a1, uint64_t a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    uint64_t v5 = DerivedStorage;
    uint64_t v6 = DerivedStorage + 80;
    if ((*(unsigned char *)(DerivedStorage + 92) & 1) != 0
      && (*(unsigned char *)(DerivedStorage + 116) & 1) != 0
      && !*(void *)(DerivedStorage + 120)
      && (*(void *)(DerivedStorage + 104) & 0x8000000000000000) == 0)
    {
      uint64_t result = 0;
      long long v27 = *(_OWORD *)v6;
      long long v28 = *(_OWORD *)(v6 + 32);
      *(_OWORD *)(a2 + 16) = *(_OWORD *)(v6 + 16);
      *(_OWORD *)(a2 + 32) = v28;
      *(_OWORD *)a2 = v27;
      return result;
    }
    uint64_t v40 = 0;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    uint64_t result = FigTTMLNodeGetParameters(a1, &v40);
    if (!result)
    {
      CFDictionaryRef v8 = *(const __CFDictionary **)(v5 + 24);
      uint64_t v9 = v40;
      uint64_t v10 = MEMORY[0x1E4F1FA48];
      long long v30 = *MEMORY[0x1E4F1FA48];
      *(_OWORD *)&v36.start.CMTimeValue value = *MEMORY[0x1E4F1FA48];
      CMTimeEpoch v11 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
      v36.start.CMTimeEpoch epoch = v11;
      long long v29 = *MEMORY[0x1E4F1F9F0];
      *(_OWORD *)&duration.start.CMTimeValue value = *MEMORY[0x1E4F1F9F0];
      CMTimeEpoch v12 = *(void *)(MEMORY[0x1E4F1F9F0] + 16);
      duration.start.CMTimeEpoch epoch = v12;
      CMTimeValue value = 0;
      if (!CFDictionaryGetValueIfPresent(v8, @"begin", (const void **)&value)
        || (uint64_t result = FigTTMLParseTimeExpression(v9, (CFStringRef)value, &v36.start), !result))
      {
        if (!CFDictionaryGetValueIfPresent(v8, @"dur", (const void **)&value)
          || (uint64_t result = FigTTMLParseTimeExpression(v9, (CFStringRef)value, &duration.start), !result))
        {
          if (CFDictionaryGetValueIfPresent(v8, @"end", (const void **)&value))
          {
            memset(&v42, 0, sizeof(v42));
            uint64_t result = FigTTMLParseTimeExpression(v9, (CFStringRef)value, &v42);
            if (result) {
              return result;
            }
            CMTime lhs = v42;
            CMTime rhs = v36.start;
            CMTimeSubtract(&v45, &lhs, &rhs);
            duration.CMTime start = v45;
          }
          CMTime v42 = v36.start;
          lhs.CMTimeValue value = duration.start.value;
          CMTimeFlags flags = duration.start.flags;
          lhs.CMTimeScale timescale = duration.start.timescale;
          CMTimeEpoch epoch = duration.start.epoch;
          uint64_t v15 = *(void *)CMBaseObjectGetDerivedStorage();
          if (!v15)
          {
            *(_OWORD *)&duration.start.CMTimeValue value = v30;
            duration.start.CMTimeEpoch epoch = v11;
            *(_OWORD *)&v45.CMTimeValue value = v29;
            v45.CMTimeEpoch epoch = v12;
            CMTimeRangeMake(&v36, &duration.start, &v45);
            v45.CMTimeValue value = v36.start.value;
            CMTimeFlags v17 = v36.start.flags;
            v45.CMTimeScale timescale = v36.start.timescale;
            CMTimeEpoch v18 = v36.start.epoch;
            CMTimeValue v19 = v36.duration.value;
            CMTimeScale timescale = v36.duration.timescale;
            CMTimeFlags v21 = v36.duration.flags;
            CMTimeEpoch v23 = v36.duration.epoch;
            goto LABEL_31;
          }
          rhs.CMTimeValue value = 0;
          uint64_t result = figTTMLNodeGetUnclippedTimeRange(v15, &v37);
          if (!result)
          {
            uint64_t result = FigTTMLNodeGetTimeContainerSemantics(v15, (__CFString **)&rhs);
            if (!result)
            {
              if (CFEqual((CFTypeRef)rhs.value, @"par"))
              {
                *(_OWORD *)&v36.start.CMTimeValue value = v37;
                v36.start.CMTimeEpoch epoch = v38;
                duration.CMTime start = v42;
                CMTimeAdd(&start, &v36.start, &duration.start);
                duration.start.CMTimeValue value = lhs.value;
                duration.start.CMTimeScale timescale = lhs.timescale;
                duration.start.CMTimeFlags flags = flags;
                duration.start.CMTimeEpoch epoch = epoch;
                p_CMTime start = &start;
              }
              else
              {
                uint64_t v24 = *(void *)(CMBaseObjectGetDerivedStorage() + 8);
                if ((~flags & 0x11) == 0)
                {
                  lhs.CMTimeValue value = *(void *)v10;
                  CMTimeFlags flags = *(_DWORD *)(v10 + 12);
                  lhs.CMTimeScale timescale = *(_DWORD *)(v10 + 8);
                  CMTimeEpoch epoch = v11;
                }
                if (v24 != v15)
                {
                  memset(&v36, 0, sizeof(v36));
                  uint64_t result = figTTMLNodeGetUnclippedTimeRange(v24, &v36);
                  if (result) {
                    return result;
                  }
                  CMTimeRange duration = v36;
                  CMTimeRangeGetEnd(&v31, &duration);
                  duration.CMTime start = v42;
                  CMTimeAdd(&v32, &v31, &duration.start);
                  v45.CMTimeValue value = lhs.value;
                  v45.CMTimeScale timescale = lhs.timescale;
                  v45.CMTimeFlags flags = flags;
                  v45.CMTimeEpoch epoch = epoch;
                  CMTimeRangeMake(&duration, &v32, &v45);
                  v45.CMTimeValue value = duration.start.value;
                  CMTimeFlags v17 = duration.start.flags;
                  v45.CMTimeScale timescale = duration.start.timescale;
                  CMTimeEpoch v18 = duration.start.epoch;
                  CMTimeValue v19 = duration.duration.value;
                  CMTimeScale timescale = duration.duration.timescale;
                  CMTimeFlags v21 = duration.duration.flags;
                  CMTimeEpoch v22 = duration.duration.epoch;
                  if ((duration.start.flags & 1) == 0) {
                    goto LABEL_30;
                  }
LABEL_26:
                  if ((v21 & 1) == 0 || v22 || v19 < 0) {
                    goto LABEL_30;
                  }
                  CMTimeEpoch v23 = 0;
LABEL_31:
                  uint64_t result = 0;
                  CMTimeScale v25 = v45.timescale;
                  *(_DWORD *)(v6 + 8) = v45.timescale;
                  CMTimeValue v26 = v45.value;
                  *(void *)uint64_t v6 = v45.value;
                  *(_DWORD *)(v5 + 92) = v17;
                  *(void *)(v5 + 96) = v18;
                  *(void *)(v5 + 104) = v19;
                  *(_DWORD *)(v5 + 112) = timescale;
                  *(_DWORD *)(v5 + 116) = v21;
                  *(void *)(v5 + 120) = v23;
                  *(void *)a2 = v26;
                  *(_DWORD *)(a2 + 8) = v25;
                  *(_DWORD *)(a2 + 12) = v17;
                  *(void *)(a2 + 16) = v18;
                  *(void *)(a2 + 24) = v19;
                  *(_DWORD *)(a2 + 32) = timescale;
                  *(_DWORD *)(a2 + 36) = v21;
                  *(void *)(a2 + 40) = v23;
                  return result;
                }
                *(_OWORD *)&v36.start.CMTimeValue value = v37;
                v36.start.CMTimeEpoch epoch = v38;
                duration.CMTime start = v42;
                CMTimeAdd(&v34, &v36.start, &duration.start);
                duration.start.CMTimeValue value = lhs.value;
                duration.start.CMTimeScale timescale = lhs.timescale;
                duration.start.CMTimeFlags flags = flags;
                duration.start.CMTimeEpoch epoch = epoch;
                p_CMTime start = &v34;
              }
              CMTimeRangeMake(&v36, p_start, &duration.start);
              v45.CMTimeValue value = v36.start.value;
              CMTimeFlags v17 = v36.start.flags;
              v45.CMTimeScale timescale = v36.start.timescale;
              CMTimeEpoch v18 = v36.start.epoch;
              CMTimeValue v19 = v36.duration.value;
              CMTimeScale timescale = v36.duration.timescale;
              CMTimeFlags v21 = v36.duration.flags;
              CMTimeEpoch v22 = v36.duration.epoch;
              if ((v36.start.flags & 1) == 0)
              {
LABEL_30:
                v45.CMTimeValue value = v37;
                CMTimeFlags v17 = HIDWORD(v37);
                v45.CMTimeScale timescale = DWORD2(v37);
                CMTimeValue v19 = *((void *)&v38 + 1);
                CMTimeEpoch v18 = v38;
                CMTimeScale timescale = v39;
                CMTimeFlags v21 = DWORD1(v39);
                CMTimeEpoch v23 = *((void *)&v39 + 1);
                goto LABEL_31;
              }
              goto LABEL_26;
            }
          }
        }
      }
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t FigTTMLNodeGetTimeContainerSemantics(uint64_t a1, __CFString **a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    CMTimeValue value = 0;
    uint64_t result = CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(DerivedStorage + 24), @"timeContainer", (const void **)&value);
    if (result)
    {
      if (!CFEqual(value, @"par") && !CFEqual(value, @"seq")) {
        return 4294950725;
      }
      uint64_t result = 0;
      uint64_t v5 = (__CFString *)value;
    }
    else
    {
      uint64_t v5 = @"par";
    }
    *a2 = v5;
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t FigTTMLNodeCopyChildNodeArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 8);
  if (!v6) {
    return 4294954514;
  }

  return v6(a1, a2);
}

uint64_t FigTTMLNodeGetNodeType(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 16);
  if (!v6) {
    return 4294954514;
  }

  return v6(a1, a2);
}

uint64_t FigTTMLNodeGetRegionAttributeValue(uint64_t a1, void **a2)
{
  CMTimeValue value = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(DerivedStorage + 24), @"region", (const void **)&value);
    *a2 = value;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigTTMLNodeIsAssociatedWithRegionID(const void *a1, const void *a2)
{
  if (CFEqual(&stru_1EE53F4B8, a2)) {
    return 1;
  }
  CMTimeValue value = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(DerivedStorage + 24), @"region", (const void **)&value);
  uint64_t v6 = value;
  if (value) {
    return CFEqual(v6, a2);
  }
  if (a1)
  {
    do
    {
      CMTimeValue value = 0;
      uint64_t v7 = CMBaseObjectGetDerivedStorage();
      CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(v7 + 24), @"region", (const void **)&value);
      uint64_t v6 = value;
      if (value) {
        return CFEqual(v6, a2);
      }
    }
    while (*(void *)CMBaseObjectGetDerivedStorage());
  }
  uint64_t v9 = a2;
  uint64_t v10 = 0;
  if (FigTTMLTreeWalkFromNode(a1, (uint64_t (*)(const void *, uint64_t))figTTMLNodeIsAssociatedWithRegionIDCallback, 0, (uint64_t)&v9))BOOL v8 = 1; {
  else
  }
    BOOL v8 = v10 == 0;
  return !v8;
}

uint64_t figTTMLNodeIsAssociatedWithRegionIDCallback(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 8)) {
    return 4294950723;
  }
  CMTimeValue value = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(DerivedStorage + 24), @"region", (const void **)&value);
  uint64_t result = (uint64_t)value;
  if (value)
  {
    uint64_t result = CFEqual(value, *(CFTypeRef *)a2);
    if (result)
    {
      uint64_t result = 0;
      *(unsigned char *)(a2 + 8) = 1;
    }
  }
  return result;
}

uint64_t FigTTMLNodeCopyNodeValue(uint64_t a1, void *a2)
{
  if (a2)
  {
    int v8 = 0;
    uint64_t result = FigTTMLNodeGetNodeType(a1, (uint64_t)&v8);
    if (!result)
    {
      if (v8 == 19 || v8 == 18)
      {
        Designation = (const void *)FigTTMLExtensionGetDesignation();
        uint64_t v7 = Designation;
        if (Designation) {
          CFRetain(Designation);
        }
        uint64_t result = 0;
        *a2 = v7;
      }
      else if (v8 == 14)
      {
        return FigTTMLTextCopyContent(a1, a2);
      }
      else
      {
        uint64_t result = 0;
        *a2 = 0;
      }
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t FigTTMLNodeCopyAttributes(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    CFTypeRef v4 = *(CFTypeRef *)(DerivedStorage + 24);
    if (v4) {
      CFTypeRef v4 = CFRetain(v4);
    }
    *a2 = v4;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigTTMLNodeCopySkippedElementLocalNames(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    CFTypeRef v4 = *(CFTypeRef *)(DerivedStorage + 128);
    if (v4) {
      CFTypeRef v4 = CFRetain(v4);
    }
    *a2 = v4;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

CFStringRef figTTMLNode_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigTTMLNode %p]", a1);
}

uint64_t FigTTMLDocumentWriterCreateFrameRateParameterInserter(uint64_t a1, const void *a2, void *a3)
{
  if (a2 && a3)
  {
    FigTTMLDocumentWriterGetClassID();
    uint64_t v5 = CMDerivedObjectCreate();
    if (!v5)
    {
      FigTTMLDocumentWriterGetCMBaseObject(0);
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
      *uint64_t DerivedStorage = CFRetain(a2);
      DerivedStorage[1] = @"nonDrop";
      *a3 = 0;
    }
    return v5;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void figTTMLDocumentWriterFrameRateParameterInserter_Finalize(uint64_t a1)
{
  FigTTMLDocumentWriterGetCMBaseObject(a1);
  CFAllocatorRef v1 = *(const void **)CMBaseObjectGetDerivedStorage();
  if (v1)
  {
    CFRelease(v1);
  }
}

CFStringRef figTTMLDocumentWriterFrameRateParameterInserter_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"figTTMLDocumentWriterFrameRateParameterInserter[%p]", a1);
}

uint64_t figTTMLDocumentWriterFrameRateParameterInserter_CopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 && a4) {
    return 4294954512;
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t figTTMLDocumentWriterFrameRateParameterInserter_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  FigTTMLDocumentWriterGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2 || !a3) {
    goto LABEL_17;
  }
  uint64_t v6 = DerivedStorage;
  if (!CFEqual(@"timeCodeFrameDuration", a2))
  {
    if (!CFEqual(@"useDropFrame", a2)) {
      return 4294954512;
    }
    CFTypeID v10 = CFGetTypeID(a3);
    if (v10 == CFBooleanGetTypeID())
    {
      uint64_t result = CFBooleanGetValue((CFBooleanRef)a3);
      if (result)
      {
        uint64_t result = 0;
        *(void *)(v6 + 8) = @"dropNTSC";
      }
      return result;
    }
LABEL_17:
    return FigSignalErrorAt();
  }
  CFTypeID v7 = CFGetTypeID(a3);
  if (v7 != CFDictionaryGetTypeID()) {
    goto LABEL_17;
  }
  memset(&v14, 0, sizeof(v14));
  CMTimeMakeFromDictionary(&v14, (CFDictionaryRef)a3);
  CMTime v13 = v14;
  CMTimeMake(&v17, 1, 24);
  int v18 = 24;
  CMTimeMake(&v19, 1, 1);
  CMTimeMake(&v20, 1, 25);
  int v21 = 25;
  CMTimeMake(&v22, 1, 1);
  CMTimeMake(&v23, 1, 30);
  int v24 = 30;
  CMTimeMake(&v25, 1, 1);
  CMTimeMake(&v26, 1, 50);
  int v27 = 50;
  CMTimeMake(&v28, 1, 1);
  CMTimeMake(&v29, 1, 60);
  int v30 = 60;
  CMTimeMake(&v31, 1, 1);
  CMTimeMake(&v32, 1001, 24000);
  int v33 = 24;
  CMTimeMake(&v34, 1000, 1001);
  CMTimeMake(&v35, 1001, 30000);
  int v36 = 30;
  CMTimeMake(&v37, 1000, 1001);
  CMTimeMake(&v38, 1001, 60000);
  int v39 = 60;
  CMTimeMake(&v40, 1000, 1001);
  CMTimeMake(&v41, 1000, 23976);
  int v42 = 24;
  CMTimeMake(&v43, 999, 1000);
  CMTimeMake(&v44, 1000, 29970);
  int v45 = 30;
  CMTimeMake(&v46, 999, 1000);
  CMTimeMake(&v47, 1000, 59940);
  int v48 = 60;
  CMTimeMake(&v49, 999, 1000);
  uint64_t v8 = 0;
  *(_DWORD *)(v6 + 16) = 0;
  uint64_t v9 = MEMORY[0x1E4F1F9F8];
  *(_OWORD *)(v6 + 20) = *MEMORY[0x1E4F1F9F8];
  *(void *)(v6 + 36) = *(void *)(v9 + 16);
  while (1)
  {
    CMTime time1 = v13;
    CMTime time2 = *(CMTime *)((char *)&v17 + v8);
    if (!CMTimeCompare(&time1, &time2)) {
      break;
    }
    v8 += 52;
    if (v8 == 572) {
      return 0;
    }
  }
  *(_DWORD *)(v6 + 16) = *(_DWORD *)((char *)&v17 + v8 + 24);
  long long v12 = *(_OWORD *)((char *)&v19.value + v8);
  *(void *)(v6 + 36) = *(CMTimeEpoch *)((char *)&v19.epoch + v8);
  *(_OWORD *)(v6 + 20) = v12;
  return 0;
}

uint64_t figTTMLDocumentWriterFrameRateParameterInserter_StartElement(uint64_t a1, uint64_t a2)
{
  FigTTMLDocumentWriterGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t started = FigTTMLDocumentWriterStartElement(*(void *)DerivedStorage, a2);
  uint64_t v6 = started;
  if (a2 == 7 && !started)
  {
    if (!*(_DWORD *)(DerivedStorage + 16)) {
      goto LABEL_10;
    }
    CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (const void *)(DerivedStorage + 16));
    uint64_t v6 = FigTTMLDocumentWriterSetAttribute(a1, @"http://www.w3.org/ns/ttml#parameter frameRate", (uint64_t)v7);
    if (v7) {
      CFRelease(v7);
    }
    if (!v6)
    {
LABEL_10:
      if ((*(_DWORD *)(DerivedStorage + 32) & 0x1D) != 1) {
        goto LABEL_11;
      }
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CMTime v12 = *(CMTime *)(DerivedStorage + 20);
      CFDictionaryRef v9 = CMTimeCopyAsDictionary(&v12, v8);
      uint64_t v6 = FigTTMLDocumentWriterSetAttribute(a1, @"http://www.w3.org/ns/ttml#parameter frameRateMultiplier", (uint64_t)v9);
      if (v9) {
        CFRelease(v9);
      }
      if (!v6)
      {
LABEL_11:
        CFTypeID v10 = *(__CFString **)(DerivedStorage + 8);
        if (v10 == @"nonDrop") {
          return 0;
        }
        else {
          return FigTTMLDocumentWriterSetAttribute(a1, @"http://www.w3.org/ns/ttml#parameter dropMode", (uint64_t)v10);
        }
      }
    }
  }
  return v6;
}

uint64_t figTTMLDocumentWriterFrameRateParameterInserter_EndElement(uint64_t a1)
{
  FigTTMLDocumentWriterGetCMBaseObject(a1);
  uint64_t v1 = *(void *)CMBaseObjectGetDerivedStorage();

  return FigTTMLDocumentWriterEndElement(v1);
}

uint64_t figTTMLDocumentWriterFrameRateParameterInserter_AddCaptionData(uint64_t a1, uint64_t a2)
{
  FigTTMLDocumentWriterGetCMBaseObject(a1);
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage();

  return FigTTMLDocumentWriterAddCaptionData(v3, a2);
}

uint64_t figTTMLDocumentWriterFrameRateParameterInserter_SetAttribute(uint64_t a1, uint64_t a2, uint64_t a3)
{
  FigTTMLDocumentWriterGetCMBaseObject(a1);
  uint64_t v5 = *(void *)CMBaseObjectGetDerivedStorage();

  return FigTTMLDocumentWriterSetAttribute(v5, a2, a3);
}

uint64_t figTTMLDocumentWriterFrameRateParameterInserter_Flush(uint64_t a1)
{
  FigTTMLDocumentWriterGetCMBaseObject(a1);
  uint64_t v1 = *(void *)CMBaseObjectGetDerivedStorage();

  return FigTTMLDocumentWriterFlush(v1);
}

uint64_t figtimebase_synchronizeToMomentInternal(OpaqueCMTimebase *a1, OpaqueCMTimebase *a2, uint64_t a3)
{
  memset(&v20, 0, sizeof(v20));
  if ((*(unsigned char *)(a3 + 52) & 1) == 0 || (*(unsigned char *)(a3 + 28) & 1) == 0) {
    return 4294954944;
  }
  CMClockOrTimebaseRef v5 = CMTimebaseCopySource(a1);
  uint64_t v6 = v5;
  if (a2)
  {
    CMClockOrTimebaseRef v7 = CMTimebaseCopySource(a2);
    CFAllocatorRef v8 = v7;
  }
  else
  {
    CFAllocatorRef v8 = 0;
    CMClockOrTimebaseRef v7 = v5;
  }
  double v9 = *(double *)(a3 + 64);
  CMClockRef HostTimeClock = CMClockGetHostTimeClock();
  double v11 = v9 * CMSyncGetRelativeRate(HostTimeClock, v7);
  if (!a2 || (uint64_t v12 = CMTimebaseSetRate(a2, v11), !v12))
  {
    if (*(unsigned char *)(a3 + 4) & 8) != 0 && (*(unsigned char *)(a3 + 108) & 1) != 0 && (*(unsigned char *)(a3 + 84))
    {
      CMTime v13 = (CMTime *)(a3 + 96);
      *(_OWORD *)&v19.CMTimeValue value = *(_OWORD *)(a3 + 72);
      CMTimeEpoch v14 = *(void *)(a3 + 88);
    }
    else
    {
      CMTime v13 = (CMTime *)(a3 + 40);
      *(_OWORD *)&v19.CMTimeValue value = *(_OWORD *)(a3 + 16);
      CMTimeEpoch v14 = *(void *)(a3 + 32);
    }
    v19.CMTimeEpoch epoch = v14;
    CMClockRef v15 = CMClockGetHostTimeClock();
    CMTime time = *v13;
    CMSyncConvertTime(&v20, &time, v15, v6);
    CMTime time = v19;
    uint64_t v12 = CMTimebaseSetRateAndAnchorTimeWithFlags();
  }
  uint64_t v16 = v12;
  if (v6) {
    CFRelease(v6);
  }
  if (v8) {
    CFRelease(v8);
  }
  return v16;
}

uint64_t FigTimebaseGetSyncMoment2(OpaqueCMTimebase *a1, uint64_t a2)
{
  return figtimebase_getSyncMomentInternal(a1, 1, a2);
}

uint64_t figtimebase_getSyncMomentInternal(OpaqueCMTimebase *a1, int a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)&v26.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v3 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  v26.CMTimeEpoch epoch = v3;
  *(_OWORD *)&outOfClockOrTimebaseAnchorTime.CMTimeValue value = *(_OWORD *)&v26.value;
  outOfClockOrTimebaseAnchorTime.CMTimeEpoch epoch = v3;
  if (a1)
  {
    long long v19 = *(_OWORD *)&v26.value;
    CMClockRef v7 = CMTimebaseCopyUltimateSourceClock(a1);
    if (v7)
    {
      CMClockRef v8 = v7;
      *(void *)(a3 + 112) = 0;
      *(_OWORD *)(a3 + 64) = 0u;
      *(_OWORD *)(a3 + 80) = 0u;
      *(_OWORD *)(a3 + 32) = 0u;
      *(_OWORD *)(a3 + 48) = 0u;
      *(_OWORD *)a3 = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      *(_OWORD *)(a3 + 96) = 0u;
      *(_DWORD *)a3 = 120;
      *(Float64 *)(a3 + 8) = CMTimebaseGetEffectiveRate(a1);
      *(_DWORD *)(a3 + 4) = 0;
      CMClockRef HostTimeClock = CMClockGetHostTimeClock();
      CMClockGetTime(&v26, HostTimeClock);
      CMClockRef v10 = CMClockGetHostTimeClock();
      CMTime time = v26;
      CMSyncConvertTime(&v24, &time, v10, a1);
      *(CMTime *)(a3 + 16) = v24;
      *(CMTime *)(a3 + 40) = v26;
      CMClockRef v11 = CMClockGetHostTimeClock();
      *(Float64 *)(a3 + 64) = CMSyncGetRelativeRate(v8, v11);
      *(_OWORD *)(a3 + 72) = v19;
      *(void *)(a3 + 88) = v3;
      *(_OWORD *)(a3 + 96) = v19;
      *(void *)(a3 + 112) = v3;
      if (!a2) {
        goto LABEL_15;
      }
      CMClockOrTimebaseRef v12 = CMTimebaseCopySource(a1);
      if (!v12) {
        goto LABEL_15;
      }
      CMTime v13 = v12;
      Float64 v21 = 0.0;
      outRelativeFloat64 Rate = 0.0;
      memset(&time, 0, sizeof(time));
      CMSyncGetRelativeRateAndAnchorTime(a1, v8, &outRelativeRate, 0, 0);
      CMSyncGetRelativeRateAndAnchorTime(a1, v13, 0, &outOfClockOrTimebaseAnchorTime, &time);
      CMSyncGetRelativeRateAndAnchorTime(v13, v8, &v21, 0, 0);
      CMSyncGetTime(&v24, v13);
      if (outRelativeRate != 0.0)
      {
        double v14 = v21;
        if (v21 > 0.0)
        {
          CMTime time1 = time;
          CMTime time2 = v24;
          if (CMTimeCompare(&time1, &time2) > 0) {
            goto LABEL_11;
          }
          double v14 = v21;
        }
        if (v14 < 0.0)
        {
          CMTime time1 = time;
          CMTime time2 = v24;
          if (CMTimeCompare(&time1, &time2) < 0)
          {
LABEL_11:
            CMClockRef v15 = CMClockGetHostTimeClock();
            CMTime time2 = time;
            CMSyncConvertTime(&time1, &time2, v13, v15);
            time2.CMTimeValue value = time1.value;
            time2.CMTimeScale timescale = time1.timescale;
            if (outOfClockOrTimebaseAnchorTime.flags)
            {
              CMTimeFlags flags = time1.flags;
              if (time1.flags)
              {
                CMTimeEpoch epoch = time1.epoch;
                *(CMTime *)(a3 + 72) = outOfClockOrTimebaseAnchorTime;
                *(void *)(a3 + 96) = time2.value;
                *(_DWORD *)(a3 + 104) = time2.timescale;
                *(_DWORD *)(a3 + 108) = flags;
                *(void *)(a3 + 112) = epoch;
                *(_DWORD *)(a3 + 4) |= 8u;
              }
            }
          }
        }
      }
      CFRelease(v13);
LABEL_15:
      CFRelease(v8);
      return 0;
    }
  }

  return FigSignalErrorAt();
}

void figSyncMomentSource_UpdateToCurrentTimebaseRate(uint64_t a1)
{
  EffectiveFloat64 Rate = CMTimebaseGetEffectiveRate(*(CMTimebaseRef *)(a1 + 64));
  if (EffectiveRate == 0.0 && *(double *)(a1 + 72) != 0.0)
  {
    CMTimeEpoch v3 = *(NSObject **)(a1 + 224);
    dispatch_time_t v4 = -1;
    uint64_t v5 = -1;
    uint64_t v6 = 0;
LABEL_7:
    dispatch_source_set_timer(v3, v4, v5, v6);
    goto LABEL_8;
  }
  if (EffectiveRate != 0.0 && *(double *)(a1 + 72) == 0.0)
  {
    CMClockRef v7 = *(NSObject **)(a1 + 224);
    dispatch_time_t v4 = dispatch_time(0, 1000000000);
    CMTimeEpoch v3 = v7;
    uint64_t v5 = 1000000000;
    uint64_t v6 = 10000000;
    goto LABEL_7;
  }
LABEL_8:
  *(double *)(a1 + 72) = EffectiveRate;
}

__n128 figSyncMomentSource_getSyncMoment(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v16 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  __n128 v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  if (!figtimebase_getSyncMomentInternal(*(OpaqueCMTimebase **)(a1 + 64), 1, (uint64_t)&v9))
  {
    DWORD1(v9) |= *(_DWORD *)(a1 + 232) & a2;
    long long v7 = v14;
    *(_OWORD *)(a3 + 64) = v13;
    *(_OWORD *)(a3 + 80) = v7;
    *(_OWORD *)(a3 + 96) = v15;
    *(void *)(a3 + 112) = v16;
    long long v8 = v12;
    *(_OWORD *)(a3 + 32) = v11;
    *(_OWORD *)(a3 + 48) = v8;
    __n128 result = v10;
    *(_OWORD *)a3 = v9;
    *(__n128 *)(a3 + 16) = result;
  }
  return result;
}

uint64_t FigSyncMomentSourceChangeFlagsMask(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  if (!a1) {
    return FigSignalErrorAt();
  }
  if (a4) {
    *a4 = *(_DWORD *)(a1 + 232);
  }
  *(_DWORD *)(a1 + 232) = *(_DWORD *)(a1 + 232) & ~a2 | a3 & a2;
  return 0;
}

uint64_t FigSyncMomentSourceGetTypeID()
{
  return sFigSyncMomentSourceID;
}

uint64_t figSyncMomentSource_registerClass()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigSyncMomentSourceID = result;
  return result;
}

uint64_t FigSyncMomentSourceCreateWithDispatchQueueAndDestructor(uint64_t a1, uint64_t a2, void (*a3)(uint64_t), const void *a4, NSObject *a5, uint64_t *a6)
{
  return figSyncMomentSource_createInternal(a1, 0, a2, a3, a4, a5, a6);
}

uint64_t figSyncMomentSource_createInternal(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t), const void *a5, NSObject *a6, uint64_t *a7)
{
  uint64_t Instance = 0;
  if (a1 | a2
    && a5
    && a7
    && a6
    && (MEMORY[0x19970EE10](&FigSyncMomentSourceGetTypeID_sRegisterFigSyncMomentSourceOnce, figSyncMomentSource_registerClass), (Instance = _CFRuntimeCreateInstance()) != 0)&& (uint64_t v15 = FigCFWeakReferenceHolderCreateWithReferencedObject(), (*(void *)(Instance + 16) = v15) != 0)&& (*(_DWORD *)(Instance + 232) = -1, v16 = FigReentrantMutexCreate(), (*(void *)(Instance + 24) = v16) != 0))
  {
    MEMORY[0x19970E290]();
    uint64_t v17 = *(void *)(Instance + 24);
    *(void *)(Instance + 32) = a1;
    *(void *)(Instance + 40) = a2;
    *(void *)(Instance + 48) = a3;
    *(void *)(Instance + 56) = a4;
    *(void *)(Instance + 80) = FigDispatchQueueCreateWithPriority();
    *(void *)(Instance + 216) = a6;
    dispatch_retain(a6);
    int v18 = *(NSObject **)(Instance + 80);
    if (v18)
    {
      long long v19 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v18);
      *(void *)(Instance + 224) = v19;
      if (v19)
      {
        dispatch_source_set_timer(v19, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        dispatch_set_context(*(dispatch_object_t *)(Instance + 224), *(void **)(Instance + 16));
        CFRetain(*(CFTypeRef *)(Instance + 16));
        dispatch_set_finalizer_f(*(dispatch_object_t *)(Instance + 224), (dispatch_function_t)figSyncMomentSource_QueueTimerFinalizer);
        dispatch_source_set_event_handler_f(*(dispatch_source_t *)(Instance + 224), (dispatch_function_t)figSyncMomentSource_QueueTimerCallback);
        *(void *)(Instance + 240) = voucher_copy();
        dispatch_resume(*(dispatch_object_t *)(Instance + 224));
        goto LABEL_12;
      }
    }
    uint64_t v20 = FigSignalErrorAt();
    if (!v20)
    {
LABEL_12:
      FigSyncMomentSourceSetTimebase((void *)Instance, a5);
      uint64_t v21 = 0;
      *a7 = Instance;
      uint64_t Instance = 0;
      if (!v17) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
    uint64_t v21 = v20;
    if (v17) {
LABEL_13:
    }
      MEMORY[0x19970E2B0](v17);
  }
  else
  {
    uint64_t v21 = FigSignalErrorAt();
    if (a4) {
      a4(a3);
    }
  }
LABEL_14:
  if (Instance) {
    CFRelease((CFTypeRef)Instance);
  }
  return v21;
}

uint64_t FigSyncMomentSourceCreateWithDispatchQueue(uint64_t a1, uint64_t a2, const void *a3, NSObject *a4, uint64_t *a5)
{
  return figSyncMomentSource_createInternal(a1, 0, a2, 0, a3, a4, a5);
}

uint64_t FigSyncMomentSourceCreateWithDispatchQueueAndDestructor2(uint64_t a1, uint64_t a2, void (*a3)(uint64_t), const void *a4, NSObject *a5, uint64_t *a6)
{
  return figSyncMomentSource_createInternal(0, a1, a2, a3, a4, a5, a6);
}

__n128 figSyncMomentSource_updatePendingMoment(__n128 *a1)
{
  unint64_t v1 = a1->n128_u64[0];
  int v2 = a1->n128_i32[3];
  __n128 v9 = a1[5];
  __n128 v10 = a1[6];
  __n128 v11 = a1[7];
  __n128 v5 = a1[1];
  __n128 v6 = a1[2];
  __n128 v7 = a1[3];
  __n128 v8 = a1[4];
  int v3 = *(unsigned __int8 *)(a1->n128_u64[0] + 208);
  if (*(unsigned char *)(a1->n128_u64[0] + 208)) {
    v2 |= *(_DWORD *)(v1 + 92);
  }
  *(_DWORD *)(v1 + 88) = a1->n128_u32[2];
  *(_DWORD *)(v1 + 92) = v2;
  *(__n128 *)(v1 + 160) = v9;
  *(__n128 *)(v1 + 176) = v10;
  *(__n128 *)(v1 + 192) = v11;
  *(__n128 *)(v1 + 96) = v5;
  *(__n128 *)(v1 + 112) = v6;
  __n128 result = v8;
  *(__n128 *)(v1 + 128) = v7;
  *(__n128 *)(v1 + 144) = v8;
  a1[8].n128_u8[0] = v3 == 0;
  *(unsigned char *)(v1 + 208) = 1;
  return result;
}

void figSyncMomentSource_sendMomentInternal(uint64_t a1)
{
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  memset(v14, 0, sizeof(v14));
  long long v12 = 0u;
  uint64_t context = a1;
  dispatch_sync_f(*(dispatch_queue_t *)(a1 + 80), &context, (dispatch_function_t)figSyncMomentSource_retrievePendingMoment);
  if (!DWORD2(v18))
  {
    int v2 = *(void (**)(void, long long *))(a1 + 40);
    if (v2) {
      v2(*(void *)(a1 + 48), &v12);
    }
    int v3 = *(void (**)(void, _DWORD *))(a1 + 32);
    if (v3)
    {
      uint64_t v5 = *((void *)&v12 + 1);
      v4[0] = 72;
      v4[1] = DWORD1(v12) & 0xFFFFFFF7;
      long long v6 = v13;
      uint64_t v7 = *(void *)&v14[0];
      long long v8 = *(_OWORD *)((char *)v14 + 8);
      uint64_t v9 = *((void *)&v14[1] + 1);
      uint64_t v10 = v15;
      v3(*(void *)(a1 + 48), v4);
    }
  }
  CFRelease((CFTypeRef)a1);
}

uint64_t figSyncMomentSource_retrievePendingMoment(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*(unsigned char *)(*a1 + 208))
  {
    uint64_t result = 0;
    long long v4 = *(_OWORD *)(v2 + 88);
    long long v5 = *(_OWORD *)(v2 + 104);
    long long v6 = *(_OWORD *)(v2 + 120);
    *(_OWORD *)(a1 + 7) = *(_OWORD *)(v2 + 136);
    *(_OWORD *)(a1 + 5) = v6;
    *(_OWORD *)(a1 + 3) = v5;
    *(_OWORD *)(a1 + 1) = v4;
    long long v7 = *(_OWORD *)(v2 + 152);
    long long v8 = *(_OWORD *)(v2 + 168);
    long long v9 = *(_OWORD *)(v2 + 184);
    a1[15] = *(void *)(v2 + 200);
    *(_OWORD *)(a1 + 13) = v9;
    *(_OWORD *)(a1 + 11) = v8;
    *(_OWORD *)(a1 + 9) = v7;
    *(unsigned char *)(v2 + 208) = 0;
  }
  else
  {
    uint64_t result = FigSignalErrorAt();
  }
  *((_DWORD *)a1 + 32) = result;
  return result;
}

double figSyncMomentSource_Init(uint64_t a1)
{
  *(void *)(a1 + 240) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

uint64_t figSyncMomentSource_Finalize(uint64_t a1)
{
  *(unsigned char *)(a1 + 236) = 1;
  if (*(void *)(a1 + 64))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    CFRelease(*(CFTypeRef *)(a1 + 64));
  }
  uint64_t v2 = *(void **)(a1 + 224);
  if (v2)
  {
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 80), v2, (dispatch_function_t)figSyncMomentSource_DestroyPeriodicTimer);
    *(void *)(a1 + 224) = 0;
  }
  int v3 = *(const void **)(a1 + 16);
  if (v3) {
    CFRelease(v3);
  }
  long long v4 = *(NSObject **)(a1 + 80);
  if (v4)
  {
    dispatch_release(v4);
    *(void *)(a1 + 80) = 0;
  }
  long long v5 = *(NSObject **)(a1 + 216);
  if (v5)
  {
    dispatch_release(v5);
    *(void *)(a1 + 216) = 0;
  }
  long long v6 = *(void **)(a1 + 240);
  if (v6)
  {
    os_release(v6);
    *(void *)(a1 + 240) = 0;
  }
  long long v7 = *(void (**)(void))(a1 + 56);
  if (v7) {
    v7(*(void *)(a1 + 48));
  }
  uint64_t result = FigSimpleMutexDestroy();
  *(void *)(a1 + 24) = 0;
  return result;
}

__CFString *figSyncMomentSource_CopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  long long v4 = Mutable;
  long long v5 = "(INVALID) ";
  if (!*(unsigned char *)(a1 + 236)) {
    long long v5 = "";
  }
  long long v6 = "YES";
  if (!*(unsigned char *)(a1 + 208)) {
    long long v6 = "NO";
  }
  CFStringAppendFormat(Mutable, 0, @"FigSyncMomentSource: %p %stimebase: %p timebaseEffectiveRate: %f pendingQueue: %p queueTimer: %p signallingQueue: %p momentPending: %s flagsMask: %x callbacks: %p %p refcon: %p\n", a1, v5, *(void *)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 224), *(void *)(a1 + 216), v6, *(unsigned int *)(a1 + 232), *(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48));
  return v4;
}

void figSyncMomentSource_DestroyPeriodicTimer(NSObject *a1)
{
  if (a1)
  {
    dispatch_source_cancel(a1);
    dispatch_release(a1);
  }
}

void figSyncMomentSource_QueueTimerCallback()
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v0)
  {
    uint64_t v1 = v0;
    if (!*(unsigned char *)(v0 + 236))
    {
      uint64_t v10 = 0;
      long long v8 = 0u;
      long long v9 = 0u;
      long long v6 = 0u;
      long long v7 = 0u;
      long long v4 = 0u;
      long long v5 = 0u;
      long long v3 = 0u;
      os_retain(*(void **)(v0 + 240));
      voucher_adopt();
      long long v19 = 0u;
      memset(v20, 0, sizeof(v20));
      FigDebugGetAdoptedVoucherProcessIDAndUUIDString();
      MEMORY[0x19970E290](*(void *)(v1 + 24));
      uint64_t v18 = 0;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      long long v12 = 0u;
      long long v13 = 0u;
      long long v11 = 0u;
      if (!figtimebase_getSyncMomentInternal(*(OpaqueCMTimebase **)(v1 + 64), 1, (uint64_t)&v11))
      {
        long long v7 = v15;
        long long v8 = v16;
        long long v9 = v17;
        uint64_t v10 = v18;
        long long v3 = v11;
        long long v4 = v12;
        long long v5 = v13;
        long long v6 = v14;
      }
      MEMORY[0x19970E2B0](*(void *)(v1 + 24));
      long long v15 = v7;
      long long v16 = v8;
      long long v17 = v9;
      uint64_t v18 = v10;
      long long v11 = v3;
      long long v12 = v4;
      long long v13 = v5;
      long long v14 = v6;
      figSyncMomentSource_SendMoment((dispatch_queue_t *)v1, (uint64_t)&v11, 1);
      CFAllocatorRef v2 = (void *)voucher_adopt();
      os_release(v2);
    }
    CFRelease((CFTypeRef)v1);
  }
}

uint64_t registerLayerSynchronizerType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sLayerSynchronizerID = result;
  return result;
}

uint64_t FigLayerSynchronizerCreate(void *a1)
{
  FigNote_AllowInternalDefaultLogs();
  fig_note_initialize_category_with_default_work_cf();
  fig_note_initialize_category_with_default_work_cf();
  if (!a1) {
    goto LABEL_8;
  }
  if (FigLayerSynchronizerGetTypeID_sRegisterLayerSynchronizerTypeOnce != -1) {
    dispatch_once_f(&FigLayerSynchronizerGetTypeID_sRegisterLayerSynchronizerTypeOnce, 0, (dispatch_function_t)registerLayerSynchronizerType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    long long v3 = (void *)Instance;
    *(unsigned char *)(Instance + 88) = 1;
    uint64_t v4 = FigReentrantMutexCreate();
    v3[3] = v4;
    if (v4)
    {
      uint64_t result = 0;
      *a1 = v3;
    }
    else
    {
      CFRelease(v3);
      return 4294954935;
    }
  }
  else
  {
LABEL_8:
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t FigLayerSynchronizerSynchronizeToTimebaseWithDeferredTransaction(const void *a1, const void *a2, int a3, uint64_t a4, const void *a5)
{
  if (!a1 || !a2) {
    return 0;
  }
  uint64_t v10 = malloc_type_calloc(1uLL, 0x60uLL, 0x102004037358F12uLL);
  if (v10)
  {
    uint64_t v11 = (uint64_t)v10;
    *uint64_t v10 = a1;
    CFRetain(a1);
    *(void *)(v11 + 8) = a2;
    CFRetain(a2);
    *(_DWORD *)(v11 + 88) = a3;
    return FigDeferredTransactionAppendChangeWithCallback(a5, 1, a4, v11, (uint64_t)figlayersync_disposeSetLayerTimingContext, (uint64_t)figlayersync_copyDescriptionSetLayerTimingContext, (uint64_t)figlayersync_setLayerTimingToMomentContext);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void figlayersync_disposeSetLayerTimingContext(const void **a1)
{
  CFAllocatorRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  long long v3 = a1[1];
  if (v3) {
    CFRelease(v3);
  }

  free(a1);
}

__CFString *figlayersync_copyDescriptionSetLayerTimingContext()
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"Set layer timing");
  uint64_t v1 = (const void *)FigCFCopyCompactDescription();
  CFStringAppendFormat(Mutable, 0, @"\nwith: %@", v1);
  if (v1) {
    CFRelease(v1);
  }
  return Mutable;
}

void figlayersync_setLayerTimingToMomentContext(uint64_t a1)
{
  CFAllocatorRef v2 = *(OpaqueCMTimebase **)(a1 + 8);
  if (!v2 || (FigTimebaseGetSyncMoment(v2, a1 + 16), !v3))
  {
    uint64_t v4 = *(void *)a1;
    int v5 = *(_DWORD *)(a1 + 88);
    figlayersync_synchronizeToMoment(v4, a1 + 16, v5);
  }
}

uint64_t FigLayerSynchronizerSynchronizeToMomentWithDeferredTransaction(const void *a1, uint64_t a2, int a3, uint64_t a4, const void *a5)
{
  if (!a1 || !a2) {
    return 0;
  }
  uint64_t v10 = malloc_type_calloc(1uLL, 0x60uLL, 0x102004037358F12uLL);
  if (v10)
  {
    uint64_t v11 = (uint64_t)v10;
    *uint64_t v10 = a1;
    CFRetain(a1);
    *(_OWORD *)(v11 + 16) = *(_OWORD *)a2;
    long long v12 = *(_OWORD *)(a2 + 16);
    long long v13 = *(_OWORD *)(a2 + 32);
    long long v14 = *(_OWORD *)(a2 + 48);
    *(void *)(v11 + 80) = *(void *)(a2 + 64);
    *(_OWORD *)(v11 + 48) = v13;
    *(_OWORD *)(v11 + 64) = v14;
    *(_OWORD *)(v11 + 32) = v12;
    *(_DWORD *)(v11 + 88) = a3;
    return FigDeferredTransactionAppendChangeWithCallback(a5, 1, a4, v11, (uint64_t)figlayersync_disposeSetLayerTimingContext, (uint64_t)figlayersync_copyDescriptionSetLayerTimingContext, (uint64_t)figlayersync_setLayerTimingToMomentContext);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigLayerSynchronizerSetLayerArraysWithDeferredTransaction(uint64_t a1, const __CFArray *a2, const __CFArray *a3, const void *a4)
{
  if (dword_1EB2AE9A8)
  {
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return figlayersync_setLayerArrays(a1, a2, a3, 0, a4);
}

uint64_t figlayersync_setLayerArrays(uint64_t a1, const __CFArray *a2, const __CFArray *a3, char a4, const void *a5)
{
  if (a1)
  {
    uint64_t v10 = (void *)MEMORY[0x199711A30]();
    MEMORY[0x19970E290](*(void *)(a1 + 24));
    if (*(unsigned char *)(a1 + 16))
    {
      CFArrayRef Mutable = 0;
      long long v12 = 0;
      CFIndex Count = 0;
      CFArrayRef v14 = 0;
      uint64_t v15 = 4294954934;
LABEL_82:
      MEMORY[0x19970E2B0](*(void *)(a1 + 24));
      if ((a4 & 2) != 0 && v14)
      {
        [MEMORY[0x1E4F39CF8] begin];
        if (!pthread_main_np()) {
          [MEMORY[0x1E4F39CF8] activateBackground:1];
        }
        [MEMORY[0x1E4F39CF8] setValue:*MEMORY[0x1E4F1CFD0] forKey:*MEMORY[0x1E4F3A5A8]];
        if (Count >= 1)
        {
          for (CFIndex i = 0; i != Count; ++i)
          {
            if (fabs(v12[i]) != INFINITY)
            {
              CFNumberRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v14, i);
              [ValueAtIndex duration];
              if (v48 == v12[i]) {
                [ValueAtIndex setDuration:INFINITY];
              }
            }
          }
        }
        CFRelease(v14);
        [MEMORY[0x1E4F39CF8] commit];
        if (!Mutable) {
          goto LABEL_99;
        }
      }
      else
      {
        if (Mutable && CFArrayGetCount(Mutable))
        {
          long long v61 = *MEMORY[0x1E4F1FA10];
          uint64_t v62 = *(void *)(MEMORY[0x1E4F1FA10] + 16);
          FPSupport_AppendDeferredTransactionChangeForSettingDurationOnLayers(a5, &v61, Mutable, (uint64_t)"figlayersync_setLayerArrays");
        }
        FPSupport_AppendDeferredTransactionChangeToRelease(a5, (uint64_t)v14, (uint64_t)"figlayersync_setLayerArrays");
        if (!Mutable) {
          goto LABEL_99;
        }
      }
      CFRelease(Mutable);
LABEL_99:
      free(v12);
      return v15;
    }
    char v60 = a4;
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (!Mutable)
    {
      long long v12 = 0;
      CFIndex Count = 0;
      CFArrayRef v14 = 0;
      goto LABEL_27;
    }
    CFArrayRef v14 = *(const __CFArray **)(a1 + 64);
    *(void *)(a1 + 64) = 0;
    if (v14) {
      CFIndex Count = CFArrayGetCount(v14);
    }
    else {
      CFIndex Count = 0;
    }
    long long v12 = *(double **)(a1 + 72);
    *(void *)(a1 + 72) = 0;
    *(unsigned char *)(a1 + 89) = 0;
    long long v17 = *(void **)(a1 + 40);
    if (v17)
    {
      *(void *)(a1 + 40) = 0;
      free(v17);
    }
    uint64_t v18 = *(void **)(a1 + 48);
    if (v18)
    {
      *(void *)(a1 + 48) = 0;
      free(v18);
    }
    long long v19 = *(void **)(a1 + 56);
    if (v19)
    {
      *(void *)(a1 + 56) = 0;
      free(v19);
    }
    uint64_t v20 = *(void **)(a1 + 80);
    if (v20)
    {
      *(void *)(a1 + 80) = 0;
      free(v20);
    }
    if (!((unint64_t)a2 | (unint64_t)a3)) {
      goto LABEL_80;
    }
    uint64_t v57 = a5;
    if (a2)
    {
      CFIndex v21 = CFArrayGetCount(a2);
      if (a3)
      {
LABEL_20:
        CFIndex v22 = CFArrayGetCount(a3);
LABEL_23:
        if (!(v22 + v21))
        {
          uint64_t v15 = 0;
          a5 = v57;
          goto LABEL_81;
        }
        uint64_t size = v22 + v21;
        CMTime v23 = malloc_type_calloc(1uLL, v22 + v21, 0xC6E25BC7uLL);
        *(void *)(a1 + 80) = v23;
        a5 = v57;
        double v52 = v23;
        if (!v23)
        {
LABEL_27:
          uint64_t v15 = 4294954935;
LABEL_81:
          a4 = v60;
          goto LABEL_82;
        }
        if (!((unint64_t)a2 | (unint64_t)a3))
        {
          *(void *)(a1 + 64) = 0;
          goto LABEL_27;
        }
        if (a2) {
          CFIndex v24 = CFArrayGetCount(a2);
        }
        else {
          CFIndex v24 = 0;
        }
        CFIndex v56 = v24;
        if (a3)
        {
          CFIndex v25 = CFArrayGetCount(a3);
          CFIndex v24 = v56;
        }
        else
        {
          CFIndex v25 = 0;
        }
        if (v25 + v24 == 1)
        {
          if (v24 < 1)
          {
            MutableCFArrayRef Copy = CFArrayCreateMutableCopy(v16, 0, a3);
            *double v52 = 0;
          }
          else
          {
            MutableCFArrayRef Copy = CFArrayCreateMutableCopy(v16, 0, a2);
            *double v52 = 1;
          }
          a4 = v60;
        }
        else
        {
          CFArrayRef v51 = Mutable;
          int v27 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
          uint64_t capacity = v25 + v24;
          theArray = CFArrayCreateMutable(v16, v25 + v24, MEMORY[0x1E4F1D510]);
          CFMutableArrayRef v28 = CFArrayCreateMutable(v16, capacity, v27);
          if (capacity >= 1 && theArray)
          {
            CMTime v29 = v28;
            uint64_t v50 = v10;
            CFIndex v30 = 0;
            double v54 = (const void *)*MEMORY[0x1E4F1CFC8];
            __int16 v53 = (const void *)*MEMORY[0x1E4F1CFD0];
            do
            {
              LayerFrom2Arrays = (void *)figlayersync_getLayerFrom2Arrays(a2, a3, v30);
              CFIndex v32 = 0;
              if (v30)
              {
                do
                {
                  int v33 = (void *)figlayersync_getLayerFrom2Arrays(a2, a3, v32);
                  while (1)
                  {
                    int v33 = (void *)[v33 superlayer];
                    if (!v33) {
                      break;
                    }
                    if (v33 == LayerFrom2Arrays) {
                      goto LABEL_48;
                    }
                  }
                  ++v32;
                }
                while (v32 != v30);
                CFIndex v32 = v30;
              }
LABEL_48:
              CFArrayInsertValueAtIndex(theArray, v32, LayerFrom2Arrays);
              if (v30 >= v56) {
                CMTime v34 = v54;
              }
              else {
                CMTime v34 = v53;
              }
              CFArrayInsertValueAtIndex(v29, v32, v34);
              ++v30;
            }
            while (v30 != capacity);
            CFIndex v35 = 0;
            uint64_t v10 = v50;
            do
            {
              BOOL v36 = v54 == CFArrayGetValueAtIndex(v29, v35);
              CFMutableArrayRef v28 = v29;
              char v37 = !v36;
              v52[v35++] = v37;
            }
            while (capacity != v35);
          }
          if (v28) {
            CFRelease(v28);
          }
          a5 = v57;
          a4 = v60;
          MutableCFArrayRef Copy = theArray;
          CFArrayRef Mutable = v51;
        }
        *(void *)(a1 + 64) = MutableCopy;
        if (!MutableCopy) {
          goto LABEL_101;
        }
        CMTime v38 = malloc_type_calloc(8uLL, size, 0x2C0FA82BuLL);
        *(void *)(a1 + 40) = v38;
        if (!v38
          || (int v39 = malloc_type_calloc(8uLL, size, 0x443F37CAuLL), (*(void *)(a1 + 48) = v39) == 0)
          || (CMTime v40 = malloc_type_calloc(8uLL, size, 0x25C788D4uLL), (*(void *)(a1 + 56) = v40) == 0)
          || (CMTime v41 = malloc_type_calloc(8uLL, size, 0xF316400EuLL), (*(void *)(a1 + 72) = v41) == 0))
        {
LABEL_101:
          uint64_t v15 = 4294954935;
          goto LABEL_82;
        }
        if (size >= 1) {
          memset_pattern16(v41, &unk_194992D10, 8 * size);
        }
        if (Count < 1)
        {
          uint64_t v15 = 0;
          goto LABEL_82;
        }
        for (CFIndex j = 0; j != Count; ++j)
        {
          if (fabs(v12[j]) != INFINITY)
          {
            CMTime v43 = v10;
            CMTime v44 = CFArrayGetValueAtIndex(v14, j);
            if (size < 1)
            {
LABEL_76:
              CFArrayAppendValue(Mutable, v44);
            }
            else
            {
              CFIndex v45 = 0;
              while (v44 != CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), v45))
              {
                if (size == ++v45) {
                  goto LABEL_76;
                }
              }
              *(double *)(*(void *)(a1 + 72) + 8 * v45) = v12[j];
              v12[j] = INFINITY;
            }
            uint64_t v10 = v43;
            a5 = v57;
          }
        }
LABEL_80:
        uint64_t v15 = 0;
        goto LABEL_81;
      }
    }
    else
    {
      CFIndex v21 = 0;
      if (a3) {
        goto LABEL_20;
      }
    }
    CFIndex v22 = 0;
    goto LABEL_23;
  }
  return 4294954936;
}

uint64_t FigLayerSynchronizerSetLayerArrayWithDeferredTransaction(uint64_t a1, const __CFArray *a2, const void *a3)
{
  if (dword_1EB2AE9A8)
  {
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return figlayersync_setLayerArrays(a1, 0, a2, 0, a3);
}

uint64_t FigLayerSynchronizerSetCompensateForDisplayLatency(uint64_t a1, char a2)
{
  if (dword_1EB2AE9A8)
  {
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  *(unsigned char *)(a1 + 88) = a2;
  *(unsigned char *)(a1 + 89) = 0;
  return 0;
}

uint64_t FigLayerSynchronizerSetLayerArray(uint64_t a1, const __CFArray *a2)
{
  if (dword_1EB2AE9A8)
  {
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return figlayersync_setLayerArrays(a1, 0, a2, 2, 0);
}

uint64_t FigLayerSynchronizerSynchronizeToMoment(uint64_t a1, uint64_t a2, char a3)
{
  return figlayersync_synchronizeToMoment(a1, a2, a3 | 2u);
}

uint64_t figlayersync_synchronizeToMoment(uint64_t a1, uint64_t a2, char a3)
{
  if (!a1) {
    return 4294954936;
  }
  uint64_t v6 = *(void *)(a1 + 24);
  long long v7 = (void *)MEMORY[0x199711A30]();
  MEMORY[0x19970E290](*(void *)(a1 + 24));
  if (*(unsigned char *)(a1 + 16))
  {
    if (*(void *)(a1 + 24) == v6) {
      MEMORY[0x19970E2B0](v6);
    }
    uint64_t v8 = 4294954934;
  }
  else
  {
    if ((a3 & 2) != 0)
    {
      [MEMORY[0x1E4F39CF8] begin];
      if (!pthread_main_np()) {
        [MEMORY[0x1E4F39CF8] activateBackground:1];
      }
      figlayersync_setLayerTimingToMoment(a1, a2);
      MEMORY[0x19970E2B0](*(void *)(a1 + 24));
      [MEMORY[0x1E4F39CF8] commit];
      [MEMORY[0x1E4F39CF8] flush];
    }
    else
    {
      figlayersync_setLayerTimingToMoment(a1, a2);
      MEMORY[0x19970E2B0](*(void *)(a1 + 24));
    }
    uint64_t v8 = 0;
  }
  return v8;
}

uint64_t FigLayerSynchronizerDestroy(const void *a1)
{
  if (a1) {
    CFRelease(a1);
  }
  return 0;
}

double LayerSynchronizer_init(_OWORD *a1)
{
  double result = 0.0;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void LayerSynchronizer_finalize(uint64_t a1)
{
  if (a1)
  {
    CFAllocatorRef v2 = (void *)MEMORY[0x199711A30]();
    MEMORY[0x19970E290](*(void *)(a1 + 24));
    *(unsigned char *)(a1 + 16) = 1;
    MEMORY[0x19970E2B0](*(void *)(a1 + 24));
    free(*(void **)(a1 + 40));
    free(*(void **)(a1 + 48));
    free(*(void **)(a1 + 56));
    free(*(void **)(a1 + 72));
    free(*(void **)(a1 + 80));
    if (*(void *)(a1 + 64))
    {
      [MEMORY[0x1E4F39CF8] begin];
      if (!pthread_main_np()) {
        [MEMORY[0x1E4F39CF8] activateBackground:1];
      }
      int v3 = *(const void **)(a1 + 64);
      if (v3) {
        CFRelease(v3);
      }
      [MEMORY[0x1E4F39CF8] commit];
    }
    FigSimpleMutexDestroy();
    *(void *)(a1 + 24) = 0;
  }
}

__CFString *LayerSynchronizer_CopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFArrayRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<LayerSynchronizer %p>", a1);
  return Mutable;
}

const void *figlayersync_getLayerFrom2Arrays(CFArrayRef theArray, const __CFArray *a2, CFIndex a3)
{
  if (!theArray)
  {
    CFIndex Count = 0;
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    CFIndex v7 = 0;
    goto LABEL_6;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  CFIndex v7 = CFArrayGetCount(a2);
LABEL_6:
  if (!(v7 + Count) || v7 + Count <= a3) {
    return 0;
  }
  CFIndex v8 = a3 - Count;
  if (a3 >= Count)
  {
    CFArrayRef v9 = a2;
  }
  else
  {
    CFArrayRef v9 = theArray;
    CFIndex v8 = a3;
  }

  return CFArrayGetValueAtIndex(v9, v8);
}

void figlayersync_setLayerTimingToMoment(uint64_t a1, uint64_t a2)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  memset(&v75, 0, sizeof(v75));
  if (!*(void *)(a1 + 64)) {
    goto LABEL_125;
  }
  uint64_t v3 = a2;
  if (!*(unsigned char *)(a1 + 89) || (*(unsigned char *)(a2 + 4) & 1) != 0)
  {
    char v69 = 0;
    *(void *)(a1 + 32) = *(void *)(a2 + 8);
    int v4 = 1;
  }
  else
  {
    int v4 = 0;
    char v69 = 1;
  }
  memset(&time, 0, sizeof(time));
  CMClockRef HostTimeClock = CMClockGetHostTimeClock();
  CMClockGetTime(&time, HostTimeClock);
  memset(&v86, 0, sizeof(v86));
  *(CMTime *)CMTime lhs = time;
  CMTime rhs = *(CMTime *)(v3 + 40);
  CMTimeSubtract(&v86, (CMTime *)lhs, &rhs);
  memset(lhs, 0, 24);
  Float64 v6 = *(double *)(v3 + 8) * *(double *)(v3 + 64);
  CMTime rhs = v86;
  CMTimeMultiplyByFloat64((CMTime *)lhs, &rhs, v6);
  CMTime rhs = *(CMTime *)(v3 + 16);
  CMTime v74 = *(CMTime *)lhs;
  CMTimeAdd(&v75, &rhs, &v74);
  CFIndex v7 = (int *)MEMORY[0x1E4F1EBA8];
  int v8 = *MEMORY[0x1E4F1EBA8];
  if (v4 && v8 == 1)
  {
    kdebug_trace();
    int v8 = *v7;
  }
  if ((*(unsigned char *)(v3 + 4) & 2) != 0 && v8 == 1)
  {
    CMTime time = *(CMTime *)(v3 + 16);
    CMTimeGetSeconds(&time);
    kdebug_trace();
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  if (Count >= 1)
  {
    uint64_t v9 = 0;
    CFIndex v10 = 0;
    int v70 = v4;
    uint64_t v68 = v3;
    while (1)
    {
      CMTime time = v75;
      double Seconds = CMTimeGetSeconds(&time);
      double v12 = *(double *)(*(void *)(a1 + 40) + 8 * v10);
      double v13 = *(double *)(*(void *)(a1 + 48) + 8 * v10);
      CFNumberRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), v10);
      int v73 = *(unsigned __int8 *)(*(void *)(a1 + 80) + v10);
      [ValueAtIndex convertTime:0 fromLayer:CACurrentMediaTime()];
      double v16 = v15;
      if (objc_opt_respondsToSelector())
      {
        [ValueAtIndex setInheritsTiming:0];
        double v17 = CACurrentMediaTime();
        [ValueAtIndex beginTime];
        double v19 = v17 - v18;
        [ValueAtIndex speed];
        double v21 = v20;
        [ValueAtIndex timeOffset];
        double v16 = v22 + v19 * v21;
      }
      else
      {
        CMTime v23 = (void *)[ValueAtIndex superlayer];
        double v24 = CACurrentMediaTime();
        double v17 = v24;
        if (v23)
        {
          [v23 convertTime:0 fromLayer:v24];
          double v17 = v25;
        }
      }
      if (!v4) {
        goto LABEL_47;
      }
      [ValueAtIndex duration];
      double v27 = v26;
      double v28 = fabs(v26);
      if ((objc_opt_respondsToSelector() & 1) == 0
        || (double v29 = 1.0, [ValueAtIndex inheritsTiming]))
      {
        CFIndex v30 = (void *)[ValueAtIndex superlayer];
        if ((objc_opt_respondsToSelector() & 1) == 0 || (double v29 = 1.0, [v30 inheritsTiming]))
        {
          uint64_t v31 = [v30 superlayer];
          if (v31)
          {
            CFIndex v32 = (void *)v31;
            double v13 = 1.0;
            double v29 = 1.0;
            while (1)
            {
              [v32 speed];
              double v29 = v29 * v33;
              if (v29 == 0.0) {
                break;
              }
              if ((objc_opt_respondsToSelector() & 1) == 0 || [v32 inheritsTiming])
              {
                CFIndex v32 = (void *)[v32 superlayer];
                if (v32) {
                  continue;
                }
              }
              goto LABEL_31;
            }
            double v12 = 1.0;
LABEL_40:
            uint64_t v35 = *(void *)(a1 + 72);
            if (v28 == INFINITY || v27 != *(double *)(v35 + 8 * v10)) {
              goto LABEL_47;
            }
            *(void *)(v35 + 8 * v10) = 0x7FF0000000000000;
            double v34 = INFINITY;
            goto LABEL_46;
          }
          double v29 = 1.0;
        }
      }
LABEL_31:
      double v12 = *(double *)(v3 + 8) / v29;
      if (v12 == 0.0) {
        double v13 = 1.0;
      }
      else {
        double v13 = 1.0 / v12;
      }
      if (v12 >= 0.0) {
        goto LABEL_40;
      }
      if (v28 != INFINITY) {
        goto LABEL_47;
      }
      double v34 = v16 + 0.1;
      *(double *)(*(void *)(a1 + 72) + 8 * v10) = v16 + 0.1;
      if (*(unsigned char *)(*(void *)(a1 + 80) + v10)) {
        double v34 = INFINITY;
      }
LABEL_46:
      [ValueAtIndex setDuration:v34];
LABEL_47:
      if (!*(unsigned char *)(a1 + 89)
        || (*(unsigned char *)(v3 + 4) & 3) != 0
        || vabdd_f64(Seconds + v12 * *(double *)(*(void *)(a1 + 56) + 8 * v10), v16) >= 0.005)
      {
        if (*(unsigned char *)(a1 + 88))
        {
          uint64_t v72 = v9;
          char v37 = (void *)[ValueAtIndex context];
          double v38 = 0.0;
          if (v37 && (objc_opt_respondsToSelector() & 1) != 0)
          {
            int v39 = [v37 displayId];
            if (v39)
            {
              long long v78 = 0u;
              long long v79 = 0u;
              memset(lhs, 0, sizeof(lhs));
              CMTime v40 = (void *)[MEMORY[0x1E4F39B60] displays];
              uint64_t v41 = [v40 countByEnumeratingWithState:lhs objects:&time count:16];
              if (v41)
              {
                uint64_t v42 = v41;
                uint64_t v43 = **(void **)&lhs[16];
LABEL_56:
                uint64_t v44 = 0;
                while (1)
                {
                  if (**(void **)&lhs[16] != v43) {
                    objc_enumerationMutation(v40);
                  }
                  CFIndex v45 = *(void **)(*(void *)&lhs[8] + 8 * v44);
                  if ([v45 displayId] == v39) {
                    break;
                  }
                  if (v42 == ++v44)
                  {
                    uint64_t v42 = [v40 countByEnumeratingWithState:lhs objects:&time count:16];
                    if (v42) {
                      goto LABEL_56;
                    }
                    goto LABEL_102;
                  }
                }
                [v45 latency];
                if (v59 < 0.0)
                {
LABEL_102:
                  uint64_t v3 = v68;
                  goto LABEL_64;
                }
                uint64_t v3 = v68;
                if (v59 <= 1.0) {
                  double v38 = v59;
                }
              }
            }
          }
          else
          {
            int v39 = 0;
          }
LABEL_64:
          if (dword_1EB2AE9A8)
          {
            LODWORD(v74.CFDictionarySetValue(theDict, key, value) = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int value = v74.value;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
              unsigned int v48 = value;
            }
            else {
              unsigned int v48 = value & 0xFFFFFFFE;
            }
            if (v48)
            {
              LODWORD(rhs.CFDictionarySetValue(theDict, key, value) = 136316162;
              *(CMTimeValue *)((char *)&rhs.value + 4) = (CMTimeValue)"figlayersync_getLayerDisplayLatency";
              LOWORD(rhs.flags) = 2048;
              *(void *)((char *)&rhs.flags + 2) = ValueAtIndex;
              HIWORD(rhs.epoch) = 2048;
              CMTimeFlags v81 = v37;
              __int16 v82 = 1024;
              int v83 = v39;
              __int16 v84 = 2048;
              double v85 = v38;
              LODWORD(v67) = 48;
              p_CMTime rhs = &rhs;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          int v4 = v70;
          uint64_t v9 = v72;
        }
        else
        {
          double v38 = 0.0;
        }
        if (v73)
        {
          if (dword_1EB2AE9A8)
          {
            *(_DWORD *)CMTime lhs = 0;
            LOBYTE(rhs.CFDictionarySetValue(theDict, key, value) = 0;
            CMTime v49 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v50 = *(_DWORD *)lhs;
            if (os_log_type_enabled(v49, rhs.value)) {
              unsigned int v51 = v50;
            }
            else {
              unsigned int v51 = v50 & 0xFFFFFFFE;
            }
            if (v51)
            {
              LODWORD(v86.CFDictionarySetValue(theDict, key, value) = 136315906;
              *(CMTimeValue *)((char *)&v86.value + 4) = (CMTimeValue)"figlayersync_setLayerTiming";
              LOWORD(v86.flags) = 2048;
              *(void *)((char *)&v86.flags + 2) = ValueAtIndex;
              HIWORD(v86.epoch) = 2048;
              double v87 = v38;
              __int16 v88 = 2048;
              double v89 = v17;
              LODWORD(v67) = 42;
              p_CMTime rhs = &v86;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          objc_msgSend(ValueAtIndex, "setTimeOffset:", v38, p_rhs, v67);
        }
        else
        {
          if (v12 == 0.0)
          {
            [ValueAtIndex duration];
            if (v52 <= Seconds)
            {
              double Seconds = v52 + -0.000001;
            }
            else if (Seconds < 0.0)
            {
              double Seconds = 0.0;
            }
            if (dword_1EB2AE9A8)
            {
              *(_DWORD *)CMTime lhs = 0;
              LOBYTE(rhs.CFDictionarySetValue(theDict, key, value) = 0;
              CFIndex v56 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              unsigned int v57 = *(_DWORD *)lhs;
              if (os_log_type_enabled(v56, rhs.value)) {
                unsigned int v58 = v57;
              }
              else {
                unsigned int v58 = v57 & 0xFFFFFFFE;
              }
              if (v58)
              {
                LODWORD(v86.CFDictionarySetValue(theDict, key, value) = 136315906;
                *(CMTimeValue *)((char *)&v86.value + 4) = (CMTimeValue)"figlayersync_setLayerTiming";
                LOWORD(v86.flags) = 2048;
                *(void *)((char *)&v86.flags + 2) = ValueAtIndex;
                HIWORD(v86.epoch) = 2048;
                double v87 = Seconds;
                __int16 v88 = 2048;
                double v89 = v17;
                LODWORD(v67) = 42;
                p_CMTime rhs = &v86;
                _os_log_send_and_compose_impl();
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
          }
          else if (v12 <= 0.0)
          {
            [ValueAtIndex duration];
            double v61 = v60;
            [ValueAtIndex setBeginTime:v17 - (Seconds - v60) * v13 - v38];
            double Seconds = v61;
          }
          else
          {
            if (dword_1EB2AE9A8)
            {
              *(_DWORD *)CMTime lhs = 0;
              LOBYTE(rhs.CFDictionarySetValue(theDict, key, value) = 0;
              __int16 v53 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              unsigned int v54 = *(_DWORD *)lhs;
              if (os_log_type_enabled(v53, rhs.value)) {
                unsigned int v55 = v54;
              }
              else {
                unsigned int v55 = v54 & 0xFFFFFFFE;
              }
              if (v55)
              {
                LODWORD(v86.CFDictionarySetValue(theDict, key, value) = 136316674;
                *(CMTimeValue *)((char *)&v86.value + 4) = (CMTimeValue)"figlayersync_setLayerTiming";
                LOWORD(v86.flags) = 2048;
                *(void *)((char *)&v86.flags + 2) = ValueAtIndex;
                HIWORD(v86.epoch) = 2048;
                double v87 = v17 - Seconds * v13 - v38;
                __int16 v88 = 2048;
                double v89 = v17;
                __int16 v90 = 2048;
                double v91 = Seconds;
                __int16 v92 = 2048;
                double v93 = v12;
                __int16 v94 = 2048;
                double v95 = v38;
                LODWORD(v67) = 72;
                p_CMTime rhs = &v86;
                _os_log_send_and_compose_impl();
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
            objc_msgSend(ValueAtIndex, "setBeginTime:", v17 - Seconds * v13 - v38, p_rhs, v67);
            double Seconds = 0.0;
          }
          objc_msgSend(ValueAtIndex, "setTimeOffset:", Seconds, p_rhs, v67);
          if ((v69 & 1) == 0)
          {
            if (dword_1EB2AE9A8)
            {
              *(_DWORD *)CMTime lhs = 0;
              LOBYTE(rhs.CFDictionarySetValue(theDict, key, value) = 0;
              uint64_t v63 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              unsigned int v64 = *(_DWORD *)lhs;
              if (os_log_type_enabled(v63, rhs.value)) {
                unsigned int v65 = v64;
              }
              else {
                unsigned int v65 = v64 & 0xFFFFFFFE;
              }
              if (v65)
              {
                LODWORD(v86.CFDictionarySetValue(theDict, key, value) = 136315650;
                *(CMTimeValue *)((char *)&v86.value + 4) = (CMTimeValue)"figlayersync_setLayerTiming";
                LOWORD(v86.flags) = 2048;
                *(void *)((char *)&v86.flags + 2) = ValueAtIndex;
                HIWORD(v86.epoch) = 2048;
                double v87 = v12;
                LODWORD(v67) = 32;
                p_CMTime rhs = &v86;
                _os_log_send_and_compose_impl();
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
            *(float *)&double v62 = v12;
            objc_msgSend(ValueAtIndex, "setSpeed:", v62, p_rhs, v67);
          }
        }
        *(double *)(*(void *)(a1 + 56) + 8 * v10) = v38;
        ++v9;
        if (v4)
        {
          *(double *)(*(void *)(a1 + 40) + 8 * v10) = v12;
          *(double *)(*(void *)(a1 + 48) + 8 * v10) = v13;
        }
      }
      if (++v10 == Count) {
        goto LABEL_124;
      }
    }
  }
  uint64_t v9 = 0;
LABEL_124:
  if (v9 == Count) {
LABEL_125:
  }
    *(unsigned char *)(a1 + 89) = 1;
}

uint64_t FigVTTRegionBlockCreate(uint64_t a1, void *a2)
{
  if (a2)
  {
    FigVTTNodeGetClassID();
    uint64_t v3 = CMDerivedObjectCreate();
    if (!v3)
    {
      uint64_t DerivedStorage = (CFMutableDictionaryRef *)CMBaseObjectGetDerivedStorage();
      uint64_t v3 = FigVTTInitializeNodeBaseStorage(DerivedStorage);
      if (!v3) {
        *a2 = 0;
      }
    }
    return v3;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void figVTTRegionBlock_Finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();

  FigVTTReleaseNodeBaseStorage(DerivedStorage);
}

CFStringRef figVTTRegionBlock_CopyDebugDesc()
{
  CMBaseObjectGetDerivedStorage();
  uint64_t v0 = (const void *)FigCFCopyCompactDescription();
  CFStringRef v1 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"regionblock: %@", v0);
  if (v0) {
    CFRelease(v0);
  }
  return v1;
}

uint64_t figVTTRegionBlock_GetNodeType(uint64_t a1, _DWORD *a2)
{
  if (!a2) {
    return FigSignalErrorAt();
  }
  *a2 = 4;
  return 0;
}

uint64_t figVTTRegionBlock_copyNodeDocumentSerialization(const void *a1, CFStringRef *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFTypeRef v23 = 0;
  if (a2)
  {
    CFAllocatorRef v5 = v4;
    *a2 = 0;
    CFMutableStringRef Mutable = CFStringCreateMutable(v4, 0);
    if (Mutable)
    {
      CFIndex v7 = Mutable;
      uint64_t v8 = FigVTTNodeCopyAttributes((uint64_t)a1, &v23);
      if (v8 || FigCFDictionaryGetCount() < 1)
      {
LABEL_21:
        CFRelease(v7);
        if (v23) {
          CFRelease(v23);
        }
        return v8;
      }
      int Value = CFDictionaryGetValue((CFDictionaryRef)v23, @"id");
      if (Value)
      {
        CFStringAppendFormat(v7, 0, @"id:%@", Value);
        CFStringAppendFormat(v7, 0, @"\n");
        int v10 = 1;
      }
      else
      {
        int v10 = 0;
      }
      uint64_t v11 = CFDictionaryGetValue((CFDictionaryRef)v23, @"lines");
      if (v11)
      {
        CFStringAppendFormat(v7, 0, @"lines:%@", v11);
        CFStringAppendFormat(v7, 0, @"\n");
        ++v10;
      }
      if (CFDictionaryGetValue((CFDictionaryRef)v23, @"width"))
      {
        uint64_t v12 = FigGeometryDimensionMakeFromDictionary();
        int v14 = v13;
        CFStringAppendFormat(v7, 0, @"%@:", @"width");
        FigVTTStringifyFigGeometryDimensionAndAppend(v7, v12, v14);
        CFStringAppendFormat(v7, 0, @"\n");
        ++v10;
      }
      if (CFDictionaryGetValue((CFDictionaryRef)v23, @"regionanchor"))
      {
        long long v21 = 0u;
        long long v22 = 0u;
        FigGeometryPointMakeFromDictionary();
        CFStringAppendFormat(v7, 0, @"%@:", @"regionanchor");
        long long v19 = 0u;
        long long v20 = 0u;
        FigVTTStringifyFigGeometryPointAndAppend(v7, (uint64_t *)&v19);
        CFStringAppendFormat(v7, 0, @"\n");
        ++v10;
      }
      if (CFDictionaryGetValue((CFDictionaryRef)v23, @"viewportanchor"))
      {
        long long v21 = 0u;
        long long v22 = 0u;
        FigGeometryPointMakeFromDictionary();
        CFStringAppendFormat(v7, 0, @"%@:", @"viewportanchor");
        long long v19 = v21;
        long long v20 = v22;
        FigVTTStringifyFigGeometryPointAndAppend(v7, (uint64_t *)&v19);
        CFStringAppendFormat(v7, 0, @"\n");
        int v10 = 1;
      }
      double v15 = CFDictionaryGetValue((CFDictionaryRef)v23, @"scroll");
      if (v15)
      {
        CFStringAppendFormat(v7, 0, @"scroll:%@", v15);
        CFStringAppendFormat(v7, 0, @"\n");
      }
      else if (!v10)
      {
        CFStringRef v16 = CFStringCreateWithFormat(v5, 0, &stru_1EE53F4B8, v18);
        goto LABEL_20;
      }
      CFStringRef v16 = CFStringCreateWithFormat(v5, 0, @"%@\n%@\n", @"REGION", v7);
LABEL_20:
      *a2 = v16;
      goto LABEL_21;
    }
  }

  return FigSignalErrorAt();
}

uint64_t FigCLCPCaptionGroupConverterToSampleBufferCreate(_OWORD *a1, const void *a2, CFTypeRef *a3)
{
  CFTypeRef v19 = 0;
  if (a1)
  {
    if (a3)
    {
      FigCaptionGroupConverterToSampleBufferGetClassID();
      uint64_t v6 = CMDerivedObjectCreate();
      if (v6)
      {
        uint64_t v15 = v6;
        FigSignalErrorAt();
        goto LABEL_35;
      }
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      if (a2) {
        CFTypeRef v8 = CFRetain(a2);
      }
      else {
        CFTypeRef v8 = 0;
      }
      *(void *)uint64_t DerivedStorage = v8;
      *(_OWORD *)(DerivedStorage + 144) = *a1;
      ClosedCaptionuint64_t Channel = FigCEA608DataGeneratorCreate((uint64_t)clcpcgctsbCEA608DataGeneratorCallback, (uint64_t)v19, (CFAllocatorRef)a2, (void *)(DerivedStorage + 8));
      if (!ClosedCaptionChannel)
      {
        unsigned int v18 = 0;
        ClosedCaptionuint64_t Channel = FigCEA608DataGeneratorGetClosedCaptionChannel(*(void *)(DerivedStorage + 8), &v18);
        if (!ClosedCaptionChannel)
        {
          CFDictionaryRef v10 = 0;
          unsigned int v11 = v18;
          CFTypeRef cf = 0;
          values = 0;
          CMFormatDescriptionRef formatDescriptionOut = 0;
          if (v18 != 1)
          {
            CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)a2, 8);
            values = Mutable;
            if (!Mutable) {
              goto LABEL_28;
            }
            int v13 = Mutable;
            *(_DWORD *)UInt8 bytes = 942683748;
            CFDataAppendBytes(Mutable, bytes, 4);
            *(_DWORD *)long long v21 = bswap32(v11);
            CFDataAppendBytes(v13, v21, 4);
            keys = @"cccc";
            CFTypeRef cf = CFDictionaryCreate((CFAllocatorRef)a2, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (!cf
              || (CFDictionaryRef v14 = CFDictionaryCreate((CFAllocatorRef)a2, MEMORY[0x1E4F1EE20], &cf, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) == 0)
            {
LABEL_28:
              uint64_t v15 = FigSignalErrorAt();
              goto LABEL_18;
            }
            CFDictionaryRef v10 = v14;
          }
          uint64_t v15 = CMFormatDescriptionCreate((CFAllocatorRef)a2, 0x636C6370u, 0x63363038u, v10, &formatDescriptionOut);
          if (!v15) {
            *(void *)(DerivedStorage + 24) = formatDescriptionOut;
          }
          if (v10) {
            CFRelease(v10);
          }
LABEL_18:
          if (cf) {
            CFRelease(cf);
          }
          if (values) {
            CFRelease(values);
          }
          if (!v15)
          {
            if (v18 - 3 >= 2) {
              int v16 = 1667522932;
            }
            else {
              int v16 = 1667527730;
            }
            *(_DWORD *)(DerivedStorage + 20) = v16;
            *a3 = v19;
            return v15;
          }
LABEL_35:
          if (v19) {
            CFRelease(v19);
          }
          return v15;
        }
      }
    }
    else
    {
      ClosedCaptionuint64_t Channel = FigSignalErrorAt();
    }
    uint64_t v15 = ClosedCaptionChannel;
    goto LABEL_35;
  }

  return FigSignalErrorAt();
}

uint64_t clcpcgctsbCEA608DataGeneratorCallback(const void *a1, long long *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  long long v10 = *a2;
  uint64_t v11 = *((void *)a2 + 2);
  uint64_t CCData = clcpcgctsbOutputAndReleaseLastCCData(DerivedStorage, (uint64_t)&v10);
  if (!CCData)
  {
    long long v6 = *a2;
    long long v7 = a2[2];
    *(_OWORD *)(DerivedStorage + 112) = a2[1];
    *(_OWORD *)(DerivedStorage + 128) = v7;
    *(_OWORD *)(DerivedStorage + 96) = v6;
    if (a1) {
      CFTypeRef v8 = CFRetain(a1);
    }
    else {
      CFTypeRef v8 = 0;
    }
    *(void *)(DerivedStorage + 88) = v8;
  }
  return CCData;
}

uint64_t FigCLCPCaptionConversionValidatorCreate(_OWORD *a1, uint64_t a2, const void *a3, void *a4)
{
  if (a1)
  {
    if (!a4) {
      return FigSignalErrorAt();
    }
    FigCaptionConversionValidatorGetClassID();
    uint64_t v7 = CMDerivedObjectCreate();
    if (v7)
    {
      uint64_t ShouldAdjustOverlappedDataTime = v7;
      FigSignalErrorAt();
      return ShouldAdjustOverlappedDataTime;
    }
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    if (a3) {
      CFTypeRef v9 = CFRetain(a3);
    }
    else {
      CFTypeRef v9 = 0;
    }
    *(void *)uint64_t DerivedStorage = v9;
    *(_OWORD *)(DerivedStorage + 104) = *a1;
    uint64_t v10 = FigCEA608DataGeneratorCreate((uint64_t)clcpccvCEA608DataGeneratorCallback, 0, (CFAllocatorRef)a3, (void *)(DerivedStorage + 8));
    if (!v10)
    {
      uint64_t ShouldAdjustOverlappedDataTime = FigCEA608DataGeneratorSetShouldAdjustOverlappedDataTime(*(void *)(DerivedStorage + 8), 0);
      if (!ShouldAdjustOverlappedDataTime) {
        *a4 = 0;
      }
      return ShouldAdjustOverlappedDataTime;
    }
    return v10;
  }

  return FigSignalErrorAt();
}

uint64_t clcpccvCEA608DataGeneratorCallback()
{
  return 0;
}

void clcpcgctsb_Finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigCEA608DataGeneratorRelease(*(void **)(DerivedStorage + 8));
  CFStringRef v1 = *(const void **)(DerivedStorage + 32);
  if (v1) {
    CFRelease(v1);
  }
  CFAllocatorRef v2 = *(const void **)(DerivedStorage + 24);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(DerivedStorage + 88);
  if (v3) {
    CFRelease(v3);
  }
  CFAllocatorRef v4 = *(const void **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    CFRelease(v4);
  }
}

__CFString *clcpcgctsb_CopyDebugDescription(uint64_t a1)
{
  CFMutableDataRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigCLCPCaptionGroupConverterToSampleBufferf %p>", a1);
  return Mutable;
}

uint64_t clcpcgctsb_CopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 && a4) {
    return 4294954512;
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t clcpcgctsb_SetProperty(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 4294954512;
  }
  else {
    return FigSignalErrorAt();
  }
}

uint64_t clcpcgctsb_AddCaptionGroup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2
    || (*(unsigned char *)(a3 + 12) & 1) == 0
    || (*(unsigned char *)(a3 + 36) & 1) == 0
    || *(void *)(a3 + 40)
    || (*(void *)(a3 + 24) & 0x8000000000000000) != 0
    || (uint64_t v7 = DerivedStorage, *(_DWORD *)(DerivedStorage + 16) == 2))
  {
    return FigSignalErrorAt();
  }
  else
  {
    SliceCFIndex Count = FigCaptionGroupGetSliceCount();
    if (SliceCount >= 1)
    {
      uint64_t v9 = SliceCount;
      uint64_t v10 = 0;
      uint64_t v11 = (_OWORD *)(v7 + 40);
      uint64_t v12 = (_OWORD *)(v7 + 64);
      long long v20 = *MEMORY[0x1E4F1FA48];
      CMTimeEpoch v13 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
      do
      {
        long long v26 = 0uLL;
        CMTimeEpoch v27 = 0;
        FigCaptionGroupGetDurationBeforeSlice();
        *(_OWORD *)&time1.start.unsigned int value = v26;
        time1.start.CMTimeEpoch epoch = v27;
        *(_OWORD *)&time2.start.unsigned int value = v20;
        time2.start.CMTimeEpoch epoch = v13;
        if (!CMTimeCompare(&time1.start, &time2.start))
        {
          long long v24 = 0uLL;
          CMTimeEpoch v25 = 0;
          FigCaptionGroupGetDurationAfterSlice();
          memset(&v23, 0, sizeof(v23));
          *(_OWORD *)&time1.start.unsigned int value = *(_OWORD *)(a3 + 24);
          time1.start.CMTimeEpoch epoch = *(void *)(a3 + 40);
          *(_OWORD *)&time2.start.unsigned int value = v24;
          time2.start.CMTimeEpoch epoch = v25;
          CMTimeAdd(&v23, &time1.start, &time2.start);
          memset(&v22, 0, sizeof(v22));
          *(_OWORD *)&time1.start.unsigned int value = *(_OWORD *)a3;
          time1.start.CMTimeEpoch epoch = *(void *)(a3 + 16);
          time2.CMTime start = v23;
          CMTimeRangeMake(&v22, &time1.start, &time2.start);
          CaptionData = (const void *)FigCaptionGroupGetCaptionData();
          CMTimeRange v21 = v22;
          long long v15 = *(_OWORD *)(v7 + 56);
          *(_OWORD *)&time1.start.unsigned int value = *v11;
          *(_OWORD *)&time1.start.CMTimeEpoch epoch = v15;
          *(_OWORD *)&time1.duration.CMTimeScale timescale = *(_OWORD *)(v7 + 72);
          CMTimeRange time2 = v22;
          if (CMTimeRangeEqual(&time1, &time2))
          {
            CFArrayAppendValue(*(CFMutableArrayRef *)(v7 + 32), CaptionData);
          }
          else
          {
            long long v16 = *(_OWORD *)(v7 + 56);
            *(_OWORD *)&time2.start.unsigned int value = *v11;
            *(_OWORD *)&time2.start.CMTimeEpoch epoch = v16;
            *(_OWORD *)&time2.duration.CMTimeScale timescale = *(_OWORD *)(v7 + 72);
            memset(&time1, 0, sizeof(time1));
            CMTimeRange otherRange = v21;
            CMTimeRangeGetIntersection(&time1, &time2, &otherRange);
            long long v17 = *(_OWORD *)(MEMORY[0x1E4F1FA30] + 16);
            *(_OWORD *)&time2.start.unsigned int value = *MEMORY[0x1E4F1FA30];
            *(_OWORD *)&time2.start.CMTimeEpoch epoch = v17;
            *(_OWORD *)&time2.duration.CMTimeScale timescale = *(_OWORD *)(MEMORY[0x1E4F1FA30] + 32);
            CMTimeRange otherRange = time1;
            if (!CMTimeRangeEqual(&time2, &otherRange))
            {
              *(_OWORD *)&otherRange.start.unsigned int value = *v12;
              otherRange.start.CMTimeEpoch epoch = *(void *)(v7 + 80);
              CMTime rhs = time1.duration;
              CMTimeSubtract(&time2.start, &otherRange.start, &rhs);
              *uint64_t v12 = *(_OWORD *)&time2.start.value;
              *(void *)(v7 + 80) = time2.start.epoch;
            }
            uint64_t result = clcpcgctsbAddCaptionDataWithSameTimeRange(v7);
            if (result) {
              return result;
            }
            unsigned int v18 = *(const void **)(v7 + 32);
            if (v18)
            {
              CFRelease(v18);
              *(void *)(v7 + 32) = 0;
            }
            CFMutableDataRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)v7, 0, MEMORY[0x1E4F1D510]);
            *(void *)(v7 + 32) = Mutable;
            if (Mutable)
            {
              CFArrayAppendValue(Mutable, CaptionData);
              *uint64_t v11 = *(_OWORD *)&v21.start.value;
              *(_OWORD *)(v7 + 56) = *(_OWORD *)&v21.start.epoch;
              *(_OWORD *)(v7 + 72) = *(_OWORD *)&v21.duration.timescale;
            }
            else
            {
              uint64_t result = FigSignalErrorAt();
              if (result) {
                return result;
              }
            }
          }
        }
        ++v10;
      }
      while (v9 != v10);
    }
    uint64_t result = 0;
    *(_DWORD *)(v7 + 16) = 1;
  }
  return result;
}

uint64_t clcpcgctsb_Finish()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = clcpcgctsbAddCaptionDataWithSameTimeRange(DerivedStorage);
  if (!result)
  {
    uint64_t result = FigCEA608DataGeneratorFinish(*(void *)(DerivedStorage + 8));
    if (!result)
    {
      uint64_t result = clcpcgctsbOutputAndReleaseLastCCData(DerivedStorage, MEMORY[0x1E4F1F9F0]);
      if (!result) {
        *(_DWORD *)(DerivedStorage + 16) = 2;
      }
    }
  }
  return result;
}

uint64_t clcpcgctsbAddCaptionDataWithSameTimeRange(uint64_t a1)
{
  uint64_t v20 = *(void *)(a1 + 8);
  CFAllocatorRef allocator = *(const __CFAllocator **)a1;
  CFArrayRef v1 = *(const __CFArray **)(a1 + 32);
  long long v2 = *(_OWORD *)(a1 + 56);
  long long v31 = *(_OWORD *)(a1 + 40);
  long long v32 = v2;
  long long v33 = *(_OWORD *)(a1 + 72);
  if (!v1)
  {
    CFTypeRef cf = 0;
    CFTypeRef v30 = 0;
    ptr = 0;
    goto LABEL_27;
  }
  CFIndex Count = CFArrayGetCount(v1);
  CFTypeRef cf = 0;
  CFTypeRef v30 = 0;
  CFAttributedStringRef aStr = 0;
  ptr = 0;
  if (!Count)
  {
LABEL_27:
    FigCEA608DataGeneratorCaptionInfoRelease(0);
    uint64_t v18 = 0;
    goto LABEL_30;
  }
  CFIndex v4 = Count;
  if (Count >= 1)
  {
    CFIndex v5 = 0;
    uint64_t v6 = 0;
    int v7 = 0;
    while (1)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v1, v5);
      unsigned int v9 = clcpcgctsbDoesCaptioDataHaveText((uint64_t)ValueAtIndex);
      uint64_t v26 = 0;
      int v25 = 0;
      if (v9)
      {
        uint64_t v10 = clcpcgctsbCopyCaptionAnimationAndRegionInformation((uint64_t)ValueAtIndex, (uint64_t)allocator, &v30, &cf, (_DWORD *)&v26 + 1, &v26, &v25);
        if (v10) {
          goto LABEL_25;
        }
        CFArrayRef v11 = v1;
        CFTypeRef v13 = cf;
        CFTypeRef v12 = v30;
        uint64_t FigCEA608DataGeneratorClosedCaptionMode = clcpcgctsbGetFigCEA608DataGeneratorClosedCaptionMode();
        uint64_t v15 = FigCEA608DataGeneratorClosedCaptionMode;
        if (v6 && v6 != FigCEA608DataGeneratorClosedCaptionMode)
        {
          uint64_t v10 = FigSignalErrorAt();
LABEL_25:
          uint64_t v18 = v10;
          goto LABEL_29;
        }
        if (!v7)
        {
          long long v22 = v31;
          long long v23 = v32;
          long long v24 = v33;
          uint64_t v10 = FigCEA608DataGeneratorCaptionInfoCreate(FigCEA608DataGeneratorClosedCaptionMode, v25, &v22, allocator, &ptr);
          if (v10) {
            goto LABEL_25;
          }
          long long v22 = *MEMORY[0x1E4F1F9F8];
          *(void *)&long long v23 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
          uint64_t v10 = FigCEA608DataGeneratorBeginCaption(v20, &v22, 0, (uint64_t)ptr);
          if (v10) {
            goto LABEL_25;
          }
        }
        uint64_t v16 = clcpcgctsbCreateCEA608DataGeneratorAttributedString((uint64_t)ValueAtIndex, allocator, &aStr);
        CFAttributedStringRef v17 = aStr;
        if (v16 || (uint64_t v16 = FigCEA608DataGeneratorAddCaptionLine(v20, HIDWORD(v26), v26, aStr), v16))
        {
          uint64_t v18 = v16;
          FigCEA608DataGeneratorCaptionInfoRelease((const __CFAllocator **)ptr);
          if (v17) {
            CFRelease(v17);
          }
          goto LABEL_30;
        }
        if (v17)
        {
          CFRelease(v17);
          CFAttributedStringRef aStr = 0;
        }
        if (v13)
        {
          CFRelease(v13);
          CFTypeRef cf = 0;
        }
        if (v12)
        {
          CFRelease(v12);
          CFTypeRef v30 = 0;
        }
        int v7 = 1;
        CFArrayRef v1 = v11;
      }
      else
      {
        uint64_t v15 = v6;
      }
      ++v5;
      uint64_t v6 = v15;
      if (v4 == v5)
      {
        if (!v7) {
          break;
        }
        uint64_t v10 = FigCEA608DataGeneratorEndCaption(v20, 0, 0, 0);
        goto LABEL_25;
      }
    }
  }
  uint64_t v18 = 0;
LABEL_29:
  FigCEA608DataGeneratorCaptionInfoRelease((const __CFAllocator **)ptr);
LABEL_30:
  if (cf) {
    CFRelease(cf);
  }
  if (v30) {
    CFRelease(v30);
  }
  return v18;
}

CFStringRef clcpcgctsbDoesCaptioDataHaveText(uint64_t a1)
{
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  CFIndex v4 = *(uint64_t (**)(uint64_t))(v3 + 8);
  if (!v4)
  {
    CFStringRef result = &stru_1EE53F4B8;
    return (const __CFString *)(CFStringGetLength(result) != 0);
  }
  CFStringRef result = (const __CFString *)v4(a1);
  if (result) {
    return (const __CFString *)(CFStringGetLength(result) != 0);
  }
  return result;
}

uint64_t clcpcgctsbCopyCaptionAnimationAndRegionInformation(uint64_t a1, uint64_t a2, void *a3, void *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  CFTypeRef v46 = 0;
  CFTypeRef v47 = 0;
  CFTypeRef v44 = 0;
  CFTypeRef v45 = 0;
  CFTypeRef cf = 0;
  *(_OWORD *)uint64_t v42 = *MEMORY[0x1E4F1DAD8];
  double v41 = 0.0;
  uint64_t CMBaseObject = FigCaptionDataGetCMBaseObject();
  uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *(uint64_t (**)(uint64_t, void, uint64_t, CFTypeRef *))(v15 + 48);
  if (!v16) {
    goto LABEL_36;
  }
  uint64_t CellBasedPointFromDictionary = v16(CMBaseObject, *MEMORY[0x1E4F1FEE0], a2, &v47);
  if (CellBasedPointFromDictionary) {
    goto LABEL_60;
  }
  uint64_t v18 = FigCaptionDataGetCMBaseObject();
  uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  CMTimeRange v21 = *(uint64_t (**)(uint64_t, void, uint64_t, CFTypeRef *))(v20 + 48);
  if (!v21) {
    goto LABEL_36;
  }
  uint64_t CellBasedPointFromDictionary = v21(v18, *MEMORY[0x1E4F1FF20], a2, &v46);
  if (CellBasedPointFromDictionary) {
    goto LABEL_60;
  }
  if (!v46) {
    goto LABEL_31;
  }
  uint64_t v22 = FigCaptionRegionGetCMBaseObject();
  uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v23) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = 0;
  }
  int v25 = *(uint64_t (**)(uint64_t, void, uint64_t, CFTypeRef *))(v24 + 48);
  if (!v25) {
    goto LABEL_36;
  }
  uint64_t CellBasedPointFromDictionary = v25(v22, *MEMORY[0x1E4F1FFC0], a2, &v45);
  if (CellBasedPointFromDictionary)
  {
LABEL_60:
    uint64_t v36 = CellBasedPointFromDictionary;
    goto LABEL_37;
  }
  uint64_t v26 = FigCaptionRegionGetCMBaseObject();
  uint64_t v27 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v27) {
    uint64_t v28 = v27;
  }
  else {
    uint64_t v28 = 0;
  }
  double v29 = *(uint64_t (**)(uint64_t, void, uint64_t, CFTypeRef *))(v28 + 48);
  if (!v29) {
    goto LABEL_36;
  }
  uint64_t CellBasedPointFromDictionary = v29(v26, *MEMORY[0x1E4F20070], a2, &v44);
  if (CellBasedPointFromDictionary) {
    goto LABEL_60;
  }
  if (v44)
  {
    FigCaptionDynamicStyleGetInitialValue();
    uint64_t CellBasedPointFromDictionary = FigCaptionGeometryGetCellBasedPointFromDictionary();
    if (CellBasedPointFromDictionary) {
      goto LABEL_60;
    }
  }
  uint64_t v30 = FigCaptionRegionGetCMBaseObject();
  uint64_t v31 = *(void *)(CMBaseObjectGetVTable() + 8);
  uint64_t v32 = v31 ? v31 : 0;
  long long v33 = *(uint64_t (**)(uint64_t, void, uint64_t, CFTypeRef *))(v32 + 48);
  if (!v33)
  {
LABEL_36:
    uint64_t v36 = 4294954514;
    goto LABEL_37;
  }
  uint64_t CellBasedPointFromDictionary = v33(v30, *MEMORY[0x1E4F20008], a2, &cf);
  if (CellBasedPointFromDictionary) {
    goto LABEL_60;
  }
  if (cf)
  {
    FigCaptionDynamicStyleGetInitialValue();
    uint64_t CellBasedPointFromDictionary = FigCaptionGeometryGetCellBasedDimensionFromDictionary();
    if (CellBasedPointFromDictionary) {
      goto LABEL_60;
    }
  }
LABEL_31:
  double v34 = 1.0;
  if (v42[1] < 1.0 || (double v34 = 15.0, v42[1] > 15.0)) {
    v42[1] = v34;
  }
  if (v42[0] >= 1.0)
  {
    uint64_t v35 = 0x4040000000000000;
    if (v42[0] <= 32.0) {
      goto LABEL_50;
    }
  }
  else
  {
    uint64_t v35 = 0x3FF0000000000000;
  }
  *(void *)&v42[0] = v35;
LABEL_50:
  if (0.0 < 2.0)
  {
    *(double *)&uint64_t v38 = 2.0;
LABEL_54:
    double v41 = *(double *)&v38;
    goto LABEL_55;
  }
  if (0.0 > 4.0)
  {
    *(double *)&uint64_t v38 = 4.0;
    goto LABEL_54;
  }
LABEL_55:
  CFTypeRef v39 = v47;
  if (v47) {
    CFTypeRef v39 = CFRetain(v47);
  }
  *a3 = v39;
  CFTypeRef v40 = v45;
  if (v45) {
    CFTypeRef v40 = CFRetain(v45);
  }
  uint64_t v36 = 0;
  *a4 = v40;
  *a5 = (int)v42[1];
  *a6 = (int)v42[0];
  *a7 = (int)v41;
LABEL_37:
  if (cf) {
    CFRelease(cf);
  }
  if (v44) {
    CFRelease(v44);
  }
  if (v45) {
    CFRelease(v45);
  }
  if (v46) {
    CFRelease(v46);
  }
  if (v47) {
    CFRelease(v47);
  }
  return v36;
}

uint64_t clcpcgctsbGetFigCEA608DataGeneratorClosedCaptionMode()
{
  if (FigCFEqual()) {
    return 3;
  }
  if (FigCFEqual()) {
    return 2;
  }
  return 1;
}

uint64_t clcpcgctsbCreateCEA608DataGeneratorAttributedString(uint64_t a1, const __CFAllocator *a2, __CFAttributedString **a3)
{
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  CFTypeRef v8 = *(uint64_t (**)(uint64_t))(v7 + 8);
  if (v8) {
    CFStringRef v9 = (const __CFString *)v8(a1);
  }
  else {
    CFStringRef v9 = &stru_1EE53F4B8;
  }
  uint64_t Length = CFStringGetLength(v9);
  CFTypeRef cf = 0;
  CFArrayRef theArray = 0;
  CFMutableDataRef Mutable = CFAttributedStringCreateMutable(a2, Length);
  CFTypeRef v12 = Mutable;
  if (Mutable)
  {
    CFAttributedStringBeginEditing(Mutable);
    v66.CFIndex location = 0;
    v66.size_t length = 0;
    CFAttributedStringReplaceString(v12, v66, v9);
    uint64_t CMBaseObject = FigCaptionDataGetCMBaseObject();
    uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v14) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v16 = *(uint64_t (**)(uint64_t, void, const __CFAllocator *, CFArrayRef *))(v15 + 48);
    if (v16)
    {
      double v59 = a3;
      uint64_t v17 = v16(CMBaseObject, *MEMORY[0x1E4F1FF48], a2, &theArray);
      if (v17)
      {
LABEL_78:
        uint64_t v56 = v17;
      }
      else
      {
        if (theArray)
        {
          CFIndex Count = CFArrayGetCount(theArray);
          if (Count >= 1)
          {
            CFIndex v18 = 0;
            CFTypeRef value = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
            do
            {
              CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v18);
              CFIndex v61 = 0;
              CFIndex v62 = 0;
              while (FigCFRangeGetLimit() < Length)
              {
                uint64_t Limit = FigCFRangeGetLimit();
                uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 16);
                if (v21) {
                  uint64_t v22 = v21;
                }
                else {
                  uint64_t v22 = 0;
                }
                uint64_t v23 = *(uint64_t (**)(uint64_t, uint64_t, const void *, const __CFAllocator *, CFTypeRef *, CFIndex *))(v22 + 24);
                if (!v23) {
                  goto LABEL_69;
                }
                uint64_t v17 = v23(a1, Limit, ValueAtIndex, a2, &cf, &v61);
                if (v17) {
                  goto LABEL_78;
                }
                CFTypeRef v24 = cf;
                if (cf)
                {
                  CFIndex v26 = v61;
                  CFIndex v25 = v62;
                  CFGetAllocator(v12);
                  if (FigCFEqual())
                  {
                    CFTypeID v27 = CFGetTypeID(v24);
                    if (v27 == FigCaptionDynamicStyleGetTypeID())
                    {
                      if (FigCaptionDynamicStyleGetInitialValue())
                      {
                        Initialint Value = (const void *)FigCaptionDynamicStyleGetInitialValue();
                        CFTypeID v29 = CFGetTypeID(InitialValue);
                        if (v29 == CFNumberGetTypeID())
                        {
                          valuePtr[0] = 0;
                          CFNumberRef v30 = (const __CFNumber *)FigCaptionDynamicStyleGetInitialValue();
                          CFNumberGetValue(v30, kCFNumberSInt32Type, valuePtr);
                          if (valuePtr[0])
                          {
                            uint64_t v31 = v12;
                            v32.CFIndex location = v26;
                            v32.size_t length = v25;
                            CFStringRef v33 = @"Underline";
LABEL_36:
                            CFAttributedStringSetAttribute(v31, v32, v33, value);
                          }
                        }
                      }
                    }
                  }
                  else
                  {
                    if (!FigCFEqual())
                    {
                      if (FigCFEqual())
                      {
                        CFTypeID v37 = CFGetTypeID(v24);
                        if (v37 != FigCaptionDynamicStyleGetTypeID()) {
                          goto LABEL_62;
                        }
                        if (!FigCaptionDynamicStyleGetInitialValue()) {
                          goto LABEL_62;
                        }
                        uint64_t v38 = (const void *)FigCaptionDynamicStyleGetInitialValue();
                        CFTypeID v39 = CFGetTypeID(v38);
                        if (v39 != CGColorGetTypeID()) {
                          goto LABEL_62;
                        }
                        valuePtr[0] = 0;
                        CFTypeRef v40 = (CGColor *)FigCaptionDynamicStyleGetInitialValue();
                        if (!clcpcgctsbGetCEA608DataGeneratorColorFromCGColor(v40, valuePtr)) {
                          goto LABEL_62;
                        }
                        uint64_t SInt32 = FigCFNumberCreateSInt32();
                        if (SInt32)
                        {
                          uint64_t v42 = (const void *)SInt32;
                          uint64_t v43 = v12;
                          v44.CFIndex location = v26;
                          v44.size_t length = v25;
                          CFStringRef v45 = @"ForegroundColor";
LABEL_61:
                          CFAttributedStringSetAttribute(v43, v44, v45, v42);
                          CFRelease(v42);
                          goto LABEL_62;
                        }
                        goto LABEL_65;
                      }
                      if (!FigCFEqual()) {
                        goto LABEL_62;
                      }
                      CFTypeID v46 = CFGetTypeID(v24);
                      if (v46 != FigCaptionDynamicStyleGetTypeID()) {
                        goto LABEL_62;
                      }
                      if (!FigCaptionDynamicStyleGetInitialValue()) {
                        goto LABEL_62;
                      }
                      CFTypeRef v47 = (const void *)FigCaptionDynamicStyleGetInitialValue();
                      CFTypeID v48 = CFGetTypeID(v47);
                      if (v48 != CGColorGetTypeID()) {
                        goto LABEL_62;
                      }
                      valuePtr[0] = 0;
                      CMTime v49 = (CGColor *)FigCaptionDynamicStyleGetInitialValue();
                      if (clcpcgctsbGetCEA608DataGeneratorColorFromCGColor(v49, valuePtr))
                      {
                        unsigned int v50 = (const void *)FigCFNumberCreateSInt32();
                        if (!v50)
                        {
LABEL_65:
                          uint64_t v56 = FigSignalErrorAt();
                          if (v56) {
                            goto LABEL_70;
                          }
                          goto LABEL_62;
                        }
                        unsigned int v51 = v50;
                        v67.CFIndex location = v26;
                        v67.size_t length = v25;
                        CFAttributedStringSetAttribute(v12, v67, @"BackgroundColor", v50);
                        CFRelease(v51);
                      }
                      double v52 = (CGColor *)FigCaptionDynamicStyleGetInitialValue();
                      ColorSpace = CGColorGetColorSpace(v52);
                      if (CGColorSpaceGetModel(ColorSpace) != kCGColorSpaceModelRGB
                        || CGColorGetNumberOfComponents(v52) != 4)
                      {
                        goto LABEL_62;
                      }
                      double Alpha = CGColorGetAlpha(v52);
                      if ((Alpha < 0.0 || Alpha > 0.25)
                        && (Alpha <= 0.25 || Alpha >= 0.85)
                        && (Alpha < 0.85 || Alpha > 1.0))
                      {
                        goto LABEL_62;
                      }
                      uint64_t v55 = FigCFNumberCreateSInt32();
                      if (v55)
                      {
                        uint64_t v42 = (const void *)v55;
                        uint64_t v43 = v12;
                        v44.CFIndex location = v26;
                        v44.size_t length = v25;
                        CFStringRef v45 = @"BackgroundTransparency";
                        goto LABEL_61;
                      }
                      goto LABEL_65;
                    }
                    CFTypeID v34 = CFGetTypeID(v24);
                    if (v34 == FigCaptionDynamicStyleGetTypeID())
                    {
                      if (FigCaptionDynamicStyleGetInitialValue())
                      {
                        uint64_t v35 = (const void *)FigCaptionDynamicStyleGetInitialValue();
                        CFTypeID v36 = CFGetTypeID(v35);
                        if (v36 == CFStringGetTypeID())
                        {
                          FigCaptionDynamicStyleGetInitialValue();
                          if (FigCFEqual())
                          {
                            uint64_t v31 = v12;
                            v32.CFIndex location = v26;
                            v32.size_t length = v25;
                            CFStringRef v33 = @"Italic";
                            goto LABEL_36;
                          }
                        }
                      }
                    }
                  }
LABEL_62:
                  if (cf)
                  {
                    CFRelease(cf);
                    CFTypeRef cf = 0;
                  }
                }
              }
              ++v18;
            }
            while (v18 != Count);
          }
        }
        CFAttributedStringEndEditing(v12);
        uint64_t v56 = 0;
        *double v59 = v12;
        CFTypeRef v12 = 0;
      }
    }
    else
    {
LABEL_69:
      uint64_t v56 = 4294954514;
    }
LABEL_70:
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    uint64_t v56 = FigSignalErrorAt();
  }
  if (theArray) {
    CFRelease(theArray);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v56;
}

uint64_t clcpcgctsbGetCEA608DataGeneratorColorFromCGColor(CGColor *a1, int *a2)
{
  ColorSpace = CGColorGetColorSpace(a1);
  if (CGColorSpaceGetModel(ColorSpace) != kCGColorSpaceModelRGB || CGColorGetNumberOfComponents(a1) != 4) {
    return 0;
  }
  Components = CGColorGetComponents(a1);
  unsigned int v6 = llround(*Components);
  unsigned int v7 = llround(Components[1]);
  unsigned int v8 = llround(Components[2]);
  BOOL v9 = (v6 | v7) == 0;
  if (v6 | v7) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = v8 == 0;
  }
  if (v10)
  {
    int v11 = 7;
    goto LABEL_58;
  }
  if (v8 != 1) {
    BOOL v9 = 0;
  }
  if (v9)
  {
    int v11 = 2;
LABEL_58:
    *a2 = v11;
    return 1;
  }
  BOOL v13 = v6 == 1 && v7 == 0;
  if (v13 && v8 == 0)
  {
    int v11 = 4;
    goto LABEL_58;
  }
  if (v8 != 1) {
    LOBYTE(v13) = 0;
  }
  if (v13)
  {
    int v11 = 6;
    goto LABEL_58;
  }
  if (v6) {
    BOOL v15 = 0;
  }
  else {
    BOOL v15 = v7 == 1;
  }
  int v16 = v15;
  if (v16 == 1 && v8 == 0)
  {
    int v11 = 1;
    goto LABEL_58;
  }
  if (v8 != 1) {
    LOBYTE(v16) = 0;
  }
  if (v16)
  {
    int v11 = 3;
    goto LABEL_58;
  }
  BOOL v19 = v6 == 1 && v7 == 1;
  if (v19 && v8 == 0)
  {
    int v11 = 5;
    goto LABEL_58;
  }
  int v11 = 0;
  uint64_t result = 0;
  if (v8 == 1 && v19) {
    goto LABEL_58;
  }
  return result;
}

uint64_t clcpcgctsbOutputAndReleaseLastCCData(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (!v2) {
    return v2;
  }
  CFIndex v4 = (_OWORD *)(a1 + 96);
  CMTime v21 = *(CMTime *)(a1 + 96);
  memset(&v20, 0, sizeof(v20));
  if ((~*(_DWORD *)(a2 + 12) & 0x11) != 0)
  {
    *(_OWORD *)&lhs.duration.CFTypeRef value = *(_OWORD *)a2;
    lhs.duration.CMTimeEpoch epoch = *(void *)(a2 + 16);
    *(_OWORD *)&rhs.CFTypeRef value = *v4;
    rhs.CMTimeEpoch epoch = *(void *)(a1 + 112);
    CMTimeSubtract(&v20, &lhs.duration, &rhs);
    uint64_t v2 = *(void *)(a1 + 88);
  }
  else
  {
    CMTime v20 = *(CMTime *)(a1 + 120);
  }
  unsigned int v5 = *(_DWORD *)(a1 + 20);
  unsigned int v6 = *(const opaqueCMFormatDescription **)(a1 + 24);
  CFAllocatorRef v7 = *(const __CFAllocator **)a1;
  CMTime rhs = v20;
  CMSampleBufferRef v25 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  unint64_t sourceBytes = 0;
  BytePtr = CFDataGetBytePtr((CFDataRef)v2);
  CFIndex Length = CFDataGetLength((CFDataRef)v2);
  size_t v10 = Length + 8;
  size_t sampleSizeArray = Length + 8;
  if ((unint64_t)(Length + 8) >> 32)
  {
    uint64_t v12 = FigSignalErrorAt();
LABEL_23:
    uint64_t v2 = v12;
LABEL_24:
    CMSampleBufferRef v13 = 0;
    goto LABEL_11;
  }
  size_t v11 = Length;
  uint64_t v12 = CMBlockBufferCreateWithMemoryBlock(v7, 0, v10, v7, 0, 0, v10, 1u, &blockBufferOut);
  if (v12) {
    goto LABEL_23;
  }
  unint64_t sourceBytes = _byteswap_uint64(__PAIR64__(v10, v5));
  uint64_t v12 = CMBlockBufferReplaceDataBytes(&sourceBytes, blockBufferOut, 0, 8uLL);
  if (v12) {
    goto LABEL_23;
  }
  uint64_t v12 = CMBlockBufferReplaceDataBytes(BytePtr, blockBufferOut, 8uLL, v11);
  if (v12) {
    goto LABEL_23;
  }
  lhs.CMTimeRange duration = rhs;
  lhs.CMTime presentationTimeStamp = v21;
  lhs.decodeTimeStamp = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  uint64_t v2 = CMSampleBufferCreate(v7, blockBufferOut, 1u, 0, 0, v6, 1, 1, &lhs, 1, &sampleSizeArray, &v25);
  CMSampleBufferRef v13 = v25;
  if (v2)
  {
    if (!v25) {
      goto LABEL_11;
    }
    CFRelease(v25);
    goto LABEL_24;
  }
  CMSampleBufferRef v25 = 0;
LABEL_11:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  if (!v2)
  {
    uint64_t v14 = (*(uint64_t (**)(CMSampleBufferRef, void))(a1 + 144))(v13, *(void *)(a1 + 152));
    if (v14)
    {
      uint64_t v2 = v14;
      if (!v13) {
        return v2;
      }
      goto LABEL_20;
    }
    uint64_t v15 = MEMORY[0x1E4F1FA20];
    long long v16 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
    *CFIndex v4 = *MEMORY[0x1E4F1FA20];
    v4[1] = v16;
    _DWORD v4[2] = *(_OWORD *)(v15 + 32);
    uint64_t v17 = *(const void **)(a1 + 88);
    if (v17)
    {
      CFRelease(v17);
      uint64_t v2 = 0;
      *(void *)(a1 + 88) = 0;
      if (!v13) {
        return v2;
      }
      goto LABEL_20;
    }
    uint64_t v2 = 0;
  }
  if (v13) {
LABEL_20:
  }
    CFRelease(v13);
  return v2;
}

void clcpccv_Finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigCEA608DataGeneratorRelease(*(void **)(DerivedStorage + 8));
  CFArrayRef v1 = *(const void **)(DerivedStorage + 32);
  if (v1) {
    CFRelease(v1);
  }
  uint64_t v2 = *(const void **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    CFRelease(v2);
  }
}

__CFString *clcpccv_CopyDebugDescription(uint64_t a1)
{
  CFMutableDataRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigCLCPCaptionConversionValidator %p>", a1);
  return Mutable;
}

uint64_t clcpccv_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFDictionaryRef *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2 && a4)
  {
    uint64_t v8 = DerivedStorage;
    if (!CFEqual(@"TimeRange", a2)) {
      return 4294954512;
    }
    long long v9 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
    *(_OWORD *)&v13.start.CFTypeRef value = *MEMORY[0x1E4F1FA20];
    *(_OWORD *)&v13.start.CMTimeEpoch epoch = v9;
    *(_OWORD *)&v13.duration.CMTimeScale timescale = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
    uint64_t TimeLineRange = FigCEA608DataGeneratorGetTimeLineRange(*(void *)(v8 + 8), &v13);
    if (!TimeLineRange)
    {
      CMTimeRange v12 = v13;
      *a4 = CMTimeRangeCopyAsDictionary(&v12, a3);
    }
    return TimeLineRange;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t clcpccv_SetProperty(uint64_t a1, const void *a2, const __CFDictionary *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2) {
    goto LABEL_14;
  }
  uint64_t v6 = DerivedStorage;
  if (!CFEqual(@"TimeRange", a2)) {
    return 4294954512;
  }
  if (a3 && (CFTypeID v7 = CFGetTypeID(a3), v7 == CFDictionaryGetTypeID()))
  {
    memset(&v11, 0, sizeof(v11));
    CMTimeRangeMakeFromDictionary(&v11, a3);
    if ((v11.start.flags & 1) == 0
      || (v11.duration.flags & 1) == 0
      || v11.duration.epoch
      || v11.duration.value < 0
      || *(_DWORD *)(v6 + 16) == 1)
    {
      return FigSignalErrorAt();
    }
    else
    {
      uint64_t v8 = *(void *)(v6 + 8);
      CMTimeRange v10 = v11;
      return FigCEA608DataGeneratorSetTimeLineRange(v8, (long long *)&v10.start.value);
    }
  }
  else
  {
LABEL_14:
    return FigSignalErrorAt();
  }
}

uint64_t clcpccv_AppendAndValidateCaptionData(uint64_t a1, const void *a2, long long *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2
    || (*((unsigned char *)a3 + 12) & 1) == 0
    || (*((unsigned char *)a3 + 36) & 1) == 0
    || *((void *)a3 + 5)
    || (*((void *)a3 + 3) & 0x8000000000000000) != 0
    || (uint64_t v7 = DerivedStorage, *(_DWORD *)(DerivedStorage + 16) == 2))
  {
    return FigSignalErrorAt();
  }
  else
  {
    *(_OWORD *)&v20.start.CFTypeRef value = *a3;
    *(_OWORD *)&v20.start.CMTimeEpoch epoch = a3[1];
    *(_OWORD *)&v20.duration.CMTimeScale timescale = a3[2];
    long long v8 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
    *(_OWORD *)&range1.start.CFTypeRef value = *MEMORY[0x1E4F1FA20];
    *(_OWORD *)&range1.start.CMTimeEpoch epoch = v8;
    *(_OWORD *)&range1.duration.CMTimeScale timescale = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
    uint64_t result = FigCEA608DataGeneratorGetTimeLineRange(*(void *)(DerivedStorage + 8), &range1);
    if (result) {
      return result;
    }
    memset(&range2, 0, sizeof(range2));
    CMTimeRange range = range1;
    CMTimeRange otherRange = v20;
    CMTimeRangeGetIntersection(&range2, &range, &otherRange);
    long long v18 = *(_OWORD *)(MEMORY[0x1E4F1FA30] + 16);
    long long v19 = *MEMORY[0x1E4F1FA30];
    *(_OWORD *)&range.start.CFTypeRef value = *MEMORY[0x1E4F1FA30];
    *(_OWORD *)&range.start.CMTimeEpoch epoch = v18;
    long long v17 = *(_OWORD *)(MEMORY[0x1E4F1FA30] + 32);
    *(_OWORD *)&range.duration.CMTimeScale timescale = v17;
    CMTimeRange otherRange = range2;
    if (CMTimeRangeEqual(&range, &otherRange)) {
      goto LABEL_21;
    }
    long long v9 = *(_OWORD *)(v7 + 56);
    *(_OWORD *)&range1.start.CFTypeRef value = *(_OWORD *)(v7 + 40);
    *(_OWORD *)&range1.start.CMTimeEpoch epoch = v9;
    *(_OWORD *)&range1.duration.CMTimeScale timescale = *(_OWORD *)(v7 + 72);
    long long v10 = a3[1];
    *(_OWORD *)&range2.start.CFTypeRef value = *a3;
    *(_OWORD *)&range2.start.CMTimeEpoch epoch = v10;
    *(_OWORD *)&range2.duration.CMTimeScale timescale = a3[2];
    if (CMTimeRangeEqual(&range1, &range2))
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(v7 + 32), a2);
      ++*(void *)(v7 + 96);
LABEL_21:
      uint64_t result = 0;
      ++*(void *)(v7 + 24);
      *(_DWORD *)(v7 + 16) = 1;
      return result;
    }
    long long v11 = *(_OWORD *)(v7 + 56);
    *(_OWORD *)&range2.start.CFTypeRef value = *(_OWORD *)(v7 + 40);
    *(_OWORD *)&range2.start.CMTimeEpoch epoch = v11;
    *(_OWORD *)&range2.duration.CMTimeScale timescale = *(_OWORD *)(v7 + 72);
    memset(&range1, 0, sizeof(range1));
    long long v12 = a3[1];
    *(_OWORD *)&range.start.CFTypeRef value = *a3;
    *(_OWORD *)&range.start.CMTimeEpoch epoch = v12;
    *(_OWORD *)&range.duration.CMTimeScale timescale = a3[2];
    CMTimeRangeGetIntersection(&range1, &range2, &range);
    *(_OWORD *)&range2.start.CFTypeRef value = v19;
    *(_OWORD *)&range2.start.CMTimeEpoch epoch = v18;
    *(_OWORD *)&range2.duration.CMTimeScale timescale = v17;
    CMTimeRange range = range1;
    if (!CMTimeRangeEqual(&range2, &range))
    {
      *(_OWORD *)&range.start.CFTypeRef value = *(_OWORD *)(v7 + 64);
      range.start.CMTimeEpoch epoch = *(void *)(v7 + 80);
      otherRange.CMTime start = range1.duration;
      CMTimeSubtract(&range2.start, &range.start, &otherRange.start);
      *(_OWORD *)(v7 + 64) = *(_OWORD *)&range2.start.value;
      *(void *)(v7 + 80) = range2.start.epoch;
    }
    uint64_t result = cclcpccvAppendCaptionDataWithSameTimeRange(v7);
    if (!result)
    {
      CMTimeRange v13 = *(const void **)(v7 + 32);
      if (v13)
      {
        CFRelease(v13);
        *(void *)(v7 + 32) = 0;
      }
      CFMutableDataRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)v7, 0, MEMORY[0x1E4F1D510]);
      *(void *)(v7 + 32) = Mutable;
      if (!Mutable) {
        return FigSignalErrorAt();
      }
      CFArrayAppendValue(Mutable, a2);
      long long v15 = *a3;
      long long v16 = a3[2];
      *(_OWORD *)(v7 + 56) = a3[1];
      *(_OWORD *)(v7 + 72) = v16;
      *(_OWORD *)(v7 + 40) = v15;
      *(void *)(v7 + 88) = *(void *)(v7 + 24);
      *(void *)(v7 + 96) = 1;
      goto LABEL_21;
    }
  }
  return result;
}

uint64_t clcpccv_Finish()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = cclcpccvAppendCaptionDataWithSameTimeRange(DerivedStorage);
  if (!result)
  {
    uint64_t result = FigCEA608DataGeneratorFinish(*(void *)(DerivedStorage + 8));
    if (!result) {
      *(_DWORD *)(DerivedStorage + 16) = 2;
    }
  }
  return result;
}

uint64_t cclcpccvAppendCaptionDataWithSameTimeRange(uint64_t a1)
{
  uint64_t v32 = *(void *)(a1 + 8);
  CFAllocatorRef allocator = *(const __CFAllocator **)a1;
  CFArrayRef v1 = *(const __CFArray **)(a1 + 32);
  long long v2 = *(_OWORD *)(a1 + 56);
  long long v46 = *(_OWORD *)(a1 + 40);
  long long v47 = v2;
  long long v48 = *(_OWORD *)(a1 + 72);
  if (!v1)
  {
    CFTypeRef v44 = 0;
    CFTypeRef v45 = 0;
    uint64_t v43 = 0;
    goto LABEL_25;
  }
  CFIndex Count = CFArrayGetCount(v1);
  CFTypeRef v44 = 0;
  CFTypeRef v45 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  if (!Count)
  {
LABEL_25:
    FigCEA608DataGeneratorCaptionInfoRelease(0);
    uint64_t v18 = 0;
    goto LABEL_46;
  }
  CFIndex v4 = Count;
  if (Count < 1)
  {
    int v7 = 0;
LABEL_27:
    long long v19 = *MEMORY[0x1E4F1FA48];
    *(_OWORD *)&v38.CFTypeRef value = v19;
    CMTimeEpoch v20 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
    v38.CMTimeEpoch epoch = v20;
    *(_OWORD *)&v37.CFTypeRef value = v19;
    v37.CMTimeEpoch epoch = v20;
    *(_OWORD *)CFAllocatorRef allocatora = v19;
    if (!v7
      || (uint64_t v10 = FigCEA608DataGeneratorEndCaption(v32, &v38, &v37, 0), v19 = *(_OWORD *)allocatora, !v10))
    {
      *(CMTime *)CMTimeRange time1 = v38;
      *(_OWORD *)&time2.CFTypeRef value = v19;
      time2.CMTimeEpoch epoch = v20;
      if (!CMTimeCompare((CMTime *)time1, &time2)
        && (*(CMTime *)CMTimeRange time1 = v37,
            *(_OWORD *)&time2.CFTypeRef value = *(_OWORD *)allocatora,
            time2.CMTimeEpoch epoch = v20,
            !CMTimeCompare((CMTime *)time1, &time2))
        || (time2 = v38, CMTime v35 = v37, !*(void *)(a1 + 104)))
      {
        uint64_t v18 = 0;
        goto LABEL_45;
      }
      CFAllocatorRef v21 = *(const __CFAllocator **)a1;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(*(CFAllocatorRef *)a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        uint64_t v23 = Mutable;
        uint64_t v24 = FigCFDictionarySetInt32();
        if (!v24)
        {
          CFMutableDictionaryRef v25 = CFDictionaryCreateMutable(v21, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (v25)
          {
            CFMutableDictionaryRef v26 = v25;
            uint64_t v27 = FigCFDictionarySetCFIndex();
            if (!v27)
            {
              uint64_t v27 = FigCFDictionarySetCFIndex();
              if (!v27)
              {
                CFDictionarySetValue(v23, @"CaptionRange", v26);
                CFMutableDictionaryRef v28 = CFDictionaryCreateMutable(v21, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                if (v28)
                {
                  uint64_t v29 = FigCFDictionarySetInt32();
                  if (v29
                    || (*(CMTime *)time1 = time2, uint64_t v29 = FigCFDictionarySetCMTime(), v29)
                    || (*(CMTime *)time1 = v35, uint64_t v29 = FigCFDictionarySetCMTime(), v29))
                  {
                    uint64_t v18 = v29;
                    goto LABEL_42;
                  }
LABEL_41:
                  CFDictionarySetValue(v23, @"Adjustment", v28);
                  uint64_t v18 = (*(uint64_t (**)(__CFDictionary *, void))(a1 + 104))(v23, *(void *)(a1 + 112));
                  if (!v28)
                  {
LABEL_43:
                    CFRelease(v26);
LABEL_44:
                    CFRelease(v23);
LABEL_45:
                    FigCEA608DataGeneratorCaptionInfoRelease(v43);
                    goto LABEL_46;
                  }
LABEL_42:
                  CFRelease(v28);
                  goto LABEL_43;
                }
                uint64_t v27 = FigSignalErrorAt();
                if (!v27) {
                  goto LABEL_41;
                }
              }
            }
            uint64_t v18 = v27;
            goto LABEL_43;
          }
          uint64_t v24 = FigSignalErrorAt();
        }
        uint64_t v18 = v24;
        goto LABEL_44;
      }
LABEL_54:
      uint64_t v10 = FigSignalErrorAt();
    }
LABEL_55:
    uint64_t v18 = v10;
    goto LABEL_45;
  }
  CFIndex v5 = 0;
  uint64_t v6 = 0;
  int v7 = 0;
  while (1)
  {
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v1, v5);
    unsigned int v9 = clcpcgctsbDoesCaptioDataHaveText((uint64_t)ValueAtIndex);
    LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 0;
    LODWORD(v35.CFDictionarySetValue(theDict, key, value) = 0;
    int v41 = 0;
    if (v9) {
      break;
    }
    uint64_t v15 = v6;
LABEL_22:
    ++v5;
    uint64_t v6 = v15;
    if (v4 == v5) {
      goto LABEL_27;
    }
  }
  uint64_t v10 = clcpcgctsbCopyCaptionAnimationAndRegionInformation((uint64_t)ValueAtIndex, (uint64_t)allocator, &v45, &v44, &time2, &v35, &v41);
  if (v10) {
    goto LABEL_55;
  }
  CFArrayRef v11 = v1;
  CFTypeRef v13 = v44;
  CFTypeRef v12 = v45;
  uint64_t FigCEA608DataGeneratorClosedCaptionMode = clcpcgctsbGetFigCEA608DataGeneratorClosedCaptionMode();
  uint64_t v15 = FigCEA608DataGeneratorClosedCaptionMode;
  if (v6 && v6 != FigCEA608DataGeneratorClosedCaptionMode) {
    goto LABEL_54;
  }
  if (!v7)
  {
    *(_OWORD *)CMTimeRange time1 = v46;
    *(_OWORD *)&time1[16] = v47;
    long long v40 = v48;
    uint64_t v10 = FigCEA608DataGeneratorCaptionInfoCreate(FigCEA608DataGeneratorClosedCaptionMode, v41, (long long *)time1, allocator, &v43);
    if (v10) {
      goto LABEL_55;
    }
    *(_OWORD *)CMTimeRange time1 = *MEMORY[0x1E4F1F9F8];
    *(void *)&time1[16] = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
    uint64_t v10 = FigCEA608DataGeneratorBeginCaption(v32, (long long *)time1, 0, (uint64_t)v43);
    if (v10) {
      goto LABEL_55;
    }
  }
  uint64_t v16 = clcpcgctsbCreateCEA608DataGeneratorAttributedString((uint64_t)ValueAtIndex, allocator, &v42);
  long long v17 = v42;
  if (!v16)
  {
    uint64_t v16 = FigCEA608DataGeneratorAddCaptionLine(v32, time2.value, v35.value, v42);
    if (!v16)
    {
      if (v17)
      {
        CFRelease(v17);
        uint64_t v42 = 0;
      }
      if (v13)
      {
        CFRelease(v13);
        CFTypeRef v44 = 0;
      }
      if (v12)
      {
        CFRelease(v12);
        CFTypeRef v45 = 0;
      }
      int v7 = 1;
      CFArrayRef v1 = v11;
      goto LABEL_22;
    }
  }
  uint64_t v18 = v16;
  FigCEA608DataGeneratorCaptionInfoRelease(v43);
  if (v17) {
    CFRelease(v17);
  }
LABEL_46:
  if (v44) {
    CFRelease(v44);
  }
  if (v45) {
    CFRelease(v45);
  }
  return v18;
}

uint64_t FigCaptionRendererNodeProtocolGetProtocolID()
{
  return sFigCaptionRendererNodeProtocolID;
}

uint64_t RegisterFigCaptionRendererNodeProtocolType()
{
  return MEMORY[0x1F40DC660](&sFigCaptionRendererNodeProtocolDesc, 0, &sFigCaptionRendererNodeProtocolID);
}

uint64_t RTMStartGeneralRecording(int a1, void *a2)
{
  CFIndex v4 = malloc_type_calloc(1uLL, 0x68uLL, 0x1000040ED882C02uLL);
  if (!v4) {
    return 4294967188;
  }
  CFIndex v5 = v4;
  if (a1 && (uint64_t v6 = TakeGeneralMeasurements((uint64_t)v4), v6))
  {
    uint64_t v7 = v6;
    free(v5);
  }
  else
  {
    GetElapsedTime(v5 + 2);
    uint64_t v7 = 0;
    *a2 = v5;
  }
  return v7;
}

uint64_t TakeGeneralMeasurements(uint64_t a1)
{
  *(_OWORD *)task_info_out = 0u;
  long long v14 = 0u;
  long long v2 = (unsigned int *)MEMORY[0x1E4F14960];
  task_name_t v3 = *MEMORY[0x1E4F14960];
  if (!gMallocInst_0)
  {
    CFIndex v4 = malloc_default_zone();
    gMallocInst_0 = (uint64_t (*)(void))v4->malloc;
    gMallocInst_1 = (uint64_t (*)(void))v4->calloc;
    gMallocInst_2 = (uint64_t (*)(void))v4->valloc;
    gMallocInst_3 = v4->free;
    gMallocInst_4 = (uint64_t (*)(void, void, void))v4->realloc;
    v4->malloc = (void *(__cdecl *)(_malloc_zone_t *, size_t))instrum_malloc;
    v4->calloc = (void *(__cdecl *)(_malloc_zone_t *, size_t, size_t))instrum_calloc;
    v4->valloc = (void *(__cdecl *)(_malloc_zone_t *, size_t))instrum_valloc;
    v4->free = (void (__cdecl *)(_malloc_zone_t *, void *))instrum_free;
    v4->realloc = (void *(__cdecl *)(_malloc_zone_t *, void *, size_t))instrum_realloc;
  }
  mach_msg_type_number_t task_info_outCnt = 8;
  uint64_t result = task_info(v3, 1u, task_info_out, &task_info_outCnt);
  if (!result)
  {
    uint64_t v6 = *(void *)task_info_out;
    unsigned int v7 = dword_1E934D42C;
    if (!dword_1E934D42C)
    {
      mach_timebase_info((mach_timebase_info_t)&AbsoluteToMicroseconds_sTimebaseInfo);
      unsigned int v7 = dword_1E934D42C;
    }
    uint64_t v8 = AbsoluteToMicroseconds_sTimebaseInfo;
    uint64_t v9 = v7;
    *(void *)a1 = v6 * AbsoluteToMicroseconds_sTimebaseInfo / v7 / 1000;
    uint64_t v10 = *(void *)&task_info_out[2];
    if (!v7)
    {
      mach_timebase_info((mach_timebase_info_t)&AbsoluteToMicroseconds_sTimebaseInfo);
      uint64_t v8 = AbsoluteToMicroseconds_sTimebaseInfo;
      uint64_t v9 = dword_1E934D42C;
    }
    *(void *)(a1 + 8) = v10 * v8 / v9 / 1000;
    GetElapsedTime((void *)(a1 + 16));
    *(_OWORD *)(a1 + 24) = 0u;
    *(void *)(a1 + 72) = 0;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    uint64_t result = AddTotalForVMObject(*v2, 0, 0, (int64x2_t *)(a1 + 24), &v15);
    if (result <= 1)
    {
      uint64_t result = 0;
      uint64_t v11 = gMallocInst_7;
      *(void *)(a1 + 80) = gMallocInst_5;
      *(void *)(a1 + 88) = v11;
      *(void *)(a1 + 96) = gMallocInst_6;
    }
  }
  return result;
}

uint64_t GetElapsedTime(void *a1)
{
  uint64_t result = mach_absolute_time();
  uint64_t v3 = result;
  unsigned int v4 = dword_1E934D42C;
  if (!dword_1E934D42C)
  {
    uint64_t result = mach_timebase_info((mach_timebase_info_t)&AbsoluteToMicroseconds_sTimebaseInfo);
    unsigned int v4 = dword_1E934D42C;
  }
  uint64_t v5 = (unsigned __int128)((uint64_t)(v3 * AbsoluteToMicroseconds_sTimebaseInfo)
                         / v4
                         * (__int128)0x20C49BA5E353F7CFLL) >> 64;
  *a1 = (v5 >> 7) + ((unint64_t)v5 >> 63);
  return result;
}

uint64_t RTMCopyGeneralMetrics(int64x2_t *a1, const void *a2, __CFDictionary **a3)
{
  uint64_t v22 = 0;
  int64x2_t v20 = 0u;
  long long v21 = 0u;
  int64x2_t v18 = 0u;
  int64x2_t v19 = 0u;
  int64x2_t v16 = 0u;
  int64x2_t v17 = 0u;
  uint64_t v6 = TakeGeneralMeasurements((uint64_t)&v16);
  if (v6) {
    return v6;
  }
  int64x2_t v7 = vsubq_s64(v17, a1[1]);
  int64x2_t v16 = vsubq_s64(v16, *a1);
  int64x2_t v17 = v7;
  int64x2_t v8 = vsubq_s64(v18, a1[2]);
  int64x2_t v9 = vsubq_s64(v19, a1[3]);
  uint64_t v10 = v22 - a1[6].i64[0];
  *(void *)&long long v21 = v21 - a1[5].i64[0];
  uint64_t v22 = v10;
  int64x2_t v18 = v8;
  int64x2_t v19 = v9;
  int64x2_t v20 = vsubq_s64(v20, a1[4]);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 4294967188;
  }
  CFTypeRef v12 = Mutable;
  if (a2) {
    CFDictionarySetValue(Mutable, @"Label", a2);
  }
  uint64_t v13 = FigCFDictionarySetInt64();
  if (v13
    || (uint64_t v13 = FigCFDictionarySetInt64(), v13)
    || (uint64_t v13 = FigCFDictionarySetInt64(), v13)
    || (uint64_t v13 = FigCFDictionarySetInt64(), v13)
    || (uint64_t v13 = FigCFDictionarySetInt64(), v13)
    || (uint64_t v13 = FigCFDictionarySetInt64(), v13)
    || (uint64_t v13 = FigCFDictionarySetInt64(), v13)
    || (uint64_t v13 = FigCFDictionarySetInt64(), v13))
  {
    uint64_t v14 = v13;
    goto LABEL_17;
  }
  uint64_t v14 = FigCFDictionarySetInt64();
  if (v14)
  {
LABEL_17:
    CFRelease(v12);
    return v14;
  }
  *a3 = v12;
  return v14;
}

uint64_t RTMWriteResultsToFile(CFPropertyListRef propertyList, FILE *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  CFDataRef Data = CFPropertyListCreateData(0, propertyList, kCFPropertyListXMLFormat_v1_0, 0, 0);
  if (!Data) {
    return 4294967188;
  }
  CFDataRef v4 = Data;
  size_t Length = CFDataGetLength(Data);
  snprintf(__str, 0xAuLL, "0x%8.8lx", Length);
  fwrite(__str, 0xAuLL, 1uLL, a2);
  BytePtr = CFDataGetBytePtr(v4);
  fwrite(BytePtr, Length, 1uLL, a2);
  CFRelease(v4);
  return 0;
}

uint64_t RTMReadResultsFromFile(FILE *a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = MEMORY[0x1E4F14390];
  do
  {
    while (1)
    {
      char v5 = getc(a1);
      int v6 = v5;
      if (v5 < 0) {
        break;
      }
      if ((*(_DWORD *)(v4 + 4 * v5 + 60) & 0x4000) == 0) {
        goto LABEL_6;
      }
    }
  }
  while (__maskrune(v5, 0x4000uLL));
LABEL_6:
  ungetc(v6, a1);
  if (fread(__ptr, 1uLL, 0xAuLL, a1) != 10) {
    return 4294967090;
  }
  __ptr[10] = 0;
  int64_t v7 = strtol(__ptr, 0, 0);
  if (v7 >= 0x10000) {
    return 4294967090;
  }
  CFIndex v8 = v7;
  uint64_t v9 = (UInt8 *)malloc_type_malloc(v7, 0x7AEB3013uLL);
  if (!v9) {
    return 4294967188;
  }
  uint64_t v10 = v9;
  if (fread(v9, 1uLL, v8, a1) == v8)
  {
    CFDataRef v11 = CFDataCreateWithBytesNoCopy(0, v10, v8, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (v11)
    {
      CFDataRef v12 = v11;
      CFPropertyListRef v13 = CFPropertyListCreateWithData(0, v11, 0, 0, 0);
      *a2 = v13;
      if (v13) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = 4294967090;
      }
      CFRelease(v12);
    }
    else
    {
      uint64_t v14 = 4294967188;
    }
  }
  else
  {
    uint64_t v14 = 4294967090;
  }
  free(v10);
  return v14;
}

uint64_t instrum_malloc(uint64_t a1, uint64_t a2)
{
  uint64_t result = gMallocInst_0();
  if (result)
  {
    gMallocInst_5 += a2;
    if (gMallocInst_7 < (unint64_t)gMallocInst_5) {
      gMallocInst_7 = gMallocInst_5;
    }
    gMallocInst_6 += a2;
  }
  return result;
}

uint64_t instrum_calloc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = gMallocInst_1();
  if (result)
  {
    unint64_t v6 = gMallocInst_5 + a3 * a2;
    gMallocInst_5 = v6;
    if (gMallocInst_7 < v6) {
      gMallocInst_7 = v6;
    }
    gMallocInst_6 += a3 * a2;
  }
  return result;
}

uint64_t instrum_valloc(uint64_t a1, uint64_t a2)
{
  uint64_t result = gMallocInst_2();
  if (result)
  {
    gMallocInst_5 += a2;
    if (gMallocInst_7 < (unint64_t)gMallocInst_5) {
      gMallocInst_7 = gMallocInst_5;
    }
    gMallocInst_6 += a2;
  }
  return result;
}

uint64_t instrum_free(uint64_t a1, void *ptr)
{
  if (ptr)
  {
    size_t v4 = malloc_size(ptr);
    uint64_t v5 = gMallocInst_5 - v4;
    if (gMallocInst_5 < v4) {
      uint64_t v5 = 0;
    }
    gMallocInst_5 = v5;
  }
  unint64_t v6 = (uint64_t (*)(uint64_t, void *))gMallocInst_3;

  return v6(a1, ptr);
}

uint64_t instrum_realloc(uint64_t a1, void *ptr, uint64_t a3)
{
  if (ptr) {
    size_t v6 = malloc_size(ptr);
  }
  else {
    size_t v6 = 0;
  }
  uint64_t result = gMallocInst_4(a1, ptr, a3);
  if (result)
  {
    unint64_t v8 = a3 - v6 + gMallocInst_5;
    if (gMallocInst_5 + a3 <= v6) {
      unint64_t v8 = 0;
    }
    gMallocInst_5 = v8;
    if (gMallocInst_7 < v8) {
      gMallocInst_7 = v8;
    }
    gMallocInst_6 += a3;
  }
  return result;
}

uint64_t AddTotalForVMObject(uint64_t a1, vm_address_t a2, natural_t a3, int64x2_t *a4, vm_address_t *a5)
{
  natural_t nesting_depth = a3;
  long long v25 = 0u;
  memset(v26, 0, sizeof(v26));
  *(_OWORD *)info = 0u;
  long long v24 = 0u;
  mach_msg_type_number_t infoCnt = 19;
  vm_address_t address = a2;
  vm_size_t size = 0;
  int64x2_t v19 = vdupq_n_s64(1uLL);
  uint64_t v9 = (uint64_t *)MEMORY[0x1E4F14B00];
  while (1)
  {
    uint64_t v10 = vm_region_recurse_64(a1, &address, &size, &nesting_depth, info, &infoCnt);
    if (v10) {
      break;
    }
    if (nesting_depth < a3)
    {
      uint64_t v11 = 0;
      *a5 = address;
      return v11;
    }
    if (v26[0])
    {
      uint64_t v11 = AddTotalForVMObject(a1, address, nesting_depth + 1, a4, &address);
      if (v11) {
        return v11;
      }
    }
    else
    {
      int v12 = HIBYTE(v25);
      vm_size_t v13 = size;
      if (HIBYTE(v25) == 3) {
        goto LABEL_15;
      }
      v14.i64[1] = v19.i64[1];
      v14.i64[0] = size;
      *a4 = vaddq_s64(*a4, v14);
      uint64_t v15 = *v9;
      a4[1].i64[0] += *v9 * DWORD2(v24);
      if ((v12 - 4) < 2 || v12 == 1)
      {
        vm_size_t v16 = v15 * HIDWORD(v24);
        uint64_t v17 = a4[2].i64[0] + v16;
        a4[1].i64[1] = a4[1].i64[1] + v13 - v16;
        a4[2].i64[0] = v17;
        if ((info[0] & 2) == 0) {
          goto LABEL_15;
        }
LABEL_14:
        a4[2].i64[1] += v16;
        goto LABEL_15;
      }
      if (v12 == 2)
      {
        a4[2].i64[0] += v13;
        vm_size_t v16 = v13;
        if ((info[0] & 2) != 0) {
          goto LABEL_14;
        }
      }
LABEL_15:
      address += v13;
    }
  }
  uint64_t v11 = v10;
  if (v10 != 1) {
    FigSignalErrorAt();
  }
  return v11;
}

uint64_t FigTextSampleBufferCopyText(opaqueCMSampleBuffer *a1, CFStringRef *a2)
{
  CMFormatDescriptionRef FormatDescription = CMSampleBufferGetFormatDescription(a1);
  CMBlockBufferRef DataBuffer = CMSampleBufferGetDataBuffer(a1);
  uint64_t DataPointer = 0;
  if (!FormatDescription) {
    return DataPointer;
  }
  int64_t v7 = DataBuffer;
  if (!DataBuffer) {
    return DataPointer;
  }
  FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(FormatDescription);
  if (MediaSubType == 1954034535 || MediaSubType == 1952807028)
  {
    UInt8 bytes = 0;
    uint64_t DataPointer = CMBlockBufferAccessDataBytes(v7, 0, 2uLL, temporaryBlock, (char **)&bytes);
    if (DataPointer) {
      return DataPointer;
    }
    CFStringEncoding v9 = 134217984;
    size_t v10 = __rev16(*(unsigned __int16 *)bytes);
    if (v10 >= 3
      && !CMBlockBufferAccessDataBytes(v7, 2uLL, 2uLL, temporaryBlock, (char **)&bytes)
      && *bytes == 254)
    {
      if (bytes[1] == 255) {
        CFStringEncoding v9 = 256;
      }
      else {
        CFStringEncoding v9 = 134217984;
      }
    }
    if (CMBlockBufferGetDataLength(v7) < (v10 + 2)) {
      return FigSignalErrorAt();
    }
    if (CMBlockBufferIsRangeContiguous(v7, 2uLL, v10))
    {
      uint64_t DataPointer = CMBlockBufferGetDataPointer(v7, 2uLL, 0, 0, (char **)&bytes);
      if (DataPointer) {
        return DataPointer;
      }
      int v12 = 0;
      vm_size_t v13 = bytes;
    }
    else
    {
      int64x2_t v14 = (UInt8 *)malloc_type_malloc(v10, 0xF89627ACuLL);
      if (!v14) {
        return FigSignalErrorAt();
      }
      vm_size_t v13 = v14;
      uint64_t DataPointer = CMBlockBufferCopyDataBytes(v7, 2uLL, v10, v14);
      UInt8 bytes = v13;
      int v12 = v13;
    }
    CFStringRef v15 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v13, v10, v9, 1u);
    if (a2)
    {
      *a2 = v15;
    }
    else if (v15)
    {
      CFRelease(v15);
    }
    if (v12) {
      free(v12);
    }
    return DataPointer;
  }

  return FigSignalErrorAt();
}

uint64_t TMCCreateWithQueueAndOptions(uint64_t a1, const void *a2, uint64_t a3, void *a4, const void *a5, uint64_t a6, uint64_t *a7)
{
  CFTypeRef cf = 0;
  uint64_t v13 = FigSampleBufferProviderCreateForBufferQueue(*MEMORY[0x1E4F1CF80], a2, &cf);
  int v14 = v13;
  uint64_t v15 = v13;
  if (!v13)
  {
    long long v18 = *(_OWORD *)a3;
    uint64_t v19 = *(void *)(a3 + 16);
    uint64_t v15 = TMCCreateWithCallbacksAndOptions(a1, cf, &v18, a4, a5, a6, a7);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (a4)
  {
    if (v14)
    {
      vm_size_t v16 = (void (*)(void))a4[3];
      if (v16) {
        v16(a4[1]);
      }
    }
  }
  return v15;
}

uint64_t TMCCreateWithCallbacksAndOptions(uint64_t a1, const void *a2, long long *a3, void *a4, const void *a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v25 = 0u;
  memset(v26, 0, sizeof(v26));
  *(_OWORD *)__str = 0u;
  long long v24 = 0u;
  if (!a2) {
    goto LABEL_16;
  }
  if (a4)
  {
    if (a4[2] && a5 && (*((_DWORD *)a3 + 3) & 0x1D) == 1 && a7 != 0)
    {
      MEMORY[0x19970EE10](&sRegisterTMCTypeOnce, RegisterTMCType);
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v14 = Instance;
        __copy_assignment_8_8_t0w16_pa0_44489_16_pa0_25850_24_pa0_65440_32(Instance + 56, (uint64_t)a4);
        long long v15 = *a3;
        *(void *)(v14 + 112) = *((void *)a3 + 2);
        *(_OWORD *)(v14 + 96) = v15;
        *(void *)(v14 + 120) = CFRetain(a5);
        uint64_t v16 = MEMORY[0x1E4F1F9F8];
        *(_OWORD *)(v14 + 144) = *MEMORY[0x1E4F1F9F8];
        *(void *)(v14 + 160) = *(void *)(v16 + 16);
        FigCFDictionaryGetBooleanIfPresent();
        *(unsigned char *)(v14 + 188) = 0;
        snprintf(__str, 0x46uLL, "com.apple.coremedia.textmediaconverter.%p", (const void *)v14);
        *(void *)(v14 + 24) = dispatch_queue_create(__str, 0);
        snprintf(__str, 0x46uLL, "com.apple.coremedia.textmediaconverter.jumpseed.%p", (const void *)v14);
        *(void *)(v14 + 32) = dispatch_queue_create(__str, 0);
        snprintf(__str, 0x46uLL, "com.apple.coremedia.textmediaconverter.callback.%p", (const void *)v14);
        *(void *)(v14 + 40) = dispatch_queue_create(__str, 0);
        *(void *)(v14 + 168) = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(v14 + 24));
        uint64_t v17 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
        dispatch_source_set_cancel_handler_f(*(dispatch_source_t *)(v14 + 168), (dispatch_function_t)tmcSendingTimerCanceled);
        dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v14 + 168), (dispatch_function_t)tmcSendingTimerFired);
        dispatch_set_context(*(dispatch_object_t *)(v14 + 168), v17);
        dispatch_source_set_timer(*(dispatch_source_t *)(v14 + 168), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        *(void *)(v14 + 176) = voucher_copy();
        dispatch_resume(*(dispatch_object_t *)(v14 + 168));
        uint64_t v18 = CMTimebaseAddTimerDispatchSource(*(CMTimebaseRef *)(v14 + 120), *(dispatch_source_t *)(v14 + 168));
        if (v18
          || (CMNotificationCenterGetDefaultLocalCenter(), uint64_t v18 = FigNotificationCenterAddWeakListener(), v18)
          || (*(void *)(v14 + 48) = CFRetain(a2),
              CMNotificationCenterGetDefaultLocalCenter(),
              uint64_t v18 = FigNotificationCenterAddWeakListener(),
              v18)
          || (CMNotificationCenterGetDefaultLocalCenter(), uint64_t v18 = FigNotificationCenterAddWeakListener(), v18))
        {
          uint64_t v19 = v18;
        }
        else
        {
          CMNotificationCenterGetDefaultLocalCenter();
          uint64_t v19 = FigNotificationCenterAddWeakListener();
          if (!v19)
          {
            *a7 = v14;
            return v19;
          }
        }
        CFRelease((CFTypeRef)v14);
        return v19;
      }
    }
LABEL_16:
    uint64_t v20 = FigSignalErrorAt();
    uint64_t v19 = v20;
    if (a4)
    {
      if (v20)
      {
        long long v21 = (void (*)(void))a4[3];
        if (v21) {
          v21(a4[1]);
        }
      }
    }
    return v19;
  }

  return FigSignalErrorAt();
}

void TMCInvalidate(void *a1)
{
  if (a1)
  {
    tmcInvalidateInternal((uint64_t)a1);
    CFRetain(a1);
    long long v2 = a1[3];
    dispatch_async_f(v2, a1, (dispatch_function_t)tmcReleaseObjectsAndConsumeTMC);
  }
}

void tmcInvalidateInternal(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 16))
  {
    *(unsigned char *)(a1 + 16) = 1;
    if (*(void *)(a1 + 48))
    {
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      uint64_t FigBaseObject = FigSampleBufferProviderGetFigBaseObject(*(void *)(a1 + 48));
      if (FigBaseObject)
      {
        uint64_t v3 = FigBaseObject;
        uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 8);
        uint64_t v5 = v4 ? v4 : 0;
        size_t v6 = *(void (**)(uint64_t))(v5 + 24);
        if (v6) {
          v6(v3);
        }
      }
    }
    int64_t v7 = *(NSObject **)(a1 + 168);
    if (v7)
    {
      CMTimebaseRemoveTimerDispatchSource(*(CMTimebaseRef *)(a1 + 120), v7);
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 168));
    }
    if (*(void *)(a1 + 120))
    {
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
    }
  }
}

void tmcReleaseObjectsAndConsumeTMC(const void *a1)
{
  tmcReleaseObjects((uint64_t)a1);

  CFRelease(a1);
}

uint64_t RegisterTMCType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sTMCID = result;
  return result;
}

uint64_t __copy_assignment_8_8_t0w16_pa0_44489_16_pa0_25850_24_pa0_65440_32(uint64_t result, uint64_t a2)
{
  *(_OWORD *)uint64_t result = *(_OWORD *)a2;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

uint64_t tmcTimeJumped(int a1, CFTypeRef cf)
{
  if (!*((unsigned char *)cf + 16))
  {
    CFRetain(cf);
    CFGetAllocator(cf);
    return FigDeferNotificationToDispatchQueue();
  }
  return result;
}

uint64_t tmcInputDataBecameReady(int a1, CFTypeRef cf)
{
  if (!*((unsigned char *)cf + 16))
  {
    CFRetain(cf);
    CFGetAllocator(cf);
    return FigDeferNotificationToDispatchQueue();
  }
  return result;
}

void tmcInhibitOutputUntil(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  if (!*(unsigned char *)(a2 + 16))
  {
    int64_t v7 = (const void **)malloc_type_calloc(1uLL, 0x10uLL, 0xE0040E685C293uLL);
    if (v7)
    {
      unint64_t v8 = v7;
      *int64_t v7 = (const void *)a2;
      CFStringEncoding v9 = (const void *)a2;
      if (!a5
        || (Value = CFDictionaryGetValue(a5, (const void *)*MEMORY[0x1E4F1F328]), v8[1] = Value, (CFStringEncoding v9 = *v8) != 0))
      {
        CFRetain(v9);
        int Value = v8[1];
      }
      if (Value) {
        CFRetain(Value);
      }
      uint64_t v11 = *(NSObject **)(a2 + 32);
      dispatch_async_f(v11, v8, (dispatch_function_t)tmcInhibitOutputUntilSerialized);
    }
    else
    {
      FigSignalErrorAt();
    }
  }
}

void tmcResetOutput(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 16))
  {
    FigAtomicIncrement32();
    CFRetain((CFTypeRef)a2);
    uint64_t v3 = *(NSObject **)(a2 + 24);
    dispatch_async_f(v3, (void *)a2, (dispatch_function_t)tmcResetOutputSerialized);
  }
}

uint64_t TMCGetEndPresentationTimeForDecodedSamples(dispatch_queue_t *cf, uint64_t a2)
{
  uint64_t v5 = cf;
  long long v6 = *MEMORY[0x1E4F1F9F8];
  uint64_t v7 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  if (!a2 || *((unsigned char *)cf + 16))
  {
    return FigSignalErrorAt();
  }
  else
  {
    CFRetain(cf);
    dispatch_sync_f(cf[3], &v5, (dispatch_function_t)tmcSerializedGetEndPresentationTimeForDecodedSamples);
    *(_OWORD *)a2 = v6;
    *(void *)(a2 + 16) = v7;
    return 0;
  }
}

void tmcSerializedGetEndPresentationTimeForDecodedSamples(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v2 = *(CMSampleBufferRef **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 160);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(*(void *)a1 + 144);
  *(void *)(a1 + 24) = v3;
  uint64_t v4 = v2[16];
  if (v4)
  {
    CMSampleBufferGetOutputPresentationTimeStamp(&v10, v4);
    CMTimeValue value = v10.value;
    CMTimeFlags flags = v10.flags;
    CMTimeScale timescale = v10.timescale;
    if ((v10.flags & 0x1D) == 1)
    {
      long long v6 = (_OWORD *)(a1 + 8);
      CMTimeEpoch epoch = v10.epoch;
      *(void *)(a1 + 8) = value;
      *(_DWORD *)(a1 + 16) = timescale;
      *(_DWORD *)(a1 + 20) = flags;
      *(void *)(a1 + 24) = epoch;
      CMSampleBufferGetOutputDuration(&v10, v2[16]);
      CMTimeValue v11 = v10.value;
      CMTimeScale v12 = v10.timescale;
      if ((v10.flags & 0x1D) == 1)
      {
        *(_OWORD *)&lhs.CMTimeValue value = *v6;
        lhs.CMTimeEpoch epoch = *(void *)(a1 + 24);
        rhs.CMTimeValue value = v11;
        rhs.CMTimeScale timescale = v12;
        rhs.CMTimeFlags flags = v10.flags;
        rhs.CMTimeEpoch epoch = v10.epoch;
        CMTimeAdd(&v10, &lhs, &rhs);
        *long long v6 = *(_OWORD *)&v10.value;
        *(void *)(a1 + 24) = v10.epoch;
      }
    }
  }
  CFRelease(v2);
}

void tmcReleaseObjects(uint64_t a1)
{
  long long v2 = *(const void **)(a1 + 48);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 120);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 120) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 128);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 128) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 136);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 136) = 0;
  }
  long long v6 = *(NSObject **)(a1 + 168);
  if (v6)
  {
    dispatch_release(v6);
    *(void *)(a1 + 168) = 0;
  }
  uint64_t v7 = *(void **)(a1 + 176);
  if (v7)
  {
    os_release(v7);
    *(void *)(a1 + 176) = 0;
  }
  unint64_t v8 = *(NSObject **)(a1 + 40);
  if (v8)
  {
    CFStringEncoding v9 = *(void (__cdecl **)(void *))(a1 + 80);
    if (v9)
    {
      dispatch_async_f(v8, *(void **)(a1 + 64), v9);
      unint64_t v8 = *(NSObject **)(a1 + 40);
      *(void *)(a1 + 72) = 0;
      *(void *)(a1 + 80) = 0;
      if (!v8) {
        return;
      }
    }
    else
    {
      *(void *)(a1 + 72) = 0;
    }
    dispatch_release(v8);
    *(void *)(a1 + 40) = 0;
  }
}

double tmcInit(_OWORD *a1)
{
  double result = 0.0;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void tmcFinalize(uint64_t a1)
{
  tmcInvalidateInternal(a1);
  tmcReleaseObjects(a1);
  long long v2 = *(NSObject **)(a1 + 32);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(a1 + 24) = 0;
  }
}

CFTypeRef tmcCopyFormattingDesc(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return CFRetain(@"[TMC (invalidated)]");
  }
  else {
    return CFRetain(@"[TMC]");
  }
}

__CFString *tmcCopyDebugDesc(unsigned char *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFIndex v4 = CFGetRetainCount(a1);
  if (a1[16]) {
    uint64_t v5 = " (invalidated)";
  }
  else {
    uint64_t v5 = "";
  }
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"TMC %p retainCount: %d%s allocator: %p\n", a1, v4, v5, v6);
  return Mutable;
}

void tmcSendingTimerCanceled(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void tmcSendingTimerFired()
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v0)
  {
    uint64_t v1 = v0;
    os_retain(*(void **)(v0 + 176));
    voucher_adopt();
    if (!*(unsigned char *)(v1 + 16) && *(void *)(v1 + 128))
    {
      uint64_t v3 = malloc_type_malloc(0x10uLL, 0x20040A4A59CD2uLL);
      *uint64_t v3 = CFRetain((CFTypeRef)v1);
      v3[1] = CFRetain(*(CFTypeRef *)(v1 + 128));
      dispatch_async_f(*(dispatch_queue_t *)(v1 + 40), v3, (dispatch_function_t)tmcSendSampleToCallback);
      CMSampleBufferGetOutputPresentationTimeStamp(&v7, *(CMSampleBufferRef *)(v1 + 128));
      *(CMTime *)(v1 + 144) = v7;
      CMSampleBufferGetOutputDuration(&v7, *(CMSampleBufferRef *)(v1 + 128));
      CMTimeValue value = v7.value;
      CMTimeScale timescale = v7.timescale;
      if ((v7.flags & 0x1D) == 1)
      {
        CMTime lhs = *(CMTime *)(v1 + 144);
        rhs.CMTimeValue value = value;
        rhs.CMTimeScale timescale = timescale;
        rhs.CMTimeFlags flags = v7.flags;
        rhs.CMTimeEpoch epoch = v7.epoch;
        CMTimeAdd(&v7, &lhs, &rhs);
        *(CMTime *)(v1 + 144) = v7;
      }
      CFIndex v4 = *(const void **)(v1 + 128);
      if (v4)
      {
        CFRelease(v4);
        *(void *)(v1 + 128) = 0;
      }
    }
    tmcPrepareToSendNextSample(v1);
    CFRelease((CFTypeRef)v1);
    CFAllocatorRef v2 = (void *)voucher_adopt();
    os_release(v2);
  }
}

void tmcPrepareToSendNextSample(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 16) && FigAtomicCompareAndSwap32() && !*(void *)(a1 + 128))
  {
    CFStringRef v2 = (const __CFString *)*MEMORY[0x1E4F1F2A8];
    CFStringRef v3 = (const __CFString *)*MEMORY[0x1E4F1F258];
    key = (void *)*MEMORY[0x1E4F1F1B8];
    CFIndex v4 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFStringRef v19 = (const __CFString *)*MEMORY[0x1E4F1F228];
    while (1)
    {
      do
      {
        uint64_t v5 = *(void *)(a1 + 48);
        if (!v5) {
          return;
        }
        uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v6) {
          uint64_t v7 = v6;
        }
        else {
          uint64_t v7 = 0;
        }
        unint64_t v8 = *(uint64_t (**)(uint64_t))(v7 + 24);
        if (!v8)
        {
          *(void *)(a1 + 128) = 0;
          return;
        }
        CFStringEncoding v9 = (const void *)v8(v5);
        *(void *)(a1 + 128) = v9;
        if (!v9) {
          return;
        }
        if (CMGetAttachment(v9, v2, 0))
        {
          CMNotificationCenterGetDefaultLocalCenter();
          CMNotificationCenterPostNotification();
        }
        dispatch_sync_f(*(dispatch_queue_t *)(a1 + 32), (void *)a1, (dispatch_function_t)tmcHandleIgnoreSamplesUntilThisJumpSeed);
        uint64_t v10 = *(opaqueCMSampleBuffer **)(a1 + 128);
      }
      while (!v10);
      if (!CMSampleBufferGetDataBuffer(v10)
        && !CMGetAttachment(*(CMAttachmentBearerRef *)(a1 + 128), v3, 0)
        && (!*(unsigned char *)(a1 + 188) || !FigSampleBufferGetCaptionGroup()))
      {
        break;
      }
      CMSampleBufferGetOutputPresentationTimeStamp(&v23, *(CMSampleBufferRef *)(a1 + 128));
      CMTimeValue value = v23.value;
      CMTimeFlags flags = v23.flags;
      CMTimeScale timescale = v23.timescale;
      CMTimeScale v12 = *(opaqueCMSampleBuffer **)(a1 + 128);
      if ((v23.flags & 0x1D) == 1)
      {
        CMTimeEpoch epoch = v23.epoch;
        if (tmcShouldDisplaySampleImmediately(v12)
          || (CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(*(CMSampleBufferRef *)(a1 + 128), 0)) != 0
          && (CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0)) != 0
          && v4 == CFDictionaryGetValue(ValueAtIndex, key)
          || (uint64_t v16 = *(const void **)(a1 + 128), v4 == CMGetAttachment(v16, v3, 0))
          && v4 == CMGetAttachment(v16, v19, 0))
        {
          if (CMTimebaseSetTimerDispatchSourceToFireImmediately(*(CMTimebaseRef *)(a1 + 120), *(dispatch_source_t *)(a1 + 168)))
          {
            return;
          }
        }
        else
        {
          memset(&v23, 0, sizeof(v23));
          lhs.CMTimeValue value = value;
          lhs.CMTimeScale timescale = timescale;
          lhs.CMTimeFlags flags = flags;
          lhs.CMTimeEpoch epoch = epoch;
          CMTime rhs = *(CMTime *)(a1 + 96);
          CMTimeSubtract(&v23, &lhs, &rhs);
          uint64_t v17 = *(OpaqueCMTimebase **)(a1 + 120);
          uint64_t v18 = *(NSObject **)(a1 + 168);
          CMTime lhs = v23;
          if (CMTimebaseSetTimerDispatchSourceNextFireTime(v17, v18, &lhs, 1u)) {
            return;
          }
        }
        if (*(void *)(a1 + 128)) {
          return;
        }
      }
      else
      {
LABEL_32:
        if (v12)
        {
          CFRelease(v12);
          *(void *)(a1 + 128) = 0;
        }
      }
    }
    CMTimeScale v12 = *(opaqueCMSampleBuffer **)(a1 + 128);
    goto LABEL_32;
  }
}

void tmcSendSampleToCallback(CFTypeRef *a1)
{
  CFStringRef v2 = (void (**)(void, CFTypeRef))*a1;
  if (!*((unsigned char *)*a1 + 16))
  {
    v2[9](v2[8], a1[1]);
    if (*((unsigned char *)v2 + 188))
    {
      if (FigSampleBufferGetCaptionGroup()) {
        FigCaptionGroupGetSliceCount();
      }
    }
  }
  CFRelease(a1[1]);
  CFRelease(v2);

  free(a1);
}

void tmcHandleIgnoreSamplesUntilThisJumpSeed(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 136))
  {
    CFTypeRef v2 = CMGetAttachment(*(CMAttachmentBearerRef *)(a1 + 128), (CFStringRef)*MEMORY[0x1E4F1F2C0], 0);
    if (FigCFEqual())
    {
      CFStringRef v3 = *(const void **)(a1 + 136);
      if (v3)
      {
        CFRelease(v3);
        *(void *)(a1 + 136) = 0;
      }
    }
    else
    {
      if (!v2)
      {
        CMSampleBufferGetOutputPresentationTimeStamp(&v7, *(CMSampleBufferRef *)(a1 + 128));
        *(CMTime *)(a1 + 144) = v7;
        CMSampleBufferGetOutputDuration(&v7, *(CMSampleBufferRef *)(a1 + 128));
        CMTimeValue value = v7.value;
        CMTimeScale timescale = v7.timescale;
        if ((v7.flags & 0x1D) == 1)
        {
          CMTime lhs = *(CMTime *)(a1 + 144);
          rhs.CMTimeValue value = value;
          rhs.CMTimeScale timescale = timescale;
          rhs.CMTimeFlags flags = v7.flags;
          rhs.CMTimeEpoch epoch = v7.epoch;
          CMTimeAdd(&v7, &lhs, &rhs);
          *(CMTime *)(a1 + 144) = v7;
        }
      }
      CFIndex v4 = *(const void **)(a1 + 128);
      if (v4)
      {
        CFRelease(v4);
        *(void *)(a1 + 128) = 0;
      }
    }
  }
}

CFArrayRef tmcShouldDisplaySampleImmediately(opaqueCMSampleBuffer *a1)
{
  CFArrayRef result = CMSampleBufferGetSampleAttachmentsArray(a1, 0);
  if (result)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(result, 0);
    return (const __CFArray *)(ValueAtIndex
                            && (const void *)*MEMORY[0x1E4F1CFD0] == CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F1B0]));
  }
  return result;
}

void tmcDeferredInputDataBecameReady(int a1, unsigned char *cf)
{
  if (!cf[16]) {
    tmcPrepareToSendNextSample((uint64_t)cf);
  }

  CFRelease(cf);
}

void tmcResetOutputSerialized(void *cf)
{
  if (!*((unsigned char *)cf + 16))
  {
    CFTypeRef v2 = (const void *)cf[16];
    if (v2)
    {
      CFRelease(v2);
      cf[16] = 0;
    }
    uint64_t v3 = MEMORY[0x1E4F1F9F8];
    long long v4 = *MEMORY[0x1E4F1F9F8];
    *((_OWORD *)cf + 9) = *MEMORY[0x1E4F1F9F8];
    CMTimeEpoch v5 = *(void *)(v3 + 16);
    cf[20] = v5;
    uint64_t v6 = (OpaqueCMTimebase *)cf[15];
    CMTime v7 = cf[21];
    *(_OWORD *)&v9.CMTimeValue value = v4;
    v9.CMTimeEpoch epoch = v5;
    CMTimebaseSetTimerDispatchSourceNextFireTime(v6, v7, &v9, 0);
    unint64_t v8 = (void (*)(void))cf[11];
    if (v8) {
      v8(cf[8]);
    }
    FigAtomicDecrement32();
    tmcPrepareToSendNextSample((uint64_t)cf);
  }
  CFRelease(cf);
}

void tmcInhibitOutputUntilSerialized(void *a1)
{
  uint64_t v2 = *a1;
  if (*(unsigned char *)(*a1 + 16)) {
    goto LABEL_7;
  }
  uint64_t v3 = *(const void **)(v2 + 136);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(v2 + 136) = 0;
  }
  long long v4 = (const void *)a1[1];
  if (v4) {
    *(void *)(v2 + 136) = CFRetain(v4);
  }
  CFRetain((CFTypeRef)v2);
  dispatch_async_f(*(dispatch_queue_t *)(v2 + 24), (void *)v2, (dispatch_function_t)tmcPrepareToSendNextSampleAndConsumeTMC);
  uint64_t v2 = *a1;
  if (*a1) {
LABEL_7:
  }
    CFRelease((CFTypeRef)v2);
  CMTimeEpoch v5 = (const void *)a1[1];
  if (v5) {
    CFRelease(v5);
  }

  free(a1);
}

void tmcPrepareToSendNextSampleAndConsumeTMC(const void *a1)
{
  tmcPrepareToSendNextSample((uint64_t)a1);

  CFRelease(a1);
}

void tmcDeferredTimeJumped(int a1, CFTypeRef cf)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  memset(&v15, 0, sizeof(v15));
  memset(&v14, 0, sizeof(v14));
  memset(&v13, 0, sizeof(v13));
  if (*((unsigned char *)cf + 16)) {
    goto LABEL_2;
  }
  uint64_t v3 = (opaqueCMSampleBuffer *)*((void *)cf + 16);
  if (!v3) {
    goto LABEL_2;
  }
  if (tmcShouldDisplaySampleImmediately(v3)) {
    goto LABEL_2;
  }
  CFTypeRef v4 = CMGetAttachment(*((CMAttachmentBearerRef *)cf + 16), (CFStringRef)*MEMORY[0x1E4F1F258], 0);
  CMSampleBufferGetOutputPresentationTimeStamp(&lhs, *((CMSampleBufferRef *)cf + 16));
  CMTimeValue value = lhs.value;
  CMTimeFlags flags = lhs.flags;
  CMTimeScale timescale = lhs.timescale;
  if ((lhs.flags & 0x1D) != 1) {
    goto LABEL_2;
  }
  CMTimeEpoch epoch = lhs.epoch;
  if (!v4
    && (CMSampleBufferGetOutputDuration(&lhs, *((CMSampleBufferRef *)cf + 16)),
        CMTimeValue v16 = lhs.value,
        CMTimeFlags v7 = lhs.flags,
        CMTimeScale v17 = lhs.timescale,
        (lhs.flags & 1) != 0))
  {
    CMTimeEpoch v8 = lhs.epoch;
  }
  else
  {
    CMTimeValue v16 = *MEMORY[0x1E4F1FA48];
    CMTimeFlags v7 = *(_DWORD *)(MEMORY[0x1E4F1FA48] + 12);
    CMTimeScale v17 = *(_DWORD *)(MEMORY[0x1E4F1FA48] + 8);
    CMTimeEpoch v8 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  }
  lhs.CMTimeValue value = value;
  lhs.CMTimeScale timescale = timescale;
  lhs.CMTimeFlags flags = flags;
  lhs.CMTimeEpoch epoch = epoch;
  CMTime v11 = *(CMTime *)((unsigned char *)cf + 4);
  CMTimeSubtract(&v15, &lhs, &v11);
  lhs.CMTimeValue value = value;
  lhs.CMTimeScale timescale = timescale;
  lhs.CMTimeFlags flags = flags;
  lhs.CMTimeEpoch epoch = epoch;
  v11.CMTimeValue value = v16;
  v11.CMTimeScale timescale = v17;
  v11.CMTimeFlags flags = v7;
  v11.CMTimeEpoch epoch = v8;
  CMTimeAdd(&v14, &lhs, &v11);
  CMTimebaseGetTime(&v13, *((CMTimebaseRef *)cf + 15));
  double Rate = CMTimebaseGetRate(*((CMTimebaseRef *)cf + 15));
  CMTime lhs = v13;
  CMTime v11 = v15;
  if ((CMTimeCompare(&lhs, &v11) & 0x80000000) == 0)
  {
    CMTime lhs = v13;
    CMTime v11 = v14;
    if (CMTimeCompare(&lhs, &v11) <= 0) {
      goto LABEL_18;
    }
  }
  if (Rate > 0.0 && (lhs = v13, CMTime v11 = v14, CMTimeCompare(&lhs, &v11) > 0)
    || Rate < 0.0 && (lhs = v13, CMTime v11 = v15, CMTimeCompare(&lhs, &v11) < 0))
  {
    if (!v4)
    {
      uint64_t v10 = (const void *)*((void *)cf + 16);
      if (v10)
      {
        CFRelease(v10);
        *((void *)cf + 16) = 0;
      }
    }
LABEL_18:
    if (CMTimebaseSetTimerDispatchSourceToFireImmediately(*((CMTimebaseRef *)cf + 15), *((dispatch_source_t *)cf + 21))) {
      FigSignalErrorAt();
    }
  }
LABEL_2:
  CFRelease(cf);
}

uint64_t FigByteStreamServerCreateByteStreamDetails(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  CFTypeRef v45 = 0;
  CFNumberRef number = 0;
  CFTypeRef v43 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v41 = 0;
  CFTypeRef v42 = 0;
  CFTypeRef v39 = 0;
  uint64_t value = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  uint64_t v6 = *MEMORY[0x1E4F1CF80];
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(void (**)(uint64_t, void, uint64_t, CFTypeRef *))(v9 + 48);
  if (v10) {
    v10(CMBaseObject, *MEMORY[0x1E4F1EC78], v6, &v45);
  }
  uint64_t v11 = CMByteStreamGetCMBaseObject();
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  CMTime v14 = *(void (**)(uint64_t, void, uint64_t, CFTypeRef *))(v13 + 48);
  if (v14) {
    v14(v11, *MEMORY[0x1E4F1EC58], v6, &cf);
  }
  uint64_t v15 = CMByteStreamGetCMBaseObject();
  uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v16) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v18 = *(void (**)(uint64_t, void, uint64_t, CFTypeRef *))(v17 + 48);
  if (v18) {
    v18(v15, *MEMORY[0x1E4F1EC80], v6, &v43);
  }
  uint64_t v19 = CMByteStreamGetCMBaseObject();
  uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v20) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v22 = *(void (**)(uint64_t, void, uint64_t, CFTypeRef *))(v21 + 48);
  if (v22) {
    v22(v19, *MEMORY[0x1E4F1EC50], v6, &v41);
  }
  FigXPCMessageSetCFURL();
  CFTypeRef v23 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
  xpc_dictionary_set_BOOL(v5, "Writable", v43 == (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
  xpc_dictionary_set_BOOL(v5, "EntireLengthAvailable", cf == v23);
  CMByteStreamGetCMBaseObject();
  FigCRABSGetClassID();
  BOOL v24 = CMBaseObjectIsMemberOfClass() != 0;
  xpc_dictionary_set_BOOL(v5, "ReadsMayBlockIndefinitely", v24);
  int64_t SInt64 = FigCFNumberGetSInt64();
  xpc_dictionary_set_int64(v5, "EntireLength", SInt64);
  CMByteStreamGetCMBaseObject();
  FigCachedFileByteStreamGetClassID();
  if (CMBaseObjectIsMemberOfClass())
  {
    xpc_dictionary_set_BOOL(v5, "UseFigReadCache", 1);
    uint64_t v26 = CMByteStreamGetCMBaseObject();
    uint64_t v27 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v27) {
      uint64_t v28 = v27;
    }
    else {
      uint64_t v28 = 0;
    }
    uint64_t v29 = *(void (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(v28 + 48);
    if (v29) {
      v29(v26, 0x1EE5525F8, v6, &v42);
    }
    xpc_dictionary_set_BOOL(v5, "EnableFigReadCache", v42 == v23);
  }
  uint64_t v30 = CMByteStreamGetCMBaseObject();
  uint64_t v31 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v31) {
    uint64_t v32 = v31;
  }
  else {
    uint64_t v32 = 0;
  }
  CFStringRef v33 = *(void (**)(uint64_t, void, uint64_t, CFNumberRef *))(v32 + 48);
  if (v33)
  {
    v33(v30, *MEMORY[0x1E4F1FB38], v6, &number);
    if (number)
    {
      int valuePtr = -1;
      CFNumberGetValue(number, kCFNumberIntType, &valuePtr);
      xpc_dictionary_set_fd(v5, "FileDescriptor", valuePtr);
      CFTypeID v34 = 0;
      goto LABEL_37;
    }
  }
  CFTypeID v34 = (const void *)FigCopyCommonMemoryPool();
  if (!v34)
  {
    uint64_t BlockBuffer = FigSignalErrorAt();
LABEL_57:
    uint64_t v36 = BlockBuffer;
    goto LABEL_39;
  }
  uint64_t BlockBuffer = FigMemoryPoolCreateBlockBuffer();
  if (BlockBuffer) {
    goto LABEL_57;
  }
  uint64_t BlockBuffer = FigMemoryOriginSetBlockBufferInXPCMessage();
  if (BlockBuffer) {
    goto LABEL_57;
  }
LABEL_37:
  uint64_t v36 = FigXPCServerAssociateObjectWithNeighborProcessByPID();
  if (!v36)
  {
    xpc_dictionary_set_uint64(v5, "ObjectID", value);
    CFTypeRef v39 = 0;
    *a4 = v5;
  }
LABEL_39:
  if (cf) {
    CFRelease(cf);
  }
  if (v43) {
    CFRelease(v43);
  }
  if (v42) {
    CFRelease(v42);
  }
  if (v41) {
    CFRelease(v41);
  }
  if (number) {
    CFRelease(number);
  }
  if (v34) {
    CFRelease(v34);
  }
  if (v39) {
    CFRelease(v39);
  }
  if (v45) {
    CFRelease(v45);
  }
  FigXPCRelease();
  return v36;
}

void ReadBufferDestructor(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t FigByteStreamServerStart()
{
  if (FigByteStreamServerStart_sStartByteStreamServerOnce != -1) {
    dispatch_once(&FigByteStreamServerStart_sStartByteStreamServerOnce, &__block_literal_global_4);
  }
  return FigByteStreamServerStart_sByteStreamServerStartResult;
}

void __FigByteStreamServerStart_block_invoke()
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetValue();
  if (FigServer_IsMediaparserd())
  {
    int v1 = FigSignalErrorAt();
  }
  else
  {
    FigServer_IsMediaplaybackd();
    int v1 = FigXPCServerStart();
  }
  FigByteStreamServerStart_sByteStreamServerStartResult = v1;
  if (Mutable) {
    CFRelease(Mutable);
  }
}

uint64_t byteStreamServer_HandleMessage(uint64_t a1, void *a2)
{
  Opint Code = FigXPCMessageGetOpCode();
  if (OpCode) {
    return OpCode;
  }
  xpc_dictionary_get_uint64(a2, (const char *)*MEMORY[0x1E4F20280]);
  Opint Code = FigXPCServerLookupAndRetainAssociatedObjectAndCFTypeRefcon();
  if (OpCode) {
    return OpCode;
  }
  else {
    return 4294951138;
  }
}

uint64_t FigByteStreamServerCopyByteStreamForID()
{
  return FigXPCServerRetainNeighborObjectFromID();
}

uint64_t FigSecureStopManagerRemoteCreate(uint64_t a1, CFTypeRef *a2)
{
  xpc_object_t xdict = 0;
  uint64_t v10 = 0;
  CFTypeRef cf = 0;
  if (!a2) {
    goto LABEL_9;
  }
  *a2 = 0;
  uint64_t v4 = FigCPERemoteEnsureClientEstablished();
  if (v4) {
    goto LABEL_10;
  }
  uint64_t v4 = FigXPCCreateBasicMessage();
  if (v4) {
    goto LABEL_10;
  }
  uint64_t v4 = FigXPCRemoteClientSendSyncMessageCreatingReply();
  if (v4) {
    goto LABEL_10;
  }
  uint64_t uint64 = xpc_dictionary_get_uint64(xdict, (const char *)*MEMORY[0x1E4F20280]);
  if (!uint64)
  {
LABEL_9:
    uint64_t v4 = FigSignalErrorAt();
LABEL_10:
    uint64_t v6 = v4;
    goto LABEL_8;
  }
  uint64_t v6 = fssm_remote_createManagerForID(a1, uint64, &cf);
  if (v6)
  {
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    *a2 = cf;
    CFTypeRef cf = 0;
  }
LABEL_8:
  FigXPCRelease();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v6;
}

uint64_t fssm_remote_createManagerForID(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2 && a3)
  {
    *a3 = 0;
    uint64_t v3 = FigCPERemoteEnsureClientEstablished();
    if (v3) {
      return v3;
    }
    FigSecureStopManagerGetClassID();
    uint64_t v4 = CMDerivedObjectCreate();
    if (!v4) {
      return FigSignalErrorAt();
    }
    return v4;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigSecureStopManagerRemoteCopyDefaultRuntimeInstance(uint64_t a1, void *a2)
{
  xpc_object_t xdict = 0;
  uint64_t v12 = 0;
  CFTypeRef cf = 0;
  if (!a2) {
    goto LABEL_13;
  }
  *a2 = 0;
  uint64_t v4 = FigCPERemoteEnsureClientEstablished();
  if (v4) {
    goto LABEL_14;
  }
  uint64_t v4 = FigXPCCreateBasicMessage();
  if (v4) {
    goto LABEL_14;
  }
  uint64_t v4 = FigXPCRemoteClientSendSyncMessageCreatingReply();
  if (v4) {
    goto LABEL_14;
  }
  uint64_t uint64 = xpc_dictionary_get_uint64(xdict, (const char *)*MEMORY[0x1E4F20280]);
  if (!uint64)
  {
LABEL_13:
    uint64_t v4 = FigSignalErrorAt();
LABEL_14:
    uint64_t v7 = v4;
    goto LABEL_10;
  }
  uint64_t v6 = uint64;
  uint64_t v7 = FigXPCRemoteClientRetainCopiedObject();
  CFTypeRef v8 = cf;
  if (v7 || !cf && (v7 = fssm_remote_createManagerForID(a1, v6, &cf), CFTypeRef v8 = cf, v7))
  {
    if (v8) {
      CFRelease(v8);
    }
  }
  else
  {
    uint64_t v7 = 0;
    *a2 = v8;
    CFTypeRef cf = 0;
  }
LABEL_10:
  FigXPCRelease();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v7;
}

uint64_t fssm_remote_finalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigXPCRemoteClientDisassociateObject();
  if (!*(unsigned char *)DerivedStorage && !FigXPCCreateBasicMessage()) {
    FigXPCRemoteClientSendAsyncMessage();
  }
  int v1 = *(const void **)(DerivedStorage + 16);
  if (v1)
  {
    CFRelease(v1);
    *(void *)(DerivedStorage + 16) = 0;
  }
  return FigXPCRelease();
}

__CFString *fssm_remote_copyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFIndex v4 = CFGetRetainCount(a1);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<FigSecureStopManager_Remote %p retainCount: %ld allocator: %p, ", a1, v4, v5);
  CFStringAppendFormat(Mutable, 0, @">");
  return Mutable;
}

uint64_t fssm_remote_initialize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v11 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2 || !a3)
  {
    uint64_t ObjectID = FigSignalErrorAt();
LABEL_12:
    uint64_t v9 = ObjectID;
    goto LABEL_10;
  }
  uint64_t v7 = DerivedStorage;
  uint64_t ObjectID = fssm_remote_getObjectID(a1, &v11);
  if (ObjectID) {
    goto LABEL_12;
  }
  uint64_t ObjectID = FigXPCCreateBasicMessage();
  if (ObjectID) {
    goto LABEL_12;
  }
  uint64_t ObjectID = FigXPCMessageSetCFData();
  if (ObjectID) {
    goto LABEL_12;
  }
  uint64_t ObjectID = FigXPCMessageSetCFURL();
  if (ObjectID) {
    goto LABEL_12;
  }
  uint64_t ObjectID = FigSandboxRegisterURLWithProcessAndCopyRegistration();
  if (ObjectID) {
    goto LABEL_12;
  }
  uint64_t v9 = FigXPCRemoteClientSendSyncMessage();
  if (!v9) {
    *(void *)(v7 + 16) = 0;
  }
LABEL_10:
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v9;
}

uint64_t fssm_remote_copyRecords(uint64_t a1, void *a2)
{
  uint64_t v5 = 0;
  if (a2)
  {
    *a2 = 0;
    uint64_t ObjectID = fssm_remote_getObjectID(a1, &v5);
    if (!ObjectID)
    {
      uint64_t ObjectID = FigXPCCreateBasicMessage();
      if (!ObjectID)
      {
        uint64_t ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply();
        if (!ObjectID) {
          uint64_t ObjectID = FigXPCMessageCopyCFDictionary();
        }
      }
    }
  }
  else
  {
    uint64_t ObjectID = FigSignalErrorAt();
  }
  uint64_t v3 = ObjectID;
  FigXPCRelease();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v3;
}

uint64_t fssm_remote_removeRecords(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if (!a2)
  {
    uint64_t ObjectID = FigSignalErrorAt();
    goto LABEL_9;
  }
  uint64_t ObjectID = fssm_remote_getObjectID(a1, &v6);
  if (ObjectID)
  {
LABEL_9:
    uint64_t v4 = ObjectID;
    goto LABEL_6;
  }
  uint64_t v3 = FigXPCCreateBasicMessage();
  if (v3 || (uint64_t v3 = FigXPCMessageSetCFArray(), v3)) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = FigXPCRemoteClientSendSyncMessage();
  }
LABEL_6:
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v4;
}

uint64_t fssm_remote_getObjectID(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2 || *(unsigned char *)DerivedStorage)
  {
    return FigSignalErrorAt();
  }
  else
  {
    *a2 = *(void *)(DerivedStorage + 8);
    return 0;
  }
}

uint64_t figCSSTokenWalkerRegisterFigCSSTokenWalker()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCSSTokenWalkerID = result;
  return result;
}

uint64_t FigCSSTokenWalkerCreate(uint64_t a1, const void *a2, uint64_t *a3)
{
  if (a2
    && a3
    && (MEMORY[0x19970EE10](&FigCSSTokenWalkerGetTypeID_sRegisterFigCSSTokenWalkerOnce, figCSSTokenWalkerRegisterFigCSSTokenWalker), (uint64_t Instance = _CFRuntimeCreateInstance()) != 0))
  {
    uint64_t v7 = Instance;
    *(void *)(Instance + 16) = CFRetain(a2);
    *(void *)(v7 + 24) = CFArrayGetCount((CFArrayRef)a2);
    *(void *)(v7 + 32) = -1;
    uint64_t v8 = FigCSSEOFTokenCreate(a1, (CFTypeRef *)(v7 + 48));
    if (v8) {
      CFRelease((CFTypeRef)v7);
    }
    else {
      *a3 = v7;
    }
    return v8;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigCSSTokenWalkerConsumeNextInputToken(uint64_t a1, void *a2, _DWORD *a3)
{
  int v10 = 0;
  if (!a1) {
    goto LABEL_17;
  }
  if (*(unsigned char *)(a1 + 40))
  {
    *(unsigned char *)(a1 + 40) = 0;
    CFIndex v5 = *(void *)(a1 + 32);
    if (v5 != -1)
    {
      CFIndex v6 = *(void *)(a1 + 24);
      goto LABEL_7;
    }
LABEL_17:
    return FigSignalErrorAt();
  }
  CFIndex v6 = *(void *)(a1 + 24);
  CFIndex v5 = *(void *)(a1 + 32);
  if (v5 < v6) {
    *(void *)(a1 + 32) = ++v5;
  }
LABEL_7:
  if (v5 < v6)
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v5);
    if (!a2) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  CFDictionaryRef ValueAtIndex = *(const void **)(a1 + 48);
  if (a2) {
LABEL_11:
  }
    *a2 = ValueAtIndex;
LABEL_12:
  if (!a3) {
    return 0;
  }
  if (ValueAtIndex)
  {
    uint64_t result = FigCSSTokenGetTokenType((uint64_t)ValueAtIndex, &v10);
    if (result) {
      return result;
    }
    int v9 = v10;
  }
  else
  {
    int v9 = 0;
  }
  uint64_t result = 0;
  *a3 = v9;
  return result;
}

uint64_t FigCSSTokenWalkerGetCurrentInputToken(uint64_t a1, void *a2, _DWORD *a3)
{
  if (!a1)
  {
    return FigSignalErrorAt();
  }
  CFIndex v6 = *(void *)(a1 + 32);
  if (v6 != -1)
  {
    if (v6 >= *(void *)(a1 + 24))
    {
      CFDictionaryRef ValueAtIndex = *(const void **)(a1 + 48);
      if (!a2) {
        goto LABEL_8;
      }
    }
    else
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v6);
      if (!a2) {
        goto LABEL_8;
      }
    }
    goto LABEL_7;
  }
  CFDictionaryRef ValueAtIndex = 0;
  if (a2) {
LABEL_7:
  }
    *a2 = ValueAtIndex;
LABEL_8:
  if (!a3) {
    return 0;
  }
  int v10 = 0;
  if (ValueAtIndex)
  {
    uint64_t result = FigCSSTokenGetTokenType((uint64_t)ValueAtIndex, &v10);
    if (result) {
      return result;
    }
    int v9 = v10;
  }
  else
  {
    int v9 = 0;
  }
  uint64_t result = 0;
  *a3 = v9;
  return result;
}

uint64_t FigCSSTokenWalkerReconsumeInputToken(uint64_t a1)
{
  if (!a1 || *(void *)(a1 + 32) == -1) {
    return FigSignalErrorAt();
  }
  *(unsigned char *)(a1 + 40) = 1;
  return 0;
}

double figCSSTokenWalker_Init(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figCSSTokenWalker_Finalize(uint64_t a1)
{
  CFAllocatorRef v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    CFRelease(v3);
  }
}

CFStringRef figCSSTokenWalker_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCSSTokenWalker %p]", a1);
}

CFStringRef figCSSTokenWalker_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCSSTokenWalker %p]", a1);
}

uint64_t FigNetworkUrgencyMonitorSetTimebase(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    MEMORY[0x19970E290](*(void *)(a1 + 32));
    if (a2)
    {
      if (*(void *)(a1 + 16))
      {
        FigReadOnlyTimebaseSetTargetTimebase();
      }
      else
      {
        CMTimebaseCreateReadOnlyTimebase();
        if (!*(void *)(a1 + 16)) {
          goto LABEL_14;
        }
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterAddWeakListener();
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterAddWeakListener();
      }
    }
    else
    {
      fnum_releaseReadOnlyTimebase(a1);
    }
    if (*(void *)(a1 + 40))
    {
      if (*(unsigned char *)(a1 + 120))
      {
        uint64_t v4 = *(void *)(a1 + 96);
        uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
        fnum_rescheduleBufferDepletionUpdateTimer(a1, v4 - UpTimeNanoseconds);
      }
      else
      {
        fnum_evaluateBufferDepletionUrgencyAndRescheduleTimer(a1);
      }
      goto LABEL_12;
    }
LABEL_14:
    FigSignalErrorAt();
LABEL_12:
    MEMORY[0x19970E2B0](*(void *)(a1 + 32));
    return 0;
  }
  return 4294954516;
}

uint64_t FigNetworkUrgencyMonitorSetStreamFullyAvailable(uint64_t a1, int a2)
{
  if (!a1) {
    return 4294954516;
  }
  MEMORY[0x19970E290](*(void *)(a1 + 32));
  if (*(unsigned __int8 *)(a1 + 121) != a2)
  {
    *(unsigned char *)(a1 + 121) = a2;
    if (a2)
    {
      MEMORY[0x19970E290](*(void *)(a1 + 104));
      *(void *)(a1 + 112) = 0;
      MEMORY[0x19970E2B0](*(void *)(a1 + 104));
      fnum_updateExpectedProgressTargets(a1);
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (v4) {
        dispatch_source_set_timer(v4, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      }
    }
    else if (*(unsigned char *)(a1 + 120))
    {
      uint64_t v5 = *(void *)(a1 + 96);
      uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      fnum_rescheduleBufferDepletionUpdateTimer(a1, v5 - UpTimeNanoseconds);
    }
    else
    {
      fnum_evaluateBufferDepletionUrgencyAndRescheduleTimer(a1);
    }
  }
  MEMORY[0x19970E2B0](*(void *)(a1 + 32));
  return 0;
}

void fnum_updateExpectedProgressTargets(uint64_t a1)
{
  ExpectedProgressTarget = (const void *)fnum_createExpectedProgressTarget(a1);
  FigCFWeakReferenceTableApplyFunction();
  if (ExpectedProgressTarget)
  {
    CFRelease(ExpectedProgressTarget);
  }
}

void fnum_rescheduleBufferDepletionUpdateTimer(uint64_t a1, int64_t a2)
{
  *(void *)(a1 + 96) = FigGetUpTimeNanoseconds() + a2;
  if (!*(unsigned char *)(a1 + 121) && *(void *)(a1 + 16) && (int v6 = *(_DWORD *)(a1 + 136), (~v6 & 5) != 0))
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if ((~v6 & 0x11) != 0)
    {
      dispatch_time_t v5 = dispatch_time(0, a2);
      uint64_t v4 = v7;
      goto LABEL_4;
    }
    if (!v7) {
      return;
    }
    uint64_t v4 = v7;
  }
  else
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (!v4) {
      return;
    }
  }
  dispatch_time_t v5 = -1;
LABEL_4:

  dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0);
}

void fnum_evaluateBufferDepletionUrgencyAndRescheduleTimer(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int64_t v2 = sFigNetworkUrgencyMonitorBufferDepletionUpdatePeriodNanoseconds;
  if (!*(unsigned char *)(a1 + 121))
  {
    uint64_t v3 = *(OpaqueCMTimebase **)(a1 + 16);
    if (v3)
    {
      if ((*(unsigned char *)(a1 + 60) & 1) != 0
        && (*(unsigned char *)(a1 + 84) & 1) != 0
        && !*(void *)(a1 + 88)
        && (*(void *)(a1 + 72) & 0x8000000000000000) == 0)
      {
        double Rate = CMTimebaseGetRate(v3);
        CMTimebaseGetTime(&time.start, *(CMTimebaseRef *)(a1 + 16));
        CMTimeValue value = time.start.value;
        CMTimeFlags flags = time.start.flags;
        CMTimeScale timescale = time.start.timescale;
        if (time.start.flags)
        {
          CMTimeEpoch epoch = time.start.epoch;
          long long v19 = *MEMORY[0x1E4F1F9F8];
          *(_OWORD *)&v24.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
          CMTimeEpoch v7 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
          v24.CMTimeEpoch epoch = v7;
          long long v8 = *(_OWORD *)(a1 + 64);
          *(_OWORD *)&time.start.CMTimeValue value = *(_OWORD *)(a1 + 48);
          *(_OWORD *)&time.start.CMTimeEpoch epoch = v8;
          *(_OWORD *)&time.duration.CMTimeScale timescale = *(_OWORD *)(a1 + 80);
          CMTimeRangeGetEnd(&v24, &time);
          time.CMTime start = v24;
          CMTimeGetSeconds(&time.start);
          time.start.CMTimeValue value = value;
          time.start.CMTimeScale timescale = timescale;
          time.start.CMTimeFlags flags = flags;
          time.start.CMTimeEpoch epoch = epoch;
          CMTimeGetSeconds(&time.start);
          time.CMTime start = v24;
          rhs.CMTimeValue value = value;
          rhs.CMTimeScale timescale = timescale;
          rhs.CMTimeFlags flags = flags;
          rhs.CMTimeEpoch epoch = epoch;
          CMTimeSubtract(&v22, &time.start, &rhs);
          double Seconds = CMTimeGetSeconds(&v22);
          uint64_t v10 = 0;
          if (Rate >= 0.0)
          {
            int v11 = *(_DWORD *)(a1 + 136);
            if ((~v11 & 5) != 0 && (*(_DWORD *)(a1 + 136) & 0x11) != 0x11)
            {
              double v12 = 1.0;
              if (Rate >= 0.1) {
                double v12 = Rate;
              }
              double v13 = Seconds / v12;
              if (v11)
              {
                CMTime v14 = (_OWORD *)(a1 + 124);
                memset(&time, 0, 24);
                CMClockRef HostTimeClock = CMClockGetHostTimeClock();
                CMClockGetTime(&time.start, HostTimeClock);
                CMTime rhs = *(CMTime *)(a1 + 124);
                CMTime time2 = time.start;
                if (CMTimeCompare(&rhs, &time2) < 0)
                {
                  *CMTime v14 = v19;
                  *(void *)(a1 + 140) = v7;
                }
                else
                {
                  *(_OWORD *)&rhs.CMTimeValue value = *v14;
                  rhs.CMTimeEpoch epoch = *(void *)(a1 + 140);
                  double v16 = CMTimeGetSeconds(&rhs);
                  CMTime rhs = time.start;
                  double v13 = v13 + v16 - CMTimeGetSeconds(&rhs);
                }
              }
              double v17 = *(double *)&sFigNetworkUrgencyMonitorBufferDepletionLowWater;
              if (v13 >= *(double *)&sFigNetworkUrgencyMonitorBufferDepletionLowWater)
              {
                uint64_t v10 = 0;
              }
              else
              {
                uint64_t v10 = (uint64_t)((double)FigGetContinuousUpTimeNanoseconds() + v13 * 1000000000.0);
                double v17 = *(double *)&sFigNetworkUrgencyMonitorBufferDepletionLowWater;
              }
              double v18 = v13 - v17;
              if (v18 <= *(double *)&sFigNetworkUrgencyMonitorBufferDepletionUpdatePeriod) {
                double v18 = *(double *)&sFigNetworkUrgencyMonitorBufferDepletionUpdatePeriod;
              }
              int64_t v2 = (uint64_t)(v18 * 1000000000.0);
            }
          }
          MEMORY[0x19970E290](*(void *)(a1 + 104));
          *(void *)(a1 + 112) = v10;
          MEMORY[0x19970E2B0](*(void *)(a1 + 104));
          fnum_updateExpectedProgressTargets(a1);
        }
      }
    }
  }
  fnum_rescheduleBufferDepletionUpdateTimer(a1, v2);
}

uint64_t FigNetworkUrgencyMonitorSetPlayableRange(uint64_t a1, _OWORD *a2)
{
  if (!a1) {
    return 4294954516;
  }
  MEMORY[0x19970E290](*(void *)(a1 + 32));
  long long v5 = a2[1];
  long long v4 = a2[2];
  *(_OWORD *)(a1 + 48) = *a2;
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 80) = v4;
  MEMORY[0x19970E2B0](*(void *)(a1 + 32));
  return 0;
}

uint64_t FigNetworkUrgencyMonitorSetEstimatedStartTime(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294954516;
  }
  MEMORY[0x19970E290](*(void *)(a1 + 32));
  uint64_t v4 = *(void *)(a2 + 16);
  *(_OWORD *)(a1 + 124) = *(_OWORD *)a2;
  *(void *)(a1 + 140) = v4;
  if (!*(unsigned char *)(a1 + 120)) {
    fnum_evaluateBufferDepletionUrgencyAndRescheduleTimer(a1);
  }
  MEMORY[0x19970E2B0](*(void *)(a1 + 32));
  return 0;
}

uint64_t FigNetworkUrgencyAssertDeadline(uint64_t a1, CMTime *a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = FigAtomicIncrement64();
  if (!v4) {
    uint64_t v4 = FigAtomicIncrement64();
  }
  CMTime v9 = *a2;
  uint64_t v5 = (uint64_t)(CMTimeGetSeconds(&v9) * 1000000000.0);
  Continuousuint64_t UpTimeNanoseconds = FigGetContinuousUpTimeNanoseconds();
  MEMORY[0x19970E290](*(void *)(a1 + 32));
  if (!fnum_scheduleDeadlineCleanup(a1, v5 + 1000000000))
  {
    CMTimeEpoch v7 = malloc_type_calloc(1uLL, 0x20uLL, 0x1020040B07D1DCCuLL);
    if (v7)
    {
      v7[1] = v4;
      void v7[2] = ContinuousUpTimeNanoseconds + v5;
      *CMTimeEpoch v7 = 0;
      **(void **)(a1 + 160) = v7;
      *(void *)(a1 + 160) = v7;
      fnum_updateExpectedProgressTargets(a1);
    }
  }
  MEMORY[0x19970E2B0](*(void *)(a1 + 32));
  return v4;
}

uint64_t fnum_scheduleDeadlineCleanup(uint64_t a1, int64_t a2)
{
  uint64_t v3 = FigCFWeakReferenceHolderCreateWithReferencedObject();
  if (v3)
  {
    uint64_t v4 = v3;
    dispatch_time_t v5 = dispatch_time(0, a2);
    GlobalNetworkBufferingQueue = FigThreadGetGlobalNetworkBufferingQueue();
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __fnum_scheduleDeadlineCleanup_block_invoke;
    block[3] = &__block_descriptor_tmp_3;
    block[4] = v4;
    dispatch_after(v5, GlobalNetworkBufferingQueue, block);
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigNetworkUrgencyCancelDeadline(uint64_t result, uint64_t a2)
{
  if (result && a2)
  {
    uint64_t v3 = result;
    MEMORY[0x19970E290](*(void *)(result + 32));
    uint64_t v4 = *(void **)(v3 + 152);
    if (v4)
    {
      while (v4[1] != a2)
      {
        uint64_t v4 = (void *)*v4;
        if (!v4) {
          goto LABEL_9;
        }
      }
      v4[3] = FigGetContinuousUpTimeNanoseconds();
      fnum_scheduleDeadlineCleanup(v3, 1000000000);
    }
LABEL_9:
    JUMPOUT(0x19970E2B0);
  }
  return result;
}

uint64_t FigNetworkUrgencyMonitorCopyExpectedProgressTarget(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  MEMORY[0x19970E290](*(void *)(a1 + 104));
  uint64_t v2 = *(void *)(a1 + 112);
  MEMORY[0x19970E2B0](*(void *)(a1 + 104));
  if (!v2) {
    return 0;
  }

  return FigCFNumberCreateSInt64();
}

uint64_t FigNetworkUrgencyMonitorAddHTTPRequest(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294954516;
  }
  MEMORY[0x19970E290](*(void *)(a1 + 32));
  FigCFWeakReferenceTableAddValueAndGetKey();
  ExpectedProgressTarget = (const void *)fnum_createExpectedProgressTarget(a1);
  fnum_setHTTPRequestExpectedProgressTarget(a2, (uint64_t)ExpectedProgressTarget);
  MEMORY[0x19970E2B0](*(void *)(a1 + 32));
  if (ExpectedProgressTarget) {
    CFRelease(ExpectedProgressTarget);
  }
  return 0;
}

uint64_t fnum_createExpectedProgressTarget(uint64_t a1)
{
  int v1 = *(void **)(a1 + 152);
  if (v1)
  {
    uint64_t v2 = 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      if (v2 >= v1[2]) {
        uint64_t v2 = v1[2];
      }
      int v1 = (void *)*v1;
    }
    while (v1);
    if (*(void *)(a1 + 112)) {
      return FigCFNumberCreateSInt64();
    }
  }
  else
  {
    uint64_t v2 = *(void *)(a1 + 112);
  }
  if (v2) {
    return FigCFNumberCreateSInt64();
  }
  return 0;
}

uint64_t fnum_setHTTPRequestExpectedProgressTarget(uint64_t a1, uint64_t a2)
{
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v7 = *(void *)(VTable + 8);
  uint64_t result = VTable + 8;
  uint64_t v6 = v7;
  if (v7) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = 0;
  }
  CMTime v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
  if (v9)
  {
    return v9(a1, 0x1EE57B838, a2);
  }
  return result;
}

uint64_t __FigNetworkUrgencyMonitorGetClassID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigNetworkUrgencyMonitorID = result;
  return result;
}

double fnum_Init(uint64_t a1)
{
  *(void *)(a1 + 160) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t fnum_Finalize(void *a1)
{
  fnum_releaseReadOnlyTimebase((uint64_t)a1);
  uint64_t v2 = a1[5];
  if (v2)
  {
    dispatch_source_set_timer(v2, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    uint64_t v2 = a1[5];
  }
  dispatch_source_cancel(v2);
  uint64_t v3 = a1[5];
  if (v3)
  {
    dispatch_release(v3);
    a1[5] = 0;
  }
  uint64_t v4 = (const void *)a1[3];
  if (v4)
  {
    CFRelease(v4);
    a1[3] = 0;
  }
  uint64_t v6 = (void **)(a1 + 19);
  dispatch_time_t v5 = (void *)a1[19];
  if (!v5) {
    goto LABEL_16;
  }
  while (1)
  {
    uint64_t v7 = (void *)*v5;
    uint64_t v8 = *v6;
    if (*v6 == v5) {
      break;
    }
    do
    {
      CMTime v9 = v8;
      uint64_t v8 = (void *)*v8;
    }
    while (v8 != v5);
    *CMTime v9 = v7;
    if (!v7) {
      goto LABEL_15;
    }
LABEL_13:
    free(v5);
    dispatch_time_t v5 = v7;
  }
  *uint64_t v6 = v7;
  if (v7) {
    goto LABEL_13;
  }
  CMTime v9 = a1 + 19;
LABEL_15:
  a1[20] = v9;
  free(v5);
LABEL_16:
  if (a1[13]) {
    FigSimpleMutexDestroy();
  }

  return FigSimpleMutexDestroy();
}

CFStringRef fnum_BaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigNetworkUrgencyMonitor %p]", a1);
}

CFStringRef fnum_CopyDebugDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigNetworkUrgencyMonitor %p]", a1);
}

uint64_t FigNetworkUrgencyMonitorCreate(uint64_t a1, uint64_t *a2)
{
  MEMORY[0x19970EE10](&sFigPlayerInitializeBufferDurationParameters, fnum_initializeBufferDurationParameters);
  *a2 = 0;
  if (FigNetworkUrgencyMonitorGetClassID_sRegisterFigNetworkUrgencyMonitorTypeOnce != -1) {
    dispatch_once(&FigNetworkUrgencyMonitorGetClassID_sRegisterFigNetworkUrgencyMonitorTypeOnce, &__block_literal_global_5);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v4 = Instance;
    uint64_t v5 = FigReentrantMutexCreate();
    *(void *)(v4 + 104) = v5;
    if (v5)
    {
      *(void *)(v4 + 152) = 0;
      *(void *)(v4 + 96) = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v6 = MEMORY[0x1E4F1F9F8];
      *(_OWORD *)(v4 + 124) = *MEMORY[0x1E4F1F9F8];
      *(void *)(v4 + 140) = *(void *)(v6 + 16);
      *(void *)(v4 + 160) = v4 + 152;
      uint64_t v7 = FigCFWeakReferenceTableCreate();
      if (v7)
      {
        uint64_t v14 = v7;
LABEL_17:
        CFRelease((CFTypeRef)v4);
        return v14;
      }
      uint64_t v8 = FigReentrantMutexCreate();
      *(void *)(v4 + 32) = v8;
      if (v8)
      {
        GlobalNetworkBufferingQueue = FigThreadGetGlobalNetworkBufferingQueue();
        dispatch_source_t v10 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, GlobalNetworkBufferingQueue);
        *(void *)(v4 + 40) = v10;
        if (v10)
        {
          int v11 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
          if (v11)
          {
            double v12 = v11;
            dispatch_set_context(*(dispatch_object_t *)(v4 + 40), v11);
            dispatch_source_set_timer(*(dispatch_source_t *)(v4 + 40), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
            dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v4 + 40), (dispatch_function_t)fnum_bufferDepletionUpdateTimerProc);
            CFRetain(v12);
            double v13 = *(NSObject **)(v4 + 40);
            handler[0] = MEMORY[0x1E4F143A8];
            handler[1] = 0x40000000;
            handler[2] = __FigNetworkUrgencyMonitorCreate_block_invoke;
            handler[3] = &__block_descriptor_tmp_2;
            handler[4] = v12;
            dispatch_source_set_cancel_handler(v13, handler);
            MEMORY[0x19970E290](*(void *)(v4 + 32));
            MEMORY[0x19970E290](*(void *)(v4 + 104));
            *(void *)(v4 + 112) = 0;
            MEMORY[0x19970E2B0](*(void *)(v4 + 104));
            fnum_updateExpectedProgressTargets(v4);
            *(unsigned char *)(v4 + 120) = 1;
            fnum_rescheduleBufferDepletionUpdateTimer(v4, sFigNetworkUrgencyMonitorBufferDepletionGracePeriodNanoseconds);
            MEMORY[0x19970E2B0](*(void *)(v4 + 32));
            dispatch_resume(*(dispatch_object_t *)(v4 + 40));
            *a2 = v4;
            CFRelease(v12);
            return 0;
          }
        }
      }
    }
    uint64_t v14 = FigSignalErrorAt();
    if (!v14) {
      return v14;
    }
    goto LABEL_17;
  }

  return FigSignalErrorAt();
}

double fnum_initializeBufferDurationParameters()
{
  FigNote_AllowInternalDefaultLogs();
  fig_note_initialize_category_with_default_work_cf();
  fig_note_initialize_category_with_default_work_cf();
  FigGetCFPreferenceDoubleWithDefault();
  if (v0 != *(double *)&sFigNetworkUrgencyMonitorBufferDepletionLowWater) {
    sFigNetworkUrgencyMonitorBufferDepletionLowWater = *(void *)&v0;
  }
  FigGetCFPreferenceDoubleWithDefault();
  if (v1 != *(double *)&sFigNetworkUrgencyMonitorBufferDepletionUpdatePeriod) {
    sFigNetworkUrgencyMonitorBufferDepletionUpdatePeriod = *(void *)&v1;
  }
  FigGetCFPreferenceDoubleWithDefault();
  double v3 = *(double *)&sFigNetworkUrgencyMonitorBufferDepletionGracePeriod;
  if (v2 != *(double *)&sFigNetworkUrgencyMonitorBufferDepletionGracePeriod)
  {
    sFigNetworkUrgencyMonitorBufferDepletionGracePeriod = *(void *)&v2;
    double v3 = v2;
  }
  sFigNetworkUrgencyMonitorBufferDepletionUpdatePeriodNanoseconds = (uint64_t)(*(double *)&sFigNetworkUrgencyMonitorBufferDepletionUpdatePeriod
                                                                            * 1000000000.0);
  double result = v3 * 1000000000.0;
  sFigNetworkUrgencyMonitorBufferDepletionGracePeriodNanoseconds = (uint64_t)(v3 * 1000000000.0);
  return result;
}

void fnum_bufferDepletionUpdateTimerProc()
{
  uint64_t v0 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v0)
  {
    uint64_t v1 = v0;
    MEMORY[0x19970E290](*(void *)(v0 + 32));
    *(unsigned char *)(v1 + 120) = 0;
    fnum_evaluateBufferDepletionUrgencyAndRescheduleTimer(v1);
    MEMORY[0x19970E2B0](*(void *)(v1 + 32));
    CFRelease((CFTypeRef)v1);
  }
}

void __FigNetworkUrgencyMonitorCreate_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void fnum_timebaseRateChangedCallback(uint64_t a1, uint64_t a2)
{
  MEMORY[0x19970E290](*(void *)(a2 + 32));
  if (!*(unsigned char *)(a2 + 120)) {
    fnum_evaluateBufferDepletionUrgencyAndRescheduleTimer(a2);
  }

  JUMPOUT(0x19970E2B0);
}

void fnum_timebaseJumpedCallback(uint64_t a1, uint64_t a2)
{
  MEMORY[0x19970E290](*(void *)(a2 + 32));
  if (!*(unsigned char *)(a2 + 120)) {
    fnum_evaluateBufferDepletionUrgencyAndRescheduleTimer(a2);
  }

  JUMPOUT(0x19970E2B0);
}

void fnum_releaseReadOnlyTimebase(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    double v2 = *(const void **)(a1 + 16);
    if (v2)
    {
      CFRelease(v2);
      *(void *)(a1 + 16) = 0;
    }
  }
}

uint64_t fnum_updateExpectedProgressTargetApplierFunc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return fnum_setHTTPRequestExpectedProgressTarget(a2, a3);
}

void __fnum_scheduleDeadlineCleanup_block_invoke(uint64_t a1)
{
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v2)
  {
    double v3 = (void *)v2;
    MEMORY[0x19970E290](*(void *)(v2 + 32));
    Continuousuint64_t UpTimeNanoseconds = FigGetContinuousUpTimeNanoseconds();
    uint64_t v6 = (void **)(v3 + 19);
    uint64_t v5 = (void *)v3[19];
    if (v5)
    {
      uint64_t v7 = ContinuousUpTimeNanoseconds - 1000000000;
      while (1)
      {
        uint64_t v8 = (void *)*v5;
        uint64_t v9 = v5[3];
        if (v9 && v9 < v7) {
          break;
        }
        if (v5[2] < v7)
        {
          int v11 = *v6;
          if (*v6 != v5)
          {
            do
            {
              double v12 = v11;
              int v11 = (void *)*v11;
            }
            while (v11 != v5);
            goto LABEL_14;
          }
LABEL_19:
          *uint64_t v6 = v8;
          double v12 = v3 + 19;
          if (!v8) {
            goto LABEL_15;
          }
          goto LABEL_16;
        }
LABEL_17:
        uint64_t v5 = v8;
        if (!v8) {
          goto LABEL_21;
        }
      }
      double v13 = *v6;
      if (*v6 == v5) {
        goto LABEL_19;
      }
      do
      {
        double v12 = v13;
        double v13 = (void *)*v13;
      }
      while (v13 != v5);
LABEL_14:
      *double v12 = v8;
      if (!v8) {
LABEL_15:
      }
        v3[20] = v12;
LABEL_16:
      free(v5);
      goto LABEL_17;
    }
LABEL_21:
    fnum_updateExpectedProgressTargets((uint64_t)v3);
    MEMORY[0x19970E2B0](v3[4]);
    CFRelease(v3);
  }
  uint64_t v14 = *(const void **)(a1 + 32);
  if (v14)
  {
    CFRelease(v14);
  }
}

uint64_t OccupancyChangedBlobGetTypeID()
{
  if (sRegisterOccupancyChangedBlobTypeOnce != -1) {
    dispatch_once_f(&sRegisterOccupancyChangedBlobTypeOnce, 0, (dispatch_function_t)RegisterVMC2OutputCallbacksType);
  }
  return sOccupancyChangedBlobID;
}

uint64_t RegisterVMC2OutputCallbacksType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sOccupancyChangedBlobID = result;
  return result;
}

uint64_t VMC2MakeOutputCallbacksForImageQueueArray(const __CFArray *a1, const __CFArray *a2, uint64_t a3, void *a4)
{
  if (a1 && a4 && a3 == 96)
  {
    uint64_t v7 = malloc_type_calloc(1uLL, 0x20uLL, 0x700402B80F0C4uLL);
    if (!v7)
    {
      uint64_t v15 = 0;
      uint64_t v27 = 4294954510;
      goto LABEL_41;
    }
    uint64_t Count = CFArrayGetCount(a1);
    if (a2) {
      CFIndex v9 = CFArrayGetCount(a2);
    }
    else {
      CFIndex v9 = 0;
    }
    if (Count != v9)
    {
      uint64_t v27 = FigSignalErrorAt();
LABEL_50:
      uint64_t v15 = 0;
      goto LABEL_41;
    }
    CFArrayRef cf = a1;
    if (Count)
    {
      CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      double v12 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
      CFMutableArrayRef v14 = CFArrayCreateMutable(v11, Count, v12);
      uint64_t v15 = v14;
      if (!Mutable)
      {
        uint64_t v27 = FigSignalErrorAt();
        goto LABEL_48;
      }
      if (!v14)
      {
        uint64_t v28 = v7;
        uint64_t v22 = FigSignalErrorAt();
LABEL_47:
        uint64_t v27 = v22;
        CFRelease(Mutable);
        uint64_t v7 = v28;
LABEL_48:
        if (v15)
        {
          CFRelease(v15);
          goto LABEL_50;
        }
LABEL_41:
        free(v15);
        free(v7);
        return v27;
      }
      if (Count >= 1)
      {
        uint64_t v28 = v7;
        CFIndex v16 = 0;
        double v17 = (const void *)*MEMORY[0x1E4F1CFC8];
        uint64_t v30 = (const void *)*MEMORY[0x1E4F1CFD0];
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, v16);
          if (ValueAtIndex && (v19 = ValueAtIndex, CFTypeID v20 = CFGetTypeID(ValueAtIndex), v20 == CFDictionaryGetTypeID()))
          {
            CFDictionaryGetValue(v19, @"DestinationPixelBufferAttributes");
            uint64_t v21 = CFDictionaryGetValue(v19, @"EnsureModifiableImageBuffers") == v30 ? v30 : v17;
          }
          else
          {
            uint64_t v21 = v17;
          }
          uint64_t v22 = VTPixelBufferConformerCreateWithAttributes();
          if (v22) {
            goto LABEL_47;
          }
          CFArrayAppendValue((CFMutableArrayRef)v15, 0);
          CFArrayAppendValue(Mutable, v21);
          if (Count == ++v16)
          {
            uint64_t v7 = v28;
            break;
          }
        }
      }
    }
    else
    {
      CFMutableArrayRef Mutable = 0;
      uint64_t v15 = 0;
    }
    v7[1] = Mutable;
    void v7[2] = v15;
    uint64_t v15 = malloc_type_calloc(Count, 4uLL, 0x100004052888210uLL);
    if (!v15)
    {
LABEL_44:
      uint64_t v27 = FigSignalErrorAt();
      goto LABEL_41;
    }
    if (Count < 1)
    {
      if (Count) {
        goto LABEL_40;
      }
    }
    else
    {
      CFIndex v23 = 0;
      uint64_t v24 = 0;
      do
      {
        long long v25 = CFArrayGetValueAtIndex(a2, v23);
        if (v25)
        {
          CFTypeID v26 = CFGetTypeID(v25);
          if (v26 == CFDictionaryGetTypeID())
          {
            if (FigCFDictionaryGetInt32IfPresent())
            {
              *((_DWORD *)v15 + v23) = 0;
              ++v24;
            }
          }
        }
        ++v23;
      }
      while (Count != v23);
      if (v24 != Count)
      {
        if (v24) {
          goto LABEL_44;
        }
LABEL_40:
        uint64_t v27 = 0;
        *uint64_t v7 = CFRetain(cf);
        *a4 = 0;
        a4[1] = v7;
        a4[2] = vmciqa_setSourceInfo;
        a4[3] = vmciqa_getSafeDisplayDuration;
        a4[4] = vmciqa_installOccupancyChangedCallback;
        a4[5] = vmciqa_removeOccupancyChangedCallback;
        a4[6] = vmciqa_canOutputImage;
        a4[7] = vmciqa_outputImage;
        a4[8] = vmciqa_flushOutput;
        a4[9] = vmciqa_releaseOutput;
        a4[10] = vmciqa_postNotification;
        a4[11] = vmciqa_copyGPURegistryID;
        uint64_t v7 = 0;
        goto LABEL_41;
      }
    }
    v7[3] = v15;
    uint64_t v15 = 0;
    goto LABEL_40;
  }

  return FigSignalErrorAt();
}

CFIndex vmciqa_setSourceInfo(CFArrayRef *a1, int a2, int a3, long long *a4, long long *a5)
{
  CFArrayRef v9 = *a1;
  CFIndex result = CFArrayGetCount(*a1);
  CFIndex v11 = result;
  if (a2)
  {
    if (a3) {
      uint64_t v12 = 3;
    }
    else {
      uint64_t v12 = 1;
    }
  }
  else if (*((_DWORD *)a4 + 3) & 0x1D) == 1 && (*((unsigned char *)a5 + 12))
  {
    uint64_t v12 = 2;
  }
  else
  {
    uint64_t v12 = 0;
  }
  if (result >= 1)
  {
    CFIndex v13 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v9, v13);
      long long v22 = *a4;
      uint64_t v23 = *((void *)a4 + 2);
      long long v20 = *a5;
      uint64_t v21 = *((void *)a5 + 2);
      uint64_t VTable = CMBaseObjectGetVTable();
      uint64_t v17 = *(void *)(VTable + 16);
      CFIndex result = VTable + 16;
      uint64_t v16 = v17;
      if (v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = 0;
      }
      CFDictionaryRef v19 = *(uint64_t (**)(const void *, uint64_t, long long *, long long *))(v18 + 56);
      if (v19)
      {
        long long v26 = v22;
        uint64_t v27 = v23;
        long long v24 = v20;
        uint64_t v25 = v21;
        CFIndex result = v19(ValueAtIndex, v12, &v26, &v24);
      }
      ++v13;
    }
    while (v11 != v13);
  }
  return result;
}

uint64_t vmciqa_getSafeDisplayDuration@<X0>(CFArrayRef *a1@<X0>, CMTime *a2@<X8>)
{
  void (*v12)(CMTime *__return_ptr, const void *);
  CMTime v13;
  CMTime time1;
  CMTime v15;

  CFArrayRef v3 = *a1;
  uint64_t result = CFArrayGetCount(*a1);
  uint64_t v5 = MEMORY[0x1E4F1FA10];
  *(_OWORD *)&a2->CMTimeValue value = *MEMORY[0x1E4F1FA10];
  a2->CMTimeEpoch epoch = *(void *)(v5 + 16);
  if (result >= 1)
  {
    uint64_t v6 = result;
    CFIndex v7 = 0;
    uint64_t v8 = (CMTime *)MEMORY[0x1E4F1F9F8];
    do
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v3, v7);
      memset(&v15, 0, sizeof(v15));
      uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = *(void (**)(CMTime *__return_ptr, const void *))(v11 + 80);
      if (v12) {
        v12(&v15, ValueAtIndex);
      }
      else {
        uint64_t v15 = *v8;
      }
      CMTimeRange time1 = *a2;
      CFIndex v13 = v15;
      uint64_t result = (uint64_t)CMTimeMinimum(a2, &time1, &v13);
      ++v7;
    }
    while (v6 != v7);
  }
  return result;
}

uint64_t vmciqa_installOccupancyChangedCallback(CFArrayRef *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  CFArrayRef v6 = *a1;
  CFIndex Count = CFArrayGetCount(*a1);
  if (sRegisterOccupancyChangedBlobTypeOnce != -1) {
    dispatch_once_f(&sRegisterOccupancyChangedBlobTypeOnce, 0, (dispatch_function_t)RegisterVMC2OutputCallbacksType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v9 = Instance;
    FigCFWeakReferenceStore();
    *(void *)(v9 + 24) = a3;
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFArrayGetValueAtIndex(v6, i);
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterAddWeakListener();
      }
    }
    *a4 = v9;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t vmciqa_removeOccupancyChangedCallback(CFArrayRef *a1, const void *a2)
{
  CFArrayRef v3 = *a1;
  CFIndex Count = CFArrayGetCount(*a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0; i != v5; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v3, i);
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      uint64_t FigBaseObject = FigImageQueueGetFigBaseObject(ValueAtIndex);
      uint64_t v9 = *(void **)(CMBaseObjectGetVTable() + 8);
      if (v9) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = 0;
      }
      if (*v10 >= 2uLL)
      {
        uint64_t v11 = (void (*)(uint64_t))v10[8];
        if (v11) {
          v11(FigBaseObject);
        }
      }
    }
  }
  if (a2) {
    CFRelease(a2);
  }
  return 0;
}

uint64_t vmciqa_canOutputImage(CFArrayRef *a1)
{
  CFArrayRef v1 = *a1;
  CFIndex Count = CFArrayGetCount(*a1);
  if (Count < 1) {
    return 100;
  }
  CFIndex v3 = Count;
  CFIndex v4 = 0;
  LODWORD(v5) = 100;
  do
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v1, v4);
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(uint64_t (**)(const void *))(v8 + 24);
    if (v9) {
      int v10 = v9(ValueAtIndex);
    }
    else {
      int v10 = 0;
    }
    if (v10 >= (int)v5) {
      uint64_t v5 = v5;
    }
    else {
      uint64_t v5 = v10;
    }
    ++v4;
  }
  while (v3 != v4);
  return v5;
}

uint64_t vmciqa_outputImage(const __CFArray **a1, uint64_t a2, uint64_t a3, unsigned __int8 a4, uint64_t a5, long long *a6, unsigned int a7)
{
  CFArrayRef v7 = *a1;
  if (!*a1) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(*a1);
  CFIndex v36 = Count - 1;
  if (Count < 1) {
    return 0;
  }
  CFIndex v9 = Count;
  int v10 = 0;
  CFIndex v11 = 0;
  uint64_t v12 = 0;
  CFArrayRef theArray = a1[2];
  CFArrayRef v35 = a1[1];
  if (a2) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = a3 == 0;
  }
  char v14 = v13;
  do
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v7, v11);
    uint64_t v16 = a2;
    if ((v14 & 1) != 0 || (v17 = FigTagMakeWithSInt64Value(), (uint64_t v16 = MEMORY[0x19970EBE0](a3, v17, v18, 0)) != 0))
    {
      CFArrayGetValueAtIndex(theArray, v11);
      CFArrayGetValueAtIndex(v35, v11);
      if (v11 >= v36) {
        int v19 = a4 & (v10 == 0);
      }
      else {
        int v19 = 0;
      }
      unsigned int v20 = VTPixelBufferConformerCopyConformedPixelBuffer();
      if (v20)
      {
        if (v12) {
          uint64_t v12 = v12;
        }
        else {
          uint64_t v12 = v20;
        }
      }
      else
      {
        if (v16)
        {
          int v21 = 1;
        }
        else
        {
          int v10 = 1;
          int v21 = v19;
        }
        if (v21) {
          int v22 = 0x10000;
        }
        else {
          int v22 = 0;
        }
        long long v39 = *a6;
        uint64_t v40 = *((void *)a6 + 2);
        uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v23) {
          uint64_t v24 = v23;
        }
        else {
          uint64_t v24 = 0;
        }
        uint64_t v25 = *(uint64_t (**)(const void *, void, uint64_t, long long *, void))(v24 + 32);
        if (v25)
        {
          long long v41 = v39;
          uint64_t v42 = v40;
          unsigned int v26 = v25(ValueAtIndex, 0, a5, &v41, v22 | a7);
        }
        else
        {
          unsigned int v26 = -12782;
        }
        if (v12) {
          BOOL v27 = 1;
        }
        else {
          BOOL v27 = v26 == 0;
        }
        if (v27) {
          uint64_t v12 = v12;
        }
        else {
          uint64_t v12 = v26;
        }
      }
    }
    ++v11;
  }
  while (v9 != v11);
  return v12;
}

CFIndex vmciqa_flushOutput(CFArrayRef *a1)
{
  CFArrayRef v1 = *a1;
  CFIndex result = CFArrayGetCount(*a1);
  if (result >= 1)
  {
    CFIndex v3 = result;
    for (CFIndex i = 0; i != v3; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v1, i);
      uint64_t VTable = CMBaseObjectGetVTable();
      uint64_t v8 = *(void *)(VTable + 16);
      CFIndex result = VTable + 16;
      uint64_t v7 = v8;
      if (v8) {
        uint64_t v9 = v7;
      }
      else {
        uint64_t v9 = 0;
      }
      int v10 = *(uint64_t (**)(const void *))(v9 + 16);
      if (v10) {
        CFIndex result = v10(ValueAtIndex);
      }
    }
  }
  return result;
}

void vmciqa_releaseOutput(void *a1)
{
  uint64_t v2 = *(const void **)a1;
  if (v2) {
    CFRelease(v2);
  }
  CFIndex v3 = (const void *)*((void *)a1 + 1);
  if (v3) {
    CFRelease(v3);
  }
  CFIndex v4 = (const void *)*((void *)a1 + 2);
  if (v4) {
    CFRelease(v4);
  }
  free(*((void **)a1 + 3));

  free(a1);
}

uint64_t vmciqa_postNotification(CFArrayRef *a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef v5 = *a1;
  CFIndex Count = CFArrayGetCount(*a1);
  if (Count < 1) {
    return 0;
  }
  CFIndex v7 = Count;
  CFIndex v8 = 0;
  LODWORD(v9) = 0;
  do
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v5, v8);
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v11) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0;
    }
    BOOL v13 = *(uint64_t (**)(const void *, uint64_t, uint64_t))(v12 + 88);
    if (v13) {
      unsigned int v14 = v13(ValueAtIndex, a2, a3);
    }
    else {
      unsigned int v14 = -12782;
    }
    if (v9) {
      BOOL v15 = 1;
    }
    else {
      BOOL v15 = v14 == 0;
    }
    if (v15) {
      uint64_t v9 = v9;
    }
    else {
      uint64_t v9 = v14;
    }
    ++v8;
  }
  while (v7 != v8);
  return v9;
}

__CFArray *vmciqa_copyGPURegistryID(CFArrayRef *a1)
{
  CFArrayRef v1 = *a1;
  CFIndex Count = CFArrayGetCount(*a1);
  uint64_t v3 = *MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
  if (Mutable) {
    BOOL v5 = Count < 1;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    CFIndex v6 = 0;
    CFIndex v7 = (const void *)*MEMORY[0x1E4F1D260];
    do
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v1, v6);
      CFTypeRef cf = 0;
      uint64_t FigBaseObject = FigImageQueueGetFigBaseObject(ValueAtIndex);
      uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v11 + 48);
      if (v12) {
        v12(FigBaseObject, @"FigImageQueueProperty_GPURegistryID", v3, &cf);
      }
      if (cf) {
        CFTypeRef v13 = cf;
      }
      else {
        CFTypeRef v13 = v7;
      }
      CFArrayAppendValue(Mutable, v13);
      if (cf) {
        CFRelease(cf);
      }
      ++v6;
    }
    while (Count != v6);
  }
  return Mutable;
}

uint64_t InitOccupancyChangedBlob(uint64_t result)
{
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

void FinalizeOccupancyChangedBlob(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  CFArrayRef v1 = (id *)(a1 + 16);
  if (v2) {
    objc_destroyWeak(v1);
  }
}

void vmciqa_OccupancyMonitorCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = MEMORY[0x19970C720](a2 + 16);
  if (v3)
  {
    CFIndex v4 = (const void *)v3;
    (*(void (**)(void))(a2 + 24))();
    CFRelease(v4);
  }
}

uint64_t FigMetricPlaybackEventInstallDeserializationHandler(uint64_t result)
{
  switch(result)
  {
    case 0:
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      CFIndex result = FigMetricEventClassInstallEventDeserializeHandler();
      break;
    default:
      return result;
  }
  return result;
}

uint64_t FigMetricInstallAllPlaybackDeserializationHandlers()
{
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();
  FigMetricEventClassInstallEventDeserializeHandler();

  return FigMetricEventClassInstallEventDeserializeHandler();
}

uint64_t FigAudioQueueCreateWithOptions(const __CFAllocator *a1, const opaqueCMFormatDescription *a2, uint64_t a3, int a4, const __CFDictionary *a5, uint64_t *a6)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  CFTypeRef v41 = 0;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  *(_OWORD *)__str = 0u;
  MEMORY[0x19970EE10](&faq_oneTimeInitialization_sInitializationOnce, faq_oneTimeInitializationWork);
  if (a2)
  {
    if (a3)
    {
      if (a6)
      {
        if ((a4 & 0x402) != 0x400)
        {
          MEMORY[0x19970EE10](&FigAudioQueueGetTypeID_sRegisterFAQTypeOnce, faq_registerFAQType);
          uint64_t Instance = _CFRuntimeCreateInstance();
          if (Instance)
          {
            uint64_t v13 = Instance;
            unsigned int v14 = (char *)(Instance + 776);
            *(unsigned char *)(Instance + 776) = 0;
            CFStringRef theString = 0;
            cf.CMTimeValue value = 0;
            CFTypeRef v42 = 0;
            uint64_t v43 = 0;
            CMTimeValue Value = FigCFDictionaryGetValue();
            if (FigCFDictionaryGetValueIfPresent()) {
              *(void *)(v13 + 264) = cf.value;
            }
            if (FigCFDictionaryGetValueIfPresent()) {
              CFStringGetCString(theString, v14, 10, 0x600u);
            }
            if (FigCFDictionaryGetValueIfPresent())
            {
              DispatchQueue = FigDispatchQueueHolderGetDispatchQueue();
              *(void *)(v13 + 32) = DispatchQueue;
              if (DispatchQueue) {
                dispatch_retain(DispatchQueue);
              }
            }
            if (FigCFDictionaryGetValueIfPresent())
            {
              CFTypeRef v17 = v42;
              if (v42) {
                CFTypeRef v17 = CFRetain(v42);
              }
              *(void *)(v13 + 272) = v17;
            }
            uint64_t v18 = FigReentrantMutexCreate();
            *(void *)(v13 + 24) = v18;
            if (!v18) {
              goto LABEL_49;
            }
            snprintf(__str, 0x50uLL, "com.apple.coremedia.faq.asyncQueue.%s", v14);
            if (!*(void *)(v13 + 32))
            {
              uint64_t v19 = FigDispatchQueueCreateWithPriority();
              *(void *)(v13 + 32) = v19;
              if (!v19) {
                goto LABEL_49;
              }
            }
            snprintf(__str, 0x50uLL, "com.apple.coremedia.faq.deferredAQPropertyHandler.%s", v14);
            uint64_t v20 = FigDispatchQueueCreateWithPriority();
            *(void *)(v13 + 40) = v20;
            if (!v20) {
              goto LABEL_49;
            }
            uint64_t v21 = FigCFWeakReferenceHolderCreateWithReferencedObject();
            *(void *)(v13 + 80) = v21;
            if (!v21)
            {
              uint64_t v32 = 4294954355;
              goto LABEL_37;
            }
            *(_DWORD *)(v13 + 48) = a4;
            if (CFDictionaryGetValue(a5, @"DestFormatDescription"))
            {
              CFStringRef theString = 0;
              cf.CMTimeValue value = 0;
              int CinematicAudioEffectEligibility = FigAudioFormatDescriptionGetCinematicAudioEffectEligibility();
              CMAudioFormatDescriptionGetMostCompatibleFormatAndChannelLayout();
              if (CinematicAudioEffectEligibility) {
                *(_DWORD *)(v13 + 48) |= 0x100u;
              }
            }
            *(void *)(v13 + 64) = FigBufferQueueRetain();
            *(unsigned char *)(v13 + 72) = (*(unsigned char *)(v13 + 48) & 0x40) != 0;
            *(void *)(v13 + 176) = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
            *(void *)(v13 + 184) = 0;
            *(_DWORD *)(v13 + 208) = 1065353216;
            *(_DWORD *)(v13 + 216) = 1065353216;
            *(_DWORD *)(v13 + 224) = 1065353216;
            *(_DWORD *)(v13 + 280) = 1065353216;
            *(_DWORD *)(v13 + 352) = 1953064047;
            *(void *)(v13 + 672) = faq_scaledEditRateSupportValidator_one32nd_to_32;
            CFRetain(*(CFTypeRef *)(v13 + 80));
            uint64_t v23 = *(opaqueCMBufferQueue **)(v13 + 64);
            uint64_t v24 = *(void **)(v13 + 80);
            long long v40 = *MEMORY[0x1E4F1FA48];
            *(_OWORD *)&cf.CMTimeValue value = *MEMORY[0x1E4F1FA48];
            CMTimeEpoch v25 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
            cf.CMTimeEpoch epoch = v25;
            uint64_t v26 = CMBufferQueueInstallTrigger(v23, (CMBufferQueueTriggerCallback)faq_sourceDataBecameReady, v24, 7, &cf, (CMBufferQueueTriggerToken *)(v13 + 88));
            if (v26) {
              goto LABEL_50;
            }
            if ((*(unsigned char *)(v13 + 48) & 2) != 0)
            {
              BOOL v27 = *(opaqueCMBufferQueue **)(v13 + 64);
              uint64_t v28 = *(void **)(v13 + 80);
              CMTime cf = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
              uint64_t v26 = CMBufferQueueInstallTrigger(v27, (CMBufferQueueTriggerCallback)faq_sourceEndOfDataReached, v28, 8, &cf, (CMBufferQueueTriggerToken *)(v13 + 96));
              if (v26) {
                goto LABEL_50;
              }
            }
            CMNotificationCenterGetDefaultLocalCenter();
            uint64_t v26 = FigNotificationCenterAddWeakListener();
            if (v26) {
              goto LABEL_50;
            }
            CMNotificationCenterGetDefaultLocalCenter();
            uint64_t v26 = FigNotificationCenterAddWeakListener();
            if (v26) {
              goto LABEL_50;
            }
            *(_OWORD *)(v13 + 128) = v40;
            *(void *)(v13 + 144) = v25;
            uint64_t v29 = FigSemaphoreCreate();
            *(void *)(v13 + 296) = v29;
            if (!v29) {
              goto LABEL_49;
            }
            uint64_t v30 = (uint64_t *)(v13 + 168);
            uint64_t v26 = AudioSampleBufferSplitterCreate((void *)(v13 + 168));
            if (v26) {
              goto LABEL_50;
            }
            uint64_t v26 = AudioSampleBufferSplitterSetSplitMethod((_DWORD *)*v30, 3);
            if (v26) {
              goto LABEL_50;
            }
            uint64_t v26 = AudioSampleBufferSplitterSetMaxNumberOfSplitSampleBuffers(*v30, 3);
            if (v26) {
              goto LABEL_50;
            }
            MEMORY[0x19970E290](*(void *)(v13 + 24));
            uint64_t v31 = FigSubAudioQueueCreate((unsigned char *)v13, a2, Value, MEMORY[0x1E4F1FA48], (uint64_t *)&v41);
            if (v31)
            {
              uint64_t v32 = v31;
              MEMORY[0x19970E2B0](*(void *)(v13 + 24));
              if (v41) {
                CFRelease(v41);
              }
              goto LABEL_37;
            }
            CFTypeRef v33 = v41;
            if (!*(unsigned char *)(v13 + 16)) {
              CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(v13 + 176), 0, v41);
            }
            MEMORY[0x19970E2B0](*(void *)(v13 + 24));
            if (v33) {
              CFRelease(v33);
            }
            cf.CMTimeValue value = (CMTimeValue)@"com.apple.coremedia.audioqueue.source";
            CFDictionaryRef v34 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], MEMORY[0x1E4F21EA8], (const void **)&cf, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            uint64_t v32 = FigThreadCreate();
            if (v32)
            {
              FigSignalErrorAt();
              if (!v34) {
                goto LABEL_45;
              }
            }
            else if (!v34)
            {
LABEL_45:
              if (v32)
              {
LABEL_37:
                CFRelease((CFTypeRef)v13);
                return v32;
              }
              CFArrayRef v35 = (long long *)MEMORY[0x1E4F1F9F8];
              *(void *)(v13 + 424) = v13;
              long long v36 = *v35;
              *(_OWORD *)(v13 + 432) = *v35;
              uint64_t v37 = *((void *)v35 + 2);
              *(void *)(v13 + 448) = v37;
              *(_OWORD *)(v13 + 456) = v36;
              *(void *)(v13 + 472) = v37;
              *(_OWORD *)(v13 + 480) = v36;
              *(void *)(v13 + 496) = v37;
              *(void *)(v13 + 520) = v37;
              *(_OWORD *)(v13 + 504) = v36;
              *(_OWORD *)(v13 + 528) = v36;
              *(void *)(v13 + 544) = v37;
              *(void *)(v13 + 568) = v37;
              *(_OWORD *)(v13 + 552) = v36;
              *(void *)(v13 + 336) = v37;
              *(_OWORD *)(v13 + 320) = v36;
              CMTime v38 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(v13 + 32));
              *(void *)(v13 + 344) = v38;
              if (v38)
              {
                dispatch_source_set_timer(v38, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
                dispatch_set_context(*(dispatch_object_t *)(v13 + 344), (void *)v13);
                dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v13 + 344), (dispatch_function_t)faq_wakeupToDiscard);
                *(void *)(v13 + 752) = voucher_copy();
                dispatch_resume(*(dispatch_object_t *)(v13 + 344));
                *(unsigned char *)(v13 + 746) = 1;
                uint64_t v32 = 0;
                *(_DWORD *)(v13 + 772) = FigAtomicIncrement32();
                *a6 = v13;
                return v32;
              }
LABEL_49:
              uint64_t v26 = FigSignalErrorAt();
LABEL_50:
              uint64_t v32 = v26;
              goto LABEL_37;
            }
            CFRelease(v34);
            goto LABEL_45;
          }
        }
      }
    }
  }

  return FigSignalErrorAt();
}

uint64_t FigAudioQueueGetTypeID()
{
  return gFAQID;
}

uint64_t FigSubAudioQueueCreate(unsigned char *cf, const opaqueCMFormatDescription *a2, CMTimeValue a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  long long v85 = 0u;
  long long v86 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  *(_OWORD *)__str = 0u;
  if (cf[16]) {
    return 0;
  }
  if (FigSubAudioQueueCreate_initValidSubAQSetOnce != -1) {
    dispatch_once_f(&FigSubAudioQueueCreate_initValidSubAQSetOnce, 0, (dispatch_function_t)subaq_createValidSubAQSetAndLock);
  }
  CFGetAllocator(cf);
  MEMORY[0x19970EE10](&FigSubAudioQueueGetTypeID_sRegisterFSAQTypeOnce, fsaq_registerFSAQType);
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v11 = Instance;
    uint64_t v12 = FigCFWeakReferenceHolderCreateWithReferencedObject();
    *(void *)(v11 + 24) = v12;
    if (!v12)
    {
      uint64_t v33 = 4294954355;
      goto LABEL_130;
    }
    uint64_t Key = FigCFWeakReferenceTableAddValueAndGetKey();
    if (Key) {
      goto LABEL_129;
    }
    FigCFWeakReferenceStore();
    uint64_t Key = subaq_setupForDecode(v11, a2);
    if (Key) {
      goto LABEL_129;
    }
    LODWORD(outPropertyData[0].CFDictionarySetValue(theDict, key, value) = 0;
    *(_DWORD *)UInt32 ioPropertyDataSize = 4;
    if (AudioFormatGetProperty(0x66646570u, 0x28u, *(const void **)(v11 + 64), (UInt32 *)ioPropertyDataSize, outPropertyData))
    {
      BOOL v14 = 1;
    }
    else
    {
      BOOL v14 = LODWORD(outPropertyData[0].value) == 0;
    }
    char v15 = !v14;
    *(unsigned char *)(v11 + 104) = v15;
    uint64_t v16 = FigSimpleMutexCreate();
    *(void *)(v11 + 136) = v16;
    if (!v16) {
      goto LABEL_128;
    }
    uint64_t v17 = FigSimpleMutexCreate();
    *(void *)(v11 + 336) = v17;
    if (!v17) {
      goto LABEL_128;
    }
    *(unsigned char *)(v11 + 544) = 1;
    uint64_t v18 = FigSimpleMutexCreate();
    *(void *)(v11 + 536) = v18;
    if (!v18) {
      goto LABEL_128;
    }
    uint64_t v19 = FigReadWriteLockCreate();
    *(void *)(v11 + 648) = v19;
    if (!v19) {
      goto LABEL_128;
    }
    FigReadWriteLockLockForWrite();
    CFSetAddValue((CFMutableSetRef)gValidFigSubAudioQueueSet, (const void *)v11);
    FigReadWriteLockUnlockForWrite();
    *(_OWORD *)&v78.CMTimeValue value = *(_OWORD *)a4;
    v78.CMTimeEpoch epoch = *(void *)(a4 + 16);
    UInt32 v79 = 0;
    uint64_t v20 = (uint64_t *)(v11 + 40);
    uint64_t v21 = (long long *)MEMORY[0x1E4F1F9F8];
    if (*(void *)(v11 + 40))
    {
      FigSignalErrorAt();
    }
    else if (!cf[16])
    {
      MEMORY[0x19970E290](*((void *)cf + 3));
      if (cf[16])
      {
        FigSignalErrorAt();
        uint64_t v33 = 0;
        goto LABEL_31;
      }
      uint64_t v22 = *(void *)(v11 + 64);
      unsigned int v23 = *((_DWORD *)cf + 12);
      if ((v23 & 0x10) == 0 && *(_DWORD *)(v22 + 8) == 1633771875) {
        int v25 = (v23 >> 1) & 0x10;
      }
      else {
        int v25 = (v23 >> 1) & 0x10 | 4;
      }
      UInt32 v26 = v25 & 0xFFFFFFFE | (v23 >> 2) & 1;
      *(_DWORD *)(v11 + 100) = (int)(*(double *)v22 + 0.5);
      if (dword_1E9350B70)
      {
        UInt32 v81 = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      CFRetain(*(CFTypeRef *)(v11 + 24));
      uint64_t v28 = *(const AudioStreamBasicDescription **)(v11 + 64);
      uint64_t v29 = *(void **)(v11 + 24);
      CFStringRef v30 = (const __CFString *)*MEMORY[0x1E4F1D410];
      uint64_t v31 = (const void *)*((void *)cf + 33);
      outPropertyData[0] = v78;
      uint64_t v32 = FigAudioQueueTimingShimNewOutput(v28, (void (__cdecl *)(void *, AudioQueueRef, AudioQueueBufferRef))subaq_outputBufferBecameReady, v29, 0, v30, v26, v31, (long long *)&outPropertyData[0].value, (uint64_t *)(v11 + 40));
      if (v32)
      {
        uint64_t v33 = v32;
        FigSignalErrorAt();
        CFRelease(*(CFTypeRef *)(v11 + 24));
LABEL_31:
        MEMORY[0x19970E2B0](*((void *)cf + 3));
        goto LABEL_117;
      }
      outPropertyData[0].CMTimeValue value = a3;
      if (cf[16])
      {
        CFMutableStringRef Mutable = 0;
        goto LABEL_74;
      }
      CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      if (a3)
      {
        FigAudioQueueTimingShimSetProperty(*v20, 0x61716364u, outPropertyData, 8u);
        CFStringAppendFormat(Mutable, 0, @", DeviceUID %@", outPropertyData[0].value);
      }
      CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(*(CMFormatDescriptionRef *)(v11 + 56));
      if (Extensions)
      {
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(Extensions, @"AudibleGroupID");
        if (Value)
        {
          *(_DWORD *)UInt32 ioPropertyDataSize = 0;
          CFNumberGetValue(Value, kCFNumberSInt32Type, ioPropertyDataSize);
          FigAudioQueueTimingShimSetProperty(*v20, 0x61676964u, ioPropertyDataSize, 4u);
          CFStringAppendFormat(Mutable, 0, @", Audible Group ID %d", *(unsigned int *)ioPropertyDataSize);
        }
      }
      uint64_t v37 = *(unsigned int **)(v11 + 80);
      if (v37)
      {
        if (*(void *)(v11 + 88))
        {
          CFStringAppendFormat(Mutable, 0, @", LayoutTag: 0x%08x, Channels: %u", *v37, *(unsigned int *)(*(void *)(v11 + 64) + 28));
          unint64_t v38 = *(void *)(v11 + 88);
          if (!HIDWORD(v38)) {
            FigAudioQueueTimingShimSetProperty(*(void *)(v11 + 40), 0x6171636Cu, *(const void **)(v11 + 80), v38);
          }
        }
      }
      long long v39 = v21;
      *(void *)UInt32 ioPropertyDataSize = 0;
      MagicCookie = CMAudioFormatDescriptionGetMagicCookie(*(CMAudioFormatDescriptionRef *)(v11 + 56), (size_t *)ioPropertyDataSize);
      if (MagicCookie && *(void *)ioPropertyDataSize) {
        FigAudioQueueTimingShimSetProperty(*v20, 0x61716D63u, MagicCookie, *(UInt32 *)ioPropertyDataSize);
      }
      CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(*(CMFormatDescriptionRef *)(v11 + 56), (CFStringRef)*MEMORY[0x1E4F1EE20]);
      *(void *)UInt32 ioPropertyDataSize = Extension;
      if (Extension)
      {
        CFDictionaryRef v42 = Extension;
        CFTypeID v43 = CFGetTypeID(Extension);
        if (v43 == CFDictionaryGetTypeID() && CFDictionaryGetCount(v42) >= 1) {
          FigAudioQueueTimingShimSetProperty(*v20, 0x69736F65u, ioPropertyDataSize, 8u);
        }
      }
      *(_DWORD *)UInt32 ioPropertyDataSize = 0;
      FigAudioQueueTimingShimSetProperty(*v20, 0x71726169u, ioPropertyDataSize, 4u);
      if ((*((_WORD *)cf + 24) & 0x4004) != 0)
      {
LABEL_59:
        if (cf[680] || *((float *)cf + 191) != 0.0)
        {
          *(_DWORD *)UInt32 ioPropertyDataSize = 1;
          CFStringAppendFormat(Mutable, 0, @", ScheduledRate2");
          FigAudioQueueTimingShimSetProperty(*v20, 0x71737232u, ioPropertyDataSize, 4u);
        }
        uint64_t v21 = v39;
        if (cf[696])
        {
          subaq_setSweepFilterEnable((uint64_t)cf, v11, cf[696]);
          CFStringAppendFormat(Mutable, 0, @", SweepFilter");
        }
        *(_DWORD *)UInt32 ioPropertyDataSize = (*((_DWORD *)cf + 12) >> 8) & 1;
        FigAudioQueueTimingShimSetProperty(*v20, 0x715F7370u, ioPropertyDataSize, 4u);
        if (*(_DWORD *)ioPropertyDataSize) {
          CFStringAppendFormat(Mutable, 0, @", Spatialization");
        }
        if (FigAudioFormatDescriptionGetCinematicAudioEffectEligibility()) {
          *(_WORD *)(v11 + 720) = 1;
        }
        if ((cf[49] & 8) != 0)
        {
          *(_DWORD *)UInt32 ioPropertyDataSize = 1;
          FigAudioQueueTimingShimSetProperty(*v20, 0x6369616Fu, ioPropertyDataSize, 4u);
          CFStringAppendFormat(Mutable, 0, @", UnaccompaniedByVisuals");
        }
        *(_DWORD *)UInt32 ioPropertyDataSize = 1;
        FigAudioQueueTimingShimSetProperty(*v20, 0x24696E73u, ioPropertyDataSize, 4u);
        if ((cf[49] & 2) == 0)
        {
          *(_DWORD *)UInt32 ioPropertyDataSize = 1;
          FigAudioQueueTimingShimSetProperty(*v20, 0x73747263u, ioPropertyDataSize, 4u);
          CFStringAppendFormat(Mutable, 0, @", PauseAfterConfigChange");
        }
        *(_DWORD *)UInt32 ioPropertyDataSize = 1;
        FigAudioQueueTimingShimSetProperty(*v20, 0x7066666Cu, ioPropertyDataSize, 4u);
        if (CFStringGetLength(Mutable) >= 3)
        {
          v115.CFIndex location = 0;
          v115.size_t length = 2;
          CFStringDelete(Mutable, v115);
        }
LABEL_74:
        uint64_t v47 = subaq_buildAudioProcssingUnits((uint64_t)cf, (uint64_t *)v11);
        if (v47) {
          goto LABEL_139;
        }
        unsigned int v48 = FigUInt32NearestPowerOfTwo();
        if (v48 >= 0x20000) {
          unsigned int v49 = 0x20000;
        }
        else {
          unsigned int v49 = v48;
        }
        int v50 = v49 >> 2;
        if (v49 >> 2 >= 0x4000) {
          int v50 = 0x4000;
        }
        LODWORD(outPropertyData[0].CFDictionarySetValue(theDict, key, value) = v49;
        *(_DWORD *)UInt32 ioPropertyDataSize = v50;
        FigAudioQueueTimingShimSetProperty(*(void *)(v11 + 40), 0x64636266u, outPropertyData, 4u);
        FigAudioQueueTimingShimSetProperty(*(void *)(v11 + 40), 0x6463626Cu, ioPropertyDataSize, 4u);
        int v51 = *(_DWORD *)(*(void *)(v11 + 64) + 8);
        if (v51 == 1633772400 || v51 == 1633772392)
        {
          UInt32 v81 = *(_DWORD *)ioPropertyDataSize >> 1;
          FigAudioQueueTimingShimSetProperty(*v20, 0x646D6663u, &v81, 4u);
        }
        double v52 = (_OWORD *)(v11 + 108);
        *(_DWORD *)UInt32 ioPropertyDataSize = 0;
        UInt32 v81 = 4;
        if (FigAudioQueueTimingShimGetProperty(*(void *)(v11 + 40), 0x64636266u, ioPropertyDataSize, &v81))
        {
          *double v52 = *v21;
          CMTimeEpoch epoch = *((void *)v21 + 2);
        }
        else
        {
          CMTimeMake(outPropertyData, *(unsigned int *)ioPropertyDataSize, *(_DWORD *)(v11 + 100));
          *double v52 = *(_OWORD *)&outPropertyData[0].value;
          CMTimeEpoch epoch = outPropertyData[0].epoch;
        }
        *(void *)(v11 + 124) = epoch;
        uint64_t v47 = subaq_setCPECryptorPropertyOnAudioQueue((uint64_t)cf, v11);
        if (v47)
        {
LABEL_139:
          uint64_t v33 = v47;
        }
        else
        {
          long long v54 = *v21;
          *(_OWORD *)(v11 + 408) = *v21;
          uint64_t v55 = v21;
          uint64_t v56 = *((void *)v21 + 2);
          *(void *)(v11 + 424) = v56;
          *(_OWORD *)(v11 + 432) = v54;
          *(void *)(v11 + 448) = v56;
          *(_OWORD *)(v11 + 456) = v54;
          *(void *)(v11 + 472) = v56;
          LODWORD(outPropertyData[0].CFDictionarySetValue(theDict, key, value) = 1065353216;
          int Parameter = FigAudioQueueTimingShimGetParameter(*(void *)(v11 + 40), 0x15u, (AudioQueueParameterValue *)outPropertyData);
          float v58 = *(float *)&outPropertyData[0].value;
          if (Parameter) {
            float v58 = 1.0;
          }
          *(float *)(v11 + 532) = v58;
          double v59 = *(void **)(v11 + 32);
          uint64_t v60 = FigAudioQueueTimingShimAddPropertyListener(*(void *)(v11 + 40), 0x71637665u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v59);
          if (v60) {
            goto LABEL_131;
          }
          uint64_t v60 = FigAudioQueueTimingShimAddPropertyListener(*v20, 0x61747072u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v59);
          if (v60) {
            goto LABEL_131;
          }
          uint64_t v60 = FigAudioQueueTimingShimAddPropertyListener(*v20, 0x6171726Eu, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_startStopListener, v59);
          if (v60) {
            goto LABEL_131;
          }
          if (cf[72])
          {
            uint64_t v60 = FigAudioQueueTimingShimAddPropertyListener(*v20, 0x666C7368u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v59);
            if (v60) {
              goto LABEL_131;
            }
          }
          if ((cf[49] & 2) == 0)
          {
            uint64_t v60 = FigAudioQueueTimingShimAddPropertyListener(*v20, 0x72746F72u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v59);
            if (v60) {
              goto LABEL_131;
            }
            uint64_t v60 = FigAudioQueueTimingShimAddPropertyListener(*v20, 0x69737470u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v59);
            if (v60) {
              goto LABEL_131;
            }
          }
          *(void *)(v11 + 656) = 0;
          UInt32 v79 = 8;
          FigAudioQueueTimingShimGetProperty(*(void *)(v11 + 40), 0x71646C73u, (void *)(v11 + 656), &v79);
          *(void *)(v11 + 664) = *(void *)(v11 + 656);
          uint64_t v60 = FigAudioQueueTimingShimAddPropertyListener(*(void *)(v11 + 40), 0x71646C73u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v59);
          if (v60
            || (uint64_t v60 = FigAudioQueueTimingShimAddPropertyListener(*v20, 0x6864666Du, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v59), v60))
          {
LABEL_131:
            uint64_t v33 = v60;
          }
          else
          {
            uint64_t v61 = *((void *)cf + 33);
            if (!v61) {
              goto LABEL_106;
            }
            outPropertyData[0].CMTimeValue value = 0;
            uint64_t v62 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (!v62) {
              goto LABEL_106;
            }
            uint64_t v63 = *(unsigned int (**)(uint64_t, __CFString *, void, CMTime *))(v62 + 16);
            if (!v63 || v63(v61, @"FAS_MXSession", *MEMORY[0x1E4F1CF80], outPropertyData)) {
              goto LABEL_106;
            }
            uint64_t v33 = FigAudioQueueTimingShimSetProperty(*v20, 0x636D7873u, outPropertyData, 8u);
            if (outPropertyData[0].value) {
              CFRelease((CFTypeRef)outPropertyData[0].value);
            }
            if (!v33)
            {
LABEL_106:
              if (dword_1E9350B70)
              {
                UInt32 v81 = 0;
                type[0] = OS_LOG_TYPE_DEFAULT;
                unsigned int v64 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                UInt32 v65 = v81;
                if (os_log_type_enabled(v64, type[0])) {
                  unsigned int v66 = v65;
                }
                else {
                  unsigned int v66 = v65 & 0xFFFFFFFE;
                }
                if (v66)
                {
                  CFRange v67 = *(uint64_t **)(v11 + 64);
                  unsigned int v68 = *((_DWORD *)v67 + 2);
                  int v69 = *((_DWORD *)v67 + 7);
                  int v70 = *((_DWORD *)v67 + 5);
                  uint64_t v71 = *v67;
                  *(_DWORD *)UInt32 ioPropertyDataSize = 136318210;
                  *(void *)&ioPropertyDataSize[4] = "subaq_buildCAAudioQueue";
                  __int16 v88 = 2048;
                  double v89 = cf;
                  __int16 v90 = 2048;
                  uint64_t v91 = v11;
                  __int16 v92 = 2082;
                  double v93 = cf + 776;
                  __int16 v94 = 1024;
                  unsigned int v95 = HIBYTE(v68);
                  __int16 v96 = 1024;
                  int v97 = BYTE2(v68);
                  __int16 v98 = 1024;
                  int v99 = BYTE1(v68);
                  __int16 v100 = 1024;
                  int v101 = v68;
                  __int16 v102 = 1024;
                  unsigned int v103 = v68;
                  __int16 v104 = 1024;
                  int v105 = v69;
                  __int16 v106 = 1024;
                  int v107 = v70;
                  __int16 v108 = 2048;
                  uint64_t v109 = v71;
                  __int16 v110 = 2114;
                  CFMutableStringRef v111 = Mutable;
                  _os_log_send_and_compose_impl();
                }
                uint64_t v21 = v55;
                fig_log_call_emit_and_clean_up_after_send_and_compose();
                uint64_t v33 = 0;
                goto LABEL_115;
              }
              uint64_t v33 = 0;
            }
          }
          uint64_t v21 = v55;
        }
LABEL_115:
        MEMORY[0x19970E2B0](*((void *)cf + 3));
        if (Mutable) {
          CFRelease(Mutable);
        }
LABEL_117:
        if (v33)
        {
LABEL_130:
          CFRelease((CFTypeRef)v11);
          return v33;
        }
        goto LABEL_118;
      }
      int v44 = *((_DWORD *)cf + 88);
      *(_DWORD *)UInt32 ioPropertyDataSize = 1;
      *(_DWORD *)os_log_type_t type = v44;
      UInt32 v81 = 0;
      CFStringAppendFormat(Mutable, 0, @", TimePitch (Algorithm '%c%c%c%c')", HIBYTE(v44), BYTE2(v44), BYTE1(v44), v44);
      FigAudioQueueTimingShimSetProperty(*v20, 0x715F7470u, ioPropertyDataSize, 4u);
      CFTypeRef v45 = faq_scaledEditRateSupportValidator_one32nd_to_32;
      if (v44 > 1953064046)
      {
        if (v44 != 1953064047)
        {
          int v46 = 1987276900;
LABEL_55:
          if (v44 != v46) {
            CFTypeRef v45 = faq_scaledEditRateSupportValidator_noScaleAllowed;
          }
        }
      }
      else
      {
        if (v44 != 1819376236)
        {
          int v46 = 1936745827;
          goto LABEL_55;
        }
        CFTypeRef v45 = faq_scaledEditRateSupportValidator_lowQualityZeroLatency;
      }
      *((void *)cf + 84) = v45;
      FigAudioQueueTimingShimSetProperty(*v20, 0x71747061u, type, 4u);
      FigAudioQueueTimingShimSetProperty(*v20, 0x71747062u, &v81, 4u);
      goto LABEL_59;
    }
LABEL_118:
    if (*((void *)cf + 90))
    {
      uint64_t Key = faq_connectToOfflineMixer(cf, v11);
      if (Key) {
        goto LABEL_129;
      }
    }
    uint64_t Key = (uint64_t)subaq_ensureClock((uint64_t)cf, v11);
    if (Key) {
      goto LABEL_129;
    }
    *(_OWORD *)(v11 + 616) = *v21;
    *(void *)(v11 + 632) = *((void *)v21 + 2);
    snprintf(__str, 0x50uLL, "com.apple.coremedia.subAQ.timerQueue.%s", cf + 776);
    uint64_t v72 = FigDispatchQueueCreateWithPriority();
    *(void *)(v11 + 672) = v72;
    if (v72)
    {
      *(unsigned char *)(v11 + 688) = 0;
      dispatch_source_t v73 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v72);
      *(void *)(v11 + 680) = v73;
      if (v73)
      {
        CMTime v74 = v73;
        CMTime v75 = *(const void **)(v11 + 24);
        if (v75) {
          CMTime v76 = (void *)CFRetain(v75);
        }
        else {
          CMTime v76 = 0;
        }
        dispatch_set_context(v74, v76);
        dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v11 + 680), (dispatch_function_t)subaq_deferredPerformStartupSync);
        dispatch_source_set_timer(*(dispatch_source_t *)(v11 + 680), 0xFFFFFFFFFFFFFFFFLL, 0, 0);
        dispatch_resume(*(dispatch_object_t *)(v11 + 680));
        uint64_t v33 = 0;
        *a5 = v11;
        return v33;
      }
    }
LABEL_128:
    uint64_t Key = FigSignalErrorAt();
LABEL_129:
    uint64_t v33 = Key;
    goto LABEL_130;
  }

  return FigSignalErrorAt();
}

void faq_wakeupToDiscard(uint64_t a1)
{
  if (a1 && !*(unsigned char *)(a1 + 16) && *(void *)(a1 + 296) && (*(unsigned char *)(a1 + 73) || *(unsigned char *)(a1 + 576)))
  {
    os_retain(*(void **)(a1 + 752));
    voucher_adopt();
    FigSemaphoreSignal();
    CFArrayRef v1 = (void *)voucher_adopt();
    os_release(v1);
  }
}

uint64_t faq_disconnectFromOfflineMixer(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 720);
  if (v2)
  {
    if (*(unsigned char *)(a2 + 642))
    {
      CFIndex v4 = (const void *)result;
      FigAudioQueueTimingShimGetAudioQueue(*(void *)(a2 + 40));
      CFIndex result = FigAudioQueueOfflineMixerDisconnectAudioQueue(v2, v4);
      *(unsigned char *)(a2 + 642) = 0;
    }
  }
  return result;
}

uint64_t faq_offlineMixerNeedsMoreInputData(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 16))
  {
    *(unsigned char *)(a2 + 306) = 1;
    return FigSemaphoreSignal();
  }
  return result;
}

void faq_destroyTransitionRecord(void *a1)
{
  uint64_t v2 = (const void *)a1[10];
  if (v2) {
    CFRelease(v2);
  }

  free(a1);
}

uint64_t faq_removeAudioProcessingTapListeners(uint64_t result)
{
  if (*(void *)(result + 736))
  {
    uint64_t v1 = result;
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    uint64_t v2 = *(void *)(v1 + 736);
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v5 = *(void *)(VTable + 8);
    uint64_t result = VTable + 8;
    uint64_t v4 = v5;
    CFIndex v6 = v5 ? (void *)v4 : 0;
    if (*v6 >= 2uLL)
    {
      CFIndex v7 = (uint64_t (*)(uint64_t))v6[8];
      if (v7)
      {
        return v7(v2);
      }
    }
  }
  return result;
}

__n128 faq_clearSeamHandlingState(__n128 *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[7].n128_u64[1];
    if (v2)
    {
      CFRelease(v2);
      a1[7].n128_u64[1] = 0;
    }
    uint64_t v3 = (const void *)a1[10].n128_u64[0];
    if (v3)
    {
      CFRelease(v3);
      a1[10].n128_u64[0] = 0;
    }
    uint64_t v4 = (__n128 *)MEMORY[0x1E4F1FA48];
    a1[7].n128_u64[0] = 0;
    __n128 result = *v4;
    a1[8] = *v4;
    a1[9].n128_u64[0] = v4[1].n128_u64[0];
    a1[9].n128_u64[1] = 0;
  }
  return result;
}

uint64_t FigAudioQueueRequestTransitionCallback(uint64_t a1, long long *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  if (a1 && (*((_DWORD *)a2 + 3) & 0x1D) == 1 && a3 && a4)
  {
    MEMORY[0x19970E290](*(void *)(a1 + 24));
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v14 = FigSignalErrorAt();
    }
    else
    {
      uint64_t v10 = (char *)malloc_type_calloc(1uLL, 0x60uLL, 0x10E0040BC008D63uLL);
      if (v10)
      {
        uint64_t v11 = v10;
        *((void *)v10 + 1) = a4;
        *((void *)v10 + 2) = a5;
        long long v12 = *a2;
        *((void *)v10 + 5) = *((void *)a2 + 2);
        *(_OWORD *)(v10 + 24) = v12;
        uint64_t v13 = MEMORY[0x1E4F1F9F8];
        *((_OWORD *)v10 + 3) = *MEMORY[0x1E4F1F9F8];
        *((void *)v10 + 8) = *(void *)(v13 + 16);
        *((_DWORD *)v10 + 18) = 0;
        *((void *)v10 + 10) = a3;
        CFRetain(a3);
        uint64_t v14 = 0;
        v11[88] = 0;
        *(void *)uint64_t v11 = *(void *)(a1 + 184);
        *(void *)(a1 + 184) = v11;
        ++*(_DWORD *)(a1 + 192);
      }
      else
      {
        uint64_t v14 = 4294954355;
      }
    }
    MEMORY[0x19970E2B0](*(void *)(a1 + 24));
    return v14;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t faq_enqueueSourceData(uint64_t a1, uint64_t a2)
{
  uint64_t v411 = *MEMORY[0x1E4F143B8];
  MEMORY[0x19970E290](*(void *)(a1 + 24));
  if (*(unsigned char *)(a1 + 16) || !*(void *)(a1 + 64) || !*(unsigned char *)(a1 + 305))
  {
    JUMPOUT(0x19970E2B0);
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  double v7 = 0.2;
  double v8 = -0.2;
  uint64_t v9 = 0x40000000;
  double v10 = 1.0;
  CFStringRef key = (const __CFString *)*MEMORY[0x1E4F21A20];
  CFStringRef v328 = (const __CFString *)*MEMORY[0x1E4F1F258];
  float v11 = 1.0;
  CFStringRef v323 = (const __CFString *)*MEMORY[0x1E4F1F2C0];
  CFStringRef v324 = (const __CFString *)*MEMORY[0x1E4F1F2B8];
  CFStringRef v319 = (const __CFString *)*MEMORY[0x1E4F21A30];
  CFStringRef v320 = (const __CFString *)*MEMORY[0x1E4F1F238];
  CFStringRef v321 = (const __CFString *)*MEMORY[0x1E4F1F2F8];
  CFStringRef v315 = (const __CFString *)*MEMORY[0x1E4F21A40];
  CFStringRef v313 = (const __CFString *)*MEMORY[0x1E4F1F2E8];
  v306 = (void *)*MEMORY[0x1E4F21A08];
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v307 = (const __CFString *)*MEMORY[0x1E4F1F2A8];
  CFStringRef v339 = (const __CFString *)*MEMORY[0x1E4F1F308];
  CFStringRef v338 = (const __CFString *)*MEMORY[0x1E4F1F300];
  CFStringRef v318 = (const __CFString *)*MEMORY[0x1E4F1F278];
  v346 = (int *)(a1 + 308);
  CFTypeRef v317 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
  v316 = (_OWORD *)(a1 + 456);
  v348 = (void *)(a1 + 184);
  v326 = (_OWORD *)(a1 + 128);
  uint64_t v327 = a1 + 424;
  v345 = (_OWORD *)(a1 + 552);
  v343 = (_OWORD *)(a1 + 528);
  v342 = (_OWORD *)(a1 + 480);
  v322 = (_OWORD *)(a1 + 360);
  v325 = (CMTimeValue *)(a1 + 320);
  CMTimeFlags v309 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
  CMTimeEpoch v347 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  CMTimeFlags v314 = *(_DWORD *)(MEMORY[0x1E4F1FA48] + 12);
  CMTimeEpoch v362 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  unsigned int v349 = a2;
  do
  {
    if (*(unsigned char *)(a1 + 16)) {
      break;
    }
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0);
    if (!ValueAtIndex) {
      break;
    }
    uint64_t v13 = (uint64_t)ValueAtIndex;
    if (ValueAtIndex[641]) {
      break;
    }
    if (a2)
    {
      if (!ValueAtIndex[104])
      {
        uint64_t v6 = *(unsigned __int8 *)(a1 + 312);
        if (FigAtomicCompareAndSwap32())
        {
          if (!v6) {
            *(unsigned char *)(v13 + 545) = 1;
          }
        }
      }
    }
    if (*(unsigned char *)(a1 + 16)) {
      break;
    }
    if (!*(unsigned char *)(a1 + 306)
      && (*v346 > 7 || *v346 >= 2 && !*(unsigned char *)(a1 + 356) && *(_DWORD *)(v13 + 480) >= *(_DWORD *)(v13 + 100)))
    {
      int v22 = 0;
      int v23 = 0;
      char v15 = 0;
      goto LABEL_77;
    }
    uint64_t v14 = (opaqueCMSampleBuffer *)CMBufferQueueCopyHead(*(CMBufferQueueRef *)(a1 + 64));
    char v15 = v14;
    if (!v14 || (*(unsigned char *)(a1 + 48) & 2) != 0 && !CMSampleBufferDataIsReady(v14))
    {
      if ((*(unsigned char *)(a1 + 48) & 2) == 0 || !CMBufferQueueIsAtEndOfData(*(CMBufferQueueRef *)(a1 + 64)))
      {
LABEL_75:
        int v22 = 0;
LABEL_76:
        int v23 = 0;
        goto LABEL_77;
      }
      if (dword_1E9350B70)
      {
        *(_DWORD *)CMTime lhs = 0;
        rhs[0] = 0;
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v20 = *(_DWORD *)lhs;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, (os_log_type_t)rhs[0])) {
          unsigned int v21 = v20;
        }
        else {
          unsigned int v21 = v20 & 0xFFFFFFFE;
        }
        if (v21)
        {
          *(_DWORD *)CMTime time2 = 136315650;
          *(void *)&time2[4] = "subaq_enqueueOneSourceSBuf";
          *(_WORD *)&time2[12] = 2048;
          *(void *)&time2[14] = a1;
          *(_WORD *)&time2[22] = 2048;
          *(void *)&time2[24] = v13;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      faq_stopAllAudioQueues(a1, 0, 0);
      int v22 = 0;
      int v45 = 0;
      goto LABEL_116;
    }
    long long v360 = *MEMORY[0x1E4F1FA48];
    *(_OWORD *)&v409.CMTimeValue value = *MEMORY[0x1E4F1FA48];
    v409.CMTimeEpoch epoch = v362;
    if (!*(unsigned char *)(a1 + 16))
    {
      CMSampleBufferGetOutputPresentationTimeStamp(&time1.duration, v15);
      CMSampleBufferGetOutputDuration((CMTime *)rhs, v15);
      *(_OWORD *)CMTime lhs = *(_OWORD *)&time1.duration.value;
      *(void *)&lhs[16] = time1.duration.epoch;
      CMTimeAdd((CMTime *)time2, (CMTime *)lhs, (CMTime *)rhs);
      subaq_getCurrentQueueTime(v13, &type);
      subaq_convertAQTimeToMediaTime((CMTime *)a1, &type, (uint64_t)lhs);
      if ((*(unsigned char *)(a1 + 48) & 2) != 0 || (float v16 = *(float *)(a1 + 416), v16 > 0.0))
      {
        CMTime presentationTimeStamp = *(CMTime *)time2;
        *(_OWORD *)&v390.CMTimeValue value = *(_OWORD *)lhs;
        CMTimeEpoch epoch = *(void *)&lhs[16];
      }
      else
      {
        if (v16 >= 0.0)
        {
          *(_OWORD *)&v409.CMTimeValue value = v360;
          v409.CMTimeEpoch epoch = v362;
          goto LABEL_23;
        }
        CMTime presentationTimeStamp = *(CMTime *)lhs;
        *(_OWORD *)&v390.CMTimeValue value = *(_OWORD *)&time1.duration.value;
        CMTimeEpoch epoch = time1.duration.epoch;
      }
      v390.CMTimeEpoch epoch = epoch;
      CMTimeSubtract(&v409, &presentationTimeStamp, &v390);
    }
LABEL_23:
    CMTime v370 = v409;
    if (*(unsigned char *)(a1 + 16) || (*(unsigned char *)(a1 + 48) & 2) != 0)
    {
      unsigned int v18 = 0;
    }
    else
    {
      time1.CMTime duration = v370;
      *(_OWORD *)CMTime time2 = v360;
      *(void *)&time2[16] = v362;
      unsigned int v18 = CMTimeCompare(&time1.duration, (CMTime *)time2) >> 31;
    }
    unsigned int v361 = v6;
    v359 = v15;
    if (!CMSampleBufferDataIsReady(v15) && !v18)
    {
      if ((*(unsigned char *)(a1 + 73) || *(unsigned char *)(a1 + 576)) && FigAtomicCompareAndSwap32())
      {
        memset(lhs, 0, 24);
        float v24 = *(float *)(a1 + 416);
        double v25 = 1.0;
        if (v24 == 0.0) {
          double v26 = 1.0;
        }
        else {
          double v26 = v24;
        }
        if (*(unsigned char *)(a1 + 236))
        {
          float v27 = *(float *)(a1 + 232);
          BOOL v78 = v27 == 0.0;
          double v25 = v27;
          if (v78) {
            double v25 = v10;
          }
        }
        time1.CMTime duration = v370;
        CMTimeMultiplyByFloat64(&time, &time1.duration, v26 / v25);
        CMTimeAbsoluteValue(&v369, &time);
        CMTimeMake(&v367, 5, 1);
        CMTimeMinimum((CMTime *)lhs, &v369, &v367);
        if (dword_1E9350B70)
        {
          *(_DWORD *)CMTime rhs = 0;
          LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
          uint64_t v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v29 = *(_DWORD *)rhs;
          if (os_log_type_enabled(v28, type.value)) {
            unsigned int v30 = v29;
          }
          else {
            unsigned int v30 = v29 & 0xFFFFFFFE;
          }
          if (v30)
          {
            int v31 = *(unsigned __int8 *)(a1 + 73);
            int v32 = v5;
            int v33 = *(unsigned __int8 *)(a1 + 576);
            time1.CMTime duration = v370;
            Float64 Seconds = CMTimeGetSeconds(&time1.duration);
            *(_OWORD *)&time1.duration.CMTimeValue value = *(_OWORD *)lhs;
            time1.duration.CMTimeEpoch epoch = *(void *)&lhs[16];
            Float64 v35 = CMTimeGetSeconds(&time1.duration);
            *(_DWORD *)CMTime time2 = 136316674;
            *(void *)&time2[4] = "subaq_enqueueOneSourceSBuf";
            *(_WORD *)&time2[12] = 2048;
            *(void *)&time2[14] = a1;
            *(_WORD *)&time2[22] = 2048;
            *(void *)&time2[24] = v13;
            *(_WORD *)v394 = 1024;
            *(_DWORD *)&v394[2] = v31;
            *(_WORD *)&v394[6] = 1024;
            *(_DWORD *)&v394[8] = v33;
            LODWORD(v5) = v32;
            *(_WORD *)&v394[12] = 2048;
            *(Float64 *)&v394[14] = Seconds;
            *(_WORD *)v395 = 2048;
            *(Float64 *)&v395[2] = v35;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          uint64_t v4 = v4;
          a2 = v349;
        }
        CFRetain((CFTypeRef)a1);
        *(_OWORD *)&time1.duration.CMTimeValue value = *(_OWORD *)lhs;
        time1.duration.CMTimeEpoch epoch = *(void *)&lhs[16];
        Float64 v58 = CMTimeGetSeconds(&time1.duration);
        dispatch_time_t v59 = dispatch_time(0, (uint64_t)(v58 * 1000000000.0));
        global_queue = dispatch_get_global_queue(0, 0);
        dispatch_after_f(v59, global_queue, (void *)a1, (dispatch_function_t)faq_scheduledWakeupRetainedToDiscard);
        int v22 = 0;
        int v23 = 0;
        int v45 = 0;
        uint64_t v6 = v6;
        goto LABEL_78;
      }
      goto LABEL_75;
    }
    if (!CMSampleBufferDataIsReady(v15) && *(unsigned char *)(a1 + 196))
    {
      if (dword_1E9350B70)
      {
        uint64_t v41 = v4;
        *(_DWORD *)CMTime lhs = 0;
        rhs[0] = 0;
        CFDictionaryRef v42 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v43 = *(_DWORD *)lhs;
        if (os_log_type_enabled(v42, (os_log_type_t)rhs[0])) {
          unsigned int v44 = v43;
        }
        else {
          unsigned int v44 = v43 & 0xFFFFFFFE;
        }
        if (v44)
        {
          *(_DWORD *)CMTime time2 = 136315906;
          *(void *)&time2[4] = "subaq_enqueueOneSourceSBuf";
          *(_WORD *)&time2[12] = 2048;
          *(void *)&time2[14] = a1;
          *(_WORD *)&time2[22] = 2048;
          *(void *)&time2[24] = v13;
          *(_WORD *)v394 = 2048;
          *(void *)&v394[2] = v15;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        int v22 = 0;
        int v23 = 0;
        int v45 = 0;
        uint64_t v4 = v41;
        a2 = v349;
        goto LABEL_78;
      }
      goto LABEL_75;
    }
    unsigned int v340 = v4;
    if (!*(unsigned char *)(a1 + 16))
    {
      Decryptor = (const void *)FigSampleBufferGetDecryptor();
      uint64_t v37 = *(const void **)(a1 + 56);
      if (Decryptor != v37)
      {
        unint64_t v38 = Decryptor;
        if (Decryptor
          && (CFTypeID v39 = CFGetTypeID(Decryptor),
              uint64_t TypeID = FigCPECryptorGetTypeID(),
              uint64_t v37 = *(const void **)(a1 + 56),
              v39 == TypeID))
        {
          *(void *)(a1 + 56) = v38;
          CFRetain(v38);
          if (!v37) {
            goto LABEL_93;
          }
        }
        else
        {
          *(void *)(a1 + 56) = 0;
          if (!v37)
          {
LABEL_93:
            subaq_setCPECryptorPropertyOnAudioQueue(a1, v13);
            goto LABEL_94;
          }
        }
        CFRelease(v37);
        goto LABEL_93;
      }
    }
LABEL_94:
    CFNumberRef v46 = (const __CFNumber *)CMGetAttachment(v15, key, 0);
    if (v46) {
      FigAudioQueueSetProperty(a1, @"LoudnessInfo", v46);
    }
    if (CMGetAttachment(v15, v328, 0))
    {
      MEMORY[0x19970E290](*(void *)(a1 + 24));
      if (!*(unsigned char *)(a1 + 16))
      {
        uint64_t v47 = (float *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0);
        if (v47[133] != v11)
        {
          uint64_t v48 = (uint64_t)v47;
          memset(&time1, 0, 24);
          CMSampleBufferGetOutputPresentationTimeStamp(&time1.duration, v15);
          memset(time2, 0, 24);
          *(_OWORD *)CMTime lhs = *(_OWORD *)&time1.duration.value;
          *(void *)&lhs[16] = time1.duration.epoch;
          subaq_convertMediaTimeToAQTime((CMTime *)a1, (CMTime *)lhs, (uint64_t)time2);
          *(_OWORD *)CMTime lhs = *(_OWORD *)time2;
          *(void *)&lhs[16] = *(void *)&time2[16];
          subaq_schedulePlayRate2ValueForTime(a1, v48, (CMTime *)lhs, 1.0);
          *(_DWORD *)(v48 + 532) = 1065353216;
        }
      }
      MEMORY[0x19970E2B0](*(void *)(a1 + 24));
    }
    uint64_t v4 = v340;
    if (*(void *)(a1 + 104))
    {
      CFTypeRef v49 = CMGetAttachment(v15, v323, 0);
      int v50 = *(const void **)(a1 + 104);
      if (v49)
      {
        int v51 = CFEqual(v49, v50);
        int v50 = *(const void **)(a1 + 104);
        if (v51)
        {
          if (v50)
          {
            CFRelease(*(CFTypeRef *)(a1 + 104));
            *(void *)(a1 + 104) = 0;
          }
          if (!*(unsigned char *)(a1 + 648)) {
            goto LABEL_127;
          }
          MEMORY[0x19970E290](*(void *)(a1 + 24));
          if (!*(unsigned char *)(a1 + 16))
          {
            double v52 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0);
            *(unsigned char *)(a1 + 576) = 1;
            if (dword_1E9350B70)
            {
              unsigned int v299 = v5;
              *(_DWORD *)CMTime lhs = 0;
              rhs[0] = 0;
              __int16 v53 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              unsigned int v54 = *(_DWORD *)lhs;
              if (os_log_type_enabled(v53, (os_log_type_t)rhs[0])) {
                unsigned int v55 = v54;
              }
              else {
                unsigned int v55 = v54 & 0xFFFFFFFE;
              }
              if (v55)
              {
                uint64_t v56 = *((void *)v52 + 5);
                *(_OWORD *)&time1.duration.CMTimeValue value = *v316;
                time1.duration.CMTimeEpoch epoch = *(void *)(a1 + 472);
                Float64 v57 = CMTimeGetSeconds(&time1.duration);
                *(_DWORD *)CMTime time2 = 136316418;
                *(void *)&time2[4] = "faq_restartIfPausedDueToReset";
                *(_WORD *)&time2[12] = 2048;
                *(void *)&time2[14] = a1;
                *(_WORD *)&time2[22] = 2048;
                *(void *)&time2[24] = v52;
                *(_WORD *)v394 = 2048;
                *(void *)&v394[2] = v56;
                *(_WORD *)&v394[10] = 2082;
                *(void *)&v394[12] = a1 + 776;
                *(_WORD *)&v394[20] = 2048;
                *(Float64 *)v395 = v57;
                _os_log_send_and_compose_impl();
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
              uint64_t v5 = v299;
              a2 = v349;
            }
            CFRetain(*((CFTypeRef *)v52 + 3));
            if (FigAudioQueueTimingShimStartAsync(*((void *)v52 + 5), 0, 0, (uint64_t)subaq_audioQueueStartupCompleted, *((void *)v52 + 3)))
            {
              CFRelease(*((CFTypeRef *)v52 + 3));
              MEMORY[0x19970E2B0](*(void *)(a1 + 24));
              int v23 = 0;
              int v45 = 0;
              int v22 = 1;
              goto LABEL_178;
            }
            subaq_startListener(a1, (uint64_t)v52);
            *(unsigned char *)(a1 + 648) = 0;
            *(unsigned char *)(a1 + 579) = 0;
          }
          MEMORY[0x19970E2B0](*(void *)(a1 + 24));
          int v50 = *(const void **)(a1 + 104);
          uint64_t v4 = v340;
        }
      }
      if (v50)
      {
        faq_dequeueFromSourceQueueAndDiscard();
        int v23 = 0;
        int v45 = 0;
        int v22 = 1;
        goto LABEL_78;
      }
    }
LABEL_127:
    if (!*(unsigned char *)(a1 + 16) && CMGetAttachment(v15, v324, 0) && !*(unsigned char *)(a1 + 577)) {
      subaq_flushAudioQueue(a1, v13);
    }
    int v355 = *(_DWORD *)(a1 + 192);
    if (v355 < 1 || (CFTypeRef v61 = CMGetAttachment(v15, v321, 0)) == 0 || (v62 = (void *)*v348) == 0)
    {
LABEL_143:
      if (*(unsigned char *)(a1 + 72))
      {
        CFTypeRef v66 = CMGetAttachment(v15, v319, 0);
        if (!CMSampleBufferGetDataBuffer(v15))
        {
          if (v66)
          {
            uint64_t v4 = v340;
            if (subaq_doesAudioQueueHaveBuffersToFlush(v13) || *(_DWORD *)(v13 + 612))
            {
              subaq_flushAudioQueue(a1, v13);
              int v45 = 0;
              *(unsigned char *)(v13 + 640) = 1;
            }
            else
            {
              int v45 = 1;
            }
            faq_dequeueFromSourceQueueAndDiscard();
            int v22 = 0;
            int v23 = 0;
            goto LABEL_78;
          }
        }
      }
      CFTypeRef v67 = CMGetAttachment(v15, v320, 0);
      if (!CMSampleBufferGetDataBuffer(v15))
      {
        if (v67 && !*(unsigned char *)(a1 + 577)) {
          subaq_flushAudioQueue(a1, v13);
        }
        uint64_t v4 = v340;
        if (!*(unsigned char *)(a1 + 16)
          && (CFDictionaryRef v73 = (const __CFDictionary *)CMGetAttachment(v15, v315, 0),
              CMTimeRangeMakeFromDictionary((CMTimeRange *)&time1, v73),
              (time1.duration.flags & 1) != 0))
        {
          int v23 = 0;
          int v22 = 1;
          if ((time1.presentationTimeStamp.flags & 1) != 0
            && !time1.presentationTimeStamp.epoch
            && (time1.presentationTimeStamp.value & 0x8000000000000000) == 0)
          {
            CMNotificationCenterGetDefaultLocalCenter();
            CMNotificationCenterPostNotification();
            if ((*(unsigned char *)(a1 + 48) & 2) != 0)
            {
              faq_stopAllAudioQueues(a1, 0, 0);
              int v22 = 0;
              int v23 = 1;
            }
            else
            {
              int v23 = 0;
            }
          }
        }
        else
        {
          int v23 = 0;
          int v22 = 1;
        }
        faq_dequeueFromSourceQueueAndDiscard();
        goto LABEL_77;
      }
      CFTypeRef v296 = v67;
      *(_DWORD *)CMTime rhs = 0;
      if (*(unsigned char *)(a1 + 16)
        || CMSampleBufferGetNumSamples(v15) < 1
        || (CMFormatDescriptionRef FormatDescription = CMSampleBufferGetFormatDescription(v15)) == 0
        || (int v69 = FormatDescription,
            CMAudioFormatDescriptionEqual(FormatDescription, *(CMAudioFormatDescriptionRef *)(v13 + 56), 0xFu, (CMAudioFormatDescriptionMask *)rhs)))
      {
LABEL_158:
        LODWORD(time1.duration.CFDictionarySetValue(theDict, key, value) = 1065353216;
        CFNumberRef v71 = (const __CFNumber *)CMGetAttachment(v15, v313, 0);
        uint64_t v293 = v9;
        if (v71)
        {
          CFNumberGetValue(v71, kCFNumberFloat32Type, &time1);
          float v72 = *(float *)&time1.duration.value;
        }
        else
        {
          float v72 = 1.0;
        }
        if (*(float *)(a1 + 764) == 0.0) {
          float v75 = v72;
        }
        else {
          float v75 = *(float *)(a1 + 764);
        }
        int v76 = (*(uint64_t (**)(uint64_t, double))(a1 + 672))(a1, v75);
        int v77 = v76;
        if (!v76) {
          *(unsigned char *)(v13 + 546) = 1;
        }
        if (*(unsigned char *)(v13 + 104) || !v6 && (v76 ? (BOOL v78 = v18 == 0) : (BOOL v78 = 0), v78))
        {
          char v298 = 1;
        }
        else
        {
          if (!*(unsigned char *)(a1 + 196))
          {
            memset(&time1, 0, 24);
            subaq_getCurrentQueueTime(v13, &v366);
            subaq_convertAQTimeToMediaTime((CMTime *)a1, &v366, (uint64_t)&time1);
            memset(time2, 0, 24);
            CMSampleBufferGetOutputPresentationTimeStamp((CMTime *)time2, v15);
            memset(lhs, 0, 24);
            CMSampleBufferGetOutputDuration(&v365, v15);
            *(_OWORD *)CMTime rhs = *(_OWORD *)time2;
            *(void *)&rhs[16] = *(void *)&time2[16];
            CMTimeAdd((CMTime *)lhs, (CMTime *)rhs, &v365);
            if (v355 > 0 || v18 || !v77)
            {
              faq_dequeueFromSourceQueueAndDiscard();
              if ((*(unsigned char *)(a1 + 48) & 2) != 0 || *(float *)(a1 + 416) > 0.0) {
                uint64_t v109 = lhs;
              }
              else {
                uint64_t v109 = time2;
              }
              uint64_t v4 = v340;
              *(_OWORD *)v325 = *(_OWORD *)v109;
              *(void *)(a1 + 336) = *((void *)v109 + 2);
              int v22 = 1;
              *(unsigned char *)(v13 + 545) = 1;
            }
            else
            {
              int v22 = 0;
              uint64_t v4 = v340;
            }
            goto LABEL_76;
          }
          char v298 = 0;
        }
        unsigned int v300 = v5;
        if (!*(void *)(a1 + 120))
        {
          CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(v15, 0);
          if (SampleAttachmentsArray)
          {
            CFArrayRef v80 = SampleAttachmentsArray;
            if (CFArrayGetCount(SampleAttachmentsArray) >= 1)
            {
              CFIndex v81 = CFArrayGetCount(v80);
              CFDictionaryRef v82 = (const __CFDictionary *)CFArrayGetValueAtIndex(v80, v81 - 1);
              CFNumberRef Value = CFDictionaryGetValue(v82, v306);
              if (Value)
              {
                long long v84 = Value;
                if (!FigCFEqual())
                {
                  if (dword_1E9350B70)
                  {
                    *(_DWORD *)CMTime rhs = 0;
                    LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
                    long long v85 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                    unsigned int v86 = *(_DWORD *)rhs;
                    if (os_log_type_enabled(v85, type.value)) {
                      unsigned int v87 = v86;
                    }
                    else {
                      unsigned int v87 = v86 & 0xFFFFFFFE;
                    }
                    if (v87)
                    {
                      BufferCFIndex Count = CMBufferQueueGetBufferCount(*(CMBufferQueueRef *)(a1 + 64));
                      CMSampleBufferGetOutputPresentationTimeStamp((CMTime *)lhs, v15);
                      Float64 v89 = CMTimeGetSeconds((CMTime *)lhs);
                      *(_DWORD *)CMTime time2 = 136316162;
                      *(void *)&time2[4] = "faq_handleSampleAttachmentsIfPresent_SeamIdentifier";
                      *(_WORD *)&time2[12] = 2048;
                      *(void *)&time2[14] = a1;
                      *(_WORD *)&time2[22] = 2112;
                      *(void *)&time2[24] = v84;
                      *(_WORD *)v394 = 1024;
                      *(_DWORD *)&v394[2] = BufferCount;
                      *(_WORD *)&v394[6] = 2048;
                      *(Float64 *)&v394[8] = v89;
                      _os_log_send_and_compose_impl();
                    }
                    fig_log_call_emit_and_clean_up_after_send_and_compose();
                    a2 = v349;
                  }
                  *(_OWORD *)CMTime rhs = v360;
                  *(void *)&rhs[16] = v362;
                  presentationTimeStamp.CMTimeValue value = 0;
                  __int16 v104 = "Samples with matching seam ID not found";
                  switch(FigValidateSampleSeamInSampleBufferQueue(*(opaqueCMBufferQueue **)(a1 + 64), (uint64_t)v84, (unint64_t)v321, &presentationTimeStamp, (uint64_t)rhs))
                  {
                    case 0u:
                      memset(&type, 0, sizeof(type));
                      int32_t v105 = *(_DWORD *)(v13 + 100);
                      *(_OWORD *)&time1.duration.CMTimeValue value = *(_OWORD *)rhs;
                      time1.duration.CMTimeEpoch epoch = *(void *)&rhs[16];
                      CMTimeConvertScale(&type, &time1.duration, v105, kCMTimeRoundingMethod_RoundTowardZero);
                      if (dword_1E9350B70)
                      {
                        LODWORD(v390.CFDictionarySetValue(theDict, key, value) = 0;
                        LOBYTE(v409.CFDictionarySetValue(theDict, key, value) = 0;
                        __int16 v106 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                        unsigned int v107 = v390.value;
                        if (os_log_type_enabled(v106, v409.value)) {
                          unsigned int v108 = v107;
                        }
                        else {
                          unsigned int v108 = v107 & 0xFFFFFFFE;
                        }
                        if (v108)
                        {
                          *(_DWORD *)CMTime time2 = 136316162;
                          *(void *)&time2[4] = "faq_handleSampleAttachmentsIfPresent_SeamIdentifier";
                          *(_WORD *)&time2[12] = 2048;
                          *(void *)&time2[14] = a1;
                          *(_WORD *)&time2[22] = 2112;
                          *(void *)&time2[24] = v84;
                          *(_WORD *)v394 = 1024;
                          *(_DWORD *)&v394[2] = presentationTimeStamp.value;
                          *(_WORD *)&v394[6] = 2048;
                          *(void *)&v394[8] = type.value;
                          _os_log_send_and_compose_impl();
                        }
                        fig_log_call_emit_and_clean_up_after_send_and_compose();
                      }
                      *(void *)(a1 + 112) = presentationTimeStamp.value;
                      *(void *)(a1 + 120) = CFRetain(v84);
                      _OWORD *v326 = *(_OWORD *)rhs;
                      *(void *)(a1 + 144) = *(void *)&rhs[16];
                      v286 = *(const void **)(a1 + 160);
                      *(void *)(a1 + 152) = presentationTimeStamp.value;
                      *(void *)(a1 + 160) = v84;
                      CFRetain(v84);
                      if (v286) {
                        CFRelease(v286);
                      }
                      goto LABEL_292;
                    case 1u:
                      goto LABEL_285;
                    case 2u:
                      __int16 v104 = "No samples are present before transition";
                      goto LABEL_285;
                    case 3u:
                      __int16 v104 = "More than one transitions found";
                      goto LABEL_285;
                    case 4u:
                      __int16 v104 = "Seam samples do not extend till the start of transition";
                      goto LABEL_285;
                    case 5u:
                      __int16 v104 = "Specified start trim is too long before transition";
                      goto LABEL_285;
                    case 6u:
                      __int16 v104 = "Specified end trim is too long before transition";
                      goto LABEL_285;
                    case 7u:
                      __int16 v104 = "Specified start trim is too long after transition";
                      goto LABEL_285;
                    case 8u:
                      __int16 v104 = "Specified end trim is too long after transition";
                      goto LABEL_285;
                    case 9u:
                      __int16 v104 = "Not enough seam samples present after transition";
                      goto LABEL_285;
                    case 0xAu:
                      __int16 v104 = "Trim duration is not equal on both sides of transition";
                      goto LABEL_285;
                    default:
                      __int16 v104 = "Unknown";
LABEL_285:
                      if (dword_1E9350B70)
                      {
                        LODWORD(type.CFDictionarySetValue(theDict, key, value) = 0;
                        LOBYTE(v390.CFDictionarySetValue(theDict, key, value) = 0;
                        __int16 v110 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                        unsigned int v111 = type.value;
                        if (os_log_type_enabled(v110, v390.value)) {
                          unsigned int v112 = v111;
                        }
                        else {
                          unsigned int v112 = v111 & 0xFFFFFFFE;
                        }
                        if (v112)
                        {
                          *(_DWORD *)CMTime time2 = 136315906;
                          *(void *)&time2[4] = "faq_handleSampleAttachmentsIfPresent_SeamIdentifier";
                          *(_WORD *)&time2[12] = 2048;
                          *(void *)&time2[14] = a1;
                          *(_WORD *)&time2[22] = 2112;
                          *(void *)&time2[24] = v84;
                          *(_WORD *)v394 = 2080;
                          *(void *)&v394[2] = v104;
                          _os_log_send_and_compose_impl();
                        }
                        fig_log_call_emit_and_clean_up_after_send_and_compose();
                      }
LABEL_292:
                      uint64_t v5 = v300;
                      break;
                  }
                }
              }
            }
          }
        }
        CFTypeRef cf = 0;
        values = v15;
        int v372 = 0;
        CFArrayRef theArray = 0;
        int v113 = *(unsigned __int8 *)(v13 + 544);
        uint64_t v114 = *(void *)(a1 + 120);
        if (v114)
        {
          uint64_t CountOfSequentialSamplesWithSeamIdentifier = FigGetCountOfSequentialSamplesWithSeamIdentifier(v15, v114, 0, 0);
          if (CountOfSequentialSamplesWithSeamIdentifier <= *(void *)(a1 + 112))
          {
            if (FigCreateReplacementSBufByOmittingTrailingSeamSamples(v15, *(void *)(a1 + 120), (CMSampleBufferRef *)&cf))
            {
              CFRange v115 = (opaqueCMSampleBuffer *)cf;
              values = (void *)cf;
            }
            else
            {
              faq_clearSeamHandlingState((__n128 *)a1);
              CFRange v115 = (opaqueCMSampleBuffer *)values;
            }
LABEL_301:
            if (!v115)
            {
              int v117 = 0;
LABEL_317:
              CFArrayRef v121 = theArray;
LABEL_322:
              int v356 = v117;
              if (!v121 || CFArrayGetCount(v121) < 1)
              {
                uint64_t v123 = 0;
                v311 = 0;
                v297 = 0;
                goto LABEL_376;
              }
              size_t v122 = (size_t)theArray;
              if (theArray) {
                size_t v122 = CFArrayGetCount(theArray);
              }
              uint64_t count = v122;
              v311 = malloc_type_calloc(v122, 8uLL, 0x2004093837F09uLL);
              uint64_t v123 = count;
              v297 = malloc_type_calloc(count, 1uLL, 0x100004077774924uLL);
              if (count < 1)
              {
                char v15 = v359;
                goto LABEL_376;
              }
              CFIndex v124 = 0;
              CMTimeScale timescale = (void *)(v13 + 336);
              while (1)
              {
                float v125 = (opaqueCMSampleBuffer *)CFArrayGetValueAtIndex(theArray, v124);
                *(void *)CMTime time2 = 0;
                *(void *)CMTime lhs = 0;
                *(void *)CMTime rhs = 0;
                type.CMTimeValue value = 0;
                if (!*(unsigned char *)(a1 + 16))
                {
                  double v126 = v125;
                  if (!CMSampleBufferDataIsReady(v125)) {
                    goto LABEL_659;
                  }
                  CMBlockBufferRef DataBuffer = CMSampleBufferGetDataBuffer(v126);
                  OSStatus DataPointer = CMBlockBufferGetDataPointer(DataBuffer, 0, (size_t *)&type, (size_t *)rhs, (char **)lhs);
                  if (DataPointer)
                  {
                    OSStatus v287 = DataPointer;
                    uint64_t v288 = 0;
                    goto LABEL_657;
                  }
                  if (*(void *)lhs && (uint64_t v129 = *(void *)rhs) != 0)
                  {
                    CMTimeValue v130 = type.value;
                    MEMORY[0x19970E910](*(void *)(v13 + 136));
                    uint64_t v131 = 0;
                    while (1)
                    {
                      uint64_t v132 = v13 + v131;
                      if (!*(unsigned char *)(v13 + v131 + 160)) {
                        break;
                      }
                      v131 += 24;
                      if (v131 == 192)
                      {
                        uint64_t v246 = 0;
                        v247 = (void *)(v13 + 136);
                        goto LABEL_565;
                      }
                    }
                    *(unsigned char *)(v132 + 160) = 1;
                    MEMORY[0x19970E930](*(void *)(v13 + 136));
                    *(void *)(v132 + 144) = CFRetain(v126);
                    double v133 = (void *)(v132 + 144);
                    CFTypeRef v134 = CMGetAttachment(v126, v307, 0);
                    v133[1] = v134;
                    if (v134) {
                      CFRetain(v134);
                    }
                    time1.duration.CMTimeValue value = MEMORY[0x1E4F143A8];
                    *(void *)&time1.duration.CMTimeScale timescale = v9;
                    time1.duration.CMTimeEpoch epoch = (CMTimeEpoch)__subaq_acquireAndPrepareAQBuffer_block_invoke;
                    time1.presentationTimeStamp.CMTimeValue value = (CMTimeValue)&__block_descriptor_tmp_317;
                    *(void *)&time1.presentationTimeStamp.CMTimeScale timescale = v13;
                    if (subaq_acquireAndPrepareAQBuffer_sAudioQueueCheckPIDOnce != -1) {
                      dispatch_once(&subaq_acquireAndPrepareAQBuffer_sAudioQueueCheckPIDOnce, &time1);
                    }
                    if (v130 == v129 && subaq_acquireAndPrepareAQBuffer_sAudioQueueCanAllocateBufferWithMemory)
                    {
                      OSStatus BufferWithMemory = FigAudioQueueTimingShimAllocateBufferWithMemory(*(void *)(v13 + 40));
                      if (BufferWithMemory)
                      {
                        OSStatus v287 = BufferWithMemory;
                        uint64_t v288 = v13 + v131 + 144;
LABEL_657:
                        FigSignalErrorAt();
                        subaq_returnAQBufferInfoPtr(v13, v288);
                        if (v287 == -12946)
                        {
                          uint64_t hostTime = 0;
                          LOBYTE(v337) = 0;
                          int v22 = 0;
                          int v301 = 0;
                          double v147 = 0.0;
                          uint64_t v5 = v300;
                          a2 = v349;
                          uint64_t v6 = v361;
                          goto LABEL_566;
                        }
LABEL_659:
                        char v15 = v359;
                        faq_dequeueFromSourceQueueAndDiscard();
                        uint64_t hostTime = 0;
                        LOBYTE(v337) = 0;
                        int v301 = 0;
                        int v22 = 1;
                        double v147 = 0.0;
                        uint64_t v5 = v300;
                        a2 = v349;
                        uint64_t v6 = v361;
                        double v245 = 0.5;
LABEL_567:
                        double v150 = v311;
                        uint64_t v148 = count;
                        goto LABEL_568;
                      }
                      char v136 = 1;
                      *(unsigned char *)(v13 + v131 + 161) = 1;
                      long long v137 = *(AudioQueueBuffer **)time2;
                    }
                    else
                    {
                      CMTimeValue v350 = v130;
                      unint64_t v138 = *(void *)rhs;
                      MEMORY[0x19970E910](*timescale);
                      uint64_t v139 = 0;
                      int v140 = -1;
                      int v141 = -1;
                      do
                      {
                        long long v137 = *(AudioQueueBuffer **)(v13 + 344 + 8 * v139);
                        if (!v137 || v137->mUserData) {
                          goto LABEL_350;
                        }
                        if (v138 <= v137->mAudioDataBytesCapacity) {
                          goto LABEL_365;
                        }
                        if (v140 == -1)
                        {
                          int v140 = v139;
                        }
                        else
                        {
LABEL_350:
                          if (v137) {
                            BOOL v142 = 0;
                          }
                          else {
                            BOOL v142 = v141 == -1;
                          }
                          if (v142) {
                            int v141 = v139;
                          }
                        }
                        ++v139;
                      }
                      while (v139 != 8);
                      UInt32 v143 = (v138 + 4095) & 0xFFFFF000;
                      if (v140 == -1)
                      {
                        if (v141 == -1)
                        {
                          uint64_t v246 = v13 + v131 + 144;
LABEL_650:
                          v247 = (void *)(v13 + 336);
LABEL_565:
                          MEMORY[0x19970E930](*v247);
                          subaq_returnAQBufferInfoPtr(v13, v246);
                          uint64_t hostTime = 0;
                          LOBYTE(v337) = 0;
                          int v22 = 0;
                          int v301 = 0;
                          double v147 = 0.0;
                          uint64_t v5 = v300;
                          a2 = v349;
                          uint64_t v6 = v361;
LABEL_566:
                          double v245 = 0.5;
                          char v15 = v359;
                          goto LABEL_567;
                        }
                        uint64_t v145 = *(void *)(v13 + 40);
                        CMTime v144 = (AudioQueueBuffer **)(v13 + 8 * v141 + 344);
                      }
                      else
                      {
                        CMTime v144 = (AudioQueueBuffer **)(v13 + 8 * v140 + 344);
                        FigAudioQueueTimingShimFreeBuffer(*(void *)(v13 + 40), *v144);
                        *CMTime v144 = 0;
                        uint64_t v145 = *(void *)(v13 + 40);
                        UInt32 v143 = (v138 + 4095) & 0xFFFFF000;
                      }
                      if (FigAudioQueueTimingShimAllocateBuffer(v145, v143, v144))
                      {
                        FigSignalErrorAt();
                        uint64_t v246 = v13 + v131 + 144;
                        goto LABEL_650;
                      }
                      long long v137 = *v144;
LABEL_365:
                      v137->mUserCFDataRef Data = v133;
                      *(void *)CMTime time2 = v137;
                      MEMORY[0x19970E930](*timescale);
                      if (v350 == v129)
                      {
                        memcpy(v137->mAudioData, *(const void **)lhs, *(size_t *)rhs);
                      }
                      else
                      {
                        CMTime v146 = CMSampleBufferGetDataBuffer(v126);
                        CMBlockBufferCopyDataBytes(v146, 0, *(size_t *)rhs, v137->mAudioData);
                      }
                      if (*MEMORY[0x1E4F1EBA8] == 1) {
                        kdebug_trace();
                      }
                      char v136 = 0;
                      *(unsigned char *)(v13 + v131 + 161) = 0;
                    }
                    v137->mAudioDataByteSize = *(_DWORD *)rhs;
                    v137->mUserCFDataRef Data = v133;
                    v311[v124] = v137;
                    v297[v124] = v136;
                    uint64_t v5 = v300;
                    uint64_t v6 = v361;
                  }
                  else
                  {
                    FigSignalErrorAt();
                    uint64_t v5 = v300;
                    uint64_t v6 = v361;
                  }
                }
                if (++v124 == count)
                {
                  int v356 = 0;
                  a2 = v349;
                  char v15 = v359;
                  uint64_t v123 = count;
LABEL_376:
                  faq_dequeueFromSourceQueueAndDiscard();
                  int v22 = 1;
                  double v147 = 0.0;
                  uint64_t v148 = v123;
                  if (v123 >= 1 && !v356)
                  {
                    uint64_t hostTime = 0;
                    int v337 = 0;
                    uint64_t v149 = 0;
                    int v301 = 0;
                    v310 = (_OWORD *)(v13 + 408);
                    v294 = (_OWORD *)(v13 + 456);
                    v295 = (_OWORD *)(v13 + 432);
                    v302 = (_OWORD *)(v13 + 484);
                    size_t counta = v123;
                    double v150 = v311;
                    while (2)
                    {
                      uint64_t v151 = v150[v149];
                      double v152 = **(opaqueCMSampleBuffer ***)(v151 + 24);
                      CMTimeValue v406 = *MEMORY[0x1E4F1FA20];
                      CMTimeScale v407 = *(_DWORD *)(MEMORY[0x1E4F1FA20] + 8);
                      long long v384 = 0u;
                      long long v385 = 0u;
                      memset(lhs, 0, sizeof(lhs));
                      long long v381 = 0u;
                      long long v382 = 0u;
                      memset(rhs, 0, sizeof(rhs));
                      int v305 = *(unsigned __int8 *)(v13 + 546);
                      if (*(unsigned char *)(v13 + 546))
                      {
                        uint64_t v153 = *(void *)(v13 + 64);
                        if (*(_DWORD *)(v153 + 20)) {
                          BOOL v154 = 0;
                        }
                        else {
                          BOOL v154 = *(_DWORD *)(v153 + 8) == 1987015266;
                        }
                        *(void *)(v13 + 552) = v154;
                      }
                      packetDescriptionsSizeOut.CMTimeValue value = 0;
                      packetDescriptionsPointerOut = 0;
                      memset(time2, 0, 24);
                      if (faq_getFigTimeAttachment(v152, v339, (CMTime *)time2))
                      {
                        if (*(uint64_t *)(v13 + 552) < 1)
                        {
                          CMItemIndex v155 = 0;
                        }
                        else
                        {
                          CMItemIndex v155 = 0;
                          do
                          {
                            memset(&time1, 0, sizeof(time1));
                            if (CMSampleBufferGetSampleTimingInfo(v152, v155, &time1)) {
                              break;
                            }
                            CMTime type = *(CMTime *)time2;
                            CMTime presentationTimeStamp = time1.duration;
                            if (CMTimeCompare(&type, &presentationTimeStamp) < 0)
                            {
                              *(void *)(v13 + 552) = 0;
                              break;
                            }
                            CMTime type = *(CMTime *)time2;
                            CMTime presentationTimeStamp = time1.duration;
                            CMTimeSubtract((CMTime *)time2, &type, &presentationTimeStamp);
                            uint64_t v156 = *(void *)(v13 + 552);
                            ++v155;
                            *(void *)(v13 + 552) = v156 - 1;
                          }
                          while (v156 > 1);
                        }
                        int32_t v157 = *(_DWORD *)(v13 + 100);
                        *(_OWORD *)&time1.duration.CMTimeValue value = *(_OWORD *)time2;
                        time1.duration.CMTimeEpoch epoch = *(void *)&time2[16];
                        CMTimeConvertScale(&type, &time1.duration, v157, kCMTimeRoundingMethod_RoundTowardZero);
                        UInt32 v336 = type.value;
                      }
                      else
                      {
                        UInt32 v336 = 0;
                        CMItemIndex v155 = 0;
                      }
                      memset(time2, 0, 24);
                      memset(&presentationTimeStamp, 0, sizeof(presentationTimeStamp));
                      if (faq_getFigTimeAttachment(v152, v338, (CMTime *)time2))
                      {
                        int32_t v158 = *(_DWORD *)(v13 + 100);
                        *(_OWORD *)&time1.duration.CMTimeValue value = *(_OWORD *)time2;
                        time1.duration.CMTimeEpoch epoch = *(void *)&time2[16];
                        CMTimeConvertScale(&v390, &time1.duration, v158, kCMTimeRoundingMethod_RoundTowardZero);
                        int v334 = v390.value;
                      }
                      else
                      {
                        int v334 = 0;
                      }
                      if (!*(unsigned char *)(v13 + 544)) {
                        goto LABEL_403;
                      }
                      int64_t v159 = *(unsigned int *)(*(void *)(v13 + 64) + 20);
                      if (!v159) {
                        goto LABEL_403;
                      }
                      memset(&v409, 0, sizeof(v409));
                      CMTimeMake(&v409, v159, *(_DWORD *)(v13 + 100));
                      long long v160 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 48);
                      *(_OWORD *)&time1.presentationTimeStamp.CMTimeScale timescale = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 32);
                      *(_OWORD *)&time1.decodeTimeStamp.CMTimeValue value = v160;
                      time1.decodeTimeStamp.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA70] + 64);
                      long long v161 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 16);
                      *(_OWORD *)&time1.duration.CMTimeValue value = *MEMORY[0x1E4F1FA70];
                      *(_OWORD *)&time1.duration.CMTimeEpoch epoch = v161;
                      CMItemCount NumSamples = CMSampleBufferGetNumSamples(v152);
                      if (CMSampleBufferGetSampleTimingInfo(v152, NumSamples - 1, &time1)) {
                        goto LABEL_403;
                      }
                      if ((time1.duration.flags & 0x1D) == 1
                        && (CMTime v389 = time1.duration, end = v409, CMTimeCompare(&v389, &end) < 0))
                      {
                        CMTime v389 = v409;
                        CMTime end = time1.duration;
                        CMTimeSubtract(&presentationTimeStamp, &v389, &end);
                        int32_t v190 = *(_DWORD *)(v13 + 100);
                        CMTime end = presentationTimeStamp;
                        CMTimeConvertScale(&v389, &end, v190, kCMTimeRoundingMethod_RoundTowardZero);
                        int v332 = v389.value;
                      }
                      else
                      {
LABEL_403:
                        int v332 = 0;
                      }
                      if (CMSampleBufferGetAudioStreamPacketDescriptionsPtr(v152, (const AudioStreamPacketDescription **)&packetDescriptionsPointerOut, (size_t *)&packetDescriptionsSizeOut))
                      {
                        int v163 = 0;
                        LODWORD(v333) = 0;
                        packetDescriptionsPointerOut = 0;
                      }
                      else
                      {
                        unint64_t v333 = (unint64_t)packetDescriptionsSizeOut.value >> 4;
                        if (v155 < 1)
                        {
                          int v163 = 0;
                        }
                        else
                        {
                          CMTimeValue v164 = packetDescriptionsSizeOut.value & 0xFFFFFFFF0;
                          CFAllocatorRef v165 = CFGetAllocator((CFTypeRef)v13);
                          v166 = (AudioStreamPacketDescription *)CFAllocatorAllocate(v165, v164, 0);
                          if (v166)
                          {
                            CMTimeValue v167 = v166;
                            memcpy(v166, packetDescriptionsPointerOut, v164);
                            uint64_t v168 = 8;
                            do
                            {
                              *(_DWORD *)((char *)&v167->mStartOffset + v168) = 0;
                              v168 += 16;
                              --v155;
                            }
                            while (v155);
                            packetDescriptionsPointerOut = v167;
                            int v163 = 1;
                          }
                          else
                          {
                            int v163 = 0;
                          }
                        }
                      }
                      uint64_t v169 = *(void *)(a1 + 160);
                      if (v169 && !*(void *)(a1 + 112))
                      {
                        uint64_t v170 = FigGetCountOfSequentialSamplesWithSeamIdentifier(v152, v169, 1, 0);
                        if (!v170
                          || ((v336 = 0, uint64_t v171 = *(void *)(a1 + 152), v170 >= v171)
                            ? (uint64_t v172 = *(void *)(a1 + 152))
                            : (uint64_t v172 = v170),
                              *(void *)(a1 + 152) = v171 - v172,
                              v171 <= v170))
                        {
                          faq_clearSeamHandlingState((__n128 *)a1);
                        }
                      }
                      CMSampleBufferGetOutputPresentationTimeStamp(&start, v152);
                      CMSampleBufferGetOutputDuration(&duration, v152);
                      CMTimeRangeMake((CMTimeRange *)&time1, &start, &duration);
                      CMTimeValue v406 = time1.duration.value;
                      CMTimeFlags flags = time1.duration.flags;
                      CMTimeScale v407 = time1.duration.timescale;
                      CMTimeEpoch v174 = time1.duration.epoch;
                      CMTimeValue timescalea = time1.presentationTimeStamp.value;
                      uint64_t v175 = *(void *)&time1.presentationTimeStamp.timescale;
                      CMTimeEpoch v344 = time1.presentationTimeStamp.epoch;
                      CMTimeFlags v351 = time1.duration.flags;
                      int v331 = v163;
                      v330 = (AudioQueueBuffer *)v151;
                      CMTimeEpoch v341 = time1.duration.epoch;
                      if (*(unsigned char *)(v13 + 546))
                      {
                        memset(&time1, 0, 24);
                        *(void *)CMTime time2 = v406;
                        *(_DWORD *)&time2[8] = v407;
                        *(_DWORD *)&time2[12] = flags;
                        *(void *)&time2[16] = v174;
                        subaq_convertMediaTimeToAQTime((CMTime *)a1, (CMTime *)time2, (uint64_t)&time1);
                        memset(lhs, 0, sizeof(lhs));
                        long long v384 = 0u;
                        long long v385 = 0u;
                        int32_t v176 = *(_DWORD *)(v13 + 100);
                        *(_OWORD *)CMTime time2 = *(_OWORD *)&time1.duration.value;
                        *(void *)&time2[16] = time1.duration.epoch;
                        CMTimeConvertScale(&v377, (CMTime *)time2, v176, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
                        int v177 = 0;
                        *(double *)CMTime lhs = (double)v377.value;
                        DWORD2(v385) = 1;
                        *(unsigned char *)(v13 + 546) = 0;
                        long long v178 = (double *)lhs;
                        if ((flags & 1) == 0) {
                          goto LABEL_460;
                        }
                        goto LABEL_455;
                      }
                      if (*(unsigned char *)(a1 + 16)) {
                        goto LABEL_430;
                      }
                      if ((*(unsigned char *)(v13 + 420) & 1) == 0) {
                        goto LABEL_425;
                      }
                      CFTypeRef v179 = CMGetAttachment(v152, v318, 0);
                      CMTimeEpoch v174 = v341;
                      if (v179 == v317 || *(unsigned char *)(v13 + 545))
                      {
LABEL_430:
                        v409.CMTimeValue value = v406;
                        v409.CMTimeScale timescale = v407;
                        if (v298)
                        {
                          time1.duration.CMTimeValue value = v406;
                          time1.duration.CMTimeScale timescale = v407;
                          time1.duration.CMTimeFlags flags = v351;
                          time1.duration.CMTimeEpoch epoch = v174;
                          *(_OWORD *)CMTime time2 = *v310;
                          *(void *)&time2[16] = *(void *)(v13 + 424);
                          CMTimeEpoch v180 = v174;
                          CMTimeCompare(&time1.duration, (CMTime *)time2);
                          uint64_t v181 = v13 + 408;
                          CMTimeFlags v182 = v351;
                          goto LABEL_434;
                        }
                        CMTimeFlags v182 = *(_DWORD *)(a1 + 332);
                      }
                      else
                      {
                        if (v298)
                        {
LABEL_425:
                          long long v178 = 0;
                          int v177 = 0;
                          goto LABEL_426;
                        }
                        CMTimeFlags v182 = *(_DWORD *)(a1 + 332);
                        if ((v182 & 1) == 0)
                        {
                          long long v178 = 0;
                          int v177 = 0;
LABEL_426:
                          CMTimeFlags flags = v351;
                          if ((v351 & 1) == 0) {
                            goto LABEL_460;
                          }
                          goto LABEL_455;
                        }
                      }
                      uint64_t v181 = v13 + 408;
                      v409.CMTimeValue value = *v325;
                      v409.CMTimeScale timescale = *(_DWORD *)(a1 + 328);
                      CMTimeEpoch v180 = *(void *)(a1 + 336);
LABEL_434:
                      time1.duration.CMTimeValue value = v409.value;
                      time1.duration.CMTimeScale timescale = v409.timescale;
                      time1.duration.CMTimeFlags flags = v182;
                      time1.duration.CMTimeEpoch epoch = v180;
                      *(_OWORD *)CMTime time2 = *(_OWORD *)v181;
                      *(void *)&time2[16] = *(void *)(v181 + 16);
                      uint64_t v183 = v181;
                      if (!CMTimeCompare(&time1.duration, (CMTime *)time2)) {
                        goto LABEL_436;
                      }
                      memset(&type, 0, sizeof(type));
                      CMTimeMake(&type, 2, *(_DWORD *)(v13 + 100));
                      memset(&presentationTimeStamp, 0, sizeof(presentationTimeStamp));
                      time1.duration.CMTimeValue value = v409.value;
                      time1.duration.CMTimeScale timescale = v409.timescale;
                      time1.duration.CMTimeFlags flags = v182;
                      time1.duration.CMTimeEpoch epoch = v180;
                      *(_OWORD *)CMTime time2 = *(_OWORD *)v183;
                      *(void *)&time2[16] = *(void *)(v183 + 16);
                      CMTimeSubtract(&v377, &time1.duration, (CMTime *)time2);
                      CMTimeAbsoluteValue(&presentationTimeStamp, &v377);
                      time1.CMTime duration = type;
                      *(CMTime *)CMTime time2 = presentationTimeStamp;
                      if (CMTimeCompare(&time1.duration, (CMTime *)time2) < 0)
                      {
                        memset(&v390, 0, sizeof(v390));
                        *(_OWORD *)&time1.duration.CMTimeValue value = *v295;
                        time1.duration.CMTimeEpoch epoch = *(void *)(v13 + 448);
                        *(_OWORD *)CMTime time2 = *v294;
                        *(void *)&time2[16] = *(void *)(v13 + 472);
                        CMTimeAdd(&v376, &time1.duration, (CMTime *)time2);
                        time1.CMTime duration = presentationTimeStamp;
                        CMTimeAdd(&v390, &v376, &time1.duration);
                        if (dword_1E9350B70)
                        {
                          LODWORD(v389.CFDictionarySetValue(theDict, key, value) = 0;
                          LOBYTE(end.CFDictionarySetValue(theDict, key, value) = 0;
                          v184 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                          unsigned int v185 = v389.value;
                          if (os_log_type_enabled(v184, end.value)) {
                            unsigned int v186 = v185;
                          }
                          else {
                            unsigned int v186 = v185 & 0xFFFFFFFE;
                          }
                          if (v186)
                          {
                            CMTimeValue v290 = presentationTimeStamp.value;
                            CMTimeScale v291 = presentationTimeStamp.timescale;
                            time1.CMTime duration = presentationTimeStamp;
                            Float64 v187 = CMTimeGetSeconds(&time1.duration);
                            time1.duration.CMTimeValue value = v409.value;
                            time1.duration.CMTimeScale timescale = v409.timescale;
                            time1.duration.CMTimeFlags flags = v182;
                            time1.duration.CMTimeEpoch epoch = v180;
                            Float64 v188 = CMTimeGetSeconds(&time1.duration);
                            *(_OWORD *)&time1.duration.CMTimeValue value = *v310;
                            time1.duration.CMTimeEpoch epoch = *(void *)(v13 + 424);
                            Float64 v189 = CMTimeGetSeconds(&time1.duration);
                            *(_DWORD *)CMTime time2 = 136317186;
                            *(void *)&time2[4] = "subaq_enqueueAQBufferIntoAudioQueue";
                            *(_WORD *)&time2[12] = 2048;
                            *(void *)&time2[14] = a1;
                            *(_WORD *)&time2[22] = 2048;
                            *(void *)&time2[24] = v13;
                            *(_WORD *)v394 = 2080;
                            *(void *)&v394[2] = a1 + 776;
                            *(_WORD *)&v394[10] = 2048;
                            *(void *)&v394[12] = v290;
                            *(_WORD *)&v394[20] = 1024;
                            *(_DWORD *)v395 = v291;
                            *(_WORD *)&v395[4] = 2048;
                            *(Float64 *)&v395[6] = v187;
                            __int16 v396 = 2048;
                            Float64 v397 = v188;
                            __int16 v398 = 2048;
                            double v399 = v189;
                            _os_log_send_and_compose_impl();
                          }
                          fig_log_call_emit_and_clean_up_after_send_and_compose();
                        }
                        subaq_flushAudioQueue(a1, v13);
                        long long v384 = 0u;
                        long long v385 = 0u;
                        memset(lhs, 0, sizeof(lhs));
                        int32_t v191 = *(_DWORD *)(v13 + 100);
                        time1.CMTime duration = v390;
                        int v177 = 1;
                        CMTimeConvertScale(&v375, &time1.duration, v191, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
                        *(double *)CMTime lhs = (double)v375.value;
                        DWORD2(v385) = 1;
                        long long v178 = (double *)lhs;
                      }
                      else
                      {
LABEL_436:
                        long long v178 = 0;
                        int v177 = 0;
                      }
                      CMTimeFlags flags = v351;
                      BOOL v192 = 0;
                      if ((v351 & 1) != 0
                        && (v175 & 0x100000000) != 0
                        && !v344
                        && (timescalea & 0x8000000000000000) == 0)
                      {
                        time1.duration.CMTimeValue value = timescalea;
                        *(void *)&time1.duration.CMTimeScale timescale = v175;
                        time1.duration.CMTimeEpoch epoch = 0;
                        *(_OWORD *)CMTime time2 = v360;
                        *(void *)&time2[16] = v362;
                        BOOL v192 = CMTimeCompare(&time1.duration, (CMTime *)time2) == 0;
                      }
                      *(unsigned char *)(v13 + 545) = v192;
                      if ((v351 & 1) == 0)
                      {
LABEL_460:
                        BOOL v193 = v177 != 0;
                        uint64_t v6 = v361;
                        goto LABEL_461;
                      }
LABEL_455:
                      if ((v175 & 0x100000000) == 0 || v344 || timescalea < 0) {
                        goto LABEL_460;
                      }
                      time1.duration.CMTimeValue value = timescalea;
                      *(void *)&time1.duration.CMTimeScale timescale = v175;
                      time1.duration.CMTimeEpoch epoch = 0;
                      *(_OWORD *)CMTime time2 = v360;
                      *(void *)&time2[16] = v362;
                      BOOL v193 = v177 != 0;
                      if (!(v305 | v177 | CMTimeCompare(&time1.duration, (CMTime *)time2)))
                      {
                        int v206 = 1;
                        uint64_t v6 = v361;
LABEL_487:
                        BOOL v205 = 0;
                        if (v206 && !v344 && (timescalea & 0x8000000000000000) == 0)
                        {
                          time1.duration.CMTimeValue value = timescalea;
                          *(void *)&time1.duration.CMTimeScale timescale = v175;
                          time1.duration.CMTimeEpoch epoch = 0;
                          *(_OWORD *)CMTime time2 = v360;
                          *(void *)&time2[16] = v362;
                          BOOL v205 = !CMTimeCompare(&time1.duration, (CMTime *)time2) && (*(unsigned char *)(v13 + 420) & 1) == 0;
                          time1.duration.CMTimeValue value = timescalea;
                          *(void *)&time1.duration.CMTimeScale timescale = v175;
                          time1.duration.CMTimeEpoch epoch = 0;
                          *(_OWORD *)CMTime time2 = v360;
                          *(void *)&time2[16] = v362;
                          char v207 = CMTimeCompare(&time1.duration, (CMTime *)time2) || v193;
                          if ((v207 & 1) == 0 && !v205) {
                            goto LABEL_512;
                          }
                        }
                        goto LABEL_498;
                      }
                      uint64_t v6 = v361;
                      CMTimeFlags flags = v351;
LABEL_461:
                      int v194 = *(unsigned __int8 *)(a1 + 16);
                      if (!*(unsigned char *)(a1 + 16))
                      {
                        if (*(float *)(v13 + 532) == v75)
                        {
                          int v194 = 0;
                        }
                        else
                        {
                          memset(&time1, 0, 24);
                          if (v178)
                          {
                            CMTimeMake(&time1.duration, (uint64_t)*v178, *(_DWORD *)(v13 + 100));
                          }
                          else
                          {
                            float v195 = *(float *)(a1 + 416);
                            double v196 = 1.0;
                            if (v195 == 0.0) {
                              double v197 = 1.0;
                            }
                            else {
                              double v197 = v195;
                            }
                            if (*(unsigned char *)(a1 + 236))
                            {
                              float v198 = *(float *)(a1 + 232);
                              BOOL v78 = v198 == 0.0;
                              double v196 = v198;
                              if (v78) {
                                double v196 = 1.0;
                              }
                            }
                            *(void *)CMTime time2 = v406;
                            *(_DWORD *)&time2[8] = v407;
                            *(_DWORD *)&time2[12] = flags;
                            *(void *)&time2[16] = v341;
                            faqTimelineWrangler_convertMediaTimeToAQTime(v327, (CMTime *)time2, (uint64_t)&time1, v197 / v196);
                          }
                          *(_OWORD *)CMTime time2 = *(_OWORD *)&time1.duration.value;
                          *(void *)&time2[16] = time1.duration.epoch;
                          int v199 = subaq_schedulePlayRate2ValueForTime(a1, v13, (CMTime *)time2, v75);
                          if (v199)
                          {
                            int v216 = v199;
                            goto LABEL_514;
                          }
                          int v194 = *(unsigned __int8 *)(a1 + 16);
                        }
                      }
                      *(float *)(v13 + 532) = v75;
                      memset(&type, 0, sizeof(type));
                      memset(&presentationTimeStamp, 0, sizeof(presentationTimeStamp));
                      memset(&v390, 0, sizeof(v390));
                      memset(&time1, 0, 48);
                      if (!v194)
                      {
                        CMSampleBufferGetOutputPresentationTimeStamp(&type, v152);
                        CMSampleBufferGetOutputDuration(&v409, v152);
                        *(CMTime *)CMTime time2 = type;
                        CMTimeAdd(&presentationTimeStamp, (CMTime *)time2, &v409);
                        if (v178)
                        {
                          memset(time2, 0, 24);
                          CMTimeMake(&v389, 3, 10);
                          CMTime end = type;
                          CMTimeSubtract((CMTime *)time2, &end, &v389);
                          if (*(unsigned char *)(v13 + 496))
                          {
                            *(_OWORD *)&end.CMTimeValue value = *v302;
                            CMTimeEpoch v200 = *(void *)(v13 + 500);
                          }
                          else
                          {
                            *(_OWORD *)&end.CMTimeValue value = v360;
                            CMTimeEpoch v200 = v362;
                          }
                          end.CMTimeEpoch epoch = v200;
                          CMTime packetDescriptionsSizeOut = *(CMTime *)time2;
                          *(_OWORD *)&v387.CMTimeValue value = *(_OWORD *)&end.value;
                          v387.CMTimeEpoch epoch = v200;
                          CMTimeMaximum(&v390, &packetDescriptionsSizeOut, &v387);
                        }
                        else
                        {
                          CMTime v390 = type;
                        }
                        *(CMTime *)CMTime time2 = v390;
                        CMTime end = presentationTimeStamp;
                        CMTimeRangeFromTimeToTime((CMTimeRange *)&time1, (CMTime *)time2, &end);
                        CFDictionaryRef v201 = *(const __CFDictionary **)(a1 + 656);
                        *(_OWORD *)CMTime time2 = *(_OWORD *)&time1.duration.value;
                        *(_OWORD *)&time2[16] = *(_OWORD *)&time1.duration.epoch;
                        *(_OWORD *)v394 = *(_OWORD *)&time1.presentationTimeStamp.timescale;
                        subaq_scheduleVolumeCurvesForMediaTimeRange(a1, v13, v201, time2, 1, v178 != 0);
                        CFDictionaryRef v202 = *(const __CFDictionary **)(a1 + 664);
                        *(_OWORD *)CMTime time2 = *(_OWORD *)&time1.duration.value;
                        *(_OWORD *)&time2[16] = *(_OWORD *)&time1.duration.epoch;
                        *(_OWORD *)v394 = *(_OWORD *)&time1.presentationTimeStamp.timescale;
                        subaq_scheduleVolumeCurvesForMediaTimeRange(a1, v13, v202, time2, 0, v178 != 0);
                        subaq_scheduleCinematicForMediaTimeRange((const __CFArray *)a1, v13, *(CFDictionaryRef *)(a1 + 656));
                        uint64_t v203 = *(void *)(a1 + 656);
                        *(_OWORD *)CMTime time2 = *(_OWORD *)&time1.duration.value;
                        *(_OWORD *)&time2[16] = *(_OWORD *)&time1.duration.epoch;
                        *(_OWORD *)v394 = *(_OWORD *)&time1.presentationTimeStamp.timescale;
                        subaq_scheduleAudioProcessingUnitForMediaTimeRange(a1, v13, v203, (long long *)time2, 1, 0);
                        uint64_t v204 = *(void *)(a1 + 664);
                        *(_OWORD *)CMTime time2 = *(_OWORD *)&time1.duration.value;
                        *(_OWORD *)&time2[16] = *(_OWORD *)&time1.duration.epoch;
                        *(_OWORD *)v394 = *(_OWORD *)&time1.presentationTimeStamp.timescale;
                        subaq_scheduleAudioProcessingUnitForMediaTimeRange(a1, v13, v204, (long long *)time2, 0, 0);
                      }
                      if (v351)
                      {
                        int v206 = BYTE4(v175) & 1;
                        goto LABEL_487;
                      }
                      BOOL v205 = 0;
LABEL_498:
                      if ((*(unsigned char *)(a1 + 48) & 2) != 0 || *(float *)(a1 + 416) >= 0.0)
                      {
                        time1.duration.CMTimeValue value = v406;
                        time1.duration.CMTimeScale timescale = v407;
                        time1.duration.CMTimeFlags flags = v351;
                        time1.duration.CMTimeEpoch epoch = v341;
                        time1.presentationTimeStamp.CMTimeValue value = timescalea;
                        *(void *)&time1.presentationTimeStamp.CMTimeScale timescale = v175;
                        time1.presentationTimeStamp.CMTimeEpoch epoch = v344;
                        CMTimeRangeGetEnd((CMTime *)time2, (CMTimeRange *)&time1);
                        uint64_t v208 = v13 + 408;
                        _OWORD *v310 = *(_OWORD *)time2;
                        CMTimeEpoch v209 = *(void *)&time2[16];
                      }
                      else
                      {
                        *(void *)CMTime time2 = v406;
                        *(_DWORD *)&time2[8] = v407;
                        *(_DWORD *)&time2[12] = v351;
                        *(void *)&time2[16] = v341;
                        type.CMTimeValue value = timescalea;
                        *(void *)&type.CMTimeScale timescale = v175;
                        type.CMTimeEpoch epoch = v344;
                        CMTimeSubtract(&time1.duration, (CMTime *)time2, &type);
                        uint64_t v208 = v13 + 408;
                        _OWORD *v310 = *(_OWORD *)&time1.duration.value;
                        CMTimeEpoch v209 = time1.duration.epoch;
                      }
                      *(void *)(v208 + 16) = v209;
                      if (dword_1E9350B70) {
                        BOOL v210 = v205;
                      }
                      else {
                        BOOL v210 = 0;
                      }
                      if (v210)
                      {
                        LODWORD(type.CFDictionarySetValue(theDict, key, value) = 0;
                        LOBYTE(presentationTimeStamp.CFDictionarySetValue(theDict, key, value) = 0;
                        v211 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                        unsigned int v212 = type.value;
                        if (os_log_type_enabled(v211, presentationTimeStamp.value)) {
                          unsigned int v213 = v212;
                        }
                        else {
                          unsigned int v213 = v212 & 0xFFFFFFFE;
                        }
                        if (v213)
                        {
                          *(_OWORD *)&time1.duration.CMTimeValue value = *v310;
                          time1.duration.CMTimeEpoch epoch = *(void *)(v13 + 424);
                          Float64 v214 = CMTimeGetSeconds(&time1.duration);
                          *(_DWORD *)CMTime time2 = 136315906;
                          *(void *)&time2[4] = "subaq_enqueueAQBufferIntoAudioQueue";
                          *(_WORD *)&time2[12] = 2048;
                          *(void *)&time2[14] = a1;
                          *(_WORD *)&time2[22] = 2048;
                          *(void *)&time2[24] = v13;
                          *(_WORD *)v394 = 2048;
                          *(Float64 *)&v394[2] = v214;
                          _os_log_send_and_compose_impl();
                        }
                        fig_log_call_emit_and_clean_up_after_send_and_compose();
                        uint64_t v6 = v361;
                      }
LABEL_512:
                      CMSampleBufferGetOutputDuration(&v409, v152);
                      CMTimeConvertScale(&v389, &v409, *(_DWORD *)(v13 + 100), kCMTimeRoundingMethod_RoundHalfAwayFromZero);
                      int v215 = v389.value;
                      *(void *)(a1 + 728) += CMSampleBufferGetNumSamples(v152);
                      *(unsigned char *)(a1 + 306) = 0;
                      if (FigAudioQueueTimingShimEnqueueBufferWithParameters(*(CMTime **)(v13 + 40), v330, v333, packetDescriptionsPointerOut, v336, v332 + v334, 0, 0, (uint64_t)v178, rhs))
                      {
                        FigSignalErrorAt();
                        int v22 = 0;
                        int v216 = 1;
LABEL_514:
                        a2 = v349;
                        goto LABEL_531;
                      }
                      *(unsigned char *)(a1 + 577) = 0;
                      double v217 = *(double *)rhs;
                      char v218 = BYTE8(v382);
                      long long v219 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
                      *(_OWORD *)&time1.duration.CMTimeValue value = *MEMORY[0x1E4F1FA20];
                      *(_OWORD *)&time1.duration.CMTimeEpoch epoch = v219;
                      *(_OWORD *)&time1.presentationTimeStamp.CMTimeScale timescale = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 32);
                      end.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
                      end.CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
                      if (!*(unsigned char *)(a1 + 16))
                      {
                        CMSampleBufferGetOutputPresentationTimeStamp((CMTime *)time2, v152);
                        CMSampleBufferGetOutputDuration(&type, v152);
                        CMTimeRangeMake((CMTimeRange *)&time1, (CMTime *)time2, &type);
                        if ((*(unsigned char *)(a1 + 48) & 2) != 0)
                        {
                          CMTime presentationTimeStamp = time1.presentationTimeStamp;
                          *(_OWORD *)&v390.CMTimeValue value = v360;
                          v390.CMTimeEpoch epoch = v362;
                          if (CMTimeCompare(&presentationTimeStamp, &v390)
                            || v178
                            || (CMTimeFlags v220 = v309, v221 = v347, (*(_DWORD *)(v13 + 444) & 1) == 0))
                          {
                            CMTime v390 = time1.duration;
                            subaq_convertMediaTimeToAQTime((CMTime *)a1, &v390, (uint64_t)&presentationTimeStamp);
                            goto LABEL_522;
                          }
                        }
                        else
                        {
                          if ((v218 & 1) == 0)
                          {
                            end.CMTimeValue value = *MEMORY[0x1E4F1FA48];
                            end.CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1FA48] + 8);
                            CMTimeFlags v220 = v314;
                            CMTimeEpoch v221 = v362;
                            goto LABEL_523;
                          }
                          CMTimeMake(&presentationTimeStamp, (uint64_t)v217, *(_DWORD *)(v13 + 100));
LABEL_522:
                          end.CMTimeValue value = presentationTimeStamp.value;
                          CMTimeFlags v220 = presentationTimeStamp.flags;
                          end.CMTimeScale timescale = presentationTimeStamp.timescale;
                          CMTimeEpoch v221 = presentationTimeStamp.epoch;
                        }
LABEL_523:
                        if (v220)
                        {
                          *(void *)v295 = end.value;
                          *(_DWORD *)(v13 + 440) = end.timescale;
                          *(_DWORD *)(v13 + 444) = v220;
                          *(void *)(v13 + 448) = v221;
                          _OWORD *v294 = *(_OWORD *)&time1.presentationTimeStamp.value;
                          *(void *)(v13 + 472) = time1.presentationTimeStamp.epoch;
                        }
                      }
                      time1.duration.CMTimeValue value = v406;
                      time1.duration.CMTimeScale timescale = v407;
                      time1.duration.CMTimeFlags flags = v351;
                      time1.duration.CMTimeEpoch epoch = v341;
                      time1.presentationTimeStamp.CMTimeValue value = timescalea;
                      *(void *)&time1.presentationTimeStamp.CMTimeScale timescale = v175;
                      time1.presentationTimeStamp.CMTimeEpoch epoch = v344;
                      CMTimeRangeGetEnd((CMTime *)time2, (CMTimeRange *)&time1);
                      _OWORD *v302 = *(_OWORD *)time2;
                      *(void *)(v13 + 500) = *(void *)&time2[16];
                      *(_OWORD *)v325 = *MEMORY[0x1E4F1F9F8];
                      *(void *)(a1 + 336) = v347;
                      unsigned int v222 = 1;
                      FigAtomicAdd32();
                      FigAtomicAdd32();
                      int v223 = *(_DWORD *)(v13 + 564);
                      *(_DWORD *)(v13 + 564) = v223 + 1;
                      if (v223 >= 10)
                      {
                        float v224 = (double)v215 / (double)*(int *)(v13 + 100) + *(float *)(v13 + 568);
                        *(float *)(v13 + 568) = v224;
                        double v225 = v224;
                        if (v225 >= v7)
                        {
                          float v226 = v225 + v8;
                          *(float *)(v13 + 568) = v226;
                        }
                        else
                        {
                          unsigned int v222 = 3;
                        }
                      }
                      if (v222 <= dword_1E9350B70)
                      {
                        LODWORD(presentationTimeStamp.CFDictionarySetValue(theDict, key, value) = 0;
                        LOBYTE(v390.CFDictionarySetValue(theDict, key, value) = 0;
                        v234 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                        unsigned int v235 = presentationTimeStamp.value;
                        if (os_log_type_enabled(v234, v390.value)) {
                          unsigned int v236 = v235;
                        }
                        else {
                          unsigned int v236 = v235 & 0xFFFFFFFE;
                        }
                        if (v236)
                        {
                          double v237 = v7;
                          double v238 = v8;
                          *(void *)timescaleb = *(void *)(v13 + 40);
                          int v357 = *(_DWORD *)(v13 + 564);
                          time1.duration.CMTimeValue value = v406;
                          time1.duration.CMTimeScale timescale = v407;
                          time1.duration.CMTimeFlags flags = v351;
                          time1.duration.CMTimeEpoch epoch = v341;
                          Float64 v239 = CMTimeGetSeconds(&time1.duration);
                          *(_OWORD *)&time1.duration.CMTimeValue value = *v302;
                          time1.duration.CMTimeEpoch epoch = *(void *)(v13 + 500);
                          Float64 v240 = CMTimeGetSeconds(&time1.duration);
                          if (v178) {
                            double v241 = *v178 / **(double **)(v13 + 64);
                          }
                          else {
                            double v241 = NAN;
                          }
                          int v242 = *(_DWORD *)(v13 + 100);
                          int v243 = *(_DWORD *)(v13 + 480);
                          if ((BYTE8(v382) & 2) != 0)
                          {
                            CMClockMakeHostTimeFromSystemUnits(&type, *(uint64_t *)&rhs[8]);
                            double v244 = CMTimeGetSeconds(&type);
                          }
                          else
                          {
                            double v244 = NAN;
                          }
                          *(_DWORD *)CMTime time2 = 136317954;
                          *(void *)&time2[4] = "subaq_enqueueAQBufferIntoAudioQueue";
                          *(_WORD *)&time2[12] = 2048;
                          *(void *)&time2[14] = a1;
                          *(_WORD *)&time2[22] = 2048;
                          *(void *)&time2[24] = v13;
                          *(_WORD *)v394 = 2048;
                          *(void *)&v394[2] = *(void *)timescaleb;
                          *(_WORD *)&v394[10] = 2082;
                          *(void *)&v394[12] = a1 + 776;
                          *(_WORD *)&v394[20] = 1024;
                          *(_DWORD *)v395 = v357;
                          *(_WORD *)&v395[4] = 2048;
                          *(Float64 *)&v395[6] = v239;
                          __int16 v396 = 2048;
                          Float64 v397 = v240;
                          __int16 v398 = 2048;
                          double v399 = (double)v215 / (double)v242;
                          __int16 v400 = 2048;
                          double v401 = (double)v243 / (double)v242;
                          __int16 v402 = 2048;
                          double v403 = v241;
                          __int16 v404 = 2048;
                          double v405 = v244;
                          _os_log_send_and_compose_impl();
                          double v8 = v238;
                          double v7 = v237;
                        }
                        char v15 = v359;
                        int v301 = 1;
                        fig_log_call_emit_and_clean_up_after_send_and_compose();
                        int v216 = 0;
                        a2 = v349;
                        uint64_t v6 = v361;
                        goto LABEL_532;
                      }
                      int v216 = 0;
                      int v301 = 1;
                      a2 = v349;
LABEL_531:
                      char v15 = v359;
LABEL_532:
                      int v227 = v331;
                      if (!packetDescriptionsPointerOut) {
                        int v227 = 0;
                      }
                      if (v227 == 1)
                      {
                        CFAllocatorRef v228 = CFGetAllocator((CFTypeRef)v13);
                        CFAllocatorDeallocate(v228, packetDescriptionsPointerOut);
                      }
                      uint64_t v229 = *(void *)&rhs[8];
                      double v230 = *(double *)rhs;
                      int v231 = DWORD2(v382);
                      if (v216)
                      {
                        int v231 = 0;
                        uint64_t v229 = 0;
                        double v230 = 0.0;
                      }
                      double v150 = v311;
                      v311[v149] = 0;
                      if (!v149) {
                        double v147 = v230;
                      }
                      uint64_t v232 = hostTime;
                      if (!v149) {
                        uint64_t v232 = v229;
                      }
                      uint64_t hostTime = v232;
                      int v233 = v337;
                      if (!v149) {
                        int v233 = v231;
                      }
                      int v337 = v233;
                      ++v149;
                      uint64_t v148 = counta;
                      if (v149 == counta)
                      {
                        uint64_t v5 = v300;
                        uint64_t v9 = v293;
                        double v245 = 0.5;
                        goto LABEL_568;
                      }
                      continue;
                    }
                  }
                  uint64_t hostTime = 0;
                  LOBYTE(v337) = 0;
                  int v301 = 0;
                  double v245 = 0.5;
                  double v150 = v311;
LABEL_568:
                  v312 = v150;
                  v248 = (AudioQueueBuffer **)v150;
                  v249 = v297;
                  if (v148 >= 1)
                  {
                    do
                    {
                      if (*v248)
                      {
                        v250 = v15;
                        uint64_t v251 = a2;
                        uint64_t v252 = v5;
                        uint64_t v253 = v6;
                        uint64_t v254 = v148;
                        subaq_returnAQBufferInfoPtr(v13, (uint64_t)(*v248)->mUserData);
                        if (*v249)
                        {
                          FigAudioQueueTimingShimFreeBuffer(*(void *)(v13 + 40), *v248);
                        }
                        else
                        {
                          v255 = *v248;
                          v255->mAudioDataByteSize = 0;
                          v255->mUserCFDataRef Data = 0;
                        }
                        uint64_t v148 = v254;
                        uint64_t v6 = v253;
                        uint64_t v5 = v252;
                        a2 = v251;
                        char v15 = v250;
                      }
                      ++v249;
                      ++v248;
                      --v148;
                    }
                    while (v148);
                  }
                  v256 = *(const void **)(a1 + 120);
                  if (v256)
                  {
                    uint64_t v257 = *(void *)(a1 + 112);
                    uint64_t v258 = CountOfSequentialSamplesWithSeamIdentifier >= v257
                         ? *(void *)(a1 + 112)
                         : CountOfSequentialSamplesWithSeamIdentifier;
                    *(void *)(a1 + 112) = v257 - v258;
                    if (v257 <= CountOfSequentialSamplesWithSeamIdentifier)
                    {
                      CFRelease(v256);
                      *(void *)(a1 + 120) = 0;
                    }
                  }
                  uint64_t v4 = v340;
                  if (cf) {
                    CFRelease(cf);
                  }
                  if (theArray) {
                    CFRelease(theArray);
                  }
                  free(v312);
                  free(v297);
                  if (v296 && !*(unsigned char *)(a1 + 577)) {
                    subaq_flushAudioQueue(a1, v13);
                  }
                  if (*(unsigned char *)(a1 + 196))
                  {
                    int32_t v259 = *(_DWORD *)(v13 + 100);
                    long long v358 = *MEMORY[0x1E4F1F9F8];
                    *(_OWORD *)CMTime lhs = *MEMORY[0x1E4F1F9F8];
                    *(void *)&lhs[16] = v347;
                    if ((v337 & 2) != 0)
                    {
                      CMClockMakeHostTimeFromSystemUnits((CMTime *)lhs, hostTime);
                      memset(rhs, 0, 24);
                      CMClockRef HostTimeClock = CMClockGetHostTimeClock();
                      CMClockGetTime((CMTime *)rhs, HostTimeClock);
                      if (dword_1E9350B70)
                      {
                        LODWORD(presentationTimeStamp.CFDictionarySetValue(theDict, key, value) = 0;
                        LOBYTE(v390.CFDictionarySetValue(theDict, key, value) = 0;
                        v264 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                        unsigned int v265 = presentationTimeStamp.value;
                        if (os_log_type_enabled(v264, v390.value)) {
                          unsigned int v266 = v265;
                        }
                        else {
                          unsigned int v266 = v265 & 0xFFFFFFFE;
                        }
                        if (v266)
                        {
                          *(_OWORD *)&time1.duration.CMTimeValue value = *(_OWORD *)lhs;
                          time1.duration.CMTimeEpoch epoch = *(void *)&lhs[16];
                          Float64 v267 = CMTimeGetSeconds(&time1.duration);
                          *(_OWORD *)&time1.duration.CMTimeValue value = *(_OWORD *)rhs;
                          time1.duration.CMTimeEpoch epoch = *(void *)&rhs[16];
                          Float64 v268 = CMTimeGetSeconds(&time1.duration);
                          *(_OWORD *)&time1.duration.CMTimeValue value = *(_OWORD *)lhs;
                          time1.duration.CMTimeEpoch epoch = *(void *)&lhs[16];
                          char v15 = v359;
                          *(_OWORD *)CMTime time2 = *(_OWORD *)rhs;
                          *(void *)&time2[16] = *(void *)&rhs[16];
                          CMTimeSubtract(&type, &time1.duration, (CMTime *)time2);
                          Float64 v269 = CMTimeGetSeconds(&type);
                          *(_DWORD *)CMTime time2 = 136316162;
                          *(void *)&time2[4] = "faq_processTransitions";
                          *(_WORD *)&time2[12] = 2048;
                          *(void *)&time2[14] = a1;
                          *(_WORD *)&time2[22] = 2048;
                          *(Float64 *)&time2[24] = v267;
                          *(_WORD *)v394 = 2048;
                          *(Float64 *)&v394[2] = v268;
                          *(_WORD *)&v394[10] = 2048;
                          *(Float64 *)&v394[12] = v269;
                          _os_log_send_and_compose_impl();
                        }
                        fig_log_call_emit_and_clean_up_after_send_and_compose();
                        LODWORD(v5) = v300;
                        a2 = v349;
                      }
                      char v271 = v337;
                    }
                    else
                    {
                      *(_DWORD *)CMTime rhs = 0;
                      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
                      v260 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                      unsigned int v261 = *(_DWORD *)rhs;
                      if (os_log_type_enabled(v260, type.value)) {
                        unsigned int v262 = v261;
                      }
                      else {
                        unsigned int v262 = v261 & 0xFFFFFFFE;
                      }
                      if (v262)
                      {
                        *(_DWORD *)CMTime time2 = 136315394;
                        *(void *)&time2[4] = "faq_processTransitions";
                        *(_WORD *)&time2[12] = 2048;
                        *(void *)&time2[14] = a1;
                        _os_log_send_and_compose_impl();
                      }
                      fig_log_call_emit_and_clean_up_after_send_and_compose();
                      v270 = CMClockGetHostTimeClock();
                      CMClockGetTime((CMTime *)lhs, v270);
                      char v271 = v337;
                    }
                    if (v271)
                    {
                      v275 = (long long *)rhs;
                      CMTimeMake((CMTime *)rhs, (uint64_t)(v147 + v245), v259);
                    }
                    else
                    {
                      *(_DWORD *)CMTime rhs = 0;
                      LOBYTE(presentationTimeStamp.CFDictionarySetValue(theDict, key, value) = 0;
                      v272 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                      unsigned int v273 = *(_DWORD *)rhs;
                      if (os_log_type_enabled(v272, presentationTimeStamp.value)) {
                        unsigned int v274 = v273;
                      }
                      else {
                        unsigned int v274 = v273 & 0xFFFFFFFE;
                      }
                      if (v274)
                      {
                        *(_DWORD *)CMTime time2 = 136315394;
                        *(void *)&time2[4] = "faq_processTransitions";
                        *(_WORD *)&time2[12] = 2048;
                        *(void *)&time2[14] = a1;
                        _os_log_send_and_compose_impl();
                      }
                      fig_log_call_emit_and_clean_up_after_send_and_compose();
                      v275 = (long long *)MEMORY[0x1E4F1FA48];
                    }
                    faqTimelineWrangler_setAQTimeInFAQProcessTransitions(v327, v275);
                    v276 = (unsigned char *)(a1 + 184);
                    while (1)
                    {
                      v276 = *(unsigned char **)v276;
                      if (!v276) {
                        break;
                      }
                      if (v276[88])
                      {
                        if (*(unsigned char *)(a1 + 16)) {
                          v277 = 0;
                        }
                        else {
                          v277 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0);
                        }
                        v278 = (void *)(a1 + 184);
                        for (CFIndex i = (void *)*v348; i != (void *)v276; CFIndex i = (void *)*i)
                          v278 = i;
                        void *v278 = *(void *)v276;
                        --*(_DWORD *)(a1 + 192);
                        long long v280 = *(_OWORD *)(v276 + 24);
                        *(void *)(a1 + 568) = *((void *)v276 + 5);
                        _OWORD *v345 = v280;
                        if (dword_1E9350B70)
                        {
                          LODWORD(presentationTimeStamp.CFDictionarySetValue(theDict, key, value) = 0;
                          LOBYTE(v390.CFDictionarySetValue(theDict, key, value) = 0;
                          v281 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                          unsigned int v282 = presentationTimeStamp.value;
                          if (os_log_type_enabled(v281, v390.value)) {
                            unsigned int v283 = v282;
                          }
                          else {
                            unsigned int v283 = v282 & 0xFFFFFFFE;
                          }
                          if (v283)
                          {
                            *(_OWORD *)&time1.duration.CMTimeValue value = *v345;
                            time1.duration.CMTimeEpoch epoch = *(void *)(a1 + 568);
                            Float64 v284 = CMTimeGetSeconds(&time1.duration);
                            *(_DWORD *)CMTime time2 = 136315906;
                            *(void *)&time2[4] = "faq_processTransitions";
                            *(_WORD *)&time2[12] = 2048;
                            *(void *)&time2[14] = a1;
                            *(_WORD *)&time2[22] = 2048;
                            *(void *)&time2[24] = a1 + 424;
                            *(_WORD *)v394 = 2048;
                            *(Float64 *)&v394[2] = v284;
                            _os_log_send_and_compose_impl();
                          }
                          fig_log_call_emit_and_clean_up_after_send_and_compose();
                          a2 = v349;
                          char v15 = v359;
                        }
                        long long v285 = *(_OWORD *)(v276 + 24);
                        *(void *)(a1 + 544) = *((void *)v276 + 5);
                        _OWORD *v343 = v285;
                        _OWORD *v342 = v358;
                        *(void *)(a1 + 496) = v347;
                        if (v277) {
                          subaq_setTapTimelineInfo(a1, (uint64_t)v277);
                        }
                        *((_OWORD *)v276 + 3) = *(_OWORD *)lhs;
                        *((void *)v276 + 8) = *(void *)&lhs[16];
                        *((_DWORD *)v276 + 18) = *(_DWORD *)(a1 + 416);
                        dispatch_async_f(*(dispatch_queue_t *)(a1 + 32), v276, (dispatch_function_t)faq_fireTransitionCallback);
                        v276 = (unsigned char *)(a1 + 184);
                        uint64_t v6 = v361;
                      }
                    }
                    *(unsigned char *)(a1 + 196) = 0;
                    uint64_t v4 = v340;
                  }
                  if (*(_DWORD *)(*(void *)(v13 + 64) + 8) == 1819304813)
                  {
                    memset(&time1, 0, 24);
                    CMSampleBufferGetOutputDuration(&time1.duration, v15);
                    double v10 = 1.0;
                    float v11 = 1.0;
                    int v23 = v301;
                    if (*(unsigned char *)(a1 + 356)) {
                      goto LABEL_638;
                    }
                    *(_OWORD *)CMTime time2 = *(_OWORD *)&time1.duration.value;
                    *(void *)&time2[16] = time1.duration.epoch;
                    *(_OWORD *)CMTime lhs = v360;
                    *(void *)&lhs[16] = v362;
                    if (CMTimeCompare((CMTime *)time2, (CMTime *)lhs) >= 1)
                    {
                      CMTimeMake(&v364, 100, 1000);
                      *(_OWORD *)CMTime time2 = *(_OWORD *)&time1.duration.value;
                      *(void *)&time2[16] = time1.duration.epoch;
                      if (CMTimeCompare((CMTime *)time2, &v364) < 0)
                      {
                        *(unsigned char *)(a1 + 356) = 1;
                        _OWORD *v322 = *(_OWORD *)&time1.duration.value;
                        *(void *)(a1 + 376) = time1.duration.epoch;
                        goto LABEL_77;
                      }
                    }
                    if (*(unsigned char *)(a1 + 356))
                    {
LABEL_638:
                      *(_OWORD *)CMTime time2 = *(_OWORD *)&time1.duration.value;
                      *(void *)&time2[16] = time1.duration.epoch;
                      *(_OWORD *)CMTime lhs = v360;
                      *(void *)&lhs[16] = v362;
                      if (CMTimeCompare((CMTime *)time2, (CMTime *)lhs) >= 1)
                      {
                        *(_OWORD *)CMTime lhs = *v322;
                        *(void *)&lhs[16] = *(void *)(a1 + 376);
                        *(_OWORD *)CMTime rhs = *(_OWORD *)&time1.duration.value;
                        *(void *)&rhs[16] = time1.duration.epoch;
                        CMTimeAdd((CMTime *)time2, (CMTime *)lhs, (CMTime *)rhs);
                        _OWORD *v322 = *(_OWORD *)time2;
                        *(void *)(a1 + 376) = *(void *)&time2[16];
                        CMTimeMake(&v363, 200, 1000);
                        *(_OWORD *)CMTime time2 = *v322;
                        int v23 = v301;
                        *(void *)&time2[16] = *(void *)(a1 + 376);
                        if (CMTimeCompare((CMTime *)time2, &v363) >= 1)
                        {
                          *(unsigned char *)(a1 + 356) = 0;
                          _OWORD *v322 = v360;
                          *(void *)(a1 + 376) = v362;
                        }
                      }
                    }
                  }
                  else
                  {
                    double v10 = 1.0;
                    float v11 = 1.0;
                    int v23 = v301;
                    if (*(unsigned char *)(a1 + 356))
                    {
                      int v45 = 0;
                      *(unsigned char *)(a1 + 356) = 0;
                      _OWORD *v322 = v360;
                      *(void *)(a1 + 376) = v362;
                      goto LABEL_78;
                    }
                  }
LABEL_77:
                  int v45 = 0;
                  goto LABEL_78;
                }
              }
            }
            char v116 = *(unsigned char *)(v13 + 544);
            if (v116)
            {
              int v117 = AudioSampleBufferSplitterCreateSplitSampleBufferArray(*(void *)(a1 + 168), v115, &v372, &theArray);
              if (v117)
              {
                char v116 = 1;
              }
              else
              {
                CFIndex v119 = (CFIndex)theArray;
                if (theArray) {
                  CFIndex v119 = CFArrayGetCount(theArray);
                }
                char v116 = v119 == 0;
              }
              char v120 = v372;
              if (v372)
              {
                *(unsigned char *)(v13 + 544) = 0;
                int v118 = 1;
              }
              else
              {
                int v118 = 0;
              }
              if ((v120 & 2) != 0)
              {
                *(unsigned char *)(v13 + 544) = 0;
                goto LABEL_319;
              }
            }
            else
            {
              int v118 = 0;
              int v117 = 0;
            }
            if (v113 && (v116 & 1) == 0 && !v118) {
              goto LABEL_317;
            }
LABEL_319:
            if (theArray) {
              CFRelease(theArray);
            }
            CFArrayRef v121 = CFArrayCreate(allocator, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
            int v117 = 0;
            CFArrayRef theArray = v121;
            goto LABEL_322;
          }
          faq_clearSeamHandlingState((__n128 *)a1);
        }
        else
        {
          uint64_t CountOfSequentialSamplesWithSeamIdentifier = 0;
        }
        CFRange v115 = v15;
        goto LABEL_301;
      }
      if ((~*(_DWORD *)rhs & 5) == 0)
      {
        if ((rhs[0] & 2) == 0)
        {
          time1.duration.CMTimeValue value = 0;
          MagicCookie = CMAudioFormatDescriptionGetMagicCookie(v69, (size_t *)&time1);
          subaq_flushAudioQueue(a1, v13);
          FigAudioQueueTimingShimSetProperty(*(void *)(v13 + 40), 0x61716D63u, MagicCookie, time1.duration.value);
          subaq_setupForDecode(v13, v69);
        }
        goto LABEL_158;
      }
      *(void *)CMTime lhs = 0;
      LODWORD(type.CFDictionarySetValue(theDict, key, value) = 8;
      if (*(unsigned char *)(a1 + 72) == 1 && (subaq_doesAudioQueueHaveBuffersToFlush(v13) || *(int *)(v13 + 612) >= 1)) {
        BOOL v74 = (*(unsigned char *)(a1 + 48) & 2) == 0 || *(unsigned char *)(a1 + 306) == 0;
      }
      else {
        BOOL v74 = 0;
      }
      if (FigAudioQueueTimingShimGetProperty(*(void *)(v13 + 40), 0x61716364u, lhs, (UInt32 *)&type)) {
        *(void *)CMTime lhs = 0;
      }
      uint64_t v90 = *(void *)(v13 + 592);
      if (v90)
      {
        uint64_t v91 = v5;
        if (*(unsigned char *)(v13 + 48))
        {
          int v92 = 1;
          FigAudioQueueTimingShimStop(*(void *)(v13 + 40), 1u);
          *(unsigned char *)(v13 + 48) = 0;
        }
        else
        {
          int v92 = 0;
        }
        subaq_setProperty(a1, v13, @"AudioProcessingTap", 0);
      }
      else
      {
        uint64_t v91 = v5;
        int v92 = 0;
      }
      *(_OWORD *)&time1.duration.CMTimeValue value = *v316;
      time1.duration.CMTimeEpoch epoch = *(void *)(a1 + 472);
      *(void *)CMTime time2 = 0;
      int v93 = FigSubAudioQueueCreate((CFTypeRef)a1);
      uint64_t v95 = *(void *)time2;
      if (v93)
      {
        uint64_t v98 = 0;
        if (!*(void *)time2) {
          goto LABEL_235;
        }
        goto LABEL_234;
      }
      if (*(unsigned char *)(a1 + 16))
      {
        *(unsigned char *)(*(void *)time2 + 546) = 1;
        *(void *)(v95 + 552) = 0;
      }
      else
      {
        CFDictionaryRef v96 = *(const __CFDictionary **)(a1 + 240);
        if (v96)
        {
          time1.duration.CMTimeEpoch epoch = 1;
          time1.duration.CMTimeValue value = a1;
          *(void *)&time1.duration.CMTimeScale timescale = *(void *)time2;
          CFDictionaryApplyFunction(v96, (CFDictionaryApplierFunction)subaq_applyOneCachedProperty, &time1);
        }
        if (*(unsigned char *)(a1 + 236)) {
          FigAudioQueueTimingShimSetParameter(*(void *)(v95 + 40), 2u, *(AudioQueueParameterValue *)(a1 + 232));
        }
        if (*(unsigned char *)(a1 + 204)) {
          FigAudioQueueTimingShimSetParameter(*(void *)(v95 + 40), 1u, *(AudioQueueParameterValue *)(a1 + 200));
        }
        if (*(unsigned char *)(a1 + 212)) {
          FigAudioQueueTimingShimSetParameter(*(void *)(v95 + 40), 5u, *(AudioQueueParameterValue *)(a1 + 208));
        }
        if (*(unsigned char *)(a1 + 220)) {
          FigAudioQueueTimingShimSetParameter(*(void *)(v95 + 40), 9u, *(AudioQueueParameterValue *)(a1 + 216));
        }
        if (*(unsigned char *)(a1 + 228)) {
          FigAudioQueueTimingShimSetParameter(*(void *)(v95 + 40), 0xEu, *(AudioQueueParameterValue *)(a1 + 224));
        }
        if (*(unsigned char *)(a1 + 716)) {
          FigAudioQueueTimingShimSetParameter(*(void *)(v95 + 40), 0x16u, *(AudioQueueParameterValue *)(a1 + 712));
        }
        int v97 = *(unsigned __int8 *)(a1 + 16);
        *(unsigned char *)(v95 + 546) = 1;
        uint64_t v98 = v95;
        *(void *)(v95 + 552) = 0;
        if (v97) {
          goto LABEL_234;
        }
        CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 176), 0, (const void *)v95);
      }
      uint64_t v98 = v95;
LABEL_234:
      CFRelease((CFTypeRef)v95);
LABEL_235:
      if (*(void *)lhs) {
        CFRelease(*(CFTypeRef *)lhs);
      }
      if (!v98)
      {
        uint64_t v5 = v91;
        a2 = v349;
        uint64_t v6 = v361;
        char v15 = v359;
        goto LABEL_158;
      }
      if (v90)
      {
        *(unsigned char *)(a1 + 744) = 0;
        subaq_setProperty(a1, v98, @"AudioProcessingTap", *(const __CFString **)(a1 + 736));
        uint64_t v99 = *(void *)(v98 + 592);
        if (v99)
        {
          uint64_t v100 = *(void *)(v98 + 600);
          uint64_t v101 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v102 = v101 ? v101 : 0;
          unsigned int v103 = *(void (**)(uint64_t, uint64_t))(v102 + 8);
          if (v103) {
            v103(v99, v100);
          }
        }
        if (v92) {
          FigAudioQueueTimingShimStart(*(void *)(v13 + 40), 0, 0);
        }
      }
      if (v74)
      {
        *(unsigned char *)(v98 + 641) = 1;
        subaq_flushAudioQueue(a1, v13);
        *(unsigned char *)(v13 + 640) = 1;
        LODWORD(v5) = v91;
        a2 = v349;
        uint64_t v4 = v340;
        char v15 = v359;
      }
      else
      {
        LODWORD(v5) = v91;
        a2 = v349;
        uint64_t v4 = v340;
        char v15 = v359;
        if (*(unsigned char *)(a1 + 73) || (*(unsigned char *)(a1 + 48) & 2) != 0)
        {
          subaq_startSlavedAudioQueue(a1, v98);
          subaq_stopAudioQueue(a1, v13, 0);
        }
      }
      uint64_t v6 = v361;
      if (!*(unsigned char *)(a1 + 578))
      {
        int v45 = 0;
        int v22 = 1;
        int v23 = 1;
        goto LABEL_78;
      }
      if (*(unsigned char *)(v13 + 496)) {
        faq_reset(a1, v94);
      }
      int v45 = 0;
      int v22 = 1;
LABEL_116:
      int v23 = 1;
      goto LABEL_78;
    }
    CFTypeRef v63 = v61;
    while (v63 != (CFTypeRef)v62[10])
    {
LABEL_142:
      uint64_t v62 = (void *)*v62;
      if (!v62) {
        goto LABEL_143;
      }
    }
    if (!*(unsigned char *)(a1 + 576) && *(unsigned char *)(a1 + 649))
    {
      *((unsigned char *)v62 + 88) = 1;
      *(unsigned char *)(a1 + 196) = 1;
      if (*(unsigned char *)(a1 + 140))
      {
        *(_OWORD *)&time1.duration.CMTimeValue value = *v326;
        time1.duration.CMTimeEpoch epoch = *(void *)(a1 + 144);
        *(_OWORD *)CMTime time2 = v360;
        *(void *)&time2[16] = v362;
        if (CMTimeCompare(&time1.duration, (CMTime *)time2) >= 1)
        {
          *(_OWORD *)CMTime time2 = *(_OWORD *)(v62 + 3);
          *(void *)&time2[16] = v62[5];
          *(_OWORD *)CMTime lhs = *v326;
          *(void *)&lhs[16] = *(void *)(a1 + 144);
          CMTimeSubtract(&time1.duration, (CMTime *)time2, (CMTime *)lhs);
          *(_OWORD *)(v62 + 3) = *(_OWORD *)&time1.duration.value;
          v62[5] = time1.duration.epoch;
          _OWORD *v326 = v360;
          *(void *)(a1 + 144) = v362;
          char v15 = v359;
        }
      }
      long long v64 = *(_OWORD *)(v62 + 3);
      *(void *)(a1 + 568) = v62[5];
      _OWORD *v345 = v64;
      long long v65 = *(_OWORD *)(v62 + 3);
      *(void *)(a1 + 544) = v62[5];
      _OWORD *v343 = v65;
      _OWORD *v342 = *MEMORY[0x1E4F1F9F8];
      *(void *)(a1 + 496) = v347;
      goto LABEL_142;
    }
    int v22 = 0;
    int v23 = 0;
    int v45 = 0;
LABEL_178:
    uint64_t v4 = v340;
LABEL_78:
    if (!*(unsigned char *)(a1 + 16))
    {
      if (v15) {
        CFRelease(v15);
      }
      if (!v22)
      {
        int v22 = 0;
        if (!*(unsigned char *)(a1 + 16))
        {
          *(unsigned char *)(a1 + 356) = 0;
          _OWORD *v322 = *MEMORY[0x1E4F1FA48];
          *(void *)(a1 + 376) = v362;
        }
      }
    }
    if (v23) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v5;
    }
    if (v45) {
      uint64_t v4 = 1;
    }
  }
  while (v22);
  uint64_t result = MEMORY[0x19970E2B0](*(void *)(a1 + 24));
  if (v4)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    uint64_t result = CMNotificationCenterPostNotification();
  }
  if (*(void *)(a1 + 720))
  {
    if ((_BYTE)v5)
    {
      CMNotificationCenterGetDefaultLocalCenter();
      return CMNotificationCenterPostNotification();
    }
  }
  return result;
}

uint64_t figAudioQueueStartCommon(uint64_t a1, CMTime *a2, CMTime *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, float a9)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (a1 && (a2->flags & 0x1D) == 1)
  {
    MEMORY[0x19970E290](*(void *)(a1 + 24));
    if (*(unsigned char *)(a1 + 16)
      || (*(unsigned char *)(a1 + 48) & 2) != 0
      || a4 && *(void *)(a1 + 400)
      || a6 && *(void *)(a1 + 384))
    {
      goto LABEL_67;
    }
    uint64_t v46 = a5;
    if (((*(_DWORD *)(a1 + 540) & 0x1D) != 1) | a8)
    {
      if (dword_1E9350B70) {
        goto LABEL_13;
      }
    }
    else if (dword_1E9350B70)
    {
LABEL_13:
      LODWORD(v58.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (!*(unsigned char *)(a1 + 16))
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176));
      if (Count >= 1)
      {
        CFIndex v20 = Count;
        for (CFIndex i = 0; i != v20; ++i)
          *((unsigned char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), i) + 560) = 0;
      }
      if (!*(unsigned char *)(a1 + 16))
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0);
        if (ValueAtIndex)
        {
          uint64_t v23 = (uint64_t)ValueAtIndex;
          if (*((void *)ValueAtIndex + 5))
          {
            ValueAtIndex[560] = 1;
            if (a4)
            {
              *(void *)(a1 + 384) = a4;
              *(void *)(a1 + 392) = v46;
              *(float *)(a1 + 416) = a9;
              *(unsigned char *)(a1 + 576) = 1;
            }
            if (a6)
            {
              *(void *)(a1 + 400) = a6;
              float v24 = *(const void **)(a1 + 408);
              if (v24)
              {
                CFRelease(v24);
                *(void *)(a1 + 408) = 0;
              }
              if (a7) {
                *(void *)(a1 + 408) = FigCFWeakReferenceHolderCreateWithReferencedObject();
              }
              *(float *)(a1 + 416) = a9;
              *(unsigned char *)(a1 + 576) = 1;
            }
            CMTime time1 = *a2;
            int v25 = *(_DWORD *)(a1 + 540) & 0x1D;
            BOOL v26 = v25 == 1;
            BOOL v27 = v25 != 1;
            if (!v26)
            {
              long long v28 = *(_OWORD *)&a2->value;
              *(void *)(a1 + 568) = a2->epoch;
              *(_OWORD *)(a1 + 552) = v28;
            }
            unsigned int v29 = (CMTime *)MEMORY[0x1E4F1F9F8];
            if (v27 | a8)
            {
              *(CMTime *)(a1 + 528) = time1;
              *(_OWORD *)(a1 + 480) = *(_OWORD *)&v29->value;
              *(void *)(a1 + 496) = v29->epoch;
              *(unsigned char *)(v23 + 546) = 1;
              *(void *)(v23 + 552) = 0;
            }
            *(_OWORD *)(a1 + 616) = 0u;
            *(_OWORD *)(a1 + 632) = 0u;
            *(_OWORD *)(a1 + 584) = 0u;
            *(_OWORD *)(a1 + 600) = 0u;
            CMTime time1 = *a2;
            long long v47 = *MEMORY[0x1E4F1FA48];
            *(_OWORD *)&time2.unsigned int value = *MEMORY[0x1E4F1FA48];
            CMTimeEpoch v30 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
            time2.CMTimeEpoch epoch = v30;
            BOOL v31 = CMTimeCompare(&time1, &time2) == 0;
            if ((a3->flags & 0x1D) == 1)
            {
              memset(&v49, 0, sizeof(v49));
              *(_OWORD *)&v48.unsigned int value = *(_OWORD *)&a2->value;
              v48.CMTimeEpoch epoch = a2->epoch;
              CMTime time1 = *v29;
              *(_OWORD *)&time2.unsigned int value = v47;
              time2.CMTimeEpoch epoch = v30;
              subaq_getAudioQueueLatencyFigTime(a1, v23, &time1);
              if ((time1.flags & 1) == 0)
              {
                *(_OWORD *)&time1.unsigned int value = v47;
                time1.CMTimeEpoch epoch = v30;
              }
              if (*(unsigned char *)(v23 + 48))
              {
                subaq_getCurrentQueueTime(v23, &v58);
                CMTime type = *(CMTime *)(a1 + 456);
                CMTime rhs = *(CMTime *)(a1 + 504);
                CMTimeSubtract(&v52, &type, &rhs);
                CMTime rhs = v58;
                CMTimeSubtract(&type, &rhs, &v52);
                int v32 = *(CMTime **)(v23 + 40);
                CMTime v55 = type;
                FigAudioQueueTimingShimConvertTimingShimTimeToAQTime(v32, &v55, &rhs);
                CMTime lhs = v48;
                CMTime v53 = *(CMTime *)(a1 + 552);
                CMTimeSubtract(&v55, &lhs, &v53);
                CMTime v53 = v55;
                CMTime v51 = *(CMTime *)(a1 + 504);
                CMTimeAdd(&lhs, &v53, &v51);
                int v33 = *(CMTime **)(v23 + 40);
                CMTime v51 = lhs;
                FigAudioQueueTimingShimConvertTimingShimTimeToAQTime(v33, &v51, &v53);
                CMTime v51 = rhs;
                CMTime v50 = v53;
                CMTimeSubtract(&time2, &v51, &v50);
              }
              CMTime v58 = time2;
              CMTime type = time1;
              CMTimeSubtract(&v49, &v58, &type);
              CMTime time2 = *a3;
              CMTime v58 = v49;
              CMTimeAdd(&time1, &time2, &v58);
              *(_OWORD *)&a3->unsigned int value = *(_OWORD *)&time1.value;
              CMTimeEpoch epoch = time1.epoch;
              a3->CMTimeEpoch epoch = time1.epoch;
              *(_OWORD *)&time1.unsigned int value = *(_OWORD *)&a3->value;
              time1.CMTimeEpoch epoch = epoch;
              *(void *)(a1 + 592) = CMClockConvertHostTimeToSystemUnits(&time1);
              *(_DWORD *)(a1 + 640) = 2;
              char v35 = 1;
            }
            else
            {
              char v35 = 0;
            }
            *(unsigned char *)(a1 + 305) = 1;
            BOOL v36 = (*(unsigned char *)(a1 + 48) & 4) != 0 && *(unsigned char *)(a1 + 312) && *(float *)(a1 + 280) != 1.0;
            faq_enqueueSourceData(a1, v36);
            if (*(unsigned char *)(a1 + 16)) {
              uint64_t v37 = 0;
            }
            else {
              uint64_t v37 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0);
            }
            v37[560] = 1;
            if (dword_1E9350B70)
            {
              LODWORD(v58.CFDictionarySetValue(theDict, key, value) = 0;
              LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
              unint64_t v38 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              unsigned int value = v58.value;
              if (os_log_type_enabled(v38, type.value)) {
                unsigned int v40 = value;
              }
              else {
                unsigned int v40 = value & 0xFFFFFFFE;
              }
              if (v40)
              {
                uint64_t v41 = *((void *)v37 + 5);
                CMTime time1 = *a3;
                Float64 Seconds = CMTimeGetSeconds(&time1);
                LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316162;
                *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"figAudioQueueStartCommon";
                LOWORD(time2.flags) = 2048;
                *(void *)((char *)&time2.flags + 2) = a1;
                HIWORD(time2.epoch) = 2048;
                uint64_t v60 = v37;
                __int16 v61 = 2048;
                uint64_t v62 = v41;
                __int16 v63 = 2048;
                Float64 v64 = Seconds;
                _os_log_send_and_compose_impl();
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
            *(unsigned char *)(a1 + 745) = 1;
            if (!*(unsigned char *)(a1 + 16))
            {
              if (*((void *)v37 + 75))
              {
                uint64_t started = subaq_setTapTimelineInfo(a1, (uint64_t)v37);
                if (started) {
                  goto LABEL_68;
                }
                v37[609] = 1;
              }
              *(unsigned char *)(a1 + 580) = v35;
              *(unsigned char *)(a1 + 581) = v31;
            }
            uint64_t started = subaq_startAudioQueueIfReady(a1, (uint64_t)v37);
            if (!started)
            {
              if (*(unsigned char *)(a1 + 578) || *(unsigned char *)(a1 + 579))
              {
                if (v37[50]) {
                  subaq_startListener(a1, (uint64_t)v37);
                }
                *(_WORD *)(a1 + 578) = 0;
              }
              *(unsigned char *)(a1 + 761) = 0;
              *(unsigned char *)(a1 + 649) = 1;
              FigSemaphoreSignal();
              uint64_t v44 = 0;
              goto LABEL_66;
            }
LABEL_68:
            uint64_t v44 = started;
LABEL_66:
            MEMORY[0x19970E2B0](*(void *)(a1 + 24));
            return v44;
          }
        }
      }
    }
LABEL_67:
    uint64_t started = FigSignalErrorAt();
    goto LABEL_68;
  }

  return FigSignalErrorAt();
}

uint64_t FigAudioQueueStart2(uint64_t a1, CMTime *a2, CMTime *a3, uint64_t a4, uint64_t a5, int a6, float a7)
{
  CMTime v9 = *a2;
  CMTime v8 = *a3;
  return figAudioQueueStartCommon(a1, &v9, &v8, 0, 0, a4, a5, a6, a7);
}

uint64_t FigAudioQueueStartOffline(uint64_t a1, long long *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    MEMORY[0x19970E290](*(void *)(a1 + 24));
    if (dword_1E9350B70)
    {
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (*(unsigned char *)(a1 + 16) || (*(unsigned char *)(a1 + 48) & 2) == 0)
    {
      uint64_t started = FigSignalErrorAt();
    }
    else
    {
      long long v5 = *a2;
      *(void *)(a1 + 544) = *((void *)a2 + 2);
      *(_OWORD *)(a1 + 528) = v5;
      uint64_t v6 = MEMORY[0x1E4F1F9F8];
      *(_OWORD *)(a1 + 480) = *MEMORY[0x1E4F1F9F8];
      *(void *)(a1 + 496) = *(void *)(v6 + 16);
      uint64_t v7 = MEMORY[0x1E4F1FA48];
      *(_OWORD *)(a1 + 456) = *MEMORY[0x1E4F1FA48];
      *(void *)(a1 + 472) = *(void *)(v7 + 16);
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176));
      if (Count >= 1)
      {
        CFIndex v9 = Count;
        for (CFIndex i = 0; i != v9; ++i)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), i);
          ValueAtIndex[546] = 1;
          *((void *)ValueAtIndex + 69) = 0;
        }
      }
      *(void *)(a1 + 584) = 0;
      *(_DWORD *)(a1 + 640) = 1;
      *(unsigned char *)(a1 + 576) = 1;
      *(unsigned char *)(a1 + 305) = 1;
      faq_enqueueSourceData(a1, 0);
      *(unsigned char *)(a1 + 745) = 1;
      if (*(unsigned char *)(a1 + 16) || (CFIndex v12 = CFArrayGetCount(*(CFArrayRef *)(a1 + 176)), v12 < 1))
      {
LABEL_25:
        uint64_t v18 = 0;
        *(unsigned char *)(a1 + 649) = 1;
LABEL_26:
        MEMORY[0x19970E2B0](*(void *)(a1 + 24));
        return v18;
      }
      CFIndex v13 = v12;
      CFIndex v14 = 0;
      while (1)
      {
        if (*(unsigned char *)(a1 + 16)) {
          char v15 = 0;
        }
        else {
          char v15 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), v14);
        }
        if (dword_1E9350B70)
        {
          float v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        if (!*(unsigned char *)(a1 + 16))
        {
          if (*((void *)v15 + 75))
          {
            uint64_t started = subaq_setTapTimelineInfo(a1, (uint64_t)v15);
            if (started) {
              break;
            }
            v15[609] = 1;
          }
          *(_WORD *)(a1 + 580) = 1;
        }
        uint64_t started = subaq_startAudioQueueIfReady(a1, (uint64_t)v15);
        if (started) {
          break;
        }
        if (v13 == ++v14) {
          goto LABEL_25;
        }
      }
    }
    uint64_t v18 = started;
    goto LABEL_26;
  }

  return FigSignalErrorAt();
}

uint64_t subaq_startAudioQueueIfReady(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (!a1 || *(unsigned char *)(a1 + 16)) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 48);
  if (*(void *)(a2 + 600))
  {
    if (!*(unsigned char *)(a1 + 745) || !*(unsigned char *)(a2 + 609) || !*(unsigned char *)(a1 + 744) || !*(unsigned char *)(a2 + 608)) {
      return 0;
    }
    *(unsigned char *)(a2 + 609) = 0;
  }
  long long v31 = 0u;
  memset(v30, 0, sizeof(v30));
  memset(&v29, 0, sizeof(v29));
  faqTimelineWrangler_getAQTimePauseOffset(a1 + 424, &v29);
  int v5 = *(_DWORD *)(a1 + 48);
  if (!*(unsigned char *)(a1 + 580))
  {
    if ((v5 & 2) == 0 && !*(unsigned char *)(a2 + 49))
    {
      CMTime time1 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      CMTime time2 = v29;
      if (CMTimeCompare(&time1, &time2))
      {
        memset(&v28, 0, sizeof(v28));
        CMClockRef HostTimeClock = CMClockGetHostTimeClock();
        CMClockGetTime(&v28, HostTimeClock);
        memset(&type, 0, sizeof(type));
        CMTimeMake(&rhs, 1, 10);
        CMTime time1 = v28;
        CMTimeAdd(&type, &time1, &rhs);
        memset(&v25, 0, sizeof(v25));
        CMTime time1 = type;
        CMTime time2 = v29;
        CMTimeSubtract(&v25, &time1, &time2);
        CMTime time1 = v25;
        *((void *)&v30[0] + 1) = CMClockConvertHostTimeToSystemUnits(&time1);
        DWORD2(v31) = 2;
        if (!dword_1E9350B70) {
          goto LABEL_35;
        }
        int v24 = 0;
        os_log_type_t v23 = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
LABEL_34:
        fig_log_call_emit_and_clean_up_after_send_and_compose();
LABEL_35:
        uint64_t v6 = v30;
        if ((v4 & 2) != 0) {
          goto LABEL_36;
        }
        goto LABEL_25;
      }
    }
    if (dword_1E9350B70)
    {
      LODWORD(v28.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
      CMTime v8 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    uint64_t v6 = 0;
LABEL_24:
    if ((v4 & 2) != 0) {
      goto LABEL_36;
    }
    goto LABEL_25;
  }
  if ((v5 & 2) == 0 && !*(unsigned char *)(a2 + 49))
  {
    CMTime time1 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    CMTime time2 = v29;
    if (CMTimeCompare(&time1, &time2))
    {
      uint64_t v9 = *(void *)(a1 + 592);
      CMTime time1 = v29;
      *((void *)&v30[0] + 1) = v9 - CMClockConvertHostTimeToSystemUnits(&time1);
      DWORD2(v31) = 2;
      if (!dword_1E9350B70) {
        goto LABEL_35;
      }
      LODWORD(v28.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
      double v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      goto LABEL_34;
    }
  }
  uint64_t v6 = (_OWORD *)(a1 + 584);
  if (!dword_1E9350B70) {
    goto LABEL_24;
  }
  LODWORD(v28.CFDictionarySetValue(theDict, key, value) = 0;
  LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
  uint64_t v7 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
  os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  fig_log_call_emit_and_clean_up_after_send_and_compose();
  if ((v4 & 2) != 0)
  {
LABEL_36:
    uint64_t v14 = FigAudioQueueTimingShimStartWithPerfCallback(*(void *)(a2 + 40), (uint64_t)v6, *(unsigned char *)(a1 + 581), 0, 0);
    if (!v14) {
      goto LABEL_37;
    }
    return v14;
  }
LABEL_25:
  float v11 = *(const void **)(a2 + 24);
  if (v11)
  {
    CFRetain(v11);
    uint64_t v12 = *(void *)(a2 + 24);
  }
  else
  {
    uint64_t v12 = 0;
  }
  uint64_t started = FigAudioQueueTimingShimStartAsyncWithPerfCallback(*(void *)(a2 + 40), (uint64_t)v6, *(unsigned char *)(a1 + 581), (uint64_t)subaq_audioQueueStartupCompleted, v12, 0, 0);
  if (!started)
  {
LABEL_37:
    *(unsigned char *)(a2 + 49) = 1;
    if ((*(unsigned char *)(a1 + 48) & 2) != 0)
    {
      if (*(unsigned char *)(a1 + 16) || (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176)), Count < 1))
      {
LABEL_45:
        CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterPostNotification();
        return 0;
      }
      CFIndex v19 = Count;
      if (*((unsigned char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0) + 49))
      {
        CFIndex v20 = 1;
        while (v19 != v20)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), v20++);
          if (!ValueAtIndex[49])
          {
            if (v20 - 1 < v19) {
              return 0;
            }
            goto LABEL_45;
          }
        }
        goto LABEL_45;
      }
    }
    return 0;
  }
  uint64_t v14 = started;
  char v15 = *(const void **)(a2 + 24);
  if (v15) {
    CFRelease(v15);
  }
  return v14;
}

CMTime *subaq_getCurrentQueueTime@<X0>(uint64_t a1@<X0>, CMTime *a2@<X8>)
{
  long long v7 = 0u;
  uint64_t v4 = MEMORY[0x1E4F1FA48];
  memset(v6, 0, sizeof(v6));
  *(_OWORD *)&a2->unsigned int value = *MEMORY[0x1E4F1FA48];
  a2->CMTimeEpoch epoch = *(void *)(v4 + 16);
  uint64_t result = *(CMTime **)(a1 + 40);
  if (result)
  {
    DWORD2(v7) = 1;
    uint64_t result = (CMTime *)FigAudioQueueTimingShimGetCurrentTime(result, 0, 0, v6, 0);
    if (!result && (BYTE8(v7) & 1) != 0) {
      return CMTimeMake(a2, (uint64_t)(*(double *)v6 + 0.5), *(_DWORD *)(a1 + 100));
    }
  }
  return result;
}

uint64_t FigAudioQueueStop(uint64_t a1)
{
  return faq_stopAllAudioQueues(a1, 1u, 1);
}

uint64_t faq_stopAllAudioQueues(uint64_t a1, Boolean a2, int a3)
{
  if (a1)
  {
    MEMORY[0x19970E290](*(void *)(a1 + 24));
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v11 = FigSignalErrorAt();
    }
    else
    {
      *(unsigned char *)(a1 + 305) = 0;
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176));
      if (Count < 1)
      {
LABEL_11:
        uint64_t v12 = 0;
        *(unsigned char *)(a1 + 73) = 0;
        *(_WORD *)(a1 + 578) = 0;
        *(unsigned char *)(a1 + 761) = 0;
        uint64_t v13 = MEMORY[0x1E4F1F9F8];
        long long v14 = *MEMORY[0x1E4F1F9F8];
        *(_OWORD *)(a1 + 528) = *MEMORY[0x1E4F1F9F8];
        uint64_t v15 = *(void *)(v13 + 16);
        *(void *)(a1 + 544) = v15;
        *(_OWORD *)(a1 + 480) = v14;
        *(void *)(a1 + 496) = v15;
        *(_WORD *)(a1 + 648) = 0;
        *(unsigned char *)(a1 + 745) = 0;
LABEL_12:
        MEMORY[0x19970E2B0](*(void *)(a1 + 24));
        if (a3)
        {
          if (*(void *)(a1 + 720))
          {
            CMNotificationCenterGetDefaultLocalCenter();
            CMNotificationCenterPostNotification();
          }
        }
        return v12;
      }
      CFIndex v8 = Count;
      CFIndex v9 = 0;
      while (1)
      {
        double v10 = *(unsigned char *)(a1 + 16) ? 0 : CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), v9);
        uint64_t v11 = subaq_stopAudioQueue(a1, (uint64_t)v10, a2);
        if (v11) {
          break;
        }
        v10[48] = 0;
        if (v8 == ++v9) {
          goto LABEL_11;
        }
      }
    }
    uint64_t v12 = v11;
    goto LABEL_12;
  }
  return FigSignalErrorAt();
}

uint64_t FigAudioQueueStopOffline(uint64_t a1)
{
  return faq_stopAllAudioQueues(a1, 0, 1);
}

uint64_t FigAudioQueueResetOffline(uint64_t a1)
{
  MEMORY[0x19970E290](*(void *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 16)) {
    v2.n128_f64[0] = faq_reset(a1, v2.n128_f64[0]);
  }
  MEMORY[0x19970E2B0](*(void *)(a1 + 24), v2);
  return 0;
}

double faq_reset(uint64_t a1, double result)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int v16 = 1;
  UInt32 v17 = 4;
  if (!*(unsigned char *)(a1 + 16))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176));
    if (Count >= 2)
    {
      unint64_t v4 = Count + 1;
      do
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 176), v4 - 2);
        --v4;
      }
      while (v4 > 2);
    }
    if (*(unsigned char *)(a1 + 16)) {
      CFDictionaryRef ValueAtIndex = 0;
    }
    else {
      CFDictionaryRef ValueAtIndex = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0);
    }
    FigAudioQueueTimingShimGetProperty(*((void *)ValueAtIndex + 5), 0x6171726Eu, &v16, &v17);
    if (dword_1E9350B70)
    {
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (*(void *)(a1 + 720) && *(unsigned char *)(a1 + 760)) {
      faq_disconnectFromOfflineMixer(a1, (uint64_t)ValueAtIndex);
    }
    FigAudioQueueTimingShimReset(*((void *)ValueAtIndex + 5));
    if (*(void *)(a1 + 720) && *(unsigned char *)(a1 + 760)) {
      faq_connectToOfflineMixer((void *)a1, (uint64_t)ValueAtIndex);
    }
    AudioQueueParameterValue v7 = 1.0;
    if (*(unsigned char *)(a1 + 236) && *(float *)(a1 + 232) != 0.0) {
      AudioQueueParameterValue v7 = *(float *)(a1 + 232);
    }
    FigAudioQueueTimingShimSetParameter(*((void *)ValueAtIndex + 5), 2u, v7);
    subaq_restoreParameters(a1, (uint64_t)ValueAtIndex);
    if (v16 && (*(unsigned char *)(a1 + 48) & 2) == 0)
    {
      FigAudioQueueTimingShimPause(*((void *)ValueAtIndex + 5));
      *(unsigned char *)(a1 + 579) = 1;
      if (*(unsigned char *)(a1 + 73) || *(unsigned char *)(a1 + 576))
      {
        *(unsigned char *)(a1 + 648) = 1;
      }
      else
      {
        *(unsigned char *)(a1 + 648) = 0;
        *(unsigned char *)(a1 + 305) = 0;
      }
    }
    v18[0] = 1.0;
    int Parameter = FigAudioQueueTimingShimGetParameter(*((void *)ValueAtIndex + 5), 0x15u, v18);
    float v9 = v18[0];
    if (Parameter) {
      float v9 = 1.0;
    }
    *((float *)ValueAtIndex + 133) = v9;
    double v10 = (long long *)MEMORY[0x1E4F1F9F8];
    if (*(unsigned char *)(a1 + 578))
    {
      *(unsigned char *)(a1 + 578) = 0;
      *(unsigned char *)(a1 + 305) = 0;
      *(unsigned char *)(a1 + 648) = 0;
      long long v11 = *v10;
      *(_OWORD *)(a1 + 528) = *v10;
      uint64_t v12 = *((void *)v10 + 2);
      *(void *)(a1 + 544) = v12;
      *(_OWORD *)(a1 + 480) = v11;
      *(void *)(a1 + 496) = v12;
      *(_OWORD *)(ValueAtIndex + 484) = v11;
      *(void *)(ValueAtIndex + 500) = v12;
    }
    *(unsigned char *)(a1 + 761) = 0;
    long long v15 = *v10;
    *(_OWORD *)(ValueAtIndex + 408) = *v10;
    uint64_t v13 = *((void *)v10 + 2);
    *((void *)ValueAtIndex + 53) = v13;
    *((_OWORD *)ValueAtIndex + 27) = v15;
    *((void *)ValueAtIndex + 56) = v13;
    *(_OWORD *)(ValueAtIndex + 456) = v15;
    *((void *)ValueAtIndex + 59) = v13;
    *(_OWORD *)(ValueAtIndex + 616) = v15;
    *((void *)ValueAtIndex + 79) = v13;
    MEMORY[0x19970E910](*((void *)ValueAtIndex + 67));
    *(_OWORD *)(ValueAtIndex + 508) = v15;
    *(void *)(ValueAtIndex + 524) = v13;
    MEMORY[0x19970E930](*((void *)ValueAtIndex + 67));
    *(unsigned char *)(a1 + 577) = 1;
    *(unsigned char *)(a1 + 196) = 0;
    *(unsigned char *)(a1 + 356) = 0;
    uint64_t v14 = MEMORY[0x1E4F1FA48];
    *(_OWORD *)(a1 + 360) = *MEMORY[0x1E4F1FA48];
    *(void *)(a1 + 376) = *(void *)(v14 + 16);
    *(void *)&uint64_t result = faq_clearSeamHandlingState((__n128 *)a1).n128_u64[0];
  }
  return result;
}

uint64_t subaq_getAudioQueueLatencyFigTime(uint64_t result, uint64_t a2, CMTime *a3)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  CMTime v5 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  if (result)
  {
    if (*(unsigned char *)(result + 16))
    {
      return 0;
    }
    else
    {
      uint64_t result = FigAudioQueueTimingShimGetAudioQueueLatency(*(void *)(a2 + 40), *(OpaqueCMClock **)(a2 + 576), *(unsigned __int8 *)(result + 746), &v5);
      if (!result)
      {
        if (dword_1E9350B70)
        {
          os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        uint64_t result = 0;
        *a3 = v5;
      }
    }
  }
  return result;
}

uint64_t subaq_getEQPreset(uint64_t result, uint64_t a2, int *a3)
{
  float v8 = -1.0;
  if (result)
  {
    if (!*(unsigned char *)(result + 16))
    {
      UInt32 v6 = 4;
      int v7 = 0;
      if ((*(unsigned char *)(result + 48) & 4) == 0)
      {
        uint64_t result = FigAudioQueueTimingShimGetProperty(*(void *)(a2 + 40), 0x715F6571u, &v7, &v6);
        if (!result)
        {
          if (v7)
          {
            uint64_t result = FigAudioQueueTimingShimGetParameter(*(void *)(a2 + 40), 7u, &v8);
            if (result) {
              return result;
            }
            int v5 = (int)v8;
          }
          else
          {
            int v5 = -1;
          }
          *a3 = v5;
        }
      }
    }
  }
  return result;
}

uint64_t faq_setAudioCurves(uint64_t a1, unint64_t a2, const __CFDictionary *a3)
{
  BOOL v3 = a2 == 0;
  if (a2 > 1) {
    return 4294954356;
  }
  LODWORD(start.CFDictionarySetValue(theDict, key, value) = 0;
  theDict.start.unsigned int value = 0;
  context.start.unsigned int value = (CMTimeValue)&start;
  *(void *)&context.start.CMTimeScale timescale = a1;
  context.start.CMTimeEpoch epoch = 0;
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], &faq_audioProcessingUnitsParametersInspectionResultsDictValueCallbacks);
  context.duration.unsigned int value = (CMTimeValue)Mutable;
  CFDictionaryRef v30 = a3;
  if (Mutable)
  {
    if (FigCFDictionaryGetValueIfPresent())
    {
      CFDictionaryApplyFunction((CFDictionaryRef)theDict.start.value, (CFDictionaryApplierFunction)faq_inspectAudioProcessingUnitsParametersInNewAudioCurvesApplier, &context);
      CFMutableStringRef Mutable = (const void *)context.duration.value;
    }
    uint64_t value_low = LODWORD(start.value);
    if (LODWORD(start.value)) {
      goto LABEL_42;
    }
  }
  else
  {
    uint64_t value_low = FigSignalErrorAt();
    if (value_low) {
      goto LABEL_42;
    }
  }
  MEMORY[0x19970E290](*(void *)(a1 + 24));
  unint64_t v29 = a2;
  if (*(unsigned char *)(a1 + 16) || (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176)), Count < 1))
  {
    uint64_t value_low = 0;
LABEL_36:
    uint64_t v26 = a1 + 8 * v29;
    BOOL v27 = *(const void **)(v26 + 656);
    *(void *)(v26 + 656) = v30;
    if (v30) {
      CFRetain(v30);
    }
    if (v27) {
      CFRelease(v27);
    }
    MEMORY[0x19970E2B0](*(void *)(a1 + 24));
    if (value_low)
    {
      CFRelease((CFTypeRef)value_low);
      uint64_t value_low = 0;
    }
    goto LABEL_42;
  }
  CFIndex v10 = Count;
  CFIndex v11 = 0;
  uint64_t value_low = 0;
  uint64_t v12 = (void *)(a1 + 8 * a2 + 656);
  uint64_t v13 = (_OWORD *)(a1 + 528);
  while (1)
  {
    uint64_t v14 = *(unsigned char *)(a1 + 16) ? 0 : (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), v11);
    memset(&context, 0, sizeof(context));
    if (v14[496]) {
      break;
    }
LABEL_32:
    if (v10 == ++v11) {
      goto LABEL_36;
    }
  }
  if (value_low)
  {
LABEL_22:
    float v20 = *(float *)(a1 + 416);
    double v21 = 1.0;
    if (v20 == 0.0) {
      double v22 = 1.0;
    }
    else {
      double v22 = v20;
    }
    if (*(unsigned char *)(a1 + 236))
    {
      float v23 = *(float *)(a1 + 232);
      BOOL v24 = v23 == 0.0;
      double v21 = v23;
      if (v24) {
        double v21 = 1.0;
      }
    }
    CMTime v25 = v14 + 484;
    if (v22 / v21 >= 0.0)
    {
      *(_OWORD *)&v34.unsigned int value = *v13;
      v34.CMTimeEpoch epoch = *(void *)(a1 + 544);
      *(_OWORD *)&theDict.start.unsigned int value = *v25;
      theDict.start.CMTimeEpoch epoch = *(void *)(v14 + 500);
      CMTimeRangeFromTimeToTime(&context, &v34, &theDict.start);
    }
    else
    {
      *(_OWORD *)&end.unsigned int value = *v13;
      end.CMTimeEpoch epoch = *(void *)(a1 + 544);
      *(_OWORD *)&start.unsigned int value = *v25;
      start.CMTimeEpoch epoch = *(void *)(v14 + 500);
      CMTimeRangeFromTimeToTime(&theDict, &start, &end);
      CMTimeRange context = theDict;
    }
    CMTimeRange theDict = context;
    subaq_scheduleVolumeCurvesForMediaTimeRange(a1, (uint64_t)v14, (CFDictionaryRef)value_low, &theDict, v3, 1);
    subaq_scheduleCinematicForMediaTimeRange((const __CFArray *)a1, (uint64_t)v14, (CFDictionaryRef)value_low);
    CMTimeRange theDict = context;
    subaq_scheduleAudioProcessingUnitForMediaTimeRange(a1, (uint64_t)v14, value_low, (long long *)&theDict.start.value, v3, (uint64_t)Mutable);
    goto LABEL_32;
  }
  if (!*v12)
  {
    uint64_t value_low = (uint64_t)v30;
    if (!v30)
    {
      *uint64_t v12 = 0;
      MEMORY[0x19970E2B0](*(void *)(a1 + 24));
      goto LABEL_42;
    }
    goto LABEL_21;
  }
  uint64_t value_low = (uint64_t)v30;
  if (v30)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v30, @"AudioCurve_Volume");
    if (Value)
    {
      if (CFArrayGetCount(Value))
      {
LABEL_21:
        CFRetain((CFTypeRef)value_low);
        goto LABEL_22;
      }
    }
  }
  int v16 = v12;
  CFMutableArrayRef v17 = CFArrayCreateMutable(0, 3, MEMORY[0x1E4F1D510]);
  if (!v17) {
    goto LABEL_47;
  }
  uint64_t v18 = v17;
  *(_OWORD *)&theDict.start.unsigned int value = *MEMORY[0x1E4F1FA48];
  theDict.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  FigCFArrayAppendCMTime();
  FigCFArrayAppendDouble();
  CFArrayAppendValue(v18, @"Linear");
  MutableCFArrayRef Copy = (__CFDictionary *)FigCFDictionaryCreateMutableCopy();
  if (MutableCopy)
  {
    uint64_t value_low = (uint64_t)MutableCopy;
    CFDictionarySetValue(MutableCopy, @"AudioCurve_Volume", v18);
    CFRelease(v18);
    uint64_t v12 = v16;
    goto LABEL_22;
  }
  CFRelease(v18);
LABEL_47:
  MEMORY[0x19970E2B0](*(void *)(a1 + 24));
  uint64_t value_low = 4294954355;
LABEL_42:
  if (Mutable) {
    CFRelease(Mutable);
  }
  return value_low;
}

CFIndex faq_updateRate2Enable(CFIndex result)
{
  CFIndex v1 = result;
  if (*(unsigned char *)(result + 680)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(float *)(result + 764) != 0.0;
  }
  BOOL v6 = v2;
  if (!*(unsigned char *)(result + 16))
  {
    uint64_t result = CFArrayGetCount(*(CFArrayRef *)(result + 176));
    if (result >= 1)
    {
      CFIndex v3 = result;
      for (CFIndex i = 0; i != v3; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 176), i);
        uint64_t result = FigAudioQueueTimingShimSetProperty(ValueAtIndex[5], 0x71737232u, &v6, 4u);
      }
    }
  }
  return result;
}

uint64_t faq_connectToOfflineMixer(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[90];
  if (!v2 || *(unsigned char *)(a2 + 642)) {
    return 0;
  }
  FigAudioQueueTimingShimGetAudioQueue(*(void *)(a2 + 40));
  uint64_t result = FigAudioQueueOfflineMixerConnectAudioQueue(v2, a1);
  if (!result) {
    *(unsigned char *)(a2 + 642) = 1;
  }
  return result;
}

uint64_t faq_setPropertyOnAllSubAudioQueues(uint64_t a1, const void *a2, const __CFString *a3)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176));
  if (Count < 1) {
    return 0;
  }
  CFIndex v7 = Count;
  CFIndex v8 = 0;
  while (1)
  {
    float v9 = *(unsigned char *)(a1 + 16) ? 0 : CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), v8);
    uint64_t result = subaq_setProperty(a1, (uint64_t)v9, a2, a3);
    if (result) {
      break;
    }
    if (v7 == ++v8) {
      return 0;
    }
  }
  return result;
}

uint64_t faq_addAudioProcessingTapListeners(uint64_t a1)
{
  if (!*(void *)(a1 + 736)) {
    return 0;
  }
  CMNotificationCenterGetDefaultLocalCenter();
  uint64_t result = FigNotificationCenterAddWeakListener();
  if (!result)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    return FigNotificationCenterAddWeakListener();
  }
  return result;
}

const void *faq_GetLastSubAudioQueue(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176));
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  CFIndex v3 = Count - 1;
  CFArrayRef v4 = *(const __CFArray **)(a1 + 176);

  return CFArrayGetValueAtIndex(v4, v3);
}

uint64_t MTAudioProcessingTapInitializeTap(uint64_t a1, uint64_t a2)
{
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v7 = *(void *)(VTable + 16);
  uint64_t result = VTable + 16;
  uint64_t v6 = v7;
  if (v7) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = 0;
  }
  float v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 8);
  if (v9)
  {
    return v9(a1, a2);
  }
  return result;
}

uint64_t FigAudioQueueGetParameter(uint64_t a1, AudioQueueParameterID a2, _DWORD *a3)
{
  int v10 = 0;
  if (a1 && a3)
  {
    MEMORY[0x19970E290](*(void *)(a1 + 24));
    if (!*(unsigned char *)(a1 + 16)
      && (CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0)) != 0
      && (uint64_t v7 = ValueAtIndex[5]) != 0)
    {
      uint64_t Parameter = FigAudioQueueTimingShimGetParameter(v7, a2, (AudioQueueParameterValue *)&v10);
      if (!Parameter) {
        *a3 = v10;
      }
    }
    else
    {
      uint64_t Parameter = FigSignalErrorAt();
    }
    MEMORY[0x19970E2B0](*(void *)(a1 + 24));
    return Parameter;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigAudioQueueRestoreParameters(uint64_t a1)
{
  if (a1)
  {
    MEMORY[0x19970E290](*(void *)(a1 + 24));
    if (!*(unsigned char *)(a1 + 16)
      && (CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0)) != 0
      && ValueAtIndex[5])
    {
      subaq_restoreParameters(a1, (uint64_t)ValueAtIndex);
      uint64_t v4 = 0;
    }
    else
    {
      uint64_t v4 = FigSignalErrorAt();
    }
    MEMORY[0x19970E2B0](*(void *)(a1 + 24));
    return v4;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

CFDictionaryRef subaq_restoreParameters(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 204)) {
    FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 1u, *(AudioQueueParameterValue *)(a1 + 200));
  }
  if (*(unsigned char *)(a1 + 212)) {
    FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 5u, *(AudioQueueParameterValue *)(a1 + 208));
  }
  if (*(unsigned char *)(a1 + 220)) {
    FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 9u, *(AudioQueueParameterValue *)(a1 + 216));
  }
  if (*(unsigned char *)(a1 + 228)) {
    FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 0xEu, *(AudioQueueParameterValue *)(a1 + 224));
  }
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 240);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"LoudnessInfo");
    if (result)
    {
      if (result != (const __CFDictionary *)*MEMORY[0x1E4F1D260])
      {
        return (const __CFDictionary *)subaq_setProperty(a1, a2, @"LoudnessInfo", (const __CFString *)result);
      }
    }
  }
  return result;
}

uint64_t FigAudioQueueCopyPerformanceDictionary(uint64_t a1, CFDictionaryRef *a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long keys = 0u;
    long long v29 = 0u;
    *(_OWORD *)values = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    uint64_t valuePtr = 0;
    MEMORY[0x19970E290](*(void *)(a1 + 24));
    if (!*(unsigned char *)(a1 + 16)
      && (CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0)) != 0
      && (int v5 = ValueAtIndex, *((void *)ValueAtIndex + 5)))
    {
      uint64_t v6 = *(void *)(a1 + 728) * *(unsigned int *)(*((void *)ValueAtIndex + 8) + 20);
      DefaultAudioPrimingFrameCFIndex Count = FigGaplessInfoGetDefaultAudioPrimingFrameCount(*((const opaqueCMFormatDescription **)ValueAtIndex
                                                                                     + 7));
      uint64_t valuePtr = (v6 - DefaultAudioPrimingFrameCount) & ~((v6 - DefaultAudioPrimingFrameCount) >> 63);
      *(void *)&long long keys = @"NumberOfInputPacketsFedToDecoder";
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, (const void *)(a1 + 728));
      *((void *)&keys + 1) = @"NumberOfOutputFramesExpected";
      values[1] = CFNumberCreate(v8, kCFNumberSInt64Type, &valuePtr);
      uint64_t v16 = 0;
      UInt32 v15 = 8;
      FigAudioQueueTimingShimGetProperty(v5[5], 0x24696E64u, &v16, &v15);
      if (v16)
      {
        *(void *)&long long v29 = @"AudioConverterStatistics";
        *(void *)&long long v19 = v16;
        CFIndex v9 = 3;
      }
      else
      {
        CFIndex v9 = 2;
      }
      int v10 = values;
      CFDictionaryRef v11 = CFDictionaryCreate(v8, (const void **)&keys, (const void **)values, v9, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      do
      {
        uint64_t v12 = *v10++;
        CFRelease(v12);
        --v9;
      }
      while (v9);
      uint64_t v13 = 0;
      *a2 = v11;
    }
    else
    {
      uint64_t v13 = FigSignalErrorAt();
    }
    MEMORY[0x19970E2B0](*(void *)(a1 + 24));
    return v13;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t faq_registerFAQType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  gFAQID = result;
  return result;
}

uint64_t FigAudioQueueIsPassthroughSupported()
{
  return 1;
}

uint64_t faq_oneTimeInitializationWork()
{
  FigNote_AllowInternalDefaultLogs();
  fig_note_initialize_category_with_default_work_cf();

  return fig_note_initialize_category_with_default_work_cf();
}

BOOL faq_scaledEditRateSupportValidator_one32nd_to_32(uint64_t a1, double a2)
{
  double v2 = 1.0;
  if (*(unsigned char *)(a1 + 236))
  {
    float v3 = *(float *)(a1 + 232);
    if (v3 != 0.0) {
      double v2 = v3;
    }
  }
  double v4 = v2 * a2;
  return v4 <= 32.0 && v4 >= 0.03125;
}

uint64_t faq_scaledEditRateSupportValidator_lowQualityZeroLatency(uint64_t a1, double a2)
{
  if (*(unsigned char *)(a1 + 236))
  {
    float v2 = *(float *)(a1 + 232);
    BOOL v3 = v2 == 0.0;
    double v4 = v2;
    if (v3) {
      double v4 = 1.0;
    }
  }
  else
  {
    double v4 = 1.0;
  }
  uint64_t v5 = 0;
  double v6 = v4 * a2;
  while (1)
  {
    double v7 = *(double *)&qword_194992D80[v5];
    double v8 = v7 * 0.98;
    double v9 = v7 * 1.02;
    if (v8 < v6 && v6 < v9) {
      break;
    }
    if (++v5 == 7) {
      return 0;
    }
  }
  return 1;
}

BOOL faq_scaledEditRateSupportValidator_noScaleAllowed(uint64_t a1, double a2)
{
  double v2 = 1.0;
  if (*(unsigned char *)(a1 + 236))
  {
    float v3 = *(float *)(a1 + 232);
    if (v3 != 0.0) {
      double v2 = v3;
    }
  }
  return v2 * a2 == 1.0;
}

void faq_sourceDataBecameReady()
{
  uint64_t v0 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v0)
  {
    uint64_t v1 = (const void *)v0;
    if (!*(unsigned char *)(v0 + 16)) {
      FigSemaphoreSignal();
    }
    CFRelease(v1);
  }
}

void faq_sourceEndOfDataReached()
{
  uint64_t v0 = (unsigned char *)FigCFWeakReferenceHolderCopyReferencedObject();
  if (v0)
  {
    uint64_t v1 = v0;
    if (!v0[16])
    {
      CFRetain(v0);
      global_queue = dispatch_get_global_queue(0, 0);
      dispatch_async_f(global_queue, v1, (dispatch_function_t)faq_deferredAudioQueueEndOfDataReached);
      FigSemaphoreSignal();
    }
    CFRelease(v1);
  }
}

void faq_resetOutput(uint64_t a1, uint64_t a2)
{
  MEMORY[0x19970E290](*(void *)(a2 + 24));
  if (!*(unsigned char *)(a2 + 16)) {
    faq_reset(a2, v3);
  }

  JUMPOUT(0x19970E2B0);
}

void faq_inhibitOutputUntil(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  MEMORY[0x19970E290](*(void *)(a2 + 24));
  if (!*(unsigned char *)(a2 + 16))
  {
    double v8 = *(const void **)(a2 + 104);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(a2 + 104) = 0;
    }
    if (a5)
    {
      CFArrayRef Value = CFDictionaryGetValue(a5, (const void *)*MEMORY[0x1E4F1F328]);
      if (Value)
      {
        *(void *)(a2 + 104) = Value;
        CFRetain(Value);
      }
    }
    faq_reset(a2, v7);
  }

  JUMPOUT(0x19970E2B0);
}

void faq_deferredAudioQueueEndOfDataReached(unsigned char *cf)
{
  if (!cf[16])
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
  }

  CFRelease(cf);
}

uint64_t subaq_createValidSubAQSetAndLock()
{
  gValidFigSubAudioQueueSet = (uint64_t)CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  uint64_t result = FigReadWriteLockCreate();
  gValidFigSubAudioQueueSetRWLock = result;
  if (gValidFigSubAudioQueueSet) {
    BOOL v1 = result == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1)
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t subaq_setupForDecode(uint64_t a1, CMFormatDescriptionRef desc)
{
  ptr = 0;
  uint64_t v9 = 0;
  CFIndex size = 0;
  CMFormatDescriptionGetMediaSubType(desc);
  uint64_t v3 = MEMORY[0x19970C720](a1 + 16);
  if (!v3) {
    return 0;
  }
  double v4 = (const void *)v3;
  if (*(unsigned char *)(v3 + 16))
  {
    uint64_t v6 = 0;
  }
  else
  {
    if (*(void *)(v3 + 272)) {
      FigAudioFormatDescriptionGetBestDecodableFormatAndChannelLayoutForRenderingPreferences();
    }
    else {
      CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout();
    }
    uint64_t v6 = FigSignalErrorAt();
  }
  CFRelease(v4);
  return v6;
}

const void **subaq_ensureClock(uint64_t a1, uint64_t a2)
{
  double v2 = (const void **)a1;
  if (a1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      return 0;
    }
    if (*(void *)(a2 + 576)) {
      return 0;
    }
    if ((*(unsigned char *)(a1 + 48) & 2) != 0) {
      return 0;
    }
    uint64_t v3 = (CMClockRef *)(a2 + 576);
    if (FigPreferAudioSessionClock()
      && (CFAllocatorRef v4 = CFGetAllocator(v2), !FigAudioSessionClockCreate((uint64_t)v4, v2[33], 0, v3)))
    {
      return 0;
    }
    else
    {
      CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], "VirtualAudioDevice_Default", 0);
      CFAllocatorRef v6 = CFGetAllocator(v2);
      double v2 = (const void **)CMAudioDeviceClockCreate(v6, v5, v3);
      if (v5) {
        CFRelease(v5);
      }
    }
  }
  return v2;
}

void subaq_deferredPerformStartupSync(const void *a1)
{
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v2)
  {
    uint64_t v3 = (const void *)v2;
    uint64_t v4 = MEMORY[0x19970C720](v2 + 16);
    if (v4)
    {
      CFStringRef v5 = (const void *)v4;
      if (!*(unsigned char *)(v4 + 16)) {
        subaq_performStartupSync(v4, (uint64_t)v3);
      }
      CFRelease(v3);
    }
    else
    {
      CFStringRef v5 = v3;
    }
    CFRelease(v5);
  }

  CFRelease(a1);
}

uint64_t fsaq_registerFSAQType()
{
  gFSAQID = _CFRuntimeRegisterClass();

  return FigCFWeakReferenceTableCreate();
}

void fsaq_Init(uint64_t a1)
{
}

void fsaq_Finalize(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x19970C720](a1 + 16);
  FigReadWriteLockLockForWrite();
  CFSetRemoveValue((CFMutableSetRef)gValidFigSubAudioQueueSet, (const void *)a1);
  FigReadWriteLockUnlockForWrite();
  if (*(unsigned char *)(a1 + 642)) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3 && !*(unsigned char *)(v2 + 16) && *(void *)(v2 + 720)) {
    faq_disconnectFromOfflineMixer(v2, a1);
  }
  uint64_t v4 = *(NSObject **)(a1 + 680);
  if (v4)
  {
    dispatch_source_cancel(v4);
    if (*(unsigned char *)(a1 + 688))
    {
      CFStringRef v5 = *(NSObject **)(a1 + 672);
      if (v5 != dispatch_get_current_queue()) {
        dispatch_sync_f(v5, 0, (dispatch_function_t)subaq_noop);
      }
    }
    dispatch_release(*(dispatch_object_t *)(a1 + 680));
    *(void *)(a1 + 680) = 0;
    CFAllocatorRef v6 = *(const void **)(a1 + 24);
    if (v6) {
      CFRelease(v6);
    }
  }
  double v7 = *(NSObject **)(a1 + 672);
  if (v7)
  {
    dispatch_release(v7);
    *(void *)(a1 + 672) = 0;
  }
  double v8 = *(const void **)(a1 + 712);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 712) = 0;
  }
  if (*(void *)(a1 + 40))
  {
    uint64_t v9 = *(void **)(a1 + 32);
    FigCFWeakReferenceTableRemoveValue();
    FigAudioQueueTimingShimRemovePropertyListener(*(void *)(a1 + 40), 0x71637665u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v9);
    FigAudioQueueTimingShimRemovePropertyListener(*(void *)(a1 + 40), 0x61747072u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v9);
    FigAudioQueueTimingShimRemovePropertyListener(*(void *)(a1 + 40), 0x6171726Eu, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_startStopListener, v9);
    if (!v2) {
      goto LABEL_23;
    }
    *(void *)(v2 + 384) = 0;
    *(void *)(v2 + 400) = 0;
    int v10 = *(const void **)(v2 + 408);
    if (v10)
    {
      CFRelease(v10);
      *(void *)(v2 + 408) = 0;
    }
    if (*(unsigned char *)(v2 + 72)) {
LABEL_23:
    }
      FigAudioQueueTimingShimRemovePropertyListener(*(void *)(a1 + 40), 0x666C7368u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v9);
    FigAudioQueueTimingShimRemovePropertyListener(*(void *)(a1 + 40), 0x71646C73u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v9);
    FigAudioQueueTimingShimRemovePropertyListener(*(void *)(a1 + 40), 0x6864666Du, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v9);
    if (!v2 || (*(unsigned char *)(v2 + 49) & 2) == 0)
    {
      FigAudioQueueTimingShimRemovePropertyListener(*(void *)(a1 + 40), 0x72746F72u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v9);
      FigAudioQueueTimingShimRemovePropertyListener(*(void *)(a1 + 40), 0x69737470u, (void (__cdecl *)(void *, AudioQueueRef, AudioQueuePropertyID))subaq_deferringAQPropertyListenerHandler, v9);
    }
    FigReadWriteLockLockForWrite();
    FigReadWriteLockUnlockForWrite();
    FigAudioQueueTimingShimStop(*(void *)(a1 + 40), 1u);
    uint64_t v11 = 0;
    uint64_t v12 = a1 + 344;
    do
    {
      uint64_t v13 = *(AudioQueueBuffer **)(v12 + v11);
      if (v13)
      {
        FigAudioQueueTimingShimFreeBuffer(*(void *)(a1 + 40), v13);
        *(void *)(v12 + v11) = 0;
      }
      v11 += 8;
    }
    while (v11 != 64);
    for (uint64_t i = 0; i != 192; i += 24)
    {
      uint64_t v15 = a1 + i;
      if (*(unsigned char *)(a1 + i + 160))
      {
        uint64_t v16 = *(const void **)(v15 + 144);
        if (v16)
        {
          CFRelease(v16);
          *(void *)(v15 + 144) = 0;
        }
        CFMutableArrayRef v17 = *(const void **)(a1 + i + 152);
        if (v17)
        {
          CFRelease(v17);
          *(void *)(a1 + i + 152) = 0;
        }
        *(unsigned char *)(v15 + 160) = 0;
      }
    }
    uint64_t v18 = *(void *)(a1 + 600);
    if (v18)
    {
      uint64_t v19 = *(void *)(a1 + 592);
      uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v20) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = 0;
      }
      long long v22 = *(void (**)(uint64_t, uint64_t))(v21 + 24);
      if (v22) {
        v22(v19, v18);
      }
      long long v23 = *(const void **)(a1 + 592);
      if (v23)
      {
        CFRelease(v23);
        *(void *)(a1 + 592) = 0;
      }
      *(void *)(a1 + 600) = 0;
    }
    if (dword_1E9350B70)
    {
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    FigAudioQueueTimingShimDispose(*(AudioQueueRef **)(a1 + 40), 1u);
    *(void *)(a1 + 40) = 0;
    CFRelease(*(CFTypeRef *)(a1 + 24));
  }
  long long v25 = *(const void **)(a1 + 576);
  if (v25)
  {
    CFRelease(v25);
    *(void *)(a1 + 576) = 0;
  }
  if (*(void *)(a1 + 136))
  {
    FigSimpleMutexDestroy();
    *(void *)(a1 + 136) = 0;
  }
  if (*(void *)(a1 + 336))
  {
    FigSimpleMutexDestroy();
    *(void *)(a1 + 336) = 0;
  }
  if (*(void *)(a1 + 536))
  {
    FigSimpleMutexDestroy();
    *(void *)(a1 + 536) = 0;
  }
  if (*(void *)(a1 + 648))
  {
    FigReadWriteLockDestroy();
    *(void *)(a1 + 648) = 0;
  }
  long long v26 = *(const void **)(a1 + 56);
  if (v26)
  {
    CFRelease(v26);
    *(void *)(a1 + 56) = 0;
  }
  if (*(unsigned char *)(a1 + 72))
  {
    CFAllocatorRef v27 = CFGetAllocator((CFTypeRef)a1);
    CFAllocatorDeallocate(v27, *(void **)(a1 + 64));
    *(void *)(a1 + 64) = 0;
    *(unsigned char *)(a1 + 72) = 0;
  }
  if (*(unsigned char *)(a1 + 96))
  {
    CFAllocatorRef v28 = CFGetAllocator((CFTypeRef)a1);
    CFAllocatorDeallocate(v28, *(void **)(a1 + 80));
    *(void *)(a1 + 80) = 0;
    *(unsigned char *)(a1 + 96) = 0;
  }
  FigCFWeakReferenceStore();
  long long v29 = *(const void **)(a1 + 24);
  if (v29) {
    CFRelease(v29);
  }
  if (v2) {
    CFRelease((CFTypeRef)v2);
  }
}

__CFString *fsaq_CopyFormattingDesc(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v2, 0);
  CFIndex v4 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, @"[FigSubAudioQueue %p (rc=%d)", a1, v4);
  return Mutable;
}

__CFString *fsaq_CopyDebugDesc(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v2, 0);
  subaq_appendDebugDesc(Mutable, a1);
  return Mutable;
}

void subaq_deferringAQPropertyListenerHandler(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = FigCFWeakReferenceTableCopyValue();
  if (v4)
  {
    CFStringRef v5 = (const void *)v4;
    uint64_t v6 = MEMORY[0x19970C720](v4 + 16);
    if (v6)
    {
      double v7 = (dispatch_queue_t *)v6;
      if (!*(unsigned char *)(v6 + 16) && subaq_lockListenerBarrierForValidSubAQ((uint64_t)v5))
      {
        double v8 = malloc_type_malloc(0x18uLL, 0x1020040EDCEB4C7uLL);
        if (v8)
        {
          uint64_t v9 = v8;
          *double v8 = CFRetain(v7);
          v9[1] = CFRetain(v5);
          *((_DWORD *)v9 + 4) = a3;
          dispatch_async_f(v7[5], v9, (dispatch_function_t)subaq_deferredAQPropertyListenerHandler);
        }
        FigReadWriteLockUnlockForRead();
      }
      CFRelease(v7);
    }
    CFRelease(v5);
  }
}

void subaq_startStopListener()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v6 = 0;
  UInt32 v7 = 4;
  uint64_t v0 = FigCFWeakReferenceTableCopyValue();
  if (v0)
  {
    uint64_t v1 = v0;
    uint64_t v2 = MEMORY[0x19970C720](v0 + 16);
    if (v2)
    {
      uint64_t v3 = v2;
      if (subaq_lockListenerBarrierForValidSubAQ(v1))
      {
        if (!FigAudioQueueTimingShimGetProperty(*(void *)(v1 + 40), 0x6171726Eu, &v6, &v7))
        {
          if (v6)
          {
            if (dword_1E9350B70)
            {
              os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
            subaq_startListener(v3, v1);
          }
          else
          {
            if (dword_1E9350B70)
            {
              CFStringRef v5 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
            if (!*(unsigned char *)(v3 + 16))
            {
              CFRetain(*(CFTypeRef *)(v1 + 24));
              dispatch_async_f(*(dispatch_queue_t *)(v3 + 32), *(void **)(v1 + 24), (dispatch_function_t)subaq_stopListenerInternal);
            }
          }
        }
        FigReadWriteLockUnlockForRead();
      }
      CFRelease((CFTypeRef)v3);
    }
    CFRelease((CFTypeRef)v1);
  }
}

uint64_t MTAudioProcessingTapDisposeAQTap(uint64_t a1, uint64_t a2)
{
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v7 = *(void *)(VTable + 16);
  uint64_t result = VTable + 16;
  uint64_t v6 = v7;
  if (v7) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 24);
  if (v9)
  {
    return v9(a1, a2);
  }
  return result;
}

uint64_t subaq_lockListenerBarrierForValidSubAQ(uint64_t a1)
{
  if (a1)
  {
    if (CFSetContainsValue((CFSetRef)gValidFigSubAudioQueueSet, (const void *)a1))
    {
      FigReadWriteLockLockForRead();
      a1 = 1;
    }
    else
    {
      a1 = 0;
    }
  }
  FigReadWriteLockUnlockForRead();
  return a1;
}

void subaq_deferredAQPropertyListenerHandler(void *a1)
{
  uint64_t v3 = *(void *)a1;
  uint64_t v2 = *((void *)a1 + 1);
  int v4 = *((_DWORD *)a1 + 4);
  if (v4 > 1769174127)
  {
    if (v4 > 1902406770)
    {
      if (v4 != 1902406771)
      {
        if (v4 == 1920233330) {
          goto LABEL_94;
        }
        goto LABEL_96;
      }
      values = 0;
      UInt32 valuePtr = 0;
      MEMORY[0x19970E290](*(void *)(v3 + 24));
      if (!*(unsigned char *)(v3 + 16))
      {
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v3 + 176));
        if (Count < 1)
        {
          uint64_t v19 = 0;
LABEL_69:
          if (v19 != (const void *)v2) {
            goto LABEL_78;
          }
        }
        else
        {
          CFIndex v17 = Count;
          CFIndex v18 = 0;
          while (1)
          {
            uint64_t v19 = *(unsigned char *)(v3 + 16) ? 0 : CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 176), v18);
            if (v19 == (const void *)v2) {
              break;
            }
            if (v17 == ++v18) {
              goto LABEL_69;
            }
          }
        }
        UInt32 valuePtr = 8;
        if (!FigAudioQueueTimingShimGetProperty(*(void *)(v2 + 40), 0x71646C73u, &values, &valuePtr))
        {
          long long v25 = values;
          *(void *)(v2 + 664) = values;
          if (*(unsigned char *)(v2 + 49) || (*(unsigned char *)(v3 + 49) & 0x20) != 0)
          {
            if (vabdd_f64(*(double *)(v2 + 656), *(double *)&v25) >= 0.02 || (*(unsigned char *)(v3 + 49) & 0x20) != 0)
            {
              *(void *)(v2 + 656) = v25;
              if (!*(unsigned char *)(v3 + 761))
              {
                CMNotificationCenterGetDefaultLocalCenter();
                CMNotificationCenterPostNotification();
              }
            }
          }
          else
          {
            *(void *)(v2 + 656) = v25;
          }
        }
      }
    }
    else if (v4 == 1769174128)
    {
      MEMORY[0x19970E290](*(void *)(v3 + 24));
      *(unsigned char *)(v3 + 578) = 1;
      *(unsigned char *)(v3 + 761) = 1;
    }
    else
    {
      if (v4 != 1902343781) {
        goto LABEL_96;
      }
      UInt32 v28 = 4;
      UInt32 valuePtr = 0;
      MEMORY[0x19970E290](*(void *)(v3 + 24));
      if (!*(unsigned char *)(v3 + 16))
      {
        CFIndex v5 = CFArrayGetCount(*(CFArrayRef *)(v3 + 176));
        if (v5 >= 1)
        {
          CFIndex v6 = v5;
          CFIndex v7 = 0;
          while (1)
          {
            uint64_t v8 = *(unsigned char *)(v3 + 16) ? 0 : CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 176), v7);
            if (v8 == (const void *)v2) {
              break;
            }
            if (v6 == ++v7) {
              goto LABEL_80;
            }
          }
          uint64_t v8 = (const void *)v2;
LABEL_80:
          if (v8
            && v8 == (const void *)v2
            && !FigAudioQueueTimingShimGetProperty(*(void *)(v2 + 40), 0x71637665u, &valuePtr, &v28))
          {
            MEMORY[0x19970E2B0](*(void *)(v3 + 24));
            if (valuePtr)
            {
              CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
              values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
              CFDictionaryRef v27 = CFDictionaryCreate(v26, (const void **)kFigAudioQueueNotificationParameter_ConverterError, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              CMNotificationCenterGetDefaultLocalCenter();
              CMNotificationCenterPostNotification();
              if (values) {
                CFRelease(values);
              }
              if (v27) {
                CFRelease(v27);
              }
            }
            goto LABEL_96;
          }
        }
      }
    }
LABEL_78:
    MEMORY[0x19970E2B0](*(void *)(v3 + 24));
    goto LABEL_96;
  }
  if (v4 > 1718383463)
  {
    if (v4 != 1718383464)
    {
      if (v4 == 1751410285) {
        goto LABEL_94;
      }
      goto LABEL_96;
    }
    MEMORY[0x19970E290](*(void *)(v3 + 24));
    if (*(unsigned char *)(v3 + 16)) {
      goto LABEL_91;
    }
    CFIndex v13 = CFArrayGetCount(*(CFArrayRef *)(v3 + 176));
    if (v13 < 1)
    {
      uint64_t v15 = 0;
LABEL_56:
      if (v15 != (const void *)v2) {
        goto LABEL_91;
      }
    }
    else
    {
      CFIndex v14 = 0;
      while (1)
      {
        uint64_t v15 = *(unsigned char *)(v3 + 16) ? 0 : CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 176), v14);
        if (v15 == (const void *)v2) {
          break;
        }
        if (v13 == ++v14) {
          goto LABEL_56;
        }
      }
    }
    int v20 = *(_DWORD *)(v2 + 612);
    if (v20)
    {
      int v21 = 0;
      int v22 = v20 - 1;
      *(_DWORD *)(v2 + 612) = v22;
      if (!*(unsigned char *)(v2 + 640) || v22)
      {
LABEL_92:
        MEMORY[0x19970E2B0](*(void *)(v3 + 24));
        if (v21 && *(void *)(v3 + 720)) {
          goto LABEL_94;
        }
        goto LABEL_96;
      }
      *(unsigned char *)(v2 + 640) = 0;
      if (v13 < 1)
      {
LABEL_54:
        MEMORY[0x19970E2B0](*(void *)(v3 + 24));
        CMNotificationCenterGetDefaultLocalCenter();
LABEL_95:
        CMNotificationCenterPostNotification();
        goto LABEL_96;
      }
      CFIndex v23 = 0;
      while (1)
      {
        long long v24 = *(unsigned char *)(v3 + 16) ? 0 : CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 176), v23);
        if (v24[641] == 1) {
          break;
        }
        if (v13 == ++v23) {
          goto LABEL_54;
        }
      }
      v24[641] = 0;
      if (*(unsigned char *)(v3 + 73) || (*(unsigned char *)(v3 + 48) & 2) != 0)
      {
        subaq_startSlavedAudioQueue(v3, (uint64_t)v24);
        subaq_stopAudioQueue(v3, v2, 0);
        int v21 = 1;
        goto LABEL_92;
      }
    }
LABEL_91:
    int v21 = 0;
    goto LABEL_92;
  }
  if (v4 == 1635020914)
  {
    MEMORY[0x19970E290](*(void *)(v3 + 24));
    if (!*(unsigned char *)(v3 + 16))
    {
      CFIndex v9 = CFArrayGetCount(*(CFArrayRef *)(v3 + 176));
      if (v9 >= 1)
      {
        CFIndex v10 = v9;
        CFIndex v11 = 0;
        while (1)
        {
          uint64_t v12 = *(unsigned char *)(v3 + 16) ? 0 : CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 176), v11);
          if (v12 == (const void *)v2) {
            goto LABEL_54;
          }
          if (v10 == ++v11) {
            goto LABEL_53;
          }
        }
      }
      uint64_t v12 = 0;
LABEL_53:
      if (v12 == (const void *)v2) {
        goto LABEL_54;
      }
    }
    goto LABEL_78;
  }
  if (v4 == 1685288048)
  {
LABEL_94:
    CMNotificationCenterGetDefaultLocalCenter();
    goto LABEL_95;
  }
LABEL_96:
  CFRelease((CFTypeRef)v3);
  CFRelease((CFTypeRef)v2);
  free(a1);
}

uint64_t subaq_startSlavedAudioQueue(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = (unsigned char *)result;
    if (!*(unsigned char *)(result + 16))
    {
      *(unsigned char *)(a2 + 546) = 1;
      *(void *)(a2 + 552) = 0;
      faq_enqueueSourceData(result, 0);
      if (((v2[48] & 2) != 0 || (v2[640] & 2) != 0)
        && faq_isSubAudioQueueInList((uint64_t)v2, (const void *)a2))
      {
        BOOL v4 = v2[581] != 0;
        if (!v2[16])
        {
          if (*(void *)(a2 + 600))
          {
            uint64_t result = subaq_setTapTimelineInfo((uint64_t)v2, a2);
            if (result) {
              return result;
            }
            *(unsigned char *)(a2 + 609) = 1;
          }
          v2[580] = 1;
          v2[581] = v4;
        }
        return subaq_startAudioQueueIfReady((uint64_t)v2, a2);
      }
      else
      {
        return FigSignalErrorAt();
      }
    }
  }
  return result;
}

uint64_t subaq_stopAudioQueue(uint64_t result, uint64_t a2, Boolean a3)
{
  if (result)
  {
    if (*(unsigned char *)(result + 16))
    {
      return 0;
    }
    else
    {
      if (dword_1E9350B70)
      {
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      return FigAudioQueueTimingShimStop(*(void *)(a2 + 40), a3);
    }
  }
  return result;
}

uint64_t faq_isSubAudioQueueInList(uint64_t result, const void *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(unsigned char *)(result + 16)) {
      return 0;
    }
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(result + 176));
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      CFIndex v5 = Count;
      CFIndex v6 = 0;
      while (1)
      {
        CFIndex v7 = *(unsigned char *)(v2 + 16) ? 0 : CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 176), v6);
        if (v7 == a2) {
          break;
        }
        if (v5 == ++v6) {
          return 0;
        }
      }
      return 1;
    }
  }
  return result;
}

void subaq_startListener(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && !*(unsigned char *)(a1 + 16))
  {
    CFRetain(*(CFTypeRef *)(a2 + 24));
    BOOL v4 = *(NSObject **)(a1 + 32);
    CFIndex v5 = *(void **)(a2 + 24);
    dispatch_async_f(v4, v5, (dispatch_function_t)subaq_startListenerInternal);
  }
}

void subaq_startListenerInternal(const void *a1)
{
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = MEMORY[0x19970C720](v2 + 16);
    if (v4)
    {
      uint64_t v5 = v4;
      MEMORY[0x19970E290](*(void *)(v4 + 24));
      if (*(unsigned char *)(v5 + 16)) {
        goto LABEL_20;
      }
      *(unsigned char *)(v3 + 689) = 1;
      float v6 = *(float *)(v3 + 692);
      if (v6 > 0.0)
      {
        FigAudioQueueTimingShimSetParameter(*(void *)(v3 + 40), 4u, v6);
        FigAudioQueueTimingShimSetParameter(*(void *)(v3 + 40), 1u, *(AudioQueueParameterValue *)(v3 + 696));
        *(_DWORD *)(v3 + 692) = 0;
        *(_DWORD *)(v5 + 200) = *(_DWORD *)(v3 + 696);
        *(unsigned char *)(v5 + 204) = 1;
      }
      float v7 = *(float *)(v3 + 700);
      if (v7 > 0.0)
      {
        FigAudioQueueTimingShimSetParameter(*(void *)(v3 + 40), 6u, v7);
        FigAudioQueueTimingShimSetParameter(*(void *)(v3 + 40), 5u, *(AudioQueueParameterValue *)(v3 + 704));
        *(_DWORD *)(v3 + 700) = 0;
        *(_DWORD *)(v5 + 208) = *(_DWORD *)(v3 + 704);
        *(unsigned char *)(v5 + 212) = 1;
      }
      if ((*(unsigned char *)(v5 + 48) & 2) != 0)
      {
LABEL_20:
        MEMORY[0x19970E2B0](*(void *)(v5 + 24));
      }
      else
      {
        MEMORY[0x19970E2B0](*(void *)(v5 + 24));
        if (*(unsigned char *)(v3 + 560))
        {
          CMTime v16 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
          subaq_getAudioQueueLatencyFigTime(v5, v3, &v16);
          CMTime v15 = v16;
          double Seconds = CMTimeGetSeconds(&v15);
          double v9 = 1.0;
          if (*(unsigned char *)(v5 + 236))
          {
            float v10 = *(float *)(v5 + 232);
            BOOL v11 = v10 == 0.0;
            double v9 = v10;
            if (v11) {
              double v9 = 1.0;
            }
          }
          if (Seconds * v9 <= 1.0)
          {
            subaq_performStartupSync(v5, v3);
          }
          else
          {
            double v12 = Seconds + -1.0 / v9;
            CFRetain(*(CFTypeRef *)(v3 + 24));
            *(unsigned char *)(v3 + 688) = 1;
            CFIndex v13 = *(NSObject **)(v3 + 680);
            dispatch_time_t v14 = dispatch_time(0, (uint64_t)(v12 * 1000000000.0));
            dispatch_source_set_timer(v13, v14, 0xFFFFFFFFFFFFFFFFLL, 0);
          }
        }
        *(unsigned char *)(v3 + 48) = 1;
        *(unsigned char *)(v3 + 50) = 1;
        CFRetain(*(CFTypeRef *)(v3 + 24));
        dispatch_async_f(*(dispatch_queue_t *)(v5 + 32), *(void **)(v3 + 24), (dispatch_function_t)subaq_stopAudioQueueIfObsolete);
      }
      CFRelease((CFTypeRef)v5);
    }
    CFRelease((CFTypeRef)v3);
  }
  CFRelease(a1);
}

void subaq_performStartupSync(uint64_t a1, uint64_t a2)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  long long v38 = 0u;
  memset(v37, 0, sizeof(v37));
  *(_OWORD *)&v36.unsigned int value = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v2 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  v36.CMTimeEpoch epoch = v2;
  long long v32 = *(_OWORD *)&v36.value;
  *(_OWORD *)&v35.unsigned int value = *(_OWORD *)&v36.value;
  v35.CMTimeEpoch epoch = v2;
  if (!a1
    || *(unsigned char *)(a1 + 16)
    || !*(unsigned char *)(a1 + 576)
    || FigAudioQueueTimingShimWaitForStartup(*(void *)(a2 + 40)))
  {
    return;
  }
  DWORD2(v38) = 3;
  int CurrentTime = FigAudioQueueTimingShimGetCurrentTime(*(CMTime **)(a2 + 40), 0, 1, v37, 0);
  float v6 = (CMTime *)MEMORY[0x1E4F1FA48];
  if (!CurrentTime)
  {
    if (BYTE8(v38))
    {
      CMTimeMake(&v36, (uint64_t)(*(double *)v37 + 0.5), *(_DWORD *)(a2 + 100));
      if ((BYTE8(v38) & 2) == 0) {
        goto LABEL_11;
      }
    }
    else
    {
      CMTime v36 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      if ((BYTE8(v38) & 2) == 0) {
        goto LABEL_11;
      }
    }
    int64_t v7 = FigHostTimeToNanoseconds();
    CMTimeMake(&v35, v7, 1000000000);
    goto LABEL_12;
  }
  DWORD2(v38) = 0;
  CMTime v36 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
LABEL_11:
  CMClockRef HostTimeClock = CMClockGetHostTimeClock();
  CMClockGetTime(&hostTime, HostTimeClock);
  CMTime v35 = hostTime;
LABEL_12:
  if ((*(unsigned char *)(a1 + 640) & 2) == 0)
  {
    memset(&v44, 0, sizeof(v44));
    CMTime lhs = v36;
    CMTime v43 = v35;
    CMTime rhs = *(CMTime *)(a1 + 432);
    CMTimeSubtract(&hostTime, &lhs, &rhs);
    CMTime lhs = v43;
    CMTime rhs = hostTime;
    CMTimeSubtract(&v44, &lhs, &rhs);
    CMTime hostTime = v44;
    *(void *)(a1 + 592) = CMClockConvertHostTimeToSystemUnits(&hostTime);
    *(_DWORD *)(a1 + 640) = 2;
  }
  if (!*(void *)(a1 + 384) && !*(void *)(a1 + 400)) {
    goto LABEL_39;
  }
  if (*(unsigned char *)(a1 + 236))
  {
    float v9 = *(float *)(a1 + 232);
    float v10 = *(float *)(a1 + 416);
    double v11 = 1.0;
    if (v10 == 0.0) {
      double v12 = 1.0;
    }
    else {
      double v12 = v10;
    }
    if (v9 != 0.0) {
      double v11 = v9;
    }
  }
  else
  {
    float v13 = *(float *)(a1 + 416);
    double v11 = 1.0;
    if (v13 == 0.0) {
      double v12 = 1.0;
    }
    else {
      double v12 = v13;
    }
  }
  CMTime v33 = v36;
  *(_OWORD *)&hostTime.unsigned int value = v32;
  hostTime.CMTimeEpoch epoch = v2;
  memset(&lhs, 0, sizeof(lhs));
  memset(&rhs, 0, sizeof(rhs));
  memset(&v44, 0, sizeof(v44));
  memset(&v43, 0, sizeof(v43));
  double v14 = v12 / v11;
  memset(&v42, 0, sizeof(v42));
  memset(&v34, 0, sizeof(v34));
  subaq_getAudioQueueLatencyFigTime(a1, a2, &hostTime);
  if ((hostTime.flags & 1) == 0) {
    CMTime hostTime = *v6;
  }
  CMTime time = hostTime;
  CMTimeMultiplyByFloat64(&lhs, &time, v11);
  CMTime time = v33;
  CMTime v40 = lhs;
  CMTimeSubtract(&rhs, &time, &v40);
  CMTime time = rhs;
  CMTime v40 = *(CMTime *)(a1 + 432);
  CMTimeSubtract(&v44, &time, &v40);
  faqTimelineWrangler_getAQTimePauseOffset(a1 + 424, &time);
  CMTime v40 = v44;
  CMTimeAdd(&v43, &v40, &time);
  CMTime v40 = v43;
  CMTime v39 = *(CMTime *)(a1 + 456);
  CMTimeAdd(&v42, &v40, &v39);
  CMTime v40 = v42;
  faqTimelineWrangler_convertAQTimeToMediaTime(a1 + 424, &v40, (uint64_t)&v34, v14);
  if (dword_1E9350B70)
  {
    LODWORD(rhs.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(v44.CFDictionarySetValue(theDict, key, value) = 0;
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int value = rhs.value;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, v44.value)) {
      unsigned int v17 = value;
    }
    else {
      unsigned int v17 = value & 0xFFFFFFFE;
    }
    if (v17)
    {
      CMTime hostTime = v36;
      Float64 Seconds = CMTimeGetSeconds(&hostTime);
      CMTime hostTime = v34;
      Float64 v19 = CMTimeGetSeconds(&hostTime);
      CMTime hostTime = v35;
      Float64 v20 = CMTimeGetSeconds(&hostTime);
      LODWORD(lhs.CFDictionarySetValue(theDict, key, value) = 136316674;
      *(CMTimeValue *)((char *)&lhs.value + 4) = (CMTimeValue)"subaq_performStartupSync";
      LOWORD(lhs.flags) = 2048;
      *(void *)((char *)&lhs.flags + 2) = a1;
      HIWORD(lhs.epoch) = 2048;
      uint64_t v47 = a2;
      __int16 v48 = 2082;
      uint64_t v49 = a1 + 776;
      __int16 v50 = 2048;
      Float64 v51 = Seconds;
      __int16 v52 = 2048;
      Float64 v53 = v19;
      __int16 v54 = 2048;
      Float64 v55 = v20;
      _os_log_send_and_compose_impl();
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  int v21 = (void (**)(uint64_t, void, CMTime *, CMTime *, float))(a1 + 384);
  if (*MEMORY[0x1E4F1EBA8] == 1)
  {
    CMTime hostTime = v36;
    CMTimeGetSeconds(&hostTime);
    CMTime hostTime = v34;
    CMTimeGetSeconds(&hostTime);
    CMTime hostTime = v35;
    CMTimeGetSeconds(&hostTime);
    kdebug_trace();
  }
  int v22 = *v21;
  if (!*v21)
  {
    if (!*(void *)(a1 + 400)) {
      goto LABEL_39;
    }
    int v21 = (void (**)(uint64_t, void, CMTime *, CMTime *, float))(a1 + 408);
    if (*(void *)(a1 + 408))
    {
      uint64_t v27 = FigCFWeakReferenceHolderCopyReferencedObject();
      uint64_t v28 = v27;
      if (*v21 && !v27) {
        goto LABEL_53;
      }
    }
    else
    {
      uint64_t v28 = 0;
    }
    long long v29 = *(void (**)(uint64_t, void, CMTime *, CMTime *, float))(a1 + 400);
    float v30 = *(float *)(a1 + 416);
    CMTime hostTime = v34;
    CMTime lhs = v35;
    v29(v28, 0, &hostTime, &lhs, v30);
LABEL_53:
    FigDeferCFRelease();
    *(void *)(a1 + 400) = 0;
    long long v31 = *(const void **)(a1 + 408);
    if (!v31) {
      goto LABEL_39;
    }
    CFRelease(v31);
    goto LABEL_38;
  }
  uint64_t v23 = *(void *)(a1 + 392);
  float v24 = *(float *)(a1 + 416);
  CMTime hostTime = v34;
  CMTime lhs = v35;
  v22(v23, 0, &hostTime, &lhs, v24);
LABEL_38:
  *int v21 = 0;
LABEL_39:
  MEMORY[0x19970E290](*(void *)(a1 + 24));
  *(unsigned char *)(a2 + 48) = 1;
  if (*(unsigned char *)(a1 + 576))
  {
    *(unsigned char *)(a1 + 576) = 0;
    *(unsigned char *)(a1 + 73) = 1;
  }
  MEMORY[0x19970E2B0](*(void *)(a1 + 24));
  FigSemaphoreSignal();
  long long v25 = *(const void **)(a2 + 24);
  if (v25)
  {
    CFRetain(v25);
    CFAllocatorRef v26 = *(void **)(a2 + 24);
  }
  else
  {
    CFAllocatorRef v26 = 0;
  }
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 32), v26, (dispatch_function_t)faq_startObsoleteAudioQueues);
}

void subaq_stopAudioQueueIfObsolete(const void *a1)
{
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v2)
  {
    uint64_t v3 = (CFArrayRef *)v2;
    uint64_t v4 = MEMORY[0x19970C720](v2 + 16);
    if (v4)
    {
      uint64_t v5 = v4;
      MEMORY[0x19970E290](*(void *)(v4 + 24));
      if (*(unsigned char *)(v5 + 16) || !faq_isSubAudioQueueObsolete((CFArrayRef *)v5, v3))
      {
        int v6 = 0;
      }
      else
      {
        subaq_stopAudioQueue(v5, (uint64_t)v3, 0);
        int v6 = 1;
      }
      MEMORY[0x19970E2B0](*(void *)(v5 + 24));
      if (v6 && *(void *)(v5 + 720))
      {
        CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterPostNotification();
      }
      CFRelease((CFTypeRef)v5);
    }
    CFRelease(v3);
  }

  CFRelease(a1);
}

void faq_startObsoleteAudioQueues(const void *a1)
{
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v2)
  {
    uint64_t v3 = (unsigned char *)v2;
    uint64_t v4 = MEMORY[0x19970C720](v2 + 16);
    if (v4)
    {
      uint64_t v5 = v4;
      MEMORY[0x19970E290](*(void *)(v4 + 24));
      if (!*(unsigned char *)(v5 + 16))
      {
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v5 + 176));
        if (Count >= 1)
        {
          CFIndex v7 = Count;
          for (CFIndex i = 0; i != v7; ++i)
          {
            if (*(unsigned char *)(v5 + 16)) {
              CFDictionaryRef ValueAtIndex = 0;
            }
            else {
              CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v5 + 176), i);
            }
            if (ValueAtIndex != v3 && !ValueAtIndex[641]) {
              subaq_startSlavedAudioQueue(v5, (uint64_t)ValueAtIndex);
            }
          }
        }
      }
      MEMORY[0x19970E2B0](*(void *)(v5 + 24));
      CFRelease(v3);
    }
    else
    {
      uint64_t v5 = (uint64_t)v3;
    }
    CFRelease((CFTypeRef)v5);
  }

  CFRelease(a1);
}

__n128 faqTimelineWrangler_getAQTimePauseOffset@<Q0>(uint64_t a1@<X0>, CMTime *a2@<X8>)
{
  if ((*(_DWORD *)(a1 + 68) & 0x1D) == 1)
  {
    CMTime lhs = *(CMTime *)(a1 + 56);
    CMTime v4 = *(CMTime *)(a1 + 32);
    CMTimeSubtract(a2, &lhs, &v4);
  }
  else
  {
    uint64_t v3 = MEMORY[0x1E4F1FA48];
    __n128 result = *(__n128 *)MEMORY[0x1E4F1FA48];
    *(_OWORD *)&a2->unsigned int value = *MEMORY[0x1E4F1FA48];
    a2->CMTimeEpoch epoch = *(void *)(v3 + 16);
  }
  return result;
}

CMTime *faqTimelineWrangler_convertAQTimeToMediaTime@<X0>(uint64_t a1@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  CMTime lhs = *a2;
  CMTime rhs = *(CMTime *)(a1 + 32);
  CMTimeSubtract(&v11, &lhs, &rhs);
  CMTime rhs = v11;
  CMTimeMultiplyByFloat64(&lhs, &rhs, fabs(a4));
  CMTime rhs = *(CMTime *)(a1 + 104);
  CMTime v8 = lhs;
  if (a4 <= 0.0) {
    return CMTimeSubtract((CMTime *)a3, &rhs, &v8);
  }
  else {
    return CMTimeAdd((CMTime *)a3, &rhs, &v8);
  }
}

BOOL faq_isSubAudioQueueObsolete(CFArrayRef *ValueAtIndex, CFArrayRef *a2)
{
  uint64_t v3 = (uint64_t)ValueAtIndex;
  if (ValueAtIndex)
  {
    if (*((unsigned char *)ValueAtIndex + 16)) {
      CFDictionaryRef ValueAtIndex = 0;
    }
    else {
      CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(ValueAtIndex[22], 0);
    }
  }
  return ValueAtIndex != a2 && faq_isSubAudioQueueInList(v3, a2) != 0;
}

void subaq_stopListenerInternal(const void *a1)
{
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = MEMORY[0x19970C720](v2 + 16);
    if (v4)
    {
      uint64_t v5 = v4;
      MEMORY[0x19970E290](*(void *)(v4 + 24));
      if (!*(unsigned char *)(v5 + 16))
      {
        *(unsigned char *)(v3 + 689) = 0;
        subaq_removeIfObsolete(v5, (CFArrayRef *)v3);
      }
      MEMORY[0x19970E2B0](*(void *)(v5 + 24));
      CFRelease((CFTypeRef)v5);
    }
    CFRelease((CFTypeRef)v3);
  }

  CFRelease(a1);
}

void subaq_removeIfObsolete(uint64_t a1, CFArrayRef *a2)
{
  MEMORY[0x19970E290](*(void *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 16) && faq_isSubAudioQueueObsolete((CFArrayRef *)a1, a2))
  {
    if (a2)
    {
      if (!*(unsigned char *)(a1 + 16))
      {
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176));
        if (Count >= 1)
        {
          CFIndex v5 = Count;
          CFIndex v6 = 0;
          while (1)
          {
            CFIndex v7 = *(unsigned char *)(a1 + 16) ? 0 : (CFArrayRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), v6);
            if (v7 == a2) {
              break;
            }
            if (v5 == ++v6) {
              goto LABEL_15;
            }
          }
          if (!*(unsigned char *)(a1 + 16)) {
            CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 176), v6);
          }
        }
      }
    }
  }
LABEL_15:

  JUMPOUT(0x19970E2B0);
}

void subaq_appendDebugDesc(__CFString *a1, CFTypeRef cf)
{
  CFIndex v4 = CFGetRetainCount(cf);
  uint64_t v5 = *((void *)cf + 8);
  CFStringAppendFormat(a1, 0, @"(SubAQ %p retainCount:%d -> AQTS %p %.0f Hz '%c%c%c%c')\n", cf, v4, *((void *)cf + 5), *(void *)v5, HIBYTE(*(_DWORD *)(v5 + 8)), BYTE2(*(_DWORD *)(v5 + 8)), BYTE1(*(_DWORD *)(v5 + 8)), *(_DWORD *)(v5 + 8));
}

void subaq_outputBufferBecameReady(uint64_t a1, uint64_t a2, AudioQueueBuffer *a3)
{
  if (a3)
  {
    uint64_t v4 = FigCFWeakReferenceHolderCopyReferencedObject();
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = MEMORY[0x19970C720](v4 + 16);
      if (v6)
      {
        CFIndex v7 = (const void *)v6;
        if (!*(unsigned char *)(v6 + 16))
        {
          mUserCFDataRef Data = (uint64_t)a3->mUserData;
          if (mUserData)
          {
            if (*(void *)(mUserData + 8))
            {
              CMNotificationCenterGetDefaultLocalCenter();
              CMNotificationCenterPostNotification();
              float v9 = *(const void **)(mUserData + 8);
              if (v9)
              {
                CFRelease(v9);
                *(void *)(mUserData + 8) = 0;
              }
            }
            float v10 = *(opaqueCMSampleBuffer **)mUserData;
            if (*(void *)mUserData)
            {
              memset(&v16, 0, sizeof(v16));
              CMSampleBufferGetOutputDuration(&v16, v10);
              MEMORY[0x19970E910](*(void *)(v5 + 536));
              CMSampleBufferGetOutputPresentationTimeStamp(&lhs, *(CMSampleBufferRef *)mUserData);
              CMTime rhs = v16;
              CMTimeAdd(&time, &lhs, &rhs);
              *(CMTime *)(v5 + 508) = time;
              MEMORY[0x19970E930](*(void *)(v5 + 536));
              FigAtomicAdd32();
              int32_t v11 = *(_DWORD *)(v5 + 100);
              CMTime time = v16;
              CMTimeConvertScale(&v12, &time, v11, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
              FigAtomicAdd32();
              if (*(void *)mUserData)
              {
                CFRelease(*(CFTypeRef *)mUserData);
                *(void *)mUserCFDataRef Data = 0;
              }
            }
            if (*(unsigned char *)(mUserData + 17))
            {
              subaq_returnAQBufferInfoPtr(v5, mUserData);
              FigAudioQueueTimingShimFreeBuffer(*(void *)(v5 + 40), a3);
            }
            else
            {
              a3->mAudioDataByteSize = 0;
              FigMemoryBarrier();
              a3->mUserCFDataRef Data = 0;
              subaq_returnAQBufferInfoPtr(v5, mUserData);
            }
            FigSemaphoreSignal();
          }
        }
        CFRelease(v7);
      }
      CFRelease((CFTypeRef)v5);
    }
  }
}

uint64_t subaq_buildAudioProcssingUnits(uint64_t a1, uint64_t *a2)
{
  unsigned int value = 0;
  CFArrayRef v3 = *(const __CFArray **)(a1 + 688);
  if (!v3)
  {
LABEL_24:
    uint64_t v16 = 0;
    goto LABEL_25;
  }
  CFIndex Count = CFArrayGetCount(v3);
  CFIndex v6 = Count;
  if ((Count & 1) == 0)
  {
    if (Count >= 1)
    {
      CFIndex v7 = 0;
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      float v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      float v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      while (1)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 688), v7);
        CFIndex v12 = v7 + 1;
        CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 688), v12);
        if (FigCFDictionaryGetValueIfPresent())
        {
          if (FigCFDictionaryGetValueIfPresent()) {
            CFDictionaryApplyFunction(0, (CFDictionaryApplierFunction)subaq_audioProcessingUnitSetPropertyApplier, 0);
          }
        }
        else
        {
          if (*(unsigned char *)(a1 + 16)
            || CFArrayGetCount(*(CFArrayRef *)(a1 + 176)) < 1
            || (*(unsigned char *)(a1 + 16)
              ? (float v13 = 0)
              : (float v13 = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0)),
                v13 == a2 || !FigCFDictionaryGetValueIfPresent()))
          {
            uint64_t v14 = FigAudioProcessingUnitCreateWithOptions((uint64_t)v8, a1, (uint64_t)a2, a2[5]);
            if (v14) {
              goto LABEL_29;
            }
          }
          else
          {
            uint64_t v14 = FigAudioProcessingUnitCreateCopy((uint64_t)v8, (const void *)a1, a2, (const void *)a2[5], 0, &value);
            if (v14) {
              goto LABEL_29;
            }
          }
          CFMutableStringRef Mutable = (__CFDictionary *)a2[89];
          if (!Mutable)
          {
            CFMutableStringRef Mutable = CFDictionaryCreateMutable(v8, 0, v9, v10);
            a2[89] = (uint64_t)Mutable;
            if (!Mutable) {
              goto LABEL_28;
            }
          }
          CFDictionarySetValue(Mutable, ValueAtIndex, value);
          if (value)
          {
            CFRelease(value);
            unsigned int value = 0;
          }
        }
        CFIndex v7 = v12 + 1;
        if (v7 >= v6) {
          goto LABEL_24;
        }
      }
    }
    goto LABEL_24;
  }
LABEL_28:
  uint64_t v14 = FigSignalErrorAt();
LABEL_29:
  uint64_t v16 = v14;
LABEL_25:
  if (value) {
    CFRelease(value);
  }
  return v16;
}

uint64_t subaq_setCPECryptorPropertyOnAudioQueue(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a2 + 40);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 56);
  if (!v4) {
    return 0;
  }
  int v8 = 1668310371;
  uint64_t v9 = v4;
  uint64_t v5 = FigAudioQueueTimingShimSetProperty(v3, 0x61637064u, &v8, 0xCu);
  unsigned int v10 = v5;
  if (dword_1E9350B70)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    return v10;
  }
  return v5;
}

uint64_t subaq_returnAQBufferInfoPtr(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    if (*(void *)a2)
    {
      CFRelease(*(CFTypeRef *)a2);
      *(void *)a2 = 0;
    }
    uint64_t v4 = *(const void **)(a2 + 8);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(a2 + 8) = 0;
    }
    MEMORY[0x19970E910](*(void *)(v3 + 136));
    *(unsigned char *)(a2 + 16) = 0;
    JUMPOUT(0x19970E930);
  }
  return result;
}

uint64_t subaq_setSweepFilterEnable(uint64_t result, uint64_t a2, int a3)
{
  BOOL v6 = a3 != 0;
  if (result)
  {
    uint64_t v3 = result;
    if (*(unsigned char *)(result + 16)) {
      return 0;
    }
    __n128 result = FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x656E7366u, &v6, 4u);
    if (a3 && !result)
    {
      if (*(void *)(v3 + 704)) {
        return subaq_setSweepFilterConfig(v3, a2);
      }
      return 0;
    }
  }
  return result;
}

uint64_t subaq_ensureCinematicAudioEnabled(uint64_t result, uint64_t a2, int a3)
{
  if (!a3 && *(unsigned char *)(a2 + 720) && !*(unsigned char *)(a2 + 721))
  {
    uint64_t v4 = result;
    int v5 = 1;
    __n128 result = FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x715F6361u, &v5, 4u);
    if (!result)
    {
      *(unsigned char *)(v4 + 768) = 1;
      *(unsigned char *)(a2 + 721) = 1;
    }
  }
  return result;
}

uint64_t subaq_setSweepFilterConfig(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (*(unsigned char *)(result + 16))
    {
      return 0;
    }
    else
    {
      __n128 result = *(void *)(result + 704);
      if (result)
      {
        int v4 = 0;
        uint64_t v3 = 0;
        __n128 result = FigCFDictionaryGetFloat32IfPresent();
        if (!result)
        {
          __n128 result = FigCFDictionaryGetFloat32IfPresent();
          if (!result)
          {
            __n128 result = FigCFDictionaryGetFloat32IfPresent();
            if (!result) {
              return FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x73666367u, &v3, 0xCu);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t subaq_audioProcessingUnitSetPropertyApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v9 = *(void *)(VTable + 8);
  uint64_t result = VTable + 8;
  uint64_t v8 = v9;
  if (v9) {
    uint64_t v10 = v8;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 56);
  if (v11)
  {
    return v11(a3, a1, a2);
  }
  return result;
}

uint64_t faq_enqueueSourceDataThread(uint64_t a1)
{
  do
  {
    FigSemaphoreWaitRelative();
    if (*(unsigned char *)(a1 + 304)) {
      break;
    }
    faq_enqueueSourceData(a1, 1);
  }
  while (!*(unsigned char *)(a1 + 304));
  return 0;
}

void faq_initializeTapCompleted(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  MEMORY[0x19970E290](*(void *)(a2 + 24));
  if (!*(unsigned char *)(a2 + 16))
  {
    MTAudioProcessingTapGetPointerFromCFDictionary(@"AQTapPointer", a5);
    *(unsigned char *)(a2 + 744) = 1;
    if (!*(unsigned char *)(a2 + 16))
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 176));
      if (Count >= 1)
      {
        CFIndex v8 = Count;
        for (CFIndex i = 0; i != v8; ++i)
        {
          if (*(unsigned char *)(a2 + 16)) {
            CFDictionaryRef ValueAtIndex = 0;
          }
          else {
            CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 176), i);
          }
          subaq_startAudioQueueIfReady(a2, (uint64_t)ValueAtIndex);
        }
      }
    }
  }

  JUMPOUT(0x19970E2B0);
}

void faq_createAQTapCompleted(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  MEMORY[0x19970E290](*(void *)(a2 + 24));
  if (!*(unsigned char *)(a2 + 16))
  {
    CFNumberRef PointerFromCFDictionary = MTAudioProcessingTapGetPointerFromCFDictionary(@"AQTapPointer", a5);
    if (!*(unsigned char *)(a2 + 16))
    {
      CFNumberRef v8 = PointerFromCFDictionary;
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 176));
      if (Count >= 1)
      {
        CFIndex v10 = Count;
        CFIndex v11 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 176), v11);
          if ((const __CFNumber *)ValueAtIndex[75] == v8) {
            break;
          }
          if (v10 == ++v11) {
            goto LABEL_9;
          }
        }
        *((unsigned char *)ValueAtIndex + 608) = 1;
        subaq_startAudioQueueIfReady(a2, (uint64_t)ValueAtIndex);
      }
    }
  }
LABEL_9:

  JUMPOUT(0x19970E2B0);
}

void faq_scheduledWakeupRetainedToDiscard(_DWORD *a1)
{
  a1[19] = 0;
  faq_wakeupToDiscard((uint64_t)a1);

  CFRelease(a1);
}

void faq_dequeueFromSourceQueueAndDiscard()
{
  uint64_t v0 = (const void *)FigBufferQueueDequeueIfMatchingAndRetain();
  if (v0)
  {
    CFRelease(v0);
  }
}

BOOL subaq_doesAudioQueueHaveBuffersToFlush(uint64_t a1)
{
  memset(&v5, 0, sizeof(v5));
  if ((*(unsigned char *)(a1 + 444) & 1) == 0) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 628) & 1) == 0) {
    return 1;
  }
  CMTime lhs = *(CMTime *)(a1 + 432);
  CMTime v3 = *(CMTime *)(a1 + 456);
  CMTimeAdd(&v5, &lhs, &v3);
  CMTime lhs = *(CMTime *)(a1 + 616);
  CMTime v3 = v5;
  return CMTimeCompare(&lhs, &v3) != 0;
}

uint64_t subaq_flushAudioQueue(uint64_t result, uint64_t a2)
{
  if (!*(unsigned char *)(result + 16))
  {
    uint64_t v3 = result;
    uint64_t result = subaq_doesAudioQueueHaveBuffersToFlush(a2);
    if (result && !*(void *)(v3 + 160))
    {
      uint64_t result = FigAudioQueueTimingShimFlush(*(void *)(a2 + 40));
      if (!result)
      {
        CMTime lhs = *(CMTime *)(a2 + 432);
        CMTime v4 = *(CMTime *)(a2 + 456);
        uint64_t result = (uint64_t)CMTimeAdd(&v6, &lhs, &v4);
        *(CMTime *)(a2 + 616) = v6;
        ++*(_DWORD *)(a2 + 612);
      }
    }
    *(unsigned char *)(a2 + 544) = 1;
  }
  return result;
}

CMTime *subaq_convertAQTimeToMediaTime@<X0>(CMTime *result@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = MEMORY[0x1E4F1F9F8];
  *(_OWORD *)a3 = *MEMORY[0x1E4F1F9F8];
  *(void *)(a3 + 16) = *(void *)(v3 + 16);
  if (!LOBYTE(result->epoch))
  {
    float v4 = *(float *)&result[17].timescale;
    double v5 = 1.0;
    if (v4 == 0.0) {
      double v6 = 1.0;
    }
    else {
      double v6 = v4;
    }
    if (BYTE4(result[9].epoch))
    {
      float v7 = *(float *)&result[9].epoch;
      BOOL v8 = v7 == 0.0;
      double v5 = v7;
      if (v8) {
        double v5 = 1.0;
      }
    }
    CMTime v9 = *a2;
    return faqTimelineWrangler_convertAQTimeToMediaTime((uint64_t)&result[17].epoch, &v9, a3, v6 / v5);
  }
  return result;
}

CMTime *subaq_convertMediaTimeToAQTime@<X0>(CMTime *result@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = MEMORY[0x1E4F1F9F8];
  *(_OWORD *)a3 = *MEMORY[0x1E4F1F9F8];
  *(void *)(a3 + 16) = *(void *)(v3 + 16);
  if (!LOBYTE(result->epoch))
  {
    float v4 = *(float *)&result[17].timescale;
    double v5 = 1.0;
    if (v4 == 0.0) {
      double v6 = 1.0;
    }
    else {
      double v6 = v4;
    }
    if (BYTE4(result[9].epoch))
    {
      float v7 = *(float *)&result[9].epoch;
      BOOL v8 = v7 == 0.0;
      double v5 = v7;
      if (v8) {
        double v5 = 1.0;
      }
    }
    CMTime v9 = *a2;
    return faqTimelineWrangler_convertMediaTimeToAQTime((uint64_t)&result[17].epoch, &v9, a3, v6 / v5);
  }
  return result;
}

uint64_t subaq_schedulePlayRate2ValueForTime(uint64_t a1, uint64_t a2, CMTime *a3, double a4)
{
  unsigned int v16 = 21;
  float v4 = a4;
  float v15 = v4;
  uint64_t v14 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v11 = 0u;
  if (!*(void *)(a2 + 40) || *(unsigned char *)(a1 + 16)) {
    return 0;
  }
  int32_t v6 = *(_DWORD *)(a2 + 100);
  CMTime v8 = *a3;
  CMTimeConvertScale(&v9, &v8, v6, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
  double value = (double)v9.value;
  LODWORD(v14) = 1;
  return FigAudioQueueTimingShimScheduleParameters(*(void *)(a2 + 40), &value, 1u, &v16, &v15);
}

CMTime *faqTimelineWrangler_convertMediaTimeToAQTime@<X0>(uint64_t a1@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  memset(&v15, 0, sizeof(v15));
  memset(&v14, 0, sizeof(v14));
  float v7 = (_OWORD *)(a1 + 104);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (a4 >= 0.0)
  {
    CMTime lhs = *a2;
    *(_OWORD *)&rhs.double value = *v7;
    CMTimeEpoch epoch = *(void *)(a1 + 120);
  }
  else
  {
    *(_OWORD *)&lhs.double value = *v7;
    lhs.CMTimeEpoch epoch = *(void *)(a1 + 120);
    *(_OWORD *)&rhs.double value = *(_OWORD *)&a2->value;
    CMTimeEpoch epoch = a2->epoch;
  }
  rhs.CMTimeEpoch epoch = epoch;
  CMTimeSubtract(&v15, &lhs, &rhs);
  Float64 v9 = fabs(a4);
  CMTime lhs = *(CMTime *)(a1 + 32);
  CMTimeMultiplyByFloat64(&v14, &lhs, v9);
  CMTime lhs = v15;
  CMTime rhs = v15;
  CMTime v11 = v14;
  CMTimeAdd(&lhs, &rhs, &v11);
  CMTime rhs = lhs;
  return CMTimeMultiplyByFloat64((CMTime *)a3, &rhs, 1.0 / v9);
}

void subaq_audioQueueStartupCompleted(const void *a1, int a2)
{
  uint64_t v4 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v4)
  {
    double v5 = (void *)v4;
    uint64_t v6 = MEMORY[0x19970C720](v4 + 16);
    if (v6)
    {
      float v7 = (dispatch_queue_t *)v6;
      if (!*(unsigned char *)(v6 + 16) && subaq_lockListenerBarrierForValidSubAQ((uint64_t)v5))
      {
        CMTime v8 = malloc_type_malloc(0x18uLL, 0x1020040EDCEB4C7uLL);
        *CMTime v8 = CFRetain(v7);
        v8[1] = CFRetain(v5);
        *((_DWORD *)v8 + 4) = a2;
        dispatch_async_f(v7[4], v8, (dispatch_function_t)subaq_deferredAudioQueueStartupCompleted);
      }
      CFRelease(v5);
    }
    else
    {
      float v7 = (dispatch_queue_t *)v5;
    }
    CFRelease(v7);
  }

  CFRelease(a1);
}

void subaq_deferredAudioQueueStartupCompleted(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = *((unsigned int *)a1 + 4);
  MEMORY[0x19970E290](*(void *)(*a1 + 24));
  if (*(unsigned char *)(v3 + 16)) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = v4 == 0;
  }
  if (v6) {
    goto LABEL_15;
  }
  if (!*(unsigned char *)(v2 + 560))
  {
    subaq_removeIfObsolete(v3, (CFArrayRef *)v2);
    goto LABEL_11;
  }
  float v7 = *(void (**)(uint64_t, uint64_t, long long *, long long *, float))(v3 + 384);
  if (!v7)
  {
    if (!*(void *)(v3 + 400)) {
      goto LABEL_9;
    }
    CMTime v8 = (void *)(v3 + 408);
    if (*(void *)(v3 + 408))
    {
      uint64_t v14 = FigCFWeakReferenceHolderCopyReferencedObject();
      uint64_t v15 = v14;
      if (*v8) {
        BOOL v16 = v14 == 0;
      }
      else {
        BOOL v16 = 0;
      }
      if (v16) {
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    unsigned int v17 = *(void (**)(uint64_t, uint64_t, long long *, long long *, float))(v3 + 400);
    long long v21 = *MEMORY[0x1E4F1F9F8];
    uint64_t v22 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
    long long v19 = v21;
    uint64_t v20 = v22;
    v17(v15, v4, &v21, &v19, NAN);
LABEL_26:
    FigDeferCFRelease();
    *(void *)(v3 + 400) = 0;
    CFIndex v18 = *(const void **)(v3 + 408);
    if (!v18) {
      goto LABEL_9;
    }
    CFRelease(v18);
    goto LABEL_8;
  }
  CMTime v8 = (void *)(v3 + 384);
  uint64_t v9 = *(void *)(v3 + 392);
  long long v21 = *MEMORY[0x1E4F1F9F8];
  uint64_t v22 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  long long v19 = v21;
  uint64_t v20 = v22;
  v7(v9, v4, &v21, &v19, NAN);
LABEL_8:
  *CMTime v8 = 0;
LABEL_9:
  *(unsigned char *)(v3 + 305) = 0;
  *(unsigned char *)(v3 + 576) = 0;
  *(unsigned char *)(v3 + 745) = 0;
LABEL_11:
  if (*(unsigned char *)(v2 + 48))
  {
    LODWORD(v21) = 0;
    LODWORD(v19) = 4;
    int Property = FigAudioQueueTimingShimGetProperty(*(void *)(v2 + 40), 0x6171726Eu, &v21, (UInt32 *)&v19);
    if (!(Property | v21))
    {
      *(_WORD *)(v2 + 48) = 0;
      *(unsigned char *)(v2 + 50) = 0;
      if (*(unsigned char *)(v2 + 560))
      {
        uint64_t v11 = MEMORY[0x1E4F1F9F8];
        long long v12 = *MEMORY[0x1E4F1F9F8];
        *(_OWORD *)(v3 + 528) = *MEMORY[0x1E4F1F9F8];
        uint64_t v13 = *(void *)(v11 + 16);
        *(void *)(v3 + 544) = v13;
        *(_OWORD *)(v3 + 480) = v12;
        *(void *)(v3 + 496) = v13;
        v5.n128_f64[0] = faq_reset(v3, *(double *)&v12);
      }
    }
  }
LABEL_15:
  MEMORY[0x19970E2B0](*(void *)(v3 + 24), v5);
  FigReadWriteLockUnlockForRead();
  CFRelease((CFTypeRef)v3);
  CFRelease((CFTypeRef)v2);
  free(a1);
}

uint64_t subaq_setProperty(uint64_t a1, uint64_t a2, CFTypeRef cf1, const __CFString *a4)
{
  CFStringRef deviceUID = a4;
  if (!a2) {
    return 4294954356;
  }
  if (!a1 || *(unsigned char *)(a1 + 16)) {
    return 0;
  }
  if (!*(void *)(a2 + 40)) {
    return 4294954356;
  }
  uint64_t AQTap = (uint64_t)a4;
  if (CFEqual(cf1, @"EQPreset"))
  {
    if (AQTap)
    {
      CFTypeID TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID((CFTypeRef)AQTap))
      {
        int valuePtr = 0;
        CFNumberGetValue((CFNumberRef)AQTap, kCFNumberIntType, &valuePtr);
        if (!*(unsigned char *)(a1 + 16))
        {
          uint64_t AQTap = 0;
          int v9 = valuePtr;
          LODWORD(cf) = 0;
          UInt32 v50 = 4;
          UInt32 v51 = 0;
          if ((*(unsigned char *)(a1 + 48) & 4) != 0) {
            return AQTap;
          }
          if (valuePtr == -1)
          {
            int v10 = 0;
          }
          else
          {
            int v10 = 1;
            LODWORD(cf) = 1;
          }
          uint64_t Property = FigAudioQueueTimingShimGetProperty(*(void *)(a2 + 40), 0x715F6571u, &v51, &v50);
          if (!Property)
          {
            if (v10 == v51
              || (uint64_t AQTap = FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x715F6571u, &cf, v50), !AQTap)
              && cf)
            {
              uint64_t AQTap = FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 7u, (float)v9);
              if (AQTap)
              {
                if (cf != v51) {
                  FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x715F6571u, &v51, v50);
                }
              }
            }
            return AQTap;
          }
          return Property;
        }
        return 0;
      }
    }
    goto LABEL_94;
  }
  if (CFEqual(cf1, @"ClientName"))
  {
    if (AQTap)
    {
      CFTypeID v11 = CFStringGetTypeID();
      if (v11 == CFGetTypeID((CFTypeRef)AQTap))
      {
        uint64_t v12 = *(void *)(a2 + 40);
        p_CFStringRef deviceUID = (UInt32 *)&deviceUID;
        AudioQueuePropertyID v14 = 1668639076;
LABEL_25:
        UInt32 v17 = 8;
        return FigAudioQueueTimingShimSetProperty(v12, v14, p_deviceUID, v17);
      }
    }
    goto LABEL_94;
  }
  if (CFEqual(cf1, @"DeviceUID"))
  {
    if (!AQTap || (CFTypeID v15 = CFStringGetTypeID(), v15 == CFGetTypeID((CFTypeRef)AQTap)))
    {
      uint64_t AQTap = FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x61716364u, &deviceUID, 8u);
      if (!AQTap) {
        CMAudioDeviceClockSetAudioDeviceUID(*(CMClockRef *)(a2 + 576), deviceUID);
      }
      return AQTap;
    }
    goto LABEL_94;
  }
  if (CFEqual(cf1, @"ClockDevice"))
  {
    if (!AQTap || (CFTypeID v16 = CFStringGetTypeID(), v16 == CFGetTypeID((CFTypeRef)AQTap)))
    {
      uint64_t v12 = *(void *)(a2 + 40);
      p_CFStringRef deviceUID = (UInt32 *)&deviceUID;
      AudioQueuePropertyID v14 = 1902340964;
      goto LABEL_25;
    }
LABEL_94:
    return FigSignalErrorAt();
  }
  if (CFEqual(cf1, @"TimePitchAlgorithm"))
  {
    if (!AQTap) {
      goto LABEL_94;
    }
    CFTypeID v20 = CFStringGetTypeID();
    if (v20 != CFGetTypeID((CFTypeRef)AQTap)) {
      goto LABEL_94;
    }
    if (CFEqual((CFTypeRef)AQTap, @"TimeDomain"))
    {
      int v21 = 1953064047;
      goto LABEL_67;
    }
    if (CFEqual((CFTypeRef)AQTap, @"Spectral"))
    {
      int v21 = 1936745827;
      goto LABEL_67;
    }
    if (CFEqual((CFTypeRef)AQTap, @"Varispeed"))
    {
      int v21 = 1987276900;
      goto LABEL_67;
    }
    if (CFEqual((CFTypeRef)AQTap, @"LowQualityZeroLatency"))
    {
      int v21 = 1819376236;
LABEL_67:
      LODWORD(cf) = v21;
      if (*(_DWORD *)(a1 + 352) == v21) {
        return 0;
      }
      unsigned int v25 = FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x71747061u, &cf, 4u);
      if (v25 == -66630) {
        uint64_t AQTap = 0;
      }
      else {
        uint64_t AQTap = v25;
      }
      int v26 = (int)cf;
      *(_DWORD *)(a1 + 352) = cf;
      uint64_t v27 = faq_scaledEditRateSupportValidator_one32nd_to_32;
      if (v26 > 1953064046)
      {
        if (v26 != 1953064047)
        {
          int v28 = 1987276900;
LABEL_77:
          if (v26 != v28) {
            uint64_t v27 = faq_scaledEditRateSupportValidator_noScaleAllowed;
          }
        }
      }
      else
      {
        if (v26 != 1819376236)
        {
          int v28 = 1936745827;
          goto LABEL_77;
        }
        uint64_t v27 = faq_scaledEditRateSupportValidator_lowQualityZeroLatency;
      }
      *(void *)(a1 + 672) = v27;
      return AQTap;
    }
    return FigSignalErrorAt();
  }
  if (CFEqual(cf1, @"MATOriginalSourceFormat"))
  {
    if (AQTap)
    {
      CFTypeID v22 = CFNumberGetTypeID();
      if (v22 == CFGetTypeID((CFTypeRef)AQTap))
      {
        LODWORD(cf) = 0;
        CFNumberGetValue((CFNumberRef)AQTap, kCFNumberIntType, &cf);
        FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x6D6F7366u, &deviceUID, 4u);
        return 0;
      }
    }
    goto LABEL_94;
  }
  if (CFEqual(cf1, @"STSLabel"))
  {
    uint64_t v12 = *(void *)(a2 + 40);
    p_CFStringRef deviceUID = (UInt32 *)&deviceUID;
    AudioQueuePropertyID v14 = 1937011564;
    goto LABEL_25;
  }
  if (CFEqual(cf1, @"MXSession"))
  {
    if (!faq_shouldSetMXSessionOnAudioQueues()) {
      return 0;
    }
    uint64_t v23 = *(const void **)(a2 + 576);
    if (v23)
    {
      CFRelease(v23);
      *(void *)(a2 + 576) = 0;
    }
    subaq_ensureClock(a1, a2);
    uint64_t v12 = *(void *)(a2 + 40);
    p_CFStringRef deviceUID = (UInt32 *)&deviceUID;
    AudioQueuePropertyID v14 = 1668118643;
    goto LABEL_25;
  }
  if (CFEqual(cf1, @"TimePitchBypass"))
  {
    if ((*(unsigned char *)(a1 + 49) & 0x40) != 0) {
      goto LABEL_94;
    }
    if (!AQTap) {
      goto LABEL_94;
    }
    CFTypeID v24 = CFBooleanGetTypeID();
    if (v24 != CFGetTypeID((CFTypeRef)AQTap)) {
      goto LABEL_94;
    }
    LODWORD(cf) = *MEMORY[0x1E4F1CFD0] == AQTap;
    uint64_t v12 = *(void *)(a2 + 40);
    AudioQueuePropertyID v14 = 1903456354;
    goto LABEL_63;
  }
  if (CFEqual(cf1, @"EnableTimePitch"))
  {
    if ((*(unsigned char *)(a1 + 49) & 0x40) != 0) {
      goto LABEL_94;
    }
    if (!AQTap) {
      goto LABEL_94;
    }
    CFTypeID v29 = CFBooleanGetTypeID();
    if (v29 != CFGetTypeID((CFTypeRef)AQTap)) {
      goto LABEL_94;
    }
    CFStringRef v30 = (const __CFString *)*MEMORY[0x1E4F1CFD0];
    LODWORD(cf) = *MEMORY[0x1E4F1CFD0] == AQTap;
    uint64_t AQTap = FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x715F7470u, &cf, 4u);
    if (AQTap) {
      return AQTap;
    }
    if (deviceUID != v30) {
      return 0;
    }
    UInt32 v51 = *(_DWORD *)(a1 + 352);
    uint64_t v12 = *(void *)(a2 + 40);
    p_CFStringRef deviceUID = &v51;
    AudioQueuePropertyID v14 = 1903456353;
    goto LABEL_64;
  }
  if (CFEqual(cf1, @"TrackID"))
  {
    if (!AQTap) {
      return AQTap;
    }
    CFTypeID v31 = CFGetTypeID((CFTypeRef)AQTap);
    if (v31 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)AQTap, kCFNumberSInt32Type, (void *)(a2 + 588));
    }
    return 0;
  }
  if (CFEqual(cf1, @"AudioProcessingTap"))
  {
    if (!*(unsigned char *)(a2 + 48))
    {
      FigAudioQueueTimingShimStop(*(void *)(a2 + 40), 1u);
      uint64_t v33 = *(void *)(a2 + 600);
      if (v33)
      {
        MTAudioProcessingTapDisposeAQTap(*(void *)(a2 + 592), v33);
        CMTime v34 = *(const void **)(a2 + 592);
        if (v34)
        {
          CFRelease(v34);
          *(void *)(a2 + 592) = 0;
        }
        *(void *)(a2 + 600) = 0;
      }
      *(_WORD *)(a2 + 608) = 0;
      CMTime v35 = *(const void **)(a1 + 736);
      if (v35)
      {
        CFTypeRef v36 = CFRetain(v35);
        *(void *)(a2 + 592) = v36;
        uint64_t v37 = *(unsigned int *)(a2 + 588);
        uint64_t v38 = *(unsigned int *)(a1 + 772);
        uint64_t AudioQueue = FigAudioQueueTimingShimGetAudioQueue(*(void *)(a2 + 40));
        uint64_t AQTap = MTAudioProcessingTapCreateAQTap((uint64_t)v36, v37, v38, AudioQueue, a2 + 600);
        if (AQTap)
        {
          CMTime v40 = *(const void **)(a2 + 592);
          if (v40)
          {
            CFRelease(v40);
            *(void *)(a2 + 592) = 0;
          }
        }
        return AQTap;
      }
      return 0;
    }
    goto LABEL_94;
  }
  if (CFEqual(cf1, @"CinematicAudioParameters"))
  {
    if (!AQTap) {
      return AQTap;
    }
    CFTypeID v32 = CFGetTypeID((CFTypeRef)AQTap);
    if (v32 != CFDataGetTypeID()) {
      return 0;
    }
    return subaq_setCinematicAudioBulkParameters(a1, a2, (CFDataRef)AQTap);
  }
  if (CFEqual(cf1, @"LoudnessInfo"))
  {
    if (AQTap)
    {
      CFTypeID v41 = CFDictionaryGetTypeID();
      if (v41 != CFGetTypeID((CFTypeRef)AQTap)) {
        return FigSignalErrorAt();
      }
      CFTypeRef cf = CFRetain((CFTypeRef)AQTap);
    }
    else
    {
      CFTypeRef cf = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (!cf) {
        return FigSignalErrorAt();
      }
    }
    uint64_t AQTap = FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x716C646Eu, &cf, 8u);
    if (cf) {
      CFRelease(cf);
    }
    return AQTap;
  }
  if (CFEqual(cf1, @"AudioDynamicRangeCompression"))
  {
    LODWORD(cf) = -1;
    UInt32 v51 = 4;
    uint64_t Property = FigAudioQueueTimingShimGetProperty(*(void *)(a2 + 40), 0x7164796Eu, &cf, &v51);
    if (Property) {
      return Property;
    }
    if (!FigCFEqual())
    {
      if (FigCFEqual())
      {
        if (cf == 1)
        {
          LODWORD(cf) = 0;
          uint64_t Property = FigAudioQueueTimingShimSetProperty(*(void *)(a2 + 40), 0x7164796Eu, &cf, 4u);
          uint64_t AQTap = 0;
          if (!Property) {
            return AQTap;
          }
          return Property;
        }
        return 0;
      }
      return FigSignalErrorAt();
    }
    if (cf == 1) {
      return 0;
    }
    LODWORD(cf) = 1;
    uint64_t v12 = *(void *)(a2 + 40);
    p_CFStringRef deviceUID = (UInt32 *)&cf;
    AudioQueuePropertyID v14 = 1902410094;
LABEL_64:
    UInt32 v17 = 4;
    return FigAudioQueueTimingShimSetProperty(v12, v14, p_deviceUID, v17);
  }
  if (CFEqual(cf1, @"AdjustTargetLevel"))
  {
    LODWORD(cf) = 0;
    CFNumberGetValue((CFNumberRef)AQTap, kCFNumberFloat32Type, &cf);
    uint64_t v12 = *(void *)(a2 + 40);
    AudioQueuePropertyID v14 = 1584952428;
LABEL_63:
    p_CFStringRef deviceUID = (UInt32 *)&cf;
    goto LABEL_64;
  }
  if (CFEqual(cf1, @"AdjustCompressionProfile"))
  {
    LODWORD(cf) = 0;
    CFNumberGetValue((CFNumberRef)AQTap, kCFNumberSInt32Type, &cf);
    uint64_t v12 = *(void *)(a2 + 40);
    p_CFStringRef deviceUID = (UInt32 *)&cf;
    AudioQueuePropertyID v14 = 1584948336;
    goto LABEL_64;
  }
  if (CFEqual(cf1, @"SweepFilterConfiguration"))
  {
    if (!AQTap) {
      goto LABEL_94;
    }
    CFTypeID v42 = CFGetTypeID((CFTypeRef)AQTap);
    if (v42 != CFDictionaryGetTypeID()) {
      goto LABEL_94;
    }
    CMTime v43 = *(const void **)(a1 + 704);
    *(void *)(a1 + 704) = AQTap;
    CFRetain((CFTypeRef)AQTap);
    if (v43) {
      CFRelease(v43);
    }
    if (!*(unsigned char *)(a1 + 696)) {
      return 0;
    }
    return subaq_setSweepFilterConfig(a1, a2);
  }
  else
  {
    if (!CFEqual(cf1, @"EnableSweepFilter"))
    {
      if (CFEqual(cf1, @"CodecProgramTargetLevel"))
      {
        LODWORD(cf) = 0;
        CFNumberGetValue((CFNumberRef)AQTap, kCFNumberFloat32Type, &cf);
        uint64_t v12 = *(void *)(a2 + 40);
        p_CFStringRef deviceUID = (UInt32 *)&cf;
        AudioQueuePropertyID v14 = 1886418028;
      }
      else if (CFEqual(cf1, @"BestAvailableContentType"))
      {
        LODWORD(cf) = 0;
        CFNumberGetValue((CFNumberRef)AQTap, kCFNumberSInt32Type, &cf);
        uint64_t v12 = *(void *)(a2 + 40);
        p_CFStringRef deviceUID = (UInt32 *)&cf;
        AudioQueuePropertyID v14 = 1650549620;
      }
      else
      {
        if (!CFEqual(cf1, @"SceneCompositionPreset")) {
          return 4294954353;
        }
        LODWORD(cf) = 0;
        if (!AQTap) {
          return FigSignalErrorAt();
        }
        CFTypeID v46 = CFGetTypeID((CFTypeRef)AQTap);
        if (v46 != CFNumberGetTypeID()) {
          return FigSignalErrorAt();
        }
        CFNumberGetValue((CFNumberRef)AQTap, kCFNumberSInt32Type, &cf);
        uint64_t v12 = *(void *)(a2 + 40);
        p_CFStringRef deviceUID = (UInt32 *)&cf;
        AudioQueuePropertyID v14 = 1584620400;
      }
      goto LABEL_64;
    }
    if (!AQTap) {
      goto LABEL_94;
    }
    CFTypeID v44 = CFGetTypeID((CFTypeRef)AQTap);
    if (v44 != CFBooleanGetTypeID()) {
      goto LABEL_94;
    }
    int Value = CFBooleanGetValue((CFBooleanRef)AQTap);
    *(unsigned char *)(a1 + 696) = Value;
    return subaq_setSweepFilterEnable(a1, a2, Value);
  }
}

BOOL faq_shouldSetMXSessionOnAudioQueues()
{
  if (faq_shouldSetMXSessionOnAudioQueues_onceToken != -1) {
    dispatch_once(&faq_shouldSetMXSessionOnAudioQueues_onceToken, &__block_literal_global_6);
  }
  return (faq_shouldSetMXSessionOnAudioQueues_sShouldSetMXSession & 1) == 0;
}

uint64_t MTAudioProcessingTapCreateAQTap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 16);
  if (!v12) {
    return 4294954514;
  }

  return v12(a1, a2, a3, a4, a5);
}

uint64_t subaq_setCinematicAudioBulkParameters(int a1, int a2, CFDataRef theData)
{
  CFDataGetLength(theData);
  CFDataGetBytePtr(theData);
  uint64_t v4 = FigAtomStreamInitWithMemoryBlock();
  if (!v4)
  {
    FigAtomStreamGetCurrentAtomTypeAndDataLength();
    uint64_t v4 = FigSignalErrorAt();
  }
  uint64_t v6 = v4;
  free(0);
  return v6;
}

uint64_t __faq_shouldSetMXSessionOnAudioQueues_block_invoke()
{
  uint64_t result = FigPreferAudioSessionOverCMSession();
  if (result || (uint64_t result = FigGetCFPreferenceNumberWithDefault(), result != 1)) {
    faq_shouldSetMXSessionOnAudioQueues_sShouldSetMXSession = 1;
  }
  return result;
}

uint64_t parseCinematicAudioHeaderAtom()
{
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t parseCinematicAudioParametersAtom()
{
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t subaq_applyOneCachedProperty(CFTypeRef cf1, const __CFString *a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 16) || (uint64_t result = CFEqual(cf1, @"AllowedToUseHardware"), !result))
  {
    uint64_t v7 = *(void *)a3;
    uint64_t v6 = *(void *)(a3 + 8);
    if (FigCFEqual()) {
      CFStringRef v8 = 0;
    }
    else {
      CFStringRef v8 = a2;
    }
    return subaq_setProperty(v7, v6, cf1, v8);
  }
  return result;
}

uint64_t __subaq_acquireAndPrepareAQBuffer_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 40);
  UInt32 v5 = 4;
  int v6 = 0;
  uint64_t result = FigAudioQueueTimingShimGetProperty(v1, 0x71706964u, &v6, &v5);
  BOOL v3 = 0;
  if (!result)
  {
    int v4 = v6;
    uint64_t result = getpid();
    BOOL v3 = v4 == result;
  }
  subaq_acquireAndPrepareAQBuffer_sAudioQueueCanAllocateOSStatus BufferWithMemory = v3;
  return result;
}

void subaq_scheduleVolumeCurvesForMediaTimeRange(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, _OWORD *a4, int a5, int a6)
{
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return;
  }
  if (!theDict) {
    return;
  }
  uint64_t v6 = a1;
  if (*(unsigned char *)(a1 + 16)) {
    return;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"AudioCurve_Volume");
  if (!Value) {
    return;
  }
  CFArrayRef v11 = Value;
  long long v12 = a4[1];
  *(_OWORD *)&time.start.double value = *a4;
  *(_OWORD *)&time.start.CMTimeEpoch epoch = v12;
  *(_OWORD *)&time.duration.CMTimeScale timescale = a4[2];
  memset(&v86, 0, sizeof(v86));
  CFIndex Count = CFArrayGetCount(Value);
  uint64_t v78 = a2;
  if (0xAAAAAAAAAAAAAAABLL * Count + 0x2AAAAAAAAAAAAAAALL >= 0x5555555555555555)
  {
    if (FigSignalErrorAt()) {
      return;
    }
    goto LABEL_121;
  }
  if (!Count)
  {
    CFMutableStringRef Mutable = (void *)CFRetain(v11);
    goto LABEL_56;
  }
  CFIndex v80 = Count;
  int v79 = a6;
  CFMutableStringRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CMTimeRange range = time;
  CMTimeRangeGetEnd(&v86, &range);
  uint64_t v15 = MEMORY[0x1E4F1F9F8];
  v95.double value = *MEMORY[0x1E4F1F9F8];
  v95.CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  CFIndex v16 = CFArrayGetCount(v11);
  uint64_t v75 = v6;
  if (v16 < 4)
  {
    CFIndex v22 = 0;
  }
  else
  {
    CFIndex v17 = v16;
    int64_t v18 = 0;
    uint64_t v19 = 0;
    int64_t v20 = (v16 - 1) / 3uLL;
    while (1)
    {
      memset(&range, 0, 24);
      uint64_t v21 = v18 + v20 < 0 != __OFADD__(v18, v20) ? v18 + v20 + 1 : v18 + v20;
      CFIndex v22 = (v21 & 0xFFFFFFFFFFFFFFFELL) + (v21 >> 1);
      if (!FigCFArrayGetCMTimeAtIndex()) {
        break;
      }
      uint64_t v23 = v21 >> 1;
      CMTime time1 = range.start;
      CMTime time2 = time.start;
      if (CMTimeCompare(&time1, &time2) < 0)
      {
        int64_t v18 = v23 + 1;
        uint64_t v19 = v22;
      }
      else
      {
        CMTime time1 = range.start;
        CMTime time2 = time.start;
        if (CMTimeCompare(&time1, &time2) <= 0)
        {
          memset(&time1, 0, sizeof(time1));
          if (v17 <= v22 + 3)
          {
LABEL_27:
            uint64_t v19 = v22;
          }
          else
          {
            uint64_t v19 = 3 * v23;
            while (FigCFArrayGetCMTimeAtIndex())
            {
              CMTime time2 = time.start;
              CMTime v91 = time1;
              if (CMTimeCompare(&time2, &v91) < 0)
              {
                CFIndex v22 = v19;
                goto LABEL_27;
              }
              memset(&time1, 0, sizeof(time1));
              CFIndex v22 = v19 + 3;
              uint64_t v24 = v19 + 6;
              v19 += 3;
              if (v17 <= v24) {
                goto LABEL_27;
              }
            }
          }
          break;
        }
        int64_t v20 = v23 - 1;
        CFIndex v22 = v19;
      }
      if (v20 < v18) {
        goto LABEL_29;
      }
    }
    CFIndex v22 = v19;
  }
LABEL_29:
  CFIndex v25 = v22 + 2;
  if (v22 + 2 >= v80) {
    goto LABEL_53;
  }
  int v26 = 0;
  CMTimeFlags flags = *(_DWORD *)(v15 + 12);
  CMTimeEpoch epoch = *(void *)(v15 + 16);
  CFTypeID v29 = @"Linear";
  double v30 = NAN;
  while (1)
  {
    CFTypeID v31 = v29;
    memset(&range, 0, 24);
    v91.double value = 0;
    if (!FigCFArrayGetCMTimeAtIndex()
      || !FigCFArrayGetDoubleAtIndex()
      || (CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v11, v25)) == 0
      || (CFTypeID v29 = ValueAtIndex, v33 = CFGetTypeID(ValueAtIndex), v33 != CFStringGetTypeID()))
    {
      int v74 = FigSignalErrorAt();
      if (Mutable) {
        CFRelease(Mutable);
      }
      a6 = v79;
      uint64_t v6 = v75;
      if (v74) {
        return;
      }
LABEL_121:
      CFMutableStringRef Mutable = 0;
      goto LABEL_56;
    }
    CMTime time1 = range.start;
    CMTime time2 = time.start;
    if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0) {
      break;
    }
    CFIndex v36 = v22 + 3;
    int v26 = 1;
    if (!v79) {
      goto LABEL_46;
    }
    CFIndex v37 = v80;
    if (v36 == v80)
    {
      CMTime time1 = time.start;
      FigCFArrayAppendCMTime();
      uint64_t v38 = CFArrayGetValueAtIndex(v11, v22 + 1);
      CFArrayAppendValue((CFMutableArrayRef)Mutable, v38);
      goto LABEL_52;
    }
LABEL_47:
    v95.double value = range.start.value;
    CMTimeFlags flags = range.start.flags;
    v95.CMTimeScale timescale = range.start.timescale;
    CMTimeEpoch epoch = range.start.epoch;
    double v30 = *(double *)&v91.value;
    CFIndex v25 = v22 + 5;
    CFIndex v22 = v36;
    if (v25 >= v37) {
      goto LABEL_53;
    }
  }
  CMTime time1 = range.start;
  CMTime time2 = time.start;
  if (!CMTimeCompare(&time1, &time2)) {
    goto LABEL_42;
  }
  if (v26 && (v79 || v30 != *(double *)&v91.value))
  {
    time1.double value = v95.value;
    time1.CMTimeScale timescale = v95.timescale;
    time1.CMTimeFlags flags = flags;
    time1.CMTimeEpoch epoch = epoch;
    CMTime time2 = range.start;
    CMTimeRangeFromTimeToTime(&v85, &time1, &time2);
    CMTime time1 = time.start;
    faq_getLinearlyInterpolatedVolumeAtTimeInRange(&v85.start, &time1, v30, *(double *)&v91.value);
    CMTime time1 = time.start;
    FigCFArrayAppendCMTime();
    FigCFArrayAppendDouble();
    CFArrayAppendValue((CFMutableArrayRef)Mutable, v31);
  }
  CMTime time1 = range.start;
  CMTime time2 = v86;
  if (CMTimeCompare(&time1, &time2) < 1)
  {
LABEL_42:
    CMTime v34 = CFArrayGetValueAtIndex(v11, v22);
    CFArrayAppendValue((CFMutableArrayRef)Mutable, v34);
    CMTime v35 = CFArrayGetValueAtIndex(v11, v22 + 1);
    CFArrayAppendValue((CFMutableArrayRef)Mutable, v35);
    CFArrayAppendValue((CFMutableArrayRef)Mutable, v29);
    int v26 = 0;
    CFIndex v36 = v22 + 3;
LABEL_46:
    CFIndex v37 = v80;
    goto LABEL_47;
  }
  if ((flags & 1) != 0 && v30 != *(double *)&v91.value)
  {
    time1.double value = v95.value;
    time1.CMTimeScale timescale = v95.timescale;
    time1.CMTimeFlags flags = flags;
    time1.CMTimeEpoch epoch = epoch;
    CMTime time2 = range.start;
    CMTimeRangeFromTimeToTime(&v84, &time1, &time2);
    CMTime time1 = v86;
    faq_getLinearlyInterpolatedVolumeAtTimeInRange(&v84.start, &time1, v30, *(double *)&v91.value);
    CMTime time1 = v86;
    FigCFArrayAppendCMTime();
    FigCFArrayAppendDouble();
LABEL_52:
    CFArrayAppendValue((CFMutableArrayRef)Mutable, v29);
  }
LABEL_53:
  a6 = v79;
  uint64_t v6 = v75;
  if (v79 && CFArrayGetCount((CFArrayRef)Mutable) >= 4)
  {
    CMTime v39 = CFArrayGetValueAtIndex((CFArrayRef)Mutable, 0);
    CMTime v40 = CFArrayGetValueAtIndex((CFArrayRef)Mutable, 1);
    CFTypeID v41 = CFArrayGetValueAtIndex((CFArrayRef)Mutable, 2);
    CFArrayInsertValueAtIndex((CFMutableArrayRef)Mutable, 0, v39);
    CFArrayInsertValueAtIndex((CFMutableArrayRef)Mutable, 1, v40);
    CFArrayInsertValueAtIndex((CFMutableArrayRef)Mutable, 2, v41);
  }
LABEL_56:
  double v94 = -1.0;
  long long v42 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&v85.start.double value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v43 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  v85.start.CMTimeEpoch epoch = v43;
  if (!Mutable || *(unsigned char *)(v6 + 16))
  {
LABEL_115:
    if (Mutable) {
      goto LABEL_116;
    }
  }
  else
  {
    long long v81 = v42;
    CFIndex v44 = CFArrayGetCount((CFArrayRef)Mutable);
    if (v44 >= 1)
    {
      CFIndex v45 = v44;
      if (0xAAAAAAAAAAAAAAABLL * v44 >= 0x5555555555555556)
      {
        FigSignalErrorAt();
      }
      else
      {
        double v46 = 1.0;
        if ((*(unsigned char *)(v6 + 48) & 2) != 0) {
          goto LABEL_69;
        }
        float v47 = *(float *)(v6 + 416);
        double v48 = 1.0;
        if (v47 == 0.0) {
          double v49 = 1.0;
        }
        else {
          double v49 = v47;
        }
        if (*(unsigned char *)(v6 + 236))
        {
          float v50 = *(float *)(v6 + 232);
          BOOL v58 = v50 == 0.0;
          double v48 = v50;
          if (v58) {
            double v48 = 1.0;
          }
        }
        float v51 = v49 / v48;
        if (v51 != 0.0)
        {
          double v46 = v51;
LABEL_69:
          if (*(unsigned char *)(v78 + 48))
          {
            subaq_getCurrentQueueTime(v78, &v85.start);
          }
          else
          {
            *(_OWORD *)&v85.start.double value = v81;
            v85.start.CMTimeEpoch epoch = v43;
          }
          int32_t v52 = *(_DWORD *)(v78 + 100);
          *(_OWORD *)&range.start.double value = *(_OWORD *)&v85.start.value;
          range.start.CMTimeEpoch epoch = v85.start.epoch;
          CMTimeConvertScale(&v84.start, &range.start, v52, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
          double v53 = (double)v84.start.value;
          *(_OWORD *)&time.start.double value = *(_OWORD *)(v6 + 528);
          time.start.CMTimeEpoch epoch = *(void *)(v6 + 544);
          CMTimeConvertScale(&time1, &time.start, *(_DWORD *)(v78 + 100), kCMTimeRoundingMethod_RoundHalfAwayFromZero);
          double v54 = (double)time1.value;
          int32_t v55 = *(_DWORD *)(v78 + 100);
          *(_OWORD *)&range.start.double value = *(_OWORD *)(v6 + 456);
          range.start.CMTimeEpoch epoch = *(void *)(v6 + 472);
          CMTimeConvertScale(&time2, &range.start, v55, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
          CFIndex v56 = 0;
          double v57 = (double)time2.value;
          if (a6) {
            BOOL v58 = 1;
          }
          else {
            BOOL v58 = v45 == 3;
          }
          int v59 = v58;
          int v76 = v59;
          long long v82 = *MEMORY[0x1E4F1F9F8];
          CMTimeEpoch v60 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
          CFIndex v61 = v45;
          while (2)
          {
            *(_OWORD *)&v91.double value = v82;
            v91.CMTimeEpoch epoch = v60;
            double v89 = 0.0;
            double v90 = 0.0;
            long long v88 = 0u;
            memset(&range, 0, sizeof(range));
            float v99 = 0.0;
            uint64_t v98 = 0;
            AudioQueueParameterID v97 = 18;
            uint64_t v96 = 0xB0000000CLL;
            if (!a5)
            {
              uint64_t v96 = 0x1A0000001BLL;
              AudioQueueParameterID v97 = 28;
            }
            if (v46 <= 0.0)
            {
              uint64_t v62 = v78;
              if (!FigCFArrayGetCMTimeAtIndex() || !FigCFArrayGetDoubleAtIndex()) {
                goto LABEL_115;
              }
              CFIndex v63 = v61 - 1;
            }
            else
            {
              uint64_t v62 = v78;
              if (!FigCFArrayGetCMTimeAtIndex() || !FigCFArrayGetDoubleAtIndex()) {
                goto LABEL_115;
              }
              CFIndex v63 = v56 + 2;
            }
            Float64 v64 = CFArrayGetValueAtIndex((CFArrayRef)Mutable, v63);
            if (!v64) {
              goto LABEL_115;
            }
            int v65 = CFEqual(v64, @"EqualPower");
            float v66 = 1.0;
            if (!v65) {
              float v66 = 0.0;
            }
            float v99 = v66;
            if (FigAudioQueueTimingShimSetParameter(*(void *)(v62 + 40), v97, v66)) {
              goto LABEL_115;
            }
            int32_t v67 = *(_DWORD *)(v62 + 100);
            CMTime v95 = v91;
            CMTimeConvertScale(&v86, &v95, v67, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
            if (v57 + ((double)v86.value - v54) * v46 >= 0.0) {
              double v68 = v57 + ((double)v86.value - v54) * v46;
            }
            else {
              double v68 = 0.0;
            }
            double v90 = v68;
            double v69 = v94;
            if (v68 <= v94)
            {
              subaq_incrementSampleTime(v62, &v90, v94);
              if (v70) {
                goto LABEL_115;
              }
              double v68 = v90;
            }
            float v71 = v89;
            *((float *)&v98 + 1) = v71;
            if (v56)
            {
              if (a6 || v68 >= v53)
              {
                float v72 = (v68 - v69) / (double)*(int *)(v62 + 100);
                *(float *)&uint64_t v98 = v72;
                *(double *)&range.start.double value = v69;
LABEL_102:
                DWORD2(v88) = 1;
                if (FigAudioQueueTimingShimScheduleParameters(*(void *)(v62 + 40), (double *)&range.start.value, 3u, (unsigned int *)&v96, (float *)&v98))goto LABEL_115; {
                goto LABEL_103;
                }
              }
            }
            else if (v76)
            {
              LODWORD(v98) = 0;
              if (a6 || v68 >= v53)
              {
                if (!a6 || *(unsigned char *)(v62 + 48) || *(unsigned char *)(v62 + 584))
                {
                  *(double *)&range.start.double value = v68;
                  goto LABEL_102;
                }
                *(double *)&range.start.double value = v53;
                DWORD2(v88) = 0;
                FigAudioQueueTimingShimScheduleParameters(*(void *)(v62 + 40), (double *)&range.start.value, 1u, (unsigned int *)&v96 + 1, (float *)&v98 + 1);
LABEL_103:
                *(unsigned char *)(v62 + 584) = 1;
              }
            }
            subaq_incrementSampleTime(v62, &v94, v68);
            if (v73) {
              goto LABEL_115;
            }
            v56 += 3;
            v61 -= 3;
            if (v56 >= v45) {
              goto LABEL_115;
            }
            continue;
          }
        }
      }
    }
LABEL_116:
    CFRelease(Mutable);
  }
}

CFArrayRef subaq_scheduleCinematicForMediaTimeRange(const __CFArray *result, uint64_t a2, CFDictionaryRef theDict)
{
  if (result)
  {
    if (theDict)
    {
      uint64_t v4 = (uint64_t)result;
      if (!*((unsigned char *)result + 16))
      {
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"AudioCurves_AmbienceLevel");
        CFArrayRef v7 = (const __CFArray *)CFDictionaryGetValue(theDict, @"AudioCurves_DialogLevel");
        CFArrayRef v8 = (const __CFArray *)CFDictionaryGetValue(theDict, @"AudioCurves_DialogMixBias");
        CFArrayRef v9 = (const __CFArray *)CFDictionaryGetValue(theDict, @"AudioCurves_DialogLoudness");
        CFArrayRef v10 = (const __CFArray *)CFDictionaryGetValue(theDict, @"AudioCurves_AmbienceLoudness");
        CFArrayRef v11 = (const __CFArray *)CFDictionaryGetValue(theDict, @"AudioCurves_RecordingLoudness");
        uint64_t result = (const __CFArray *)CFDictionaryGetValue(theDict, @"AudioCurves_RenderingStyle");
        CFArrayRef v12 = result;
        if (Value || v8 || v7 || v9 || v10 || v11 || result)
        {
          uint64_t result = (const __CFArray *)subaq_ensureCinematicAudioEnabled(v4, a2, 0);
          if (*(unsigned char *)(v4 + 768))
          {
            if (!Value
              || (CFArrayGetValueAtIndex(Value, 1),
                  FigCFNumberGetFloat32(),
                  uint64_t result = (const __CFArray *)FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 0x20u, v13),
                  !result))
            {
              if (!v7
                || (CFArrayGetValueAtIndex(v7, 1),
                    FigCFNumberGetFloat32(),
                    uint64_t result = (const __CFArray *)FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 0x1Fu, v14),
                    !result))
              {
                if (!v8
                  || (CFArrayGetValueAtIndex(v8, 1),
                      FigCFNumberGetFloat32(),
                      uint64_t result = (const __CFArray *)FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 0x1Eu, v15),
                      !result))
                {
                  if (!v9
                    || (CFArrayGetValueAtIndex(v9, 1),
                        FigCFNumberGetFloat32(),
                        uint64_t result = (const __CFArray *)FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 0x21u, v16), !result))
                  {
                    if (!v10
                      || (CFArrayGetValueAtIndex(v10, 1),
                          FigCFNumberGetFloat32(),
                          uint64_t result = (const __CFArray *)FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 0x22u, v17), !result))
                    {
                      if (!v11
                        || (CFArrayGetValueAtIndex(v11, 1),
                            FigCFNumberGetFloat32(),
                            uint64_t result = (const __CFArray *)FigAudioQueueTimingShimSetParameter(*(void *)(a2 + 40), 0x23u, v18), !result))
                      {
                        if (v12)
                        {
                          CFArrayGetValueAtIndex(v12, 1);
                          FigCFNumberGetFloat32();
                          uint64_t v20 = *(void *)(a2 + 40);
                          return (const __CFArray *)FigAudioQueueTimingShimSetParameter(v20, 0x48u, v19);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void subaq_scheduleAudioProcessingUnitForMediaTimeRange(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, char a5, uint64_t a6)
{
  *(_OWORD *)&v26.double value = *MEMORY[0x1E4F1F9F8];
  memset(v23, 0, sizeof(v23));
  long long v6 = a4[1];
  long long v20 = *a4;
  int v28 = 0;
  CFDictionaryRef v27 = 0;
  v26.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  context[0] = &v28;
  context[1] = a1;
  context[2] = a2;
  long long v21 = v6;
  long long v22 = a4[2];
  LOBYTE(v23[0]) = 1;
  memset(&v23[1], 0, 24);
  uint64_t v24 = 0;
  BYTE1(v24) = a5;
  uint64_t v25 = a6;
  if (!*(unsigned char *)(a1 + 16) && (*(unsigned char *)(a1 + 48) & 2) == 0)
  {
    float v10 = *(float *)(a1 + 416);
    double v11 = 1.0;
    if (v10 == 0.0) {
      double v12 = 1.0;
    }
    else {
      double v12 = v10;
    }
    if (*(unsigned char *)(a1 + 236))
    {
      float v13 = *(float *)(a1 + 232);
      BOOL v14 = v13 == 0.0;
      double v11 = v13;
      if (v14) {
        double v11 = 1.0;
      }
    }
    float v15 = v12 / v11;
    *((float *)v23 + 1) = v15;
    if (v15 != 0.0)
    {
      if (v15 <= 0.0)
      {
        FigSignalErrorAt();
      }
      else if (FigCFDictionaryGetValueIfPresent())
      {
        if (*(unsigned char *)(a2 + 48)) {
          subaq_getCurrentQueueTime(a2, &v26);
        }
        else {
          CMTime v26 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
        }
        range.CMTime start = v26;
        faqTimelineWrangler_convertAQTimeToMediaTime(a1 + 424, &range.start, (uint64_t)&v23[1], v15);
        long long v16 = a4[1];
        *(_OWORD *)&range.start.double value = *a4;
        *(_OWORD *)&range.start.CMTimeEpoch epoch = v16;
        *(_OWORD *)&range.duration.CMTimeScale timescale = a4[2];
        CMTime v17 = *(CMTime *)&v23[1];
        LOBYTE(v24) = CMTimeRangeContainsTime(&range, &v17);
        CFDictionaryApplyFunction(v27, (CFDictionaryApplierFunction)subaq_audioProcessingUnitScheduleParametersApplier, context);
      }
    }
  }
}

double faq_getLinearlyInterpolatedVolumeAtTimeInRange(CMTime *a1, CMTime *a2, double a3, double a4)
{
  CMTime lhs = *a2;
  CMTime v9 = *a1;
  CMTimeSubtract(&v11, &lhs, &v9);
  CMTime lhs = v11;
  double Seconds = CMTimeGetSeconds(&lhs);
  CMTime lhs = a1[1];
  return (a4 - a3) * (Seconds / CMTimeGetSeconds(&lhs)) + a3;
}

double subaq_incrementSampleTime(uint64_t a1, void *a2, double a3)
{
  long long v10 = 0u;
  long long v9 = 0u;
  long long v8 = 0u;
  long long v6 = 0u;
  memset(v5, 0, sizeof(v5));
  double v7 = a3;
  uint64_t v11 = 1;
  DWORD2(v6) = 1;
  if (!FigAudioQueueTimingShimGetIncrementedSampleTime(*(CMTime **)(a1 + 40), &v7, (double *)v5))
  {
    double result = *(double *)v5;
    *a2 = *(void *)&v5[0];
  }
  return result;
}

void subaq_audioProcessingUnitScheduleParametersApplier(void *key, const __CFArray *a2, uint64_t a3)
{
  uint64_t v77 = 0;
  int v62 = *(unsigned __int8 *)(a3 + 104);
  CMTime v76 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CMTime v75 = v76;
  int v73 = 0;
  double value = 0;
  float v72 = 0;
  uint64_t v3 = *(void *)(a3 + 8);
  if (**(_DWORD **)a3) {
    return;
  }
  uint64_t v4 = (int **)a3;
  if (!*(unsigned char *)(a3 + 105))
  {
    CFDictionaryRef v7 = *(const __CFDictionary **)(v3 + 656);
    if (v7)
    {
      if (CFDictionaryContainsKey(v7, key)) {
        return;
      }
    }
  }
  if (!FigCFDictionaryGetValueIfPresent()) {
    goto LABEL_100;
  }
  if (!FigCFDictionaryGetValueIfPresent() || !*v72)
  {
LABEL_14:
    if (a2) {
      CFIndex Count = CFArrayGetCount(a2);
    }
    else {
      CFIndex Count = 0;
    }
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      float v13 = Mutable;
      if (Count >= 1)
      {
        CMTimeRange theDict = 0;
        CFIndex v14 = 0;
        CFIndex v63 = v4 + 3;
        uint64_t v60 = v3 + 424;
        CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
        BOOL v58 = v4 + 10;
        CFArrayRef v59 = a2;
        int32_t v52 = (CMTime *)(v3 + 456);
        double v53 = (CMTime *)(v3 + 528);
        double v54 = Mutable;
        int32_t v55 = v4;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, v14);
          if (!FigCFDictionaryGetCMTimeIfPresent()) {
            goto LABEL_86;
          }
          long long v17 = *((_OWORD *)v63 + 1);
          *(_OWORD *)&range.start.double value = *(_OWORD *)v63;
          *(_OWORD *)&range.start.CMTimeEpoch epoch = v17;
          *(_OWORD *)&range.duration.CMTimeScale timescale = *((_OWORD *)v63 + 2);
          CMTimeRangeGetEnd(&time1, &range);
          range.CMTime start = v76;
          if (CMTimeCompare(&time1, &range.start) < 0) {
            goto LABEL_67;
          }
          double v18 = *((float *)v4 + 19);
          range.CMTime start = v76;
          faqTimelineWrangler_convertMediaTimeToAQTime(v60, &range.start, (uint64_t)&v75, v18);
          if (!CFDictionaryGetValueIfPresent(ValueAtIndex, @"params", (const void **)&value)
            || !CFDictionaryGetValueIfPresent(ValueAtIndex, @"values", (const void **)&v73))
          {
LABEL_86:
            int v49 = FigSignalErrorAt();
            CFDataRef v29 = 0;
            CFNumberRef v31 = 0;
            goto LABEL_87;
          }
          BytePtr = CFDataGetBytePtr((CFDataRef)value);
          long long v20 = CFDataGetBytePtr((CFDataRef)v73);
          unint64_t Length = CFDataGetLength((CFDataRef)value);
          unint64_t v22 = Length / 0xC;
          if (!v14)
          {
            if (!*((unsigned char *)v4 + 72) && !v62) {
              goto LABEL_44;
            }
            CMTime v26 = CFDataGetBytePtr((CFDataRef)value);
            CMTimeRange theDict = CFDictionaryCreateMutable(v11, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (!theDict)
            {
              **uint64_t v4 = FigSignalErrorAt();
              float v51 = v13;
LABEL_96:
              CFRelease(v51);
              return;
            }
            if (Length >= 0xC)
            {
              unint64_t v56 = Length;
              unint64_t v57 = Length / 0xC;
              if (v22 <= 1) {
                unint64_t v27 = 1;
              }
              else {
                unint64_t v27 = Length / 0xC;
              }
              int v28 = v20;
              while (1)
              {
                CFDataRef v29 = CFDataCreateWithBytesNoCopy(v11, v26, 12, v15);
                CFNumberRef v30 = CFNumberCreate(v11, kCFNumberFloat32Type, v28);
                CFNumberRef v31 = v30;
                if (!v29 || !v30) {
                  break;
                }
                CFDictionarySetValue(theDict, v29, v30);
                CFRelease(v29);
                CFRelease(v31);
                v28 += 4;
                v26 += 12;
                if (!--v27)
                {
                  float v13 = v54;
                  uint64_t v4 = v55;
                  unint64_t Length = v56;
                  unint64_t v22 = v57;
                  goto LABEL_25;
                }
              }
              int v49 = FigSignalErrorAt();
              float v13 = v54;
              float v50 = *v55;
              goto LABEL_88;
            }
          }
LABEL_25:
          if (v62)
          {
            *(_OWORD *)&range.start.double value = *(_OWORD *)v58;
            range.start.CMTimeEpoch epoch = (CMTimeEpoch)v58[2];
            CMTime time2 = v76;
            if (CMTimeCompare(&range.start, &time2) > 0) {
              goto LABEL_45;
            }
            uint64_t v23 = v77;
            uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v24) {
              uint64_t v25 = v24;
            }
            else {
              uint64_t v25 = 0;
            }
            if (!*(void *)(v25 + 8))
            {
              CFDataRef v29 = 0;
              CFNumberRef v31 = 0;
              **uint64_t v4 = -12782;
LABEL_89:
              CMTime v39 = theDict;
              goto LABEL_90;
            }
            int v32 = (*(uint64_t (**)(uint64_t, __CFDictionary *))(v25 + 16))(v23, theDict);
            **uint64_t v4 = v32;
            if (v32)
            {
              CFDataRef v29 = 0;
              CFNumberRef v31 = 0;
              goto LABEL_89;
            }
          }
LABEL_44:
          int v62 = 0;
LABEL_45:
          *(_OWORD *)&range.start.double value = *(_OWORD *)v63;
          range.start.CMTimeEpoch epoch = (CMTimeEpoch)v63[2];
          CMTime time2 = v76;
          if (CMTimeCompare(&range.start, &time2) < 0)
          {
            if (!CFArrayGetCount(v13))
            {
              if (*((unsigned char *)v4 + 72))
              {
                *(_OWORD *)&range.start.double value = *MEMORY[0x1E4F1FA48];
                range.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16);
                CMTime time2 = v76;
                if (CMTimeCompare(&range.start, &time2) < 0)
                {
                  memset(&range, 0, 24);
                  CMTime rhs = *v53;
                  CMTime time2 = *(CMTime *)v63;
                  CMTimeSubtract(&time, &time2, &rhs);
                  CMTimeMultiplyByFloat64(&lhs, &time, *((float *)v4 + 19));
                  CMTime v65 = *v52;
                  CMTimeAdd(&range.start, &lhs, &v65);
                  CFMutableDictionaryRef v37 = CFDictionaryCreateMutable(v11, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  if (!v37) {
                    goto LABEL_86;
                  }
                  uint64_t v38 = v37;
                  CMTime time2 = range.start;
                  FigCFDictionarySetCMTime();
                  CFDictionarySetValue(v38, @"params", value);
                  CFDictionarySetValue(v38, @"values", v73);
                  CFArrayAppendValue(v13, v38);
                  CFRelease(v38);
                }
              }
            }
            CFMutableDictionaryRef v33 = CFDictionaryCreateMutable(v11, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (!v33) {
              goto LABEL_86;
            }
            CMTime v34 = v33;
            range.CMTime start = v75;
            FigCFDictionarySetCMTime();
            CFDictionarySetValue(v34, @"params", value);
            CFDictionarySetValue(v34, @"values", v73);
            CFArrayAppendValue(v13, v34);
            CFRelease(v34);
            if (!v14) {
              goto LABEL_60;
            }
          }
          else if (!v14)
          {
            goto LABEL_60;
          }
          range.CMTime start = v76;
          CMTime time2 = *(CMTime *)v63;
          if (CMTimeCompare(&range.start, &time2) <= 0 && *((unsigned char *)v4 + 72) && Length >= 0xC)
          {
            if (v22 <= 1) {
              uint64_t v35 = 1;
            }
            else {
              uint64_t v35 = v22;
            }
            while (1)
            {
              CFDataRef v29 = CFDataCreateWithBytesNoCopy(v11, BytePtr, 12, v15);
              CFNumberRef v36 = CFNumberCreate(v11, kCFNumberFloat32Type, v20);
              CFNumberRef v31 = v36;
              if (!v29 || !v36) {
                break;
              }
              CFDictionarySetValue(theDict, v29, v36);
              CFRelease(v29);
              CFRelease(v31);
              v20 += 4;
              BytePtr += 12;
              if (!--v35) {
                goto LABEL_60;
              }
            }
            int v49 = FigSignalErrorAt();
LABEL_87:
            float v50 = *v4;
LABEL_88:
            *float v50 = v49;
            goto LABEL_89;
          }
LABEL_60:
          ++v14;
          a2 = v59;
          if (v14 == Count) {
            goto LABEL_67;
          }
        }
      }
      CMTimeRange theDict = 0;
LABEL_67:
      CMTime v39 = theDict;
      if (v62)
      {
        uint64_t v40 = v77;
        uint64_t v41 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v41) {
          uint64_t v42 = v41;
        }
        else {
          uint64_t v42 = 0;
        }
        if (!*(void *)(v42 + 8))
        {
          CFDataRef v29 = 0;
          CFNumberRef v31 = 0;
          **uint64_t v4 = -12782;
          goto LABEL_90;
        }
        int v43 = (*(uint64_t (**)(uint64_t, __CFDictionary *))(v42 + 16))(v40, theDict);
        **uint64_t v4 = v43;
        if (v43) {
          goto LABEL_101;
        }
      }
      if (CFArrayGetCount(v13) < 1)
      {
LABEL_101:
        CFDataRef v29 = 0;
        CFNumberRef v31 = 0;
      }
      else
      {
        uint64_t v44 = v77;
        uint64_t v45 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v45) {
          uint64_t v46 = v45;
        }
        else {
          uint64_t v46 = 0;
        }
        float v47 = *(uint64_t (**)(uint64_t, __CFArray *))(v46 + 8);
        if (v47) {
          int v48 = v47(v44, v13);
        }
        else {
          int v48 = -12782;
        }
        CFDataRef v29 = 0;
        CFNumberRef v31 = 0;
        **uint64_t v4 = v48;
      }
LABEL_90:
      CFRelease(v13);
      if (v39) {
        CFRelease(v39);
      }
      if (v29) {
        CFRelease(v29);
      }
      if (v31)
      {
        float v51 = v31;
        goto LABEL_96;
      }
      return;
    }
LABEL_100:
    **uint64_t v4 = FigSignalErrorAt();
    return;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  if (!*(void *)(v9 + 8))
  {
    **uint64_t v4 = -12782;
    return;
  }
  int v10 = (*(uint64_t (**)(uint64_t))(v9 + 24))(v77);
  **uint64_t v4 = v10;
  if (!v10)
  {
    int v62 = 1;
    goto LABEL_14;
  }
}

uint64_t faqTimelineWrangler_setAQTimeInFAQProcessTransitions(uint64_t result, long long *a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  long long v2 = *a2;
  *(void *)(result + 48) = *((void *)a2 + 2);
  *(_OWORD *)(result + 32) = v2;
  if (dword_1E9350B70)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    return fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return result;
}

uint64_t subaq_setTapTimelineInfo(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(unsigned char *)(result + 16) || !*(void *)(a2 + 600)) {
      return 0;
    }
    CMTime time = *(CMTime *)(result + 528);
    CMTimeConvertScale(&v17, &time, *(_DWORD *)(a2 + 100), kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    float v4 = 1.0;
    float v5 = 1.0;
    if ((*(unsigned char *)(v2 + 48) & 2) == 0) {
      float v5 = *(float *)(v2 + 416);
    }
    CMTimeValue value = v17.value;
    int32_t v7 = *(_DWORD *)(a2 + 100);
    CMTime v15 = *(CMTime *)(v2 + 456);
    CMTimeConvertScale(&v16, &v15, v7, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    if (*(unsigned char *)(v2 + 236))
    {
      if (*(float *)(v2 + 232) == 0.0) {
        float v4 = 1.0;
      }
      else {
        float v4 = *(float *)(v2 + 232);
      }
    }
    CMTimeValue v8 = v16.value;
    uint64_t v9 = *(void *)(a2 + 592);
    uint64_t v10 = *(void *)(a2 + 600);
    uint64_t AudioQueue = FigAudioQueueTimingShimGetAudioQueue(*(void *)(a2 + 40));
    uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v13 = v12 ? v12 : 0;
    CFIndex v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CMTimeValue, CMTimeValue, float, float))(v13 + 32);
    if (!v14) {
      return 0;
    }
    double result = v14(v9, v10, AudioQueue, value, v8, v5, v4);
    if (result == -12782) {
      return 0;
    }
  }
  return result;
}

void faq_fireTransitionCallback(uint64_t a1)
{
  uint64_t v3 = *(void (**)(uint64_t, void, long long *, long long *, float))(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  long long v6 = *(_OWORD *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 64);
  v3(v2, *(void *)(a1 + 80), &v6, &v4, *(float *)(a1 + 72));
  faq_destroyTransitionRecord((void *)a1);
}

uint64_t faq_inspectAudioProcessingUnitsParametersInNewAudioCurvesApplier(uint64_t result, CFTypeRef cf, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v3 = MEMORY[0x1E4F1F9F8];
  long long v4 = *(__CFDictionary **)(a3 + 24);
  *(_OWORD *)&v29.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  v29.CMTimeEpoch epoch = epoch;
  *(_OWORD *)&v28.CMTimeValue value = *(_OWORD *)&v29.value;
  v28.CMTimeEpoch epoch = epoch;
  CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  uint64_t v26 = 0;
  CFTypeRef cfa = 0;
  uint64_t v24 = 0;
  CFTypeRef v25 = 0;
  if (!**(_DWORD **)a3)
  {
    if (cf)
    {
      uint64_t v7 = (const void *)result;
      CFTypeID v8 = CFGetTypeID(cf);
      if (v8 == CFArrayGetTypeID())
      {
        CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
        if (Count > 0)
        {
          uint64_t v9 = (BOOL *)malloc_type_calloc(1uLL, 1uLL, 0x100004077774924uLL);
          if (v9)
          {
            uint64_t v10 = v9;
            CMTimeFlags flags = *(_DWORD *)(v3 + 12);
            CFDictionarySetValue(v4, v7, v9);
            if (FigCFDictionaryGetValueIfPresent())
            {
              if (FigCFDictionaryGetValueIfPresent()) {
                BOOL v12 = Count != v31;
              }
              else {
                BOOL v12 = 1;
              }
              *uint64_t v10 = v12;
            }
            CFIndex v13 = 0;
            while (1)
            {
              CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v13);
              if (!ValueAtIndex) {
                break;
              }
              CFTypeID v15 = CFGetTypeID(ValueAtIndex);
              if (v15 != CFDictionaryGetTypeID()
                || !FigCFDictionaryGetCMTimeIfPresent()
                || (v29.flags & 0x1D) != 1)
              {
                break;
              }
              if (flags)
              {
                time1.CMTimeValue value = value;
                time1.CMTimeScale timescale = timescale;
                time1.CMTimeFlags flags = flags;
                time1.CMTimeEpoch epoch = epoch;
                CMTime time2 = v29;
                if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0) {
                  break;
                }
              }
              else
              {
                CMTime time1 = v29;
                CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
                if (CMTimeCompare(&time1, &time2)) {
                  break;
                }
              }
              CMTimeValue value = v29.value;
              CMTimeFlags flags = v29.flags;
              CMTimeScale timescale = v29.timescale;
              CMTimeEpoch epoch = v29.epoch;
              if (!FigCFDictionaryGetValueIfPresent()) {
                break;
              }
              if (!cfa) {
                break;
              }
              CFTypeID v16 = CFGetTypeID(cfa);
              if (v16 != CFDataGetTypeID()) {
                break;
              }
              if (!FigCFDictionaryGetValueIfPresent()) {
                break;
              }
              if (!v25) {
                break;
              }
              CFTypeID v17 = CFGetTypeID(v25);
              if (v17 != CFDataGetTypeID()) {
                break;
              }
              unint64_t Length = CFDataGetLength((CFDataRef)cfa);
              unint64_t v19 = Length / 0xC;
              if (Length % 0xC) {
                break;
              }
              double result = CFDataGetLength((CFDataRef)v25);
              if (result != 4 * v19) {
                break;
              }
              if (!*v10)
              {
                FigCFArrayGetValueAtIndex();
                FigCFDictionaryGetCMTimeIfPresent();
                CMTime time1 = v29;
                CMTime time2 = v28;
                double result = CMTimeCompare(&time1, &time2);
                if (result
                  || (FigCFDictionaryGetValueIfPresent(), double result = FigCFEqual(), !result)
                  || (FigCFDictionaryGetValueIfPresent(), double result = FigCFEqual(), !result))
                {
                  *uint64_t v10 = 1;
                }
              }
              if (Count == ++v13) {
                return result;
              }
            }
          }
        }
      }
    }
    double result = FigSignalErrorAt();
    **(_DWORD **)a3 = result;
  }
  return result;
}

void faq_audioProcessingUnitsParametersInspectionResultsDictValueReleaseCallBack(int a1, void *a2)
{
}

void faq_Init(uint64_t a1)
{
}

void faq_Finalize(uint64_t a1)
{
  FigAudioQueueInvalidate(a1);
  if (*(void *)(a1 + 24))
  {
    FigSimpleMutexDestroy();
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(a1 + 40) = 0;
  }
  uint64_t v3 = *(NSObject **)(a1 + 32);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(a1 + 32) = 0;
  }
  if (*(void *)(a1 + 296))
  {
    FigSemaphoreDestroy();
    *(void *)(a1 + 296) = 0;
  }
  MediaSampleTimingGeneratorDisposeMediaSampleTimingInfoArray(*(void **)(a1 + 168));
  *(void *)(a1 + 168) = 0;
  long long v4 = *(const void **)(a1 + 80);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 408);
  if (v5)
  {
    CFRelease(v5);
  }
}

__CFString *faq_CopyFormattingDesc(unsigned char *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  CFIndex v4 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, @"[FigAudioQueue %p (rc=%d)", a1, v4);
  if (a1[16]) {
    CFStringAppendFormat(Mutable, 0, @"invalidated]");
  }
  else {
    CFStringAppendFormat(Mutable, 0, @"]");
  }
  return Mutable;
}

__CFString *faq_CopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  CFIndex v4 = CFGetRetainCount((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, @"[FigAudioQueue %p retainCount:%d", a1, v4);
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 16))
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176));
      if (Count)
      {
        uint64_t v6 = Count;
        CFStringAppendFormat(Mutable, 0, @"\n");
        if (v6 >= 1)
        {
          for (CFIndex i = 0; i != v6; ++i)
          {
            if (*(unsigned char *)(a1 + 16)) {
              CFDictionaryRef ValueAtIndex = 0;
            }
            else {
              CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), i);
            }
            CFStringAppendFormat(Mutable, 0, @"  ");
            subaq_appendDebugDesc(Mutable, ValueAtIndex);
          }
        }
      }
    }
  }
  CFStringAppendFormat(Mutable, 0, @"]\n");
  return Mutable;
}

uint64_t FigCaptionRendererInputGetClassID()
{
  return sFigCaptionRendererInputClassID;
}

uint64_t RegisterFigCaptionRendererInputType()
{
  CMBaseGetClassID();

  return FigBaseClassRegisterClass();
}

CFStringRef FigCaptionRendererInputCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionRendererInput %p]", a1);
}

void vmc2FinishAndDestroyImageEnhancementFilter(uint64_t a1)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  uint64_t v1 = *(NSObject **)(a1 + 968);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __vmc2FinishAndDestroyImageEnhancementFilter_block_invoke;
  block[3] = &unk_1E578C6B0;
  void block[5] = &v5;
  block[6] = a1;
  block[4] = &v9;
  dispatch_sync(v1, block);
  if (v10[3]) {
    VTTemporalFilterSessionCompleteFrames();
  }
  CFAllocatorRef v2 = (const void *)v6[3];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)v10[3];
  if (v3) {
    CFRelease(v3);
  }
  _Block_object_dispose(&v5, 8);
  _Block_object_dispose(&v9, 8);
}

uint64_t vmc2PriorImageQueueGaugeSafeDisplayDurationChanged(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 16)) {
    return vmc2OutputOccupancyChanged(a2);
  }
  return result;
}

void vmc2PriorImageQueueGaugeWasInvalidated(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 16))
  {
    MEMORY[0x19970E910](*(void *)(a2 + 1480));
    if (*(void *)(a2 + 1488))
    {
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      uint64_t v3 = *(const void **)(a2 + 1488);
      if (v3)
      {
        CFRelease(v3);
        *(void *)(a2 + 1488) = 0;
      }
    }
    MEMORY[0x19970E930](*(void *)(a2 + 1480));
    vmc2OutputOccupancyChanged(a2);
  }
}

void vmc2RemoveDecompressionSession(uint64_t a1)
{
  if (*(void *)(a1 + 64))
  {
    FigStopForwardingMediaServicesProcessDeathNotification();
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterRemoveListener();
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    VTDecompressionSessionInvalidate(*(VTDecompressionSessionRef *)(a1 + 64));
    CFRelease(*(CFTypeRef *)(a1 + 64));
    *(void *)(a1 + 64) = 0;
    ++*(_DWORD *)(a1 + 1144);
  }
  *(_WORD *)(a1 + 1033) = 0;
  *(unsigned char *)(a1 + 1065) = 0;
}

void vmc2UpcomingPTSInfoChanged(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 16) && FigAtomicCompareAndSwap32())
  {
    uint64_t v3 = *(NSObject **)(a2 + 448);
    dispatch_async_f(v3, (void *)a2, (dispatch_function_t)vmc2RecalculateUpcomingImageTimes2);
  }
}

void vmc2DisplayModeChanged(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 16))
  {
    int v3 = 0;
    FPSupport_GetCurrentDisplayModeVideoRangeAndSizeAndFrameRate(0, &v3, 0, 0);
    *(unsigned char *)(a2 + 1400) = (v3 - 2) < 3;
  }
}

void vmc2ClearSavedList(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 800);
  *(void *)(a1 + 800) = 0;
  if (v1)
  {
    do
    {
      int v3 = (void *)*v1;
      CFAllocatorRef v2 = (const void *)v1[1];
      if (v2)
      {
        CFRelease(v2);
        v1[1] = 0;
      }
      CFIndex v4 = (const void *)v1[3];
      if (v4)
      {
        CFRelease(v4);
        v1[3] = 0;
      }
      uint64_t v5 = (const void *)v1[4];
      if (v5) {
        CFRelease(v5);
      }
      free(v1);
      uint64_t v1 = v3;
    }
    while (v3);
  }
}

uint64_t VMC2GetTypeID()
{
  return sVMC2ID;
}

uint64_t VMC2CreateWithQueues2(const __CFAllocator *a1, const opaqueCMFormatDescription *a2, const void *a3, const void *a4, const void *a5, const void *a6, uint64_t a7, const __CFArray *a8, const __CFArray *a9, uint64_t a10, uint64_t a11, const void *a12, const void *a13, const __CFDictionary *a14, uint64_t *a15)
{
  CFTypeRef v48 = 0;
  long long v46 = 0uLL;
  long long v47 = 0u;
  memset(v45, 0, sizeof(v45));
  CFTypeRef cf = 0;
  char v43 = 1;
  char v42 = 0;
  fig_note_initialize_category_with_default_work_cf();
  if (a8)
  {
    CFIndex Count = CFArrayGetCount(a8);
    if (a9)
    {
LABEL_3:
      CFIndex v21 = CFArrayGetCount(a9);
      goto LABEL_6;
    }
  }
  else
  {
    CFIndex Count = 0;
    if (a9) {
      goto LABEL_3;
    }
  }
  CFIndex v21 = 0;
LABEL_6:
  if (Count != v21)
  {
    uint64_t OutputCallbacksForImageQueueArray = FigSignalErrorAt();
LABEL_9:
    uint64_t v24 = OutputCallbacksForImageQueueArray;
    CFArrayRef Mutable = 0;
    goto LABEL_10;
  }
  CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t OutputCallbacksForImageQueueArray = FigSampleBufferProviderCreateForBufferQueue(*MEMORY[0x1E4F1CF80], a6, &v48);
  if (OutputCallbacksForImageQueueArray) {
    goto LABEL_9;
  }
  uint64_t OutputCallbacksForImageQueueArray = VMC2MakeOutputCallbacksForImageQueueArray(a8, a9, 96, v45);
  if (OutputCallbacksForImageQueueArray) {
    goto LABEL_9;
  }
  if (a9 && (CFIndex v28 = CFArrayGetCount(a9), v28 >= 1))
  {
    CFIndex v29 = v28;
    CFIndex v30 = 0;
    CFArrayRef Mutable = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a9, v30);
      if (ValueAtIndex)
      {
        CFTypeID v32 = CFGetTypeID(ValueAtIndex);
        if (v32 == CFDictionaryGetTypeID())
        {
          LODWORD(v40) = 0;
          if (FigCFDictionaryGetInt32IfPresent())
          {
            if (!Mutable)
            {
              CFArrayRef Mutable = CFArrayCreateMutable(v22, 0, MEMORY[0x1E4F1D510]);
              if (!Mutable)
              {
                uint64_t v34 = FigSignalErrorAt();
                goto LABEL_41;
              }
            }
            FigCFArrayAppendInt32();
          }
        }
      }
      ++v30;
    }
    while (v29 != v30);
    if (Mutable)
    {
      CFIndex v33 = CFArrayGetCount(Mutable);
      if (v33 >= 1 && v33 != v29)
      {
        uint64_t v24 = 4294954473;
        goto LABEL_10;
      }
    }
  }
  else
  {
    CFArrayRef Mutable = 0;
  }
  FigCFDictionaryGetBooleanIfPresent();
  FigCFDictionaryGetBooleanIfPresent();
  if (a12)
  {
    uint64_t v34 = FigActivitySchedulerCreateForCFRunLoop(a1, a12, &cf);
    if (!v34) {
      goto LABEL_42;
    }
LABEL_41:
    uint64_t v24 = v34;
    goto LABEL_10;
  }
  uint64_t v34 = FigActivitySchedulerCreateForNewThread((uint64_t)a1, 3, @"com.apple.coremedia.videomediaconverter", &cf);
  if (v34) {
    goto LABEL_41;
  }
LABEL_42:
  long long v40 = *(_OWORD *)a10;
  uint64_t v41 = *(void *)(a10 + 16);
  long long v38 = *(_OWORD *)a11;
  uint64_t v39 = *(void *)(a11 + 16);
  uint64_t v24 = VMC2CreateWithCallbacks((int)a1, a2, a3, a4, a5, v48, a7, v45, Mutable, &v40, &v38, cf, a13, a14, a15);
  a7 = 0;
  *((void *)&v46 + 1) = 0;
LABEL_10:
  if (v48) {
    CFRelease(v48);
  }
  if (*((void *)&v46 + 1)) {
    (*((void (**)(void))&v46 + 1))(*((void *)&v45[0] + 1));
  }
  if (a7)
  {
    uint64_t v26 = *(void (**)(void))(a7 + 24);
    if (v26) {
      v26(*(void *)(a7 + 8));
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v24;
}

uint64_t vmc2SetVideoFormatDescription(uint64_t result, CMFormatDescriptionRef desc)
{
  if (result && desc)
  {
    uint64_t v3 = result;
    CFIndex v4 = *(const void **)(result + 32);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(v3 + 32) = 0;
    }
    if (CMFormatDescriptionGetMediaType(desc) == 1952606066)
    {
      *(unsigned char *)(v3 + 40) = 1;
      uint64_t result = FigFormatDescriptionRetain();
      *(void *)(v3 + 32) = result;
    }
    else
    {
      CMFormatDescriptionGetMediaSubType(desc);
      *(void *)(v3 + 32) = FigFormatDescriptionRetain();
      uint64_t result = CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
      *(unsigned char *)(v3 + 40) = result != 0;
    }
  }
  return result;
}

void vmc2UpdateDisplayMode(uint64_t a1)
{
  int v2 = 0;
  FPSupport_GetCurrentDisplayModeVideoRangeAndSizeAndFrameRate(0, &v2, 0, 0);
  *(unsigned char *)(a1 + 1400) = (v2 - 2) < 3;
}

uint64_t __copy_assignment_8_8_t0w16_pa0_323_16_pa0_24722_24_pa0_38677_32(uint64_t result, uint64_t a2)
{
  *(_OWORD *)uint64_t result = *(_OWORD *)a2;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

uint64_t __copy_assignment_8_8_t0w16_pa0_37031_16_pa0_15589_24_pa0_48845_32_pa0_31235_40_pa0_15173_48_pa0_1637_56_pa0_22919_64_pa0_52647_72_pa0_36147_80_pa0_30122_88(uint64_t result, uint64_t a2)
{
  *(_OWORD *)uint64_t result = *(_OWORD *)a2;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(result + 72) = *(void *)(a2 + 72);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(result + 88) = *(void *)(a2 + 88);
  return result;
}

uint64_t FigActivitySchedulerSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigBaseObject = FigActivitySchedulerGetFigBaseObject();
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
  if (!v8) {
    return 4294954514;
  }

  return v8(FigBaseObject, a2, a3);
}

uint64_t vmc2BuildDecompressionSession(uint64_t a1)
{
  value[0] = 0;
  if (!*(void *)(a1 + 32) || *(unsigned char *)(a1 + 40)) {
    return 0;
  }
  value[1] = vmc2OutputFrame;
  value[2] = (void *)a1;
  uint64_t v4 = *(void *)(a1 + 264);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(unsigned int (**)(uint64_t))(v6 + 24);
  uint64_t v8 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
  if (v7 && v7(v4))
  {
    uint64_t v9 = *(void *)(a1 + 264);
    uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, void **))(v11 + 48);
    if (v12)
    {
      uint64_t v13 = v12(v9, @"ThreadPriority", *v8, value);
      if (!v13) {
        goto LABEL_15;
      }
      uint64_t v2 = v13;
      CFTypeID v16 = 0;
      MutableCFArrayRef Copy = 0;
    }
    else
    {
      CFTypeID v16 = 0;
      MutableCFArrayRef Copy = 0;
      uint64_t v2 = 4294954514;
    }
LABEL_84:
    if (*(void *)(a1 + 64))
    {
      FigStopForwardingMediaServicesProcessDeathNotification();
      VTDecompressionSessionInvalidate(*(VTDecompressionSessionRef *)(a1 + 64));
      uint64_t v44 = *(const void **)(a1 + 64);
      if (v44) {
        CFRelease(v44);
      }
      *(void *)(a1 + 64) = 0;
      ++*(_DWORD *)(a1 + 1144);
    }
    goto LABEL_88;
  }
LABEL_15:
  CFAllocatorRef v14 = *v8;
  CFArrayRef Mutable = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFTypeID v16 = Mutable;
  if (Mutable)
  {
    if (value[0]) {
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F44D88], value[0]);
    }
    CFTypeID v17 = *(const void **)(a1 + 976);
    if (v17) {
      CFDictionarySetValue(v16, (const void *)*MEMORY[0x1E4F44DA8], v17);
    }
    double v18 = *(const void **)(a1 + 984);
    if (v18) {
      CFDictionarySetValue(v16, (const void *)*MEMORY[0x1E4F44D78], v18);
    }
    if (*(_DWORD *)(a1 + 840)) {
      FigCFDictionarySetInt32();
    }
    unint64_t v19 = *(const void **)(a1 + 848);
    if (v19) {
      CFDictionarySetValue(v16, (const void *)*MEMORY[0x1E4F44DA0], v19);
    }
    long long v20 = (const void **)MEMORY[0x1E4F1CFD0];
    if (*(unsigned char *)(a1 + 859)) {
      CFDictionarySetValue(v16, (const void *)*MEMORY[0x1E4F44D98], (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    if (*(unsigned char *)(a1 + 860)) {
      CFDictionarySetValue(v16, (const void *)*MEMORY[0x1E4F44D90], *v20);
    }
  }
  MutableCFArrayRef Copy = (const void *)FigCFDictionaryCreateMutableCopy();
  FigCFDictionarySetUInt32();
  CFGetAllocator((CFTypeRef)a1);
  CFAllocatorRef v22 = (VTSessionRef *)(a1 + 64);
  uint64_t started = VTDecompressionSessionCreateWithOptions();
  if (started) {
    goto LABEL_31;
  }
  ++*(_DWORD *)(a1 + 1140);
  uint64_t started = FigStartForwardingMediaServicesProcessDeathNotification();
  if (started) {
    goto LABEL_31;
  }
  CFArrayRef v24 = *(const __CFArray **)(a1 + 256);
  if (v24)
  {
    if (CFArrayGetCount(v24) >= 1)
    {
      uint64_t started = VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44CB8], *(CFTypeRef *)(a1 + 256));
      if (started) {
        goto LABEL_31;
      }
      uint64_t started = VTDecompressionSessionSetMultiImageCallback(*(VTDecompressionSessionRef *)(a1 + 64), (VTDecompressionOutputMultiImageCallback)vmc2OutputMultiImageFrame, (void *)a1);
      if (started) {
        goto LABEL_31;
      }
    }
  }
  CFTypeRef v25 = *(const void **)(a1 + 600);
  if (v25)
  {
    CFRelease(v25);
    *(void *)(a1 + 600) = 0;
  }
  VTSessionCopyProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44CC0], v14, (void *)(a1 + 600));
  *(_DWORD *)(a1 + 608) = 0;
  vmc2WhileHoldingTimebaseMutexUpdateQualityOfServiceCapability(a1);
  *(unsigned char *)(a1 + 626) = 1;
  uint64_t v26 = *(const void **)(a1 + 992);
  if (v26)
  {
    CFRelease(v26);
    *(void *)(a1 + 992) = 0;
  }
  VTSessionCopyProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44C60], v14, (void *)(a1 + 992));
  unint64_t v27 = *(const void **)(a1 + 56);
  if (v27)
  {
    uint64_t started = VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44C88], v27);
    if (started) {
      goto LABEL_31;
    }
  }
  if (*(_DWORD *)(a1 + 840))
  {
    CFNumberRef v28 = CFNumberCreate(v14, kCFNumberSInt32Type, (const void *)(a1 + 840));
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44C08], v28);
    CFRelease(v28);
  }
  if (*(unsigned char *)(a1 + 858)) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44C68], (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
  }
  if (*(unsigned char *)(a1 + 856)) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44CD0], (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
  }
  CFIndex v29 = *(const void **)(a1 + 736);
  if (v29) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44C30], v29);
  }
  CFIndex v30 = *(const void **)(a1 + 744);
  if (v30) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44CE8], v30);
  }
  uint64_t v31 = *(const void **)(a1 + 752);
  if (v31) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44C98], v31);
  }
  CFTypeID v32 = *(const void **)(a1 + 760);
  if (v32) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44CC8], v32);
  }
  CFTypeRef v33 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
  uint64_t v34 = (const void *)*MEMORY[0x1E4F1CFC8];
  if (*(unsigned char *)(a1 + 857)) {
    uint64_t v35 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    uint64_t v35 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44CA8], v35);
  if (*(unsigned char *)(a1 + 863)) {
    CFNumberRef v36 = v33;
  }
  else {
    CFNumberRef v36 = v34;
  }
  VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44CA0], v36);
  CFMutableDictionaryRef v37 = *(const void **)(a1 + 1000);
  if (v37) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44C10], v37);
  }
  long long v38 = *(const void **)(a1 + 1008);
  if (v38) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44CE0], v38);
  }
  uint64_t v39 = *(const void **)(a1 + 1016);
  if (v39) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44D08], v39);
  }
  long long v40 = *(const void **)(a1 + 1024);
  if (v40) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44C90], v40);
  }
  if (*(void *)(a1 + 768))
  {
    FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(*(CMFormatDescriptionRef *)(a1 + 32));
    if (MediaSubType == 1902212657 || MediaSubType == 1635135537) {
      VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44BF0], *(CFTypeRef *)(a1 + 768));
    }
  }
  if (value[0]) {
    VTSessionSetProperty(*v22, (CFStringRef)*MEMORY[0x1E4F44C38], value[0]);
  }
  CMNotificationCenterGetDefaultLocalCenter();
  uint64_t started = CMNotificationCenterAddListener();
  if (started
    || (CMNotificationCenterGetDefaultLocalCenter(), uint64_t started = FigNotificationCenterAddWeakListener(), started))
  {
LABEL_31:
    uint64_t v2 = started;
    goto LABEL_84;
  }
  *(void *)(a1 + 608) = 0x7FFFFFFF00000000;
  char v42 = *(const void **)(a1 + 64);
  if (v42)
  {
    CFTypeRef cf = 0;
    VTSessionCopyProperty(v42, (CFStringRef)*MEMORY[0x1E4F44CF0], v14, &cf);
    CFTypeRef v43 = cf;
    *(unsigned char *)(a1 + 1184) = cf != 0;
    if (v43)
    {
      *(unsigned char *)(a1 + 1185) = v43 == v33;
      CFRelease(v43);
    }
  }
  uint64_t v2 = 0;
LABEL_88:
  if (v16) {
    CFRelease(v16);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (value[0]) {
    CFRelease(value[0]);
  }
  return v2;
}

void vmc2UpdateExternalProtectionStatus(uint64_t a1)
{
  int v10 = 0;
  os_retain(*(void **)(a1 + 1392));
  voucher_adopt();
  uint64_t v2 = *(void *)(a1 + 808);
  if (v2)
  {
    uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v3) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = 0;
    }
    uint64_t v6 = *(unsigned int (**)(uint64_t, uint64_t, int *))(v4 + 24);
    if (v6 && !v6(v2, 7, &v10))
    {
      int v5 = v10;
    }
    else
    {
      int v5 = 0;
      int v10 = 0;
    }
  }
  else
  {
    int v5 = 1;
    int v10 = 1;
  }
  *(_DWORD *)(a1 + 836) = v5;
  UInt32 = (const void *)FigCFNumberCreateUInt32();
  MEMORY[0x19970E910](*(void *)(a1 + 72));
  uint64_t v8 = *(const void **)(a1 + 64);
  if (v8) {
    VTSessionSetProperty(v8, (CFStringRef)*MEMORY[0x1E4F44C48], UInt32);
  }
  MEMORY[0x19970E930](*(void *)(a1 + 72));
  uint64_t v9 = (void *)voucher_adopt();
  os_release(v9);
  if (UInt32) {
    CFRelease(UInt32);
  }
}

uint64_t vmc2InvokeOutputCallback_InstallOccupancyChangedCallback(uint64_t a1)
{
  FigReadWriteLockLockForRead();
  if (*(unsigned char *)(a1 + 249))
  {
    uint64_t v2 = *(uint64_t (**)(void, uint64_t, uint64_t (*)(uint64_t), uint64_t))(a1 + 176);
    if (v2)
    {
      uint64_t v3 = v2(*(void *)(a1 + 152), a1, vmc2OutputOccupancyChanged, a1 + 240);
      if (!v3) {
        *(unsigned char *)(a1 + 248) = 1;
      }
    }
    else
    {
      uint64_t v3 = 0;
    }
  }
  else
  {
    uint64_t v3 = FigSignalErrorAt();
  }
  FigReadWriteLockUnlockForRead();
  return v3;
}

uint64_t VMC2SetMinUpcomingPresentationTimeStamp(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    return FigSignalErrorAt();
  }
  else
  {
    MEMORY[0x19970E290](*(void *)(a1 + 280));
    uint64_t v5 = *(void *)(a2 + 16);
    *(_OWORD *)(a1 + 416) = *(_OWORD *)a2;
    *(void *)(a1 + 432) = v5;
    MEMORY[0x19970E2B0](*(void *)(a1 + 280));
    return vmc2RecalculateUpcomingImageTimes(a1);
  }
}

uint64_t vmc2ResetTroubleMonitorTimers(uint64_t result)
{
  if (*(unsigned char *)(result + 626))
  {
    uint64_t v1 = (unsigned char *)result;
    MEMORY[0x19970E910](*(void *)(result + 632));
    v1[640] = 0;
    v1[656] = 0;
    v1[672] = 0;
    v1[688] = 0;
    JUMPOUT(0x19970E930);
  }
  return result;
}

uint64_t VMC2WaitUntilPrerolled(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16))
  {
    return FigSignalErrorAt();
  }
  else
  {
    FigSemaphoreWaitRelative();
    return 0;
  }
}

uint64_t VMC2Reset(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    return FigSignalErrorAt();
  }
  else
  {
    MEMORY[0x19970E290](*(void *)(a1 + 280));
    uint64_t v5 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)(a1 + 416) = *MEMORY[0x1E4F1F9F8];
    *(void *)(a1 + 432) = *(void *)(v5 + 16);
    *(unsigned char *)(a1 + 520) = 0;
    *(unsigned char *)(a1 + 730) = 0;
    MEMORY[0x19970E2B0](*(void *)(a1 + 280));
    if (a2) {
      vmc2InvokeOutputCallback_FlushOutput(a1);
    }
    return 0;
  }
}

uint64_t vmc2InvokeOutputCallback_FlushOutput(uint64_t a1)
{
  FigReadWriteLockLockForRead();
  if (*(unsigned char *)(a1 + 249))
  {
    uint64_t v2 = *(void (**)(void))(a1 + 208);
    if (v2) {
      v2(*(void *)(a1 + 152));
    }
  }
  else
  {
    FigSignalErrorAt();
  }

  return FigReadWriteLockUnlockForRead();
}

uint64_t VMC2PretendOutputIsLow(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return FigSignalErrorAt();
  }
  *(unsigned char *)(a1 + 440) = 1;
  return 0;
}

uint64_t VMC2RequestDecodeForPreroll(uint64_t a1, const void *a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    return FigSignalErrorAt();
  }
  else
  {
    vmc2PostCompletedDecodeForPrerollIfPreviouslyRequestedAndMaybeRecordNewRequest(a1, 1, a2);
    uint64_t v4 = *(void *)(a1 + 264);
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(void (**)(uint64_t))(v6 + 16);
    if (v7) {
      v7(v4);
    }
    return 0;
  }
}

void vmc2PostCompletedDecodeForPrerollIfPreviouslyRequestedAndMaybeRecordNewRequest(uint64_t a1, char a2, const void *a3)
{
  MEMORY[0x19970E910](*(void *)(a1 + 704));
  int v6 = *(unsigned __int8 *)(a1 + 712);
  uint64_t v7 = *(void **)(a1 + 720);
  values = v7;
  *(unsigned char *)(a1 + 712) = a2;
  if (a3) {
    CFTypeRef v8 = CFRetain(a3);
  }
  else {
    CFTypeRef v8 = 0;
  }
  *(void *)(a1 + 720) = v8;
  MEMORY[0x19970E930](*(void *)(a1 + 704));
  if (v6)
  {
    if (v7) {
      CFDictionaryRef v9 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)kVideoMediaConverter2NotificationParameter_RequestID, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    else {
      CFDictionaryRef v9 = 0;
    }
    CMNotificationCenterGetDefaultLocalCenter();
    FigDispatchAsyncPostNotification();
    uint64_t v7 = values;
    if (values) {
      goto LABEL_11;
    }
  }
  else
  {
    CFDictionaryRef v9 = 0;
    if (v7) {
LABEL_11:
    }
      CFRelease(v7);
  }
  if (v9) {
    CFRelease(v9);
  }
}

uint64_t VMC2CopyPerformanceDictionary(uint64_t a1, __CFDictionary **a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 30, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  MEMORY[0x19970E910](*(void *)(a1 + 72));
  if (*(int *)(a1 + 1092) >= 1)
  {
    CFArrayRef v6 = *(const __CFArray **)(a1 + 600);
    if (v6)
    {
      int Count = CFArrayGetCount(v6);
      CFIndex v8 = *(int *)(a1 + 1092);
      if ((int)v8 < Count)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 600), v8);
        CFDictionarySetValue(Mutable, @"WorstQualityOfServiceTier", ValueAtIndex);
      }
    }
  }
  int v10 = *(const void **)(a1 + 64);
  if (v10 && (CFTypeRef v11 = CFRetain(v10)) != 0)
  {
    uint64_t v12 = v11;
    CFTypeRef propertyValueOut = 0;
    VTSessionCopyProperty(v11, (CFStringRef)*MEMORY[0x1E4F44CF0], v4, &propertyValueOut);
    if (propertyValueOut
      && (CFDictionarySetValue(Mutable, @"UsingHardwareAcceleratedVideoDecoder", propertyValueOut),
          (uint64_t v13 = propertyValueOut) != 0)
      || (CFDictionarySetValue(Mutable, @"UsingHardwareAcceleratedVideoDecoder", (const void *)*MEMORY[0x1E4F1CFD0]), (uint64_t v13 = propertyValueOut) != 0))
    {
      CFRelease(v13);
      CFTypeRef propertyValueOut = 0;
    }
    VTSessionCopyProperty(v12, (CFStringRef)*MEMORY[0x1E4F44CF8], v4, &propertyValueOut);
    if (propertyValueOut)
    {
      CFDictionarySetValue(Mutable, @"UsingSandboxedVideoDecoder", propertyValueOut);
      if (propertyValueOut) {
        CFRelease(propertyValueOut);
      }
    }
    MEMORY[0x19970E930](*(void *)(a1 + 72));
    *a2 = Mutable;
    CFRelease(v12);
  }
  else
  {
    MEMORY[0x19970E930](*(void *)(a1 + 72));
    *a2 = Mutable;
  }
  return 0;
}

uint64_t VMC2CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFDictionaryRef *a4)
{
  uint64_t v4 = 4294954473;
  if (a2 && a4)
  {
    if (CFEqual(@"ObeyEmptyMediaMarkers", a2))
    {
      CFDictionaryRef v9 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      int v10 = *(unsigned __int8 *)(a1 + 728);
LABEL_7:
      if (!v10) {
        CFDictionaryRef v9 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
      }
      CFTypeRef v11 = *v9;
LABEL_10:
      CFTypeRef v11 = CFRetain(v11);
LABEL_11:
      uint64_t v4 = 0;
      *a4 = (CFDictionaryRef)v11;
      return v4;
    }
    if (CFEqual(@"RenderEmptyMedia", a2))
    {
      CFDictionaryRef v9 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      int v10 = *(unsigned __int8 *)(a1 + 729);
      goto LABEL_7;
    }
    if (CFEqual(@"OutputPixelBufferPool", a2))
    {
      MEMORY[0x19970E910](*(void *)(a1 + 72));
      uint64_t v13 = *(const void **)(a1 + 64);
      if (v13) {
        uint64_t v4 = VTSessionCopyProperty(v13, (CFStringRef)*MEMORY[0x1E4F44C80], a3, a4);
      }
      else {
        uint64_t v4 = 0;
      }
LABEL_20:
      MEMORY[0x19970E930](*(void *)(a1 + 72));
      return v4;
    }
    if (CFEqual(@"FieldMode", a2))
    {
      CFTypeRef v11 = *(CFTypeRef *)(a1 + 736);
      if (!v11) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    if (CFEqual(@"AllowVideoQualityOfServiceAdjustments", a2))
    {
      CFAllocatorRef v14 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      int v15 = *(unsigned __int8 *)(a1 + 624);
    }
    else
    {
      if (CFEqual(@"DecoderUsage", a2))
      {
        CFTypeRef v11 = *(CFTypeRef *)(a1 + 744);
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      if (CFEqual(@"DecoderPriority", a2))
      {
        CFTypeRef v11 = *(CFTypeRef *)(a1 + 752);
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      if (CFEqual(@"QualityOfServiceTier", a2))
      {
        MEMORY[0x19970E910](*(void *)(a1 + 72));
        CFArrayRef v16 = *(const __CFArray **)(a1 + 600);
        if (v16)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v16, *(int *)(a1 + 608));
          if (ValueAtIndex) {
            CFDictionaryRef ValueAtIndex = CFRetain(ValueAtIndex);
          }
          uint64_t v4 = 0;
          *a4 = (CFDictionaryRef)ValueAtIndex;
        }
        else
        {
          uint64_t v4 = 4294954470;
        }
        goto LABEL_20;
      }
      if (CFEqual(@"DecoderThreadCount", a2))
      {
        CFTypeRef v11 = *(CFTypeRef *)(a1 + 760);
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      if (CFEqual(@"EndPresentationTimeForDecodedSamples", a2))
      {
        MEMORY[0x19970E290](*(void *)(a1 + 280));
        CMTime v19 = *(CMTime *)(a1 + 368);
        *a4 = CMTimeCopyAsDictionary(&v19, a3);
        MEMORY[0x19970E2B0](*(void *)(a1 + 280));
        return 0;
      }
      if (CFEqual(@"ForceFullPowerDecode", a2))
      {
        CFDictionaryRef v9 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
        int v10 = *(unsigned __int8 *)(a1 + 861);
        goto LABEL_7;
      }
      if (CFEqual(@"EnableIOFenceDecode", a2))
      {
        CFDictionaryRef v9 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
        int v10 = *(unsigned __int8 *)(a1 + 862);
        goto LABEL_7;
      }
      if (CFEqual(@"PropagatePerFrameHDRDisplayMetadata", a2))
      {
        CFDictionaryRef v9 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
        int v10 = *(unsigned __int8 *)(a1 + 863);
        goto LABEL_7;
      }
      if (CFEqual(@"DisplayLayerSize", a2))
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        FigCFDictionarySetCGSize();
        uint64_t v4 = 0;
        *a4 = Mutable;
        return v4;
      }
      if (CFEqual(@"EnhancementFilterOptions", a2))
      {
        CFTypeRef v11 = *(CFTypeRef *)(a1 + 896);
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      if (CFEqual(@"ColorPrimaries", a2))
      {
        CFTypeRef v11 = *(CFTypeRef *)(a1 + 1000);
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      if (CFEqual(@"TransferFunction", a2))
      {
        CFTypeRef v11 = *(CFTypeRef *)(a1 + 1008);
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      if (CFEqual(@"YCbCrMatrix", a2))
      {
        CFTypeRef v11 = *(CFTypeRef *)(a1 + 1016);
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      if (CFEqual(@"PreserveSyncFrames", a2))
      {
        CFDictionaryRef v9 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
        int v10 = *(unsigned __int8 *)(a1 + 731);
        goto LABEL_7;
      }
      if (CFEqual(@"PlaybackSessionID", a2))
      {
        CFTypeRef v11 = *(CFTypeRef *)(a1 + 1024);
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      if (CFEqual(@"HDRCrossTalker", a2))
      {
        CFTypeRef v11 = *(CFTypeRef *)(a1 + 1408);
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      if (!CFEqual(@"IsRunning", a2))
      {
        if (!CFEqual(@"CollectionRules", a2)) {
          return 4294954470;
        }
        CFTypeRef v11 = *(CFTypeRef *)(a1 + 1072);
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      CFAllocatorRef v14 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      int v15 = *(unsigned __int8 *)(a1 + 288);
    }
    if (!v15) {
      CFAllocatorRef v14 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
    }
    CFTypeRef v11 = *v14;
    if (!*v14) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  return v4;
}

uint64_t VMC2SetProperty(uint64_t a1, const void *a2, const __CFBoolean *a3)
{
  if (!a2) {
    return 4294954473;
  }
  if (*(unsigned char *)(a1 + 16)) {
    goto LABEL_183;
  }
  CFBooleanRef v4 = a3;
  if (!CFEqual(@"ObeyEmptyMediaMarkers", a2))
  {
    if (CFEqual(@"RenderEmptyMedia", a2))
    {
      if (v4)
      {
        CFTypeID TypeID = CFBooleanGetTypeID();
        if (TypeID == CFGetTypeID(v4))
        {
          Boolean Value = CFBooleanGetValue(v4);
          CFBooleanRef v4 = 0;
          *(unsigned char *)(a1 + 729) = Value;
          return (uint64_t)v4;
        }
      }
      goto LABEL_183;
    }
    if (CFEqual(@"ClientPID", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v11 = CFNumberGetTypeID();
      if (v11 != CFGetTypeID(v4)) {
        goto LABEL_183;
      }
      CFNumberGetValue(v4, kCFNumberSInt32Type, (void *)(a1 + 840));
      uint64_t v12 = *(void *)(a1 + 264);
      if (v12) {
        FigActivitySchedulerSetProperty(v12, @"ClientPID", (uint64_t)v4);
      }
      MEMORY[0x19970E910](*(void *)(a1 + 72));
      uint64_t v13 = *(const void **)(a1 + 64);
      if (!v13) {
        goto LABEL_30;
      }
      CFAllocatorRef v14 = (const __CFString **)MEMORY[0x1E4F44C08];
      goto LABEL_28;
    }
    if (CFEqual(@"ThrottleForBackground", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v15 = CFBooleanGetTypeID();
      if (v15 != CFGetTypeID(v4)) {
        goto LABEL_183;
      }
      *(unsigned char *)(a1 + 856) = CFBooleanGetValue(v4);
      uint64_t v16 = *(void *)(a1 + 264);
      if (v16) {
        FigActivitySchedulerSetProperty(v16, @"ThrottleForBackground", (uint64_t)v4);
      }
      MEMORY[0x19970E910](*(void *)(a1 + 72));
      uint64_t v13 = *(const void **)(a1 + 64);
      if (!v13) {
        goto LABEL_30;
      }
      CFAllocatorRef v14 = (const __CFString **)MEMORY[0x1E4F44CD0];
LABEL_28:
      CFStringRef v17 = *v14;
      CFBooleanRef v18 = v4;
LABEL_29:
      VTSessionSetProperty(v13, v17, v18);
LABEL_30:
      uint64_t v19 = *(void *)(a1 + 72);
LABEL_31:
      MEMORY[0x19970E930](v19);
      return 0;
    }
    if (CFEqual(@"FieldMode", a2))
    {
      if (v4)
      {
        CFTypeID v20 = CFStringGetTypeID();
        if (v20 != CFGetTypeID(v4)) {
          goto LABEL_183;
        }
      }
      if (!FigCFEqual())
      {
        CFIndex v21 = *(const void **)(a1 + 736);
        *(void *)(a1 + 736) = v4;
        if (v4) {
          CFRetain(v4);
        }
        if (v21) {
          CFRelease(v21);
        }
        MEMORY[0x19970E910](*(void *)(a1 + 72));
        uint64_t v13 = *(const void **)(a1 + 64);
        if (!v13) {
          goto LABEL_30;
        }
        CFStringRef v17 = (const __CFString *)*MEMORY[0x1E4F44C30];
        CFBooleanRef v18 = *(const __CFBoolean **)(a1 + 736);
        goto LABEL_29;
      }
      return 0;
    }
    if (CFEqual(@"AllowVideoQualityOfServiceAdjustments", a2))
    {
      CFTypeID v22 = CFBooleanGetTypeID();
      if (v22 != CFGetTypeID(v4)) {
        goto LABEL_183;
      }
      int v23 = *MEMORY[0x1E4F1CFD0] == (void)v4;
      if (*(unsigned __int8 *)(a1 + 624) != v23)
      {
        *(unsigned char *)(a1 + 624) = v23;
        MEMORY[0x19970E910](*(void *)(a1 + 72));
        vmc2WhileHoldingTimebaseMutexUpdateQualityOfServiceCapability(a1);
        if (!*(unsigned char *)(a1 + 624))
        {
          vmc2ResetTroubleMonitorTimers(a1);
          vmc2ResetQualityOfService(a1);
        }
        goto LABEL_30;
      }
      return 0;
    }
    if (CFEqual(@"DecoderUsage", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v24 = CFNumberGetTypeID();
      if (v24 != CFGetTypeID(v4)) {
        goto LABEL_183;
      }
      if (!FigCFEqual())
      {
        CFTypeRef v25 = *(const void **)(a1 + 744);
        *(void *)(a1 + 744) = v4;
        CFRetain(v4);
        if (v25) {
          CFRelease(v25);
        }
        MEMORY[0x19970E910](*(void *)(a1 + 72));
        uint64_t v13 = *(const void **)(a1 + 64);
        if (!v13) {
          goto LABEL_30;
        }
        CFStringRef v17 = (const __CFString *)*MEMORY[0x1E4F44CE8];
        CFBooleanRef v18 = *(const __CFBoolean **)(a1 + 744);
        goto LABEL_29;
      }
      return 0;
    }
    if (CFEqual(@"DecoderPriority", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v26 = CFNumberGetTypeID();
      if (v26 != CFGetTypeID(v4)) {
        goto LABEL_183;
      }
      if (!FigCFEqual())
      {
        unint64_t v27 = *(const void **)(a1 + 752);
        *(void *)(a1 + 752) = v4;
        CFRetain(v4);
        if (v27) {
          CFRelease(v27);
        }
        MEMORY[0x19970E910](*(void *)(a1 + 72));
        uint64_t v13 = *(const void **)(a1 + 64);
        if (!v13) {
          goto LABEL_30;
        }
        CFStringRef v17 = (const __CFString *)*MEMORY[0x1E4F44C98];
        CFBooleanRef v18 = *(const __CFBoolean **)(a1 + 752);
        goto LABEL_29;
      }
      return 0;
    }
    if (CFEqual(@"DecoderThreadCount", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v28 = CFNumberGetTypeID();
      if (v28 != CFGetTypeID(v4)) {
        goto LABEL_183;
      }
      if (!FigCFEqual())
      {
        CFIndex v29 = *(const void **)(a1 + 760);
        *(void *)(a1 + 760) = v4;
        CFRetain(v4);
        if (v29) {
          CFRelease(v29);
        }
        MEMORY[0x19970E910](*(void *)(a1 + 72));
        uint64_t v13 = *(const void **)(a1 + 64);
        if (!v13) {
          goto LABEL_30;
        }
        CFStringRef v17 = (const __CFString *)*MEMORY[0x1E4F44CC8];
        CFBooleanRef v18 = *(const __CFBoolean **)(a1 + 760);
        goto LABEL_29;
      }
      return 0;
    }
    if (CFEqual(@"MaxAgeForOutputPixelBufferPool", a2))
    {
      if (v4)
      {
        CFTypeID v30 = CFNumberGetTypeID();
        if (v30 != CFGetTypeID(v4)) {
          goto LABEL_183;
        }
        uint64_t v31 = (uint64_t *)(a1 + 72);
        MEMORY[0x19970E910](*(void *)(a1 + 72));
        vmc2PreallocatePixelBuffers(a1);
      }
      else
      {
        uint64_t v31 = (uint64_t *)(a1 + 72);
        MEMORY[0x19970E910](*(void *)(a1 + 72));
        CFBooleanRef v4 = *(const __CFBoolean **)(a1 + 992);
      }
      CFNumberRef v36 = *(const void **)(a1 + 64);
      if (v36 && v4) {
        VTSessionSetProperty(v36, (CFStringRef)*MEMORY[0x1E4F44C60], v4);
      }
      uint64_t v19 = *v31;
      goto LABEL_31;
    }
    if (CFEqual(@"VideoDecoderIsSecondary", a2))
    {
      if (v4)
      {
        CFTypeID v32 = CFBooleanGetTypeID();
        if (v32 == CFGetTypeID(v4))
        {
          if ((const __CFBoolean *)*MEMORY[0x1E4F1CFD0] == v4) {
            int v33 = 34;
          }
          else {
            int v33 = 3;
          }
          int valuePtr = v33;
          CFNumberRef v34 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
          if (!v34) {
            return FigSignalErrorAt();
          }
          CFNumberRef v35 = v34;
          CFBooleanRef v4 = (const __CFBoolean *)FigActivitySchedulerSetProperty(*(void *)(a1 + 264), @"ThreadPriority", (uint64_t)v34);
          if (!v4
            && FigActivitySchedulerIsProcessingCallbackCalledOnConsistentThread(*(void *)(a1 + 264)))
          {
            VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44C38], v35);
          }
          CFRelease(v35);
          return (uint64_t)v4;
        }
      }
      goto LABEL_183;
    }
    if (CFEqual(@"ForceFullPowerDecode", a2))
    {
      if (v4)
      {
        CFTypeID v37 = CFGetTypeID(v4);
        if (v37 == CFBooleanGetTypeID())
        {
          Boolean v38 = CFBooleanGetValue(v4);
          CFBooleanRef v4 = 0;
          *(unsigned char *)(a1 + 861) = v38;
          return (uint64_t)v4;
        }
      }
      goto LABEL_183;
    }
    if (CFEqual(@"PropagatePerFrameHDRDisplayMetadata", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v39 = CFGetTypeID(v4);
      if (v39 != CFBooleanGetTypeID()) {
        goto LABEL_183;
      }
      int v40 = CFBooleanGetValue(v4);
      if (*(unsigned __int8 *)(a1 + 863) != v40)
      {
        *(unsigned char *)(a1 + 863) = v40;
        MEMORY[0x19970E910](*(void *)(a1 + 72));
        uint64_t v13 = *(const void **)(a1 + 64);
        if (!v13) {
          goto LABEL_30;
        }
        CFAllocatorRef v14 = (const __CFString **)MEMORY[0x1E4F44CA0];
        goto LABEL_28;
      }
      return 0;
    }
    if (CFEqual(@"EnableIOFenceDecode", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v41 = CFGetTypeID(v4);
      if (v41 != CFBooleanGetTypeID()) {
        goto LABEL_183;
      }
      int v42 = CFBooleanGetValue(v4);
      if (*(unsigned __int8 *)(a1 + 862) != v42)
      {
        *(unsigned char *)(a1 + 862) = v42;
        MEMORY[0x19970E910](*(void *)(a1 + 72));
        uint64_t v13 = *(const void **)(a1 + 64);
        if (!v13) {
          goto LABEL_30;
        }
        CFAllocatorRef v14 = (const __CFString **)MEMORY[0x1E4F44C18];
        goto LABEL_28;
      }
      return 0;
    }
    if (CFEqual(@"DisplayLayerSize", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v43 = CFGetTypeID(v4);
      if (v43 != CFDictionaryGetTypeID()) {
        goto LABEL_183;
      }
      FigCFDictionaryGetCGSizeIfPresent();
      return 0;
    }
    if (CFEqual(@"EnhancementFilterOptions", a2))
    {
      if (v4)
      {
        CFTypeID v44 = CFGetTypeID(v4);
        if (v44 != CFDictionaryGetTypeID()) {
          goto LABEL_183;
        }
        uint64_t v45 = *(const void **)(a1 + 896);
        *(void *)(a1 + 896) = v4;
        CFRetain(v4);
        if (v45) {
          CFRelease(v45);
        }
        *(void *)(a1 + 904) = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 896), @"UseFilter");
        CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 896), @"ScaleMode");
        if (FigCFEqual())
        {
          CFBooleanRef v4 = 0;
          int v46 = 1;
LABEL_140:
          *(_DWORD *)(a1 + 912) = v46;
          return (uint64_t)v4;
        }
        CFBooleanRef v4 = 0;
        if (FigCFEqual())
        {
          int v46 = 2;
          goto LABEL_140;
        }
      }
      else
      {
        float v51 = *(const void **)(a1 + 896);
        if (v51)
        {
          CFRelease(v51);
          *(void *)(a1 + 896) = 0;
        }
        CFBooleanRef v4 = 0;
        *(void *)(a1 + 904) = 0;
      }
      *(_DWORD *)(a1 + 912) = 0;
      return (uint64_t)v4;
    }
    if (CFEqual(@"ColorPrimaries", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v47 = CFGetTypeID(v4);
      if (v47 != CFStringGetTypeID()) {
        goto LABEL_183;
      }
      CFTypeRef v48 = *(const void **)(a1 + 1000);
      *(void *)(a1 + 1000) = v4;
      CFRetain(v4);
      if (v48) {
        CFRelease(v48);
      }
      int v49 = *(const void **)(a1 + 64);
      if (!v49) {
        return 0;
      }
      float v50 = (CFStringRef *)MEMORY[0x1E4F44C10];
      goto LABEL_148;
    }
    if (CFEqual(@"TransferFunction", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v52 = CFGetTypeID(v4);
      if (v52 != CFStringGetTypeID()) {
        goto LABEL_183;
      }
      double v53 = *(const void **)(a1 + 1008);
      *(void *)(a1 + 1008) = v4;
      CFRetain(v4);
      if (v53) {
        CFRelease(v53);
      }
      int v49 = *(const void **)(a1 + 64);
      if (!v49) {
        return 0;
      }
      float v50 = (CFStringRef *)MEMORY[0x1E4F44CE0];
      goto LABEL_148;
    }
    if (CFEqual(@"YCbCrMatrix", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v54 = CFGetTypeID(v4);
      if (v54 != CFStringGetTypeID()) {
        goto LABEL_183;
      }
      int32_t v55 = *(const void **)(a1 + 1016);
      *(void *)(a1 + 1016) = v4;
      CFRetain(v4);
      if (v55) {
        CFRelease(v55);
      }
      int v49 = *(const void **)(a1 + 64);
      if (!v49) {
        return 0;
      }
      float v50 = (CFStringRef *)MEMORY[0x1E4F44D08];
      goto LABEL_148;
    }
    if (CFEqual(@"PreserveSyncFrames", a2))
    {
      if (v4)
      {
        CFTypeID v56 = CFGetTypeID(v4);
        if (v56 == CFBooleanGetTypeID())
        {
          Boolean v57 = CFBooleanGetValue(v4);
          CFBooleanRef v4 = 0;
          *(unsigned char *)(a1 + 731) = v57;
          return (uint64_t)v4;
        }
      }
      goto LABEL_183;
    }
    if (CFEqual(@"PlaybackSessionID", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v58 = CFGetTypeID(v4);
      if (v58 != CFStringGetTypeID()) {
        goto LABEL_183;
      }
      CFArrayRef v59 = *(const void **)(a1 + 1024);
      *(void *)(a1 + 1024) = v4;
      CFRetain(v4);
      if (v59) {
        CFRelease(v59);
      }
      int v49 = *(const void **)(a1 + 64);
      if (!v49) {
        return 0;
      }
      float v50 = (CFStringRef *)MEMORY[0x1E4F44C90];
LABEL_148:
      VTSessionSetProperty(v49, *v50, v4);
      return 0;
    }
    if (CFEqual(@"HDRCrossTalker", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v60 = CFGetTypeID(v4);
      if (v60 != FigCrossTalkerGetTypeID()) {
        goto LABEL_183;
      }
      CFIndex v61 = *(const void **)(a1 + 1408);
      *(void *)(a1 + 1408) = v4;
      CFRetain(v4);
      if (v61) {
        CFRelease(v61);
      }
      vmc2BroadcastHDRStatus(a1);
      return 0;
    }
    if (CFEqual(@"AV1FilmGrainMode", a2))
    {
      if (!v4) {
        goto LABEL_183;
      }
      CFTypeID v62 = CFGetTypeID(v4);
      if (v62 != CFStringGetTypeID()
        || !CFEqual((CFTypeRef)*MEMORY[0x1E4F44788], v4)
        && !CFEqual((CFTypeRef)*MEMORY[0x1E4F44790], v4)
        && !CFEqual((CFTypeRef)*MEMORY[0x1E4F44798], v4))
      {
        goto LABEL_183;
      }
      CFIndex v63 = *(const void **)(a1 + 768);
      *(void *)(a1 + 768) = v4;
      CFRetain(v4);
      if (v63) {
        CFRelease(v63);
      }
      if (*(void *)(a1 + 64))
      {
        FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(*(CMFormatDescriptionRef *)(a1 + 32));
        if (MediaSubType == 1902212657 || MediaSubType == 1635135537)
        {
          MEMORY[0x19970E910](*(void *)(a1 + 72));
          uint64_t v13 = *(const void **)(a1 + 64);
          CFStringRef v17 = (const __CFString *)*MEMORY[0x1E4F44BF0];
          CFBooleanRef v18 = *(const __CFBoolean **)(a1 + 768);
          goto LABEL_29;
        }
      }
      return 0;
    }
    if (CFEqual(@"PriorImageQueueGauge", a2))
    {
      if (v4)
      {
        CFTypeID v65 = CFGetTypeID(v4);
        if (v65 == FigImageQueueGaugeGetTypeID())
        {
          MEMORY[0x19970E910](*(void *)(a1 + 1480));
          if (*(void *)(a1 + 1488))
          {
            CFBooleanRef v4 = (const __CFBoolean *)FigSignalErrorAt();
          }
          else
          {
            *(void *)(a1 + 1488) = CFRetain(v4);
            CMNotificationCenterGetDefaultLocalCenter();
            FigNotificationCenterAddWeakListener();
            CMNotificationCenterGetDefaultLocalCenter();
            FigNotificationCenterAddWeakListener();
            CFBooleanRef v4 = 0;
          }
          MEMORY[0x19970E930](*(void *)(a1 + 1480));
          vmc2OutputOccupancyChanged(a1);
          return (uint64_t)v4;
        }
      }
      goto LABEL_183;
    }
    if (!CFEqual(@"CollectionRules", a2)) {
      return 4294954470;
    }
    if (v4)
    {
      CFTypeID v66 = CFGetTypeID(v4);
      if (v66 == FigSampleAttachmentCollectionRulesGetTypeID())
      {
        int32_t v67 = *(const void **)(a1 + 1072);
        *(void *)(a1 + 1072) = v4;
        CFRetain(v4);
        if (v67) {
          CFRelease(v67);
        }
      }
      return 0;
    }
    return (uint64_t)v4;
  }
  if (v4)
  {
    CFTypeID v7 = CFBooleanGetTypeID();
    if (v7 == CFGetTypeID(v4))
    {
      Boolean v8 = CFBooleanGetValue(v4);
      CFBooleanRef v4 = 0;
      *(unsigned char *)(a1 + 728) = v8;
      return (uint64_t)v4;
    }
  }
LABEL_183:

  return FigSignalErrorAt();
}

void vmc2WhileHoldingTimebaseMutexUpdateQualityOfServiceCapability(uint64_t a1)
{
  MEMORY[0x19970E910](*(void *)(a1 + 576));
  uint64_t v2 = *(void *)(a1 + 584);
  if (v2)
  {
    uint64_t v2 = *(void *)(a1 + 600);
    if (v2) {
      LOBYTE(v2) = *(unsigned char *)(a1 + 624) != 0;
    }
  }
  *(unsigned char *)(a1 + 625) = v2;

  JUMPOUT(0x19970E930);
}

double vmc2ResetQualityOfService(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 600);
  if (v2 && *(_DWORD *)(a1 + 608))
  {
    CFArrayGetValueAtIndex(v2, 0);
    CFStringRef v3 = (const __CFString *)*MEMORY[0x1E4F44D50];
    if (FigCFEqual())
    {
      uint64_t valuePtr = 0x3FF0000000000000;
      CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &valuePtr);
      VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44C78], (CFTypeRef)*MEMORY[0x1E4F44D38]);
      VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44CB0], v4);
      if (v4) {
        CFRelease(v4);
      }
    }
    else
    {
      uint64_t v5 = *(const void **)(a1 + 64);
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 600), 0);
      VTSessionSetProperties(v5, ValueAtIndex);
    }
    VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), v3, 0);
    if (*(int *)(a1 + 608) >= 1) {
      ++*(_DWORD *)(a1 + 1088);
    }
    double result = NAN;
    *(void *)(a1 + 608) = 0x7FFFFFFF00000000;
  }
  return result;
}

void vmc2PreallocatePixelBuffers(uint64_t a1)
{
  CFTypeRef propertyValueOut = 0;
  CVPixelBufferPoolRef pixelBufferPool = 0;
  if ((*(_DWORD *)(a1 + 484) & 0x1D) == 1)
  {
    signed int MediaSubType = CMFormatDescriptionGetMediaSubType(*(CMFormatDescriptionRef *)(a1 + 32));
    if (MediaSubType <= 1685481572)
    {
      BOOL v3 = MediaSubType == 1667524657 || MediaSubType == 1684895096;
      int v5 = 1685481521;
    }
    else
    {
      if (MediaSubType > 1902405732)
      {
        BOOL v3 = MediaSubType == 1902405733;
        unsigned __int16 v4 = 28024;
      }
      else
      {
        BOOL v3 = MediaSubType == 1685481573;
        unsigned __int16 v4 = 26673;
      }
      int v5 = v4 | 0x71640000;
    }
    if (!v3 && MediaSubType != v5)
    {
      CMTime v17 = *(CMTime *)(a1 + 472);
      CMTimeConvertScale(&v18, &v17, 30, kCMTimeRoundingMethod_RoundAwayFromZero);
      size_t value = v18.value;
      if (v18.value >= 1)
      {
        CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        VTSessionCopyProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44CF8], (CFAllocatorRef)*MEMORY[0x1E4F1CF80], &propertyValueOut);
        CFTypeRef v9 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
        CFTypeRef v10 = propertyValueOut;
        if (propertyValueOut) {
          CFRelease(propertyValueOut);
        }
        if (v9 != v10)
        {
          VTSessionCopyProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44C80], v8, &pixelBufferPool);
          if (pixelBufferPool)
          {
            CFTypeID v11 = (CVPixelBufferRef *)malloc_type_calloc(value, 8uLL, 0x2004093837F09uLL);
            if (v11)
            {
              uint64_t v12 = v11;
              MEMORY[0x19970E930](*(void *)(a1 + 72));
              size_t v13 = value;
              CFAllocatorRef v14 = v12;
              do
              {
                CVPixelBufferPoolCreatePixelBuffer(0, pixelBufferPool, v14++);
                --v13;
              }
              while (v13);
              uint64_t v15 = 0;
              do
              {
                uint64_t v16 = v12[v15];
                if (v16) {
                  CVPixelBufferRelease(v16);
                }
                ++v15;
              }
              while (value != v15);
              free(v12);
              CVPixelBufferPoolRelease(pixelBufferPool);
              MEMORY[0x19970E910](*(void *)(a1 + 72));
            }
            else
            {
              CVPixelBufferPoolRelease(pixelBufferPool);
            }
          }
        }
      }
    }
  }
}

uint64_t FigActivitySchedulerIsProcessingCallbackCalledOnConsistentThread(uint64_t a1)
{
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  unsigned __int16 v4 = *(uint64_t (**)(uint64_t))(v3 + 24);
  if (!v4) {
    return 0;
  }

  return v4(a1);
}

uint64_t vmc2BroadcastHDRStatus(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result && *(void *)(a1 + 1408))
  {
    uint64_t v3 = (uint64_t *)((int)CMVideoFormatDescriptionGetVideoDynamicRange() <= 1 ? MEMORY[0x1E4F1CFC8] : MEMORY[0x1E4F1CFD0]);
    FigBytePumpGetFigBaseObject(*(void *)(a1 + 1408));
    uint64_t v5 = v4;
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v8 = *(void *)(VTable + 8);
    uint64_t result = VTable + 8;
    uint64_t v7 = v8;
    uint64_t v9 = v8 ? v7 : 0;
    CFTypeRef v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    if (v10)
    {
      uint64_t v11 = *v3;
      return v10(v5, 0x1EE56ACD8, v11);
    }
  }
  return result;
}

uint64_t vmc2HandleSessionTerminatedNotification(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 857)) {
    *(unsigned char *)(a2 + 1034) = 1;
  }
  CMNotificationCenterGetDefaultLocalCenter();

  return CMNotificationCenterPostNotification();
}

uint64_t vmc2UpdateSessionMinAndMaxOutputPTS(uint64_t result)
{
  CMTime v8 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CMTime v7 = v8;
  if (*(void *)(result + 64))
  {
    uint64_t v1 = result;
    MEMORY[0x19970E290](*(void *)(result + 280));
    int v2 = *(_DWORD *)(v1 + 316);
    do
    {
      MEMORY[0x19970E2B0](*(void *)(v1 + 280));
      VTDecompressionSessionGetMinAndMaxOutputPresentationTimeStampOfFramesBeingDecoded();
      MEMORY[0x19970E290](*(void *)(v1 + 280));
      BOOL v3 = v2 == *(_DWORD *)(v1 + 316);
      int v2 = *(_DWORD *)(v1 + 316);
    }
    while (!v3);
    CMTime time1 = *(CMTime *)(v1 + 320);
    CMTime v5 = v8;
    int32_t v4 = CMTimeCompare(&time1, &v5);
    if (v4) {
      *(CMTime *)(v1 + 320) = v8;
    }
    CMTime time1 = *(CMTime *)(v1 + 344);
    CMTime v5 = v7;
    if (CMTimeCompare(&time1, &v5))
    {
      *(CMTime *)(v1 + 344) = v7;
    }
    else if (!v4)
    {
LABEL_11:
      ++*(_DWORD *)(v1 + 316);
      return MEMORY[0x19970E2B0](*(void *)(v1 + 280));
    }
    vmc2RecalculateUpcomingImageTimes(v1);
    goto LABEL_11;
  }
  return result;
}

CFTypeRef vmc2CopyFormattingDesc(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return CFRetain(@"[VMC2 (invalidated)]");
  }
  else {
    return CFRetain(@"[VMC2]");
  }
}

__CFString *vmc2CopyDebugDesc(unsigned char *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFIndex v4 = CFGetRetainCount(a1);
  if (a1[16]) {
    CMTime v5 = " (invalidated)";
  }
  else {
    CMTime v5 = "";
  }
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"VMC2 %p retainCount: %d%s allocator: %p", a1, v4, v5, v6);
  return Mutable;
}

void vmc2OutputMultiImageFrame(uint64_t a1, _DWORD *a2, int a3, unsigned int a4, uint64_t a5, CMTime *a6, uint64_t a7)
{
  CMTime v9 = *a6;
  long long v7 = *(_OWORD *)a7;
  uint64_t v8 = *(void *)(a7 + 16);
  vmc2OutputFrameInternal(a1, a2, a3, a4, 0, a5, &v9, &v7, 0);
}

void vmc2OutputFrameInternal(uint64_t a1, _DWORD *a2, int a3, unsigned int a4, uint64_t a5, uint64_t a6, CMTime *a7, long long *a8, char a9)
{
  uint64_t v156 = *MEMORY[0x1E4F143B8];
  CFTypeRef v125 = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  CFTypeRef cf = 0;
  unsigned int v114 = a4;
  if ((a4 & 8) != 0) {
    int v14 = 0;
  }
  else {
    int v14 = -17694;
  }
  if (a3 == -17694) {
    int v15 = v14;
  }
  else {
    int v15 = a3;
  }
  if (a2)
  {
    int v18 = *a2;
    int v17 = a2[1];
    CFArrayRef v121 = (const void *)*((void *)a2 + 1);
    CFTypeRef v116 = (CFTypeRef)*((void *)a2 + 4);
    CFTypeRef value = (CFTypeRef)*((void *)a2 + 2);
    CFTypeRef v118 = (CFTypeRef)*((void *)a2 + 5);
    CFTypeRef v119 = (CFTypeRef)*((void *)a2 + 3);
    CFTypeRef v112 = (CFTypeRef)*((void *)a2 + 6);
    mach_absolute_time();
    int v19 = *((unsigned __int8 *)a2 + 72);
    CFTypeRef v113 = (CFTypeRef)*((void *)a2 + 7);
    free(a2);
  }
  else
  {
    LOBYTE(v18) = 0;
    int v17 = 0;
    CFArrayRef v121 = 0;
    CFTypeRef value = 0;
    CFTypeRef v118 = 0;
    CFTypeRef v119 = 0;
    CFTypeRef v116 = 0;
    CFTypeRef v112 = 0;
    int v19 = 0;
    CFTypeRef v113 = 0;
  }
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CMTimeRange theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (theDict) {
    BOOL v20 = v19 == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20 && *(unsigned char *)(a1 + 731)) {
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E4F1F288], (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  CFIndex v21 = v121;
  if (v121)
  {
    CFTypeID v22 = malloc_type_calloc(1uLL, 0x58uLL, 0x10E0040E756AD93uLL);
    if (v22)
    {
      int v23 = v22;
      v22[1] = CFRetain(v121);
      *((_DWORD *)v23 + 4) = v15;
      *((_DWORD *)v23 + 5) = v114;
      v114 &= ~4u;
      v23[3] = CVBufferRetain((CVBufferRef)a5);
      if (a6) {
        CFTypeRef v24 = CFRetain((CFTypeRef)a6);
      }
      else {
        CFTypeRef v24 = 0;
      }
      void v23[4] = v24;
      long long v25 = *(_OWORD *)&a7->value;
      v23[7] = a7->epoch;
      *(_OWORD *)(v23 + 5) = v25;
      long long v26 = *a8;
      v23[10] = *((void *)a8 + 2);
      *((_OWORD *)v23 + 4) = v26;
      *int v23 = *(void *)(a1 + 800);
      *(void *)(a1 + 800) = v23;
    }
  }
  MEMORY[0x19970E910](*(void *)(a1 + 776));
  int v27 = *(_DWORD *)(a1 + 792);
  if (v17 != v27)
  {
    a6 = 0;
    a5 = 0;
  }
  MEMORY[0x19970E930](*(void *)(a1 + 776));
  if (!v15)
  {
    int v28 = v18 & 3;
    if (v28 != 1) {
      goto LABEL_30;
    }
    ++*(_DWORD *)(a1 + 1096);
LABEL_29:
    vmc2ResetTroubleMonitorTimers(a1);
    a6 = 0;
    a5 = 0;
    int v28 = 1;
    CFIndex v29 = v116;
    goto LABEL_37;
  }
  CMTime lhs = *a7;
  vmc2PostDecodeError(a1);
  int v28 = v18 & 3;
  if (v28 == 1) {
    goto LABEL_29;
  }
LABEL_30:
  CFIndex v29 = v116;
  if (!(a5 | a6))
  {
    if (v17 == v27)
    {
      ++*(_DWORD *)(a1 + 1100);
      CFTypeID v30 = (_OWORD *)(a1 + 1448);
      if ((*(unsigned char *)(a1 + 1460) & 1) != 0
        && (*(_OWORD *)&lhs.CFTypeRef value = *v30,
            lhs.CMTimeEpoch epoch = *(void *)(a1 + 1464),
            CMTime rhs = *(CMTime *)(a1 + 1420),
            CMTimeAdd(&time2, &lhs, &rhs),
            CMTime lhs = *a7,
            CMTimeCompare(&lhs, &time2) < 1))
      {
        int v38 = *(_DWORD *)(a1 + 1472) + 1;
        *(_DWORD *)(a1 + 1472) = v38;
        if (v38 == *(_DWORD *)(a1 + 1444)) {
          ++*(_DWORD *)(a1 + 1104);
        }
      }
      else
      {
        long long v31 = *(_OWORD *)&a7->value;
        *(void *)(a1 + 1464) = a7->epoch;
        *CFTypeID v30 = v31;
        *(_DWORD *)(a1 + 1472) = 1;
      }
      MEMORY[0x19970E910](*(void *)(a1 + 1160));
      ++*(_DWORD *)(a1 + 1340);
      MEMORY[0x19970E930](*(void *)(a1 + 1160));
      a6 = 0;
      a5 = 0;
    }
    else
    {
      vmc2ResetTroubleMonitorTimers(a1);
      a6 = 0;
      a5 = 0;
      ++*(_DWORD *)(a1 + 1124);
    }
  }
LABEL_37:
  BOOL v32 = (a6 | a5) == 0;
  if (!(a6 | a5))
  {
    a6 = 0;
    a5 = 0;
    double v33 = 0.0;
    goto LABEL_54;
  }
  int v34 = *(_DWORD *)(a1 + 836);
  ++*(_DWORD *)(a1 + 1108);
  double v33 = (double)FigHostTimeToNanoseconds() * 0.000000001;
  if (v34 != 1 && v34 != 4)
  {
    CFTypeRef v35 = CVBufferCopyAttachment((CVBufferRef)a5, @"IsDRMSubstitute", 0);
    CFTypeRef v36 = v35;
    CFTypeRef v37 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
    if (v35) {
      CFRelease(v35);
    }
    if (v37 != v36)
    {
      VTDecompressionSessionCopyBlackPixelBuffer(*(VTDecompressionSessionRef *)(a1 + 64), &pixelBufferOut);
      if (a5)
      {
        a5 = (uint64_t)pixelBufferOut;
LABEL_53:
        ++*(_DWORD *)(a1 + 1132);
        goto LABEL_54;
      }
      if (a6)
      {
        if (pixelBufferOut)
        {
          vmcCreateTaggedBufferGroupSubstitutingImageBufferInTaggedBufferGroup(pixelBufferOut, (OpaqueCMTaggedBufferGroup *)a6, &v125);
          a5 = 0;
          a6 = (uint64_t)v125;
          goto LABEL_53;
        }
        a6 = 0;
      }
      a5 = 0;
      goto LABEL_53;
    }
  }
LABEL_54:
  if (!(a5 | a6)) {
    goto LABEL_184;
  }
  int v39 = 4 * (v28 == 3);
  if (v28 == 2) {
    int v39 = 3;
  }
  unsigned int v109 = v39;
  MEMORY[0x19970E910](*(void *)(a1 + 576));
  int v40 = *(const void **)(a1 + 584);
  if (v40) {
    timebase = (OpaqueCMTimebase *)CFRetain(v40);
  }
  else {
    timebase = 0;
  }
  MEMORY[0x19970E930](*(void *)(a1 + 576));
  if (!v28)
  {
    CMTime type = *a7;
    if (timebase)
    {
      float Rate = CMTimebaseGetRate(timebase);
      if (Rate > 0.0)
      {
        memset(&lhs, 0, sizeof(lhs));
        CMTimebaseGetTime(&lhs, timebase);
        CMTime rhs = lhs;
        CMTime v129 = type;
        if (CMTimeCompare(&rhs, &v129) < 1) {
          goto LABEL_61;
        }
LABEL_121:
        ++*(_DWORD *)(a1 + 1120);
        goto LABEL_61;
      }
      if (Rate < 0.0)
      {
        memset(&lhs, 0, sizeof(lhs));
        CMTimebaseGetTime(&lhs, timebase);
        CMTime rhs = lhs;
        CMTime v129 = type;
        if (CMTimeCompare(&rhs, &v129) < 0) {
          goto LABEL_121;
        }
      }
    }
  }
LABEL_61:
  if (a5)
  {
    if (value) {
      CVBufferSetAttachment((CVBufferRef)a5, @"SourceRect", value, kCVAttachmentMode_ShouldPropagate);
    }
    if (v119 && v29)
    {
      CVBufferSetAttachment((CVBufferRef)a5, @"DestRect", v119, kCVAttachmentMode_ShouldPropagate);
      CVBufferSetAttachment((CVBufferRef)a5, @"VirtualDisplaySizeForDestRect", v29, kCVAttachmentMode_ShouldPropagate);
    }
    if (v118) {
      CVBufferSetAttachment((CVBufferRef)a5, @"SymmetricTransform", v118, kCVAttachmentMode_ShouldPropagate);
    }
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)a5);
  }
  else
  {
    OSType PixelFormatType = 32;
  }
  if (!*(unsigned char *)(a1 + 888) && (!*(unsigned char *)(a1 + 889) || PixelFormatType != *(_DWORD *)(a1 + 892)) && !a6)
  {
    if ((size_t Width = CVPixelBufferGetWidth((CVPixelBufferRef)a5),
          size_t Height = CVPixelBufferGetHeight((CVPixelBufferRef)a5),
          unint64_t v55 = Height,
          *(unsigned char *)(a1 + 889) = 0,
          double v56 = *(double *)(a1 + 872),
          v56 >= (double)Width)
      && *(double *)(a1 + 880) >= (double)Height
      && *MEMORY[0x1E4F1CFC8] != *(void *)(a1 + 904)
      || *MEMORY[0x1E4F1CFD0] == *(void *)(a1 + 904))
    {
      if (Width != *(void *)(a1 + 920)
        || Height != *(void *)(a1 + 928)
        || *(void *)(a1 + 936) != (unint64_t)v56
        || *(void *)(a1 + 944) != (unint64_t)*(double *)(a1 + 880))
      {
        vmc2FinishAndDestroyImageEnhancementFilter(a1);
      }
      if (*(void *)(a1 + 952)
        || (int ImageEnhancementFilter = vmc2CreateImageEnhancementFilter(a1, Width, v55), *(void *)(a1 + 952)))
      {
        mach_absolute_time();
        type.CFTypeRef value = a7->value;
        CMTimeFlags flags = a7->flags;
        type.CMTimeScale timescale = a7->timescale;
        CMTimeEpoch epoch = a7->epoch;
        OSType v104 = PixelFormatType;
        if (!*(void *)(a1 + 952))
        {
          int v101 = FigSignalErrorAt();
          int v49 = timebase;
          if (!v101) {
            goto LABEL_212;
          }
LABEL_222:
          lhs.CFTypeRef value = type.value;
          lhs.CMTimeScale timescale = type.timescale;
          lhs.CMTimeFlags flags = flags;
          lhs.CMTimeEpoch epoch = epoch;
          vmc2CopyFrameBaggageForPTS(a1, &lhs, 0, 0, 0);
          CFIndex v29 = v116;
          if (v101 == -12218)
          {
            *(unsigned char *)(a1 + 889) = 1;
            *(_DWORD *)(a1 + 892) = v104;
          }
          goto LABEL_76;
        }
        v129.CFTypeRef value = a7->value;
        v129.CMTimeScale timescale = a7->timescale;
        rhs.CFTypeRef value = 0;
        *(void *)&rhs.CMTimeScale timescale = &rhs;
        rhs.CMTimeEpoch epoch = 0x2000000000;
        *(_DWORD *)uint64_t v131 = 0;
        if ((flags & 0x1D) == 1)
        {
          if (*(void *)(a1 + 960))
          {
LABEL_107:
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            lhs.CFTypeRef value = v129.value;
            lhs.CMTimeScale timescale = v129.timescale;
            lhs.CMTimeFlags flags = flags;
            lhs.CMTimeEpoch epoch = epoch;
            Float64 valuePtr = CMTimeGetSeconds(&lhs);
            CFNumberRef v61 = CFNumberCreate(allocator, kCFNumberFloat64Type, &valuePtr);
            FigCFDictionarySetInt32();
            FigCFDictionarySetInt32();
            CFDictionarySetValue(Mutable, @"OriginalFrame", (const void *)a5);
            CFTypeID v62 = *(NSObject **)(a1 + 968);
            lhs.CFTypeRef value = MEMORY[0x1E4F143A8];
            *(void *)&lhs.CMTimeScale timescale = 0x40000000;
            lhs.CMTimeEpoch epoch = (CMTimeEpoch)__vmc2StoreFrameBaggageForPTS_block_invoke;
            uint64_t v151 = &unk_1E578C660;
            CFNumberRef v154 = v61;
            CMItemIndex v155 = Mutable;
            p_CMTime rhs = &rhs;
            uint64_t v153 = a1;
            dispatch_sync(v62, &lhs);
            if (Mutable) {
              CFRelease(Mutable);
            }
            if (v61) {
              CFRelease(v61);
            }
            goto LABEL_210;
          }
          if (*(unsigned char *)(a1 + 16))
          {
            uint64_t v100 = v131;
          }
          else
          {
            CFMutableDictionaryRef v103 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            *(void *)(a1 + 960) = v103;
            if (v103) {
              goto LABEL_107;
            }
            uint64_t v100 = (_DWORD *)(*(void *)&rhs.timescale + 24);
          }
          *uint64_t v100 = -12824;
        }
        else
        {
          *(_DWORD *)(*(void *)&rhs.timescale + 24) = FigSignalErrorAt();
        }
LABEL_210:
        int v101 = *(_DWORD *)(*(void *)&rhs.timescale + 24);
        _Block_object_dispose(&rhs, 8);
        if (!v101)
        {
          lhs.CFTypeRef value = type.value;
          lhs.CMTimeScale timescale = type.timescale;
          lhs.CMTimeFlags flags = flags;
          lhs.CMTimeEpoch epoch = epoch;
          int v102 = VTTemporalFilterSessionProcessFrame();
          int v49 = timebase;
          if (!v102)
          {
LABEL_212:
            mach_absolute_time();
            double v48 = (double)FigHostTimeToNanoseconds() * 0.000000001;
            int v47 = 1;
            CFIndex v29 = v116;
            CFIndex v21 = v121;
            goto LABEL_124;
          }
          int v101 = v102;
        }
        FigSignalErrorAt();
        goto LABEL_222;
      }
      if (ImageEnhancementFilter) {
        *(unsigned char *)(a1 + 888) = 1;
      }
    }
  }
LABEL_76:
  if (*(void *)(a1 + 952)) {
    vmc2FinishAndDestroyImageEnhancementFilter(a1);
  }
  if (!*(void *)(a1 + 128) || !a5)
  {
    float v50 = *(void (**)(uint64_t, uint64_t, CMTime *, CFTypeRef *))(a1 + 112);
    if (v50 && a5)
    {
      uint64_t v51 = *(void *)(a1 + 104);
      CMTime lhs = *a7;
      v50(v51, a5, &lhs, &cf);
      if (cf) {
        a5 = (uint64_t)cf;
      }
      CFIndex v21 = v121;
    }
    else
    {
      CFIndex v21 = v121;
      if (!a5)
      {
        if (a6 && (CMItemCount Count = CMTaggedBufferGroupGetCount((CMTaggedBufferGroupRef)a6), Count >= 1))
        {
          CMItemCount v64 = Count;
          for (uint64_t i = 0; i != v64; ++i)
          {
            CVPixelBufferAtIndex = (__CVBuffer *)FigTaggedBufferGroupGetCVPixelBufferAtIndex();
            if (!a9 && CVPixelBufferAtIndex)
            {
              CMTime lhs = *a7;
              vmcAddPresentationTimeAsAttachment(CVPixelBufferAtIndex);
            }
          }
          a5 = 0;
          CFIndex v21 = v121;
        }
        else
        {
          a5 = 0;
        }
        goto LABEL_123;
      }
    }
    if (!a9)
    {
      CMTime lhs = *a7;
      vmcAddPresentationTimeAsAttachment((__CVBuffer *)a5);
      uint64_t v52 = *(void *)(a1 + 1072);
      if (v52) {
        FigSampleAttachmentCollectionRulesAttachAttachmentsToPixelBuffer(v52, (uint64_t)v113, a5);
      }
    }
LABEL_123:
    int v49 = timebase;
    CMTime lhs = *a7;
    vmc2InvokeOutputCallback_OutputImage(a1, a5, a6, (v114 >> 2) & 1, (uint64_t)theDict, (long long *)&lhs.value, v109);
    int v47 = 0;
    double v48 = 0.0;
    goto LABEL_124;
  }
  CFTypeID v43 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x10200406E8F4065uLL);
  *(void *)CFTypeID v43 = CFRetain((CFTypeRef)a1);
  CMTimeEpoch v44 = a7->epoch;
  *(_OWORD *)(v43 + 8) = *(_OWORD *)&a7->value;
  *((void *)v43 + 3) = v44;
  *((_DWORD *)v43 + 8) = v109;
  uint64_t v45 = *(void (**)(uint64_t, uint64_t, CMTime *, void (*)(char *, __CVBuffer *), char *))(a1 + 128);
  uint64_t v46 = *(void *)(a1 + 104);
  CMTime lhs = *a7;
  v45(v46, a5, &lhs, vmc2FinishOutputFrame, v43);
  int v47 = 0;
  double v48 = 0.0;
  CFIndex v21 = v121;
  int v49 = timebase;
LABEL_124:
  if (*(unsigned char *)(a1 + 441)) {
    *(_WORD *)(a1 + 440) = 0;
  }
  MEMORY[0x19970E910](*(void *)(a1 + 1160));
  if (!v32)
  {
    if (a5 || a6 && (a5 = FigTaggedBufferGroupGetCVPixelBufferAtIndex()) != 0)
    {
      *(_DWORD *)(a1 + 1188) = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)a5);
      *(_DWORD *)(a1 + 1192) = CVPixelBufferGetWidth((CVPixelBufferRef)a5);
      *(_DWORD *)(a1 + 1196) = CVPixelBufferGetHeight((CVPixelBufferRef)a5);
    }
    ++*(_DWORD *)(a1 + 1336);
    *(double *)(a1 + 1344) = v33 + *(double *)(a1 + 1344);
    *(double *)(a1 + 1352) = fmax(*(double *)(a1 + 1352), v33);
  }
  if (v47)
  {
    ++*(_DWORD *)(a1 + 1360);
    *(double *)(a1 + 1368) = v48 + *(double *)(a1 + 1368);
    *(double *)(a1 + 1376) = fmax(*(double *)(a1 + 1376), v48);
  }
  CMTime lhs = *a7;
  double Seconds = CMTimeGetSeconds(&lhs);
  double v68 = (int *)(a1 + 1200);
  int v69 = *(_DWORD *)(a1 + 1200);
  int v70 = *(_DWORD *)(a1 + 1204);
  if (v70 + v69 <= 0) {
    uint64_t v71 = -(-(v70 + v69) & 3);
  }
  else {
    uint64_t v71 = (v70 + v69) & 3;
  }
  float v72 = (double *)&v68[8 * v71];
  v72[1] = Seconds;
  v72[2] = v33;
  *((unsigned char *)v72 + 32) = v47;
  v72[3] = v48;
  unsigned int v73 = v70 + 1;
  if (v73 > 4)
  {
    int v74 = v69 + 1;
    BOOL v75 = -v74 < 0;
    int v76 = -v74 & 3;
    int v77 = v74 & 3;
    if (!v75) {
      int v77 = -v76;
    }
    int *v68 = v77;
  }
  else
  {
    *(_DWORD *)(a1 + 1204) = v73;
  }
  MEMORY[0x19970E930](*(void *)(a1 + 1160));
  uint64_t v78 = mach_absolute_time();
  if ((unint64_t)FigHostTimeToNanoseconds() >= 0x165A0BC00)
  {
    *(void *)(a1 + 1168) = v78;
    if (v49)
    {
      CMTimebaseGetTime(&time, v49);
      Float64 v79 = CMTimeGetSeconds(&time);
      Float64 v80 = CMTimebaseGetRate(v49);
    }
    else
    {
      Float64 v79 = 0.0;
      Float64 v80 = 0.0;
    }
    long long v81 = CFStringCreateMutable(allocator, 0);
    MEMORY[0x19970E910](*(void *)(a1 + 1160));
    unsigned int v82 = *(_DWORD *)(a1 + 1336);
    double v83 = *(double *)(a1 + 1344);
    unsigned int v115 = *(_DWORD *)(a1 + 1360);
    double v84 = *(double *)(a1 + 1368);
    CFAllocatorRef allocatora = *(CFAllocatorRef *)(a1 + 1352);
    uint64_t v110 = *(void *)(a1 + 1376);
    int v105 = *(_DWORD *)(a1 + 1384);
    int v106 = *(_DWORD *)(a1 + 1340);
    *(_OWORD *)(a1 + 1336) = 0u;
    *(_OWORD *)(a1 + 1352) = 0u;
    *(_OWORD *)(a1 + 1368) = 0u;
    *(void *)(a1 + 1384) = 0;
    int v85 = *(_DWORD *)(a1 + 1204);
    int v86 = *(_DWORD *)(a1 + 1200);
    if (*(_DWORD *)(a1 + 1180)) {
      CFStringAppendFormat(v81, 0, @"CodecType: %c%c%c%c", HIBYTE(*(_DWORD *)(a1 + 1180)), BYTE2(*(_DWORD *)(a1 + 1180)), BYTE1(*(_DWORD *)(a1 + 1180)), *(_DWORD *)(a1 + 1180));
    }
    if (*(unsigned char *)(a1 + 1184))
    {
      if (*(unsigned char *)(a1 + 1185)) {
        unsigned int v87 = "HW";
      }
      else {
        unsigned int v87 = "SW";
      }
      CFStringAppendFormat(v81, 0, @" (%s decoder)", v87);
    }
    if (*(_DWORD *)(a1 + 1188)) {
      CFStringAppendFormat(v81, 0, @", DecodedPixelBuffer: %c%c%c%c, %u x %u\n", HIBYTE(*(_DWORD *)(a1 + 1188)), BYTE2(*(_DWORD *)(a1 + 1188)), BYTE1(*(_DWORD *)(a1 + 1188)), *(_DWORD *)(a1 + 1188), *(unsigned int *)(a1 + 1192), *(unsigned int *)(a1 + 1196));
    }
    CFStringAppendCString(v81, "Last Decoded Frames [\n", 0x600u);
    if (v85 >= 1)
    {
      do
      {
        if (v86 <= 0) {
          int v88 = -(-v86 & 3);
        }
        else {
          int v88 = v86 & 3;
        }
        uint64_t v89 = a1 + 32 * v88;
        int v90 = *(unsigned __int8 *)(v89 + 1232);
        double v91 = *(double *)(v89 + 1224);
        CFStringAppendFormat(v81, 0, @"{PTS: %.3f s, decode: %.3f ms", *(void *)(v89 + 1208), *(double *)(v89 + 1216) * 1000.0);
        if (v90) {
          CFStringAppendFormat(v81, 0, @", enhancement blocked: %.3f ms", v91 * 1000.0);
        }
        CFStringAppend(v81, @"},\n");
        ++v86;
        --v85;
      }
      while (v85);
    }
    CFStringAppendCString(v81, "]\n", 0x600u);
    *(void *)(a1 + 1328) = 0;
    *(_OWORD *)(a1 + 1296) = 0u;
    *(_OWORD *)(a1 + 1312) = 0u;
    *(_OWORD *)(a1 + 1264) = 0u;
    *(_OWORD *)(a1 + 1280) = 0u;
    *(_OWORD *)(a1 + 1232) = 0u;
    *(_OWORD *)(a1 + 1248) = 0u;
    *(_OWORD *)double v68 = 0u;
    *(_OWORD *)(a1 + 1216) = 0u;
    MEMORY[0x19970E930](*(void *)(a1 + 1160));
    if (v82) {
      double v83 = v83 / (double)v82;
    }
    CFIndex v29 = v116;
    if (v115) {
      double v84 = v84 / (double)v115;
    }
    if (dword_1E934D4F0)
    {
      LODWORD(v129.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v93 = v129.value;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type.value)) {
        unsigned int v94 = v93;
      }
      else {
        unsigned int v94 = v93 & 0xFFFFFFFE;
      }
      if (v94)
      {
        int v95 = *(_DWORD *)(a1 + 1176);
        int v96 = *(_DWORD *)(a1 + 608);
        LODWORD(rhs.CFDictionarySetValue(theDict, key, value) = 136318210;
        *(CMTimeValue *)((char *)&rhs.value + 4) = (CMTimeValue)"vmc2GMFigLogDumpStats";
        LOWORD(rhs.flags) = 2048;
        *(void *)((char *)&rhs.flags + 2) = a1;
        HIWORD(rhs.epoch) = 1024;
        *(_DWORD *)uint64_t v131 = v95;
        *(_WORD *)&v131[4] = 2048;
        *(Float64 *)&v131[6] = v79;
        __int16 v132 = 2048;
        Float64 v133 = v80;
        __int16 v134 = 1024;
        int v135 = v105;
        __int16 v136 = 1024;
        unsigned int v137 = v82;
        __int16 v138 = 1024;
        int v139 = v106;
        __int16 v140 = 2048;
        double v141 = v83;
        __int16 v142 = 2048;
        CFAllocatorRef v143 = allocatora;
        __int16 v144 = 2048;
        double v145 = v84;
        __int16 v146 = 2048;
        uint64_t v147 = v110;
        __int16 v148 = 1024;
        int v149 = v96;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      if (dword_1E934D4F0)
      {
        LODWORD(v129.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
        AudioQueueParameterID v97 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v98 = v129.value;
        if (os_log_type_enabled(v97, type.value)) {
          unsigned int v99 = v98;
        }
        else {
          unsigned int v99 = v98 & 0xFFFFFFFE;
        }
        if (v99)
        {
          LODWORD(rhs.CFDictionarySetValue(theDict, key, value) = 136315650;
          *(CMTimeValue *)((char *)&rhs.value + 4) = (CMTimeValue)"vmc2GMFigLogDumpStats";
          LOWORD(rhs.flags) = 2048;
          *(void *)((char *)&rhs.flags + 2) = a1;
          HIWORD(rhs.epoch) = 2114;
          *(void *)uint64_t v131 = v81;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
    }
    CFIndex v21 = v121;
    int v49 = timebase;
    if (v81) {
      CFRelease(v81);
    }
  }
  if (v49) {
    CFRelease(v49);
  }
LABEL_184:
  if (cf) {
    CFRelease(cf);
  }
  if (pixelBufferOut) {
    CFRelease(pixelBufferOut);
  }
  if (v125) {
    CFRelease(v125);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (value) {
    CFRelease(value);
  }
  if (v119) {
    CFRelease(v119);
  }
  if (v118) {
    CFRelease(v118);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (v112) {
    CFRelease(v112);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (v113) {
    CFRelease(v113);
  }
}

void vmc2PostDecodeError(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32();
  FigCFDictionarySetCMTime();
  BOOL v3 = *(const opaqueCMFormatDescription **)(a1 + 32);
  if (v3)
  {
    CMFormatDescriptionGetMediaSubType(v3);
    FigCFDictionarySetInt32();
  }
  CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification();
  if (Mutable) {
    CFRelease(Mutable);
  }
  ++*(_DWORD *)(a1 + 1136);
}

void vmcCreateTaggedBufferGroupSubstitutingImageBufferInTaggedBufferGroup(const void *a1, OpaqueCMTaggedBufferGroup *a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  long long v7 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFMutableArrayRef v9 = CFArrayCreateMutable(v6, 0, v7);
  CFTypeRef v10 = v9;
  if (Mutable) {
    BOOL v11 = v9 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11) {
    goto LABEL_18;
  }
  CMItemCount Count = CMTaggedBufferGroupGetCount(a2);
  if (Count >= 1)
  {
    CMItemCount v13 = Count;
    CFIndex v14 = 0;
    while (1)
    {
      CMTagCollectionRef TagCollectionAtIndex = CMTaggedBufferGroupGetTagCollectionAtIndex(a2, v14);
      if (!TagCollectionAtIndex) {
        break;
      }
      CFArrayAppendValue(Mutable, TagCollectionAtIndex);
      CFArrayAppendValue(v10, a1);
      if (v13 == ++v14) {
        goto LABEL_9;
      }
    }
LABEL_18:
    FigSignalErrorAt();
    if (!Mutable) {
      goto LABEL_13;
    }
LABEL_12:
    CFRelease(Mutable);
    goto LABEL_13;
  }
LABEL_9:
  if (!MEMORY[0x19970EBC0](v6, Mutable, v10, &cf))
  {
    *a3 = cf;
    CFTypeRef cf = 0;
  }
  if (Mutable) {
    goto LABEL_12;
  }
LABEL_13:
  if (v10) {
    CFRelease(v10);
  }
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t vmc2CreateImageEnhancementFilter(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  uint64_t v8 = a1 + 872;
  uint64_t v9 = 2 * a2;
  BOOL v10 = *(double *)(a1 + 872) < (double)(2 * a2) || *(double *)(a1 + 880) < (double)(2 * a3);
  int v11 = *(_DWORD *)(a1 + 912);
  if (v11 == 2) {
    BOOL v10 = 0;
  }
  if (v11 == 1) {
    BOOL v10 = 1;
  }
  if (v10) {
    uint64_t v9 = a2;
  }
  unint64_t v12 = a3 << !v10;
  uint64_t v13 = *MEMORY[0x1E4F1CFD0];
  uint64_t v14 = *(void *)(a1 + 904);
  if (*MEMORY[0x1E4F1CFD0] == v14)
  {
    int v15 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    if (a2 > 0x500 || a3 > 0x2D0) {
      return v3;
    }
    int v15 = @"Weak";
    if (a2 == 1280 && a3 >= 0x1F5)
    {
      int v15 = @"StaticWeak";
      if (v9 == 1280 && v12 == a3) {
        return 0;
      }
    }
  }
  long long v25 = v15;
  v27.width = (double)(unint64_t)v9;
  v27.height = (double)v12;
  propertyBoolean Value = CGSizeCreateDictionaryRepresentation(v27);
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  int v17 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  int v18 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F454D0], @"com.apple.videotoolbox.temporalfilter.SRSEnhancementFilter");
  BOOL v20 = CFDictionaryCreateMutable(v16, 0, v17, v18);
  FigCFDictionarySetInt32();
  CFDictionarySetValue(v20, (const void *)*MEMORY[0x1E4F454C8], @"SRS");
  CFIndex v21 = (VTSessionRef *)(a1 + 952);
  uint64_t v22 = VTTemporalFilterSessionCreate();
  if (v22)
  {
    uint64_t v3 = v22;
    CFDictionaryRef v23 = propertyValue;
LABEL_40:
    vmc2FinishAndDestroyImageEnhancementFilter(a1);
    if (!v23) {
      goto LABEL_33;
    }
    goto LABEL_32;
  }
  *(void *)(a1 + 920) = a2;
  *(void *)(a1 + 928) = a3;
  *(uint64x2_t *)(v8 + 64) = vcvtq_u64_f64(*(float64x2_t *)v8);
  CFDictionaryRef v23 = propertyValue;
  if (propertyValue
    && (uint64_t v24 = VTSessionSetProperty(*v21, (CFStringRef)*MEMORY[0x1E4F454A8], propertyValue), v24)
    || (uint64_t v24 = VTSessionSetProperty(*v21, (CFStringRef)*MEMORY[0x1E4F45488], (CFTypeRef)*MEMORY[0x1E4F1CFC8]), v24))
  {
    uint64_t v3 = v24;
LABEL_38:
    FigSignalErrorAt();
    goto LABEL_40;
  }
  if (v13 == v14)
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = VTSessionSetProperty(*v21, (CFStringRef)*MEMORY[0x1E4F45490], v25);
    if (v3) {
      goto LABEL_38;
    }
  }
  if (propertyValue) {
LABEL_32:
  }
    CFRelease(v23);
LABEL_33:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v20) {
    CFRelease(v20);
  }
  return v3;
}

void vmc2FinishOutputFrame(char *a1, __CVBuffer *a2)
{
  uint64_t v3 = *(unsigned char **)a1;
  if (!v3[16])
  {
    long long v7 = *(_OWORD *)(a1 + 8);
    uint64_t v8 = *((void *)a1 + 3);
    vmcAddPresentationTimeAsAttachment(a2);
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = *((unsigned int *)a1 + 8);
    long long v7 = *(_OWORD *)(a1 + 8);
    uint64_t v8 = *((void *)a1 + 3);
    vmc2InvokeOutputCallback_OutputImage(v5, (uint64_t)a2, 0, 1, 0, &v7, v6);
    uint64_t v3 = *(unsigned char **)a1;
  }
  CFRelease(v3);

  free(a1);
}

void vmcAddPresentationTimeAsAttachment(__CVBuffer *a1)
{
  CFAllocatorRef v2 = (const void *)CMTimeCopyAsCVBufferTimeDictionary();
  if (v2)
  {
    uint64_t v3 = v2;
    CVBufferSetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F24980], v2, kCVAttachmentMode_ShouldPropagate);
    CFRelease(v3);
  }
}

uint64_t FigSampleAttachmentCollectionRulesAttachAttachmentsToPixelBuffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v9 = *(void *)(VTable + 16);
  uint64_t result = VTable + 16;
  uint64_t v8 = v9;
  if (v9) {
    uint64_t v10 = v8;
  }
  else {
    uint64_t v10 = 0;
  }
  int v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 40);
  if (v11)
  {
    return v11(a1, a2, a3);
  }
  return result;
}

uint64_t vmc2InvokeOutputCallback_OutputImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, long long *a6, uint64_t a7)
{
  FigReadWriteLockLockForRead();
  if (*(unsigned char *)(a1 + 249))
  {
    uint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, long long *, uint64_t))(a1 + 200);
    if (v14)
    {
      uint64_t v15 = *(void *)(a1 + 152);
      long long v17 = *a6;
      uint64_t v18 = *((void *)a6 + 2);
      v14(v15, a2, a3, a4, a5, &v17, a7);
    }
  }
  else
  {
    FigSignalErrorAt();
  }
  return FigReadWriteLockUnlockForRead();
}

void vmcTemporalFilterOutput(uint64_t a1, int a2, uint64_t a3, CMTime *a4, __CVBuffer *a5)
{
  unsigned int v17 = 0;
  unsigned int v16 = 0;
  CFTypeRef cf = 0;
  if (!*(unsigned char *)(a1 + 16))
  {
    CMTime v14 = *a4;
    vmc2CopyFrameBaggageForPTS(a1, &v14, &v16, &v17, (const __CFDictionary **)&cf);
    if (a2 || !a5)
    {
      if (!cf)
      {
        FigSignalErrorAt();
LABEL_9:
        if (cf) {
          CFRelease(cf);
        }
        return;
      }
      uint64_t v13 = (v16 >> 2) & 1;
      CMTime v14 = *a4;
      vmcAddPresentationTimeAsAttachment((__CVBuffer *)cf);
      CFTypeRef v11 = cf;
      uint64_t v9 = v17;
      CMTime v14 = *a4;
      uint64_t v10 = a1;
      uint64_t v12 = v13;
    }
    else
    {
      CMTime v14 = *a4;
      vmcAddPresentationTimeAsAttachment(a5);
      uint64_t v9 = v17;
      CMTime v14 = *a4;
      uint64_t v10 = a1;
      CFTypeRef v11 = a5;
      uint64_t v12 = 1;
    }
    vmc2InvokeOutputCallback_OutputImage(v10, (uint64_t)v11, 0, v12, 0, (long long *)&v14.value, v9);
    goto LABEL_9;
  }
}

void vmc2CopyFrameBaggageForPTS(uint64_t a1, CMTime *a2, _DWORD *a3, _DWORD *a4, const __CFDictionary **a5)
{
  uint64_t v22 = 0;
  CFDictionaryRef v23 = &v22;
  uint64_t v24 = 0x2000000000;
  int v25 = 0;
  Float64 valuePtr = 0.0;
  uint64_t v21 = 0;
  uint64_t v16 = 0;
  unsigned int v17 = &v16;
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = 0;
  if (*(void *)(a1 + 960) && (a2->flags & 0x1D) == 1)
  {
    CMTime time = *a2;
    Float64 valuePtr = CMTimeGetSeconds(&time);
    CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat64Type, &valuePtr);
    uint64_t v10 = *(NSObject **)(a1 + 968);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 0x40000000;
    _OWORD v14[2] = __vmc2CopyFrameBaggageForPTS_block_invoke;
    v14[3] = &unk_1E578C638;
    v14[6] = a1;
    v14[7] = v9;
    v14[4] = &v16;
    v14[5] = &v22;
    dispatch_sync(v10, v14);
    FigCFDictionaryGetInt32IfPresent();
    FigCFDictionaryGetInt32IfPresent();
    CFDictionaryRef Value = (const __CFDictionary *)v17[3];
    if (Value) {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, @"OriginalFrame");
    }
    if (a3) {
      goto LABEL_6;
    }
  }
  else
  {
    int v13 = FigSignalErrorAt();
    CFNumberRef v9 = 0;
    CFDictionaryRef Value = 0;
    *((_DWORD *)v23 + 6) = v13;
    if (a3) {
LABEL_6:
    }
      *a3 = v21;
  }
  if (a4) {
    *a4 = HIDWORD(v21);
  }
  if (a5)
  {
    if (Value) {
      CFDictionaryRef Value = (const __CFDictionary *)CFRetain(Value);
    }
    *a5 = Value;
  }
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v12 = (const void *)v17[3];
  if (v12) {
    CFRelease(v12);
  }
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v22, 8);
}

void __vmc2CopyFrameBaggageForPTS_block_invoke(uint64_t a1)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(*(void *)(a1 + 48) + 960);
  if (v2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue(v2, *(const void **)(a1 + 56));
  }
  uint64_t v3 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v3)
  {
    CFRetain(v3);
    CFIndex v4 = *(const void **)(a1 + 56);
    uint64_t v5 = *(__CFDictionary **)(*(void *)(a1 + 48) + 960);
    CFDictionaryRemoveValue(v5, v4);
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = FigSignalErrorAt();
  }
}

void __vmc2StoreFrameBaggageForPTS_block_invoke(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 40) + 960)) {
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 40) + 960), *(const void **)(a1 + 48), *(const void **)(a1 + 56));
  }
  else {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -12824;
  }
}

void vmc2UpdateTroubleMonitor2(uint64_t a1, int a2, int a3, int a4, int a5)
{
  MEMORY[0x19970E910](*(void *)(a1 + 576));
  uint64_t v10 = *(const void **)(a1 + 584);
  if (!v10)
  {
    MEMORY[0x19970E930](*(void *)(a1 + 576));
    CFTypeRef v11 = 0;
    goto LABEL_6;
  }
  CFTypeRef v11 = (void *)CFRetain(v10);
  MEMORY[0x19970E930](*(void *)(a1 + 576));
  if (!v11)
  {
LABEL_6:
    char v12 = 1;
    goto LABEL_7;
  }
  if (CMTimebaseGetRate((CMTimebaseRef)v11) == 0.0)
  {
    vmc2ResetTroubleMonitorTimers(a1);
    vmc2ResetQualityOfService(a1);
LABEL_47:
    CFRelease(v11);
    return;
  }
  char v12 = 0;
LABEL_7:
  MEMORY[0x19970E910](*(void *)(a1 + 632));
  if (!a2 || !a3)
  {
    *(unsigned char *)(a1 + 640) = 0;
LABEL_21:
    *(unsigned char *)(a1 + 672) = 0;
    goto LABEL_22;
  }
  if (*(unsigned char *)(a1 + 640))
  {
    uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    if (a5 && UpTimeNanoseconds >= *(void *)(a1 + 648))
    {
      ++*(_DWORD *)(a1 + 1080);
      if (*(unsigned char *)(a1 + 625)) {
        vmc2AdjustQualityOfService(a1, 1);
      }
    }
    else if (*(unsigned char *)(a1 + 640))
    {
      goto LABEL_18;
    }
  }
  *(unsigned char *)(a1 + 640) = 1;
  *(void *)(a1 + 648) = FigGetUpTimeNanoseconds() + 500000000;
LABEL_18:
  if (*(unsigned char *)(a1 + 672))
  {
    if (FigGetUpTimeNanoseconds() >= *(void *)(a1 + 680))
    {
      *(unsigned char *)(a1 + 656) = 0;
      goto LABEL_21;
    }
  }
  else if (*(unsigned char *)(a1 + 656))
  {
    *(unsigned char *)(a1 + 672) = 1;
    *(void *)(a1 + 680) = FigGetUpTimeNanoseconds() + 250000000;
  }
LABEL_22:
  if (*(unsigned char *)(a1 + 656) && a5 && !*(unsigned char *)(a1 + 640) && FigGetUpTimeNanoseconds() >= *(void *)(a1 + 664))
  {
    if (*(unsigned char *)(a1 + 625)) {
      vmc2AdjustQualityOfService(a1, -1);
    }
    *(unsigned char *)(a1 + 656) = 0;
  }
  if (a4 && !*(unsigned char *)(a1 + 656) && *(int *)(a1 + 608) >= 1)
  {
    *(unsigned char *)(a1 + 656) = 1;
    *(void *)(a1 + 664) = FigGetUpTimeNanoseconds() + 2000000000;
  }
  if (a5 && *(unsigned char *)(a1 + 688) && FigGetUpTimeNanoseconds() >= *(void *)(a1 + 696))
  {
    if (*(unsigned char *)(a1 + 625)) {
      vmc2AdjustQualityOfService(a1, -1);
    }
    *(unsigned char *)(a1 + 688) = 0;
  }
  if (a2)
  {
    *(unsigned char *)(a1 + 688) = 0;
  }
  else if (!*(unsigned char *)(a1 + 640) && !*(unsigned char *)(a1 + 656) && !*(unsigned char *)(a1 + 688) && *(int *)(a1 + 608) >= 1)
  {
    *(unsigned char *)(a1 + 688) = 1;
    *(void *)(a1 + 696) = FigGetUpTimeNanoseconds() + 750000000;
  }
  MEMORY[0x19970E930](*(void *)(a1 + 632));
  if ((v12 & 1) == 0) {
    goto LABEL_47;
  }
}

void vmc2WhileHoldingSessionVTMutexUpdateTroubleMonitor(unsigned __int8 *a1)
{
  uint64_t v2 = *(void *)a1;
  if (!*(unsigned char *)(*(void *)a1 + 16))
  {
    int v3 = a1[8];
    MEMORY[0x19970E910](*(void *)(v2 + 72));
    int v4 = *(unsigned __int8 *)(v2 + 592);
    if (vmc2GetWaterLevelState(v2)) {
      BOOL v5 = *(unsigned char *)(v2 + 440) != 0;
    }
    else {
      BOOL v5 = 1;
    }
    int v6 = vmc2GetWaterLevelState(v2) == 2 && *(unsigned char *)(v2 + 440) == 0;
    vmc2UpdateTroubleMonitor2(v2, v4, v5, v6, v3);
    MEMORY[0x19970E930](*(void *)(v2 + 72));
  }
  CFRelease((CFTypeRef)v2);

  free(a1);
}

void vmc2AdjustQualityOfService(uint64_t a1, int a2)
{
  v25[16] = *MEMORY[0x1E4F143B8];
  if (a2 >= 0) {
    int v3 = a2;
  }
  else {
    int v3 = -a2;
  }
  if (v3 == 1) {
    int v4 = a2;
  }
  else {
    int v4 = (a2 >> 31) | 1;
  }
  CFArrayRef v5 = *(const __CFArray **)(a1 + 600);
  if (v5)
  {
    int v7 = *(_DWORD *)(a1 + 608);
    int v8 = *(_DWORD *)(a1 + 616) <= *(_DWORD *)(a1 + 620) ? *(_DWORD *)(a1 + 620) : *(_DWORD *)(a1 + 616);
    if ((a2 & 0x80000000) == 0 || v7)
    {
      CFIndex Count = CFArrayGetCount(v5);
      if (a2 < 0 || Count != v7 + 1)
      {
        uint64_t v10 = (_DWORD *)(a1 + 612);
        CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 600), *(int *)(a1 + 608));
        CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F44D50];
        int v12 = FigCFEqual();
        if (v8 && v12)
        {
          int v13 = *v10 - v4;
          *uint64_t v10 = v13;
          if (v13 >= v8)
          {
            *(_DWORD *)(a1 + 608) += v4;
            *(_DWORD *)(a1 + 612) = v8;
            int v13 = v8;
          }
          if (v13 < 0) {
            *(void *)(a1 + 608) = (*(_DWORD *)(a1 + 608) + v4);
          }
        }
        else
        {
          CFIndex v14 = *(int *)(a1 + 608) + (uint64_t)v4;
          *(_DWORD *)(a1 + 608) = v14;
          CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 600), v14);
          if (FigCFEqual())
          {
            if (v8)
            {
              if (a2 < 0) {
                *uint64_t v10 = 0;
              }
              else {
                *uint64_t v10 = v8 - 1;
              }
            }
            else
            {
              *(_DWORD *)(a1 + 608) += v4;
            }
          }
        }
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 600), *(int *)(a1 + 608));
        if (FigCFEqual())
        {
          CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFNumberRef v17 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(a1 + 612));
          VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), v11, v17);
          if (v17) {
            CFRelease(v17);
          }
          if (a2 < 0)
          {
            CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 600), v7);
            if (!FigCFEqual())
            {
              int v18 = *(_DWORD *)(a1 + 608);
              if (v18 < 1)
              {
                v25[0] = 0x3FF0000000000000;
                CFNumberRef v24 = CFNumberCreate(v16, kCFNumberDoubleType, v25);
                VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44C78], (CFTypeRef)*MEMORY[0x1E4F44D38]);
                VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), (CFStringRef)*MEMORY[0x1E4F44CB0], v24);
                if (v24) {
                  CFRelease(v24);
                }
              }
              else
              {
                uint64_t v19 = *(const void **)(a1 + 64);
                CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 600), (v18 - 1));
                VTSessionSetProperties(v19, ValueAtIndex);
              }
            }
LABEL_38:
            ++*(_DWORD *)(a1 + 1088);
LABEL_39:
            int v23 = *(_DWORD *)(a1 + 608);
            if (v23 > *(_DWORD *)(a1 + 1092)) {
              *(_DWORD *)(a1 + 1092) = v23;
            }
            return;
          }
        }
        else
        {
          uint64_t v21 = *(const void **)(a1 + 64);
          CFDictionaryRef v22 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 600), *(int *)(a1 + 608));
          VTSessionSetProperties(v21, v22);
          if (a2 < 0)
          {
            CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 600), v7);
            if (FigCFEqual()) {
              VTSessionSetProperty(*(VTSessionRef *)(a1 + 64), v11, 0);
            }
            goto LABEL_38;
          }
        }
        ++*(_DWORD *)(a1 + 1084);
        goto LABEL_39;
      }
    }
  }
}

uint64_t vmc2GetWaterLevelState(uint64_t a1)
{
  void (*v4)(CMTime *__return_ptr, void);
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  unsigned int (*v9)(uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(CMTime *__return_ptr, uint64_t);
  char v14;
  CMTime v16;
  CMTime rhs;
  CMTime lhs;
  CMTime v19;

  int v2 = *(_DWORD *)(a1 + 524);
  if (*(_DWORD *)(a1 + 528) != v2)
  {
    FigMemoryBarrier();
    CFAllocatorRef v16 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
    FigReadWriteLockLockForRead();
    if (*(unsigned char *)(a1 + 249))
    {
      int v4 = *(void (**)(CMTime *__return_ptr, void))(a1 + 168);
      if (v4)
      {
        memset(&v19, 0, sizeof(v19));
        v4(&v19, *(void *)(a1 + 152));
        CFAllocatorRef v16 = v19;
      }
      MEMORY[0x19970E910](*(void *)(a1 + 1480));
      CFArrayRef v5 = *(void *)(a1 + 1488);
      if (v5)
      {
        int v6 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v6) {
          int v7 = v6;
        }
        else {
          int v7 = 0;
        }
        CFNumberRef v9 = *(unsigned int (**)(uint64_t))(v7 + 32);
        if (v9) {
          int v8 = v9(v5) == 0;
        }
        else {
          int v8 = 0;
        }
        if ((v16.flags & 0x1D) == 1)
        {
          memset(&v19, 0, sizeof(v19));
          uint64_t v10 = *(void *)(a1 + 1488);
          CFStringRef v11 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v11) {
            int v12 = v11;
          }
          else {
            int v12 = 0;
          }
          int v13 = *(void (**)(CMTime *__return_ptr, uint64_t))(v12 + 16);
          if (v13) {
            v13(&v19, v10);
          }
          else {
            uint64_t v19 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
          }
          CMTime lhs = v16;
          CMTime rhs = v19;
          CMTimeAdd(&v16, &lhs, &rhs);
        }
      }
      else
      {
        int v8 = 0;
      }
      MEMORY[0x19970E930](*(void *)(a1 + 1480));
      CFIndex v14 = !v8;
    }
    else
    {
      FigSignalErrorAt();
      CFIndex v14 = 1;
    }
    FigReadWriteLockUnlockForRead();
    uint64_t v19 = v16;
    MEMORY[0x19970E910](*(void *)(a1 + 536));
    *(CMTime *)(a1 + 544) = v19;
    if (v14)
    {
      CMTime lhs = v19;
      CMTime rhs = *(CMTime *)(a1 + 496);
      if (CMTimeCompare(&lhs, &rhs) < 0)
      {
        uint64_t v3 = 0;
        *(_DWORD *)(a1 + 568) = 0;
        goto LABEL_33;
      }
      CMTime lhs = v19;
      CMTime rhs = *(CMTime *)(a1 + 472);
      if (CMTimeCompare(&lhs, &rhs) < 0)
      {
        uint64_t v3 = *(unsigned int *)(a1 + 568);
        if (v3 == 2)
        {
          uint64_t v3 = 3;
        }
        else
        {
          if (v3) {
            goto LABEL_33;
          }
          uint64_t v3 = 1;
        }
        *(_DWORD *)(a1 + 568) = v3;
        goto LABEL_33;
      }
    }
    uint64_t v3 = 2;
    *(_DWORD *)(a1 + 568) = 2;
    *(unsigned char *)(a1 + 572) = 0;
LABEL_33:
    *(_DWORD *)(a1 + 528) = v2;
    goto LABEL_34;
  }
  MEMORY[0x19970E910](*(void *)(a1 + 536));
  uint64_t v3 = *(unsigned int *)(a1 + 568);
LABEL_34:
  MEMORY[0x19970E930](*(void *)(a1 + 536));
  return v3;
}

uint64_t vmc2RecalculateUpcomingImageTimes2(uint64_t result)
{
  *(_DWORD *)(result + 444) = 0;
  if (!*(unsigned char *)(result + 16))
  {
    uint64_t v1 = result;
    MEMORY[0x19970E910](*(void *)(result + 296));
    vmc2RecalculateUpcomingImageTimes(v1);
    JUMPOUT(0x19970E930);
  }
  return result;
}

uint64_t vmcGetCompressedFrameOutputMode(opaqueCMSampleBuffer *a1)
{
  CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(a1, 0);
  if (SampleAttachmentsArray)
  {
    uint64_t ValueAtIndex = (uint64_t)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    if (ValueAtIndex)
    {
      FigCFDictionaryGetBooleanIfPresent();
      FigCFDictionaryGetBooleanIfPresent();
      FigCFDictionaryGetBooleanIfPresent();
      if (CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, (const void *)*MEMORY[0x1E4F21A00])) {
        uint64_t ValueAtIndex = 4;
      }
      else {
        uint64_t ValueAtIndex = 0;
      }
    }
  }
  else
  {
    uint64_t ValueAtIndex = 0;
  }
  CFBooleanRef v4 = (const __CFBoolean *)CMGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F1F258], 0);
  if (v4)
  {
    CFBooleanRef v5 = v4;
    CFTypeID TypeID = CFBooleanGetTypeID();
    if (TypeID == CFGetTypeID(v5))
    {
      if (CFBooleanGetValue(v5))
      {
        CFBooleanRef v7 = (const __CFBoolean *)CMGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F1F228], 0);
        if (v7)
        {
          CFBooleanRef v8 = v7;
          CFTypeID v9 = CFBooleanGetTypeID();
          if (v9 == CFGetTypeID(v8))
          {
            if (CFBooleanGetValue(v8)) {
              return 2;
            }
            else {
              return ValueAtIndex;
            }
          }
        }
      }
    }
  }
  return ValueAtIndex;
}

void vmc2UpdateCPECryptor(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t Decryptor = FigSampleBufferGetDecryptor();
  uint64_t v3 = *(const void **)(v1 + 808);
  if ((const void *)Decryptor == v3) {
    return;
  }
  CFBooleanRef v4 = (const void *)Decryptor;
  if (Decryptor) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    dispatch_resume(*(dispatch_object_t *)(v1 + 824));
    *(unsigned char *)(v1 + 832) = 1;
    uint64_t v3 = *(const void **)(v1 + 808);
LABEL_12:
    *(void *)(v1 + 808) = v4;
    CFRetain(v4);
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }
  if (Decryptor) {
    goto LABEL_12;
  }
  if (v3)
  {
    dispatch_suspend(*(dispatch_object_t *)(v1 + 824));
    *(unsigned char *)(v1 + 832) = 0;
    uint64_t v3 = *(const void **)(v1 + 808);
  }
  *(void *)(v1 + 808) = 0;
  if (v3)
  {
LABEL_13:
    CFRelease(v3);
  }
}

_DWORD *vmcCreateSourceFrameInfo(int a1, opaqueCMSampleBuffer *a2, int a3)
{
  int v6 = malloc_type_calloc(0x50uLL, 1uLL, 0xB185D5C3uLL);
  CFBooleanRef v7 = v6;
  if (v6)
  {
    *int v6 = a1;
    v6[1] = a3;
    CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(a2, 0);
    if (SampleAttachmentsArray
      && (CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0)) != 0)
    {
      CFDictionaryRef Value = CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F21A00]);
      CFStringRef v11 = Value;
      if (Value) {
        CFRetain(Value);
      }
    }
    else
    {
      CFStringRef v11 = 0;
    }
    *((void *)v7 + 1) = v11;
    CFTypeRef v12 = CMGetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F21A58], 0);
    *((void *)v7 + 2) = v12;
    if (v12) {
      CFRetain(v12);
    }
    CFTypeRef v13 = CMGetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F21A10], 0);
    *((void *)v7 + 3) = v13;
    if (v13) {
      CFRetain(v13);
    }
    CFTypeRef v14 = CMGetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F21A78], 0);
    *((void *)v7 + 4) = v14;
    if (v14) {
      CFRetain(v14);
    }
    CFTypeRef v15 = CMGetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F21A70], 0);
    *((void *)v7 + 5) = v15;
    if (v15) {
      CFRetain(v15);
    }
    CFTypeRef v16 = CMGetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F1F220], 0);
    *((void *)v7 + 6) = v16;
    if (v16) {
      CFRetain(v16);
    }
    *((void *)v7 + 8) = mach_absolute_time();
    CFArrayRef v17 = CMSampleBufferGetSampleAttachmentsArray(a2, 0);
    if (v17)
    {
      CFArrayRef v17 = (const __CFArray *)CFArrayGetValueAtIndex(v17, 0);
      if (v17) {
        CFArrayRef v17 = (const __CFArray *)CFDictionaryGetValue(v17, (const void *)*MEMORY[0x1E4F1F200]);
      }
    }
    *((unsigned char *)v7 + 72) = *MEMORY[0x1E4F1CFD0] != (void)v17;
  }
  return v7;
}

void vmcCreateAttachmentsDictionaryForSourceFrameInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    if (a2)
    {
      uint64_t v4 = *(void *)(a1 + 1072);
      if (v4
        && ((uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16)) == 0 ? (v7 = 0) : (v7 = v6),
            (CFBooleanRef v8 = *(void (**)(uint64_t, uint64_t, CFTypeRef *))(v7 + 32)) != 0))
      {
        v8(v4, a3, &cf);
        CFTypeRef v9 = cf;
        uint64_t v10 = *(const void **)(a2 + 56);
        *(void *)(a2 + 56) = cf;
        if (v9) {
          CFRetain(v9);
        }
      }
      else
      {
        uint64_t v10 = *(const void **)(a2 + 56);
        *(void *)(a2 + 56) = 0;
      }
      if (v10) {
        CFRelease(v10);
      }
    }
    else
    {
      FigSignalErrorAt();
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    FigSignalErrorAt();
  }
}

uint64_t vmc2RebuildDecompressionSession(uint64_t a1)
{
  int v2 = *(OpaqueVTDecompressionSession **)(a1 + 64);
  if (v2) {
    VTDecompressionSessionWaitForAsynchronousFrames(v2);
  }
  MEMORY[0x19970E910](*(void *)(a1 + 72));
  vmc2RemoveDecompressionSession(a1);
  uint64_t v3 = vmc2BuildDecompressionSession(a1);
  MEMORY[0x19970E930](*(void *)(a1 + 72));
  return v3;
}

CFTypeRef __vmc2DequeueAndDecodeFrame_block_invoke(uint64_t a1)
{
  CFTypeRef result = *(CFTypeRef *)(*(void *)(a1 + 40) + 952);
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void *__vmc2FinishAndDestroyImageEnhancementFilter_block_invoke(void *result)
{
  *(void *)(*(void *)(result[4] + 8) + 24) = *(void *)(result[6] + 952);
  *(void *)(result[6] + 952) = 0;
  *(void *)(*(void *)(result[5] + 8) + 24) = *(void *)(result[6] + 960);
  *(void *)(result[6] + 960) = 0;
  return result;
}

uint64_t FigVisualContextCreateBasic(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  double v14 = 0.0;
  CFTypeRef cf = 0;
  uint64_t v4 = lvcCreateCommon(a1, 0, 0, &cf);
  if (!v4)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    uint64_t v6 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)(DerivedStorage + 128) = *MEMORY[0x1E4F1F9F8];
    *(void *)(DerivedStorage + 144) = *(void *)(v6 + 16);
    if (!FigCFDictionaryGetDoubleIfPresent())
    {
LABEL_12:
      uint64_t v11 = 0;
      *a3 = cf;
      return v11;
    }
    Float64 v7 = v14;
    if (v14 < 0.005)
    {
      double v14 = 0.005;
      Float64 v7 = 0.005;
    }
    CMTimeMakeWithSeconds(&v13, v7, 1000);
    *(CMTime *)(DerivedStorage + 128) = v13;
    snprintf(__str, 0x64uLL, "com.apple.coremedia.localvisualcontext.autoprune.%p", cf);
    if (sCreateSharedAutoPruneDispatchQueueOnce != -1) {
      dispatch_once_f(&sCreateSharedAutoPruneDispatchQueueOnce, 0, (dispatch_function_t)lvcCreateSharedAutoPruneDispatchQueue);
    }
    if (sLVCSharedAutoPruneDispatchQueue)
    {
      CFBooleanRef v8 = dispatch_queue_create_with_target_V2(__str, 0, (dispatch_queue_t)sLVCSharedAutoPruneDispatchQueue);
      *(void *)(DerivedStorage + 152) = v8;
      if (v8)
      {
        dispatch_source_t v9 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v8);
        *(void *)(DerivedStorage + 160) = v9;
        if (v9)
        {
          uint64_t v10 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
          if (v10)
          {
            dispatch_set_context(*(dispatch_object_t *)(DerivedStorage + 160), v10);
            *(void *)(DerivedStorage + 184) = voucher_copy();
            dispatch_source_set_event_handler_f(*(dispatch_source_t *)(DerivedStorage + 160), (dispatch_function_t)lvcAutoPrune);
            dispatch_source_set_cancel_handler_f(*(dispatch_source_t *)(DerivedStorage + 160), (dispatch_function_t)lvcCancelAutoPruneTimer);
            dispatch_resume(*(dispatch_object_t *)(DerivedStorage + 160));
            goto LABEL_12;
          }
        }
      }
    }
    else
    {
      FigSignalErrorAt();
      *(void *)(DerivedStorage + 152) = 0;
    }
    uint64_t v4 = FigSignalErrorAt();
  }
  uint64_t v11 = v4;
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t lvcCreateCommon(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a4)
  {
    FigVisualContextGetClassID();
    uint64_t v7 = CMDerivedObjectCreate();
    if (!v7)
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
      uint64_t v9 = FigReadWriteLockCreate();
      DerivedStorage[1] = v9;
      if (v9)
      {
        DerivedStorage[21] = a2;
        DerivedStorage[22] = a3;
        if (!a3
          || (uint64_t v10 = *(uint64_t (**)(uint64_t, void))(a3 + 8)) == 0
          || (uint64_t v7 = v10(a2, 0), !v7))
        {
          uint64_t v11 = 0;
          *a4 = 0;
          return v11;
        }
      }
      else
      {
        return FigSignalErrorAt();
      }
    }
    return v7;
  }

  return FigSignalErrorAt();
}

void lvcAutoPrune(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = MEMORY[0x1E4F1F9F8];
  CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  if (a1)
  {
    uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject();
    if (v2)
    {
      uint64_t v3 = (const void *)v2;
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      if (!*(unsigned char *)DerivedStorage)
      {
        uint64_t v5 = DerivedStorage;
        os_retain(*(void **)(DerivedStorage + 184));
        voucher_adopt();
        FigReadWriteLockLockForRead();
        uint64_t v6 = *(OpaqueCMTimebase **)(v5 + 120);
        if (v6)
        {
          CMTimebaseGetTime(&v11, v6);
          CMTimeValue value = v11.value;
          CMTimeFlags flags = v11.flags;
          CMTimeScale timescale = v11.timescale;
          CMTimeEpoch epoch = v11.epoch;
        }
        else
        {
          CMTimeFlags flags = *(_DWORD *)(v1 + 12);
          CMTimeEpoch epoch = *(void *)(v1 + 16);
        }
        FigReadWriteLockUnlockForRead();
        if ((flags & 0x1D) == 1)
        {
          uint64_t v9 = *MEMORY[0x1E4F1CF80];
          v11.CMTimeValue value = value;
          v11.CMTimeScale timescale = timescale;
          v11.CMTimeFlags flags = flags;
          v11.CMTimeEpoch epoch = epoch;
          lvcCopyImageForTime((uint64_t)v3, v9, (long long *)&v11.value, 5, 0, 0, 0);
        }
        uint64_t v10 = (void *)voucher_adopt();
        os_release(v10);
      }
      CFRelease(v3);
    }
  }
}

void lvcCancelAutoPruneTimer(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t lvcInvalidate(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!*(unsigned char *)DerivedStorage)
  {
    uint64_t v3 = DerivedStorage;
    *(unsigned char *)uint64_t DerivedStorage = 1;
    uint64_t v4 = *(void *)(DerivedStorage + 176);
    if (v4)
    {
      uint64_t v5 = *(void (**)(void, uint64_t))(v4 + 16);
      if (v5) {
        v5(*(void *)(DerivedStorage + 168), a1);
      }
    }
    if (*(void *)(v3 + 120))
    {
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
    }
    uint64_t v6 = *(NSObject **)(v3 + 160);
    if (v6) {
      dispatch_source_cancel(v6);
    }
    uint64_t v7 = *(NSObject **)(v3 + 152);
    if (v7)
    {
      dispatch_sync_f(v7, 0, (dispatch_function_t)lvcNoop);
      dispatch_release(*(dispatch_object_t *)(v3 + 152));
      *(void *)(v3 + 152) = 0;
    }
    FigReadWriteLockLockForWrite();
    *(void *)(v3 + 16) = 0;
    *(void *)(v3 + 32) = 0;
    *(void *)(v3 + 48) = 0;
    CFBooleanRef v8 = *(const void **)(v3 + 120);
    if (v8) {
      CFRelease(v8);
    }
    *(void *)(v3 + 120) = 0;
    *(void *)(v3 + 88) = 0;
    *(void *)(v3 + 96) = 0;
    *(void *)(v3 + 80) = 0;
    uint64_t v9 = *(const void **)(v3 + 112);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(v3 + 112) = 0;
    }
    FigReadWriteLockUnlockForWrite();
  }
  return 0;
}

uint64_t lvcFinalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  lvcInvalidate(a1);
  uint64_t v3 = *(NSObject **)(DerivedStorage + 160);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(DerivedStorage + 160) = 0;
  }
  uint64_t v4 = *(void **)(DerivedStorage + 184);
  if (v4)
  {
    os_release(v4);
    *(void *)(DerivedStorage + 184) = 0;
  }

  return FigReadWriteLockDestroy();
}

__CFString *lvcCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<FigVisualContext %p [%p]>{imageAvailableImmediate:%p, imageAvailableSequential:%p, noMoreImages:%p, timebase:%p, isNewImageAvailable:%p, copyImageForTime:%p, getEarliestSequentialImageTime:%p}", a1, v5, DerivedStorage[2], DerivedStorage[4], DerivedStorage[6], DerivedStorage[15], DerivedStorage[10], DerivedStorage[11], DerivedStorage[12]);
  return Mutable;
}

uint64_t lvcCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (*(unsigned char *)CMBaseObjectGetDerivedStorage())
  {
    return FigSignalErrorAt();
  }
  else if (FigCFEqual())
  {
    uint64_t UInt64 = FigCFNumberCreateUInt64();
    uint64_t result = 0;
    *a4 = UInt64;
  }
  else
  {
    return 4294954512;
  }
  return result;
}

uint64_t lvcTimebaseRateChanged()
{
  CMBaseObjectGetDerivedStorage();
  FigReadWriteLockLockForRead();
  lvcUpdateAutoPruneTimer();

  return FigReadWriteLockUnlockForRead();
}

void lvcUpdateAutoPruneTimer()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = *(NSObject **)(DerivedStorage + 160);
  if (v1)
  {
    if (*(void *)(DerivedStorage + 120))
    {
      double Rate = CMTimebaseGetRate(*(CMTimebaseRef *)(DerivedStorage + 120));
      if (Rate != 0.0)
      {
        CMTime v4 = *(CMTime *)(DerivedStorage + 128);
        int64_t v3 = (uint64_t)(CMTimeGetSeconds(&v4) * 1000000000.0 / fabs(Rate));
        dispatch_source_set_timer(*(dispatch_source_t *)(DerivedStorage + 160), 0, v3, v3 / 10);
        return;
      }
      uint64_t v1 = *(NSObject **)(DerivedStorage + 160);
    }
    dispatch_source_set_timer(v1, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
  }
}

uint64_t lvcSetImageAvailableImmediateCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigReadWriteLockLockForWrite();
  if (a2 && *(void *)(DerivedStorage + 16))
  {
    uint64_t v6 = FigSignalErrorAt();
  }
  else
  {
    uint64_t v6 = 0;
    *(void *)(DerivedStorage + 16) = a2;
    *(void *)(DerivedStorage + 24) = a3;
  }
  FigReadWriteLockUnlockForWrite();
  return v6;
}

uint64_t lvcSetImageAvailableSequentialCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigReadWriteLockLockForWrite();
  if (a2 && *(void *)(DerivedStorage + 32))
  {
    uint64_t v6 = FigSignalErrorAt();
  }
  else
  {
    uint64_t v6 = 0;
    *(void *)(DerivedStorage + 32) = a2;
    *(void *)(DerivedStorage + 40) = a3;
  }
  FigReadWriteLockUnlockForWrite();
  return v6;
}

uint64_t lvcSetNoMoreImagesCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigReadWriteLockLockForWrite();
  if (a2 && *(void *)(DerivedStorage + 48))
  {
    uint64_t v6 = FigSignalErrorAt();
  }
  else
  {
    uint64_t v6 = 0;
    *(void *)(DerivedStorage + 48) = a2;
    *(void *)(DerivedStorage + 56) = a3;
  }
  FigReadWriteLockUnlockForWrite();
  return v6;
}

uint64_t lvcSetBecameEmptyCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigReadWriteLockLockForWrite();
  if (a2 && *(void *)(DerivedStorage + 64))
  {
    uint64_t v6 = FigSignalErrorAt();
  }
  else
  {
    uint64_t v6 = 0;
    *(void *)(DerivedStorage + 64) = a2;
    *(void *)(DerivedStorage + 72) = a3;
  }
  FigReadWriteLockUnlockForWrite();
  return v6;
}

uint64_t lvcIsNewImageAvailable(uint64_t a1, long long *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if ((*((_DWORD *)a2 + 3) & 0x1D) != 1)
  {
    FigSignalErrorAt();
    return 0;
  }
  uint64_t v5 = DerivedStorage;
  FigReadWriteLockLockForRead();
  if (!*(void *)(v5 + 80) || !*(void *)(v5 + 112) || (uint64_t v6 = FigCFWeakReferenceHolderCopyReferencedObject()) == 0)
  {
    FigReadWriteLockUnlockForRead();
    return 0;
  }
  uint64_t v7 = (const void *)v6;
  CFBooleanRef v8 = *(uint64_t (**)(uint64_t, long long *, uint64_t))(v5 + 80);
  long long v11 = *a2;
  uint64_t v12 = *((void *)a2 + 2);
  uint64_t v9 = v8(a1, &v11, v6);
  FigReadWriteLockUnlockForRead();
  CFRelease(v7);
  return v9;
}

uint64_t lvcCopyImageForTime(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, CVBufferRef *a5, CFTypeRef *a6, uint64_t a7)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  CVBufferRef buffer = 0;
  long long v29 = *MEMORY[0x1E4F1F9F8];
  uint64_t v30 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  if ((*((_DWORD *)a3 + 3) & 0x1D) == 1)
  {
    CFTypeRef v15 = (void *)DerivedStorage;
    if (a5) {
      *a5 = 0;
    }
    FigReadWriteLockLockForRead();
    if (v15[11] && v15[14])
    {
      CFTypeRef v16 = (const void *)FigCFWeakReferenceHolderCopyReferencedObject();
      if (v16)
      {
        uint64_t v17 = (uint64_t (*)(uint64_t, uint64_t, long long *, uint64_t, CVBufferRef *, CFTypeRef *, long long *, const void *))v15[11];
        if (a5) {
          p_CVBufferRef buffer = &buffer;
        }
        else {
          p_CVBufferRef buffer = 0;
        }
        if (a6) {
          p_CFTypeRef cf = &cf;
        }
        else {
          p_CFTypeRef cf = 0;
        }
        if (a7) {
          BOOL v20 = &v29;
        }
        else {
          BOOL v20 = 0;
        }
        long long v27 = *a3;
        uint64_t v28 = *((void *)a3 + 2);
        uint64_t v21 = v17(a1, a2, &v27, a4, p_buffer, p_cf, v20, v16);
        if (!a5) {
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v21 = 0;
        if (!a5) {
          goto LABEL_28;
        }
      }
    }
    else
    {
      uint64_t v21 = 0;
      CFTypeRef v16 = 0;
      if (!a5) {
        goto LABEL_28;
      }
    }
    if (!v21)
    {
      uint64_t v23 = v15[22];
      if (v23)
      {
        CFNumberRef v24 = *(uint64_t (**)(uint64_t, uint64_t, CVBufferRef, CVBufferRef *, CFTypeRef, CFTypeRef *, long long *, uint64_t))(v23 + 24);
        if (v24)
        {
          uint64_t v25 = v15[21];
          long long v27 = v29;
          uint64_t v28 = v30;
          uint64_t v21 = v24(v25, a2, buffer, a5, cf, a6, &v27, a7);
LABEL_34:
          FigReadWriteLockUnlockForRead();
          if (v16) {
            CFRelease(v16);
          }
          if (buffer) {
            CVBufferRelease(buffer);
          }
          if (cf) {
            CFRelease(cf);
          }
          return v21;
        }
      }
      BOOL v26 = a7 != 0;
      goto LABEL_29;
    }
LABEL_28:
    BOOL v26 = a7 != 0;
    if (!a5)
    {
LABEL_30:
      if (a6)
      {
        *a6 = cf;
        CFTypeRef cf = 0;
      }
      if (v26)
      {
        *(_OWORD *)a7 = v29;
        *(void *)(a7 + 16) = v30;
      }
      goto LABEL_34;
    }
LABEL_29:
    *a5 = buffer;
    CVBufferRef buffer = 0;
    goto LABEL_30;
  }

  return FigSignalErrorAt();
}

uint64_t lvcConvertHostTimeToImageTime(uint64_t a1, uint64_t a2, CMTime *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  memset(&v13, 0, sizeof(v13));
  if (a3 && ((uint64_t v6 = DerivedStorage, !a2) || (*(unsigned char *)(a2 + 64) & 2) != 0))
  {
    FigReadWriteLockLockForRead();
    CFBooleanRef v8 = *(OpaqueCMTimebase **)(v6 + 120);
    if (v8)
    {
      if (a2)
      {
        CMClockMakeHostTimeFromSystemUnits(&v13, *(void *)(a2 + 16));
        CMClockRef HostTimeClock = CMClockGetHostTimeClock();
        uint64_t v10 = *(const void **)(v6 + 120);
        CMTime v11 = v13;
        CMSyncConvertTime(&v12, &v11, HostTimeClock, v10);
        a2 = 0;
      }
      else
      {
        CMTimebaseGetTime(&v12, v8);
      }
      *a3 = v12;
    }
    else
    {
      a2 = 4294954481;
    }
    FigReadWriteLockUnlockForRead();
    return a2;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t lvcGetEarliestSequentialImageTimeAfterTime(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, unsigned char *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a4)
  {
    uint64_t v11 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)a4 = *MEMORY[0x1E4F1F9F8];
    *(void *)(a4 + 16) = *(void *)(v11 + 16);
  }
  if (a5) {
    *a5 = 0;
  }
  FigReadWriteLockLockForRead();
  if (!*(void *)(DerivedStorage + 96) || !*(void *)(DerivedStorage + 112))
  {
    uint64_t v15 = 4294954483;
LABEL_11:
    FigReadWriteLockUnlockForRead();
    return v15;
  }
  uint64_t v12 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (!v12)
  {
    uint64_t v15 = 0;
    goto LABEL_11;
  }
  CMTime v13 = (const void *)v12;
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, long long *, uint64_t, unsigned char *, uint64_t))(DerivedStorage + 96);
  long long v17 = *a3;
  uint64_t v18 = *((void *)a3 + 2);
  uint64_t v15 = v14(a1, a2, &v17, a4, a5, v12);
  FigReadWriteLockUnlockForRead();
  CFRelease(v13);
  return v15;
}

uint64_t lvcTask()
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = *(void *)(result + 176);
  if (v1)
  {
    uint64_t v2 = *(uint64_t (**)(uint64_t))(v1 + 32);
    if (v2)
    {
      uint64_t v3 = *(void *)(result + 168);
      return v2(v3);
    }
  }
  return result;
}

uint64_t lvcImageAvailableImmediate(uint64_t a1, long long *a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if ((*((_DWORD *)a2 + 3) & 0x1D) == 1)
  {
    uint64_t v7 = DerivedStorage;
    FigReadWriteLockLockForRead();
    CFBooleanRef v8 = *(void (**)(uint64_t, long long *, uint64_t, uint64_t))(v7 + 16);
    if (v8)
    {
      uint64_t v9 = *(void *)(v7 + 24);
      long long v11 = *a2;
      uint64_t v12 = *((void *)a2 + 2);
      v8(a1, &v11, a3, v9);
    }
    FigReadWriteLockUnlockForRead();
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t lvcImageAvailableSequential(uint64_t a1, long long *a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if ((*((_DWORD *)a2 + 3) & 0x1D) == 1)
  {
    uint64_t v7 = DerivedStorage;
    FigReadWriteLockLockForRead();
    CFBooleanRef v8 = *(void (**)(uint64_t, long long *, uint64_t, uint64_t))(v7 + 32);
    if (v8)
    {
      uint64_t v9 = *(void *)(v7 + 40);
      long long v11 = *a2;
      uint64_t v12 = *((void *)a2 + 2);
      v8(a1, &v11, a3, v9);
    }
    FigReadWriteLockUnlockForRead();
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t lvcNoMoreImages(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigReadWriteLockLockForRead();
  uint64_t v3 = *(void (**)(uint64_t, void))(DerivedStorage + 48);
  if (v3) {
    v3(a1, *(void *)(DerivedStorage + 56));
  }
  FigReadWriteLockUnlockForRead();
  return 0;
}

uint64_t lvcBecameEmpty(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigReadWriteLockLockForRead();
  uint64_t v3 = *(void (**)(uint64_t, void))(DerivedStorage + 64);
  if (v3) {
    v3(a1, *(void *)(DerivedStorage + 72));
  }
  FigReadWriteLockUnlockForRead();
  return 0;
}

uint64_t lvcSetProducerCallbacks(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigReadWriteLockLockForWrite();
  uint64_t v12 = *(void *)(DerivedStorage + 104);
  if (v12) {
    BOOL v13 = v12 == a6;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13 || a3 && a4 && a5 || (uint64_t v14 = 4294954480, !a2) && !a5 && !a4 && !a3 && !a6)
  {
    uint64_t v15 = *(const void **)(DerivedStorage + 112);
    if (v15)
    {
      CFRelease(v15);
      *(void *)(DerivedStorage + 112) = 0;
    }
    if (*(void *)(DerivedStorage + 120))
    {
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      CFTypeRef v16 = *(const void **)(DerivedStorage + 120);
    }
    else
    {
      CFTypeRef v16 = 0;
    }
    *(void *)(DerivedStorage + 120) = a2;
    if (a2) {
      CFRetain((CFTypeRef)a2);
    }
    if (v16) {
      CFRelease(v16);
    }
    *(void *)(DerivedStorage + 80) = a3;
    *(void *)(DerivedStorage + 88) = a4;
    if (a2 | a5 | a3 | a4) {
      uint64_t v17 = a6;
    }
    else {
      uint64_t v17 = 0;
    }
    *(void *)(DerivedStorage + 96) = a5;
    *(void *)(DerivedStorage + 104) = v17;
    *(void *)(DerivedStorage + 112) = FigCFWeakReferenceHolderCreateWithReferencedObject();
    if (*(unsigned char *)(DerivedStorage + 140))
    {
      if (*(void *)(DerivedStorage + 120))
      {
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterAddWeakListener();
      }
      lvcUpdateAutoPruneTimer();
    }
    uint64_t v14 = 0;
  }
  FigReadWriteLockUnlockForWrite();
  return v14;
}

uint64_t lvcCreateSharedAutoPruneDispatchQueue()
{
  uint64_t result = FigDispatchQueueCreateWithPriority();
  sLVCSharedAutoPruneDispatchQueue = result;
  return result;
}

uint64_t FigPhotoJPEGPreload()
{
  return MEMORY[0x1F410DB28]();
}

uint64_t FigMediaparserdUtilities_EnsureProcessLaunched()
{
  if ((gNeedToWakeupMediaparserd & 1) == 0)
  {
    if (FigMediaparserdUtilities_EnsureProcessLaunched_utilityQueueSetup != -1) {
      dispatch_once(&FigMediaparserdUtilities_EnsureProcessLaunched_utilityQueueSetup, &__block_literal_global_7);
    }
    dispatch_async_f((dispatch_queue_t)gWakeUpQueue, 0, (dispatch_function_t)figMediaParserdUtilities_KickStartProcess);
  }
  return 0;
}

uint64_t figMediaParserdUtilities_KickStartProcess()
{
  if (figMediaParserdUtilities_KickStartProcess_mediaparserdWakeup != -1) {
    dispatch_once(&figMediaParserdUtilities_KickStartProcess_mediaparserdWakeup, &__block_literal_global_4);
  }
  if (!figMediaParserdUtilities_KickStartProcess_connectionError
    && !FigXPCCreateBasicMessage()
    && !FigXPCRemoteClientSendAsyncMessage())
  {
    gNeedToWakeupMediaparserd = 1;
  }
  return FigXPCRelease();
}

void FigMediaparserdUtilities_DeadServerConnectionCallback()
{
  gNeedToWakeupMediaparserd = 0;
}

__CFString *convertPresetEnumToUsageModeString(uint64_t a1)
{
  switch(a1)
  {
    case 0:
      uint64_t v1 = kFigVirtualDisplayUsage_Uncompressed;
      goto LABEL_12;
    case 1:
      uint64_t v1 = kFigVirtualDisplayUsage_AirPlayHEVC;
      goto LABEL_12;
    case 2:
      uint64_t v1 = kFigVirtualDisplayUsage_CarPlay;
      goto LABEL_12;
    case 3:
      uint64_t v1 = kFigVirtualDisplayUsage_CarPlayHEVC;
      goto LABEL_12;
    case 4:
      uint64_t v1 = kFigVirtualDisplayUsage_Stevenote;
      goto LABEL_12;
    case 5:
      uint64_t v1 = kFigVirtualDisplayUsage_Valeria;
      goto LABEL_12;
    case 6:
      uint64_t v1 = kFigVirtualDisplayUsage_AirPlay;
      goto LABEL_12;
    case 7:
    case 9:
      uint64_t v1 = kFigVirtualDisplayUsage_UncompressedHDR;
      goto LABEL_12;
    case 8:
    case 10:
      uint64_t v1 = kFigVirtualDisplayUsage_AirPlayHDR;
LABEL_12:
      uint64_t result = *v1;
      break;
    default:
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      uint64_t result = 0;
      break;
  }
  return result;
}

void sub_193F71A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

uint64_t handleServerDiedNotification(uint64_t a1, void *a2)
{
  [a2 delegate];
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    CMTime v4 = (void *)[a2 delegate];
    return [v4 screenCaptureControllerMediaServicesWereReset:a2];
  }
  return result;
}

void *conduitPushFrameCallback(void *result, uint64_t a2, unsigned int a3)
{
  if (a2)
  {
    uint64_t v5 = result;
    uint64_t v6 = (void *)[result delegate];
    return (void *)[v6 screenCaptureController:v5 didReceiveSampleBuffer:a2 transformFlags:a3];
  }
  return result;
}

uint64_t conduitClearScreenCallback(void *a1)
{
  [a1 delegate];
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v3 = (void *)[a1 delegate];
    return [v3 screenCaptureControllerDidReceiveClearScreen:a1];
  }
  return result;
}

uint64_t handleSourceTerminatedNotification(uint64_t a1, void *a2)
{
  [a2 delegate];
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    CMTime v4 = (void *)[a2 delegate];
    return [v4 screenCaptureController:a2 didFailWithStatus:4294955218];
  }
  return result;
}

uint64_t FBLSupportAppendDeferredTransactionChangeToSetContentsScaleForFigCALayer(const void *a1, const void *a2, uint64_t a3, float a4)
{
  CFBooleanRef v8 = malloc_type_malloc(0x10uLL, 0x10800409227ACB4uLL);
  if (v8)
  {
    uint64_t v9 = (uint64_t)v8;
    *CFBooleanRef v8 = CFRetain(a2);
    *(float *)(v9 + 8) = a4;
    return FigDeferredTransactionAppendChangeWithCallback(a1, 1, a3, v9, (uint64_t)disposeSetContentsScaleContext, (uint64_t)copyDescriptionForSetContentsScaleContext, (uint64_t)setContentsScaleForFigCALayer);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void disposeSetContentsScaleContext(id *a1)
{
  if (*a1) {

  }
  free(a1);
}

CFStringRef copyDescriptionForSetContentsScaleContext(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"\nset ContentsScale: %f", *(float *)(a1 + 8));
}

uint64_t setContentsScaleForFigCALayer(uint64_t a1)
{
  return 0;
}

uint64_t FBLSupportAppendDeferredTransactionChangeToSetAllowsDisplayCompositing(const void *a1, const void *a2, char a3, uint64_t a4)
{
  CFBooleanRef v8 = malloc_type_malloc(0x10uLL, 0x1080040C20BADFCuLL);
  if (v8)
  {
    uint64_t v9 = (uint64_t)v8;
    *CFBooleanRef v8 = CFRetain(a2);
    *(unsigned char *)(v9 + 8) = a3;
    return FigDeferredTransactionAppendChangeWithCallback(a1, 1, a4, v9, (uint64_t)disposeSetAllowsDisplayCompositingContext, (uint64_t)copyDescriptionForSetAllowsDisplayCompositingContext, (uint64_t)setAllowsDisplayCompositingForFigCALayer);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void disposeSetAllowsDisplayCompositingContext(id *a1)
{
  if (*a1) {

  }
  free(a1);
}

CFStringRef copyDescriptionForSetAllowsDisplayCompositingContext(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"\nset allowsDisplayCompositing: %d", *(unsigned __int8 *)(a1 + 8));
}

uint64_t setAllowsDisplayCompositingForFigCALayer(uint64_t a1)
{
  return 0;
}

uint64_t FigImageQueueGaugeXPCRemoteGetObjectID(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    *a2 = *(void *)CMBaseObjectGetDerivedStorage();
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigImageQueueGaugeXPCRemoteRetainCopiedImageQueueGauge(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    uint64_t v4 = FigXPCRemoteClientRetainCopiedObject();
    if (!v4)
    {
      FigImageQueueGaugeGetClassID();
      uint64_t v4 = CMDerivedObjectCreate();
      if (!v4)
      {
        *(void *)CMBaseObjectGetDerivedStorage() = a1;
        uint64_t v4 = FigXPCRemoteClientAssociateObject();
        if (!v4)
        {
          uint64_t v4 = 0;
          *a2 = 0;
        }
      }
    }
    return v4;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t FigImageQueueGaugeXPCRemoteStartAsSubClient(uint64_t a1)
{
  if (gImageQueueGaugeRemoteClient || !a1)
  {
    return FigSignalErrorAt();
  }
  else
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FigImageQueueGaugeXPCRemoteStartAsSubClient_block_invoke;
    block[3] = &__block_descriptor_tmp_12;
    block[4] = a1;
    if (FigImageQueueGaugeXPCRemoteStartAsSubClient_onceToken != -1) {
      dispatch_once(&FigImageQueueGaugeXPCRemoteStartAsSubClient_onceToken, block);
    }
    return 0;
  }
}

uint64_t __FigImageQueueGaugeXPCRemoteStartAsSubClient_block_invoke(uint64_t result)
{
  gImageQueueGaugeRemoteClient = *(void *)(result + 32);
  return result;
}

uint64_t remoteXPCImageQueueGauge_Finalize()
{
  if (!FigXPCCreateBasicMessage()) {
    FigXPCRemoteClientSendAsyncMessage();
  }
  FigXPCRelease();
  return FigXPCRemoteClientKillServerOnTimeout();
}

__CFString *remoteXPCImageQueueGauge_CopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  CFIndex v5 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, @"<FigImageQueueGaugeRemote(XPC) %p retainCount: %ld ObjectID: %016llx>", a1, v5, *DerivedStorage);
  return Mutable;
}

uint64_t remoteXPCImageQueueGauge_CopyProperty()
{
  CMBaseObjectGetDerivedStorage();
  uint64_t v0 = FigXPCSendStdCopyPropertyMessage();
  FigXPCRemoteClientKillServerOnTimeout();
  return v0;
}

uint64_t remoteXPCImageQueueGauge_SetProperty()
{
  CMBaseObjectGetDerivedStorage();
  uint64_t v0 = FigXPCSendStdSetPropertyMessage();
  FigXPCRemoteClientKillServerOnTimeout();
  return v0;
}

uint64_t FigReportingModeratorCreateForHLS(uint64_t a1, const void *a2, const __CFDictionary *a3, void *a4)
{
  fig_note_initialize_category_with_default_work_cf();
  fig_note_initialize_category_with_default_work_cf();
  if (!a4) {
    return 4294949785;
  }
  FigReportingModeratorGetClassID();
  uint64_t v7 = CMDerivedObjectCreate();
  if (!v7)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    *(_DWORD *)(DerivedStorage + 8) = 0;
    *(void *)uint64_t DerivedStorage = FigGetUpTimeNanoseconds();
    if (a2) {
      CFTypeRef v9 = CFRetain(a2);
    }
    else {
      CFTypeRef v9 = 0;
    }
    *(void *)(DerivedStorage + 168) = v9;
    *(void *)(DerivedStorage + 176) = 0x1EE582C58;
    *(void *)(DerivedStorage + 64) = -1;
    if (a3) {
      CFDictionaryRef Value = CFDictionaryGetValue(a3, @"FRM_BundleName");
    }
    else {
      CFDictionaryRef Value = 0;
    }
    FigUserExperienceScorerCreate(Value, (void *)(DerivedStorage + 216));
    uint64_t v7 = 0;
    *a4 = 0;
  }
  return v7;
}

void streamReportingModeratorFinalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (DerivedStorage)
  {
    uint64_t v1 = (void *)DerivedStorage;
    uint64_t v2 = *(const void **)(DerivedStorage + 208);
    if (v2) {
      CFRelease(v2);
    }
    CFAllocatorRef v3 = (const void *)v1[12];
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = (const void *)v1[11];
    if (v4) {
      CFRelease(v4);
    }
    CFIndex v5 = (const void *)v1[21];
    if (v5) {
      CFRelease(v5);
    }
    uint64_t v6 = (const void *)v1[27];
    if (v6)
    {
      CFRelease(v6);
    }
  }
}

__CFString *streamReportingModeratorCopyDebugDescription()
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"\tFigStreamReportingModerator : ");
  return Mutable;
}

uint64_t streamReportingModeratorSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!DerivedStorage) {
    return 4294949785;
  }
  uint64_t v6 = DerivedStorage;
  uint64_t result = CFEqual(a2, @"Timebase");
  if (!result) {
    return result;
  }
  if (!a3) {
    return 4294949785;
  }
  CFTypeID v8 = CFGetTypeID(a3);
  if (v8 != CMTimebaseGetTypeID()) {
    return 4294949785;
  }
  CFTypeRef v9 = *(const void **)(v6 + 208);
  *(void *)(v6 + 208) = a3;
  CFRetain(a3);
  if (v9) {
    CFRelease(v9);
  }
  return 0;
}

uint64_t streamModeratorProcessEventAndCopyKeyArray(uint64_t a1, int a2, uint64_t *a3, void *a4)
{
  uint64_t v248 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = 4294949785;
  if (!a3 || !DerivedStorage) {
    return result;
  }
  uint64_t v215 = 0;
  int v214 = 0;
  unsigned int v212 = a4;
  uint64_t v213 = 0;
  v211 = a3;
  if (a2 == 106)
  {
    uint64_t result = fsrm_getInt32FromAggregatedSessionStats(*(void *)(DerivedStorage + 168), 0x1EE54F698, &v214);
    if (result) {
      return result;
    }
LABEL_5:
    fsrm_updateProcessMemoryAndCPUSession(DerivedStorage);
    goto LABEL_6;
  }
  int v9 = 0;
  if (a2 <= 1000)
  {
    if (a2 != 101)
    {
      if (a2 == 105)
      {
        uint64_t v17 = *(void *)(DerivedStorage + 168);
        uint64_t v18 = kFigReportingFrozenKeySetForEvent_LikelyToKeepUp;
      }
      else
      {
        if (a2 != 115) {
          goto LABEL_7;
        }
        uint64_t v17 = *(void *)(DerivedStorage + 168);
        uint64_t v18 = kFigReportingFrozenKeySetForEvent_StartupPerformanceMetrics;
      }
      uint64_t v67 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v67) {
        uint64_t v68 = v67;
      }
      else {
        uint64_t v68 = 0;
      }
      uint64_t v71 = *(void (**)(uint64_t, uint64_t, uint64_t))(v68 + 200);
      if (v71) {
        v71(v17, 0x1EE582CD8, v18);
      }
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  if (a2 > 2001)
  {
    if (a2 != 2002)
    {
      if (a2 != 3001) {
        goto LABEL_7;
      }
      fsrm_updateExpensiveNetworkStats(DerivedStorage);
      goto LABEL_6;
    }
    uint64_t v15 = *(void *)(DerivedStorage + 168);
    uint64_t v16 = kFigReportingEventKeyArray_DownloadPerfValuesPerAudioSubstreamSegment;
  }
  else
  {
    if (a2 == 1001)
    {
      double Current = CFAbsoluteTimeGetCurrent();
      if (Current - *(double *)(DerivedStorage + 184) >= 30.0)
      {
        long long v246 = 0u;
        long long v247 = 0u;
        long long v244 = 0u;
        long long v245 = 0u;
        long long v242 = 0u;
        long long v243 = 0u;
        long long v240 = 0u;
        long long v241 = 0u;
        long long v238 = 0u;
        long long v239 = 0u;
        long long v236 = 0u;
        long long v237 = 0u;
        long long v234 = 0u;
        long long v235 = 0u;
        long long v232 = 0u;
        long long v233 = 0u;
        long long v230 = 0u;
        long long v231 = 0u;
        long long v228 = 0u;
        long long v229 = 0u;
        long long v226 = 0u;
        long long v227 = 0u;
        long long v224 = 0u;
        long long v225 = 0u;
        long long v223 = 0u;
        long long v221 = 0u;
        long long v222 = 0u;
        *(_OWORD *)CVBufferRef buffer = 0u;
        long long v220 = 0u;
        pid_t v58 = getpid();
        if (!proc_pid_rusage(v58, 6, buffer))
        {
          uint64_t v59 = v220;
          if (mach_absolute_time_to_s_have_tmscale != -1) {
            dispatch_once(&mach_absolute_time_to_s_have_tmscale, &__block_literal_global_8);
          }
          double v60 = *(double *)&mach_absolute_time_to_s_tmscale * (double)v59 / 1000000000.0;
          double v61 = *(double *)(DerivedStorage + 192);
          if (v61 == 0.0 || (double v110 = *(double *)(DerivedStorage + 184), v110 == 0.0) || v60 < v61)
          {
            *(double *)(DerivedStorage + 184) = Current;
            *(double *)(DerivedStorage + 192) = v60;
          }
          else
          {
            uint64_t v111 = *(void *)(DerivedStorage + 168);
            uint64_t v112 = *(void *)(DerivedStorage + 176);
            uint64_t v113 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v113) {
              uint64_t v114 = v113;
            }
            else {
              uint64_t v114 = 0;
            }
            int v128 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v114 + 72);
            if (v128) {
              v128(v111, v112, 0x1EE583D18, (unint64_t)((v60 - v61) * 10000.0 / (Current - v110)));
            }
          }
          unint64_t v62 = *((void *)&v223 + 1);
          uint64_t v63 = *(void *)(DerivedStorage + 168);
          uint64_t v64 = *(void *)(DerivedStorage + 176);
          uint64_t v65 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v65) {
            uint64_t v66 = v65;
          }
          else {
            uint64_t v66 = 0;
          }
          unsigned int v115 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v66 + 72);
          if (v115) {
            v115(v63, v64, 0x1EE583CB8, v62 >> 10);
          }
          *(double *)(DerivedStorage + 184) = Current;
          *(double *)(DerivedStorage + 192) = v60;
        }
      }
      goto LABEL_6;
    }
    if (a2 != 2001) {
      goto LABEL_7;
    }
    uint64_t v15 = *(void *)(DerivedStorage + 168);
    uint64_t v16 = kFigReportingEventKeyArray_DownloadPerfValuesPerMainSubstreamSegment;
  }
  uint64_t v69 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v69) {
    uint64_t v70 = v69;
  }
  else {
    uint64_t v70 = 0;
  }
  float v72 = *(void (**)(uint64_t, uint64_t))(v70 + 96);
  if (v72) {
    v72(v15, v16);
  }
LABEL_6:
  int v9 = v214;
LABEL_7:
  uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  uint64_t v11 = UpTimeNanoseconds;
  int v12 = *(_DWORD *)(DerivedStorage + 8);
  if (*(void *)DerivedStorage)
  {
    unint64_t v13 = (UpTimeNanoseconds - *(void *)DerivedStorage) / 0xF4240uLL;
    switch(v12)
    {
      case 0:
        uint64_t v14 = @"InitTime";
        goto LABEL_28;
      case 1:
        uint64_t v14 = @"PauseTime";
        goto LABEL_28;
      case 2:
        LODWORD(v19) = *(_DWORD *)(DerivedStorage + 12);
        if ((int)v19 >= 0) {
          uint64_t v19 = v19;
        }
        else {
          uint64_t v19 = -(int)v19;
        }
        unint64_t v20 = v13 * v19;
        unint64_t v21 = v13 * v19 / 0x64;
        fsrm_addToSessionStatsCountValue(DerivedStorage, 0x1EE583F38, v13);
        fsrm_addToSessionStatsCountValue(DerivedStorage, @"PlayTime", v21);
        unint64_t v22 = *(void *)(DerivedStorage + 128) + v13;
        *(void *)(DerivedStorage + 120) += v20 / 0x64;
        *(void *)(DerivedStorage + 128) = v22;
        unint64_t v23 = *(void *)(DerivedStorage + 112) + v13;
        *(void *)(DerivedStorage + 104) += v20 / 0x64;
        *(void *)(DerivedStorage + 112) = v23;
        break;
      case 3:
        fsrm_addToSessionStatsCountValue(DerivedStorage, @"StallTime", v13);
        uint64_t v14 = @"VarStallTime";
LABEL_28:
        fsrm_addToSessionStatsCountValue(DerivedStorage, (uint64_t)v14, v13);
        break;
      default:
        break;
    }
  }
  *(void *)uint64_t DerivedStorage = v11;
  unsigned int v24 = a2 - 101;
  switch(a2)
  {
    case 'e':
      uint64_t v25 = *(void *)(DerivedStorage + 168);
      uint64_t v26 = *(void *)(DerivedStorage + 176);
      long long v27 = (uint64_t *)(DerivedStorage + 104);
      uint64_t v28 = 0x1EE561698;
      uint64_t v29 = 0x1EE561678;
      goto LABEL_83;
    case 'f':
    case 'h':
    case 'l':
      goto LABEL_174;
    case 'g':
      *(void *)(DerivedStorage + 32) = v11;
      int v12 = 3;
      goto LABEL_174;
    case 'i':
      uint64_t v34 = *(void *)(DerivedStorage + 168);
      uint64_t v35 = *(void *)(DerivedStorage + 176);
      uint64_t v36 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v36) {
        uint64_t v37 = v36;
      }
      else {
        uint64_t v37 = 0;
      }
      unsigned int v73 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v37 + 64);
      if (v73) {
        v73(v34, v35, 0x1EE584038, 1);
      }
      if (!*(void *)(DerivedStorage + 88) && !*(void *)(DerivedStorage + 96)) {
        fsrm_copyPlayerIndicatedBitrate(*(void *)(DerivedStorage + 168), DerivedStorage);
      }
      if (*(_DWORD *)(DerivedStorage + 64) != -1) {
        goto LABEL_78;
      }
      LODWORD(buffer[0]) = 0;
      if (!fsrm_getInt32FromAggregatedSessionStats(*(void *)(DerivedStorage + 168), 0x1EE561158, buffer))
      {
        *(_DWORD *)(DerivedStorage + 64) = buffer[0];
LABEL_78:
        if (*(_DWORD *)(DerivedStorage + 68) == -1)
        {
          LODWORD(buffer[0]) = 0;
          if (!fsrm_getInt32FromAggregatedSessionStats(*(void *)(DerivedStorage + 168), 0x1EE5619B8, buffer))*(_DWORD *)(DerivedStorage + 68) = buffer[0]; {
        }
          }
      }
LABEL_174:
      int v98 = 0;
      *(_DWORD *)(DerivedStorage + 8) = v12;
      goto LABEL_175;
    case 'j':
      if (v9)
      {
        *(_DWORD *)(DerivedStorage + 12) = v9;
        int v38 = (uint64_t *)(DerivedStorage + 16);
        int v12 = 2;
      }
      else
      {
        int v38 = (uint64_t *)(DerivedStorage + 40);
        int v12 = 1;
      }
      *int v38 = v11;
      uint64_t v25 = *(void *)(DerivedStorage + 168);
      uint64_t v26 = *(void *)(DerivedStorage + 176);
      long long v27 = (uint64_t *)(DerivedStorage + 120);
      uint64_t v28 = 0x1EE583F78;
      uint64_t v29 = 0x1EE583F98;
LABEL_83:
      fsrm_updatePlayTimeStatsForEvent(v25, v26, v27, v28, v29);
      goto LABEL_174;
    case 'k':
      fsrm_setSessionEndReasonIfFatalError(DerivedStorage, *(void *)(DerivedStorage + 176), 0, 0x1EE5840B8, 0x1EE5840F8, 0x1EE5840D8);
      uint64_t v39 = *(void *)(DerivedStorage + 168);
      uint64_t v40 = *(void *)(DerivedStorage + 176);
      uint64_t v41 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v41) {
        uint64_t v42 = v41;
      }
      else {
        uint64_t v42 = 0;
      }
      int v74 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v42 + 64);
      if (v74) {
        v74(v39, v40, 0x1EE584098, 1);
      }
      goto LABEL_174;
    case 'm':
      buffer[0] = 0;
      uint64_t v43 = *(void *)(DerivedStorage + 168);
      uint64_t v44 = *(void *)(DerivedStorage + 176);
      uint64_t v45 = *(void *)(DerivedStorage + 88);
      uint64_t v46 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v46) {
        uint64_t v47 = v46;
      }
      else {
        uint64_t v47 = 0;
      }
      BOOL v75 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v47 + 80);
      if (v75) {
        v75(v43, v44, 0x1EE561278, v45);
      }
      uint64_t v76 = *(void *)(DerivedStorage + 168);
      uint64_t v77 = *(void *)(DerivedStorage + 176);
      uint64_t v78 = *(void *)(DerivedStorage + 96);
      uint64_t v79 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v79) {
        uint64_t v80 = v79;
      }
      else {
        uint64_t v80 = 0;
      }
      int v85 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v80 + 80);
      if (v85) {
        v85(v76, v77, 0x1EE561298, v78);
      }
      uint64_t v86 = *(void *)(DerivedStorage + 168);
      uint64_t v87 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v87) {
        uint64_t v88 = v87;
      }
      else {
        uint64_t v88 = 0;
      }
      uint64_t v89 = *(unsigned int (**)(uint64_t, void, uint64_t, rusage_info_t *))(v88 + 144);
      if (v89 && !v89(v86, 0, 0x1EE561318, buffer))
      {
        rusage_info_t v90 = buffer[0];
        *(unsigned char *)(DerivedStorage + 80) = buffer[0];
        if (!v90) {
          goto LABEL_128;
        }
        uint64_t v91 = *(void *)(DerivedStorage + 168);
        uint64_t v92 = *(void *)(DerivedStorage + 176);
        uint64_t v93 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v93) {
          uint64_t v94 = v93;
        }
        else {
          uint64_t v94 = 0;
        }
        OSType v104 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v94 + 64);
        if (v104) {
          v104(v91, v92, 0x1EE5616B8, 1);
        }
        if (!buffer[0])
        {
LABEL_128:
          fsrm_copyPlayerIndicatedBitrate(*(void *)(DerivedStorage + 168), DerivedStorage);
          uint64_t v105 = *(void *)(DerivedStorage + 168);
          uint64_t v106 = *(void *)(DerivedStorage + 176);
          uint64_t v107 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v107) {
            uint64_t v108 = v107;
          }
          else {
            uint64_t v108 = 0;
          }
          unsigned int v109 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v108 + 64);
          if (v109) {
            v109(v105, v106, 0x1EE561178, 1);
          }
          fsrm_calculatePlayTimeAndUpdateTimeWeightedStats(DerivedStorage, DerivedStorage);
        }
      }
      fsrm_updatePlayTimeStatsForEvent(*(void *)(DerivedStorage + 168), *(void *)(DerivedStorage + 176), (uint64_t *)(DerivedStorage + 104), 0x1EE561698, 0x1EE561678);
      *(void *)(DerivedStorage + 24) = v11;
      goto LABEL_174;
    case 'n':
      uint64_t result = fsrm_calculatePlayTimeAndUpdateTimeWeightedStats(DerivedStorage, DerivedStorage);
      *(_DWORD *)(DerivedStorage + 8) = v12;
      if (result) {
        return result;
      }
      uint64_t v48 = *(void *)(DerivedStorage + 168);
      buffer[0] = 0;
      time.CMTimeValue value = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (!Mutable) {
        return 4294949786;
      }
      CFMutableDictionaryRef v50 = Mutable;
      uint64_t v51 = kFigReportingEventKeyArray_PeriodicStatsActivityMonitor;
      uint64_t v52 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v52) {
        uint64_t v53 = v52;
      }
      else {
        uint64_t v53 = 0;
      }
      int v95 = *(void (**)(uint64_t, uint64_t, CFMutableDictionaryRef))(v53 + 8);
      if (v95) {
        v95(v48, v51, v50);
      }
      FigCFDictionaryGetInt64IfPresent();
      FigCFDictionaryGetInt64IfPresent();
      rusage_info_t v96 = buffer[0];
      CMTimeValue value = time.value;
      CFRelease(v50);
      int v98 = 1;
      if ((uint64_t)v96 <= 0 && value < 1) {
        return 4294949783;
      }
LABEL_175:
      uint64_t v145 = FigGetUpTimeNanoseconds();
      *(_OWORD *)CVBufferRef buffer = *MEMORY[0x1E4F1F9F8];
      *(void *)&long long v220 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
      if (*(void *)(DerivedStorage + 208))
      {
        uint64_t v146 = fsrm_copyEventKeyArray(a2);
        if (v146)
        {
          uint64_t v147 = (const void *)v146;
          if (FigCFArrayContainsValue())
          {
            CMTimebaseGetTimeClampedAboveAnchorTime();
            uint64_t v148 = *(void *)(DerivedStorage + 168);
            *(_OWORD *)&time.CMTimeValue value = *(_OWORD *)buffer;
            time.CMTimeEpoch epoch = v220;
            double Seconds = CMTimeGetSeconds(&time);
            uint64_t v150 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v150) {
              uint64_t v151 = v150;
            }
            else {
              uint64_t v151 = 0;
            }
            double v152 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v151 + 88);
            if (v152) {
              v152(v148, 0x1EE582B78, 0x1EE562378, (unint64_t)Seconds);
            }
            uint64_t v153 = *(void *)(DerivedStorage + 168);
            *(_OWORD *)&time.CMTimeValue value = *(_OWORD *)buffer;
            time.CMTimeEpoch epoch = v220;
            double v154 = CMTimeGetSeconds(&time);
            uint64_t v155 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v155) {
              uint64_t v156 = v155;
            }
            else {
              uint64_t v156 = 0;
            }
            int32_t v157 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v156 + 88);
            if (v157) {
              v157(v153, 0x1EE582B78, 0x1EE562398, (unint64_t)(v154 * 1000.0));
            }
          }
          CFRelease(v147);
        }
      }
      if ((a2 & 0xFFFFFFFB) == 0x69)
      {
        LODWORD(buffer[0]) = 0;
        if (!fsrm_getInt32FromAggregatedSessionStats(*(void *)(DerivedStorage + 168), 0x1EE5619B8, buffer))FigUserExperienceSetCurrentRank(*(void **)(DerivedStorage + 216), (int)buffer[0]); {
        goto LABEL_192;
        }
      }
      if (a2 <= 105)
      {
        if (a2 == 101)
        {
          FigUserExperienceReportSessionEnd(*(void **)(DerivedStorage + 216));
          FigUserExperienceCalculateScore(*(void *)(DerivedStorage + 216));
          LOBYTE(v158) = 1;
          goto LABEL_209;
        }
        if (a2 == 103)
        {
          LODWORD(buffer[0]) = 0;
          FigUserExperienceReportStall(*(void **)(DerivedStorage + 216));
          if (!fsrm_getInt32FromAggregatedSessionStats(*(void *)(DerivedStorage + 168), 0x1EE5619B8, buffer))FigUserExperienceSetCurrentRank(*(void **)(DerivedStorage + 216), (int)buffer[0]); {
          uint64_t v159 = *(void *)(DerivedStorage + 24);
          }
          if (v159)
          {
            uint64_t v160 = *(void *)(DerivedStorage + 168);
            uint64_t v161 = *(void *)(DerivedStorage + 176);
            uint64_t v162 = *(void *)(CMBaseObjectGetVTable() + 16);
            uint64_t v163 = v162 ? v162 : 0;
            float v195 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v163 + 88);
            if (v195) {
              v195(v160, v161, 0x1EE5614B8, (v145 - v159) / 0xF4240uLL);
            }
          }
          uint64_t v196 = *(void *)(DerivedStorage + 16);
          if (v196)
          {
            uint64_t v197 = *(void *)(DerivedStorage + 168);
            uint64_t v198 = *(void *)(DerivedStorage + 176);
            uint64_t v199 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v199) {
              uint64_t v200 = v199;
            }
            else {
              uint64_t v200 = 0;
            }
            CFDictionaryRef v201 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v200 + 88);
            if (v201) {
              v201(v197, v198, 0x1EE584A98, (v145 - v196) / 0xF4240uLL);
            }
            *(void *)(DerivedStorage + 16) = 0;
          }
          uint64_t v202 = *(void *)(DerivedStorage + 168);
          uint64_t v203 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v203) {
            uint64_t v204 = v203;
          }
          else {
            uint64_t v204 = 0;
          }
          BOOL v205 = *(void (**)(uint64_t, void, uint64_t, uint64_t *))(v204 + 144);
          if (v205) {
            v205(v202, 0, 0x1EE585138, &v213);
          }
          uint64_t v158 = v213;
          if (v213)
          {
            uint64_t v206 = *(void *)(DerivedStorage + 168);
            uint64_t v207 = *(void *)(DerivedStorage + 176);
            uint64_t v208 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v208) {
              uint64_t v209 = v208;
            }
            else {
              uint64_t v209 = 0;
            }
            BOOL v210 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v209 + 88);
            if (v210) {
              v210(v206, v207, 0x1EE585158, (v145 - v158) / 0xF4240uLL);
            }
            LOBYTE(v158) = 0;
          }
          char v170 = 1;
          goto LABEL_218;
        }
LABEL_192:
        LOBYTE(v158) = 0;
        if (a2 != 106 || !v214)
        {
LABEL_216:
          if ((a2 | 2) != 0x67 && (a2 != 106 || !v214)) {
            goto LABEL_229;
          }
          char v170 = 0;
LABEL_218:
          uint64_t v171 = *(void *)(DerivedStorage + 40);
          if (v171)
          {
            uint64_t v172 = *(void *)(DerivedStorage + 168);
            uint64_t v173 = *(void *)(DerivedStorage + 176);
            uint64_t v174 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v174) {
              uint64_t v175 = v174;
            }
            else {
              uint64_t v175 = 0;
            }
            int32_t v176 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v175 + 88);
            if (v176) {
              v176(v172, v173, 0x1EE584AD8, (v145 - v171) / 0xF4240uLL);
            }
            *(void *)(DerivedStorage + 40) = 0;
          }
          if (v170)
          {
LABEL_231:
            uint64_t v177 = *(void *)(DerivedStorage + 168);
            uint64_t v178 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v178) {
              uint64_t v179 = v178;
            }
            else {
              uint64_t v179 = 0;
            }
            CMTimeEpoch v180 = *(void (**)(uint64_t, void, uint64_t, uint64_t *))(v179 + 152);
            if (v180) {
              v180(v177, 0, 0x1EE5612F8, &v215);
            }
            uint64_t v181 = *(void *)(DerivedStorage + 168);
            uint64_t v182 = *(void *)(DerivedStorage + 176);
            uint64_t v183 = v215;
            uint64_t v184 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v184) {
              uint64_t v185 = v184;
            }
            else {
              uint64_t v185 = 0;
            }
            unsigned int v186 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v185 + 80);
            if (v186) {
              v186(v181, v182, 0x1EE561198, v183);
            }
            goto LABEL_245;
          }
LABEL_229:
          if (a2 != 106 || !v214) {
            goto LABEL_245;
          }
          goto LABEL_231;
        }
LABEL_209:
        uint64_t v164 = *(void *)(DerivedStorage + 32);
        if (v164)
        {
          uint64_t v165 = *(void *)(DerivedStorage + 168);
          uint64_t v166 = *(void *)(DerivedStorage + 176);
          uint64_t v167 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v167) {
            uint64_t v168 = v167;
          }
          else {
            uint64_t v168 = 0;
          }
          uint64_t v169 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v168 + 88);
          if (v169) {
            v169(v165, v166, 0x1EE584AB8, (v145 - v164) / 0xF4240uLL);
          }
          *(void *)(DerivedStorage + 32) = 0;
        }
        goto LABEL_216;
      }
      if (a2 != 111)
      {
        if (a2 == 106)
        {
          LODWORD(buffer[0]) = 0;
          LODWORD(time.CFDictionarySetValue(theDict, key, value) = 0;
          if (!fsrm_getInt32FromAggregatedSessionStats(*(void *)(DerivedStorage + 168), 0x1EE54F698, buffer)&& !fsrm_getInt32FromAggregatedSessionStats(*(void *)(DerivedStorage + 168), 0x1EE5619B8, &time))
          {
            FigUserExperienceReportRateChange(*(void **)(DerivedStorage + 216), time.value, (int)buffer[0]);
          }
        }
        goto LABEL_192;
      }
      LODWORD(buffer[0]) = 0;
      LODWORD(time.CFDictionarySetValue(theDict, key, value) = 0;
      if (!fsrm_getInt32FromAggregatedSessionStats(*(void *)(DerivedStorage + 168), 0x1EE5619D8, buffer)&& !fsrm_getInt32FromAggregatedSessionStats(*(void *)(DerivedStorage + 168), 0x1EE561838, &time))
      {
        FigUserExperienceReportVariantCompleted(*(void **)(DerivedStorage + 216), (int)buffer[0], SLODWORD(time.value));
      }
      LOBYTE(v158) = 0;
LABEL_245:
      uint64_t v187 = *(void *)(DerivedStorage + 72);
      if (v187) {
        unint64_t v188 = (v145 - v187) / 0xF4240uLL;
      }
      else {
        unint64_t v188 = 0;
      }
      uint64_t v189 = *(void *)(DerivedStorage + 168);
      uint64_t v190 = *(void *)(DerivedStorage + 176);
      uint64_t v191 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v191) {
        uint64_t v192 = v191;
      }
      else {
        uint64_t v192 = 0;
      }
      BOOL v193 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v192 + 88);
      if (v193)
      {
        uint64_t result = v193(v189, v190, 0x1EE583ED8, v188);
        if (!result)
        {
          if ((v98 | v158)) {
            fsrm_reportAggregatedTimeWeightedStats(DerivedStorage, v98 ^ 1u);
          }
          uint64_t *v211 = fsrm_copyEventKeyArray(a2);
          if (v212 && (v24 > 0xC || ((1 << v24) & 0x1801) == 0))
          {
            if (kFigReportingEventKeyArray_FetchKeysFromAggregatedSessionStats) {
              CFTypeRef v194 = CFRetain((CFTypeRef)kFigReportingEventKeyArray_FetchKeysFromAggregatedSessionStats);
            }
            else {
              CFTypeRef v194 = 0;
            }
            uint64_t result = 0;
            *unsigned int v212 = v194;
          }
          else
          {
            uint64_t result = 0;
          }
        }
      }
      else
      {
        uint64_t result = 4294954514;
      }
      break;
    case 'o':
      buffer[0] = 0;
      uint64_t v217 = 0;
      time.CMTimeValue value = 0;
      uint64_t v216 = 0;
      uint64_t v54 = *(void *)(DerivedStorage + 168);
      uint64_t v55 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v55) {
        uint64_t v56 = v55;
      }
      else {
        uint64_t v56 = 0;
      }
      long long v81 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, rusage_info_t *))(v56 + 144);
      if (v81 && !v81(v54, 0x1EE582B78, 0x1EE5617D8, buffer))
      {
        uint64_t v82 = *(void *)(DerivedStorage + 168);
        uint64_t v83 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v84 = v83 ? v83 : 0;
        uint64_t v100 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, CMTime *))(v84 + 144);
        if (v100
          && !v100(v82, 0x1EE582B78, 0x1EE5617B8, &time)
          && *(void *)(DerivedStorage + 144) * *(void *)(DerivedStorage + 136) < time.value * (uint64_t)buffer[0])
        {
          uint64_t v101 = *(void *)(DerivedStorage + 168);
          uint64_t v102 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v103 = v102 ? v102 : 0;
          CFTypeRef v116 = *(unsigned int (**)(uint64_t, uint64_t, __CFString *, uint64_t *))(v103 + 48);
          if (v116 && !v116(v101, 1, @"PlayTime", &v217))
          {
            uint64_t v117 = *(void *)(DerivedStorage + 168);
            uint64_t v118 = *(void *)(CMBaseObjectGetVTable() + 16);
            uint64_t v119 = v118 ? v118 : 0;
            char v120 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v119 + 144);
            if (v120 && !v120(v117, 0x1EE582B78, 0x1EE561818, &v216))
            {
              uint64_t v122 = v217;
              CMTimeValue v121 = time.value;
              *(rusage_info_t *)(DerivedStorage + 136) = buffer[0];
              *(void *)(DerivedStorage + 144) = v121;
              uint64_t v123 = *(void *)(DerivedStorage + 168);
              uint64_t v124 = *(void *)(DerivedStorage + 176);
              uint64_t v125 = v216;
              uint64_t v126 = *(void *)(CMBaseObjectGetVTable() + 16);
              uint64_t v127 = v126 ? v126 : 0;
              CMTime v129 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v127 + 88);
              if (v129) {
                v129(v123, v124, 0x1EE561F98, v122 - v125);
              }
            }
          }
        }
      }
      buffer[0] = 0;
      time.CMTimeValue value = 0;
      uint64_t v130 = *(void *)(DerivedStorage + 168);
      uint64_t v131 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v131) {
        uint64_t v132 = v131;
      }
      else {
        uint64_t v132 = 0;
      }
      Float64 v133 = *(unsigned int (**)(uint64_t, uint64_t, __CFString *, rusage_info_t *))(v132 + 48);
      if (v133 && !v133(v130, 1, @"PlayTime", buffer))
      {
        uint64_t v134 = *(void *)(DerivedStorage + 168);
        uint64_t v135 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v136 = v135 ? v135 : 0;
        unsigned int v137 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, CMTime *))(v136 + 144);
        if (v137 && !v137(v134, 0x1EE582B78, 0x1EE561818, &time))
        {
          uint64_t v138 = *(void *)(DerivedStorage + 168);
          uint64_t v139 = *(void *)(DerivedStorage + 176);
          __int16 v140 = (char *)buffer[0];
          CMTimeValue v141 = time.value;
          uint64_t v142 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v143 = v142 ? v142 : 0;
          __int16 v144 = *(void (**)(uint64_t, uint64_t, uint64_t, char *))(v143 + 88);
          if (v144) {
            v144(v138, v139, 0x1EE561FB8, &v140[-v141]);
          }
        }
      }
      goto LABEL_174;
    default:
      if (a2 == 202)
      {
        fsrm_setSessionEndReasonIfFatalError(DerivedStorage, *(void *)(DerivedStorage + 176), 0x1EE583EB8, 0x1EE583E38, 0x1EE583E78, 0x1EE583E58);
        uint64_t v30 = *(void *)(DerivedStorage + 168);
        uint64_t v31 = *(void *)(DerivedStorage + 176);
        uint64_t v32 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v32) {
          uint64_t v33 = v32;
        }
        else {
          uint64_t v33 = 0;
        }
        unsigned int v99 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v33 + 64);
        if (v99) {
          v99(v30, v31, 0x1EE583DF8, 1);
        }
        *(void *)(DerivedStorage + 72) = v11;
      }
      goto LABEL_174;
  }
  return result;
}

uint64_t streamModeratorResetStatsForEvent(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!DerivedStorage) {
    return 4294949785;
  }
  uint64_t v4 = DerivedStorage;
  uint64_t result = 0;
  switch(a2)
  {
    case 'g':
      uint64_t v6 = *(void *)(v4 + 168);
      uint64_t v7 = *(void *)(v4 + 176);
      uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v8) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = 0;
      }
      uint64_t v34 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 104);
      if (v34) {
        v34(v6, v7, 0x1EE584A98);
      }
      uint64_t v35 = *(void *)(v4 + 168);
      uint64_t v36 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v36) {
        uint64_t v37 = v36;
      }
      else {
        uint64_t v37 = 0;
      }
      double v60 = *(void (**)(uint64_t, uint64_t))(v37 + 128);
      if (v60) {
        v60(v35, 0x1EE584A98);
      }
      uint64_t v61 = *(void *)(v4 + 168);
      uint64_t v62 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v62) {
        uint64_t v63 = v62;
      }
      else {
        uint64_t v63 = 0;
      }
      int v74 = *(void (**)(uint64_t, uint64_t))(v63 + 176);
      if (!v74) {
        return 0;
      }
      uint64_t v75 = v61;
      uint64_t v76 = 0x1EE584A98;
      goto LABEL_127;
    case 'j':
      uint64_t v10 = *(void *)(v4 + 168);
      uint64_t v11 = *(void *)(v4 + 176);
      uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v12) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = 0;
      }
      int v38 = *(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 104);
      if (v38) {
        v38(v10, v11, 0x1EE583F78);
      }
      uint64_t v39 = *(void *)(v4 + 168);
      uint64_t v40 = *(void *)(v4 + 176);
      uint64_t v41 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v41) {
        uint64_t v42 = v41;
      }
      else {
        uint64_t v42 = 0;
      }
      uint64_t v64 = *(void (**)(uint64_t, uint64_t, uint64_t))(v42 + 104);
      if (v64) {
        v64(v39, v40, 0x1EE583F98);
      }
      uint64_t v65 = *(void *)(v4 + 168);
      uint64_t v66 = *(void *)(v4 + 176);
      uint64_t v67 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v67) {
        uint64_t v68 = v67;
      }
      else {
        uint64_t v68 = 0;
      }
      uint64_t v77 = *(void (**)(uint64_t, uint64_t, uint64_t))(v68 + 104);
      if (v77) {
        v77(v65, v66, 0x1EE584AB8);
      }
      uint64_t v78 = *(void *)(v4 + 168);
      uint64_t v79 = *(void *)(v4 + 176);
      uint64_t v80 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v80) {
        uint64_t v81 = v80;
      }
      else {
        uint64_t v81 = 0;
      }
      uint64_t v87 = *(void (**)(uint64_t, uint64_t, uint64_t))(v81 + 104);
      if (v87) {
        v87(v78, v79, 0x1EE584AD8);
      }
      uint64_t v88 = *(void *)(v4 + 168);
      uint64_t v89 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v89) {
        uint64_t v90 = v89;
      }
      else {
        uint64_t v90 = 0;
      }
      rusage_info_t v96 = *(void (**)(uint64_t, uint64_t))(v90 + 128);
      if (v96) {
        v96(v88, 0x1EE584AB8);
      }
      uint64_t v97 = *(void *)(v4 + 168);
      uint64_t v98 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v98) {
        uint64_t v99 = v98;
      }
      else {
        uint64_t v99 = 0;
      }
      uint64_t v105 = *(void (**)(uint64_t, uint64_t))(v99 + 128);
      if (v105) {
        v105(v97, 0x1EE584AD8);
      }
      uint64_t v106 = *(void *)(v4 + 168);
      uint64_t v107 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v107) {
        uint64_t v108 = v107;
      }
      else {
        uint64_t v108 = 0;
      }
      uint64_t v114 = *(void (**)(uint64_t, uint64_t))(v108 + 176);
      if (v114) {
        v114(v106, 0x1EE584AB8);
      }
      uint64_t v115 = *(void *)(v4 + 168);
      uint64_t v116 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v116) {
        uint64_t v117 = v116;
      }
      else {
        uint64_t v117 = 0;
      }
      int v74 = *(void (**)(uint64_t, uint64_t))(v117 + 176);
      if (v74)
      {
        uint64_t v75 = v115;
        uint64_t v76 = 0x1EE584AD8;
LABEL_127:
        v74(v75, v76);
      }
      return 0;
    case 'm':
      goto LABEL_41;
    case 'n':
      uint64_t v14 = *(void *)(v4 + 168);
      uint64_t v15 = kFigReportingEventKeyArray_PeriodicEventKeysToReset;
      uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v16) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v43 = *(void (**)(uint64_t, uint64_t))(v17 + 136);
      if (v43) {
        v43(v14, v15);
      }
LABEL_41:
      uint64_t v44 = *(void *)(v4 + 168);
      uint64_t v45 = *(void *)(v4 + 176);
      uint64_t v46 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v46) {
        uint64_t v47 = v46;
      }
      else {
        uint64_t v47 = 0;
      }
      uint64_t v48 = *(void (**)(uint64_t, uint64_t, __CFString *))(v47 + 104);
      if (v48) {
        v48(v44, v45, @"PlayTime");
      }
      uint64_t v50 = *(void *)(v4 + 168);
      uint64_t v49 = *(void *)(v4 + 176);
      uint64_t v51 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v51) {
        uint64_t v52 = v51;
      }
      else {
        uint64_t v52 = 0;
      }
      uint64_t v53 = *(void (**)(uint64_t, uint64_t, uint64_t))(v52 + 104);
      if (!v53) {
        return 0;
      }
      uint64_t v54 = 0x1EE583F38;
      break;
    case 'o':
      uint64_t v18 = *(void *)(v4 + 168);
      uint64_t v19 = *(void *)(v4 + 176);
      uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v20) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v55 = *(void (**)(uint64_t, uint64_t, uint64_t))(v21 + 104);
      if (v55) {
        v55(v18, v19, 0x1EE5618B8);
      }
      uint64_t v56 = *(void *)(v4 + 168);
      uint64_t v57 = *(void *)(v4 + 176);
      uint64_t v58 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v58) {
        uint64_t v59 = v58;
      }
      else {
        uint64_t v59 = 0;
      }
      uint64_t v69 = *(void (**)(uint64_t, uint64_t, uint64_t))(v59 + 104);
      if (v69) {
        v69(v56, v57, 0x1EE561898);
      }
      uint64_t v70 = *(void *)(v4 + 168);
      uint64_t v71 = *(void *)(v4 + 176);
      uint64_t v72 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v72) {
        uint64_t v73 = v72;
      }
      else {
        uint64_t v73 = 0;
      }
      uint64_t v82 = *(void (**)(uint64_t, uint64_t, uint64_t))(v73 + 104);
      if (v82) {
        v82(v70, v71, 0x1EE5618D8);
      }
      uint64_t v83 = *(void *)(v4 + 168);
      uint64_t v84 = *(void *)(v4 + 176);
      uint64_t v85 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v85) {
        uint64_t v86 = v85;
      }
      else {
        uint64_t v86 = 0;
      }
      uint64_t v91 = *(void (**)(uint64_t, uint64_t, uint64_t))(v86 + 104);
      if (v91) {
        v91(v83, v84, 0x1EE561938);
      }
      uint64_t v92 = *(void *)(v4 + 168);
      uint64_t v93 = *(void *)(v4 + 176);
      uint64_t v94 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v94) {
        uint64_t v95 = v94;
      }
      else {
        uint64_t v95 = 0;
      }
      uint64_t v100 = *(void (**)(uint64_t, uint64_t, uint64_t))(v95 + 104);
      if (v100) {
        v100(v92, v93, 0x1EE5618F8);
      }
      uint64_t v101 = *(void *)(v4 + 168);
      uint64_t v102 = *(void *)(v4 + 176);
      uint64_t v103 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v103) {
        uint64_t v104 = v103;
      }
      else {
        uint64_t v104 = 0;
      }
      unsigned int v109 = *(void (**)(uint64_t, uint64_t, uint64_t))(v104 + 104);
      if (v109) {
        v109(v101, v102, 0x1EE561918);
      }
      uint64_t v110 = *(void *)(v4 + 168);
      uint64_t v111 = *(void *)(v4 + 176);
      uint64_t v112 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v112) {
        uint64_t v113 = v112;
      }
      else {
        uint64_t v113 = 0;
      }
      uint64_t v118 = *(void (**)(uint64_t, uint64_t, uint64_t))(v113 + 104);
      if (v118) {
        v118(v110, v111, 0x1EE561958);
      }
      uint64_t v119 = *(void *)(v4 + 168);
      uint64_t v120 = *(void *)(v4 + 176);
      uint64_t v121 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v121) {
        uint64_t v122 = v121;
      }
      else {
        uint64_t v122 = 0;
      }
      uint64_t v123 = *(void (**)(uint64_t, uint64_t, uint64_t))(v122 + 104);
      if (v123) {
        v123(v119, v120, 0x1EE561F98);
      }
      uint64_t v50 = *(void *)(v4 + 168);
      uint64_t v49 = *(void *)(v4 + 176);
      uint64_t v124 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v124) {
        uint64_t v125 = v124;
      }
      else {
        uint64_t v125 = 0;
      }
      uint64_t v53 = *(void (**)(uint64_t, uint64_t, uint64_t))(v125 + 104);
      if (!v53) {
        return 0;
      }
      uint64_t v54 = 0x1EE562338;
      break;
    case 'p':
      if (CFArrayGetCount((CFArrayRef)kFigReportingEventKeyArray_DownloadPerfValuesPerMainSubstreamSegment) >= 1)
      {
        CFIndex v22 = 0;
        do
        {
          uint64_t v23 = *(void *)CFArrayGetValueAtIndex((CFArrayRef)kFigReportingEventKeyArray_DownloadPerfValuesPerMainSubstreamSegment, v22);
          uint64_t v24 = *(void *)(v4 + 168);
          uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v25) {
            uint64_t v26 = v25;
          }
          else {
            uint64_t v26 = 0;
          }
          long long v27 = *(void (**)(uint64_t, uint64_t))(v26 + 112);
          if (v27) {
            v27(v24, v23);
          }
          ++v22;
        }
        while (v22 < CFArrayGetCount((CFArrayRef)kFigReportingEventKeyArray_DownloadPerfValuesPerMainSubstreamSegment));
      }
      if (CFArrayGetCount((CFArrayRef)kFigReportingEventKeyArray_DownloadPerfValuesPerAudioSubstreamSegment) >= 1)
      {
        CFIndex v28 = 0;
        do
        {
          uint64_t v29 = *(void *)CFArrayGetValueAtIndex((CFArrayRef)kFigReportingEventKeyArray_DownloadPerfValuesPerAudioSubstreamSegment, v28);
          uint64_t v30 = *(void *)(v4 + 168);
          uint64_t v31 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v31) {
            uint64_t v32 = v31;
          }
          else {
            uint64_t v32 = 0;
          }
          uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v32 + 112);
          if (v33) {
            v33(v30, v29);
          }
          ++v28;
        }
        while (v28 < CFArrayGetCount((CFArrayRef)kFigReportingEventKeyArray_DownloadPerfValuesPerAudioSubstreamSegment));
      }
      return 0;
    default:
      return result;
  }
  v53(v50, v49, v54);
  return 0;
}

uint64_t streamModeratorPostProcessPayloadForEvent(int a1, int a2, CFDictionaryRef theDict)
{
  if (a2 != 112 || !theDict || CFDictionaryGetCount(theDict) < 1) {
    return 0;
  }
  ArrayNameFromuint64_t Key = fsrm_createArrayNameFromKey(@"SST");
  CFIndex v5 = fsrm_createArrayNameFromKey(@"AudSST");
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, ArrayNameFromKey);
  CFArrayRef v7 = Value;
  if (Value && CFArrayGetCount(Value) >= 1)
  {
    CFIndex v8 = 0;
    do
    {
      if (FigCFArrayGetInt64AtIndex()) {
        break;
      }
      ++v8;
    }
    while (v8 < CFArrayGetCount(v7));
  }
  CFArrayRef v9 = (const __CFArray *)CFDictionaryGetValue(theDict, v5);
  CFArrayRef v10 = v9;
  if (v9)
  {
    if (CFArrayGetCount(v9) < 1) {
      goto LABEL_17;
    }
    CFIndex v11 = 0;
    do
    {
      if (FigCFArrayGetInt64AtIndex()) {
        break;
      }
      ++v11;
    }
    while (v11 < CFArrayGetCount(v10));
  }
  if ((unint64_t)v7 | (unint64_t)v10)
  {
LABEL_17:
    FigCFDictionarySetInt64();
    fsrm_replaceTimestampWithDelta(theDict, ArrayNameFromKey);
    fsrm_replaceTimestampWithDelta(theDict, v5);
  }
  if (ArrayNameFromKey) {
    CFRelease(ArrayNameFromKey);
  }
  if (v5) {
    CFRelease(v5);
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theDict);
  if (Copy)
  {
    CFDictionaryRef v13 = Copy;
    CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)fsrm_stringifyArrayFunc, theDict);
    CFRelease(v13);
  }
  return 0;
}

uint64_t streamModeratorGetFollowupEventForEvent(uint64_t a1, int a2, _DWORD *a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a3 && a4)
  {
    *a3 = 0;
    *a4 = 0;
    if ((a2 - 2001) <= 1)
    {
      uint64_t v8 = DerivedStorage;
      MaxArrayCFIndex Count = fsrm_getMaxArrayCount(*(void *)(DerivedStorage + 168), (CFArrayRef)kFigReportingEventKeyArray_DownloadPerfValuesPerMainSubstreamSegment);
      if (fsrm_getMaxArrayCount(*(void *)(v8 + 168), (CFArrayRef)kFigReportingEventKeyArray_DownloadPerfValuesPerAudioSubstreamSegment)+ MaxArrayCount <= 49)return 0; {
      goto LABEL_7;
      }
    }
    if (a2 == 103)
    {
LABEL_7:
      *a3 = 112;
      *a4 = 0;
    }
  }
  return 0;
}

uint64_t fsrm_copyEventKeyArray(int a1)
{
  MEMORY[0x19970EE10](&fsrm_copyEventKeyArray_sCreateStaticKeyArrayFromEventKeysOnce, fsrm_createStaticDataStructuresFromEventKeys);
  uint64_t v2 = 0;
  CFAllocatorRef v3 = &kFigReportingEventKeyArray_AggregatedEvent;
  if (a1 > 200)
  {
    if (a1 <= 801)
    {
      if (a1 > 799)
      {
        if (a1 == 800) {
          CFAllocatorRef v3 = &kFigReportingEventKeyArray_IRATStreamingActivityStartEvent;
        }
        else {
          CFAllocatorRef v3 = &kFigReportingEventKeyArray_IRATStreamingActivityEndEvent;
        }
      }
      else if (a1 == 201)
      {
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_PumpAlternateSwitchEvent;
      }
      else
      {
        if (a1 != 202) {
          return v2;
        }
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_PumpErrorEvent;
      }
    }
    else if (a1 <= 900)
    {
      if (a1 == 802)
      {
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_IRATStallEvent;
      }
      else
      {
        if (a1 != 900) {
          return v2;
        }
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_PowerLogEvent;
      }
    }
    else if (a1 != 901)
    {
      if (a1 == 1001)
      {
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_VerboseLoggingPerMainSubstreamSegment;
      }
      else
      {
        if (a1 != 1002) {
          return v2;
        }
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_VerboseLoggingPerAudioSubstreamSegment;
      }
    }
LABEL_33:
    uint64_t v2 = *v3;
    if (*v3) {
      CFRetain((CFTypeRef)*v3);
    }
  }
  else
  {
    switch(a1)
    {
      case 'e':
        goto LABEL_33;
      case 'g':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_StallEvent;
        goto LABEL_33;
      case 'i':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_LikelyToKeepUpEvent;
        goto LABEL_33;
      case 'j':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_PlayRateChangedEvent;
        goto LABEL_33;
      case 'k':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_PlayerErrorEvent;
        goto LABEL_33;
      case 'm':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_PlayerSwitchCompleteEvent;
        goto LABEL_33;
      case 'n':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_PeriodicEvent;
        goto LABEL_33;
      case 'o':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_PlayerVideoVariantEndedEvent;
        goto LABEL_33;
      case 'p':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_DownloadPerformanceEvent;
        goto LABEL_33;
      case 'q':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_BandwidthPredictionsPeriodic;
        goto LABEL_33;
      case 'r':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_PlayerFormatTransition;
        goto LABEL_33;
      case 's':
        CFAllocatorRef v3 = &kFigReportingEventKeyArray_StartupPerformanceMetrics;
        goto LABEL_33;
      default:
        return v2;
    }
  }
  return v2;
}

uint64_t fsrm_getInt32FromAggregatedSessionStats(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = 4294949785;
  if (a1 && a3)
  {
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    CFArrayRef v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v8 + 40);
    if (v9)
    {
      uint64_t v10 = 0;
      uint64_t result = v9(a1, 1, a2, &v10);
      if (!result) {
        *a3 = v10;
      }
    }
    else
    {
      return 4294954514;
    }
  }
  return result;
}

uint64_t fsrm_updateProcessMemoryAndCPUSession(uint64_t a1)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  pid_t v2 = getpid();
  uint64_t result = proc_pid_rusage(v2, 6, (rusage_info_t *)&v22);
  if (!result)
  {
    BOOL v5 = *(_DWORD *)(a1 + 8) > 3u || (*(_DWORD *)(a1 + 8) & 0xF) == 1;
    uint64_t v6 = v23;
    if (mach_absolute_time_to_s_have_tmscale != -1) {
      dispatch_once(&mach_absolute_time_to_s_have_tmscale, &__block_literal_global_8);
    }
    double v7 = *(double *)&mach_absolute_time_to_s_tmscale * (double)v6 / 1000000000.0;
    if (!v5)
    {
      double v8 = *(double *)(a1 + 200);
      if (v8 != 0.0 && v7 > v8)
      {
        uint64_t v9 = *(void *)(a1 + 168);
        uint64_t v10 = *(void *)(a1 + 176);
        uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v12 = v11 ? v11 : 0;
        CFDictionaryRef v13 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v12 + 64);
        if (v13) {
          v13(v9, v10, 0x1EE583D38, (unint64_t)((v7 - v8) * 1000.0));
        }
      }
    }
    unint64_t v14 = *((void *)&v26 + 1);
    uint64_t v15 = *(void *)(a1 + 168);
    uint64_t v16 = *(void *)(a1 + 176);
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v19 = *(void *)(VTable + 16);
    uint64_t result = VTable + 16;
    uint64_t v18 = v19;
    if (v19) {
      uint64_t v20 = v18;
    }
    else {
      uint64_t v20 = 0;
    }
    uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v20 + 72);
    if (v21) {
      uint64_t result = v21(v15, v16, 0x1EE583CB8, v14 >> 10);
    }
    *(double *)(a1 + 200) = v7;
  }
  return result;
}

uint64_t fsrm_updateExpensiveNetworkStats(uint64_t a1)
{
  uint64_t result = FigGetUpTimeNanoseconds();
  uint64_t v19 = 0;
  if (a1)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)(a1 + 152);
    if (v4)
    {
      unint64_t v5 = result - v4;
      unint64_t v6 = (result - v4) / 0xF4240uLL;
      if (*(unsigned char *)(a1 + 160)) {
        double v7 = &kFigReportingEventKey_TimeWeightedIndicatedBitsExpensive;
      }
      else {
        double v7 = &kFigReportingEventKey_TimeWeightedIndicatedBitsInexpensive;
      }
      if (*(unsigned char *)(a1 + 160)) {
        double v8 = &kFigReportingEventKey_TimeWeightedIndicatedAverageBitsExpensive;
      }
      else {
        double v8 = &kFigReportingEventKey_TimeWeightedIndicatedAverageBitsInexpensive;
      }
      if (*(unsigned char *)(a1 + 160)) {
        uint64_t v9 = &kFigReportingEventKey_TimeWeightedVariantRankInPlayTimeExpensive;
      }
      else {
        uint64_t v9 = &kFigReportingEventKey_TimeWeightedVariantRankInPlayTimeInexpensive;
      }
      if (*(unsigned char *)(a1 + 160)) {
        uint64_t v10 = &kFigReportingEventKey_TimeWeightedVariantBitrateRankInPlayTimeExpensive;
      }
      else {
        uint64_t v10 = &kFigReportingEventKey_TimeWeightedVariantBitrateRankInPlayTimeInexpensive;
      }
      if (*(unsigned char *)(a1 + 160)) {
        uint64_t v11 = &kFigReportingEventKey_ExpensivePlayTimeWC;
      }
      else {
        uint64_t v11 = &kFigReportingEventKey_InexpensivePlayTimeWC;
      }
      fsrm_addToSessionStatsCountValue(a1, *v7, v6 * *(int *)(a1 + 56));
      fsrm_addToSessionStatsCountValue(a1, *v8, v6 * *(int *)(a1 + 60));
      fsrm_addToSessionStatsCountValue(a1, *v9, v6 * *(int *)(a1 + 64));
      fsrm_addToSessionStatsCountValue(a1, *v10, v6 * *(int *)(a1 + 68));
      fsrm_addToSessionStatsCountValue(a1, *v11, v5 / 0xF4240);
    }
    *(void *)(a1 + 152) = v3;
    uint64_t v12 = *(void *)(a1 + 168);
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v15 = *(void *)(VTable + 16);
    uint64_t result = VTable + 16;
    uint64_t v14 = v15;
    if (v15) {
      uint64_t v16 = v14;
    }
    else {
      uint64_t v16 = 0;
    }
    uint64_t v17 = *(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(v16 + 144);
    if (v17)
    {
      uint64_t result = v17(v12, 0, 0x1EE584898, &v19);
      char v18 = v19;
    }
    else
    {
      char v18 = 0;
    }
    *(unsigned char *)(a1 + 160) = v18;
  }
  return result;
}

uint64_t fsrm_reportAggregatedTimeWeightedStats(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  fsrm_updateExpensiveNetworkStats(a1);
  uint64_t v4 = *(void *)(a1 + 168);
  uint64_t v5 = *(void *)(a1 + 176);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  double v8 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v7 + 48);
  if (v8) {
    v8(v4, a2, 0x1EE584858, &v36);
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v10 + 48);
  if (v11) {
    v11(v4, a2, 0x1EE583958, &v35);
  }
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v13 + 48);
  if (v14) {
    v14(v4, a2, 0x1EE562A58, &v38);
  }
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v18 = *(void *)(VTable + 16);
  uint64_t result = VTable + 16;
  uint64_t v17 = v18;
  if (v18) {
    uint64_t v19 = v17;
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v19 + 48);
  if (v20) {
    uint64_t result = v20(v4, a2, 0x1EE562A78, &v37);
  }
  if (v38)
  {
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE5848B8, 0x1EE5628D8, v38);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE5848D8, 0x1EE5628F8, v38);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE5848F8, 0x1EE562918, v38);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE584918, 0x1EE562938, v38);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE584938, 0x1EE562958, v38);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE584958, 0x1EE562978, v38);
    uint64_t v21 = v38;
    uint64_t v22 = CMBaseObjectGetVTable();
    uint64_t v24 = *(void *)(v22 + 16);
    uint64_t result = v22 + 16;
    uint64_t v23 = v24;
    uint64_t v25 = v24 ? v23 : 0;
    long long v26 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 88);
    if (v26) {
      uint64_t result = v26(v4, v5, 0x1EE562A58, 1000 * v21);
    }
  }
  if (v37)
  {
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE584978, 0x1EE562998, v37);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE584998, 0x1EE5629B8, v37);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE5849B8, 0x1EE5629D8, v37);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE5849D8, 0x1EE5629F8, v37);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE5849F8, 0x1EE562A18, v37);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE584A18, 0x1EE562A38, v37);
    uint64_t v27 = v37;
    uint64_t v28 = CMBaseObjectGetVTable();
    uint64_t v30 = *(void *)(v28 + 16);
    uint64_t result = v28 + 16;
    uint64_t v29 = v30;
    uint64_t v31 = v30 ? v29 : 0;
    long long v32 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v31 + 88);
    if (v32) {
      uint64_t result = v32(v4, v5, 0x1EE562A78, 1000 * v27);
    }
  }
  uint64_t v33 = v35;
  uint64_t v34 = v36;
  if (v36)
  {
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE5847D8, 0x1EE561078, v36);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE584878, 0x1EE561A18, v34);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE584798, 0x1EE583698, v34);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE5847B8, 0x1EE5836B8, v34);
    fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE5847F8, 0x1EE561098, v34);
    uint64_t result = fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE584818, 0x1EE5610B8, v34);
  }
  if (v33) {
    return fsrm_setTimeWeightedValue(v4, v5, a2, 0x1EE584838, 0x1EE583678, v33);
  }
  return result;
}

double __mach_absolute_time_to_s_block_invoke()
{
  mach_timebase_info info = 0;
  if (!mach_timebase_info(&info))
  {
    LODWORD(result) = info.numer;
    LODWORD(v1) = info.denom;
    double result = (double)*(unint64_t *)&result / (double)v1;
    mach_absolute_time_to_s_tmscale = *(void *)&result;
  }
  return result;
}

uint64_t fsrm_addToSessionStatsCountValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 168);
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v10 = *(void *)(VTable + 16);
  uint64_t result = VTable + 16;
  uint64_t v9 = v10;
  if (v10) {
    uint64_t v11 = v9;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 64);
  if (v12)
  {
    return v12(v5, v6, a2, a3);
  }
  return result;
}

uint64_t fsrm_updatePlayTimeStatsForEvent(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = a3[1];
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 88);
  if (v13) {
    v13(a1, a2, a5, v10);
  }
  uint64_t v14 = *a3;
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v18 = *(void *)(VTable + 16);
  uint64_t result = VTable + 16;
  uint64_t v17 = v18;
  if (v18) {
    uint64_t v19 = v17;
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 88);
  if (v20) {
    uint64_t result = v20(a1, a2, a4, v14);
  }
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t fsrm_calculatePlayTimeAndUpdateTimeWeightedStats(uint64_t a1, uint64_t a2)
{
  CFNumberRef v30 = 0;
  uint64_t v31 = 0;
  uint64_t valuePtr = 0;
  CFNumberRef number = 0;
  uint64_t v27 = 0;
  uint64_t v4 = *(void *)(a1 + 168);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(unsigned int (**)(uint64_t, void, uint64_t, uint64_t *))(v6 + 160);
  if (!v7 || v7(v4, 0, 0x1EE583F38, &v31)) {
    uint64_t v31 = 1;
  }
  uint64_t v8 = *(void *)(a1 + 168);
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t, CFNumberRef *))(v10 + 56);
  if (v11)
  {
    v11(v8, 1, 0x1EE5614D8, &number);
    if (number) {
      CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
    }
  }
  uint64_t v12 = *(void *)(a1 + 168);
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFNumberRef *))(v14 + 56);
  if (v15)
  {
    uint64_t Int32FromAggregatedSessionStats = v15(v12, 1, 0x1EE5614F8, &v30);
    if (!Int32FromAggregatedSessionStats)
    {
      if (!v30 || (CFNumberGetValue(v30, kCFNumberSInt32Type, (char *)&valuePtr + 4), !HIDWORD(valuePtr)))
      {
LABEL_33:
        uint64_t v25 = 0;
        goto LABEL_35;
      }
      uint64_t Int32FromAggregatedSessionStats = fsrm_getInt32FromAggregatedSessionStats(*(void *)(a1 + 168), 0x1EE561158, (_DWORD *)&v27 + 1);
      if (!Int32FromAggregatedSessionStats)
      {
        uint64_t Int32FromAggregatedSessionStats = fsrm_getInt32FromAggregatedSessionStats(*(void *)(a1 + 168), 0x1EE5619B8, &v27);
        if (!Int32FromAggregatedSessionStats)
        {
          fsrm_updateExpensiveNetworkStats(a1);
          uint64_t v17 = v31;
          int v19 = valuePtr;
          int v18 = HIDWORD(valuePtr);
          int v21 = v27;
          int v20 = HIDWORD(v27);
          uint64_t v32 = 0;
          if (a2 && v31 >= 1)
          {
            CFNumberRef v22 = *(const __CFNumber **)(a2 + 88);
            if (v22) {
              CFNumberGetValue(v22, kCFNumberSInt32Type, (char *)&v32 + 4);
            }
            CFNumberRef v23 = *(const __CFNumber **)(a2 + 96);
            if (v23) {
              CFNumberGetValue(v23, kCFNumberSInt32Type, &v32);
            }
            int v24 = *(_DWORD *)(a2 + 56);
            if (!v24)
            {
              *(_DWORD *)(a2 + 56) = v18;
              int v24 = v18;
            }
            if (!*(_DWORD *)(a2 + 60)) {
              *(_DWORD *)(a2 + 60) = v19;
            }
            fsrm_addToSessionStatsCountValue(a1, 0x1EE584798, v17 * v24);
            fsrm_addToSessionStatsCountValue(a1, 0x1EE5847B8, v17 * *(int *)(a2 + 60));
            fsrm_addToSessionStatsCountValue(a1, 0x1EE5847D8, v17 * *(int *)(a2 + 64));
            fsrm_addToSessionStatsCountValue(a1, 0x1EE584878, v17 * *(int *)(a2 + 68));
            fsrm_addToSessionStatsCountValue(a1, 0x1EE5847F8, v17 * SHIDWORD(v32));
            fsrm_addToSessionStatsCountValue(a1, 0x1EE584818, v17 * (int)v32);
            fsrm_addToSessionStatsCountValue(a1, 0x1EE584858, v17);
            *(void *)(a2 + 48) = v17;
            *(_DWORD *)(a2 + 56) = v18;
            *(_DWORD *)(a2 + 60) = v19;
            *(_DWORD *)(a2 + 64) = v20;
            *(_DWORD *)(a2 + 68) = v21;
          }
          goto LABEL_33;
        }
      }
    }
    uint64_t v25 = Int32FromAggregatedSessionStats;
  }
  else
  {
    uint64_t v25 = 4294954514;
  }
LABEL_35:
  if (number) {
    CFRelease(number);
  }
  if (v30) {
    CFRelease(v30);
  }
  return v25;
}

uint64_t fsrm_copyPlayerIndicatedBitrate(uint64_t a1, uint64_t a2)
{
  uint64_t result = fsrm_copyCFTypeValueFromAggregatedStats(a1, 0x1EE5614F8, (uint64_t *)(a2 + 88));
  if (!result)
  {
    return fsrm_copyCFTypeValueFromAggregatedStats(a1, 0x1EE5614D8, (uint64_t *)(a2 + 96));
  }
  return result;
}

uint64_t fsrm_copyCFTypeValueFromAggregatedStats(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  CFTypeRef cf = 0;
  if (!a3) {
    return 4294949785;
  }
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(v7 + 56);
  if (v8)
  {
    uint64_t v9 = v8(a1, 1, a2, &cf);
    if (v9)
    {
      uint64_t v11 = v9;
    }
    else
    {
      CFTypeRef v10 = cf;
      if (!cf) {
        return 4294949781;
      }
      uint64_t v11 = *a3;
      *a3 = (uint64_t)cf;
      CFRetain(v10);
      if (v11)
      {
        CFRelease((CFTypeRef)v11);
        uint64_t v11 = 0;
      }
    }
  }
  else
  {
    uint64_t v11 = 4294954514;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t fsrm_setSessionEndReasonIfFatalError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v59 = 1;
  if (!a3
    || ((uint64_t v12 = *(void *)(a1 + 168), (v13 = *(void *)(CMBaseObjectGetVTable() + 16)) == 0)
      ? (uint64_t v14 = 0)
      : (uint64_t v14 = v13),
        (uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v14 + 144)) == 0
     || (uint64_t result = v15(v12, a2, a3, &v59), v59 == 1)))
  {
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    uint64_t v56 = 0;
    uint64_t v17 = *(void *)(a1 + 168);
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v20 = *(void *)(VTable + 16);
    uint64_t result = VTable + 16;
    uint64_t v19 = v20;
    uint64_t v21 = v20 ? v19 : 0;
    CFNumberRef v22 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v21 + 144);
    if (v22)
    {
      uint64_t result = v22(v17, a2, a4, &v58);
      if (!result)
      {
        uint64_t v23 = *(void *)(a1 + 168);
        uint64_t v24 = *(void *)(a1 + 176);
        uint64_t v25 = v58;
        uint64_t v26 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v26) {
          uint64_t v27 = v26;
        }
        else {
          uint64_t v27 = 0;
        }
        uint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v27 + 88);
        if (v28) {
          v28(v23, v24, 0x1EE5841B8, v25);
        }
        uint64_t v29 = *(void *)(a1 + 168);
        uint64_t v30 = CMBaseObjectGetVTable();
        uint64_t v32 = *(void *)(v30 + 16);
        uint64_t result = v30 + 16;
        uint64_t v31 = v32;
        if (v32) {
          uint64_t v33 = v31;
        }
        else {
          uint64_t v33 = 0;
        }
        uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v33 + 152);
        if (v34)
        {
          uint64_t result = v34(v29, a2, a6, &v57);
          if (!result)
          {
            uint64_t v35 = *(void *)(a1 + 168);
            uint64_t v36 = *(void *)(a1 + 176);
            uint64_t v37 = v57;
            uint64_t v38 = CMBaseObjectGetVTable();
            uint64_t v40 = *(void *)(v38 + 16);
            uint64_t result = v38 + 16;
            uint64_t v39 = v40;
            if (v40) {
              uint64_t v41 = v39;
            }
            else {
              uint64_t v41 = 0;
            }
            long long v42 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v41 + 80);
            if (v42) {
              uint64_t result = v42(v35, v36, 0x1EE5841D8, v37);
            }
            if (a5)
            {
              uint64_t v43 = *(void *)(a1 + 168);
              uint64_t v44 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v44) {
                uint64_t v45 = v44;
              }
              else {
                uint64_t v45 = 0;
              }
              long long v46 = *(void (**)(uint64_t, uint64_t, uint64_t, __CFString **))(v45 + 152);
              if (v46)
              {
                v46(v43, a2, a5, &v56);
                long long v47 = v56;
              }
              else
              {
                long long v47 = 0;
              }
              uint64_t v49 = *(void *)(a1 + 168);
              uint64_t v48 = *(void *)(a1 + 176);
              if (v47) {
                long long v50 = v47;
              }
              else {
                long long v50 = @"CoreMediaErrorDomain";
              }
              uint64_t v51 = CMBaseObjectGetVTable();
              uint64_t v53 = *(void *)(v51 + 16);
              uint64_t result = v51 + 16;
              uint64_t v52 = v53;
              if (v53) {
                uint64_t v54 = v52;
              }
              else {
                uint64_t v54 = 0;
              }
              uint64_t v55 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, __CFString *))(v54 + 80);
              if (v55) {
                return v55(v49, v48, 0x1EE5841F8, v50);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t fsrm_setTimeWeightedValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v24 = 0;
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v15 = *(void *)(VTable + 16);
  uint64_t result = VTable + 16;
  uint64_t v14 = v15;
  if (v15) {
    uint64_t v16 = v14;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v16 + 48);
  if (v17)
  {
    uint64_t result = v17(a1, a3, a4, &v24);
    if (!result)
    {
      if (a6)
      {
        uint64_t v18 = v24;
        if (v24)
        {
          uint64_t v19 = CMBaseObjectGetVTable();
          uint64_t v21 = *(void *)(v19 + 16);
          uint64_t result = v19 + 16;
          uint64_t v20 = v21;
          if (v21) {
            uint64_t v22 = v20;
          }
          else {
            uint64_t v22 = 0;
          }
          uint64_t v23 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v22 + 88);
          if (v23) {
            return v23(a1, a2, a5, v18 / a6);
          }
        }
      }
    }
  }
  return result;
}

void *fsrm_createStaticDataStructuresFromEventKeys()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  memcpy(v2, &off_1E578C798, sizeof(v2));
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)v2, 373, 0);
  kFigReportingEventKeyArray_AggregatedEvent = (uint64_t)result;
  if (result)
  {
    memcpy(v2, off_1E578D340, 0x5C8uLL);
    uint64_t result = CFArrayCreate(v0, (const void **)v2, 185, 0);
    kFigReportingEventKeyArray_PeriodicEvent = (uint64_t)result;
    if (result)
    {
      memcpy(v2, off_1E578D908, 0x2C8uLL);
      uint64_t result = CFArrayCreate(v0, (const void **)v2, 89, 0);
      kFigReportingEventKeyArray_PlayRateChangedEvent = (uint64_t)result;
      if (result)
      {
        memcpy(v2, off_1E578DBD0, 0x3A8uLL);
        uint64_t result = CFArrayCreate(v0, (const void **)v2, 117, 0);
        kFigReportingEventKeyArray_PlayerSwitchCompleteEvent = (uint64_t)result;
        if (result)
        {
          memcpy(v2, off_1E578DF78, 0x190uLL);
          uint64_t result = CFArrayCreate(v0, (const void **)v2, 50, 0);
          kFigReportingEventKeyArray_PumpAlternateSwitchEvent = (uint64_t)result;
          if (result)
          {
            memcpy(v2, &off_1E578E108, 0x5D0uLL);
            uint64_t result = CFArrayCreate(v0, (const void **)v2, 186, 0);
            kFigReportingEventKeyArray_LikelyToKeepUpEvent = (uint64_t)result;
            if (result)
            {
              memcpy(v2, off_1E578E6D8, 0x458uLL);
              uint64_t result = CFArrayCreate(v0, (const void **)v2, 139, 0);
              kFigReportingEventKeyArray_StallEvent = (uint64_t)result;
              if (result)
              {
                memcpy(v2, off_1E578EB30, 0x330uLL);
                uint64_t result = CFArrayCreate(v0, (const void **)v2, 102, 0);
                kFigReportingEventKeyArray_PumpErrorEvent = (uint64_t)result;
                if (result)
                {
                  memcpy(v2, off_1E578EE60, 0x3F0uLL);
                  uint64_t result = CFArrayCreate(v0, (const void **)v2, 126, 0);
                  kFigReportingEventKeyArray_PlayerErrorEvent = (uint64_t)result;
                  if (result)
                  {
                    *(_OWORD *)&v2[32] = xmmword_1E578F270;
                    *(_OWORD *)&v2[48] = *(_OWORD *)&off_1E578F280;
                    *(void *)&v2[64] = &kFigReportingEventKey_InterfaceType;
                    *(_OWORD *)pid_t v2 = xmmword_1E578F250;
                    *(_OWORD *)&v2[16] = *(_OWORD *)&off_1E578F260;
                    uint64_t result = CFArrayCreate(v0, (const void **)v2, 9, 0);
                    kFigReportingEventKeyArray_PowerLogEvent = (uint64_t)result;
                    if (result)
                    {
                      *(_OWORD *)pid_t v2 = xmmword_1E578F298;
                      *(void *)&v2[16] = 0;
                      uint64_t result = CFArrayCreate(v0, (const void **)v2, 3, 0);
                      kFigReportingEventKeyArray_IRATStreamingActivityStartEvent = (uint64_t)result;
                      if (result)
                      {
                        *(_OWORD *)pid_t v2 = xmmword_1E578F2B0;
                        *(_OWORD *)&v2[16] = *(_OWORD *)&off_1E578F2C0;
                        *(_OWORD *)&v2[32] = xmmword_1E578F2D0;
                        uint64_t result = CFArrayCreate(v0, (const void **)v2, 6, 0);
                        kFigReportingEventKeyArray_IRATStreamingActivityEndEvent = (uint64_t)result;
                        if (result)
                        {
                          *(_OWORD *)pid_t v2 = xmmword_1E578F2E0;
                          uint64_t result = CFArrayCreate(v0, (const void **)v2, 2, 0);
                          kFigReportingEventKeyArray_IRATStallEvent = (uint64_t)result;
                          if (result)
                          {
                            memcpy(v2, off_1E578F2F0, 0x370uLL);
                            uint64_t result = CFArrayCreate(v0, (const void **)v2, 110, 0);
                            kFigReportingEventKeyArray_VerboseLoggingPerMainSubstreamSegment = (uint64_t)result;
                            if (result)
                            {
                              memcpy(v2, off_1E578F660, 0x268uLL);
                              uint64_t result = CFArrayCreate(v0, (const void **)v2, 77, 0);
                              kFigReportingEventKeyArray_VerboseLoggingPerAudioSubstreamSegment = (uint64_t)result;
                              if (result)
                              {
                                *(_OWORD *)&v2[160] = xmmword_1E578F968;
                                *(_OWORD *)&v2[176] = *(_OWORD *)off_1E578F978;
                                *(void *)&v2[192] = &kFigReportingEventKey_HasSufficientBandwidthHistory;
                                *(_OWORD *)&v2[96] = xmmword_1E578F928;
                                *(_OWORD *)&v2[112] = *(_OWORD *)&off_1E578F938;
                                *(_OWORD *)&v2[128] = xmmword_1E578F948;
                                *(_OWORD *)&v2[144] = *(_OWORD *)&off_1E578F958;
                                *(_OWORD *)&v2[32] = xmmword_1E578F8E8;
                                *(_OWORD *)&v2[48] = *(_OWORD *)&off_1E578F8F8;
                                *(_OWORD *)&v2[64] = xmmword_1E578F908;
                                *(_OWORD *)&v2[80] = *(_OWORD *)&off_1E578F918;
                                *(_OWORD *)pid_t v2 = xmmword_1E578F8C8;
                                *(_OWORD *)&v2[16] = *(_OWORD *)&off_1E578F8D8;
                                uint64_t result = CFArrayCreate(v0, (const void **)v2, 25, 0);
                                kFigReportingEventKeyArray_FetchKeysFromAggregatedSessionStats = (uint64_t)result;
                                if (result)
                                {
                                  memcpy(v2, off_1E578F990, 0x358uLL);
                                  uint64_t result = CFArrayCreate(v0, (const void **)v2, 107, 0);
                                  kFigReportingEventKeyArray_PeriodicEventKeysToReset = (uint64_t)result;
                                  if (result)
                                  {
                                    *(_OWORD *)pid_t v2 = xmmword_1E578FCE8;
                                    uint64_t result = CFArrayCreate(v0, (const void **)v2, 2, 0);
                                    kFigReportingEventKeyArray_PeriodicStatsActivityMonitor = (uint64_t)result;
                                    if (result)
                                    {
                                      memcpy(v2, off_1E578FCF8, 0x2D0uLL);
                                      uint64_t result = CFArrayCreate(v0, (const void **)v2, 90, 0);
                                      kFigReportingEventKeyArray_PlayerVideoVariantEndedEvent = (uint64_t)result;
                                      if (result)
                                      {
                                        memcpy(v2, off_1E578FFC8, 0x230uLL);
                                        uint64_t result = CFArrayCreate(v0, (const void **)v2, 70, 0);
                                        kFigReportingEventKeyArray_DownloadPerformanceEvent = (uint64_t)result;
                                        if (result)
                                        {
                                          memcpy(v2, off_1E57901F8, 0x358uLL);
                                          uint64_t result = CFArrayCreate(v0, (const void **)v2, 107, 0);
                                          kFigReportingEventKeyArray_PlayerFormatTransition = (uint64_t)result;
                                          if (result)
                                          {
                                            memcpy(v2, &off_1E5790550, 0x280uLL);
                                            uint64_t result = CFArrayCreate(v0, (const void **)v2, 80, 0);
                                            kFigReportingEventKeyArray_StartupPerformanceMetrics = (uint64_t)result;
                                            if (result)
                                            {
                                              memcpy(v2, off_1E57907D0, 0x218uLL);
                                              uint64_t result = CFArrayCreate(v0, (const void **)v2, 67, 0);
                                              kFigReportingEventKeyArray_DownloadPerfValuesPerMainSubstreamSegment = (uint64_t)result;
                                              if (result)
                                              {
                                                memcpy(v2, off_1E57909E8, 0x168uLL);
                                                uint64_t result = CFArrayCreate(v0, (const void **)v2, 45, 0);
                                                kFigReportingEventKeyArray_DownloadPerfValuesPerAudioSubstreamSegment = (uint64_t)result;
                                                if (result)
                                                {
                                                  memcpy(v2, off_1E5790B50, 0x1F0uLL);
                                                  uint64_t result = CFArrayCreate(v0, (const void **)v2, 62, 0);
                                                  kFigReportingEventKeyArray_BandwidthPredictionsPeriodic = (uint64_t)result;
                                                  if (result)
                                                  {
                                                    uint64_t result = fsrm_createStaticKeySetFromEventKeys((const void ***)off_1E5790D40, 0x25uLL);
                                                    kFigReportingFrozenKeySetForEvent_LikelyToKeepUp = (uint64_t)result;
                                                    if (result)
                                                    {
                                                      uint64_t result = fsrm_createStaticKeySetFromEventKeys((const void ***)off_1E5790E68, 0xAuLL);
                                                      kFigReportingFrozenKeySetForEvent_StartupPerformanceMetrics = (uint64_t)result;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

const void **fsrm_createStaticKeySetFromEventKeys(const void ***a1, size_t count)
{
  int v2 = count;
  CFIndex v4 = count;
  uint64_t result = (const void **)malloc_type_calloc(count, 8uLL, 0x80040B8603338uLL);
  if (result)
  {
    uint64_t v6 = result;
    if (v2 >= 1)
    {
      CFIndex v7 = v4;
      uint64_t v8 = result;
      do
      {
        uint64_t v9 = *a1++;
        *v8++ = *v9;
        --v7;
      }
      while (v7);
    }
    CFSetRef v10 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], result, v4, MEMORY[0x1E4F1D548]);
    free(v6);
    return (const void **)v10;
  }
  return result;
}

__CFString *fsrm_createArrayNameFromKey(CFStringRef theString)
{
  MutableCFDictionaryRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theString);
  int v2 = MutableCopy;
  if (MutableCopy) {
    CFStringAppend(MutableCopy, @"_Array");
  }
  return v2;
}

void fsrm_replaceTimestampWithDelta(const __CFDictionary *a1, const void *a2)
{
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFArrayRef v5 = Value;
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFIndex v7 = Mutable;
      if (CFArrayGetCount(v5) >= 1)
      {
        CFIndex v8 = 0;
        do
        {
          if (FigCFArrayGetInt64AtIndex()) {
            FigCFArrayAppendInt64();
          }
          else {
            CFArrayAppendValue(v7, @"-");
          }
          ++v8;
        }
        while (v8 < CFArrayGetCount(v5));
      }
      FigCFDictionarySetValue();
      CFRelease(v7);
    }
  }
  CFDictionaryRemoveValue(a1, a2);
}

void fsrm_stringifyArrayFunc(const void *a1, const __CFArray *a2, __CFDictionary *a3)
{
  if (a3)
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(a2))
    {
      CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      if (Mutable)
      {
        CFIndex v8 = Mutable;
        if (CFArrayGetCount(a2) >= 1)
        {
          CFIndex v9 = 0;
          do
          {
            CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a2, v9);
            if (ValueAtIndex && (CFNumberRef v11 = ValueAtIndex, v12 = CFNumberGetTypeID(), v12 == CFGetTypeID(v11)))
            {
              uint64_t valuePtr = 0;
              CFNumberGetValue(v11, kCFNumberSInt64Type, &valuePtr);
              CFStringAppendFormat(v8, 0, @"%lld", valuePtr);
            }
            else
            {
              CFStringAppend(v8, @"-");
            }
            if (++v9 < CFArrayGetCount(a2)) {
              CFStringAppend(v8, @",");
            }
          }
          while (v9 < CFArrayGetCount(a2));
        }
        CFDictionarySetValue(a3, a1, v8);
        CFRelease(v8);
      }
    }
  }
}

uint64_t fsrm_getMaxArrayCount(uint64_t a1, CFArrayRef theArray)
{
  if (CFArrayGetCount(theArray) < 1) {
    return 0;
  }
  uint64_t v4 = 0;
  CFIndex v5 = 0;
  do
  {
    uint64_t v11 = 0;
    uint64_t v6 = *(void *)CFArrayGetValueAtIndex(theArray, v5);
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    CFIndex v9 = *(void (**)(uint64_t, uint64_t, uint64_t *))(v8 + 120);
    if (v9) {
      v9(a1, v6, &v11);
    }
    if (v4 <= v11) {
      uint64_t v4 = v11;
    }
    ++v5;
  }
  while (v5 < CFArrayGetCount(theArray));
  return v4;
}

uint64_t PIQCopyPerformanceDictionaryForInstanceStatistics(const __CFAllocator *a1, int *a2, __CFDictionary **a3)
{
  CFTypeRef cf = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  if (*a2)
  {
    if (*a2 >= 100) {
      int v8 = 100;
    }
    else {
      int v8 = *a2;
    }
    int v9 = piqCopyArrayOfMilliseconds(a1, v8, a2 + 6, (CFArrayRef *)&cf);
    CFTypeRef v10 = cf;
    if (v9)
    {
      if (!cf) {
        goto LABEL_8;
      }
      goto LABEL_7;
    }
    CFDictionarySetValue(Mutable, @"DisplayTimesOfFramesDroppedFromImageQueue", cf);
    if (v10)
    {
LABEL_7:
      CFRelease(v10);
      CFTypeRef cf = 0;
    }
  }
LABEL_8:
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  if (a2[5]) {
    FigCFDictionarySetDouble();
  }
  if (a2[4]) {
    FigCFDictionarySetInt32();
  }
  if (a2[224]) {
    FigCFDictionarySetInt32();
  }
  int v11 = a2[4];
  if (v11)
  {
    if (v11 >= 100) {
      int v12 = 100;
    }
    else {
      int v12 = a2[4];
    }
    int v13 = piqCopyArrayOfMilliseconds(a1, v12, a2 + 106, (CFArrayRef *)&cf);
    CFTypeRef v14 = cf;
    if (!v13)
    {
      CFDictionarySetValue(Mutable, @"DisplayTimesOfFramesConsumedAtLeast16msLate", cf);
      if (!v14) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
    if (cf) {
LABEL_20:
    }
      CFRelease(v14);
  }
LABEL_21:
  uint64_t v15 = 0;
  LODWORD(v16) = 0;
  do
  {
    if (a2[v15 + 215]) {
      uint64_t v16 = (v15 + 2);
    }
    else {
      uint64_t v16 = v16;
    }
    ++v15;
  }
  while (v15 != 9);
  if ((int)v16 >= 2)
  {
    CFMutableArrayRef v17 = CFArrayCreateMutable(v6, (v16 - 1), MEMORY[0x1E4F1D510]);
    uint64_t v18 = a2 + 215;
    uint64_t v19 = v16 - 1;
    do
    {
      ++v18;
      FigCFArrayAppendInt32();
      --v19;
    }
    while (v19);
    CFDictionarySetValue(Mutable, @"DisplayCountHistogram", v17);
    if (v17) {
      CFRelease(v17);
    }
  }
  *a3 = Mutable;
  return 0;
}

uint64_t piqCopyArrayOfMilliseconds(const __CFAllocator *a1, int a2, int *a3, CFArrayRef *a4)
{
  CFIndex v8 = a2;
  int v9 = (const void **)malloc_type_calloc(8uLL, a2, 0x900D8D76uLL);
  if (v9)
  {
    CFTypeRef v10 = v9;
    if (a2 < 1)
    {
LABEL_6:
      CFArrayRef v16 = CFArrayCreate(a1, v10, v8, MEMORY[0x1E4F1D510]);
      *a4 = v16;
      if (v16)
      {
        uint64_t v17 = 0;
LABEL_12:
        if (a2 >= 1)
        {
          uint64_t v19 = v10;
          do
          {
            if (*v19) {
              CFRelease(*v19);
            }
            ++v19;
            --v8;
          }
          while (v8);
        }
        free(v10);
        return v17;
      }
    }
    else
    {
      CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      int v12 = (CFNumberRef *)v9;
      CFIndex v13 = v8;
      while (1)
      {
        int v14 = *a3++;
        double valuePtr = (double)v14 * 0.001;
        CFNumberRef v15 = CFNumberCreate(v11, kCFNumberDoubleType, &valuePtr);
        *int v12 = v15;
        if (!v15) {
          break;
        }
        ++v12;
        if (!--v13) {
          goto LABEL_6;
        }
      }
    }
    uint64_t v17 = FigSignalErrorAt();
    goto LABEL_12;
  }

  return FigSignalErrorAt();
}

uint64_t FigMutableCompositionServerStart()
{
  if (FigServer_IsMediaparserd()) {
    return FigSignalErrorAt();
  }
  FigServer_IsMediaplaybackd();
  return FigXPCServerStart();
}

uint64_t HandleMutableCompositionMessage(uint64_t a1, void *a2)
{
  Opint Code = FigXPCMessageGetOpCode();
  if (OpCode) {
    return OpCode;
  }
  uint64_t v7 = 0;
  xpc_dictionary_get_uint64(a2, (const char *)*MEMORY[0x1E4F20280]);
  uint64_t v4 = LookupMutableCompositionByObjectIDForConnection();
  if (v4) {
    return v4;
  }
  else {
    return 4294951138;
  }
}

uint64_t LookupMutableCompositionByObjectIDForConnection()
{
  uint64_t result = FigXPCServerLookupAndRetainAssociatedObject();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleMutableCompositionCreateMutableCopyMessage(uint64_t a1, uint64_t a2, void *a3)
{
  CFTypeRef cf = 0;
  uint64_t value = 0;
  int v14 = 0;
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  CFIndex v8 = *(uint64_t (**)(void, uint64_t, CFTypeRef *))(v7 + 8);
  if (v8)
  {
    uint64_t v9 = v8(*MEMORY[0x1E4F1CF80], a2, &cf);
    if (v9)
    {
      uint64_t v12 = v9;
LABEL_9:
      CFAllocatorRef v11 = 0;
      goto LABEL_11;
    }
    uint64_t v10 = CreateServedMutableCompositionState(a1, &v14);
    CFAllocatorRef v11 = v14;
    if (!v10)
    {
      uint64_t v12 = FigXPCServerAssociateObjectWithConnection();
      if (v12) {
        goto LABEL_11;
      }
      xpc_dictionary_set_uint64(a3, (const char *)*MEMORY[0x1E4F20280], value);
      goto LABEL_9;
    }
    uint64_t v12 = v10;
  }
  else
  {
    CFAllocatorRef v11 = 0;
    uint64_t v12 = 4294954514;
  }
LABEL_11:
  DisposeServedMutableCompositionState(v11);
  if (cf) {
    CFRelease(cf);
  }
  return v12;
}

uint64_t HandleMutableCompositionCopyFormatReaderMessage(_xpc_connection_s *a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  CFTypeRef v14 = 0;
  CFTypeRef cf = 0;
  BOOL v7 = xpc_dictionary_get_BOOL(xdict, "MakeImmutableSnapshot");
  uint64_t v8 = FigXPCMessageCopyCFDictionary();
  if (v8) {
    goto LABEL_15;
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  CFAllocatorRef v11 = *(uint64_t (**)(uint64_t, BOOL, CFTypeRef, CFTypeRef *))(v10 + 16);
  if (!v11)
  {
    uint64_t v12 = 4294954514;
    goto LABEL_10;
  }
  uint64_t v8 = v11(a2, v7, cf, &v14);
  if (v8)
  {
LABEL_15:
    uint64_t v12 = v8;
  }
  else
  {
    uint64_t v12 = FigXPCFormatReaderServerAssociateCopiedNeighborFormatReader(a1, (uint64_t)v14);
    if (!v12) {
      xpc_dictionary_set_uint64(a4, "FormatReader", 0);
    }
  }
LABEL_10:
  if (cf) {
    CFRelease(cf);
  }
  if (v14) {
    CFRelease(v14);
  }
  return v12;
}

uint64_t HandleMutableCompositionCopyAssetMessage(_xpc_connection_s *a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  CFTypeRef cf = 0;
  CFTypeRef v15 = 0;
  BOOL v7 = xpc_dictionary_get_BOOL(xdict, "MakeImmutableSnapshot");
  uint64_t v8 = FigXPCMessageCopyCFDictionary();
  if (v8) {
    goto LABEL_15;
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  CFAllocatorRef v11 = *(uint64_t (**)(uint64_t, BOOL, CFTypeRef, CFTypeRef *))(v10 + 208);
  if (!v11)
  {
    uint64_t v12 = 4294954514;
    goto LABEL_10;
  }
  uint64_t v8 = v11(a2, v7, v15, &cf);
  if (v8)
  {
LABEL_15:
    uint64_t v12 = v8;
  }
  else
  {
    uint64_t v12 = FigXPCAssetServerAssociateCopiedNeighborAsset(a1);
    if (!v12) {
      xpc_dictionary_set_uint64(a4, "Asset", 0);
    }
  }
LABEL_10:
  if (cf) {
    CFRelease(cf);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v12;
}

uint64_t HandleMutableCompositionGetTrackCompatibleWithAssetTrackMessage(uint64_t a1, xpc_object_t xdict, void *a3)
{
  LODWORD(CFDictionarySetValue(theDict, key, value) = 0;
  int64_t int64 = xpc_dictionary_get_int64(xdict, "AssetTrackID");
  uint64_t v6 = FigXPCMessageCopyCFURL();
  if (v6) {
    return v6;
  }
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, void, int64_t, int64_t *))(v8 + 24);
  if (!v9) {
    return 4294954514;
  }
  uint64_t v10 = v9(a1, 0, int64, &value);
  if (!v10) {
    xpc_dictionary_set_int64(a3, "TrackID", (int)value);
  }
  return v10;
}

uint64_t HandleMutableCompositionAddTrackMessage(uint64_t a1, xpc_object_t xdict, void *a3)
{
  LODWORD(CFDictionarySetValue(theDict, key, value) = 0;
  int64_t int64 = xpc_dictionary_get_int64(xdict, "TrackID");
  uint64_t uint64 = xpc_dictionary_get_uint64(xdict, "MediaType");
  uint64_t v8 = FigXPCMessageCopyCFDictionary();
  if (v8) {
    return v8;
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  CFAllocatorRef v11 = *(uint64_t (**)(uint64_t, uint64_t, void, int64_t, int64_t *))(v10 + 32);
  if (!v11) {
    return 4294954514;
  }
  uint64_t v12 = v11(a1, uint64, 0, int64, &value);
  if (!v12) {
    xpc_dictionary_set_int64(a3, "TrackID", (int)value);
  }
  return v12;
}

uint64_t HandleMutableCompositionDeleteTrackMessage(uint64_t a1, xpc_object_t xdict)
{
  int64_t int64 = xpc_dictionary_get_int64(xdict, "TrackID");
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, int64_t))(v5 + 40);
  if (!v6) {
    return 4294954514;
  }

  return v6(a1, int64);
}

uint64_t HandleMutableCompositionSetTrackEditListMessage(uint64_t a1, xpc_object_t xdict)
{
  size_t length = 0;
  int64_t int64 = xpc_dictionary_get_int64(xdict, "TrackID");
  int64_t v5 = xpc_dictionary_get_int64(xdict, "EditCount");
  if (v5 < 1)
  {
    uint64_t v9 = 0;
  }
  else
  {
    data = (const UInt8 *)xpc_dictionary_get_data(xdict, "EditListData", &length);
    if (!data) {
      return FigSignalErrorAt();
    }
    if (!length) {
      return FigSignalErrorAt();
    }
    uint64_t v7 = data;
    uint64_t v8 = (char *)malloc_type_calloc(v5, 0x6CuLL, 0x1060040CB727B4DuLL);
    if (!v8) {
      return FigSignalErrorAt();
    }
    uint64_t v9 = v8;
    EditArrayFromCFDataRef Data = FigRemote_CreateEditArrayFromData(v7, length, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, (uint64_t)v8);
    if (EditArrayFromData)
    {
      uint64_t v11 = EditArrayFromData;
      goto LABEL_16;
    }
  }
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  CFTypeRef v14 = *(uint64_t (**)(uint64_t, int64_t, int64_t, char *))(v13 + 48);
  if (v14)
  {
    uint64_t v11 = v14(a1, int64, v5, v9);
    if (!v9) {
      return v11;
    }
LABEL_15:
    if (v5 < 1)
    {
LABEL_20:
      free(v9);
      return v11;
    }
LABEL_16:
    uint64_t v15 = 96;
    do
    {
      CFArrayRef v16 = *(const void **)&v9[v15];
      if (v16) {
        CFRelease(v16);
      }
      v15 += 108;
      --v5;
    }
    while (v5);
    goto LABEL_20;
  }
  uint64_t v11 = 4294954514;
  if (v9) {
    goto LABEL_15;
  }
  return v11;
}

uint64_t HandleMutableCompositionCopyTrackEditListMessage(uint64_t a1, xpc_object_t xdict, void *a3)
{
  CFDataRef theData = 0;
  size_t count = 0;
  int64_t int64 = xpc_dictionary_get_int64(xdict, "TrackID");
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, int64_t, size_t *, void, void))(v7 + 56);
  if (!v8) {
    return 4294954514;
  }
  uint64_t v9 = v8(a1, int64, &count, 0, 0);
  if (v9) {
    return v9;
  }
  uint64_t v10 = (CFTypeRef *)malloc_type_calloc(count, 0x6CuLL, 0x1060040CB727B4DuLL);
  if (!v10) {
    return FigSignalErrorAt();
  }
  uint64_t v11 = v10;
  size_t v12 = count;
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  CFArrayRef v16 = *(uint64_t (**)(uint64_t, int64_t, void, size_t, CFTypeRef *))(v14 + 56);
  if (v16)
  {
    uint64_t v17 = v16(a1, int64, 0, v12, v11);
    if (v17
      || (uint64_t v17 = FigRemote_CreateEditArrayData(count, (uint64_t)v11, (const __CFAllocator *)*MEMORY[0x1E4F1CF80], &theData), v17))
    {
      uint64_t v15 = v17;
    }
    else
    {
      if (theData)
      {
        BytePtr = CFDataGetBytePtr(theData);
        size_t Length = CFDataGetLength(theData);
        xpc_dictionary_set_data(a3, "EditListData", BytePtr, Length);
      }
      xpc_dictionary_set_int64(a3, "EditCount", count);
      uint64_t v15 = 0;
    }
  }
  else
  {
    uint64_t v15 = 4294954514;
  }
  int64_t v20 = count;
  if ((uint64_t)count >= 1)
  {
    int64_t v21 = 0;
    uint64_t v22 = v11 + 12;
    do
    {
      if (*v22)
      {
        CFRelease(*v22);
        int64_t v20 = count;
      }
      ++v21;
      uint64_t v22 = (CFTypeRef *)((char *)v22 + 108);
    }
    while (v20 > v21);
  }
  free(v11);
  if (theData) {
    CFRelease(theData);
  }
  return v15;
}

uint64_t HandleMutableCompositionAddFormatReaderForURLMessage(uint64_t a1, xpc_object_t xdict)
{
  xpc_dictionary_get_uint64(xdict, "FormatReader");
  uint64_t v3 = FigXPCFormatReaderServerCopyFormatReaderForID();
  if (!v3)
  {
    uint64_t v3 = FigXPCMessageCopyCFURL();
    if (!v3)
    {
      uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v4) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(uint64_t (**)(uint64_t, void, void))(v5 + 64);
      if (!v6) {
        return 4294954514;
      }
      return v6(a1, 0, 0);
    }
  }
  return v3;
}

uint64_t HandleMutableCompositionCopyTrackPropertyMessage(int a1, xpc_object_t xdict)
{
  xpc_dictionary_get_int64(xdict, "TrackID");
  uint64_t result = FigXPCMessageCopyCFString();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleMutableCompositionSetTrackPropertyMessage(int a1, xpc_object_t xdict)
{
  xpc_dictionary_get_int64(xdict, "TrackID");
  uint64_t result = FigXPCMessageCopyCFString();
  if (!result) {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t HandleMutableCompositionInsertAssetSegmentIntoTrackMessage(uint64_t a1, xpc_object_t xdict)
{
  long long v14 = *MEMORY[0x1E4F1FA48];
  uint64_t v15 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  long long v13 = *MEMORY[0x1E4F1FA48];
  long long v12 = *MEMORY[0x1E4F1FA48];
  int64_t int64 = xpc_dictionary_get_int64(xdict, "DestTrackID");
  int64_t v5 = xpc_dictionary_get_int64(xdict, "AssetTrackID");
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  uint64_t v6 = FigXPCMessageCopyCFURL();
  if (!v6)
  {
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(uint64_t (**)(uint64_t, int64_t, void, int64_t, long long *, long long *, long long *))(v8 + 88);
    if (!v9) {
      return 4294954514;
    }
    long long v20 = v14;
    uint64_t v21 = v15;
    long long v18 = v13;
    uint64_t v19 = v15;
    long long v16 = v12;
    uint64_t v17 = v15;
    return v9(a1, int64, 0, v5, &v20, &v18, &v16);
  }
  return v6;
}

uint64_t HandleMutableCompositionInsertAssetSegmentMessage(uint64_t a1)
{
  long long v10 = *MEMORY[0x1E4F1FA48];
  uint64_t v11 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  long long v9 = *MEMORY[0x1E4F1FA48];
  long long v8 = *MEMORY[0x1E4F1FA48];
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  uint64_t v2 = FigXPCMessageCopyCFURL();
  if (!v2)
  {
    uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v3) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = 0;
    }
    int64_t v5 = *(uint64_t (**)(uint64_t, void, long long *, long long *, long long *))(v4 + 96);
    if (!v5) {
      return 4294954514;
    }
    long long v16 = v10;
    uint64_t v17 = v11;
    long long v14 = v9;
    uint64_t v15 = v11;
    long long v12 = v8;
    uint64_t v13 = v11;
    return v5(a1, 0, &v16, &v14, &v12);
  }
  return v2;
}

uint64_t HandleMutableCompositionInsertEmptyTrackSegmentMessage(uint64_t a1, xpc_object_t xdict)
{
  long long v9 = *MEMORY[0x1E4F1FA48];
  uint64_t v10 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  long long v8 = *MEMORY[0x1E4F1FA48];
  int64_t int64 = xpc_dictionary_get_int64(xdict, "TrackID");
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, int64_t, long long *, long long *))(v5 + 104);
  if (!v6) {
    return 4294954514;
  }
  long long v13 = v9;
  uint64_t v14 = v10;
  long long v11 = v8;
  uint64_t v12 = v10;
  return v6(a1, int64, &v13, &v11);
}

uint64_t HandleMutableCompositionInsertEmptySegmentMessage(uint64_t a1)
{
  long long v7 = *MEMORY[0x1E4F1FA48];
  uint64_t v8 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  long long v6 = *MEMORY[0x1E4F1FA48];
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, long long *, long long *))(v3 + 112);
  if (!v4) {
    return 4294954514;
  }
  long long v11 = v7;
  uint64_t v12 = v8;
  long long v9 = v6;
  uint64_t v10 = v8;
  return v4(a1, &v11, &v9);
}

uint64_t HandleMutableCompositionDeleteTrackSegmentMessage(uint64_t a1, xpc_object_t xdict)
{
  long long v9 = *MEMORY[0x1E4F1FA48];
  uint64_t v10 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  long long v8 = *MEMORY[0x1E4F1FA48];
  int64_t int64 = xpc_dictionary_get_int64(xdict, "TrackID");
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  long long v6 = *(uint64_t (**)(uint64_t, int64_t, long long *, long long *))(v5 + 120);
  if (!v6) {
    return 4294954514;
  }
  long long v13 = v9;
  uint64_t v14 = v10;
  long long v11 = v8;
  uint64_t v12 = v10;
  return v6(a1, int64, &v13, &v11);
}

uint64_t HandleMutableCompositionDeleteSegmentMessage(uint64_t a1)
{
  long long v7 = *MEMORY[0x1E4F1FA48];
  uint64_t v8 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  long long v6 = *MEMORY[0x1E4F1FA48];
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, long long *, long long *))(v3 + 128);
  if (!v4) {
    return 4294954514;
  }
  long long v11 = v7;
  uint64_t v12 = v8;
  long long v9 = v6;
  uint64_t v10 = v8;
  return v4(a1, &v11, &v9);
}

uint64_t HandleMutableCompositionScaleTrackSegmentMessage(uint64_t a1, xpc_object_t xdict)
{
  long long v10 = *MEMORY[0x1E4F1FA48];
  uint64_t v11 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  long long v9 = *MEMORY[0x1E4F1FA48];
  long long v8 = *MEMORY[0x1E4F1FA48];
  int64_t int64 = xpc_dictionary_get_int64(xdict, "TrackID");
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  long long v6 = *(uint64_t (**)(uint64_t, int64_t, long long *, long long *, long long *))(v5 + 136);
  if (!v6) {
    return 4294954514;
  }
  long long v16 = v10;
  uint64_t v17 = v11;
  long long v14 = v9;
  uint64_t v15 = v11;
  long long v12 = v8;
  uint64_t v13 = v11;
  return v6(a1, int64, &v16, &v14, &v12);
}

uint64_t HandleMutableCompositionScaleSegmentMessage(uint64_t a1)
{
  long long v8 = *MEMORY[0x1E4F1FA48];
  uint64_t v9 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  long long v7 = *MEMORY[0x1E4F1FA48];
  long long v6 = *MEMORY[0x1E4F1FA48];
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, long long *, long long *, long long *))(v3 + 144);
  if (!v4) {
    return 4294954514;
  }
  long long v14 = v8;
  uint64_t v15 = v9;
  long long v12 = v7;
  uint64_t v13 = v9;
  long long v10 = v6;
  uint64_t v11 = v9;
  return v4(a1, &v14, &v12, &v10);
}

uint64_t HandleMutableCompositionDeferTracksChangedNotificationsMessage(uint64_t a1)
{
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(v3 + 152);
  if (!v4) {
    return 4294954514;
  }

  return v4(a1);
}

uint64_t HandleMutableCompositionPostDeferredTracksChangedNotificationMessage(uint64_t a1)
{
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(v3 + 160);
  if (!v4) {
    return 4294954514;
  }

  return v4(a1);
}

uint64_t HandleMutableCompositionInsertSegmentArrayIntoTrackMessage()
{
  return 4294954516;
}

uint64_t HandleMutableCompositionAddAssetForURLMessage(uint64_t a1, void *a2)
{
  FigXPCMessageCopyCFURL();
  xpc_dictionary_get_uint64(a2, "Asset");
  uint64_t v4 = FigXPCAssetServerCopyAssetForID();
  if (!v4)
  {
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    long long v7 = *(uint64_t (**)(uint64_t, void, void))(v6 + 176);
    if (!v7) {
      return 4294954514;
    }
    return v7(a1, 0, 0);
  }
  return v4;
}

uint64_t HandleMutableCompositionGetTrackCompatibleWithMutableCompositionTrackMessage(int a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  memset(value, 0, sizeof(value));
  int64_t int64 = xpc_dictionary_get_int64(xdict, "AssetTrackID");
  xpc_dictionary_get_uint64(xdict, "SourceCompositionID");
  uint64_t v8 = LookupMutableCompositionByObjectIDForConnection();
  if (v8) {
    return v8;
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, void, int64_t, _DWORD *))(v10 + 200);
  if (!v11) {
    return 4294954514;
  }
  uint64_t v12 = v11(a2, 0, int64, value);
  if (!v12) {
    xpc_dictionary_set_int64(a4, "TrackID", value[0]);
  }
  return v12;
}

uint64_t HandleMutableCompositionInsertMutableCompositionSegmentIntoTrackMessage(int a1, uint64_t a2, xpc_object_t xdict)
{
  long long v15 = *MEMORY[0x1E4F1FA48];
  uint64_t v16 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  long long v14 = *MEMORY[0x1E4F1FA48];
  long long v13 = *MEMORY[0x1E4F1FA48];
  int64_t int64 = xpc_dictionary_get_int64(xdict, "AssetTrackID");
  int64_t v6 = xpc_dictionary_get_int64(xdict, "DestTrackID");
  xpc_dictionary_get_uint64(xdict, "SourceCompositionID");
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  uint64_t v7 = LookupMutableCompositionByObjectIDForConnection();
  if (!v7)
  {
    uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v8) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v10 = *(uint64_t (**)(uint64_t, int64_t, void, int64_t, long long *, long long *, long long *))(v9 + 184);
    if (!v10) {
      return 4294954514;
    }
    long long v21 = v15;
    uint64_t v22 = v16;
    long long v19 = v14;
    uint64_t v20 = v16;
    long long v17 = v13;
    uint64_t v18 = v16;
    return v10(a2, v6, 0, int64, &v21, &v19, &v17);
  }
  return v7;
}

uint64_t HandleMutableCompositionInsertMutableCompositionSegmentMessage(int a1, uint64_t a2, xpc_object_t xdict)
{
  long long v12 = *MEMORY[0x1E4F1FA48];
  uint64_t v13 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  long long v11 = *MEMORY[0x1E4F1FA48];
  long long v10 = *MEMORY[0x1E4F1FA48];
  xpc_dictionary_get_uint64(xdict, "SourceCompositionID");
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  FigXPCMessageGetCMTime();
  uint64_t v4 = LookupMutableCompositionByObjectIDForConnection();
  if (!v4)
  {
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(uint64_t (**)(uint64_t, void, long long *, long long *, long long *))(v6 + 192);
    if (!v7) {
      return 4294954514;
    }
    long long v18 = v12;
    uint64_t v19 = v13;
    long long v16 = v11;
    uint64_t v17 = v13;
    long long v14 = v10;
    uint64_t v15 = v13;
    return v7(a2, 0, &v18, &v16, &v14);
  }
  return v4;
}

uint64_t CreateServedMutableCompositionState(uint64_t a1, const void ***a2)
{
  memset(&v9[1], 0, sizeof(audit_token_t));
  uint64_t v3 = (const void **)malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
  if (!v3) {
    goto LABEL_6;
  }
  xpc_connection_get_audit_token();
  v9[0] = v9[1];
  FigServer_GetClientPIDFromAuditToken();
  uint64_t v4 = FigSandboxAssertionCreateForPID();
  if (v4)
  {
LABEL_7:
    uint64_t v7 = v4;
    goto LABEL_5;
  }
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  v9[0] = v9[1];
  v3[1] = SecTaskCreateWithAuditToken(v5, v9);
  uint64_t v6 = FigOSTransactionCreate();
  void v3[2] = (const void *)v6;
  if (!v6)
  {
LABEL_6:
    uint64_t v4 = FigSignalErrorAt();
    goto LABEL_7;
  }
  uint64_t v7 = 0;
  *a2 = v3;
  uint64_t v3 = 0;
LABEL_5:
  DisposeServedMutableCompositionState(v3);
  return v7;
}

void DisposeServedMutableCompositionState(const void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2)
    {
      CFRelease(v2);
      *a1 = 0;
    }
    uint64_t v3 = a1[1];
    if (v3)
    {
      CFRelease(v3);
      a1[1] = 0;
    }
    uint64_t v4 = (void *)a1[2];
    if (v4) {
      os_release(v4);
    }
    free(a1);
  }
}

uint64_t FigPhotoJPEGEncodeSessionGetTypeID()
{
  return MEMORY[0x1F410DB00]();
}

uint64_t FigPhotoJPEGEncodeSessionCreate()
{
  return MEMORY[0x1F410DAF0]();
}

uint64_t FigPhotoJPEGEncodeSessionCreateJPEGSbufFromBuffer()
{
  return MEMORY[0x1F410DAF8]();
}

uint64_t FigPlayerStreamCreateWithOptions()
{
  return FigSignalErrorAt();
}

uint64_t fig_player_stream_init_once()
{
  return MEMORY[0x1F40DDD78]();
}

void fpfs_autoSelectionCriteriaChanged(uint64_t a1, const void *a2)
{
}

void fpfs_ValeriaEnabled(uint64_t a1, const void *a2)
{
  if (RaEiDSv6c())
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    fpfs_LockMutexWithCaller((uint64_t)a2);
    if (!*(unsigned char *)(DerivedStorage + 51))
    {
      *(unsigned char *)(DerivedStorage + 524) = 1;
      fpfs_stopResetDisturbReprepareAndResume(a2, *(const __CFArray **)(DerivedStorage + 80), 0);
    }
    fpfs_UnlockAndPostNotificationsWithCaller(a2);
  }
}

void fpfs_HDRBatonAvailable(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  fpfs_LockMutexWithCaller(a2);
  if (!*(unsigned char *)(DerivedStorage + 51))
  {
    if (*(void *)(DerivedStorage + 80))
    {
      CMBaseObjectGetDerivedStorage();
      uint64_t v4 = CMBaseObjectGetDerivedStorage();
      if (!CelestialShouldLimitHDRConcurrentPlayback() || (*(_DWORD *)(v4 + 808) - 1) >= 2) {
        fpfsi_SwitchBetweenHDRAndSDR(*(void *)(DerivedStorage + 80), 0);
      }
    }
  }

  fpfs_UnlockWithCaller();
}

void fpfs_4kBatonAvailable(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  fpfs_LockMutexWithCaller(a2);
  if (!*(unsigned char *)(DerivedStorage + 51))
  {
    if (*(void *)(DerivedStorage + 80))
    {
      CMBaseObjectGetDerivedStorage();
      uint64_t v4 = CMBaseObjectGetDerivedStorage();
      if (!CelestialShouldLimit4kConcurrentPlayback() || (*(_DWORD *)(v4 + 808) - 1) >= 2) {
        fpfsi_SwitchBetween4kAndHD(*(void *)(DerivedStorage + 80), 0);
      }
    }
  }

  fpfs_UnlockWithCaller();
}

void fpfs_SpatialAudioPreferencesChanged(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  fpfs_LockMutexWithCaller((uint64_t)a2);
  if (!*(unsigned char *)(DerivedStorage + 51) && *(void *)(DerivedStorage + 80))
  {
    char v4 = 0;
    fpfs_PlayQueueCallForEachItem((uint64_t)a2, (uint64_t (*)(const __CFArray *, uint64_t))fpfs_handleAvailableAudioFormatChange_Apply, (uint64_t)&v4);
  }
  fpfs_UnlockAndPostNotificationsWithCaller(a2);
}

void FigCFRelease_0(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t FigPlayerStreamCreate()
{
  return FigPlayerStreamCreateWithOptions();
}

uint64_t fpfs_LockMutexWithCaller(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = MEMORY[0x19970E290](*(void *)DerivedStorage);
  uint64_t v4 = *(void *)(DerivedStorage + 8);
  *(void *)(DerivedStorage + 8) = v4 + 1;
  if (!v4)
  {
    return fpfs_getPlaybackState(a1, (int *)(DerivedStorage + 164), (unsigned char *)(DerivedStorage + 168));
  }
  return result;
}

void fpfs_stopResetDisturbReprepareAndResume(const void *a1, const __CFArray *a2, int a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    uint64_t v7 = DerivedStorage;
    uint64_t v8 = CMBaseObjectGetDerivedStorage();
    uint64_t v9 = *(void *)(v8 + 1048);
    BOOL v10 = *(float *)(v7 + 108) == 0.0 || v9 == 0;
    int v11 = !v10;
    if (!v10)
    {
      long long v19 = *MEMORY[0x1E4F1F9F8];
      uint64_t v20 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
      long long v17 = v19;
      uint64_t v18 = v20;
      fpfs_setRateInternal(a1, a2, &v19, &v17, 0.0);
    }
    if (*(void *)(v8 + 936)) {
      fpfsi_ConfigurePumpForPlayerAndRelock();
    }
    uint64_t v12 = CMBaseObjectGetDerivedStorage();
    fpfs_ClearRenderChains(a2, 255);
    *(void *)(v12 + 780) = 0;
    if (v9)
    {
      if (a3 == 1) {
        fpfs_PrepareForSeek(a2, 0xFFu, 1);
      }
      if (*(unsigned char *)(v8 + 593) && !*(unsigned char *)(v8 + 592))
      {
        if (dword_1E9350BB0)
        {
          LODWORD(v14) = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        fpfsi_SetCurrentTimeWithSeekID((uint64_t)a2, MEMORY[0x1E4F1FA10], 0, 0);
      }
      else
      {
        fpfsi_SeekToCurrentTime(a2);
      }
    }
    if (*(const __CFArray **)(v7 + 80) == a2)
    {
      fpfs_enqueuePrerollWasCancelledNotificationIfNeeded(a2);
      if (*(unsigned char *)(v7 + 463) && !*(unsigned char *)(v7 + 462)) {
        fpfs_UpdateNeroPlaybackActiveStateAndNotifyIfNeeded(a1, (uint64_t)a2, 0);
      }
      if (v11)
      {
        long long v17 = 0uLL;
        uint64_t v18 = 0;
        fpfs_GetItemBufferedDuration(a2, &v17, &v19, 0);
        long long v14 = v17;
        uint64_t v15 = v18;
        fpfs_CheckIfLikelyToKeepUpAndNotify(a1, a2, &v14, 0, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], &v19);
      }
    }
  }
}

void fpfs_UnlockAndPostNotificationsWithCaller(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = DerivedStorage;
  uint64_t v4 = *(void *)(DerivedStorage + 8);
  if (v4 >= 1) {
    *(void *)(DerivedStorage + 8) = --v4;
  }
  if (v4
    || (fpfs_CheckIfPlaybackStateChangedAndNotifyBeforeUnlock(a1),
        CFAllocatorRef v5 = (void *)(v3 + 88),
        (uint64_t v6 = *(void **)(v3 + 88)) == 0))
  {
LABEL_22:
    JUMPOUT(0x19970E2B0);
  }
  uint64_t v7 = 0;
  while (1)
  {
    while (1)
    {
      uint64_t v8 = v6;
      uint64_t v9 = v6 + 4;
      uint64_t v6 = (void *)v6[4];
      uint64_t v10 = *(v9 - 1);
      if (v10 == MEMORY[0x19970ED80]()) {
        break;
      }
LABEL_15:
      if (!v6) {
        goto LABEL_20;
      }
    }
    if (!v7)
    {
      int v11 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      uint64_t v7 = (void **)v11;
      if (v11)
      {
        *int v11 = 0;
        v11[1] = v11;
      }
    }
    uint64_t v12 = (void *)*v5;
    if ((void *)*v5 == v8)
    {
      uint64_t v16 = *v9;
      *CFAllocatorRef v5 = *v9;
      uint64_t v15 = v3 + 88;
      if (v16) {
        goto LABEL_13;
      }
    }
    else
    {
      do
      {
        uint64_t v13 = v12;
        uint64_t v12 = (void *)v12[4];
      }
      while (v12 != v8);
      uint64_t v14 = *v9;
      v13[4] = *v9;
      uint64_t v15 = (uint64_t)(v13 + 4);
      if (v14)
      {
LABEL_13:
        if (v7) {
          goto LABEL_14;
        }
        goto LABEL_19;
      }
    }
    *(void *)(v3 + 96) = v15;
    if (v7)
    {
LABEL_14:
      v8[4] = 0;
      *v7[1] = v8;
      v7[1] = v9;
      goto LABEL_15;
    }
LABEL_19:
    dispatch_async_f(*(dispatch_queue_t *)(v3 + 24), v8, (dispatch_function_t)fpfs_PostNotificationFromDispatch);
    if (!v6)
    {
LABEL_20:
      if (v7) {
        dispatch_async_f(*(dispatch_queue_t *)(v3 + 24), v7, (dispatch_function_t)fpfs_PostNotificationListFromDispatch);
      }
      goto LABEL_22;
    }
  }
}

uint64_t fpfs_getPlaybackState(uint64_t a1, int *a2, unsigned char *a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = *(void *)(DerivedStorage + 80);
  if (!result)
  {
    if (*(float *)(DerivedStorage + 108) != 0.0) {
      goto LABEL_19;
    }
LABEL_20:
    int v19 = 0;
    LOBYTE(v18) = 0;
    goto LABEL_30;
  }
  uint64_t result = CMBaseObjectGetDerivedStorage();
  int v29 = 0;
  if (*(float *)(DerivedStorage + 108) == 0.0) {
    goto LABEL_20;
  }
  uint64_t v8 = result;
  if (!result)
  {
LABEL_19:
    LOBYTE(v18) = 0;
    int v19 = 3;
    goto LABEL_30;
  }
  CFArrayRef v9 = *(const __CFArray **)(DerivedStorage + 80);
  uint64_t v10 = CMBaseObjectGetDerivedStorage();
  uint64_t v11 = CMBaseObjectGetDerivedStorage();
  uint64_t v12 = (_OWORD *)(v10 + 1448);
  if ((*(_DWORD *)(v10 + 1460) & 0x1D) == 1)
  {
    fpfs_GetNextTimeToPlay(v10, 0, (uint64_t)&lhs);
    CMTimeMake(&rhs, 1, 1000);
    CMTimeAdd(&v36, &lhs, &rhs);
    *(_OWORD *)&time2.unsigned int value = *v12;
    time2.CMTimeEpoch epoch = *(void *)(v10 + 1464);
    uint64_t result = fpfs_TimeIsAtOrAfter(v11, &v36, &time2);
    if (result) {
      goto LABEL_17;
    }
  }
  if (fpfsi_isAssociatedInterstitialEventActive())
  {
    if (*(unsigned char *)(v10 + 444))
    {
      CMClockRef HostTimeClock = CMClockGetHostTimeClock();
      CMClockGetTime(&time1, HostTimeClock);
      CMTime time2 = *(CMTime *)(v10 + 432);
      uint64_t result = CMTimeCompare(&time1, &time2);
      if ((int)result < 1) {
        goto LABEL_17;
      }
    }
  }
  uint64_t result = (uint64_t)fpfsi_isAssociatedInterstitialEventActive();
  if (result)
  {
    if ((*(_DWORD *)(v10 + 1460) & 0x1D) == 1)
    {
      fpfsi_PredictedEndTime(v9, &v30);
      *(_OWORD *)&time2.unsigned int value = *v12;
      time2.CMTimeEpoch epoch = *(void *)(v10 + 1464);
      uint64_t result = fpfs_TimeIsAtOrAfter(v11, &time2, &v30);
      if (result)
      {
        uint64_t v14 = *(unsigned int *)(v11 + 632);
        uint64_t v15 = *(void *)(v11 + 80);
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v11 + 72));
        uint64_t v17 = v15 ? Count + 1 : Count;
        uint64_t result = FigPlaybackGetEffectiveActionAtEnd(v14, v17);
        if (result == 2)
        {
          if (*(unsigned char *)(v10 + 530))
          {
LABEL_17:
            LOBYTE(v18) = 0;
            int v19 = 6;
            goto LABEL_30;
          }
        }
      }
    }
  }
  LOBYTE(v18) = *(unsigned char *)(DerivedStorage + 160);
  if (!(_BYTE)v18) {
    goto LABEL_29;
  }
  if (*(unsigned char *)(v8 + 530)
    && ((uint64_t v20 = *(unsigned int *)(DerivedStorage + 632),
         uint64_t v21 = *(void *)(DerivedStorage + 80),
         CFIndex v22 = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 72)),
         !v21)
      ? (uint64_t v23 = v22)
      : (uint64_t v23 = v22 + 1),
        uint64_t result = FigPlaybackGetEffectiveActionAtEnd(v20, v23),
        result == 2)
    || *(float *)(v8 + 848) != 0.0)
  {
LABEL_28:
    LOBYTE(v18) = 0;
LABEL_29:
    int v19 = 4;
    goto LABEL_30;
  }
  int v18 = *(_DWORD *)(v8 + 524);
  if (!v18) {
    goto LABEL_37;
  }
  if (v18 == 1)
  {
    uint64_t result = fpfsi_waitForVenueDescriptionProcessing(v8);
    if (result)
    {
      LOBYTE(v18) = 0;
LABEL_37:
      int v19 = 1;
      goto LABEL_30;
    }
    float v24 = *(float *)(v8 + 848);
    if (v24 == 0.0)
    {
      uint64_t result = (uint64_t)fpfs_getStartupTaskWaitingStatus(a1, &v29);
      if (result)
      {
        LOBYTE(v18) = 1;
        int v19 = v29;
        goto LABEL_30;
      }
      float v24 = *(float *)(v8 + 848);
    }
    if (v24 == 0.0 && *(void *)(v8 + 2968)) {
      goto LABEL_28;
    }
    LODWORD(rhs.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(time2.CFDictionarySetValue(theDict, key, value) = 0;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int value = rhs.value;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, time2.value)) {
      unsigned int v27 = value;
    }
    else {
      unsigned int v27 = value & 0xFFFFFFFE;
    }
    if (v27)
    {
      if (a1) {
        uint64_t v28 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      }
      else {
        uint64_t v28 = "";
      }
      LODWORD(lhs.CFDictionarySetValue(theDict, key, value) = 136315650;
      *(CMTimeValue *)((char *)&lhs.value + 4) = (CMTimeValue)"fpfs_getPlaybackState";
      LOWORD(lhs.flags) = 2048;
      *(void *)((char *)&lhs.flags + 2) = a1;
      HIWORD(lhs.epoch) = 2082;
      uint64_t v35 = v28;
      _os_log_send_and_compose_impl();
    }
    uint64_t result = fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  LOBYTE(v18) = 0;
  int v19 = 2;
LABEL_30:
  if (a3) {
    *a3 = v18;
  }
  *a2 = v19;
  return result;
}

BOOL fpfsi_waitForVenueDescriptionProcessing(uint64_t a1)
{
  CFNumberRef number = 0;
  int valuePtr = 0;
  if (!*(void *)(a1 + 744)) {
    return 0;
  }
  if (fpfsi_waitForVenueDescriptionProcessing_onceToken != -1) {
    dispatch_once(&fpfsi_waitForVenueDescriptionProcessing_onceToken, &__block_literal_global_313);
  }
  if (!fpfsi_waitForVenueDescriptionProcessing_checkForVenueDescriptionProcessing) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 744);
  uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 8);
  uint64_t v4 = v3 ? v3 : 0;
  CFAllocatorRef v5 = *(uint64_t (**)(uint64_t, __CFString *, void, CFNumberRef *))(v4 + 48);
  if (!v5) {
    return 0;
  }
  int v6 = v5(v2, @"SMS_ProcessingStatus", 0, &number);
  CFNumberRef v7 = number;
  if (v6)
  {
    BOOL v8 = 0;
    if (!number) {
      return v8;
    }
    goto LABEL_11;
  }
  CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
  BOOL v8 = valuePtr == 0;
  CFNumberRef v7 = number;
  if (number) {
LABEL_11:
  }
    CFRelease(v7);
  return v8;
}

CFArrayRef fpfs_getStartupTaskWaitingStatus(uint64_t a1, _DWORD *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef result = *(const __CFArray **)(DerivedStorage + 888);
  if (result)
  {
    if (CFArrayGetCount(result) < 1)
    {
      return 0;
    }
    else
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 888), 0);
      *a2 = FigPlayerStartupTaskGetWaitingState((uint64_t)ValueAtIndex);
      return (const __CFArray *)1;
    }
  }
  return result;
}

BOOL fpfs_TimeIsAtOrAfter(uint64_t a1, CMTime *a2, CMTime *a3)
{
  CMTime time1 = *a2;
  CMTime v7 = *a3;
  if (!CMTimeCompare(&time1, &v7)) {
    return 1;
  }
  CMTime time1 = *a2;
  CMTime v7 = *a3;
  return fpfs_TimeIsAfter(a1, &time1, &v7);
}

double fpfs_GetNextTimeToPlay@<D0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6 = MEMORY[0x1E4F1F9F8];
  long long v7 = *MEMORY[0x1E4F1F9F8];
  *(_OWORD *)a3 = *MEMORY[0x1E4F1F9F8];
  uint64_t v8 = *(void *)(v6 + 16);
  *(void *)(a3 + 16) = v8;
  if (*(unsigned char *)(a1 + 1508))
  {
    uint64_t v9 = a1 + 1496;
  }
  else
  {
    if ((*(unsigned char *)(a1 + 332) & 1) == 0) {
      goto LABEL_6;
    }
    uint64_t v9 = a1 + 320;
  }
  long long v10 = *(_OWORD *)v9;
  *(_OWORD *)a3 = *(_OWORD *)v9;
  *(void *)(a3 + 16) = *(void *)(v9 + 16);
LABEL_6:
  int v11 = *(_DWORD *)(a3 + 12);
  if ((~v11 & 9) != 0)
  {
    if ((~v11 & 5) != 0) {
      goto LABEL_16;
    }
    long long v14 = v7;
    memset(&v18, 0, sizeof(v18));
    fpfsi_GetPumpMaxTimeAvailable(a1, (uint64_t)&v18);
    if ((v18.flags & 1) == 0)
    {
      *(void *)&long long v10 = v14;
      *(_OWORD *)a3 = v14;
      goto LABEL_12;
    }
    CMTime rhs = v18;
    CMTime v15 = *(CMTime *)(a1 + 1184);
    CMTimeSubtract(&lhs, &rhs, &v15);
    *(void *)&long long v10 = lhs.value;
    *(_OWORD *)a3 = *(_OWORD *)&lhs.value;
    CMTimeEpoch epoch = lhs.epoch;
  }
  else
  {
    if ((*(unsigned char *)(a1 + 1364) & 1) == 0)
    {
      *(_OWORD *)a3 = v7;
LABEL_12:
      *(void *)(a3 + 16) = v8;
      goto LABEL_16;
    }
    CMTime lhs = *(CMTime *)(a1 + 1352);
    CMTime rhs = *(CMTime *)(a1 + 1184);
    CMTimeSubtract(&v18, &lhs, &rhs);
    *(void *)&long long v10 = v18.value;
    *(_OWORD *)a3 = *(_OWORD *)&v18.value;
    CMTimeEpoch epoch = v18.epoch;
  }
  *(void *)(a3 + 16) = epoch;
LABEL_16:
  if ((*(_DWORD *)(a3 + 12) & 0x1D) != 1)
  {
    if (a2) {
      fpfs_GetApproximateTime(a1, (uint64_t)&v18);
    }
    else {
      fpfs_GetTime(a1, (uint64_t)&v18);
    }
    *(void *)&long long v10 = v18.value;
    *(CMTime *)a3 = v18;
  }
  return *(double *)&v10;
}

const void *fpfsi_isAssociatedInterstitialEventActive()
{
  CFArrayRef result = *(const void **)(CMBaseObjectGetDerivedStorage() + 3208);
  if (result) {
    return (const void *)(CFEqual(result, &stru_1EE53F4B8) == 0);
  }
  return result;
}

__n128 fpfsi_PredictedEndTime@<Q0>(const __CFArray *a1@<X0>, CMTime *a2@<X8>)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = MEMORY[0x1E4F1F9F8];
  *(_OWORD *)&a2->unsigned int value = *MEMORY[0x1E4F1F9F8];
  a2->CMTimeEpoch epoch = *(void *)(v5 + 16);
  memset(&v12, 0, sizeof(v12));
  result.n128_f64[0] = fpfsi_MapEndTimeFromTargetToSource(DerivedStorage, (uint64_t)&v12);
  if (*(unsigned char *)(DerivedStorage + 470))
  {
    memset(&time1, 0, sizeof(time1));
    memset(&time2, 0, sizeof(time2));
    fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&time2);
    fpfs_GetItemBufferedDuration(a1, &time1, 0, 0);
    CMTime lhs = time2;
    CMTime v7 = time1;
    CMTimeAdd(&v9, &lhs, &v7);
    result.n128_u64[0] = v9.value;
    *a2 = v9;
  }
  if ((v12.flags & 0x1D) == 1)
  {
    CMTime time1 = v12;
    CMTime time2 = *a2;
    if (CMTimeCompare(&time1, &time2) < 0)
    {
      __n128 result = *(__n128 *)&v12.value;
      *a2 = v12;
    }
  }
  return result;
}

BOOL fpfs_TimeIsAfter(uint64_t a1, CMTime *a2, CMTime *a3)
{
  if (*(float *)(a1 + 108) >= 0.0)
  {
    CMTime time1 = *a2;
    CMTime v4 = *a3;
    return CMTimeCompare(&time1, &v4) > 0;
  }
  else
  {
    CMTime time1 = *a2;
    CMTime v4 = *a3;
    return CMTimeCompare(&time1, &v4) >> 31;
  }
}

void fpfsi_GetPumpMaxTimeAvailable(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = MEMORY[0x1E4F1F9F8];
  CFDictionaryRef dictionaryRepresentation = 0;
  *(_OWORD *)a2 = *MEMORY[0x1E4F1F9F8];
  *(void *)(a2 + 16) = *(void *)(v3 + 16);
  uint64_t v4 = *(void *)(a1 + 936);
  if (v4)
  {
    uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
    uint64_t FigBaseObject = FigBytePumpGetFigBaseObject(v4);
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
    uint64_t v8 = v7 ? v7 : 0;
    CMTime v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFDictionaryRef *))(v8 + 48);
    if (v9)
    {
      int v10 = v9(FigBaseObject, 0x1EE53E198, AllocatorForMedia, &dictionaryRepresentation);
      CFDictionaryRef v11 = dictionaryRepresentation;
      if (!v10 && dictionaryRepresentation)
      {
        CMTimeMakeFromDictionary(&v12, dictionaryRepresentation);
        *(_OWORD *)a2 = *(_OWORD *)&v12.value;
        CFDictionaryRef v11 = dictionaryRepresentation;
        *(void *)(a2 + 16) = v12.epoch;
      }
      if (v11) {
        CFRelease(v11);
      }
    }
  }
}

void fpfs_GetApproximateTime(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = MEMORY[0x1E4F1F9F8];
  *(_OWORD *)a2 = *MEMORY[0x1E4F1F9F8];
  *(void *)(a2 + 16) = *(void *)(v4 + 16);
  uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  if ((*(unsigned char *)(a1 + 3288) & 1) != 0 && UpTimeNanoseconds - *(void *)(a1 + 3304) < 1000001)
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 3276);
    uint64_t v6 = *(void *)(a1 + 3292);
  }
  else
  {
    fpfs_GetTime(a1, (uint64_t)&v7);
    *(_OWORD *)a2 = v7;
    uint64_t v6 = v8;
  }
  *(void *)(a2 + 16) = v6;
}

void fpfs_GetTime(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  char v11 = 0;
  uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  CMTimebaseGetTimeClampedAboveAnchorTime();
  CMTime time1 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  CMTimeMaximum((CMTime *)a2, &time1, &time2);
  *(_OWORD *)(a1 + 3276) = *(_OWORD *)a2;
  *(void *)(a1 + 3292) = *(void *)(a2 + 16);
  *(void *)(a1 + 3304) = UpTimeNanoseconds;
  if (v11)
  {
    if (dword_1E9350BB0 >= 2)
    {
      CFTypeRef v8 = 0;
      CFTypeRef cf = 0;
      if (!fpfsi_CopyPlayerAndItemFromItemRetainProxy(*(void *)(a1 + 16), &cf, &v8))
      {
        if (dword_1E9350BB0)
        {
          int v7 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        CFRelease(cf);
        CFRelease(v8);
      }
    }
  }
}

uint64_t FigBytePumpCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  FigBytePumpGetFigBaseObject(a1);
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  char v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 48);
  if (!v11) {
    return 4294954514;
  }

  return v11(v8, a2, a3, a4);
}

uint64_t fpfsi_CopyPlayerAndItemFromItemRetainProxy(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated())
  {
    uint64_t v5 = FigSignalErrorAt();
    uint64_t DerivedStorage = 0;
  }
  else
  {
    uint64_t Owner = (const void *)FigRetainProxyGetOwner();
    if (Owner) {
      uint64_t Owner = CFRetain(Owner);
    }
    *a3 = Owner;
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    uint64_t v5 = 0;
  }
  FigRetainProxyUnlockMutex();
  if (a2 && DerivedStorage)
  {
    MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
    if (*(unsigned char *)(DerivedStorage + 24))
    {
      MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
      uint64_t v5 = 4294954511;
    }
    else
    {
      *a2 = CFRetain(*(CFTypeRef *)DerivedStorage);
      MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
      if (!v5) {
        return v5;
      }
    }
    if (*a3)
    {
      CFRelease(*a3);
      *a3 = 0;
    }
  }
  return v5;
}

double fpfsi_MapEndTimeFromTargetToSource@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v4 = *(_OWORD *)(a1 + 1376);
  *(_OWORD *)a2 = v4;
  *(void *)(a2 + 16) = *(void *)(a1 + 1392);
  CFDataRef v5 = *(const __CFData **)(a1 + 3352);
  if (v5)
  {
    CFDataGetLength(v5);
    CFDataGetBytePtr(*(CFDataRef *)(a1 + 3352));
    CMSpeedRampMapTimeFromTargetToSource();
    *(void *)&long long v4 = v7;
    *(_OWORD *)a2 = v7;
    *(void *)(a2 + 16) = v8;
  }
  return *(double *)&v4;
}

uint64_t fpfs_GetItemBufferedDuration(const __CFArray *a1, CMTime *a2, CMTime *a3, unsigned int a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  float v9 = *(float *)(CMBaseObjectGetDerivedStorage() + 108);
  memset(&v65, 0, sizeof(v65));
  int v10 = 1;
  fpfs_GetNextTimeToPlay(DerivedStorage, 1, (uint64_t)&v65);
  CMTime v68 = v65;
  CMTime v67 = v65;
  CMTime v66 = v65;
  int v11 = *(_DWORD *)(DerivedStorage + 1096);
  if (v11)
  {
    int v10 = *(unsigned __int8 *)(DerivedStorage + 471);
    if (*(unsigned char *)(DerivedStorage + 553))
    {
      if (*(unsigned char *)(DerivedStorage + 471) && *(void *)(DerivedStorage + 1768)) {
        int v10 = *(unsigned __int8 *)(DerivedStorage + 474);
      }
    }
  }
  uint64_t v52 = a2;
  if ((v11 & 2) != 0)
  {
    int v12 = *(unsigned __int8 *)(DerivedStorage + 472);
    if (*(unsigned char *)(DerivedStorage + 553) && *(unsigned char *)(DerivedStorage + 472) && *(void *)(DerivedStorage + 1768)) {
      int v12 = *(unsigned __int8 *)(DerivedStorage + 475);
    }
  }
  else
  {
    int v12 = 1;
  }
  int v53 = v12;
  int v54 = v10;
  uint64_t v13 = *(void *)(DerivedStorage + 1048);
  if (v13)
  {
    int v14 = 0;
    int v55 = 0;
    char v56 = 0;
    int v58 = 0;
    while (1)
    {
      int v15 = *(_DWORD *)(v13 + 152);
      if (v15 == 7 || v15 == 4)
      {
        CMTime time1 = *(CMTime *)(v13 + 192);
        CMTime time2 = v65;
        if (CMTimeCompare(&time1, &time2) > 0 || *(unsigned char *)(v13 + 184)) {
          goto LABEL_63;
        }
      }
      else if (*(void *)(v13 + 48) == *(void *)(DerivedStorage + 16 * *(unsigned __int8 *)(v13 + 180) + 1008))
      {
        goto LABEL_63;
      }
      BOOL v17 = fpfs_LooksLikeStrandedTrack(a1, *(unsigned __int8 *)(v13 + 180), a4, v13) && *(unsigned char *)(v13 + 184) == 0;
      int v18 = *(_DWORD *)(v13 + 32);
      switch(v18)
      {
        case 1935832172:
          char v21 = (*(unsigned char *)(v13 + 228) & 1) == 0 || v17;
          if ((v21 & 1) == 0)
          {
            CFIndex v22 = (_OWORD *)(v13 + 216);
            if (v9 < 0.0)
            {
              CMTime time2 = v66;
              *(_OWORD *)&lhs.unsigned int value = *v22;
              lhs.CMTimeEpoch epoch = *(void *)(v13 + 232);
              CMTimeMinimum(&time1, &time2, &lhs);
              CMTime v66 = time1;
            }
            else
            {
              CMTime time1 = v66;
              *(_OWORD *)&time2.unsigned int value = *v22;
              time2.CMTimeEpoch epoch = *(void *)(v13 + 232);
              CMTimeMaximum(&v66, &time1, &time2);
            }
          }
          int v55 = 1;
          break;
        case 1986618469:
          char v23 = (*(unsigned char *)(v13 + 228) & 1) == 0 || v17;
          if ((v23 & 1) == 0)
          {
            float v24 = (_OWORD *)(v13 + 216);
            if (v9 < 0.0)
            {
              CMTime time2 = v67;
              *(_OWORD *)&lhs.unsigned int value = *v24;
              lhs.CMTimeEpoch epoch = *(void *)(v13 + 232);
              CMTimeMinimum(&time1, &time2, &lhs);
              CMTime v67 = time1;
            }
            else
            {
              CMTime time1 = v67;
              *(_OWORD *)&time2.unsigned int value = *v24;
              time2.CMTimeEpoch epoch = *(void *)(v13 + 232);
              CMTimeMaximum(&v67, &time1, &time2);
            }
          }
          uint64_t v28 = *(void *)(v13 + 48);
          uint64_t v29 = DerivedStorage + 16 * *(unsigned __int8 *)(v13 + 180);
          BOOL v30 = v28 == *(void *)(v29 + 1000) || v28 == *(void *)(v29 + 1008);
          if (v30 && !v17) {
            int v54 = *(unsigned __int8 *)(v13 + 182);
          }
          int v58 = 1;
          break;
        case 1936684398:
          char v19 = (*(unsigned char *)(v13 + 228) & 1) == 0 || v17;
          if ((v19 & 1) == 0)
          {
            uint64_t v20 = (_OWORD *)(v13 + 216);
            if (v9 < 0.0)
            {
              CMTime time2 = v68;
              *(_OWORD *)&lhs.unsigned int value = *v20;
              lhs.CMTimeEpoch epoch = *(void *)(v13 + 232);
              CMTimeMinimum(&time1, &time2, &lhs);
              CMTime v68 = time1;
            }
            else
            {
              CMTime time1 = v68;
              *(_OWORD *)&time2.unsigned int value = *v20;
              time2.CMTimeEpoch epoch = *(void *)(v13 + 232);
              CMTimeMaximum(&v68, &time1, &time2);
            }
          }
          uint64_t v25 = *(void *)(v13 + 48);
          uint64_t v26 = DerivedStorage + 16 * *(unsigned __int8 *)(v13 + 180);
          BOOL v27 = v25 == *(void *)(v26 + 1000) || v25 == *(void *)(v26 + 1008);
          if (v27 && !v17) {
            int v53 = *(unsigned __int8 *)(v13 + 182);
          }
          char v56 = 1;
          break;
      }
LABEL_63:
      if (*(unsigned char *)(v13 + 228)) {
        goto LABEL_72;
      }
      int v31 = *(_DWORD *)(v13 + 32);
      if (v31 != 1986618469 && v31 != 1936684398) {
        goto LABEL_72;
      }
      uint64_t v32 = *(unsigned __int8 *)(v13 + 180);
      int v33 = *(unsigned __int8 *)(DerivedStorage + v32 + 471);
      if (!*(unsigned char *)(DerivedStorage + 553)) {
        goto LABEL_70;
      }
      if (!*(unsigned char *)(DerivedStorage + v32 + 471)) {
        goto LABEL_71;
      }
      if (*(void *)(DerivedStorage + 1768))
      {
        int v33 = *(unsigned __int8 *)(DerivedStorage + v32 + 474);
LABEL_70:
        if (!v33) {
LABEL_71:
        }
          int v14 = 1;
      }
LABEL_72:
      uint64_t v13 = *(void *)(v13 + 8);
      if (!v13)
      {
        if (!a3) {
          goto LABEL_78;
        }
        goto LABEL_76;
      }
    }
  }
  int v55 = 0;
  char v56 = 0;
  int v58 = 0;
  int v14 = 0;
  if (!a3) {
    goto LABEL_78;
  }
LABEL_76:
  uint64_t v34 = 0;
  long long v35 = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v36 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  do
  {
    uint64_t v37 = &a3[v34];
    *(_OWORD *)&v37->unsigned int value = v35;
    v37->CMTimeEpoch epoch = v36;
    ++v34;
  }
  while (v34 != 3);
LABEL_78:
  if (fpfsi_HasRequiredSubstreamsToIndicateBuffering())
  {
    memset(&time1, 0, sizeof(time1));
    memset(&time2, 0, sizeof(time2));
    if (v9 < 0.0)
    {
      CMTime lhs = v65;
      *(_OWORD *)&rhs.unsigned int value = *(_OWORD *)&v68.value;
      CMTimeEpoch epoch = v68.epoch;
    }
    else
    {
      CMTime lhs = v68;
      *(_OWORD *)&rhs.unsigned int value = *(_OWORD *)&v65.value;
      CMTimeEpoch epoch = v65.epoch;
    }
    rhs.CMTimeEpoch epoch = epoch;
    CMTimeSubtract(&time2, &lhs, &rhs);
    unsigned __int8 v40 = v56;
    CMTime rhs = time2;
    long long v57 = *MEMORY[0x1E4F1FA48];
    *(_OWORD *)&v60.unsigned int value = *MEMORY[0x1E4F1FA48];
    CMTimeEpoch v41 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
    v60.CMTimeEpoch epoch = v41;
    CMTimeMaximum(&lhs, &rhs, &v60);
    CMTimeEpoch v42 = lhs.epoch;
    CMTime time2 = lhs;
    if (v58 | v40) {
      char v43 = v40;
    }
    else {
      char v43 = 1;
    }
    if (v14) {
      unsigned __int8 v40 = v43;
    }
    *(_OWORD *)&v52->unsigned int value = *(_OWORD *)&lhs.value;
    v52->CMTimeEpoch epoch = v42;
    if (v58)
    {
      if (v9 < 0.0)
      {
        CMTime lhs = v65;
        *(_OWORD *)&rhs.unsigned int value = *(_OWORD *)&v67.value;
        CMTimeEpoch v44 = v67.epoch;
      }
      else
      {
        CMTime lhs = v67;
        *(_OWORD *)&rhs.unsigned int value = *(_OWORD *)&v65.value;
        CMTimeEpoch v44 = v65.epoch;
      }
      rhs.CMTimeEpoch epoch = v44;
      CMTimeSubtract(&time1, &lhs, &rhs);
      CMTime rhs = time1;
      *(_OWORD *)&v60.unsigned int value = v57;
      v60.CMTimeEpoch epoch = v41;
      CMTimeMaximum(&lhs, &rhs, &v60);
      CMTime time1 = lhs;
      if (!v40 || !v54 && v53 == 1) {
        goto LABEL_95;
      }
      if (v53 == v54)
      {
        CMTime lhs = time1;
        CMTime rhs = *v52;
        if (CMTimeCompare(&lhs, &rhs) < 0) {
LABEL_95:
        }
          *uint64_t v52 = time1;
      }
    }
    if (a3)
    {
      if ((*(unsigned char *)(DerivedStorage + 1096) & 2) != 0)
      {
        if (v58) {
          *a3 = time1;
        }
        int v46 = v55;
        if (v40) {
          a3[1] = time2;
        }
      }
      else
      {
        long long v45 = *(_OWORD *)&v52->value;
        a3->CMTimeEpoch epoch = v52->epoch;
        *(_OWORD *)&a3->unsigned int value = v45;
        int v46 = v55;
      }
      if (v46)
      {
        long long v47 = a3 + 2;
        if (v9 < 0.0)
        {
          CMTime rhs = v65;
          *(_OWORD *)&v60.unsigned int value = *(_OWORD *)&v66.value;
          CMTimeEpoch v48 = v66.epoch;
        }
        else
        {
          CMTime rhs = v66;
          *(_OWORD *)&v60.unsigned int value = *(_OWORD *)&v65.value;
          CMTimeEpoch v48 = v65.epoch;
        }
        v60.CMTimeEpoch epoch = v48;
        CMTimeSubtract(&lhs, &rhs, &v60);
        *(_OWORD *)&v47->unsigned int value = *(_OWORD *)&lhs.value;
        CMTimeEpoch v49 = lhs.epoch;
        v47->CMTimeEpoch epoch = lhs.epoch;
        *(_OWORD *)&rhs.unsigned int value = *(_OWORD *)&v47->value;
        rhs.CMTimeEpoch epoch = v49;
        *(_OWORD *)&v60.unsigned int value = v57;
        v60.CMTimeEpoch epoch = v41;
        CMTimeMaximum(&lhs, &rhs, &v60);
        *long long v47 = lhs;
      }
    }
  }
  else
  {
    uint64_t v39 = MEMORY[0x1E4F1FA48];
    *(_OWORD *)&a2->unsigned int value = *MEMORY[0x1E4F1FA48];
    a2->CMTimeEpoch epoch = *(void *)(v39 + 16);
  }
  uint64_t v50 = *(void *)(DerivedStorage + 3104);
  CMTime time1 = v65;
  CMTime time2 = *v52;
  CMTimeRangeMake(&v59, &time1, &time2);
  return FigNetworkUrgencyMonitorSetPlayableRange(v50, &v59);
}

BOOL fpfs_LooksLikeStrandedTrack(const __CFArray *a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v9 = *(unsigned __int8 *)(a4 + 180);
  if (v9 == a2)
  {
LABEL_14:
    int v14 = *(_DWORD *)(a4 + 152);
    if (v14 != 6)
    {
      if ((uint64_t v16 = *(void *)(a4 + 48), v17 = DerivedStorage + 16 * v9, v16 != *(void *)(v17 + 1000))
        && v16 != *(void *)(v17 + 1008)
        || ((a3 >> v9) & 1) != 0)
      {
        if (v14 != 3) {
          return 1;
        }
        char v19 = 0;
        return fpfs_AreTracksReadyToPlay(a1, *(void *)(a4 + 64), &v19) || v19 == 0;
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  int v11 = *(_DWORD *)(a4 + 32);
  if (v11 > 1935832171)
  {
    if (v11 == 1935832172)
    {
      int v12 = 4;
    }
    else
    {
      int v12 = 1;
      if (v11 != 1986618469)
      {
        if (v11 != 1936684398) {
          return v10;
        }
        int v12 = 2;
      }
    }
LABEL_13:
    if (1 << a2 != v12) {
      return 0;
    }
    goto LABEL_14;
  }
  BOOL v13 = v11 == 1668047728 || v11 == 1835365473;
  int v12 = 1;
  if (v13) {
    goto LABEL_13;
  }
  return v10;
}

BOOL fpfsi_HasRequiredSubstreamsToIndicateBuffering()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = *(void *)(DerivedStorage + 1048);
  if (v1)
  {
    int v2 = 0;
    do
    {
      if (*(unsigned char *)(v1 + 228))
      {
        int v3 = *(_DWORD *)(v1 + 32);
        BOOL v4 = v3 == 1935832172 || v3 == 1986618469;
        if (v4 || v3 == 1936684398) {
          v2 |= 1 << *(unsigned char *)(v1 + 180);
        }
      }
      uint64_t v1 = *(void *)(v1 + 8);
    }
    while (v1);
  }
  else
  {
    int v2 = 0;
  }
  int v6 = *(unsigned __int8 *)(DerivedStorage + 471);
  if (*(unsigned char *)(DerivedStorage + 553))
  {
    if (!*(unsigned char *)(DerivedStorage + 471)) {
      goto LABEL_22;
    }
    if (!*(void *)(DerivedStorage + 1768))
    {
      v2 |= 1u;
      if (!*(unsigned char *)(DerivedStorage + 472)) {
        goto LABEL_28;
      }
      goto LABEL_24;
    }
    int v6 = *(unsigned __int8 *)(DerivedStorage + 474);
  }
  if (v6) {
    v2 |= 1u;
  }
LABEL_22:
  int v7 = *(unsigned __int8 *)(DerivedStorage + 472);
  if (*(unsigned char *)(DerivedStorage + 553))
  {
    if (!*(unsigned char *)(DerivedStorage + 472)) {
      goto LABEL_28;
    }
LABEL_24:
    if (!*(void *)(DerivedStorage + 1768))
    {
      v2 |= 2u;
      if (!*(unsigned char *)(DerivedStorage + 473)) {
        return (*(_DWORD *)(DerivedStorage + 1096) & ~v2 & 3) == 0;
      }
LABEL_30:
      if (!*(void *)(DerivedStorage + 1768))
      {
LABEL_33:
        v2 |= 4u;
        return (*(_DWORD *)(DerivedStorage + 1096) & ~v2 & 3) == 0;
      }
      int v8 = *(unsigned __int8 *)(DerivedStorage + 476);
      goto LABEL_32;
    }
    int v7 = *(unsigned __int8 *)(DerivedStorage + 475);
  }
  if (v7) {
    v2 |= 2u;
  }
LABEL_28:
  int v8 = *(unsigned __int8 *)(DerivedStorage + 473);
  if (*(unsigned char *)(DerivedStorage + 553))
  {
    if (!*(unsigned char *)(DerivedStorage + 473)) {
      return (*(_DWORD *)(DerivedStorage + 1096) & ~v2 & 3) == 0;
    }
    goto LABEL_30;
  }
LABEL_32:
  if (v8) {
    goto LABEL_33;
  }
  return (*(_DWORD *)(DerivedStorage + 1096) & ~v2 & 3) == 0;
}

uint64_t fpfs_AreTracksReadyToPlay(const __CFArray *a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = CMBaseObjectGetDerivedStorage();
  if (a3) {
    *a3 = 0;
  }
  uint64_t v8 = *(void *)(DerivedStorage + 1048);
  unsigned __int8 v9 = 1;
  if (!v8)
  {
    int v22 = 0;
    LOBYTE(v10) = 0;
LABEL_57:
    if (*(uint64_t *)(DerivedStorage + 1104) < 2) {
      goto LABEL_94;
    }
    int v23 = *(_DWORD *)(DerivedStorage + 1096);
    if (((v23 ^ v10) & 7) == 0) {
      goto LABEL_94;
    }
    for (uint64_t i = 0; i != 3; ++i)
    {
      if (*(unsigned char *)(DerivedStorage + 471 + i)) {
        int v25 = 1 << i;
      }
      else {
        LOBYTE(v25) = 0;
      }
      LOBYTE(v10) = v25 | v10;
    }
    if (((v10 ^ v23) & 7) == 0)
    {
LABEL_94:
      if (v9) {
        goto LABEL_74;
      }
      for (uint64_t j = *(void *)(DerivedStorage + 1048); j; uint64_t j = *(void *)(j + 8))
      {
        if (!*(unsigned char *)(j + 184) && *(void *)(j + 64) == a2)
        {
          memset(&time1, 0, sizeof(time1));
          CMTime time2 = *(CMTime *)(j + 192);
          fpfs_GetTrackStartupQueueDuration(j, &time2, (uint64_t)&time1);
          CMTimeMake(&v32, 10, 1);
          CMTime time2 = time1;
          if ((CMTimeCompare(&time2, &v32) & 0x80000000) == 0) {
            goto LABEL_73;
          }
        }
      }
      if (!v22)
      {
LABEL_74:
        if (*(unsigned char *)(DerivedStorage + 1508))
        {
          uint64_t v27 = *(void *)(DerivedStorage + 1048);
          if (v27)
          {
            uint64_t v28 = (CMTime *)(DerivedStorage + 1496);
            do
            {
              if (!*(unsigned char *)(v27 + 184) && *(void *)(v27 + 64) == a2 && !*(unsigned char *)(v27 + 182))
              {
                if ((*(unsigned char *)(v27 + 228) & 1) == 0
                  || (CMTime time1 = *(CMTime *)(v27 + 216), time2 = *v28, CMTimeCompare(&time1, &time2) < 0))
                {
                  unsigned __int8 v9 = 0;
                }
              }
              uint64_t v27 = *(void *)(v27 + 8);
            }
            while (v27);
          }
        }
        return v9;
      }
      if (*(unsigned char *)(DerivedStorage + 470))
      {
LABEL_73:
        unsigned __int8 v9 = 1;
        goto LABEL_74;
      }
    }
    return 0;
  }
  BOOL v30 = a3;
  int v10 = 0;
  uint64_t v11 = *MEMORY[0x1E4F75A20];
  while (1)
  {
    uint64_t v12 = *(void *)(v8 + 64);
    if (v12 <= a2 && *(void *)(v8 + 384))
    {
      if (!fpfs_isDecryptorReady(v8)) {
        return 0;
      }
      uint64_t v12 = *(void *)(v8 + 64);
    }
    if (v12 < a2)
    {
      if ((*(_DWORD *)(v8 + 152) | 2) == 3) {
        return 0;
      }
      goto LABEL_54;
    }
    if (v12 != a2)
    {
      int v16 = 1 << *(unsigned char *)(v8 + 180);
      if ((v16 & v10) == 0)
      {
        if (dword_1E9350BB0 >= 3)
        {
          uint64_t v31 = v11;
          int v34 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          int v16 = 1 << *(unsigned char *)(v8 + 180);
          uint64_t v11 = v31;
        }
        v10 |= v16;
      }
      goto LABEL_54;
    }
    if ((*(unsigned char *)(v8 + 140) & 1) != 0 || *(unsigned char *)(v8 + 182) || *(unsigned char *)(v8 + 180) == 2) {
      v10 |= 1 << *(unsigned char *)(v8 + 180);
    }
    if (!*(unsigned char *)(v8 + 184)) {
      break;
    }
LABEL_54:
    uint64_t v8 = *(void *)(v8 + 8);
    if (!v8)
    {
      int v22 = 0;
      unsigned __int8 v9 = 1;
      goto LABEL_57;
    }
  }
  int v13 = *(_DWORD *)(v8 + 32);
  if (v13 == 1936684398)
  {
    if (*(void *)(v8 + 40)) {
      goto LABEL_33;
    }
LABEL_34:
    if (*(const __CFArray **)(v7 + 80) != a1 && *(_DWORD *)(v8 + 32) == 1936684398)
    {
      LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 0;
      CMBaseObjectGetDerivedStorage();
      int v18 = FigCFEqual();
      if (fpfs_WantAudioHardwarePassthroughForTrack(v8, (int *)&time1) != (v18 != 0)) {
        return 0;
      }
      int v19 = v18 ? 1633889587 : 0;
      if (v18 && v19 != LODWORD(time1.value)) {
        return 0;
      }
    }
    if (!*(unsigned char *)(v8 + 182))
    {
      if (!*(void *)(v8 + 40) || (int v20 = *(_DWORD *)(v8 + 152)) == 0)
      {
LABEL_85:
        unsigned __int8 v9 = 0;
        int v22 = 1;
        goto LABEL_57;
      }
      int v21 = *(_DWORD *)(v8 + 32);
      if (v21 == 1986618469)
      {
        if (v20 != 3 && fpfs_CanRenderVideo(v7, *(void *)v8)) {
          goto LABEL_85;
        }
      }
      else if (!v21)
      {
        goto LABEL_85;
      }
      if ((*(unsigned char *)(v8 + 228) & 1) == 0) {
        goto LABEL_85;
      }
      CMTime time1 = *(CMTime *)(v8 + 216);
      CMTime time2 = *(CMTime *)(v8 + 192);
      if (CMTimeCompare(&time1, &time2) < 1) {
        goto LABEL_85;
      }
    }
    goto LABEL_54;
  }
  if (v13 != 1986618469 || !*(void *)(v8 + 40)) {
    goto LABEL_34;
  }
  CFArrayRef v14 = *(const __CFArray **)(v7 + 80);
  if (v14 != a1
    && v14
    && (fpfs_getNext(v7, v14) != a1 || !fpfsi_PumpHasEndedOrBufferedBeyondFwdEnd(*(void *)(v7 + 80))))
  {
    return 0;
  }
  if (*(uint64_t *)(v7 + 616) < 4
    || (uint64_t v15 = *(void *)(DerivedStorage + 792)) != 0
    && fpfs_FormatsAreCompatible((uint64_t)a1, *(const opaqueCMFormatDescription **)(v15 + 16), *(const opaqueCMFormatDescription **)(v8 + 40)))
  {
LABEL_33:
    if (*(unsigned char *)(DerivedStorage + 2880))
    {
      if (!v30) {
        return 0;
      }
      unsigned __int8 v9 = 0;
      *BOOL v30 = 1;
      return v9;
    }
    goto LABEL_34;
  }
  fpfs_ClearRenderChains(a1, 1u);
  if (!v30) {
    return 0;
  }
  unsigned __int8 v9 = 0;
  *BOOL v30 = 1;
  return v9;
}

uint64_t fpfs_isDecryptorReady(uint64_t a1)
{
  CFTypeRef cf = 0;
  uint64_t v1 = *(void *)(a1 + 384);
  uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
  uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  CFDataRef v5 = *(unsigned int (**)(uint64_t, void, uint64_t, CFTypeRef *))(v4 + 48);
  if (!v5 || v5(v1, *MEMORY[0x1E4F1FDF8], AllocatorForMedia, &cf)) {
    return 1;
  }
  BOOL v6 = *MEMORY[0x1E4F1CFD0] == (void)cf;
  CFRelease(cf);
  return v6;
}

CFArrayRef fpfs_getNext(uint64_t a1, const void *a2)
{
  if (!a2)
  {
    CFArrayRef result = *(const __CFArray **)(a1 + 80);
    if (result) {
      return result;
    }
    CFArrayRef v10 = *(const __CFArray **)(a1 + 72);
    unsigned __int8 v9 = (const __CFArray **)(a1 + 72);
    CFArrayRef result = v10;
    if (!v10) {
      return result;
    }
    if (CFArrayGetCount(result) > 0)
    {
      CFIndex v11 = 0;
      CFDataRef v5 = v9;
      goto LABEL_13;
    }
    return 0;
  }
  CFDataRef v5 = (const __CFArray **)(a1 + 72);
  CFArrayRef result = *(const __CFArray **)(a1 + 72);
  if (!result)
  {
    CFArrayRef v8 = 0;
    CFIndex v7 = 0;
    if (*(const void **)(a1 + 80) == a2) {
      return result;
    }
LABEL_10:
    v15.CFIndex location = 0;
    v15.size_t length = v7;
    FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v8, v15, a2);
    CFArrayRef result = 0;
    CFIndex v11 = FirstIndexOfValue + 1;
    if (FirstIndexOfValue + 1 >= v7) {
      return result;
    }
    goto LABEL_13;
  }
  CFIndex Count = CFArrayGetCount(result);
  CFIndex v7 = Count;
  if (*(const void **)(a1 + 80) != a2)
  {
    CFArrayRef v8 = *v5;
    goto LABEL_10;
  }
  CFIndex v11 = 0;
  if (Count <= 0) {
    return 0;
  }
LABEL_13:
  CFArrayRef v13 = *v5;

  return (const __CFArray *)CFArrayGetValueAtIndex(v13, v11);
}

uint64_t fpfsi_PumpHasEndedOrBufferedBeyondFwdEnd(uint64_t a1)
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (result) {
    return *(unsigned char *)(result + 470) || fpfsi_PlaybackHasBufferedBeyondForwardEndTime(a1) != 0;
  }
  return result;
}

uint64_t fpfs_FormatsAreCompatible(uint64_t a1, const opaqueCMFormatDescription *a2, const opaqueCMFormatDescription *a3)
{
  CMBaseObjectGetDerivedStorage();
  CMMediaType MediaType = CMFormatDescriptionGetMediaType(a2);
  if (MediaType != CMFormatDescriptionGetMediaType(a3)) {
    return 0;
  }
  if (MediaType == 1986618469)
  {
    uint64_t result = FPSupport_CanFormatsShareVideoRenderPipeline(a2, a3);
    if (!result) {
      return result;
    }
LABEL_9:
    FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(a2);
    return MediaSubType == CMFormatDescriptionGetMediaSubType(a3);
  }
  if (MediaType == 1936684398)
  {
    int v8 = fpfs_passthroughFormatForAudioFormat(a2);
    int v9 = fpfs_passthroughFormatForAudioFormat(a3);
    if (v8 == v9
      || ((int v13 = v9, !v8)
       || (uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(), v8 != 1633889587)
       || !*(void *)(DerivedStorage + 536)
       || !*(unsigned char *)(DerivedStorage + 562))
      && (!v13
       || (uint64_t v15 = CMBaseObjectGetDerivedStorage(), v13 != 1633889587)
       || !*(void *)(v15 + 536)
       || !*(unsigned char *)(v15 + 562)))
    {
      signed int v10 = CMFormatDescriptionGetMediaSubType(a2);
      int v11 = 1;
      if (v10 > 1885692722)
      {
        if (v10 <= 1902469938)
        {
          if (v10 != 1885692723)
          {
            int v12 = 1902324531;
LABEL_35:
            if (v10 == v12) {
              goto LABEL_47;
            }
            goto LABEL_46;
          }
LABEL_37:
          size_t sizeOut = 0;
          FormatList = CMAudioFormatDescriptionGetFormatList(a2, &sizeOut);
          int v11 = 0;
          if (FormatList && sizeOut >= 0x30)
          {
            int mFormatID = FormatList->mASBD.mFormatID;
            int v11 = 1;
            if (mFormatID <= 1885547314)
            {
              if (mFormatID == 1667574579) {
                goto LABEL_47;
              }
              int v19 = 1700997939;
LABEL_45:
              if (mFormatID == v19) {
                goto LABEL_47;
              }
              goto LABEL_46;
            }
            if (mFormatID != 1885547315 && mFormatID != 1902324531)
            {
              int v19 = 2053319475;
              goto LABEL_45;
            }
          }
LABEL_47:
          signed int v20 = CMFormatDescriptionGetMediaSubType(a3);
          int v21 = 1;
          if (v20 > 1885692722)
          {
            if (v20 <= 1902469938)
            {
              if (v20 != 1885692723)
              {
                int v22 = 1902324531;
LABEL_62:
                if (v20 != v22) {
                  goto LABEL_73;
                }
                return v11 == v21 || !*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561);
              }
              goto LABEL_64;
            }
            if (v20 == 2053464883)
            {
LABEL_64:
              size_t sizeOut = 0;
              float v24 = CMAudioFormatDescriptionGetFormatList(a3, &sizeOut);
              int v21 = 0;
              if (!v24 || sizeOut < 0x30) {
                return v11 == v21 || !*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561);
              }
              int v25 = v24->mASBD.mFormatID;
              int v21 = 1;
              if (v25 <= 1885547314)
              {
                if (v25 == 1667574579) {
                  return v11 == v21 || !*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561);
                }
                int v26 = 1700997939;
              }
              else
              {
                if (v25 == 1885547315 || v25 == 1902324531) {
                  return v11 == v21 || !*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561);
                }
                int v26 = 2053319475;
              }
              if (v25 == v26) {
                return v11 == v21 || !*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561);
              }
LABEL_73:
              int v21 = 0;
              return v11 == v21 || !*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561);
            }
            if (v20 == 2053319475) {
              return v11 == v21 || !*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561);
            }
            int v23 = 1902469939;
          }
          else
          {
            if (v20 > 1700997938)
            {
              if (v20 == 1700997939) {
                return v11 == v21 || !*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561);
              }
              if (v20 != 1700998451)
              {
                int v22 = 1885547315;
                goto LABEL_62;
              }
              goto LABEL_64;
            }
            if (v20 == 1667574579) {
              return v11 == v21 || !*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561);
            }
            int v23 = 1667575091;
          }
          if (v20 != v23) {
            goto LABEL_73;
          }
          goto LABEL_64;
        }
        if (v10 == 2053464883) {
          goto LABEL_37;
        }
        if (v10 == 2053319475) {
          goto LABEL_47;
        }
        int v16 = 1902469939;
      }
      else
      {
        if (v10 > 1700997938)
        {
          if (v10 == 1700997939) {
            goto LABEL_47;
          }
          if (v10 != 1700998451)
          {
            int v12 = 1885547315;
            goto LABEL_35;
          }
          goto LABEL_37;
        }
        if (v10 == 1667574579) {
          goto LABEL_47;
        }
        int v16 = 1667575091;
      }
      if (v10 != v16)
      {
LABEL_46:
        int v11 = 0;
        goto LABEL_47;
      }
      goto LABEL_37;
    }
    return 0;
  }
  if (MediaType != 1835365473) {
    goto LABEL_9;
  }

  return fpfsi_canMetadataFormatsSync(a2, a3);
}

void fpfs_ClearRenderChains(const __CFArray *a1, unsigned int a2)
{
  uint64_t v4 = 0;
  uint64_t v5 = CMBaseObjectGetDerivedStorage() + 792;
  do
  {
    if ((a2 >> v4))
    {
      BOOL v6 = *(void **)(v5 + 8 * v4);
      if (v6)
      {
        fpfs_releaseRenderChain(a1, v6);
        *(void *)(v5 + 8 * v4) = 0;
      }
    }
    ++v4;
  }
  while (v4 != 5);
}

uint64_t fpfs_WantAudioHardwarePassthroughForTrack(uint64_t a1, int *a2)
{
  if (*(_DWORD *)(a1 + 32) != 1936684398) {
    goto LABEL_13;
  }
  if (!*(void *)(a1 + 40))
  {
    FigSignalErrorAt();
LABEL_13:
    int v5 = 0;
    goto LABEL_14;
  }
  uint64_t result = FigAudioQueueRenderPipelineIsPassthroughSupported();
  if (result)
  {
    uint64_t result = fpfs_passthroughFormatForAudioFormat(*(const opaqueCMFormatDescription **)(a1 + 40));
    int v5 = result;
    if (!result) {
      goto LABEL_15;
    }
    AudioDeviceMaxPhysicalOutputChannelCFIndex Count = fpfs_GetAudioDeviceMaxPhysicalOutputChannelCount(*(void *)a1, 0, 0);
    int v7 = fpfs_GetAudioDeviceMaxPhysicalOutputChannelCount(*(void *)a1, 1, v5);
    if (v7 >= 1)
    {
      int v8 = v7;
      CMBaseObjectGetDerivedStorage();
      CMBaseObjectGetDerivedStorage();
      if (FigCFEqual()
        || (CMFormatDescriptionGetMediaSubType(*(CMFormatDescriptionRef *)(a1 + 40)),
            v8 > AudioDeviceMaxPhysicalOutputChannelCount))
      {
        uint64_t result = 1;
        if (!a2) {
          return result;
        }
      }
      else
      {
        uint64_t result = FigAudioCodecTypeIsDecodable() == 0;
        if (!a2) {
          return result;
        }
      }
      goto LABEL_16;
    }
LABEL_14:
    uint64_t result = 0;
LABEL_15:
    if (!a2) {
      return result;
    }
    goto LABEL_16;
  }
  int v5 = 0;
  if (!a2) {
    return result;
  }
LABEL_16:
  *a2 = v5;
  return result;
}

BOOL fpfs_CanRenderVideo(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 80))
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    if (*(unsigned char *)(a1 + 524))
    {
      if (*(void *)(DerivedStorage + 936))
      {
        if (*(void *)(DerivedStorage + 400)) {
          FigCFDictionaryGetBooleanIfPresent();
        }
        CFTypeRef cf = 0;
        uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage() + 936);
        if (!v5) {
          return 0;
        }
        uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
        uint64_t FigBaseObject = FigBytePumpGetFigBaseObject(v5);
        uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
        uint64_t v9 = v8 ? v8 : 0;
        signed int v10 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v9 + 48);
        if (!v10) {
          return 0;
        }
        if (v10(FigBaseObject, @"FBP_HasKeyContent", AllocatorForMedia, &cf)) {
          BOOL v11 = 1;
        }
        else {
          BOOL v11 = cf == (CFTypeRef)*MEMORY[0x1E4F1CFD0];
        }
        char v12 = v11;
        if (cf) {
          CFRelease(cf);
        }
        if (v12) {
          return 0;
        }
      }
    }
  }
  if (a2
    && (CFArrayRef v13 = *(const __CFArray **)(CMBaseObjectGetDerivedStorage() + 864),
        uint64_t TrackWithFormatDescriptionOfType = fpfs_FirstTrackWithFormatDescriptionOfType(a2, 1986618469),
        v13)
    && (uint64_t v15 = TrackWithFormatDescriptionOfType, CFArrayGetCount(v13) >= 1))
  {
    uint64_t v16 = fpfsi_VideoOutputAllowedWithPermissivePolicy(v15);
  }
  else
  {
    uint64_t v16 = 0;
  }
  CFArrayRef v17 = *(const __CFArray **)(a1 + 376);
  if (v17 && CFArrayGetCount(v17) > 0 || *(uint64_t *)(a1 + 400) >= 1) {
    uint64_t v16 = 1;
  }
  CFArrayRef v18 = *(const __CFArray **)(a1 + 432);
  if (v18)
  {
    if (CFArrayGetCount(v18) > 0) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = v16;
    }
  }
  if (*(unsigned char *)(a1 + 462))
  {
    if (!a2) {
      return 1;
    }
    if (*(unsigned char *)(a1 + 496)) {
      return *(void *)(a1 + 80) == a2;
    }
    return 0;
  }
  return v16;
}

double fpfs_GetTrackStartupQueueDuration@<D0>(uint64_t a1@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  memset(&v14, 0, sizeof(v14));
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  CMBufferQueueGetDuration((CMTime *)a3, *(CMBufferQueueRef *)(a1 + 72));
  CMTime time1 = *(CMTime *)a3;
  CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    CMSampleBufferRef refcon = 0;
    CMBufferQueueCallForEachBuffer(*(CMBufferQueueRef *)(a1 + 72), (OSStatus (__cdecl *)(CMBufferRef, void *))fpfs_GetMinSampleInStartupQueue, &refcon);
    if (refcon)
    {
      memset(&time1, 0, sizeof(time1));
      CMSampleBufferGetPresentationTimeStamp(&time1, refcon);
      CMTime lhs = time1;
      CMTime v9 = *(CMTime *)(a1 + 128);
      CMTimeAdd(&time2, &lhs, &v9);
      CMTimeEpoch epoch = time2.epoch;
      CMTime time1 = time2;
      long long v8 = *(_OWORD *)&time2.value;
      CMTime time2 = *a2;
      *(_OWORD *)&lhs.unsigned int value = v8;
      lhs.CMTimeEpoch epoch = epoch;
      CMTimeSubtract(&v14, &time2, &lhs);
      CMTime lhs = *(CMTime *)a3;
      CMTime v9 = v14;
      CMTimeSubtract(&time2, &lhs, &v9);
      double result = *(double *)&time2.value;
      *(CMTime *)a3 = time2;
    }
  }
  return result;
}

uint64_t fpfsi_PlaybackHasBufferedBeyondForwardEndTime(uint64_t a1)
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (result)
  {
    fpfsi_MapEndTimeFromTargetToSource(result, (uint64_t)v3);
    return fpfsi_PlaybackHasBufferedBeyondTime(a1, (uint64_t)v3) != 0;
  }
  return result;
}

uint64_t fpfsi_PlaybackHasBufferedBeyondTime(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMTime v11 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  if ((*(unsigned char *)(a2 + 12) & 1) == 0) {
    return 0;
  }
  uint64_t v5 = DerivedStorage;
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (!result) {
    return result;
  }
  uint64_t v7 = result;
  fpfs_GetItemBufferedDuration(a1, &v11, 0, 0);
  fpfs_GetNextTimeToPlay(v5, 0, (uint64_t)&lhs);
  CMTime v8 = v11;
  CMTimeAdd(&time1, &lhs, &v8);
  CMTime v8 = *(CMTime *)a2;
  return (CMTimeCompare(&time1, &v8) & 0x80000000) == 0 && *(float *)(v7 + 108) >= 0.0;
}

uint64_t fpfsi_canMetadataFormatsSync(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2)
{
  FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  if (MediaSubType != CMFormatDescriptionGetMediaSubType(a2)) {
    return 0;
  }
  uint64_t result = 0;
  if (a1 && a2)
  {
    if (MediaSubType == 1835360888)
    {
      return CMFormatDescriptionEqual(a1, a2);
    }
    else if (MediaSubType == 1701671783)
    {
      CMFormatDescriptionGetExtensions(a1);
      CMFormatDescriptionGetExtensions(a2);
      return FigCFEqual();
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t fpfs_passthroughFormatForAudioFormat(const opaqueCMFormatDescription *a1)
{
  uint64_t v2 = 1700997939;
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  if (MediaSubType <= 1885692722)
  {
    if (MediaSubType > 1700997938)
    {
      if (MediaSubType == 1700997939) {
        return v2;
      }
      if (MediaSubType != 1700998451)
      {
        int v4 = 1885547315;
        goto LABEL_16;
      }
      goto LABEL_18;
    }
    if (MediaSubType == 1667574579) {
      return v2;
    }
    int v5 = 1667575091;
LABEL_12:
    if (MediaSubType != v5) {
      goto LABEL_27;
    }
    goto LABEL_18;
  }
  if (MediaSubType > 1902469938)
  {
    if (MediaSubType == 2053464883) {
      goto LABEL_18;
    }
    if (MediaSubType == 2053319475) {
      return v2;
    }
    int v5 = 1902469939;
    goto LABEL_12;
  }
  if (MediaSubType != 1885692723)
  {
    int v4 = 1902324531;
LABEL_16:
    if (MediaSubType == v4) {
      return v2;
    }
    goto LABEL_27;
  }
LABEL_18:
  size_t sizeOut = 0;
  FormatList = CMAudioFormatDescriptionGetFormatList(a1, &sizeOut);
  if (FormatList && sizeOut > 0x2F)
  {
    int mFormatID = FormatList->mASBD.mFormatID;
    if (mFormatID <= 1885547314)
    {
      if (mFormatID == 1667574579) {
        return v2;
      }
      int v8 = 1700997939;
    }
    else
    {
      if (mFormatID == 1885547315 || mFormatID == 1902324531) {
        return v2;
      }
      int v8 = 2053319475;
    }
    if (mFormatID == v8) {
      return v2;
    }
  }
LABEL_27:
  uint64_t v9 = 1633889587;
  signed int v10 = CMFormatDescriptionGetMediaSubType(a1);
  uint64_t v2 = 1700998451;
  if (v10 > 1885430578)
  {
    if (v10 <= 1902469938)
    {
      if (v10 == 1885430579) {
        return v9;
      }
      if (v10 != 1885692723)
      {
        int v11 = 1902207795;
LABEL_43:
        if (v10 != v11) {
          return 0;
        }
        return v9;
      }
      return v2;
    }
    if (v10 == 1902469939) {
      return v2;
    }
    if (v10 == 2053202739) {
      return v9;
    }
    int v12 = 2053464883;
LABEL_39:
    if (v10 != v12) {
      return 0;
    }
    return v2;
  }
  if (v10 <= 1667326770)
  {
    if (v10 == 1633889587) {
      return v9;
    }
    int v11 = 1667312947;
    goto LABEL_43;
  }
  if (v10 == 1667326771) {
    return v9;
  }
  if (v10 != 1667575091)
  {
    int v12 = 1700998451;
    goto LABEL_39;
  }
  return v2;
}

uint64_t CMAudioFormatDescriptionIsAtmos(const opaqueCMFormatDescription *a1)
{
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  uint64_t result = 1;
  if (MediaSubType <= 1885692722)
  {
    if (MediaSubType > 1700997938)
    {
      if (MediaSubType == 1700997939) {
        return result;
      }
      if (MediaSubType != 1700998451)
      {
        int v4 = 1885547315;
        goto LABEL_24;
      }
      goto LABEL_16;
    }
    if (MediaSubType == 1667574579) {
      return result;
    }
    int v5 = 1667575091;
LABEL_12:
    if (MediaSubType != v5) {
      return 0;
    }
    goto LABEL_16;
  }
  if (MediaSubType > 1902469938)
  {
    if (MediaSubType == 2053464883) {
      goto LABEL_16;
    }
    if (MediaSubType == 2053319475) {
      return result;
    }
    int v5 = 1902469939;
    goto LABEL_12;
  }
  if (MediaSubType != 1885692723)
  {
    int v4 = 1902324531;
    goto LABEL_24;
  }
LABEL_16:
  size_t sizeOut = 0;
  FormatList = CMAudioFormatDescriptionGetFormatList(a1, &sizeOut);
  uint64_t result = 0;
  if (FormatList && sizeOut >= 0x30)
  {
    signed int MediaSubType = FormatList->mASBD.mFormatID;
    uint64_t result = 1;
    if (MediaSubType <= 1885547314)
    {
      if (MediaSubType == 1667574579) {
        return result;
      }
      int v4 = 1700997939;
LABEL_24:
      if (MediaSubType == v4) {
        return result;
      }
      return 0;
    }
    if (MediaSubType != 1885547315 && MediaSubType != 1902324531)
    {
      int v4 = 2053319475;
      goto LABEL_24;
    }
  }
  return result;
}

void fpfs_releaseRenderChain(const __CFArray *a1, void *a2)
{
  queueOut[27] = *(CMBufferQueueRef *)MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = CMBaseObjectGetDerivedStorage();
  if ((*(void *)a2)-- != 1) {
    return;
  }
  uint64_t v7 = v5;
  if (*((unsigned char *)a2 + 24)) {
    fpfs_EstablishTimebase(a1);
  }
  int v8 = (const opaqueCMFormatDescription *)*((void *)a2 + 2);
  if (v8)
  {
    CMMediaType MediaType = CMFormatDescriptionGetMediaType(v8);
    switch(MediaType)
    {
      case 0x636C6370u:
        FPSupport_resetClosedCaptionLayer(v7 + 208);
        break;
      case 0x736F756Eu:
        int v11 = 0;
        int v10 = 1;
        goto LABEL_14;
      case 0x76696465u:
        int v10 = 0;
        int v11 = 1;
LABEL_14:
        FigFormatDescriptionRelease();
        *((void *)a2 + 2) = 0;
        goto LABEL_15;
    }
    int v10 = 0;
    int v11 = 0;
    goto LABEL_14;
  }
  int v10 = 0;
  int v11 = 0;
LABEL_15:
  int v12 = (const void *)*((void *)a2 + 6);
  if (v12)
  {
    CFRelease(v12);
    *((void *)a2 + 6) = 0;
  }
  uint64_t v13 = *((void *)a2 + 4);
  if (v13)
  {
    queueOut[0] = 0;
    FPSupport_ForgetAboutMetadataOutputRenderPipeline(*(void *)(DerivedStorage + 1880), v13);
    uint64_t v14 = *(void *)(DerivedStorage + 1864);
    if (v14) {
      FigLegibleOutputManagerForgetAboutLegibleOutputRenderPipeline(v14, *((void *)a2 + 4));
    }
    if (v11)
    {
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
    }
    else if (v10)
    {
      fpfsi_RemoveAudioRenderChainListeners();
    }
    uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(*((void *)a2 + 4));
    uint64_t v16 = *(void **)(CMBaseObjectGetVTable() + 8);
    if (v16) {
      CFArrayRef v17 = v16;
    }
    else {
      CFArrayRef v17 = 0;
    }
    if (*v17 >= 2uLL)
    {
      CFArrayRef v18 = (void (*)(uint64_t))v17[8];
      if (v18) {
        v18(FigBaseObject);
      }
    }
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (*((void *)a2 + 5)
      && (CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia(),
          CallbacksForUnsortedSampleBuffers = CMBufferQueueGetCallbacksForUnsortedSampleBuffers(),
          !CMBufferQueueCreate(AllocatorForMedia, 0, CallbacksForUnsortedSampleBuffers, queueOut)))
    {
      MEMORY[0x199709540](*((void *)a2 + 5), fpfs_StealBuffer, queueOut[0]);
      fpfs_SendBufferQueueToChomper(v7, (uint64_t)queueOut[0]);
    }
    else
    {
      uint64_t v22 = *((void *)a2 + 4);
      uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v23) {
        uint64_t v24 = v23;
      }
      else {
        uint64_t v24 = 0;
      }
      int v25 = *(void (**)(uint64_t, void))(v24 + 64);
      if (v25) {
        v25(v22, 0);
      }
    }
    uint64_t v26 = FigRenderPipelineGetFigBaseObject(*((void *)a2 + 4));
    if (v26)
    {
      uint64_t v27 = v26;
      uint64_t v28 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v29 = v28 ? v28 : 0;
      BOOL v30 = *(void (**)(uint64_t))(v29 + 24);
      if (v30) {
        v30(v27);
      }
    }
    CFRelease(*((CFTypeRef *)a2 + 4));
    *((void *)a2 + 4) = 0;
  }
  if (*((void *)a2 + 5))
  {
    FigBufferQueueRelease();
    *((void *)a2 + 5) = 0;
  }
  uint64_t v31 = (const void *)*((void *)a2 + 7);
  if (v31)
  {
    CFRelease(v31);
    *((void *)a2 + 7) = 0;
  }
  CMTime v32 = (const void *)*((void *)a2 + 8);
  if (v32)
  {
    CFRelease(v32);
    *((void *)a2 + 8) = 0;
  }
  int v33 = (const void *)*((void *)a2 + 9);
  if (v33)
  {
    CFRelease(v33);
    *((void *)a2 + 9) = 0;
  }
  if (v11) {
    --*(void *)(v7 + 616);
  }
  if (*((void *)a2 + 11)) {
    fpfs_releaseRenderChain(a1);
  }
  free(a2);
}

uint64_t fpfs_EstablishTimebase(const __CFArray *a1)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = DerivedStorage;
  if (DerivedStorage) {
    uint64_t v4 = *(void *)(DerivedStorage + 800);
  }
  else {
    uint64_t v4 = 0;
  }
  CMClockRef clockOut = 0;
  uint64_t v5 = *(void *)(DerivedStorage + 1048);
  if (!v5)
  {
    uint64_t v6 = 0;
    goto LABEL_14;
  }
  uint64_t v6 = 0;
  while (!*(void *)(v5 + 96))
  {
LABEL_10:
    uint64_t v5 = *(void *)(v5 + 8);
    if (!v5) {
      goto LABEL_14;
    }
  }
  if (*(_DWORD *)(v5 + 32) != 1936684398)
  {
    if (!v6) {
      uint64_t v6 = *(void *)(v5 + 96);
    }
    goto LABEL_10;
  }
  uint64_t v4 = *(void *)(v5 + 96);
LABEL_14:
  if (v4) {
    uint64_t v7 = v4;
  }
  else {
    uint64_t v7 = v6;
  }
  if (!*(unsigned char *)(DerivedStorage + 553))
  {
    int v11 = 0;
    if (v7) {
      goto LABEL_26;
    }
LABEL_33:
    if (FigPreferAudioSessionClock())
    {
      uint64_t v18 = CMBaseObjectGetDerivedStorage();
      if (!*(void *)(v18 + 536))
      {
LABEL_39:
        CMClockRef v25 = clockOut;
        CMClockRef HostTimeClock = CMClockGetHostTimeClock();
        CMClockRef clockOut = HostTimeClock;
        if (HostTimeClock) {
          CFRetain(HostTimeClock);
        }
        if (v25) {
          CFRelease(v25);
        }
        goto LABEL_43;
      }
      uint64_t v19 = v18;
      uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
      int v21 = FigAudioSessionClockCreate(AllocatorForMedia, *(const void **)(v19 + 536), 0, &clockOut);
    }
    else
    {
      CFAllocatorRef v22 = (const __CFAllocator *)FigGetAllocatorForMedia();
      CFStringRef v23 = CFStringCreateWithCString(v22, "VirtualAudioDevice_Default", 0);
      CFAllocatorRef v24 = (const __CFAllocator *)FigGetAllocatorForMedia();
      int v21 = CMAudioDeviceClockCreate(v24, v23, &clockOut);
      if (v23) {
        CFRelease(v23);
      }
    }
    if (!v21) {
      goto LABEL_43;
    }
    goto LABEL_39;
  }
  if (!*(void *)(DerivedStorage + 3168))
  {
    uint64_t v8 = *(void *)DerivedStorage;
    uint64_t v9 = FigGetAllocatorForMedia();
    FigRateMinderCreate(v9, 0, v8, @"PlaylistVsHostTime", 1, (CFTypeRef *)(v3 + 3168));
  }
  Clock = (const void *)FigRateMinderGetClock();
  if (Clock) {
    int v11 = (OpaqueCMClock *)CFRetain(Clock);
  }
  else {
    int v11 = 0;
  }
  CMClockRef clockOut = v11;
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterAddWeakListener();
  if (!v7) {
    goto LABEL_33;
  }
LABEL_26:
  uint64_t v12 = *(void *)(v7 + 32);
  if (!v12) {
    goto LABEL_33;
  }
  if (!v11)
  {
    uint64_t v13 = FigGetAllocatorForMedia();
    uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v12);
    uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 8);
    uint64_t v16 = v15 ? v15 : 0;
    CFArrayRef v17 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CMClockRef *))(v16 + 48);
    if (!v17 || v17(FigBaseObject, @"PreferredClock", v13, &clockOut)) {
      goto LABEL_33;
    }
  }
LABEL_43:
  uint64_t v27 = *(OpaqueCMTimebase **)(v3 + 576);
  uint64_t v28 = clockOut;
  if (v27)
  {
    uint64_t v29 = CMTimebaseSetSourceClock(v27, clockOut);
  }
  else
  {
    uint64_t v30 = CMBaseObjectGetDerivedStorage();
    uint64_t v31 = (CMTimebaseRef *)(v30 + 576);
    *(void *)(v30 + 576) = 0;
    CFAllocatorRef v32 = (const __CFAllocator *)FigGetAllocatorForMedia();
    unsigned int v53 = CMTimebaseCreateWithSourceClock(v32, v28, (CMTimebaseRef *)(v30 + 576));
    if (!v53)
    {
      uint64_t v52 = v7;
      FigNetworkUrgencyMonitorSetTimebase(*(void *)(v30 + 3104), *(void *)(v30 + 576));
      int v33 = *(void **)(v30 + 1048);
      if (v33)
      {
        int v34 = (CMTime *)MEMORY[0x1E4F1F9F8];
        long long v35 = &PerformOneTimeAssetTableInitialization_sAssetTableInit;
        do
        {
          CMTimeEpoch v36 = v33[15];
          if (v36) {
            CMTimebaseAddTimerDispatchSource(*v31, v36);
          }
          uint64_t v37 = v33[14];
          if (v37)
          {
            CMTime v60 = *v34;
            CMTimebaseAddTimerDispatchSource(*(CMTimebaseRef *)(v30 + 576), v37);
            fpfs_scheduleForwardEndTimeForTrack(v30, (uint64_t)v33, (uint64_t)&v60);
            if (*((_DWORD *)v35 + 748))
            {
              unsigned int v59 = 0;
              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              unsigned int v39 = v59;
              if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
                unsigned int v40 = v39;
              }
              else {
                unsigned int v40 = v39 & 0xFFFFFFFE;
              }
              if (v40)
              {
                CMTimeEpoch v41 = *(const void **)v30;
                if (*(void *)v30) {
                  CMTimeEpoch v42 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
                }
                else {
                  CMTimeEpoch v42 = "";
                }
                int v55 = v42;
                if (a1) {
                  char v43 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
                }
                else {
                  char v43 = "";
                }
                int v54 = v43;
                CFArrayRef v44 = a1;
                uint64_t v45 = v33[2];
                CMTime time = v60;
                Float64 Seconds = CMTimeGetSeconds(&time);
                uint64_t v47 = v33[14];
                fpfs_GetTime(v30, (uint64_t)&v57);
                Float64 v48 = CMTimeGetSeconds(&v57);
                double v49 = *(float *)(v30 + 848);
                int v61 = 136317442;
                uint64_t v62 = "fpfs_CreateItemTimebase";
                __int16 v63 = 2048;
                uint64_t v64 = v41;
                __int16 v65 = 2082;
                CMTime v66 = v55;
                __int16 v67 = 2048;
                CFArrayRef v68 = v44;
                __int16 v69 = 2082;
                uint64_t v70 = v54;
                __int16 v71 = 2048;
                uint64_t v72 = v45;
                __int16 v73 = 2048;
                Float64 v74 = Seconds;
                __int16 v75 = 2048;
                uint64_t v76 = v47;
                __int16 v77 = 2048;
                Float64 v78 = v48;
                __int16 v79 = 2048;
                double v80 = v49;
                _os_log_send_and_compose_impl();
                a1 = v44;
                uint64_t v31 = (CMTimebaseRef *)(v30 + 576);
                int v34 = (CMTime *)MEMORY[0x1E4F1F9F8];
                long long v35 = &PerformOneTimeAssetTableInitialization_sAssetTableInit;
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
          }
          int v33 = (void *)v33[1];
        }
        while (v33);
      }
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterAddWeakListener();
      uint64_t v50 = CMBaseObjectGetDerivedStorage();
      if (fpfs_getNext(v50, 0) == a1)
      {
        *(unsigned char *)(v30 + 469) = 1;
        fpfs_EnqueueNotification(*(const void **)v30, @"TimebaseChanged", a1, 0);
      }
      fpfs_CheckPrebufferedLevels((uint64_t)a1, 0, -1, 0, (uint64_t)&time);
      uint64_t v7 = v52;
    }
    fpfsi_setPlaybackRateMonitorProperty(v30, @"AfmfpbProperty_Timebase", *(void *)(v30 + 576));
    fpfsi_setupCMCDHeaderVendor();
    uint64_t v29 = v53;
  }
  if (clockOut) {
    CFRelease(clockOut);
  }
  if (!v29 && v7 && *(void *)(v7 + 32)) {
    *(unsigned char *)(v7 + 24) = 1;
  }
  return v29;
}

uint64_t fpfs_SynchronousFrameEnqueued(uint64_t a1, const void *a2)
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(result + 51) != 1)
  {
    uint64_t result = FigAtomicIncrement32();
    if ((int)result <= 1)
    {
      fpfs_PostNotificationWhenUnlocked(a2, @"SynchronousFrameEnqueued", a2, 0);
      CFRetain(a2);
      CMNotificationCenterGetDefaultLocalCenter();
      dispatch_get_global_queue(0, 0);
      FigGetAllocatorForMedia();
      return FigDeferNotificationToDispatchQueue();
    }
  }
  return result;
}

void fpfsi_completedDecodeForPreroll(int a1, uint64_t a2, int a3, int a4, CFTypeRef cf)
{
  CFTypeRef cfa = 0;
  CFTypeRef v8 = 0;
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFDictionaryGetTypeID())
    {
      if (!fpfsi_CopyPlayerAndItemFromItemRetainProxy(a2, &v8, &cfa))
      {
        CMBaseObjectGetDerivedStorage();
        FigRetainProxyRetain();
        CMNotificationCenterGetDefaultLocalCenter();
        FigGetAllocatorForMedia();
        FigDeferNotificationToDispatchQueue();
      }
    }
    else
    {
      FigSignalErrorAt();
    }
    if (cfa) {
      CFRelease(cfa);
    }
  }
  else
  {
    FigSignalErrorAt();
  }
  if (v8) {
    CFRelease(v8);
  }
}

uint64_t fpfsi_markerBufferConsumed(int a1, int a2, int a3, const void *a4, CFTypeRef cf)
{
  if (cf && (CFTypeID v6 = CFGetTypeID(cf), v6 == CFDictionaryGetTypeID()))
  {
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    FigRetainProxyRetain();
    if (a4) {
      CFRetain(a4);
    }
    CMNotificationCenterGetDefaultLocalCenter();
    dispatch_get_global_queue(2, 0);
    FigGetAllocatorForMedia();
    return FigDeferNotificationToDispatchQueue();
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void fpfs_RenderPipelineLostDecoderState(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  CFTypeRef v6 = 0;
  CFTypeRef cf = 0;
  if (!fpfsi_CopyPlayerAndItemFromItemRetainProxy(a2, &cf, &v6))
  {
    FigRetainProxyRetain();
    if (a4) {
      CFRetain(a4);
    }
    CMNotificationCenterGetDefaultLocalCenter();
    CFTypeRef v5 = v6;
    CMBaseObjectGetDerivedStorage();
    FigGetAllocatorForMedia();
    FigDeferNotificationToDispatchQueue();
    if (cf) {
      CFRelease(cf);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
}

uint64_t fpfsi_RemoveAudioRenderChainListeners()
{
  CMBaseObjectGetDerivedStorage();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();

  return FigNotificationCenterRemoveWeakListener();
}

uint64_t fpfs_StealBuffer(CMBufferRef buf, CMBufferQueueRef queue)
{
  return CMBufferQueueEnqueue(queue, buf);
}

void fpfs_SendBufferQueueToChomper(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (v3)
  {
    uint64_t v4 = v3;
    *uint64_t v3 = a2;
    uint64_t v5 = FigOSTransactionCreate();
    v4[1] = v5;
    if (v5)
    {
      global_queue = dispatch_get_global_queue(-2, 0);
      dispatch_async_f(global_queue, v4, (dispatch_function_t)fpfs_BufferChomper);
      return;
    }
    FigSignalErrorAt();
    free(v4);
  }
  else
  {
    FigSignalErrorAt();
  }

  FigBufferQueueRelease();
}

void fps_HandleRateDelta(int a1, CFTypeRef cf)
{
  CFTypeRef cfa = 0;
  CFTypeRef v4 = 0;
  if (cf) {
    CFRetain(cf);
  }
  if (fpfsi_CopyPlayerAndItemFromItemRetainProxy((uint64_t)cf, &v4, &cfa))
  {
    FigRetainProxyRelease();
  }
  else
  {
    CMBaseObjectGetDerivedStorage();
    CMNotificationCenterGetDefaultLocalCenter();
    FigGetAllocatorForMedia();
    FigDeferNotificationToDispatchQueue();
    if (cfa) {
      CFRelease(cfa);
    }
    if (v4) {
      CFRelease(v4);
    }
  }
}

uint64_t FigRenderPipelineCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(a1);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  int v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 48);
  if (!v10) {
    return 4294954514;
  }

  return v10(FigBaseObject, a2, a3, a4);
}

void fpfsi_deferredHandleRateDelta(uint64_t a1, const void *a2)
{
  CFTypeRef v6 = 0;
  CFTypeRef cf = 0;
  if (fpfsi_CopyPlayerAndItemFromItemRetainProxyAndLockPlayer((uint64_t)a2, &v6, &cf))
  {
    CFTypeRef v5 = v6;
    if (v6) {
LABEL_5:
    }
      CFRelease(v5);
  }
  else
  {
    CFTypeRef v3 = cf;
    for (uint64_t i = *(void *)(CMBaseObjectGetDerivedStorage() + 1048); i; uint64_t i = *(void *)(i + 8))
      fpfs_GetRelativeRateAndSetRate2OnRenderPipelines((uint64_t)v3, i);
    CFTypeRef v5 = v6;
    fpfs_UnlockAndPostNotificationsWithCaller(v6);
    if (v5) {
      goto LABEL_5;
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (a2)
  {
    CFRelease(a2);
  }
}

uint64_t fpfsi_CopyPlayerAndItemFromItemRetainProxyAndLockPlayer(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  CFTypeRef v3 = a3;
  uint64_t v5 = fpfsi_CopyPlayerAndItemFromItemRetainProxy(a1, 0, a3);
  if (v5) {
    return v5;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = 5;
  while (1)
  {
    MEMORY[0x19970E910](*(void *)(DerivedStorage + 8));
    if (*(unsigned char *)(DerivedStorage + 24))
    {
      MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
      CFTypeRef v11 = *v3;
      uint64_t v12 = 4294954511;
      if (!*v3) {
        return v12;
      }
      goto LABEL_18;
    }
    CFTypeRef v8 = CFRetain(*(CFTypeRef *)DerivedStorage);
    MEMORY[0x19970E930](*(void *)(DerivedStorage + 8));
    fpfs_LockMutexWithCaller(v8);
    if (v8 == *(CFTypeRef *)DerivedStorage) {
      break;
    }
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    fpfs_UnlockWithCaller();
    if (v8) {
      CFRelease(v8);
    }
    if (!--v7)
    {
      int v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      CFTypeRef v11 = *v3;
      uint64_t v12 = 4294950069;
      if (*v3)
      {
LABEL_18:
        CFRelease(v11);
        *CFTypeRef v3 = 0;
        return v12;
      }
      return v12;
    }
  }
  *a2 = v8;
  if (!*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 51) && !FigRetainProxyIsInvalidated()) {
    return 0;
  }
  if (*v3)
  {
    CFRelease(*v3);
    *CFTypeRef v3 = 0;
  }
  fpfs_UnlockWithCaller();
  CFTypeRef v11 = *a2;
  uint64_t v12 = 4294954511;
  CFTypeRef v3 = a2;
  if (*a2) {
    goto LABEL_18;
  }
  return v12;
}

uint64_t fpfs_GetRelativeRateAndSetRate2OnRenderPipelines(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  float valuePtr = 0.0;
  if (*(void *)(CMBaseObjectGetDerivedStorage() + 3168)
    && *(_DWORD *)(a2 + 32) == 1936684398
    && (uint64_t v3 = *(void *)(a2 + 96)) != 0)
  {
    uint64_t v4 = *(void *)(v3 + 32);
    uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
    uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v4);
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    CFTypeRef v11 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v8 + 48);
    if (v11)
    {
      uint64_t v12 = v11(FigBaseObject, @"PreferredClock", AllocatorForMedia, &cf);
      if (v12)
      {
        uint64_t v9 = v12;
      }
      else
      {
        Clock = (const void *)FigRateMinderGetClock();
        Relativedouble Rate = CMSyncGetRelativeRate(Clock, cf);
        float valuePtr = RelativeRate;
        CFNumberRef v15 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, &valuePtr);
        uint64_t v16 = FigRenderPipelineGetFigBaseObject(*(void *)(*(void *)(a2 + 96) + 32));
        uint64_t v17 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v17) {
          uint64_t v18 = v17;
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = *(uint64_t (**)(uint64_t, __CFString *, CFNumberRef))(v18 + 56);
        if (v19) {
          uint64_t v9 = v19(v16, @"FAQRate2", v15);
        }
        else {
          uint64_t v9 = 4294954514;
        }
        if (v15) {
          CFRelease(v15);
        }
      }
    }
    else
    {
      uint64_t v9 = 4294954514;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

void fpfs_UnlockWithCaller()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = *(void *)(DerivedStorage + 8);
  BOOL v3 = __OFSUB__(v1, 1);
  BOOL v2 = v1 - 1 < 0;
  uint64_t v4 = v1 - 1;
  if (v2 == v3) {
    *(void *)(DerivedStorage + 8) = v4;
  }

  JUMPOUT(0x19970E2B0);
}

uint64_t FigRenderPipelineSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(a1);
  uint64_t VTable = CMBaseObjectGetVTable();
  uint64_t v9 = *(void *)(VTable + 8);
  uint64_t result = VTable + 8;
  uint64_t v8 = v9;
  if (v9) {
    uint64_t v10 = v8;
  }
  else {
    uint64_t v10 = 0;
  }
  CFTypeRef v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 56);
  if (v11)
  {
    return v11(FigBaseObject, a2, a3);
  }
  return result;
}

uint64_t fpfs_scheduleForwardEndTimeForTrack(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = MEMORY[0x1E4F1F9F8];
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CMTimeValue v23 = *MEMORY[0x1E4F1F9F8];
  CMTimeScale v24 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  if (*(void *)(a1 + 576) && (uint64_t v5 = (dispatch_object_t *)(a2 + 112), *(void *)(a2 + 112)))
  {
    if ((*(_DWORD *)(a1 + 1388) & 0x1D) == 1
      && (uint64_t v8 = (CMTimeValue *)(a1 + 1376),
          CMTime time1 = *(CMTime *)(a1 + 1376),
          CMTime time2 = *(CMTime *)(a2 + 216),
          CMTimeCompare(&time1, &time2) <= 0))
    {
      CMTimeValue v23 = *v8;
      CMTimeScale v24 = *(_DWORD *)(a1 + 1384);
      CMTimeFlags v9 = *(_DWORD *)(a1 + 1388);
      CMTimeEpoch v10 = *(void *)(a1 + 1392);
      uint64_t v13 = *(OpaqueCMTimebase **)(a1 + 576);
      uint64_t v14 = *v5;
      time1.unsigned int value = *v8;
      time1.CMTimeScale timescale = *(_DWORD *)(a1 + 1384);
      time1.CMTimeFlags flags = v9;
      time1.CMTimeEpoch epoch = v10;
      uint64_t result = CMTimebaseSetTimerDispatchSourceNextFireTime(v13, v14, &time1, 1u);
      if (result) {
        return result;
      }
    }
    else if (*(unsigned char *)(a2 + 182))
    {
      CMTimeValue v23 = *(void *)(a2 + 216);
      CMTimeFlags v9 = *(_DWORD *)(a2 + 228);
      CMTimeScale v24 = *(_DWORD *)(a2 + 224);
      CMTimeEpoch v10 = *(void *)(a2 + 232);
      CFTypeRef v11 = *(OpaqueCMTimebase **)(a1 + 576);
      uint64_t v12 = *(NSObject **)(a2 + 112);
      time1.unsigned int value = *(void *)(a2 + 216);
      time1.CMTimeScale timescale = *(_DWORD *)(a2 + 224);
      time1.CMTimeFlags flags = v9;
      time1.CMTimeEpoch epoch = v10;
      CMTimebaseSetTimerDispatchSourceNextFireTime(v11, v12, &time1, 1u);
    }
    else
    {
      CMTimeFlags v9 = *(_DWORD *)(v3 + 12);
      CMTimeEpoch v10 = *(void *)(v3 + 16);
      fpfs_ReleaseAndClearTimebaseTimer(*(OpaqueCMTimebase **)(a1 + 576), v5);
    }
    if (v9)
    {
      CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      time1.unsigned int value = v23;
      time1.CMTimeScale timescale = v24;
      time1.CMTimeFlags flags = v9;
      time1.CMTimeEpoch epoch = v10;
      CFStringRef v17 = CMTimeCopyDescription(AllocatorForMedia, &time1);
      if (dword_1E9350BB0)
      {
        int v20 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      if (v17) {
        CFRelease(v17);
      }
    }
    uint64_t result = 0;
    if (a3)
    {
      *(void *)a3 = v23;
      *(_DWORD *)(a3 + 8) = v24;
      *(_DWORD *)(a3 + 12) = v9;
      *(void *)(a3 + 16) = v10;
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

uint64_t fpfsi_HandleTimebaseEffectiveRateChanged(uint64_t a1, const void *a2)
{
  CMBaseObjectGetDerivedStorage();
  if (dword_1E9350BB0)
  {
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (a2) {
    CFRetain(a2);
  }
  CMNotificationCenterGetDefaultLocalCenter();
  FigGetAllocatorForMedia();
  return FigDeferNotificationToDispatchQueue();
}

uint64_t fpfs_EnqueueNotification(const void *a1, const void *a2, const void *a3, const void *a4)
{
  fpfs_LockMutexWithCaller(a1);
  uint64_t v8 = fpfs_EnqueueNotificationWithoutLocking((uint64_t)a1, a2, a3, a4);
  fpfs_UnlockAndPostNotificationsWithCaller(a1);
  return v8;
}

void fpfs_CheckPrebufferedLevels(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v281 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v216 = *(const void **)DerivedStorage;
  uint64_t v9 = CMBaseObjectGetDerivedStorage();
  memset(&v255, 0, sizeof(v255));
  memset(&v254, 0, sizeof(v254));
  memset(&v253, 0, sizeof(v253));
  memset(&v252, 0, sizeof(v252));
  uint64_t v260 = 0;
  memset(v259, 0, sizeof(v259));
  CMTimeValue value = *MEMORY[0x1E4F1FA10];
  CMTimeFlags v10 = *(_DWORD *)(MEMORY[0x1E4F1FA10] + 12);
  CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1FA10] + 8);
  CMTimeEpoch v11 = *(void *)(MEMORY[0x1E4F1FA10] + 16);
  *(_OWORD *)&v251.CMTimeValue value = *MEMORY[0x1E4F1FA10];
  CMTimeEpoch v233 = v11;
  v251.CMTimeEpoch epoch = v11;
  uint64_t v12 = *(void *)(DerivedStorage + 1704);
  uint64_t v13 = MEMORY[0x1E4F1FA48];
  uint64_t v221 = v9;
  if (!v12)
  {
    *(_OWORD *)a5 = *MEMORY[0x1E4F1FA48];
    *(void *)(a5 + 16) = *(void *)(v13 + 16);
LABEL_5:
    int v15 = *(_DWORD *)(DerivedStorage + 2240);
    int v16 = *(_DWORD *)(DerivedStorage + 2248);
    int v17 = *(_DWORD *)(DerivedStorage + 2268);
    if (v17 >= 1 && *(unsigned char *)(DerivedStorage + 2264))
    {
      if (*(double *)(DerivedStorage + 2272) <= 0.0)
      {
        if (v15 <= v17) {
          int v15 = *(_DWORD *)(DerivedStorage + 2268);
        }
      }
      else
      {
        CMTimeFlags v218 = v10;
        v280.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
        v280.CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
        time.CMTimeValue value = v280.value;
        time.CMTimeScale timescale = v280.timescale;
        if (*(unsigned char *)(DerivedStorage + 236))
        {
          fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)time1);
          v280.CMTimeValue value = time1[0].value;
          CMTimeFlags flags = time1[0].flags;
          v280.CMTimeScale timescale = time1[0].timescale;
          CMTimeEpoch epoch = time1[0].epoch;
          time.CMTimeValue value = *(void *)(DerivedStorage + 224);
          CMTimeFlags v20 = *(_DWORD *)(DerivedStorage + 236);
          time.CMTimeScale timescale = *(_DWORD *)(DerivedStorage + 232);
          CMTimeEpoch v21 = *(void *)(DerivedStorage + 240);
        }
        else
        {
          CMTimeFlags flags = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
          CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
          CMTimeFlags v20 = flags;
          CMTimeEpoch v21 = epoch;
        }
        if (flags & 1) != 0 && (v20)
        {
          time1[0].CMTimeValue value = v280.value;
          *(void *)&time1[0].CMTimeScale timescale = __PAIR64__(flags, v280.timescale);
          time1[0].CMTimeEpoch epoch = epoch;
          *(void *)CMTime time2 = time.value;
          *(_DWORD *)&time2[8] = time.timescale;
          *(_DWORD *)&time2[12] = v20;
          *(void *)&time2[16] = v21;
          if (CMTimeCompare(time1, (CMTime *)time2) >= 1)
          {
            double v23 = *(double *)(DerivedStorage + 2272);
            *(void *)CMTime time2 = v280.value;
            *(_DWORD *)&time2[8] = v280.timescale;
            *(_DWORD *)&time2[12] = flags;
            *(void *)&time2[16] = epoch;
            *(void *)CMTime rhs = time.value;
            *(void *)&rhs[8] = __PAIR64__(v20, time.timescale);
            *(void *)&rhs[16] = v21;
            CMTimeSubtract(time1, (CMTime *)time2, (CMTime *)rhs);
            double Seconds = CMTimeGetSeconds(time1);
            int v25 = *(_DWORD *)(DerivedStorage + 2268);
            if (v15 < v25)
            {
              float v26 = v23 * Seconds;
              if (v25 >= (int)(float)((float)v15 + v26)) {
                int v15 = (int)(float)((float)v15 + v26);
              }
              else {
                int v15 = *(_DWORD *)(DerivedStorage + 2268);
              }
            }
          }
        }
        CMTimeFlags v10 = v218;
      }
    }
    else if (*(_DWORD *)(v9 + 752))
    {
      if (v15 >= 120) {
        int v16 = 120;
      }
      else {
        int v16 = *(_DWORD *)(DerivedStorage + 2240);
      }
    }
    else
    {
      if (v15 >= 120) {
        int v22 = 120;
      }
      else {
        int v22 = *(_DWORD *)(DerivedStorage + 2240);
      }
      if (*(_DWORD *)(DerivedStorage + 2244)) {
        int v16 = v22;
      }
    }
    int v220 = 1;
    CMTimeMake(time1, v16, 1);
    CMTime v255 = time1[0];
    CMTimeMake(time1, v15, 1);
    CMTime v254 = time1[0];
    goto LABEL_31;
  }
  int IsIFrameOnly = FigAlternateIsIFrameOnly(v12);
  *(_OWORD *)a5 = *(_OWORD *)v13;
  *(void *)(a5 + 16) = *(void *)(v13 + 16);
  if (!IsIFrameOnly) {
    goto LABEL_5;
  }
  CMTimeMake(&v255, (uint64_t)(fabsf(*(float *)(v9 + 108)) * 5.0), 1);
  CMTimeMake(&v254, (uint64_t)(fabsf(*(float *)(v9 + 108)) * 10.0), 1);
  int v220 = 0;
LABEL_31:
  uint64_t v27 = 0;
  int v237 = 0;
  uint64_t v28 = (CMTime *)v259;
  do
  {
    if (fpfs_SubstreamNeedsFlowControl(DerivedStorage, v27))
    {
      fpfs_CurrentSubStreamBufferedDuration(v27, (uint64_t)time1);
      *uint64_t v28 = time1[0];
      if (a3 == v27)
      {
        *(_OWORD *)a5 = *(_OWORD *)&v28->value;
        *(void *)(a5 + 16) = v28->epoch;
      }
      time1[0] = v251;
      *(_OWORD *)CMTime time2 = *(_OWORD *)&v28->value;
      *(void *)&time2[16] = v28->epoch;
      if (CMTimeCompare(time1, (CMTime *)time2) >= 1) {
        CMTime v251 = *v28;
      }
      v237 |= 1 << v27;
      time1[0] = *v28;
      *(CMTime *)CMTime time2 = v255;
      if ((CMTimeCompare(time1, (CMTime *)time2) & 0x80000000) == 0)
      {
        time1[0].CMTimeValue value = value;
        *(void *)&time1[0].CMTimeScale timescale = __PAIR64__(v10, timescale);
        time1[0].CMTimeEpoch epoch = v233;
        *(_OWORD *)CMTime time2 = *(_OWORD *)&v28->value;
        *(void *)&time2[16] = v28->epoch;
        if (CMTimeCompare(time1, (CMTime *)time2) >= 1)
        {
          CMTimeValue value = v28->value;
          CMTimeFlags v10 = v28->flags;
          CMTimeScale timescale = v28->timescale;
          CMTimeEpoch v233 = v28->epoch;
        }
      }
    }
    ++v27;
    ++v28;
  }
  while (v27 != 3);
  int v29 = *(_DWORD *)(v221 + 752);
  int v30 = *(_DWORD *)(DerivedStorage + 2244);
  if (v29 >= v30) {
    int v31 = *(_DWORD *)(DerivedStorage + 2244);
  }
  else {
    int v31 = *(_DWORD *)(v221 + 752);
  }
  if (v30) {
    int v32 = *(_DWORD *)(DerivedStorage + 2244);
  }
  else {
    int v32 = 50;
  }
  if (!v30) {
    int v31 = *(_DWORD *)(v221 + 752);
  }
  if (!v29) {
    int v31 = v32;
  }
  if (v30 | v29) {
    BOOL v33 = v31 <= 50;
  }
  else {
    BOOL v33 = 0;
  }
  int v34 = v220;
  if (v33) {
    int v34 = 0;
  }
  LOBYTE(v35) = 1;
  int v36 = v237;
  if (v34 == 1)
  {
    uint64_t v37 = *(void *)(DerivedStorage + 1048);
    if (v37)
    {
      while (1)
      {
        int v35 = *(_DWORD *)(v37 + 152);
        if (v35 == 1) {
          break;
        }
        uint64_t v37 = *(void *)(v37 + 8);
        if (!v37) {
          goto LABEL_60;
        }
      }
    }
    else
    {
LABEL_60:
      memset(time1, 0, 24);
      CMTimeMake(time1, 10, 1);
      if (*(int *)(DerivedStorage + 2268) < 1 || !*(unsigned char *)(DerivedStorage + 2264))
      {
        *(void *)CMTime time2 = value;
        *(_DWORD *)&time2[8] = timescale;
        *(_DWORD *)&time2[12] = v10;
        *(void *)&time2[16] = v233;
        *(CMTime *)CMTime rhs = time1[0];
        CMTimeSubtract(&v250, (CMTime *)time2, (CMTime *)rhs);
        *(CMTime *)CMTime time2 = v255;
        if (CMTimeCompare((CMTime *)time2, &v250) < 0)
        {
          *(void *)CMTime rhs = value;
          *(void *)&rhs[8] = __PAIR64__(v10, timescale);
          *(void *)&rhs[16] = v233;
          CMTime v280 = time1[0];
          CMTimeSubtract((CMTime *)time2, (CMTime *)rhs, &v280);
          CMTime v255 = *(CMTime *)time2;
        }
      }
      LOBYTE(v35) = 0;
    }
  }
  char v224 = v35;
  uint64_t v38 = 0;
  int v226 = 0;
  int v227 = 0;
  unsigned int v39 = (CMTime *)v259;
  uint64_t v235 = DerivedStorage;
  long long v236 = (const void *)a1;
  CMTimeFlags v219 = v10;
  do
  {
    int v40 = 1 << v38;
    if (((1 << v38) & v36) != 0)
    {
      time1[0] = *v39;
      *(CMTime *)CMTime time2 = v255;
      if (CMTimeCompare(time1, (CMTime *)time2) < 0)
      {
        if (a4 && dword_1E9350BB0)
        {
          *(_DWORD *)CMTime rhs = 0;
          LOBYTE(v280.CFDictionarySetValue(theDict, key, value) = 0;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v47 = *(_DWORD *)rhs;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, v280.value)) {
            unsigned int v48 = v47;
          }
          else {
            unsigned int v48 = v47 & 0xFFFFFFFE;
          }
          if (v48)
          {
            double v49 = *(const void **)DerivedStorage;
            if (*(void *)DerivedStorage) {
              uint64_t v50 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
            }
            else {
              uint64_t v50 = "";
            }
            if (v236) {
              int v54 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
            }
            else {
              int v54 = "";
            }
            time1[0] = *v39;
            Float64 v55 = CMTimeGetSeconds(time1);
            time1[0] = v255;
            Float64 v56 = CMTimeGetSeconds(time1);
            *(_DWORD *)CMTime time2 = 136316930;
            *(void *)&time2[4] = "fpfs_CheckPrebufferedLevels";
            *(_WORD *)&time2[12] = 2048;
            *(void *)&time2[14] = v49;
            *(_WORD *)&time2[22] = 2082;
            *(void *)&time2[24] = v50;
            *(_WORD *)unsigned int v262 = 2048;
            *(void *)&v262[2] = v236;
            *(_WORD *)&v262[10] = 2082;
            *(void *)&v262[12] = v54;
            __int16 v263 = 1024;
            *(_DWORD *)v264 = v38;
            *(_WORD *)&v264[4] = 2048;
            *(Float64 *)&v264[6] = v55;
            *(_WORD *)&v264[14] = 2048;
            *(Float64 *)&v264[16] = v56;
            _os_log_send_and_compose_impl();
            uint64_t DerivedStorage = v235;
            int v36 = v237;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          a1 = (uint64_t)v236;
        }
        v226 |= v40;
      }
      else
      {
        time1[0] = *v39;
        *(CMTime *)CMTime time2 = v254;
        if ((CMTimeCompare(time1, (CMTime *)time2) & 0x80000000) == 0)
        {
          if (a4 && dword_1E9350BB0)
          {
            *(_DWORD *)CMTime rhs = 0;
            LOBYTE(v280.CFDictionarySetValue(theDict, key, value) = 0;
            CMTimeEpoch v41 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v42 = *(_DWORD *)rhs;
            if (os_log_type_enabled(v41, v280.value)) {
              unsigned int v43 = v42;
            }
            else {
              unsigned int v43 = v42 & 0xFFFFFFFE;
            }
            if (v43)
            {
              CFArrayRef v44 = *(const void **)DerivedStorage;
              if (*(void *)DerivedStorage) {
                uint64_t v45 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
              }
              else {
                uint64_t v45 = "";
              }
              if (v236) {
                uint64_t v51 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
              }
              else {
                uint64_t v51 = "";
              }
              time1[0] = *v39;
              Float64 v52 = CMTimeGetSeconds(time1);
              time1[0] = v254;
              Float64 v53 = CMTimeGetSeconds(time1);
              *(_DWORD *)CMTime time2 = 136316930;
              *(void *)&time2[4] = "fpfs_CheckPrebufferedLevels";
              *(_WORD *)&time2[12] = 2048;
              *(void *)&time2[14] = v44;
              *(_WORD *)&time2[22] = 2082;
              *(void *)&time2[24] = v45;
              *(_WORD *)unsigned int v262 = 2048;
              *(void *)&v262[2] = v236;
              *(_WORD *)&v262[10] = 2082;
              *(void *)&v262[12] = v51;
              __int16 v263 = 1024;
              *(_DWORD *)v264 = v38;
              *(_WORD *)&v264[4] = 2048;
              *(Float64 *)&v264[6] = v52;
              *(_WORD *)&v264[14] = 2048;
              *(Float64 *)&v264[16] = v53;
              _os_log_send_and_compose_impl();
              uint64_t DerivedStorage = v235;
              int v36 = v237;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            a1 = (uint64_t)v236;
          }
          v227 |= v40;
        }
      }
    }
    ++v38;
    ++v39;
  }
  while (v38 != 3);
  if (v224)
  {
    int v57 = v227;
    goto LABEL_191;
  }
  uint64_t v58 = CMBaseObjectGetDerivedStorage();
  uint64_t v59 = 0;
  unint64_t v60 = 0;
  int v222 = 0;
  uint64_t v215 = *(void *)(v58 + 544);
  uint64_t v249 = 0;
  long long v225 = (uint64_t *)v58;
  do
  {
    if ((*(_DWORD *)(v58 + 1096) & (1 << v59)) == 0) {
      goto LABEL_137;
    }
    unint64_t v230 = v60;
    uint64_t v61 = CMBaseObjectGetDerivedStorage();
    uint64_t v62 = CMBaseObjectGetDerivedStorage();
    fpfs_GetNextTimeToPlay(v61, 1, (uint64_t)time1);
    uint64_t v63 = *(void *)(v61 + 1048);
    if (!v63)
    {
      *(&duration.value + v59) = 0;
      goto LABEL_135;
    }
    unint64_t v64 = 0;
    do
    {
      if (v59 == *(unsigned __int8 *)(v63 + 180))
      {
        __int16 v65 = *(opaqueCMBufferQueue **)(v63 + 80);
        if (v65)
        {
          if (CMBufferQueueGetHead(v65))
          {
            CMTime v66 = *(opaqueCMBufferQueue **)(v63 + 80);
            if (v66)
            {
              CMBufferQueueGetMinPresentationTimeStamp((CMTime *)time2, v66);
            }
            else
            {
              *(_OWORD *)CMTime time2 = *MEMORY[0x1E4F1F9F8];
              *(void *)&time2[16] = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
            }
            CFTypeRef cf = *(CFTypeRef *)time2;
            CMTimeFlags v67 = *(_DWORD *)&time2[12];
            CMTimeScale v273 = *(_DWORD *)&time2[8];
            CMTimeEpoch v68 = *(void *)&time2[16];
            CMTimeValue v274 = *(void *)(v63 + 216);
            CMTimeScale v275 = *(_DWORD *)(v63 + 224);
            if ((*(_DWORD *)(v63 + 140) & 0x1D) != 1
              || (time2[12] & 0x1D) != 1
              || (int v69 = *(_DWORD *)(v63 + 228), (v69 & 0x1D) != 1))
            {
              v64 += CMBufferQueueGetTotalSize(*(CMBufferQueueRef *)(v63 + 80));
              goto LABEL_129;
            }
            uint64_t v70 = *(void *)(v63 + 232);
            *(void *)CMTime time2 = *(void *)(v63 + 216);
            *(_DWORD *)&time2[8] = *(_DWORD *)(v63 + 224);
            *(_DWORD *)&time2[12] = v69;
            *(void *)&time2[16] = v70;
            v280.CMTimeValue value = (CMTimeValue)cf;
            v280.CMTimeScale timescale = v273;
            v280.CMTimeFlags flags = v67;
            v280.CMTimeEpoch epoch = v68;
            CMTimeSubtract((CMTime *)rhs, (CMTime *)time2, &v280);
            double v71 = CMTimeGetSeconds((CMTime *)rhs);
            if (*(float *)(v62 + 108) >= 0.0)
            {
              *(void *)CMTime time2 = v274;
              *(_DWORD *)&time2[8] = v275;
              *(_DWORD *)&time2[12] = v69;
              *(void *)&time2[16] = v70;
              CMTime v280 = time1[0];
              if (CMTimeCompare((CMTime *)time2, &v280) < 1 || v71 <= 0.0) {
                goto LABEL_128;
              }
              *(void *)CMTime time2 = cf;
              *(_DWORD *)&time2[8] = v273;
              *(_DWORD *)&time2[12] = v67;
              *(void *)&time2[16] = v68;
              CMTime v280 = time1[0];
              int32_t v76 = CMTimeCompare((CMTime *)time2, &v280);
              size_t TotalSize = CMBufferQueueGetTotalSize(*(CMBufferQueueRef *)(v63 + 80));
              if (v76 < 0)
              {
                double v74 = (double)TotalSize;
                *(void *)CMTime time2 = v274;
                *(_DWORD *)&time2[8] = v275;
                *(_DWORD *)&time2[12] = v69;
                *(void *)&time2[16] = v70;
                CMTime v280 = time1[0];
                CMTimeSubtract(&time, (CMTime *)time2, &v280);
                p_CMTime time = &time;
                goto LABEL_127;
              }
            }
            else
            {
              *(void *)CMTime time2 = v274;
              *(_DWORD *)&time2[8] = v275;
              *(_DWORD *)&time2[12] = v69;
              *(void *)&time2[16] = v70;
              CMTime v280 = time1[0];
              if ((CMTimeCompare((CMTime *)time2, &v280) & 0x80000000) == 0 || v71 <= 0.0) {
                goto LABEL_128;
              }
              *(void *)CMTime time2 = cf;
              *(_DWORD *)&time2[8] = v273;
              *(_DWORD *)&time2[12] = v67;
              *(void *)&time2[16] = v68;
              CMTime v280 = time1[0];
              int32_t v72 = CMTimeCompare((CMTime *)time2, &v280);
              size_t TotalSize = CMBufferQueueGetTotalSize(*(CMBufferQueueRef *)(v63 + 80));
              if (v72 >= 1)
              {
                double v74 = (double)TotalSize;
                *(void *)CMTime time2 = v274;
                *(_DWORD *)&time2[8] = v275;
                *(_DWORD *)&time2[12] = v69;
                *(void *)&time2[16] = v70;
                CMTime v280 = time1[0];
                CMTimeSubtract(&v256, (CMTime *)time2, &v280);
                p_CMTime time = &v256;
LABEL_127:
                unint64_t v64 = (unint64_t)(CMTimeGetSeconds(p_time) * v74 / v71 + (double)v64);
                goto LABEL_128;
              }
            }
            v64 += TotalSize;
LABEL_128:
            uint64_t DerivedStorage = v235;
          }
        }
      }
LABEL_129:
      uint64_t v63 = *(void *)(v63 + 8);
    }
    while (v63);
    *(&duration.value + v59) = v64;
    if (v64)
    {
      v222 |= 1 << v59;
      goto LABEL_136;
    }
LABEL_135:
    unint64_t v64 = 0;
LABEL_136:
    int v36 = v237;
    uint64_t v58 = (uint64_t)v225;
    unint64_t v60 = v64 + v230;
LABEL_137:
    ++v59;
  }
  while (v59 != 3);
  uint64_t v77 = v221;
  if (((*(_DWORD *)(v58 + 1096) ^ v222) & 7) == 0)
  {
    BOOL v80 = v60 >= *(void *)(v58 + 536) && v215 == 0;
    a1 = (uint64_t)v236;
    if (v80)
    {
      int v78 = 0;
      int v79 = 0;
      goto LABEL_182;
    }
    uint64_t v81 = 0;
    double v82 = 0.0;
    uint64_t v83 = (CMTime *)v259;
    do
    {
      if (fpfs_SubstreamNeedsFlowControl(v58, v81))
      {
        unint64_t v84 = *(&duration.value + v81);
        if (v84)
        {
          time1[0] = *v83;
          double v85 = (double)v84 * 8.0 / CMTimeGetSeconds(time1);
        }
        else
        {
          double v85 = 0.0;
        }
        *(double *)&rhs[8 * v81] = v85;
        double v82 = v82 + v85;
      }
      ++v81;
      ++v83;
    }
    while (v81 != 3);
    uint64_t v86 = 0;
    uint64_t v87 = (CMTime *)v259;
    while (1)
    {
      if (fpfs_SubstreamNeedsFlowControl(v58, v86))
      {
        CMTimeMake(&v280, 900, 1);
        time1[0] = *v87;
        if (CMTimeCompare(time1, &v280) < 0) {
          break;
        }
      }
LABEL_179:
      ++v86;
      ++v87;
      uint64_t v58 = (uint64_t)v225;
      if (v86 == 3)
      {
        int v79 = HIDWORD(v249);
        int v78 = v249;
        uint64_t DerivedStorage = v235;
        uint64_t v77 = v221;
        goto LABEL_182;
      }
    }
    double v88 = *(double *)&rhs[8 * v86];
    unint64_t v89 = (unint64_t)(v88 * (double)(unint64_t)v225[67] / v82);
    unint64_t v90 = (unint64_t)(v88 * (double)(unint64_t)v225[68] / v82);
    unint64_t v91 = *(&duration.value + v86);
    if (v91 >= v89)
    {
      if (!v215 || v91 <= v90)
      {
LABEL_160:
        if (dword_1E9350BB0 >= 3)
        {
          LODWORD(time.CFDictionarySetValue(theDict, key, value) = 0;
          LOBYTE(v256.CFDictionarySetValue(theDict, key, value) = 0;
          uint64_t v93 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v94 = time.value;
          if (os_log_type_enabled(v93, v256.value)) {
            unsigned int v95 = v94;
          }
          else {
            unsigned int v95 = v94 & 0xFFFFFFFE;
          }
          if (v95)
          {
            uint64_t v96 = *v225;
            if (*v225) {
              uint64_t v97 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
            }
            else {
              uint64_t v97 = "";
            }
            long long v223 = v97;
            if (v236) {
              uint64_t v98 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
            }
            else {
              uint64_t v98 = "";
            }
            time1[0] = *v87;
            double v99 = CMTimeGetSeconds(time1);
            *(_DWORD *)CMTime time2 = 136317954;
            uint64_t v100 = "Above";
            if (v91 >= v89) {
              uint64_t v101 = "Above";
            }
            else {
              uint64_t v101 = "Below";
            }
            *(void *)&time2[4] = "fpfs_AdjustBufferingForMemoryLimits";
            if (v91 < v90) {
              uint64_t v100 = "Below";
            }
            *(_WORD *)&time2[12] = 2048;
            *(void *)&time2[14] = v96;
            *(_WORD *)&time2[22] = 2082;
            *(void *)&time2[24] = v223;
            *(_WORD *)unsigned int v262 = 2048;
            *(void *)&v262[2] = v236;
            *(_WORD *)&v262[10] = 2082;
            *(void *)&v262[12] = v98;
            __int16 v263 = 1024;
            *(_DWORD *)v264 = v86;
            *(_WORD *)&v264[4] = 2048;
            *(double *)&v264[6] = v99;
            *(_WORD *)&v264[14] = 2048;
            *(void *)&v264[16] = v91;
            *(_WORD *)&v264[24] = 2080;
            *(void *)&v264[26] = v101;
            __int16 v265 = 2048;
            unint64_t v266 = v89;
            __int16 v267 = 2080;
            Float64 v268 = v100;
            __int16 v269 = 2048;
            unint64_t v270 = v90;
            _os_log_send_and_compose_impl();
            int v36 = v237;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          a1 = (uint64_t)v236;
        }
        goto LABEL_179;
      }
      uint64_t v92 = &v249;
    }
    else
    {
      uint64_t v92 = (uint64_t *)((char *)&v249 + 4);
    }
    *(_DWORD *)v92 |= 1 << v86;
    goto LABEL_160;
  }
  int v78 = 0;
  int v79 = 0;
  a1 = (uint64_t)v236;
LABEL_182:
  int v102 = v78 & ~v226 | v227;
  if (*(_DWORD *)(v77 + 752) || (int v103 = v79, *(_DWORD *)(DerivedStorage + 2244))) {
    int v103 = v79 & ~v102;
  }
  int v104 = v79 | v227;
  int v105 = v102 & ~v103;
  if (*(int *)(DerivedStorage + 2268) <= 0)
  {
    int v107 = v36 & ~(v226 | v104);
  }
  else
  {
    int v106 = v36 & ~(v226 | v104);
    if (*(unsigned char *)(DerivedStorage + 2264)) {
      int v107 = 0;
    }
    else {
      int v107 = v106;
    }
  }
  int v57 = v107 | v105;
LABEL_191:
  uint64_t v108 = MEMORY[0x1E4F1F9F8];
  CMTimeValue v274 = *MEMORY[0x1E4F1F9F8];
  CMTimeScale v275 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  if (fpfsi_PlaybackHasBufferedBeyondForwardEndTime(a1))
  {
    fpfsi_MapEndTimeFromTargetToSource(DerivedStorage, (uint64_t)time1);
    goto LABEL_193;
  }
  CMTimeFlags v109 = *(_DWORD *)(v108 + 12);
  CMTimeEpoch v110 = *(void *)(v108 + 16);
  if (fpfsi_PlaybackHasBufferedBeyondTimeToPauseBuffering(a1) && *(unsigned char *)(DerivedStorage + 464))
  {
    *(_OWORD *)CMTime time2 = *(_OWORD *)(DerivedStorage + 1424);
    *(void *)&time2[16] = *(void *)(DerivedStorage + 1440);
    *(_OWORD *)CMTime rhs = kGaplessTransitionDeadlineInterval;
    *(void *)&rhs[16] = 0;
    CMTimeAdd(time1, (CMTime *)time2, (CMTime *)rhs);
LABEL_193:
    CMTimeValue v274 = time1[0].value;
    CMTimeFlags v109 = time1[0].flags;
    CMTimeScale v275 = time1[0].timescale;
    CMTimeEpoch v110 = time1[0].epoch;
  }
  int v228 = v57;
  if ((v109 & 1) == 0)
  {
    unsigned int v111 = 0;
    goto LABEL_215;
  }
  fpfsi_MapEndTimeFromTargetToSource(DerivedStorage, (uint64_t)&v248);
  time1[0].CMTimeValue value = v274;
  *(void *)&time1[0].CMTimeScale timescale = __PAIR64__(v109, v275);
  time1[0].CMTimeEpoch epoch = v110;
  uint64_t v112 = CMTimeCompare(time1, &v248);
  fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&v253);
  uint64_t v113 = 0;
  unsigned int v111 = 0;
  while (2)
  {
    if (fpfs_SubstreamNeedsFlowControl(DerivedStorage, v113))
    {
      uint64_t v114 = (char *)v259 + 24 * v113;
      *(CMTime *)CMTime time2 = v253;
      *(_OWORD *)CMTime rhs = *(_OWORD *)v114;
      *(void *)&rhs[16] = *((void *)v114 + 2);
      CMTimeAdd(time1, (CMTime *)time2, (CMTime *)rhs);
      *(void *)CMTime rhs = time1[0].value;
      *(_DWORD *)&rhs[8] = time1[0].timescale;
      if ((time1[0].flags & 0x1D) == 1)
      {
        time1[0].CMTimeValue value = *(void *)rhs;
        time1[0].CMTimeScale timescale = *(_DWORD *)&rhs[8];
        *(void *)CMTime time2 = v274;
        *(_DWORD *)&time2[8] = v275;
        *(_DWORD *)&time2[12] = v109;
        *(void *)&time2[16] = v110;
        if ((CMTimeCompare(time1, (CMTime *)time2) & 0x80000000) == 0)
        {
          v228 |= 1 << v113;
          v111 |= 1 << v113;
          v226 &= ~(1 << v113);
          if (!v112)
          {
            uint64_t v115 = v112;
            uint64_t v116 = *(void *)(DerivedStorage + 1048);
            if (v116)
            {
              while (1)
              {
                uint64_t v117 = *(void *)(v116 + 48);
                uint64_t v118 = *(unsigned __int8 *)(v116 + 180);
                uint64_t v119 = DerivedStorage + 16 * v118;
                if (v117 != *(void *)(v119 + 1000)) {
                  break;
                }
                if (v113 == v118) {
                  goto LABEL_209;
                }
LABEL_212:
                uint64_t v116 = *(void *)(v116 + 8);
                if (!v116) {
                  goto LABEL_213;
                }
              }
              uint64_t v120 = *(void *)(v119 + 1008);
              if (v113 != v118 || v117 != v120) {
                goto LABEL_212;
              }
LABEL_209:
              if (*(void *)(v116 + 112)) {
                fpfs_scheduleForwardEndTimeForTrack(DerivedStorage, v116, 0);
              }
              else {
                fpfs_EnsureEndTimerProcForTrack(v116);
              }
              goto LABEL_212;
            }
LABEL_213:
            uint64_t v112 = v115;
          }
        }
      }
    }
    if (++v113 != 3) {
      continue;
    }
    break;
  }
LABEL_215:
  unsigned int v231 = v111;
  if (v226)
  {
    *(_DWORD *)(DerivedStorage + 1888) = 0;
    uint64_t v122 = *(void *)(DerivedStorage + 2256);
    CMTimeFlags v123 = v219;
    CMTimeEpoch v124 = v233;
    int v125 = v237;
    int v126 = v228;
    if (v122)
    {
      uint64_t v127 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v128 = v127 ? v127 : 0;
      uint64_t v134 = *(void (**)(uint64_t, uint64_t, void))(v128 + 56);
      if (v134) {
        v134(v122, 0x1EE57E498, *MEMORY[0x1E4F1CFD0]);
      }
    }
  }
  else
  {
    int v125 = v237;
    int v126 = v228;
    CMTimeFlags v123 = v219;
    CMTimeEpoch v124 = v233;
    if (v228 == v237)
    {
      if (*(_DWORD *)(DerivedStorage + 1888) != 1)
      {
        if (a4 && dword_1E9350BB0)
        {
          *(_DWORD *)CMTime rhs = 0;
          LOBYTE(v280.CFDictionarySetValue(theDict, key, value) = 0;
          CMTime v129 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v130 = *(_DWORD *)rhs;
          if (os_log_type_enabled(v129, v280.value)) {
            unsigned int v131 = v130;
          }
          else {
            unsigned int v131 = v130 & 0xFFFFFFFE;
          }
          if (v131)
          {
            uint64_t v132 = *(const void **)DerivedStorage;
            if (*(void *)DerivedStorage) {
              Float64 v133 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
            }
            else {
              Float64 v133 = "";
            }
            if (v236) {
              uint64_t v135 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
            }
            else {
              uint64_t v135 = "";
            }
            time1[0].CMTimeValue value = value;
            *(void *)&time1[0].CMTimeScale timescale = __PAIR64__(v219, timescale);
            time1[0].CMTimeEpoch epoch = v233;
            Float64 v136 = CMTimeGetSeconds(time1);
            *(_DWORD *)CMTime time2 = 136316418;
            *(void *)&time2[4] = "fpfs_CheckPrebufferedLevels";
            *(_WORD *)&time2[12] = 2048;
            *(void *)&time2[14] = v132;
            *(_WORD *)&time2[22] = 2082;
            *(void *)&time2[24] = v133;
            *(_WORD *)unsigned int v262 = 2048;
            *(void *)&v262[2] = v236;
            *(_WORD *)&v262[10] = 2082;
            *(void *)&v262[12] = v135;
            __int16 v263 = 2048;
            *(Float64 *)v264 = v136;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          CMTimeFlags v123 = v219;
          CMTimeEpoch v124 = v233;
          int v125 = v237;
          int v126 = v228;
        }
        *(_DWORD *)(DerivedStorage + 1888) = 1;
        uint64_t v137 = *(void *)(DerivedStorage + 2256);
        if (v137)
        {
          uint64_t v138 = *(void *)(CMBaseObjectGetVTable() + 8);
          uint64_t v139 = v138 ? v138 : 0;
          __int16 v140 = *(void (**)(uint64_t, uint64_t, void))(v139 + 56);
          if (v140) {
            v140(v137, 0x1EE57E498, *MEMORY[0x1E4F1CFC8]);
          }
        }
        fpfs_EnqueueNotification(v216, @"StreamBufferFull", v236, 0);
      }
      if (fpfsi_PlaybackHasBufferedBeyondTimeToPauseBuffering((uint64_t)v236))
      {
        fpfsi_EnqueuePlayableRangeChangedNotification(v236);
        fpfs_EnqueueNotification(v216, @"ReachedTimeToPauseBuffering", v236, 0);
      }
    }
  }
  uint64_t v141 = 0;
  int v142 = 0;
  uint64_t v143 = (CMTime *)v259;
  do
  {
    if (((1 << v141) & v125) != 0)
    {
      if (((1 << v141) & v126) != 0)
      {
        time1[0] = *v143;
        if (fpfs_CheckCanKeepUp((uint64_t)v236, (uint64_t)time1, MEMORY[0x1E4F1F9F8], (1 << v141), (uint64_t)v259, 0, 0, 0))int v144 = 1 << v141; {
        else
        }
          int v144 = 0;
        v231 |= v144;
      }
      else
      {
        if (*(_DWORD *)(DerivedStorage + 1888)) {
          int v145 = 0;
        }
        else {
          int v145 = 1 << v141;
        }
        v142 |= v145;
      }
    }
    ++v141;
    ++v143;
  }
  while (v141 != 3);
  uint64_t v146 = 0;
  uint64_t v147 = (CMTime *)v259;
  unsigned int v148 = v231;
  int v149 = v142;
  uint64_t v150 = (void *)v236;
  do
  {
    if (fpfs_SubstreamNeedsFlowControl(DerivedStorage, v146))
    {
      CMTimeMake(&v246, 15, 1);
      time1[0] = v251;
      CMTimeAdd(&v247, time1, &v246);
      time1[0] = *v147;
      if (CMTimeCompare(time1, &v247) >= 1)
      {
        memset(rhs, 0, 24);
        CMTimeMake(&v245, 15, 2);
        time1[0] = *v147;
        CMTimeSubtract((CMTime *)rhs, time1, &v245);
        time1[0].CMTimeValue value = value;
        *(void *)&time1[0].CMTimeScale timescale = __PAIR64__(v123, timescale);
        time1[0].CMTimeEpoch epoch = v124;
        *(CMTime *)CMTime time2 = v255;
        CMTimeSubtract(&v244, time1, (CMTime *)time2);
        time1[0] = *v147;
        *(_OWORD *)CMTime time2 = *(_OWORD *)rhs;
        *(void *)&time2[16] = *(void *)&rhs[16];
        CMTimeSubtract(&v243, time1, (CMTime *)time2);
        if ((CMTimeCompare(&v244, &v243) & 0x80000000) == 0)
        {
          CMTimeValue value = v147->value;
          CMTimeFlags v123 = v147->flags;
          CMTimeScale timescale = v147->timescale;
          CMTimeEpoch v124 = v147->epoch;
          CMTime v255 = *(CMTime *)rhs;
        }
        if (a4 && dword_1E9350BB0)
        {
          CMTimeEpoch v234 = v124;
          LODWORD(v280.CFDictionarySetValue(theDict, key, value) = 0;
          LOBYTE(time.CFDictionarySetValue(theDict, key, value) = 0;
          uint64_t v151 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v152 = v280.value;
          if (os_log_type_enabled(v151, time.value)) {
            unsigned int v153 = v152;
          }
          else {
            unsigned int v153 = v152 & 0xFFFFFFFE;
          }
          if (v153)
          {
            int v238 = v149;
            uint64_t v154 = *(void *)v235;
            if (*(void *)v235) {
              uint64_t v155 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
            }
            else {
              uint64_t v155 = "";
            }
            unsigned int v232 = v148;
            if (v236) {
              uint64_t v156 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
            }
            else {
              uint64_t v156 = "";
            }
            time1[0] = *v147;
            Float64 v157 = CMTimeGetSeconds(time1);
            time1[0] = v251;
            Float64 v158 = CMTimeGetSeconds(time1);
            time1[0] = *(CMTime *)rhs;
            Float64 v159 = CMTimeGetSeconds(time1);
            *(_DWORD *)CMTime time2 = 136317186;
            *(void *)&time2[4] = "fpfs_CheckPrebufferedLevels";
            *(_WORD *)&time2[12] = 2048;
            *(void *)&time2[14] = v154;
            *(_WORD *)&time2[22] = 2082;
            *(void *)&time2[24] = v155;
            *(_WORD *)unsigned int v262 = 2048;
            *(void *)&v262[2] = v236;
            *(_WORD *)&v262[10] = 2082;
            *(void *)&v262[12] = v156;
            __int16 v263 = 1024;
            *(_DWORD *)v264 = v146;
            *(_WORD *)&v264[4] = 2048;
            *(Float64 *)&v264[6] = v157;
            *(_WORD *)&v264[14] = 2048;
            *(Float64 *)&v264[16] = v158;
            *(_WORD *)&v264[24] = 2048;
            *(Float64 *)&v264[26] = v159;
            _os_log_send_and_compose_impl();
            unsigned int v148 = v232;
            int v149 = v238;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          CMTimeEpoch v124 = v234;
          uint64_t DerivedStorage = v235;
        }
        v148 |= 1 << v146;
        v149 &= ~(1 << v146);
      }
    }
    ++v146;
    ++v147;
  }
  while (v146 != 3);
  int v160 = v149;
  if (v220)
  {
    uint64_t v161 = v221;
    if ((v123 & 0x1D) != 1) {
      goto LABEL_320;
    }
LABEL_292:
    memset(&time, 0, sizeof(time));
    time1[0].CMTimeValue value = value;
    *(void *)&time1[0].CMTimeScale timescale = __PAIR64__(v123, timescale);
    time1[0].CMTimeEpoch epoch = v124;
    *(CMTime *)CMTime time2 = v255;
    CMTimeSubtract(&time, time1, (CMTime *)time2);
    if (*(float *)(v161 + 108) >= 0.0)
    {
      fpfs_GetApproximateTime(DerivedStorage, (uint64_t)&v242);
      *(CMTime *)CMTime time2 = time;
      CMTimeAdd(time1, &v242, (CMTime *)time2);
    }
    else
    {
      fpfs_GetApproximateTime(DerivedStorage, (uint64_t)&lhs);
      *(CMTime *)CMTime time2 = time;
      CMTimeSubtract(time1, &lhs, (CMTime *)time2);
    }
    CMTime time = time1[0];
    if (!*(void *)(DerivedStorage + 1632) && dword_1E9350BB0)
    {
      *(_DWORD *)CMTime rhs = 0;
      LOBYTE(v280.CFDictionarySetValue(theDict, key, value) = 0;
      uint64_t v162 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v163 = *(_DWORD *)rhs;
      if (os_log_type_enabled(v162, v280.value)) {
        unsigned int v164 = v163;
      }
      else {
        unsigned int v164 = v163 & 0xFFFFFFFE;
      }
      if (v164)
      {
        uint64_t v165 = *(void *)v235;
        if (*(void *)v235) {
          uint64_t v166 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          uint64_t v166 = "";
        }
        if (v236) {
          uint64_t v167 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else {
          uint64_t v167 = "";
        }
        fpfs_GetTime(v235, (uint64_t)&v240);
        Float64 v168 = CMTimeGetSeconds(&v240);
        time1[0] = time;
        Float64 v169 = CMTimeGetSeconds(time1);
        *(_DWORD *)CMTime time2 = 136316674;
        *(void *)&time2[4] = "fpfs_CheckPrebufferedLevels";
        *(_WORD *)&time2[12] = 2048;
        *(void *)&time2[14] = v165;
        *(_WORD *)&time2[22] = 2082;
        *(void *)&time2[24] = v166;
        *(_WORD *)unsigned int v262 = 2048;
        *(void *)&v262[2] = v236;
        *(_WORD *)&v262[10] = 2082;
        *(void *)&v262[12] = v167;
        __int16 v263 = 2048;
        *(Float64 *)v264 = v168;
        *(_WORD *)&v264[8] = 2048;
        *(Float64 *)&v264[10] = v169;
        _os_log_send_and_compose_impl();
        uint64_t v161 = v221;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      uint64_t DerivedStorage = v235;
      uint64_t v150 = (void *)v236;
    }
    CMTime v256 = time;
    uint64_t v170 = CMBaseObjectGetDerivedStorage();
    uint64_t v171 = v170;
    if (!*(void *)(DerivedStorage + 1632))
    {
      uint64_t v172 = fpfs_TimerDispatchSourceCreate(*(dispatch_queue_t *)(v170 + 600), *(void **)(v170 + 16), 0xFFFFFFFFFFFFFFFFLL, (void (__cdecl *)(void *))fpfs_needsMoreTimerProc, 0);
      *(void *)(DerivedStorage + 1632) = v172;
      if (v172) {
        CMTimebaseAddTimerDispatchSource(*(CMTimebaseRef *)(v171 + 576), v172);
      }
      uint64_t v173 = MEMORY[0x1E4F1F9F8];
      long long v174 = *MEMORY[0x1E4F1F9F8];
      *(_OWORD *)(DerivedStorage + 1640) = *MEMORY[0x1E4F1F9F8];
      uint64_t v175 = *(void *)(v173 + 16);
      *(void *)(DerivedStorage + 1656) = v175;
      *(_OWORD *)(DerivedStorage + 1664) = v174;
      *(void *)(DerivedStorage + 1680) = v175;
    }
    int32_t v176 = (_OWORD *)(DerivedStorage + 1640);
    if ((*(unsigned char *)(DerivedStorage + 1652) & 1) == 0
      || (*(CMTime *)CMTime time2 = v256,
          *(_OWORD *)CMTime rhs = kTimerScheduleTime,
          *(void *)&rhs[16] = 0,
          CMTimeAdd(time1, (CMTime *)time2, (CMTime *)rhs),
          *(_OWORD *)CMTime time2 = *v176,
          *(void *)&time2[16] = *(void *)(DerivedStorage + 1656),
          CMTimeCompare(time1, (CMTime *)time2) < 0))
    {
      uint64_t v177 = *(OpaqueCMTimebase **)(v171 + 576);
      uint64_t v178 = *(NSObject **)(DerivedStorage + 1632);
      *(CMTime *)CMTime time2 = v256;
      CMTimebaseSetTimerDispatchSourceNextFireTime(v177, v178, (CMTime *)time2, 1u);
      *int32_t v176 = *(_OWORD *)&v256.value;
      *(void *)(DerivedStorage + 1656) = v256.epoch;
      uint64_t v179 = MEMORY[0x1E4F1F9F8];
      *(_OWORD *)(DerivedStorage + 1664) = *MEMORY[0x1E4F1F9F8];
      *(void *)(DerivedStorage + 1680) = *(void *)(v179 + 16);
    }
    else
    {
      *(_OWORD *)CMTime rhs = *v176;
      *(void *)&rhs[16] = *(void *)(DerivedStorage + 1656);
      *(_OWORD *)&v280.CMTimeValue value = kTimerScheduleTime;
      v280.CMTimeEpoch epoch = 0;
      CMTimeAdd((CMTime *)time2, (CMTime *)rhs, &v280);
      *(CMTime *)CMTime rhs = v256;
      if (CMTimeCompare((CMTime *)rhs, (CMTime *)time2) >= 1)
      {
        *(CMTime *)CMTime rhs = v256;
        CMTime v280 = *(CMTime *)(DerivedStorage + 1664);
        if (CMTimeCompare((CMTime *)rhs, &v280) < 0) {
          *(CMTime *)(DerivedStorage + 1664) = v256;
        }
      }
    }
  }
  else
  {
    uint64_t v161 = v221;
    if ((v148 >> *(_DWORD *)(DerivedStorage + 1112))) {
      *(unsigned char *)(DerivedStorage + 1565) = 1;
    }
    if ((v123 & 0x1D) == 1 && *(unsigned char *)(DerivedStorage + 1565)) {
      goto LABEL_292;
    }
  }
LABEL_320:
  if (*(float *)(v161 + 108) == 0.0)
  {
    int v180 = *(_DWORD *)(v161 + 764);
    if (v180 <= 0) {
      int v181 = v160;
    }
    else {
      int v181 = 0;
    }
    if (v180 > 0) {
      unsigned int v148 = 0;
    }
  }
  else
  {
    int v181 = v160;
  }
  if (!(v148 | v181)
    || (CMBaseObjectGetDerivedStorage(), !fpfs_FlowControlPump(DerivedStorage, v148, 1, v181)))
  {
    if (a4 && dword_1E9350BB0)
    {
      *(_DWORD *)CMTime rhs = 0;
      LOBYTE(v280.CFDictionarySetValue(theDict, key, value) = 0;
      uint64_t v182 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v183 = *(_DWORD *)rhs;
      if (os_log_type_enabled(v182, v280.value)) {
        unsigned int v184 = v183;
      }
      else {
        unsigned int v184 = v183 & 0xFFFFFFFE;
      }
      if (v184)
      {
        uint64_t v185 = *(void *)v235;
        if (*(void *)v235) {
          unsigned int v186 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          unsigned int v186 = "";
        }
        int v187 = v181;
        if (v150) {
          unint64_t v188 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else {
          unint64_t v188 = "";
        }
        Float64 v189 = -1.0;
        if (*(void *)(v235 + 1632))
        {
          time1[0] = *(CMTime *)(v235 + 1640);
          Float64 v190 = CMTimeGetSeconds(time1);
          if (*(void *)(v235 + 1632))
          {
            time1[0] = *(CMTime *)(v235 + 1664);
            Float64 v189 = CMTimeGetSeconds(time1);
          }
        }
        else
        {
          Float64 v190 = -1.0;
        }
        *(_DWORD *)CMTime time2 = 136317186;
        *(void *)&time2[4] = "fpfs_CheckPrebufferedLevels";
        *(_WORD *)&time2[12] = 2048;
        *(void *)&time2[14] = v185;
        *(_WORD *)&time2[22] = 2082;
        *(void *)&time2[24] = v186;
        *(_WORD *)unsigned int v262 = 2048;
        *(void *)&v262[2] = v150;
        *(_WORD *)&v262[10] = 2082;
        *(void *)&v262[12] = v188;
        __int16 v263 = 1024;
        *(_DWORD *)v264 = v148;
        *(_WORD *)&v264[4] = 1024;
        *(_DWORD *)&v264[6] = v187;
        *(_WORD *)&v264[10] = 2048;
        *(Float64 *)&v264[12] = v190;
        *(_WORD *)&v264[20] = 2048;
        *(Float64 *)&v264[22] = v189;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      uint64_t DerivedStorage = v235;
    }
    fpfs_GetNextTimeToPlay(DerivedStorage, 1, (uint64_t)&v253);
    for (uint64_t i = *(void *)(DerivedStorage + 1048); i; uint64_t i = *(void *)(i + 8))
    {
      if (*(void *)(i + 120))
      {
        if (!*(unsigned char *)(i + 182) && *(_DWORD *)(i + 152) == 6 && (*(unsigned char *)(i + 228) & 1) != 0)
        {
          uint64_t v192 = (_OWORD *)(i + 216);
          if ((*(unsigned char *)(DerivedStorage + 1388) & 1) == 0
            || (*(_OWORD *)&time1[0].CMTimeValue value = *v192,
                time1[0].CMTimeEpoch epoch = *(void *)(i + 232),
                *(_OWORD *)CMTime time2 = *(_OWORD *)(DerivedStorage + 1376),
                *(void *)&time2[16] = *(void *)(DerivedStorage + 1392),
                CMTimeCompare(time1, (CMTime *)time2) < 0))
          {
            *(_OWORD *)&time1[0].CMTimeValue value = *v192;
            time1[0].CMTimeEpoch epoch = *(void *)(i + 232);
            if (!fpfsi_atOrAfterTimeToPausePlayback(DerivedStorage, time1) && !*(unsigned char *)(i + 184))
            {
              memset(&v280, 0, sizeof(v280));
              *(_OWORD *)&time1[0].CMTimeValue value = *v192;
              time1[0].CMTimeEpoch epoch = *(void *)(i + 232);
              *(_OWORD *)CMTime time2 = kGaplessTransitionDeadlineInterval;
              *(void *)&time2[16] = 0;
              CMTimeSubtract(&v280, time1, (CMTime *)time2);
              *(CMTime *)CMTime time2 = v280;
              *(_OWORD *)CMTime rhs = kTimerVariability;
              *(void *)&rhs[16] = 0;
              CMTimeAdd(time1, (CMTime *)time2, (CMTime *)rhs);
              CMTime v280 = time1[0];
              time1[0] = v253;
              *(_OWORD *)CMTime time2 = kTimerScheduleTime;
              *(void *)&time2[16] = 0;
              CMTimeAdd(&v239, time1, (CMTime *)time2);
              time1[0] = v280;
              if (CMTimeCompare(time1, &v239) < 1)
              {
                if (*(float *)(DerivedStorage + 848) != 0.0)
                {
                  uint64_t v198 = MEMORY[0x1E4F1F9F8];
                  *(_OWORD *)(i + 156) = *MEMORY[0x1E4F1F9F8];
                  *(void *)(i + 172) = *(void *)(v198 + 16);
                  fpfs_CallDispatchHandlerWithItemAndTrack(v150, i, (void (*)(void))fpfs_ranDryTimerProc);
                }
              }
              else
              {
                CMTime time = v280;
                BOOL v193 = (_OWORD *)(i + 156);
                if ((*(unsigned char *)(i + 168) & 1) == 0
                  || (CMTimeMake((CMTime *)time2, 1, 100),
                      *(CMTime *)CMTime rhs = time,
                      CMTimeAdd(time1, (CMTime *)rhs, (CMTime *)time2),
                      *(_OWORD *)CMTime rhs = *v193,
                      *(void *)&rhs[16] = *(void *)(i + 172),
                      CMTimeCompare(time1, (CMTime *)rhs) < 0))
                {
                  long long v194 = *(_OWORD *)&time.value;
                  *BOOL v193 = *(_OWORD *)&time.value;
                  CMTimeEpoch v195 = time.epoch;
                  *(void *)(i + 172) = time.epoch;
                  uint64_t v196 = *(OpaqueCMTimebase **)(DerivedStorage + 576);
                  uint64_t v197 = *(NSObject **)(i + 120);
                  *(_OWORD *)CMTime rhs = v194;
                  *(void *)&rhs[16] = v195;
                  CMTimebaseSetTimerDispatchSourceNextFireTime(v196, v197, (CMTime *)rhs, 1u);
                }
                else
                {
                  *BOOL v193 = *(_OWORD *)&time.value;
                  *(void *)(i + 172) = time.epoch;
                }
              }
            }
          }
        }
      }
    }
    fpfs_GetItemBufferedDuration(v150, &v252, 0, 0);
    uint64_t v199 = (CMTime *)MEMORY[0x1E4F1FA48];
    if (a2)
    {
      if (*(unsigned char *)(DerivedStorage + 470)
        || ((*(_DWORD *)(DerivedStorage + 1096) ^ v148) & 3) == 0)
      {
        uint64_t RenderingTrackofType = fpfs_FirstRenderingTrackofType((uint64_t)v150, 1986618469);
        if (RenderingTrackofType) {
          BOOL v200 = *(unsigned char *)(RenderingTrackofType + 104) == 0;
        }
        else {
          BOOL v200 = 1;
        }
      }
      else
      {
        BOOL v200 = 0;
      }
      uint64_t v202 = *(void **)DerivedStorage;
      time1[0] = v252;
      fpfs_CheckIfLikelyToKeepUpAndNotify(v202, (const __CFArray *)v150, time1, v200, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], (uint64_t)v259);
    }
    uint64_t v203 = CMBaseObjectGetDerivedStorage();
    uint64_t v204 = CMBaseObjectGetDerivedStorage();
    CFTypeRef cf = 0;
    memset(time1, 0, 72);
    memset(&v280, 0, sizeof(v280));
    fpfs_GetTime(v203, (uint64_t)&v280);
    CMTime time = *v199;
    memset(&v256, 0, sizeof(v256));
    fpfs_GetNextTimeToPlay(v203, 1, (uint64_t)&v256);
    if (!*(void *)(v203 + 96)) {
      goto LABEL_388;
    }
    fpfs_GetItemBufferedDuration(v150, &time, time1, 0);
    if (*(float *)(v204 + 108) >= 0.0)
    {
      *(CMTime *)CMTime time2 = v256;
      *(CMTime *)CMTime rhs = time;
      CMTimeAdd(&v256, (CMTime *)time2, (CMTime *)rhs);
    }
    else
    {
      *(CMTime *)CMTime time2 = v256;
      *(CMTime *)CMTime rhs = time;
      CMTimeSubtract(&v256, (CMTime *)time2, (CMTime *)rhs);
    }
    BOOL v205 = *(const void **)(v203 + 96);
    char HasEndedOrBufferedBeyondFwdEnd = fpfsi_PumpHasEndedOrBufferedBeyondFwdEnd((uint64_t)v150);
    *(CMTime *)CMTime time2 = v256;
    FigAlternatePlaybackBitrateMonitorSetStreamDuration(v205, (CMTime *)time2, HasEndedOrBufferedBeyondFwdEnd);
    uint64_t v207 = *(void *)(v203 + 936);
    if (!v207) {
      goto LABEL_388;
    }
    uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
    FigBytePumpGetFigBaseObject(v207);
    uint64_t v210 = v209;
    uint64_t v211 = *(void *)(CMBaseObjectGetVTable() + 8);
    uint64_t v212 = v211 ? v211 : 0;
    uint64_t v213 = *(void (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(v212 + 48);
    if (v213)
    {
      v213(v210, 0x1EE53EC18, AllocatorForMedia, &cf);
      if (cf)
      {
        int v214 = *(_DWORD *)(v203 + 1096);
        if ((v214 & 1) == 0)
        {
          if ((v214 & 2) == 0) {
            goto LABEL_386;
          }
LABEL_392:
          *(_OWORD *)unsigned int v262 = 0u;
          memset(time2, 0, sizeof(time2));
          *(CMTime *)CMTime rhs = v280;
          CMTime duration = time1[1];
          CMTimeRangeMake((CMTimeRange *)time2, (CMTime *)rhs, &duration);
          *(_OWORD *)CMTime rhs = *(_OWORD *)time2;
          *(_OWORD *)&rhs[16] = *(_OWORD *)&time2[16];
          long long v277 = *(_OWORD *)v262;
          FigCMCDHeaderVendorSetLoadedTimeRange((uint64_t)cf, 2, (long long *)rhs);
          if ((*(_DWORD *)(v203 + 1096) & 4) == 0) {
            goto LABEL_388;
          }
LABEL_387:
          *(_OWORD *)unsigned int v262 = 0u;
          memset(time2, 0, sizeof(time2));
          *(CMTime *)CMTime rhs = v280;
          CMTime duration = time1[2];
          CMTimeRangeMake((CMTimeRange *)time2, (CMTime *)rhs, &duration);
          *(_OWORD *)CMTime rhs = *(_OWORD *)time2;
          *(_OWORD *)&rhs[16] = *(_OWORD *)&time2[16];
          long long v277 = *(_OWORD *)v262;
          FigCMCDHeaderVendorSetLoadedTimeRange((uint64_t)cf, 6, (long long *)rhs);
          goto LABEL_388;
        }
        *(_OWORD *)unsigned int v262 = 0u;
        memset(time2, 0, sizeof(time2));
        *(CMTime *)CMTime rhs = v280;
        CMTime duration = time1[0];
        CMTimeRangeMake((CMTimeRange *)time2, (CMTime *)rhs, &duration);
        *(_OWORD *)CMTime rhs = *(_OWORD *)time2;
        *(_OWORD *)&rhs[16] = *(_OWORD *)&time2[16];
        long long v277 = *(_OWORD *)v262;
        FigCMCDHeaderVendorSetLoadedTimeRange((uint64_t)cf, 4, (long long *)rhs);
        int v214 = *(_DWORD *)(v203 + 1096);
        if ((v214 & 2) != 0) {
          goto LABEL_392;
        }
LABEL_386:
        if ((v214 & 4) != 0) {
          goto LABEL_387;
        }
LABEL_388:
        if (cf) {
          CFRelease(cf);
        }
      }
    }
  }
}

uint64_t fpfsi_setPlaybackRateMonitorProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 96);
  if (!v3) {
    return 0;
  }
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
  if (!v8) {
    return 4294954514;
  }

  return v8(v3, a2, a3);
}

void fpfsi_setupCMCDHeaderVendor()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v1 = *(void *)(DerivedStorage + 936);
  if (v1)
  {
    uint64_t v2 = DerivedStorage;
    CFTypeRef cf = 0;
    uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
    uint64_t FigBaseObject = FigBytePumpGetFigBaseObject(v1);
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(v6 + 48);
    if (v7)
    {
      v7(FigBaseObject, 0x1EE53EC18, AllocatorForMedia, &cf);
      if (cf)
      {
        FigCMCDHeaderVendorSetIsLikelyToKeepUp((uint64_t)cf, *(_DWORD *)(v2 + 524) == 1);
        FigCMCDHeaderVendorSetTimebase((uint64_t)cf, *(const void **)(v2 + 576));
        CFRelease(cf);
      }
    }
  }
}

void fpfs_ReleaseAndClearTimebaseTimer(OpaqueCMTimebase *a1, dispatch_object_t *a2)
{
  if (a2)
  {
    if (a1)
    {
      uint64_t v3 = *a2;
      if (*a2) {
        CMTimebaseRemoveTimerDispatchSource(a1, v3);
      }
    }
  }

  fpfs_ReleaseAndClearDispatchSource(a2);
}

void fpfs_ReleaseAndClearDispatchSource(dispatch_object_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2)
    {
      dispatch_source_cancel(v2);
      dispatch_release(*a1);
    }
    *a1 = 0;
  }
}

void fpfsi_DeferredHandleTimebaseEffectiveRateChanged(uint64_t a1, const __CFString *a2)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(const void **)DerivedStorage;
  uint64_t v63 = CMBaseObjectGetDerivedStorage();
  *(_OWORD *)&v72.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v5 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  v72.CMTimeEpoch epoch = v5;
  long long v62 = *(_OWORD *)&v72.value;
  *(_OWORD *)&v71.CMTimeValue value = *(_OWORD *)&v72.value;
  v71.CMTimeEpoch epoch = v5;
  fpfs_LockMutexWithCaller(v4);
  double Rate = CMTimebaseGetRate(*(CMTimebaseRef *)(DerivedStorage + 576));
  CMTimebaseGetTime(&v71, *(CMTimebaseRef *)(DerivedStorage + 576));
  FigCFDictionaryGetCMTimeIfPresent();
  if ((v72.flags & 1) == 0) {
    CMTime v72 = v71;
  }
  uint64_t v7 = (_DWORD *)MEMORY[0x1E4F1EBA8];
  if (Rate == 0.0)
  {
    if (dword_1E9350BB0)
    {
      LODWORD(v70.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      uint64_t v7 = (_DWORD *)MEMORY[0x1E4F1EBA8];
    }
  }
  else
  {
    uint64_t v8 = CMBaseObjectGetDerivedStorage();
    if (*(unsigned char *)(v8 + 3332))
    {
      uint64_t v9 = v8;
      CMTimeFlags v10 = v7;
      CMTimeEpoch v11 = (CMTime *)(v8 + 3320);
      double v12 = (double)(FigGetUpTimeNanoseconds() - *(void *)(v8 + 3312));
      CMTime time = *v11;
      unint64_t v13 = (uint64_t)(v12 + CMTimeGetSeconds(&time) * -1000000000.0) / 0xF4240uLL;
      if ((int)v13 >= 1)
      {
        uint64_t v14 = *(void *)(v9 + 2544);
        if (v14)
        {
          uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v16 = v15 ? v15 : 0;
          uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v16 + 40);
          if (v18) {
            v18(v14, 0x1EE582B78, 0x1EE585BD8, v13);
          }
        }
      }
      *(void *)(v9 + 3312) = 0;
      *(_OWORD *)&v11->CMTimeValue value = v62;
      v11->CMTimeEpoch epoch = v5;
      uint64_t v7 = v10;
    }
    uint64_t TimebaseStarterTrack = fpfsi_getTimebaseStarterTrack((uint64_t)a2);
    if (TimebaseStarterTrack && (uint64_t v20 = TimebaseStarterTrack, (*(unsigned char *)(TimebaseStarterTrack + 372) & 1) != 0))
    {
      int v22 = (CMTime *)(TimebaseStarterTrack + 360);
      memset(&v70, 0, sizeof(v70));
      double v23 = *(const void **)(DerivedStorage + 576);
      CMClockRef HostTimeClock = CMClockGetHostTimeClock();
      CMTime time = v71;
      CMSyncConvertTime(&v70, &time, v23, HostTimeClock);
      memset(&type, 0, sizeof(type));
      int v25 = *(const void **)(DerivedStorage + 576);
      CMClockRef v26 = CMClockGetHostTimeClock();
      CMTime time = *v22;
      CMSyncConvertTime(&type, &time, v25, v26);
      memset(&v68, 0, sizeof(v68));
      uint64_t v27 = *(const void **)(DerivedStorage + 576);
      CMClockRef v28 = CMClockGetHostTimeClock();
      CMTime time = v72;
      CMSyncConvertTime(&v68, &time, v27, v28);
      *(_OWORD *)&v67.CMTimeValue value = v62;
      v67.CMTimeEpoch epoch = v5;
      CMTime time = v68;
      CMTime time2 = type;
      if (CMTimeCompare(&time, &time2) < 0)
      {
        memset(&v66, 0, sizeof(v66));
        CMTime time = type;
        CMTime time2 = v70;
        CMTimeSubtract(&v66, &time, &time2);
        if (dword_1E9350BB0)
        {
          LODWORD(v65.CFDictionarySetValue(theDict, key, value) = 0;
          int v35 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          uint64_t v7 = (_DWORD *)MEMORY[0x1E4F1EBA8];
        }
        *(_OWORD *)&v67.CMTimeValue value = *(_OWORD *)&v66.value;
        CMTimeEpoch epoch = v66.epoch;
      }
      else
      {
        CMTime v66 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
        uint64_t v29 = *(void *)(v20 + 96);
        if (v29)
        {
          uint64_t v30 = *(void *)(v29 + 32);
          if (v30)
          {
            time.CMTimeValue value = 0;
            uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
            uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v30);
            uint64_t v33 = *(void *)(CMBaseObjectGetVTable() + 8);
            if (v33) {
              uint64_t v34 = v33;
            }
            else {
              uint64_t v34 = 0;
            }
            int v36 = *(void (**)(uint64_t, __CFString *, uint64_t, CMTime *))(v34 + 48);
            if (v36) {
              v36(FigBaseObject, @"UnpauseLatencyEstimate", AllocatorForMedia, &time);
            }
            if (time.value)
            {
              CMTimeMakeFromDictionary(&v66, (CFDictionaryRef)time.value);
              CFRelease((CFTypeRef)time.value);
            }
          }
        }
        memset(&v65, 0, sizeof(v65));
        CMTime time = v68;
        CMTime time2 = v66;
        CMTimeAdd(&lhs, &time, &time2);
        CMTime time = v70;
        CMTimeSubtract(&v65, &lhs, &time);
        if (dword_1E9350BB0)
        {
          uint64_t v37 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          uint64_t v7 = (_DWORD *)MEMORY[0x1E4F1EBA8];
        }
        *(_OWORD *)&v67.CMTimeValue value = *(_OWORD *)&v65.value;
        CMTimeEpoch epoch = v65.epoch;
      }
      v67.CMTimeEpoch epoch = epoch;
      if (!*(unsigned char *)(DerivedStorage + 2595))
      {
        *(unsigned char *)(DerivedStorage + 2595) = 1;
        uint64_t v39 = *(void *)(DerivedStorage + 2544);
        CMTime time = v67;
        double Seconds = CMTimeGetSeconds(&time);
        if (v39)
        {
          double v41 = Seconds;
          uint64_t v42 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v43 = v42 ? v42 : 0;
          CFArrayRef v44 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v43 + 56);
          if (v44) {
            v44(v39, 0x1EE582B78, 0x1EE584B38, (uint64_t)(v41 * 1000.0), 0);
          }
        }
        uint64_t v45 = v7;
        uint64_t v46 = *(void *)(DerivedStorage + 2544);
        double Current = CFAbsoluteTimeGetCurrent();
        if (v46)
        {
          double v48 = Current;
          double v49 = *(double *)(DerivedStorage + 2992);
          uint64_t v50 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v51 = v50 ? v50 : 0;
          Float64 v52 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v51 + 56);
          if (v52) {
            v52(v46, 0x1EE582B78, 0x1EE584B18, (uint64_t)((v48 - v49) * 1000.0), 0);
          }
        }
        uint64_t v53 = CMBaseObjectGetDerivedStorage();
        uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
        uint64_t v55 = *(void *)(v53 + 2072);
        if (v55)
        {
          uint64_t v56 = *(void *)(v53 + 2544);
          if (v56)
          {
            uint64_t v57 = UpTimeNanoseconds;
            uint64_t v58 = *(void *)(CMBaseObjectGetVTable() + 16);
            uint64_t v59 = v58 ? v58 : 0;
            unint64_t v60 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, void))(v59 + 56);
            if (v60) {
              v60(v56, 0x1EE582CD8, 0x1EE585CF8, (v57 - v55) / 0xF4240uLL, 0);
            }
          }
        }
        uint64_t v7 = v45;
        if (!*(unsigned char *)(v53 + 2597))
        {
          *(unsigned char *)(v53 + 2597) = 1;
          fpfsi_RTCReportingReportStartupPerformanceMetrics();
        }
      }
      if (*v7 == 1)
      {
        strncpy((char *)&time, (const char *)(DerivedStorage + 3080), 8uLL);
        CMTime time = v71;
        CMTimeGetSeconds(&time);
        CMTime time = v67;
        CMTimeGetSeconds(&time);
        kdebug_trace();
      }
      fpfsi_scheduleFVTTransitionsForItem(a2, 3, 0);
    }
    else if (dword_1E9350BB0)
    {
      LODWORD(v70.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
      CMTimeEpoch v21 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
  if (*v7 == 1)
  {
    CMTime time = v71;
    CMTimeGetSeconds(&time);
    kdebug_trace();
  }
  if (!*(unsigned char *)(v63 + 51) && !FigRetainProxyIsInvalidated())
  {
    uint64_t v61 = *(void *)(DerivedStorage + 720);
    if (v61) {
      FigImageQueueTableRespondToTimebaseRateChange(v61, *(OpaqueCMTimebase **)(DerivedStorage + 576));
    }
    if (fpfs_EnsureScanningBoundaryTimer((uint64_t)a2) == -12863) {
      fpfs_HandleScanningBoundaryTimerEnd((const __CFArray *)a2);
    }
  }
  if (*v7 == 1)
  {
    CMTime time = v71;
    CMTimeGetSeconds(&time);
    kdebug_trace();
  }
  fpfs_UnlockAndPostNotificationsWithCaller(v4);
  if (a2) {
    CFRelease(a2);
  }
}

uint64_t fpfsi_getTimebaseStarterTrack(uint64_t a1)
{
  uint64_t result = fpfs_FirstRenderingTrackofType(a1, 1936684398);
  if (!result)
  {
    uint64_t result = fpfs_FirstRenderingTrackofType(a1, 1986618469);
    if (!result)
    {
      uint64_t result = fpfs_FirstRenderingTrackofType(a1, 1835365473);
      if (!result)
      {
        uint64_t result = fpfs_FirstRenderingTrackofType(a1, 1935832172);
        if (!result)
        {
          return fpfs_FirstRenderingTrackofType(a1, 1668047728);
        }
      }
    }
  }
  return result;
}

void fpfsi_scheduleFVTTransitionsForItem(const __CFString *a1, uint64_t a2, int a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v53 = 0;
  memset(v52, 0, sizeof(v52));
  uint64_t v51 = 0;
  memset(v50, 0, sizeof(v50));
  if (!DerivedStorage) {
    return;
  }
  uint64_t v7 = DerivedStorage;
  CFArrayRef v8 = *(const __CFArray **)(CMBaseObjectGetDerivedStorage() + 432);
  if (!v8) {
    return;
  }
  if (CFArrayGetCount(v8) < 1) {
    return;
  }
  uint64_t v48 = CMBaseObjectGetDerivedStorage();
  if (*(const __CFString **)(v48 + 80) != a1) {
    return;
  }
  uint64_t RenderingTrackofType = fpfs_FirstRenderingTrackofType((uint64_t)a1, 1986618469);
  CMTimeFlags v10 = (uint64_t *)RenderingTrackofType;
  if (a2 != 2 && !RenderingTrackofType) {
    return;
  }
  if (!RenderingTrackofType)
  {
    CMBaseObjectGetDerivedStorage();
    LODWORD(v15) = 0;
    unint64_t v13 = 0;
    uint64_t ConcurrentMetadataTracksInDiscontinuityDomainNeededForVideo = 0;
    goto LABEL_19;
  }
  uint64_t ConcurrentMetadataTracksInDiscontinuityDomainNeededForVideo = fpfs_FirstConcurrentMetadataTracksInDiscontinuityDomainNeededForVideo((uint64_t)a1, *(void *)(RenderingTrackofType + 64), (uint64_t)v52);
  if (ConcurrentMetadataTracksInDiscontinuityDomainNeededForVideo < 1)
  {
LABEL_12:
    CMBaseObjectGetDerivedStorage();
    unint64_t v13 = v10;
    while (1)
    {
      if (v13 != v10 && *((_DWORD *)v13 + 8) == 1986618469)
      {
        uint64_t v14 = v13[12];
        if (v14) {
          break;
        }
      }
      unint64_t v13 = (uint64_t *)v13[1];
      if (!v13)
      {
        LODWORD(v15) = 0;
        goto LABEL_19;
      }
    }
    int v34 = a3;
    uint64_t v35 = v7;
    CFTypeRef v36 = (CFTypeRef)*MEMORY[0x1E4F1CFC8];
    CFTypeRef cf = (CFTypeRef)*MEMORY[0x1E4F1CFC8];
    uint64_t v37 = *(void *)(v14 + 32);
    uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
    uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v37);
    uint64_t v40 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v40) {
      uint64_t v41 = v40;
    }
    else {
      uint64_t v41 = 0;
    }
    uint64_t v42 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v41 + 48);
    if (v42)
    {
      v42(FigBaseObject, @"Suspended", AllocatorForMedia, &cf);
      CFTypeRef v43 = cf;
    }
    else
    {
      CFTypeRef v43 = v36;
    }
    if (v43 == v36) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = 0;
    }
    if (v43) {
      CFRelease(v43);
    }
    uint64_t v7 = v35;
    a3 = v34;
    if (v15)
    {
      uint64_t v44 = fpfs_FirstConcurrentMetadataTracksInDiscontinuityDomainNeededForVideo((uint64_t)a1, v15[8], (uint64_t)v50);
      LODWORD(v15) = 1;
LABEL_20:
      CFArrayRef v16 = *(const __CFArray **)(v48 + 432);
      if (!v16) {
        return;
      }
      CFIndex Count = CFArrayGetCount(v16);
      if (Count < 1) {
        return;
      }
      CFIndex v18 = Count;
      CFIndex v19 = 0;
      uint64_t v20 = (const void *)*MEMORY[0x1E4F1CFC8];
      if (a3) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = (uint64_t *)v15;
      }
      CFIndex v45 = Count;
      while (1)
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v48 + 432), v19);
        uint64_t v22 = CMBaseObjectGetDerivedStorage();
        CFTypeRef cf = v20;
        if (!a2) {
          goto LABEL_30;
        }
        if (a2 != 2) {
          break;
        }
        CFTypeRef v24 = v20;
        if (v10) {
          goto LABEL_41;
        }
LABEL_39:
        fpfsi_scheduleFVTTransitionForFVTAndTrack(a1, (uint64_t)ValueAtIndex, v10, (uint64_t)v52, ConcurrentMetadataTracksInDiscontinuityDomainNeededForVideo, 1);
LABEL_40:
        CFTypeRef v24 = cf;
LABEL_41:
        if (v24) {
          CFRelease(v24);
        }
        if (v15 && *(float *)(v7 + 848) != 0.0 && *((_DWORD *)v13 + 38) == 6) {
          fpfsi_scheduleFVTTransitionForFVTAndTrack(a1, (uint64_t)ValueAtIndex, v13, (uint64_t)v50, v44, 0);
        }
        if (v18 == ++v19) {
          return;
        }
      }
      uint64_t v23 = v22;
      CFTypeRef v24 = v20;
      if (a2 != 1) {
        goto LABEL_41;
      }
      CFTypeRef v24 = v20;
      if (*(float *)(v23 + 848) == 0.0) {
        goto LABEL_41;
      }
LABEL_30:
      if (v10)
      {
        int v25 = v15;
        uint64_t v26 = a2;
        CFStringRef v27 = a1;
        uint64_t v28 = v7;
        uint64_t v29 = *(void *)(v10[12] + 32);
        uint64_t v46 = FigGetAllocatorForMedia();
        uint64_t v30 = FigRenderPipelineGetFigBaseObject(v29);
        uint64_t v31 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v31) {
          uint64_t v32 = v31;
        }
        else {
          uint64_t v32 = 0;
        }
        uint64_t v33 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v32 + 48);
        if (v33) {
          v33(v30, @"Suspended", v46, &cf);
        }
        uint64_t v7 = v28;
        a1 = v27;
        a2 = v26;
        uint64_t v15 = v25;
        CFIndex v18 = v45;
        if (!FigCFEqual()) {
          goto LABEL_40;
        }
      }
      goto LABEL_39;
    }
    unint64_t v13 = 0;
LABEL_19:
    uint64_t v44 = 0;
    goto LABEL_20;
  }
  CMTimeEpoch v11 = v52;
  uint64_t v12 = ConcurrentMetadataTracksInDiscontinuityDomainNeededForVideo;
  while (*(void *)(*(void *)v11 + 96))
  {
    CMTimeEpoch v11 = (_OWORD *)((char *)v11 + 8);
    if (!--v12) {
      goto LABEL_12;
    }
  }
}

uint64_t fpfs_EnsureScanningBoundaryTimer(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = MEMORY[0x1E4F1F9F8];
  CMTimeValue v5 = *MEMORY[0x1E4F1F9F8];
  uint64_t v24 = 0;
  CMTimeValue value = v5;
  CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  long long v23 = 0uLL;
  uint64_t v6 = 0;
  if (fpfsi_GetDuration(a1, &v23) || (BYTE12(v23) & 0x11) != 0x11) {
    return v6;
  }
  CMTimeFlags flags = *(_DWORD *)(v4 + 12);
  CMTimeEpoch epoch = *(void *)(v4 + 16);
  float v9 = *(float *)(v3 + 108);
  if (v9 <= 1.0 && v9 >= 0.0)
  {
    uint64_t v6 = 0;
    goto LABEL_15;
  }
  memset(&v22, 0, sizeof(v22));
  CMTimeMake(&v22, 2, 1);
  memset(fireTime, 0, sizeof(fireTime));
  fpfsi_getSeekableTimeRange(a1, fireTime);
  memset(&v20, 0, sizeof(v20));
  fpfs_GetTime(DerivedStorage, (uint64_t)&v20);
  memset(&v19, 0, sizeof(v19));
  CMTime lhs = fireTime[0];
  CMTime rhs = fireTime[1];
  CMTimeAdd(&v19, &lhs, &rhs);
  float v10 = *(float *)(v3 + 108);
  if (v10 > 1.0)
  {
    CMTime lhs = v19;
    CMTime rhs = v22;
    CMTimeSubtract(&time2, &lhs, &rhs);
    CMTime lhs = v20;
    if (CMTimeCompare(&lhs, &time2) < 0)
    {
      CMTimeEpoch v11 = &v19;
      goto LABEL_14;
    }
    float v10 = *(float *)(v3 + 108);
  }
  if (v10 >= 0.0 || (lhs = v20, CMTime rhs = fireTime[0], CMTimeCompare(&lhs, &rhs) < 1))
  {
    uint64_t v6 = 4294954433;
    goto LABEL_15;
  }
  CMTimeEpoch v11 = fireTime;
LABEL_14:
  uint64_t v6 = 0;
  CMTimeValue value = v11->value;
  CMTimeFlags flags = v11->flags;
  CMTimeScale timescale = v11->timescale;
  CMTimeEpoch epoch = v11->epoch;
LABEL_15:
  uint64_t v12 = *(NSObject **)(DerivedStorage + 2304);
  if (flags)
  {
    if (!v12)
    {
      unint64_t v13 = fpfs_TimerDispatchSourceCreate(*(dispatch_queue_t *)(DerivedStorage + 600), *(void **)(DerivedStorage + 16), 0xFFFFFFFFFFFFFFFFLL, (void (__cdecl *)(void *))fpfs_ScanningBoundaryTimerProc, 0);
      *(void *)(DerivedStorage + 2304) = v13;
      if (!v13) {
        return FigSignalErrorAt();
      }
      CMTimebaseAddTimerDispatchSource(*(CMTimebaseRef *)(DerivedStorage + 576), v13);
      uint64_t v12 = *(NSObject **)(DerivedStorage + 2304);
    }
    uint64_t v14 = *(OpaqueCMTimebase **)(DerivedStorage + 576);
    fireTime[0].CMTimeValue value = value;
    *(void *)&fireTime[0].CMTimeScale timescale = __PAIR64__(flags, timescale);
    fireTime[0].CMTimeEpoch epoch = epoch;
    CMTimebaseSetTimerDispatchSourceNextFireTime(v14, v12, fireTime, 0);
  }
  else if (v12)
  {
    fpfs_ReleaseAndClearTimebaseTimer(*(OpaqueCMTimebase **)(DerivedStorage + 576), (dispatch_object_t *)(DerivedStorage + 2304));
  }
  return v6;
}

void fpfs_HandleScanningBoundaryTimerEnd(const __CFArray *a1)
{
  uint64_t DerivedStorage = (void **)CMBaseObjectGetDerivedStorage();
  uint64_t v3 = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(unsigned int *)(v3 + 632);
  uint64_t v5 = *(void *)(v3 + 80);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v3 + 72));
  if (v5) {
    uint64_t v7 = Count + 1;
  }
  else {
    uint64_t v7 = Count;
  }
  if (FigPlaybackGetEffectiveActionAtEnd(v4, v7) == 2)
  {
    CFArrayRef v8 = *DerivedStorage;
    fpfs_SetRateWithFade(v8, 1.0);
  }
  else
  {
    fpfs_StopPlayingItem(v3, a1, 0);
  }
}

uint64_t FigReportingAgentStatsUpdateSampleValue(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v7 = result;
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v10 = *(void *)(VTable + 16);
    uint64_t result = VTable + 16;
    uint64_t v9 = v10;
    uint64_t v11 = v10 ? v9 : 0;
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 40);
    if (v12)
    {
      return v12(v7, a2, a3, a4);
    }
  }
  return result;
}

uint64_t fpfs_FirstRenderingTrackofType(uint64_t a1, int a2)
{
  for (uint64_t result = *(void *)(CMBaseObjectGetDerivedStorage() + 1048); result; uint64_t result = *(void *)(result + 8))
  {
    if (*(_DWORD *)(result + 32) == a2 && *(void *)(result + 96)) {
      break;
    }
  }
  return result;
}

void fpfsi_RTCReportingReportStartupPerformanceMetrics()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  if (!*(void *)(DerivedStorage + 2584))
  {
    uint64_t v1 = DerivedStorage;
    uint64_t v2 = *(void *)(DerivedStorage + 2544);
    if (v2)
    {
      uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v4 = v3 ? v3 : 0;
      uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, CFTypeRef *))(v4 + 8);
      if (v5)
      {
        int v6 = v5(v2, 0x1EE582B78, 115, 0, &cf);
        CFTypeRef v7 = cf;
        if (!v6)
        {
          CFArrayRef v8 = *(const void **)(v1 + 2584);
          *(void *)(v1 + 2584) = cf;
          if (v7) {
            CFRetain(v7);
          }
          if (v8) {
            CFRelease(v8);
          }
          fpfsi_UpdateAccessLogStartupPerformanceMetrics();
          CFTypeRef v7 = cf;
        }
        if (v7) {
          CFRelease(v7);
        }
      }
    }
  }
}

void fpfsi_UpdateAccessLogStartupPerformanceMetrics()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef v1 = *(const __CFArray **)(DerivedStorage + 1912);
  if (v1 && CFArrayGetCount(v1) >= 1 && *(void *)(DerivedStorage + 2584))
  {
    CFNumberRef ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 1912), 0);
    uint64_t v3 = *(const void **)(DerivedStorage + 2584);
    CFDictionarySetValue(ValueAtIndex, @"c-startup_perf", v3);
  }
}

uint64_t fpfs_FirstConcurrentMetadataTracksInDiscontinuityDomainNeededForVideo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  TracksInListOfCMMediaType MediaType = fpfsi_findTracksInListOfMediaType(1835365473, *(void *)(DerivedStorage + 1048), *(void *)(DerivedStorage + 1056), a2, (uint64_t)v12, 0, 0);
  if (TracksInListOfMediaType < 1) {
    return 0;
  }
  uint64_t v7 = TracksInListOfMediaType;
  uint64_t v8 = 0;
  uint64_t v9 = v12;
  do
  {
    uint64_t v10 = *(void *)v9;
    if (fpfs_isKnownMebxMetadataForRendering(*(const opaqueCMFormatDescription **)(*(void *)v9 + 40)))
    {
      *(void *)(a3 + 8 * v8++) = v10;
      if (v8 == 5) {
        break;
      }
    }
    uint64_t v9 = (_OWORD *)((char *)v9 + 8);
    --v7;
  }
  while (v7);
  return v8;
}

void fpfsi_scheduleFVTTransitionForFVTAndTrack(const __CFString *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMBaseObjectGetDerivedStorage();
  CFTypeRef v94 = 0;
  CMTimeValue v117 = *MEMORY[0x1E4F1F9F8];
  CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  CMTime v93 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CFTypeRef v92 = 0;
  if (!*(void *)(DerivedStorage + 744))
  {
    if (dword_1E9350BB0)
    {
      LODWORD(CFDictionarySetValue(theDict, key, value) = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    goto LABEL_98;
  }
  int v86 = a6;
  uint64_t v13 = *(void *)DerivedStorage;
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFStringRef v85 = a1;
  uint64_t v87 = a4;
  if (fpfs_createDataChannelConfigurationAndSetIdentifiers(v13, a1, (CFMutableStringRef)a3, a4, a5, AllocatorForMedia, (uint64_t *)&v94, (CFMutableStringRef *)&v92))goto LABEL_98; {
  if (a3)
  }
  {
    CFTypeRef v15 = v94;
    CFTypeRef v16 = v92;
    v116.CMTimeValue value = 0;
    cf.CMTimeValue value = 0;
    if (a3[11])
    {
      int v17 = FPSupport_CreateFigTagCollectionFromFormatDescriptionExtensions((const opaqueCMFormatDescription *)a3[5], &cf);
      if (v17) {
        goto LABEL_106;
      }
      CMTimeValue v18 = cf.value;
      FigGetAllocatorForMedia();
      if (v18) {
        FigTagCollectionCreateMutableCopy();
      }
      else {
        FigTagCollectionCreateMutable();
      }
      if (v116.value)
      {
        int v17 = CMTagCollectionAddTag((CMMutableTagCollectionRef)v116.value, *MEMORY[0x1E4F21E08]);
        if (!v17)
        {
          CFAllocatorRef v19 = (const __CFAllocator *)FigGetAllocatorForMedia();
          CFMutableStringRef Mutable = CFDictionaryCreateMutable(v19, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (Mutable)
          {
            CMTimeValue value = 0;
            uint64_t v21 = *a3;
            uint64_t v22 = FigGetAllocatorForMedia();
            uint64_t FigBaseObject = FigPlaybackItemGetFigBaseObject(v21);
            uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 8);
            uint64_t v25 = v24 ? v24 : 0;
            uint64_t v26 = *(void (**)(uint64_t, __CFString *, uint64_t, void **))(v25 + 48);
            if (v26)
            {
              v26(FigBaseObject, @"VideoTrackMatrix", v22, &value);
              if (value)
              {
                CFDictionarySetValue(Mutable, @"TrackMatrix", value);
                if (value) {
                  CFRelease(value);
                }
              }
            }
          }
          uint64_t v27 = a3[11];
          CMTimeValue v28 = v116.value;
          uint64_t v29 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v29) {
            uint64_t v30 = v29;
          }
          else {
            uint64_t v30 = 0;
          }
          uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CMTimeValue, __CFDictionary *, CFTypeRef, CFTypeRef))(v30 + 32);
          if (v31)
          {
            int v32 = v31(v27, a2, 1, v28, Mutable, v15, v16);
            if (!Mutable)
            {
LABEL_27:
              if (v116.value) {
                CFRelease((CFTypeRef)v116.value);
              }
              if (cf.value) {
                CFRelease((CFTypeRef)cf.value);
              }
              if (v32) {
                goto LABEL_98;
              }
              goto LABEL_32;
            }
          }
          else
          {
            int v32 = -12782;
            if (!Mutable) {
              goto LABEL_27;
            }
          }
          CFRelease(Mutable);
          goto LABEL_27;
        }
LABEL_106:
        int v32 = v17;
        goto LABEL_27;
      }
    }
    int v17 = FigSignalErrorAt();
    goto LABEL_106;
  }
LABEL_32:
  if (a5 < 1)
  {
LABEL_41:
    uint64_t v42 = *(void *)(DerivedStorage + 744);
    CFTypeRef v43 = v94;
    CFTypeRef v44 = v92;
    uint64_t v45 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v45) {
      uint64_t v46 = v45;
    }
    else {
      uint64_t v46 = 0;
    }
    unsigned int v47 = *(unsigned int (**)(uint64_t, uint64_t, CFTypeRef, CFTypeRef, uint64_t))(v46 + 8);
    if (!v47 || v47(v42, a2, v43, v44, 100)) {
      goto LABEL_98;
    }
    FigDataChannelConfigurationGetResourceCount((uint64_t)v94);
    if (!v86)
    {
      if (a3
        && *((_DWORD *)a3 + 38) == 6
        && (*((unsigned char *)a3 + 484) & 1) != 0
        && CMTimebaseGetRate(*(CMTimebaseRef *)(DerivedStorage + 576)) != 0.0)
      {
        uint64_t v53 = *(const void **)(DerivedStorage + 576);
        CMClockRef HostTimeClock = CMClockGetHostTimeClock();
        CMTime cf = *(CMTime *)(a3 + 59);
        CMSyncConvertTime(&v116, &cf, v53, HostTimeClock);
        CMTimeValue v117 = v116.value;
        CMTimeFlags flags = v116.flags;
        CMTimeScale timescale = v116.timescale;
        CMTimeEpoch epoch = v116.epoch;
        fpfs_GetTime(DerivedStorage, (uint64_t)&time);
        uint64_t v57 = *(const void **)(DerivedStorage + 576);
        CMClockRef v58 = CMClockGetHostTimeClock();
        CMSyncConvertTime(&v93, &time, v57, v58);
        if (dword_1E9350BB0)
        {
          LODWORD(CFDictionarySetValue(theDict, key, value) = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          uint64_t v59 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v60 = value;
          if (os_log_type_enabled(v59, type)) {
            unsigned int v61 = v60;
          }
          else {
            unsigned int v61 = v60 & 0xFFFFFFFE;
          }
          if (v61)
          {
            CMTimeEpoch v62 = epoch;
            uint64_t v63 = *(void *)DerivedStorage;
            if (*(void *)DerivedStorage) {
              unint64_t v64 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
            }
            else {
              unint64_t v64 = "";
            }
            unint64_t v84 = v64;
            if (v85) {
              CMTime v72 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
            }
            else {
              CMTime v72 = "";
            }
            uint64_t v83 = v72;
            int v73 = *((_DWORD *)a3 + 4);
            if (a5 < 1) {
              int v74 = -1;
            }
            else {
              int v74 = *(_DWORD *)(*(void *)v87 + 16);
            }
            int v88 = v74;
            v116.CMTimeValue value = v117;
            v116.CMTimeScale timescale = timescale;
            v116.CMTimeFlags flags = flags;
            v116.CMTimeEpoch epoch = v62;
            Float64 Seconds = CMTimeGetSeconds(&v116);
            CMTime v116 = v93;
            Float64 v76 = CMTimeGetSeconds(&v116);
            fpfs_GetTime(DerivedStorage, (uint64_t)&v89);
            Float64 v77 = CMTimeGetSeconds(&v89);
            LODWORD(cf.CFDictionarySetValue(theDict, key, value) = 136317954;
            *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"fpfsi_scheduleFVTTransitionForFVTAndTrack";
            LOWORD(cf.flags) = 2048;
            *(void *)((char *)&cf.flags + 2) = v63;
            CMTimeEpoch epoch = v62;
            HIWORD(cf.epoch) = 2082;
            uint64_t v97 = v84;
            __int16 v98 = 2048;
            CFStringRef v99 = v85;
            __int16 v100 = 2082;
            uint64_t v101 = v83;
            __int16 v102 = 1024;
            int v103 = v73;
            __int16 v104 = 1024;
            int v105 = v88;
            __int16 v106 = 1024;
            int v107 = a5;
            __int16 v108 = 2048;
            Float64 v109 = Seconds;
            __int16 v110 = 2048;
            Float64 v111 = v76;
            __int16 v112 = 2048;
            Float64 v113 = v77;
            __int16 v114 = 2112;
            CFTypeRef v115 = v92;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        if (flags)
        {
          CFTypeRef v78 = v94;
          uint64_t v79 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v80 = v79 ? v79 : 0;
          uint64_t v81 = *(void (**)(uint64_t, CFTypeRef, CMTime *))(v80 + 64);
          if (v81)
          {
            v116.CMTimeValue value = v117;
            v116.CMTimeScale timescale = timescale;
            v116.CMTimeFlags flags = flags;
            v116.CMTimeEpoch epoch = epoch;
            v81(a2, v78, &v116);
          }
        }
      }
      goto LABEL_98;
    }
    if (!dword_1E9350BB0)
    {
LABEL_77:
      CFTypeRef v68 = v94;
      uint64_t v69 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v69) {
        uint64_t v70 = v69;
      }
      else {
        uint64_t v70 = 0;
      }
      CMTime v71 = *(void (**)(uint64_t, CFTypeRef))(v70 + 72);
      if (v71) {
        v71(a2, v68);
      }
      goto LABEL_98;
    }
    LODWORD(CFDictionarySetValue(theDict, key, value) = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    uint64_t v48 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int v49 = value;
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v50 = v49;
    }
    else {
      unsigned int v50 = v49 & 0xFFFFFFFE;
    }
    if (!v50)
    {
LABEL_76:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      goto LABEL_77;
    }
    uint64_t v51 = *(void *)DerivedStorage;
    if (v51) {
      Float64 v52 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
    }
    else {
      Float64 v52 = "";
    }
    if (v85)
    {
      CMTime v65 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
      if (a3)
      {
LABEL_69:
        int v66 = *((_DWORD *)a3 + 4);
LABEL_72:
        if (*(void *)v87) {
          int v67 = *(_DWORD *)(*(void *)v87 + 16);
        }
        else {
          int v67 = -1;
        }
        LODWORD(cf.CFDictionarySetValue(theDict, key, value) = 136317186;
        *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"fpfsi_scheduleFVTTransitionForFVTAndTrack";
        LOWORD(cf.flags) = 2048;
        *(void *)((char *)&cf.flags + 2) = v51;
        HIWORD(cf.epoch) = 2082;
        uint64_t v97 = v52;
        __int16 v98 = 2048;
        CFStringRef v99 = v85;
        __int16 v100 = 2082;
        uint64_t v101 = v65;
        __int16 v102 = 1024;
        int v103 = v66;
        __int16 v104 = 1024;
        int v105 = v67;
        __int16 v106 = 1024;
        int v107 = a5;
        __int16 v108 = 2112;
        Float64 v109 = *(double *)&v92;
        _os_log_send_and_compose_impl();
        goto LABEL_76;
      }
    }
    else
    {
      CMTime v65 = "";
      if (a3) {
        goto LABEL_69;
      }
    }
    int v66 = -1;
    goto LABEL_72;
  }
  uint64_t v33 = v87;
  uint64_t v34 = a5;
  while (1)
  {
    uint64_t v35 = *(void *)(*(void *)v33 + 88);
    if (v35)
    {
      int v36 = *(_DWORD *)(*(void *)v33 + 28);
      CFTypeRef v37 = v94;
      CFTypeRef v38 = v92;
      uint64_t v39 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v40 = v39 ? v39 : 0;
      uint64_t v41 = *(unsigned int (**)(uint64_t, uint64_t, void, void, void, CFTypeRef, CFTypeRef))(v40 + 32);
      if (!v41 || v41(v35, a2, (v36 + 101), 0, 0, v37, v38)) {
        break;
      }
    }
    v33 += 8;
    if (!--v34) {
      goto LABEL_41;
    }
  }
LABEL_98:
  if (v94) {
    CFRelease(v94);
  }
  if (v92) {
    CFRelease(v92);
  }
}

uint64_t fpfsi_findTracksInListOfMediaType(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  char v16 = 0;
  uint64_t v15 = 0;
  if (a2)
  {
    uint64_t v11 = a2;
    do
    {
      if (*(_DWORD *)(v11 + 32) == a1 && (a4 == 0x7FFFFFFF || *(void *)(v11 + 64) == a4))
      {
        if (a6 >= 1)
        {
          uint64_t v13 = 0;
          do
          {
            if (fpfsi_areTracksSyncPairs(*(void *)(a5 + 8 * v13), v11))
            {
              if (a7 || !*((unsigned char *)&v15 + v13))
              {
                *(void *)(a5 + 8 * v13) = v11;
                *((unsigned char *)&v15 + v13) = 1;
              }
              goto LABEL_15;
            }
            ++v13;
          }
          while (a6 != v13);
          if (a6 == 4) {
            return a6;
          }
        }
        *(void *)(a5 + 8 * a6) = v11;
        *((unsigned char *)&v15 + a6++) = 1;
      }
LABEL_15:
      uint64_t v11 = *(void *)(v11 + 8);
    }
    while (v11);
  }
  return a6;
}

uint64_t fpfs_isKnownMebxMetadataForRendering(const opaqueCMFormatDescription *a1)
{
  if (CMFormatDescriptionGetMediaSubType(a1) != 1835360888) {
    return 0;
  }
  CMMetadataFormatDescriptionGetIdentifiers(a1);
  if (FigCFArrayContainsValue()) {
    return 1;
  }
  if (FigCFArrayContainsValue()) {
    return 1;
  }
  if (FigCFArrayContainsValue()) {
    return 1;
  }
  uint64_t result = FigCFArrayContainsValue();
  if (result) {
    return 1;
  }
  return result;
}

BOOL fpfsi_areTracksSyncPairs(uint64_t a1, uint64_t a2)
{
  CMBaseObjectGetDerivedStorage();
  if (*(void *)(a1 + 64) != *(void *)(a2 + 64)) {
    return 0;
  }

  return fpfsi_canTracksBeSyncPairsIgnoringDiscontinuity(a1, a2);
}

BOOL fpfsi_canTracksBeSyncPairsIgnoringDiscontinuity(uint64_t a1, uint64_t a2)
{
  CMBaseObjectGetDerivedStorage();
  int v4 = *(_DWORD *)(a1 + 32);
  int v5 = *(_DWORD *)(a2 + 32);
  if (v4 != 1835365473 || v5 != 1835365473) {
    return v4 == v5;
  }
  if (*(unsigned __int8 *)(a1 + 180) == *(unsigned __int8 *)(a2 + 180)) {
    return fpfsi_canMetadataFormatsSync(*(const opaqueCMFormatDescription **)(a1 + 40), *(const opaqueCMFormatDescription **)(a2 + 40)) != 0;
  }
  return 0;
}

uint64_t fpfs_createDataChannelConfigurationAndSetIdentifiers(uint64_t a1, CFStringRef a2, CFMutableStringRef length, uint64_t a4, uint64_t a5, const __CFAllocator *a6, uint64_t *a7, CFMutableStringRef *a8)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFStringRef v30 = 0;
  appendedCFStringRef String = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v17 = CFStringCreateWithCString(a6, (const char *)(DerivedStorage + 824), 0x600u);
  FigCFDictionarySetValue();
  if (a2)
  {
    uint64_t v18 = CMBaseObjectGetDerivedStorage();
    a2 = CFStringCreateWithCString(a6, (const char *)(v18 + 3080), 0x600u);
    FigCFDictionarySetValue();
    FigCFDictionarySetValue();
  }
  if (!length) {
    goto LABEL_25;
  }
  size_t length = (CFMutableStringRef)length[2].length;
  if (!length) {
    goto LABEL_25;
  }
  uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  uint64_t v21 = *(uint64_t (**)(CFMutableStringRef, CFStringRef *))(v20 + 40);
  if (!v21)
  {
    size_t length = 0;
LABEL_29:
    uint64_t v24 = 4294954514;
    goto LABEL_30;
  }
  uint64_t v22 = v21(length, &appendedString);
  if (v22)
  {
    uint64_t v24 = v22;
    size_t length = 0;
    if (!Mutable) {
      goto LABEL_32;
    }
LABEL_31:
    CFRelease(Mutable);
    goto LABEL_32;
  }
  if (!appendedString) {
    goto LABEL_24;
  }
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  size_t length = CFStringCreateMutable(AllocatorForMedia, 0);
  CFStringAppend(length, appendedString);
  if (a5 >= 1)
  {
    while (1)
    {
      uint64_t v24 = *(void *)(*(void *)a4 + 88);
      if (!v24) {
        break;
      }
      uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v25) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = 0;
      }
      uint64_t v27 = *(uint64_t (**)(uint64_t, CFStringRef *))(v26 + 40);
      if (!v27) {
        goto LABEL_29;
      }
      uint64_t v28 = v27(v24, &v30);
      if (v28) {
        goto LABEL_26;
      }
      CFStringAppend(length, @"/");
      CFStringAppend(length, v30);
      if (v30)
      {
        CFRelease(v30);
        CFStringRef v30 = 0;
      }
      a4 += 8;
      if (!--a5) {
        goto LABEL_21;
      }
    }
LABEL_30:
    if (!Mutable) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
LABEL_21:
  if (length)
  {
    FigCFDictionarySetValue();
    if (a8)
    {
      *a8 = length;
LABEL_24:
      size_t length = 0;
    }
  }
LABEL_25:
  uint64_t v28 = FigDataChannelConfigurationCreate(a6, Mutable, a7);
LABEL_26:
  uint64_t v24 = v28;
  if (Mutable) {
    goto LABEL_31;
  }
LABEL_32:
  if (v17) {
    CFRelease(v17);
  }
  if (a2) {
    CFRelease(a2);
  }
  if (length) {
    CFRelease(length);
  }
  if (appendedString) {
    CFRelease(appendedString);
  }
  if (v30) {
    CFRelease(v30);
  }
  return v24;
}

uint64_t fpfsi_GetDuration(uint64_t a1, long long *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    int v4 = DerivedStorage;
    int v5 = *DerivedStorage;
    CFDictionaryRef dictionaryRepresentation = 0;
    uint64_t v6 = MEMORY[0x1E4F1F9F0];
    *a2 = *MEMORY[0x1E4F1F9F0];
    *((void *)a2 + 2) = *(void *)(v6 + 16);
    fpfs_LockMutexWithCaller(v5);
    if (FigRetainProxyIsInvalidated())
    {
      uint64_t v7 = FigSignalErrorAt();
      if (v7) {
        goto LABEL_32;
      }
    }
    uint64_t v8 = v4[117];
    if (v8)
    {
      uint64_t v9 = v4 + 166;
      if (*((unsigned char *)v4 + 1340))
      {
        long long v15 = *(_OWORD *)v9;
        *((void *)a2 + 2) = v4[168];
        *a2 = v15;
      }
      else
      {
        uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
        uint64_t FigBaseObject = FigBytePumpGetFigBaseObject(v8);
        uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v12) {
          uint64_t v13 = v12;
        }
        else {
          uint64_t v13 = 0;
        }
        char v16 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFDictionaryRef *))(v13 + 48);
        if (v16)
        {
          uint64_t v17 = v16(FigBaseObject, @"FBP_Duration", AllocatorForMedia, &dictionaryRepresentation);
          if (v17)
          {
            uint64_t v7 = v17;
            if ((v17 & 0xFFFFFFFD) != 0xFFFFCE10) {
              goto LABEL_32;
            }
          }
          else
          {
            CMTimeMakeFromDictionary(&time1, dictionaryRepresentation);
            *a2 = *(_OWORD *)&time1.value;
            CFDictionaryRef v18 = dictionaryRepresentation;
            *((void *)a2 + 2) = time1.epoch;
            CFRelease(v18);
          }
        }
        long long v19 = *a2;
        v4[168] = (const void *)*((void *)a2 + 2);
        *(_OWORD *)uint64_t v9 = v19;
      }
      if ((*((_DWORD *)a2 + 3) & 0x1D) == 1)
      {
        CMTimeValue v26 = *MEMORY[0x1E4F1FA48];
        CMTimeFlags v20 = *(_DWORD *)(MEMORY[0x1E4F1FA48] + 12);
        CMTimeScale v27 = *(_DWORD *)(MEMORY[0x1E4F1FA48] + 8);
        CMTimeEpoch v21 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
        for (uint64_t i = v4[131]; i; uint64_t i = (const void *)*((void *)i + 1))
        {
          if (!*((unsigned char *)i + 184) && *((_DWORD *)i + 38) == 6 && (*((unsigned char *)i + 228) & 1) != 0)
          {
            time1.CMTimeScale timescale = v27;
            time1.CMTimeFlags flags = v20;
            time1.CMTimeEpoch epoch = v21;
            CMTime v23 = *(CMTime *)((unsigned char *)i + 9);
            time1.CMTimeValue value = v26;
            if (CMTimeCompare(&time1, &v23) < 0)
            {
              CMTimeValue v26 = *((void *)i + 27);
              CMTimeScale v27 = *((_DWORD *)i + 56);
              CMTimeFlags v20 = *((_DWORD *)i + 57);
              CMTimeEpoch v21 = *((void *)i + 29);
            }
          }
        }
        if ((v20 & 0x1D) == 1)
        {
          time1.CMTimeScale timescale = v27;
          time1.CMTimeFlags flags = v20;
          time1.CMTimeEpoch epoch = v21;
          CMTime v23 = *(CMTime *)a2;
          time1.CMTimeValue value = v26;
          if (CMTimeCompare(&time1, &v23) >= 1)
          {
            *(void *)a2 = v26;
            *((_DWORD *)a2 + 2) = v27;
            *((_DWORD *)a2 + 3) = v20;
            *((void *)a2 + 2) = v21;
            *(_OWORD *)uint64_t v9 = *a2;
            audit_token_t v9[2] = (const void *)v21;
          }
        }
      }
      uint64_t v7 = 0;
      goto LABEL_32;
    }
    uint64_t v7 = 4294954513;
LABEL_32:
    fpfs_UnlockAndPostNotificationsWithCaller(v5);
    return v7;
  }

  return FigSignalErrorAt();
}

uint64_t fpfsi_getSeekableTimeRange@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = MEMORY[0x1E4F1FA20];
  long long v6 = *MEMORY[0x1E4F1FA20];
  long long v7 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  *a2 = *MEMORY[0x1E4F1FA20];
  a2[1] = v7;
  long long v8 = *(_OWORD *)(v5 + 32);
  a2[2] = v8;
  long long v14 = v6;
  long long v15 = v7;
  long long v16 = v8;
  uint64_t result = fpfsi_getPumpAvailableTimeRange(DerivedStorage, &v14);
  if (result
    || (BYTE12(v14) & 1) == 0
    || (BYTE4(v16) & 1) == 0
    || *((void *)&v16 + 1)
    || (*((void *)&v15 + 1) & 0x8000000000000000) != 0)
  {
    uint64_t result = fpfsi_TotalTimeRangeInBuffer(a1, (uint64_t)v13);
    long long v12 = v13[1];
    *a2 = v13[0];
    a2[1] = v12;
    long long v11 = v13[2];
  }
  else
  {
    long long v10 = v15;
    *a2 = v14;
    a2[1] = v10;
    long long v11 = v16;
  }
  a2[2] = v11;
  return result;
}

NSObject *fpfs_TimerDispatchSourceCreate(dispatch_queue_t queue, void *a2, dispatch_time_t a3, void (__cdecl *a4)(void *), void (__cdecl *a5)(void *))
{
  uint64_t v9 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 1uLL, queue);
  if (v9)
  {
    if (a2) {
      CFRetain(a2);
    }
    dispatch_set_context(v9, a2);
    dispatch_source_set_timer(v9, a3, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_event_handler_f(v9, a4);
    dispatch_source_set_cancel_handler_f(v9, a5);
    dispatch_set_finalizer_f(v9, (dispatch_function_t)FigCFRelease_0);
    dispatch_resume(v9);
  }
  return v9;
}

void fpfs_ScanningBoundaryTimerProc(uint64_t a1)
{
  CFTypeRef v5 = 0;
  CFTypeRef cf = 0;
  if (fpfsi_CopyPlayerAndItemFromItemRetainProxyAndLockPlayer(a1, &cf, &v5))
  {
    CFTypeRef v3 = v5;
    if (v5) {
LABEL_5:
    }
      CFRelease(v3);
  }
  else
  {
    CFTypeRef v1 = cf;
    id v2 = *(id *)(CMBaseObjectGetDerivedStorage() + 776);
    voucher_adopt();
    CFTypeRef v3 = v5;
    if (fpfs_EnsureScanningBoundaryTimer(v5) == -12863) {
      fpfs_HandleScanningBoundaryTimerEnd((const __CFArray *)v3);
    }

    fpfs_UnlockAndPostNotificationsWithCaller(v1);
    if (v3) {
      goto LABEL_5;
    }
  }
  CFTypeRef v4 = cf;
  if (cf)
  {
    CFRelease(v4);
  }
}

uint64_t fpfsi_getPumpAvailableTimeRange(uint64_t a1, _OWORD *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef dictionaryRepresentation = 0;
  uint64_t v2 = MEMORY[0x1E4F1FA20];
  long long v3 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  *a2 = *MEMORY[0x1E4F1FA20];
  a2[1] = v3;
  a2[2] = *(_OWORD *)(v2 + 32);
  uint64_t v4 = *(void *)(a1 + 936);
  if (!v4) {
    return 4294954436;
  }
  uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
  uint64_t FigBaseObject = FigBytePumpGetFigBaseObject(v4);
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  long long v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFDictionaryRef *))(v10 + 48);
  if (!v11) {
    return 4294954514;
  }
  uint64_t result = v11(FigBaseObject, 0x1EE53E178, AllocatorForMedia, &dictionaryRepresentation);
  if (result) {
    return result;
  }
  CMTimeMakeFromDictionary(&v24.start, dictionaryRepresentation);
  CMTimeScale timescale = v24.start.timescale;
  CMTimeValue value = v24.start.value;
  lhs.CMTimeEpoch epoch = v24.start.epoch;
  CMTime rhs = *(CMTime *)(a1 + 1184);
  *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&v24.start.value;
  CMTimeSubtract(&v24.start, &lhs, &rhs);
  CMTimeValue value = v24.start.value;
  CMTimeFlags flags = v24.start.flags;
  CMTimeScale timescale = v24.start.timescale;
  CMTimeEpoch epoch = v24.start.epoch;
  CFRelease(dictionaryRepresentation);
  uint64_t v15 = *(void *)(a1 + 936);
  uint64_t v16 = FigGetAllocatorForMedia();
  uint64_t v17 = FigBytePumpGetFigBaseObject(v15);
  uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 8);
  uint64_t v19 = v18 ? v18 : 0;
  CMTimeFlags v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFDictionaryRef *))(v19 + 48);
  if (!v20) {
    return 4294954514;
  }
  uint64_t result = v20(v17, 0x1EE53E198, v16, &dictionaryRepresentation);
  if (!result)
  {
    CMTimeMakeFromDictionary(&v24.start, dictionaryRepresentation);
    CMTimeScale v29 = v24.start.timescale;
    CMTimeValue v28 = v24.start.value;
    lhs.CMTimeEpoch epoch = v24.start.epoch;
    CMTime rhs = *(CMTime *)(a1 + 1184);
    *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&v24.start.value;
    CMTimeSubtract(&v24.start, &lhs, &rhs);
    CMTimeValue v28 = v24.start.value;
    CMTimeFlags v21 = v24.start.flags;
    CMTimeScale v29 = v24.start.timescale;
    CMTimeEpoch v22 = v24.start.epoch;
    CFRelease(dictionaryRepresentation);
    uint64_t result = 0;
    if (flags & 1) != 0 && (v21)
    {
      rhs.CMTimeEpoch epoch = v22;
      lhs.CMTimeValue value = value;
      lhs.CMTimeScale timescale = timescale;
      lhs.CMTimeFlags flags = flags;
      lhs.CMTimeEpoch epoch = epoch;
      rhs.CMTimeValue value = v28;
      rhs.CMTimeScale timescale = v29;
      rhs.CMTimeFlags flags = v21;
      CMTimeRangeFromTimeToTime(&v24, &lhs, &rhs);
      uint64_t result = 0;
      long long v23 = *(_OWORD *)&v24.start.epoch;
      *a2 = *(_OWORD *)&v24.start.value;
      a2[1] = v23;
      a2[2] = *(_OWORD *)&v24.duration.timescale;
    }
  }
  return result;
}

uint64_t fpfsi_TotalTimeRangeInBuffer@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  uint64_t v5 = MEMORY[0x1E4F1FA20];
  long long v53 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  long long v54 = *MEMORY[0x1E4F1FA20];
  *(_OWORD *)a2 = *MEMORY[0x1E4F1FA20];
  *(_OWORD *)(a2 + 16) = v53;
  long long v52 = *(_OWORD *)(v5 + 32);
  *(_OWORD *)(a2 + 32) = v52;
  uint64_t result = fpfsi_HasRequiredSubstreamsToIndicateBuffering();
  if (!result) {
    return result;
  }
  uint64_t v7 = 0;
  __int16 v72 = 0;
  int v71 = 0;
  int v69 = 0;
  __int16 v70 = 0;
  do
  {
    long long v8 = &v80[v7];
    *long long v8 = v54;
    v8[1] = v53;
    v8[2] = v52;
    uint64_t v9 = &v79[v7];
    *uint64_t v9 = v54;
    v9[1] = v53;
    v7 += 48;
    audit_token_t v9[2] = v52;
  }
  while (v7 != 288);
  uint64_t v10 = &v71;
  fpfsi_TotalTimeRangeInBufferForTrackList((opaqueCMBufferQueue *)(DerivedStorage + 131), (uint64_t)v80, (uint64_t)&v71);
  long long v11 = (unsigned __int8 *)&v69;
  uint64_t result = (uint64_t)fpfsi_TotalTimeRangeInBufferForTrackList((opaqueCMBufferQueue *)(DerivedStorage + 133), (uint64_t)v79, (uint64_t)&v69);
  uint64_t v12 = 0;
  p_CMTime duration = &v63.duration;
  do
  {
    if (*v11++)
    {
      uint64_t v15 = &v79[v12];
      if ((v79[v12 + 12] & 1) != 0
        && (v15[36] & 1) != 0
        && !*(void *)&v79[v12 + 40]
        && (*((void *)v15 + 3) & 0x8000000000000000) == 0)
      {
        if (*(unsigned char *)v10
          && (uint64_t v16 = &v80[v12], (v80[v12 + 12] & 1) != 0)
          && (v16[36] & 1) != 0
          && !*(void *)&v80[v12 + 40]
          && (*((void *)v16 + 3) & 0x8000000000000000) == 0)
        {
          uint64_t v51 = p_duration;
          long long v19 = *((_OWORD *)v15 + 1);
          *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)v15;
          *(_OWORD *)&range.start.CMTimeEpoch epoch = v19;
          *(_OWORD *)&range.duration.CMTimeScale timescale = *((_OWORD *)v15 + 2);
          long long v20 = *((_OWORD *)v16 + 1);
          *(_OWORD *)CMTimeRange otherRange = *(_OWORD *)v16;
          *(_OWORD *)&otherRange[16] = v20;
          *(_OWORD *)&otherRange[32] = *((_OWORD *)v16 + 2);
          CMTimeRangeGetIntersection(&v68, &range, (CMTimeRange *)otherRange);
          if (v68.start.flags)
          {
            long long v21 = *((_OWORD *)v15 + 1);
            *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)v15;
            *(_OWORD *)&range.start.CMTimeEpoch epoch = v21;
            *(_OWORD *)&range.duration.CMTimeScale timescale = *((_OWORD *)v15 + 2);
            long long v22 = *((_OWORD *)v16 + 1);
            *(_OWORD *)CMTimeRange otherRange = *(_OWORD *)v16;
            *(_OWORD *)&otherRange[16] = v22;
            *(_OWORD *)&otherRange[32] = *((_OWORD *)v16 + 2);
            CMTimeRangeGetIntersection(&v67, &range, (CMTimeRange *)otherRange);
            if (v67.duration.flags)
            {
              long long v23 = *((_OWORD *)v15 + 1);
              *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)v15;
              *(_OWORD *)&range.start.CMTimeEpoch epoch = v23;
              *(_OWORD *)&range.duration.CMTimeScale timescale = *((_OWORD *)v15 + 2);
              long long v24 = *((_OWORD *)v16 + 1);
              *(_OWORD *)CMTimeRange otherRange = *(_OWORD *)v16;
              *(_OWORD *)&otherRange[16] = v24;
              *(_OWORD *)&otherRange[32] = *((_OWORD *)v16 + 2);
              CMTimeRangeGetIntersection(&v66, &range, (CMTimeRange *)otherRange);
              if (!v66.duration.epoch)
              {
                long long v28 = *((_OWORD *)v15 + 1);
                *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)v15;
                *(_OWORD *)&range.start.CMTimeEpoch epoch = v28;
                *(_OWORD *)&range.duration.CMTimeScale timescale = *((_OWORD *)v15 + 2);
                long long v29 = *((_OWORD *)v16 + 1);
                *(_OWORD *)CMTimeRange otherRange = *(_OWORD *)v16;
                *(_OWORD *)&otherRange[16] = v29;
                *(_OWORD *)&otherRange[32] = *((_OWORD *)v16 + 2);
                CMTimeRangeGetIntersection(&v65, &range, (CMTimeRange *)otherRange);
                if ((v65.duration.value & 0x8000000000000000) == 0)
                {
                  long long v30 = *((_OWORD *)v15 + 1);
                  *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)v15;
                  *(_OWORD *)&range.start.CMTimeEpoch epoch = v30;
                  *(_OWORD *)&range.duration.CMTimeScale timescale = *((_OWORD *)v15 + 2);
                  long long v31 = *((_OWORD *)v16 + 1);
                  *(_OWORD *)CMTimeRange otherRange = *(_OWORD *)v16;
                  *(_OWORD *)&otherRange[16] = v31;
                  *(_OWORD *)&otherRange[32] = *((_OWORD *)v16 + 2);
                  CMTimeRangeGetIntersection(&v63, &range, (CMTimeRange *)otherRange);
                  CMTime time1 = *v51;
                  *(_OWORD *)&range.start.unsigned int value = *MEMORY[0x1E4F1FA48];
                  range.start.CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16);
                  if (!CMTimeCompare(&time1, &range.start))
                  {
                    memset(otherRange, 0, 24);
                    *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)v15;
                    range.start.CMTimeEpoch epoch = *((void *)v15 + 2);
                    *(_OWORD *)&v56.start.unsigned int value = *(_OWORD *)v16;
                    v56.start.CMTimeEpoch epoch = *((void *)v16 + 2);
                    CMTimeMaximum((CMTime *)otherRange, &range.start, &v56.start);
                    memset(&v56, 0, 24);
                    long long v32 = *((_OWORD *)v15 + 1);
                    *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)v15;
                    *(_OWORD *)&range.start.CMTimeEpoch epoch = v32;
                    *(_OWORD *)&range.duration.CMTimeScale timescale = *((_OWORD *)v15 + 2);
                    CMTimeRangeGetEnd(&v62, &range);
                    long long v33 = *((_OWORD *)v16 + 1);
                    *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)v16;
                    *(_OWORD *)&range.start.CMTimeEpoch epoch = v33;
                    *(_OWORD *)&range.duration.CMTimeScale timescale = *((_OWORD *)v16 + 2);
                    CMTimeRangeGetEnd(&time2, &range);
                    CMTimeMinimum(&v56.start, &v62, &time2);
                    *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)&v56.start.value;
                    range.start.CMTimeEpoch epoch = v56.start.epoch;
                    CMTime rhs = *(CMTime *)otherRange;
                    if (CMTimeCompare(&range.start, &rhs))
                    {
                      *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)&v56.start.value;
                      range.start.CMTimeEpoch epoch = v56.start.epoch;
                      CMTime rhs = *(CMTime *)otherRange;
                      CMTimeSubtract(&time, &range.start, &rhs);
                      CMTimeAbsoluteValue(&v59, &time);
                      CMTimeMakeWithSeconds(&v57, 5.0, 1);
                      CMTimeCompare(&v59, &v57);
                    }
                  }
                }
              }
            }
          }
          long long v25 = *((_OWORD *)v16 + 1);
          *(_OWORD *)CMTimeRange otherRange = *(_OWORD *)v16;
          *(_OWORD *)&otherRange[16] = v25;
          *(_OWORD *)&otherRange[32] = *((_OWORD *)v16 + 2);
          long long v26 = *((_OWORD *)v15 + 1);
          *(_OWORD *)&v56.start.unsigned int value = *(_OWORD *)v15;
          *(_OWORD *)&v56.start.CMTimeEpoch epoch = v26;
          *(_OWORD *)&v56.duration.CMTimeScale timescale = *((_OWORD *)v15 + 2);
          uint64_t result = (uint64_t)CMTimeRangeGetUnion(&range, (CMTimeRange *)otherRange, &v56);
          long long v27 = *(_OWORD *)&range.start.epoch;
          *(_OWORD *)uint64_t v16 = *(_OWORD *)&range.start.value;
          *((_OWORD *)v16 + 1) = v27;
          *((_OWORD *)v16 + 2) = *(_OWORD *)&range.duration.timescale;
          p_CMTime duration = v51;
        }
        else
        {
          *(unsigned char *)uint64_t v10 = 1;
          uint64_t v17 = &v80[v12];
          long long v18 = *((_OWORD *)v15 + 1);
          _OWORD *v17 = *(_OWORD *)v15;
          v17[1] = v18;
          CMTime v17[2] = *((_OWORD *)v15 + 2);
        }
      }
    }
    v12 += 48;
    uint64_t v10 = (int *)((char *)v10 + 1);
  }
  while (v12 != 240);
  uint64_t v34 = 0;
  uint64_t v35 = v80;
  long long v36 = v54;
  while (!*((unsigned char *)&v71 + v34))
  {
LABEL_38:
    ++v34;
    v35 += 48;
    if (v34 == 5) {
      goto LABEL_41;
    }
  }
  if ((v35[12] & 1) != 0
    && (v35[36] & 1) != 0
    && !*((void *)v35 + 5)
    && (*((void *)v35 + 3) & 0x8000000000000000) == 0)
  {
    if ((*(unsigned char *)(a2 + 12) & 1) == 0
      || (*(unsigned char *)(a2 + 36) & 1) == 0
      || *(void *)(a2 + 40)
      || (*(void *)(a2 + 24) & 0x8000000000000000) != 0)
    {
      long long v37 = *((_OWORD *)v35 + 1);
      *(_OWORD *)a2 = *(_OWORD *)v35;
      *(_OWORD *)(a2 + 16) = v37;
      long long v38 = *((_OWORD *)v35 + 2);
    }
    else
    {
      long long v39 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)CMTimeRange otherRange = *(_OWORD *)a2;
      *(_OWORD *)&otherRange[16] = v39;
      *(_OWORD *)&otherRange[32] = *(_OWORD *)(a2 + 32);
      long long v40 = *((_OWORD *)v35 + 1);
      *(_OWORD *)&v56.start.unsigned int value = *(_OWORD *)v35;
      *(_OWORD *)&v56.start.CMTimeEpoch epoch = v40;
      *(_OWORD *)&v56.duration.CMTimeScale timescale = *((_OWORD *)v35 + 2);
      uint64_t result = (uint64_t)CMTimeRangeGetIntersection(&range, (CMTimeRange *)otherRange, &v56);
      long long v36 = v54;
      long long v41 = *(_OWORD *)&range.start.epoch;
      *(_OWORD *)a2 = *(_OWORD *)&range.start.value;
      *(_OWORD *)(a2 + 16) = v41;
      long long v38 = *(_OWORD *)&range.duration.timescale;
    }
    *(_OWORD *)(a2 + 32) = v38;
    goto LABEL_38;
  }
  *(_OWORD *)a2 = v36;
  *(_OWORD *)(a2 + 16) = v53;
  *(_OWORD *)(a2 + 32) = v52;
LABEL_41:
  if (dword_1E9350BB0 >= 5)
  {
    LODWORD(v56.start.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(rhs.CFDictionarySetValue(theDict, key, value) = 0;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int value = v56.start.value;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, rhs.value)) {
      unsigned int v44 = value;
    }
    else {
      unsigned int v44 = value & 0xFFFFFFFE;
    }
    if (v44)
    {
      uint64_t v45 = *DerivedStorage;
      if (v45)
      {
        uint64_t v46 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        if (a1) {
          goto LABEL_48;
        }
LABEL_51:
        unsigned int v47 = "";
      }
      else
      {
        uint64_t v46 = "";
        if (!a1) {
          goto LABEL_51;
        }
LABEL_48:
        unsigned int v47 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
      }
      *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)a2;
      range.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
      Float64 Seconds = CMTimeGetSeconds(&range.start);
      long long v49 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)&range.start.unsigned int value = *(_OWORD *)a2;
      *(_OWORD *)&range.start.CMTimeEpoch epoch = v49;
      *(_OWORD *)&range.duration.CMTimeScale timescale = *(_OWORD *)(a2 + 32);
      CMTimeRangeGetEnd(&v55, &range);
      Float64 v50 = CMTimeGetSeconds(&v55);
      *(_DWORD *)CMTimeRange otherRange = 136316674;
      *(void *)&otherRange[4] = "fpfsi_TotalTimeRangeInBuffer";
      *(_WORD *)&otherRange[12] = 2048;
      *(void *)&otherRange[14] = v45;
      *(_WORD *)&otherRange[22] = 2082;
      *(void *)&otherRange[24] = v46;
      *(_WORD *)&otherRange[32] = 2048;
      *(void *)&otherRange[34] = a1;
      *(_WORD *)&otherRange[42] = 2082;
      *(void *)&otherRange[44] = v47;
      __int16 v74 = 2048;
      Float64 v75 = Seconds;
      __int16 v76 = 2048;
      Float64 v77 = v50;
      _os_log_send_and_compose_impl();
    }
    return fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return result;
}

opaqueCMBufferQueue *fpfsi_TotalTimeRangeInBufferForTrackList(opaqueCMBufferQueue *result, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *(void *)result; i; uint64_t i = *(void *)(i + 8))
  {
    if (!*(unsigned char *)(i + 184) || *(_DWORD *)(i + 32) == 1986618469)
    {
      uint64_t result = *(opaqueCMBufferQueue **)(i + 80);
      if (result)
      {
        memset(&start, 0, sizeof(start));
        CMBufferQueueGetMinPresentationTimeStamp(&start, result);
        memset(&v19, 0, sizeof(v19));
        uint64_t result = (opaqueCMBufferQueue *)CMBufferQueueGetDuration(&v19, *(CMBufferQueueRef *)(i + 80));
        for (uint64_t j = 0; j != 5; ++j)
        {
          if (*(_DWORD *)&kCommonTypes[4 * j] == *(_DWORD *)(i + 32)) {
            break;
          }
        }
        *(unsigned char *)(a3 + (int)j) = 1;
        if ((start.flags & 0x1D) == 1 && (v19.flags & 0x1D) == 1)
        {
          memset(&v18, 0, sizeof(v18));
          time1.CMTime start = start;
          *(_OWORD *)&time2.start.unsigned int value = *(_OWORD *)(i + 216);
          time2.start.CMTimeEpoch epoch = *(void *)(i + 232);
          if (CMTimeCompare(&time1.start, &time2.start) >= 1)
          {
            time2.CMTime start = start;
            v14.CMTime start = v19;
            CMTimeSubtract(&time1.start, &time2.start, &v14.start);
            CMTime start = time1.start;
          }
          if (*(unsigned char *)(i + 184))
          {
            CMBufferQueueGetEndPresentationTimeStamp(&end, *(CMBufferQueueRef *)(i + 80));
            time2.CMTime start = start;
            CMTimeRangeFromTimeToTime(&time1, &time2.start, &end);
            CMTimeRange v18 = time1;
          }
          else
          {
            time1.CMTime start = start;
            time2.CMTime start = v19;
            CMTimeRangeMake(&v18, &time1.start, &time2.start);
          }
          int v7 = j;
          uint64_t result = (opaqueCMBufferQueue *)CMBaseObjectGetDerivedStorage();
          uint64_t v8 = a2 + 48 * (int)j;
          if ((*(unsigned char *)(v8 + 12) & 1) == 0
            || (uint64_t v9 = a2 + 48 * v7, (*(unsigned char *)(v9 + 36) & 1) == 0)
            || *(void *)(a2 + 48 * v7 + 40)
            || (*(void *)(v9 + 24) & 0x8000000000000000) != 0)
          {
            long long v10 = *(_OWORD *)&v18.start.epoch;
            *(_OWORD *)uint64_t v8 = *(_OWORD *)&v18.start.value;
            *(_OWORD *)(v8 + 16) = v10;
            long long v11 = *(_OWORD *)&v18.duration.timescale;
          }
          else
          {
            long long v12 = *(_OWORD *)(v8 + 16);
            *(_OWORD *)&time2.start.unsigned int value = *(_OWORD *)v8;
            *(_OWORD *)&time2.start.CMTimeEpoch epoch = v12;
            *(_OWORD *)&time2.duration.CMTimeScale timescale = *(_OWORD *)(v8 + 32);
            CMTimeRange v14 = v18;
            uint64_t result = (opaqueCMBufferQueue *)CMTimeRangeGetUnion(&time1, &time2, &v14);
            long long v13 = *(_OWORD *)&time1.start.epoch;
            *(_OWORD *)uint64_t v8 = *(_OWORD *)&time1.start.value;
            *(_OWORD *)(v8 + 16) = v13;
            long long v11 = *(_OWORD *)&time1.duration.timescale;
          }
          *(_OWORD *)(v8 + 32) = v11;
        }
      }
    }
  }
  return result;
}

uint64_t fpfs_SetRateWithFade(void *a1, float a2)
{
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetCMTime();
  uint64_t v6 = fpfs_SetRateWithOptionsGuts(a1, (uint64_t)Mutable, 1, a2);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v6;
}

void fpfs_StopPlayingItem(uint64_t a1, const __CFArray *a2, __CFError *a3)
{
  uint64_t v178 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  int v7 = *(void **)DerivedStorage;
  CFMutableDictionaryRef v167 = 0;
  CFArrayRef v8 = *(const __CFArray **)(a1 + 80);
  BOOL v158 = v8 == a2;
  uint64_t v9 = *(unsigned int *)(a1 + 632);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  CFArrayRef v160 = v8;
  if (v8) {
    uint64_t v11 = Count + 1;
  }
  else {
    uint64_t v11 = Count;
  }
  int EffectiveActionAtEnd = FigPlaybackGetEffectiveActionAtEnd(v9, v11);
  CFTypeRef cf = 0;
  CFTypeRef v166 = 0;
  CFRetain(a2);
  if (!a3) {
    a3 = *(__CFError **)(DerivedStorage + 504);
  }
  fpfs_ReleaseAndClearTimebaseTimer(*(OpaqueCMTimebase **)(DerivedStorage + 576), (dispatch_object_t *)(DerivedStorage + 1632));
  uint64_t v12 = MEMORY[0x1E4F1F9F8];
  long long v13 = *MEMORY[0x1E4F1F9F8];
  *(_OWORD *)(DerivedStorage + 1640) = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v14 = *(void *)(v12 + 16);
  *(void *)(DerivedStorage + 1656) = v14;
  long long v162 = v13;
  *(_OWORD *)(DerivedStorage + 1664) = v13;
  *(void *)(DerivedStorage + 1680) = v14;
  fpfs_ReleaseAndClearTimebaseTimer(*(OpaqueCMTimebase **)(DerivedStorage + 576), (dispatch_object_t *)(DerivedStorage + 2304));
  fpfs_ReleaseAndClearTimebaseTimer(*(OpaqueCMTimebase **)(DerivedStorage + 576), (dispatch_object_t *)(DerivedStorage + 2336));
  if (*(unsigned char *)(DerivedStorage + 332))
  {
    if (a3 && CFErrorGetCode(a3) != -15697)
    {
      int v16 = *(_DWORD *)(DerivedStorage + 2200);
      if (!v16) {
        int v16 = *(_DWORD *)(DerivedStorage + 2204);
      }
      int Code = CFErrorGetCode(a3);
      fpfs_SeekDidFail(v7, a2, v16, Code);
    }
    else
    {
      memset(valuePtr, 0, 24);
      fpfsi_GetPumpMaxTimeAvailable(DerivedStorage, (uint64_t)valuePtr);
      memset(&v169, 0, sizeof(v169));
      fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&time2);
      CMTime time1 = valuePtr[0];
      CMTimeMinimum(&v169, &time1, &time2);
      CMTime time1 = v169;
      fpfs_SetTime((uint64_t)a2, &time1);
      fpfsi_setLastSeekTimeSet(DerivedStorage, v12);
      *(_OWORD *)(DerivedStorage + 1496) = v162;
      *(void *)(DerivedStorage + 1512) = v14;
      int v15 = *(_DWORD *)(DerivedStorage + 2200);
      if (!v15) {
        int v15 = *(_DWORD *)(DerivedStorage + 2204);
      }
      CMTime time1 = v169;
      fpfs_SeekDidComplete(v7, a2, v15, 0, 0, &time1);
    }
  }
  err = a3;
  unsigned int v163 = v7;
  if (*(unsigned char *)(DerivedStorage + 530))
  {
    int v156 = 0;
  }
  else
  {
    CMTimeRange v18 = *(const void **)(a1 + 640);
    *(void *)(a1 + 640) = a3;
    if (a3) {
      CFRetain(a3);
    }
    if (v18) {
      CFRelease(v18);
    }
    if (a3)
    {
      LODWORD(valuePtr[0].CFDictionarySetValue(theDict, key, value) = CFErrorGetCode(a3);
      CFNumberRef v19 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, valuePtr);
      if (v19)
      {
        CFNumberRef v20 = v19;
        CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        long long v23 = Mutable;
        if (Mutable)
        {
          CFDictionarySetValue(Mutable, @"Result", v20);
          if (LODWORD(valuePtr[0].value)) {
            CFDictionarySetValue(v23, @"CFError", a3);
          }
        }
        CFRelease(v20);
      }
      else
      {
        long long v23 = 0;
      }
      *(void *)(a1 + 648) = @"ReasonAdvanceDueToError";
      if (*(unsigned char *)(DerivedStorage + 460))
      {
        if (*(unsigned char *)(DerivedStorage + 468)) {
          long long v24 = (const void **)&kFigPlaybackItemNotification_FailedToPlayToEnd;
        }
        else {
          long long v24 = (const void **)&kFigPlaybackItemNotification_FailedToBecomeReadyForPlayback;
        }
      }
      else
      {
        long long v24 = (const void **)&kFigPlaybackItemNotification_FailedToBecomeReadyForInspection;
      }
      long long v25 = *v24;
      fpfs_EnqueueNotification(v163, *v24, a2, v23);
      valuePtr[0].CMTimeValue value = 0;
      v169.CMTimeValue value = 0;
      time1.CMTimeValue value = 0;
      CMBaseObjectGetDerivedStorage();
      int v157 = CFErrorGetCode(err);
      CFErrorDomain Domain = CFErrorGetDomain(err);
      FigCopyLastSignaledErrorInfo();
      uint64_t v27 = *(void *)(DerivedStorage + 2544);
      if (!v27) {
        goto LABEL_286;
      }
      uint64_t v28 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v28) {
        uint64_t v29 = v28;
      }
      else {
        uint64_t v29 = 0;
      }
      long long v30 = *(void (**)(uint64_t, uint64_t, uint64_t, CFErrorDomain, void))(v29 + 48);
      if (v30) {
        v30(v27, 0x1EE582B78, 0x1EE5840F8, Domain, 0);
      }
      uint64_t v31 = *(void *)(DerivedStorage + 2544);
      if (v31)
      {
        uint64_t v32 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v32) {
          uint64_t v33 = v32;
        }
        else {
          uint64_t v33 = 0;
        }
        uint64_t v34 = *(void (**)(uint64_t, uint64_t, uint64_t, const void *, void))(v33 + 48);
        if (v34) {
          v34(v31, 0x1EE582B78, 0x1EE5840D8, v25, 0);
        }
        uint64_t v35 = *(void *)(DerivedStorage + 2544);
        if (v35)
        {
          uint64_t v36 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v36) {
            uint64_t v37 = v36;
          }
          else {
            uint64_t v37 = 0;
          }
          long long v38 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v37 + 56);
          if (v38) {
            v38(v35, 0x1EE582B78, 0x1EE5840B8, v157, 0);
          }
          uint64_t v39 = *(void *)(DerivedStorage + 2544);
        }
        else
        {
          uint64_t v39 = 0;
        }
      }
      else
      {
LABEL_286:
        uint64_t v39 = 0;
      }
      CMTimeValue value = valuePtr[0].value;
      if (valuePtr[0].value)
      {
        if (v39)
        {
          uint64_t v41 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v42 = v41 ? v41 : 0;
          CFTypeRef v43 = *(void (**)(uint64_t, uint64_t, uint64_t, CMTimeValue, void))(v42 + 48);
          if (v43) {
            v43(v39, 0x1EE582B78, 0x1EE584178, value, 0);
          }
        }
        CFRelease((CFTypeRef)valuePtr[0].value);
        uint64_t v39 = *(void *)(DerivedStorage + 2544);
      }
      CMTimeValue v44 = v169.value;
      if (v169.value)
      {
        if (v39)
        {
          uint64_t v45 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v46 = v45 ? v45 : 0;
          unsigned int v47 = *(void (**)(uint64_t, uint64_t, uint64_t, CMTimeValue, void))(v46 + 48);
          if (v47) {
            v47(v39, 0x1EE582B78, 0x1EE584138, v44, 0);
          }
        }
        CFRelease((CFTypeRef)v169.value);
        uint64_t v39 = *(void *)(DerivedStorage + 2544);
      }
      if (v39)
      {
        uint64_t value_low = SLODWORD(time1.value);
        uint64_t v49 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v50 = v49 ? v49 : 0;
        uint64_t v51 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v50 + 56);
        if (v51) {
          v51(v39, 0x1EE582B78, 0x1EE584158, value_low, 0);
        }
      }
      uint64_t v52 = *(void *)(DerivedStorage + 2544);
      a3 = err;
      if (v52)
      {
        uint64_t v53 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v54 = v53 ? v53 : 0;
        CMTime v55 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v54 + 8);
        if (v55) {
          v55(v52, 0x1EE582B78, 107, 0, 0);
        }
      }
      FigCAStatsReportingSubmitData();
      CFAllocatorRef v56 = (const __CFAllocator *)FigGetAllocatorForMedia();
      *(_OWORD *)&valuePtr[0].CMTimeValue value = v162;
      valuePtr[0].CMTimeEpoch epoch = v14;
      FigMetricErrorEventCreate(v56, (long long *)&valuePtr[0].value, 0, 0, 0, err, &cf);
      uint64_t v57 = *(void *)(DerivedStorage + 3376);
      CFTypeRef v58 = cf;
      uint64_t v59 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v59) {
        uint64_t v60 = v59;
      }
      else {
        uint64_t v60 = 0;
      }
      unsigned int v61 = *(void (**)(uint64_t, const __CFArray *, CFTypeRef))(v60 + 40);
      if (v61) {
        v61(v57, a2, v58);
      }
      if (v23) {
        CFRelease(v23);
      }
      int v156 = 0;
      int v7 = (void *)v163;
    }
    else
    {
      fpfs_EnqueueNotification(v7, @"DidPlayToTheEnd", a2, 0);
      int v156 = 1;
    }
    CMTime v62 = *(__CFError **)(a1 + 904);
    if (v62)
    {
      uint64_t v63 = *(void *)(DerivedStorage + 2544);
      CFIndex v64 = CFErrorGetCode(v62);
      if (v63)
      {
        CFIndex v65 = v64;
        uint64_t v66 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v67 = v66 ? v66 : 0;
        int v69 = *(void (**)(uint64_t, uint64_t, uint64_t, CFIndex, void))(v67 + 56);
        if (v69) {
          v69(v63, 0x1EE582B78, 0x1EE584118, v65, 0);
        }
      }
      CMTimeRange v68 = *(const void **)(a1 + 904);
    }
    else
    {
      CMTimeRange v68 = 0;
    }
    *(void *)(a1 + 904) = a3;
    if (a3) {
      CFRetain(a3);
    }
    if (v68) {
      CFRelease(v68);
    }
    *(unsigned char *)(DerivedStorage + 530) = 1;
    if (*(float *)(a1 + 108) < 0.0 && EffectiveActionAtEnd == 1) {
      fpfsi_SeekToCurrentTime(a2);
    }
  }
  uint64_t v70 = *(void *)(DerivedStorage + 1048);
  if (v70)
  {
    int v71 = (long long *)MEMORY[0x1E4F1F9F8];
    do
    {
      uint64_t v72 = *(void *)(v70 + 8);
      if (*(_DWORD *)(v70 + 152) == 6)
      {
        fpfsi_MoveTrackToPlayedOut(DerivedStorage, v70, v71);
        if (!v72) {
          break;
        }
      }
      else
      {
        fpfs_DeleteTrack(a2, v70);
        if (!v72) {
          break;
        }
      }
      uint64_t v70 = v72;
    }
    while (*(void *)(DerivedStorage + 1048));
  }
  uint64_t v73 = CMBaseObjectGetDerivedStorage();
  fpfs_ClearRenderChains(a2, 255);
  *(void *)(v73 + 780) = 0;
  uint64_t v74 = CMBaseObjectGetDerivedStorage();
  uint64_t v75 = CMBaseObjectGetDerivedStorage();
  v169.CMTimeValue value = 0;
  uint64_t v76 = *(void *)(v74 + 936);
  if (v76)
  {
    if (*(unsigned char *)(v74 + 3065)) {
      goto LABEL_137;
    }
    uint64_t v77 = v75;
    uint64_t v78 = FigGetAllocatorForMedia();
    FigBytePumpGetFigBaseObject(v76);
    uint64_t v80 = v79;
    uint64_t v81 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v81) {
      uint64_t v82 = v81;
    }
    else {
      uint64_t v82 = 0;
    }
    uint64_t v83 = *(void (**)(uint64_t, uint64_t, uint64_t, CMTime *))(v82 + 48);
    if (v83) {
      v83(v80, 0x1EE53EA58, v78, &v169);
    }
    if (v169.value)
    {
      unint64_t v84 = (const void **)(v77 + 528);
      if (*(void *)(v77 + 528)
        || (FigAssetDownloadCoordinatorCopyClientBundleIdentifierForAsset(*(void *)(v74 + 32), (void *)(v77 + 528)),
            *v84))
      {
        CFAllocatorRef v85 = (const __CFAllocator *)FigGetAllocatorForMedia();
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        CFDateRef v87 = CFDateCreate(v85, Current);
        if (v87)
        {
          CFDateRef v88 = v87;
          CMTime v89 = (const void *)v169.value;
          unint64_t v90 = *v84;
          uint64_t v91 = CMBaseObjectGetDerivedStorage();
          BOOL v92 = 0;
          valuePtr[0].CMTimeValue value = 0;
          if (!v89 || !v90) {
            goto LABEL_133;
          }
          if (*(unsigned char *)(v91 + 3064))
          {
            BOOL v92 = 1;
            goto LABEL_133;
          }
          if (fpfsi_isItemPlayedOut((uint64_t)a2))
          {
            BOOL v92 = 1;
            CMTime v93 = (const void *)valuePtr[0].value;
            if (!valuePtr[0].value) {
              goto LABEL_133;
            }
          }
          else
          {
            int PlayedOutDateForAssetAtURL = FigAssetDownloadStorageManagementCopyLastPlayedOutDateForAssetAtURL(v89, v90, valuePtr);
            CMTime v93 = (const void *)valuePtr[0].value;
            if (PlayedOutDateForAssetAtURL)
            {
              BOOL v92 = 0;
              if (!valuePtr[0].value)
              {
LABEL_133:
                int PlayedDateForAssetAtURL = FigAssetDownloadStorageManagementSetLastPlayedDateForAssetAtURL((const __CFURL *)v169.value, *v84, (uint64_t)v88, v92);
                if (v92 && !PlayedDateForAssetAtURL) {
                  *(unsigned char *)(v74 + 3065) = 1;
                }
                CFRelease(v88);
                int v7 = (void *)v163;
                goto LABEL_137;
              }
            }
            else
            {
              BOOL v92 = valuePtr[0].value != 0;
              if (!valuePtr[0].value) {
                goto LABEL_133;
              }
            }
          }
          CFRelease(v93);
          goto LABEL_133;
        }
        FigSignalErrorAt();
      }
LABEL_137:
      if (v169.value) {
        CFRelease((CFTypeRef)v169.value);
      }
    }
  }
  fpfsi_RTCReportingReportStartupPerformanceMetrics();
  if ((EffectiveActionAtEnd - 1) > 1)
  {
    uint64_t v98 = CMBaseObjectGetDerivedStorage();
    valuePtr[0].CMTimeValue value = 0;
    BOOL IsPlayerPerformanceTraceEnabled = FPSupport_IsPlayerPerformanceTraceEnabled();
    if (!(*(unsigned __int8 *)(v98 + 656) | IsPlayerPerformanceTraceEnabled)) {
      goto LABEL_155;
    }
    BOOL v100 = IsPlayerPerformanceTraceEnabled;
    if (!*(unsigned char *)(v98 + 656)
      || *(void *)(v98 + 664)
      || (CFAllocatorRef v101 = CFGetAllocator(v7),
          CFMutableArrayRef v102 = CFArrayCreateMutable(v101, 0, MEMORY[0x1E4F1D510]),
          (*(void *)(v98 + 664) = v102) != 0))
    {
      CFAllocatorRef v103 = CFGetAllocator(v7);
      int v104 = fpfsi_copyPerformanceDictionary((uint64_t)a2, v103, (__CFDictionary **)valuePtr);
      int v105 = (void *)valuePtr[0].value;
      if (v104 || !valuePtr[0].value)
      {
        if (!valuePtr[0].value) {
          goto LABEL_155;
        }
      }
      else
      {
        if (*(unsigned char *)(v98 + 656)) {
          CFArrayAppendValue(*(CFMutableArrayRef *)(v98 + 664), (const void *)valuePtr[0].value);
        }
        if (v100) {
          FPSupport_TracePlayerPerformanceDictionary((uint64_t)"Stream", v105);
        }
      }
      CFRelease(v105);
    }
    else
    {
      FigSignalErrorAt();
    }
LABEL_155:
    if (*(unsigned char *)(DerivedStorage + 468))
    {
      CFArrayRef v106 = v160;
      if (*(float *)(a1 + 108) == 0.0 || *(float *)(DerivedStorage + 848) != 0.0)
      {
        CMBaseObjectGetDerivedStorage();
        if (*(_DWORD *)(DerivedStorage + 2292)) {
          goto LABEL_165;
        }
        int v107 = 6;
      }
      else
      {
        CMBaseObjectGetDerivedStorage();
        if (*(_DWORD *)(DerivedStorage + 2292)) {
          goto LABEL_165;
        }
        int v107 = 10;
      }
    }
    else
    {
      CMBaseObjectGetDerivedStorage();
      CFArrayRef v106 = v160;
      if (*(_DWORD *)(DerivedStorage + 2292)) {
        goto LABEL_165;
      }
      int v107 = 11;
    }
    *(_DWORD *)(DerivedStorage + 2292) = v107;
LABEL_165:
    if (!fpfs_CreateAccessLogEntryWithUnlock((uint64_t)a2, &v167))
    {
      CFMutableDictionaryRef v108 = v167;
      fpfs_CommitAccessLogEntry(a2, v167);
      if (v108) {
        CFRelease(v108);
      }
      if (*(unsigned char *)(DerivedStorage + 25))
      {
        CFArrayRef v109 = *(const __CFArray **)(DerivedStorage + 1912);
        if (v109)
        {
          time1.CMTimeValue value = 0;
          if (!FigPlaybackItemLogCreateW3CLogData(v109, (__CFString **)&time1))
          {
            if (dword_1E9350BB0)
            {
              os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
              fig_log_call_emit_and_clean_up_after_send_and_compose();
              int v7 = (void *)v163;
              CFArrayRef v106 = v160;
            }
            CFRelease((CFTypeRef)time1.value);
          }
        }
      }
    }
    if (v106 != a2)
    {
      fpfsi_ResetPlaybackItem(a2, v158);
      goto LABEL_274;
    }
    CFArrayRef Next = fpfs_getNext(a1, a2);
    if (!*(void *)(CMBaseObjectGetDerivedStorage() + 504) || *(float *)(DerivedStorage + 848) == 0.0 || Next)
    {
      if (Next)
      {
        uint64_t v112 = CMBaseObjectGetDerivedStorage();
        uint64_t v113 = CMBaseObjectGetDerivedStorage();
        uint64_t v114 = CMBaseObjectGetDerivedStorage();
        if (*(unsigned char *)(v113 + 2448))
        {
          *(_OWORD *)&v169.CMTimeValue value = v162;
          v169.CMTimeEpoch epoch = v14;
          if (*(const __CFArray **)(v114 + 80) == Next) {
            fpfs_StopPlayingItem_cold_1();
          }
          float v115 = *(float *)(v113 + 848);
          fpfs_GetItemBufferedDuration(Next, &v169, valuePtr, 0);
          CMTime time1 = v169;
          fpfs_CheckIfLikelyToKeepUpAndNotify(v163, Next, &time1, 0, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], valuePtr);
          float Rate = CMTimebaseGetRate(*(CMTimebaseRef *)(v113 + 576));
          *(float *)(CMBaseObjectGetDerivedStorage() + 848) = Rate;
          fpfsi_updateMaxPlayThroughTime();
          fpfsi_updateItemTimePropertiesForRateChange((uint64_t)Next, v115);
          if (*(float *)(v113 + 848) == 0.0) {
            fpfs_CancelGaplessAttempt(v163, Next, 1);
          }
        }
        int v7 = (void *)v163;
        if (*(void *)(v112 + 936) && *(unsigned char *)(v112 + 462) && *(unsigned char *)(v112 + 593))
        {
          if (dword_1E9350BB0)
          {
            LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 0;
            CMTimeValue v117 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v118 = time1.value;
            if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT)) {
              unsigned int v119 = v118;
            }
            else {
              unsigned int v119 = v118 & 0xFFFFFFFE;
            }
            if (v119)
            {
              uint64_t v120 = *(void *)v112;
              if (*(void *)v112) {
                uint64_t v121 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
              }
              else {
                uint64_t v121 = "";
              }
              uint64_t v131 = CMBaseObjectGetDerivedStorage();
              LODWORD(v169.CFDictionarySetValue(theDict, key, value) = 136316162;
              *(CMTimeValue *)((char *)&v169.value + 4) = (CMTimeValue)"fpfs_StopPlayingItem";
              LOWORD(v169.flags) = 2048;
              *(void *)((char *)&v169.flags + 2) = v120;
              HIWORD(v169.epoch) = 2082;
              uint64_t v170 = v121;
              __int16 v171 = 2048;
              CFArrayRef v172 = Next;
              __int16 v173 = 2082;
              long long v174 = (const char *)(v131 + 3080);
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            int v7 = (void *)v163;
          }
          fpfsi_SetCurrentTimeWithSeekID((uint64_t)Next, MEMORY[0x1E4F1FA10], 0, 0);
        }
      }
    }
    else
    {
      *(_OWORD *)&valuePtr[0].CMTimeValue value = v162;
      valuePtr[0].CMTimeEpoch epoch = v14;
      *(_OWORD *)&v169.CMTimeValue value = v162;
      v169.CMTimeEpoch epoch = v14;
      fpfs_setRateInternal(v7, a2, valuePtr, &v169, 0.0);
    }
    uint64_t v132 = *(const void **)(a1 + 80);
    if (v132)
    {
      CFRelease(v132);
      *(void *)(a1 + 80) = 0;
    }
    if (Next)
    {
      if (*(unsigned char *)(a1 + 49))
      {
        valuePtr[0].CMTimeValue value = 0;
        fpfs_ensureTransaction((uint64_t)v7, &valuePtr[0].value);
        fpfsi_removeLayerSync();
        fpfs_commitTransaction((uint64_t)v7, valuePtr[0].value);
        if (valuePtr[0].value) {
          CFRelease((CFTypeRef)valuePtr[0].value);
        }
      }
    }
    fpfs_cleanupAllImageQueues(a2, 1);
    fpfs_tearDownManifoldsAndStream();
    fpfs_PullNextItem(v7);
    fpfs_EnqueueNotification(v7, @"ItemStoppedBeingCurrent", a2, 0);
    *(_OWORD *)(a1 + 112) = v162;
    *(void *)(a1 + 128) = v14;
    *(_OWORD *)(a1 + 136) = v162;
    *(void *)(a1 + 152) = v14;
    fpfs_enqueuePrerollWasCancelledNotificationIfNeeded(a2);
    if (!dword_1E9350BB0) {
      goto LABEL_245;
    }
    LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 0;
    Float64 v133 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int v134 = time1.value;
    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v135 = v134;
    }
    else {
      unsigned int v135 = v134 & 0xFFFFFFFE;
    }
    if (!v135)
    {
LABEL_243:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      int v7 = (void *)v163;
LABEL_245:
      while (1)
      {
        uint64_t v138 = *(void *)(DerivedStorage + 1048);
        if (!v138) {
          break;
        }
        fpfs_DeleteTrack(a2, v138);
      }
      int v139 = 0;
      do
      {
        unsigned int v140 = v139;
        StoreCurrentManifold(DerivedStorage, v139, 0, 0);
        StoreCurrentManifold(DerivedStorage, v139++, 1u, 0);
      }
      while (v140 < 2);
      *(unsigned char *)(DerivedStorage + 463) = 0;
      uint64_t v141 = CMBaseObjectGetDerivedStorage();
      fpfs_ClearRenderChains(a2, 255);
      *(void *)(v141 + 780) = 0;
      if (!Next)
      {
        fpfs_ResetAudioHardwareFormat(*(void *)DerivedStorage);
        fpfs_releaseTransitionImageQueuesAndSlots();
        fpfs_disassociatePlayerVideoLayer((uint64_t)v7, 0);
        fpfs_sendEmptyConfigurationToEachVideoTarget((uint64_t)v7, *(const __CFArray **)(a1 + 432));
      }
      CFArrayRef v97 = v160;
      if (!fpfs_HaveHDRItem()) {
        fpfs_ReleasePlayerHDRPlaybackBaton();
      }
      if (!fpfs_PlayQueueCallForEachItem(*(void *)DerivedStorage, (uint64_t (*)(const __CFArray *, uint64_t))fpfsi_isPlaying4k, 0))fpfs_ReleasePlayer4kPlaybackBaton(*(const void **)DerivedStorage); {
      fpfs_PostRemovedFromPlayQueueNotifications(v7, a2);
      }
      if (*(unsigned char *)(a1 + 463)) {
        fpfs_UpdateNeroPlaybackActiveStateAndNotifyIfNeeded(v7, (uint64_t)a2, 0);
      }
      fpfsi_ResetPlaybackItem(a2, v158);
      if (!Next) {
        fpfs_EnqueueCurrentItemDidChangeNotification(v7, (uint64_t)a2);
      }
      goto LABEL_258;
    }
    if (v163)
    {
      Float64 v136 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      if (a2)
      {
LABEL_238:
        uint64_t v137 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
LABEL_242:
        LODWORD(v169.CFDictionarySetValue(theDict, key, value) = 136316418;
        *(CMTimeValue *)((char *)&v169.value + 4) = (CMTimeValue)"fpfs_StopPlayingItem";
        LOWORD(v169.flags) = 2048;
        *(void *)((char *)&v169.flags + 2) = v163;
        HIWORD(v169.epoch) = 2082;
        uint64_t v170 = v136;
        __int16 v171 = 2048;
        CFArrayRef v172 = a2;
        __int16 v173 = 2082;
        long long v174 = v137;
        __int16 v175 = 2112;
        int32_t v176 = err;
        _os_log_send_and_compose_impl();
        goto LABEL_243;
      }
    }
    else
    {
      Float64 v136 = "";
      if (a2) {
        goto LABEL_238;
      }
    }
    uint64_t v137 = "";
    goto LABEL_242;
  }
  uint64_t v96 = err;
  CFArrayRef v97 = v160;
  if (v160 != a2) {
    goto LABEL_208;
  }
  if (EffectiveActionAtEnd == 1)
  {
    fpfs_stopPlaybackForInternalReason(v7, v156);
  }
  else
  {
    *(_OWORD *)&valuePtr[0].CMTimeValue value = v162;
    valuePtr[0].CMTimeEpoch epoch = v14;
    *(_OWORD *)&v169.CMTimeValue value = v162;
    v169.CMTimeEpoch epoch = v14;
    fpfs_setRateInternal(v7, a2, valuePtr, &v169, 0.0);
  }
  if (!dword_1E9350BB0) {
    goto LABEL_208;
  }
  LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 0;
  uint64_t v122 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
  unsigned int v123 = time1.value;
  if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT)) {
    unsigned int v124 = v123;
  }
  else {
    unsigned int v124 = v123 & 0xFFFFFFFE;
  }
  if (v124)
  {
    if (v163)
    {
      int v125 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      if (a2)
      {
LABEL_202:
        int v126 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
LABEL_206:
        LODWORD(v169.CFDictionarySetValue(theDict, key, value) = 136316418;
        *(CMTimeValue *)((char *)&v169.value + 4) = (CMTimeValue)"fpfs_StopPlayingItem";
        LOWORD(v169.flags) = 2048;
        *(void *)((char *)&v169.flags + 2) = v163;
        HIWORD(v169.epoch) = 2082;
        uint64_t v170 = v125;
        __int16 v171 = 2048;
        CFArrayRef v172 = a2;
        __int16 v173 = 2082;
        long long v174 = v126;
        __int16 v175 = 2112;
        int32_t v176 = err;
        _os_log_send_and_compose_impl();
        goto LABEL_207;
      }
    }
    else
    {
      int v125 = "";
      if (a2) {
        goto LABEL_202;
      }
    }
    int v126 = "";
    goto LABEL_206;
  }
LABEL_207:
  fig_log_call_emit_and_clean_up_after_send_and_compose();
  uint64_t v96 = err;
  CFArrayRef v97 = v160;
LABEL_208:
  if (v96)
  {
    fpfs_haltStream();
    fpfsi_ResetPlaybackItem(a2, 0);
  }
  if (v97 == a2 && !fpfs_FirstRenderingTrackofType((uint64_t)a2, 1936684398))
  {
    fpfs_ClearRenderChains(a2, 2);
    fpfs_ResetAudioHardwareFormat(*(void *)DerivedStorage);
  }
  uint64_t v127 = *(void *)(DerivedStorage + 840);
  if (v127)
  {
    uint64_t v128 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v129 = v128 ? v128 : 0;
    unsigned int v130 = *(void (**)(uint64_t))(v129 + 72);
    if (v130) {
      v130(v127);
    }
  }
LABEL_258:
  if (v97 == a2)
  {
    CFArrayRef v142 = fpfs_getNext(a1, 0);
    if (v142)
    {
      CFArrayRef v143 = v142;
      if (v142 != a2)
      {
        uint64_t v144 = CMBaseObjectGetDerivedStorage();
        if (!*(unsigned char *)(v144 + 2449) && dword_1E9350BB0)
        {
          LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 0;
          int v145 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v146 = time1.value;
          if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT)) {
            unsigned int v147 = v146;
          }
          else {
            unsigned int v147 = v146 & 0xFFFFFFFE;
          }
          if (v147)
          {
            if (v163) {
              unsigned int v148 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
            }
            else {
              unsigned int v148 = "";
            }
            uint64_t v149 = CMBaseObjectGetDerivedStorage();
            LODWORD(v169.CFDictionarySetValue(theDict, key, value) = 136316162;
            *(CMTimeValue *)((char *)&v169.value + 4) = (CMTimeValue)"fpfs_StopPlayingItem";
            LOWORD(v169.flags) = 2048;
            *(void *)((char *)&v169.flags + 2) = v163;
            HIWORD(v169.epoch) = 2082;
            uint64_t v170 = v148;
            __int16 v171 = 2048;
            CFArrayRef v172 = v143;
            __int16 v173 = 2082;
            long long v174 = (const char *)(v149 + 3080);
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        *(unsigned char *)(v144 + 469) = 1;
        fpfs_EnqueueNotification(*(const void **)DerivedStorage, @"TimebaseChanged", v143, 0);
      }
    }
  }
LABEL_274:
  if (*(void *)(DerivedStorage + 3376))
  {
    CFAllocatorRef v150 = (const __CFAllocator *)FigGetAllocatorForMedia();
    *(_OWORD *)&valuePtr[0].CMTimeValue value = v162;
    valuePtr[0].CMTimeEpoch epoch = v14;
    FigMetricItemPlaybackEndEventCreate(v150, (long long *)&valuePtr[0].value, 0, 0, &v166);
    uint64_t v151 = *(void *)(DerivedStorage + 3376);
    CFTypeRef v152 = v166;
    uint64_t v153 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v154 = v153 ? v153 : 0;
    uint64_t v155 = *(void (**)(uint64_t, const __CFArray *, CFTypeRef))(v154 + 40);
    if (v155) {
      v155(v151, a2, v152);
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v166) {
    CFRelease(v166);
  }
  CFRelease(a2);
}

uint64_t fpfs_SetRateWithOptionsGuts(void *a1, uint64_t a2, int a3, float a4)
{
  CMTime v13 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CMTime v12 = v13;
  int v11 = 0;
  FigCFDictionaryGetCMTimeIfPresent();
  FigCFDictionaryGetCMTimeIfPresent();
  FigCFDictionaryGetInt32IfPresent();
  CMTime v10 = v13;
  CMTime v9 = v13;
  return fpfs_SetRateWithOptionsAndAnchorTime(a1, a4, a2, &v10, (long long *)&v9.value, 0, a3);
}

uint64_t fpfs_SetRateWithOptionsAndAnchorTime(void *a1, float a2, uint64_t a3, CMTime *a4, long long *a5, char a6, int a7)
{
  uint64_t v138 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  long long v116 = *MEMORY[0x1E4F1F9F8];
  *(_OWORD *)&v128.unsigned int value = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v115 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  v128.CMTimeEpoch epoch = v115;
  __int16 v127 = 0;
  char v126 = 0;
  int v125 = 0;
  int v124 = 0;
  FigCFDictionaryGetCMTimeIfPresent();
  FigCFDictionaryGetBooleanIfPresent();
  FigCFDictionaryGetInt32IfPresent();
  FigCFDictionaryGetBooleanIfPresent();
  FigCFDictionaryGetInt32IfPresent();
  FigCFDictionaryGetBooleanIfPresent();
  fpfs_LockMutexWithCaller(a1);
  if (*(unsigned char *)(DerivedStorage + 51))
  {
    uint64_t v43 = FigSignalErrorAt();
    CFMutableDictionaryRef Mutable = 0;
    CFArrayRef Next = 0;
    float v14 = 0.0;
    goto LABEL_142;
  }
  char v13 = a6;
  float v14 = *(float *)(DerivedStorage + 108);
  float valuePtr = (float *)(DerivedStorage + 108);
  CFArrayRef Next = fpfs_getNext(DerivedStorage, 0);
  uint64_t v114 = a4;
  int v110 = a7;
  char v109 = a6;
  if (Next)
  {
    uint64_t v22 = CMBaseObjectGetDerivedStorage();
    BOOL v24 = *(float *)(v22 + 848) != a2 && HIBYTE(v127) != 0;
    char cf = v24;
    fpfs_enqueuePrerollWasCancelledNotificationIfNeeded(Next);
    if ((v13 & 2) != 0) {
      fpfsi_applyTimeToPausePlayback(Next, MEMORY[0x1E4F1F9F8], 0, 0);
    }
  }
  else
  {
    char cf = 0;
    uint64_t v22 = 0;
    *float valuePtr = a2;
  }
  char v113 = v13;
  if (dword_1E9350BB0)
  {
    LODWORD(theArray.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (*MEMORY[0x1E4F1EBA8] == 1)
  {
    if (Next) {
      long long v26 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
    }
    else {
      long long v26 = "";
    }
    strncpy((char *)&v137, v26, 8uLL);
    if (a1) {
      uint64_t v27 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
    }
    else {
      uint64_t v27 = "";
    }
    strncpy((char *)&v137, v27, 8uLL);
    kdebug_trace();
  }
  if (!Next && v126)
  {
LABEL_252:
    uint64_t v43 = FigSignalErrorAt();
    CFMutableDictionaryRef Mutable = 0;
    CFArrayRef Next = 0;
    goto LABEL_142;
  }
  if (!Next)
  {
    CFMutableDictionaryRef Mutable = 0;
LABEL_251:
    uint64_t v43 = 0;
    goto LABEL_142;
  }
  BOOL v28 = v14 == 0.0 && a2 != 0.0;
  if (v28 || HIBYTE(v127) && *(_DWORD *)(DerivedStorage + 164) != 4) {
    LOBYTE(v127) = 1;
  }
  if (v14 != a2) {
    fpfsi_RTCReportingReportDesiredRateChange(*valuePtr);
  }
  if (a2 == 0.0 || !(_BYTE)v127)
  {
    LOBYTE(v127) = 0;
  }
  else
  {
    if (*(unsigned char *)(v22 + 464)) {
      int v29 = 5;
    }
    else {
      int v29 = 1;
    }
    fpfs_notifyExternalStartupTasksOfEvents((uint64_t)a1, v29, HIBYTE(v127), 0, MEMORY[0x1E4F1F9F8]);
    if (!fpfs_areAllExternalStartupTasksCompleted() && *(float *)(v22 + 848) != 0.0) {
      fpfs_SetRateWithFadeInternal(a1, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], 0.0);
    }
  }
  if (a2 > 0.0)
  {
    uint64_t RenderingTrackofType = fpfs_FirstRenderingTrackofType((uint64_t)Next, 1936684398);
    if (RenderingTrackofType)
    {
      uint64_t v31 = RenderingTrackofType;
      if (fpfs_WantMATAtmosForTrack(RenderingTrackofType))
      {
        *(unsigned char *)(v31 + 190) = *((unsigned char *)a5 + 12) & ((v109 & 4) >> 2);
        fpfs_applySoftwareVolumeToTrack(v31, 1, *(float *)(DerivedStorage + 104), 0.0);
      }
    }
  }
  BOOL v32 = *valuePtr == a2 && v127 == 0;
  char v33 = cf;
  if (!v32) {
    char v33 = 1;
  }
  if ((v13 & 2) == 0 && (v33 & 1) == 0 && v125 != 7)
  {
    CFMutableDictionaryRef Mutable = 0;
    CFArrayRef Next = 0;
    goto LABEL_251;
  }
  CMTimeFlags flags = a4->flags;
  if ((flags & 1) != 0 && (a2 > 2.0 || a2 < 0.0)) {
    goto LABEL_252;
  }
  if (*valuePtr != a2 || ((*((_DWORD *)a5 + 3) | flags) & 1) != 0)
  {
    v137.unsigned int value = 0;
    *(void *)&v137.CMTimeScale timescale = 0;
    fpfs_PlayQueueCallForEachItem((uint64_t)a1, (uint64_t (*)(const __CFArray *, uint64_t))fpfs_clearCoordinatedPlaybackSynchronizationTimebaseForPlayQueueItemsApply, (uint64_t)&v137);
  }
  *(_WORD *)(v22 + 518) = 0;
  *(unsigned char *)(v22 + 520) = 0;
  uint64_t v35 = *(void *)(v22 + 2544);
  if (v35)
  {
    uint64_t v36 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v37 = v36 ? v36 : 0;
    long long v38 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v37 + 56);
    if (v38) {
      v38(v35, 0x1EE582B78, 0x1EE583F18, HIBYTE(v127), 0);
    }
  }
  if (v126)
  {
    CMTime v137 = *a4;
    CMTime v129 = *(CMTime *)a5;
    FPSupport_SetTransientTimebaseForCoordinatedPlaybackSynchronization((uint64_t)Next, (uint64_t)&v137, (uint64_t)&v129, a2);
  }
  if (a2 == 0.0)
  {
    *float valuePtr = a2;
    int v39 = 0;
    if (v110)
    {
      *(_OWORD *)(DerivedStorage + 112) = v116;
      *(void *)(DerivedStorage + 128) = v115;
      *(_OWORD *)(DerivedStorage + 136) = v116;
      *(void *)(DerivedStorage + 152) = v115;
    }
  }
  else
  {
    if (*(float *)(v22 + 848) == 0.0 && *(void *)(v22 + 936) && !*(unsigned char *)(v22 + 470))
    {
      int v39 = 0;
      if (a2 <= 2.0 && a2 >= 0.0)
      {
        uint64_t v77 = CMBaseObjectGetDerivedStorage();
        v137.unsigned int value = 0;
        LODWORD(v129.CFDictionarySetValue(theDict, key, value) = 7;
        uint64_t v78 = *(void *)(v77 + 936);
        uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
        FigBytePumpGetFigBaseObject(v78);
        uint64_t v81 = v80;
        uint64_t v82 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v82) {
          uint64_t v83 = v82;
        }
        else {
          uint64_t v83 = 0;
        }
        BOOL v92 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CMTime *))(v83 + 48);
        if (v92)
        {
          int v93 = v92(v81, 0x1EE53E378, AllocatorForMedia, &v137);
          if (v137.value) {
            CFNumberGetValue((CFNumberRef)v137.value, kCFNumberSInt32Type, &v129);
          }
          a4 = v114;
          if (v93 || (unsigned int value = v129.value, LODWORD(v129.value) == 7))
          {
            int v39 = 0;
          }
          else
          {
            for (uint64_t i = 0; i != 3; ++i)
              *(unsigned char *)(v77 + 518 + i) = ((value >> i) & 1) == 0;
            int v39 = 1;
          }
        }
        else
        {
          int v39 = 0;
          a4 = v114;
        }
        if (v137.value) {
          CFRelease((CFTypeRef)v137.value);
        }
      }
    }
    else
    {
      int v39 = 0;
    }
    *float valuePtr = a2;
    if (v110)
    {
      long long v40 = *(_OWORD *)&a4->value;
      *(void *)(DerivedStorage + 128) = a4->epoch;
      *(_OWORD *)(DerivedStorage + 112) = v40;
      long long v41 = *a5;
      *(void *)(DerivedStorage + 152) = *((void *)a5 + 2);
      *(_OWORD *)(DerivedStorage + 136) = v41;
      if ((*((unsigned char *)a5 + 12) & 1) != 0 && (a4->flags & 1) == 0)
      {
        fpfs_GetNextTimeToPlay(v22, 0, (uint64_t)&v137);
        *(CMTime *)(DerivedStorage + 112) = v137;
      }
    }
  }
  *(unsigned char *)(DerivedStorage + 522) = 0;
  CFNumberRef cfa = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, valuePtr);
  fpfsi_setPlaybackRateMonitorProperty(v22, @"AfmfpbProperty_PlayerRate", (uint64_t)cfa);
  if (v28 && *(int *)(DerivedStorage + 764) >= 3) {
    fpfsi_SeekToCurrentTime(Next);
  }
  if (fpfs_ShouldTryToGrabHDRPlaybackBaton((uint64_t)a1, (uint64_t)Next)
    && !fpfs_GrabPlayerHDRPlaybackBaton())
  {
    fpfsi_SwitchBetweenHDRAndSDR((uint64_t)Next, 1);
  }
  if (fpfs_ShouldTryToGrab4kPlaybackBaton((uint64_t)a1, (uint64_t)Next)
    && !fpfs_GrabPlayer4kPlaybackBaton(a1))
  {
    fpfsi_SwitchBetween4kAndHD((uint64_t)Next, 1);
  }
  uint64_t v42 = fpfs_EnsureScanningBoundaryTimer(Next);
  if (!v42)
  {
    float v59 = *valuePtr;
    uint64_t v60 = CMBaseObjectGetDerivedStorage();
    uint64_t v108 = *(void *)v60;
    uint64_t v61 = CMBaseObjectGetDerivedStorage();
    theArray.unsigned int value = 0;
    if (!*(void *)(v60 + 936))
    {
      uint64_t v43 = 0;
      unint64_t v84 = v114;
      goto LABEL_173;
    }
    uint64_t v107 = v61;
    uint64_t v62 = CMBaseObjectGetDerivedStorage();
    if (*(void *)(v62 + 40) && *(unsigned char *)(v62 + 48) && *(unsigned char *)(v62 + 49))
    {
      uint64_t updated = fpfsi_ConfigureAlternateSelectionBossForPlayRate((uint64_t)Next, v59);
      if (!updated)
      {
        if (!*(unsigned char *)(v60 + 2880)
          || v59 <= 2.0
          && v59 >= 0.0
          && ((uint64_t v64 = *(void *)(v60 + 1704)) == 0 || !FigAlternateIsIFrameOnly(v64))
          || (uint64_t updated = FigAlternateSelectionBossSetProperty(*(const void **)(v60 + 40), @"Paused", (const void *)*MEMORY[0x1E4F1CFC8]), !updated))
        {
          int v65 = v39;
          uint64_t v66 = FigAlternateSelectionBossApplyFilters(*(const void **)(v60 + 40));
          if (v66
            || (uint64_t v67 = *(void *)(v60 + 40),
                uint64_t v68 = FigGetAllocatorForMedia(),
                uint64_t v66 = FigAlternateSelectionBossCopyProperty(v67, @"FilteredAlternateList", v68, (const __CFArray **)&theArray), v66))
          {
            uint64_t v43 = v66;
            int v39 = v65;
LABEL_171:
            unint64_t v84 = v114;
            if (theArray.value) {
              CFRelease((CFTypeRef)theArray.value);
            }
LABEL_173:
            uint64_t v85 = *(void *)(v22 + 1704);
            if (v85 && FigAlternateIsIFrameOnly(v85))
            {
              BOOL v86 = 1;
              if (v43) {
                goto LABEL_91;
              }
            }
            else
            {
              BOOL v86 = *(void *)(v22 + 2968) != 0;
              if (v43) {
                goto LABEL_91;
              }
            }
            if (v39)
            {
              if ((*(unsigned char *)(v22 + 332) & 1) == 0)
              {
                uint64_t v43 = fpfsi_SetCurrentTimeWithSeekID((uint64_t)Next, MEMORY[0x1E4F1FA10], 0, 0);
                goto LABEL_237;
              }
LABEL_236:
              uint64_t v43 = 0;
              goto LABEL_237;
            }
            if (a2 == 0.0) {
              goto LABEL_192;
            }
            float v87 = *(float *)(v22 + 848);
            if (v87 != 0.0 || HIBYTE(v127) == 0) {
              BOOL v86 = 1;
            }
            if (!v86)
            {
              memset(&v129, 0, sizeof(v129));
              fpfs_GetItemBufferedDuration(Next, &v129, &v137, 0);
              CMTime theArray = v129;
              CMTime type = *v84;
              CMTime v121 = *(CMTime *)a5;
              fpfs_CheckIfLikelyToKeepUpAndNotify(a1, Next, &theArray, 1, &type, &v121, (uint64_t)&v137);
              goto LABEL_236;
            }
            if (v87 != 0.0)
            {
LABEL_192:
              BOOL v90 = 0;
              BOOL v89 = 0;
            }
            else
            {
              if (*(unsigned char *)(v22 + 464))
              {
                fpfs_notifyExternalStartupTasksOfEvents((uint64_t)a1, 4, 0, 0, MEMORY[0x1E4F1F9F8]);
                BOOL v89 = !fpfs_areAllExternalStartupTasksCompleted();
              }
              else
              {
                BOOL v89 = 0;
              }
              fpfs_GetNextTimeToPlay(v22, 0, (uint64_t)&v120);
              BOOL v90 = fpfsi_atOrAfterTimeToPausePlayback(v22, &v120);
            }
            uint64_t v43 = 0;
            if (!*(void *)(v22 + 2968) && !v89 && !v90)
            {
              int IsDisplayModeSwitchInProgress = FPSupport_IsDisplayModeSwitchInProgress();
              float v96 = *valuePtr;
              if (IsDisplayModeSwitchInProgress && v96 != 0.0)
              {
                if (dword_1E9350BB0)
                {
                  LODWORD(theArray.CFDictionarySetValue(theDict, key, value) = 0;
                  LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
                  CFArrayRef v97 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                  unsigned int v98 = theArray.value;
                  if (os_log_type_enabled(v97, type.value)) {
                    unsigned int v99 = v98;
                  }
                  else {
                    unsigned int v99 = v98 & 0xFFFFFFFE;
                  }
                  if (v99)
                  {
                    if (a1) {
                      BOOL v100 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
                    }
                    else {
                      BOOL v100 = "";
                    }
                    uint64_t v104 = CMBaseObjectGetDerivedStorage();
                    double v105 = *valuePtr;
                    LODWORD(v129.CFDictionarySetValue(theDict, key, value) = 136316418;
                    *(CMTimeValue *)((char *)&v129.value + 4) = (CMTimeValue)"fpfs_SetRateWithOptionsAndAnchorTime";
                    LOWORD(v129.flags) = 2048;
                    *(void *)((char *)&v129.flags + 2) = a1;
                    HIWORD(v129.epoch) = 2082;
                    unsigned int v130 = v100;
                    __int16 v131 = 2048;
                    CFArrayRef v132 = Next;
                    __int16 v133 = 2082;
                    uint64_t v134 = v104 + 3080;
                    __int16 v135 = 2048;
                    double v136 = v105;
                    _os_log_send_and_compose_impl();
                  }
                  fig_log_call_emit_and_clean_up_after_send_and_compose();
                }
                goto LABEL_236;
              }
              if (!*(unsigned char *)(v22 + 464) && v96 != 0.0)
              {
                fpfs_CheckPrebufferedLevels((uint64_t)Next, 1, -1, 0, (uint64_t)&v137);
                goto LABEL_236;
              }
              CMTime v137 = v128;
              CMTime v129 = *v84;
              CMTime theArray = *(CMTime *)a5;
              uint64_t v43 = fpfs_SetRateWithFadeInternal(a1, &v137, &v129, (long long *)&theArray.value, v96);
              if (v43)
              {
                uint64_t v101 = *(void *)(v22 + 1704);
                if (!v101 || !FigAlternateIsIFrameOnly(v101)) {
                  goto LABEL_91;
                }
                int v102 = fpfs_SetRateWithFade(a1, MEMORY[0x1E4F1FA48], 1.0);
                int v44 = 0;
                float v45 = v14;
                if (v102) {
                  goto LABEL_92;
                }
LABEL_243:
                if (*valuePtr != 0.0 && *(float *)(v22 + 848) == 0.0)
                {
                  fpfs_GetNextTimeToPlay(v22, 0, (uint64_t)&v119);
                  fpfsi_PrepareToStartWhenLikelyToKeepUp((uint64_t)Next, &v119);
                }
                goto LABEL_93;
              }
            }
LABEL_237:
            int v44 = 0;
            if (!v43 && HIBYTE(v127))
            {
              if (*(float *)(v22 + 848) == a2)
              {
                uint64_t v43 = 0;
                int v44 = 0;
              }
              else
              {
                int v44 = 1;
                if (!*(unsigned char *)(DerivedStorage + 160))
                {
                  float v45 = 0.0;
                  uint64_t v43 = 4294954368;
                  goto LABEL_92;
                }
                uint64_t v43 = 0;
              }
            }
            goto LABEL_243;
          }
          int v39 = v65;
          if (theArray.value && CFArrayGetCount((CFArrayRef)theArray.value) > 0)
          {
            uint64_t updated = fpfsi_UpdateValidAlternateListAndSuggestAnAlternate((uint64_t)Next, (const __CFArray *)theArray.value, 0);
            if (!updated)
            {
              fpfsi_setPlaybackRateMonitorProperty(v60, @"AfmfpbProperty_CurrentAlternate", *(void *)(v60 + 1704));
              uint64_t v69 = *(void *)(v60 + 1704);
              if (v69) {
                BOOL v70 = FigAlternateIsIFrameOnly(v69) != 0;
              }
              else {
                BOOL v70 = 0;
              }
              CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v60 + 1688), 0);
              int IsIFrameOnly = FigAlternateIsIFrameOnly((uint64_t)ValueAtIndex);
              if (*(void *)(v60 + 1704))
              {
                BOOL v72 = FigCFArrayContainsValue() == 0;
LABEL_134:
                if (dword_1E9350BB0)
                {
                  BOOL v106 = v72;
                  LODWORD(type.CFDictionarySetValue(theDict, key, value) = 0;
                  LOBYTE(v121.CFDictionarySetValue(theDict, key, value) = 0;
                  uint64_t v73 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                  os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT);
                  fig_log_call_emit_and_clean_up_after_send_and_compose();
                  BOOL v72 = v106;
                }
                if (v72 || IsIFrameOnly || fpfs_audioOnlyValidAlternateList(v60) || v59 <= 2.0 && v59 >= 0.0)
                {
                  if (*(void *)(v60 + 2968)) {
                    fpfsi_EndBestEffortSeekTrickplayMode(v60);
                  }
                  uint64_t updated = fpfsi_handleIFrameOnlyRateTransition(Next, v70, IsIFrameOnly, *(const __CFArray **)(v60 + 1688), 0, v14);
                  if (!updated)
                  {
                    if (*(unsigned char *)(v60 + 470))
                    {
                      uint64_t v43 = 0;
                      goto LABEL_171;
                    }
                    uint64_t updated = fpfsi_SetPumpRate(v60, *(float *)(v107 + 108));
                  }
                }
                else
                {
                  uint64_t updated = fpfs_EnterBestEffortTrickplayMode(v108, (const __CFString *)Next, *(float *)(v107 + 108));
                }
                goto LABEL_170;
              }
LABEL_133:
              BOOL v72 = 0;
              goto LABEL_134;
            }
          }
          else
          {
            uint64_t updated = FigSignalErrorAt();
          }
        }
      }
LABEL_170:
      uint64_t v43 = updated;
      goto LABEL_171;
    }
    BOOL v70 = 0;
    int IsIFrameOnly = 0;
    goto LABEL_133;
  }
  uint64_t v43 = v42;
LABEL_91:
  int v44 = 0;
  float v45 = v14;
LABEL_92:
  *(float *)(DerivedStorage + 108) = v45;
  *(_OWORD *)(DerivedStorage + 112) = v116;
  *(void *)(DerivedStorage + 128) = v115;
  *(_OWORD *)(DerivedStorage + 136) = v116;
  *(void *)(DerivedStorage + 152) = v115;
  *(_WORD *)(v22 + 518) = 0;
  *(unsigned char *)(v22 + 520) = 0;
LABEL_93:
  CFAllocatorRef v46 = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v46, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetFloat32();
  fpfs_EnqueueNotification(a1, @"Remote_RateWillChangeTo", a1, Mutable);
  if (!v43 && !v44) {
    goto LABEL_98;
  }
  NotificationPayloadForProperties = fpfs_CreateNotificationPayloadForProperties(a1, 0, v48, v49, v50, v51, v52, v53, @"CurrentRate", 0);
  fpfs_EnqueueNotification(a1, @"SetRateFailed", a1, NotificationPayloadForProperties);
  if (NotificationPayloadForProperties) {
    CFRelease(NotificationPayloadForProperties);
  }
  if (!v43)
  {
LABEL_98:
    if (*valuePtr != 0.0) {
      *(unsigned char *)(v22 + 530) = 0;
    }
    if (!CelestialShouldLimitHDRConcurrentPlayback()
      || (uint64_t v55 = CMBaseObjectGetDerivedStorage(), *(float *)(v55 + 108) == 0.0)
      || !fpfs_CanRenderVideo(v55, 0))
    {
      fpfs_ReleasePlayerHDRPlaybackBaton();
    }
    if (!CelestialShouldLimit4kConcurrentPlayback()
      || (uint64_t v56 = CMBaseObjectGetDerivedStorage(), *(float *)(v56 + 108) == 0.0)
      || !fpfs_CanRenderVideo(v56, 0))
    {
      fpfs_ReleasePlayer4kPlaybackBaton(a1);
    }
  }
  float v57 = *valuePtr;
  if (*valuePtr == 0.0)
  {
    fpfsi_performCurrentResourceConservationAction(Next, *(_DWORD *)(DerivedStorage + 764));
    uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    fpfsi_SetLastTimestampClientDidPauseOnContentSteeringMonitor((uint64_t)Next, UpTimeNanoseconds);
    float v57 = *(float *)(DerivedStorage + 108);
  }
  if (v113 & 2) != 0 && v57 > 0.0 && (*((unsigned char *)a5 + 12))
  {
    long long v74 = *a5;
    *(void *)(v22 + 448) = *((void *)a5 + 2);
    *(_OWORD *)(v22 + 432) = v74;
  }
  else
  {
    *(_OWORD *)(v22 + 432) = v116;
    *(void *)(v22 + 448) = v115;
  }
  if (*(_DWORD *)(DerivedStorage + 808) != 1 && *valuePtr == 1.0 && *(float *)(v22 + 848) == 1.0)
  {
    fpfs_ReportVideoPlaybackTimeThroughFigLog((uint64_t)Next);
    fpfs_ReportAudioPlaybackThroughFigLog((uint64_t)Next);
    fpfsi_SetLastTimestampClientDidPauseOnContentSteeringMonitor((uint64_t)Next, 0x7FFFFFFFFFFFFFFFLL);
  }
  CFArrayRef Next = cfa;
LABEL_142:
  if (*(float *)(DerivedStorage + 108) != v14)
  {
    uint64_t v75 = fpfs_CreateNotificationPayloadForProperties(a1, 0, v15, v16, v17, v18, v19, v20, @"CurrentRate", 0);
    FigCFDictionarySetInt32();
    FigCFDictionarySetValueFromKeyInDict();
    FigCFDictionarySetValueFromKeyInDict();
    FigCFDictionarySetValueFromKeyInDict();
    fpfs_EnqueueNotification(a1, @"RateDidChange", a1, v75);
    if (v75) {
      CFRelease(v75);
    }
  }
  if (*(unsigned char *)(DerivedStorage + 842) && v125 == 37) {
    fpfs_PostNotificationWhenUnlocked(a1, @"InterstitialStarted", a1, 0);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (Next) {
    CFRelease(Next);
  }
  fpfs_UnlockAndPostNotificationsWithCaller(a1);
  return v43;
}

void fpfs_enqueuePrerollWasCancelledNotificationIfNeeded(const __CFArray *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(_DWORD *)(DerivedStorage + 2208))
  {
    uint64_t v3 = DerivedStorage;
    uint64_t v4 = CMBaseObjectGetDerivedStorage();
    if (fpfs_getNext(v4, 0) == a1)
    {
      CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (!FigCFDictionarySetInt32())
      {
        fpfs_EnqueueNotification(*(const void **)v3, @"PrerollWasCancelled", *(const void **)v3, Mutable);
        *(_DWORD *)(v3 + 2208) = 0;
      }
      if (Mutable)
      {
        CFRelease(Mutable);
      }
    }
    else
    {
      FigSignalErrorAt();
    }
  }
}

void fpfsi_applyTimeToPausePlayback(const void *a1, long long *a2, int a3, int a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a4 && (*((unsigned char *)a2 + 12) & 1) == 0)
  {
    CMTime v9 = (const AudioFormatListItem *)CMBaseObjectGetDerivedStorage();
    fpfs_UnmuteNextAtmosAudioTrack(v9, DerivedStorage, 0);
  }
  if (!a3)
  {
    CMTime time1 = *(CMTime *)(DerivedStorage + 1448);
    CMTime time2 = *(CMTime *)a2;
    if (!CMTimeCompare(&time1, &time2)) {
      return;
    }
  }
  CMTime v10 = (CMTime *)(DerivedStorage + 1448);
  CMTime v38 = *(CMTime *)(DerivedStorage + 1448);
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CMTime time1 = *(CMTime *)a2;
  CFStringRef v12 = CMTimeCopyDescription(AllocatorForMedia, &time1);
  uint64_t v35 = DerivedStorage;
  if (dword_1E9350BB0)
  {
    LODWORD(fireTime.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    CMTime v10 = (CMTime *)(DerivedStorage + 1448);
  }
  if (v12) {
    CFRelease(v12);
  }
  long long v14 = *a2;
  v10->CMTimeEpoch epoch = *((void *)a2 + 2);
  *(_OWORD *)&v10->CMTimeValue value = v14;
  uint64_t v15 = CMBaseObjectGetDerivedStorage();
  CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
  CMTimeEpoch v16 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  *(_OWORD *)&time2.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
  time2.CMTimeEpoch epoch = v16;
  long long v36 = *(_OWORD *)&time2.value;
  *(_OWORD *)&fireTime.CMTimeValue value = *(_OWORD *)&time2.value;
  fireTime.CMTimeEpoch epoch = v16;
  __int16 v41 = 0;
  __int16 v40 = 0;
  if ((*(unsigned char *)(v15 + 1460) & 1) == 0) {
    goto LABEL_35;
  }
  uint64_t v17 = v15;
  if (!*(unsigned char *)(v15 + 466)) {
    goto LABEL_35;
  }
  CMTimeFlags v18 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
  int v19 = (_OWORD *)(v15 + 1448);
  uint64_t v20 = *(void *)(v15 + 1048);
  if (!v20) {
    goto LABEL_23;
  }
  CMTimeFlags v34 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
  do
  {
    if (*(unsigned char *)(v20 + 184)) {
      goto LABEL_20;
    }
    *(_OWORD *)&time1.CMTimeValue value = *v19;
    time1.CMTimeEpoch epoch = *(void *)(v17 + 1464);
    long long v47 = v36;
    CMTimeEpoch v48 = v16;
    long long v49 = v36;
    CMTimeEpoch v50 = v16;
    long long v51 = v36;
    CMTimeEpoch v52 = v16;
    long long v53 = v36;
    CMTimeEpoch v54 = v16;
    CMBufferQueueCallForEachBuffer(*(CMBufferQueueRef *)(v20 + 80), (OSStatus (__cdecl *)(CMBufferRef, void *))fpfs_GetClosestSegmentBoundary, &time1);
    int v21 = *(_DWORD *)(v20 + 32);
    if (v21 == 1986618469)
    {
      p_CMTime fireTime = &fireTime;
      long long v23 = &v41;
      BOOL v24 = (BOOL *)&v40;
    }
    else
    {
      if (v21 != 1936684398) {
        goto LABEL_20;
      }
      p_CMTime fireTime = &time2;
      long long v23 = (__int16 *)((char *)&v41 + 1);
      BOOL v24 = (BOOL *)&v40 + 1;
    }
    fpfsi_UpdateTimeIfCloser((uint64_t)&time1, (uint64_t)p_fireTime, v23, v24);
LABEL_20:
    uint64_t v20 = *(void *)(v20 + 8);
  }
  while (v20);
  CMTime v10 = (CMTime *)(DerivedStorage + 1448);
  CMTimeFlags v18 = v34;
  if (HIBYTE(v41))
  {
    int v25 = 1;
    goto LABEL_24;
  }
LABEL_23:
  int v25 = (*(_DWORD *)(v17 + 1096) >> 1) & 1;
  if (v25)
  {
LABEL_24:
    if (HIBYTE(v40)) {
      goto LABEL_25;
    }
  }
  else
  {
LABEL_25:
    if ((_BYTE)v41) {
      BOOL v26 = 1;
    }
    else {
      BOOL v26 = v25 == 0;
    }
    if (!v26 || v40 != 0)
    {
      CMTime type = time2;
      CMTime lhs = fireTime;
      CMTimeMinimum(&time1, &type, &lhs);
      CMTimeValue value = time1.value;
      CMTimeFlags flags = time1.flags;
      CMTimeScale timescale = time1.timescale;
      CMTimeEpoch epoch = time1.epoch;
      CMTimeMake(&type, 5, 10000);
      lhs.CMTimeValue value = value;
      lhs.CMTimeScale timescale = timescale;
      lhs.CMTimeFlags flags = flags;
      lhs.CMTimeEpoch epoch = epoch;
      uint64_t DerivedStorage = v35;
      CMTimeSubtract(&time1, &lhs, &type);
      CMTimeScale timescale = time1.timescale;
      CMTimeValue value = time1.value;
      CMTime lhs = time1;
      CMTime v39 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      CMTimeMaximum(&time1, &lhs, &v39);
      CMTimeValue value = time1.value;
      CMTimeFlags v18 = time1.flags;
      CMTimeScale timescale = time1.timescale;
      CMTimeEpoch v16 = time1.epoch;
    }
  }
  if (v18)
  {
    *(void *)int v19 = value;
    *(_DWORD *)(v17 + 1456) = timescale;
    *(_DWORD *)(v17 + 1460) = v18;
    *(void *)(v17 + 1464) = v16;
    fpfs_EnqueueNotification(*(const void **)v17, @"SnappedTimeToPausePlayback", a1, 0);
  }
LABEL_35:
  if (*(unsigned char *)(DerivedStorage + 1460) & 1) != 0 || (*(unsigned char *)(DerivedStorage + 1484))
  {
    CMTime time1 = v38;
    CMTime time2 = *v10;
    fpfsi_ClampVideoToTime(a1, &time1, (long long *)&time2.value);
    if (*(unsigned char *)(DerivedStorage + 1460) & 1) != 0 && (*(unsigned char *)(DerivedStorage + 1436))
    {
      CMTime time1 = *(CMTime *)(DerivedStorage + 1424);
      CMTime time2 = *v10;
      if (CMTimeCompare(&time1, &time2) < 0)
      {
        CMTime time1 = *v10;
        fpfsi_applyTimeToPauseBuffering((uint64_t)a1, (long long *)&time1.value);
      }
    }
  }
  uint64_t v30 = CMBaseObjectGetDerivedStorage();
  uint64_t v31 = v30;
  uint64_t v32 = *(void *)(v30 + 2336);
  if (*(unsigned char *)(v30 + 1460))
  {
    if (!v32)
    {
      char v33 = fpfs_TimerDispatchSourceCreate(*(dispatch_queue_t *)(v30 + 600), *(void **)(v30 + 16), 0xFFFFFFFFFFFFFFFFLL, (void (__cdecl *)(void *))fpfs_TimeToPausePlaybackTimerProc, 0);
      *(void *)(v31 + 2336) = v33;
      if (!v33)
      {
        FigSignalErrorAt();
        goto LABEL_48;
      }
      CMTimebaseAddTimerDispatchSource(*(CMTimebaseRef *)(v31 + 576), v33);
    }
    memset(&time1, 0, sizeof(time1));
    fpfsi_EstimateTimeToPause((uint64_t)a1, &time1);
    memset(&time2, 0, sizeof(time2));
    CMTime fireTime = *(CMTime *)(v31 + 1448);
    CMTime type = time1;
    CMTimeSubtract(&time2, &fireTime, &type);
    CMTime type = *(CMTime *)(v31 + 1448);
    *(_OWORD *)&lhs.CMTimeValue value = kTimeToPausePlaybackAdvanceNotice;
    lhs.CMTimeEpoch epoch = 0;
    CMTimeSubtract(&fireTime, &type, &lhs);
    CMTime time2 = fireTime;
    CMTimebaseSetTimerDispatchSourceNextFireTime(*(CMTimebaseRef *)(v31 + 576), *(dispatch_source_t *)(v31 + 2336), &fireTime, 0);
    goto LABEL_48;
  }
  if (v32) {
    fpfs_ReleaseAndClearTimebaseTimer(*(OpaqueCMTimebase **)(v30 + 576), (dispatch_object_t *)(v30 + 2336));
  }
LABEL_48:
  fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&v37);
  if (fpfsi_atOrAfterTimeToPausePlayback(DerivedStorage, &v37)) {
    fpfs_HandleReachingTimeToPausePlayback(a1);
  }
  if (a4) {
    fpfs_CheckPrebufferedLevels(&time1, a1, 1, -1, 0);
  }
}

void fpfsi_RTCReportingReportDesiredRateChange(double a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = *(void *)(DerivedStorage + 2544);
  if (v3)
  {
    uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v5 = v4 ? v4 : 0;
    uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v5 + 56);
    if (v6) {
      v6(v3, 0x1EE582B78, 0x1EE583A38, (uint64_t)(a1 * 100.0), 0);
    }
  }
  if (a1 != 0.0 && !*(unsigned char *)(DerivedStorage + 2593))
  {
    if (*(unsigned char *)(DerivedStorage + 2592))
    {
      double Current = CFAbsoluteTimeGetCurrent();
      double v8 = *(double *)(DerivedStorage + 2992);
      *(unsigned char *)(DerivedStorage + 2593) = 1;
      uint64_t v9 = *(void *)(DerivedStorage + 2544);
      if (v9)
      {
        double v10 = Current;
        uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v12 = v11 ? v11 : 0;
        char v13 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v12 + 56);
        if (v13)
        {
          v13(v9, 0x1EE582B78, 0x1EE584B58, (uint64_t)((v10 - v8) * 1000.0), 0);
        }
      }
    }
  }
}

void fpfs_notifyExternalStartupTasksOfEvents(uint64_t a1, int a2, uint64_t a3, int a4, long long *a5)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef Next = fpfs_getNext(DerivedStorage, 0);
  uint64_t v20 = CMBaseObjectGetDerivedStorage();
  CFArrayRef v8 = *(const __CFArray **)(DerivedStorage + 880);
  if (v8)
  {
    CFIndex Count = CFArrayGetCount(v8);
    if (Next)
    {
      if (Count >= 1)
      {
        CFIndex v9 = 0;
        uint64_t v19 = DerivedStorage;
        int v18 = a4;
        do
        {
          CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 880), v9);
          char v27 = 0;
          CFTypeRef cf = 0;
          if (FigPlayerStartupTaskCopyRequiredParameters((uint64_t)ValueAtIndex, (__CFArray **)&cf)) {
            break;
          }
          NotificationPayloadForProperties = FPSupport_CreateNotificationPayloadForProperties(a1, (uint64_t)Next, (CFArrayRef)cf);
          int v12 = FigCFArrayContainsValue();
          if (a4 && v12) {
            FigCFDictionarySetInt32();
          }
          if FigCFArrayContainsValue() && (*((unsigned char *)a5 + 12))
          {
            long long v28 = *a5;
            uint64_t v29 = *((void *)a5 + 2);
            FigCFDictionarySetCMTime();
          }
          if (FigCFArrayContainsValue()) {
            FigCFDictionarySetFloat32();
          }
          if (FigCFArrayContainsValue()) {
            FigCFDictionarySetValue();
          }
          if (FigCFArrayContainsValue())
          {
            fpfs_GetNextTimeToPlay(v20, 0, (uint64_t)v25);
            FigCFDictionarySetCMTime();
          }
          if (FigPlayerStartupTaskNotifyOfEvents((uint64_t)ValueAtIndex, a2, (uint64_t)NotificationPayloadForProperties, (BOOL *)&v27))
          {
            os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            char v27 = 1;
            a4 = v18;
            uint64_t DerivedStorage = v19;
          }
          if (NotificationPayloadForProperties) {
            CFRelease(NotificationPayloadForProperties);
          }
          if (cf) {
            CFRelease(cf);
          }
          CFArrayRef v14 = *(const __CFArray **)(DerivedStorage + 888);
          v31.size_t length = CFArrayGetCount(v14);
          v31.CFIndex location = 0;
          FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v14, v31, ValueAtIndex);
          if (v27)
          {
            if (FirstIndexOfValue != -1)
            {
              CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(DerivedStorage + 888), FirstIndexOfValue);
              if (dword_1E9350BB0)
              {
                CMTimeEpoch v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
                fig_log_call_emit_and_clean_up_after_send_and_compose();
              }
            }
          }
          else if (FirstIndexOfValue == -1)
          {
            CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 888), ValueAtIndex);
            if (dword_1E9350BB0)
            {
              uint64_t v17 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
          }
          ++v9;
        }
        while (Count != v9);
      }
    }
  }
}

BOOL fpfs_areAllExternalStartupTasksCompleted()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef v1 = *(const __CFArray **)(DerivedStorage + 888);
  if (!v1) {
    return 1;
  }
  CFIndex Count = CFArrayGetCount(v1);
  if (Count < 1) {
    return 1;
  }
  CFIndex v3 = Count;
  CFIndex v4 = 0;
  while (1)
  {
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 888), v4);
    BOOL result = FigPlayerStartupTaskDoesAllowStartup((uint64_t)ValueAtIndex);
    if (!result) {
      break;
    }
    if (v3 == ++v4) {
      return 1;
    }
  }
  return result;
}

uint64_t fpfs_SetRateWithFadeInternal(void *a1, CMTime *a2, CMTime *a3, long long *a4, float a5)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (dword_1E9350BB0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (a5 != 0.0 && !*(void *)(DerivedStorage + 80)) {
    fpfs_PullNextItem(a1);
  }
  CFArrayRef Next = fpfs_getNext(DerivedStorage, 0);
  if (Next) {
    float v13 = *(float *)(CMBaseObjectGetDerivedStorage() + 848);
  }
  else {
    float v13 = 0.0;
  }
  if (v13 == a5) {
    return 0;
  }
  if (a5 == 0.0)
  {
    float Seconds = 0.0;
    if ((a2->flags & 0x1D) == 1)
    {
      CMTime time = *a2;
      float Seconds = CMTimeGetSeconds(&time);
    }
    fpfs_applySoftwareVolume(0.0, Seconds, (uint64_t)a1, 1);
    *(_OWORD *)&time.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
    CMTimeEpoch v15 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
    time.CMTimeEpoch epoch = v15;
    long long v19 = *(_OWORD *)&time.value;
    goto LABEL_14;
  }
  if (v13 != 0.0)
  {
    CMTime time = *a3;
    long long v19 = *a4;
    CMTimeEpoch v15 = *((void *)a4 + 2);
LABEL_14:
    CMTimeEpoch v20 = v15;
    return fpfs_setRateInternal((uint64_t)a1, 0, (uint64_t)&time, (uint64_t)&v19, a5);
  }
  float v17 = 0.0;
  if ((a2->flags & 0x1D) == 1)
  {
    CMTime time = *a2;
    float v17 = CMTimeGetSeconds(&time);
  }
  fpfs_applySoftwareVolume(0.0, 0.0, (uint64_t)a1, 1);
  if (Next)
  {
    uint64_t v18 = CMBaseObjectGetDerivedStorage();
    fpfsi_applySoftwareVolume(*(float *)(v18 + 1832), 0.0, (uint64_t)Next, 3);
  }
  CMTime time = *a3;
  long long v19 = *a4;
  CMTimeEpoch v20 = *((void *)a4 + 2);
  uint64_t result = fpfs_setRateInternal((uint64_t)a1, 0, (uint64_t)&time, (uint64_t)&v19, a5);
  if (!result)
  {
    fpfs_applySoftwareVolume(*(float *)(DerivedStorage + 104), v17, (uint64_t)a1, 0);
    return 0;
  }
  return result;
}

BOOL fpfs_WantMATAtmosForTrack(uint64_t a1)
{
  CMBaseObjectGetDerivedStorage();
  uint64_t v2 = *(const opaqueCMFormatDescription **)(a1 + 40);
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(v2);
  BOOL result = 0;
  if (MediaSubType <= 1885692722)
  {
    if (MediaSubType > 1700997938)
    {
      if (MediaSubType == 1700997939) {
        return *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561) != 0;
      }
      if (MediaSubType != 1700998451)
      {
        int v5 = 1885547315;
        goto LABEL_16;
      }
LABEL_18:
      size_t sizeOut = 0;
      FormatList = CMAudioFormatDescriptionGetFormatList(v2, &sizeOut);
      if (!FormatList || sizeOut <= 0x2F) {
        return 0;
      }
      int mFormatID = FormatList->mASBD.mFormatID;
      if (mFormatID <= 1885547314)
      {
        BOOL v9 = mFormatID == 1667574579;
        int v10 = 1700997939;
      }
      else
      {
        BOOL v9 = mFormatID == 1885547315 || mFormatID == 1902324531;
        int v10 = 2053319475;
      }
      if (!v9 && mFormatID != v10) {
        return 0;
      }
      return *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561) != 0;
    }
    if (MediaSubType == 1667574579) {
      return *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561) != 0;
    }
    int v6 = 1667575091;
LABEL_12:
    if (MediaSubType != v6) {
      return result;
    }
    goto LABEL_18;
  }
  if (MediaSubType > 1902469938)
  {
    if (MediaSubType == 2053464883) {
      goto LABEL_18;
    }
    if (MediaSubType == 2053319475) {
      return *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561) != 0;
    }
    int v6 = 1902469939;
    goto LABEL_12;
  }
  if (MediaSubType == 1885692723) {
    goto LABEL_18;
  }
  int v5 = 1902324531;
LABEL_16:
  if (MediaSubType == v5) {
    return *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561) != 0;
  }
  return result;
}

uint64_t fpfsi_SeekToCurrentTime(const __CFArray *a1)
{
  memset(&v14, 0, sizeof(v14));
  memset(&v13, 0, sizeof(v13));
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&v16);
  CMTime lhs = v16;
  *(_OWORD *)&rhs.CMTimeValue value = kSeekToCurrentFudge;
  rhs.CMTimeEpoch epoch = 0;
  CMTimeAdd(&v15, &lhs, &rhs);
  uint64_t v3 = *(void *)(DerivedStorage + 1704);
  if (v3 && FigAlternateIsIFrameOnly(v3))
  {
    CMTimeMake(&v10, 2, 1);
    CMTime lhs = v15;
    CMTimeSubtract(&v14, &lhs, &v10);
    CMTimeMake(&v9, 2, 1);
    CMTime lhs = v15;
    CMTimeAdd(&v13, &lhs, &v9);
    int v4 = 0;
    unsigned int v5 = 0;
    int v6 = 0;
  }
  else if (*(unsigned char *)(DerivedStorage + 332))
  {
    if (*(unsigned char *)(DerivedStorage + 1508))
    {
      CMTime v14 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
      CMTime v13 = v14;
      int v4 = 5;
    }
    else
    {
      int v4 = *(_DWORD *)(DerivedStorage + 392);
      CMTime v14 = *(CMTime *)(DerivedStorage + 344);
      CMTime v13 = *(CMTime *)(DerivedStorage + 368);
    }
    unsigned int v5 = *(_DWORD *)(DerivedStorage + 2204);
    int v6 = *(_DWORD *)(DerivedStorage + 2224);
  }
  else
  {
    unsigned int v5 = 0;
    int v6 = 0;
    CMTime v14 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
    CMTime v13 = v14;
    int v4 = 5;
  }
  CMTime lhs = v15;
  CMTime rhs = v14;
  CMTime v8 = v13;
  return fpfsi_SetCurrentTimeWithRangeAndSeekIDGuts(a1, &lhs, v4 | 0xF0u, (uint64_t)&rhs, (long long *)&v8.value, v5, 0, v6, 1, 0, 0, 0, 0, 0);
}

uint64_t fpfs_ShouldTryToGrabHDRPlaybackBaton(uint64_t a1, uint64_t a2)
{
  uint64_t result = CelestialShouldLimitHDRConcurrentPlayback();
  if (result)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    if (*(float *)(DerivedStorage + 108) == 0.0) {
      return 0;
    }
    uint64_t result = fpfs_CanRenderVideo(DerivedStorage, 0);
    if (!result) {
      return result;
    }
    uint64_t v5 = CMBaseObjectGetDerivedStorage();
    uint64_t v6 = CMBaseObjectGetDerivedStorage();
    if (*(void *)(v5 + 80) != a2) {
      return 0;
    }
    uint64_t result = *(void *)(v6 + 1704);
    if (result)
    {
      if (FigAlternateGetVideoRange(result) >= 2) {
        return *(void *)(v5 + 792) == 0;
      }
      return 0;
    }
  }
  return result;
}

CFStringRef fpfs_GrabPlayerHDRPlaybackBaton()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFStringRef result = *(CFStringRef *)(DerivedStorage + 792);
  if (!result)
  {
    CFStringRef result = FPSupport_AcquireHDRVideoDisplayAssertion(*(const void **)(DerivedStorage + 856));
    *(void *)(DerivedStorage + 792) = result;
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      return *(CFStringRef *)(DerivedStorage + 792);
    }
  }
  return result;
}

uint64_t fpfsi_SwitchBetweenHDRAndSDR(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (dword_1E9350BB0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (!*(void *)(DerivedStorage + 40)) {
    return 0;
  }
  uint64_t v5 = *(void *)(DerivedStorage + 64);
  if (v5)
  {
    if (a2)
    {
      uint64_t SInt32 = (const void *)FigCFNumberCreateSInt32();
      uint64_t v5 = *(void *)(DerivedStorage + 64);
    }
    else
    {
      uint64_t SInt32 = 0;
    }
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    CMTime v9 = *(uint64_t (**)(uint64_t, __CFString *, const void *))(v8 + 56);
    if (v9)
    {
      uint64_t v5 = v9(v5, @"AlternateFilterMonitorProperty_PreferredVideoRange", SInt32);
      if (!SInt32)
      {
LABEL_17:
        if (!v5) {
          FigAlternateSelectionBossApplyFilters(*(const void **)(DerivedStorage + 40));
        }
        return v5;
      }
    }
    else
    {
      uint64_t v5 = 4294954514;
      if (!SInt32) {
        goto LABEL_17;
      }
    }
    CFRelease(SInt32);
    goto LABEL_17;
  }
  return v5;
}

uint64_t fpfs_ShouldTryToGrab4kPlaybackBaton(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = CMBaseObjectGetDerivedStorage();
  if (!*(unsigned char *)(DerivedStorage + 841) || *(void *)(DerivedStorage + 80) != a2 || !*(void *)(v4 + 1704)) {
    return 0;
  }
  uint64_t result = CelestialShouldLimit4kConcurrentPlayback();
  if (!result) {
    return result;
  }
  uint64_t v6 = CMBaseObjectGetDerivedStorage();
  if (*(float *)(v6 + 108) == 0.0) {
    return 0;
  }
  uint64_t result = fpfs_CanRenderVideo(v6, 0);
  if (result)
  {
    uint64_t result = fpfsi_isPlaying4k();
    if (result) {
      return *(void *)(DerivedStorage + 800) == 0;
    }
  }
  return result;
}

CFStringRef fpfs_GrabPlayer4kPlaybackBaton(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFStringRef result = *(CFStringRef *)(DerivedStorage + 800);
  if (!result)
  {
    CFStringRef result = FPSupport_Acquire4kVideoDisplayAssertion(a1);
    *(void *)(DerivedStorage + 800) = result;
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      return *(CFStringRef *)(DerivedStorage + 800);
    }
  }
  return result;
}

uint64_t fpfsi_SwitchBetween4kAndHD(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
  if (!*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 841) || !DerivedStorage[5]) {
    return 0;
  }
  if (a2)
  {
    uint64_t result = fpfsi_addHDResolutionCap();
    if (result) {
      return result;
    }
    goto LABEL_11;
  }
  if (!CelestialShouldLimit4kConcurrentPlayback()
    || (uint64_t v5 = CMBaseObjectGetDerivedStorage(), *(float *)(v5 + 108) == 0.0)
    || !fpfs_CanRenderVideo(v5, 0)
    || !fpfs_GrabPlayer4kPlaybackBaton(*DerivedStorage)
    || (uint64_t v6 = CMBaseObjectGetDerivedStorage(),
        uint64_t result = FigAlternateSelectionBossRemoveFilter(*(void *)(v6 + 40), @"ResolutionCapFor4kBaton"),
        !result))
  {
LABEL_11:
    FigAlternateSelectionBossApplyFilters(DerivedStorage[5]);
    return 0;
  }
  return result;
}

uint64_t fpfs_CheckIfLikelyToKeepUpAndNotify(void *a1, const __CFArray *a2, CMTime *a3, int a4, CMTime *a5, CMTime *a6, uint64_t a7)
{
  uint64_t v221 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  long long v192 = *MEMORY[0x1E4F1F9F8];
  *(_OWORD *)&v207.unsigned int value = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v14 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  v207.CMTimeEpoch epoch = v14;
  uint64_t v206 = 0;
  CFRetain(a1);
  uint64_t v15 = CMBaseObjectGetDerivedStorage();
  if (FigRetainProxyIsInvalidated())
  {
    uint64_t v25 = 4294954511;
    goto LABEL_334;
  }
  if (a4) {
    BOOL v16 = 1;
  }
  else {
    BOOL v16 = *(unsigned char *)(DerivedStorage + 160) == 0;
  }
  int v198 = v16;
  uint64_t v17 = *(void *)(v15 + 1704);
  CMTimeEpoch v191 = v14;
  if (v17) {
    int v18 = FigAlternateIsIFrameOnly(v17) != 0;
  }
  else {
    int v18 = 0;
  }
  BOOL v196 = fpfsi_waitForVenueDescriptionProcessing(v15);
  uint64_t v194 = a7;
  if (*(float *)(v15 + 848) == 0.0 && (*(float *)(DerivedStorage + 108) != 0.0 ? (int v19 = 1) : (int v19 = v18), v19 == 1))
  {
    if (((v198 ^ 1 | v18) & 1) == 0)
    {
      CMTimeEpoch v20 = a1;
      if (fpfs_FirstRenderingTrackofType((uint64_t)a2, 1936684398)) {
        BOOL v21 = 1;
      }
      else {
        BOOL v21 = fpfs_FirstRenderingTrackofType((uint64_t)a2, 1986618469) != 0;
      }
      CMTime lhs = *a3;
      CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      if (CMTimeCompare(&lhs, &time2) && v21)
      {
        if (dword_1E9350BB0)
        {
          LODWORD(v205.CFDictionarySetValue(theDict, key, value) = 0;
          LOBYTE(v203.CFDictionarySetValue(theDict, key, value) = 0;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          int v198 = 1;
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          a1 = v20;
LABEL_263:
          a7 = v194;
          goto LABEL_17;
        }
        int v198 = 1;
      }
      else
      {
        if (dword_1E9350BB0)
        {
          LODWORD(v205.CFDictionarySetValue(theDict, key, value) = 0;
          LOBYTE(v203.CFDictionarySetValue(theDict, key, value) = 0;
          CMTimeEpoch v52 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        if (!*(unsigned char *)(DerivedStorage + 160))
        {
          a1 = v20;
          fpfs_stopPlaybackForInternalReason(v20, 4);
          int v198 = 0;
          goto LABEL_263;
        }
        int v198 = 0;
      }
      a1 = v20;
      goto LABEL_263;
    }
  }
  else
  {
    int v198 = 0;
  }
LABEL_17:
  int v195 = *(_DWORD *)(v15 + 524);
  CMTime lhs = *a3;
  int IsItemReadyToStart = fpfs_IsItemReadyToStart((uint64_t)a2, &lhs, a7, (float *)&v206 + 1, &v207, (uint64_t)&v206);
  if ((v207.flags & 1) == 0) {
    goto LABEL_23;
  }
  if (*(float *)(v15 + 848) != 0.0) {
    goto LABEL_23;
  }
  memset(&v205, 0, sizeof(v205));
  fpfs_GetTime(v15, (uint64_t)&rhs);
  CMTime lhs = v207;
  CMTimeSubtract(&v205, &lhs, &rhs);
  memset(&v203, 0, sizeof(v203));
  CMTime lhs = *a3;
  CMTime time2 = v205;
  CMTimeSubtract(&v203, &lhs, &time2);
  uint64_t v23 = *(unsigned int *)(v15 + 1096);
  CMTime lhs = v203;
  CMTime time2 = v207;
  if (!fpfs_CheckCanKeepUp((uint64_t)a2, (uint64_t)&lhs, &time2, v23, 0, 0, 0, 0)) {
    goto LABEL_23;
  }
  CMTime lhs = v207;
  if (fpfsi_TryToSeekWithinBuffer(a2, &lhs, 0, 1))
  {
    CFTypeRef cf = 0;
    CMTime lhs = v207;
    fpfsi_CopyDateForTime((uint64_t)a2, &lhs, (CFDateRef *)&cf);
    if (dword_1E9350BB0)
    {
      int v201 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      BOOL v24 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (cf) {
      CFRelease(cf);
    }
    uint64_t v25 = 4294954433;
  }
  else
  {
LABEL_23:
    uint64_t v25 = 0;
  }
  if (!(v198 | IsItemReadyToStart)) {
    goto LABEL_329;
  }
  unint64_t v188 = a6;
  Float64 v189 = a5;
  int v190 = v18;
  if (!(*(unsigned __int8 *)(v15 + 464) | v196))
  {
    if (*(unsigned char *)(v15 + 553) == 1)
    {
      uint64_t v26 = v25;
      lhs.unsigned int value = 0;
      uint64_t v27 = *(void *)(v15 + 936);
      uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
      FigBytePumpGetFigBaseObject(v27);
      uint64_t v30 = v29;
      uint64_t v31 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v31) {
        uint64_t v32 = v31;
      }
      else {
        uint64_t v32 = 0;
      }
      char v33 = *(void (**)(uint64_t, __CFString *, uint64_t, CMTime *))(v32 + 48);
      uint64_t v25 = v26;
      if (v33) {
        v33(v30, @"FBP_PrebufferReservation", AllocatorForMedia, &lhs);
      }
      if (lhs.value) {
        CFRelease((CFTypeRef)lhs.value);
      }
    }
    unsigned int v185 = v25;
    if (dword_1E9350BB0)
    {
      LODWORD(v205.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(v203.CFDictionarySetValue(theDict, key, value) = 0;
      CMTimeFlags v34 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int value = v205.value;
      if (os_log_type_enabled(v34, v203.value)) {
        unsigned int v36 = value;
      }
      else {
        unsigned int v36 = value & 0xFFFFFFFE;
      }
      if (v36)
      {
        if (a1) {
          CMTime v37 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          CMTime v37 = "";
        }
        CMTime v38 = a1;
        if (a2) {
          CMTime v39 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else {
          CMTime v39 = "";
        }
        CMTime lhs = *a3;
        Float64 Seconds = CMTimeGetSeconds(&lhs);
        LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316930;
        *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_CheckIfLikelyToKeepUpAndNotify";
        LOWORD(time2.flags) = 2048;
        *(void *)((char *)&time2.flags + 2) = v38;
        HIWORD(time2.epoch) = 2082;
        uint64_t v209 = v37;
        __int16 v210 = 2048;
        CFArrayRef v211 = a2;
        __int16 v212 = 2082;
        uint64_t v213 = v39;
        a1 = v38;
        __int16 v214 = 2048;
        double v215 = Seconds;
        __int16 v216 = 1024;
        int v217 = v198;
        __int16 v218 = 1024;
        int v219 = IsItemReadyToStart;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      uint64_t v25 = v185;
      int v18 = v190;
    }
    fpfs_UpdateDimensions(a2, 1);
    uint64_t v41 = CMBaseObjectGetDerivedStorage();
    if (!*(unsigned char *)(v41 + 464))
    {
      uint64_t v48 = v41;
      int v49 = *(unsigned __int8 *)(v41 + 468);
      if (!*(unsigned char *)(v41 + 468) && *MEMORY[0x1E4F1EBA8] == 1)
      {
        if (a2) {
          CMTimeEpoch v50 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else {
          CMTimeEpoch v50 = "";
        }
        strncpy((char *)&lhs, v50, 8uLL);
        kdebug_trace();
      }
      *(unsigned char *)(v48 + 464) = 1;
      *(unsigned char *)(v48 + 468) = 1;
      NotificationPayloadForProperties = fpfs_CreateNotificationPayloadForProperties(a1, (uint64_t)a2, v42, v43, v44, v45, v46, v47, @"CanPlayFastForward", @"CanPlayFastReverse");
      fpfs_EnqueueNotification(a1, @"ReadyForPlayback", a2, NotificationPayloadForProperties);
      fpfs_enqueuePrerollDidCompleteNotificationIfNeeded();
      if (*(double *)(v48 + 2064) == 0.0)
      {
        double Current = CFAbsoluteTimeGetCurrent();
        *(double *)(v48 + 2064) = Current;
        double v55 = *(double *)(v48 + 2032);
        double v56 = *(double *)(v48 + 2048);
        uint64_t v57 = *(void *)(v48 + 2544);
        if (v57)
        {
          double v58 = *(double *)(v48 + 2040);
          uint64_t v59 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v60 = v59 ? v59 : 0;
          uint64_t v61 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v60 + 56);
          if (v61) {
            v61(v57, 0x1EE582B78, 0x1EE583B98, (uint64_t)((v58 - v55) * 1000.0), 0);
          }
        }
        uint64_t v62 = *(void *)(v48 + 2544);
        if (v62)
        {
          uint64_t v63 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v63) {
            uint64_t v64 = v63;
          }
          else {
            uint64_t v64 = 0;
          }
          int v65 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v64 + 56);
          if (v65) {
            v65(v62, 0x1EE582B78, 0x1EE583BB8, (uint64_t)((v56 - v55) * 1000.0), 0);
          }
          uint64_t v66 = *(void *)(v48 + 2544);
          if (v66)
          {
            uint64_t v67 = *(void *)(CMBaseObjectGetVTable() + 16);
            uint64_t v68 = v67 ? v67 : 0;
            uint64_t v69 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v68 + 56);
            if (v69) {
              v69(v66, 0x1EE582B78, 0x1EE583BD8, (uint64_t)((Current - v55) * 1000.0), 0);
            }
          }
        }
      }
      if (!v49)
      {
        fpfsi_networkActivitySubmitMetricsForInitialStartupIfAvailable();
        if (*(void *)(v48 + 2072))
        {
          if (!*(unsigned char *)(v48 + 2081))
          {
            uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
            uint64_t v71 = *(void *)(v48 + 2544);
            if (v71)
            {
              uint64_t v72 = *(void *)(v48 + 2072);
              uint64_t v73 = *(void *)(CMBaseObjectGetVTable() + 16);
              uint64_t v74 = v73 ? v73 : 0;
              uint64_t v170 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, void))(v74 + 56);
              if (v170) {
                v170(v71, 0x1EE582CD8, 0x1EE585C58, (UpTimeNanoseconds - v72) / 0xF4240uLL, 0);
              }
            }
          }
        }
      }
      if (*(unsigned char *)(v48 + 2082))
      {
        uint64_t v25 = v185;
        if (*(unsigned char *)(v48 + 2084))
        {
          *(unsigned char *)(v48 + 2084) = 0;
          double v70 = CFAbsoluteTimeGetCurrent() - *(double *)(v48 + 1976);
          *(double *)(v48 + 2000) = v70;
        }
        else
        {
          if (*(double *)(v48 + 2016) <= 0.0)
          {
LABEL_102:
            int v18 = v190;
            if (NotificationPayloadForProperties) {
              CFRelease(NotificationPayloadForProperties);
            }
            goto LABEL_104;
          }
          double v70 = CFAbsoluteTimeGetCurrent() - *(double *)(v48 + 2016);
        }
      }
      else
      {
        *(unsigned char *)(v48 + 2082) = 1;
        double v70 = CFAbsoluteTimeGetCurrent() - *(double *)(v48 + 1984);
        *(double *)(v48 + 1992) = v70;
        uint64_t v25 = v185;
      }
      uint64_t v75 = *(void *)(v48 + 2544);
      if (v75)
      {
        uint64_t v76 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v77 = v76 ? v76 : 0;
        uint64_t v78 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v77 + 56);
        if (v78) {
          v78(v75, 0x1EE582B78, 0x1EE583B78, (uint64_t)(v70 * 1000.0), 0);
        }
      }
      goto LABEL_102;
    }
  }
LABEL_104:
  int v79 = (IsItemReadyToStart == 0) & ~v18;
  if (v79 || *(_DWORD *)(v15 + 524) == 1) {
    goto LABEL_144;
  }
  if (*MEMORY[0x1E4F1EBA8] == 1)
  {
    if (a2) {
      uint64_t v80 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
    }
    else {
      uint64_t v80 = "";
    }
    strncpy((char *)&lhs, v80, 8uLL);
    kdebug_trace();
  }
  fpfs_setPlaythroughPredictionAndNotify(a2, 1);
  uint64_t v81 = CMBaseObjectGetDerivedStorage();
  time2.unsigned int value = 0;
  v205.unsigned int value = 0;
  uint64_t RenderingTrackofType = fpfs_FirstRenderingTrackofType((uint64_t)a2, 1986618469);
  if (RenderingTrackofType || (uint64_t RenderingTrackofType = fpfs_FirstRenderingTrackofType((uint64_t)a2, 1936684398)) != 0) {
    uint64_t v83 = *(const void **)(RenderingTrackofType + 440);
  }
  else {
    uint64_t v83 = 0;
  }
  if (!fpfsi_copyPlayableTime((uint64_t)a2, (CFTypeRef *)&v205))
  {
    if (*(double *)(v81 + 2024) > 0.0)
    {
      double v84 = CFAbsoluteTimeGetCurrent();
      double v85 = *(double *)(v81 + 2024);
LABEL_120:
      double v86 = v84 - v85;
      CFAllocatorRef v87 = (const __CFAllocator *)FigGetAllocatorForMedia();
      *(_OWORD *)&lhs.unsigned int value = v192;
      lhs.CMTimeEpoch epoch = v191;
      if (FigMetricItemLikelyToKeepUpEventCreate(v87, (long long *)&lhs.value, 0, 0, v83, (const void *)v205.value, &time2, v86))goto LABEL_128; {
LABEL_123:
      }
      uint64_t v90 = *(void *)(v81 + 3376);
      CMTimeValue v91 = time2.value;
      uint64_t v92 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v92) {
        uint64_t v93 = v92;
      }
      else {
        uint64_t v93 = 0;
      }
      CFTypeRef v94 = *(void (**)(uint64_t, const __CFArray *, CMTimeValue))(v93 + 40);
      if (v94) {
        v94(v90, a2, v91);
      }
      goto LABEL_128;
    }
    if (*(unsigned char *)(v81 + 2081))
    {
      if (*(double *)(v81 + 2016) <= 0.0) {
        goto LABEL_123;
      }
      double v84 = CFAbsoluteTimeGetCurrent();
      double v85 = *(double *)(v81 + 2016);
      goto LABEL_120;
    }
    double v88 = CFAbsoluteTimeGetCurrent() - *(double *)(v81 + 1984);
    CFAllocatorRef v89 = (const __CFAllocator *)FigGetAllocatorForMedia();
    *(_OWORD *)&lhs.unsigned int value = v192;
    lhs.CMTimeEpoch epoch = v191;
    if (!FigMetricItemInternalInitialLikelyToKeepUpEventCreate(v89, (long long *)&lhs.value, 0, 0, v83, (const void *)v205.value, &time2, v88))goto LABEL_123; {
  }
    }
LABEL_128:
  if (v205.value) {
    CFRelease((CFTypeRef)v205.value);
  }
  if (time2.value) {
    CFRelease((CFTypeRef)time2.value);
  }
  if (*(unsigned char *)(v15 + 2081))
  {
    if (*(unsigned char *)(v15 + 2083))
    {
      double v95 = CFAbsoluteTimeGetCurrent() - *(double *)(v15 + 1976);
      *(unsigned char *)(v15 + 2083) = 0;
    }
    else
    {
      if (*(double *)(v15 + 2016) <= 0.0) {
        goto LABEL_144;
      }
      double v95 = CFAbsoluteTimeGetCurrent() - *(double *)(v15 + 2016);
    }
  }
  else
  {
    *(unsigned char *)(v15 + 2081) = 1;
    double v95 = CFAbsoluteTimeGetCurrent() - *(double *)(v15 + 1984);
    *(double *)(v15 + 1968) = v95;
  }
  uint64_t v96 = *(void *)(v15 + 2544);
  if (v96)
  {
    uint64_t v97 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v98 = v97 ? v97 : 0;
    unsigned int v99 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v98 + 56);
    if (v99) {
      v99(v96, 0x1EE582B78, 0x1EE583B58, (uint64_t)(v95 * 1000.0), 0);
    }
  }
LABEL_144:
  fpfsi_performCurrentResourceConservationAction(a2, *(_DWORD *)(DerivedStorage + 764));
  *(void *)(v15 + 2016) = 0;
  if (fpfs_getNext(DerivedStorage, 0) != a2) {
    goto LABEL_328;
  }
  int v193 = v79;
  if (v195 == 1) {
    char v100 = 1;
  }
  else {
    char v100 = v79;
  }
  if ((v100 & 1) == 0)
  {
    CMTime lhs = *a3;
    double v101 = CMTimeGetSeconds(&lhs);
    uint64_t v102 = CMBaseObjectGetDerivedStorage();
    uint64_t v103 = CMBaseObjectGetDerivedStorage();
    fpfsi_RTCReportingUpdateCurrentAlternateInfo();
    fpfsi_RTCReportingUpdateBufferDuration(v102, v194, v101);
    uint64_t v104 = *(void *)(v102 + 2544);
    if (v104)
    {
      uint64_t v105 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v105) {
        uint64_t v106 = v105;
      }
      else {
        uint64_t v106 = 0;
      }
      uint64_t v107 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v106 + 8);
      if (v107) {
        v107(v104, 0x1EE582B78, 105, 0, 0);
      }
      uint64_t v108 = *(void *)(v102 + 2544);
      if (v108)
      {
        uint64_t v109 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v109) {
          uint64_t v110 = v109;
        }
        else {
          uint64_t v110 = 0;
        }
        Float64 v111 = *(void (**)(uint64_t, uint64_t, uint64_t))(v110 + 64);
        if (v111) {
          v111(v108, 0x1EE582B78, 0x1EE584D98);
        }
        uint64_t v112 = *(void *)(v102 + 2544);
        if (v112)
        {
          uint64_t v113 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v113) {
            uint64_t v114 = v113;
          }
          else {
            uint64_t v114 = 0;
          }
          CMTimeEpoch v115 = *(void (**)(uint64_t, uint64_t, uint64_t))(v114 + 64);
          if (v115) {
            v115(v112, 0x1EE582B78, 0x1EE584D58);
          }
          uint64_t v116 = *(void *)(v102 + 2544);
          if (v116)
          {
            uint64_t v117 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v117) {
              uint64_t v118 = v117;
            }
            else {
              uint64_t v118 = 0;
            }
            CMTime v119 = *(void (**)(uint64_t, uint64_t, uint64_t))(v118 + 64);
            if (v119) {
              v119(v116, 0x1EE582B78, 0x1EE584DB8);
            }
            uint64_t v120 = *(void *)(v102 + 2544);
            if (v120)
            {
              uint64_t v121 = *(void *)(CMBaseObjectGetVTable() + 16);
              uint64_t v122 = v121 ? v121 : 0;
              unsigned int v123 = *(void (**)(uint64_t, uint64_t, uint64_t))(v122 + 64);
              if (v123) {
                v123(v120, 0x1EE582B78, 0x1EE584D78);
              }
            }
          }
        }
      }
    }
    uint64_t v124 = *(void *)(v102 + 1704);
    if (v124) {
      BOOL v125 = FigAlternateIsIFrameOnly(v124) != 0;
    }
    else {
      BOOL v125 = 0;
    }
    if (!*(unsigned char *)(v102 + 2592) && !v125)
    {
      *(unsigned char *)(v102 + 2592) = 1;
      double v126 = CFAbsoluteTimeGetCurrent();
      double v127 = *(double *)(v102 + 2984);
      double v128 = CFAbsoluteTimeGetCurrent();
      double v129 = *(double *)(v102 + 2032);
      *(CFAbsoluteTime *)(v102 + 2992) = CFAbsoluteTimeGetCurrent();
      uint64_t v130 = *(void *)(v102 + 2544);
      if (v130)
      {
        uint64_t v131 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v131) {
          uint64_t v132 = v131;
        }
        else {
          uint64_t v132 = 0;
        }
        __int16 v133 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v132 + 56);
        if (v133) {
          v133(v130, 0x1EE582B78, 0x1EE55E6F8, (uint64_t)((v126 - v127) * 1000.0), 0);
        }
        uint64_t v134 = *(void *)(v102 + 2544);
        if (v134)
        {
          uint64_t v135 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v136 = v135 ? v135 : 0;
          CMTime v137 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v136 + 56);
          if (v137) {
            v137(v134, 0x1EE582B78, 0x1EE584B78, (uint64_t)((v128 - v129) * 1000.0), 0);
          }
        }
      }
      fpfsi_networkActivitySubmitMetricsForInitialStartupIfAvailable();
      fpfsi_RTCReportingReportDesiredRateChange(*(float *)(v103 + 108));
    }
  }
  if (*(float *)(DerivedStorage + 108) == 0.0)
  {
    if (v195 != 1)
    {
      if (dword_1E9350BB0)
      {
        unsigned int v187 = v25;
        LODWORD(v205.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(v203.CFDictionarySetValue(theDict, key, value) = 0;
        CFAllocatorRef v150 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v151 = v205.value;
        if (os_log_type_enabled(v150, v203.value)) {
          unsigned int v152 = v151;
        }
        else {
          unsigned int v152 = v151 & 0xFFFFFFFE;
        }
        if (v152)
        {
          if (a1) {
            uint64_t v153 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
          }
          else {
            uint64_t v153 = "";
          }
          if (a2) {
            uint64_t v165 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
          }
          else {
            uint64_t v165 = "";
          }
          LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316162;
          *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_CheckIfLikelyToKeepUpAndNotify";
          LOWORD(time2.flags) = 2048;
          *(void *)((char *)&time2.flags + 2) = a1;
          HIWORD(time2.epoch) = 2082;
          uint64_t v209 = v153;
          __int16 v210 = 2048;
          CFArrayRef v211 = a2;
          __int16 v212 = 2082;
          uint64_t v213 = v165;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        uint64_t v25 = v187;
      }
      if (fpfs_shouldReleaseRenderChainForPausing((uint64_t)a2)) {
        fpfsi_ReleaseRenderChainsForPausing(*(const void **)(DerivedStorage + 80));
      }
    }
    goto LABEL_327;
  }
  if (*(float *)(v15 + 848) != 0.0)
  {
LABEL_327:
    int v79 = v193;
    goto LABEL_328;
  }
  unsigned int v186 = v25;
  int IsDisplayModeSwitchInProgress = FPSupport_IsDisplayModeSwitchInProgress();
  fpfs_GetNextTimeToPlay(v15, 0, (uint64_t)&v199);
  BOOL v139 = fpfsi_atOrAfterTimeToPausePlayback(v15, &v199);
  if (IsDisplayModeSwitchInProgress) {
    BOOL v140 = v198 == 0;
  }
  else {
    BOOL v140 = 0;
  }
  if (v140 || v139 || v196)
  {
    if (IsDisplayModeSwitchInProgress)
    {
      if (dword_1E9350BB0)
      {
        uint64_t v154 = a1;
        LODWORD(v205.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(v203.CFDictionarySetValue(theDict, key, value) = 0;
        uint64_t v155 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v156 = v205.value;
        if (os_log_type_enabled(v155, v203.value)) {
          unsigned int v157 = v156;
        }
        else {
          unsigned int v157 = v156 & 0xFFFFFFFE;
        }
        if (!v157) {
          goto LABEL_325;
        }
        if (a1) {
          BOOL v158 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          BOOL v158 = "";
        }
        if (!a2)
        {
          CMTime v169 = "";
LABEL_324:
          double v181 = *(float *)(DerivedStorage + 108);
          LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316418;
          *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_CheckIfLikelyToKeepUpAndNotify";
          LOWORD(time2.flags) = 2048;
          *(void *)((char *)&time2.flags + 2) = v154;
          HIWORD(time2.epoch) = 2082;
          uint64_t v209 = v158;
          __int16 v210 = 2048;
          CFArrayRef v211 = a2;
          __int16 v212 = 2082;
          uint64_t v213 = v169;
          __int16 v214 = 2048;
          double v215 = v181;
          _os_log_send_and_compose_impl();
LABEL_325:
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          a1 = v154;
          goto LABEL_326;
        }
LABEL_322:
        CMTime v169 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        goto LABEL_324;
      }
    }
    else
    {
      if (!v139)
      {
        if (!v196 || !dword_1E9350BB0) {
          goto LABEL_326;
        }
        uint64_t v154 = a1;
        LODWORD(v205.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(v203.CFDictionarySetValue(theDict, key, value) = 0;
        CFTypeRef v166 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v167 = v205.value;
        if (os_log_type_enabled(v166, v203.value)) {
          unsigned int v168 = v167;
        }
        else {
          unsigned int v168 = v167 & 0xFFFFFFFE;
        }
        if (!v168) {
          goto LABEL_325;
        }
        if (a1) {
          BOOL v158 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          BOOL v158 = "";
        }
        if (!a2)
        {
          CMTime v169 = "";
          goto LABEL_324;
        }
        goto LABEL_322;
      }
      if (dword_1E9350BB0)
      {
        uint64_t v154 = a1;
        LODWORD(v205.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(v203.CFDictionarySetValue(theDict, key, value) = 0;
        long long v162 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v163 = v205.value;
        if (os_log_type_enabled(v162, v203.value)) {
          unsigned int v164 = v163;
        }
        else {
          unsigned int v164 = v163 & 0xFFFFFFFE;
        }
        if (!v164) {
          goto LABEL_325;
        }
        if (a1) {
          BOOL v158 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          BOOL v158 = "";
        }
        if (!a2)
        {
          CMTime v169 = "";
          goto LABEL_324;
        }
        goto LABEL_322;
      }
    }
LABEL_326:
    uint64_t v25 = v186;
    goto LABEL_327;
  }
  if (!*(unsigned char *)(DerivedStorage + 168) && *(unsigned char *)(v15 + 464)) {
    fpfs_notifyExternalStartupTasksOfEvents((uint64_t)a1, 4, 0, 0, MEMORY[0x1E4F1F9F8]);
  }
  uint64_t v141 = v188;
  CFArrayRef v142 = v189;
  if (!fpfs_areAllExternalStartupTasksCompleted())
  {
    if (dword_1E9350BB0)
    {
      uint64_t v154 = a1;
      LODWORD(v205.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(v203.CFDictionarySetValue(theDict, key, value) = 0;
      Float64 v159 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v160 = v205.value;
      if (os_log_type_enabled(v159, v203.value)) {
        unsigned int v161 = v160;
      }
      else {
        unsigned int v161 = v160 & 0xFFFFFFFE;
      }
      if (!v161) {
        goto LABEL_325;
      }
      if (a1) {
        BOOL v158 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      }
      else {
        BOOL v158 = "";
      }
      if (!a2)
      {
        CMTime v169 = "";
        goto LABEL_324;
      }
      goto LABEL_322;
    }
    goto LABEL_326;
  }
  if (!fpfs_audioOnlyValidAlternateList(v15))
  {
    float v143 = *(float *)(DerivedStorage + 108);
    BOOL v144 = v143 <= 2.0;
    if (v143 < 0.0) {
      BOOL v144 = 0;
    }
    if (((v144 | v190) & 1) == 0 && !*(void *)(v15 + 2968)) {
      fpfs_EnterBestEffortTrickplayMode((uint64_t)a1, (const __CFString *)a2, v143);
    }
  }
  uint64_t v25 = v186;
  int v79 = v193;
  if (!*(void *)(v15 + 2968))
  {
    uint64_t v145 = fpfs_FirstRenderingTrackofType((uint64_t)a2, 1986618469);
    if (!v145 || !*(unsigned char *)(v145 + 104))
    {
      if (dword_1E9350BB0)
      {
        LODWORD(v205.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(v203.CFDictionarySetValue(theDict, key, value) = 0;
        unsigned int v146 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v147 = v205.value;
        if (os_log_type_enabled(v146, v203.value)) {
          unsigned int v148 = v147;
        }
        else {
          unsigned int v148 = v147 & 0xFFFFFFFE;
        }
        if (v148)
        {
          if (a1) {
            uint64_t v149 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
          }
          else {
            uint64_t v149 = "";
          }
          if (a2) {
            __int16 v171 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
          }
          else {
            __int16 v171 = "";
          }
          double v172 = *(float *)(DerivedStorage + 108);
          LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316418;
          *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_CheckIfLikelyToKeepUpAndNotify";
          LOWORD(time2.flags) = 2048;
          *(void *)((char *)&time2.flags + 2) = a1;
          HIWORD(time2.epoch) = 2082;
          uint64_t v209 = v149;
          __int16 v210 = 2048;
          CFArrayRef v211 = a2;
          __int16 v212 = 2082;
          uint64_t v213 = v171;
          __int16 v214 = 2048;
          double v215 = v172;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        uint64_t v141 = v188;
        CFArrayRef v142 = v189;
      }
      float v173 = *(float *)(DerivedStorage + 108);
      CMTime lhs = *v142;
      CMTime time2 = *v141;
      uint64_t v174 = fpfs_SetRateWithFadeInternal(a1, MEMORY[0x1E4F1F9F8], &lhs, (long long *)&time2.value, v173);
      if (v174)
      {
        uint64_t v175 = v174;
        LODWORD(v205.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(v203.CFDictionarySetValue(theDict, key, value) = 0;
        int32_t v176 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v177 = v205.value;
        if (os_log_type_enabled(v176, v203.value)) {
          unsigned int v178 = v177;
        }
        else {
          unsigned int v178 = v177 & 0xFFFFFFFE;
        }
        if (v178)
        {
          if (a1) {
            uint64_t v179 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
          }
          else {
            uint64_t v179 = "";
          }
          if (a2) {
            int v180 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
          }
          else {
            int v180 = "";
          }
          LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316418;
          *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_CheckIfLikelyToKeepUpAndNotify";
          LOWORD(time2.flags) = 2048;
          *(void *)((char *)&time2.flags + 2) = a1;
          HIWORD(time2.epoch) = 2082;
          uint64_t v209 = v179;
          __int16 v210 = 2048;
          CFArrayRef v211 = a2;
          __int16 v212 = 2082;
          uint64_t v213 = v180;
          __int16 v214 = 1024;
          LODWORD(v215) = v175;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        uint64_t v25 = v175;
        goto LABEL_327;
      }
      if (*(_DWORD *)(DerivedStorage + 808) == 1)
      {
        uint64_t v25 = 0;
        goto LABEL_327;
      }
      int v79 = v193;
      if (*(float *)(DerivedStorage + 108) == 1.0)
      {
        fpfs_ReportVideoPlaybackTimeThroughFigLog((uint64_t)a2);
        fpfs_ReportAudioPlaybackThroughFigLog((uint64_t)a2);
      }
      uint64_t v25 = 0;
    }
  }
LABEL_328:
  if (!v79)
  {
    int v182 = *(_DWORD *)(v15 + 524);
    goto LABEL_332;
  }
LABEL_329:
  int v182 = *(_DWORD *)(v15 + 524);
  if (!v182)
  {
    fpfs_setPlaythroughPredictionAndNotify(a2, 2);
    goto LABEL_334;
  }
LABEL_332:
  if (v182 == 1) {
    fpfsi_setPlaybackMonitorOkayToAttemptSwitchUp(v15, v206);
  }
LABEL_334:
  CFRelease(a1);
  return v25;
}

BOOL fpfsi_atOrAfterTimeToPausePlayback(uint64_t a1, CMTime *a2)
{
  if ((*(unsigned char *)(a1 + 1460) & 1) == 0) {
    return 0;
  }
  CMTime time1 = *a2;
  CMTime v3 = *(CMTime *)(a1 + 1448);
  return CMTimeCompare(&time1, &v3) >= 0;
}

double fpfsi_PrepareToStartWhenLikelyToKeepUp(uint64_t a1, CMTime *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  LODWORD(result) = *(_DWORD *)(CMBaseObjectGetDerivedStorage() + 108);
  if (*(float *)&result != 0.0)
  {
    LODWORD(result) = *(_DWORD *)(DerivedStorage + 848);
    if (*(float *)&result == 0.0)
    {
      if (*(unsigned char *)(DerivedStorage + 465))
      {
        *(_OWORD *)&v13.unsigned int value = *MEMORY[0x1E4F1F9F8];
        CMTimeEpoch v6 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
        v13.CMTimeEpoch epoch = v6;
        long long v8 = *(_OWORD *)&v13.value;
        *(_OWORD *)&v14.unsigned int value = *(_OWORD *)&v13.value;
        v14.CMTimeEpoch epoch = v6;
        uint64_t v7 = (CMTime *)MEMORY[0x1E4F1FA48];
        fpfs_CheckCanKeepUp(a1, MEMORY[0x1E4F1FA48], MEMORY[0x1E4F1F9F8], *(unsigned int *)(DerivedStorage + 1096), 0, 0, (uint64_t)&v13, 0);
        if ((v13.flags & 1) != 0 && (v14.flags & 1) != 0 && !v14.epoch && (v14.value & 0x8000000000000000) == 0)
        {
          *(_OWORD *)&v12.unsigned int value = v8;
          v12.CMTimeEpoch epoch = v6;
          if ((~a2->flags & 5) != 0)
          {
            CMTime lhs = v13;
            CMTime rhs = v14;
            CMTimeAdd(&v11, &lhs, &rhs);
            CMTime lhs = *a2;
            CMTimeSubtract(&v12, &v11, &lhs);
          }
          else
          {
            CMTime v12 = *v7;
          }
          *(void *)(DerivedStorage + 424) = v12.epoch;
          double result = *(double *)&v12.value;
          *(_OWORD *)(DerivedStorage + 408) = *(_OWORD *)&v12.value;
        }
      }
    }
  }
  return result;
}

__CFDictionary *fpfs_CreateNotificationPayloadForProperties(const void *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, void *value, uint64_t a10)
{
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E4F1D510]);
  int v18 = (const void **)&a10;
  CMTime v14 = value;
  if (value)
  {
    do
    {
      CFArrayAppendValue(Mutable, v14);
      uint64_t v15 = v18++;
      CMTime v14 = *v15;
    }
    while (*v15);
  }
  if (!a1 && a2) {
    a1 = *(const void **)CMBaseObjectGetDerivedStorage();
  }
  if (!a1)
  {
    NotificationPayloadForProperties = 0;
    if (!Mutable) {
      return NotificationPayloadForProperties;
    }
    goto LABEL_8;
  }
  fpfs_LockMutexWithCaller(a1);
  NotificationPayloadForProperties = FPSupport_CreateNotificationPayloadForProperties((uint64_t)a1, a2, Mutable);
  fpfs_UnlockAndPostNotificationsWithCaller(a1);
  if (Mutable) {
LABEL_8:
  }
    CFRelease(Mutable);
  return NotificationPayloadForProperties;
}

uint64_t fpfs_ReleasePlayerHDRPlaybackBaton()
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  CFArrayRef v1 = *(const void **)(result + 792);
  if (v1)
  {
    uint64_t v2 = result;
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      CFArrayRef v1 = *(const void **)(v2 + 792);
    }
    uint64_t result = FPSupport_ReleaseHDRVideoDisplayAssertion(*(const void **)(v2 + 856), v1);
    *(void *)(v2 + 792) = 0;
  }
  return result;
}

uint64_t fpfs_ReleasePlayer4kPlaybackBaton(const void *a1)
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  CMTime v3 = *(const void **)(result + 800);
  if (v3)
  {
    uint64_t v4 = result;
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      CMTime v3 = *(const void **)(v4 + 800);
    }
    uint64_t result = FPSupport_Release4kVideoDisplayAssertion(a1, v3);
    *(void *)(v4 + 800) = 0;
  }
  return result;
}

void fpfsi_performCurrentResourceConservationAction(const void *a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = v5;
  int v7 = *(_DWORD *)(v5 + 764);
  if (v7 >= a2)
  {
    if (v7 >= 1 && *(float *)(v5 + 108) == 0.0)
    {
      uint64_t v8 = *(void *)(DerivedStorage + 1704);
      if (!v8 || !FigAlternateIsIFrameOnly(v8))
      {
        if (dword_1E9350BB0)
        {
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        if (*(int *)(v6 + 764) >= 1 && *(unsigned char *)(DerivedStorage + 464)) {
          fpfs_FlowControlPump(DerivedStorage, 0xFFu, 1, 0);
        }
        if (fpfs_shouldReleaseRenderChainForPausing((uint64_t)a1) && *(unsigned char *)(DerivedStorage + 464)) {
          fpfsi_ReleaseRenderChainsForPausing(a1);
        }
        if (*(int *)(v6 + 764) >= 3) {
          fpfs_PrepareForSeek((const __CFArray *)a1, 0xFFu, 1);
        }
      }
    }
  }
  else if (a2 >= 3 && v7 <= 2 && *(float *)(v5 + 108) == 0.0)
  {
    fpfsi_SeekToCurrentTime(a1);
  }
}

void fpfs_ReportVideoPlaybackTimeThroughFigLog(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t RenderingNonGapTrackofType = fpfs_FirstRenderingNonGapTrackofType(a1, 1986618469);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (RenderingNonGapTrackofType)
  {
    if (*(void *)(RenderingNonGapTrackofType + 440))
    {
      if (!*(unsigned char *)(RenderingNonGapTrackofType + 184) && !*(unsigned char *)(RenderingNonGapTrackofType + 456))
      {
        memset(&v5, 0, sizeof(v5));
        fpfs_GetTime(DerivedStorage, (uint64_t)&v5);
        CMTime time1 = *(CMTime *)(RenderingNonGapTrackofType + 216);
        CMTime time2 = v5;
        if (CMTimeCompare(&time1, &time2) >= 1)
        {
          DescriptionCFStringRef String = (const void *)FigAlternateCreateDescriptionString(*(void *)(RenderingNonGapTrackofType
                                                                                          + 440));
          if (dword_1E9350BB0)
          {
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          if (DescriptionString) {
            CFRelease(DescriptionString);
          }
        }
      }
    }
  }
}

void fpfs_ReportAudioPlaybackThroughFigLog(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFArrayRef theArray = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMBaseObjectGetDerivedStorage();
  uint64_t RenderingNonGapTrackofType = fpfs_FirstRenderingNonGapTrackofType(a1, 1936684398);
  if (RenderingNonGapTrackofType)
  {
    uint64_t v4 = RenderingNonGapTrackofType;
    CMTime v5 = *(const opaqueCMFormatDescription **)(RenderingNonGapTrackofType + 40);
    uint64_t v14 = 0;
    fpfsi_GetSpatializationConfiguration(a1);
    CMAudioFormatDescriptionGetStreamBasicDescription(v5);
    CFDictionaryRef CurrentAudioPersistentIDFromMediaOption = fpfsi_GetCurrentAudioPersistentIDFromMediaOption();
    int ImmersiveAudioCapability = FigAlternateGetImmersiveAudioCapability(*(const void **)(v4 + 440), CurrentAudioPersistentIDFromMediaOption);
    FPSupport_GetAudioFormatDescriptionSpatializationEligibility((uint64_t)v5, &v14);
    if (*(unsigned char *)(DerivedStorage + 779)) {
      int v8 = 1836019574;
    }
    else {
      int v8 = 1936684398;
    }
    fpfsi_CreateAudioSpatialSourcesArray(a1, v8, &theArray, 0, 0);
    int v9 = 0;
    for (CFIndex i = 0; ; ++i)
    {
      CFIndex Count = (CFIndex)theArray;
      if (theArray) {
        CFIndex Count = CFArrayGetCount(theArray);
      }
      if (i >= Count) {
        break;
      }
      int v16 = 1064530531;
      FigCFArrayGetInt32AtIndex();
      if (v16 == 1836020596) {
        int v12 = 1;
      }
      else {
        int v12 = v9;
      }
      if (v16 != 1835824233) {
        int v9 = v12;
      }
    }
    if (ImmersiveAudioCapability != 1) {
      FigAlternateGetStringFromImmersiveAudioCapability(ImmersiveAudioCapability);
    }
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (theArray) {
      CFRelease(theArray);
    }
  }
}

void fpfs_PostNotificationWhenUnlocked(const void *a1, const void *a2, const void *a3, const void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v9 = CMBaseObjectGetDerivedStorage();
  if (FigReentrantMutexTryLock())
  {
    uint64_t v10 = *(void *)(v9 + 8);
    *(void *)(v9 + 8) = v10 + 1;
    if (!v10) {
      fpfs_getPlaybackState(a1, v9 + 164, v9 + 168);
    }
    fpfs_EnqueueNotification(a1, a2, a3, a4);
    fpfs_UnlockAndPostNotificationsWithCaller(a1);
  }
  else
  {
    CMTime v11 = malloc_type_malloc(0x28uLL, 0xE0040CDB25F8DuLL);
    if (v11)
    {
      int v12 = v11;
      *CMTime v11 = a2;
      if (a3) {
        CFTypeRef v13 = CFRetain(a3);
      }
      else {
        CFTypeRef v13 = 0;
      }
      v12[1] = v13;
      if (a4) {
        CFTypeRef v14 = CFRetain(a4);
      }
      else {
        CFTypeRef v14 = 0;
      }
      _OWORD v12[2] = v14;
      uint64_t v15 = *(NSObject **)(DerivedStorage + 24);
      dispatch_async_f(v15, v12, (dispatch_function_t)fpfs_PostNotificationFromDispatch);
    }
  }
}

const AudioFormatListItem *fpfs_UnmuteNextAtmosAudioTrack(const AudioFormatListItem *result, uint64_t a2, uint64_t a3)
{
  CMTime v3 = (uint64_t *)(a3 + 8);
  if (!a3) {
    CMTime v3 = (uint64_t *)(a2 + 1048);
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    CMTime v5 = result;
    do
    {
      if (*(_DWORD *)(v4 + 32) != 1936684398) {
        goto LABEL_36;
      }
      uint64_t v6 = *(const opaqueCMFormatDescription **)(v4 + 40);
      uint64_t result = (const AudioFormatListItem *)CMFormatDescriptionGetMediaSubType(v6);
      if ((int)result <= 1885692722)
      {
        if ((int)result <= 1700997938)
        {
          if (result != 1667575091)
          {
            int v8 = 1667574579;
            goto LABEL_35;
          }
        }
        else if (result != 1700998451)
        {
          if (result == 1700997939) {
            goto LABEL_38;
          }
          int v8 = 1885547315;
LABEL_35:
          if (result == v8) {
            goto LABEL_38;
          }
          goto LABEL_36;
        }
      }
      else if ((int)result <= 1902469938)
      {
        if (result != 1885692723)
        {
          int v8 = 1902324531;
          goto LABEL_35;
        }
      }
      else if (result != 1902469939 && result != 2053464883)
      {
        int v8 = 2053319475;
        goto LABEL_35;
      }
      size_t sizeOut = 0;
      uint64_t result = CMAudioFormatDescriptionGetFormatList(v6, &sizeOut);
      if (result && sizeOut > 0x2F)
      {
        int mFormatID = result->mASBD.mFormatID;
        if (mFormatID <= 1885547314)
        {
          BOOL v10 = mFormatID == 1667574579;
          int v11 = 1700997939;
        }
        else
        {
          BOOL v10 = mFormatID == 1885547315 || mFormatID == 1902324531;
          int v11 = 2053319475;
        }
        if (v10 || mFormatID == v11)
        {
LABEL_38:
          *(unsigned char *)(v4 + 190) = 0;
          return (const AudioFormatListItem *)fpfs_applySoftwareVolumeToTrack(v4, 1, *(float *)&v5[2].mASBD.mFormatID, 0.0);
        }
      }
LABEL_36:
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4);
  }
  return result;
}

void fpfsi_ClampVideoToTime(const void *a1, CMTime *a2, long long *a3)
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMBufferQueueRef queueOut = 0;
  CMTime time1 = *(CMTime *)a3;
  CMTime time2 = *a2;
  uint64_t v60 = a2;
  if (CMTimeCompare(&time1, &time2))
  {
    CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    CallbacksForUnsortedSampleBuffers = CMBufferQueueGetCallbacksForUnsortedSampleBuffers();
    if (!CMBufferQueueCreate(AllocatorForMedia, 0, CallbacksForUnsortedSampleBuffers, &queueOut))
    {
      if (dword_1E9350BB0)
      {
        LODWORD(lhs.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int value = lhs.value;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type.value)) {
          unsigned int v9 = value;
        }
        else {
          unsigned int v9 = value & 0xFFFFFFFE;
        }
        if (v9)
        {
          uint64_t v10 = *(void *)DerivedStorage;
          if (*(void *)DerivedStorage) {
            int v11 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
          }
          else {
            int v11 = "";
          }
          if (a1) {
            int v12 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
          }
          else {
            int v12 = "";
          }
          CMTime time1 = *(CMTime *)(DerivedStorage + 1472);
          Float64 Seconds = CMTimeGetSeconds(&time1);
          CMTime time1 = *(CMTime *)a3;
          Float64 v14 = CMTimeGetSeconds(&time1);
          LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316674;
          *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfsi_ClampVideoToTime";
          LOWORD(time2.flags) = 2048;
          *(void *)((char *)&time2.flags + 2) = v10;
          HIWORD(time2.epoch) = 2082;
          double v85 = v11;
          __int16 v86 = 2048;
          CFAllocatorRef v87 = a1;
          __int16 v88 = 2082;
          CFAllocatorRef v89 = v12;
          __int16 v90 = 2048;
          Float64 v91 = Seconds;
          __int16 v92 = 2048;
          Float64 v93 = v14;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      uint64_t v59 = a1;
      long long v15 = *a3;
      *(void *)(DerivedStorage + 1488) = *((void *)a3 + 2);
      *(_OWORD *)(DerivedStorage + 1472) = v15;
      uint64_t v16 = *(void *)(DerivedStorage + 1048);
      if (v16)
      {
        CMTimeFlags v17 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
        CMTimeEpoch v18 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
        CMTimeEpoch v57 = v18;
        CMTimeFlags v58 = v17;
        do
        {
          if (*(_DWORD *)(v16 + 32) != 1986618469) {
            goto LABEL_21;
          }
          if (*(unsigned char *)(v16 + 184)) {
            goto LABEL_21;
          }
          uint64_t v19 = *(void *)(v16 + 96);
          if (!v19) {
            goto LABEL_21;
          }
          uint64_t v20 = v16;
          while (1)
          {
            uint64_t v20 = *(void *)(v20 + 8);
            if (!v20) {
              break;
            }
            if (*(void *)(v20 + 96) == v19) {
              goto LABEL_21;
            }
          }
          CMTimeValue v82 = *MEMORY[0x1E4F1F9F8];
          CMTimeScale v83 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
          CMSampleBufferRef refcon = 0;
          CMTimeValue v80 = v82;
          CMTimeScale timescale = v83;
          time2.unsigned int value = 0;
          uint64_t v21 = *(void *)(v19 + 32);
          uint64_t v22 = FigGetAllocatorForMedia();
          uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v21);
          uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v24) {
            uint64_t v25 = v24;
          }
          else {
            uint64_t v25 = 0;
          }
          uint64_t v26 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CMTime *))(v25 + 48);
          CMTimeEpoch epoch = v18;
          CMTimeFlags flags = v17;
          if (v26)
          {
            int v29 = v26(FigBaseObject, @"EndPresentationTimeForDecodedSamples", v22, &time2);
            uint64_t v30 = (const void *)time2.value;
            if (!v29)
            {
              CMTimeMakeFromDictionary(&time1, (CFDictionaryRef)time2.value);
              CMTimeValue v80 = time1.value;
              CMTimeFlags flags = time1.flags;
              CMTimeScale timescale = time1.timescale;
              CMTimeEpoch epoch = time1.epoch;
              uint64_t v30 = (const void *)time2.value;
              if (!time2.value) {
                goto LABEL_35;
              }
LABEL_34:
              CFRelease(v30);
              goto LABEL_35;
            }
            CMTimeEpoch epoch = v18;
            CMTimeFlags flags = v17;
            if (time2.value) {
              goto LABEL_34;
            }
          }
LABEL_35:
          uint64_t v31 = *(void *)(v16 + 96);
          *(unsigned char *)(v31 + 26) = 0;
          MEMORY[0x199709540](*(void *)(v31 + 40), fpfs_StealBuffer, queueOut);
          CMBufferQueueCallForEachBuffer(queueOut, (OSStatus (__cdecl *)(CMBufferRef, void *))fpfs_GetFirstNonMarkerSBuf, &refcon);
          if (refcon)
          {
            CMSampleBufferGetOutputDecodeTimeStamp(&time1, refcon);
            CMTimeValue v82 = time1.value;
            CMTimeFlags v17 = time1.flags;
            CMTimeScale v83 = time1.timescale;
            CMTimeEpoch v18 = time1.epoch;
          }
          if (queueOut)
          {
            CFRelease(queueOut);
            CMBufferQueueRef queueOut = 0;
          }
          if (flags)
          {
            time1.unsigned int value = v80;
            time1.CMTimeScale timescale = timescale;
            time1.CMTimeFlags flags = flags;
            time1.CMTimeEpoch epoch = epoch;
            CMTime time2 = *(CMTime *)a3;
            if (CMTimeCompare(&time1, &time2) >= 1)
            {
              fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&v66);
              CMTime time1 = *(CMTime *)(DerivedStorage + 1472);
              if ((CMTimeCompare(&v66, &time1) & 0x80000000) == 0) {
                fpfs_FlushPrimaryAndAuxRenderChains(*(void *)(v16 + 96), 1);
              }
            }
          }
          uint64_t v32 = *(void *)(DerivedStorage + 1048);
          if (v32)
          {
            while (1)
            {
              if (*(void *)(v32 + 96) != *(void *)(v16 + 96)) {
                goto LABEL_97;
              }
              fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&v65);
              CMTimeValue v78 = v82;
              CMTimeScale v79 = v83;
              *(_OWORD *)&v64.unsigned int value = *a3;
              v64.CMTimeEpoch epoch = *((void *)a3 + 2);
              CMTimeValue v33 = v60->value;
              CMBufferQueueRef queue = 0;
              CMTimeValue v76 = v33;
              CMTimeFlags v34 = v60->flags;
              CMTimeScale v77 = v60->timescale;
              CMTimeEpoch v63 = v60->epoch;
              uint64_t v35 = *(opaqueCMBufferQueue **)(v32 + 80);
              CMBufferQueueRef v74 = 0;
              memset(&time1, 0, sizeof(time1));
              CMTimeMake(&time2, 1, 1);
              CMTime lhs = v65;
              CMTimeAdd(&time1, &lhs, &time2);
              BOOL v36 = 0;
              if (v34)
              {
                lhs.unsigned int value = v76;
                lhs.CMTimeScale timescale = v77;
                lhs.CMTimeFlags flags = v34;
                lhs.CMTimeEpoch epoch = v63;
                CMTime type = time1;
                BOOL v36 = CMTimeCompare(&lhs, &type) < 1;
              }
              int v37 = (v17 & 1) == 0 || v36;
              if (v37 != 1) {
                goto LABEL_53;
              }
              CFAllocatorRef v38 = (const __CFAllocator *)FigGetAllocatorForMedia();
              CMTime v39 = CMBufferQueueGetCallbacksForUnsortedSampleBuffers();
              OSStatus v40 = CMBufferQueueCreate(v38, 0, v39, &v74);
              if (!v40) {
                break;
              }
LABEL_99:
              int v49 = v40;
LABEL_91:
              if (queue) {
                CFRelease(queue);
              }
              if (v74) {
                CFRelease(v74);
              }
              if (v49) {
                goto LABEL_112;
              }
              CMTimeValue v82 = *(void *)(v32 + 216);
              CMTimeFlags v17 = *(_DWORD *)(v32 + 228);
              CMTimeScale v83 = *(_DWORD *)(v32 + 224);
              CMTimeEpoch v18 = *(void *)(v32 + 232);
LABEL_97:
              uint64_t v32 = *(void *)(v32 + 8);
              if (!v32) {
                goto LABEL_100;
              }
            }
            if (v34)
            {
              CMTime lhs = v65;
              type.unsigned int value = v76;
              type.CMTimeScale timescale = v77;
              type.CMTimeFlags flags = v34;
              type.CMTimeEpoch epoch = v63;
              BOOL v41 = CMTimeCompare(&lhs, &type) >= 0;
            }
            else
            {
LABEL_53:
              BOOL v41 = 0;
            }
            CFAllocatorRef v42 = (const __CFAllocator *)FigGetAllocatorForMedia();
            int v43 = CMBufferQueueGetCallbacksForUnsortedSampleBuffers();
            OSStatus v40 = CMBufferQueueCreate(v42, 0, v43, &queue);
            if (!v40)
            {
              MEMORY[0x199709540](v35, fpfs_StealBuffer, queue);
              while (1)
              {
                int v44 = (opaqueCMSampleBuffer *)CMBufferQueueDequeueAndRetain(queue);
                if (!v44)
                {
                  int v49 = 0;
                  goto LABEL_91;
                }
                int v45 = v44;
                memset(&lhs, 0, sizeof(lhs));
                fpfs_GetEndOutputPresentationTimeStamp(v44, &lhs);
                if (v37)
                {
                  CMTime type = lhs;
                  CMTime v71 = v65;
                  int32_t v46 = CMTimeCompare(&type, &v71);
                  CMBufferQueueRef v47 = v74;
                  if (v46 <= 0 && !v74)
                  {
                    fpfs_DoNotDisplay(v45);
                    CMBufferQueueRef v47 = v74;
                  }
                  if (v46 <= 0 && v47)
                  {
LABEL_67:
                    int v49 = 0;
                    goto LABEL_83;
                  }
                }
                else
                {
                  CMSampleBufferGetOutputDecodeTimeStamp(&v70, v45);
                  type.unsigned int value = v78;
                  type.CMTimeScale timescale = v79;
                  type.CMTimeFlags flags = v17;
                  type.CMTimeEpoch epoch = v18;
                  if (CMTimeCompare(&v70, &type) < 0) {
                    goto LABEL_67;
                  }
                }
                uint64_t v48 = *(void *)v32;
                CMTime type = v64;
                if (fpfsi_ProcessVideoSampleForClamping(v48, v45, (uint64_t)&type)) {
                  goto LABEL_67;
                }
                if (v74 && !fpfs_IsMarkerOnly(v45))
                {
                  if (v41)
                  {
                    fpfs_FlushPrimaryAndAuxRenderChains(*(void *)(v32 + 96), 1);
                    if (*(unsigned char *)(v32 + 104)) {
                      fpfs_PrerollRenderPipeline(*(void *)(*(void *)(v32 + 96) + 32), *(_DWORD *)(v32 + 16));
                    }
                  }
                  if (!fpfs_IsVideoSync(v45))
                  {
                    CMTimeEpoch v50 = (opaqueCMSampleBuffer *)CMBufferQueueDequeueAndRetain(v74);
                    if (v50)
                    {
                      long long v51 = v50;
                      do
                      {
                        fpfs_DoNotDisplay(v51);
                        fpfs_RenderBuffer(v32, v51);
                        CFRelease(v51);
                        long long v51 = (opaqueCMSampleBuffer *)CMBufferQueueDequeueAndRetain(v74);
                      }
                      while (v51);
                    }
                  }
                  if (v74)
                  {
                    CFRelease(v74);
                    CMBufferQueueRef v74 = 0;
                  }
                }
                if (v41)
                {
                  CMSampleBufferGetOutputPresentationTimeStamp(&v69, v45);
                  type.unsigned int value = v76;
                  type.CMTimeScale timescale = v77;
                  type.CMTimeFlags flags = v34;
                  type.CMTimeEpoch epoch = v63;
                  if (CMTimeCompare(&v69, &type) <= 0) {
                    fpfs_DoNotDisplay(v45);
                  }
                }
                int v49 = fpfs_RenderBuffer(v32, v45);
LABEL_83:
                CMBufferQueueEnqueue(v35, v45);
                if (v74)
                {
                  if (fpfs_IsVideoSync(v45))
                  {
                    CMBufferQueueReset(v74);
                  }
                  else if (CMBufferQueueIsEmpty(v74))
                  {
                    goto LABEL_88;
                  }
                  CMBufferQueueEnqueue(v74, v45);
                }
LABEL_88:
                CFRelease(v45);
                if (v49) {
                  goto LABEL_91;
                }
              }
            }
            goto LABEL_99;
          }
LABEL_100:
          CMTimeFlags v17 = v58;
          CMTimeEpoch v18 = v57;
LABEL_21:
          uint64_t v16 = *(void *)(v16 + 8);
        }
        while (v16);
      }
      if (*((unsigned char *)a3 + 12))
      {
        fpfs_SignalImageQueueGaugeEnqueueingCompleteAfterClampTime();
      }
      else
      {
        CFTypeRef v52 = fpfsi_copyImageQueueGauge(v59);
        if (v52)
        {
          long long v53 = v52;
          uint64_t v54 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v54) {
            uint64_t v55 = v54;
          }
          else {
            uint64_t v55 = 0;
          }
          double v56 = *(void (**)(const void *, uint64_t))(v55 + 24);
          if (v56) {
            v56(v53, 1);
          }
          CFRelease(v53);
        }
      }
    }
  }
LABEL_112:
  if (queueOut) {
    CFRelease(queueOut);
  }
}

void *fpfsi_applyTimeToPauseBuffering(uint64_t a1, long long *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMTime time1 = *(CMTime *)(DerivedStorage + 1424);
  CMTime time2 = *(CMTime *)a2;
  uint64_t result = (void *)CMTimeCompare(&time1, &time2);
  if (result)
  {
    CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    CMTime time1 = *(CMTime *)a2;
    CFStringRef v7 = CMTimeCopyDescription(AllocatorForMedia, &time1);
    if (dword_1E9350BB0)
    {
      int v14 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (v7) {
      CFRelease(v7);
    }
    uint64_t v9 = DerivedStorage + 1424;
    if (*((unsigned char *)a2 + 12) & 1) != 0 && (*(unsigned char *)(DerivedStorage + 1460))
    {
      uint64_t v10 = (CMTime *)(DerivedStorage + 1448);
      CMTime time1 = *v10;
      CMTime time2 = *(CMTime *)a2;
      if (CMTimeCompare(&time1, &time2) >= 1)
      {
        long long v11 = *(_OWORD *)&v10->value;
        *((void *)a2 + 2) = v10->epoch;
        *a2 = v11;
      }
    }
    long long v12 = *a2;
    *(void *)(v9 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v9 = v12;
    return fpfs_CheckPrebufferedLevels(&time1, a1, 1, -1, 0);
  }
  return result;
}

void fpfs_HandleReachingTimeToPausePlayback(const void *a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  memset(&v10, 0, sizeof(v10));
  fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&v10);
  long long v8 = *MEMORY[0x1E4F1F9F8];
  *(_OWORD *)&v9.unsigned int value = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v3 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  v9.CMTimeEpoch epoch = v3;
  if (*(void *)(DerivedStorage + 568))
  {
    fpfsi_clearCoordinatedPlaybackSynchronizationTimebase();
    fpfs_PlayQueueCallForEachItem(*(void *)DerivedStorage, (uint64_t (*)(const __CFArray *, uint64_t))fpfs_clearCoordinatedPlaybackSynchronizationTimebaseForPlayQueueItemsApply, (uint64_t)a1);
  }
  CMTime time1 = v10;
  CMTime time2 = *(CMTime *)(DerivedStorage + 1448);
  if (CMTimeCompare(&time1, &time2) < 0)
  {
    *(_OWORD *)&v9.unsigned int value = *(_OWORD *)(DerivedStorage + 1448);
    v9.CMTimeEpoch epoch = *(void *)(DerivedStorage + 1464);
  }
  uint64_t v4 = *(void *)DerivedStorage;
  CMTime time1 = v9;
  *(_OWORD *)&time2.unsigned int value = v8;
  time2.CMTimeEpoch epoch = v3;
  fpfs_setRateInternal(v4, a1, &time1, &time2, 0.0);
  fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&v10);
  if (dword_1E9350BB0)
  {
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (!*(void *)(DerivedStorage + 3312)) {
    *(void *)(DerivedStorage + 3312) = FigGetUpTimeNanoseconds();
  }
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CMTime time1 = v10;
  FigCFDictionarySetCMTime();
  fpfs_EnqueueNotification(*(const void **)DerivedStorage, @"ReachedTimeToPausePlayback", a1, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

uint64_t fpfs_GetClosestSegmentBoundary(opaqueCMSampleBuffer *a1, uint64_t a2)
{
  memset(&v15, 0, sizeof(v15));
  fpfs_GetEndOutputPresentationTimeStamp(a1, &v15);
  CFTypeRef v4 = CMGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F1F2E0], 0);
  CMTime v5 = (_OWORD *)(a2 + 72);
  int v6 = *(_DWORD *)(a2 + 84);
  if (v15.flags)
  {
    if ((v6 & 1) == 0
      || (*(_OWORD *)&time1.unsigned int value = *v5,
          time1.CMTimeEpoch epoch = *(void *)(a2 + 88),
          CMTime time2 = v15,
          CMTimeCompare(&time1, &time2) < 0))
    {
      *CMTime v5 = *(_OWORD *)&v15.value;
      *(void *)(a2 + 88) = v15.epoch;
    }
  }
  if ((*(unsigned char *)(a2 + 84) & 1) != 0 && (v4 || (v6 & 1) == 0))
  {
    memset(&time1, 0, sizeof(time1));
    if (v6)
    {
      *(_OWORD *)&time1.unsigned int value = *v5;
      time1.CMTimeEpoch epoch = *(void *)(a2 + 88);
    }
    else
    {
      CMSampleBufferGetOutputPresentationTimeStamp(&time1, a1);
    }
    memset(&time2, 0, sizeof(time2));
    CMTime lhs = time1;
    CMTime v10 = *(CMTime *)a2;
    CMTimeSubtract(&time, &lhs, &v10);
    CMTimeAbsoluteValue(&time2, &time);
    *(CMTime *)(a2 + 48) = time1;
    long long v8 = (_OWORD *)(a2 + 96);
    if ((*(unsigned char *)(a2 + 108) & 1) == 0
      || (lhs = time2, *(_OWORD *)&v10.value = *v8, v10.CMTimeEpoch epoch = *(void *)(a2 + 112), CMTimeCompare(&lhs, &v10) < 0))
    {
      *(CMTime *)(a2 + 24) = time1;
      *long long v8 = *(_OWORD *)&time2.value;
      *(void *)(a2 + 112) = time2.epoch;
    }
    else
    {
      CMTime lhs = time2;
      *(_OWORD *)&v10.unsigned int value = *v8;
      v10.CMTimeEpoch epoch = *(void *)(a2 + 112);
      if (CMTimeCompare(&lhs, &v10) > 0) {
        return 4294954433;
      }
    }
  }
  return 0;
}

__n128 fpfsi_UpdateTimeIfCloser(uint64_t a1, uint64_t a2, unsigned char *a3, BOOL *a4)
{
  int v7 = *(_DWORD *)(a1 + 60);
  *a3 = v7 & 1;
  if (v7)
  {
    CMTime time1 = *(CMTime *)(a1 + 48);
    CMTime time2 = *(CMTime *)a1;
    BOOL v8 = CMTimeCompare(&time1, &time2) >= 0;
  }
  else
  {
    BOOL v8 = 0;
  }
  *a4 = v8;
  if (*(unsigned char *)(a1 + 36))
  {
    memset(&time1, 0, sizeof(time1));
    CMTime time2 = *(CMTime *)a2;
    CMTime v10 = *(CMTime *)a1;
    CMTimeSubtract(&time, &time2, &v10);
    CMTimeAbsoluteValue(&time1, &time);
    if ((*(unsigned char *)(a2 + 12) & 1) == 0 || (time2 = *(CMTime *)(a1 + 96), CMTime v10 = time1, CMTimeCompare(&time2, &v10) < 0))
    {
      __n128 result = *(__n128 *)(a1 + 24);
      *(void *)(a2 + 16) = *(void *)(a1 + 40);
      *(__n128 *)a2 = result;
    }
  }
  return result;
}

CMTime *fpfs_GetEndOutputPresentationTimeStamp@<X0>(opaqueCMSampleBuffer *a1@<X0>, CMTime *a2@<X8>)
{
  memset(&v8, 0, sizeof(v8));
  CMSampleBufferGetOutputPresentationTimeStamp(&v8, a1);
  memset(&v7, 0, sizeof(v7));
  __n128 result = CMSampleBufferGetOutputDuration(&v7, a1);
  if (v7.flags)
  {
    CMTime lhs = v8;
    CMTime v5 = v7;
    return CMTimeAdd(a2, &lhs, &v5);
  }
  else
  {
    *a2 = v8;
  }
  return result;
}

uint64_t fpfs_GetFirstNonMarkerSBuf(opaqueCMSampleBuffer *a1, opaqueCMSampleBuffer **a2)
{
  if (fpfs_IsMarkerOnly(a1)) {
    return 0;
  }
  *a2 = a1;
  return 0xFFFFFFFFLL;
}

void fpfs_FlushPrimaryAndAuxRenderChains(uint64_t a1, int a2)
{
  uint64_t v3 = a1;
  if (a1)
  {
    uint64_t v4 = a1;
    do
    {
      uint64_t v5 = *(void *)(v4 + 32);
      uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v6) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = 0;
      }
      CMTime v8 = *(void (**)(uint64_t, void))(v7 + 64);
      if (v8) {
        v8(v5, 0);
      }
      uint64_t v4 = *(void *)(v4 + 88);
    }
    while (v4);
  }
  if (!*(void *)(v3 + 56))
  {
    ++fpfs_HaltPrimaryAndAuxRenderChains_sResumeTag;
    values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &fpfs_HaltPrimaryAndAuxRenderChains_sResumeTag);
    if (values)
    {
      CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      CFDictionaryRef v10 = CFDictionaryCreate(AllocatorForMedia, MEMORY[0x1E4F1F328], (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v10)
      {
        CFDictionaryRef v11 = v10;
        do
        {
          long long v12 = *(const void **)(v3 + 56);
          uint64_t v13 = values;
          *(void *)(v3 + 56) = values;
          if (v13) {
            CFRetain(v13);
          }
          if (v12) {
            CFRelease(v12);
          }
          CMNotificationCenterGetDefaultLocalCenter();
          CMNotificationCenterPostNotification();
          if (a2)
          {
            CMNotificationCenterGetDefaultLocalCenter();
            CMNotificationCenterPostNotification();
          }
          uint64_t v3 = *(void *)(v3 + 88);
        }
        while (v3);
        CFRelease(v11);
      }
      else
      {
        FigSignalErrorAt();
      }
      if (values) {
        CFRelease(values);
      }
    }
    else
    {
      FigSignalErrorAt();
    }
  }
}

void fpfs_SignalImageQueueGaugeEnqueueingCompleteAfterClampTime()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 1484))
  {
    CFArrayRef v1 = (CMTime *)(DerivedStorage + 1472);
    uint64_t v2 = *(void *)(DerivedStorage + 1048);
    if (v2)
    {
      while (1)
      {
        if (*(_DWORD *)(v2 + 32) == 1986618469)
        {
          if (*(void *)(v2 + 96))
          {
            CMTime time1 = *(CMTime *)(v2 + 192);
            CMTime time2 = *v1;
            if (CMTimeCompare(&time1, &time2) <= 0)
            {
              CMTime time1 = *(CMTime *)(v2 + 216);
              CMTime time2 = *v1;
              if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0) {
                break;
              }
            }
          }
        }
        uint64_t v2 = *(void *)(v2 + 8);
        if (!v2) {
          goto LABEL_8;
        }
      }
    }
    else
    {
LABEL_8:
      *(_OWORD *)&v4.unsigned int value = *(_OWORD *)&v1->value;
      v4.CMTimeEpoch epoch = v1->epoch;
      uint64_t v2 = *(void *)(CMBaseObjectGetDerivedStorage() + 1048);
      if (!v2) {
        return;
      }
      while (1)
      {
        if (*(_DWORD *)(v2 + 32) == 1986618469)
        {
          if (*(void *)(v2 + 96))
          {
            CMTime time1 = *(CMTime *)(v2 + 216);
            CMTime time2 = v4;
            if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0) {
              break;
            }
          }
        }
        uint64_t v2 = *(void *)(v2 + 8);
        if (!v2) {
          return;
        }
      }
    }
    uint64_t v3 = *(void *)(v2 + 96);
    if (!*(unsigned char *)(v3 + 26))
    {
      *(unsigned char *)(v3 + 26) = 1;
      fpfs_SignalImageQueueGaugeEnqueueingCompleteAfterDecoding(v2);
    }
  }
}

CFTypeRef fpfsi_copyImageQueueGauge(const void *a1)
{
  CFTypeRef v33 = 0;
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v3 = CMBaseObjectGetDerivedStorage();
  CFTypeRef v4 = fpfsi_copyCurrentVideoDestination((uint64_t)a1);
  if (v4) {
    goto LABEL_2;
  }
  CMTime v9 = (const void *)DerivedStorage[105];
  if (v9)
  {
    CFTypeRef v4 = CFRetain(v9);
    if (v4) {
      goto LABEL_2;
    }
  }
  uint64_t TrackWithFormatDescriptionOfType = fpfs_FirstTrackWithFormatDescriptionOfType((uint64_t)a1, 1986618469);
  if (TrackWithFormatDescriptionOfType)
  {
    uint64_t v11 = TrackWithFormatDescriptionOfType;
    fpfsi_addCAImageQueuesAndSlots(a1, TrackWithFormatDescriptionOfType, *(void *)(v3 + 400) > 0);
    fpfsi_createOutputDestinationForVideo(v11);
    long long v12 = *(const void **)(v11 + 88);
    if (!v12) {
      goto LABEL_24;
    }
    CFTypeRef v4 = CFRetain(v12);
    if (!v4) {
      goto LABEL_24;
    }
LABEL_2:
    uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
    uint64_t CMBaseObject = FigAggregateVideoDestinationGetCMBaseObject(v4);
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v13 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v8 + 48);
    if (v13) {
      v13(CMBaseObject, @"ImageQueueGauge", AllocatorForMedia, &v33);
    }
    unsigned int value = v4;
    goto LABEL_14;
  }
  memset(&v32, 0, sizeof(v32));
  double NextTimeToPlay = fpfs_GetNextTimeToPlay((uint64_t)DerivedStorage, 0, (uint64_t)&v32);
  memset(&v31, 0, sizeof(v31));
  fpfsi_PredictedEndTime(&v31, a1, NextTimeToPlay);
  CMTimeFlags flags = v31.flags;
  if ((v31.flags & 1) == 0) {
    goto LABEL_21;
  }
  CMTimeFlags v18 = v32.flags;
  CMTimeEpoch epoch = v32.epoch;
  CMTimeEpoch v20 = v31.epoch;
  if ((v32.flags & 0x1F) != 3 && (v31.flags & 0x1F) != 3) {
    goto LABEL_36;
  }
  memset(&time1, 0, sizeof(time1));
  CMTime rhs = v31;
  CMTime lhs = v32;
  CMTimeSubtract(&time, &lhs, &rhs);
  CMTimeAbsoluteValue(&time1, &time);
  CMTimeMake(&time2, 1, 1000000000);
  CMTime lhs = time1;
  if (CMTimeCompare(&lhs, &time2) > 0)
  {
LABEL_36:
    time1.unsigned int value = v32.value;
    time1.CMTimeScale timescale = v32.timescale;
    time1.CMTimeFlags flags = v18;
    time1.CMTimeEpoch epoch = epoch;
    lhs.unsigned int value = v31.value;
    lhs.CMTimeScale timescale = v31.timescale;
    lhs.CMTimeFlags flags = flags;
    lhs.CMTimeEpoch epoch = v20;
    if (CMTimeCompare(&time1, &lhs) < 0)
    {
LABEL_21:
      uint64_t v21 = (const void *)DerivedStorage[92];
      if (v21
        || (uint64_t v22 = FigGetAllocatorForMedia(),
            FigImageQueueGaugeCreate(v22, 0, DerivedStorage + 92),
            (uint64_t v21 = (const void *)DerivedStorage[92]) != 0))
      {
        CFTypeRef v33 = CFRetain(v21);
        if (v33) {
          return v33;
        }
      }
      else
      {
        CFTypeRef v33 = 0;
      }
    }
  }
LABEL_24:
  uint64_t v23 = DerivedStorage[90];
  if (v23)
  {
    time1.unsigned int value = 0;
    FigImageQueueTableCopyFigImageQueueArray(v23, &time1.value);
    uint64_t ValueAtIndex = FigCFArrayGetValueAtIndex();
    if (ValueAtIndex)
    {
      uint64_t v25 = ValueAtIndex;
      uint64_t v26 = FigGetAllocatorForMedia();
      uint64_t FigBaseObject = FigImageQueueGetFigBaseObject(v25);
      uint64_t v28 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v28) {
        uint64_t v29 = v28;
      }
      else {
        uint64_t v29 = 0;
      }
      uint64_t v30 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v29 + 48);
      if (v30) {
        v30(FigBaseObject, @"ImageQueueGauge", v26, &v33);
      }
    }
    unsigned int value = (const void *)time1.value;
    if (time1.value) {
LABEL_14:
    }
      CFRelease(value);
  }
  return v33;
}

BOOL fpfs_IsMarkerOnly(opaqueCMSampleBuffer *a1)
{
  if (CMSampleBufferGetNumSamples(a1)) {
    return 0;
  }
  CMSampleBufferGetOutputPresentationTimeStamp(&v3, a1);
  return (v3.flags & 1) == 0;
}

void fpfs_DoNotDisplay(opaqueCMSampleBuffer *a1)
{
  CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(a1, 1u);
  if (SampleAttachmentsArray)
  {
    uint64_t ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    if (ValueAtIndex)
    {
      CMTime v3 = (const void *)*MEMORY[0x1E4F1F1B8];
      CFTypeRef v4 = (const void *)*MEMORY[0x1E4F1CFD0];
      CFDictionarySetValue(ValueAtIndex, v3, v4);
    }
  }
}

BOOL fpfsi_ProcessVideoSampleForClamping(uint64_t a1, opaqueCMSampleBuffer *a2, uint64_t a3)
{
  CMBaseObjectGetDerivedStorage();
  memset(&v17, 0, sizeof(v17));
  CMSampleBufferGetOutputDecodeTimeStamp(&v17, a2);
  memset(&v16, 0, sizeof(v16));
  CMSampleBufferGetOutputPresentationTimeStamp(&v16, a2);
  if ((*(unsigned char *)(a3 + 12) & 1) == 0 || (v17.flags & 1) == 0)
  {
    BOOL v5 = 0;
LABEL_4:
    CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(a2, 0);
    if (SampleAttachmentsArray) {
      uint64_t ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    }
    else {
      uint64_t ValueAtIndex = 0;
    }
    uint64_t v8 = (const void *)*MEMORY[0x1E4F1F230];
    if (FigCFDictionaryGetValue())
    {
      fpfs_RemoveDoNotDisplay(a2);
      CFDictionaryRemoveValue(ValueAtIndex, v8);
    }
    return v5;
  }
  CMTime time1 = v16;
  CMTime v14 = *(CMTime *)a3;
  int32_t v10 = CMTimeCompare(&time1, &v14);
  CMTime time1 = v17;
  CMTime v14 = *(CMTime *)a3;
  int v11 = v10 | CMTimeCompare(&time1, &v14);
  if ((v11 & 0x80000000) == 0 || v10 < 0)
  {
    BOOL v5 = v11 >= 0;
    if ((v10 & 0x80000000) == 0) {
      return v5;
    }
    goto LABEL_4;
  }
  CFArrayRef v12 = CMSampleBufferGetSampleAttachmentsArray(a2, 0);
  if (v12) {
    CFArrayGetValueAtIndex(v12, 0);
  }
  if (FigCFDictionaryGetValue() != *MEMORY[0x1E4F1CFD0])
  {
    CFArrayRef v13 = CMSampleBufferGetSampleAttachmentsArray(a2, 1u);
    if (v13) {
      CFArrayGetValueAtIndex(v13, 0);
    }
    FigCFDictionarySetValue();
    fpfs_DoNotDisplay(a2);
  }
  return 0;
}

uint64_t fpfs_PrerollRenderPipeline(uint64_t a1, int a2)
{
  int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  if (!v3) {
    return 4294954434;
  }
  CFNumberRef v4 = v3;
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, CFNumberRef))(v6 + 56);
  if (v7) {
    uint64_t v8 = v7(a1, v4);
  }
  else {
    uint64_t v8 = 4294954514;
  }
  CFRelease(v4);
  return v8;
}

CMItemCount fpfs_IsVideoSync(opaqueCMSampleBuffer *a1)
{
  CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(a1, 0);
  if (SampleAttachmentsArray)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    if (ValueAtIndex)
    {
      CFDictionaryRef v4 = ValueAtIndex;
      uint64_t v5 = (const void *)*MEMORY[0x1E4F1F200];
      if (CFDictionaryContainsKey(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F200])) {
        return CFDictionaryGetValue(v4, v5) == (const void *)*MEMORY[0x1E4F1CFC8];
      }
    }
  }
  else
  {
    CMItemCount result = CMSampleBufferGetNumSamples(a1);
    if (!result) {
      return result;
    }
  }
  return 1;
}

uint64_t fpfs_RenderBuffer(uint64_t a1, opaqueCMSampleBuffer *a2)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = CMBaseObjectGetDerivedStorage();
  if (!*(void *)(a1 + 96)) {
    return 0;
  }
  uint64_t v6 = v5;
  memset(&v56, 0, sizeof(v56));
  fpfsi_MapEndTimeFromTargetToSource(DerivedStorage, (uint64_t)&v56);
  int v7 = *(_DWORD *)(a1 + 32);
  if (v7 == 1986618469)
  {
    uint64_t v8 = CMBaseObjectGetDerivedStorage();
    int v7 = *(_DWORD *)(a1 + 32);
    if (v7 == 1986618469)
    {
      CMTime v9 = (void *)v8;
      memset(&time1, 0, sizeof(time1));
      CMSampleBufferGetOutputDuration(&time1, a2);
      CMTime time = time1;
      double v10 = CMTimeGetSeconds(&time) * 1000.0;
      uint64_t v11 = (uint64_t)v10;
      uint64_t v12 = v9[427];
      if (v12 <= (uint64_t)v10) {
        uint64_t v12 = (uint64_t)v10;
      }
      v9[427] = v12;
      uint64_t v13 = v9[426];
      if (v13 >= v11) {
        uint64_t v13 = (uint64_t)v10;
      }
      v9[426] = v13;
      if (v9[428] != v11) {
        v9[428] = v11;
      }
      uint64_t v14 = v9[318];
      if (v14)
      {
        uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v16 = v15 ? v15 : 0;
        CMTime v17 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 40);
        if (v17) {
          v17(v14, 0x1EE582B78, 0x1EE5628B8, v11);
        }
      }
      int v7 = *(_DWORD *)(a1 + 32);
    }
  }
  if (v7 == 1936684398) {
    fpfsi_UpdateAudioActiveSamples(*(void *)a1, a2);
  }
  if (*(unsigned char *)(v6 + 49))
  {
    if (v56.flags)
    {
      memset(&v55, 0, sizeof(v55));
      fpfs_GetEndOutputPresentationTimeStamp(a2, &v55);
      if (v55.flags)
      {
        CMTime time1 = v55;
        CMTime time = v56;
        if ((CMTimeCompare(&time1, &time) & 0x80000000) == 0)
        {
          memset(&v54, 0, sizeof(v54));
          CMSampleBufferGetOutputPresentationTimeStamp(&v54, a2);
          memset(&v53, 0, sizeof(v53));
          CMSampleBufferGetOutputDecodeTimeStamp(&v53, a2);
          CMTime time1 = v54;
          CMTime time = v56;
          if (CMTimeCompare(&time1, &time) >= 1)
          {
            CMTime time1 = v53;
            CMTime time = v56;
            if (CMTimeCompare(&time1, &time) > 0) {
              return 0;
            }
          }
          CMTime time1 = v54;
          CMTime time = v56;
          if (CMTimeCompare(&time1, &time) < 0)
          {
            memset(&time1, 0, sizeof(time1));
            CMSampleBufferGetOutputPresentationTimeStamp(&time1, a2);
            memset(&time, 0, sizeof(time));
            memset(&v59, 0, sizeof(v59));
            CMTime type = v56;
            CMTime time2 = time1;
            if (CMTimeCompare(&type, &time2) >= 1)
            {
              CFStringRef v44 = (const __CFString *)*MEMORY[0x1E4F1F300];
              CMRemoveAttachment(a2, (CFStringRef)*MEMORY[0x1E4F1F300]);
              fpfs_GetEndOutputPresentationTimeStamp(a2, &time);
              CMTime type = time;
              CMTime time2 = v56;
              if ((CMTimeCompare(&type, &time2) & 0x80000000) == 0)
              {
                CMTime type = time;
                CMTime time2 = v56;
                CMTimeSubtract(&v59, &type, &time2);
                CMTime type = v59;
                CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
                if (CMTimeCompare(&type, &time2) >= 1)
                {
                  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
                  CMTime type = v59;
                  CFDictionaryRef v46 = CMTimeCopyAsDictionary(&type, AllocatorForMedia);
                  if (v46)
                  {
                    CFDictionaryRef v47 = v46;
                    CMSetAttachment(a2, v44, v46, 1u);
                    CFRelease(v47);
                  }
                }
              }
            }
          }
          else
          {
            fpfs_DoNotDisplay(a2);
          }
        }
      }
    }
  }
  CMTimeFlags v18 = *(const void **)(*(void *)(a1 + 96) + 56);
  if (!v18) {
    goto LABEL_48;
  }
  if (dword_1E9350BB0)
  {
    LODWORD(v59.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int value = v59.value;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type.value)) {
      unsigned int v21 = value;
    }
    else {
      unsigned int v21 = value & 0xFFFFFFFE;
    }
    if (v21)
    {
      uint64_t v22 = *(void *)DerivedStorage;
      if (*(void *)DerivedStorage) {
        uint64_t v23 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      }
      else {
        uint64_t v23 = "";
      }
      uint64_t v48 = v6;
      uint64_t v24 = *(void *)a1;
      if (*(void *)a1) {
        uint64_t v25 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
      }
      else {
        uint64_t v25 = "";
      }
      CMSampleBufferGetOutputPresentationTimeStamp(&v52, a2);
      Float64 Seconds = CMTimeGetSeconds(&v52);
      LODWORD(time.CFDictionarySetValue(theDict, key, value) = 136316674;
      *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"fpfs_RenderBuffer";
      LOWORD(time.flags) = 2048;
      *(void *)((char *)&time.flags + 2) = v22;
      HIWORD(time.epoch) = 2082;
      uint64_t v61 = v23;
      __int16 v62 = 2048;
      uint64_t v63 = v24;
      __int16 v64 = 2082;
      CMTime v65 = v25;
      __int16 v66 = 2048;
      Float64 v67 = *(double *)&a2;
      __int16 v68 = 2048;
      Float64 v69 = Seconds;
      _os_log_send_and_compose_impl();
      uint64_t v6 = v48;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    CMTimeFlags v18 = *(const void **)(*(void *)(a1 + 96) + 56);
  }
  CMSetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F1F2C0], v18, 1u);
  CFRelease(*(CFTypeRef *)(*(void *)(a1 + 96) + 56));
  *(void *)(*(void *)(a1 + 96) + 56) = 0;
  if (*(_DWORD *)(a1 + 32) == 1986618469)
  {
    if (*(float *)(v6 + 108) >= 0.0 || *(void *)(DerivedStorage + 2968)) {
      float v27 = 1.0;
    }
    else {
      float v27 = -1.0;
    }
    *(float *)&time1.unsigned int value = v27;
    CFNumberRef v28 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &time1);
    if (v28)
    {
      CFNumberRef v29 = v28;
      fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(*(void *)(a1 + 96), @"PrerollRate", (uint64_t)v28);
      CFRelease(v29);
    }
LABEL_48:
    if (*(_DWORD *)(a1 + 32) == 1986618469)
    {
      if (*(unsigned char *)(a1 + 184)
        && (*(unsigned char *)(DerivedStorage + 332) & 1) != 0
        && !*(unsigned char *)(a1 + 104)
        && fpfs_FirstRenderingTrackofType(*(void *)a1, 1986618469) == a1)
      {
        fpfs_UnsuspendVideoRenderingForTrack(a1, 0);
        fpfs_PrerollTrack(a1);
      }
      if (*(_DWORD *)(a1 + 32) == 1986618469)
      {
        if (*(unsigned char *)(a1 + 104))
        {
          if (!*(unsigned char *)(a1 + 184))
          {
            fpfs_GetEndOutputPresentationTimeStamp(a2, &v51);
            CMTime time1 = *(CMTime *)(a1 + 192);
            if (CMTimeCompare(&v51, &time1) < 0) {
              fpfs_DoNotDisplay(a2);
            }
          }
        }
      }
    }
  }
  if ((*(unsigned char *)(DerivedStorage + 1484) & 1) != 0 && *(_DWORD *)(a1 + 32) == 1986618469 && !*(unsigned char *)(a1 + 184))
  {
    uint64_t v36 = *(void *)a1;
    CMTime time1 = *(CMTime *)(DerivedStorage + 1472);
    if (fpfsi_ProcessVideoSampleForClamping(v36, a2, (uint64_t)&time1)) {
      return 0;
    }
  }
  uint64_t v30 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
  if (*(unsigned char *)(a1 + 185))
  {
    if (dword_1E9350BB0)
    {
      LODWORD(v59.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
      CMTime v31 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v32 = v59.value;
      if (os_log_type_enabled(v31, type.value)) {
        unsigned int v33 = v32;
      }
      else {
        unsigned int v33 = v32 & 0xFFFFFFFE;
      }
      if (v33)
      {
        uint64_t v34 = *(void *)DerivedStorage;
        if (v34) {
          uint64_t v35 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          uint64_t v35 = "";
        }
        uint64_t v49 = v6;
        uint64_t v38 = *(void *)a1;
        if (*(void *)a1) {
          CMTime v39 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else {
          CMTime v39 = "";
        }
        CMSampleBufferGetOutputPresentationTimeStamp(&v50, a2);
        Float64 v40 = CMTimeGetSeconds(&v50);
        LODWORD(time.CFDictionarySetValue(theDict, key, value) = 136316418;
        *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"fpfs_RenderBuffer";
        LOWORD(time.flags) = 2048;
        *(void *)((char *)&time.flags + 2) = v34;
        HIWORD(time.epoch) = 2082;
        uint64_t v61 = v35;
        __int16 v62 = 2048;
        uint64_t v63 = v38;
        __int16 v64 = 2082;
        CMTime v65 = v39;
        __int16 v66 = 2048;
        Float64 v67 = v40;
        _os_log_send_and_compose_impl();
        uint64_t v6 = v49;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    CMSetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F1F2B8], *v30, 1u);
    *(unsigned char *)(a1 + 185) = 0;
  }
  if (*(float *)(v6 + 108) < 0.0) {
    CMSetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F1F2C8], *v30, 1u);
  }
  if (*(_DWORD *)(a1 + 32) == 1835365473)
  {
    LODWORD(time1.CFDictionarySetValue(theDict, key, value) = *(void *)(a1 + 16);
    CFNumberRef v41 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &time1);
    CMSetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F21A60], v41, 0);
    if (v41) {
      CFRelease(v41);
    }
  }
  uint64_t v37 = CMBufferQueueEnqueue(*(CMBufferQueueRef *)(*(void *)(a1 + 96) + 40), a2);
  for (uint64_t i = *(void *)(*(void *)(a1 + 96) + 88); i; uint64_t i = *(void *)(i + 88))
    CMBufferQueueEnqueue(*(CMBufferQueueRef *)(i + 40), a2);
  return v37;
}

void fpfs_RemoveDoNotDisplay(opaqueCMSampleBuffer *a1)
{
  CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(a1, 0);
  if (SampleAttachmentsArray)
  {
    CFDictionaryRef ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    if (ValueAtIndex)
    {
      CFNumberRef v3 = (const void *)*MEMORY[0x1E4F1F1B8];
      CFDictionaryRemoveValue(ValueAtIndex, v3);
    }
  }
}

opaqueCMSampleBuffer *fpfsi_UpdateAudioActiveSamples(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  memset(&v9, 0, sizeof(v9));
  fpfs_GetTime(DerivedStorage, (uint64_t)&v9);
  if (a2 && !fpfs_IsMarkerOnly((opaqueCMSampleBuffer *)a2)) {
    CMBufferQueueEnqueue(*(CMBufferQueueRef *)(DerivedStorage + 856), a2);
  }
  while (1)
  {
    CMItemCount result = (opaqueCMSampleBuffer *)CMBufferQueueGetHead(*(CMBufferQueueRef *)(DerivedStorage + 856));
    if (!result) {
      break;
    }
    memset(&v8, 0, sizeof(v8));
    fpfs_GetEndOutputPresentationTimeStamp(result, &v8);
    CMTime time1 = v9;
    CMTime v6 = v8;
    CMItemCount result = (opaqueCMSampleBuffer *)CMTimeCompare(&time1, &v6);
    if ((result & 0x80000000) != 0) {
      break;
    }
    CMBufferRef v5 = CMBufferQueueDequeueAndRetain(*(CMBufferQueueRef *)(DerivedStorage + 856));
    if (v5) {
      CFRelease(v5);
    }
  }
  return result;
}

uint64_t fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(*(void *)(a1 + 32));
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  CMTime v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
  if (!v9) {
    return 4294954514;
  }
  uint64_t result = v9(FigBaseObject, a2, a3);
  if (result) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = v5 == 0;
  }
  if (!v11)
  {
    do
    {
      uint64_t v12 = FigRenderPipelineGetFigBaseObject(*(void *)(v5 + 32));
      uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v13) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = 0;
      }
      uint64_t v15 = *(void (**)(uint64_t, uint64_t, uint64_t))(v14 + 56);
      if (v15) {
        v15(v12, a2, a3);
      }
      uint64_t v5 = *(void *)(v5 + 88);
    }
    while (v5);
    return 0;
  }
  return result;
}

uint64_t fpfs_UnsuspendVideoRenderingForTrack(uint64_t a1, char *a2)
{
  CMBaseObjectGetDerivedStorage();
  if (*(_DWORD *)(a1 + 32) != 1986618469 || !*(void *)(a1 + 96)) {
    goto LABEL_21;
  }
  uint64_t RenderingTrackofType = fpfs_LastRenderingTrackofType(*(void *)a1, 1986618469, a1);
  if (!RenderingTrackofType)
  {
    fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(*(void *)(a1 + 96), @"Suspended", *MEMORY[0x1E4F1CFC8]);
    char v15 = 1;
    fpfsi_scheduleFVTTransitionsForItem(*(const __CFString **)a1, 0, 1);
    fpfsi_RTCReportingReportFormatTransition(*(void *)a1, 0, a1);
LABEL_22:
    uint64_t v14 = 0;
    if (a2) {
      *a2 = v15;
    }
    return v14;
  }
  uint64_t v5 = RenderingTrackofType;
  uint64_t v6 = *(void *)(RenderingTrackofType + 96);
  if (v6)
  {
    CFDictionaryRef v7 = *(const __CFDictionary **)(v6 + 64);
    if (v7)
    {
      if (CFDictionaryGetValue(v7, @"renderPipelineToStart"))
      {
        uint64_t v8 = (const void *)FigCFWeakReferenceHolderCopyReferencedObject();
        if (v8)
        {
          if (FigCFEqual()) {
            goto LABEL_12;
          }
        }
        CMTime v9 = *(const void **)(*(void *)(v5 + 96) + 64);
        if (v9)
        {
          CFRelease(v9);
          *(void *)(*(void *)(v5 + 96) + 64) = 0;
        }
        if (v8) {
LABEL_12:
        }
          CFRelease(v8);
      }
    }
  }
  uint64_t v10 = *(void *)(v5 + 96);
  BOOL v11 = !v10 || v10 == *(void *)(a1 + 96);
  if (v11 || *(void *)(v10 + 64))
  {
LABEL_21:
    char v15 = 0;
    goto LABEL_22;
  }
  CFTypeRef cf = 0;
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  uint64_t v13 = CMSampleBufferCreate(AllocatorForMedia, 0, 1u, 0, 0, 0, 0, 0, 0, 0, 0, (CMSampleBufferRef *)&cf);
  if (v13) {
    return v13;
  }
  uint64_t v14 = fpfs_RenderWithEndSignal(v5, cf, *(void *)(*(void *)(a1 + 96) + 32));
  CFRelease(cf);
  if (!v14)
  {
    fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(*(void *)(a1 + 96), @"Suspended", *MEMORY[0x1E4F1CFD0]);
    goto LABEL_21;
  }
  return v14;
}

uint64_t fpfs_PrerollTrack(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(_DWORD *)(result + 32) == 1986618469 && *(void *)(result + 96) && !*(unsigned char *)(result + 104))
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      if (*(_DWORD *)(v1 + 32) == 1986618469)
      {
        uint64_t v3 = DerivedStorage;
        if ((int)CMVideoFormatDescriptionGetVideoDynamicRange() >= 2 && !*(unsigned char *)(v1 + 184))
        {
          uint64_t v4 = *(void *)(v3 + 1048);
          if (v4)
          {
            while (v4 != v1)
            {
              if (*(_DWORD *)(v4 + 32) != 1986618469 || (int)CMVideoFormatDescriptionGetVideoDynamicRange() <= 1)
              {
                uint64_t v4 = *(void *)(v4 + 8);
                if (v4) {
                  continue;
                }
              }
              goto LABEL_8;
            }
            CelestialPreallocateSurfaceMemoryForHDRVideo();
          }
        }
      }
LABEL_8:
      uint64_t result = fpfs_PrerollRenderPipeline(*(void *)(*(void *)(v1 + 96) + 32), *(_DWORD *)(v1 + 16));
      *(unsigned char *)(v1 + 104) = result == 0;
    }
  }
  return result;
}

uint64_t fpfs_LastRenderingTrackofType(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage() + 1048);
  BOOL v6 = v5 == 0;
  uint64_t result = 0;
  while (!v6 && v5 != a3)
  {
    if (*(_DWORD *)(v5 + 32) == a2)
    {
      if (*(void *)(v5 + 96)) {
        uint64_t result = v5;
      }
    }
    uint64_t v5 = *(void *)(v5 + 8);
    BOOL v6 = v5 == 0;
  }
  return result;
}

void fpfsi_RTCReportingReportFormatTransition(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a3 || *(_DWORD *)(a3 + 32) != 1986618469) {
    return;
  }
  uint64_t v6 = DerivedStorage;
  FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(*(CMFormatDescriptionRef *)(a3 + 40));
  TrackVideoContentTypeDescription = fpfsi_getTrackVideoContentTypeDescription(a3);
  if (!a2) {
    goto LABEL_20;
  }
  if (*(_DWORD *)(a2 + 32) == 1986618469)
  {
    CMTime v9 = fpfsi_getTrackVideoContentTypeDescription(a2);
    if (!FigCFEqual())
    {
      uint64_t v10 = *(void *)(v6 + 2544);
      if (v10)
      {
        uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v12 = v11 ? v11 : 0;
        uint64_t v13 = *(void (**)(uint64_t, uint64_t, uint64_t, __CFString *, void))(v12 + 48);
        if (v13) {
          v13(v10, 0x1EE582B78, 0x1EE583838, v9, 0);
        }
      }
      CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      uint64_t v15 = CMFormatDescriptionGetMediaSubType(*(CMFormatDescriptionRef *)(a2 + 40)) >> 24;
      uint64_t v16 = (CMFormatDescriptionGetMediaSubType(*(CMFormatDescriptionRef *)(a2 + 40)) >> 16);
      uint64_t v17 = ((unsigned __int16)CMFormatDescriptionGetMediaSubType(*(CMFormatDescriptionRef *)(a2 + 40)) >> 8);
      unsigned __int8 v18 = CMFormatDescriptionGetMediaSubType(*(CMFormatDescriptionRef *)(a2 + 40));
      CFStringRef v19 = CFStringCreateWithFormat(AllocatorForMedia, 0, @"%c%c%c%c", v15, v16, v17, v18);
      if (v19)
      {
        a2 = (uint64_t)v19;
        uint64_t v20 = *(void *)(v6 + 2544);
        if (v20)
        {
          uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v22 = v21 ? v21 : 0;
          uint64_t v23 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v22 + 48);
          if (v23) {
            v23(v20, 0x1EE582B78, 0x1EE583818, a2, 0);
          }
        }
LABEL_20:
        uint64_t v24 = *(void *)(v6 + 2544);
        if (v24)
        {
          uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v26 = v25 ? v25 : 0;
          float v27 = *(void (**)(uint64_t, uint64_t, uint64_t, __CFString *, void))(v26 + 48);
          if (v27) {
            v27(v24, 0x1EE582B78, 0x1EE583858, TrackVideoContentTypeDescription, 0);
          }
        }
        CFAllocatorRef v28 = (const __CFAllocator *)FigGetAllocatorForMedia();
        CFStringRef v29 = CFStringCreateWithFormat(v28, 0, @"%c%c%c%c", HIBYTE(MediaSubType), BYTE2(MediaSubType), BYTE1(MediaSubType), MediaSubType);
        if (v29)
        {
          uint64_t v30 = *(void *)(v6 + 2544);
          if (v30)
          {
            uint64_t v31 = *(void *)(CMBaseObjectGetVTable() + 16);
            uint64_t v32 = v31 ? v31 : 0;
            unsigned int v33 = *(void (**)(uint64_t, uint64_t, uint64_t, CFStringRef, void))(v32 + 48);
            if (v33) {
              v33(v30, 0x1EE582B78, 0x1EE5837F8, v29, 0);
            }
          }
          if (*(unsigned char *)(a3 + 484))
          {
            uint64_t v34 = *(void *)(v6 + 2544);
            CMTime time = *(CMTime *)(a3 + 472);
            double Seconds = CMTimeGetSeconds(&time);
            if (v34)
            {
              double v36 = Seconds;
              uint64_t v37 = *(void *)(CMBaseObjectGetVTable() + 16);
              uint64_t v38 = v37 ? v37 : 0;
              CMTime v39 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v38 + 56);
              if (v39) {
                v39(v34, 0x1EE582B78, 0x1EE5837B8, (uint64_t)v36, 0);
              }
            }
          }
          uint64_t v40 = *(void *)(v6 + 2544);
          if (v40)
          {
            uint64_t v41 = *(void *)(a3 + 64);
            uint64_t v42 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v42) {
              uint64_t v43 = v42;
            }
            else {
              uint64_t v43 = 0;
            }
            CFStringRef v44 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v43 + 56);
            if (v44) {
              v44(v40, 0x1EE582B78, 0x1EE5837D8, v41, 0);
            }
            uint64_t v45 = *(void *)(v6 + 2544);
            if (v45)
            {
              uint64_t v46 = *(void *)(CMBaseObjectGetVTable() + 16);
              uint64_t v47 = v46 ? v46 : 0;
              uint64_t v48 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v47 + 8);
              if (v48) {
                v48(v45, 0x1EE582B78, 114, 0, 0);
              }
            }
          }
        }
        if (a2) {
          CFRelease((CFTypeRef)a2);
        }
        if (v29) {
          CFRelease(v29);
        }
      }
    }
  }
}

uint64_t fpfs_RenderWithEndSignal(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 96);
  if (!*(void *)(v3 + 64))
  {
    CMBaseObjectGetDerivedStorage();
    if (a3)
    {
      values = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
      if (values)
      {
        CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        CFDictionaryRef v8 = CFDictionaryCreate(AllocatorForMedia, (const void **)&kFigPlaybackItemParameter_RenderPipelineToStart, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (values) {
          CFRelease(values);
        }
        if (v8) {
          goto LABEL_7;
        }
      }
    }
    else
    {
      CFAllocatorRef v11 = (const __CFAllocator *)FigGetAllocatorForMedia();
      CFDictionaryRef v8 = CFDictionaryCreate(v11, 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v8)
      {
LABEL_7:
        CMTime v9 = (const void *)*MEMORY[0x1E4F1CFD0];
        CMSetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F1F238], (CFTypeRef)*MEMORY[0x1E4F1CFD0], 1u);
        CMSetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F1F2A8], v8, 1u);
        *(void *)(v3 + 64) = v8;
        CMSetAttachment(a2, (CFStringRef)*MEMORY[0x1E4F21A30], v9, 1u);
        if (CMBufferQueueIsEmpty(*(CMBufferQueueRef *)(a1 + 72))) {
          return fpfs_RenderBuffer(a1, a2);
        }
        else {
          return CMBufferQueueEnqueue(*(CMBufferQueueRef *)(a1 + 72), a2);
        }
      }
    }
    *(void *)(v3 + 64) = 0;
    return 4294954434;
  }

  return FigSignalErrorAt();
}

__CFString *fpfsi_getTrackVideoContentTypeDescription(uint64_t a1)
{
  if (fpfsi_copyTrackFigTags(a1)) {
    return 0;
  }
  else {
    return FigAlternateGetVideoContentTypeStringFromCollection(0);
  }
}

uint64_t FigReportingAgentStatsSetCFTypeValue(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v7 = result;
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v10 = *(void *)(VTable + 16);
    uint64_t result = VTable + 16;
    uint64_t v9 = v10;
    uint64_t v11 = v10 ? v9 : 0;
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v11 + 48);
    if (v12)
    {
      return v12(v7, a2, a3, a4, 0);
    }
  }
  return result;
}

uint64_t fpfsi_copyTrackFigTags(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  CMMutableTagCollectionRef tagCollection = 0;
  CFArrayRef tagCollectionsOut = 0;
  FPSupport_CreateFigTagCollectionFromFormatDescriptionExtensions(*(const opaqueCMFormatDescription **)(a1 + 40), &cf);
  if (cf) {
    goto LABEL_6;
  }
  if (dword_1E9350BB0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  uint64_t DefaultTagCollectionForVideo = FPSupport_CreateDefaultTagCollectionForVideo((CMTagCollectionRef *)&cf);
  CFTypeRef v4 = cf;
  if (!DefaultTagCollectionForVideo)
  {
    if (cf)
    {
LABEL_6:
      FigGetAllocatorForMedia();
      FigTagCollectionCreateMutableCopy();
      if (tagCollection)
      {
        CMVideoFormatDescriptionCopyTagCollectionArray(*(CMVideoFormatDescriptionRef *)(a1 + 40), &tagCollectionsOut);
        if (tagCollectionsOut && CFArrayGetCount(tagCollectionsOut) >= 2)
        {
          CMTagCollectionRemoveAllTagsOfCategory(tagCollection, kCMTagCategory_StereoView);
          CMTagCollectionAddTag(tagCollection, *MEMORY[0x1E4F21E58]);
          CMTagCollectionRemoveAllTagsOfCategory(tagCollection, kCMTagCategory_PackingType);
          CMTagCollectionAddTag(tagCollection, *MEMORY[0x1E4F21E10]);
        }
        FigTagCollectionCreateCopy();
      }
      uint64_t DefaultTagCollectionForVideo = 0;
      CFTypeRef v4 = cf;
    }
  }
  if (v4) {
    CFRelease(v4);
  }
  if (tagCollection) {
    CFRelease(tagCollection);
  }
  if (tagCollectionsOut) {
    CFRelease(tagCollectionsOut);
  }
  return DefaultTagCollectionForVideo;
}

void fpfs_SignalImageQueueGaugeEnqueueingCompleteAfterDecoding(uint64_t a1)
{
  CMSampleBufferRef v6 = 0;
  CMBaseObjectGetDerivedStorage();
  CFTypeRef v2 = fpfsi_copyImageQueueGauge(*(const void **)a1);
  if (*(_DWORD *)(a1 + 32) != 1986618469) {
    goto LABEL_5;
  }
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  OSStatus v4 = CMSampleBufferCreate(AllocatorForMedia, 0, 1u, 0, 0, 0, 0, 0, 0, 0, 0, &v6);
  CMSampleBufferRef v5 = v6;
  if (v4)
  {
    if (!v6) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  CMSetAttachment(v6, (CFStringRef)*MEMORY[0x1E4F21A30], (CFTypeRef)*MEMORY[0x1E4F1CFD0], 1u);
  if (v2) {
    CMSetAttachment(v6, (CFStringRef)*MEMORY[0x1E4F21A50], v2, 1u);
  }
  fpfs_RenderBuffer(a1, v6);
  CMSampleBufferRef v5 = v6;
  if (v6) {
LABEL_4:
  }
    CFRelease(v5);
LABEL_5:
  if (v2) {
    CFRelease(v2);
  }
}

CFTypeRef fpfsi_copyCurrentVideoDestination(uint64_t a1)
{
  uint64_t RenderingTrackofType = fpfs_FirstRenderingTrackofType(a1, 1986618469);
  if (!RenderingTrackofType) {
    return 0;
  }
  CFTypeRef v2 = *(const void **)(RenderingTrackofType + 88);
  if (!v2) {
    return 0;
  }

  return CFRetain(v2);
}

uint64_t fpfs_FirstTrackWithFormatDescriptionOfType(uint64_t a1, int a2)
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (result)
  {
    for (uint64_t result = *(void *)(result + 1048); result; uint64_t result = *(void *)(result + 8))
    {
      if (*(_DWORD *)(result + 32) == a2 && *(void *)(result + 40)) {
        break;
      }
    }
  }
  return result;
}

uint64_t fpfsi_addCAImageQueuesAndSlots(const void *a1, uint64_t a2, int a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = CMBaseObjectGetDerivedStorage();
  CFArrayRef Count = *(const __CFArray **)(v7 + 376);
  if (Count) {
    CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
  }
  if (!a2) {
    return 0;
  }
  CFIndex v9 = (CFIndex)Count + *(void *)(v7 + 400);
  if (*(void *)(DerivedStorage + 656)
    || (CFAllocatorRef v10 = (const __CFAllocator *)FigGetAllocatorForMedia(),
        CFMutableArrayRef v11 = CFArrayCreateMutable(v10, v9, MEMORY[0x1E4F1D510]),
        (*(void *)(DerivedStorage + 656) = v11) != 0))
  {
    CFArrayRef Mutable = *(const __CFArray **)(DerivedStorage + 664);
    if (Mutable
      || (CFAllocatorRef v13 = (const __CFAllocator *)FigGetAllocatorForMedia(),
          CFArrayRef Mutable = CFArrayCreateMutable(v13, *(void *)(v7 + 400), MEMORY[0x1E4F1D510]),
          (*(void *)(DerivedStorage + 664) = Mutable) != 0))
    {
      CFIndex v14 = CFArrayGetCount(Mutable);
      CFArrayRef v15 = *(const __CFArray **)(DerivedStorage + 656);
      if (v15) {
        CFIndex v16 = CFArrayGetCount(v15);
      }
      else {
        CFIndex v16 = 0;
      }
      if (v16 >= v9 || v14 >= v9) {
        return 0;
      }
      unint64_t Dimensions = (unint64_t)CMVideoFormatDescriptionGetDimensions(*(CMVideoFormatDescriptionRef *)(a2 + 40));
      int32_t v19 = Dimensions;
      unint64_t v20 = HIDWORD(Dimensions);
      if (a3) {
        uint64_t v21 = &v25;
      }
      else {
        uint64_t v21 = 0;
      }
      do
      {
        unsigned int value = 0;
        int v25 = 0;
        FPSupport_EnsureCAImageQueue((CFTypeRef *)&value, v21, v19, v20);
        if (value)
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 656), value);
          if (value)
          {
            CFRelease(value);
            unsigned int value = 0;
          }
        }
        if (a3) {
          FigCFArrayAppendInt32();
        }
        --v9;
      }
      while (v16 != v9);
      if (v16)
      {
        if (a3)
        {
LABEL_27:
          CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
          CFArrayRef Copy = CFArrayCreateCopy(AllocatorForMedia, *(CFArrayRef *)(DerivedStorage + 664));
          FigPropertyStorageSetValue(*(void *)(DerivedStorage + 168), @"VideoSlotArray", Copy);
          goto LABEL_30;
        }
      }
      else
      {
        *(unsigned char *)(DerivedStorage + 3024) = 1;
        if (a3) {
          goto LABEL_27;
        }
      }
      CFArrayRef Copy = 0;
LABEL_30:
      fpfs_EnqueueNotification(*(const void **)DerivedStorage, @"DidPrepareImageQueue", a1, 0);
      if (Copy) {
        CFRelease(Copy);
      }
      return 0;
    }
  }

  return FigSignalErrorAt();
}

uint64_t fpfsi_createOutputDestinationForVideo(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  CFArrayRef v27 = 0;
  uint64_t RenderingTrackofType = fpfs_LastRenderingTrackofType(*(void *)a1, 1986618469, a1);
  if (*(_DWORD *)(a1 + 32) != 1986618469 || *(void *)(a1 + 88))
  {
    CFArrayRef v5 = 0;
    goto LABEL_36;
  }
  uint64_t v4 = RenderingTrackofType;
  fpfs_CreateFigImageQueueOutputsArray(*(void *)a1, a1, (CFTypeRef *)&v27);
  CFArrayRef v5 = v27;
  if (!v27)
  {
LABEL_36:
    uint64_t v18 = 0;
    goto LABEL_30;
  }
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  uint64_t v7 = (uint64_t *)(DerivedStorage + 840);
  if (v4) {
    CFDictionaryRef v8 = (uint64_t *)(v4 + 88);
  }
  else {
    CFDictionaryRef v8 = (uint64_t *)(DerivedStorage + 840);
  }
  uint64_t v9 = FigAggregateVideoDestinationCreate(AllocatorForMedia, v5, *(const void **)(DerivedStorage + 576), *(CMFormatDescriptionRef *)(a1 + 40), *v8, (void *)(a1 + 88));
  if (v9)
  {
    uint64_t v18 = v9;
    goto LABEL_30;
  }
  CFAllocatorRef v10 = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFStringRef v11 = CFStringCreateWithFormat(v10, 0, @"V.%d", *(void *)(a1 + 16));
  if (v11)
  {
    uint64_t CMBaseObject = FigAggregateVideoDestinationGetCMBaseObject(*(void *)(a1 + 88));
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    CFArrayRef v15 = *(uint64_t (**)(uint64_t, __CFString *, CFStringRef))(v14 + 56);
    if (v15)
    {
      uint64_t v16 = v15(CMBaseObject, @"VideoConfigID", v11);
      if (!v16) {
        goto LABEL_14;
      }
      uint64_t v18 = v16;
    }
    else
    {
      uint64_t v18 = 4294954514;
    }
LABEL_29:
    CFRelease(v11);
    goto LABEL_30;
  }
LABEL_14:
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterAddWeakListener();
  if (v4)
  {
    uint64_t v17 = *(void *)(v4 + 88);
  }
  else
  {
    uint64_t v17 = *v7;
    if (!*v7)
    {
      CFAllocatorRef v22 = (const __CFAllocator *)FigGetAllocatorForMedia();
      CFTypeRef cf = CFArrayCreate(v22, 0, 0, MEMORY[0x1E4F1D510]);
      goto LABEL_24;
    }
  }
  uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  uint64_t v21 = *(void (**)(uint64_t, CFTypeRef *, void))(v20 + 24);
  if (v21) {
    v21(v17, &cf, 0);
  }
LABEL_24:
  fpfsi_updateFigImageQueueListeners(*(void *)a1, a1);
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener();
  CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterAddWeakListener();
  uint64_t v23 = *(const void **)(DerivedStorage + 840);
  uint64_t v24 = *(const void **)(a1 + 88);
  *(void *)(DerivedStorage + 840) = v24;
  if (v24) {
    CFRetain(v24);
  }
  if (v23) {
    CFRelease(v23);
  }
  uint64_t v18 = 0;
  if (v11) {
    goto LABEL_29;
  }
LABEL_30:
  if (cf) {
    CFRelease(cf);
  }
  if (v5) {
    CFRelease(v5);
  }
  return v18;
}

void fpfs_CreateFigImageQueueOutputsArray(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = CMBaseObjectGetDerivedStorage();
  if (!a2) {
    return;
  }
  CFArrayRef v7 = *(const __CFArray **)(DerivedStorage + 864);
  if (!*(unsigned char *)(v6 + 462))
  {
    if (v7 && CFArrayGetCount(v7) >= 1) {
      fpfsi_VideoOutputAllowedWithPermissivePolicy(a2);
    }
    uint64_t ConcatenationOfTwoArrays = FigCFArrayCreateConcatenationOfTwoArrays();
LABEL_11:
    uint64_t v9 = (const void *)ConcatenationOfTwoArrays;
    CFAllocatorRef v10 = (const void *)FigCFArrayCreateConcatenationOfTwoArrays();
    if (!v9) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (!v7 || (CFTypeRef v8 = CFRetain(*(CFTypeRef *)(DerivedStorage + 864))) == 0)
  {
    CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    uint64_t ConcatenationOfTwoArrays = (uint64_t)CFArrayCreate(AllocatorForMedia, 0, 0, MEMORY[0x1E4F1D510]);
    goto LABEL_11;
  }
  uint64_t v9 = v8;
  CFAllocatorRef v10 = (const void *)FigCFArrayCreateConcatenationOfTwoArrays();
LABEL_12:
  CFRelease(v9);
LABEL_13:
  if (v10)
  {
    *a3 = CFRetain(v10);
    CFRelease(v10);
  }
  else
  {
    *a3 = 0;
  }
}

uint64_t fpfsi_FirstImageEnqueued(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  v9[25] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  CFTypeRef v8 = 0;
  v9[0] = 0;
  uint64_t result = fpfsi_CopyPlayerAndItemFromItemRetainProxy(a2, v9, &v8);
  if (result)
  {
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      return fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
  else
  {
    if (dword_1E9350BB0)
    {
      CFArrayRef v7 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (a4) {
      CFRetain(a4);
    }
    CMNotificationCenterGetDefaultLocalCenter();
    CMBaseObjectGetDerivedStorage();
    FigGetAllocatorForMedia();
    return FigDeferNotificationToDispatchQueue();
  }
  return result;
}

void fpfsi_updateFigImageQueueListeners(uint64_t a1, uint64_t a2)
{
  CFArrayRef theArray = 0;
  if (a2 && (uint64_t v2 = *(void *)(a2 + 88)) != 0)
  {
    uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v3) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = 0;
    }
    CFArrayRef v5 = *(void (**)(uint64_t, CFArrayRef *, void))(v4 + 24);
    if (v5) {
      v5(v2, &theArray, 0);
    }
  }
  else
  {
    fpfsi_copyCurrentImageQueueArrayAndOptions(a1, (uint64_t *)&theArray);
  }
  if (theArray)
  {
    CFArrayGetCount(theArray);
    if (theArray) {
      CFRelease(theArray);
    }
  }
}

void fpfsi_displaySizeChanged(int a1, uint64_t a2, int a3, int a4, CFTypeRef cf)
{
  v11[20] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  CFTypeRef cfa = 0;
  v11[0] = 0;
  if (!cf || (CFTypeID v6 = CFGetTypeID(cf), v6 != CFDictionaryGetTypeID()) || FigRetainProxyIsInvalidated())
  {
    FigSignalErrorAt();
    goto LABEL_13;
  }
  if (dword_1E9350BB0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (fpfsi_CopyPlayerAndItemFromItemRetainProxy(a2, v11, &cfa))
  {
    CFTypeRef v8 = cfa;
    if (!cfa) {
      goto LABEL_13;
    }
LABEL_12:
    CFRelease(v8);
    goto LABEL_13;
  }
  CMBaseObjectGetDerivedStorage();
  CFTypeRef v8 = cfa;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 768));
  if (!*(unsigned char *)(DerivedStorage + 776))
  {
    *(unsigned char *)(DerivedStorage + 776) = 1;
    FigRetainProxyRetain();
    CMNotificationCenterGetDefaultLocalCenter();
    FigGetAllocatorForMedia();
    FigDeferNotificationToDispatchQueue();
  }
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 768));
  if (v8) {
    goto LABEL_12;
  }
LABEL_13:
  if (v11[0]) {
    CFRelease(v11[0]);
  }
}

uint64_t fpfsi_VideoOutputAllowedWithPermissivePolicy(uint64_t a1)
{
  CFTypeRef cf = 0;
  if (!a1) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 32) == 1986618469)
  {
    uint64_t v1 = *(void *)(a1 + 384);
    if (!v1) {
      return 1;
    }
    uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
    uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v3) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = 0;
    }
    CFArrayRef v5 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v4 + 48);
    if (v5)
    {
      int v6 = v5(v1, @"AllowsVideoOutput", AllocatorForMedia, &cf);
      if (v6) {
        BOOL v7 = v6 == -12784;
      }
      else {
        BOOL v7 = 1;
      }
      if (!v7)
      {
        BOOL v9 = 0;
        uint64_t result = 0;
        CFTypeRef v8 = cf;
        if (!cf) {
          return result;
        }
        goto LABEL_17;
      }
      CFTypeRef v8 = cf;
      if (cf)
      {
        BOOL v9 = cf == (CFTypeRef)*MEMORY[0x1E4F1CFD0];
LABEL_17:
        CFRelease(v8);
        return v9;
      }
      return 1;
    }
  }
  else
  {
    FigSignalErrorAt();
  }
  return 0;
}

void fpfsi_deferredFirstImageEnqueued(uint64_t a1, const void *a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  BOOL v7 = *(const void **)DerivedStorage;
  fpfs_LockMutexWithCaller(*(void *)DerivedStorage);
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
  else
  {
    if (dword_1E9350BB0)
    {
      CFTypeRef v8 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    fpfs_EnqueueNotification(v7, @"FirstVideoFrameEnqueued", a2, 0);
    fpfsi_assignCAImageQueuesToLayers((const __CFArray *)a2);
  }
  fpfs_UnlockAndPostNotificationsWithCaller(v7);
  if (a2) {
    CFRelease(a2);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (a4) {
    CFRelease(a4);
  }
}

uint64_t fpfsi_assignCAImageQueuesToLayers(const __CFArray *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = CMBaseObjectGetDerivedStorage();
  CFArrayRef v4 = *(const __CFArray **)(v3 + 384);
  if (v4) {
    CFIndex Count = CFArrayGetCount(v4);
  }
  else {
    CFIndex Count = 0;
  }
  CFArrayRef v6 = *(const __CFArray **)(DerivedStorage + 656);
  if (!v6) {
    return 0;
  }
  CFIndex v7 = CFArrayGetCount(v6);
  if (Count < 1 || v7 < 1) {
    return 0;
  }
  if (Count == v7)
  {
    if (fpfs_getNext(v3, 0) == a1)
    {
      CFTypeRef v8 = *(CFTypeRef *)(v3 + 816);
      CFTypeRef cf = 0;
      CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      CFArrayRef Copy = CFArrayCreateCopy(AllocatorForMedia, *(CFArrayRef *)(DerivedStorage + 656));
      if (!v8)
      {
        uint64_t v11 = FigGetAllocatorForMedia();
        FigDeferredTransactionCreate(v11, (uint64_t *)&cf);
        CFTypeRef v8 = cf;
      }
      uint64_t v12 = (const void *)FigCFCopyCompactDescription();
      uint64_t v13 = (const void *)FigCFCopyCompactDescription();
      if (dword_1E9350BB0)
      {
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      if (v12) {
        CFRelease(v12);
      }
      if (v13) {
        CFRelease(v13);
      }
      CFArrayRef v14 = *(const __CFArray **)(v3 + 384);
      long long v18 = *MEMORY[0x1E4F1FA10];
      uint64_t v19 = *(void *)(MEMORY[0x1E4F1FA10] + 16);
      FPSupport_AppendDeferredTransactionChangeForSettingCAImageQueuesOnVideoLayers(v8, Copy, v14, &v18, (uint64_t)"fpfsi_assignCAImageQueuesToLayers");
      FPSupport_AppendDeferredTransactionChangeForSettingEdgeAntialiasingMaskOnLayers(v8, 0, *(CFArrayRef *)(v3 + 384), (uint64_t)"fpfsi_assignCAImageQueuesToLayers");
      FigDeferredTransactionCommit((uint64_t)cf);
      if (cf) {
        CFRelease(cf);
      }
      if (Copy) {
        CFRelease(Copy);
      }
    }
    return 0;
  }

  return FigSignalErrorAt();
}

void fpfsi_copyCurrentImageQueueArrayAndOptions(uint64_t a1, uint64_t *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef v5 = fpfsi_copyCurrentVideoDestination(a1);
  if (v5)
  {
    CFArrayRef v6 = v5;
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    CFAllocatorRef v10 = *(void (**)(const void *, uint64_t *, void))(v8 + 24);
    if (v10) {
      v10(v6, a2, 0);
    }
    CFRelease(v6);
  }
  else
  {
    uint64_t v9 = *(void *)(DerivedStorage + 720);
    if (v9)
    {
      FigImageQueueTableCopyFigImageQueueArray(v9, a2);
    }
  }
}

uint64_t fpfsi_deferredDisplaySizeChanged(uint64_t a1, uint64_t a2)
{
  cf[26] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  CFTypeRef v11 = 0;
  cf[0] = 0;
  if (fpfsi_CopyPlayerAndItemFromItemRetainProxyAndLockPlayer(a2, cf, &v11))
  {
    CFTypeRef v2 = cf[0];
    if (!cf[0]) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  CFTypeRef v4 = v11;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef v6 = (double *)MEMORY[0x1E4F1DB30];
  long long v10 = *MEMORY[0x1E4F1DB30];
  CFTypeRef v9 = 0;
  MEMORY[0x19970E910](*(void *)(DerivedStorage + 768));
  *(unsigned char *)(DerivedStorage + 776) = 0;
  MEMORY[0x19970E930](*(void *)(DerivedStorage + 768));
  fpfsi_copyCurrentImageQueueArrayAndOptions((uint64_t)v4, (uint64_t *)&v9);
  if (!FPSupport_GetMaxDisplaySizeFromImageQueues((const __CFArray *)v9, (double *)&v10)
    && (*(double *)&v10 != *v6 || *((double *)&v10 + 1) != v6[1]))
  {
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    *(_OWORD *)(DerivedStorage + 752) = v10;
    fpfsi_HandleResolutionCapOrDisplaySizeChange((uint64_t)v4);
  }
  if (v9) {
    CFRelease(v9);
  }
  CFTypeRef v2 = cf[0];
  fpfs_UnlockAndPostNotificationsWithCaller(cf[0]);
  if (v2) {
LABEL_3:
  }
    CFRelease(v2);
LABEL_4:
  if (v11) {
    CFRelease(v11);
  }
  return FigRetainProxyRelease();
}

uint64_t fpfsi_HandleResolutionCapOrDisplaySizeChange(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!*(void *)(DerivedStorage + 40)) {
    return 0;
  }
  uint64_t v3 = DerivedStorage;
  uint64_t v4 = CMBaseObjectGetDerivedStorage();
  if (!*(void *)(v4 + 40) || !*(unsigned char *)(v4 + 48) || !*(unsigned char *)(v4 + 49)) {
    return 0;
  }
  uint64_t result = fpfsi_UpdateResourceSpecifierOnResourceArbiter(a1);
  if (!result)
  {
    uint64_t result = fpfsi_SetupResolutionCapFilter(a1);
    if (!result)
    {
      uint64_t result = fpfsi_CreateAndAddCombinedAudioPreferenceFilter(a1);
      if (!result)
      {
        CFArrayRef v6 = *(const void **)(v3 + 40);
        return FigAlternateSelectionBossApplyFilters(v6);
      }
    }
  }
  return result;
}

uint64_t fpfsi_UpdateResourceSpecifierOnResourceArbiter(uint64_t a1)
{
  CFTypeRef cf = 0;
  long long v19 = *MEMORY[0x1E4F1DB30];
  uint64_t v17 = 0;
  CFTypeRef v18 = 0;
  uint64_t GlobalSingleton = FigPlayerResourceArbiterGetGlobalSingleton(&v17);
  if (!GlobalSingleton)
  {
    if (!a1
      || (uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(),
          uint64_t v4 = CMBaseObjectGetDerivedStorage(),
          *(void *)(v4 + 80) != a1)
      || (v5 = v4, uint64_t v6 = CMBaseObjectGetDerivedStorage(), !*(void *)(v6 + 40))
      || !*(unsigned char *)(v6 + 48)
      || !*(unsigned char *)(v6 + 49))
    {
      uint64_t v12 = 0;
      goto LABEL_24;
    }
    uint64_t GlobalSingleton = FigPlayerResourceArbiterPlayerSpecifierCreate((uint64_t *)&v18);
    if (!GlobalSingleton)
    {
      double ResolutionCapForFilter = fpfsi_GetResolutionCapForFilter(a1, 0);
      uint64_t GlobalSingleton = FigPlayerResourceArbiterPlayerSpecifierSetDisplaySize((uint64_t)v18, ResolutionCapForFilter, v8);
      if (!GlobalSingleton)
      {
        uint64_t v9 = *(void *)(DerivedStorage + 40);
        uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
        uint64_t GlobalSingleton = FigAlternateSelectionBossCopyProperty(v9, @"AlternateList", AllocatorForMedia, (const __CFArray **)&cf);
        if (!GlobalSingleton)
        {
          if (!FigStreamAlternateCopyMaximumVideoResolution((CFArrayRef)cf, (double *)&v19)
            || (uint64_t GlobalSingleton = FigPlayerResourceArbiterPlayerSpecifierSetResolutionCeiling((uint64_t)v18, *(double *)&v19, *((double *)&v19 + 1)), !GlobalSingleton))
          {
            if (*(unsigned char *)(v5 + 521)) {
              char v11 = 1;
            }
            else {
              char v11 = *(unsigned char *)(v5 + 522) != 0;
            }
            FigPlayerResourceArbiterPlayerSpecifierSetIsMuted((uint64_t)v18, v11);
            int v13 = *(_DWORD *)(v5 + 808);
            if (v13 == 2)
            {
              CFArrayRef v14 = (const void **)&kFigPlayerRole_PIP;
            }
            else
            {
              if (v13 != 1)
              {
                CFArrayRef v15 = 0;
                goto LABEL_22;
              }
              CFArrayRef v14 = (const void **)&kFigPlayerRole_Scanning;
            }
            CFArrayRef v15 = *v14;
LABEL_22:
            FigPlayerResourceArbiterPlayerSpecifierSetPlayerRole((uint64_t)v18, v15);
            FigPlayerResourceArbiterPlayerSpecifierSetIsFullyActive((uint64_t)v18, *(_DWORD *)(v5 + 32) == 2);
            uint64_t GlobalSingleton = FigPlayerResourceArbiterSetSpecifierForConsumer(v17, v18, *(void *)(v5 + 864));
          }
        }
      }
    }
  }
  uint64_t v12 = GlobalSingleton;
LABEL_24:
  if (cf) {
    CFRelease(cf);
  }
  if (v18) {
    CFRelease(v18);
  }
  return v12;
}

uint64_t fpfsi_SetupResolutionCapFilter(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  char v33 = 0;
  double ResolutionCapForFilter = fpfsi_GetResolutionCapForFilter(a1, &v33);
  double v5 = v4;
  double v6 = *(double *)(DerivedStorage + 2504);
  double v7 = *(double *)(DerivedStorage + 2512);
  CFTypeRef cf = 0;
  unint64_t v37 = 0;
  uint64_t v8 = CMBaseObjectGetDerivedStorage();
  uint64_t v9 = CMBaseObjectGetDerivedStorage();
  uint64_t v36 = 0;
  uint64_t GlobalSingleton = FigPlayerResourceArbiterGetGlobalSingleton(&v36);
  if (GlobalSingleton || !v36) {
    goto LABEL_9;
  }
  if (*(float *)(v8 + 3180) != 0.0)
  {
    uint64_t GlobalSingleton = FigPlayerResourceArbiterGetBudgetForConsumer(v36, *(void *)(v9 + 864), &v37);
    if (GlobalSingleton) {
      BOOL v11 = 1;
    }
    else {
      BOOL v11 = v37 == 0;
    }
    if (!v11)
    {
      if (v37 == (unint64_t)(ResolutionCapForFilter * v5)) {
        goto LABEL_12;
      }
      float v14 = *(float *)(v8 + 3180);
      double v12 = sqrtf(v14 * (float)v37);
      double v13 = sqrtf((float)v37 / v14);
      if (!dword_1E9350BB0) {
        goto LABEL_26;
      }
      unsigned int v35 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v16 = v35;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v17 = v16;
      }
      else {
        unsigned int v17 = v16 & 0xFFFFFFFE;
      }
      if (!v17)
      {
LABEL_25:
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        goto LABEL_26;
      }
      uint64_t v18 = *(void *)v8;
      if (v18)
      {
        long long v19 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        if (a1)
        {
LABEL_20:
          uint64_t v20 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
LABEL_24:
          int v38 = 136317186;
          CMTime v39 = "fpfsi_UpdateResolutionCapWithBudgetFromArbiter";
          __int16 v40 = 2048;
          uint64_t v41 = v18;
          __int16 v42 = 2082;
          uint64_t v43 = v19;
          __int16 v44 = 2048;
          uint64_t v45 = a1;
          __int16 v46 = 2082;
          uint64_t v47 = v20;
          __int16 v48 = 2048;
          double v49 = ResolutionCapForFilter;
          __int16 v50 = 2048;
          double v51 = v5;
          __int16 v52 = 2048;
          double v53 = v12;
          __int16 v54 = 2048;
          double v55 = v13;
          _os_log_send_and_compose_impl();
          goto LABEL_25;
        }
      }
      else
      {
        long long v19 = "";
        if (a1) {
          goto LABEL_20;
        }
      }
      uint64_t v20 = "";
      goto LABEL_24;
    }
LABEL_9:
    if (GlobalSingleton) {
      return GlobalSingleton;
    }
    goto LABEL_27;
  }
LABEL_12:
  double v12 = ResolutionCapForFilter;
  double v13 = v5;
LABEL_26:
  double v5 = v13;
  double ResolutionCapForFilter = v12;
LABEL_27:
  double v22 = *MEMORY[0x1E4F1DB30];
  double v21 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
  BOOL v23 = v5 == v21 && ResolutionCapForFilter == *MEMORY[0x1E4F1DB30];
  if (!v23 && !v33) {
    goto LABEL_37;
  }
  uint64_t v24 = FigAlternateSelectionBossRemoveFilter(*(void *)(DerivedStorage + 40), @"DisplaySize");
  if (v24) {
    return v24;
  }
  if (!v33 || v23)
  {
LABEL_37:
    uint64_t v24 = FigAlternateSelectionBossRemoveFilter(*(void *)(DerivedStorage + 40), @"ResolutionCap");
    if (!v24) {
      goto LABEL_38;
    }
    return v24;
  }
LABEL_38:
  BOOL v26 = v7 == v21 && v6 == v22;
  if (v26)
  {
    uint64_t v24 = FigAlternateSelectionBossRemoveFilter(*(void *)(DerivedStorage + 40), @"ResolutionFloor");
    if (v24) {
      return v24;
    }
  }
  if (v23)
  {
    uint64_t GlobalSingleton = 0;
  }
  else
  {
    CFAllocatorRef v27 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v33) {
      uint64_t v28 = FigAlternateResolutionCapFilterCreate(v27, @"ResolutionCap", 700, &cf, ResolutionCapForFilter, v5);
    }
    else {
      uint64_t v28 = FigAlternateDisplaySizeFilterCreate(v27, &cf, ResolutionCapForFilter, v5);
    }
    uint64_t GlobalSingleton = v28;
    CFTypeRef v29 = cf;
    if (v28) {
      goto LABEL_54;
    }
    uint64_t GlobalSingleton = FigAlternateSelectionBossAddFilter(*(void *)(DerivedStorage + 40), cf);
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
  }
  if (v26) {
    return GlobalSingleton;
  }
  uint64_t v30 = FigAlternateResolutionFloorFilterCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], &cf, v6, v7);
  CFTypeRef v29 = cf;
  if (v30)
  {
    uint64_t GlobalSingleton = v30;
    if (!cf) {
      return GlobalSingleton;
    }
    goto LABEL_55;
  }
  uint64_t GlobalSingleton = FigAlternateSelectionBossAddFilter(*(void *)(DerivedStorage + 40), cf);
  CFTypeRef v29 = cf;
LABEL_54:
  if (v29) {
LABEL_55:
  }
    CFRelease(v29);
  return GlobalSingleton;
}

uint64_t fpfsi_CreateAndAddCombinedAudioPreferenceFilter(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMBaseObjectGetDerivedStorage();
  AudioDeviceMaxPhysicalOutputChannelCFIndex Count = 0;
  CFTypeRef v58 = 0;
  CMTime v59 = 0;
  CFTypeRef v56 = 0;
  CFTypeRef cf = 0;
  char v55 = 0;
  __int16 v54 = 0;
  if (*(unsigned char *)(DerivedStorage + 779)) {
    int v3 = 1836019574;
  }
  else {
    int v3 = 1936684398;
  }
  char v53 = 0;
  if (!*(void *)(DerivedStorage + 40))
  {
    uint64_t v48 = 0;
LABEL_79:
    CGFloat v20 = 0.0;
    goto LABEL_66;
  }
  uint64_t v4 = fpfsi_CreateAudioSpatialSourcesArray(a1, v3, (__CFArray **)&v56, &AudioDeviceMaxPhysicalOutputChannelCount, (uint64_t)&v53);
  if (v4)
  {
    uint64_t v48 = v4;
    goto LABEL_79;
  }
  if (FigCFArrayContainsInt32()) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = FigCFArrayContainsInt32() != 0;
  }
  CFTypeRef v6 = v56;
  uint64_t v7 = CMBaseObjectGetDerivedStorage();
  CFDictionaryRef dict = 0;
  uint64_t v8 = (double *)MEMORY[0x1E4F1DB30];
  CGSize size = (CGSize)*MEMORY[0x1E4F1DB30];
  double ResolutionCapForFilter = fpfsi_GetResolutionCapForFilter(a1, 0);
  double v11 = v10;
  if (fpfsi_ResolveSpatialAudioResolutionCutoffSize_onceToken != -1) {
    dispatch_once(&fpfsi_ResolveSpatialAudioResolutionCutoffSize_onceToken, &__block_literal_global_9);
  }
  double width = *(double *)&fpfsi_ResolveSpatialAudioResolutionCutoffSize_defaultSpatialAudioResolutionCutoffSize_0;
  double height = *(double *)&fpfsi_ResolveSpatialAudioResolutionCutoffSize_defaultSpatialAudioResolutionCutoffSize_1;
  uint64_t v14 = *(void *)(v7 + 40);
  uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
  FigAlternateSelectionBossCopyProperty(v14, @"HighestVideoResolutionAlternateWithMultiChannelAudio", AllocatorForMedia, &dict);
  if (CGSizeMakeWithDictionaryRepresentation(dict, &size) && size.width < width && size.height < height)
  {
    double height = size.height;
    double width = size.width;
  }
  double v17 = *v8;
  double v16 = v8[1];
  if (dict) {
    CFRelease(dict);
  }
  BOOL v18 = v17 != ResolutionCapForFilter;
  if (v16 != v11) {
    BOOL v18 = 1;
  }
  if (ResolutionCapForFilter >= width) {
    BOOL v18 = 0;
  }
  if (!v18 || v11 >= height)
  {
    double ResolutionCapForFilter = width;
    double v11 = height;
  }
  if (!AudioDeviceMaxPhysicalOutputChannelCount) {
    AudioDeviceMaxPhysicalOutputChannelCFIndex Count = fpfs_GetAudioDeviceMaxPhysicalOutputChannelCount(a1, 0, 0);
  }
  int v19 = *(_DWORD *)(DerivedStorage + 560);
  if (v53)
  {
    if ((v19 & 2) != 0) {
      goto LABEL_29;
    }
LABEL_28:
    CGFloat v20 = 0.0;
    goto LABEL_30;
  }
  char v53 = v19 & 1;
  if ((v19 & 2) == 0) {
    goto LABEL_28;
  }
LABEL_29:
  size.double width = 0.0;
  uint64_t v21 = CMBaseObjectGetDerivedStorage();
  CGFloat v20 = 0.0;
  if (*(void *)(v21 + 504)) {
    goto LABEL_30;
  }
  CGFloat v20 = *(double *)(v21 + 536);
  if (v20 == 0.0) {
    goto LABEL_30;
  }
  uint64_t v39 = FigGetAllocatorForMedia();
  uint64_t v40 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (!v40) {
    goto LABEL_28;
  }
  uint64_t v41 = *(void (**)(void, void, uint64_t, CGSize *))(v40 + 48);
  if (!v41) {
    goto LABEL_28;
  }
  v41(*(void *)&v20, *MEMORY[0x1E4F75F30], v39, &size);
  CGFloat v20 = size.width;
LABEL_30:
  CFAllocatorRef v22 = (const __CFAllocator *)FigGetAllocatorForMedia();
  FPSupport_CreateMaxSampleRateDictonary(v22, AudioDeviceMaxPhysicalOutputChannelCount, *(const __CFData **)&v20, (CFMutableDictionaryRef *)&v58, *(double *)(DerivedStorage + 2520));
  uint64_t v23 = CMBaseObjectGetDerivedStorage();
  if (*(void *)(v23 + 536)) {
    BOOL v24 = *(unsigned char *)(v23 + 562) != 0;
  }
  else {
    BOOL v24 = 0;
  }
  CMBaseObjectGetDerivedStorage();
  CMBaseObjectGetDerivedStorage();
  int v25 = FigCFEqual();
  fpfsi_CopyCacheRefFromPump(a1, &v59);
  int v26 = FigGetAllocatorForMedia();
  CFAllocatorRef v27 = v59;
  CFArrayRef v28 = *(const __CFArray **)(DerivedStorage + 1792);
  LOBYTE(size.width) = v5;
  *(_WORD *)((char *)&size.width + 1) = v54;
  BYTE3(size.width) = v55;
  HIDWORD(size.width) = v3;
  size.double height = ResolutionCapForFilter;
  double v51 = v11;
  CFTypeRef v52 = v6;
  uint64_t v29 = FigAlternateCombinedAudioPreferenceFilterCreate(v26, 0, AudioDeviceMaxPhysicalOutputChannelCount, v58, (uint64_t)&size, v24 | (v25 << 24), v53, (uint64_t)v59, v28, &cf);
  if (v29 || (uint64_t v29 = FigAlternateSelectionBossAddFilter(*(void *)(DerivedStorage + 40), cf), v29))
  {
    uint64_t v48 = v29;
    if (v27) {
LABEL_65:
    }
      CFRelease(v27);
  }
  else
  {
    int v30 = *(_DWORD *)(DerivedStorage + 560);
    uint64_t v31 = *(void *)(DerivedStorage + 2544);
    if (v31)
    {
      uint64_t v32 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v33 = v32 ? v32 : 0;
      uint64_t v34 = *(void (**)(uint64_t, uint64_t, uint64_t, BOOL, void))(v33 + 56);
      if (v34) {
        v34(v31, 0x1EE582B78, 0x1EE5622F8, (v30 & 1) == 0, 0);
      }
    }
    if (v30)
    {
      CFNumberRef v35 = 0;
    }
    else
    {
      CFNumberRef v35 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, (const void *)(DerivedStorage + 2520));
      uint64_t v36 = *(void *)(DerivedStorage + 2544);
      if (v36)
      {
        uint64_t v37 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v38 = v37 ? v37 : 0;
        __int16 v42 = *(void (**)(uint64_t, uint64_t, uint64_t, CFNumberRef, void))(v38 + 48);
        if (v42) {
          v42(v36, 0x1EE582B78, 0x1EE562318, v35, 0);
        }
      }
    }
    if (*(unsigned char *)(DerivedStorage + 894)) {
      uint64_t v43 = (4 * (*(unsigned char *)(DerivedStorage + 893) != 0)) | 3u;
    }
    else {
      uint64_t v43 = 4 * (*(unsigned char *)(DerivedStorage + 893) != 0);
    }
    uint64_t v44 = *(void *)(DerivedStorage + 2544);
    if (v44)
    {
      uint64_t v45 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v46 = v45 ? v45 : 0;
      uint64_t v47 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v46 + 56);
      if (v47) {
        v47(v44, 0x1EE582B78, 0x1EE562298, v43, 0);
      }
    }
    if (v35) {
      CFRelease(v35);
    }
    uint64_t v48 = 0;
    if (v27) {
      goto LABEL_65;
    }
  }
LABEL_66:
  if (cf) {
    CFRelease(cf);
  }
  if (v20 != 0.0) {
    CFRelease(*(CFTypeRef *)&v20);
  }
  if (v58) {
    CFRelease(v58);
  }
  if (v56) {
    CFRelease(v56);
  }
  return v48;
}

double fpfsi_GetResolutionCapForFilter(uint64_t a1, unsigned char *a2)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = CMBaseObjectGetDerivedStorage();
  BOOL v5 = (_OWORD *)MEMORY[0x1E4F1DB30];
  double v6 = *MEMORY[0x1E4F1DB30];
  double v7 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
  BOOL v8 = *(double *)(DerivedStorage + 2496) != v7 || *(double *)(DerivedStorage + 2488) != *MEMORY[0x1E4F1DB30];
  if (v8) {
    double v9 = *(double *)(DerivedStorage + 2496);
  }
  else {
    double v9 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
  }
  if (v8) {
    double v10 = *(double *)(DerivedStorage + 2488);
  }
  else {
    double v10 = *MEMORY[0x1E4F1DB30];
  }
  if (v10 != v6 || v9 != v7)
  {
    double v18 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
    double v17 = *MEMORY[0x1E4F1DB30];
    if (a2) {
      goto LABEL_99;
    }
    goto LABEL_100;
  }
  uint64_t v12 = v4;
  double v13 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
  double v14 = *MEMORY[0x1E4F1DB30];
  if (!CelestialIsAppleTV())
  {
    double v13 = v7;
    double v14 = v6;
    if (!fpfs_isExternalVideoOutput())
    {
      *(_OWORD *)CFNumberRef number = *v5;
      uint64_t valuePtr = 0;
      CelestialGetModelSpecificResolutionCap();
      double v14 = *(double *)number;
      double v13 = *(double *)&number[1];
      uint64_t v24 = *(void *)(DerivedStorage + 2544);
      if (v24)
      {
        uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v25) {
          uint64_t v26 = v25;
        }
        else {
          uint64_t v26 = 0;
        }
        double v51 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v26 + 56);
        if (v51) {
          v51(v24, 0x1EE582B78, 0x1EE562118, (uint64_t)*(double *)number, 0);
        }
        uint64_t v52 = *(void *)(DerivedStorage + 2544);
        if (v52)
        {
          uint64_t v53 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v54 = v53 ? v53 : 0;
          char v55 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v54 + 56);
          if (v55) {
            v55(v52, 0x1EE582B78, 0x1EE562138, (uint64_t)*(double *)&number[1], 0);
          }
        }
      }
    }
  }
  CFArrayRef v15 = (double *)(DerivedStorage + 752);
  double v16 = (double *)(DerivedStorage + 760);
  if (*(unsigned char *)(v12 + 462))
  {
    double v16 = (double *)(v12 + 472);
    CFArrayRef v15 = (double *)(v12 + 464);
  }
  double v17 = *v15;
  double v18 = *v16;
  BOOL v19 = *v15 == v6 && v18 == v7;
  CGFloat v20 = &PerformOneTimeAssetTableInitialization_sAssetTableInit;
  if (!v19)
  {
    BOOL v21 = v14 != v6;
    if (v13 != v7) {
      BOOL v21 = 1;
    }
    if (v17 <= v14) {
      BOOL v21 = 0;
    }
    BOOL v22 = v18 > v13;
    if (v21 && v22) {
      double v9 = v13;
    }
    else {
      double v9 = v18;
    }
    if (v21 && v22) {
      double v10 = v14;
    }
    else {
      double v10 = v17;
    }
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      CGFloat v20 = &PerformOneTimeAssetTableInitialization_sAssetTableInit;
    }
  }
  if (v10 != v6 || v9 != v7) {
    goto LABEL_98;
  }
  if (*(double *)(v12 + 440) == v6 && *(double *)(v12 + 448) == v7)
  {
    CFArrayRef v29 = *(const __CFArray **)(v12 + 432);
    if (!v29 || !CFArrayGetCount(v29)) {
      goto LABEL_96;
    }
  }
  uint64_t v30 = CMBaseObjectGetDerivedStorage();
  uint64_t v31 = CMBaseObjectGetDerivedStorage();
  double v32 = v7;
  double v33 = v6;
  if (!*(void *)(v31 + 40)) {
    goto LABEL_72;
  }
  double v32 = v7;
  double v33 = v6;
  if (!*(unsigned char *)(v31 + 48)) {
    goto LABEL_72;
  }
  double v32 = v7;
  double v33 = v6;
  if (!*(unsigned char *)(v31 + 49)) {
    goto LABEL_72;
  }
  double v32 = v7;
  double v33 = v6;
  if (*(float *)(v30 + 3180) == 0.0) {
    goto LABEL_72;
  }
  CMTimeScale v77 = a2;
  uint64_t v34 = CMBaseObjectGetDerivedStorage();
  CFIndex v35 = 0;
  int v36 = 0;
  LODWORD(valuePtr) = 0;
  while (1)
  {
    CFArrayRef Count = *(const __CFArray **)(v34 + 432);
    if (Count) {
      CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
    }
    if (v35 >= (uint64_t)Count) {
      break;
    }
    number[0] = 0;
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v34 + 432), v35);
    uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
    uint64_t CMBaseObject = FigVideoTargetGetCMBaseObject(ValueAtIndex);
    uint64_t v41 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v41) {
      uint64_t v42 = v41;
    }
    else {
      uint64_t v42 = 0;
    }
    uint64_t v43 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFNumberRef *))(v42 + 48);
    if (!v43) {
      goto LABEL_66;
    }
    int v44 = v43(CMBaseObject, @"DesiredPixelCount", AllocatorForMedia, number);
    CFNumberRef v45 = number[0];
    if (!v44 && number[0])
    {
      CFNumberGetValue(number[0], kCFNumberSInt32Type, &valuePtr);
      if ((int)valuePtr > v36) {
        int v36 = valuePtr;
      }
LABEL_66:
      CFNumberRef v45 = number[0];
    }
    if (v45) {
      CFRelease(v45);
    }
    ++v35;
  }
  double v32 = v7;
  double v33 = v6;
  a2 = v77;
  CGFloat v20 = &PerformOneTimeAssetTableInitialization_sAssetTableInit;
  if (v36)
  {
    float v46 = *(float *)(v30 + 3180);
    double v33 = sqrtf(v46 * (float)v36);
    double v32 = sqrtf((float)v36 / v46);
  }
LABEL_72:
  double v47 = *(double *)(v12 + 440);
  double v48 = *(double *)(v12 + 448);
  if (v32 * v33 > v47 * v48) {
    double v9 = v32;
  }
  else {
    double v9 = *(double *)(v12 + 448);
  }
  if (v32 * v33 > v47 * v48) {
    double v10 = v33;
  }
  else {
    double v10 = *(double *)(v12 + 440);
  }
  if ((v14 != v6 || v13 != v7) && v10 * v9 > v13 * v14)
  {
    double v9 = v13;
    double v10 = v14;
  }
  int v49 = *((_DWORD *)v20 + 748);
  if (v32 * v33 > v47 * v48)
  {
    if (v49) {
      goto LABEL_86;
    }
  }
  else if (v49)
  {
LABEL_86:
    __int16 v50 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
LABEL_96:
  if (v10 == v6 && v9 == v7)
  {
    double v9 = v13;
    double v10 = v14;
  }
LABEL_98:
  if (a2) {
LABEL_99:
  }
    *a2 = v8;
LABEL_100:
  uint64_t v56 = *(void *)(DerivedStorage + 2544);
  if (v56)
  {
    uint64_t v57 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v57) {
      uint64_t v58 = v57;
    }
    else {
      uint64_t v58 = 0;
    }
    CMTime v59 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v58 + 56);
    if (v59) {
      v59(v56, 0x1EE582B78, 0x1EE5620D8, (uint64_t)v18, 0);
    }
    uint64_t v60 = *(void *)(DerivedStorage + 2544);
    if (v60)
    {
      uint64_t v61 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v61) {
        uint64_t v62 = v61;
      }
      else {
        uint64_t v62 = 0;
      }
      uint64_t v63 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v62 + 56);
      if (v63) {
        v63(v60, 0x1EE582B78, 0x1EE5620F8, (uint64_t)v17, 0);
      }
      uint64_t v64 = *(void *)(DerivedStorage + 2544);
      if (v64)
      {
        uint64_t v65 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v65) {
          uint64_t v66 = v65;
        }
        else {
          uint64_t v66 = 0;
        }
        Float64 v67 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v66 + 56);
        if (v67) {
          v67(v64, 0x1EE582B78, 0x1EE562198, (uint64_t)v9, 0);
        }
        uint64_t v68 = *(void *)(DerivedStorage + 2544);
        if (v68)
        {
          uint64_t v69 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v69) {
            uint64_t v70 = v69;
          }
          else {
            uint64_t v70 = 0;
          }
          uint64_t v71 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v70 + 56);
          if (v71) {
            v71(v68, 0x1EE582B78, 0x1EE5621B8, (uint64_t)v10, 0);
          }
          uint64_t v72 = *(void *)(DerivedStorage + 2544);
          if (v72)
          {
            uint64_t v73 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v73) {
              uint64_t v74 = v73;
            }
            else {
              uint64_t v74 = 0;
            }
            uint64_t v75 = *(void (**)(uint64_t, uint64_t, uint64_t, BOOL, void))(v74 + 56);
            if (v75) {
              v75(v72, 0x1EE582B78, 0x1EE5621D8, v8, 0);
            }
          }
        }
      }
    }
  }
  return v10;
}

BOOL fpfs_shouldApplyResolutionCapForBuiltinDisplay()
{
  return !CelestialIsAppleTV() && fpfs_isExternalVideoOutput() == 0;
}

uint64_t fpfs_isExternalVideoOutput()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef v1 = *(const __CFArray **)(DerivedStorage + 672);
  if (!v1)
  {
    uint64_t IsExternalDisplay = 0;
    goto LABEL_12;
  }
  if (CFArrayGetCount(v1) < 1)
  {
    uint64_t IsExternalDisplay = 0;
LABEL_12:
    CFStringRef v6 = FPSupport_CopyMainDisplayCAName();
    if (v6)
    {
      CFStringRef v7 = v6;
      uint64_t IsExternalDisplay = FPSupport_IsExternalDisplay(v6);
      CFRelease(v7);
    }
    goto LABEL_14;
  }
  CFIndex v2 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 672), v2);
    if (FPSupport_IsExternalDisplay(ValueAtIndex)) {
      break;
    }
    CFArrayRef v4 = *(const __CFArray **)(DerivedStorage + 672);
    if (v4)
    {
      if (CFArrayGetCount(v4) > ++v2) {
        continue;
      }
    }
    uint64_t IsExternalDisplay = 0;
    goto LABEL_11;
  }
  uint64_t IsExternalDisplay = 1;
LABEL_11:
  if (!ValueAtIndex) {
    goto LABEL_12;
  }
LABEL_14:
  if (!IsExternalDisplay) {
    return *(unsigned __int8 *)(CMBaseObjectGetDerivedStorage() + 462);
  }
  return IsExternalDisplay;
}

uint64_t fpfsi_CreateAudioSpatialSourcesArray(uint64_t a1, int a2, __CFArray **a3, int *a4, uint64_t a5)
{
  int v36 = 0;
  unsigned __int8 v35 = 0;
  CFDictionaryRef theDict = 0;
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage();
  if (*(void *)(CMBaseObjectGetDerivedStorage() + 504)) {
    goto LABEL_56;
  }
  uint64_t v10 = *(void *)(CMBaseObjectGetDerivedStorage() + 536);
  if (!v10) {
    return 0;
  }
  if (FPSupport_CreateAudioSessionSpatializationCapabilities(v10, a2, (CFTypeRef *)&theDict))
  {
LABEL_56:
    uint64_t v18 = 0;
    goto LABEL_57;
  }
  if (!theDict) {
    return 0;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"SpatialCapabilitiesKey_spatialAudioSources");
  if (!Value) {
    goto LABEL_56;
  }
  CFArrayRef v12 = Value;
  CFTypeID v13 = CFGetTypeID(Value);
  if (v13 != CFArrayGetTypeID()) {
    goto LABEL_56;
  }
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFMutableArrayRef Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    double v16 = Mutable;
    FigCFDictionaryGetBooleanIfPresent();
    uint64_t v31 = a4;
    if (DerivedStorage[893] | v35)
    {
      CMBaseObjectGetDerivedStorage();
      BOOL v17 = FigCFEqual() || FigCFEqual() || FigCFEqual() != 0;
    }
    else
    {
      BOOL v17 = 0;
    }
    if (CFArrayGetCount(v12) >= 1)
    {
      CFIndex v19 = 0;
      int v20 = 0;
      double v32 = (const void *)*MEMORY[0x1E4F1CFC8];
      do
      {
        int valuePtr = 1064530531;
        CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v12, v19);
        CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
        if (valuePtr <= 1835824232)
        {
          if (valuePtr != 1064530531)
          {
            if (valuePtr == 1651076712 && v17) {
              CFArrayAppendValue(v16, ValueAtIndex);
            }
            goto LABEL_49;
          }
          if ((DerivedStorage[560] & 8) != 0)
          {
            uint64_t v28 = CMBaseObjectGetDerivedStorage();
            if (!*(void *)(v28 + 536))
            {
              FigCFArrayAppendInt32();
LABEL_48:
              FigCFArrayAppendInt32();
              int v36 = 16;
              goto LABEL_49;
            }
            int v29 = *(unsigned __int8 *)(v28 + 562);
            FigCFArrayAppendInt32();
            if (!v29) {
              goto LABEL_48;
            }
          }
        }
        else if (valuePtr == 1836020596)
        {
          if (!v20)
          {
            if (!(DerivedStorage[894] | v35)) {
              goto LABEL_46;
            }
            CFArrayAppendValue(v16, ValueAtIndex);
LABEL_41:
            int v20 = 1;
          }
        }
        else
        {
          if (valuePtr != 1836020523)
          {
            if (valuePtr == 1835824233 && v17)
            {
              CFArrayAppendValue(v16, ValueAtIndex);
              FigCFDictionaryGetInt32IfPresent();
            }
            goto LABEL_49;
          }
          if (v20) {
            BOOL v23 = 0;
          }
          else {
            BOOL v23 = v17;
          }
          if (v23)
          {
            uint64_t v24 = CMBaseObjectGetDerivedStorage();
            CFTypeRef cf = v32;
            uint64_t v25 = *(void *)(v24 + 40);
            if (!v25) {
              goto LABEL_46;
            }
            uint64_t v26 = FigGetAllocatorForMedia();
            if (FigAlternateSelectionBossCopyProperty(v25, @"HasPlayableMultiChannelAudio", v26, (const __CFArray **)&cf))goto LABEL_46; {
            int v27 = FigCFEqual();
            }
            if (cf) {
              CFRelease(cf);
            }
            if (!v27)
            {
LABEL_46:
              int v20 = 0;
              goto LABEL_49;
            }
            FigCFArrayAppendInt32();
            goto LABEL_41;
          }
        }
LABEL_49:
        ++v19;
      }
      while (v19 < CFArrayGetCount(v12));
    }
    if (v31) {
      *uint64_t v31 = v36;
    }
    if (a5) {
      FigCFDictionaryGetBooleanIfPresent();
    }
    if (a3)
    {
      uint64_t v18 = 0;
      *a3 = v16;
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  uint64_t v18 = FigSignalErrorAt();
LABEL_57:
  if (theDict) {
    CFRelease(theDict);
  }
  return v18;
}

uint64_t fpfs_GetAudioDeviceMaxPhysicalOutputChannelCount(uint64_t a1, int a2, int a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    if (a3)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
      uint64_t result = 0;
      if (a3 == 1633889587 && *(void *)(DerivedStorage + 536))
      {
        if (*(unsigned char *)(DerivedStorage + 562)) {
          return 6;
        }
        else {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v7 = CMBaseObjectGetDerivedStorage();
    if (FigCFEqual())
    {
      return 2;
    }
    else if (*(void *)(v7 + 504))
    {
      unsigned int valuePtr = 2;
      uint64_t v8 = CMBaseObjectGetDerivedStorage();
      CFTypeRef v22 = 0;
      CFTypeRef cf = 0;
      if (*(void *)(CMBaseObjectGetDerivedStorage() + 504))
      {
        uint64_t v9 = *(void *)(v8 + 504);
        uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
        uint64_t CMBaseObject = FigBufferedAirPlayOutputGetCMBaseObject(v9);
        uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v12) {
          uint64_t v13 = v12;
        }
        else {
          uint64_t v13 = 0;
        }
        double v14 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v13 + 48);
        if (v14 && !v14(CMBaseObject, @"AtmosIsSupported", AllocatorForMedia, &cf))
        {
          if (FigCFEqual())
          {
            unsigned int valuePtr = 16;
          }
          else
          {
            uint64_t v15 = *(void *)(v8 + 504);
            uint64_t v16 = FigGetAllocatorForMedia();
            uint64_t v17 = FigBufferedAirPlayOutputGetCMBaseObject(v15);
            uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 8);
            if (v18) {
              uint64_t v19 = v18;
            }
            else {
              uint64_t v19 = 0;
            }
            int v20 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v19 + 48);
            if (v20 && !v20(v17, @"MaximumNumberOfOutputChannels", v16, &v22)) {
              CFNumberGetValue((CFNumberRef)v22, kCFNumberSInt32Type, &valuePtr);
            }
          }
        }
      }
      else
      {
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      if (cf) {
        CFRelease(cf);
      }
      if (v22) {
        CFRelease(v22);
      }
      return valuePtr;
    }
    else
    {
      return fpfs_GetAudioDeviceMaxMixablePhysicalOutputChannelCountFromFigAudioSession();
    }
  }
  return result;
}

uint64_t fpfsi_CopyCacheRefFromPump(uint64_t a1, void *a2)
{
  uint64_t v12 = 0;
  uint64_t result = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(void *)(result + 936);
  if (v4)
  {
    uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
    uint64_t FigBaseObject = FigBytePumpGetFigBaseObject(v4);
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v9 = *(void *)(VTable + 8);
    uint64_t result = VTable + 8;
    uint64_t v8 = v9;
    if (v9) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = 0;
    }
    double v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v10 + 48);
    if (v11)
    {
      uint64_t result = v11(FigBaseObject, 0x1EE53E498, AllocatorForMedia, &v12);
      if (v12)
      {
        if (!result || result == -12783) {
          *a2 = v12;
        }
      }
    }
  }
  return result;
}

uint64_t fpfs_GetAudioDeviceMaxMixablePhysicalOutputChannelCountFromFigAudioSession()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = 2;
  unsigned int v4 = 2;
  uint64_t v2 = *(void *)(DerivedStorage + 536);
  if (v2)
  {
    AudioSessionOutputChannelCFArrayRef Count = FPSupport_GetAudioSessionOutputChannelCount(v2, (int *)&v4);
    uint64_t result = v4;
    if (!AudioSessionOutputChannelCount && v4 == 32)
    {
      if (*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561)) {
        return 16;
      }
      else {
        return v4;
      }
    }
  }
  return result;
}

void fpfs_TimeToPausePlaybackTimerProc(uint64_t a1)
{
  CFTypeRef v17 = 0;
  CFTypeRef v18 = 0;
  CMTime v16 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  if (fpfsi_CopyPlayerAndItemFromItemRetainProxyAndLockPlayer(a1, &v18, &v17))
  {
    CFTypeRef v3 = v17;
    if (v17) {
LABEL_6:
    }
      CFRelease(v3);
  }
  else
  {
    CFTypeRef v1 = v18;
    id v2 = *(id *)(CMBaseObjectGetDerivedStorage() + 776);
    voucher_adopt();
    CFTypeRef v3 = v17;
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    if ((*(unsigned char *)(DerivedStorage + 1460) & 1) == 0) {
      goto LABEL_4;
    }
    uint64_t v5 = DerivedStorage;
    CFStringRef v6 = (CMTime *)(DerivedStorage + 1448);
    memset(&fireTime, 0, sizeof(fireTime));
    fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&fireTime);
    fpfsi_EstimateTimeToPause((uint64_t)v3, &rhs);
    CMTime lhs = *v6;
    CMTimeSubtract(&v16, &lhs, &rhs);
    CMTime lhs = v16;
    *(_OWORD *)&v11.unsigned int value = kTimerVariability;
    v11.CMTimeEpoch epoch = 0;
    CMTimeSubtract(&time2, &lhs, &v11);
    CMTime lhs = fireTime;
    if (CMTimeCompare(&lhs, &time2) < 0)
    {
      CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CMTime fireTime = *v6;
      FigCFDictionarySetCMTime();
      fpfs_EnqueueNotification(v1, @"AlmostReachedTimeToPausePlayback", v3, Mutable);
      uint64_t v9 = *(OpaqueCMTimebase **)(v5 + 576);
      uint64_t v10 = *(NSObject **)(v5 + 2336);
      CMTime fireTime = v16;
      CMTimebaseSetTimerDispatchSourceNextFireTime(v9, v10, &fireTime, 0);
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
    else
    {
LABEL_4:
      fpfs_HandleReachingTimeToPausePlayback(v3);
    }

    fpfs_UnlockAndPostNotificationsWithCaller(v1);
    if (v3) {
      goto LABEL_6;
    }
  }
  if (v18) {
    CFRelease(v18);
  }
}

CMTime *fpfsi_EstimateTimeToPause@<X0>(uint64_t a1@<X0>, CMTime *a2@<X8>)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  memset(&v25, 0, sizeof(v25));
  CMTimeMake(&v25, 48, 1000);
  CMTime v24 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  uint64_t RenderingTrackofType = fpfs_FirstRenderingTrackofType(a1, 1986618469);
  if (RenderingTrackofType)
  {
    uint64_t v6 = *(void *)(RenderingTrackofType + 96);
    if (v6)
    {
      CFTypeRef cf = 0;
      uint64_t v7 = *(void *)(v6 + 32);
      uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
      uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v7);
      uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v11 + 48);
      if (v12)
      {
        v12(FigBaseObject, @"NextNonJerkyStopTime", AllocatorForMedia, &cf);
        CFDictionaryRef v13 = (const __CFDictionary *)cf;
      }
      else
      {
        CFDictionaryRef v13 = 0;
      }
      memset(&time1, 0, sizeof(time1));
      CMTimeMakeFromDictionary(&time1, v13);
      if (cf) {
        CFRelease(cf);
      }
      if ((time1.flags & 0x1D) == 1)
      {
        fpfs_GetTime(DerivedStorage, (uint64_t)&rhs);
        CMTime lhs = time1;
        CMTimeSubtract(&v24, &lhs, &rhs);
        CMTime time = v24;
        CMTimeMultiply(&lhs, &time, 2);
        CMTime v24 = lhs;
      }
    }
  }
  uint64_t v14 = fpfs_FirstRenderingTrackofType(a1, 1936684398);
  if (v14)
  {
    uint64_t v15 = *(const opaqueCMFormatDescription **)(v14 + 40);
    if (v15)
    {
      StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(v15);
      if (StreamBasicDescription)
      {
        CMTimeMake(&time1, StreamBasicDescription->mFramesPerPacket, (int)StreamBasicDescription->mSampleRate);
        CMTime v25 = time1;
        CMTimeMake(&v18, 25, 1000);
        CMTime lhs = v25;
        CMTimeAdd(&time1, &lhs, &v18);
        CMTime v25 = time1;
      }
    }
  }
  CMTime time1 = v25;
  CMTime lhs = v24;
  return CMTimeMaximum(a2, &time1, &lhs);
}

void fpfsi_clearCoordinatedPlaybackSynchronizationTimebase()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFTypeRef v1 = *(const void **)(DerivedStorage + 568);
  if (v1)
  {
    if (!dword_1E9350BB0
      || (os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(),
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT),
          fig_log_call_emit_and_clean_up_after_send_and_compose(),
          (CFTypeRef v1 = *(const void **)(DerivedStorage + 568)) != 0))
    {
      CFRelease(v1);
      *(void *)(DerivedStorage + 568) = 0;
    }
  }
}

uint64_t fpfs_setRateInternal(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, float a5)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef Next = fpfs_getNext(DerivedStorage, 0);
  if (a2) {
    CFStringRef v11 = a2;
  }
  else {
    CFStringRef v11 = (const __CFString *)Next;
  }
  if (!v11) {
    return (uint64_t)v11;
  }
  CFStringRef v12 = (const __CFString *)Next;
  uint64_t v13 = CMBaseObjectGetDerivedStorage();
  float v14 = *(float *)(v13 + 848);
  if (v14 == a5) {
    return 0;
  }
  if (v11 != v12) {
    return 4294954436;
  }
  uint64_t v15 = v13;
  if (*(unsigned char *)(v13 + 3233)) {
    return 0;
  }
  uint64_t v16 = *(void *)(v13 + 1704);
  if (!v16)
  {
    BOOL v18 = 0;
    BOOL v19 = a5 != 0.0;
    goto LABEL_15;
  }
  int IsIFrameOnly = FigAlternateIsIFrameOnly(v16);
  BOOL v18 = IsIFrameOnly != 0;
  BOOL v19 = a5 != 0.0;
  if (a5 == 0.0 || !IsIFrameOnly)
  {
LABEL_15:
    fpfsi_scheduleFVTTransitionsForItem(v12, 0, 1);
    if (!*(unsigned char *)(v15 + 464))
    {
      fpfsi_setItemRateTimebaseAndAnchor(0.0, (uint64_t)v12, 1, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8]);
LABEL_156:
      if (*(float *)(v15 + 848) == 0.0)
      {
        fpfs_GetTime(v15, (uint64_t)&v104);
        CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
        if (CMTimeCompare(&v104, &time2) < 0) {
          fpfs_JumpToTime(v12, MEMORY[0x1E4F1FA48], 0);
        }
      }
      fpfsi_updateItemTimePropertiesForRateChange((uint64_t)v12, v14);
      if (dword_1E9350BB0)
      {
        LODWORD(number.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(cf) = 0;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int value = number.value;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, (os_log_type_t)cf)) {
          unsigned int v93 = value;
        }
        else {
          unsigned int v93 = value & 0xFFFFFFFE;
        }
        if (v93)
        {
          if (a1) {
            CFTypeRef v94 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
          }
          else {
            CFTypeRef v94 = "";
          }
          uint64_t v95 = CMBaseObjectGetDerivedStorage() + 3080;
          double v96 = *(float *)(v15 + 848);
          fpfs_GetTime(v15, (uint64_t)&time);
          Float64 Seconds = CMTimeGetSeconds(&time);
          double v98 = *(float *)(DerivedStorage + 108);
          LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 136316930;
          *(CMTimeValue *)((char *)&time1.value + 4) = (CMTimeValue)"fpfs_setRateInternal";
          LOWORD(time1.flags) = 2048;
          *(void *)((char *)&time1.flags + 2) = a1;
          HIWORD(time1.epoch) = 2082;
          Float64 v111 = v94;
          __int16 v112 = 2048;
          CFStringRef v113 = v12;
          __int16 v114 = 2082;
          uint64_t v115 = v95;
          __int16 v116 = 2048;
          double v117 = v96;
          __int16 v118 = 2048;
          double v119 = Seconds;
          __int16 v120 = 2048;
          double v121 = v98;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      return 0;
    }
    LODWORD(v21) = *(unsigned __int8 *)(v15 + 2880);
    uint64_t v101 = DerivedStorage;
    if (!*(void *)(CMBaseObjectGetDerivedStorage() + 504) || v21)
    {
LABEL_52:
      char v34 = !v19;
      if (!v21) {
        char v34 = 1;
      }
      if ((v34 & 1) == 0)
      {
        *(unsigned char *)(v15 + 3233) = 1;
        uint64_t v35 = fpfsi_SeekToCurrentTime((const __CFArray *)v12);
        *(unsigned char *)(v15 + 3233) = 0;
        if (v35) {
          goto LABEL_173;
        }
      }
      if (a5 != 0.0
        || (CFTypeRef cf = 0, gPlayerStopMode != 1)
        || ((float v36 = *(float *)(DerivedStorage + 108), v36 > 2.0) || v36 < 0.0) && !*(void *)(v15 + 2968)
        || (uint64_t v37 = fpfs_FirstRenderingTrackofType((uint64_t)v12, 1986618469)) == 0
        || *(_DWORD *)(v37 + 152) != 6)
      {
LABEL_76:
        if (!v18)
        {
          uint64_t v46 = *(void *)(v15 + 1048);
          if (v46)
          {
            double v47 = (uint64_t *)MEMORY[0x1E4F1CFD0];
            if (a5 <= 1.0) {
              double v47 = (uint64_t *)MEMORY[0x1E4F1CFC8];
            }
            uint64_t v48 = *v47;
            do
            {
              if (*(_DWORD *)(v46 + 32) == 1986618469)
              {
                uint64_t v49 = *(void *)(v46 + 96);
                if (v49)
                {
                  uint64_t v50 = *(void *)(v49 + 32);
                  if (v50)
                  {
                    uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v50);
                    uint64_t v52 = *(void *)(CMBaseObjectGetVTable() + 8);
                    uint64_t v53 = v52 ? v52 : 0;
                    uint64_t v54 = *(void (**)(uint64_t, __CFString *, uint64_t))(v53 + 56);
                    if (v54) {
                      v54(FigBaseObject, @"AllowVideoQualityOfServiceAdjustments", v48);
                    }
                  }
                }
              }
              uint64_t v46 = *(void *)(v46 + 8);
            }
            while (v46);
          }
        }
        if (a5 < 0.0 && fpfsi_isItemPlayedOut((uint64_t)v12)) {
          *(unsigned char *)(v15 + 3064) = 1;
        }
        if (a5 != 0.0
          && (!*(unsigned char *)(v15 + 464)
           || (uint64_t RenderingTrackofType = fpfs_FirstRenderingTrackofType((uint64_t)v12, 1986618469)) != 0
           && *(unsigned char *)(RenderingTrackofType + 104)))
        {
          if (dword_1E9350BB0)
          {
            LODWORD(number.CFDictionarySetValue(theDict, key, value) = 0;
            LOBYTE(cf) = 0;
            uint64_t v60 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v61 = number.value;
            if (os_log_type_enabled(v60, (os_log_type_t)cf)) {
              unsigned int v62 = v61;
            }
            else {
              unsigned int v62 = v61 & 0xFFFFFFFE;
            }
            if (v62)
            {
              if (a1) {
                uint64_t v63 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
              }
              else {
                uint64_t v63 = "";
              }
              uint64_t v72 = CMBaseObjectGetDerivedStorage();
              int v73 = *(unsigned __int8 *)(v15 + 464);
              uint64_t v74 = "first rendering video track is in preroll";
              LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 136316674;
              *(CMTimeValue *)((char *)&time1.value + 4) = (CMTimeValue)"fpfs_setRateInternal";
              LOWORD(time1.flags) = 2048;
              *(void *)((char *)&time1.flags + 2) = a1;
              if (!v73) {
                uint64_t v74 = "item not ready";
              }
              HIWORD(time1.epoch) = 2082;
              Float64 v111 = v63;
              __int16 v112 = 2048;
              CFStringRef v113 = v12;
              __int16 v114 = 2082;
              uint64_t v115 = v72 + 3080;
              __int16 v116 = 2048;
              double v117 = a5;
              __int16 v118 = 2080;
              double v119 = *(double *)&v74;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          goto LABEL_138;
        }
        if (dword_1E9350BB0)
        {
          LODWORD(number.CFDictionarySetValue(theDict, key, value) = 0;
          LOBYTE(cf) = 0;
          char v55 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          unsigned int v56 = number.value;
          if (os_log_type_enabled(v55, (os_log_type_t)cf)) {
            unsigned int v57 = v56;
          }
          else {
            unsigned int v57 = v56 & 0xFFFFFFFE;
          }
          if (v57)
          {
            if (a1) {
              uint64_t v58 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
            }
            else {
              uint64_t v58 = "";
            }
            uint64_t v64 = CMBaseObjectGetDerivedStorage();
            LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 136316418;
            *(CMTimeValue *)((char *)&time1.value + 4) = (CMTimeValue)"fpfs_setRateInternal";
            LOWORD(time1.flags) = 2048;
            *(void *)((char *)&time1.flags + 2) = a1;
            HIWORD(time1.epoch) = 2082;
            Float64 v111 = v58;
            __int16 v112 = 2048;
            CFStringRef v113 = v12;
            __int16 v114 = 2082;
            uint64_t v115 = v64 + 3080;
            __int16 v116 = 2048;
            double v117 = a5;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        if (*(void *)(v15 + 568))
        {
          fpfs_getAnchorTimeForSyncTimebase(a5, a1, (uint64_t)v12, (CMTime *)a3, (CMTime *)a4);
        }
        else if (v19 && (*(unsigned char *)(a3 + 12) & 1) == 0 && (*(unsigned char *)(a4 + 12) & 1) == 0)
        {
          fpfs_getCachedAnchorTimeForItem(a1, (uint64_t)v12, a3, a4);
        }
        uint64_t TimebaseStarterTrack = fpfsi_getTimebaseStarterTrack((uint64_t)v12);
        if (!TimebaseStarterTrack)
        {
          fpfsi_setItemRateTimebaseAndAnchor(0.0, (uint64_t)v12, 1, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8]);
          uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
          uint64_t v70 = (uint64_t)v12;
          goto LABEL_131;
        }
        uint64_t v66 = (uint64_t *)TimebaseStarterTrack;
        if (*MEMORY[0x1E4F1EBA8] == 1 && v19)
        {
          uint64_t v68 = CMBaseObjectGetDerivedStorage();
          strncpy((char *)&time2, (const char *)(v68 + 3080), 8uLL);
          kdebug_trace();
        }
        CMTime time2 = *(CMTime *)a3;
        CMTime time1 = *(CMTime *)a4;
        uint64_t v35 = fpfs_SetRateOnTrack(v66, &time2, &time1, a5);
        if (!v35)
        {
          if (!v19)
          {
LABEL_138:
            if (fpfs_shouldReleaseRenderChainForPausing((uint64_t)v12)) {
              fpfsi_ReleaseRenderChainsForPausing(v12);
            }
            time2.unsigned int value = 0;
            uint64_t v75 = CMBaseObjectGetDerivedStorage();
            uint64_t v76 = CMBaseObjectGetDerivedStorage();
            uint64_t v77 = fpfs_LastRenderingTrackofType((uint64_t)v12, 1936684398, 0);
            CFArrayRef v78 = fpfs_getNext(v76, v12);
            if (v77) {
              char v79 = v19;
            }
            else {
              char v79 = 1;
            }
            if ((v79 & 1) == 0)
            {
              uint64_t v80 = (uint64_t)v78;
              if (v78)
              {
                uint64_t v81 = CMBaseObjectGetDerivedStorage();
                uint64_t v82 = *(void *)(*(void *)(v77 + 96) + 32);
                uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
                uint64_t v84 = FigRenderPipelineGetFigBaseObject(v82);
                uint64_t v85 = *(void *)(CMBaseObjectGetVTable() + 8);
                uint64_t v86 = v85 ? v85 : 0;
                CFAllocatorRef v87 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CMTime *))(v86 + 48);
                if (v87)
                {
                  int v88 = v87(v84, @"Timebase", AllocatorForMedia, &time2);
                  CFAllocatorRef v89 = (const void *)time2.value;
                  if (!v88 && *(void *)(v75 + 576) != time2.value && time2.value == *(void *)(v81 + 576))
                  {
                    uint64_t v90 = MEMORY[0x1E4F1F9F8];
                    fpfsi_setItemRateTimebaseAndAnchor(0.0, (uint64_t)v12, 1, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8]);
                    fpfsi_setItemRateTimebaseAndAnchor(0.0, v80, 1, v90, v90);
                    fpfs_CancelGaplessTransitionThatDependsOnTrack(*(const void **)v75, v77, 1);
                    CFAllocatorRef v89 = (const void *)time2.value;
                  }
                  if (v89) {
                    CFRelease(v89);
                  }
                }
              }
            }
            uint64_t DerivedStorage = v101;
            goto LABEL_156;
          }
          uint64_t v69 = MEMORY[0x1E4F1F9F8];
          *(_OWORD *)(v15 + 408) = *MEMORY[0x1E4F1F9F8];
          *(void *)(v15 + 424) = *(void *)(v69 + 16);
          uint64_t v70 = (uint64_t)v12;
          uint64_t UpTimeNanoseconds = 0x7FFFFFFFFFFFFFFFLL;
LABEL_131:
          fpfsi_SetLastTimestampClientDidPauseOnContentSteeringMonitor(v70, UpTimeNanoseconds);
          goto LABEL_138;
        }
LABEL_173:
        CFStringRef v11 = (const __CFString *)v35;
        if (*(float *)(v15 + 848) == 0.0)
        {
          uint64_t v99 = 0;
          int v100 = 1;
        }
        else
        {
          uint64_t v99 = 1;
          int v100 = 0;
        }
        fpfsi_scheduleFVTTransitionsForItem(v12, v99, v100);
        return (uint64_t)v11;
      }
      uint64_t v38 = *(void *)(*(void *)(v37 + 96) + 32);
      uint64_t v39 = FigGetAllocatorForMedia();
      uint64_t v40 = FigRenderPipelineGetFigBaseObject(v38);
      uint64_t v41 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v41) {
        uint64_t v42 = v41;
      }
      else {
        uint64_t v42 = 0;
      }
      uint64_t v43 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v42 + 48);
      if (v43)
      {
        int v44 = v43(v40, @"NextNonJerkyStopTime", v39, &cf);
        CFTypeRef v45 = cf;
        if (v44 || !cf)
        {
LABEL_74:
          if (v45) {
            CFRelease(v45);
          }
          goto LABEL_76;
        }
        memset(&time2, 0, sizeof(time2));
        CMTimeMakeFromDictionary(&time2, (CFDictionaryRef)cf);
        if ((time2.flags & 0x1D) == 1)
        {
          if ((*(unsigned char *)(a3 + 12) & 1) == 0
            || (CMTime time1 = time2, number = *(CMTime *)a3, CMTimeCompare(&time1, &number) >= 1))
          {
            *(CMTime *)a3 = time2;
          }
        }
      }
      CFTypeRef v45 = cf;
      goto LABEL_74;
    }
    uint64_t v22 = CMBaseObjectGetDerivedStorage();
    number.unsigned int value = 0;
    CFTypeRef cf = 0;
    CMBaseObjectGetDerivedStorage();
    uint64_t v23 = fpfs_FirstRenderingTrackofType((uint64_t)v12, 1936684398);
    if (v23)
    {
      LODWORD(v21) = 0;
      if (v14 > 2.0) {
        goto LABEL_48;
      }
      if (v14 < 0.0) {
        goto LABEL_48;
      }
      LODWORD(v21) = 0;
      if (a5 > 2.0 || a5 < 0.0) {
        goto LABEL_48;
      }
      if (!v19) {
        goto LABEL_47;
      }
      CMTime v24 = (uint64_t *)v23;
      uint64_t v21 = *(void *)(*(void *)(v23 + 96) + 32);
      if (!v21) {
        goto LABEL_48;
      }
      float valuePtr = 0.0;
      uint64_t v25 = FigGetAllocatorForMedia();
      FigRenderPipelineCopyProperty(v21, @"Started", v25, (uint64_t)&cf);
      LODWORD(v21) = 0;
      if (!cf || cf != (CFTypeRef)*MEMORY[0x1E4F1CFD0]) {
        goto LABEL_48;
      }
      uint64_t v26 = *(void *)(v24[12] + 32);
      uint64_t v27 = FigGetAllocatorForMedia();
      FigRenderPipelineCopyProperty(v26, @"DecodingRate", v27, (uint64_t)&number);
      if (number.value)
      {
        CFNumberGetValue((CFNumberRef)number.value, kCFNumberFloat32Type, &valuePtr);
        if (valuePtr != a5)
        {
          if (dword_1E9350BB0)
          {
            *(_DWORD *)uint64_t v107 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            uint64_t v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v29 = *(_DWORD *)v107;
            if (os_log_type_enabled(v28, type)) {
              unsigned int v30 = v29;
            }
            else {
              unsigned int v30 = v29 & 0xFFFFFFFE;
            }
            if (v30)
            {
              if (a1) {
                uint64_t v31 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
              }
              else {
                uint64_t v31 = "";
              }
              uint64_t v33 = CMBaseObjectGetDerivedStorage();
              LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 136316930;
              *(CMTimeValue *)((char *)&time1.value + 4) = (CMTimeValue)"fpfs_flushRenderChainForDifferentRateIfNecessary";
              LOWORD(time1.flags) = 2048;
              *(void *)((char *)&time1.flags + 2) = a1;
              HIWORD(time1.epoch) = 2082;
              Float64 v111 = v31;
              __int16 v112 = 2048;
              CFStringRef v113 = v12;
              __int16 v114 = 2082;
              uint64_t v115 = v33 + 3080;
              __int16 v116 = 2048;
              double v117 = v14;
              __int16 v118 = 2048;
              double v119 = a5;
              __int16 v120 = 2048;
              double v121 = valuePtr;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          *(_DWORD *)(CMBaseObjectGetDerivedStorage() + 848) = 0;
          fpfsi_updateMaxPlayThroughTime();
          uint64_t DerivedStorage = v101;
          if (!fpfs_SetRateOnTrack(v24, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], 0.0))
          {
            fpfsi_ReleaseRenderChainsForPausing(v12);
            FigBufferedAirPlayOutputReset(*(void *)(v22 + 504));
            LODWORD(v21) = 1;
LABEL_48:
            if (number.value) {
              CFRelease((CFTypeRef)number.value);
            }
            if (cf) {
              CFRelease(cf);
            }
            goto LABEL_52;
          }
LABEL_47:
          LODWORD(v21) = 0;
          goto LABEL_48;
        }
      }
    }
    else
    {
      if (!dword_1E9350BB0) {
        goto LABEL_47;
      }
      float valuePtr = 0.0;
      v107[0] = OS_LOG_TYPE_DEFAULT;
      double v32 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    LODWORD(v21) = 0;
    goto LABEL_48;
  }

  return fpfs_setIFrameOnlyRate((uint64_t)v12, a5);
}

uint64_t fpfs_PlayQueueCallForEachItem(uint64_t a1, uint64_t (*a2)(const __CFArray *, uint64_t), uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2) {
    return 4294954436;
  }
  uint64_t v6 = DerivedStorage;
  CFArrayRef Next = fpfs_getNext(DerivedStorage, 0);
  if (!Next) {
    return 0;
  }
  CFArrayRef v8 = Next;
  do
  {
    uint64_t v9 = a2(v8, a3);
    CFArrayRef v10 = fpfs_getNext(v6, v8);
    if (v9) {
      break;
    }
    CFArrayRef v8 = v10;
  }
  while (v10);
  return v9;
}

uint64_t fpfs_clearCoordinatedPlaybackSynchronizationTimebaseForPlayQueueItemsApply(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2 && !*(unsigned char *)(a2 + 8))
  {
    if (*(void *)a2 == a1) {
      *(unsigned char *)(a2 + 8) = 1;
    }
  }
  else
  {
    fpfsi_clearCoordinatedPlaybackSynchronizationTimebase();
  }
  return 0;
}

uint64_t fpfs_setIFrameOnlyRate(uint64_t a1, float a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMBaseObjectGetDerivedStorage();
  uint64_t v5 = *(void *)(DerivedStorage + 1704);
  if (v5 && FigAlternateIsIFrameOnly(v5))
  {
    uint64_t result = 0;
    if (a2 != 0.0 && *(float *)(DerivedStorage + 848) != a2)
    {
      if (dword_1E9350BB0)
      {
        int v20 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      uint64_t v8 = *(void *)(DerivedStorage + 1048);
      if (v8)
      {
        uint64_t v9 = *MEMORY[0x1E4F1CFC8];
        do
        {
          if (*(_DWORD *)(v8 + 32) == 1986618469)
          {
            uint64_t v10 = *(void *)(v8 + 96);
            if (v10)
            {
              uint64_t v11 = *(void *)(v10 + 32);
              if (v11)
              {
                uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v11);
                uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 8);
                uint64_t v14 = v13 ? v13 : 0;
                uint64_t v15 = *(void (**)(uint64_t, __CFString *, uint64_t))(v14 + 56);
                if (v15) {
                  v15(FigBaseObject, @"AllowVideoQualityOfServiceAdjustments", v9);
                }
              }
            }
          }
          uint64_t v8 = *(void *)(v8 + 8);
        }
        while (v8);
      }
      fpfs_GetNextTimeToPlay(DerivedStorage, 0, (uint64_t)&v18);
      uint64_t v16 = MEMORY[0x1E4F1F9F8];
      uint64_t result = fpfs_IssueSeekToPump(a1, &v18, MEMORY[0x1E4F1F9F0], 0, 1, 0, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8]);
      if (!result)
      {
        fpfs_GetTime(DerivedStorage, (uint64_t)&v17);
        uint64_t result = fpfs_PrepareToReuseLastIFrameTrack(a1, &v17, 1);
        if (!result)
        {
          *(_DWORD *)(DerivedStorage + 1560) = 1044549468;
          *(_OWORD *)(DerivedStorage + 1520) = *(_OWORD *)v16;
          *(void *)(DerivedStorage + 1536) = *(void *)(v16 + 16);
          if (*(double *)(DerivedStorage + 1944) != 0.0)
          {
            *(double *)(DerivedStorage + 1952) = *(double *)(DerivedStorage + 1952)
                                               + (CFAbsoluteTimeGetCurrent() - *(double *)(DerivedStorage + 1944))
                                               * fabsf(*(float *)(DerivedStorage + 848));
            *(double *)(DerivedStorage + 1960) = *(double *)(DerivedStorage + 1960)
                                               + CFAbsoluteTimeGetCurrent()
                                               - *(double *)(DerivedStorage + 1944);
            *(void *)(DerivedStorage + 1944) = 0;
          }
          fpfsi_RTCReportingUpdatePlayingTrackStats(DerivedStorage);
          fpfsi_RTCReportingReportRateChange(DerivedStorage, *(float *)(DerivedStorage + 848));
          return 0;
        }
      }
    }
  }
  else
  {
    return FigSignalErrorAt();
  }
  return result;
}

BOOL fpfsi_isItemPlayedOut(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMTime v8 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  int Duration = fpfsi_GetDuration(a1, (long long *)&v8.value);
  BOOL result = 0;
  if (!Duration && (v8.flags & 0x1D) == 1)
  {
    fpfs_GetTime(DerivedStorage, (uint64_t)&time1);
    CMTime v5 = v8;
    CMTimeMultiplyByFloat64(&time2, &v5, 0.95);
    return CMTimeCompare(&time1, &time2) >= 0;
  }
  return result;
}

void fpfs_getAnchorTimeForSyncTimebase(float a1, uint64_t a2, uint64_t a3, CMTime *a4, CMTime *a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v9 = CMBaseObjectGetDerivedStorage();
  CMTime v22 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  CMTime v21 = v22;
  uint64_t v10 = *(OpaqueCMTimebase **)(v9 + 568);
  if (v10)
  {
    float Rate = CMTimebaseGetRate(v10);
    float v12 = *(float *)(DerivedStorage + 108);
    if (v12 == Rate && v12 == a1)
    {
      fpfs_GetNextTimeToPlay(v9, 0, (uint64_t)&v22);
      uint64_t v15 = *(const void **)(v9 + 568);
      CMClockRef HostTimeClock = CMClockGetHostTimeClock();
      CMTime time = v22;
      CMSyncConvertTime(&v21, &time, v15, HostTimeClock);
      memset(&v20, 0, sizeof(v20));
      long long v17 = CMClockGetHostTimeClock();
      CMClockGetTime(&rhs, v17);
      CMTime time = v21;
      CMTimeSubtract(&v20, &time, &rhs);
      if (!dword_1E9350BB0) {
        goto LABEL_11;
      }
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    }
    else
    {
      if (a1 == 0.0) {
        goto LABEL_11;
      }
      LODWORD(v20.CFDictionarySetValue(theDict, key, value) = 0;
      uint64_t v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
LABEL_11:
  if (a4) {
    *a4 = v22;
  }
  if (a5) {
    *a5 = v21;
  }
}

double fpfs_getCachedAnchorTimeForItem(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMBaseObjectGetDerivedStorage();
  long long v20 = *MEMORY[0x1E4F1F9F8];
  *(void *)&long long v7 = v20;
  CMTimeEpoch v8 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  CMTimeEpoch v21 = v8;
  long long v18 = v20;
  CMTimeEpoch v19 = v8;
  long long v14 = v20;
  *(_OWORD *)&v17.unsigned int value = v20;
  v17.CMTimeEpoch epoch = v8;
  if ((*(unsigned char *)(DerivedStorage + 148) & 1) == 0)
  {
LABEL_4:
    if (!a3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v9 = DerivedStorage + 112;
  CMClockRef HostTimeClock = CMClockGetHostTimeClock();
  CMClockGetTime(&v17, HostTimeClock);
  long long v12 = *(_OWORD *)(DerivedStorage + 136);
  uint64_t v11 = DerivedStorage + 136;
  *(_OWORD *)&time1.unsigned int value = v12;
  time1.CMTimeEpoch epoch = *(void *)(v11 + 16);
  CMTime time2 = v17;
  if (CMTimeCompare(&time1, &time2) >= 1)
  {
    long long v20 = *(_OWORD *)v9;
    CMTimeEpoch v21 = *(void *)(v9 + 16);
    long long v7 = *(_OWORD *)v11;
    long long v18 = *(_OWORD *)v11;
    CMTimeEpoch v19 = *(void *)(v11 + 16);
    goto LABEL_4;
  }
  *(void *)&long long v7 = v14;
  *(_OWORD *)uint64_t v9 = v14;
  *(void *)(v9 + 16) = v8;
  *(_OWORD *)uint64_t v11 = v14;
  *(void *)(v11 + 16) = v8;
  if (a3)
  {
LABEL_5:
    *(void *)&long long v7 = v20;
    *(_OWORD *)a3 = v20;
    *(void *)(a3 + 16) = v21;
  }
LABEL_6:
  if (a4)
  {
    *(void *)&long long v7 = v18;
    *(_OWORD *)a4 = v18;
    *(void *)(a4 + 16) = v19;
  }
  return *(double *)&v7;
}

uint64_t fpfs_SetRateOnTrack(uint64_t *a1, CMTime *a2, CMTime *a3, float a4)
{
  uint64_t v5 = (uint64_t)a1;
  uint64_t v178 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v8 = CMBaseObjectGetDerivedStorage();
  if ((fpfs_rateModifiedByPref_sCheckedPref & 1) == 0)
  {
    CFPropertyListRef v9 = CFPreferencesCopyValue(@"streamingDrift", @"com.apple.coremedia", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
    fpfs_rateModifiedByPref_sCheckedPref = 1;
    if (v9)
    {
      uint64_t v10 = v9;
      if (CFEqual(v9, @"playSlightlySlower"))
      {
        fpfs_rateModifiedByPref_sfloat Rate = 1065185444;
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "FigPlayer_Stream will play streams slightly slower (%.2f) due to defaults write.\n");
      }
      else if (CFEqual(v10, @"playSlightlyFaster"))
      {
        fpfs_rateModifiedByPref_sfloat Rate = 1065437102;
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "FigPlayer_Stream will play streams slightly faster (%.2f) due to defaults write.\n");
      }
      CFRelease(v10);
    }
  }
  if (a4 == 1.0) {
    a4 = *(float *)&fpfs_rateModifiedByPref_sRate;
  }
  if (*(float *)(v8 + 108) == 0.0 && a4 != 0.0)
  {
    LODWORD(valuePtr.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (!*(void *)(v5 + 96)) {
    return 0;
  }
  uint64_t v12 = *(void *)(v5 + 16);
  if (*(_DWORD *)(v5 + 152) != 6)
  {
    LODWORD(valuePtr.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
    uint64_t v13 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  unsigned int v156 = (void *)DerivedStorage;
  if (dword_1E9350BB0)
  {
    LODWORD(valuePtr.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
    long long v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (!*(unsigned char *)(*(void *)(v5 + 96) + 25))
  {
    uint64_t v25 = fpfs_SetTimebaseOnTrack(v6, v5);
    if (v25) {
      return v25;
    }
    uint64_t v26 = *(void *)(DerivedStorage + 720);
    if (v26)
    {
      uint64_t v25 = FigImageQueueTableSetTimebase(v26, *(void **)(DerivedStorage + 576));
      if (v25) {
        return v25;
      }
      uint64_t v27 = *(void *)(DerivedStorage + 720);
      if (v27)
      {
        uint64_t v25 = FigImageQueueTableReconnectWithTimebase(v27, *(void **)(DerivedStorage + 576));
        if (v25) {
          return v25;
        }
      }
    }
  }
  if (*(_DWORD *)(v5 + 32) != 1936684398)
  {
    uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v23) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = 0;
    }
    if (*(void *)(v24 + 8) && !*(unsigned char *)(v8 + 462))
    {
      if (*MEMORY[0x1E4F1EBA8] == 1)
      {
        if (v6) {
          uint64_t v46 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else {
          uint64_t v46 = "";
        }
        strncpy((char *)sizeOut, v46, 8uLL);
        kdebug_trace();
      }
      uint64_t v69 = *(void *)(v5 + 96);
      sizeOut[0] = *a2;
      CMTime time = *a3;
      uint64_t v45 = fpfs_setRateOnPrimaryAndAuxRenderPipelines(v69, (long long *)&sizeOut[0].value, (long long *)&time.value, a4, 1.0);
      if (!v45)
      {
        *(float *)(CMBaseObjectGetDerivedStorage() + 848) = a4;
        fpfsi_updateMaxPlayThroughTime();
      }
      int v41 = 1;
      goto LABEL_306;
    }
    if (*MEMORY[0x1E4F1EBA8] == 1)
    {
      if (v6) {
        unsigned int v30 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
      }
      else {
        unsigned int v30 = "";
      }
      strncpy((char *)sizeOut, v30, 8uLL);
      kdebug_trace();
    }
    if ((a2->flags & 0x1D) != 1)
    {
      p_CMTime time = (CMTime *)MEMORY[0x1E4F1F9F8];
      int v41 = 1;
      uint64_t v42 = v6;
      float v43 = a4;
      p_CMTime valuePtr = (CMTime *)MEMORY[0x1E4F1F9F8];
LABEL_63:
      uint64_t v45 = fpfsi_setItemRateTimebaseAndAnchor(v43, v42, 1, (uint64_t)p_time, (uint64_t)p_valuePtr);
      goto LABEL_306;
    }
    memset(sizeOut, 0, 24);
    CMClockOrTimebaseRef v37 = CMTimebaseCopySource(*(CMTimebaseRef *)(DerivedStorage + 576));
    uint64_t v38 = v37;
    if ((a3->flags & 0x1D) == 1)
    {
      CMClockRef HostTimeClock = CMClockGetHostTimeClock();
      CMTime time = *a3;
      CMSyncConvertTime(sizeOut, &time, HostTimeClock, v38);
      if (!v38) {
        goto LABEL_62;
      }
    }
    else
    {
      CMSyncGetTime(sizeOut, v37);
      if (!v38)
      {
LABEL_62:
        CMTime time = *a2;
        CMTime valuePtr = sizeOut[0];
        int v41 = 1;
        p_CMTime time = &time;
        p_CMTime valuePtr = &valuePtr;
        uint64_t v42 = v6;
        float v43 = a4;
        goto LABEL_63;
      }
    }
    CFRelease(v38);
    goto LABEL_62;
  }
  if (!*(void *)(v8 + 536) || a4 <= 0.0)
  {
    uint64_t v28 = (void *)DerivedStorage;
    goto LABEL_36;
  }
  uint64_t v15 = *(const void **)v5;
  uint64_t v16 = CMBaseObjectGetDerivedStorage();
  CFTypeRef v17 = *(CFTypeRef *)v16;
  uint64_t v18 = CMBaseObjectGetDerivedStorage();
  valuePtr.CMTimeValue value = 0;
  type.CMTimeValue value = 0;
  int v19 = fpfs_WantAudioHardwarePassthroughForTrack(v5, 0);
  if (*(void *)(v18 + 504)) {
    goto LABEL_112;
  }
  if (v19)
  {
    double v20 = *(double *)&valuePtr.value;
    if (*(double *)&valuePtr.value != 0.0) {
      goto LABEL_86;
    }
    sizeOut[0].CMTimeValue value = 0;
    FormatList = (CMTimeValue *)CMAudioFormatDescriptionGetFormatList(*(CMAudioFormatDescriptionRef *)(v5 + 40), (size_t *)sizeOut);
    CMTimeValue value = sizeOut[0].value;
    if (!FormatList) {
      goto LABEL_321;
    }
  }
  else
  {
    uint64_t v31 = *(void *)(v16 + 96);
    if (v31)
    {
      uint64_t v32 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v33 = v32 ? v32 : 0;
      uint64_t v52 = *(unsigned int (**)(uint64_t, __CFString *, void, CMTime *))(v33 + 48);
      if (v52)
      {
        if (!v52(v31, @"AfmfpbProperty_HighestValidDeclaredSampleRate", *MEMORY[0x1E4F1CF80], &type))
        {
          if (type.value)
          {
            CFTypeID v53 = CFGetTypeID((CFTypeRef)type.value);
            if (v53 == CFNumberGetTypeID()) {
              CFNumberGetValue((CFNumberRef)type.value, kCFNumberDoubleType, &valuePtr);
            }
          }
        }
      }
    }
    double v20 = *(double *)&valuePtr.value;
    if (*(double *)&valuePtr.value != 0.0 || (*(unsigned char *)(v16 + 560) & 0x10) == 0) {
      goto LABEL_86;
    }
    sizeOut[0].CMTimeValue value = 0;
    FormatList = (CMTimeValue *)CMAudioFormatDescriptionGetRichestDecodableFormat(*(CMAudioFormatDescriptionRef *)(v5 + 40));
    CMTimeValue value = 48;
    if (!FormatList) {
      CMTimeValue value = 0;
    }
    sizeOut[0].CMTimeValue value = value;
    if (!FormatList) {
      goto LABEL_321;
    }
  }
  if (!value)
  {
LABEL_321:
    uint64_t v45 = FigSignalErrorAt();
    goto LABEL_113;
  }
  double v20 = *(double *)FormatList;
  valuePtr.CMTimeValue value = *FormatList;
LABEL_86:
  if (v20 == 0.0)
  {
LABEL_112:
    uint64_t v45 = 0;
    goto LABEL_113;
  }
  if (*(unsigned char *)(v18 + 840))
  {
    if (dword_1E9350BB0)
    {
      LODWORD(v163) = 0;
      v161[0] = OS_LOG_TYPE_DEFAULT;
      uint64_t v54 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v55 = v163;
      if (os_log_type_enabled(v54, v161[0])) {
        unsigned int v56 = v55;
      }
      else {
        unsigned int v56 = v55 & 0xFFFFFFFE;
      }
      if (v56)
      {
        if (v17) {
          unsigned int v57 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          unsigned int v57 = "";
        }
        if (v15) {
          uint64_t v63 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else {
          uint64_t v63 = "";
        }
        LODWORD(time.CFDictionarySetValue(theDict, key, value) = 136316418;
        *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"fpfs_UpdateCMSessionPreferredDeviceSampleRateForTrack";
        LOWORD(time.flags) = 2048;
        *(void *)((char *)&time.flags + 2) = v17;
        HIWORD(time.epoch) = 2082;
        CFTypeRef v166 = v57;
        __int16 v167 = 2048;
        uint64_t v168 = (uint64_t)v15;
        __int16 v169 = 2082;
        uint64_t v170 = v63;
        __int16 v171 = 2048;
        *(void *)double v172 = valuePtr.value;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    goto LABEL_112;
  }
  CFNumberRef v150 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat64Type, &valuePtr);
  if (dword_1E9350BB0)
  {
    LODWORD(v163) = 0;
    v161[0] = OS_LOG_TYPE_DEFAULT;
    uint64_t v58 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int v59 = v163;
    if (os_log_type_enabled(v58, v161[0])) {
      unsigned int v60 = v59;
    }
    else {
      unsigned int v60 = v59 & 0xFFFFFFFE;
    }
    if (v60)
    {
      if (v17) {
        unsigned int v61 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      }
      else {
        unsigned int v61 = "";
      }
      if (v15) {
        uint64_t v74 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
      }
      else {
        uint64_t v74 = "";
      }
      LODWORD(time.CFDictionarySetValue(theDict, key, value) = 136316418;
      *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"fpfs_UpdateCMSessionPreferredDeviceSampleRateForTrack";
      LOWORD(time.flags) = 2048;
      *(void *)((char *)&time.flags + 2) = v17;
      HIWORD(time.epoch) = 2082;
      CFTypeRef v166 = v61;
      __int16 v167 = 2048;
      uint64_t v168 = (uint64_t)v15;
      __int16 v169 = 2082;
      uint64_t v170 = v74;
      __int16 v171 = 2048;
      *(void *)double v172 = valuePtr.value;
      _os_log_send_and_compose_impl();
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  CFRetain(v15);
  CFRetain(*(CFTypeRef *)v16);
  uint64_t v75 = fpfs_UnlockMutexCompletelyWithCaller(v17);
  uint64_t v76 = *(void *)(v18 + 536);
  if (v76)
  {
    uint64_t v77 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v77)
    {
      CFArrayRef v78 = *(void (**)(uint64_t, void, CFNumberRef))(v77 + 56);
      if (v78) {
        v78(v76, *MEMORY[0x1E4F76440], v150);
      }
    }
  }
  uint64_t v79 = CMBaseObjectGetDerivedStorage();
  do
    fpfs_LockMutexWithCaller(v17);
  while (*(void *)(v79 + 8) < v75);
  if (*(unsigned char *)(v18 + 51) || FigRetainProxyIsInvalidated() || *(const void **)(v18 + 80) != v15) {
    uint64_t v45 = FigSignalErrorAt();
  }
  else {
    uint64_t v45 = 0;
  }
  CFRelease(*(CFTypeRef *)v16);
  CFRelease(v15);
  if (v150) {
    CFRelease(v150);
  }
LABEL_113:
  if (type.value) {
    CFRelease((CFTypeRef)type.value);
  }
  if (!v45)
  {
    uint64_t v28 = v156;
    uint64_t v5 = v156[131];
    if (!v5) {
      return FigSignalErrorAt();
    }
    while (*(void *)(v5 + 16) != v12)
    {
      uint64_t v5 = *(void *)(v5 + 8);
      if (!v5) {
        return FigSignalErrorAt();
      }
    }
    if (*(float *)(v8 + 108) == 0.0 && a4 != 0.0)
    {
      LODWORD(valuePtr.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
      uint64_t v64 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v65 = valuePtr.value;
      if (os_log_type_enabled(v64, type.value)) {
        unsigned int v66 = v65;
      }
      else {
        unsigned int v66 = v65 & 0xFFFFFFFE;
      }
      if (v66)
      {
        uint64_t v67 = *v156;
        if (*v156) {
          uint64_t v68 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          uint64_t v68 = "";
        }
        if (v6) {
          int v73 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else {
          int v73 = "";
        }
        LODWORD(time.CFDictionarySetValue(theDict, key, value) = 136316162;
        *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"fpfs_SetRateOnTrack";
        LOWORD(time.flags) = 2048;
        *(void *)((char *)&time.flags + 2) = v67;
        HIWORD(time.epoch) = 2082;
        CFTypeRef v166 = v68;
        __int16 v167 = 2048;
        uint64_t v168 = v6;
        __int16 v169 = 2082;
        uint64_t v170 = v73;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      return 4294954433;
    }
LABEL_36:
    if (a4 != 0.0)
    {
      unsigned int v29 = (_OWORD *)(v5 + 360);
      if (a2->flags)
      {
        long long v34 = *(_OWORD *)&a2->value;
        *(void *)(v5 + 376) = a2->epoch;
        *unsigned int v29 = v34;
      }
      else
      {
        CMTimebaseGetTime(sizeOut, (CMTimebaseRef)v28[72]);
        *unsigned int v29 = *(_OWORD *)&sizeOut[0].value;
        *(void *)(v5 + 376) = sizeOut[0].epoch;
      }
      if (*(void *)(CMBaseObjectGetDerivedStorage() + 504) && *(void *)(*(void *)(v5 + 96) + 48))
      {
        uint64_t v35 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v35) {
          uint64_t v36 = v35;
        }
        else {
          uint64_t v36 = 0;
        }
        if (*(void *)(v36 + 104))
        {
          uint64_t v47 = *(void *)(*(void *)(v5 + 96) + 48);
          uint64_t v48 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v48) {
            uint64_t v49 = v48;
          }
          else {
            uint64_t v49 = 0;
          }
          unsigned int v62 = *(unsigned int (**)(uint64_t))(v49 + 104);
          if (!v62) {
            goto LABEL_168;
          }
        }
        else
        {
          uint64_t v47 = *(void *)(*(void *)(v5 + 96) + 48);
          uint64_t v50 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v50) {
            uint64_t v51 = v50;
          }
          else {
            uint64_t v51 = 0;
          }
          unsigned int v62 = *(unsigned int (**)(uint64_t))(v51 + 24);
          if (!v62) {
            goto LABEL_168;
          }
        }
        if (v62(v47))
        {
          uint64_t v70 = *(void *)(*(void *)(v5 + 96) + 32);
          uint64_t v71 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v72 = v71 ? v71 : 0;
          uint64_t v80 = *(void (**)(uint64_t, void))(v72 + 56);
          if (v80) {
            v80(v70, *MEMORY[0x1E4F1CFD0]);
          }
        }
      }
    }
LABEL_168:
    if (a4 <= 0.0) {
      goto LABEL_228;
    }
    uint64_t v81 = (uint64_t *)CMBaseObjectGetDerivedStorage();
    uint64_t v82 = CMBaseObjectGetDerivedStorage();
    LODWORD(time.CFDictionarySetValue(theDict, key, value) = 0;
    CMTimeScale v83 = *(const opaqueCMFormatDescription **)(v5 + 40);
    signed int MediaSubType = CMFormatDescriptionGetMediaSubType(v83);
    int v85 = 1;
    if (MediaSubType > 1885692722)
    {
      if (MediaSubType <= 1902469938)
      {
        if (MediaSubType != 1885692723)
        {
          int v86 = 1902324531;
LABEL_184:
          if (MediaSubType != v86) {
            goto LABEL_195;
          }
LABEL_196:
          if (*(_DWORD *)(v5 + 32) == 1936684398 && !*(void *)(v82 + 504))
          {
            int v91 = fpfs_WantAudioHardwarePassthroughForTrack(v5, (int *)&time);
            CMBaseObjectGetDerivedStorage();
            __int16 v92 = (const void *)*MEMORY[0x1E4F75A20];
            int v93 = FigCFEqual();
            if (v91 == (v93 != 0))
            {
              if (v93) {
                int v94 = 1633889587;
              }
              else {
                int v94 = 0;
              }
              if (v91) {
                BOOL v95 = LODWORD(time.value) == v94;
              }
              else {
                BOOL v95 = 1;
              }
              int v96 = !v95;
            }
            else
            {
              int v96 = 1;
            }
            if (v85) {
              int v85 = *(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561) != 0;
            }
            uint64_t v97 = (const void *)*MEMORY[0x1E4F75A30];
            double v98 = (const void **)MEMORY[0x1E4F75A28];
            if (v96 || FigCFEqual() != v85 || !*(void *)(v82 + 544))
            {
              uint64_t v99 = *v98;
              if (v91) {
                int v100 = v92;
              }
              else {
                int v100 = v99;
              }
              if (!v85) {
                uint64_t v97 = v100;
              }
              if (*(_DWORD *)(v82 + 32) == 2 && *(void *)(v82 + 536)) {
                fpfsi_setAudioSessionPreferredAudioHardwareFormat(*v81, *(void *)v5, (uint64_t)v97);
              }
              uint64_t v101 = *(const void **)(v82 + 544);
              *(void *)(v82 + 544) = v97;
              if (v97) {
                CFRetain(v97);
              }
              if (v101) {
                CFRelease(v101);
              }
            }
            *(unsigned char *)(v82 + 560) = 0;
            if (FigCFEqual()) {
              fpfs_setPreferredNumberOfAudioOutputChannels(*v81, *(const opaqueCMFormatDescription **)(v5 + 40), 1);
            }
          }
LABEL_228:
          time.CMTimeValue value = 0;
          uint64_t v102 = *(void *)(*(void *)(v5 + 96) + 32);
          uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
          uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v102);
          uint64_t v105 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v105) {
            uint64_t v106 = v105;
          }
          else {
            uint64_t v106 = 0;
          }
          uint64_t v107 = *(void (**)(uint64_t, __CFString *, uint64_t, CMTime *))(v106 + 48);
          if (v107) {
            v107(FigBaseObject, @"IsTimebaseStarter", AllocatorForMedia, &time);
          }
          uint64_t v108 = (const void *)time.value;
          uint64_t v109 = *MEMORY[0x1E4F1CFD0];
          if (time.value == *MEMORY[0x1E4F1CFD0])
          {
            if (*MEMORY[0x1E4F1EBA8] == 1)
            {
              if (v6) {
                uint64_t v110 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
              }
              else {
                uint64_t v110 = "";
              }
              strncpy((char *)sizeOut, v110, 8uLL);
              kdebug_trace();
              int v41 = 1;
              uint64_t v108 = (const void *)time.value;
            }
            else
            {
              int v41 = 1;
            }
          }
          else
          {
            int v41 = 0;
          }
          if (v108) {
            CFRelease(v108);
          }
          CMTime valuePtr = *a2;
          CMTime type = *a3;
          uint64_t v111 = *(void *)v5;
          __int16 v112 = (void *)CMBaseObjectGetDerivedStorage();
          uint64_t v113 = CMBaseObjectGetDerivedStorage();
          uint64_t v163 = 0;
          uint64_t v164 = 0;
          uint64_t v114 = *(void *)(v113 + 708);
          int v115 = *(_DWORD *)(v113 + 716);
          int v162 = 0;
          *(void *)unsigned int v161 = 0;
          fpfsi_DetermineRateSnapping(v111, (uint64_t)&v163);
          if (fpfs_ConfigureRatePlan(v114, v115, v163, v164, (uint64_t)v161, a4, *(float *)(v113 + 108)))
          {
            uint64_t v151 = v109;
            int v153 = v41;
            uint64_t v155 = v112;
            if (*(float *)&v161[4] != 1.0
              && fpfs_WantAudioHardwarePassthroughForTrack(v5, (int *)&v164 + 1))
            {
              if (dword_1E9350BB0)
              {
                unsigned int v160 = 0;
                os_log_type_t v159 = OS_LOG_TYPE_DEFAULT;
                __int16 v116 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                unsigned int v117 = v160;
                if (os_log_type_enabled(v116, v159)) {
                  unsigned int v118 = v117;
                }
                else {
                  unsigned int v118 = v117 & 0xFFFFFFFE;
                }
                if (v118)
                {
                  uint64_t v119 = *v112;
                  if (*v112) {
                    __int16 v120 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
                  }
                  else {
                    __int16 v120 = "";
                  }
                  if (v111) {
                    double v121 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
                  }
                  else {
                    double v121 = "";
                  }
                  LODWORD(time.CFDictionarySetValue(theDict, key, value) = 136317186;
                  *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"fpfs_DecideAndSetAudioRenderPipelineRate";
                  LOWORD(time.flags) = 2048;
                  *(void *)((char *)&time.flags + 2) = v119;
                  HIWORD(time.epoch) = 2082;
                  CFTypeRef v166 = v120;
                  __int16 v167 = 2048;
                  uint64_t v168 = v111;
                  __int16 v169 = 2082;
                  uint64_t v170 = v121;
                  __int16 v171 = 1024;
                  *(_DWORD *)double v172 = HIBYTE(HIDWORD(v164));
                  *(_WORD *)&v172[4] = 1024;
                  *(_DWORD *)&v172[6] = BYTE6(v164);
                  __int16 v173 = 1024;
                  int v174 = BYTE5(v164);
                  __int16 v175 = 1024;
                  int v176 = BYTE4(v164);
                  _os_log_send_and_compose_impl();
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose();
              }
              *(_DWORD *)&v161[4] = 1065353216;
              *(float *)unsigned int v161 = a4;
              LOBYTE(v162) = 1;
            }
            CFNumberRef v122 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, &v161[4]);
            if (v122)
            {
              CFNumberRef v123 = v122;
              for (uint64_t i = v112[131]; i; uint64_t i = *(void *)(i + 8))
              {
                if (i != v5 && *(_DWORD *)(i + 32) == 1936684398)
                {
                  uint64_t v125 = *(void *)(i + 96);
                  if (v125)
                  {
                    double v126 = (uint64_t *)MEMORY[0x1E4F1CFD0];
                    if (!(_BYTE)v162)
                    {
                      double v126 = (uint64_t *)MEMORY[0x1E4F1CFD0];
                      if (!*(unsigned char *)(v113 + 521)) {
                        double v126 = (uint64_t *)MEMORY[0x1E4F1CFC8];
                      }
                    }
                    fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(v125, @"Muted", *v126);
                    uint64_t v127 = FigRenderPipelineGetFigBaseObject(*(void *)(*(void *)(i + 96) + 32));
                    uint64_t v128 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v128) {
                      uint64_t v129 = v128;
                    }
                    else {
                      uint64_t v129 = 0;
                    }
                    uint64_t v130 = *(uint64_t (**)(uint64_t, __CFString *, CFNumberRef))(v129 + 56);
                    if (!v130)
                    {
                      uint64_t v45 = 4294954514;
                      goto LABEL_297;
                    }
                    uint64_t v131 = v130(v127, @"PipelineRate", v123);
                    if (v131) {
                      goto LABEL_322;
                    }
                  }
                }
              }
              if ((_BYTE)v162)
              {
                if (dword_1E9350BB0)
                {
                  unsigned int v160 = 0;
                  os_log_type_t v159 = OS_LOG_TYPE_DEFAULT;
                  uint64_t v132 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                  unsigned int v133 = v160;
                  if (os_log_type_enabled(v132, v159)) {
                    unsigned int v134 = v133;
                  }
                  else {
                    unsigned int v134 = v133 & 0xFFFFFFFE;
                  }
                  if (v134)
                  {
                    uint64_t v135 = *v155;
                    if (*v155) {
                      uint64_t v136 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
                    }
                    else {
                      uint64_t v136 = "";
                    }
                    if (v111) {
                      uint64_t v138 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
                    }
                    else {
                      uint64_t v138 = "";
                    }
                    LODWORD(time.CFDictionarySetValue(theDict, key, value) = 136316162;
                    *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"fpfs_DecideAndSetAudioRenderPipelineRate";
                    LOWORD(time.flags) = 2048;
                    *(void *)((char *)&time.flags + 2) = v135;
                    HIWORD(time.epoch) = 2082;
                    CFTypeRef v166 = v136;
                    __int16 v167 = 2048;
                    uint64_t v168 = v111;
                    __int16 v169 = 2082;
                    uint64_t v170 = v138;
                    _os_log_send_and_compose_impl();
                  }
                  fig_log_call_emit_and_clean_up_after_send_and_compose();
                }
                fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(*(void *)(v5 + 96), @"Muted", v151);
                *(unsigned char *)(v113 + 522) = 1;
                uint64_t v139 = *(void *)(v5 + 96);
                sizeOut[0] = valuePtr;
                CMTime time = type;
                uint64_t v45 = fpfs_setRateOnPrimaryAndAuxRenderPipelines(v139, (long long *)&sizeOut[0].value, (long long *)&time.value, *(float *)v161, *(float *)&v161[4]);
              }
              else
              {
                uint64_t v137 = *(void *)(v5 + 96);
                sizeOut[0] = valuePtr;
                CMTime time = type;
                uint64_t v131 = fpfs_setRateOnPrimaryAndAuxRenderPipelines(v137, (long long *)&sizeOut[0].value, (long long *)&time.value, *(float *)v161, *(float *)&v161[4]);
                if (v131)
                {
LABEL_322:
                  uint64_t v45 = v131;
LABEL_297:
                  CFRelease(v123);
                  int v41 = v153;
                  if (!v45) {
                    goto LABEL_298;
                  }
LABEL_306:
                  if (v41)
                  {
                    if (a4 != 0.0)
                    {
                      uint64_t v141 = CMBaseObjectGetDerivedStorage();
                      uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
                      uint64_t v143 = *(void *)(v141 + 2072);
                      if (v143)
                      {
                        uint64_t v144 = *(void *)(v141 + 2544);
                        if (v144)
                        {
                          uint64_t v145 = UpTimeNanoseconds;
                          uint64_t v146 = *(void *)(CMBaseObjectGetVTable() + 16);
                          uint64_t v147 = v146 ? v146 : 0;
                          uint64_t v149 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, void))(v147 + 56);
                          if (v149) {
                            v149(v144, 0x1EE582CD8, 0x1EE585CD8, (v145 - v143) / 0xF4240uLL, 0);
                          }
                        }
                      }
                    }
                  }
                  return v45;
                }
                if (!*(unsigned char *)(v113 + 521)) {
                  fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(*(void *)(v5 + 96), @"Muted", *MEMORY[0x1E4F1CFC8]);
                }
                uint64_t v45 = 0;
                *(unsigned char *)(v113 + 522) = 0;
              }
              *((_DWORD *)v155 + 222) = *(_DWORD *)&v161[4];
              goto LABEL_297;
            }
            FigSignalErrorAt();
          }
          else
          {
            uint64_t v45 = FigSignalErrorAt();
            if (v45) {
              goto LABEL_306;
            }
          }
LABEL_298:
          *(float *)(CMBaseObjectGetDerivedStorage() + 848) = a4;
          fpfsi_updateMaxPlayThroughTime();
          if (a4 != 0.0)
          {
            fpfs_CheckPrebufferedLevels(sizeOut, v6, 0, -1, 0);
            for (uint64_t j = (void *)v156[131]; j; uint64_t j = (void *)j[1])
            {
              if (j[14]) {
                fpfs_scheduleForwardEndTimeForTrack((uint64_t)v156, (uint64_t)j, 0);
              }
              if (j[33]) {
                fpfs_CheckVideoSyncQueue((uint64_t)j, 0);
              }
            }
            uint64_t v45 = 0;
            goto LABEL_306;
          }
          return 0;
        }
        goto LABEL_186;
      }
      if (MediaSubType == 2053464883)
      {
LABEL_186:
        sizeOut[0].CMTimeValue value = 0;
        int v88 = CMAudioFormatDescriptionGetFormatList(v83, (size_t *)sizeOut);
        int v85 = 0;
        if (!v88 || sizeOut[0].value < 0x30uLL) {
          goto LABEL_196;
        }
        int mFormatID = v88->mASBD.mFormatID;
        int v85 = 1;
        if (mFormatID <= 1885547314)
        {
          if (mFormatID == 1667574579) {
            goto LABEL_196;
          }
          int v90 = 1700997939;
        }
        else
        {
          if (mFormatID == 1885547315 || mFormatID == 1902324531) {
            goto LABEL_196;
          }
          int v90 = 2053319475;
        }
        if (mFormatID == v90) {
          goto LABEL_196;
        }
LABEL_195:
        int v85 = 0;
        goto LABEL_196;
      }
      if (MediaSubType == 2053319475) {
        goto LABEL_196;
      }
      int v87 = 1902469939;
    }
    else
    {
      if (MediaSubType > 1700997938)
      {
        if (MediaSubType == 1700997939) {
          goto LABEL_196;
        }
        if (MediaSubType != 1700998451)
        {
          int v86 = 1885547315;
          goto LABEL_184;
        }
        goto LABEL_186;
      }
      if (MediaSubType == 1667574579) {
        goto LABEL_196;
      }
      int v87 = 1667575091;
    }
    if (MediaSubType != v87) {
      goto LABEL_195;
    }
    goto LABEL_186;
  }
  return v45;
}

uint64_t fpfs_shouldReleaseRenderChainForPausing(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = CMBaseObjectGetDerivedStorage();
  if (*(float *)(DerivedStorage + 848) != 0.0) {
    return 0;
  }
  uint64_t v4 = v3;
  if (*(float *)(v3 + 108) != 0.0 || *(unsigned char *)(DerivedStorage + 2880)) {
    return 0;
  }
  if (fpfs_FirstRenderingTrackofType(a1, 1986618469) || (uint64_t result = fpfs_FirstRenderingTrackofType(a1, 1936684398)) != 0)
  {
    uint64_t v6 = *(void *)(DerivedStorage + 1704);
    if (v6 && FigAlternateIsIFrameOnly(v6)) {
      return 0;
    }
    return *(unsigned char *)(v4 + 760) || *(unsigned char *)(DerivedStorage + 2881) || *(_DWORD *)(v4 + 764) > 1;
  }
  return result;
}

uint64_t fpfsi_ReleaseRenderChainsForPausing(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(unsigned char *)(DerivedStorage + 2880) || (uint64_t v3 = DerivedStorage, *(float *)(DerivedStorage + 848) != 0.0))
  {
    return FigSignalErrorAt();
  }
  else
  {
    if ((*(unsigned char *)(DerivedStorage + 332) & 1) == 0)
    {
      fpfs_ClearRenderChains(a1, 231);
      uint64_t v4 = *(void *)(v3 + 1048);
      if (v4)
      {
        do
        {
          uint64_t v5 = *(void *)(v4 + 8);
          if (*(void *)(v4 + 96))
          {
            for (uint64_t i = 0; i != 5; ++i)
            {
              if (*(_DWORD *)&kCommonTypes[4 * i] == *(_DWORD *)(v4 + 32)) {
                break;
              }
            }
            if (((1 << i) & 0xE7) != 0)
            {
              fpfs_ReleaseTrackRenderChain(v4);
              if (*(_DWORD *)(v4 + 32) == 1936684398) {
                fpfs_PrepareAndEnqueueSpatialAudioRenderingChangedNotification(*(const void **)v3, *(const void **)v4, v7, v8, v9, v10, v11, v12);
              }
            }
          }
          if (!v5) {
            break;
          }
          uint64_t v4 = v5;
        }
        while (*(void *)(v3 + 1048));
      }
      *(unsigned char *)(v3 + 528) = 1;
      fpfs_SetRenderChainsReleasedForPause((uint64_t)a1, 1);
      *(unsigned char *)(v3 + 2881) = 0;
      fpfsi_EnqueuePlayableRangeChangedNotification(a1);
    }
    return 0;
  }
}

void fpfs_JumpToTime(const void *a1, CMTime *a2, int a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CMTime lhs = *a2;
  fpfs_SetTime((uint64_t)a1, &lhs);
  fpfsi_synchronizeLayerToTimebaseWithTransaction((uint64_t)a1, 0);
  if (a3) {
    fpfs_CheckPrebufferedLevels(&lhs, a1, 0, -1, 0);
  }
  CMTime lhs = *a2;
  if (fpfsi_atOrAfterTimeToPausePlayback(DerivedStorage, &lhs))
  {
    fpfs_HandleReachingTimeToPausePlayback(a1);
  }
  else if (*(unsigned char *)(DerivedStorage + 1460))
  {
    memset(&v12, 0, sizeof(v12));
    CMTime lhs = *(CMTime *)(DerivedStorage + 1448);
    *(_OWORD *)&rhs.CMTimeValue value = kTimeToPausePlaybackAdvanceNotice;
    rhs.CMTimeEpoch epoch = 0;
    CMTimeSubtract(&v12, &lhs, &rhs);
    memset(&v11, 0, sizeof(v11));
    fpfsi_EstimateTimeToPause((uint64_t)a1, &v10);
    CMTime lhs = *(CMTime *)(DerivedStorage + 1448);
    CMTimeSubtract(&v11, &lhs, &v10);
    CMTime lhs = *a2;
    CMTime rhs = v12;
    if (CMTimeCompare(&lhs, &rhs) >= 1)
    {
      CMTime lhs = *a2;
      CMTime rhs = *(CMTime *)(DerivedStorage + 1448);
      if (CMTimeCompare(&lhs, &rhs) < 0)
      {
        if (dword_1E9350BB0)
        {
          os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        int v8 = *(OpaqueCMTimebase **)(DerivedStorage + 576);
        int v9 = *(NSObject **)(DerivedStorage + 2336);
        CMTime lhs = v11;
        CMTimebaseSetTimerDispatchSourceNextFireTime(v8, v9, &lhs, 0);
      }
    }
  }
}

void fpfsi_updateItemTimePropertiesForRateChange(uint64_t a1, float a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  float v5 = *(float *)(DerivedStorage + 848);
  if (v5 != a2)
  {
    uint64_t v6 = DerivedStorage;
    if (v5 != 0.0 && *(unsigned char *)(DerivedStorage + 464) != 0)
    {
      if ((*(unsigned char *)(DerivedStorage + 236) & 1) == 0)
      {
        fpfs_GetTime(DerivedStorage, (uint64_t)&lhs);
        CMTime rhs = *(CMTime *)(v6 + 1184);
        CMTimeAdd(&v30, &lhs, &rhs);
        *(CMTime *)(v6 + 224) = v30;
      }
      uint64_t v8 = *(void *)(v6 + 1704);
      if ((!v8 || !FigAlternateIsIFrameOnly(v8)) && (*(unsigned char *)(v6 + 3040) & 1) == 0)
      {
        fpfs_GetTime(v6, (uint64_t)&v30);
        *(CMTime *)(v6 + 3028) = v30;
        *(void *)(v6 + 3056) = FigGetUpTimeNanoseconds();
      }
    }
    uint64_t v9 = *(void *)(v6 + 1704);
    if (!v9 || !FigAlternateIsIFrameOnly(v9))
    {
      if (*(double *)(v6 + 1944) != 0.0)
      {
        *(double *)(v6 + 1952) = *(double *)(v6 + 1952)
                               + (CFAbsoluteTimeGetCurrent() - *(double *)(v6 + 1944)) * fabsf(a2);
        *(double *)(v6 + 1960) = *(double *)(v6 + 1960) + CFAbsoluteTimeGetCurrent() - *(double *)(v6 + 1944);
        *(void *)(v6 + 1944) = 0;
      }
      if (*(float *)(v6 + 848) != 0.0)
      {
        double Current = CFAbsoluteTimeGetCurrent();
        *(double *)(v6 + 1944) = Current;
        if (*(double *)(v6 + 1928) == 0.0)
        {
          *(double *)(v6 + 1928) = Current;
          fpfs_GetTime(v6, (uint64_t)&v26);
          CMTime v30 = *(CMTime *)(v6 + 1184);
          CMTimeAdd(&time, &v26, &v30);
          double Seconds = CMTimeGetSeconds(&time);
          *(double *)(v6 + 1936) = Seconds;
          uint64_t v12 = *(void *)(v6 + 2544);
          if (v12)
          {
            double v13 = Seconds;
            uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 16);
            uint64_t v15 = v14 ? v14 : 0;
            uint64_t v16 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v15 + 56);
            if (v16) {
              v16(v12, 0x1EE582B78, 0x1EE583D58, 1000 * (uint64_t)v13, 0);
            }
          }
        }
      }
      double v17 = *(float *)(v6 + 848);
      uint64_t v18 = CMBaseObjectGetDerivedStorage();
      rhs.CMTimeValue value = 0;
      CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      double v20 = *(const void **)(v18 + 1704);
      CMTime v30 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
      if (!FigMetricItemRateChangeEventCreate(AllocatorForMedia, (long long *)&v30.value, 0, 0, v20, &rhs, v17, a2))
      {
        uint64_t v21 = *(void *)(v18 + 3376);
        CMTimeValue value = rhs.value;
        uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v23) {
          uint64_t v24 = v23;
        }
        else {
          uint64_t v24 = 0;
        }
        uint64_t v25 = *(void (**)(uint64_t, uint64_t, CMTimeValue))(v24 + 40);
        if (v25) {
          v25(v21, a1, value);
        }
      }
      if (rhs.value) {
        CFRelease((CFTypeRef)rhs.value);
      }
    }
    fpfsi_RTCReportingUpdatePlayingTrackStats(v6);
    fpfsi_RTCReportingReportRateChange(v6, *(float *)(v6 + 848));
  }
}

uint64_t fpfs_IssueSeekToPump(uint64_t a1, CMTime *a2, CMTime *a3, unsigned int a4, int a5, uint64_t a6, long long *a7, long long *a8, long long *a9)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v44 = CMBaseObjectGetDerivedStorage();
  memset(&v58, 0, sizeof(v58));
  double v17 = (_OWORD *)(DerivedStorage + 1184);
  CMTime lhs = *a2;
  CMTime rhs = *(CMTime *)(DerivedStorage + 1184);
  CMTimeAdd(&v57, &lhs, &rhs);
  CMTime lhs = v57;
  long long v46 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&rhs.CMTimeValue value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v18 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  rhs.CMTimeEpoch epoch = v18;
  if (CMTimeCompare(&lhs, &rhs) < 0)
  {
    *(_OWORD *)&v57.CMTimeValue value = v46;
    v57.CMTimeEpoch epoch = v18;
  }
  CMTime lhs = *a3;
  *(_OWORD *)&rhs.CMTimeValue value = *v17;
  rhs.CMTimeEpoch epoch = *(void *)(DerivedStorage + 1200);
  CMTimeAdd(&v58, &lhs, &rhs);
  *(_OWORD *)&lhs.CMTimeValue value = *v17;
  lhs.CMTimeEpoch epoch = *(void *)(DerivedStorage + 1200);
  *(_OWORD *)&rhs.CMTimeValue value = v46;
  rhs.CMTimeEpoch epoch = v18;
  if (CMTimeCompare(&lhs, &rhs))
  {
    CMTime lhs = *a2;
    *(_OWORD *)&rhs.CMTimeValue value = v46;
    rhs.CMTimeEpoch epoch = v18;
    if (!CMTimeCompare(&lhs, &rhs)
      || (lhs = v57, *(_OWORD *)&rhs.value = v46, rhs.CMTimeEpoch epoch = v18, !CMTimeCompare(&lhs, &rhs))
      || (*(_DWORD *)(DerivedStorage + 1364) & 0x1D) == 1
      && (lhs = v57, CMTime rhs = *(CMTime *)(DerivedStorage + 1352), CMTimeCompare(&lhs, &rhs) <= 0))
    {
      if (dword_1E9350BB0)
      {
        int v43 = a5;
        LODWORD(v63) = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v20 = v63;
        BOOL v21 = os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]);
        unsigned int v22 = v20 & 0xFFFFFFFE;
        if (v21) {
          unsigned int v22 = v20;
        }
        if (v22)
        {
          uint64_t v23 = *(void *)DerivedStorage;
          if (*(void *)DerivedStorage) {
            uint64_t v24 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
          }
          else {
            uint64_t v24 = "";
          }
          uint64_t v42 = v24;
          if (a1) {
            uint64_t v25 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
          }
          else {
            uint64_t v25 = "";
          }
          int v41 = v25;
          CMTime lhs = *a2;
          Float64 Seconds = CMTimeGetSeconds(&lhs);
          CMTime lhs = v57;
          Float64 v27 = CMTimeGetSeconds(&lhs);
          CMTime lhs = *(CMTime *)(DerivedStorage + 1352);
          Float64 v28 = CMTimeGetSeconds(&lhs);
          *(_OWORD *)&lhs.CMTimeValue value = *v17;
          lhs.CMTimeEpoch epoch = *(void *)(DerivedStorage + 1200);
          Float64 v29 = CMTimeGetSeconds(&lhs);
          LODWORD(rhs.CFDictionarySetValue(theDict, key, value) = 136317186;
          *(CMTimeValue *)((char *)&rhs.value + 4) = (CMTimeValue)"fpfs_IssueSeekToPump";
          LOWORD(rhs.flags) = 2048;
          *(void *)((char *)&rhs.flags + 2) = v23;
          HIWORD(rhs.epoch) = 2082;
          unsigned int v66 = v42;
          __int16 v67 = 2048;
          uint64_t v68 = a1;
          __int16 v69 = 2082;
          uint64_t v70 = v41;
          __int16 v71 = 2048;
          Float64 v72 = Seconds;
          __int16 v73 = 2048;
          Float64 v74 = v27;
          __int16 v75 = 2048;
          Float64 v76 = v28;
          __int16 v77 = 2048;
          Float64 v78 = v29;
          int v40 = 92;
          _os_log_send_and_compose_impl();
          a6 = a6;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        a5 = v43;
      }
      _OWORD *v17 = v46;
      *(void *)(DerivedStorage + 1200) = v18;
      uint64_t v30 = *(void *)(DerivedStorage + 96);
      *(_OWORD *)&lhs.CMTimeValue value = v46;
      lhs.CMTimeEpoch epoch = v18;
      FigAlternatePlaybackBitrateMonitorSetPumpOffset(v30, (uint64_t)&lhs);
    }
  }
  if (a5)
  {
    if ((~a3->flags & 0x11) != 0) {
      goto LABEL_31;
    }
    if (*(float *)(v44 + 108) >= 0.0)
    {
      CMTimeMake(&v56, 2, 1);
      CMTime rhs = v57;
      CMTimeSubtract(&lhs, &rhs, &v56);
    }
    else
    {
      CMTimeMake(&v55, 2, 1);
      CMTime rhs = v57;
      CMTimeAdd(&lhs, &rhs, &v55);
    }
    *(_OWORD *)&v58.CMTimeValue value = *(_OWORD *)&lhs.value;
    CMTimeEpoch epoch = lhs.epoch;
  }
  else
  {
    if ((*(unsigned char *)(DerivedStorage + 1508) & 1) == 0) {
      goto LABEL_31;
    }
    *(_OWORD *)&v58.CMTimeValue value = *MEMORY[0x1E4F1F9F8];
    CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  }
  v58.CMTimeEpoch epoch = epoch;
LABEL_31:
  uint64_t v32 = *(const void **)(DerivedStorage + 504);
  if (v32)
  {
    CFRelease(v32);
    *(void *)(DerivedStorage + 504) = 0;
  }
  uint64_t v33 = *(void *)(DerivedStorage + 936);
  CMTime v54 = v57;
  CMTime v53 = v58;
  long long v51 = *a7;
  uint64_t v52 = *((void *)a7 + 2);
  long long v49 = *a8;
  uint64_t v50 = *((void *)a8 + 2);
  long long v47 = *a9;
  uint64_t v48 = *((void *)a9 + 2);
  uint64_t v34 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v34) {
    uint64_t v35 = v34;
  }
  else {
    uint64_t v35 = 0;
  }
  uint64_t v36 = *(uint64_t (**)(uint64_t, CMTime *, CMTime *, void, uint64_t, long long *, os_log_type_t *, long long *, uint64_t, int))(v35 + 24);
  if (!v36)
  {
    uint64_t v37 = 4294954514;
    goto LABEL_41;
  }
  CMTime lhs = v54;
  CMTime rhs = v53;
  long long v63 = v51;
  uint64_t v64 = v52;
  *(_OWORD *)CMTime type = v49;
  uint64_t v62 = v50;
  long long v59 = v47;
  uint64_t v60 = v48;
  uint64_t v37 = v36(v33, &lhs, &rhs, a4, a6, &v63, type, &v59, DerivedStorage + 952, v40);
  if (v37)
  {
LABEL_41:
    fpfs_FlowControlPump(DerivedStorage, 0, 0, *(_DWORD *)(DerivedStorage + 1096));
    return v37;
  }
  uint64_t v38 = CMBaseObjectGetDerivedStorage();
  uint64_t v37 = 0;
  if (*(unsigned char *)(v38 + 470)) {
    *(unsigned char *)(v38 + 470) = 0;
  }
  return v37;
}

uint64_t fpfs_PrepareToReuseLastIFrameTrack(uint64_t a1, long long *a2, int a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t TrackOfType = fpfs_LastTrackOfType(a1, 1986618469, 0);
  uint64_t v8 = *(void *)DerivedStorage;
  long long v28 = *MEMORY[0x1E4F1F9F8];
  uint64_t v9 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  uint64_t v29 = v9;
  long long v25 = v28;
  long long v26 = v28;
  uint64_t v27 = v9;
  fpfs_setRateInternal(v8, a1, &v28, &v26, 0.0);
  if (TrackOfType)
  {
    if (*(unsigned char *)(TrackOfType + 184)) {
      uint64_t v10 = TrackOfType;
    }
    else {
      uint64_t v10 = 0;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(void *)(DerivedStorage + 1048);
  if (v11)
  {
    do
    {
      uint64_t v12 = *(void *)(v11 + 8);
      if (v11 != v10) {
        fpfs_DeleteTrack(a1, v11);
      }
      if (!v12) {
        break;
      }
      uint64_t v11 = v12;
    }
    while (*(void *)(DerivedStorage + 1048));
  }
  if (!v10) {
    goto LABEL_18;
  }
  if (!*(unsigned char *)(v10 + 182))
  {
    uint64_t v14 = v10;
    goto LABEL_24;
  }
  double v13 = fpfs_AddNewTrack(a1, *(_DWORD *)(v10 + 24), *(const void **)(v10 + 48), *(unsigned __int8 *)(v10 + 180), *(_DWORD *)(v10 + 32), *(_DWORD *)(v10 + 28));
  if (!v13)
  {
    fpfs_DeleteTrack(a1, v10);
LABEL_18:
    *(_OWORD *)(DerivedStorage + 1520) = v25;
    *(void *)(DerivedStorage + 1536) = v9;
    *(unsigned char *)(DerivedStorage + 1565) = 0;
LABEL_29:
    uint64_t result = 0;
    *(unsigned char *)(DerivedStorage + 528) = 1;
    return result;
  }
  uint64_t v14 = (uint64_t)v13;
  uint64_t v15 = v13[6];
  uint64_t v16 = *((unsigned int *)v13 + 6);
  uint64_t v17 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v17) {
    uint64_t v18 = v17;
  }
  else {
    uint64_t v18 = 0;
  }
  int v19 = *(void (**)(uint64_t, uint64_t, uint64_t (**)(int, int, int, CMFormatDescriptionRef), uint64_t))(v18 + 32);
  if (v19) {
    v19(v15, v16, &kManifoldOutputCallbacks, v14);
  }
  uint64_t result = fpfs_fmtDescChangeNote(*(const void **)(v14 + 48), *(_DWORD *)(v14 + 24), v14, *(CMFormatDescriptionRef *)(v10 + 40), *(const void **)(v10 + 384));
  if (result) {
    return result;
  }
  fpfs_DeleteTrack(a1, v10);
LABEL_24:
  long long v21 = *a2;
  *(void *)(v14 + 208) = *((void *)a2 + 2);
  *(_OWORD *)(v14 + 192) = v21;
  long long v22 = *a2;
  *(void *)(v14 + 232) = *((void *)a2 + 2);
  *(_OWORD *)(v14 + 216) = v22;
  uint64_t v23 = *(void *)(v14 + 96);
  if (v23)
  {
    fpfs_FlushPrimaryAndAuxRenderChains(v23, 1);
  }
  else if (a3)
  {
    fpfs_EnsureRenderChainForTrack(*(void *)DerivedStorage, v14, 0);
    fpfs_SetRenderChainsReleasedForPause(a1, 0);
  }
  uint64_t v24 = DerivedStorage + 24 * *(unsigned __int8 *)(v14 + 180);
  *(_OWORD *)(v24 + 248) = v25;
  *(void *)(v24 + 264) = v9;
  CMBufferQueueReset(*(CMBufferQueueRef *)(v14 + 80));
  uint64_t result = 0;
  *(void *)(DerivedStorage + 1536) = v9;
  *(_OWORD *)(DerivedStorage + 1520) = v25;
  *(unsigned char *)(DerivedStorage + 1565) = 0;
  if (!*(void *)(v14 + 96)) {
    goto LABEL_29;
  }
  return result;
}

uint64_t fpfsi_RTCReportingUpdatePlayingTrackStats(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 1048);
  if (v1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = v3;
      if (*(_DWORD *)(v1 + 152) == 6)
      {
        int v5 = *(_DWORD *)(v1 + 32);
        BOOL v6 = v5 == 1936684398 && v2 == 0;
        uint64_t v3 = v1;
        uint64_t v7 = v1;
        if (!v6)
        {
          uint64_t v3 = v4;
          uint64_t v7 = v2;
          if (v5 == 1986618469)
          {
            uint64_t v3 = v1;
            return fpfsi_RTCReportingUpdateAlternateIndex(result, *(void *)(v3 + 432));
          }
        }
      }
      else
      {
        uint64_t v7 = v2;
      }
      uint64_t v1 = *(void *)(v1 + 8);
      uint64_t v2 = v7;
    }
    while (v1);
    if (!v3) {
      return result;
    }
    return fpfsi_RTCReportingUpdateAlternateIndex(result, *(void *)(v3 + 432));
  }
  return result;
}

void fpfsi_RTCReportingReportRateChange(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 2544);
  if (v4)
  {
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v6 + 56);
    if (v7) {
      v7(v4, 0x1EE582B78, 0x1EE583DB8, 23, 0);
    }
    uint64_t v8 = *(void *)(a1 + 2544);
    if (v8)
    {
      uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v9) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = 0;
      }
      uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v10 + 56);
      if (v11) {
        v11(v8, 0x1EE582B78, 0x1EE54F698, (uint64_t)(a2 * 100.0), 0);
      }
      uint64_t v12 = *(void *)(a1 + 2544);
      if (v12)
      {
        uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v14 = v13 ? v13 : 0;
        uint64_t v15 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void, void))(v14 + 16);
        if (v15) {
          v15(v12, 0x1EE582B78, 106, 0, 0, 0);
        }
      }
    }
  }
  if (a2 >= 1.0 && *(unsigned char *)(a1 + 2594) == 0)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    double v18 = *(double *)(a1 + 2992);
    *(unsigned char *)(a1 + 2594) = 1;
    uint64_t v19 = *(void *)(a1 + 2544);
    if (v19)
    {
      double v20 = Current;
      uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v22 = v21 ? v21 : 0;
      uint64_t v23 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v22 + 56);
      if (v23) {
        v23(v19, 0x1EE582B78, 0x1EE584AF8, (uint64_t)((v20 - v18) * 1000.0), 0);
      }
    }
  }
  if (a2 == 0.0)
  {
    uint64_t v24 = *(void *)(a1 + 2544);
    if (v24)
    {
      uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v26 = v25 ? v25 : 0;
      uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void, void))(v26 + 16);
      if (v27)
      {
        v27(v24, 0x1EE582B78, 901, 0, 0, 0);
      }
    }
  }
}

uint64_t fpfs_FlowControlPump(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  if (!*(void *)(a1 + 936)) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 2544);
  if (v8)
  {
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v10 = v9 ? v9 : 0;
    uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v10 + 56);
    if (v11) {
      v11(v8, 0x1EE582B78, 0x1EE5851F8, a2, 0);
    }
  }
  int v12 = 0;
  while (1)
  {
    uint64_t v13 = *(void *)(a1 + 936);
    if (!v13) {
      break;
    }
    if (((1 << v12) & a4) != 0)
    {
      uint64_t v14 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v14) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = 0;
      }
      double v18 = *(void (**)(uint64_t, void))(v15 + 16);
      if (v18) {
        v18(v13, v12);
      }
      if (!*(unsigned char *)(a1 + 2080) && *(void *)(a1 + 2072) && !*(unsigned char *)(a1 + 2081))
      {
        uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
        uint64_t v20 = *(void *)(a1 + 2544);
        if (v20)
        {
          uint64_t v21 = UpTimeNanoseconds;
          uint64_t v22 = *(void *)(a1 + 2072);
          uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v23) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = 0;
          }
          uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, void))(v24 + 56);
          if (v26) {
            v26(v20, 0x1EE582CD8, 0x1EE585C78, (v21 - v22) / 0xF4240uLL, 0);
          }
        }
        *(unsigned char *)(a1 + 2080) = 1;
      }
    }
    else if (((1 << v12) & a2) != 0)
    {
      uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v17 = v16 ? v16 : 0;
      uint64_t v25 = *(void (**)(uint64_t, void, uint64_t))(v17 + 8);
      if (v25) {
        v25(v13, v12, a3);
      }
    }
    if (++v12 == 3) {
      return 0;
    }
  }

  return FigSignalErrorAt();
}

uint64_t fpfs_LastTrackOfType(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage() + 1048);
  BOOL v6 = v5 == 0;
  uint64_t result = 0;
  while (!v6 && v5 != a3)
  {
    if (*(_DWORD *)(v5 + 32) == a2) {
      uint64_t result = v5;
    }
    uint64_t v5 = *(void *)(v5 + 8);
    BOOL v6 = v5 == 0;
  }
  return result;
}

void fpfs_DeleteTrack(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v5 = *(const void **)DerivedStorage;
  uint64_t v6 = CMBaseObjectGetDerivedStorage();
  int isTrackInLists = fpfsi_isTrackInLists(DerivedStorage, a2, 3u);
  int v8 = dword_1E9350BB0;
  if (!isTrackInLists && dword_1E9350BB0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    int v8 = dword_1E9350BB0;
  }
  if (v8)
  {
    uint64_t v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  fpfs_CompleteLogIfLastTrack((uint64_t)a1, a2);
  if (*(void *)(a2 + 96))
  {
    if (*(_DWORD *)(a2 + 32) != 1986618469)
    {
      int v11 = fpfs_itemContainsTrackWithSharedRenderChain((uint64_t)a1, a2);
      CFArrayRef Next = fpfs_getNext(v6, *(const void **)(v6 + 80));
      if (!Next || !fpfs_itemContainsTrackWithSharedRenderChain((uint64_t)Next, a2))
      {
        uint64_t v13 = *(void *)(v6 + 80);
        if ((const void *)v13 == a1 || v13 == 0)
        {
          BOOL v15 = 0;
          if (v11) {
            goto LABEL_21;
          }
        }
        else
        {
          BOOL v15 = fpfs_itemContainsTrackWithSharedRenderChain(v13, a2) != 0;
          if (v11) {
            goto LABEL_21;
          }
        }
        if (!v15)
        {
          fpfs_FlushPrimaryAndAuxRenderChains(*(void *)(a2 + 96), 1);
          for (uint64_t i = *(void *)(a2 + 96); i; uint64_t i = *(void *)(i + 88))
          {
            CMNotificationCenterGetDefaultLocalCenter();
            CMNotificationCenterPostNotification();
          }
        }
      }
    }
  }
LABEL_21:
  double v18 = (uint64_t *)(a2 + 8);
  uint64_t v17 = *(void *)(a2 + 8);
  if (v17)
  {
    while (*(_DWORD *)(v17 + 32) != *(_DWORD *)(a2 + 32)
         || !*(void *)(v17 + 40)
         || !fpfsi_canTracksBeSyncPairsIgnoringDiscontinuity(a2, v17))
    {
      uint64_t v17 = *(void *)(v17 + 8);
      if (!v17) {
        goto LABEL_26;
      }
    }
    char v19 = 0;
  }
  else
  {
LABEL_26:
    char v19 = 1;
  }
  int v20 = fpfs_shouldCheckAndReportVariantEnded(a2);
  fpfs_ReleaseTrackRenderChain(a2);
  if (*(_DWORD *)(a2 + 32) == 1936684398) {
    fpfs_PrepareAndEnqueueSpatialAudioRenderingChangedNotification(*(const void **)DerivedStorage, *(const void **)a2, v21, v22, v23, v24, v25, v26);
  }
  uint64_t v27 = (uint64_t *)(DerivedStorage + 1048);
  long long v28 = (void *)(DerivedStorage + 1048);
  do
  {
    uint64_t v29 = *v28;
    long long v28 = (void *)(*v28 + 8);
    if (v29) {
      BOOL v30 = v29 == a2;
    }
    else {
      BOOL v30 = 1;
    }
  }
  while (!v30);
  if (v29)
  {
    if (v20) {
      fpfsi_RTCReportingReportCheckAndReportVariantEnded(DerivedStorage, a2);
    }
    uint64_t v31 = *v27;
    if (*v27 == a2)
    {
      uint64_t v42 = *v18;
      *uint64_t v27 = *v18;
      if (!v42) {
        *(void *)(DerivedStorage + 1056) = v27;
      }
    }
    else
    {
      do
      {
        uint64_t v32 = v31;
        uint64_t v31 = *(void *)(v31 + 8);
      }
      while (v31 != a2);
      uint64_t v33 = *v18;
      *(void *)(v32 + 8) = *v18;
      uint64_t v34 = v32 + 8;
      if (!v33) {
        *(void *)(DerivedStorage + 1056) = v34;
      }
    }
  }
  else
  {
    uint64_t v35 = (uint64_t *)(DerivedStorage + 1064);
    uint64_t v36 = (void *)(DerivedStorage + 1064);
    do
    {
      uint64_t v37 = *v36;
      uint64_t v36 = (void *)(*v36 + 8);
      if (v37) {
        BOOL v38 = v37 == a2;
      }
      else {
        BOOL v38 = 1;
      }
    }
    while (!v38);
    if (v37)
    {
      uint64_t v39 = *v35;
      if (*v35 == a2)
      {
        uint64_t v43 = *v18;
        *uint64_t v35 = *v18;
        if (v43) {
          goto LABEL_58;
        }
      }
      else
      {
        do
        {
          uint64_t v40 = v39;
          uint64_t v39 = *(void *)(v39 + 8);
        }
        while (v39 != a2);
        uint64_t v41 = *v18;
        *(void *)(v40 + 8) = *v18;
        uint64_t v35 = (uint64_t *)(v40 + 8);
        if (v41) {
          goto LABEL_58;
        }
      }
      *(void *)(DerivedStorage + 1072) = v35;
    }
  }
LABEL_58:
  fpfs_ReleaseAndClearTimebaseTimer(*(OpaqueCMTimebase **)(DerivedStorage + 576), (dispatch_object_t *)(a2 + 112));
  fpfs_ReleaseAndClearTimebaseTimer(*(OpaqueCMTimebase **)(DerivedStorage + 576), (dispatch_object_t *)(a2 + 120));
  fpfs_ReleaseAndClearDispatchSource((dispatch_object_t *)(a2 + 264));
  fpfs_StopFeedingTrack(a2, 0, 0);
  uint64_t v50 = *(const void **)(a2 + 48);
  if (v50)
  {
    *(void *)(a2 + 48) = 0;
    CFRelease(v50);
  }
  long long v51 = *(const void **)(a2 + 72);
  if (v51)
  {
    CFRelease(v51);
    *(void *)(a2 + 72) = 0;
  }
  uint64_t v52 = *(opaqueCMBufferQueue **)(a2 + 80);
  if (v52)
  {
    BufferCFArrayRef Count = CMBufferQueueGetBufferCount(v52);
    uint64_t v54 = *(void *)(a2 + 80);
    if (BufferCount >= 1)
    {
      fpfs_SendBufferQueueToChomper(v6, v54);
LABEL_67:
      *(void *)(a2 + 80) = 0;
      goto LABEL_68;
    }
    if (v54)
    {
      CFRelease(*(CFTypeRef *)(a2 + 80));
      goto LABEL_67;
    }
  }
LABEL_68:
  if (*(void *)(a2 + 384))
  {
    fpfsi_RemoveCPECryptorListenersOncePerItem((uint64_t)a1, a2);
    CMTime v55 = *(const void **)(a2 + 384);
    if (v55)
    {
      CFRelease(v55);
      *(void *)(a2 + 384) = 0;
    }
  }
  if (v19)
  {
    fpfs_ChangeTrackState(a2, 8u);
    CMTime v56 = (void *)(DerivedStorage + 1080);
    do
    {
      uint64_t v57 = *v56;
      CMTime v56 = (void *)(*v56 + 8);
      if (v57) {
        BOOL v58 = v57 == a2;
      }
      else {
        BOOL v58 = 1;
      }
    }
    while (!v58);
    if (v57)
    {
      long long v59 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    else
    {
      *(void *)(a2 + 8) = 0;
      **(void **)(DerivedStorage + 1088) = a2;
      *(void *)(DerivedStorage + 1088) = v18;
    }
  }
  else
  {
    fpfs_PrepareAndEnqueueTracksChangedNotification(v5, a1, v44, v45, v46, v47, v48, v49);
    if (!*(void *)(v6 + 8) && dword_1E9350BB0)
    {
      uint64_t v60 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    fpfs_FreeTrack((void *)a2);
  }
}

void *fpfs_AddNewTrack(uint64_t a1, int a2, const void *a3, unsigned int a4, int a5, int a6)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v13 = malloc_type_calloc(1uLL, 0x220uLL, 0x10E0040EA42D65DuLL);
  if (!v13) {
    return v13;
  }
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CallbacksForUnsortedSampleBuffers = CMBufferQueueGetCallbacksForUnsortedSampleBuffers();
  if (CMBufferQueueCreate(AllocatorForMedia, 0, CallbacksForUnsortedSampleBuffers, (CMBufferQueueRef *)v13 + 9)
    || (CFAllocatorRef v16 = (const __CFAllocator *)FigGetAllocatorForMedia(),
        uint64_t v17 = CMBufferQueueGetCallbacksForUnsortedSampleBuffers(),
        CMBufferQueueCreate(v16, 0, v17, (CMBufferQueueRef *)v13 + 10)))
  {
    free(v13);
    return 0;
  }
  *uint64_t v13 = a1;
  uint64_t v18 = *(void *)(DerivedStorage + 1120) + 1;
  *(void *)(DerivedStorage + 1120) = v18;
  v13[2] = v18;
  *((_DWORD *)v13 + 6) = a2;
  uint64_t v19 = MEMORY[0x1E4F1F9F8];
  long long v39 = *MEMORY[0x1E4F1F9F8];
  *((_OWORD *)v13 + 8) = *MEMORY[0x1E4F1F9F8];
  uint64_t v20 = *(void *)(v19 + 16);
  v13[18] = v20;
  *((_OWORD *)v13 + 12) = v39;
  v13[26] = v20;
  CFTypeRef v21 = CFRetain(a3);
  v13[6] = v21;
  *((unsigned char *)v13 + 180) = a4;
  uint64_t v22 = DerivedStorage + 8 * a4;
  int v23 = (void *)(v22 + 1152);
  int v24 = (void *)(v22 + 1128);
  if (v21 == *(CFTypeRef *)(DerivedStorage + 16 * a4 + 1008)) {
    int v25 = v23;
  }
  else {
    int v25 = v24;
  }
  v13[8] = *v25;
  *(_OWORD *)(v13 + 27) = v39;
  v13[29] = v20;
  *((_OWORD *)v13 + 15) = v39;
  v13[32] = v20;
  *((_OWORD *)v13 + 17) = v39;
  v13[36] = v20;
  uint64_t v26 = MEMORY[0x1E4F1FA48];
  long long v27 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)((char *)v13 + 396) = *MEMORY[0x1E4F1FA48];
  uint64_t v28 = *(void *)(v26 + 16);
  *(void *)((char *)v13 + 412) = v28;
  v13[42] = v28;
  *((_OWORD *)v13 + 20) = v27;
  v13[53] = -1;
  v13[43] = FigGetUpTimeNanoseconds();
  *(_OWORD *)(v13 + 45) = v39;
  v13[47] = v20;
  fpfsi_SetTrackMediaType(DerivedStorage, (uint64_t)v13, a5);
  uint64_t v29 = MEMORY[0x1E4F1FA20];
  long long v30 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
  *((_OWORD *)v13 + 31) = *MEMORY[0x1E4F1FA20];
  *((_OWORD *)v13 + 32) = v30;
  *((_OWORD *)v13 + 33) = *(_OWORD *)(v29 + 32);
  if (!a6) {
    a6 = *((_DWORD *)v13 + 4);
  }
  *((_DWORD *)v13 + 7) = a6;
  v13[1] = 0;
  **(void **)(DerivedStorage + 1056) = v13;
  *(void *)(DerivedStorage + 1056) = v13 + 1;
  int v31 = *((_DWORD *)v13 + 8);
  if (v31 <= 1935832171)
  {
    if (v31 != 1668047728 && v31 != 1835365473) {
      goto LABEL_25;
    }
    goto LABEL_17;
  }
  switch(v31)
  {
    case 1935832172:
LABEL_17:
      *((unsigned char *)v13 + 184) = 1;
      break;
    case 1936684398:
      goto LABEL_18;
    case 1986618469:
      uint64_t v32 = *(void *)(DerivedStorage + 1704);
      if (v32)
      {
        BOOL v33 = FigAlternateIsIFrameOnly(v32) != 0;
        goto LABEL_19;
      }
LABEL_18:
      BOOL v33 = 0;
LABEL_19:
      *((unsigned char *)v13 + 184) = v33;
      fpfs_CreateTrackDryTimer((uint64_t)v13);
      uint64_t v34 = *(void *)(DerivedStorage + 1704);
      if (v34)
      {
        valuePtr[0] = FigAlternateGetAlternateIndex(v34);
        v13[54] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, valuePtr);
        uint64_t v35 = 1704;
        if (v13[6] == *(void *)(DerivedStorage + 16 * *((unsigned __int8 *)v13 + 180) + 1008)) {
          uint64_t v35 = 1768;
        }
        CFTypeRef v36 = *(CFTypeRef *)(DerivedStorage + v35);
        if (v36) {
          CFTypeRef v36 = CFRetain(v36);
        }
        v13[55] = v36;
        v13[56] = *(void *)(DerivedStorage + 1752);
      }
      break;
  }
LABEL_25:
  if (*MEMORY[0x1E4F1EBA8] == 1) {
    kdebug_trace();
  }
  if (dword_1E9350BB0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return v13;
}

uint64_t fpfs_fmtDescChangeNote(const void *a1, unsigned int a2, uint64_t a3, CMFormatDescriptionRef desc, const void *a5)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  CMMediaType MediaType = CMFormatDescriptionGetMediaType(desc);
  uint64_t v9 = *(const void **)a3;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  int v11 = *(const void **)DerivedStorage;
  uint64_t v12 = CMBaseObjectGetDerivedStorage();
  BOOL v13 = (*(unsigned char *)(a3 + 228) & 1) == 0 || CMBufferQueueGetBufferCount(*(CMBufferQueueRef *)(a3 + 80)) == 0;
  BOOL v100 = v13;
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(desc);
  fpfs_LockMutexWithCaller(v11);
  if (!*(_DWORD *)(v12 + 32) || *(CMFormatDescriptionRef *)(a3 + 40) == desc && *(const void **)(a3 + 384) == a5)
  {
LABEL_183:
    uint64_t v16 = 0;
    goto LABEL_184;
  }
  if (MediaType != 1986618469) {
    goto LABEL_45;
  }
  if (*(void *)(a3 + 440))
  {
    int VideoDynamicRange = CMVideoFormatDescriptionGetVideoDynamicRange();
    if (VideoDynamicRange >= 4
      && VideoDynamicRange != 7
      && FigAlternateGetVideoRange(*(void *)(a3 + 440)) != 3)
    {
      goto LABEL_190;
    }
  }
  if (!FPSupport_FormatDescriptionIndicatesStereoVideo(desc)) {
    goto LABEL_43;
  }
  uint64_t v16 = 4294954369;
  if (MediaSubType > 1836415072)
  {
    if (MediaSubType > 1902407031)
    {
      if (MediaSubType > 1902671458)
      {
        if (MediaSubType == 1902671459) {
          goto LABEL_40;
        }
        int v17 = 1902998904;
        goto LABEL_39;
      }
      if (MediaSubType == 1902407032) {
        goto LABEL_33;
      }
      int v17 = 1902667126;
    }
    else
    {
      if (MediaSubType > 1902405680)
      {
        if (MediaSubType == 1902405681) {
          goto LABEL_33;
        }
        int v18 = 1902405733;
        goto LABEL_32;
      }
      if (MediaSubType == 1836415073) {
        goto LABEL_40;
      }
      int v17 = 1869117027;
    }
  }
  else
  {
    if (MediaSubType <= 1685481572)
    {
      if (MediaSubType <= 1684895095)
      {
        if (MediaSubType != 1667524657)
        {
          int v17 = 1667790435;
          goto LABEL_39;
        }
        goto LABEL_33;
      }
      if (MediaSubType == 1684895096)
      {
LABEL_33:
        if (CMVideoFormatDescriptionGetVideoDynamicRange() == 10) {
          goto LABEL_43;
        }
LABEL_190:
        uint64_t v16 = FigSignalErrorAt();
        goto LABEL_196;
      }
      int v18 = 1685481521;
LABEL_32:
      if (MediaSubType != v18) {
        goto LABEL_155;
      }
      goto LABEL_33;
    }
    if (MediaSubType > 1751479856)
    {
      if (MediaSubType == 1751479857) {
        goto LABEL_40;
      }
      int v17 = 1752589105;
      goto LABEL_39;
    }
    if (MediaSubType == 1685481573) {
      goto LABEL_33;
    }
    int v17 = 1718908520;
  }
LABEL_39:
  if (MediaSubType != v17) {
    goto LABEL_155;
  }
LABEL_40:
  if (*(unsigned char *)(v12 + 873)
    && !FPSupport_FormatDescriptionIndicatesFishEyeProjection(desc)
    && CMVideoFormatDescriptionGetVideoDynamicRange() != 1)
  {
    goto LABEL_190;
  }
LABEL_43:
  if (!FPSupport_FormatDescriptionIndicatesStereoVideo(desc)
    && CMVideoFormatDescriptionGetVideoDynamicRange() == 10)
  {
    goto LABEL_190;
  }
LABEL_45:
  uint64_t v104 = v12;
  uint64_t v19 = v9;
  CFDictionaryRef v20 = *(const __CFDictionary **)(DerivedStorage + 400);
  if (!v20
    || (CFArrayRef v21 = (const __CFArray *)CFDictionaryGetValue(v20, @"assetOption_AllowableVideoCodecTypes"),
        uint64_t v22 = v11,
        v23 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 400), @"assetOption_AllowableAudioCodecTypes"), v24 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 400), @"assetOption_AllowableCaptionsFormats"), v25 = v23, int v11 = v22, FPSupport_IsFormatDescAllowable(desc, v21, v25, v24)))
  {
    if (MediaType == 1986618469)
    {
      uint64_t v26 = *(__SecTask **)(v104 + 56);
      if (v26 && (MediaSubType == 1667331683 || MediaSubType == 1667790435 || MediaSubType == 1667524657))
      {
        CFTypeRef v27 = SecTaskCopyValueForEntitlement(v26, @"com.apple.coremedia.allow-mpeg4streaming", 0);
        CFTypeRef v28 = v27;
        CFTypeRef v29 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
        if (v27) {
          CFRelease(v27);
        }
        uint64_t v9 = v19;
        if (v28 != v29) {
          goto LABEL_193;
        }
        char v30 = 0;
LABEL_61:
        int v31 = *(const opaqueCMFormatDescription **)(a3 + 40);
        uint64_t v102 = v11;
        if (!v31)
        {
          fpfsi_SetTrackMediaType(DerivedStorage, a3, MediaType);
          goto LABEL_68;
        }
        if (*(_DWORD *)(a3 + 32) == MediaType)
        {
          if (!fpfs_FormatsAreCompatible((uint64_t)v9, desc, v31))
          {
            fpfs_StopFeedingTrack(a3, 0, 1);
            uint64_t v32 = fpfs_AddNewTrack((uint64_t)v9, a2, a1, *(unsigned __int8 *)(a3 + 180), MediaType, *(_DWORD *)(a3 + 28));
            if (!v32)
            {
LABEL_194:
              uint64_t v16 = FigSignalErrorAt();
              int v11 = v102;
              goto LABEL_195;
            }
            uint64_t v33 = (uint64_t)v32;
            if (v100)
            {
              fpfs_DeleteTrack(v9, a3);
              char v101 = 0;
              a3 = v33;
            }
            else
            {
              char v101 = 0;
            }
LABEL_69:
            uint64_t v34 = *(void *)(v33 + 48);
            uint64_t v35 = *(unsigned __int8 *)(v33 + 180);
            uint64_t v36 = *(void *)(DerivedStorage + 16 * v35 + 1008);
            if (*(unsigned char *)(DerivedStorage + v35 + ((v34 == v36) | (2 * (v34 == v36))) + 512) | (v34 == v36)
              && !*(void *)(a3 + 40))
            {
              for (uint64_t i = *(void *)(DerivedStorage + 1048); i; uint64_t i = *(void *)(i + 8))
              {
                uint64_t v38 = *(void *)(i + 48);
                if (v38 != v34
                  && *(_DWORD *)(i + 152) == 6
                  && *(void *)(i + 64) == *(void *)(v33 + 64)
                  && v38 != *(void *)(DerivedStorage + 16 * *(unsigned __int8 *)(i + 180) + 1008))
                {
                  goto LABEL_78;
                }
              }
              if (v34 == v36)
              {
LABEL_78:
                if (*(_DWORD *)(v33 + 32) != 1986618469 || fpfs_CanRenderVideo(v104, (uint64_t)v9))
                {
                  fpfs_ChangeTrackState(v33, 1u);
                  if (*(_DWORD *)(DerivedStorage + 2792) > *(_DWORD *)(DerivedStorage + 2796))
                  {
                    int v39 = *(_DWORD *)(v33 + 32);
                    if (v39 == 1986618469)
                    {
                      *(unsigned char *)(DerivedStorage + 2825) = 1;
                    }
                    else if (v39 == 1936684398)
                    {
                      *(unsigned char *)(DerivedStorage + 2824) = 1;
                    }
                  }
                }
              }
            }
            uint64_t v40 = *(const void **)(v33 + 40);
            *(void *)(v33 + 40) = desc;
            if (desc) {
              CFRetain(desc);
            }
            if (v40) {
              CFRelease(v40);
            }
            int v41 = *(_DWORD *)(v33 + 32);
            if (v41 == 1986618469)
            {
              cf.CMTimeValue value = 0;
              uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
              uint64_t v43 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v43) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = 0;
              }
              int v45 = *(unsigned int (**)(const void *, void, __CFString *, uint64_t, CMTime *))(v44 + 48);
              if (v45 && !v45(a1, a2, @"FMFD_TrackMatrixArray", AllocatorForMedia, &cf))
              {
                int v46 = *(const void **)(v33 + 56);
                CMTimeValue value = (const void *)cf.value;
                *(void *)(v33 + 56) = cf.value;
                if (value) {
                  CFRetain(value);
                }
                if (v46) {
                  CFRelease(v46);
                }
              }
              if (cf.value) {
                CFRelease((CFTypeRef)cf.value);
              }
              int v41 = *(_DWORD *)(v33 + 32);
            }
            if (v41 != 1936684398)
            {
LABEL_117:
              uint64_t v12 = v104;
              if ((v101 & 1) == 0)
              {
                uint64_t v59 = *(void *)(CMBaseObjectGetVTable() + 16);
                if (v59) {
                  uint64_t v60 = v59;
                }
                else {
                  uint64_t v60 = 0;
                }
                unsigned int v61 = *(uint64_t (**)(const void *, void, void, uint64_t))(v60 + 32);
                if (!v61) {
                  goto LABEL_153;
                }
                uint64_t HasStarted = v61(a1, a2, &kManifoldOutputCallbacks, v33);
                if (HasStarted) {
                  goto LABEL_198;
                }
              }
              for (uint64_t j = *(void *)(DerivedStorage + 1048); j; uint64_t j = *(void *)(j + 8))
              {
                if (*(_DWORD *)(j + 32) == *(_DWORD *)(v33 + 32) && !*(void *)(j + 96)) {
                  break;
                }
              }
              if (j == v33 && (MediaType == 1986618469 || MediaType == 1936684398))
              {
                for (uint64_t k = 0; k != 5; ++k)
                {
                  if (*(_DWORD *)&kCommonTypes[4 * k] == MediaType) {
                    break;
                  }
                }
                uint64_t v66 = *(void *)(DerivedStorage + 8 * k + 792);
                if (v66)
                {
                  if (!fpfs_FormatsAreCompatible((uint64_t)v9, desc, *(const opaqueCMFormatDescription **)(v66 + 16)))
                  {
                    for (uint64_t m = 0; m != 5; ++m)
                    {
                      if (*(_DWORD *)&kCommonTypes[4 * m] == MediaType) {
                        break;
                      }
                    }
                    fpfs_ClearRenderChains(v9, (1 << m));
                  }
                }
              }
              if (*(void *)(v33 + 384))
              {
                fpfsi_RemoveCPECryptorListenersOncePerItem((uint64_t)v9, v33);
                uint64_t v64 = *(const void **)(v33 + 384);
              }
              else
              {
                uint64_t v64 = 0;
              }
              *(void *)(v33 + 384) = a5;
              if (a5) {
                CFRetain(a5);
              }
              if (v64) {
                CFRelease(v64);
              }
              if (!a5) {
                goto LABEL_170;
              }
              uint64_t v68 = *(void *)(v104 + 672);
              uint64_t v69 = *(void *)(CMBaseObjectGetVTable() + 8);
              if (v69) {
                uint64_t v70 = v69;
              }
              else {
                uint64_t v70 = 0;
              }
              __int16 v71 = *(uint64_t (**)(const void *, __CFString *, uint64_t))(v70 + 56);
              if (v71)
              {
                uint64_t v72 = v71(a5, @"DisplayList", v68);
                if (v72 == -12785)
                {
                  uint64_t v16 = 4294954373;
LABEL_154:
                  int v11 = v102;
                  goto LABEL_155;
                }
                uint64_t v16 = v72;
                if (v72) {
                  goto LABEL_154;
                }
                uint64_t v73 = *(void *)(v33 + 384);
                uint64_t v74 = CMBaseObjectGetDerivedStorage();
                if (v73)
                {
                  uint64_t v75 = *(void *)(v74 + 1048);
                  if (v75)
                  {
                    while (v75 == v33 || *(void *)(v75 + 384) != v73)
                    {
                      uint64_t v75 = *(void *)(v75 + 8);
                      if (!v75) {
                        goto LABEL_162;
                      }
                    }
                  }
                  else
                  {
LABEL_162:
                    uint64_t v76 = *(void *)(v74 + 1064);
                    if (v76)
                    {
                      while (v76 == v33 || *(void *)(v76 + 384) != v73)
                      {
                        uint64_t v76 = *(void *)(v76 + 8);
                        if (!v76) {
                          goto LABEL_166;
                        }
                      }
                    }
                    else
                    {
LABEL_166:
                      CMNotificationCenterGetDefaultLocalCenter();
                      uint64_t HasStarted = FigNotificationCenterAddWeakListener();
                      if (HasStarted) {
                        goto LABEL_198;
                      }
                      CMNotificationCenterGetDefaultLocalCenter();
                      uint64_t HasStarted = FigNotificationCenterAddWeakListener();
                      if (HasStarted) {
                        goto LABEL_198;
                      }
                    }
                  }
                }
                if (!fpfs_isDecryptorReady(v33)
                  || (uint64_t HasStarted = fpfs_ensureDecryptorHasStarted(v33), !HasStarted))
                {
LABEL_170:
                  fpfsi_PostExternalProtectionRequiredChangedNotification(v9);
                  fpfs_ExternalProtectionStatusChangedGuts(*(const void **)DerivedStorage, v77, v78, v79, v80, v81, v82, v83);
                  int v90 = *(_DWORD *)(v33 + 32);
                  int v11 = v102;
                  if (v90 == 1986618469)
                  {
                    fpfsi_setHasDiscoveredVideoAndNotify(v102, v9);
                    fpfsi_setStereoAudioSpatializationByDefaultForVideoItem(v9);
                  }
                  int v91 = 0;
                  for (uint64_t n = 0; n != 3; ++n)
                  {
                    uint64_t v93 = 0;
                    char v94 = 1;
                    do
                    {
                      char v95 = v94;
                      if (*(void *)(DerivedStorage + 16 * n + 8 * v93 + 1000)) {
                        int v96 = 1 << n;
                      }
                      else {
                        int v96 = 0;
                      }
                      v91 |= v96;
                      uint64_t v93 = 1;
                      char v94 = 0;
                    }
                    while ((v95 & 1) != 0);
                  }
                  int v97 = *(_DWORD *)(DerivedStorage + 1096);
                  if (v97 == v91)
                  {
                    fpfs_PrepareAndEnqueueTracksChangedNotification(v102, v9, v84, v85, v86, v87, v88, v89);
                    fpfs_FreeDeadTracks((void *)DerivedStorage);
                    int v97 = *(_DWORD *)(DerivedStorage + 1096);
                  }
                  if (((v97 ^ v91) & 3) == 0) {
                    fpfs_PostHasEnabledTrackTypeNotification(*(const void **)DerivedStorage, v9);
                  }
                  goto LABEL_183;
                }
LABEL_198:
                uint64_t v16 = HasStarted;
                goto LABEL_154;
              }
LABEL_153:
              uint64_t v16 = 4294954514;
              goto LABEL_154;
            }
            CMTimeValue v48 = *MEMORY[0x1E4F1F9F8];
            CFTypeRef v107 = 0;
            CMTimeValue v108 = v48;
            CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
            if (*(void *)(v33 + 40))
            {
              CMTimeFlags flags = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
              CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
              *(unsigned char *)(v33 + 420) = v30;
              uint64_t v51 = FigGetAllocatorForMedia();
              uint64_t v52 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v52) {
                uint64_t v53 = v52;
              }
              else {
                uint64_t v53 = 0;
              }
              uint64_t v54 = *(unsigned int (**)(const void *, void, __CFString *, uint64_t, CFTypeRef *))(v53 + 48);
              if (v54 && !v54(a1, a2, @"FMFD_TrackAudioPrimingDuration", v51, &v107) && v107)
              {
                CFTypeID v99 = CFGetTypeID(v107);
                if (v99 == CFDictionaryGetTypeID())
                {
                  CMTimeMakeFromDictionary(&cf, (CFDictionaryRef)v107);
                  CMTimeValue v108 = cf.value;
                  CMTimeFlags flags = cf.flags;
                  CMTimeScale timescale = cf.timescale;
                  CMTimeEpoch epoch = cf.epoch;
                }
                if (v107) {
                  CFRelease(v107);
                }
              }
              CMTime v55 = (CMTimeValue *)(v33 + 396);
              if ((flags & 0x1D) == 1)
              {
                *CMTime v55 = v108;
                *(_DWORD *)(v33 + 404) = timescale;
                *(_DWORD *)(v33 + 408) = flags;
                *(void *)(v33 + 412) = epoch;
                uint64_t v56 = *(void *)(CMBaseObjectGetVTable() + 8);
                if (v56) {
                  uint64_t v57 = v56;
                }
                else {
                  uint64_t v57 = 0;
                }
                uint64_t v9 = v19;
                BOOL v58 = *(void (**)(const void *, __CFString *, void))(v57 + 56);
                if (v58) {
                  v58(a1, @"FMFD_ProhibitPrimingTrim", *MEMORY[0x1E4F1CFD0]);
                }
              }
              else
              {
                FigGaplessInfoGetDefaultAudioPrimingDuration(*(const opaqueCMFormatDescription **)(v33 + 40), &cf);
                *(_OWORD *)CMTime v55 = *(_OWORD *)&cf.value;
                *(void *)(v33 + 412) = cf.epoch;
                uint64_t v9 = v19;
              }
              goto LABEL_117;
            }
            goto LABEL_194;
          }
LABEL_68:
          char v101 = 1;
          uint64_t v33 = a3;
          goto LABEL_69;
        }
LABEL_193:
        uint64_t v16 = FigSignalErrorAt();
LABEL_195:
        uint64_t v12 = v104;
LABEL_196:
        if (!v16) {
          goto LABEL_184;
        }
        goto LABEL_155;
      }
    }
    else if (MediaType == 1936684398)
    {
      char v30 = FigAudioFormatDescriptionEmploysDependentPackets();
LABEL_60:
      uint64_t v9 = v19;
      goto LABEL_61;
    }
    char v30 = 0;
    goto LABEL_60;
  }
  uint64_t v16 = 4294954369;
  uint64_t v9 = v19;
  uint64_t v12 = v104;
LABEL_155:
  fpfs_StopPlayingItemWithOSStatus(v12, (uint64_t)v9, v16);
LABEL_184:
  fpfs_UnlockAndPostNotificationsWithCaller(v11);
  return v16;
}

uint64_t fpfs_EnsureRenderChainForTrack(const void *a1, const __CFString **a2, int a3)
{
  uint64_t v3 = a2;
  uint64_t v492 = *MEMORY[0x1E4F143B8];
  CFStringRef v5 = *a2;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = CMBaseObjectGetDerivedStorage();
  p_isa = 0;
  if (*(unsigned char *)(DerivedStorage + 2880))
  {
    LODWORD(values.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(type[0]) = 0;
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (v3[48])
  {
    if (fpfs_isDecryptorReady((uint64_t)v3))
    {
      uint64_t HasStarted = fpfs_ensureDecryptorHasStarted((uint64_t)v3);
      if (HasStarted) {
        return HasStarted;
      }
    }
  }
  if (*(unsigned char *)(DerivedStorage + 2448)
    && (const __CFString **)fpfs_FirstTrackWithFormatDescriptionOfType((uint64_t)v5, 1936684398) == v3
    && (CFStringRef v23 = *(const __CFString **)(v7 + 80), v5 != v23)
    && v5 == (const __CFString *)fpfs_getNext(v7, v23))
  {
    uint64_t OutputDestinationForVideo = fpfs_CommitToGaplessTransition(*(void *)(v7 + 80), v5);
    if (!OutputDestinationForVideo || v3[12])
    {
LABEL_690:
      if (*((_DWORD *)v3 + 8) == 1936684398)
      {
        uint64_t v421 = (uint64_t)v3[55];
        CFDictionaryRef CurrentAudioPersistentIDFromMediaOption = fpfsi_GetCurrentAudioPersistentIDFromMediaOption();
        uint64_t AudioInstreamID = FigAlternateGetAudioInstreamID(v421, CurrentAudioPersistentIDFromMediaOption);
        if (AudioInstreamID)
        {
          uint64_t v424 = AudioInstreamID;
          uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v3[12][1].isa);
          uint64_t v426 = *(void *)(CMBaseObjectGetVTable() + 8);
          if (v426) {
            uint64_t v427 = v426;
          }
          else {
            uint64_t v427 = 0;
          }
          v428 = *(void (**)(uint64_t, __CFString *, uint64_t))(v427 + 56);
          if (v428) {
            v428(FigBaseObject, @"SceneCompositionPreset", v424);
          }
        }
      }
      return OutputDestinationForVideo;
    }
  }
  else
  {
    uint64_t OutputDestinationForVideo = 0;
  }
  uint64_t v11 = (uint64_t)v3[12];
  if (v11)
  {
    if (fpfsi_CanReuseRenderChainForTrack(v11, (uint64_t)v3)) {
      goto LABEL_690;
    }
    fpfs_ReleaseTrackRenderChain(v3);
    if (*((_DWORD *)v3 + 8) == 1936684398) {
      fpfs_PrepareAndEnqueueSpatialAudioRenderingChangedNotification(*(const void **)DerivedStorage, *v3, v12, v13, v14, v15, v16, v17);
    }
  }
  uint64_t v18 = 0;
  while (*(_DWORD *)&kCommonTypes[4 * v18] != *((_DWORD *)v3 + 8))
  {
    if (++v18 == 5) {
      return FigSignalErrorAt();
    }
  }
  if (v18 >= 5) {
    return FigSignalErrorAt();
  }
  uint64_t v20 = CMBaseObjectGetDerivedStorage();
  int v21 = *((_DWORD *)v3 + 8);
  if (v21 == 1835365473)
  {
    uint64_t v22 = *(void *)(v20 + 1048);
    if (!v22)
    {
LABEL_26:
      uint64_t v463 = 0;
      goto LABEL_37;
    }
    while ((const __CFString **)v22 == v3 || !fpfsi_canTracksBeSyncPairsIgnoringDiscontinuity((uint64_t)v3, v22))
    {
      uint64_t v22 = *(void *)(v22 + 8);
      if (!v22) {
        goto LABEL_26;
      }
    }
    CFArrayRef v25 = (uint64_t *)(v22 + 96);
  }
  else
  {
    for (uint64_t i = 0; i != 5; ++i)
    {
      if (*(_DWORD *)&kCommonTypes[4 * i] == v21) {
        break;
      }
    }
    CFArrayRef v25 = (uint64_t *)(v20 + 8 * i + 792);
  }
  uint64_t v463 = *v25;
LABEL_37:
  if (a3)
  {
    int v26 = *((_DWORD *)v3 + 8);
    goto LABEL_39;
  }
  CanReuseRenderChainForTracuint64_t k = fpfsi_CanReuseRenderChainForTrack(v463, (uint64_t)v3);
  int v26 = *((_DWORD *)v3 + 8);
  if (CanReuseRenderChainForTrack)
  {
    if (v26 == 1986618469)
    {
      CFStringRef v35 = (const __CFString *)v463;
      if (*(void *)v463 == 1)
      {
        uint64_t HasStarted = fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(v463, @"Suspended", *MEMORY[0x1E4F1CFD0]);
        if (HasStarted) {
          BOOL v36 = HasStarted == -12850;
        }
        else {
          BOOL v36 = 1;
        }
        if (!v36) {
          return HasStarted;
        }
        uint64_t OutputDestinationForVideo = 0;
      }
    }
    else
    {
      CFStringRef v35 = (const __CFString *)v463;
    }
    v3[12] = v35;
    ++v35->isa;
    *((unsigned char *)v3 + 185) = 1;
    if (*(unsigned char *)(v7 + 896) && !v3[11])
    {
      int v79 = *((_DWORD *)v3 + 8);
      if (v79 != 1835365473)
      {
        uint64_t v67 = DerivedStorage;
        if (v79 == 1986618469)
        {
          uint64_t OutputDestinationForVideo = fpfsi_createOutputDestinationForVideo((uint64_t)v3);
          if (OutputDestinationForVideo) {
            return OutputDestinationForVideo;
          }
        }
        goto LABEL_88;
      }
      uint64_t OutputDestinationForVideo = fpfsi_createOutputDestinationForMetadata((uint64_t)v3);
      if (OutputDestinationForVideo) {
        return OutputDestinationForVideo;
      }
    }
    uint64_t v67 = DerivedStorage;
LABEL_88:
    if (dword_1E9350BB0)
    {
      LODWORD(values.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type[0]) = 0;
      uint64_t v68 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    goto LABEL_605;
  }
LABEL_39:
  if (v26 <= 1935832171)
  {
    if (v26 != 1668047728)
    {
      if (v26 != 1835365473) {
        goto LABEL_81;
      }
      if (fpfs_canSendMetadataTrackToVideoTargets((uint64_t)a1, (const opaqueCMFormatDescription *)v3[5])
        && *(unsigned char *)(v7 + 896))
      {
        uint64_t HasStarted = fpfs_createMetadataRenderChainForDataQueue((uint64_t)a1, (uint64_t)v5, (uint64_t)v3[5], &p_isa);
        if (HasStarted) {
          return HasStarted;
        }
        uint64_t v37 = (__CFString *)p_isa;
        uint64_t HasStarted = fpfsi_ensureTrackIsSetupToDeliverMetadataToVideoDestination((uint64_t)v3, (uint64_t)p_isa);
        if (HasStarted) {
          return HasStarted;
        }
LABEL_569:
        if (v37) {
          goto LABEL_570;
        }
        return FigSignalErrorAt();
      }
      CFStringRef v69 = v5;
      uint64_t v461 = DerivedStorage;
      uint64_t v70 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x90uLL, 0x1060040EF867D01uLL);
      v450 = a1;
      if (v70)
      {
        uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
        uint64_t v72 = v70 + 4;
        uint64_t v73 = FigTimedMetadataRenderPipelineCreate(AllocatorForMedia, (uint64_t)fpfs_TimedDataRenderCallback, (uint64_t)a1, v70 + 4);
        if (v73)
        {
          uint64_t OutputDestinationForVideo = v73;
          int v153 = v70;
          goto LABEL_225;
        }
        uint64_t v37 = (__CFString *)v70;
        CFTypeRef v74 = v70[4];
        uint64_t v75 = FigGetAllocatorForMedia();
        uint64_t v76 = FigRenderPipelineGetFigBaseObject(v74);
        uint64_t v77 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v77) {
          uint64_t v78 = v77;
        }
        else {
          uint64_t v78 = 0;
        }
        uint64_t v106 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, uint64_t *))(v78 + 48);
        if (v106)
        {
          uint64_t v107 = v106(v76, @"SourceSampleBufferQueue", v75, &v37[1].info);
          if (!v107)
          {
            v37->data = (char *)FigFormatDescriptionRetain();
            v37->isa = (void *)1;
            p_isa = (CFTypeRef *)&v37->isa;
            goto LABEL_153;
          }
          uint64_t OutputDestinationForVideo = v107;
        }
        else
        {
          uint64_t OutputDestinationForVideo = 4294954514;
        }
        uint64_t v125 = *v72;
LABEL_223:
        CFRelease(v125);
        goto LABEL_224;
      }
      uint64_t v37 = 0;
      uint64_t HasStarted = FigSignalErrorAt();
      if (HasStarted) {
        return HasStarted;
      }
LABEL_153:
      CFStringRef v108 = v3[5];
      CFStringRef v109 = *v3;
      uint64_t v110 = CMBaseObjectGetDerivedStorage();
      sizeOut[0].CMTimeValue value = 0;
      uint64_t v111 = FPSupport_CreateAndAddMetadataOutputRenderPipelinesForTrackWithID(*(void *)(v110 + 1880), *((_DWORD *)v3 + 4), sizeOut);
      uint64_t v453 = v7;
      if (v111)
      {
        uint64_t OutputDestinationForVideo = v111;
      }
      else
      {
        if (CFArrayGetCount((CFArrayRef)sizeOut[0].value) >= 1)
        {
          CFIndex v112 = 0;
          uint64_t v113 = v37;
          while (1)
          {
            CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)sizeOut[0].value, v112);
            int v115 = (__CFString *)malloc_type_calloc(1uLL, 0x90uLL, 0x1060040EF867D01uLL);
            __int16 v116 = v115;
            if (v115)
            {
              ++v115->isa;
              v115[1].isa = (void *)CFRetain(ValueAtIndex);
              v116->data = (char *)CFRetain(v108);
              isa = v116[1].isa;
              uint64_t v118 = FigGetAllocatorForMedia();
              uint64_t v119 = FigRenderPipelineGetFigBaseObject(isa);
              uint64_t v120 = *(void *)(CMBaseObjectGetVTable() + 8);
              if (v120) {
                uint64_t v121 = v120;
              }
              else {
                uint64_t v121 = 0;
              }
              CFNumberRef v122 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, uint64_t *))(v121 + 48);
              if (!v122)
              {
                uint64_t OutputDestinationForVideo = 4294954514;
LABEL_164:
                fpfs_releaseRenderChain(v109);
                goto LABEL_165;
              }
              uint64_t v123 = v122(v119, @"SourceSampleBufferQueue", v118, &v116[1].info);
              if (v123)
              {
                uint64_t OutputDestinationForVideo = v123;
                goto LABEL_164;
              }
            }
            else
            {
              uint64_t v124 = FigSignalErrorAt();
              if (v124)
              {
                uint64_t OutputDestinationForVideo = v124;
                goto LABEL_165;
              }
            }
            uint64_t OutputDestinationForVideo = 0;
            v113[2].size_t length = (uint64_t)v116;
            uint64_t v113 = v116;
LABEL_165:
            if (++v112 >= CFArrayGetCount((CFArrayRef)sizeOut[0].value)) {
              goto LABEL_307;
            }
          }
        }
        uint64_t OutputDestinationForVideo = 0;
      }
LABEL_307:
      if (sizeOut[0].value) {
        CFRelease((CFTypeRef)sizeOut[0].value);
      }
      CFStringRef v5 = v69;
      a1 = v450;
      uint64_t v7 = v453;
      uint64_t DerivedStorage = v461;
      goto LABEL_565;
    }
    uint64_t v452 = v7;
    uint64_t v460 = DerivedStorage;
    CFStringRef v468 = v5;
    uint64_t v56 = (uint64_t)*v3;
    uint64_t v57 = (uint64_t)a1;
    BOOL v58 = (const opaqueCMFormatDescription *)v3[5];
    keys.CMTimeValue value = 0;
    *(void *)&keys.CMTimeScale timescale = 0;
    values.CMTimeValue value = 0;
    *(void *)&values.CMTimeScale timescale = 0;
    uint64_t v59 = v57;
    uint64_t v60 = CMBaseObjectGetDerivedStorage();
    unsigned int v61 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x90uLL, 0x1060040EF867D01uLL);
    if (!v61)
    {
      uint64_t OutputDestinationForVideo = FigSignalErrorAt();
      CFStringRef v66 = v5;
      a1 = (const void *)v59;
      uint64_t v7 = v452;
      uint64_t DerivedStorage = v460;
LABEL_121:
      CFStringRef v5 = v66;
      if (OutputDestinationForVideo) {
        return OutputDestinationForVideo;
      }
LABEL_122:
      fpfs_associateCrossTalkerToRenderChain(DerivedStorage, (uint64_t)v3, (uint64_t)v61);
      uint64_t OutputDestinationForVideo = fpfs_createLegibleOutputRenderChainsAndAttachToPrimary((uint64_t)a1, (uint64_t)*v3, v3[5], v61);
      uint64_t v37 = (__CFString *)p_isa;
      goto LABEL_565;
    }
    keys.CMTimeValue value = (CMTimeValue)@"SortSampleBufferQueueByOutputPTS";
    values.CMTimeValue value = *MEMORY[0x1E4F1CFD0];
    CFDictionaryRef v62 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!v62)
    {
      uint64_t DerivedStorage = v460;
      uint64_t v429 = FigSignalErrorAt();
      if (v429)
      {
        uint64_t OutputDestinationForVideo = v429;
        int v153 = v61;
        goto LABEL_225;
      }
      unsigned int v61 = 0;
      a1 = (const void *)v59;
      uint64_t v7 = v452;
      goto LABEL_122;
    }
    CFDictionaryRef v63 = v62;
    if (*(unsigned char *)(v60 + 462))
    {
      uint64_t OctaviaClosedCaptionsRenderPipeline = FigCreateOctaviaClosedCaptionsRenderPipeline(v58, v62, *(const void **)(v60 + 488), v61 + 4);
      if (!OctaviaClosedCaptionsRenderPipeline)
      {
        uint64_t v65 = fpfs_setDisplaySizeAndItemVideoSizeOnTextRenderPipeline((uint64_t)v61, *(double *)(v60 + 464), *(double *)(v60 + 472), *(void *)(v60 + 480), v56);
        if (v65)
        {
          uint64_t OutputDestinationForVideo = v65;
          CFStringRef v66 = v468;
          uint64_t v7 = v452;
LABEL_118:
          CFRelease(v61[4]);
          a1 = (const void *)v59;
LABEL_119:
          uint64_t DerivedStorage = v460;
          free(v61);
          unsigned int v61 = 0;
          goto LABEL_120;
        }
LABEL_111:
        fpfs_prepareClosedCaptionRenderPipeline(v59, v56, (uint64_t)v61[4]);
        CFTypeRef v84 = v61[4];
        uint64_t v85 = FigGetAllocatorForMedia();
        uint64_t v86 = FigRenderPipelineGetFigBaseObject(v84);
        uint64_t v87 = *(void *)(CMBaseObjectGetVTable() + 8);
        CFStringRef v66 = v468;
        uint64_t v7 = v452;
        if (v87) {
          uint64_t v88 = v87;
        }
        else {
          uint64_t v88 = 0;
        }
        int v89 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v88 + 48);
        if (v89)
        {
          uint64_t OutputDestinationForVideo = v89(v86, @"SourceSampleBufferQueue", v85, v61 + 5);
          if (!OutputDestinationForVideo)
          {
            v61[2] = (CFTypeRef)FigFormatDescriptionRetain();
            *unsigned int v61 = (CFTypeRef)1;
            p_isa = v61;
            a1 = (const void *)v59;
            uint64_t DerivedStorage = v460;
LABEL_120:
            CFRelease(v63);
            goto LABEL_121;
          }
        }
        else
        {
          uint64_t OutputDestinationForVideo = 4294954514;
        }
        goto LABEL_118;
      }
    }
    else
    {
      sizeOut[0] = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      uint64_t OctaviaClosedCaptionsRenderPipeline = FigCreateClosedCaptionRenderPipeline(v58, (uint64_t)fpfs_postClosedCaptionNotificationIfEnabled, v56, 0, 0, (long long *)&sizeOut[0].value, v62, v61 + 4);
      if (!OctaviaClosedCaptionsRenderPipeline) {
        goto LABEL_111;
      }
    }
    uint64_t OutputDestinationForVideo = OctaviaClosedCaptionsRenderPipeline;
    CFStringRef v66 = v468;
    a1 = (const void *)v59;
    uint64_t v7 = v452;
    goto LABEL_119;
  }
  if (v26 == 1935832172)
  {
    CFStringRef v466 = v5;
    uint64_t v458 = DerivedStorage;
    uint64_t v38 = a1;
    uint64_t v39 = (uint64_t)*v3;
    uint64_t v40 = (const opaqueCMFormatDescription *)v3[5];
    uint64_t v41 = CMBaseObjectGetDerivedStorage();
    uint64_t v42 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x90uLL, 0x1060040EF867D01uLL);
    if (!v42)
    {
      uint64_t HasStarted = FigSignalErrorAt();
      uint64_t DerivedStorage = v458;
      uint64_t v37 = 0;
      if (HasStarted) {
        return HasStarted;
      }
LABEL_220:
      fpfs_associateCrossTalkerToRenderChain(DerivedStorage, (uint64_t)v3, (uint64_t)v37);
      uint64_t OutputDestinationForVideo = fpfs_createLegibleOutputRenderChainsAndAttachToPrimary((uint64_t)a1, (uint64_t)*v3, v3[5], v37);
      CFStringRef v5 = v466;
LABEL_565:
      if (OutputDestinationForVideo && v37)
      {
        fpfs_releaseRenderChain(*v3);
        return OutputDestinationForVideo;
      }
      if (OutputDestinationForVideo) {
        return OutputDestinationForVideo;
      }
      goto LABEL_569;
    }
    uint64_t v43 = CMBaseObjectGetDerivedStorage();
    uint64_t v44 = v43;
    if (*(unsigned char *)(v43 + 462))
    {
      uint64_t v37 = (__CFString *)v42;
      uint64_t OctaviaSubtitleRenderPipeline = FigCreateOctaviaSubtitleRenderPipeline(v40, 0, *(const void **)(v43 + 488), v42 + 4);
      if (!OctaviaSubtitleRenderPipeline)
      {
        uint64_t v46 = fpfs_setDisplaySizeAndItemVideoSizeOnTextRenderPipeline((uint64_t)v42, *(double *)(v44 + 464), *(double *)(v44 + 472), *(void *)(v44 + 480), v39);
        a1 = v38;
        if (v46) {
          goto LABEL_698;
        }
        goto LABEL_213;
      }
LABEL_109:
      uint64_t OutputDestinationForVideo = OctaviaSubtitleRenderPipeline;
LABEL_224:
      int v153 = (CFTypeRef *)&v37->isa;
LABEL_225:
      free(v153);
      return OutputDestinationForVideo;
    }
    uint64_t v83 = *(void *)(v41 + 16);
    if (*(unsigned char *)(v43 + 460))
    {
      sizeOut[0] = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      uint64_t OctaviaSubtitleRenderPipeline = FigCreateSubtitleRenderPipeline((uint64_t)v40, (uint64_t)fpfs_postSubtitleCallback, v83, 0, 0, 0, 0, 0, (long long *)&sizeOut[0].value, 0, v42 + 4);
      a1 = v38;
      uint64_t v37 = (__CFString *)v42;
      if (OctaviaSubtitleRenderPipeline) {
        goto LABEL_109;
      }
    }
    else
    {
      sizeOut[0] = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
      uint64_t CaptionRenderPipeline = FigCreateCaptionRenderPipeline((uint64_t)v40, (uint64_t)fpfs_postCaptionCallback, v83, 0, 0, 0, 0, 0, (long long *)&sizeOut[0].value, 0, v42 + 4);
      if (CaptionRenderPipeline)
      {
        uint64_t OutputDestinationForVideo = CaptionRenderPipeline;
        uint64_t v37 = (__CFString *)v42;
        goto LABEL_224;
      }
      a1 = v38;
      FigNetworkCostMonitorSetProperty((uint64_t)v42[4], @"ForedSubtitle", *MEMORY[0x1E4F1CFD0]);
      uint64_t v37 = (__CFString *)v42;
    }
LABEL_213:
    uint64_t v46 = fpfsi_prepareSubtitleRenderPipeline(v39, (uint64_t)v37[1].isa);
    if (v46) {
      goto LABEL_698;
    }
    uint64_t v147 = v37[1].isa;
    uint64_t v148 = FigGetAllocatorForMedia();
    uint64_t v149 = FigRenderPipelineGetFigBaseObject(v147);
    uint64_t v150 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v150) {
      uint64_t v151 = v150;
    }
    else {
      uint64_t v151 = 0;
    }
    unsigned int v152 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, uint64_t *))(v151 + 48);
    if (!v152)
    {
      uint64_t OutputDestinationForVideo = 4294954514;
LABEL_222:
      uint64_t v125 = v37[1].isa;
      goto LABEL_223;
    }
    uint64_t v46 = v152(v149, @"SourceSampleBufferQueue", v148, &v37[1].info);
    if (v46)
    {
LABEL_698:
      uint64_t OutputDestinationForVideo = v46;
      goto LABEL_222;
    }
    v37->data = (char *)FigFormatDescriptionRetain();
    v37->isa = (void *)1;
    p_isa = (CFTypeRef *)&v37->isa;
    uint64_t DerivedStorage = v458;
    goto LABEL_220;
  }
  if (v26 != 1936684398)
  {
    if (v26 == 1986618469)
    {
      if (*(unsigned char *)(v7 + 896))
      {
        if (!v3[11])
        {
          uint64_t HasStarted = fpfsi_createOutputDestinationForVideo((uint64_t)v3);
          if (HasStarted) {
            return HasStarted;
          }
        }
      }
      int v27 = *(_DWORD *)(v7 + 576);
      CFTypeRef v28 = a1;
      uint64_t v29 = CMBaseObjectGetDerivedStorage();
      CFStringRef v30 = *v3;
      uint64_t v31 = CMBaseObjectGetDerivedStorage();
      values.CMTimeValue value = 0;
      CFArrayRef v32 = *(const __CFArray **)(v29 + 384);
      int v441 = v27;
      if (v32) {
        CFIndex Count = CFArrayGetCount(v32);
      }
      else {
        CFIndex Count = 0;
      }
      type[0] = 0;
      v477.CMTimeValue value = 0;
      CFTypeRef v80 = fpfsi_copyPreviousImageQueueGauge(v30);
      CMTimeValue value = (void *)*MEMORY[0x1E4F1CFC8];
      CFTypeRef cf = 0;
      CFTypeRef v481 = value;
      CFStringRef v435 = v3[48];
      int allocatora = *((unsigned __int8 *)v3 + 456);
      if (!fpfs_CanRenderVideo(v29, (uint64_t)v30))
      {
        uint64_t OutputDestinationForVideo = FigSignalErrorAt();
        a1 = v28;
LABEL_561:
        if (OutputDestinationForVideo) {
          return OutputDestinationForVideo;
        }
        uint64_t v37 = (__CFString *)p_isa;
        fpfs_associateCrossTalkerToRenderChain(DerivedStorage, (uint64_t)v3, (uint64_t)p_isa);
        unsigned int v360 = fpfs_setPropertyOnPrimaryAndAuxRenderPipelines((uint64_t)p_isa, @"Suspended", *MEMORY[0x1E4F1CFD0]);
        if (v360 == -12850) {
          uint64_t OutputDestinationForVideo = 0;
        }
        else {
          uint64_t OutputDestinationForVideo = v360;
        }
        goto LABEL_565;
      }
      CFArrayRef v81 = *(const __CFArray **)(v31 + 864);
      uint64_t v433 = Count;
      if (v81) {
        CFArrayRef v81 = (const __CFArray *)CFArrayGetCount(v81);
      }
      uint64_t v82 = FPSupport_CopyDestinationPixelBufferAttributesWithIOSurfaceSupport(*(CFDictionaryRef *)(v29 + 584), (uint64_t)v81 > 0, (CFDictionaryRef *)&values);
      if (v82)
      {
        uint64_t OutputDestinationForVideo = v82;
        a1 = v28;
        goto LABEL_559;
      }
      uint64_t v465 = (uint64_t)v30;
      if (*(unsigned char *)(v29 + 462))
      {
        fpfs_cleanupAllImageQueues(v30, 0);
        fpfs_releaseTransitionImageQueuesAndSlots();
      }
      else
      {
        uint64_t v97 = fpfsi_addCAImageQueuesAndSlots(v30, (uint64_t)v3, *(void *)(v29 + 400) > 0);
        if (v97)
        {
          uint64_t OutputDestinationForVideo = v97;
          CFTypeRef v430 = v80;
          v431 = v3;
          uint64_t v432 = v7;
LABEL_724:
          CFRelease((CFTypeRef)values.value);
          a1 = v28;
          uint64_t v7 = v432;
          uint64_t v3 = v431;
          CFTypeRef v80 = v430;
LABEL_559:
          if (v80) {
            CFRelease(v80);
          }
          goto LABEL_561;
        }
      }
      uint64_t v462 = DerivedStorage;
      v473 = (char *)malloc_type_calloc(1uLL, 0x90uLL, 0x1060040EF867D01uLL);
      if (v473)
      {
        CFTypeRef v445 = v80;
        CFAllocatorRef v98 = (const __CFAllocator *)FigGetAllocatorForMedia();
        if (v28) {
          CFTypeID v99 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          CFTypeID v99 = "";
        }
        if (v30) {
          BOOL v100 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else {
          BOOL v100 = "";
        }
        v447 = (__CFString *)CFStringCreateWithFormat(v98, 0, @"%s:%s.t%d", v99, v100, v3[2]);
        CFAllocatorRef v101 = (const __CFAllocator *)FigGetAllocatorForMedia();
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v101, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (!Mutable)
        {
          uint64_t OutputDestinationForVideo = FigSignalErrorAt();
          a1 = v28;
          uint64_t DerivedStorage = v462;
          uint64_t v144 = v447;
LABEL_557:
          CFRelease((CFTypeRef)values.value);
          CFTypeRef v80 = v445;
          if (v144) {
            CFRelease(v144);
          }
          goto LABEL_559;
        }
        uint64_t v103 = Mutable;
        int v104 = *(_DWORD *)(v29 + 592);
        uint64_t DerivedStorage = v462;
        if (v104 == 2)
        {
          uint64_t v105 = value;
        }
        else
        {
          if (v104 != 1) {
            goto LABEL_174;
          }
          uint64_t v105 = (const void *)*MEMORY[0x1E4F1CFD0];
        }
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F455D0], v105);
LABEL_174:
        if (*(unsigned char *)(v29 + 872)) {
          CFDictionarySetValue(v103, (const void *)*MEMORY[0x1E4F455B0], (const void *)*MEMORY[0x1E4F1CFD0]);
        }
        uint64_t v454 = v7;
        CFStringRef v469 = v5;
        double v126 = *(const void **)(v29 + 600);
        if (v126) {
          CFDictionarySetValue(v103, (const void *)*MEMORY[0x1E4F455E0], v126);
        }
        uint64_t v127 = CMBaseObjectGetDerivedStorage();
        uint64_t v128 = CMBaseObjectGetDerivedStorage();
        sizeOut[0].CMTimeValue value = 0;
        CFStringRef v129 = v3[11];
        v438 = v103;
        if (*(unsigned char *)(v128 + 896))
        {
          uint64_t v130 = *(void *)(CMBaseObjectGetVTable() + 16);
          if (v130) {
            uint64_t v131 = v130;
          }
          else {
            uint64_t v131 = 0;
          }
          uint64_t v137 = *(uint64_t (**)(const __CFString *, CFTypeRef *, void))(v131 + 24);
          if (!v137)
          {
            uint64_t OutputDestinationForVideo = 4294954514;
            goto LABEL_206;
          }
          uint64_t VideoRenderPipeline = v137(v129, &cf, 0);
          if (VideoRenderPipeline)
          {
LABEL_718:
            uint64_t OutputDestinationForVideo = VideoRenderPipeline;
            goto LABEL_206;
          }
        }
        else
        {
          uint64_t v132 = *(void *)(v127 + 720);
          if (!v132)
          {
            CFAllocatorRef v133 = (const __CFAllocator *)FigGetAllocatorForMedia();
            FigImageQueueTableCreate(v133, (void *)(v127 + 720));
            uint64_t v132 = *(void *)(v127 + 720);
            if (!v132)
            {
              uint64_t OutputDestinationForVideo = FigSignalErrorAt();
              if (OutputDestinationForVideo) {
                goto LABEL_206;
              }
              goto LABEL_450;
            }
          }
          FigImageQueueTableCopyFigImageQueueArray(v132, (uint64_t *)&cf);
        }
        fpfs_CreateFigImageQueueOutputsArray((uint64_t)*v3, (uint64_t)v3, (CFTypeRef *)sizeOut);
        uint64_t v139 = (const void *)sizeOut[0].value;
        if (!sizeOut[0].value) {
          goto LABEL_450;
        }
        if (!v129)
        {
          uint64_t v145 = *(void *)(v127 + 720);
          if (!v145)
          {
LABEL_446:
            uint64_t OutputDestinationForVideo = 0;
            goto LABEL_449;
          }
          uint64_t OutputDestinationForVideo = FigImageQueueTableUpdateToMatchOutputsArray(v145, (const __CFArray *)sizeOut[0].value, 0, 0, 0, 0);
          if (!OutputDestinationForVideo) {
            FigImageQueueTableCopyFigImageQueueArray(*(void *)(v127 + 720), (uint64_t *)type);
          }
LABEL_449:
          CFRelease(v139);
          if (!OutputDestinationForVideo)
          {
LABEL_450:
            if (allocatora) {
              CFStringRef v306 = 0;
            }
            else {
              CFStringRef v306 = v3[5];
            }
            CFStringRef v307 = (uint64_t *)(v473 + 32);
            uint64_t VideoRenderPipeline = FPSupport_createVideoRenderPipeline(v103, (const void *)values.value, 1, (const __CFArray *)type[0], (const __CFArray *)v477.value, 1, v306, v441, *(unsigned char *)(v29 + 462), *(const void **)(v29 + 488), *(const void **)(v29 + 624), *(_DWORD *)(v29 + 564), 0, v447, (CFTypeRef *)v473 + 4);
            if (!VideoRenderPipeline)
            {
              NextRenderPipelineIdentifierCFStringRef String = fpfs_createNextRenderPipelineIdentifierString();
              if (!NextRenderPipelineIdentifierString)
              {
                uint64_t OutputDestinationForVideo = FigSignalErrorAt();
                CFStringRef v143 = v469;
                a1 = v28;
                uint64_t v7 = v454;
                uint64_t v144 = v447;
                if (!OutputDestinationForVideo) {
                  goto LABEL_548;
                }
                goto LABEL_547;
              }
              if (!*(unsigned char *)(v29 + 912)) {
                goto LABEL_466;
              }
              sizeOut[0].CMTimeValue value = 0;
              SpeedRampuint64_t RenderPipelineOptions = fpfs_createSpeedRampRenderPipelineOptions();
              CFAllocatorRef v309 = (const __CFAllocator *)FigGetAllocatorForMedia();
              v310 = (const void *)*v307;
              FigGetDefaultLowWaterDurationForSpeedRampRenderPipelines(&keys);
              uint64_t OutputDestinationForVideo = FigSpeedRampRenderPipelineCreate(v309, v310, &keys, SpeedRampRenderPipelineOptions, (void **)sizeOut);
              if (sizeOut[0].value)
              {
                FigRenderPipelineSetProperty(sizeOut[0].value, 0x1EE54A2F8, *(void *)(v31 + 3352));
                v311 = (const void *)*v307;
                v312 = (const void *)sizeOut[0].value;
                *CFStringRef v307 = sizeOut[0].value;
                if (v312) {
                  CFRetain(v312);
                }
                if (v311) {
                  CFRelease(v311);
                }
                if (sizeOut[0].value) {
                  CFRelease((CFTypeRef)sizeOut[0].value);
                }
              }
              if (SpeedRampRenderPipelineOptions) {
                CFRelease(SpeedRampRenderPipelineOptions);
              }
              uint64_t DerivedStorage = v462;
              if (!OutputDestinationForVideo)
              {
LABEL_466:
                fpfsi_updateFigImageQueueListeners(v465, (uint64_t)v3);
                CFStringRef v313 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
                if (*(int *)(v29 + 564) < 1)
                {
                  uint64_t SInt32 = 0;
                }
                else
                {
                  uint64_t SInt32 = (const void *)FigCFNumberCreateSInt32();
                  FigRenderPipelineSetProperty(*v307, @"ClientPID", (uint64_t)SInt32);
                }
                CFStringRef v315 = v3[7];
                if (v315)
                {
                  int valuePtr = 0;
                  FigGetCGAffineTransformFrom3x3MatrixArray(v315, (uint64_t)sizeOut);
                  int valuePtr = FigGetRotationAngleAndFlipsFromCGAffineTransform((double *)&sizeOut[0].value, 0, 0);
                  CFNumberRef v316 = CFNumberCreate(*v313, kCFNumberIntType, &valuePtr);
                  FigRenderPipelineSetProperty(*v307, @"Rotation", (uint64_t)v316);
                  if (v316) {
                    CFRelease(v316);
                  }
                }
                CFTypeRef v443 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
                if (*(unsigned char *)(v29 + 408)) {
                  CFTypeRef v317 = (void *)*MEMORY[0x1E4F1CFD0];
                }
                else {
                  CFTypeRef v317 = value;
                }
                uint64_t v318 = FigRenderPipelineGetFigBaseObject(*v307);
                uint64_t v319 = *(void *)(CMBaseObjectGetVTable() + 8);
                if (v319) {
                  uint64_t v320 = v319;
                }
                else {
                  uint64_t v320 = 0;
                }
                CFStringRef v321 = *(void (**)(uint64_t, __CFString *, void *))(v320 + 56);
                if (v321) {
                  v321(v318, @"PreventDisplaySleepDuringVideoPlayback", v317);
                }
                if (v445 && !*((unsigned char *)v3 + 184)) {
                  FigRenderPipelineSetProperty(*v307, @"PriorImageQueueGauge", (uint64_t)v445);
                }
                uint64_t v322 = *(void *)(v31 + 704);
                if (v322) {
                  FigRenderPipelineSetProperty(*v307, @"VideoEnhancementMode", v322);
                }
                CFArrayRef v323 = *(const __CFArray **)(v31 + 656);
                if (v323)
                {
                  CFIndex v324 = CFArrayGetCount(v323);
                  if (v324 >= 1)
                  {
                    CFIndex v325 = v324;
                    if (v435) {
                      FPSupport_IsRunningInAppleVirtualMachine();
                    }
                    for (CFIndex j = 0; j != v325; ++j)
                    {
                      CFArrayGetValueAtIndex(*(CFArrayRef *)(v31 + 656), j);
                      CAImageQueueSetFlags();
                    }
                  }
                }
                uint64_t v327 = *((void *)v473 + 4);
                uint64_t v328 = FigGetAllocatorForMedia();
                uint64_t v329 = FigRenderPipelineGetFigBaseObject(v327);
                uint64_t v330 = *(void *)(CMBaseObjectGetVTable() + 8);
                if (v330) {
                  uint64_t v331 = v330;
                }
                else {
                  uint64_t v331 = 0;
                }
                int v332 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, char *))(v331 + 48);
                if (v332)
                {
                  uint64_t v333 = v332(v329, @"SourceSampleBufferQueue", v328, v473 + 40);
                  if (!v333)
                  {
                    CMNotificationCenterGetDefaultLocalCenter();
                    FigNotificationCenterAddWeakListener();
                    CMNotificationCenterGetDefaultLocalCenter();
                    FigNotificationCenterAddWeakListener();
                    CMNotificationCenterGetDefaultLocalCenter();
                    FigNotificationCenterAddWeakListener();
                    CMNotificationCenterGetDefaultLocalCenter();
                    FigNotificationCenterAddWeakListener();
                    if (v433 > 0 || *(void *)(v31 + 696))
                    {
                      if (v465 == *(void *)(v29 + 80)) {
                        fpfs_createOrUpdateLayerSync((uint64_t)v28);
                      }
                      if (!*(void *)(v31 + 688)) {
                        FigSyncMomentSourceCreateWithDispatchQueue((uint64_t)fpfsi_syncMomentSourceCallback, v465, *(const void **)(v31 + 576), *(NSObject **)(v31 + 600), (uint64_t *)(v31 + 688));
                      }
                    }
                    uint64_t v334 = *(void *)(v29 + 480);
                    uint64_t v335 = FigRenderPipelineGetFigBaseObject(*v307);
                    uint64_t v336 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v336) {
                      uint64_t v337 = v336;
                    }
                    else {
                      uint64_t v337 = 0;
                    }
                    CFStringRef v338 = *(void (**)(uint64_t, __CFString *, uint64_t))(v337 + 56);
                    if (v338) {
                      v338(v335, @"NeroVideoGravity", v334);
                    }
                    if (*(unsigned char *)(v29 + 462)) {
                      fpfs_UpdateNeroPlaybackActiveStateAndNotifyIfNeeded(v28, v465, 1);
                    }
                    CFStringRef v339 = v3[6];
                    uint64_t v340 = FigGetAllocatorForMedia();
                    uint64_t v341 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v341) {
                      uint64_t v342 = v341;
                    }
                    else {
                      uint64_t v342 = 0;
                    }
                    v343 = *(void (**)(const __CFString *, __CFString *, uint64_t, CFTypeRef *))(v342 + 48);
                    if (v343) {
                      v343(v339, @"FMFD_IsCollectingMetaData", v340, &v481);
                    }
                    if (v481 == v443)
                    {
                      uint64_t v344 = *(void *)(v31 + 3400);
                      if (v344) {
                        FigRenderPipelineSetProperty(*v307, @"SampleAttachmentCollectionRules", v344);
                      }
                    }
                    uint64_t v345 = *v307;
                    CFStringRef v143 = v469;
                    uint64_t v7 = v454;
                    if (v345)
                    {
                      uint64_t v346 = *(void *)(v31 + 2536);
                      if (v346)
                      {
                        uint64_t v347 = FigRenderPipelineGetFigBaseObject(v345);
                        uint64_t v348 = *(void *)(CMBaseObjectGetVTable() + 8);
                        if (v348) {
                          uint64_t v349 = v348;
                        }
                        else {
                          uint64_t v349 = 0;
                        }
                        CMTimeValue v350 = *(void (**)(uint64_t, __CFString *, uint64_t))(v349 + 56);
                        if (v350) {
                          v350(v347, @"PlaybackSessionID", v346);
                        }
                        uint64_t v351 = *(void *)(v31 + 2544);
                        if (v351)
                        {
                          uint64_t v352 = *(void *)(v31 + 2536);
                          uint64_t v353 = *(void *)(CMBaseObjectGetVTable() + 16);
                          uint64_t v354 = v353 ? v353 : 0;
                          int v355 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v354 + 48);
                          if (v355) {
                            v355(v351, 0x1EE582B78, 0x1EE584C58, v352, 0);
                          }
                        }
                      }
                    }
                    float v356 = *(float *)(v29 + 108);
                    if (v356 >= 0.0 && v356 <= 2.0 && v356 > 1.0) {
                      uint64_t v359 = (uint64_t)v443;
                    }
                    else {
                      uint64_t v359 = (uint64_t)value;
                    }
                    FigRenderPipelineSetProperty(*((void *)v473 + 4), @"AllowVideoQualityOfServiceAdjustments", v359);
                    uint64_t OutputDestinationForVideo = 0;
                    *((void *)v473 + 2) = FigFormatDescriptionRetain();
                    *(void *)v473 = 1;
                    ++*(void *)(v29 + 616);
                    p_isa = (CFTypeRef *)v473;
                    a1 = v28;
                    uint64_t DerivedStorage = v462;
                    goto LABEL_544;
                  }
                  uint64_t OutputDestinationForVideo = v333;
                }
                else
                {
                  uint64_t OutputDestinationForVideo = 4294954514;
                }
                a1 = v28;
                uint64_t DerivedStorage = v462;
                if (*v307) {
                  CFRelease((CFTypeRef)*v307);
                }
                CFStringRef v143 = v469;
                uint64_t v7 = v454;
LABEL_544:
                uint64_t v144 = v447;
                if (SInt32) {
                  CFRelease(SInt32);
                }
                if (!OutputDestinationForVideo) {
                  goto LABEL_548;
                }
                goto LABEL_547;
              }
LABEL_207:
              CFStringRef v143 = v469;
              a1 = v28;
              uint64_t v7 = v454;
              uint64_t v144 = v447;
LABEL_547:
              free(v473);
LABEL_548:
              CFRelease(v438);
              if (type[0]) {
                CFRelease(type[0]);
              }
              if (v477.value) {
                CFRelease((CFTypeRef)v477.value);
              }
              if (cf) {
                CFRelease(cf);
              }
              if (NextRenderPipelineIdentifierString) {
                CFRelease(NextRenderPipelineIdentifierString);
              }
              CFStringRef v5 = v143;
              goto LABEL_557;
            }
            goto LABEL_718;
          }
LABEL_206:
          NextRenderPipelineIdentifierCFStringRef String = 0;
          goto LABEL_207;
        }
        uint64_t RenderingTrackofType = fpfs_LastRenderingTrackofType((uint64_t)*v3, 1986618469, (uint64_t)v3);
        if (RenderingTrackofType) {
          uint64_t v141 = *(void *)(RenderingTrackofType + 88);
        }
        else {
          uint64_t v141 = 0;
        }
        uint64_t v210 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v210) {
          uint64_t v211 = v210;
        }
        else {
          uint64_t v211 = 0;
        }
        __int16 v212 = *(uint64_t (**)(const __CFString *, uint64_t, const void *))(v211 + 8);
        if (v212)
        {
          uint64_t v213 = v212(v129, v141, v139);
          if (!v213)
          {
            uint64_t v214 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v214) {
              uint64_t v215 = v214;
            }
            else {
              uint64_t v215 = 0;
            }
            uint64_t DerivedStorage = v462;
            CMTime v246 = *(uint64_t (**)(const __CFString *, CFTypeRef *, CMTime *))(v215 + 24);
            if (!v246)
            {
              uint64_t OutputDestinationForVideo = 4294954514;
              goto LABEL_449;
            }
            uint64_t v247 = v246(v129, type, &v477);
            if (!v247)
            {
              uint64_t v248 = *(void *)(v127 + 736);
              if (v248)
              {
                uint64_t CMBaseObject = FigAggregateVideoDestinationGetCMBaseObject(v3[11]);
                uint64_t v250 = *(void *)(CMBaseObjectGetVTable() + 8);
                if (v250) {
                  uint64_t v251 = v250;
                }
                else {
                  uint64_t v251 = 0;
                }
                v304 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(v251 + 56);
                if (v304)
                {
                  uint64_t v247 = v304(CMBaseObject, @"ImageQueueGauge", v248);
                  if (!v247)
                  {
                    int v305 = *(const void **)(v127 + 736);
                    uint64_t DerivedStorage = v462;
                    uint64_t v103 = v438;
                    if (v305)
                    {
                      CFRelease(v305);
                      uint64_t OutputDestinationForVideo = 0;
                      *(void *)(v127 + 736) = 0;
                      goto LABEL_449;
                    }
                    goto LABEL_446;
                  }
                  goto LABEL_732;
                }
                uint64_t OutputDestinationForVideo = 4294954514;
              }
              else
              {
                uint64_t OutputDestinationForVideo = 0;
              }
LABEL_448:
              uint64_t DerivedStorage = v462;
              uint64_t v103 = v438;
              goto LABEL_449;
            }
LABEL_732:
            uint64_t OutputDestinationForVideo = v247;
            goto LABEL_448;
          }
          uint64_t OutputDestinationForVideo = v213;
        }
        else
        {
          uint64_t OutputDestinationForVideo = 4294954514;
        }
        uint64_t DerivedStorage = v462;
        goto LABEL_449;
      }
      CFTypeRef v430 = v80;
      v431 = v3;
      uint64_t v432 = v7;
      uint64_t OutputDestinationForVideo = FigSignalErrorAt();
      goto LABEL_724;
    }
LABEL_81:
    if (OutputDestinationForVideo) {
      return OutputDestinationForVideo;
    }
    return FigSignalErrorAt();
  }
  CFStringRef v467 = v5;
  int v47 = *(_DWORD *)(v7 + 572);
  uint64_t v434 = *(void *)(DerivedStorage + 1808);
  CFTypeRef v437 = *(CFTypeRef *)(DerivedStorage + 880);
  uint64_t v459 = DerivedStorage;
  int valuePtr = *(_DWORD *)(DerivedStorage + 888);
  CFTypeRef v481 = 0;
  v472 = (void *)CMBaseObjectGetDerivedStorage();
  uint64_t v48 = CMBaseObjectGetDerivedStorage();
  CFStringRef v442 = v3[5];
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v446 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, &valuePtr);
  int v49 = *(unsigned __int8 *)(v48 + 779);
  if (*(double *)(v48 + 2056) == 0.0) {
    *(CFAbsoluteTime *)(v48 + 2056) = CFAbsoluteTimeGetCurrent();
  }
  uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v464 = (CFAbsoluteTime *)v48;
  uint64_t v51 = *(void *)(v48 + 2072);
  if (v51)
  {
    uint64_t v52 = *((void *)v464 + 318);
    if (v52)
    {
      uint64_t v53 = UpTimeNanoseconds;
      uint64_t v54 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v55 = v54 ? v54 : 0;
      int v90 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, void))(v55 + 56);
      if (v90) {
        v90(v52, 0x1EE582CD8, 0x1EE585C98, (v53 - v51) / 0xF4240uLL, 0);
      }
    }
  }
  if (v446)
  {
    int v91 = v464;
    valuea = (__CFString *)fpfs_createNextRenderPipelineIdentifierString();
    if (!valuea)
    {
      uint64_t OutputDestinationForVideo = FigSignalErrorAt();
      uint64_t v37 = 0;
      uint64_t DerivedStorage = v459;
      goto LABEL_431;
    }
    ShouldEnableSpatializationForTracuint64_t k = fpfs_ShouldEnableSpatializationForTrack((uint64_t)v3);
    __int16 v92 = (const opaqueCMFormatDescription *)v3[5];
    signed int MediaSubType = CMFormatDescriptionGetMediaSubType(v92);
    char v94 = 0;
    if (MediaSubType > 1885692722)
    {
      if (MediaSubType <= 1902469938)
      {
        if (MediaSubType != 1885692723)
        {
          int v95 = 1902324531;
LABEL_190:
          if (MediaSubType != v95)
          {
LABEL_235:
            CMBaseObjectGetDerivedStorage();
            uint64_t v155 = CMBaseObjectGetDerivedStorage();
            LODWORD(sizeOut[0].CFDictionarySetValue(theDict, key, value) = 0;
            if (*((_DWORD *)v3 + 8) == 1936684398)
            {
              unsigned int v156 = *(const void **)(v155 + 176);
              char v157 = fpfs_WantAudioHardwarePassthroughForTrack((uint64_t)v3, (int *)sizeOut);
            }
            else
            {
              char v157 = 0;
              unsigned int v156 = 0;
            }
            CFAllocatorRef v158 = (const __CFAllocator *)FigGetAllocatorForMedia();
            os_log_type_t v159 = (void *)*((void *)v472 + 67);
            sizeOut[0] = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
            CMTime keys = sizeOut[0];
            uint64_t RenderPipelineOptions = FPSupport_createRenderPipelineOptions(v158, v442, v47, (uint64_t)sizeOut, (uint64_t)&keys, v156, 0, 0, v157, 1, 0, v94, ShouldEnableSpatializationForTrack, v49 == 0, 0, 0, v159, 0, valuea,
                                      (__CFDictionary **)&v481);
            if (RenderPipelineOptions)
            {
              uint64_t OutputDestinationForVideo = RenderPipelineOptions;
              uint64_t v37 = 0;
              uint64_t DerivedStorage = v459;
              CFStringRef v5 = v467;
LABEL_430:
              CFRelease(valuea);
LABEL_431:
              CFRelease(v446);
              goto LABEL_432;
            }
            uint64_t v37 = (__CFString *)malloc_type_calloc(1uLL, 0x90uLL, 0x1060040EF867D01uLL);
            CFStringRef v5 = v467;
            if (v37)
            {
              if (*(void *)(CMBaseObjectGetDerivedStorage() + 504))
              {
                uint64_t v161 = CMBaseObjectGetDerivedStorage();
                sizeOut[0].CMTimeValue value = 0;
                FigGetAllocatorForMedia();
                MutableCFArrayRef Copy = (__CFDictionary *)FigCFDictionaryCreateMutableCopy();
                if (MutableCopy)
                {
                  CFDictionaryRef v163 = MutableCopy;
                  if (*(void *)(v161 + 504))
                  {
                    v37[1].isa = 0;
                    uint64_t v164 = *(const void **)(v161 + 536);
                    if (v164) {
                      CFDictionarySetValue(MutableCopy, @"AudioSession", v164);
                    }
                    CFAllocatorRef v165 = (const __CFAllocator *)FigGetAllocatorForMedia();
                    uint64_t OutputDestinationForVideo = FigBufferedAirPlayAudioRenderPipelineCreate(v165, *(const void **)(v161 + 504), v163, &sizeOut[0].value);
                    if (!OutputDestinationForVideo)
                    {
                      v37[1].isa = (void *)sizeOut[0].value;
                      sizeOut[0].CMTimeValue value = 0;
                    }
                  }
                  else
                  {
                    uint64_t OutputDestinationForVideo = 0;
                  }
                  CFRelease(v163);
                  if (sizeOut[0].value) {
                    CFRelease((CFTypeRef)sizeOut[0].value);
                  }
                }
                else
                {
                  uint64_t OutputDestinationForVideo = FigSignalErrorAt();
                }
                uint64_t v166 = MEMORY[0x1E4F1FA30];
                long long v167 = *(_OWORD *)(MEMORY[0x1E4F1FA30] + 16);
                *(_OWORD *)&v37[3].isa = *MEMORY[0x1E4F1FA30];
                *(_OWORD *)&v37[3].data = v167;
                *(_OWORD *)&v37[4].isa = *(_OWORD *)(v166 + 32);
              }
              else
              {
                CFAllocatorRef v168 = (const __CFAllocator *)FigGetAllocatorForMedia();
                uint64_t OutputDestinationForVideo = FigAudioQueueRenderPipelineCreate(v168, (const __CFDictionary *)v481, &v37[1].isa);
              }
              if (OutputDestinationForVideo) {
                goto LABEL_697;
              }
              if (!*((unsigned char *)v472 + 912)) {
                goto LABEL_267;
              }
              sizeOut[0].CMTimeValue value = 0;
              CFDictionaryRef v169 = CFDictionaryCreateMutable(allocator, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              FigCFDictionarySetValue();
              CFAllocatorRef v170 = (const __CFAllocator *)FigGetAllocatorForMedia();
              __int16 v171 = v37[1].isa;
              FigGetDefaultLowWaterDurationForSpeedRampRenderPipelines(&values);
              uint64_t OutputDestinationForVideo = FigSpeedRampRenderPipelineCreate(v170, v171, &values, v169, (void **)sizeOut);
              if (sizeOut[0].value)
              {
                double v172 = v3;
                uint64_t v173 = v7;
                uint64_t v174 = *((void *)v464 + 419);
                uint64_t v175 = FigRenderPipelineGetFigBaseObject(sizeOut[0].value);
                uint64_t v176 = *(void *)(CMBaseObjectGetVTable() + 8);
                if (v176) {
                  uint64_t v177 = v176;
                }
                else {
                  uint64_t v177 = 0;
                }
                uint64_t v178 = *(void (**)(uint64_t, uint64_t, uint64_t))(v177 + 56);
                if (v178) {
                  v178(v175, 0x1EE54A2F8, v174);
                }
                uint64_t v179 = v37[1].isa;
                int v180 = (const void *)sizeOut[0].value;
                v37[1].isa = (void *)sizeOut[0].value;
                if (v180) {
                  CFRetain(v180);
                }
                uint64_t v7 = v173;
                if (v179) {
                  CFRelease(v179);
                }
                uint64_t v3 = v172;
                CFStringRef v5 = v467;
                if (sizeOut[0].value) {
                  CFRelease((CFTypeRef)sizeOut[0].value);
                }
              }
              if (v169) {
                CFRelease(v169);
              }
              if (OutputDestinationForVideo)
              {
LABEL_697:
                uint64_t v206 = 0;
                uint64_t DerivedStorage = v459;
              }
              else
              {
LABEL_267:
                uint64_t v181 = *((void *)v464 + 420);
                if (v181)
                {
                  uint64_t v182 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                  uint64_t v183 = *(void *)(CMBaseObjectGetVTable() + 8);
                  uint64_t v184 = v183 ? v183 : 0;
                  unsigned int v185 = *(void (**)(uint64_t, __CFString *, uint64_t))(v184 + 56);
                  if (v185) {
                    v185(v182, @"OverlapRange", v181);
                  }
                }
                if (dword_1E9350BB0)
                {
                  LODWORD(type[0]) = 0;
                  LOBYTE(v477.CFDictionarySetValue(theDict, key, value) = 0;
                  unsigned int v186 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                  os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT);
                  fig_log_call_emit_and_clean_up_after_send_and_compose();
                  int v91 = v464;
                }
                uint64_t v187 = FigGetUpTimeNanoseconds();
                uint64_t v188 = *((void *)v91 + 259);
                if (v188)
                {
                  uint64_t v189 = *((void *)v91 + 318);
                  if (v189)
                  {
                    uint64_t v190 = v187;
                    uint64_t v191 = *(void *)(CMBaseObjectGetVTable() + 16);
                    uint64_t v192 = v191 ? v191 : 0;
                    int v193 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, void))(v192 + 56);
                    if (v193) {
                      v193(v189, 0x1EE582CD8, 0x1EE585CB8, (v190 - v188) / 0xF4240uLL, 0);
                    }
                  }
                }
                uint64_t v194 = v37[1].isa;
                uint64_t v195 = FigGetAllocatorForMedia();
                uint64_t v196 = FigRenderPipelineGetFigBaseObject(v194);
                uint64_t v197 = *(void *)(CMBaseObjectGetVTable() + 8);
                if (v197) {
                  uint64_t v198 = v197;
                }
                else {
                  uint64_t v198 = 0;
                }
                CMTime v199 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, uint64_t *))(v198 + 48);
                uint64_t DerivedStorage = v459;
                if (v199)
                {
                  uint64_t v455 = v7;
                  uint64_t v200 = v199(v196, @"SourceSampleBufferQueue", v195, &v37[1].info);
                  if (v200)
                  {
                    uint64_t OutputDestinationForVideo = v200;
                    uint64_t v206 = 0;
                    CFStringRef v5 = v467;
                    uint64_t DerivedStorage = v459;
                  }
                  else
                  {
                    int v201 = v37[1].isa;
                    uint64_t v202 = FigGetAllocatorForMedia();
                    uint64_t v203 = FigRenderPipelineGetFigBaseObject(v201);
                    uint64_t v204 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v204) {
                      uint64_t v205 = v204;
                    }
                    else {
                      uint64_t v205 = 0;
                    }
                    p_data = &v37[1].data;
                    uint64_t v208 = *(void (**)(uint64_t, __CFString *, uint64_t, char **))(v205 + 48);
                    if (v208) {
                      v208(v203, @"SourceSampleBufferConsumer", v202, &v37[1].data);
                    }
                    if (!*p_data)
                    {
                      uint64_t info = v37[1].info;
                      CMTimeMake((CMTime *)type, 5, 1);
                      CMTimeMake(&v477, 3, 1);
                      if (FigSampleBufferConsumerCreateForBufferQueue(info, (long long *)type, (long long *)&v477.value, &v37[1].data)|| !*p_data)
                      {
                        FigSignalErrorAt();
                      }
                    }
                    if (*((void *)v472 + 23)) {
                      __int16 v216 = (__CFString *)*((void *)v472 + 23);
                    }
                    else {
                      __int16 v216 = @"Unknown figplayer";
                    }
                    uint64_t v217 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                    uint64_t v218 = *(void *)(CMBaseObjectGetVTable() + 8);
                    uint64_t v7 = v455;
                    if (v218) {
                      uint64_t v219 = v218;
                    }
                    else {
                      uint64_t v219 = 0;
                    }
                    int v220 = *(void (**)(uint64_t, __CFString *, __CFString *))(v219 + 56);
                    if (v220) {
                      v220(v217, @"ClientName", v216);
                    }
                    uint64_t v221 = *((void *)v472 + 22);
                    if (v221)
                    {
                      uint64_t v222 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                      uint64_t v223 = *(void *)(CMBaseObjectGetVTable() + 8);
                      uint64_t v224 = v223 ? v223 : 0;
                      long long v225 = *(void (**)(uint64_t, __CFString *, uint64_t))(v224 + 56);
                      if (v225) {
                        v225(v222, @"AudioDeviceUID", v221);
                      }
                    }
                    uint64_t v226 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                    uint64_t v227 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v227) {
                      uint64_t v228 = v227;
                    }
                    else {
                      uint64_t v228 = 0;
                    }
                    long long v229 = *(void (**)(uint64_t, __CFString *, uint64_t))(v228 + 56);
                    if (v229) {
                      v229(v226, @"AudioDeviceChannelMap", v434);
                    }
                    uint64_t v230 = *MEMORY[0x1E4F1CFD0];
                    uint64_t v231 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                    uint64_t v232 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v232) {
                      uint64_t v233 = v232;
                    }
                    else {
                      uint64_t v233 = 0;
                    }
                    CMTimeEpoch v234 = *(void (**)(uint64_t, __CFString *, uint64_t))(v233 + 56);
                    if (v234) {
                      v234(v231, @"HandleFormatDescriptionChanges", v230);
                    }
                    uint64_t v436 = v230;
                    uint64_t v235 = *((void *)v472 + 24);
                    if (v235)
                    {
                      uint64_t v236 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                      uint64_t v237 = *(void *)(CMBaseObjectGetVTable() + 8);
                      uint64_t v238 = v237 ? v237 : 0;
                      CMTime v239 = *(void (**)(uint64_t, __CFString *, uint64_t))(v238 + 56);
                      if (v239) {
                        v239(v236, @"STSLabel", v235);
                      }
                    }
                    uint64_t v240 = *((void *)v472 + 67);
                    if (!v240) {
                      goto LABEL_348;
                    }
                    CFTypeRef cf = 0;
                    uint64_t v241 = FigGetAllocatorForMedia();
                    uint64_t v242 = *(void *)(CMBaseObjectGetVTable() + 16);
                    if (v242)
                    {
                      CMTime v243 = *(void (**)(uint64_t, void, uint64_t, CFTypeRef *))(v242 + 48);
                      if (v243) {
                        v243(v240, *MEMORY[0x1E4F75EA0], v241, &cf);
                      }
                    }
                    CFTypeRef v244 = cf;
                    if (cf)
                    {
                      if (dword_1E9350BB0)
                      {
                        *(_DWORD *)v476 = 0;
                        os_log_type_t v475 = OS_LOG_TYPE_DEFAULT;
                        CMTime v245 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                        os_log_type_enabled(v245, OS_LOG_TYPE_DEFAULT);
                        fig_log_call_emit_and_clean_up_after_send_and_compose();
                        CFTypeRef v244 = cf;
                      }
                      uint64_t v252 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                      uint64_t v253 = *(void *)(CMBaseObjectGetVTable() + 8);
                      if (v253) {
                        uint64_t v254 = v253;
                      }
                      else {
                        uint64_t v254 = 0;
                      }
                      CMTime v255 = *(uint64_t (**)(uint64_t, __CFString *, CFTypeRef))(v254 + 56);
                      if (v255) {
                        uint64_t OutputDestinationForVideo = v255(v252, @"AllowedToUseHardware", v244);
                      }
                      else {
                        uint64_t OutputDestinationForVideo = 4294954514;
                      }
                      if (cf) {
                        CFRelease(cf);
                      }
                    }
                    else
                    {
LABEL_348:
                      uint64_t OutputDestinationForVideo = 0;
                    }
                    CFStringRef v256 = *v3;
                    uint64_t v257 = CMBaseObjectGetDerivedStorage();
                    uint64_t v258 = CMBaseObjectGetDerivedStorage();
                    if (*(void *)(CMBaseObjectGetDerivedStorage() + 504)
                      && *(const __CFString **)(v257 + 80) == v256
                      && !*(unsigned char *)(v257 + 842)
                      && !*(void *)(v258 + 3208))
                    {
                      uint64_t v264 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                      uint64_t v265 = *(void *)(CMBaseObjectGetVTable() + 8);
                      uint64_t v266 = v265 ? v265 : 0;
                      v303 = *(void (**)(uint64_t, __CFString *, uint64_t))(v266 + 56);
                      if (v303) {
                        v303(v264, @"AllowsPrebuffering", v436);
                      }
                    }
                    CFStringRef v259 = v467;
                    int v91 = v464;
                    if (dword_1E9350BB0)
                    {
                      LODWORD(cf) = 0;
                      v476[0] = OS_LOG_TYPE_DEFAULT;
                      uint64_t v260 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                      unsigned int v261 = cf;
                      if (os_log_type_enabled(v260, OS_LOG_TYPE_DEFAULT)) {
                        unsigned int v262 = v261;
                      }
                      else {
                        unsigned int v262 = v261 & 0xFFFFFFFE;
                      }
                      if (v262)
                      {
                        if (a1) {
                          __int16 v263 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
                        }
                        else {
                          __int16 v263 = "";
                        }
                        CFStringRef v267 = *v3;
                        if (*v3) {
                          Float64 v268 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
                        }
                        else {
                          Float64 v268 = "";
                        }
                        LODWORD(keys.CFDictionarySetValue(theDict, key, value) = 136316674;
                        *(CMTimeValue *)((char *)&keys.value + 4) = (CMTimeValue)"fpfs_createAudioRenderChain";
                        LOWORD(keys.flags) = 2048;
                        *(void *)((char *)&keys.flags + 2) = a1;
                        HIWORD(keys.epoch) = 2082;
                        v483 = v263;
                        __int16 v484 = 2048;
                        CFStringRef v485 = v267;
                        __int16 v486 = 2082;
                        v487 = v268;
                        __int16 v488 = 2114;
                        *(void *)v489 = v437;
                        *(_WORD *)&v489[8] = 2114;
                        *(void *)&v489[10] = v446;
                        _os_log_send_and_compose_impl();
                      }
                      fig_log_call_emit_and_clean_up_after_send_and_compose();
                      CFStringRef v259 = v467;
                      uint64_t v7 = v455;
                    }
                    uint64_t v269 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                    uint64_t v270 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v270) {
                      uint64_t v271 = v270;
                    }
                    else {
                      uint64_t v271 = 0;
                    }
                    v272 = *(void (**)(uint64_t, __CFString *, CFTypeRef))(v271 + 56);
                    if (v272) {
                      v272(v269, @"TimePitchAlgorithm", v437);
                    }
                    uint64_t v273 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                    uint64_t v274 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v274) {
                      uint64_t v275 = v274;
                    }
                    else {
                      uint64_t v275 = 0;
                    }
                    v276 = *(void (**)(uint64_t, __CFString *, CFNumberRef))(v275 + 56);
                    if (v276) {
                      v276(v273, @"PipelineRate", v446);
                    }
                    if (!*((unsigned char *)v472 + 521))
                    {
                      uint64_t v277 = v436;
                      if (!*((unsigned char *)v472 + 522)) {
                        uint64_t v277 = *MEMORY[0x1E4F1CFC8];
                      }
                      uint64_t v436 = v277;
                    }
                    uint64_t v278 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                    uint64_t v279 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v279) {
                      uint64_t v280 = v279;
                    }
                    else {
                      uint64_t v280 = 0;
                    }
                    uint64_t v281 = *(void (**)(uint64_t, __CFString *, uint64_t))(v280 + 56);
                    if (v281) {
                      v281(v278, @"Muted", v436);
                    }
                    uint64_t v282 = *((void *)v464 + 390);
                    uint64_t v283 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                    uint64_t v284 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v284) {
                      uint64_t v285 = v284;
                    }
                    else {
                      uint64_t v285 = 0;
                    }
                    v286 = *(void (**)(uint64_t, __CFString *, uint64_t))(v285 + 56);
                    if (v286) {
                      v286(v283, @"AudioProcessingUnits", v282);
                    }
                    uint64_t v287 = *((void *)v464 + 391);
                    uint64_t v288 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                    uint64_t v289 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v289) {
                      uint64_t v290 = v289;
                    }
                    else {
                      uint64_t v290 = 0;
                    }
                    CMTimeScale v291 = *(void (**)(uint64_t, __CFString *, uint64_t))(v290 + 56);
                    if (v291) {
                      v291(v288, @"SecondaryAudioCurves", v287);
                    }
                    uint64_t v292 = *((void *)v464 + 392);
                    uint64_t v293 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                    uint64_t v294 = *(void *)(CMBaseObjectGetVTable() + 8);
                    if (v294) {
                      uint64_t v295 = v294;
                    }
                    else {
                      uint64_t v295 = 0;
                    }
                    CFTypeRef v296 = *(void (**)(uint64_t, __CFString *, uint64_t))(v295 + 56);
                    if (v296) {
                      v296(v293, @"AudioQueueClockDevice", v292);
                    }
                    CFStringRef v5 = v259;
                    if (*((unsigned char *)v472 + 462))
                    {
                      uint64_t v297 = FigRenderPipelineGetFigBaseObject(v37[1].isa);
                      uint64_t v298 = *(void *)(CMBaseObjectGetVTable() + 8);
                      uint64_t v299 = v298 ? v298 : 0;
                      unsigned int v300 = *(void (**)(uint64_t, __CFString *, void))(v299 + 56);
                      if (v300) {
                        v300(v297, @"ShouldCompensateForNeroScreenLatency", *MEMORY[0x1E4F1CFC8]);
                      }
                    }
                    fpfsi_RTCReportingUpdateAudioInfo((uint64_t)v464, (uint64_t)v3);
                    fpfsi_RTCReportingUpdateAudioSpatialization((uint64_t)v464, ShouldEnableSpatializationForTrack);
                    v37->data = (char *)FigFormatDescriptionRetain();
                    v37->isa = (void *)1;
                    p_isa = (CFTypeRef *)&v37->isa;
                    uint64_t v206 = v37;
                    uint64_t DerivedStorage = v459;
                    if (!OutputDestinationForVideo) {
                      goto LABEL_428;
                    }
                  }
                }
                else
                {
                  uint64_t v206 = 0;
                  uint64_t OutputDestinationForVideo = 4294954514;
                }
                int v301 = v37[1].isa;
                if (v301) {
                  CFRelease(v301);
                }
              }
              free(v37);
              uint64_t v37 = v206;
            }
            else
            {
              uint64_t OutputDestinationForVideo = FigSignalErrorAt();
              uint64_t DerivedStorage = v459;
            }
LABEL_428:
            if (v481) {
              CFRelease(v481);
            }
            goto LABEL_430;
          }
          goto LABEL_231;
        }
LABEL_192:
        sizeOut[0].CMTimeValue value = 0;
        FormatList = CMAudioFormatDescriptionGetFormatList(v92, (size_t *)sizeOut);
        if (!FormatList || sizeOut[0].value <= 0x2FuLL) {
          goto LABEL_233;
        }
        int mFormatID = FormatList->mASBD.mFormatID;
        if (mFormatID <= 1885547314)
        {
          if (mFormatID == 1667574579) {
            goto LABEL_231;
          }
          int v136 = 1700997939;
        }
        else
        {
          if (mFormatID == 1885547315 || mFormatID == 1902324531) {
            goto LABEL_231;
          }
          int v136 = 2053319475;
        }
        if (mFormatID != v136)
        {
LABEL_233:
          char v94 = 0;
          goto LABEL_235;
        }
LABEL_231:
        LODWORD(sizeOut[0].CFDictionarySetValue(theDict, key, value) = ShouldEnableSpatializationForTrack;
        BOOL AtmosDecodePolicy = fpfsi_GetAtmosDecodePolicy((uint64_t)*v3, sizeOut);
        char v94 = AtmosDecodePolicy;
        if (AtmosDecodePolicy) {
          FPSupport_IsDisplayModeSwitchInProgress();
        }
        else {
          CMBaseObjectGetDerivedStorage();
        }
        goto LABEL_235;
      }
      if (MediaSubType == 2053464883) {
        goto LABEL_192;
      }
      if (MediaSubType == 2053319475) {
        goto LABEL_231;
      }
      int v96 = 1902469939;
    }
    else
    {
      if (MediaSubType > 1700997938)
      {
        if (MediaSubType == 1700997939) {
          goto LABEL_231;
        }
        if (MediaSubType != 1700998451)
        {
          int v95 = 1885547315;
          goto LABEL_190;
        }
        goto LABEL_192;
      }
      if (MediaSubType == 1667574579) {
        goto LABEL_231;
      }
      int v96 = 1667575091;
    }
    if (MediaSubType != v96) {
      goto LABEL_235;
    }
    goto LABEL_192;
  }
  uint64_t OutputDestinationForVideo = FigSignalErrorAt();
  uint64_t v37 = 0;
  uint64_t DerivedStorage = v459;
  int v91 = v464;
LABEL_432:
  if (v91[256] == 0.0) {
    v91[256] = CFAbsoluteTimeGetCurrent();
  }
  if (OutputDestinationForVideo) {
    goto LABEL_565;
  }
  CFNumberRef v302 = CFNumberCreate(allocator, kCFNumberCFIndexType, v3 + 2);
  fpfsi_EnsureRenderChainListenersAndPropertiesForAudioTrack();
  FigRenderPipelineSetProperty((uint64_t)v37[1].isa, @"TrackID", (uint64_t)v302);
  FigRenderPipelineSetProperty((uint64_t)v37[1].isa, @"AudioProcessingTap", *(void *)(DerivedStorage + 3112));
  if (v302) {
    CFRelease(v302);
  }
LABEL_570:
  unsigned int v361 = (void *)DerivedStorage;
  fpfs_CacheRenderChain((uint64_t)*v3, v37, *((_DWORD *)v3 + 8));
  v3[12] = v37;
  *((unsigned char *)v3 + 185) = 1;
  *((unsigned char *)v3 + 421) = 0;
  CFStringRef v362 = *v3;
  uint64_t v363 = *(void *)(CMBaseObjectGetDerivedStorage() + 1048);
  if (!v363) {
    goto LABEL_574;
  }
  while (1)
  {
    uint64_t v364 = *(void *)(v363 + 96);
    if (v364)
    {
      if (*(unsigned char *)(v364 + 24)) {
        break;
      }
    }
    uint64_t v363 = *(void *)(v363 + 8);
    if (!v363) {
      goto LABEL_574;
    }
  }
  if (CMFormatDescriptionGetMediaType(*(CMFormatDescriptionRef *)(v364 + 16)) != 1936684398
    && CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)v37->data) == 1936684398)
  {
    *(unsigned char *)(v364 + 24) = 0;
LABEL_574:
    uint64_t HasStarted = fpfs_EstablishTimebase(v362);
    if (HasStarted) {
      return HasStarted;
    }
  }
  uint64_t v463 = (uint64_t)v37;
  if (*((_DWORD *)v3 + 8) == 1936684398)
  {
    fpfs_applyEQPreset((uint64_t)a1, (uint64_t)*v3, (uint64_t)v3);
    uint64_t v67 = (uint64_t)v361;
    if (*(unsigned char *)(v7 + 512)) {
      fpfs_applySoftwareVolumeToTrack((uint64_t)v3, 2, *(float *)(v7 + 516), 0.0);
    }
    float v365 = 0.0;
    if (!*(unsigned char *)(v7 + 520)) {
      float v365 = 1.0;
    }
    fpfs_applySoftwareVolumeToTrack((uint64_t)v3, 5, v365, 0.0);
    fpfs_applySoftwareVolumeToTrack((uint64_t)v3, 1, *(float *)(v7 + 104), 0.0);
    fpfsi_applyLoudnessInfo((uint64_t)v361, (uint64_t)v3, 1);
    fpfsi_applyAdjustTargetLevel((uint64_t)v361, (uint64_t)v3);
    fpfsi_applyAdjustCompressionProfile((uint64_t)v361, (uint64_t)v3);
  }
  else
  {
    uint64_t v67 = (uint64_t)v361;
    uint64_t HasStarted = fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(v463, @"Timebase", v361[72]);
    if (HasStarted) {
      return HasStarted;
    }
    uint64_t v366 = v361[90];
    if (v366)
    {
      uint64_t HasStarted = FigImageQueueTableSetTimebase(v366, (void *)v361[72]);
      if (HasStarted) {
        return HasStarted;
      }
      uint64_t v367 = v361[90];
      if (v367)
      {
        uint64_t HasStarted = FigImageQueueTableReconnectWithTimebase(v367, (void *)v361[72]);
        if (HasStarted) {
          return HasStarted;
        }
      }
    }
    *(unsigned char *)(v463 + 25) = 1;
  }
  if (dword_1E9350BB0)
  {
    CFStringRef v470 = v5;
    LODWORD(values.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(type[0]) = 0;
    v368 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int v369 = values.value;
    if (os_log_type_enabled(v368, (os_log_type_t)type[0])) {
      unsigned int v370 = v369;
    }
    else {
      unsigned int v370 = v369 & 0xFFFFFFFE;
    }
    if (v370)
    {
      if (a1)
      {
        v371 = a1;
        int v372 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      }
      else
      {
        v371 = 0;
        int v372 = "";
      }
      CFStringRef v373 = *v3;
      if (*v3) {
        v374 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
      }
      else {
        v374 = "";
      }
      uint64_t v375 = v361[20];
      CFStringRef v376 = v3[2];
      LODWORD(keys.CFDictionarySetValue(theDict, key, value) = 136316930;
      *(CMTimeValue *)((char *)&keys.value + 4) = (CMTimeValue)"fpfs_EnsureRenderChainForTrack";
      LOWORD(keys.flags) = 2048;
      *(void *)((char *)&keys.flags + 2) = v371;
      HIWORD(keys.epoch) = 2082;
      v483 = v372;
      a1 = v371;
      __int16 v484 = 2048;
      CFStringRef v485 = v373;
      __int16 v486 = 2082;
      v487 = v374;
      __int16 v488 = 1024;
      *(_DWORD *)v489 = v375;
      *(_WORD *)&v489[4] = 2048;
      *(void *)&v489[6] = v463;
      *(_WORD *)&v489[14] = 2048;
      *(void *)&v489[16] = v376;
      _os_log_send_and_compose_impl();
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    uint64_t OutputDestinationForVideo = 0;
    uint64_t v67 = (uint64_t)v361;
    CFStringRef v5 = v470;
  }
  else
  {
    uint64_t OutputDestinationForVideo = 0;
  }
LABEL_605:
  int v377 = *((_DWORD *)v3 + 8);
  if (v377 != 1936684398) {
    goto LABEL_672;
  }
  CFStringRef v378 = v5;
  uint64_t TrackOfType = fpfs_LastTrackOfType((uint64_t)*v3, 1936684398, (uint64_t)v3);
  if (fpfs_WantMATAtmosForTrack((uint64_t)v3))
  {
    if (!TrackOfType)
    {
      *((unsigned char *)v3 + 190) = 0;
      fpfs_applySoftwareVolumeToTrack((uint64_t)v3, 1, *(float *)(v7 + 104), 0.0);
      goto LABEL_644;
    }
    *((unsigned char *)v3 + 190) = 1;
    fpfs_applySoftwareVolumeToTrack((uint64_t)v3, 1, *(float *)(v7 + 104), 0.0);
  }
  else if (!TrackOfType)
  {
    goto LABEL_644;
  }
  if (*(void *)(TrackOfType + 96))
  {
    v451 = a1;
    *((unsigned char *)v3 + 422) = 1;
    CFStringRef v380 = *(const __CFString **)TrackOfType;
    if (*(unsigned char *)(TrackOfType + 421))
    {
      uint64_t v456 = v7;
      if (v380) {
        CFRetain(v380);
      }
      uint64_t v381 = CMBaseObjectGetDerivedStorage();
      if (dword_1E9350BB0)
      {
        long long v382 = (uint64_t *)v381;
        LODWORD(values.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(type[0]) = 0;
        v383 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v384 = values.value;
        if (os_log_type_enabled(v383, (os_log_type_t)type[0])) {
          unsigned int v385 = v384;
        }
        else {
          unsigned int v385 = v384 & 0xFFFFFFFE;
        }
        if (v385)
        {
          uint64_t v386 = *v382;
          if (v386) {
            CMTime v387 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
          }
          else {
            CMTime v387 = "";
          }
          if (v380) {
            v395 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
          }
          else {
            v395 = "";
          }
          uint64_t v396 = *(void *)(TrackOfType + 16);
          CFStringRef v397 = v3[2];
          LODWORD(keys.CFDictionarySetValue(theDict, key, value) = 136316674;
          *(CMTimeValue *)((char *)&keys.value + 4) = (CMTimeValue)"fpfsi_ScheduleNewTrackWhenOldTrackEnds";
          LOWORD(keys.flags) = 2048;
          *(void *)((char *)&keys.flags + 2) = v386;
          HIWORD(keys.epoch) = 2082;
          v483 = v387;
          __int16 v484 = 2048;
          CFStringRef v485 = v380;
          __int16 v486 = 2082;
          v487 = v395;
          __int16 v488 = 1024;
          *(_DWORD *)v489 = v396;
          *(_WORD *)&v489[4] = 1024;
          *(_DWORD *)&v489[6] = v397;
          _os_log_send_and_compose_impl();
        }
        uint64_t v381 = fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      uint64_t v7 = v456;
      fpfs_deferredAudioPlayResourceReleased(v381, v380);
      a1 = v451;
    }
    else
    {
      uint64_t v388 = CMBaseObjectGetDerivedStorage();
      a1 = v451;
      if (dword_1E9350BB0)
      {
        CMTime v389 = (uint64_t *)v388;
        uint64_t v457 = v7;
        LODWORD(values.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(type[0]) = 0;
        CMTime v390 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v391 = values.value;
        if (os_log_type_enabled(v390, (os_log_type_t)type[0])) {
          unsigned int v392 = v391;
        }
        else {
          unsigned int v392 = v391 & 0xFFFFFFFE;
        }
        if (v392)
        {
          uint64_t v393 = *v389;
          if (v393) {
            v394 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
          }
          else {
            v394 = "";
          }
          CFStringRef v398 = *(const __CFString **)TrackOfType;
          if (*(void *)TrackOfType) {
            double v399 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
          }
          else {
            double v399 = "";
          }
          CFStringRef v400 = v3[2];
          uint64_t v401 = *(void *)(TrackOfType + 16);
          LODWORD(keys.CFDictionarySetValue(theDict, key, value) = 136316674;
          *(CMTimeValue *)((char *)&keys.value + 4) = (CMTimeValue)"fpfsi_ScheduleNewTrackWhenOldTrackEnds";
          LOWORD(keys.flags) = 2048;
          *(void *)((char *)&keys.flags + 2) = v393;
          HIWORD(keys.epoch) = 2082;
          v483 = v394;
          __int16 v484 = 2048;
          CFStringRef v485 = v398;
          __int16 v486 = 2082;
          v487 = v399;
          __int16 v488 = 1024;
          *(_DWORD *)v489 = v400;
          *(_WORD *)&v489[4] = 1024;
          *(_DWORD *)&v489[6] = v401;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        a1 = v451;
        uint64_t v7 = v457;
      }
    }
  }
LABEL_644:
  __int16 v402 = (const opaqueCMFormatDescription *)v3[5];
  signed int v403 = CMFormatDescriptionGetMediaSubType(v402);
  int v404 = 1;
  if (v403 <= 1885692722)
  {
    CFStringRef v5 = v378;
    if (v403 > 1700997938)
    {
      if (v403 == 1700997939) {
        goto LABEL_671;
      }
      if (v403 != 1700998451)
      {
        int v405 = 1885547315;
        goto LABEL_659;
      }
      goto LABEL_661;
    }
    if (v403 == 1667574579) {
      goto LABEL_671;
    }
    int v406 = 1667575091;
LABEL_655:
    if (v403 != v406) {
      goto LABEL_670;
    }
    goto LABEL_661;
  }
  CFStringRef v5 = v378;
  if (v403 > 1902469938)
  {
    if (v403 != 2053464883)
    {
      if (v403 == 2053319475) {
        goto LABEL_671;
      }
      int v406 = 1902469939;
      goto LABEL_655;
    }
LABEL_661:
    sizeOut[0].CMTimeValue value = 0;
    CMTimeScale v407 = CMAudioFormatDescriptionGetFormatList(v402, (size_t *)sizeOut);
    int v404 = 0;
    if (!v407 || sizeOut[0].value < 0x30uLL) {
      goto LABEL_671;
    }
    int v408 = v407->mASBD.mFormatID;
    int v404 = 1;
    if (v408 <= 1885547314)
    {
      if (v408 == 1667574579) {
        goto LABEL_671;
      }
      int v409 = 1700997939;
    }
    else
    {
      if (v408 == 1885547315 || v408 == 1902324531) {
        goto LABEL_671;
      }
      int v409 = 2053319475;
    }
    if (v408 == v409) {
      goto LABEL_671;
    }
LABEL_670:
    int v404 = 0;
    goto LABEL_671;
  }
  if (v403 == 1885692723) {
    goto LABEL_661;
  }
  int v405 = 1902324531;
LABEL_659:
  if (v403 != v405) {
    goto LABEL_670;
  }
LABEL_671:
  fpfsi_RTCReportingUpdateATMOSMetricVar(v67, (unsigned char *)(v67 + 2579), (unsigned char *)(v67 + 2575), v404, 0, 0);
  int v377 = *((_DWORD *)v3 + 8);
LABEL_672:
  if (v377 == 1986618469)
  {
    if (!*(unsigned char *)(v67 + 528))
    {
LABEL_681:
      fpfs_SetFeederTrack((uint64_t)v3[12], (uint64_t)v3);
      int v419 = *((_DWORD *)v3 + 8);
      if (v419 == 1936684398)
      {
        fpfs_PrepareAndEnqueueSpatialAudioRenderingChangedNotification(*(const void **)v67, *v3, v413, v414, v415, v416, v417, v418);
        int v419 = *((_DWORD *)v3 + 8);
      }
      if (v419 == 1835365473 && v3[11])
      {
        fpfsi_scheduleFVTTransitionsForItem(v5, 0, 1);
        uint64_t OutputDestinationForVideo = 0;
      }
      if (!*(unsigned char *)(v67 + 469))
      {
        CFArrayRef v420 = (const __CFArray *)*v3;
        if (v420 == fpfs_getNext(v7, 0))
        {
          *(unsigned char *)(v67 + 469) = 1;
          fpfs_EnqueueNotification(a1, @"TimebaseChanged", *v3, 0);
        }
      }
      fpfs_updateCaptionOrSubtitleHintOnVideoPipeline();
      goto LABEL_690;
    }
    fpfs_FlushPrimaryAndAuxRenderChains(v463, 1);
    *(unsigned char *)(v67 + 528) = 0;
    int v377 = *((_DWORD *)v3 + 8);
  }
  if (v377 != 1935832172) {
    goto LABEL_681;
  }
  OptionsDictionaryForSelectedCMMediaType MediaType = fpfs_GetOptionsDictionaryForSelectedMediaType(v67);
  if (!OptionsDictionaryForSelectedMediaType) {
    goto LABEL_681;
  }
  uint64_t v411 = CFDictionaryGetValue(OptionsDictionaryForSelectedMediaType, @"MediaSelectionOptionsExtendedLanguageTag");
  if (!v411) {
    goto LABEL_681;
  }
  v412 = &kFigCaptionRenderPipelineProperty_ExtendedLanguageTagString;
  if (*(unsigned char *)(v7 + 460)) {
    v412 = (uint64_t *)kFigSubtitleRenderPipelineProperty_ExtendedLanguageTagString;
  }
  uint64_t OutputDestinationForVideo = fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(v463, *v412, (uint64_t)v411);
  if (!OutputDestinationForVideo) {
    goto LABEL_681;
  }
  return OutputDestinationForVideo;
}

uint64_t fpfs_SetRenderChainsReleasedForPause(uint64_t a1, int a2)
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (*(unsigned __int8 *)(result + 2880) != a2)
  {
    uint64_t v4 = result;
    *(unsigned char *)(result + 2880) = a2;
    uint64_t result = *(void *)(result + 40);
    if (result)
    {
      if (a2)
      {
        if (!*(void *)(v4 + 1704)) {
          return result;
        }
        CFStringRef v5 = (const void **)MEMORY[0x1E4F1CFD0];
      }
      else
      {
        CFStringRef v5 = (const void **)MEMORY[0x1E4F1CFC8];
      }
      uint64_t v6 = *v5;
      return FigAlternateSelectionBossSetProperty((const void *)result, @"Paused", v6);
    }
  }
  return result;
}

uint64_t fpfsi_isTrackInLists(uint64_t result, uint64_t a2, unsigned int a3)
{
  _OWORD v5[3] = *MEMORY[0x1E4F143B8];
  v5[0] = result + 1048;
  v5[1] = result + 1064;
  void v5[2] = result + 1080;
  if (result)
  {
    uint64_t v3 = 0;
    while (1)
    {
      if ((a3 >> v3))
      {
        uint64_t v4 = *(void *)v5[v3];
        if (v4) {
          break;
        }
      }
LABEL_7:
      if (++v3 == 3) {
        return 0;
      }
    }
    while (v4 != a2)
    {
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4) {
        goto LABEL_7;
      }
    }
    return 1;
  }
  return result;
}

void fpfs_CompleteLogIfLastTrack(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFIndex v5 = *(void *)(a2 + 424);
  if (v5 != -1)
  {
    uint64_t v6 = *(void *)(DerivedStorage + 1048);
    if (v6)
    {
      while (v6 == a2
           || *(void *)(v6 + 424) != v5
           || *(void *)(DerivedStorage + 1112) != *(unsigned __int8 *)(v6 + 180))
      {
        uint64_t v6 = *(void *)(v6 + 8);
        if (!v6) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      fpfs_MarkAccessLogEntryComplete(a1, v5);
    }
    *(void *)(a2 + 424) = -1;
  }
}

uint64_t fpfs_itemContainsTrackWithSharedRenderChain(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2) {
    return 0;
  }
  uint64_t v4 = *(void *)(a2 + 96);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *(void *)(DerivedStorage + 1048);
  if (!v5) {
    return 0;
  }
  while (v5 == a2 || *(void *)(v5 + 96) != v4)
  {
    uint64_t v5 = *(void *)(v5 + 8);
    if (!v5) {
      return 0;
    }
  }
  return 1;
}

uint64_t fpfs_shouldCheckAndReportVariantEnded(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = *(_DWORD *)(result + 32);
    if (v2 == 1986618469) {
      goto LABEL_8;
    }
    if (v2 == 1936684398)
    {
      uint64_t result = *(void *)(result + 440);
      if (!result) {
        return result;
      }
      if (!FigAlternateHasVideo(result))
      {
LABEL_8:
        if (!*(unsigned char *)(v1 + 184)
          && !*(unsigned char *)(v1 + 456)
          && fpfs_FirstTrackWithFormatDescriptionOfType(*(void *)v1, *(_DWORD *)(v1 + 32)) == v1)
        {
          uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
          fpfs_GetTime(DerivedStorage, (uint64_t)&time2);
          CMTime v4 = *(CMTime *)(v1 + 192);
          return CMTimeCompare(&v4, &time2) < 1;
        }
      }
    }
    return 0;
  }
  return result;
}

void fpfs_ReleaseTrackRenderChain(uint64_t a1)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  int v2 = *(const void **)a1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(void *)(a1 + 96);
  if (!v4) {
    goto LABEL_70;
  }
  uint64_t v5 = *(void *)(a1 + 96);
  if (*(unsigned char *)(a1 + 181))
  {
    fpfs_SetFeederTrack(*(void *)(a1 + 96), 0);
    uint64_t v5 = *(void *)(a1 + 96);
  }
  if (*(void *)(v5 + 64))
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      while (1)
      {
        if (*(_DWORD *)(v6 + 32) == *(_DWORD *)(a1 + 32))
        {
          uint64_t v7 = *(void *)(v6 + 96);
          if (v7) {
            break;
          }
        }
        uint64_t v6 = *(void *)(v6 + 8);
        if (!v6) {
          goto LABEL_9;
        }
      }
      if (v7 != v5 && *(_DWORD *)(v6 + 152) == 6)
      {
        if (dword_1E9350BB0)
        {
          LODWORD(cf) = 0;
          os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          uint64_t v7 = *(void *)(v6 + 96);
        }
        fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(v7, @"Suspended", *MEMORY[0x1E4F1CFC8]);
        CFStringRef v69 = *(const void **)(*(void *)(a1 + 96) + 64);
        if (v69)
        {
          CFRelease(v69);
          *(void *)(*(void *)(a1 + 96) + 64) = 0;
        }
      }
    }
  }
LABEL_9:
  if (*(_DWORD *)(a1 + 32) == 1936684398 && !*(unsigned char *)(a1 + 421))
  {
    uint64_t RenderingTrackofType = fpfs_LastRenderingTrackofType((uint64_t)v2, 1936684398, a1);
    if (*(unsigned char *)(DerivedStorage + 530) || RenderingTrackofType && !*(unsigned char *)(RenderingTrackofType + 421))
    {
      if (dword_1E9350BB0 >= 2)
      {
        LODWORD(cf) = 0;
        uint64_t v22 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
    }
    else
    {
      if (v2) {
        uint64_t RenderingTrackofType = (uint64_t)CFRetain(v2);
      }
      if (dword_1E9350BB0)
      {
        LODWORD(cf) = 0;
        uint64_t v40 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
        uint64_t RenderingTrackofType = fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      fpfs_deferredAudioPlayResourceReleased(RenderingTrackofType, v2, v21, *(void *)(*(void *)(a1 + 96) + 32));
    }
  }
  uint64_t v8 = CMBaseObjectGetDerivedStorage();
  BOOL IsPlayerPerformanceTraceEnabled = FPSupport_IsPlayerPerformanceTraceEnabled();
  int v10 = *(_DWORD *)(a1 + 32);
  if (v10 == 1986618469 || v10 == 1936684398)
  {
    uint64_t v11 = CMBaseObjectGetDerivedStorage();
    if (!(*(unsigned __int8 *)(v11 + 656) | IsPlayerPerformanceTraceEnabled))
    {
      int v19 = *(_DWORD *)(a1 + 32);
      if (v19 != 1986618469) {
        goto LABEL_48;
      }
      if (*(unsigned char *)(a1 + 184)) {
        goto LABEL_47;
      }
    }
    uint64_t v12 = CMBaseObjectGetDerivedStorage();
    CFTypeRef cf = 0;
    uint64_t v13 = *(void *)(a1 + 96);
    if (!v13)
    {
LABEL_47:
      int v19 = *(_DWORD *)(a1 + 32);
LABEL_48:
      if (v19 == 1936684398) {
        fpfs_CancelGaplessTransitionThatDependsOnTrack(*(const void **)DerivedStorage, a1, 0);
      }
      goto LABEL_50;
    }
    uint64_t v70 = v12;
    uint64_t v14 = *(void *)(v13 + 32);
    if (v14)
    {
      uint64_t AllocatorForMedia = (const void *)FigGetAllocatorForMedia();
      uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v14);
      uint64_t v17 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v17) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = 0;
      }
      CFStringRef v23 = *(uint64_t (**)(uint64_t, __CFString *, const void *, CFTypeRef *))(v18 + 48);
      if (v23)
      {
        LODWORD(AllocatorForMedia) = v23(FigBaseObject, @"PerformanceDictionary", AllocatorForMedia, &cf);
        CFTypeRef v24 = cf;
        if (AllocatorForMedia || !cf)
        {
LABEL_44:
          if (v24) {
            CFRelease(v24);
          }
          if (!AllocatorForMedia
            && *(void *)(*(void *)(a1 + 96) + 72)
            && *(unsigned __int8 *)(v11 + 656) | IsPlayerPerformanceTraceEnabled)
          {
            int v35 = *(_DWORD *)(a1 + 32);
            if (v35 == 1936684398)
            {
              BOOL v36 = (CFArrayRef *)(v8 + 1904);
            }
            else
            {
              if (v35 != 1986618469) {
                goto LABEL_50;
              }
              BOOL v36 = (CFArrayRef *)(v8 + 1896);
            }
            fpfsi_StoreTrackPerformanceDictionaries(a1, v36);
          }
          goto LABEL_47;
        }
        if (*(_DWORD *)(a1 + 32) == 1986618469)
        {
          FigCFDictionaryGetInt32IfPresent();
          FigCFDictionaryGetInt32IfPresent();
          FigCFDictionaryGetInt32IfPresent();
          FigCFDictionaryGetInt32IfPresent();
          FigCFDictionaryGetInt32IfPresent();
          FigCFDictionaryGetInt32IfPresent();
          FigCFDictionaryGetInt32IfPresent();
          if (*(void *)(*(void *)(a1 + 96) + 72))
          {
            FigCFDictionaryGetInt32IfPresent();
            FigCFDictionaryGetInt32IfPresent();
            FigCFDictionaryGetInt32IfPresent();
            FigCFDictionaryGetInt32IfPresent();
            FigCFDictionaryGetInt32IfPresent();
            FigCFDictionaryGetInt32IfPresent();
            FigCFDictionaryGetInt32IfPresent();
          }
          fpfs_GetTime(v70, (uint64_t)&time2);
          CMTime time1 = *(CMTime *)(a1 + 192);
          if (CMTimeCompare(&time1, &time2) < 0)
          {
            uint64_t v41 = *(void *)(v70 + 2544);
            if (v41)
            {
              uint64_t v42 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v42) {
                uint64_t v43 = v42;
              }
              else {
                uint64_t v43 = 0;
              }
              uint64_t v44 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v43 + 32);
              if (v44) {
                v44(v41, 0x1EE582B78, 0x1EE5618B8, 0);
              }
              uint64_t v45 = *(void *)(v70 + 2544);
              if (v45)
              {
                uint64_t v46 = *(void *)(CMBaseObjectGetVTable() + 16);
                if (v46) {
                  uint64_t v47 = v46;
                }
                else {
                  uint64_t v47 = 0;
                }
                uint64_t v48 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v47 + 32);
                if (v48) {
                  v48(v45, 0x1EE582B78, 0x1EE5618D8, 0);
                }
                uint64_t v49 = *(void *)(v70 + 2544);
                if (v49)
                {
                  uint64_t v50 = *(void *)(CMBaseObjectGetVTable() + 16);
                  if (v50) {
                    uint64_t v51 = v50;
                  }
                  else {
                    uint64_t v51 = 0;
                  }
                  uint64_t v52 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v51 + 32);
                  if (v52) {
                    v52(v49, 0x1EE582B78, 0x1EE5618F8, 0);
                  }
                  uint64_t v53 = *(void *)(v70 + 2544);
                  if (v53)
                  {
                    uint64_t v54 = *(void *)(CMBaseObjectGetVTable() + 16);
                    if (v54) {
                      uint64_t v55 = v54;
                    }
                    else {
                      uint64_t v55 = 0;
                    }
                    uint64_t v56 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v55 + 32);
                    if (v56) {
                      v56(v53, 0x1EE582B78, 0x1EE561918, 0);
                    }
                    uint64_t v57 = *(void *)(v70 + 2544);
                    if (v57)
                    {
                      uint64_t v58 = *(void *)(CMBaseObjectGetVTable() + 16);
                      if (v58) {
                        uint64_t v59 = v58;
                      }
                      else {
                        uint64_t v59 = 0;
                      }
                      uint64_t v60 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v59 + 32);
                      if (v60) {
                        v60(v57, 0x1EE582B78, 0x1EE561898, 0);
                      }
                      uint64_t v61 = *(void *)(v70 + 2544);
                      if (v61)
                      {
                        uint64_t v62 = *(void *)(CMBaseObjectGetVTable() + 16);
                        if (v62) {
                          uint64_t v63 = v62;
                        }
                        else {
                          uint64_t v63 = 0;
                        }
                        uint64_t v64 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v63 + 32);
                        if (v64) {
                          v64(v61, 0x1EE582B78, 0x1EE561938, 0);
                        }
                        uint64_t v65 = *(void *)(v70 + 2544);
                        if (v65)
                        {
                          uint64_t v66 = *(void *)(CMBaseObjectGetVTable() + 16);
                          uint64_t v67 = v66 ? v66 : 0;
                          uint64_t v68 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v67 + 32);
                          if (v68) {
                            v68(v65, 0x1EE582B78, 0x1EE561958, 0);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          CFTypeRef v24 = cf;
          uint64_t v25 = *(void *)(a1 + 96);
          uint64_t AllocatorForMedia = *(const void **)(v25 + 72);
          *(void *)(v25 + 72) = cf;
          if (!v24) {
            goto LABEL_41;
          }
        }
        else
        {
          uint64_t v27 = *(void *)(a1 + 96);
          uint64_t AllocatorForMedia = *(const void **)(v27 + 72);
          *(void *)(v27 + 72) = cf;
        }
        CFRetain(v24);
LABEL_41:
        if (AllocatorForMedia)
        {
          CFRelease(AllocatorForMedia);
          LODWORD(AllocatorForMedia) = 0;
        }
        goto LABEL_43;
      }
      LODWORD(AllocatorForMedia) = -12782;
    }
    else
    {
      LODWORD(AllocatorForMedia) = -12860;
    }
LABEL_43:
    CFTypeRef v24 = cf;
    goto LABEL_44;
  }
LABEL_50:
  if (*(void *)(a1 + 96) == v4)
  {
    *(void *)(a1 + 96) = 0;
    fpfs_releaseRenderChain(v2);
  }
  else if (dword_1E9350BB0)
  {
    LODWORD(cf) = 0;
    CFTypeRef v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int v29 = cf;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v30 = v29;
    }
    else {
      unsigned int v30 = v29 & 0xFFFFFFFE;
    }
    if (!v30) {
      goto LABEL_69;
    }
    uint64_t v31 = DerivedStorage;
    CFArrayRef v32 = *(const void **)DerivedStorage;
    if (*(void *)DerivedStorage)
    {
      uint64_t v33 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      if (v2)
      {
LABEL_58:
        uint64_t v34 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
LABEL_68:
        uint64_t v37 = *(void *)(v31 + 160);
        uint64_t v38 = *(void *)(a1 + 96);
        LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 136316930;
        *(CMTimeValue *)((char *)&time1.value + 4) = (CMTimeValue)"fpfs_ReleaseTrackRenderChain";
        LOWORD(time1.flags) = 2048;
        *(void *)((char *)&time1.flags + 2) = v32;
        HIWORD(time1.epoch) = 2082;
        uint64_t v73 = v33;
        __int16 v74 = 2048;
        uint64_t v75 = v2;
        __int16 v76 = 2082;
        uint64_t v77 = v34;
        __int16 v78 = 1024;
        int v79 = v37;
        __int16 v80 = 2048;
        uint64_t v81 = v38;
        __int16 v82 = 2048;
        uint64_t v83 = v4;
        _os_log_send_and_compose_impl();
LABEL_69:
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        goto LABEL_70;
      }
    }
    else
    {
      uint64_t v33 = "";
      if (v2) {
        goto LABEL_58;
      }
    }
    uint64_t v34 = "";
    goto LABEL_68;
  }
LABEL_70:
  if (*(void *)(a1 + 88))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    uint64_t v39 = *(const void **)(a1 + 88);
    if (v39)
    {
      CFRelease(v39);
      *(void *)(a1 + 88) = 0;
    }
  }
  *(unsigned char *)(a1 + 104) = 0;
  *(_WORD *)(a1 + 421) = 1;
  *(unsigned char *)(a1 + 423) = 0;
}

void fpfs_PrepareAndEnqueueSpatialAudioRenderingChangedNotification(const void *a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  NotificationPayloadForProperties = fpfs_CreateNotificationPayloadForProperties(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, @"IsRenderingSpatialAudio", 0);
  if (NotificationPayloadForProperties)
  {
    uint64_t v11 = NotificationPayloadForProperties;
    fpfs_EnqueueNotification(a1, @"SpatialAudioRenderingChanged", a2, NotificationPayloadForProperties);
    CFRelease(v11);
  }
}

uint64_t fpfsi_RTCReportingReportCheckAndReportVariantEnded(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    if (!*(unsigned char *)(a2 + 184))
    {
      uint64_t v3 = result;
      int v4 = *(_DWORD *)(a2 + 32);
      if (v4 == 1986618469
        || v4 == 1936684398
        && (uint64_t result = *(void *)(a2 + 440)) != 0
        && (uint64_t result = FigAlternateHasVideo(result), !result))
      {
        uint64_t v5 = *(void *)(v3 + 1048);
        if (!v5) {
          goto LABEL_11;
        }
        while (*(_DWORD *)(v5 + 32) != *(_DWORD *)(a2 + 32) || *(void *)(v5 + 16) <= *(void *)(a2 + 16))
        {
          uint64_t v5 = *(void *)(v5 + 8);
          if (!v5) {
            goto LABEL_11;
          }
        }
        uint64_t result = FigCFEqual();
        if (!result)
        {
LABEL_11:
          memset(&v115, 0, sizeof(v115));
          fpfs_GetTime(v3, (uint64_t)&v115);
          uint64_t v6 = (_OWORD *)(v3 + 3028);
          if ((*(unsigned char *)(v3 + 3040) & 1) == 0)
          {
            long long v7 = *(_OWORD *)(a2 + 192);
            *(void *)(v3 + 3044) = *(void *)(a2 + 208);
            *uint64_t v6 = v7;
          }
          CMTime time1 = *(CMTime *)(a2 + 216);
          CMTime v113 = v115;
          if (CMTimeCompare(&time1, &v113) < 0) {
            CMTime v115 = *(CMTime *)(a2 + 216);
          }
          CMTime time1 = v115;
          double Seconds = CMTimeGetSeconds(&time1);
          *(_OWORD *)&time1.CMTimeValue value = *v6;
          time1.CMTimeEpoch epoch = *(void *)(v3 + 3044);
          double v9 = Seconds - CMTimeGetSeconds(&time1);
          uint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
          if (v9 > 0.0)
          {
            uint64_t v11 = UpTimeNanoseconds;
            uint64_t v12 = *(void *)(v3 + 3056);
            uint64_t v13 = *(void *)(v3 + 2544);
            *(_OWORD *)&time1.CMTimeValue value = *v6;
            time1.CMTimeEpoch epoch = *(void *)(v3 + 3044);
            double v14 = CMTimeGetSeconds(&time1);
            if (v13)
            {
              double v15 = v14;
              uint64_t v16 = *(void *)(CMBaseObjectGetVTable() + 16);
              uint64_t v17 = v16 ? v16 : 0;
              uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v17 + 56);
              if (v18) {
                v18(v13, 0x1EE582B78, 0x1EE561858, (uint64_t)(v15 * 1000.0), 0);
              }
            }
            uint64_t v19 = *(void *)(v3 + 2544);
            CMTime time1 = v115;
            double v20 = CMTimeGetSeconds(&time1);
            if (v19)
            {
              double v21 = v20;
              uint64_t v22 = *(void *)(CMBaseObjectGetVTable() + 16);
              uint64_t v23 = v22 ? v22 : 0;
              CFTypeRef v24 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v23 + 56);
              if (v24) {
                v24(v19, 0x1EE582B78, 0x1EE561878, (uint64_t)(v21 * 1000.0), 0);
              }
            }
            uint64_t v25 = *(void *)(v3 + 2544);
            if (v25)
            {
              uint64_t v26 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v26) {
                uint64_t v27 = v26;
              }
              else {
                uint64_t v27 = 0;
              }
              CFTypeRef v28 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v27 + 56);
              if (v28) {
                v28(v25, 0x1EE582B78, 0x1EE561818, (uint64_t)(v9 * 1000.0), 0);
              }
              uint64_t v29 = *(void *)(v3 + 2544);
              if (v29)
              {
                uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v31 = v30 ? v30 : 0;
                CFArrayRef v32 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v31 + 56);
                if (v32) {
                  v32(v29, 0x1EE582B78, 0x1EE561838, (uint64_t)((double)(v11 - v12) / 1000000.0), 0);
                }
              }
            }
            uint64_t v33 = *(void *)(a2 + 440);
            if (v33)
            {
              BOOL v34 = 0;
              LODWORD(v113.CFDictionarySetValue(theDict, key, value) = 0;
              if (*(_DWORD *)(a2 + 32) == 1936684398
                || (HasAudio = FigAlternateHasAudio(v33), BOOL v34 = *(_DWORD *)(a2 + 32) == 1986618469, HasAudio))
              {
                uint64_t v36 = 0;
                uint64_t v37 = 1;
              }
              else
              {
                uint64_t v37 = 0;
                uint64_t v36 = 2;
              }
              if (v34) {
                uint64_t v38 = v36;
              }
              else {
                uint64_t v38 = v37;
              }
              uint64_t v39 = *(void *)(v3 + 2544);
              if (v39)
              {
                uint64_t v40 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v41 = v40 ? v40 : 0;
                uint64_t v42 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v41 + 56);
                if (v42) {
                  v42(v39, 0x1EE582B78, 0x1EE5616D8, v38, 0);
                }
              }
              LODWORD(v113.CFDictionarySetValue(theDict, key, value) = FigAlternateGetAlternateIndex(*(void *)(a2 + 440));
              CFAllocatorRef v43 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
              CFNumberRef v44 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v113);
              uint64_t v45 = *(void *)(v3 + 2544);
              if (v45)
              {
                uint64_t v46 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v47 = v46 ? v46 : 0;
                uint64_t v48 = *(void (**)(uint64_t, uint64_t, uint64_t, CFNumberRef, void))(v47 + 48);
                if (v48) {
                  v48(v45, 0x1EE582B78, 0x1EE561798, v44, 0);
                }
              }
              PeakBitfloat Rate = FigAlternateGetPeakBitRate(*(void *)(a2 + 440));
              uint64_t v50 = *(void *)(v3 + 2544);
              if (v50)
              {
                int v51 = PeakBitRate;
                uint64_t v52 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v53 = v52 ? v52 : 0;
                uint64_t v54 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v53 + 56);
                if (v54) {
                  v54(v50, 0x1EE582B78, 0x1EE561738, v51, 0);
                }
              }
              AverageBitfloat Rate = FigAlternateGetAverageBitRate(*(void *)(a2 + 440));
              uint64_t v56 = *(void *)(v3 + 2544);
              if (v56)
              {
                int v57 = AverageBitRate;
                uint64_t v58 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v59 = v58 ? v58 : 0;
                uint64_t v60 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v59 + 56);
                if (v60) {
                  v60(v56, 0x1EE582B78, 0x1EE561758, v57, 0);
                }
              }
              VariantBitrateRanuint64_t k = FigAlternateGetVariantBitrateRank(*(void *)(a2 + 440), *(_DWORD *)(v3 + 2876));
              uint64_t v62 = *(void *)(v3 + 2544);
              if (v62)
              {
                int v63 = VariantBitrateRank;
                uint64_t v64 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v65 = v64 ? v64 : 0;
                uint64_t v66 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v65 + 56);
                if (v66) {
                  v66(v62, 0x1EE582B78, 0x1EE5619D8, v63, 0);
                }
              }
              CodecCFStringRef String = FigAlternateGetCodecString(*(void *)(a2 + 440));
              uint64_t v68 = *(void *)(v3 + 2544);
              if (v68)
              {
                uint64_t v69 = CodecString;
                uint64_t v70 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v71 = v70 ? v70 : 0;
                uint64_t v72 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v71 + 48);
                if (v72) {
                  v72(v68, 0x1EE582B78, 0x1EE561718, v69, 0);
                }
              }
              int v73 = *(_DWORD *)(a2 + 32);
              if (v73 == 1936684398)
              {
                fpfsi_RTCReportingUpdateAudioInfoForVariantEnd(v3, a2);
              }
              else if (v73 == 1986618469)
              {
                HDCPCFStringRef String = FigAlternateGetHDCPString(*(void *)(a2 + 440));
                VideoRangeCFStringRef String = FigAlternateGetVideoRangeString(*(__CFString **)(a2 + 440));
                time1.CMTimeValue value = 0;
                Resolutiouint64_t n = FigAlternateGetResolution(*(void *)(a2 + 440));
                if (v77 > 0.0 && Resolution > 0.0)
                {
                  double v78 = v77;
                  FigReportingAgentStatsSetIntValue(*(void *)(v3 + 2544), 0x1EE582B78, 0x1EE5617B8, (uint64_t)Resolution);
                  FigReportingAgentStatsSetIntValue(*(void *)(v3 + 2544), 0x1EE582B78, 0x1EE5617D8, (uint64_t)v78);
                }
                time1.CMTimeValue value = FigAlternateGetFrameRate(*(void *)(a2 + 440));
                CFNumberRef v79 = CFNumberCreate(v43, kCFNumberDoubleType, &time1);
                FigReportingAgentStatsSetCFTypeValue(*(void *)(v3 + 2544), 0x1EE582B78, 0x1EE561778, (uint64_t)v79);
                FigReportingAgentStatsSetCFTypeValue(*(void *)(v3 + 2544), 0x1EE582B78, 0x1EE5616F8, (uint64_t)HDCPString);
                FigReportingAgentStatsSetCFTypeValue(*(void *)(v3 + 2544), 0x1EE582B78, 0x1EE5617F8, (uint64_t)VideoRangeString);
                int VideoQualityIndex = FigAlternateGetVideoQualityIndex(*(void *)(a2 + 440));
                FigReportingAgentStatsSetIntValue(*(void *)(v3 + 2544), 0x1EE582B78, 0x1EE561F58, VideoQualityIndex);
                if (v79) {
                  CFRelease(v79);
                }
              }
              if (v44) {
                CFRelease(v44);
              }
            }
            uint64_t v81 = *(void *)(v3 + 2544);
            if (v81)
            {
              uint64_t v82 = *(void *)(CMBaseObjectGetVTable() + 16);
              uint64_t v83 = v82 ? v82 : 0;
              CFTypeRef v84 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v83 + 8);
              if (v84) {
                v84(v81, 0x1EE582B78, 111, 0, 0);
              }
            }
          }
          uint64_t v85 = *(void *)(v3 + 2544);
          if (v85)
          {
            uint64_t v86 = *(void *)(CMBaseObjectGetVTable() + 16);
            if (v86) {
              uint64_t v87 = v86;
            }
            else {
              uint64_t v87 = 0;
            }
            uint64_t v88 = *(void (**)(uint64_t, uint64_t, uint64_t))(v87 + 64);
            if (v88) {
              v88(v85, 0x1EE582B78, 0x1EE5618B8);
            }
            uint64_t v89 = *(void *)(v3 + 2544);
            if (v89)
            {
              uint64_t v90 = *(void *)(CMBaseObjectGetVTable() + 16);
              if (v90) {
                uint64_t v91 = v90;
              }
              else {
                uint64_t v91 = 0;
              }
              __int16 v92 = *(void (**)(uint64_t, uint64_t, uint64_t))(v91 + 64);
              if (v92) {
                v92(v89, 0x1EE582B78, 0x1EE561918);
              }
              uint64_t v93 = *(void *)(v3 + 2544);
              if (v93)
              {
                uint64_t v94 = *(void *)(CMBaseObjectGetVTable() + 16);
                if (v94) {
                  uint64_t v95 = v94;
                }
                else {
                  uint64_t v95 = 0;
                }
                int v96 = *(void (**)(uint64_t, uint64_t, uint64_t))(v95 + 64);
                if (v96) {
                  v96(v93, 0x1EE582B78, 0x1EE561898);
                }
                uint64_t v97 = *(void *)(v3 + 2544);
                if (v97)
                {
                  uint64_t v98 = *(void *)(CMBaseObjectGetVTable() + 16);
                  if (v98) {
                    uint64_t v99 = v98;
                  }
                  else {
                    uint64_t v99 = 0;
                  }
                  BOOL v100 = *(void (**)(uint64_t, uint64_t, uint64_t))(v99 + 64);
                  if (v100) {
                    v100(v97, 0x1EE582B78, 0x1EE5618D8);
                  }
                  uint64_t v101 = *(void *)(v3 + 2544);
                  if (v101)
                  {
                    uint64_t v102 = *(void *)(CMBaseObjectGetVTable() + 16);
                    if (v102) {
                      uint64_t v103 = v102;
                    }
                    else {
                      uint64_t v103 = 0;
                    }
                    int v104 = *(void (**)(uint64_t, uint64_t, uint64_t))(v103 + 64);
                    if (v104) {
                      v104(v101, 0x1EE582B78, 0x1EE561938);
                    }
                    uint64_t v105 = *(void *)(v3 + 2544);
                    if (v105)
                    {
                      uint64_t v106 = *(void *)(CMBaseObjectGetVTable() + 16);
                      if (v106) {
                        uint64_t v107 = v106;
                      }
                      else {
                        uint64_t v107 = 0;
                      }
                      CFStringRef v108 = *(void (**)(uint64_t, uint64_t, uint64_t))(v107 + 64);
                      if (v108) {
                        v108(v105, 0x1EE582B78, 0x1EE5618F8);
                      }
                      uint64_t v109 = *(void *)(v3 + 2544);
                      if (v109)
                      {
                        uint64_t v110 = *(void *)(CMBaseObjectGetVTable() + 16);
                        if (v110) {
                          uint64_t v111 = v110;
                        }
                        else {
                          uint64_t v111 = 0;
                        }
                        CFIndex v112 = *(void (**)(uint64_t, uint64_t, uint64_t))(v111 + 64);
                        if (v112) {
                          v112(v109, 0x1EE582B78, 0x1EE561958);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          *uint64_t v6 = *(_OWORD *)&v115.value;
          *(void *)(v3 + 3044) = v115.epoch;
          uint64_t result = FigGetUpTimeNanoseconds();
          *(void *)(v3 + 3056) = result;
        }
      }
    }
  }
  return result;
}

uint64_t fpfs_StopFeedingTrack(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(const void **)a1;
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  uint64_t v8 = CMBaseObjectGetDerivedStorage();
  if (!*(unsigned char *)(a1 + 182))
  {
    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      uint64_t v10 = *(unsigned int *)(a1 + 24);
      uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v12 = v11 ? v11 : 0;
      uint64_t v13 = *(void (**)(uint64_t, uint64_t, void, void))(v12 + 32);
      if (v13) {
        v13(v9, v10, 0, 0);
      }
    }
    *(unsigned char *)(a1 + 182) = 1;
  }
  if (*(unsigned char *)(a1 + 181))
  {
    CMAttachmentBearerRef target = 0;
    CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    a2 = CMSampleBufferCreate(AllocatorForMedia, 0, 1u, 0, 0, 0, 0, 0, 0, 0, 0, (CMSampleBufferRef *)&target);
    if (!a2)
    {
      double v15 = (const void *)*MEMORY[0x1E4F1CFD0];
      CMSetAttachment(target, (CFStringRef)*MEMORY[0x1E4F1F238], (CFTypeRef)*MEMORY[0x1E4F1CFD0], 1u);
      fpfs_RenderBuffer(a1, (opaqueCMSampleBuffer *)target);
      if (target) {
        CFRelease(target);
      }
      int v16 = *(_DWORD *)(a1 + 32);
      if (v16 == 1986618469)
      {
        if (fpfsi_AllTracksForMediaTypeArePlaying((uint64_t)v6, 1986618469)) {
          fpfs_SignalImageQueueGaugeEnqueueingCompleteAfterDecoding(a1);
        }
      }
      else if (v16 == 1936684398)
      {
        int v17 = fpfsi_AllTracksForMediaTypeArePlaying((uint64_t)v6, 1936684398);
        if (*(void *)(CMBaseObjectGetDerivedStorage() + 504))
        {
          memset(&time2, 0, sizeof(time2));
          *(_OWORD *)&lhs[0].start.unsigned int value = *(_OWORD *)(a1 + 216);
          lhs[0].start.CMTimeEpoch epoch = *(void *)(a1 + 232);
          CMTime rhs = *(CMTime *)(a1 + 192);
          CMTimeSubtract(&time2, &lhs[0].start, &rhs);
          uint64_t v18 = *(void *)(a1 + 96);
          *(_OWORD *)&lhs[0].start.unsigned int value = *(_OWORD *)(v18 + 120);
          lhs[0].start.CMTimeEpoch epoch = *(void *)(v18 + 136);
          CMTime rhs = time2;
          CMTimeAdd(&end, &lhs[0].start, &rhs);
          CMTime rhs = *(CMTime *)(v18 + 96);
          CMTimeRangeFromTimeToTime(lhs, &rhs, &end);
          long long v19 = *(_OWORD *)&lhs[0].start.epoch;
          long long v20 = *(_OWORD *)&lhs[0].duration.timescale;
          *(_OWORD *)(v18 + 96) = *(_OWORD *)&lhs[0].start.value;
          *(_OWORD *)(v18 + 112) = v19;
          *(_OWORD *)(v18 + 128) = v20;
        }
        if (!v17)
        {
          a2 = fpfs_EnqueueReleaseAfterDecoding(a1);
          goto LABEL_26;
        }
        if (!fpfs_getNext(v8, v6))
        {
          CMBaseObjectGetDerivedStorage();
          if (*(void *)(CMBaseObjectGetDerivedStorage() + 504))
          {
            lhs[0].start.unsigned int value = 0;
            CFAllocatorRef v21 = (const __CFAllocator *)FigGetAllocatorForMedia();
            a2 = CMSampleBufferCreate(v21, 0, 1u, 0, 0, 0, 0, 0, 0, 0, 0, (CMSampleBufferRef *)lhs);
            if (!a2)
            {
              CMSetAttachment((CMAttachmentBearerRef)lhs[0].start.value, (CFStringRef)*MEMORY[0x1E4F21A28], v15, 1u);
              a2 = fpfs_RenderBuffer(a1, (opaqueCMSampleBuffer *)lhs[0].start.value);
              if (lhs[0].start.value) {
                CFRelease((CFTypeRef)lhs[0].start.value);
              }
            }
            goto LABEL_26;
          }
        }
      }
      a2 = 0;
    }
LABEL_26:
    fpfs_SetFeederTrack(*(void *)(a1 + 96), 0);
  }
  if (a3 && *(_DWORD *)(v8 + 32))
  {
    if ((*(unsigned char *)(a1 + 228) & 1) == 0 && (~*(_DWORD *)(a1 + 140) & 0x11) != 0)
    {
      uint64_t v22 = MEMORY[0x1E4F1FA08];
      uint64_t v23 = (_OWORD *)(a1 + 216);
      *(_OWORD *)(a1 + 216) = *MEMORY[0x1E4F1FA08];
      *(void *)(a1 + 232) = *(void *)(v22 + 16);
      for (uint64_t i = DerivedStorage[131]; i; uint64_t i = *(void *)(i + 8))
      {
        if (*(void *)(i + 64) <= *(void *)(a1 + 64) && (*(unsigned char *)(i + 228) & 1) != 0)
        {
          *(_OWORD *)&lhs[0].start.unsigned int value = *v23;
          lhs[0].start.CMTimeEpoch epoch = *(void *)(a1 + 232);
          CMTime time2 = *(CMTime *)(i + 216);
          if (CMTimeCompare(&lhs[0].start, &time2) < 0)
          {
            long long v25 = *(_OWORD *)(i + 216);
            *(void *)(a1 + 232) = *(void *)(i + 232);
            *uint64_t v23 = v25;
          }
        }
      }
      if ((*(_DWORD *)(a1 + 228) & 0x1D) != 1)
      {
        fpfs_GetNextTimeToPlay((uint64_t)DerivedStorage, 0, (uint64_t)lhs);
        *uint64_t v23 = *(_OWORD *)&lhs[0].start.value;
        *(void *)(a1 + 232) = lhs[0].start.epoch;
      }
    }
    if (!a2)
    {
      if (!*(void *)(a1 + 112) && (*(unsigned char *)(a1 + 228) & 1) != 0) {
        fpfs_EnsureEndTimerProcForTrack(a1);
      }
      return a2;
    }
LABEL_58:
    fpfs_StopPlayingItemWithOSStatus(v8, (uint64_t)v6, a2);
    return a2;
  }
  if (dword_1E9350BB0)
  {
    LODWORD(rhs.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(target) = 0;
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int value = rhs.value;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, (os_log_type_t)target)) {
      unsigned int v28 = value;
    }
    else {
      unsigned int v28 = value & 0xFFFFFFFE;
    }
    if (v28)
    {
      uint64_t v29 = *DerivedStorage;
      if (v29) {
        uint64_t v30 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      }
      else {
        uint64_t v30 = "";
      }
      uint64_t v31 = *(const void **)a1;
      if (*(void *)a1) {
        CFArrayRef v32 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
      }
      else {
        CFArrayRef v32 = "";
      }
      uint64_t v33 = *(void *)(a1 + 16);
      LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316418;
      *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_StopFeedingTrack";
      LOWORD(time2.flags) = 2048;
      *(void *)((char *)&time2.flags + 2) = v29;
      HIWORD(time2.epoch) = 2082;
      uint64_t v39 = v30;
      __int16 v40 = 2048;
      uint64_t v41 = v31;
      __int16 v42 = 2082;
      CFAllocatorRef v43 = v32;
      __int16 v44 = 1024;
      int v45 = v33;
      _os_log_send_and_compose_impl();
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (a2) {
    goto LABEL_58;
  }
  return a2;
}

uint64_t fpfsi_RemoveCPECryptorListenersOncePerItem(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 384);
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (v3)
  {
    uint64_t v5 = *(void *)(result + 1048);
    if (v5)
    {
      while (v5 == a2 || *(void *)(v5 + 384) != v3)
      {
        uint64_t v5 = *(void *)(v5 + 8);
        if (!v5) {
          goto LABEL_6;
        }
      }
    }
    else
    {
LABEL_6:
      uint64_t v6 = *(void *)(result + 1064);
      if (v6)
      {
        while (v6 == a2 || *(void *)(v6 + 384) != v3)
        {
          uint64_t v6 = *(void *)(v6 + 8);
          if (!v6) {
            goto LABEL_10;
          }
        }
      }
      else
      {
LABEL_10:
        CMNotificationCenterGetDefaultLocalCenter();
        uint64_t result = FigNotificationCenterRemoveWeakListener();
        if (!result)
        {
          CMNotificationCenterGetDefaultLocalCenter();
          return FigNotificationCenterRemoveWeakListener();
        }
      }
    }
  }
  return result;
}

void fpfs_PrepareAndEnqueueTracksChangedNotification(const void *a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  NotificationPayloadForProperties = fpfs_CreateNotificationPayloadForProperties(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, @"TrackIDArray", @"CurrentStableVariantID");
  if (NotificationPayloadForProperties)
  {
    uint64_t v11 = NotificationPayloadForProperties;
    fpfs_EnqueueNotification(a1, @"TracksChanged", a2, NotificationPayloadForProperties);
    CFRelease(v11);
  }
}

void fpfs_FreeTrack(void *a1)
{
  CMBaseObjectGetDerivedStorage();
  FigFormatDescriptionRelease();
  int v2 = (const void *)a1[54];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[55];
  if (v3) {
    CFRelease(v3);
  }
  int v4 = (const void *)a1[58];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[7];
  if (v5) {
    CFRelease(v5);
  }
  if (a1[11])
  {
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    uint64_t v6 = (const void *)a1[11];
    if (v6) {
      CFRelease(v6);
    }
  }
  memset(a1, 3, 0x220uLL);

  free(a1);
}

uint64_t fpfs_ChangeTrackState(uint64_t a1, unsigned int a2)
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  int v5 = *(_DWORD *)(a1 + 152);
  if (v5 == a2) {
    goto LABEL_13;
  }
  if (dword_1E9350BB0)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    uint64_t result = fig_log_call_emit_and_clean_up_after_send_and_compose();
    int v5 = *(_DWORD *)(a1 + 152);
  }
  if ((*(_DWORD *)(a1 + 140) & 1) != 0 || a2 <= 8 && ((1 << a2) & 0x103) != 0)
  {
    int v7 = v5;
  }
  else
  {
    uint64_t v9 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    uint64_t result = fig_log_call_emit_and_clean_up_after_send_and_compose();
    a2 = 0;
    int v7 = *(_DWORD *)(a1 + 152);
  }
  if (v7 == 8)
  {
    uint64_t v8 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  *(_DWORD *)(a1 + 152) = a2;
  if (v5 == 1)
  {
    uint64_t result = fpfs_ResolveAllWaitingTracks(*(const __CFArray **)a1);
    if (result)
    {
LABEL_13:
      uint64_t v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      return fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
  return result;
}

void fpfs_MarkAccessLogEntryComplete(uint64_t a1, CFIndex a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if ((a2 & 0x8000000000000000) == 0)
  {
    uint64_t v5 = DerivedStorage;
    if (CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 1912)) <= a2)
    {
      FigSignalErrorAt();
    }
    else
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v5 + 1912), a2);
      if (ValueAtIndex)
      {
        CFDictionaryRef v7 = ValueAtIndex;
        if (CFDictionaryContainsKey(ValueAtIndex, @"c-provisional-entry"))
        {
          fpfs_UpdateCurrentAccessLogEntryPlayTimes(v5);
          uint64_t valuePtr = 0;
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v7, @"c-frames-dropped");
          if (Value) {
            CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
          }
          uint64_t v9 = CMBaseObjectGetDerivedStorage();
          CFDictionaryRef theDict = 0;
          CFTypeRef v10 = fpfsi_copyCurrentVideoDestination(a1);
          if (v10)
          {
            uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
            uint64_t CMBaseObject = FigAggregateVideoDestinationGetCMBaseObject(v10);
            uint64_t v13 = *(void *)(CMBaseObjectGetVTable() + 8);
            if (v13) {
              uint64_t v14 = v13;
            }
            else {
              uint64_t v14 = 0;
            }
            int v16 = *(void (**)(uint64_t, __CFString *, uint64_t, CFDictionaryRef *))(v14 + 48);
            if (v16) {
              v16(CMBaseObject, @"PerformanceDictionary", AllocatorForMedia, &theDict);
            }
          }
          else
          {
            uint64_t v15 = *(void *)(v9 + 720);
            if (v15) {
              FigImageQueueTableCopyPerformanceDictionary(v15, &theDict);
            }
          }
          if (theDict
            && (uint64_t v43 = 0,
                int v42 = 0,
                CFDictionaryGetValue(theDict, @"imagequeue-0"),
                FigCFDictionaryGetInt32IfPresent(),
                FigCFDictionaryGetInt32IfPresent(),
                FigCFDictionaryGetInt32IfPresent()))
          {
            uint64_t v17 = SHIDWORD(v43);
            if (*(unsigned char *)(v9 + 3024))
            {
              uint64_t v18 = (int)v43;
              uint64_t v40 = v42;
              *(unsigned char *)(v9 + 3024) = 0;
            }
            else
            {
              uint64_t v17 = SHIDWORD(v43) - *(void *)(v9 + 2104);
              uint64_t v18 = (int)v43 - *(void *)(v9 + 2112);
              uint64_t v40 = v42 - *(void *)(v9 + 2120);
            }
            if (v17 >= 1)
            {
              uint64_t v19 = *(void *)(v9 + 2544);
              if (v19)
              {
                uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v21 = v20 ? v20 : 0;
                uint64_t v22 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v21 + 32);
                if (v22) {
                  v22(v19, 0x1EE582B78, 0x1EE583878, v17);
                }
              }
              *(void *)(v9 + 2104) += v17;
            }
            if (v18 >= 1)
            {
              uint64_t v23 = *(void *)(v9 + 2544);
              if (v23)
              {
                uint64_t v24 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v25 = v24 ? v24 : 0;
                uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 32);
                if (v26) {
                  v26(v23, 0x1EE582B78, 0x1EE583898, v18);
                }
              }
              *(void *)(v9 + 2112) += v18;
            }
            uint64_t v27 = (HIDWORD(v43) - v43);
            if ((int)v27 >= 1)
            {
              uint64_t v28 = *(void *)(v9 + 2544);
              if (v28)
              {
                uint64_t v29 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v30 = v29 ? v29 : 0;
                uint64_t v31 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v30 + 32);
                if (v31) {
                  v31(v28, 0x1EE582B78, 0x1EE5838B8, v27);
                }
              }
            }
            if (v40 >= 1)
            {
              uint64_t v32 = *(void *)(v9 + 2544);
              if (v32)
              {
                uint64_t v33 = *(void *)(CMBaseObjectGetVTable() + 16);
                uint64_t v34 = v33 ? v33 : 0;
                int v35 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v34 + 32);
                if (v35) {
                  v35(v32, 0x1EE582B78, 0x1EE5838D8, v40);
                }
              }
              *(void *)(v9 + 2120) += v40;
            }
          }
          else
          {
            uint64_t v17 = 0;
          }
          if (v10) {
            CFRelease(v10);
          }
          if (theDict) {
            CFRelease(theDict);
          }
          valuePtr += v17;
          CFNumberRef v36 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, &valuePtr);
          if (v36)
          {
            CFNumberRef v37 = v36;
            CFDictionarySetValue(v7, @"c-frames-dropped", v36);
            CFRelease(v37);
          }
          else
          {
            FigSignalErrorAt();
          }
          CFDictionaryRemoveValue(v7, @"c-provisional-entry");
        }
      }
      if (*(void *)(v5 + 2624) == a2)
      {
        *(void *)(v5 + 2624) = -1;
        uint64_t v38 = *(void *)(v5 + 1048);
        if (v38)
        {
          while (1)
          {
            CFIndex v39 = *(void *)(v38 + 424);
            if (v39 > a2 && *(void *)(v5 + 1112) == *(unsigned __int8 *)(v38 + 180) && *(_DWORD *)(v38 + 152) == 6) {
              break;
            }
            uint64_t v38 = *(void *)(v38 + 8);
            if (!v38) {
              return;
            }
          }
          *(void *)(v5 + 2624) = v39;
        }
      }
    }
  }
}

uint64_t fpfs_UpdateCurrentAccessLogEntryPlayTimes(uint64_t result)
{
  uint64_t v1 = result;
  if ((*(void *)(result + 2624) & 0x8000000000000000) == 0)
  {
LABEL_2:
    CMBaseObjectGetDerivedStorage();
    CFIndex v2 = *(void *)(v1 + 2624);
    if ((v2 & 0x8000000000000000) == 0 && v2 < CFArrayGetCount(*(CFArrayRef *)(v1 + 1912)))
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 1912), v2);
      if (!ValueAtIndex)
      {
LABEL_38:
        FigSignalErrorAt();
        goto LABEL_24;
      }
      CFDictionaryRef v4 = ValueAtIndex;
      if (CFDictionaryContainsKey(ValueAtIndex, @"c-provisional-entry"))
      {
        if (CFDictionaryContainsKey(v4, @"date") || *(double *)(v1 + 1944) <= 0.0)
        {
LABEL_10:
          if (!fpfs_UpdateAccessLogEntryPlayTimeForKey(v4, @"c-duration-watched", *(double *)(v1 + 1952), *(double *)(v1 + 1944), fabsf(*(float *)(v1 + 848)))&& !fpfs_UpdateAccessLogEntryPlayTimeForKey(v4, @"c-wall-clock-duration-watched", *(double *)(v1 + 1960), *(double *)(v1 + 1944), 1.0))
          {
            if (*(float *)(v1 + 848) == 0.0)
            {
              *(void *)(v1 + 1944) = 0;
              uint64_t v8 = 0;
            }
            else
            {
              *(CFAbsoluteTime *)(v1 + 1944) = CFAbsoluteTimeGetCurrent();
              fpfs_GetTime(v1, (uint64_t)&lhs);
              CMTime v15 = *(CMTime *)(v1 + 1184);
              CMTimeAdd(&time, &lhs, &v15);
              *(Float64 *)(v1 + 1936) = CMTimeGetSeconds(&time);
              uint64_t v8 = *(void *)(v1 + 1944);
            }
            *(void *)(v1 + 1952) = 0;
            *(void *)(v1 + 1960) = 0;
            *(void *)(v1 + 1928) = v8;
          }
          goto LABEL_24;
        }
        CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        CFDateRef v6 = CFDateCreate(AllocatorForMedia, *(CFAbsoluteTime *)(v1 + 1944));
        if (v6)
        {
          CFDateRef v7 = v6;
          CFDictionarySetValue(v4, @"date", v6);
          CFRelease(v7);
          goto LABEL_10;
        }
        goto LABEL_38;
      }
    }
LABEL_24:
    uint64_t result = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 1912), *(void *)(v1 + 2624));
    if (result)
    {
      uint64_t result = CFDictionaryContainsKey((CFDictionaryRef)result, @"c-total-audio-channels");
      if (!result)
      {
        uint64_t v12 = *(void *)(v1 + 1048);
        if (v12)
        {
          uint64_t v13 = 0;
          do
          {
            if (*(_DWORD *)(v12 + 152) == 6 && *(_DWORD *)(v12 + 32) == 1936684398)
            {
              uint64_t result = fpfs_GetAudioChannelCount(*(const opaqueCMFormatDescription **)(v12 + 40));
              if (v13 <= (int)result)
              {
                uint64_t result = fpfs_GetAudioChannelCount(*(const opaqueCMFormatDescription **)(v12 + 40));
                uint64_t v13 = (int)result;
              }
            }
            uint64_t v12 = *(void *)(v12 + 8);
          }
          while (v12);
          if (v13 >= 1) {
            return FigCFDictionarySetInt64();
          }
        }
      }
    }
    return result;
  }
  uint64_t v9 = *(void *)(result + 1048);
  if (v9)
  {
    while (1)
    {
      if (*(_DWORD *)(v9 + 152) == 6)
      {
        CFIndex v10 = *(void *)(v9 + 424);
        if ((v10 & 0x8000000000000000) == 0 && *(void *)(v1 + 1112) == *(unsigned __int8 *)(v9 + 180))
        {
          CFDictionaryRef v11 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 1912), v10);
          uint64_t result = CFDictionaryContainsKey(v11, @"c-provisional-entry");
          if (result) {
            break;
          }
        }
      }
      uint64_t v9 = *(void *)(v9 + 8);
      if (!v9)
      {
        if ((*(void *)(v1 + 2624) & 0x8000000000000000) == 0) {
          goto LABEL_2;
        }
        return result;
      }
    }
    uint64_t v14 = *(void *)(v9 + 424);
    *(void *)(v1 + 2624) = v14;
    if ((v14 & 0x8000000000000000) == 0) {
      goto LABEL_2;
    }
  }
  return result;
}

uint64_t fpfs_GetAudioChannelCount(const opaqueCMFormatDescription *a1)
{
  RichestDecodableFormat = CMAudioFormatDescriptionGetRichestDecodableFormat(a1);
  if (RichestDecodableFormat) {
    return RichestDecodableFormat->mASBD.mChannelsPerFrame;
  }
  else {
    return CMAudioFormatDescriptionGetChannelCount();
  }
}

uint64_t fpfs_UpdateAccessLogEntryPlayTimeForKey(const __CFDictionary *a1, const void *a2, double a3, double a4, double a5)
{
  double valuePtr = 0.0;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
    double v9 = valuePtr;
  }
  else
  {
    double v9 = 0.0;
  }
  double valuePtr = v9 + a3;
  if (a4 != 0.0) {
    double valuePtr = valuePtr + (CFAbsoluteTimeGetCurrent() - a4) * a5;
  }
  return FigCFDictionarySetDouble();
}

uint64_t fpfs_SetFeederTrack(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (v2 != a2)
  {
    uint64_t v4 = result;
    if (v2)
    {
      *(unsigned char *)(v2 + 181) = 0;
      uint64_t result = CMBaseObjectGetDerivedStorage();
      if (dword_1E9350BB0)
      {
        os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        uint64_t result = fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      *(void *)(v4 + 8) = 0;
      for (uint64_t i = *(void *)(v4 + 88); i; uint64_t i = *(void *)(i + 88))
        *(void *)(i + 8) = 0;
    }
    if (a2)
    {
      *(void *)(v4 + 8) = a2;
      uint64_t v7 = *(void *)(v4 + 88);
      uint64_t v8 = a2;
      if (v7)
      {
        do
        {
          *(void *)(v7 + 8) = a2;
          uint64_t v7 = *(void *)(v7 + 88);
        }
        while (v7);
        uint64_t v8 = *(void *)(v4 + 8);
      }
      *(unsigned char *)(v8 + 181) = 1;
      uint64_t result = CMBaseObjectGetDerivedStorage();
      if (dword_1E9350BB0)
      {
        double v9 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
        return fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
    }
  }
  return result;
}

void fpfs_deferredAudioPlayResourceReleased(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v7 = *(const void **)DerivedStorage;
  uint64_t v8 = CMBaseObjectGetDerivedStorage();
  fpfs_LockMutexWithCaller(v7);
  if (!FigRetainProxyIsInvalidated() && !*(unsigned char *)(v8 + 51))
  {
    uint64_t v9 = *(void *)(DerivedStorage + 1048);
    if (v9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      do
      {
        if (!v11)
        {
          if (*(_DWORD *)(v9 + 32) == 1936684398 && *(void *)(v9 + 96))
          {
            if (*(unsigned char *)(v9 + 422)) {
              uint64_t v11 = v9;
            }
            else {
              uint64_t v11 = 0;
            }
          }
          else
          {
            uint64_t v11 = 0;
          }
        }
        uint64_t v12 = *(void *)(v9 + 96);
        if (v12 && *(void *)(v12 + 32) == a4)
        {
          *(unsigned char *)(v9 + 421) = 1;
          uint64_t v10 = v9;
        }
        uint64_t v9 = *(void *)(v9 + 8);
      }
      while (v9);
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t v10 = 0;
    }
    if (dword_1E9350BB0)
    {
      LODWORD(v22.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (v11 && *(void *)(v11 + 96) && !*(unsigned char *)(v11 + 456) && v10)
    {
      if (*(void *)(v11 + 64) == *(void *)(v10 + 64))
      {
        int HaveSamePassthroughFormat = fpfs_DoTracksHaveSamePassthroughFormat(v11, v10, 0);
      }
      else
      {
        LOBYTE(v24.CFDictionarySetValue(theDict, key, value) = 0;
        int HaveSamePassthroughFormat = fpfs_DoTracksHaveSamePassthroughFormat(v11, v10, &v24);
        if (LOBYTE(v24.value))
        {
          AudioChannelCFIndex Count = fpfs_GetAudioChannelCount(*(const opaqueCMFormatDescription **)(v11 + 40));
          int HaveSamePassthroughFormat = AudioChannelCount == fpfs_GetAudioChannelCount(*(const opaqueCMFormatDescription **)(v10 + 40));
        }
      }
      if (HaveSamePassthroughFormat
        && (*(unsigned char *)(*(void *)(v11 + 96) + 25) || !fpfs_SetTimebaseOnTrack((uint64_t)a2, v11)))
      {
        if (*(unsigned char *)(v10 + 456))
        {
          if (fpfs_SetRateOnTrack((uint64_t *)v11, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], *(float *)(DerivedStorage + 848)))goto LABEL_34; {
          goto LABEL_33;
          }
        }
        if (gFSPIsCrossfadeOn == 1)
        {
          memset(&v23, 0, sizeof(v23));
          CMBaseObjectGetDerivedStorage();
          CMTime v24 = *(CMTime *)(v11 + 192);
          CMTime type = *(CMTime *)(v10 + 216);
          CMTime rhs = *(CMTime *)(v11 + 192);
          CMTimeSubtract(&v22, &type, &rhs);
          CMTime type = v22;
          CMTime rhs = *(CMTime *)gFSPAudioCrossfadeDuration;
          if (CMTimeCompare(&type, &rhs) >= 1) {
            CMTime v22 = *(CMTime *)gFSPAudioCrossfadeDuration;
          }
          CMTime type = v22;
          CMTime rhs = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
          if (CMTimeCompare(&type, &rhs) >= 1)
          {
            CMTime type = v24;
            CMTime rhs = v22;
            CMTimeAdd(&v23, &type, &rhs);
            CMTime type = v24;
            CMTime rhs = v23;
            fpfs_scheduleVolumeRamping(v11, &type, &rhs, (const void *)gFSPAudioCurveRampStyle, 0.0, 1.0);
            CMTime type = v24;
            CMTime rhs = v23;
            fpfs_scheduleVolumeRamping(v10, &type, &rhs, (const void *)gFSPAudioCurveRampStyle, 1.0, 0.0);
          }
        }
        uint64_t v16 = *(void *)(*(void *)(v11 + 96) + 32);
        uint64_t v17 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v17) {
          uint64_t v18 = v17;
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = *(unsigned int (**)(uint64_t))(v18 + 48);
        if (v19 && !v19(v16)) {
LABEL_33:
        }
          *(unsigned char *)(v11 + 422) = 0;
      }
    }
  }
LABEL_34:
  fpfs_UnlockAndPostNotificationsWithCaller(v7);
  if (a2) {
    CFRelease(a2);
  }
}

void fpfs_CancelGaplessTransitionThatDependsOnTrack(const void *a1, uint64_t a2, int a3)
{
  CMTime v22 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef Next = fpfs_getNext(DerivedStorage, 0);
  CFArrayRef v8 = fpfs_getNext(DerivedStorage, Next);
  if (v8)
  {
    CFArrayRef v9 = v8;
    if ((*(const __CFArray **)a2 == Next || *(void *)a2 == (void)v8) && *(_DWORD *)(a2 + 32) == 1936684398)
    {
      uint64_t v11 = CMBaseObjectGetDerivedStorage();
      if (*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 2448) == 1)
      {
        uint64_t RenderingTrackofType = fpfs_LastRenderingTrackofType((uint64_t)Next, 1936684398, 0);
        uint64_t v13 = fpfs_FirstRenderingTrackofType((uint64_t)v9, 1936684398);
        if (RenderingTrackofType)
        {
          uint64_t v14 = v13;
          if (v13)
          {
            if (RenderingTrackofType == a2 || v13 == a2)
            {
              fpfs_GetTime(v11, (uint64_t)&v22);
              uint64_t v15 = *(void *)(a2 + 96);
              if (v15 == *(void *)(RenderingTrackofType + 96) && v15 == *(void *)(v14 + 96))
              {
                CMTime time1 = v22;
                CMTime v20 = *(CMTime *)(v11 + 480);
                if (CMTimeCompare(&time1, &v20) < 0 && !fpfsi_PlaybackHasTraversedForwardEndTime())
                {
                  fpfs_CancelGaplessAttempt(a1, v9, *(void *)a2 == (void)Next);
                  if (a3 || *(const __CFArray **)a2 == v9)
                  {
                    BOOL v16 = FigRenderPipelineImplementsCancelAndFlushTransition();
                    CFNumberRef v17 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, (const void *)(v11 + 160));
                    BOOL v18 = 0;
                    if (v17 && v16) {
                      BOOL v18 = FigRenderPipelineCancelAndFlushTransition(*(void *)(*(void *)(RenderingTrackofType + 96) + 32), (uint64_t)v17) != 0;
                    }
                    if (!v16 || v18)
                    {
                      LOBYTE(time1.CFDictionarySetValue(theDict, key, value) = 0;
                      int v19 = fpfs_StealBuffersAfterTransitionMarker(*(opaqueCMBufferQueue **)(*(void *)(RenderingTrackofType + 96) + 40), 0, 0, (char *)&time1);
                      if ((!LOBYTE(time1.value) || v19) && (*(unsigned char *)(v11 + 332) & 1) == 0) {
                        fpfs_stopResetDisturbReprepareAndResume(a1, Next, 0);
                      }
                    }
                    if (v17) {
                      CFRelease(v17);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t fpfs_DoTracksHaveSamePassthroughFormat(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v8 = 0;
  int v5 = fpfs_WantAudioHardwarePassthroughForTrack(a1, (int *)&v8 + 1);
  if (v5 == fpfs_WantAudioHardwarePassthroughForTrack(a2, (int *)&v8)
    && (!v5 || HIDWORD(v8) == v8))
  {
    uint64_t result = 1;
    if (!a3) {
      return result;
    }
  }
  else
  {
    uint64_t result = 0;
    if (!a3) {
      return result;
    }
  }
  if (v5) {
    char v7 = 0;
  }
  else {
    char v7 = result;
  }
  *a3 = v7;
  return result;
}

uint64_t fpfs_SetTimebaseOnTrack(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t result = fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(*(void *)(a2 + 96), @"Timebase", *(void *)(DerivedStorage + 576));
  if (!result)
  {
    *(unsigned char *)(*(void *)(a2 + 96) + 25) = 1;
    return fpfs_GetRelativeRateAndSetRate2OnRenderPipelines(a1, a2);
  }
  return result;
}

void fpfs_scheduleVolumeRamping(uint64_t a1, CMTime *a2, CMTime *a3, const void *a4, float a5, float a6)
{
  float v29 = a6;
  float valuePtr = a5;
  if (*(void *)(a1 + 96))
  {
    CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    CFMutableArrayRef Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E4F1D510]);
    CMTime values = Mutable;
    if (Mutable)
    {
      uint64_t v12 = Mutable;
      CFAllocatorRef v13 = (const __CFAllocator *)FigGetAllocatorForMedia();
      CMTime v27 = *a2;
      CFDictionaryRef v14 = CMTimeCopyAsDictionary(&v27, v13);
      if (v14)
      {
        CFDictionaryRef v15 = v14;
        CFArrayAppendValue(v12, v14);
        CFRelease(v15);
        CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFNumberRef v17 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
        if (v17)
        {
          CFNumberRef v18 = v17;
          CFArrayAppendValue(v12, v17);
          CFRelease(v18);
          CFArrayAppendValue(v12, a4);
          CFAllocatorRef v19 = (const __CFAllocator *)FigGetAllocatorForMedia();
          CMTime v27 = *a3;
          CFDictionaryRef v20 = CMTimeCopyAsDictionary(&v27, v19);
          if (v20)
          {
            CFDictionaryRef v21 = v20;
            CFArrayAppendValue(v12, v20);
            CFRelease(v21);
            CFNumberRef v22 = CFNumberCreate(v16, kCFNumberFloatType, &v29);
            if (v22)
            {
              CFNumberRef v23 = v22;
              CFArrayAppendValue(v12, v22);
              CFRelease(v23);
              CFArrayAppendValue(v12, a4);
              CFAllocatorRef v24 = (const __CFAllocator *)FigGetAllocatorForMedia();
              CFDictionaryRef v25 = CFDictionaryCreate(v24, (const void **)&kFigPlaybackItemAudioCurve_Volume, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              if (v25)
              {
                CFDictionaryRef v26 = v25;
                fpfs_setPropertyOnPrimaryAndAuxRenderPipelines(*(void *)(a1 + 96), @"AudioCurves", (uint64_t)v25);
                CFRelease(v26);
              }
            }
          }
        }
      }
      if (values) {
        CFRelease(values);
      }
    }
  }
}

void fpfsi_StoreTrackPerformanceDictionaries(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef Mutable = *a2;
  if (!*a2)
  {
    CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    CFArrayRef Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E4F1D510]);
    *a2 = Mutable;
  }
  uint64_t v6 = *(void *)(a1 + 96);
  if (!*(unsigned char *)(v6 + 80)) {
    goto LABEL_9;
  }
  CFIndex Count = CFArrayGetCount(Mutable);
  CFArrayRef Mutable = *a2;
  if (Count <= 0)
  {
    uint64_t v6 = *(void *)(a1 + 96);
LABEL_9:
    CFArrayAppendValue(Mutable, *(const void **)(v6 + 72));
    *(unsigned char *)(*(void *)(a1 + 96) + 80) = 1;
    return;
  }
  CFIndex v8 = CFArrayGetCount(*a2) - 1;
  CFArrayRef v9 = *(const void **)(*(void *)(a1 + 96) + 72);

  CFArraySetValueAtIndex(Mutable, v8, v9);
}

uint64_t fpfsi_PlaybackHasTraversedForwardEndTime()
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = CMBaseObjectGetDerivedStorage();
    if (result)
    {
      uint64_t v2 = result;
      memset(&v5, 0, sizeof(v5));
      fpfs_GetTime(v1, (uint64_t)&v5);
      if ((*(_DWORD *)(v1 + 1388) & 0x1D) != 1) {
        return 0;
      }
      CMTime time1 = v5;
      CMTime v3 = *(CMTime *)(v1 + 1376);
      return (CMTimeCompare(&time1, &v3) & 0x80000000) == 0 && *(float *)(v2 + 108) >= 0.0;
    }
  }
  return result;
}

void fpfs_CancelGaplessAttempt(const void *a1, const void *a2, int a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t RenderingTrackofType = fpfs_FirstRenderingTrackofType((uint64_t)a2, 1936684398);
  if (*(unsigned char *)(DerivedStorage + 2448)) {
    BOOL v8 = RenderingTrackofType == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    uint64_t v9 = RenderingTrackofType;
    if (*(unsigned char *)(RenderingTrackofType + 423))
    {
      if (*(unsigned char *)(DerivedStorage + 2449))
      {
        fpfs_EnqueueNotification(a1, @"CancelNextItemTransitionTimer", a2, 0);
        *(unsigned char *)(DerivedStorage + 2449) = 0;
      }
      *(unsigned char *)(DerivedStorage + 2448) = 0;
      *(unsigned char *)(v9 + 423) = 0;
      if (a3)
      {
        fpfs_stopResetDisturbReprepareAndResume(a1, (const __CFArray *)a2, 0);
      }
    }
  }
}

BOOL FigRenderPipelineImplementsCancelAndFlushTransition()
{
  uint64_t v0 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v0) {
    uint64_t v1 = v0;
  }
  else {
    uint64_t v1 = 0;
  }
  return *(void *)(v1 + 80) != 0;
}

uint64_t FigRenderPipelineCancelAndFlushTransition(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 80);
  if (!v6) {
    return 4294954514;
  }

  return v6(a1, a2);
}

uint64_t fpfs_StealBuffersAfterTransitionMarker(opaqueCMBufferQueue *a1, int a2, opaqueCMBufferQueue *a3, char *a4)
{
  CFTypeRef cf = 0;
  CMBufferQueueRef queueOut = 0;
  if (!a1)
  {
    uint64_t v10 = FigSignalErrorAt();
LABEL_31:
    uint64_t v14 = v10;
    goto LABEL_8;
  }
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CallbacksForUnsortedSampleBuffers = CMBufferQueueGetCallbacksForUnsortedSampleBuffers();
  uint64_t v10 = CMBufferQueueCreate(AllocatorForMedia, 0, CallbacksForUnsortedSampleBuffers, &queueOut);
  if (v10) {
    goto LABEL_31;
  }
  CFAllocatorRef v11 = (const __CFAllocator *)FigGetAllocatorForMedia();
  uint64_t v12 = CMBufferQueueGetCallbacksForUnsortedSampleBuffers();
  uint64_t v10 = CMBufferQueueCreate(v11, 0, v12, (CMBufferQueueRef *)&cf);
  if (v10) {
    goto LABEL_31;
  }
  MEMORY[0x199709540](a1, fpfs_StealBuffer, queueOut);
  if (CMBufferQueueIsEmpty(queueOut) || (CMBufferRef v16 = CMBufferQueueDequeueAndRetain(queueOut)) == 0)
  {
LABEL_5:
    MEMORY[0x199709540](cf, fpfs_StealBuffer, a3);
    char v13 = 0;
    goto LABEL_6;
  }
  CFNumberRef v17 = (void *)v16;
  int v18 = 0;
  CFStringRef v19 = (const __CFString *)*MEMORY[0x1E4F1F2F8];
  do
  {
    if (v18)
    {
      if (!a3)
      {
        CFRelease(v17);
        goto LABEL_29;
      }
      CFDictionaryRef v20 = a3;
      goto LABEL_18;
    }
    if (fpfs_IsMarkerSampleContainingAttachment((opaqueCMSampleBuffer *)v17, v19))
    {
      MEMORY[0x199709540](cf, fpfs_StealBuffer, a1);
      if (!a2) {
        goto LABEL_19;
      }
      CFDictionaryRef v20 = a1;
LABEL_18:
      CMBufferQueueEnqueue(v20, v17);
LABEL_19:
      int v21 = 0;
      int v18 = 1;
      goto LABEL_20;
    }
    CMBufferQueueEnqueue((CMBufferQueueRef)cf, v17);
    int v18 = 0;
    int v21 = 1;
LABEL_20:
    CFRelease(v17);
    CFNumberRef v17 = (void *)CMBufferQueueDequeueAndRetain(queueOut);
  }
  while (v17);
  if (v21) {
    goto LABEL_5;
  }
LABEL_29:
  char v13 = 1;
LABEL_6:
  uint64_t v14 = 0;
  if (a4) {
    *a4 = v13;
  }
LABEL_8:
  if (queueOut) {
    CFRelease(queueOut);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v14;
}

BOOL fpfs_IsMarkerSampleContainingAttachment(opaqueCMSampleBuffer *a1, const __CFString *a2)
{
  BOOL result = fpfs_IsMarkerOnly(a1);
  if (result) {
    return CMGetAttachment(a1, a2, 0) != 0;
  }
  return result;
}

void fpfsi_RTCReportingUpdateAudioInfoForVariantEnd(uint64_t a1, uint64_t a2)
{
  valuePtr[16] = *(double *)MEMORY[0x1E4F143B8];
  if (!*(void *)(a2 + 440)) {
    return;
  }
  RichestDecodableFormat = CMAudioFormatDescriptionGetRichestDecodableFormat(*(CMAudioFormatDescriptionRef *)(a2 + 40));
  if (RichestDecodableFormat) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = dword_1E9350BB0 == 0;
  }
  if (!v5)
  {
    os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  CFDictionaryRef CurrentAudioPersistentIDFromMediaOption = fpfsi_GetCurrentAudioPersistentIDFromMediaOption();
  unsigned int v35 = 0;
  AudioChannelCFIndex Count = FigAlternateGetAudioChannelCount(*(const void **)(a2 + 440), CurrentAudioPersistentIDFromMediaOption, &v35);
  if ((AudioChannelCount - 1) <= 1)
  {
    if ((v35 & 2) != 0) {
      unint64_t v9 = 3;
    }
    else {
      unint64_t v9 = ((unint64_t)v35 >> 1) & 2;
    }
    goto LABEL_13;
  }
  if (AudioChannelCount >= 3)
  {
    unint64_t v9 = 1;
LABEL_13:
    uint64_t v10 = *(void *)(a1 + 2544);
    if (v10)
    {
      uint64_t v11 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v12 = v11 ? v11 : 0;
      char v13 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, void))(v12 + 56);
      if (v13) {
        v13(v10, 0x1EE582B78, 0x1EE562278, v9, 0);
      }
    }
  }
  if (fpfs_ShouldEnableSpatializationForTrack(a2))
  {
    uint64_t v14 = *(void *)(a1 + 2544);
    if (v14)
    {
      uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v16 = v15 ? v15 : 0;
      CFNumberRef v17 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v16 + 56);
      if (v17) {
        v17(v14, 0x1EE582B78, 0x1EE5622D8, 1, 0);
      }
    }
  }
  if (RichestDecodableFormat)
  {
    uint64_t v18 = *(void *)(a1 + 2544);
    CFStringForOSTypeCFNumberRef Value = FigGetCFStringForOSTypeValue();
    if (v18)
    {
      uint64_t v20 = CFStringForOSTypeValue;
      uint64_t v21 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v22 = v21 ? v21 : 0;
      CFNumberRef v23 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v22 + 48);
      if (v23) {
        v23(v18, 0x1EE582B78, 0x1EE5853F8, v20, 0);
      }
    }
    CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v25 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, RichestDecodableFormat);
    uint64_t v26 = *(void *)(a1 + 2544);
    if (v26)
    {
      uint64_t v27 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v28 = v27 ? v27 : 0;
      float v29 = *(void (**)(uint64_t, uint64_t, uint64_t, CFNumberRef, void))(v28 + 48);
      if (v29) {
        v29(v26, 0x1EE582B78, 0x1EE585418, v25, 0);
      }
    }
    valuePtr[0] = RichestDecodableFormat->mASBD.mSampleRate * (float)RichestDecodableFormat->mASBD.mBytesPerFrame * 8.0;
    CFNumberRef v30 = CFNumberCreate(v24, kCFNumberDoubleType, valuePtr);
    uint64_t v31 = *(void *)(a1 + 2544);
    if (v31)
    {
      uint64_t v32 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v33 = v32 ? v32 : 0;
      uint64_t v34 = *(void (**)(uint64_t, uint64_t, uint64_t, CFNumberRef, void))(v33 + 48);
      if (v34) {
        v34(v31, 0x1EE582B78, 0x1EE585438, v30, 0);
      }
    }
    if (v25) {
      CFRelease(v25);
    }
    if (v30) {
      CFRelease(v30);
    }
  }
}

CFDictionaryRef fpfsi_GetCurrentAudioPersistentIDFromMediaOption()
{
  CFArrayRef v0 = *(const __CFArray **)(CMBaseObjectGetDerivedStorage() + 1792);
  CFStringForOSTypeCFNumberRef Value = FigGetCFStringForOSTypeValue();
  CFDictionaryRef result = fpfs_FindMediaTypeInMediaArray(v0, CFStringForOSTypeValue, 0);
  if (result)
  {
    return (const __CFDictionary *)CFDictionaryGetValue(result, @"MediaSelectionOptionsPersistentID");
  }
  return result;
}

uint64_t fpfs_ShouldEnableSpatializationForTrack(uint64_t a1)
{
  uint64_t v7 = 0;
  uint64_t v2 = *(void *)a1;
  CMBaseObjectGetDerivedStorage();
  int AudioFormatDescriptionSpatializationEligibility = FPSupport_GetAudioFormatDescriptionSpatializationEligibility(*(void *)(a1 + 40), &v7);
  CFDictionaryRef CurrentAudioPersistentIDFromMediaOption = fpfsi_GetCurrentAudioPersistentIDFromMediaOption();
  FigAlternateGetImmersiveAudioCapability(*(const void **)(a1 + 440), CurrentAudioPersistentIDFromMediaOption);
  if (AudioFormatDescriptionSpatializationEligibility == 2) {
    return fpfsi_IsSpatializationAllowed(v2);
  }
  uint64_t v5 = 0;
  if (AudioFormatDescriptionSpatializationEligibility == 1)
  {
    uint64_t v5 = 1;
    if (!fpfsi_IsSpatializationAllowed(v2)) {
      return fpfsi_IsSpatializationAllowed(v2);
    }
  }
  return v5;
}

CFDictionaryRef fpfs_FindMediaTypeInMediaArray(const __CFArray *a1, uint64_t a2, CFIndex *a3)
{
  CFDictionaryRef ValueAtIndex = 0;
  if (a1 && a2)
  {
    CFIndex Count = CFArrayGetCount(a1);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      CFIndex v7 = Count;
      CFIndex v8 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v8);
        CFDictionaryGetValue(ValueAtIndex, @"MediaSelectionGroupMediaType");
        if (FigCFEqual()) {
          break;
        }
        if (v7 == ++v8) {
          return 0;
        }
      }
      if (a3) {
        *a3 = v8;
      }
    }
  }
  return ValueAtIndex;
}

uint64_t fpfsi_IsSpatializationAllowed(uint64_t a1)
{
  CFArrayRef theArray = 0;
  if (*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 779)) {
    int v2 = 1836019574;
  }
  else {
    int v2 = 1936684398;
  }
  int v3 = fpfsi_CreateAudioSpatialSourcesArray(a1, v2, &theArray, 0, 0);
  CFArrayRef Count = theArray;
  if (v3) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = theArray == 0;
  }
  if (v5)
  {
    if (!theArray) {
      return 0;
    }
    goto LABEL_17;
  }
  uint64_t v6 = 0;
  if (!theArray) {
    goto LABEL_13;
  }
LABEL_12:
  CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
LABEL_13:
  while (v6 < (uint64_t)Count)
  {
    FigCFArrayGetInt32AtIndex();
    ++v6;
    CFArrayRef Count = theArray;
    if (theArray) {
      goto LABEL_12;
    }
  }
  CFArrayRef Count = theArray;
  if (theArray) {
LABEL_17:
  }
    CFRelease(Count);
  return 0;
}

uint64_t fpfsi_AllTracksForMediaTypeArePlaying(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage() + 1048);
  if (!v3) {
    return 1;
  }
  while (*(_DWORD *)(v3 + 32) != a2 || *(_DWORD *)(v3 + 152) == 6)
  {
    uint64_t v3 = *(void *)(v3 + 8);
    if (!v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t fpfs_EnqueueReleaseAfterDecoding(uint64_t a1)
{
  CMAttachmentBearerRef target = 0;
  CMBaseObjectGetDerivedStorage();
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  uint64_t v3 = CMSampleBufferCreate(AllocatorForMedia, 0, 1u, 0, 0, 0, 0, 0, 0, 0, 0, (CMSampleBufferRef *)&target);
  if (!v3)
  {
    if (*(void *)(CMBaseObjectGetDerivedStorage() + 504) && (_os_feature_enabled_impl() & 1) == 0)
    {
      CMAttachmentBearerRef v4 = target;
      BOOL v5 = *(_OWORD **)(a1 + 96);
      CFAllocatorRef v6 = (const __CFAllocator *)FigGetAllocatorForMedia();
      long long v7 = v5[7];
      *(_OWORD *)&range.start.unsigned int value = v5[6];
      *(_OWORD *)&range.start.CMTimeEpoch epoch = v7;
      *(_OWORD *)&range.duration.CMTimeScale timescale = v5[8];
      CFDictionaryRef v8 = CMTimeRangeCopyAsDictionary(&range, v6);
      CMSetAttachment(v4, (CFStringRef)*MEMORY[0x1E4F21A40], v8, 1u);
      if (v8) {
        CFRelease(v8);
      }
      CMBaseObjectGetDerivedStorage();
      unint64_t v9 = *(_OWORD **)(a1 + 96);
      long long v10 = *(_OWORD *)(MEMORY[0x1E4F1FA30] + 32);
      long long v11 = *MEMORY[0x1E4F1FA30];
      v9[7] = *(_OWORD *)(MEMORY[0x1E4F1FA30] + 16);
      v9[8] = v10;
      v9[6] = v11;
    }
    CMSetAttachment(target, (CFStringRef)*MEMORY[0x1E4F21A30], (CFTypeRef)*MEMORY[0x1E4F1CFD0], 1u);
    uint64_t v3 = fpfs_RenderBuffer(a1, (opaqueCMSampleBuffer *)target);
    if (target) {
      CFRelease(target);
    }
  }
  return v3;
}

uint64_t fpfs_EnsureEndTimerProcForTrack(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v2 = *(void **)a1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef ItemAndTrackNumberPayload = fpfs_CreateItemAndTrackNumberPayload(v2, a1);
  BOOL v5 = fpfs_TimerDispatchSourceCreate(*(dispatch_queue_t *)(DerivedStorage + 600), ItemAndTrackNumberPayload, 0xFFFFFFFFFFFFFFFFLL, (void (__cdecl *)(void *))fpfs_endTimerProc, 0);
  *(void *)(a1 + 112) = v5;
  if (ItemAndTrackNumberPayload)
  {
    CFRelease(ItemAndTrackNumberPayload);
    CFAllocatorRef v6 = *(NSObject **)(a1 + 112);
    if (v6)
    {
LABEL_3:
      long long v12 = *MEMORY[0x1E4F1F9F8];
      long long v15 = *MEMORY[0x1E4F1F9F8];
      uint64_t v7 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
      uint64_t v16 = v7;
      CMTimebaseAddTimerDispatchSource(*(CMTimebaseRef *)(DerivedStorage + 576), v6);
      uint64_t result = fpfs_scheduleForwardEndTimeForTrack(DerivedStorage, a1, (uint64_t)&v15);
      unint64_t v9 = *(NSObject **)(a1 + 120);
      if (v9)
      {
        long long v10 = *(OpaqueCMTimebase **)(DerivedStorage + 576);
        CMTime fireTime = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA10];
        uint64_t result = CMTimebaseSetTimerDispatchSourceNextFireTime(v10, v9, &fireTime, 1u);
        *(_OWORD *)(a1 + 156) = v12;
        *(void *)(a1 + 172) = v7;
      }
      if (dword_1E9350BB0)
      {
        int v14 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        return fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      return result;
    }
  }
  else
  {
    CFAllocatorRef v6 = v5;
    if (v5) {
      goto LABEL_3;
    }
  }

  return FigSignalErrorAt();
}

void fpfs_StopPlayingItemWithOSStatus(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFTypeRef cf = 0;
  FigCreateErrorForOSStatus(a3, (CFErrorRef *)&cf);
  fpfs_StopPlayingItem(a1, a2, cf);
  if (cf) {
    CFRelease(cf);
  }
}

CFArrayRef fpfs_CreateItemAndTrackNumberPayload(void *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a2) {
    uint64_t v2 = *(void *)(a2 + 16);
  }
  else {
    uint64_t v2 = -1;
  }
  uint64_t v6 = v2;
  CMTime values = a1;
  CFTypeRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &v6);
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFArrayRef v4 = CFArrayCreate(AllocatorForMedia, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
  if (cf) {
    CFRelease(cf);
  }
  return v4;
}

void fpfs_endTimerProc(const __CFArray *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = 0;
  CFArrayGetValueAtIndex(a1, 0);
  CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFArrayRef v4 = *(const void **)DerivedStorage;
  uint64_t v5 = CMBaseObjectGetDerivedStorage();
  *(unsigned char *)(DerivedStorage + 529) = 1;
  CFNumberGetValue(ValueAtIndex, kCFNumberSInt64Type, &valuePtr);
  fpfs_LockMutexWithCaller(v4);
  id v6 = *(id *)(v5 + 776);
  voucher_adopt();
  if (!FigRetainProxyIsInvalidated())
  {
    uint64_t v7 = *(void *)(DerivedStorage + 1048);
    if (!v7)
    {
LABEL_16:
      fpfs_endEndedTracks(DerivedStorage);
      goto LABEL_17;
    }
    while (*(void *)(v7 + 16) != valuePtr)
    {
      uint64_t v7 = *(void *)(v7 + 8);
      if (!v7) {
        goto LABEL_16;
      }
    }
    memset(&v10, 0, sizeof(v10));
    fpfs_GetTime(DerivedStorage, (uint64_t)&v10);
    if (dword_1E9350BB0)
    {
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    float v8 = *(float *)(v5 + 108);
    if (v8 >= 0.0)
    {
      CMTime time = v10;
      CMTime time2 = *(CMTime *)(v7 + 216);
      if ((CMTimeCompare(&time, &time2) & 0x80000000) == 0
        || (CMTime time = v10, time2 = *(CMTime *)(DerivedStorage + 1376), (CMTimeCompare(&time, &time2) & 0x80000000) == 0))
      {
LABEL_15:
        fpfs_EndTrackPlayback(v7);
        goto LABEL_16;
      }
      float v8 = *(float *)(v5 + 108);
    }
    if (v8 >= 0.0 || (CMTime time = v10, time2 = *(CMTime *)(v7 + 216), CMTimeCompare(&time, &time2) > 0))
    {
      CMTime time = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
      if (!fpfs_scheduleForwardEndTimeForTrack(DerivedStorage, v7, (uint64_t)&time)) {
        goto LABEL_16;
      }
    }
    goto LABEL_15;
  }
LABEL_17:
  *(unsigned char *)(DerivedStorage + 529) = 0;

  fpfs_UnlockAndPostNotificationsWithCaller(v4);
}

void fpfs_EndTrackPlayback(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(const void **)a1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = CMBaseObjectGetDerivedStorage();
  int v5 = *(_DWORD *)(a1 + 32);
  fpfs_FinishTrack(a1, 1);
  uint64_t v6 = *(void *)(DerivedStorage + 1048);
  if (!v6) {
    goto LABEL_9;
  }
  while (*(_DWORD *)(v6 + 32) != v5 || !fpfsi_areTracksSyncPairs(a1, v6))
  {
    uint64_t v6 = *(void *)(v6 + 8);
    if (!v6) {
      goto LABEL_9;
    }
  }
  if (*(_DWORD *)(v6 + 152) != 1)
  {
LABEL_9:
    if (*(float *)(DerivedStorage + 848) != 0.0)
    {
      uint64_t v8 = *(void *)(DerivedStorage + 1048);
      if (!v8)
      {
LABEL_14:
        float v9 = *(float *)(v4 + 108);
        if (v9 <= 2.0 && v9 >= 0.0 || *(void *)(DerivedStorage + 2968))
        {
          fpfs_setUnlikelyToKeepUpAndRanDry(v2);
          if (!*(unsigned char *)(DerivedStorage + 470)
            && !fpfsi_PlaybackHasBufferedBeyondForwardEndTime((uint64_t)v2))
          {
            uint64_t v10 = *(void *)DerivedStorage;
            long long v19 = *MEMORY[0x1E4F1F9F8];
            uint64_t v20 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
            long long v17 = v19;
            uint64_t v18 = v20;
            fpfs_setRateInternal(v10, v2, &v19, &v17, 0.0);
          }
        }
        goto LABEL_21;
      }
      while (v8 == a1 || *(_DWORD *)(v8 + 152) != 6)
      {
        uint64_t v8 = *(void *)(v8 + 8);
        if (!v8) {
          goto LABEL_14;
        }
      }
      if (*(unsigned char *)(a1 + 184)) {
        goto LABEL_21;
      }
      unsigned int v11 = *(unsigned __int8 *)(a1 + 180);
      if (((*(_DWORD *)(DerivedStorage + 1096) >> v11) & 1) == 0) {
        goto LABEL_21;
      }
      if (*(_DWORD *)(a1 + 32) == 1986618469)
      {
        if (!fpfs_CanRenderVideo(v4, *(void *)v8)) {
          goto LABEL_21;
        }
        unsigned int v11 = *(unsigned __int8 *)(a1 + 180);
      }
      if (!*(unsigned char *)(DerivedStorage + v11 + 471))
      {
        uint64_t v12 = *(void *)(DerivedStorage + 1048);
        if (!v12) {
          goto LABEL_43;
        }
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        do
        {
          if (*(unsigned __int8 *)(v12 + 180) == v11)
          {
            if (*(_DWORD *)(v12 + 152) == 6 && *(void *)(v12 + 64) == *(void *)(a1 + 64) && !*(unsigned char *)(v12 + 184)) {
              uint64_t v14 = v12;
            }
            uint64_t v13 = v12;
          }
          uint64_t v12 = *(void *)(v12 + 8);
        }
        while (v12);
        if (!v13 || (*(void *)(v13 + 64) == *(void *)(a1 + 64) ? (BOOL v15 = v14 == 0) : (BOOL v15 = 0), v15))
        {
LABEL_43:
          if (dword_1E9350BB0)
          {
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          if (fpfs_StopPlaybackByStalledTrack(a1, 1u)) {
            return;
          }
        }
      }
    }
LABEL_21:
    fpfsi_UpdateAudioActiveSamples((uint64_t)v2, 0);
    return;
  }
  fpfsi_UpdateAudioActiveSamples((uint64_t)v2, 0);
  if (dword_1E9350BB0)
  {
    uint64_t v7 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  fpfs_AbandonSyncAttempt(v6);
}

void fpfs_endEndedTracks(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = *(void *)(a1 + 1048);
  if (v3)
  {
    uint64_t v4 = DerivedStorage;
    do
    {
      memset(&v7, 0, sizeof(v7));
      fpfs_GetTime(a1, (uint64_t)&v7);
      if (*(float *)(v4 + 108) >= 0.0)
      {
        if (*(unsigned char *)(v3 + 182)
          && (CMTime time1 = v7, time2 = *(CMTime *)(v3 + 216), (CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
          || (CMTime time1 = v7, time2 = *(CMTime *)(a1 + 1376), (CMTimeCompare(&time1, &time2) & 0x80000000) == 0))
        {
LABEL_10:
          if (dword_1E9350BB0)
          {
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          fpfs_EndTrackPlayback(v3);
          uint64_t v6 = (uint64_t *)(a1 + 1048);
          goto LABEL_14;
        }
      }
      else if (*(unsigned char *)(v3 + 182))
      {
        CMTime time1 = v7;
        CMTime time2 = *(CMTime *)(v3 + 216);
        if (CMTimeCompare(&time1, &time2) <= 0) {
          goto LABEL_10;
        }
      }
      uint64_t v6 = (uint64_t *)(v3 + 8);
LABEL_14:
      uint64_t v3 = *v6;
    }
    while (*v6);
  }
}

void fpfs_FinishTrack(uint64_t a1, int a2)
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  uint64_t v111 = a1;
  CFStringRef v3 = *(const __CFString **)a1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  memset(&v110, 0, sizeof(v110));
  fpfs_GetTime(DerivedStorage, (uint64_t)&v110);
  CMTimeValue v124 = *(void *)(a1 + 240);
  CMTimeFlags v105 = *(_DWORD *)(a1 + 252);
  CMTimeScale v125 = *(_DWORD *)(a1 + 248);
  CMTimeEpoch v101 = *(void *)(a1 + 256);
  int v5 = *(const void **)DerivedStorage;
  uint64_t v6 = CMBaseObjectGetDerivedStorage();
  int v104 = *(_DWORD *)(a1 + 32);
  uint64_t v95 = *(void *)(a1 + 16);
  CFTypeRef v108 = 0;
  CFTypeRef v109 = 0;
  if (*(_DWORD *)(v6 + 808) == 2)
  {
    uint64_t v7 = *(void *)(CMBaseObjectGetDerivedStorage() + 1048);
    if (v7)
    {
      uint64_t v8 = 0;
      do
      {
        if (*(_DWORD *)(v7 + 32) != 1986618469) {
          goto LABEL_8;
        }
        unint64_t Dimensions = (unint64_t)CMVideoFormatDescriptionGetDimensions(*(CMVideoFormatDescriptionRef *)(v7 + 40));
        unint64_t v10 = HIDWORD(Dimensions);
        if (SHIDWORD(Dimensions) >= (int)Dimensions) {
          LODWORD(v10) = Dimensions;
        }
        uint64_t v11 = v7;
        if ((int)v10 <= 1440) {
LABEL_8:
        }
          uint64_t v11 = v8;
        uint64_t v7 = *(void *)(v7 + 8);
        uint64_t v8 = v11;
      }
      while (v7);
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v12 = *(void *)(CMBaseObjectGetDerivedStorage() + 1048);
    if (v12)
    {
      uint64_t v13 = 0;
      do
      {
        if (*(_DWORD *)(v12 + 32) != 1986618469
          || (VideoDynamicRange = CMVideoFormatDescriptionGetVideoDynamicRange(), uint64_t v15 = v12, VideoDynamicRange <= 1))
        {
          uint64_t v15 = v13;
        }
        uint64_t v12 = *(void *)(v12 + 8);
        uint64_t v13 = v15;
      }
      while (v12);
    }
    else
    {
      uint64_t v15 = 0;
    }
    if (v15 == a1)
    {
      fpfs_ReleasePlayerHDRPlaybackBaton();
      if (!v11)
      {
LABEL_25:
        fpfs_ReleasePlayer4kPlaybackBaton(v5);
        goto LABEL_26;
      }
    }
    else if (!v11)
    {
      goto LABEL_25;
    }
    if (v11 != a1) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
LABEL_26:
  if (*(_DWORD *)(a1 + 32) == 1936684398)
  {
    cf.unsigned int value = 0;
    if (*(unsigned char *)(CMBaseObjectGetDerivedStorage() + 561)) {
      fpfs_UnmuteNextAtmosAudioTrack((const AudioFormatListItem *)v6, DerivedStorage, a1);
    }
    uint64_t v102 = v5;
    uint64_t v16 = *(void *)(a1 + 96);
    if (v16)
    {
      uint64_t v17 = *(void *)(v16 + 32);
      uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
      uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v17);
      uint64_t v20 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v20) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v28 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CMTime *))(v21 + 48);
      if (v28)
      {
        uint64_t v29 = v28(FigBaseObject, @"IsTimebaseStarter", AllocatorForMedia, &cf);
        if (!v29)
        {
          BOOL v27 = cf.value == *MEMORY[0x1E4F1CFD0];
          if (cf.value) {
            CFRelease((CFTypeRef)cf.value);
          }
LABEL_53:
          uint64_t v22 = *(void *)(DerivedStorage + 1048);
          if (!v22) {
            goto LABEL_69;
          }
          uint64_t v23 = *(void *)(DerivedStorage + 1048);
          while (v23 == a1 || *(_DWORD *)(v23 + 32) != 1936684398)
          {
            uint64_t v23 = *(void *)(v23 + 8);
            if (!v23) {
              goto LABEL_69;
            }
          }
          if (*(_DWORD *)(v23 + 152) == 6 && (uint64_t v32 = *(void *)(v23 + 96)) != 0 && v32 != *(void *)(a1 + 96))
          {
            if (v27) {
              uint64_t v26 = v23;
            }
            else {
              uint64_t v26 = 0;
            }
            if (!*(unsigned char *)(v32 + 25))
            {
LABEL_212:
              while (1)
              {
                if (v22 != v23 && v22 != a1 && *(_DWORD *)(v22 + 152) == 6)
                {
                  if (*(void *)(v22 + 112))
                  {
                    CMTime time = *(CMTime *)(v22 + 216);
                    CMTime time2 = *(CMTime *)(v23 + 192);
                    if (CMTimeCompare(&time, &time2) < 1) {
                      break;
                    }
                  }
                }
                uint64_t v22 = *(void *)(v22 + 8);
                if (!v22)
                {
                  CMTimebaseSetRate(*(CMTimebaseRef *)(DerivedStorage + 576), 0.0);
                  FigCFArrayApplyFunction();
                  char v98 = 0;
                  uint64_t v96 = v23;
                  goto LABEL_71;
                }
              }
            }
          }
          else
          {
LABEL_69:
            uint64_t v26 = 0;
          }
          uint64_t v96 = 0;
          char v98 = 1;
LABEL_71:
          int v5 = v102;
          goto LABEL_72;
        }
        uint64_t v30 = v29;
      }
      else
      {
        uint64_t v30 = 4294954514;
      }
      LODWORD(v106.CFDictionarySetValue(theDict, key, value) = 0;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      goto LABEL_183;
    }
    BOOL v27 = 0;
    goto LABEL_53;
  }
  uint64_t v22 = *(void *)(DerivedStorage + 1048);
  if (v22)
  {
    uint64_t v23 = 0;
    uint64_t v24 = 0x7FFFFFFFLL;
    uint64_t v25 = *(void *)(DerivedStorage + 1048);
    do
    {
      if (v25 != a1 && *(_DWORD *)(v25 + 152) == 6 && *(void *)(v25 + 64) < v24)
      {
        uint64_t v24 = *(void *)(v25 + 64);
        uint64_t v23 = v25;
      }
      uint64_t v25 = *(void *)(v25 + 8);
    }
    while (v25);
    while (v23)
    {
      if (v23 != a1
        && *(void *)(v23 + 64) == v24
        && *(_DWORD *)(v23 + 32) == 1936684398
        && *(_DWORD *)(v23 + 152) == 6)
      {
        uint64_t v84 = *(void *)(v23 + 96);
        if (!v84) {
          break;
        }
        uint64_t v26 = 0;
        if (!*(unsigned char *)(v84 + 25))
        {
          uint64_t v102 = v5;
          goto LABEL_212;
        }
        char v98 = 1;
        uint64_t v96 = 0;
        goto LABEL_72;
      }
      uint64_t v23 = *(void *)(v23 + 8);
    }
  }
  uint64_t v96 = 0;
  uint64_t v26 = 0;
  char v98 = 1;
LABEL_72:
  uint64_t v103 = v26;
  if (dword_1E9350BB0)
  {
    LODWORD(cf.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(v106.CFDictionarySetValue(theDict, key, value) = 0;
    uint64_t v33 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int value = cf.value;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v35 = value;
    }
    else {
      unsigned int v35 = value & 0xFFFFFFFE;
    }
    if (v35)
    {
      if (v5) {
        CFNumberRef v36 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      }
      else {
        CFNumberRef v36 = "";
      }
      uint64_t v93 = v36;
      uint64_t v94 = v6;
      CFNumberRef v37 = v5;
      uint64_t v38 = "";
      if (v3) {
        CFIndex v39 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
      }
      else {
        CFIndex v39 = "";
      }
      CFStringRef v40 = v3;
      uint64_t v41 = *(void *)(a1 + 16);
      CMTime time = v110;
      Float64 Seconds = CMTimeGetSeconds(&time);
      if (*(_DWORD *)(a1 + 32) == 1936684398) {
        uint64_t v38 = "(audio)";
      }
      CMTime time = *(CMTime *)(a1 + 216);
      Float64 v43 = CMTimeGetSeconds(&time);
      LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136317186;
      *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_FinishTrack";
      LOWORD(time2.flags) = 2048;
      *(void *)((char *)&time2.flags + 2) = v37;
      HIWORD(time2.epoch) = 2082;
      CMTime v113 = v93;
      __int16 v114 = 2048;
      CFStringRef v115 = v40;
      __int16 v116 = 2082;
      unsigned int v117 = v39;
      int v5 = v37;
      __int16 v118 = 2048;
      *(void *)uint64_t v119 = v41;
      v119[4] = 2048;
      *(Float64 *)&v119[5] = Seconds;
      v119[9] = 2082;
      uint64_t v120 = v38;
      __int16 v121 = 2048;
      Float64 v122 = v43;
      _os_log_send_and_compose_impl();
      CFStringRef v3 = v40;
      uint64_t v6 = v94;
      uint64_t v26 = v103;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (*(_DWORD *)(a1 + 32) == 1668047728) {
    FPSupport_resetClosedCaptionLayer(v6 + 208);
  }
  CMTime time = v110;
  fpfsi_MoveTrackToPlayedOut(DerivedStorage, a1, (long long *)&time.value);
  if (v26)
  {
    uint64_t v44 = FigRenderPipelineGetFigBaseObject(*(void *)(*(void *)(v26 + 96) + 32));
    uint64_t v45 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v45) {
      uint64_t v46 = v45;
    }
    else {
      uint64_t v46 = 0;
    }
    uint64_t v47 = *(uint64_t (**)(uint64_t, __CFString *, void))(v46 + 56);
    if (v47)
    {
      uint64_t v48 = v47(v44, @"IsTimebaseStarter", *MEMORY[0x1E4F1CFD0]);
      if (!v48) {
        goto LABEL_96;
      }
      uint64_t v30 = v48;
    }
    else
    {
      uint64_t v30 = 4294954514;
    }
    LODWORD(cf.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(v106.CFDictionarySetValue(theDict, key, value) = 0;
    uint64_t v55 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int v56 = cf.value;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v57 = v56;
    }
    else {
      unsigned int v57 = v56 & 0xFFFFFFFE;
    }
    if (!v57)
    {
LABEL_183:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
LABEL_184:
      fpfs_StopPlayingItemWithOSStatus(v6, (uint64_t)v3, v30);
      goto LABEL_185;
    }
    if (v5)
    {
      uint64_t v58 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      if (v3)
      {
LABEL_112:
        uint64_t v59 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
LABEL_115:
        uint64_t v60 = *(void *)(v103 + 16);
        LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316674;
        *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_FinishTrack";
        LOWORD(time2.flags) = 2048;
        *(void *)((char *)&time2.flags + 2) = v5;
        HIWORD(time2.epoch) = 2082;
        CMTime v113 = v58;
        __int16 v114 = 2048;
        CFStringRef v115 = v3;
        __int16 v116 = 2082;
        unsigned int v117 = v59;
        __int16 v118 = 1024;
        *(_DWORD *)uint64_t v119 = v60;
        v119[2] = 1024;
        *(_DWORD *)&v119[3] = v30;
        _os_log_send_and_compose_impl();
        goto LABEL_183;
      }
    }
    else
    {
      uint64_t v58 = "";
      if (v3) {
        goto LABEL_112;
      }
    }
    uint64_t v59 = "";
    goto LABEL_115;
  }
LABEL_96:
  if (v105)
  {
    unsigned int v49 = *(_DWORD *)(DerivedStorage + 848);
    if (!dword_1E9350BB0) {
      goto LABEL_121;
    }
    uint64_t v99 = DerivedStorage;
    LODWORD(cf.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(v106.CFDictionarySetValue(theDict, key, value) = 0;
    uint64_t v50 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int v51 = cf.value;
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v52 = v51;
    }
    else {
      unsigned int v52 = v51 & 0xFFFFFFFE;
    }
    if (!v52)
    {
LABEL_120:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      uint64_t DerivedStorage = v99;
LABEL_121:
      long long v100 = *MEMORY[0x1E4F1F9F8];
      *(_OWORD *)&time.unsigned int value = v100;
      CMTimeEpoch v62 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
      time.CMTimeEpoch epoch = v62;
      *(_OWORD *)&time2.unsigned int value = v100;
      time2.CMTimeEpoch epoch = v62;
      fpfs_setRateInternal(v5, v3, &time, &time2, 0.0);
      time.unsigned int value = v124;
      time.CMTimeScale timescale = v125;
      time.CMTimeFlags flags = v105;
      time.CMTimeEpoch epoch = v101;
      fpfs_JumpToTime(v3, &time, 1);
      *(_OWORD *)&time.unsigned int value = v100;
      time.CMTimeEpoch epoch = v62;
      *(_OWORD *)&time2.unsigned int value = v100;
      time2.CMTimeEpoch epoch = v62;
      fpfs_setRateInternal(v5, v3, &time, &time2, COERCE_DOUBLE(__PAIR64__(DWORD1(v100), v49)));
      if (!fpfsi_isTrackInLists(DerivedStorage, a1, 3u)) {
        uint64_t v111 = 0;
      }
      goto LABEL_123;
    }
    if (v5)
    {
      uint64_t v53 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      if (v3)
      {
LABEL_104:
        uint64_t v54 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
LABEL_119:
        time.unsigned int value = v124;
        time.CMTimeScale timescale = v125;
        time.CMTimeFlags flags = v105;
        time.CMTimeEpoch epoch = v101;
        Float64 v61 = CMTimeGetSeconds(&time);
        LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316418;
        *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_FinishTrack";
        LOWORD(time2.flags) = 2048;
        *(void *)((char *)&time2.flags + 2) = v5;
        HIWORD(time2.epoch) = 2082;
        CMTime v113 = v53;
        __int16 v114 = 2048;
        CFStringRef v115 = v3;
        __int16 v116 = 2082;
        unsigned int v117 = v54;
        __int16 v118 = 2048;
        *(Float64 *)uint64_t v119 = v61;
        _os_log_send_and_compose_impl();
        goto LABEL_120;
      }
    }
    else
    {
      uint64_t v53 = "";
      if (v3) {
        goto LABEL_104;
      }
    }
    uint64_t v54 = "";
    goto LABEL_119;
  }
LABEL_123:
  int v63 = v104;
  if ((v98 & 1) == 0)
  {
    CMTime cf = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
    CMTime v106 = cf;
    if (*(unsigned char *)(v96 + 422)) {
      *(unsigned char *)(v96 + 422) = 0;
    }
    float v72 = *(float *)(DerivedStorage + 848);
    if (*(void *)(DerivedStorage + 568))
    {
      fpfs_getAnchorTimeForSyncTimebase(v72, (uint64_t)v5, (uint64_t)v3, &cf, &v106);
    }
    else if (v72 != 0.0)
    {
      fpfs_getCachedAnchorTimeForItem((uint64_t)v5, (uint64_t)v3, (uint64_t)&cf, (uint64_t)&v106);
    }
    float v76 = *(float *)(DerivedStorage + 848);
    CMTime time = cf;
    CMTime time2 = v106;
    uint64_t v77 = fpfs_SetRateOnTrack(v96, &time, &time2, v76);
    if (v77)
    {
      if (v96 == v103)
      {
        uint64_t v30 = v77;
        double v78 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT);
        goto LABEL_183;
      }
    }
  }
  uint64_t v64 = *(void *)(DerivedStorage + 1048);
  if (!v64) {
    goto LABEL_135;
  }
  while (1)
  {
    uint64_t v65 = v64;
    uint64_t v64 = *(void *)(v64 + 8);
    if (*(_DWORD *)(v65 + 32) != v104) {
      goto LABEL_134;
    }
    int v66 = *(_DWORD *)(v65 + 152);
    if (v66 == 3) {
      break;
    }
LABEL_129:
    if (v66 == 1 && !*(void *)(v65 + 96) && *(_DWORD *)(v65 + 32) == 1986618469)
    {
      if (fpfs_CheckVideoSyncQueue(v65, 0))
      {
        uint64_t v67 = fpfs_FinishVideoSync(v65);
        if (v67)
        {
          uint64_t v30 = v67;
          goto LABEL_184;
        }
      }
    }
LABEL_134:
    if (!v64) {
      goto LABEL_135;
    }
  }
  if (!fpfs_AreTracksReadyToPlay(v3))
  {
    int v66 = *(_DWORD *)(v65 + 152);
    goto LABEL_129;
  }
  fpfs_PerformInitialResolveOfAllWaitingTracks((const __CFArray *)v3);
  if (!fpfs_GetItemLivingTrack(DerivedStorage, v95, &v111)) {
    uint64_t v111 = 0;
  }
LABEL_135:
  if (CFArrayGetCount(*(CFArrayRef *)(v6 + 72)) < 1)
  {
    if (!a2 || (CMTime time = v110, time2 = *(CMTime *)(DerivedStorage + 480), CMTimeCompare(&time, &time2) < 0))
    {
      if (!fpfsi_PlaybackHasTraversedForwardEndTime()) {
        goto LABEL_174;
      }
      if (!dword_1E9350BB0) {
        goto LABEL_195;
      }
      LODWORD(cf.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(v106.CFDictionarySetValue(theDict, key, value) = 0;
      CFNumberRef v79 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v80 = cf.value;
      if (os_log_type_enabled(v79, v106.value)) {
        unsigned int v81 = v80;
      }
      else {
        unsigned int v81 = v80 & 0xFFFFFFFE;
      }
      if (!v81) {
        goto LABEL_194;
      }
      LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136315138;
      *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_FinishTrack";
    }
    else
    {
      if (!dword_1E9350BB0)
      {
LABEL_195:
        fpfs_StopPlayingItem(v6, v3, 0);
        int v85 = 0;
        goto LABEL_201;
      }
      LODWORD(cf.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(v106.CFDictionarySetValue(theDict, key, value) = 0;
      int v73 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v74 = cf.value;
      if (os_log_type_enabled(v73, v106.value)) {
        unsigned int v75 = v74;
      }
      else {
        unsigned int v75 = v74 & 0xFFFFFFFE;
      }
      if (!v75)
      {
LABEL_194:
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        goto LABEL_195;
      }
      LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136315138;
      *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_FinishTrack";
    }
    _os_log_send_and_compose_impl();
    goto LABEL_194;
  }
  CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v6 + 72), 0);
  uint64_t v69 = v111;
  if (!v111) {
    goto LABEL_173;
  }
  uint64_t v70 = ValueAtIndex;
  CMTime cf = v110;
  uint64_t v71 = (CMTime *)CMBaseObjectGetDerivedStorage();
  if (!*(unsigned char *)(v69 + 184))
  {
    if (!a2) {
      goto LABEL_172;
    }
    goto LABEL_168;
  }
  if (a2 && *(_DWORD *)(v69 + 32) == 1986618469)
  {
LABEL_168:
    CMTime time = cf;
    CMTime time2 = v71[20];
    if (CMTimeCompare(&time, &time2) < 0 && !fpfsi_PlaybackHasTraversedForwardEndTime()) {
      goto LABEL_172;
    }
    if (fpfsi_AllTracksForMediaTypeArePlaying((uint64_t)v70, 1936684398)) {
      fpfsi_MakeNextItemReadyForInspectionIfItemEndedOrBeyondFwdEnd(v3);
    }
    else {
      fpfs_TransitionFromItemToItem((uint64_t)v3, v70);
    }
    goto LABEL_195;
  }
LABEL_172:
  int v63 = v104;
LABEL_173:
  fpfsi_MakeNextItemReadyForInspectionIfItemEndedOrBeyondFwdEnd(v3);
LABEL_174:
  fpfs_UpdateDimensions(v3, 0);
  if (*(_DWORD *)(v6 + 808) != 1 && *(float *)(v6 + 108) == 1.0)
  {
    if (v63 == 1936684398)
    {
      uint64_t RenderingNonGapTrackofType = fpfs_FirstRenderingNonGapTrackofType((uint64_t)v3, 1936684398);
      if (RenderingNonGapTrackofType)
      {
        uint64_t v82 = RenderingNonGapTrackofType;
        uint64_t v83 = v111;
        if (!FigCFEqual())
        {
          fpfs_ReportAudioPlaybackThroughFigLog((uint64_t)v3);
          if (FigAlternateIsAudioOnly(*(void *)(v83 + 440)))
          {
LABEL_199:
            fpfsi_copyPlayableTime((uint64_t)v3, &v109);
            CFAllocatorRef v87 = (const __CFAllocator *)FigGetAllocatorForMedia();
            uint64_t v88 = *(const void **)(DerivedStorage + 2536);
            uint64_t v89 = *(const void **)(v82 + 440);
            uint64_t v90 = *(const void **)(v83 + 440);
            CMTime time = v110;
            FigMetricItemVariantChangeEventCreate(v87, (long long *)&time.value, 0, v88, v89, v90, v109, 1, &v108);
            FigMetricEventTimelinePublishEvent(*(void *)(DerivedStorage + 3376), (uint64_t)v3, (uint64_t)v108);
          }
        }
      }
    }
    else if (v63 == 1986618469)
    {
      uint64_t v82 = fpfs_FirstRenderingNonGapTrackofType((uint64_t)v3, 1986618469);
      fpfsi_scheduleFVTTransitionsForItem(v3, 2, 1);
      if (v82)
      {
        uint64_t v83 = v111;
        if (!FigCFEqual())
        {
          fpfs_ReportVideoPlaybackTimeThroughFigLog((uint64_t)v3);
          goto LABEL_199;
        }
      }
    }
  }
  fpfsi_SetupSkipBitrateRangeFilter((uint64_t)v3);
  int v85 = 1;
LABEL_201:
  fpfs_PostHasEnabledTrackTypeNotification(v5, v3);
  if (v85)
  {
    if (v111)
    {
      if (!*(unsigned char *)(v111 + 184))
      {
        int v91 = *(unsigned __int8 *)(v111 + 180);
        if (((*(_DWORD *)(DerivedStorage + 1096) >> v91) & 1) != 0 && !*(unsigned char *)(DerivedStorage + 470))
        {
          uint64_t v92 = *(void *)(DerivedStorage + 1048);
          if (v92)
          {
            while (v92 == v111 || *(unsigned __int8 *)(v92 + 180) != v91)
            {
              uint64_t v92 = *(void *)(v92 + 8);
              if (!v92) {
                goto LABEL_210;
              }
            }
          }
          else
          {
LABEL_210:
            fpfs_StopPlaybackByStalledTrack(v111, 3u);
          }
        }
      }
    }
  }
LABEL_185:
  if (v108) {
    CFRelease(v108);
  }
  if (v109) {
    CFRelease(v109);
  }
}

double fpfs_setUnlikelyToKeepUpAndRanDry(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  fpfs_setPlaythroughPredictionAndNotify(a1, 2);
  fpfsi_setPlaybackMonitorOkayToAttemptSwitchUp(DerivedStorage, 0);

  return fpfs_setRanDry(a1);
}

uint64_t fpfs_StopPlaybackByStalledTrack(uint64_t a1, unsigned int a2)
{
  uint64_t v172 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(const void **)a1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = *(const void **)DerivedStorage;
  uint64_t v7 = CMBaseObjectGetDerivedStorage();
  CFTypeRef cf = 0;
  uint64_t v8 = *(__CFError **)(DerivedStorage + 504);
  if (v8)
  {
    if (FigCFErrorIsEqualToOSStatus(v8, @"CoreMediaErrorDomain", -12465))
    {
      uint64_t v12 = 4294954433;
    }
    else
    {
      uint64_t v9 = CMBaseObjectGetDerivedStorage();
      memset(&v135, 0, sizeof(v135));
      memset(&valuePtr, 0, sizeof(valuePtr));
      fpfs_GetItemBufferedDuration(v4, &v135, 0, 0);
      if (!*(void *)(v9 + 504)) {
        goto LABEL_6;
      }
      CMTime time1 = v135;
      *(_OWORD *)&time2.unsigned int value = kGaplessTransitionDeadlineInterval;
      time2.CMTimeEpoch epoch = 0;
      if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      fpfs_GetTime(v9, (uint64_t)&lhs);
      *(_OWORD *)&time1.unsigned int value = kGaplessTransitionDeadlineInterval;
      time1.CMTimeEpoch epoch = 0;
      CMTimeAdd(&valuePtr, &lhs, &time1);
      BOOL v10 = *(void *)(v9 + 2968) != 0;
      CMTime time1 = valuePtr;
      CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA08];
      long long v130 = *MEMORY[0x1E4F1FA10];
      uint64_t v131 = *(void *)(MEMORY[0x1E4F1FA10] + 16);
      HIWORD(v113) = 257;
      BYTE1(v113) = v10;
      LOBYTE(v113) = 1;
      uint64_t v11 = fpfsi_SetCurrentTimeWithRangeAndSeekIDGuts(v4, &time1, 0, &time2, &v130, 0, 0, 0, v113, 0, 0);
      if (!v11) {
        goto LABEL_6;
      }
      uint64_t v12 = v11;
    }
    fpfs_StopPlayingItem(v7, v4, *(void *)(DerivedStorage + 504));
    goto LABEL_11;
  }
LABEL_6:
  if (*(unsigned char *)(v7 + 160)) {
    fpfs_SetRateWithFadeInternal(v6, MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], MEMORY[0x1E4F1F9F8], 0.0);
  }
  else {
    fpfs_stopPlaybackForInternalReason(v6, 4);
  }
  if (!*(unsigned char *)(a1 + 184))
  {
    ++*(void *)(DerivedStorage + 2096);
    *(unsigned char *)(DerivedStorage + 464) = 0;
    *(CFAbsoluteTime *)(DerivedStorage + 2016) = CFAbsoluteTimeGetCurrent();
    fpfs_setUnlikelyToKeepUpAndRanDry(v4);
    fpfs_EnqueueNotification(v6, @"PlaybackStalled", v4, 0);
    uint64_t v14 = CMBaseObjectGetDerivedStorage();
    v135.unsigned int value = 0;
    unsigned int value = @"unknown";
    valuePtr.unsigned int value = 0x1EE55C518;
    uint64_t v16 = *(void *)(v14 + 936);
    if (v16)
    {
      uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
      uint64_t FigBaseObject = FigBytePumpGetFigBaseObject(v16);
      uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v20 = v19 ? v19 : 0;
      uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t, CMTime *))(v20 + 48);
      if (v21)
      {
        v21(FigBaseObject, 0x1EE53E718, AllocatorForMedia, &v135);
        if (v135.value)
        {
          CFTypeID v22 = CFGetTypeID((CFTypeRef)v135.value);
          if (v22 == CFDictionaryGetTypeID())
          {
            CFDictionaryGetValueIfPresent((CFDictionaryRef)v135.value, @"cs-iftype", (const void **)&valuePtr);
            unsigned int value = (const void *)valuePtr.value;
          }
        }
      }
    }
    FPSupport_ReportStallToSymptomLog(0, value, *(const __CFDictionary **)(v14 + 400));
    if (v135.value) {
      CFRelease((CFTypeRef)v135.value);
    }
    uint64_t v23 = CMBaseObjectGetDerivedStorage();
    uint64_t v24 = *(void *)(v23 + 2544);
    if (v24)
    {
      uint64_t v25 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v25) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = 0;
      }
      BOOL v27 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v26 + 56);
      if (v27) {
        v27(v24, 0x1EE582B78, 0x1EE5851B8, a2, 0);
      }
      uint64_t v28 = *(void *)(v23 + 2544);
      if (v28)
      {
        uint64_t v29 = *(unsigned __int8 *)(a1 + 180);
        uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v31 = v30 ? v30 : 0;
        uint64_t v32 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v31 + 56);
        if (v32) {
          v32(v28, 0x1EE582B78, 0x1EE585198, v29, 0);
        }
      }
      uint64_t v33 = *(void *)(v23 + 2544);
      if (v33)
      {
        uint64_t v34 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v35 = v34 ? v34 : 0;
        CFNumberRef v36 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v35 + 32);
        if (v36) {
          v36(v33, 0x1EE582B78, 0x1EE583738, 1);
        }
      }
    }
    uint64_t v126 = v7;
    unsigned int v125 = a2;
    uint64_t v128 = a1;
    uint64_t v37 = CMBaseObjectGetDerivedStorage();
    v135.unsigned int value = 0;
    fpfsi_RTCReportingUpdateItemStats((uint64_t)v4);
    uint64_t v127 = v4;
    fpfsi_RTCReportingUpdateCurrentAlternateInfo();
    uint64_t v38 = 0;
    CFIndex v39 = &stru_1EE53F4B8;
    do
    {
      if (((1 << v38) & 4) != 0) {
        uint64_t v40 = 0x1EE5852F8;
      }
      else {
        uint64_t v40 = (uint64_t)v39;
      }
      if (((1 << v38) & 2) != 0) {
        uint64_t v41 = 0x1EE5852D8;
      }
      else {
        uint64_t v41 = v40;
      }
      if (v38) {
        CFIndex v39 = (__CFString *)v41;
      }
      else {
        CFIndex v39 = @"TimeSinceVideoSubStream";
      }
      uint64_t v42 = *(void *)(v37 + 2544);
      double Current = CFAbsoluteTimeGetCurrent();
      if (v42)
      {
        double v44 = Current;
        double v45 = *(double *)(v37 + 3000 + 8 * v38);
        uint64_t v46 = *(void *)(CMBaseObjectGetVTable() + 16);
        uint64_t v47 = v46 ? v46 : 0;
        uint64_t v48 = *(void (**)(uint64_t, uint64_t, __CFString *, uint64_t, void))(v47 + 56);
        if (v48) {
          v48(v42, 0x1EE582B78, v39, (uint64_t)((v44 - v45) * 1000.0), 0);
        }
      }
      ++v38;
    }
    while (v38 != 3);
    uint64_t v49 = *(void *)(v37 + 936);
    uint64_t v50 = v4;
    if (v49)
    {
      LODWORD(valuePtr.CFDictionarySetValue(theDict, key, value) = 0;
      uint64_t v51 = FigGetAllocatorForMedia();
      uint64_t v52 = FigBytePumpGetFigBaseObject(v49);
      uint64_t v53 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v53) {
        uint64_t v54 = v53;
      }
      else {
        uint64_t v54 = 0;
      }
      uint64_t v55 = *(void (**)(uint64_t, uint64_t, uint64_t, CMTime *))(v54 + 48);
      if (v55) {
        v55(v52, 0x1EE53E1D8, v51, &v135);
      }
      if (v135.value)
      {
        CFNumberGetValue((CFNumberRef)v135.value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v56 = *(void *)(v37 + 2544);
        if (v56)
        {
          uint64_t value_low = SLODWORD(valuePtr.value);
          uint64_t v58 = *(void *)(CMBaseObjectGetVTable() + 16);
          uint64_t v59 = v58 ? v58 : 0;
          uint64_t v60 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v59 + 40);
          if (v60) {
            v60(v56, 0x1EE582B98, 0x1EE582E58, value_low);
          }
        }
      }
    }
    if (v135.value) {
      CFRelease((CFTypeRef)v135.value);
    }
    uint64_t v61 = *(void *)(v23 + 2544);
    uint64_t v62 = v128;
    BOOL v63 = *(_DWORD *)(v128 + 152) == 1;
    if (v61)
    {
      uint64_t v64 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v65 = v64 ? v64 : 0;
      int v66 = *(void (**)(uint64_t, uint64_t, uint64_t, BOOL, void))(v65 + 56);
      if (v66) {
        v66(v61, 0x1EE582B78, 0x1EE561578, v63, 0);
      }
    }
    uint64_t v67 = *(void *)(v23 + 1048);
    if (v67)
    {
      AudioChannelCFArrayRef Count = 0;
      do
      {
        if (*(void *)(v67 + 64) == *(void *)(v128 + 64)
          && *(_DWORD *)(v67 + 152) == 6
          && *(_DWORD *)(v67 + 32) == 1936684398
          && AudioChannelCount <= (int)fpfs_GetAudioChannelCount(*(const opaqueCMFormatDescription **)(v67 + 40)))
        {
          AudioChannelCFArrayRef Count = (int)fpfs_GetAudioChannelCount(*(const opaqueCMFormatDescription **)(v67 + 40));
        }
        uint64_t v67 = *(void *)(v67 + 8);
      }
      while (v67);
    }
    else
    {
      AudioChannelCFArrayRef Count = 0;
    }
    uint64_t v69 = *(void *)(v23 + 2544);
    if (v69)
    {
      uint64_t v70 = *(void *)(CMBaseObjectGetVTable() + 16);
      uint64_t v71 = DerivedStorage;
      if (v70) {
        uint64_t v72 = v70;
      }
      else {
        uint64_t v72 = 0;
      }
      int v73 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v72 + 56);
      if (v73) {
        v73(v69, 0x1EE582B78, 0x1EE583978, AudioChannelCount, 0);
      }
      uint64_t v74 = *(void *)(v23 + 2544);
      if (v74)
      {
        uint64_t v75 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v75) {
          uint64_t v76 = v75;
        }
        else {
          uint64_t v76 = 0;
        }
        uint64_t v77 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void))(v76 + 8);
        if (v77) {
          int v78 = v77(v74, 0x1EE582B78, 103, 0, 0);
        }
        else {
          int v78 = -12782;
        }
      }
      else
      {
        int v78 = -12000;
      }
    }
    else
    {
      int v78 = -12000;
      uint64_t v71 = DerivedStorage;
    }
    if (dword_1E9350BB0)
    {
      LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(lhs.CFDictionarySetValue(theDict, key, value) = 0;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v80 = time2.value;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, lhs.value)) {
        unsigned int v81 = v80;
      }
      else {
        unsigned int v81 = v80 & 0xFFFFFFFE;
      }
      if (v81)
      {
        uint64_t v82 = *(void *)v23;
        if (*(void *)v23) {
          uint64_t v83 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          uint64_t v83 = "";
        }
        uint64_t v123 = v83;
        int v124 = v78;
        if (v127)
        {
          uint64_t v84 = v50;
          int v85 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else
        {
          uint64_t v84 = 0;
          int v85 = "";
        }
        Float64 v122 = v85;
        if (*(_DWORD *)(v23 + 332)) {
          uint64_t v86 = "Yes";
        }
        else {
          uint64_t v86 = "No";
        }
        __int16 v121 = v86;
        fpfs_GetTime(v23, (uint64_t)&time1);
        Float64 Seconds = CMTimeGetSeconds(&time1);
        CMTime v135 = *(CMTime *)(v23 + 320);
        Float64 v88 = CMTimeGetSeconds(&v135);
        if (*(_DWORD *)(v128 + 152) == 1) {
          uint64_t v89 = "Yes";
        }
        else {
          uint64_t v89 = "No";
        }
        uint64_t v119 = v89;
        int v120 = *(_DWORD *)(v23 + 1752);
        if (FigAlternateIsAudioOnly(*(void *)(v23 + 1704))) {
          uint64_t v90 = "Yes";
        }
        else {
          uint64_t v90 = "No";
        }
        __int16 v114 = v90;
        int v115 = *(_DWORD *)(v23 + 2800);
        int v116 = *(_DWORD *)(v23 + 2804);
        int v117 = *(_DWORD *)(v23 + 2812);
        int v118 = *(_DWORD *)(v23 + 2844);
        if (*(void *)(v23 + 2664)) {
          uint64_t v91 = FigGetUpTimeNanoseconds() - *(void *)(v23 + 2664);
        }
        else {
          uint64_t v91 = 0;
        }
        uint64_t v71 = DerivedStorage;
        Float64 v92 = -1.0;
        uint64_t v50 = v84;
        if (*(void *)(v23 + 1632))
        {
          CMTime v135 = *(CMTime *)(v23 + 1640);
          Float64 v93 = CMTimeGetSeconds(&v135);
          int v94 = v124;
          if (*(void *)(v23 + 1632))
          {
            CMTime v135 = *(CMTime *)(v23 + 1664);
            Float64 v92 = CMTimeGetSeconds(&v135);
          }
        }
        else
        {
          Float64 v93 = -1.0;
          int v94 = v124;
        }
        LODWORD(v135.CFDictionarySetValue(theDict, key, value) = 136320002;
        *(CMTimeValue *)((char *)&v135.value + 4) = (CMTimeValue)"fpfsi_RTCReportingReportStall";
        LOWORD(v135.flags) = 2048;
        *(void *)((char *)&v135.flags + 2) = v82;
        HIWORD(v135.epoch) = 2082;
        int v136 = v123;
        __int16 v137 = 2048;
        uint64_t v138 = v50;
        __int16 v139 = 2082;
        BOOL v140 = v122;
        __int16 v141 = 1024;
        int v142 = v94;
        __int16 v143 = 1024;
        unsigned int v144 = v125;
        __int16 v145 = 2080;
        uint64_t v146 = v121;
        __int16 v147 = 2048;
        Float64 v148 = Seconds;
        __int16 v149 = 2048;
        Float64 v150 = v88;
        __int16 v151 = 2080;
        unsigned int v152 = v119;
        __int16 v153 = 1024;
        int v154 = v120;
        __int16 v155 = 2080;
        unsigned int v156 = v114;
        __int16 v157 = 1024;
        int v158 = v115;
        __int16 v159 = 1024;
        int v160 = v116;
        __int16 v161 = 1024;
        int v162 = v117;
        __int16 v163 = 1024;
        int v164 = v118;
        __int16 v165 = 2048;
        uint64_t v166 = v91;
        __int16 v167 = 2048;
        Float64 v168 = v93;
        __int16 v169 = 2048;
        Float64 v170 = v92;
        _os_log_send_and_compose_impl();
        uint64_t v62 = v128;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    uint64_t v95 = *(void *)(v71 + 936);
    if (v95)
    {
      v135.unsigned int value = 0;
      uint64_t v96 = FigGetAllocatorForMedia();
      uint64_t v97 = FigBytePumpGetFigBaseObject(v95);
      uint64_t v98 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v99 = v98 ? v98 : 0;
      long long v100 = *(void (**)(uint64_t, uint64_t, uint64_t, CMTime *))(v99 + 48);
      if (v100)
      {
        v100(v97, 0x1EE53EC18, v96, &v135);
        if (v135.value)
        {
          fpfs_GetOptionsDictionaryForSelectedMediaType(v71);
          uint64_t v101 = FigCFDictionaryGetValue();
          int v102 = *(_DWORD *)(v62 + 32);
          switch(v102)
          {
            case 1935832172:
              unsigned int v103 = 6;
              break;
            case 1936684398:
              unsigned int v103 = 2;
              break;
            case 1986618469:
              unsigned int v103 = v101 ? 3 : 4;
              break;
            default:
              unsigned int v103 = 0;
              break;
          }
          FigCMCDHeaderVendorSetBufferDidStarve(v135.value, v103);
          if (v135.value)
          {
            CFRelease((CFTypeRef)v135.value);
            v135.unsigned int value = 0;
          }
        }
      }
    }
    CFAllocatorRef v104 = (const __CFAllocator *)FigGetAllocatorForMedia();
    CMTimeFlags v105 = *(const void **)(v71 + 1704);
    double v106 = *(float *)(v71 + 848);
    double v107 = *(float *)(v126 + 108);
    CMTime v135 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
    FigMetricItemStallEventCreate(v104, (long long *)&v135.value, 0, 0, v105, &cf, v106, v107);
    uint64_t v108 = *(void *)(v71 + 3376);
    CFTypeRef v109 = cf;
    uint64_t v110 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v110) {
      uint64_t v111 = v110;
    }
    else {
      uint64_t v111 = 0;
    }
    CFIndex v112 = *(void (**)(uint64_t, const void *, CFTypeRef))(v111 + 40);
    if (v112) {
      v112(v108, v50, v109);
    }
  }
  uint64_t v12 = 0;
LABEL_11:
  if (cf) {
    CFRelease(cf);
  }
  return v12;
}

void fpfs_AbandonSyncAttempt(uint64_t a1)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  CFArrayRef v2 = *(const __CFArray **)a1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  memset(&v68, 0, sizeof(v68));
  memset(&v69, 0, sizeof(v69));
  memset(&v67, 0, sizeof(v67));
  fpfs_GetTime(DerivedStorage, (uint64_t)&v67);
  CMTime v66 = v67;
  unsigned int v4 = *(_DWORD *)(DerivedStorage + 848);
  char v65 = 0;
  if (*(void *)(DerivedStorage + 1704) && fpfsi_TrialSwitchDownInProgress(DerivedStorage)) {
    fpfs_CompleteTrialSwitch(*(const __CFArray **)a1, a1, &v65);
  }
  int v5 = *(_DWORD *)(a1 + 32);
  if (v5 != 1986618469)
  {
    *(unsigned char *)(a1 + 185) = 1;
    if (!*(unsigned char *)(a1 + 184))
    {
      if (v5 == 1936684398)
      {
        fpfs_EnsureRenderChainForTrack(*(void *)DerivedStorage, a1, 1);
        if (*(void *)(a1 + 96))
        {
          if (fpfs_FirstRenderingTrackofType((uint64_t)v2, 1936684398) == a1)
          {
            if (dword_1E9350BB0)
            {
              LODWORD(v64.CFDictionarySetValue(theDict, key, value) = 0;
              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
            uint64_t v38 = fpfs_SetTimebaseOnTrack((uint64_t)v2, a1);
            if (v38) {
              goto LABEL_149;
            }
            uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(*(void *)(*(void *)(a1 + 96) + 32));
            uint64_t v55 = *(void *)(CMBaseObjectGetVTable() + 8);
            if (v55) {
              uint64_t v56 = v55;
            }
            else {
              uint64_t v56 = 0;
            }
            unsigned int v57 = *(uint64_t (**)(uint64_t, __CFString *, void))(v56 + 56);
            if (!v57)
            {
              uint64_t v10 = 4294954514;
              goto LABEL_96;
            }
            uint64_t v38 = v57(FigBaseObject, @"IsTimebaseStarter", *MEMORY[0x1E4F1CFD0]);
            if (v38)
            {
LABEL_149:
              uint64_t v10 = v38;
              goto LABEL_96;
            }
          }
        }
      }
      goto LABEL_14;
    }
LABEL_10:
    CMTime time = v67;
    CMTime time2 = v67;
    CMTime v64 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
    fpfs_StartTrackPlaying(DerivedStorage, a1, &time, &time2, &v64);
    return;
  }
  if (!*(unsigned char *)(a1 + 183)) {
    *(unsigned char *)(a1 + 185) = 1;
  }
  if (*(unsigned char *)(a1 + 184)) {
    goto LABEL_10;
  }
LABEL_14:
  uint64_t v6 = &PerformOneTimeAssetTableInitialization_sAssetTableInit;
  if (dword_1E9350BB0)
  {
    LODWORD(v64.CFDictionarySetValue(theDict, key, value) = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    uint64_t v7 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  float v8 = *(float *)(DerivedStorage + 848);
  if (v8 == 0.0 || v65 != 0)
  {
    if (v8 != 0.0) {
      goto LABEL_21;
    }
    LODWORD(v10) = 0;
LABEL_55:
    if ((*(unsigned char *)(a1 + 140) & 1) == 0)
    {
      uint64_t v25 = *(void *)(DerivedStorage + 1048);
      if (v25)
      {
        while (*(void *)(v25 + 64) != *(void *)(a1 + 64)
             || *(unsigned char *)(v25 + 456)
             || (*(_DWORD *)(v25 + 140) & 0x1D) != 1)
        {
          uint64_t v25 = *(void *)(v25 + 8);
          if (!v25) {
            goto LABEL_61;
          }
        }
        *(_OWORD *)&time.unsigned int value = *(_OWORD *)(v25 + 128);
        CMTimeEpoch v26 = *(void *)(v25 + 144);
      }
      else
      {
LABEL_61:
        *(_OWORD *)&time.unsigned int value = *MEMORY[0x1E4F1F9F8];
        CMTimeEpoch v26 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
      }
      time.CMTimeEpoch epoch = v26;
      *(_OWORD *)(a1 + 128) = *(_OWORD *)&time.value;
      *(void *)(a1 + 144) = v26;
    }
    fpfs_GetTime(DerivedStorage, (uint64_t)&time);
    CMTime v67 = time;
    CMTime time = v66;
    CMTime time2 = v67;
    if (CMTimeCompare(&time, &time2) >= 1)
    {
      CMTime time = v66;
      fpfs_JumpToTime(v2, &time, 0);
      CMTime v67 = v66;
    }
    if (!v10)
    {
      if (*(_DWORD *)(DerivedStorage + 2792) > *(_DWORD *)(DerivedStorage + 2796))
      {
        *(unsigned char *)(DerivedStorage + 2296) = 1;
        int v33 = *(_DWORD *)(a1 + 32);
        if (v33 == 1986618469)
        {
          *(unsigned char *)(DerivedStorage + 2825) = 1;
        }
        else if (v33 == 1936684398)
        {
          *(unsigned char *)(DerivedStorage + 2824) = 1;
        }
        uint64_t v41 = *(void *)(DerivedStorage + 1048);
        if (v41)
        {
          uint64_t v42 = *(void *)(a1 + 64);
          do
          {
            if (v42 == *(void *)(v41 + 64) && *(_DWORD *)(v41 + 152) == 1)
            {
              int v43 = *(_DWORD *)(v41 + 32);
              if (v43 == 1936684398)
              {
                *(unsigned char *)(DerivedStorage + 2824) = 1;
              }
              else if (v43 == 1986618469)
              {
                *(unsigned char *)(DerivedStorage + 2825) = 1;
              }
            }
            uint64_t v41 = *(void *)(v41 + 8);
          }
          while (v41);
        }
        fpfsi_RTCReportingReportVariantSwitchComplete((uint64_t)v2, 1u);
      }
      uint64_t v44 = *(void *)(DerivedStorage + 1048);
      if (v44)
      {
        uint64_t v45 = *(void *)(DerivedStorage + 1048);
        do
        {
          if (*(_DWORD *)(v45 + 152) == 6 && *(void *)(v45 + 64) == *(void *)(a1 + 64) && !*(unsigned char *)(v45 + 184))
          {
            CMTime time = v67;
            CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA10];
            unsigned int started = fpfs_StartTrackPlaying(DerivedStorage, a1, &time, MEMORY[0x1E4F1FA08], &time2);
            if (started == -16042) {
              uint64_t v10 = 0;
            }
            else {
              uint64_t v10 = started;
            }
            goto LABEL_95;
          }
          uint64_t v45 = *(void *)(v45 + 8);
        }
        while (v45);
        do
        {
          if (!*(void *)(DerivedStorage + 1048)) {
            goto LABEL_94;
          }
          uint64_t v46 = v44;
          uint64_t v44 = *(void *)(v44 + 8);
          if (*(unsigned __int8 *)(v46 + 180) == *(unsigned __int8 *)(a1 + 180)
            && *(void *)(v46 + 64) <= *(void *)(a1 + 64)
            && *(void *)(v46 + 48) != *(void *)(a1 + 48))
          {
            fpfs_DeleteTrack(v2, v46);
          }
        }
        while (v44);
        uint64_t v47 = *(void *)(DerivedStorage + 1048);
        if (v47)
        {
          while (2)
          {
            uint64_t v48 = *(void *)(v47 + 8);
            if (*(void *)(v47 + 48) == *(void *)(a1 + 48) && *(_DWORD *)(v47 + 152) != 6)
            {
              int v49 = *(_DWORD *)(v47 + 32);
              if (v49 == 1986618469)
              {
                uint64_t v50 = *(void *)(v47 + 264);
                if (v50)
                {
                  fpfs_ReleaseAndClearDispatchSource((dispatch_object_t *)(v47 + 264));
                  uint64_t v50 = 0;
                }
LABEL_131:
                uint64_t v51 = *(void *)(DerivedStorage + 8 * v50 + 792);
                if (v51) {
                  fpfs_FlushPrimaryAndAuxRenderChains(v51, 1);
                }
              }
              else if (v49 == 1936684398)
              {
                CMTime time = v67;
                fpfs_TrimAudioTrack(v47, &time);
                uint64_t v50 = 1;
                goto LABEL_131;
              }
              fpfs_GetTime(DerivedStorage, (uint64_t)&time);
              *(CMTime *)(v47 + 192) = time;
              fpfs_ChangeTrackState(v47, 2u);
            }
            if (!v48) {
              goto LABEL_94;
            }
            uint64_t v10 = 0;
            uint64_t v47 = v48;
            if (!*(void *)(DerivedStorage + 1048)) {
              goto LABEL_95;
            }
            continue;
          }
        }
      }
      goto LABEL_94;
    }
    if (!*((_DWORD *)v6 + 748))
    {
LABEL_83:
      uint64_t v34 = *(void *)(DerivedStorage + 1048);
      if (v34)
      {
        uint64_t v35 = (CMTime *)MEMORY[0x1E4F1F9F8];
        CFNumberRef v36 = (CMTime *)MEMORY[0x1E4F1FA08];
        while (1)
        {
          uint64_t v37 = *(void *)(v34 + 8);
          if (*(void *)(v34 + 64) == *(void *)(a1 + 64)
            && *(unsigned __int8 *)(v34 + 180) == *(unsigned __int8 *)(a1 + 180))
          {
            if (*(void *)(v34 + 264)) {
              fpfs_ReleaseAndClearDispatchSource((dispatch_object_t *)(v34 + 264));
            }
            if ((*(_DWORD *)(v34 + 152) | 4) == 5)
            {
              CMTime time = v67;
              CMTime time2 = *v35;
              uint64_t v38 = fpfs_StartTrackPlaying(DerivedStorage, v34, &time, v36, &time2);
              if (v38) {
                goto LABEL_149;
              }
            }
          }
          if (v37)
          {
            uint64_t v34 = v37;
            if (*(void *)(DerivedStorage + 1048)) {
              continue;
            }
          }
          break;
        }
      }
      fpfs_CheckPrebufferedLevels(&time, v2, 0, -1, 0);
      uint64_t v39 = *(void *)DerivedStorage;
      CMTime time = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
      CMTime time2 = time;
      fpfs_setRateInternal(v39, v2, &time, &time2, COERCE_DOUBLE(__PAIR64__(HIDWORD(time.value), v4)));
LABEL_94:
      uint64_t v10 = 0;
LABEL_95:
      CMBaseObjectGetDerivedStorage();
      fpfs_FlowControlPump(DerivedStorage, 0, 1, 255);
      if (v10) {
        goto LABEL_96;
      }
      return;
    }
    LODWORD(v64.CFDictionarySetValue(theDict, key, value) = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    BOOL v27 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int value = v64.value;
    if (os_log_type_enabled(v27, type)) {
      unsigned int v29 = value;
    }
    else {
      unsigned int v29 = value & 0xFFFFFFFE;
    }
    if (!v29)
    {
LABEL_82:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      goto LABEL_83;
    }
    uint64_t v30 = *(void *)DerivedStorage;
    if (*(void *)DerivedStorage)
    {
      uint64_t v31 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      if (v2)
      {
LABEL_73:
        uint64_t v32 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
LABEL_81:
        LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316162;
        *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_AbandonSyncAttempt";
        LOWORD(time2.flags) = 2048;
        *(void *)((char *)&time2.flags + 2) = v30;
        HIWORD(time2.epoch) = 2082;
        uint64_t v71 = v31;
        __int16 v72 = 2048;
        CFArrayRef v73 = v2;
        __int16 v74 = 2082;
        uint64_t v75 = v32;
        _os_log_send_and_compose_impl();
        goto LABEL_82;
      }
    }
    else
    {
      uint64_t v31 = "";
      if (v2) {
        goto LABEL_73;
      }
    }
    uint64_t v32 = "";
    goto LABEL_81;
  }
  uint64_t v11 = *(void *)(DerivedStorage + 1048);
  if (!v11) {
    goto LABEL_53;
  }
  LODWORD(v10) = 1;
  do
  {
    if (*(void *)(v11 + 64) == *(void *)(a1 + 64)
      && *(unsigned __int8 *)(v11 + 180) == *(unsigned __int8 *)(a1 + 180)
      && (*(_DWORD *)(v11 + 152) | 4) == 5)
    {
      uint64_t RenderingTrackofType = fpfs_FirstRenderingTrackofType((uint64_t)v2, *(_DWORD *)(v11 + 32));
      if (!RenderingTrackofType
        || *(void *)(RenderingTrackofType + 16) >= *(void *)(v11 + 16)
        || *(_DWORD *)(RenderingTrackofType + 152) != 6)
      {
        Head = (opaqueCMSampleBuffer *)CMBufferQueueGetHead(*(CMBufferQueueRef *)(v11 + 72));
        if (!Head) {
          goto LABEL_49;
        }
        CMSampleBufferGetOutputPresentationTimeStamp(&v69, Head);
        CMTime time = v69;
        fpfs_GetTrackStartupQueueDuration(v11, &time, (uint64_t)&rhs);
        CMTime time = v69;
        CMTimeAdd(&v68, &time, &rhs);
        CMTime time = v69;
        CMTime time2 = v67;
        if (CMTimeCompare(&time, &time2) >= 1)
        {
          CMTime time = v66;
          CMTime time2 = v69;
          CMTimeMaximum(&v66, &time, &time2);
        }
        CMTimeMake(&v60, 1, 1);
        CMTime time = v66;
        CMTimeAdd(&v61, &time, &v60);
        CMTime time = v68;
        if (CMTimeCompare(&time, &v61) < 0)
        {
          if (*((_DWORD *)v6 + 748))
          {
            LODWORD(v64.CFDictionarySetValue(theDict, key, value) = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            uint64_t v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v15 = v64.value;
            if (os_log_type_enabled(v14, type)) {
              unsigned int v16 = v15;
            }
            else {
              unsigned int v16 = v15 & 0xFFFFFFFE;
            }
            if (v16)
            {
              uint64_t v17 = *(void *)DerivedStorage;
              if (*(void *)DerivedStorage) {
                uint64_t v18 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
              }
              else {
                uint64_t v18 = "";
              }
              uint64_t v59 = v18;
              CFArrayRef v19 = *(const __CFArray **)v11;
              if (*(void *)v11) {
                uint64_t v20 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
              }
              else {
                uint64_t v20 = "";
              }
              uint64_t v58 = v20;
              CMTime time = v67;
              Float64 Seconds = CMTimeGetSeconds(&time);
              CMTime time = v69;
              Float64 v22 = CMTimeGetSeconds(&time);
              CMTime time = v68;
              Float64 v23 = CMTimeGetSeconds(&time);
              LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316930;
              *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"fpfs_AbandonSyncAttempt";
              LOWORD(time2.flags) = 2048;
              *(void *)((char *)&time2.flags + 2) = v17;
              HIWORD(time2.epoch) = 2082;
              uint64_t v71 = v59;
              __int16 v72 = 2048;
              CFArrayRef v73 = v19;
              __int16 v74 = 2082;
              uint64_t v75 = v58;
              __int16 v76 = 2048;
              Float64 v77 = Seconds;
              __int16 v78 = 2048;
              Float64 v79 = v22;
              __int16 v80 = 2048;
              Float64 v81 = v23;
              _os_log_send_and_compose_impl();
              uint64_t v6 = &PerformOneTimeAssetTableInitialization_sAssetTableInit;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
LABEL_49:
          LODWORD(v10) = 0;
        }
      }
    }
    uint64_t v11 = *(void *)(v11 + 8);
  }
  while (v11);
  if (*(float *)(DerivedStorage + 848) == 0.0) {
    goto LABEL_55;
  }
  if (v10)
  {
LABEL_53:
    uint64_t v24 = *(void *)DerivedStorage;
    CMTime time = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
    CMTime time2 = time;
    fpfs_setRateInternal(v24, v2, &time, &time2, 0.0);
    LODWORD(v10) = 1;
    goto LABEL_55;
  }
LABEL_21:
  uint64_t v10 = fpfs_StopPlaybackByStalledTrack(a1, 2u);
  if (!v10) {
    goto LABEL_55;
  }
LABEL_96:
  uint64_t v40 = CMBaseObjectGetDerivedStorage();
  fpfs_StopPlayingItemWithOSStatus(v40, (uint64_t)v2, v10);
}

void fpfsi_MoveTrackToPlayedOut(uint64_t a1, uint64_t a2, long long *a3)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(const void **)a2;
  uint64_t v7 = *(const void **)a1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  int v9 = fpfs_shouldCheckAndReportVariantEnded(a2);
  fpfs_ReleaseTrackRenderChain(a2);
  if (*(_DWORD *)(a2 + 152) == 6)
  {
    int v16 = *(_DWORD *)(a2 + 32);
    if (v16 == 1936684398)
    {
      fpfs_PrepareAndEnqueueSpatialAudioRenderingChangedNotification(*(const void **)a1, *(const void **)a2, v10, v11, v12, v13, v14, v15);
      int v16 = *(_DWORD *)(a2 + 32);
    }
    if (v16 == 1986618469)
    {
      uint64_t v17 = *(void *)(a2 + 8);
      if (v17)
      {
        uint64_t v18 = MEMORY[0x1E4F1FA48];
        do
        {
          if (*(_DWORD *)(v17 + 32) == 1986618469 && (*(_DWORD *)(v17 + 152) | 4) == 5 && !*(void *)(v17 + 264))
          {
            fpfs_GetTime(a1, (uint64_t)&fireTime);
            fpfs_PrimeVideoSyncTimer(v17, &fireTime, v18);
          }
          uint64_t v17 = *(void *)(v17 + 8);
        }
        while (v17);
      }
    }
  }
  if (v9) {
    fpfsi_RTCReportingReportCheckAndReportVariantEnded(a1, a2);
  }
  uint64_t v19 = *(void *)(a1 + 1048);
  if (v19 == a2)
  {
    uint64_t v22 = a1 + 1048;
    uint64_t v28 = *(void *)(a2 + 8);
    *(void *)(a1 + 1048) = v28;
    if (!v28) {
LABEL_17:
    }
      *(void *)(a1 + 1056) = v22;
  }
  else
  {
    do
    {
      uint64_t v20 = v19;
      uint64_t v19 = *(void *)(v19 + 8);
    }
    while (v19 != a2);
    uint64_t v21 = *(void *)(a2 + 8);
    *(void *)(v20 + 8) = v21;
    uint64_t v22 = v20 + 8;
    if (!v21) {
      goto LABEL_17;
    }
  }
  unsigned int v23 = *(_DWORD *)(a2 + 152);
  BOOL v24 = v23 > 7;
  int v25 = (1 << v23) & 0xB0;
  if (!v24 && v25 != 0)
  {
    if (dword_1E9350BB0)
    {
      LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    fpfs_ChangeTrackState(a2, 6u);
    fpfsi_RTCReportingUpdateAlternateIndex(a1, *(void *)(a2 + 432));
    fpfsi_RTCReportingUpdateVariantRank(a1, *(_DWORD *)(a2 + 448), *(_DWORD *)(a2 + 452));
  }
  fpfs_ReleaseAndClearTimebaseTimer(*(OpaqueCMTimebase **)(a1 + 576), (dispatch_object_t *)(a2 + 112));
  unsigned int v29 = *(NSObject **)(a2 + 120);
  if (v29)
  {
    uint64_t v30 = *(OpaqueCMTimebase **)(a1 + 576);
    CMTime fireTime = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA10];
    CMTimebaseSetTimerDispatchSourceNextFireTime(v30, v29, &fireTime, 1u);
    uint64_t v31 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)(a2 + 156) = *MEMORY[0x1E4F1F9F8];
    *(void *)(a2 + 172) = *(void *)(v31 + 16);
  }
  *(unsigned char *)(a2 + 104) = 0;
  if (*((unsigned char *)a3 + 12))
  {
    *(void *)os_log_type_t type = 0;
    CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    CallbacksForUnsortedSampleBuffers = CMBufferQueueGetCallbacksForUnsortedSampleBuffers();
    if (!CMBufferQueueCreate(AllocatorForMedia, 0, CallbacksForUnsortedSampleBuffers, (CMBufferQueueRef *)type))
    {
      fireTime.unsigned int value = *(void *)type;
      *(_OWORD *)&fireTime.CMTimeScale timescale = *a3;
      uint64_t v73 = *((void *)a3 + 2);
      CMBufferQueueCallForEachBuffer(*(CMBufferQueueRef *)(a2 + 80), (OSStatus (__cdecl *)(CMBufferRef, void *))fpfs_GrabBuffersBeforeTime, &fireTime);
      uint64_t v34 = *(opaqueCMBufferQueue **)(a2 + 80);
      if (v34)
      {
        BufferCFArrayRef Count = CMBufferQueueGetBufferCount(v34);
        uint64_t v36 = *(void *)(a2 + 80);
        if (BufferCount < 1)
        {
          if (v36) {
            CFRelease(*(CFTypeRef *)(a2 + 80));
          }
        }
        else
        {
          fpfs_SendBufferQueueToChomper(DerivedStorage, v36);
        }
      }
      *(void *)(a2 + 80) = *(void *)type;
      CMTime time1 = *(CMTime *)(a2 + 216);
      CMTime time2 = *(CMTime *)a3;
      if (CMTimeCompare(&time1, &time2) >= 1)
      {
        long long v37 = *a3;
        *(void *)(a2 + 232) = *((void *)a3 + 2);
        *(_OWORD *)(a2 + 216) = v37;
      }
      uint64_t v38 = MEMORY[0x1E4F1FA20];
      long long v39 = *(_OWORD *)(MEMORY[0x1E4F1FA20] + 16);
      *(_OWORD *)(a2 + 496) = *MEMORY[0x1E4F1FA20];
      *(_OWORD *)(a2 + 512) = v39;
      *(_OWORD *)(a2 + 528) = *(_OWORD *)(v38 + 32);
    }
  }
  if (dword_1E9350BB0)
  {
    LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    uint64_t v40 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    unsigned int value = time2.value;
    if (os_log_type_enabled(v40, type[0])) {
      unsigned int v42 = value;
    }
    else {
      unsigned int v42 = value & 0xFFFFFFFE;
    }
    if (v42)
    {
      int v43 = *(const void **)a1;
      if (*(void *)a1) {
        uint64_t v44 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
      }
      else {
        uint64_t v44 = "";
      }
      uint64_t v59 = v7;
      if (v6) {
        uint64_t v45 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
      }
      else {
        uint64_t v45 = "";
      }
      uint64_t v46 = *(void *)(a2 + 16);
      CMTime fireTime = *(CMTime *)(a2 + 216);
      Float64 Seconds = CMTimeGetSeconds(&fireTime);
      LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 136316674;
      *(CMTimeValue *)((char *)&time1.value + 4) = (CMTimeValue)"fpfsi_MoveTrackToPlayedOut";
      LOWORD(time1.flags) = 2048;
      *(void *)((char *)&time1.flags + 2) = v43;
      HIWORD(time1.epoch) = 2082;
      BOOL v63 = v44;
      __int16 v64 = 2048;
      char v65 = v6;
      __int16 v66 = 2082;
      CMTime v67 = v45;
      __int16 v68 = 1024;
      int v69 = v46;
      __int16 v70 = 2048;
      Float64 v71 = Seconds;
      _os_log_send_and_compose_impl();
      uint64_t v7 = v59;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  uint64_t v48 = (uint64_t *)(a1 + 1064);
  uint64_t v49 = *(void *)(a1 + 1064);
  if (v49)
  {
    uint64_t v50 = *(void *)(a2 + 16);
    uint64_t v51 = *(void *)(a1 + 1064);
    while (1)
    {
      uint64_t v52 = *(void *)(v51 + 8);
      if (*(void *)(v51 + 16) < v50)
      {
        if (!v52)
        {
          uint64_t v48 = (uint64_t *)(v51 + 8);
          goto LABEL_61;
        }
        if (*(void *)(v52 + 16) > v50) {
          break;
        }
      }
      uint64_t v51 = *(void *)(v51 + 8);
      if (!v52)
      {
        *(void *)(a2 + 8) = v49;
        goto LABEL_63;
      }
    }
    uint64_t v48 = (uint64_t *)(v51 + 8);
    *(void *)(a2 + 8) = v52;
  }
  else
  {
LABEL_61:
    *(void *)(a2 + 8) = 0;
    *(void *)(a1 + 1072) = a2 + 8;
  }
LABEL_63:
  *uint64_t v48 = a2;
  if (*(_DWORD *)(a2 + 32) == 1986618469) {
    fpfsi_PostExternalProtectionRequiredChangedNotification(*(const void **)a2);
  }
  fpfs_CompleteLogIfLastTrack((uint64_t)v6, a2);
  fpfs_PrepareAndEnqueueTracksChangedNotification(v7, v6, v53, v54, v55, v56, v57, v58);
}

uint64_t fpfs_PerformInitialResolveOfAllWaitingTracks(const __CFArray *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v3 = CMBaseObjectGetDerivedStorage();
  CFArrayRef Next = fpfs_getNext(v3, *(const void **)(v3 + 80));
  CFArrayRef v5 = Next;
  uint64_t v6 = *(void *)(v3 + 80);
  if (v6) {
    BOOL v7 = v6 == (void)a1;
  }
  else {
    BOOL v7 = 1;
  }
  BOOL v8 = !v7 && Next == a1;
  if (!v8 || *(unsigned char *)(DerivedStorage + 2448))
  {
    BOOL v9 = 0;
    goto LABEL_11;
  }
  uint64_t v12 = CMBaseObjectGetDerivedStorage();
  uint64_t v13 = CMBaseObjectGetDerivedStorage();
  long long v17 = *MEMORY[0x1E4F1F9F8];
  *(_OWORD *)&v46.unsigned int value = *MEMORY[0x1E4F1F9F8];
  CMTimeEpoch v14 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  v46.CMTimeEpoch epoch = v14;
  uint64_t v45 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  uint64_t v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  if (fpfs_IsPlayerEligibleForGaplessTransition())
  {
    if (fpfs_OkayToAttemptGapless(v6, (uint64_t)a1, (uint64_t)&v41, (uint64_t)&v36, (uint64_t)&v46))
    {
      unsigned __int8 v35 = 0;
      int v34 = 0;
      uint64_t result = fpfs_EstablishTimebase(a1);
      if (result)
      {
        *(unsigned char *)(DerivedStorage + 2448) = 0;
        return result;
      }
      long long v31 = v43;
      long long v32 = v44;
      uint64_t v33 = v45;
      long long v29 = v41;
      long long v30 = v42;
      long long v26 = v38;
      long long v27 = v39;
      uint64_t v28 = v40;
      long long v24 = v36;
      long long v25 = v37;
      fpfs_AreItemsEligibleForGaplessTransition(v6, (uint64_t)&v29, (uint64_t)a1, (uint64_t)&v24, &v34, &v35);
      if (v34 == 2)
      {
        BOOL v16 = 0;
        BOOL v9 = 0;
      }
      else if (v34 == 1)
      {
        long long v29 = v17;
        *(void *)&long long v30 = v14;
        long long v24 = v17;
        *(void *)&long long v25 = v14;
        *(_OWORD *)&v23.unsigned int value = v17;
        v23.CMTimeEpoch epoch = v14;
        CMTime rhs = v46;
        fpfp_GetTransitionTimebaseStartTime(v12, v13, (uint64_t)&v41, (uint64_t)&v36, &rhs, v35, &v22, &v21, (uint64_t)&v29);
        fpfs_GetItemBufferedDuration(a1, &v24, 0, 0);
        fpfs_GetNextTimeToPlay(v13, 0, (uint64_t)&lhs);
        *(_OWORD *)&rhs.unsigned int value = v24;
        rhs.CMTimeEpoch epoch = v25;
        CMTimeAdd(&v23, &lhs, &rhs);
        CMTime rhs = v23;
        *(_OWORD *)&time2.unsigned int value = v29;
        time2.CMTimeEpoch epoch = v30;
        int32_t v15 = CMTimeCompare(&rhs, &time2);
        BOOL v16 = v15 > 0;
        BOOL v9 = v15 < 1;
      }
      else
      {
        BOOL v16 = 0;
        BOOL v9 = 1;
      }
      goto LABEL_31;
    }
    BOOL v9 = 1;
  }
  else
  {
    BOOL v9 = 0;
  }
  BOOL v16 = 0;
LABEL_31:
  *(unsigned char *)(DerivedStorage + 2448) = v16;
LABEL_11:
  if (*(const __CFArray **)(v3 + 80) != a1)
  {
    if (v5 != a1 || v9) {
      return 0;
    }
    return fpfs_ResolveAllWaitingTracks(a1);
  }
  if (!v9) {
    return fpfs_ResolveAllWaitingTracks(a1);
  }
  return 0;
}

BOOL fpfs_GetItemLivingTrack(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t i = *(void *)(a1 + 1048);
  if (i)
  {
    while (*(void *)(i + 16) != a2)
    {
      uint64_t i = *(void *)(i + 8);
      if (!i) {
        goto LABEL_4;
      }
    }
  }
  else
  {
LABEL_4:
    for (uint64_t i = *(void *)(a1 + 1064); i; uint64_t i = *(void *)(i + 8))
    {
      if (*(void *)(i + 16) == a2) {
        break;
      }
    }
  }
  *a3 = i;
  return i != 0;
}

uint64_t fpfs_CheckVideoSyncQueue(uint64_t a1, int a2)
{
  uint64_t v204 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v6 = CMBaseObjectGetDerivedStorage();
  CMTime v162 = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  long long v137 = *(_OWORD *)&v162.value;
  CMTimeEpoch epoch = v162.epoch;
  memset(&v161, 0, sizeof(v161));
  memset(&v160, 0, sizeof(v160));
  memset(&v159, 0, sizeof(v159));
  CMTimeMake(&v159, -33, 1000);
  memset(&v158, 0, sizeof(v158));
  CMTimeMake(&v158, -10, 1000);
  memset(v157, 0, sizeof(v157));
  long long v156 = 0u;
  long long v154 = 0u;
  memset(v155, 0, sizeof(v155));
  memset(v153, 0, sizeof(v153));
  memset(&v152, 0, sizeof(v152));
  *(_OWORD *)&v151.unsigned int value = v137;
  v151.CMTimeEpoch epoch = epoch;
  BOOL v8 = fpfs_CanRenderVideo(v6, v4) && *(unsigned char *)(DerivedStorage + 2880) == 0;
  if (*(void *)(a1 + 384)) {
    BOOL v113 = fpfs_isDecryptorReady(a1) == 0;
  }
  else {
    BOOL v113 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v116 = *(void *)(DerivedStorage + 16 * *(unsigned __int8 *)(a1 + 180) + 1008);
  long long v112 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)&v150.unsigned int value = *MEMORY[0x1E4F1FA48];
  CMTimeEpoch v111 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  v150.CMTimeEpoch epoch = v111;
  memset(&v149, 0, sizeof(v149));
  memset(&v148, 0, sizeof(v148));
  memset(&v146, 0, sizeof(v146));
  fpfs_GetTime(DerivedStorage, (uint64_t)&v146);
  CMTime v147 = v146;
  int v10 = *(_DWORD *)(a1 + 152);
  if ((v10 | 4) != 5) {
    return 0;
  }
  if (*(unsigned char *)(v6 + 456))
  {
    CMTimeMake(&refcon, -250, 1000);
    CMTime v159 = refcon;
    CMTimeMake(&refcon, -200, 1000);
    CMTime v158 = refcon;
    int v10 = *(_DWORD *)(a1 + 152);
  }
  CMTimeValue v202 = *(void *)(a1 + 272);
  CMTimeScale timescale = *(_DWORD *)(a1 + 280);
  CMTimeFlags flags = *(_DWORD *)(a1 + 284);
  CMTimeEpoch v128 = *(void *)(a1 + 288);
  uint64_t v114 = v6;
  int v131 = a2;
  if (v10 == 1)
  {
    uint64_t CandidateSyncTrackOfDiscontinuityDomainAndType = fpfs_FirstCandidateSyncTrackOfDiscontinuityDomainAndType(v4, a1);
    uint64_t RenderingTrackofType = fpfs_LastRenderingTrackofType(v4, *(_DWORD *)(a1 + 32), a1);
    if (CandidateSyncTrackOfDiscontinuityDomainAndType)
    {
      uint64_t v115 = RenderingTrackofType;
      uint64_t v13 = v9;
      CMTime refcon = *(CMTime *)(CandidateSyncTrackOfDiscontinuityDomainAndType + 192);
      CMTime time1 = v147;
      if (fpfs_TimeIsAfter(v6, &refcon, &time1)) {
        CMTime v147 = *(CMTime *)(CandidateSyncTrackOfDiscontinuityDomainAndType + 192);
      }
      uint64_t v14 = *(void *)(CandidateSyncTrackOfDiscontinuityDomainAndType + 96);
      if (v14)
      {
        dictionaryRepresentation.unsigned int value = 0;
        uint64_t v15 = *(void *)(v14 + 32);
        uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
        uint64_t FigBaseObject = FigRenderPipelineGetFigBaseObject(v15);
        uint64_t v18 = *(void *)(CMBaseObjectGetVTable() + 8);
        uint64_t v19 = v18 ? v18 : 0;
        CMTime v22 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CMTime *))(v19 + 48);
        if (v22)
        {
          if (!v22(FigBaseObject, @"EndPresentationTimeForDecodedSamples", AllocatorForMedia, &dictionaryRepresentation))
          {
            memset(&refcon, 0, sizeof(refcon));
            CMTimeMakeFromDictionary(&refcon, (CFDictionaryRef)dictionaryRepresentation.value);
            CFRelease((CFTypeRef)dictionaryRepresentation.value);
            if (refcon.flags)
            {
              CMTime time1 = v147;
              CMTime time2 = refcon;
              if (CMTimeCompare(&time1, &time2) < 0) {
                CMTime v147 = refcon;
              }
            }
          }
        }
      }
      char v20 = 0;
      uint64_t v9 = v13;
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t RenderingTrackofType = fpfs_LastRenderingTrackofType(v4, *(_DWORD *)(a1 + 32), a1);
  }
  uint64_t CandidateSyncTrackOfDiscontinuityDomainAndType = 0;
  char v20 = 1;
  uint64_t v115 = RenderingTrackofType;
  if (*(_DWORD *)(a1 + 152) == 1 && RenderingTrackofType && v9 == v116)
  {
    if (fpfsi_TrialSwitchDownInProgress(DerivedStorage))
    {
      uint64_t CandidateSyncTrackOfDiscontinuityDomainAndType = 0;
      goto LABEL_32;
    }
    return 0;
  }
LABEL_32:
  v153[0] = v147;
  v153[1] = v158;
  *(_OWORD *)((char *)v155 + 8) = *MEMORY[0x1E4F1FA08];
  *((void *)&v155[1] + 1) = *(void *)(MEMORY[0x1E4F1FA08] + 16);
  *(void *)&v157[0] = epoch;
  long long v156 = v137;
  if ((v20 & 1) == 0 && (*(_DWORD *)(CandidateSyncTrackOfDiscontinuityDomainAndType + 228) & 0x1D) == 1)
  {
    CMTime v162 = *(CMTime *)(CandidateSyncTrackOfDiscontinuityDomainAndType + 216);
    if (v115)
    {
      if ((*(_DWORD *)(v115 + 228) & 0x1D) == 1)
      {
        CMTime refcon = *(CMTime *)(CandidateSyncTrackOfDiscontinuityDomainAndType + 216);
        CMTime time1 = *(CMTime *)(v115 + 216);
        CMTimeMaximum(&v162, &refcon, &time1);
      }
    }
  }
  BOOL v104 = v9 == v116;
  if (v9 == v116 && !fpfsi_TrialSwitchDownInProgress(DerivedStorage))
  {
    *(_OWORD *)((char *)v157 + 8) = v137;
    *((void *)&v157[1] + 1) = epoch;
  }
  else
  {
    *(CMTime *)((char *)v157 + 8) = v162;
  }
  CMBaseObjectGetDerivedStorage();
  uint64_t v110 = v9;
  if (*(void *)(a1 + 384)) {
    BOOL v23 = fpfs_isDecryptorReady(a1) == 0;
  }
  else {
    BOOL v23 = 0;
  }
  uint64_t v24 = v4;
  BOOL v25 = (v20 & 1) == 0
     && !FigStreamAlternateCanConcurrentlyDecodeAlternates(*(__CFArray **)(CandidateSyncTrackOfDiscontinuityDomainAndType + 440), *(__CFArray **)(a1 + 440));
  if (fpfs_allowFastVideoSwitch_onceToken != -1) {
    dispatch_once(&fpfs_allowFastVideoSwitch_onceToken, &__block_literal_global_219);
  }
  uint64_t v26 = a1 + 272;
  if (*(void *)(a1 + 96)) {
    int v27 = v23;
  }
  else {
    int v27 = 1;
  }
  Float64 v122 = (_OWORD *)(a1 + 272);
  if ((v27 | v25))
  {
    int v28 = 0;
  }
  else
  {
    dictionaryRepresentation.unsigned int value = 0;
    CMBufferQueueCallForEachBuffer(*(CMBufferQueueRef *)(a1 + 72), (OSStatus (__cdecl *)(CMBufferRef, void *))fpfs_GetFirstNonMarkerSBuf, &dictionaryRepresentation);
    int v29 = *(unsigned __int8 *)(a1 + 183);
    if (!*(unsigned char *)(a1 + 183) && dictionaryRepresentation.value)
    {
      memset(&refcon, 0, sizeof(refcon));
      CMSampleBufferGetOutputPresentationTimeStamp(&refcon, (CMSampleBufferRef)dictionaryRepresentation.value);
      if (*(unsigned char *)(a1 + 184) || (CMTime time1 = refcon, time2 = v147, fpfs_TimeIsAfter(v114, &time1, &time2)))
      {
        if (*(void *)(a1 + 384))
        {
          if (!*(unsigned char *)(a1 + 186))
          {
            if (fpfs_IsVideoSync((opaqueCMSampleBuffer *)dictionaryRepresentation.value))
            {
              time1.unsigned int value = 0;
              CFAllocatorRef v79 = (const __CFAllocator *)FigGetAllocatorForMedia();
              if (!CMSampleBufferCreateCopy(v79, (CMSampleBufferRef)dictionaryRepresentation.value, (CMSampleBufferRef *)&time1))
              {
                fpfs_DoNotDisplay((opaqueCMSampleBuffer *)time1.value);
                fpfs_RenderBuffer(a1, (opaqueCMSampleBuffer *)time1.value);
                if (time1.value) {
                  CFRelease((CFTypeRef)time1.value);
                }
                *(unsigned char *)(a1 + 186) = 1;
              }
            }
          }
        }
      }
      else
      {
        *(unsigned char *)(a1 + 183) = 1;
        uint64_t v80 = *(void *)(*(void *)(a1 + 96) + 32);
        uint64_t v81 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v81) {
          uint64_t v82 = v81;
        }
        else {
          uint64_t v82 = 0;
        }
        int v85 = *(void (**)(uint64_t))(v82 + 40);
        if (v85) {
          v85(v80);
        }
      }
      int v29 = *(unsigned __int8 *)(a1 + 183);
      uint64_t v26 = a1 + 272;
    }
    if (v29)
    {
      unsigned int value = (opaqueCMSampleBuffer *)dictionaryRepresentation.value;
      int v28 = 1;
      if (dictionaryRepresentation.value)
      {
        while (1)
        {
          memset(&time1, 0, sizeof(time1));
          CMSampleBufferGetOutputPresentationTimeStamp(&time1, value);
          CMTime refcon = time1;
          CMTime time2 = v147;
          if ((CMTimeCompare(&refcon, &time2) & 0x80000000) == 0) {
            break;
          }
          dictionaryRepresentation.unsigned int value = (CMTimeValue)CMBufferQueueDequeueAndRetain(*(CMBufferQueueRef *)(a1 + 72));
          if (fpfs_IsVideoDependedOnByOthers((opaqueCMSampleBuffer *)dictionaryRepresentation.value))
          {
            if (fpfs_IsVideoSync((opaqueCMSampleBuffer *)dictionaryRepresentation.value)) {
              fpfs_FlushPrimaryAndAuxRenderChains(*(void *)(a1 + 96), 0);
            }
            fpfs_DoNotDisplay((opaqueCMSampleBuffer *)dictionaryRepresentation.value);
            fpfs_RenderBuffer(a1, (opaqueCMSampleBuffer *)dictionaryRepresentation.value);
            *(unsigned char *)(a1 + 186) = 1;
          }
          if (dictionaryRepresentation.value) {
            CFRelease((CFTypeRef)dictionaryRepresentation.value);
          }
          unsigned int value = (opaqueCMSampleBuffer *)CMBufferQueueGetHead(*(CMBufferQueueRef *)(a1 + 72));
          dictionaryRepresentation.unsigned int value = (CMTimeValue)value;
          if (!value)
          {
            int v28 = 1;
            goto LABEL_74;
          }
        }
        CMTime refcon = v147;
        *(CMTime *)int v164 = time1;
        *(_OWORD *)&v164[24] = v137;
        *(void *)__int16 v165 = epoch;
        CMBufferQueueCallForEachBuffer(*(CMBufferQueueRef *)(a1 + 72), (OSStatus (__cdecl *)(CMBufferRef, void *))fpfs_GetFirstPTSInRange, &refcon);
        *(_OWORD *)&v151.unsigned int value = *(_OWORD *)&v164[24];
        CMTimeEpoch v31 = *(void *)v165;
        v151.CMTimeEpoch epoch = *(void *)v165;
        *(_OWORD *)uint64_t v26 = *(_OWORD *)&v164[24];
        CMTimeEpoch v128 = v31;
        *(void *)(v26 + 16) = v31;
        CMTimeValue v202 = *(void *)&v164[24];
        CMTimeFlags flags = *(_DWORD *)&v164[36];
        int v28 = 1;
        CMTimeScale timescale = *(_DWORD *)&v164[32];
      }
    }
    else
    {
      int v28 = 0;
    }
  }
LABEL_74:
  BOOL v32 = *(float *)(DerivedStorage + 848) == 0.0 && v8;
  if (v28 || !v32)
  {
    int v134 = v28;
  }
  else
  {
    dictionaryRepresentation.unsigned int value = 0;
    CMBufferQueueCallForEachBuffer(*(CMBufferQueueRef *)(a1 + 72), (OSStatus (__cdecl *)(CMBufferRef, void *))fpfs_GetFirstNonMarkerSBuf, &dictionaryRepresentation);
    if (!dictionaryRepresentation.value) {
      goto LABEL_81;
    }
    memset(&refcon, 0, sizeof(refcon));
    CMSampleBufferGetOutputPresentationTimeStamp(&refcon, (CMSampleBufferRef)dictionaryRepresentation.value);
    CMTime time1 = refcon;
    CMTime time2 = v147;
    if (fpfs_TimeIsAfter(v114, &time1, &time2)) {
      goto LABEL_81;
    }
    *(CMTime *)(a1 + 192) = refcon;
    fpfs_GetStartupDurationOfType((CMTime *)a1, (uint64_t)&v152);
    CMTime time1 = refcon;
    CMTime time2 = v152;
    fpfs_TimeAfterPlayback(v114, &time1, &time2, &v144);
    CMTime time1 = v147;
    if (fpfs_TimeIsAfter(v114, &v144, &time1))
    {
      CMTimeValue v202 = refcon.value;
      CMTimeFlags flags = refcon.flags;
      CMTimeScale timescale = refcon.timescale;
      int v33 = 1;
      CMTimeEpoch v128 = refcon.epoch;
    }
    else
    {
LABEL_81:
      int v33 = 0;
    }
    int v134 = v33;
  }
  FPSupport_getVideoDecodeWaterLevels(&v161, &v160, 1);
  v160.value *= 2;
  CMTime refcon = v146;
  CMTime time1 = v160;
  fpfs_TimeAfterPlayback(v114, &refcon, &time1, &v143);
  *(_OWORD *)&refcon.unsigned int value = *v122;
  refcon.CMTimeEpoch epoch = *(void *)(a1 + 288);
  if (fpfs_TimeIsAfter(v114, &refcon, &v143))
  {
    int v34 = (CMTime *)(a1 + 272);
    if ((v20 & 1) != 0
      || (*(_OWORD *)&refcon.unsigned int value = *v122,
          refcon.CMTimeEpoch epoch = *(void *)(a1 + 288),
          CMTime time1 = *(CMTime *)(CandidateSyncTrackOfDiscontinuityDomainAndType + 216),
          CMTimeCompare(&refcon, &time1) <= 0))
    {
      uint64_t v35 = DerivedStorage;
      CMTimeEpoch v36 = v128;
      if (*(void *)(a1 + 96) || v8 && *(uint64_t *)(v114 + 616) <= 3)
      {
        uint64_t v37 = *(void *)(DerivedStorage + 1048);
        int v134 = 1;
        if (v37)
        {
          if (v37 != a1)
          {
            int v134 = 1;
            do
            {
              if (*(_DWORD *)(v37 + 32) == 1986618469)
              {
                int v38 = v134;
                if ((*(_DWORD *)(v37 + 152) | 4) == 5) {
                  int v38 = 0;
                }
                int v134 = v38;
              }
              uint64_t v37 = *(void *)(v37 + 8);
              if (v37) {
                BOOL v39 = v37 == a1;
              }
              else {
                BOOL v39 = 1;
              }
            }
            while (!v39);
          }
        }
      }
    }
    else
    {
      uint64_t v35 = DerivedStorage;
      CMTimeEpoch v36 = v128;
    }
  }
  else
  {
    uint64_t v35 = DerivedStorage;
    CMTimeEpoch v36 = v128;
    int v34 = (CMTime *)(a1 + 272);
  }
  uint64_t v123 = (dispatch_object_t *)(a1 + 264);
  BOOL v109 = !v8 || v113;
  double v107 = (CMTimeValue *)(a1 + 216);
  if (v131) {
    BOOL v40 = 0;
  }
  else {
    BOOL v40 = v110 == v116;
  }
  char v41 = v40;
  double v106 = (CMTimeValue *)(v115 + 216);
  char v103 = v41;
  if (v115) {
    char v42 = v41;
  }
  else {
    char v42 = 1;
  }
  char v105 = v42;
  CMTimeFlags v108 = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 12);
  uint64_t v43 = v24;
  int v44 = 0;
  CMTimeFlags v45 = flags;
  CMTimeEpoch v117 = epoch;
  while (1)
  {
    while (1)
    {
      if ((v45 & 1) == 0) {
        goto LABEL_133;
      }
      refcon.unsigned int value = v202;
      refcon.CMTimeScale timescale = timescale;
      refcon.CMTimeFlags flags = v45;
      refcon.CMTimeEpoch epoch = v36;
      CMTime time1 = v159;
      CMTimeAdd(&v149, &refcon, &time1);
      refcon.unsigned int value = v202;
      refcon.CMTimeScale timescale = timescale;
      refcon.CMTimeFlags flags = v45;
      refcon.CMTimeEpoch epoch = v36;
      CMTime time1 = v158;
      CMTimeAdd(&v148, &refcon, &time1);
      if (!*(void *)(a1 + 352)) {
        *(void *)(a1 + 352) = FigGetUpTimeNanoseconds();
      }
      if (v134) {
        break;
      }
      CMTime refcon = v146;
      CMTime time1 = v148;
      if (CMTimeCompare(&refcon, &time1) <= 0)
      {
        CMTime refcon = v146;
        CMTime time1 = v149;
        if (CMTimeCompare(&refcon, &time1) < 0)
        {
          CMTimeEpoch v130 = v36;
          if (!*v123 && dword_1E9350BB0)
          {
            CMTimeFlags v127 = v45;
            LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 0;
            LOBYTE(dictionaryRepresentation.CFDictionarySetValue(theDict, key, value) = 0;
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            unsigned int v87 = time2.value;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, dictionaryRepresentation.value)) {
              unsigned int v88 = v87;
            }
            else {
              unsigned int v88 = v87 & 0xFFFFFFFE;
            }
            if (v88)
            {
              uint64_t v89 = *(void *)v35;
              if (*(void *)v35) {
                uint64_t v90 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
              }
              else {
                uint64_t v90 = "";
              }
              int v136 = v90;
              if (v43) {
                uint64_t v91 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
              }
              else {
                uint64_t v91 = "";
              }
              uint64_t v92 = *(void *)(v35 + 160);
              uint64_t v93 = *(void *)(a1 + 16);
              refcon.unsigned int value = v202;
              refcon.CMTimeScale timescale = timescale;
              refcon.CMTimeFlags flags = v127;
              refcon.CMTimeEpoch epoch = v130;
              Float64 Seconds = CMTimeGetSeconds(&refcon);
              CMTime refcon = v146;
              Float64 v95 = CMTimeGetSeconds(&refcon);
              LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 136317186;
              *(CMTimeValue *)((char *)&time1.value + 4) = (CMTimeValue)"fpfs_CheckVideoSyncQueue";
              LOWORD(time1.flags) = 2048;
              *(void *)((char *)&time1.flags + 2) = v89;
              HIWORD(time1.epoch) = 2082;
              unsigned int v185 = v136;
              __int16 v186 = 2048;
              uint64_t v187 = v43;
              __int16 v188 = 2082;
              uint64_t v189 = v91;
              __int16 v190 = 1024;
              int v191 = v92;
              __int16 v192 = 1024;
              int v193 = v93;
              __int16 v194 = 2048;
              Float64 v195 = Seconds;
              __int16 v196 = 2048;
              Float64 v197 = v95;
              _os_log_send_and_compose_impl();
              CMTimeEpoch epoch = v117;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            CMTimeFlags v45 = v127;
            int v34 = (CMTime *)(a1 + 272);
          }
LABEL_238:
          v34->unsigned int value = v202;
          v34->CMTimeScale timescale = timescale;
          *(_DWORD *)(a1 + 284) = v45;
          *(void *)(a1 + 288) = v130;
          if (!*(void *)(a1 + 264))
          {
            refcon.unsigned int value = v202;
            refcon.CMTimeScale timescale = timescale;
            refcon.CMTimeFlags flags = v45;
            refcon.CMTimeEpoch epoch = v130;
            CMTime time1 = v150;
            fpfs_PrimeVideoSyncTimer(a1, &refcon, &time1);
          }
          goto LABEL_240;
        }
        break;
      }
      if (dword_1E9350BB0)
      {
        int v132 = v44;
        CMTimeEpoch v129 = v36;
        LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(dictionaryRepresentation.CFDictionarySetValue(theDict, key, value) = 0;
        CMTime v46 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        unsigned int v47 = time2.value;
        if (os_log_type_enabled(v46, dictionaryRepresentation.value)) {
          unsigned int v48 = v47;
        }
        else {
          unsigned int v48 = v47 & 0xFFFFFFFE;
        }
        if (v48)
        {
          uint64_t v49 = *(void *)v35;
          if (*(void *)v35) {
            uint64_t v50 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
          }
          else {
            uint64_t v50 = "";
          }
          int v120 = v50;
          if (v43) {
            uint64_t v51 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
          }
          else {
            uint64_t v51 = "";
          }
          int v118 = v51;
          uint64_t v52 = v43;
          uint64_t v53 = *(void *)(v35 + 160);
          uint64_t v54 = *(void *)(a1 + 16);
          refcon.unsigned int value = v202;
          refcon.CMTimeScale timescale = timescale;
          refcon.CMTimeFlags flags = v45;
          refcon.CMTimeEpoch epoch = v129;
          Float64 v55 = CMTimeGetSeconds(&refcon);
          CMTime refcon = v146;
          Float64 v56 = CMTimeGetSeconds(&refcon);
          LODWORD(time1.CFDictionarySetValue(theDict, key, value) = 136317186;
          *(CMTimeValue *)((char *)&time1.value + 4) = (CMTimeValue)"fpfs_CheckVideoSyncQueue";
          LOWORD(time1.flags) = 2048;
          *(void *)((char *)&time1.flags + 2) = v49;
          HIWORD(time1.epoch) = 2082;
          unsigned int v185 = v120;
          __int16 v186 = 2048;
          uint64_t v187 = v52;
          __int16 v188 = 2082;
          uint64_t v189 = v118;
          __int16 v190 = 1024;
          int v191 = v53;
          __int16 v192 = 1024;
          int v193 = v54;
          __int16 v194 = 2048;
          Float64 v195 = v55;
          __int16 v196 = 2048;
          Float64 v197 = v56;
          _os_log_send_and_compose_impl();
          CMTimeEpoch epoch = v117;
          uint64_t v43 = v52;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        int v34 = (CMTime *)(a1 + 272);
        int v44 = v132;
      }
      fpfs_ReleaseAndClearDispatchSource(v123);
LABEL_133:
      long long v154 = *(_OWORD *)((char *)v155 + 8);
      *(void *)&v155[0] = *((void *)&v155[1] + 1);
      *(_OWORD *)((char *)v155 + 8) = v137;
      *((void *)&v155[1] + 1) = epoch;
      CMBufferQueueCallForEachBuffer(*(CMBufferQueueRef *)(a1 + 72), (OSStatus (__cdecl *)(CMBufferRef, void *))fpfs_VideoSyncSearch, v153);
      if (!*(unsigned char *)(a1 + 183)) {
        int v44 = 1;
      }
      if ((BYTE4(v155[1]) & 0x1D) != 1) {
        goto LABEL_240;
      }
      if (*(float *)(v35 + 848) == 0.0 && (*(_DWORD *)(a1 + 284) & 0x1D) == 1)
      {
        CMTime refcon = *v34;
        CMTime time1 = v146;
        if (CMTimeCompare(&refcon, &time1) <= 0)
        {
          CMTime refcon = *(CMTime *)((char *)v155 + 8);
          CMTime time1 = v146;
          if (CMTimeCompare(&refcon, &time1) > 0) {
            goto LABEL_240;
          }
        }
      }
      v34->CMTimeEpoch epoch = *((void *)&v155[1] + 1);
      *(_OWORD *)&v34->unsigned int value = *(_OWORD *)((char *)v155 + 8);
      CMTimeValue v202 = *((void *)&v155[0] + 1);
      CMTimeScale timescale = v155[1];
      CMTimeFlags v45 = *(_DWORD *)(a1 + 284);
      CMTimeEpoch v36 = *(void *)(a1 + 288);
    }
    *(_OWORD *)&v150.unsigned int value = v112;
    v150.CMTimeEpoch epoch = v111;
    CMTimeEpoch v130 = v36;
    int v133 = v44;
    if (v109) {
      goto LABEL_143;
    }
    refcon.unsigned int value = v202;
    refcon.CMTimeScale timescale = timescale;
    refcon.CMTimeFlags flags = v45;
    refcon.CMTimeEpoch epoch = v36;
    CMTime time1 = v151;
    if (!CMTimeCompare(&refcon, &time1))
    {
      if (*(void *)(a1 + 96))
      {
        refcon.unsigned int value = v202;
        refcon.CMTimeScale timescale = timescale;
        refcon.CMTimeFlags flags = v45;
        refcon.CMTimeEpoch epoch = v36;
        CMTime time1 = v147;
        if (CMTimeCompare(&refcon, &time1) <= 0 && *(float *)(v35 + 848) != 0.0 && *(_DWORD *)(a1 + 152) != 5)
        {
          CMTime refcon = v147;
          *(void *)&v164[16] = v111;
          *(_OWORD *)int v164 = v112;
          *(void *)&v164[24] = 0;
          *(void *)&v164[32] = 0;
          CMBufferQueueCallForEachBuffer(*(CMBufferQueueRef *)(*(void *)(a1 + 96) + 40), (OSStatus (__cdecl *)(CMBufferRef, void *))fpfs_CountNonDroppableUntil, &refcon);
          if (*(void *)&v164[32])
          {
            CMTime time1 = *(CMTime *)v164;
            CMTimeMultiplyByRatio(&v150, &time1, *(_DWORD *)&v164[24] + 1, *(int32_t *)&v164[32]);
          }
          *(_OWORD *)int v164 = v112;
          *(void *)&v164[16] = v111;
          *(void *)&v164[24] = 0;
          *(void *)&v164[32] = 0;
          CMBufferQueueCallForEachBuffer(*(CMBufferQueueRef *)(a1 + 72), (OSStatus (__cdecl *)(CMBufferRef, void *))fpfs_CountNonDroppableUntil, &refcon);
          if (*(void *)&v164[32])
          {
            CMTime time1 = *(CMTime *)v164;
            CMTimeMultiplyByRatio(&rhs, &time1, *(int32_t *)&v164[24], *(int32_t *)&v164[32]);
            CMTime time2 = v150;
            CMTimeAdd(&time1, &time2, &rhs);
            CMTime v150 = time1;
          }
          CMTime time1 = v147;
          CMTime time2 = v146;
          CMTimeSubtract(&v141, &time1, &time2);
          CMTime time1 = v150;
          if ((CMTimeCompare(&time1, &v141) & 0x80000000) == 0)
          {
LABEL_143:
            uint64_t v21 = 0;
            goto LABEL_181;
          }
        }
      }
    }
    CMTimeFlags v57 = *(_DWORD *)(a1 + 228);
    if ((v57 & 0x1D) == 1)
    {
      CMTimeFlags v58 = v45;
      CMTimeValue v200 = *v107;
      CMTimeScale v201 = *(_DWORD *)(a1 + 224);
      CMTimeEpoch v59 = *(void *)(a1 + 232);
    }
    else
    {
      CMTimeValue v200 = v202;
      CMTimeScale v201 = timescale;
      CMTimeFlags v58 = v45;
      CMTimeFlags v57 = v45;
      CMTimeEpoch v59 = v36;
    }
    if (v115)
    {
      CMTimeValue v198 = *v106;
      CMTimeScale v199 = *(_DWORD *)(v115 + 224);
      CMTimeFlags v135 = *(_DWORD *)(v115 + 228);
      CMTimeEpoch v125 = *(void *)(v115 + 232);
    }
    else
    {
      CMTimeValue v198 = v200;
      CMTimeScale v199 = v201;
      CMTimeFlags v135 = v57;
      CMTimeEpoch v125 = v59;
    }
    if (!*(unsigned char *)(a1 + 184))
    {
      float v140 = 0.0;
      memset(&refcon, 0, sizeof(refcon));
      memset(&time1, 0, sizeof(time1));
      if (CMBufferQueueIsEmpty(*(CMBufferQueueRef *)(a1 + 72)))
      {
        time1.unsigned int value = v202;
        time1.CMTimeScale timescale = timescale;
        time1.CMTimeFlags flags = v58;
        time1.CMTimeEpoch epoch = v36;
      }
      else
      {
        CMBufferQueueGetMinPresentationTimeStamp(&time1, *(CMBufferQueueRef *)(a1 + 72));
      }
      *(CMTime *)(a1 + 192) = time1;
      fpfs_GetStartupDurationOfType((CMTime *)a1, (uint64_t)&v139);
      CMTime time2 = time1;
      CMTimeAdd(&refcon, &time2, &v139);
      CMTime time2 = refcon;
      CMTime dictionaryRepresentation = v146;
      CMTimeSubtract(&v152, &time2, &dictionaryRepresentation);
      uint64_t v60 = (1 << *(unsigned char *)(a1 + 180));
      CMTime time2 = v152;
      CMTime dictionaryRepresentation = v147;
      unsigned int v61 = fpfs_CheckCanKeepUp(v43, (uint64_t)&time2, &dictionaryRepresentation, v60, 0, &v140, 0, 0);
      uint64_t v21 = v110 == v116 ? v140 >= 1.0 : v61;
      if (v21) {
        goto LABEL_174;
      }
    }
    if ((v105 & 1) == 0 && (*(unsigned char *)(v115 + 182) || fpfsi_TrialSwitchDownInProgress(v35)))
    {
      refcon.unsigned int value = v200;
      refcon.CMTimeScale timescale = v201;
      refcon.CMTimeFlags flags = v57;
      refcon.CMTimeEpoch epoch = v59;
      time1.unsigned int value = v198;
      time1.CMTimeScale timescale = v199;
      time1.CMTimeFlags flags = v135;
      time1.CMTimeEpoch epoch = v125;
      uint64_t v21 = fpfs_TimeIsAtOrAfter(v114, &refcon, &time1);
LABEL_174:
      if (v21 && v110 == v116)
      {
        if (fpfsi_TrialSwitchDownInProgress(v35))
        {
          refcon.unsigned int value = v200;
          refcon.CMTimeScale timescale = v201;
          refcon.CMTimeFlags flags = v57;
          refcon.CMTimeEpoch epoch = v59;
          time1.unsigned int value = v198;
          time1.CMTimeScale timescale = v199;
          time1.CMTimeFlags flags = v135;
          time1.CMTimeEpoch epoch = v125;
          uint64_t CanSwitchDownConcurrentlyWithoutStall = fpfs_TimeIsAtOrAfter(v114, &refcon, &time1);
        }
        else
        {
          uint64_t v63 = *(void *)(v35 + 96);
          CMTime refcon = v152;
          uint64_t CanSwitchDownConcurrentlyWithoutStall = FigAlternatePlaybackBitrateMonitorCanSwitchDownConcurrentlyWithoutStall(v63, &refcon);
        }
        uint64_t v21 = CanSwitchDownConcurrentlyWithoutStall;
      }
      goto LABEL_180;
    }
    uint64_t v21 = 0;
LABEL_180:
    CMTimeFlags v45 = v58;
    int v34 = (CMTime *)(a1 + 272);
    int v44 = v133;
LABEL_181:
    if (v21) {
      unsigned int v64 = 1;
    }
    else {
      unsigned int v64 = 3;
    }
    if (v64 <= dword_1E9350BB0)
    {
      CMTimeFlags v126 = v45;
      LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(dictionaryRepresentation.CFDictionarySetValue(theDict, key, value) = 0;
      char v65 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      unsigned int v66 = time2.value;
      if (os_log_type_enabled(v65, dictionaryRepresentation.value)) {
        unsigned int v67 = v66;
      }
      else {
        unsigned int v67 = v66 & 0xFFFFFFFE;
      }
      if (v67)
      {
        uint64_t v68 = *(void *)v35;
        if (*(void *)v35) {
          int v69 = (const char *)(CMBaseObjectGetDerivedStorage() + 824);
        }
        else {
          int v69 = "";
        }
        __int16 v121 = v69;
        if (v43) {
          __int16 v70 = (const char *)(CMBaseObjectGetDerivedStorage() + 3080);
        }
        else {
          __int16 v70 = "";
        }
        uint64_t v119 = v70;
        int v101 = *(_DWORD *)(v35 + 160);
        int v102 = *(_DWORD *)(a1 + 16);
        CMTime refcon = v146;
        Float64 v71 = CMTimeGetSeconds(&refcon);
        refcon.unsigned int value = v202;
        refcon.CMTimeScale timescale = timescale;
        refcon.CMTimeFlags flags = v126;
        refcon.CMTimeEpoch epoch = v130;
        Float64 v72 = CMTimeGetSeconds(&refcon);
        *(_OWORD *)&refcon.unsigned int value = *(_OWORD *)v107;
        refcon.CMTimeEpoch epoch = *(void *)(a1 + 232);
        Float64 v73 = CMTimeGetSeconds(&refcon);
        if (v115)
        {
          *(_OWORD *)&refcon.unsigned int value = *(_OWORD *)v106;
          refcon.CMTimeEpoch epoch = *(void *)(v115 + 232);
          Float64 v74 = CMTimeGetSeconds(&refcon);
        }
        else
        {
          Float64 v74 = -1.0;
        }
        CMTime refcon = v150;
        Float64 v75 = CMTimeGetSeconds(&refcon);
        CMTime refcon = v147;
        Float64 v76 = CMTimeGetSeconds(&refcon);
        BOOL CanRenderVideo = fpfs_CanRenderVideo(v114, v43);
        LODWORD(refcon.CFDictionarySetValue(theDict, key, value) = 136319234;
        __int16 v78 = "finishing";
        if (!v21) {
          __int16 v78 = "not ok";
        }
        *(CMTimeValue *)((char *)&refcon.value + 4) = (CMTimeValue)"fpfs_CheckVideoSyncQueue";
        LOWORD(refcon.flags) = 2048;
        *(void *)((char *)&refcon.flags + 2) = v68;
        HIWORD(refcon.epoch) = 2082;
        *(void *)int v164 = v121;
        *(_WORD *)&v164[8] = 2048;
        *(void *)&v164[10] = v43;
        *(_WORD *)&v164[18] = 2082;
        *(void *)&v164[20] = v119;
        *(_WORD *)&v164[28] = 1024;
        *(_DWORD *)&v164[30] = v101;
        *(_WORD *)&v164[34] = 1024;
        *(_DWORD *)&v164[36] = v102;
        *(_WORD *)__int16 v165 = 2048;
        *(Float64 *)&v165[2] = v71;
        __int16 v166 = 2048;
        Float64 v167 = v72;
        __int16 v168 = 2048;
        Float64 v169 = v73;
        __int16 v170 = 2048;
        Float64 v171 = v74;
        __int16 v172 = 2048;
        Float64 v173 = v75;
        __int16 v174 = 2048;
        Float64 v175 = v76;
        __int16 v176 = 1024;
        BOOL v177 = CanRenderVideo;
        __int16 v178 = 1024;
        BOOL v179 = v113;
        __int16 v180 = 1024;
        BOOL v181 = v104;
        __int16 v182 = 2082;
        uint64_t v183 = v78;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      CMTimeFlags v45 = v126;
      int v34 = (CMTime *)(a1 + 272);
      int v44 = v133;
    }
    if (v21) {
      break;
    }
    if (*(unsigned char *)(a1 + 183)) {
      goto LABEL_238;
    }
    int v134 = 0;
    CMTimeValue v202 = *MEMORY[0x1E4F1F9F8];
    CMTimeScale timescale = *(_DWORD *)(MEMORY[0x1E4F1F9F8] + 8);
    CMTimeFlags v45 = v108;
    CMTimeEpoch v36 = epoch;
  }
  if ((v103 & 1) == 0)
  {
    CMTimeValue v83 = v202;
    v34->unsigned int value = v202;
    CMTimeScale v84 = timescale;
    v34->CMTimeScale timescale = timescale;
    *(_DWORD *)(a1 + 284) = v45;
    *(void *)(a1 + 288) = v130;
    *(void *)&long long v156 = v83;
    *((void *)&v156 + 1) = __PAIR64__(v45, v84);
    *(void *)&v157[0] = v130;
    goto LABEL_241;
  }
LABEL_240:
  uint64_t v21 = 0;
LABEL_241:
  if ((BYTE4(v155[1]) & 0x1D) != 1)
  {
    *(_OWORD *)((char *)v155 + 8) = v137;
    *((void *)&v155[1] + 1) = epoch;
  }
  if ((_BYTE)v44)
  {
    for (uint64_t i = (opaqueCMSampleBuffer *)CMBufferQueueGetHead(*(CMBufferQueueRef *)(a1 + 72));
          i;
          uint64_t i = (opaqueCMSampleBuffer *)CMBufferQueueGetHead(*(CMBufferQueueRef *)(a1 + 72)))
    {
      CMSampleBufferGetOutputPresentationTimeStamp(&refcon, i);
      CMTimeValue v202 = refcon.value;
      CMTimeFlags v97 = refcon.flags;
      CMTimeScale timescale = refcon.timescale;
      CMTimeEpoch v98 = refcon.epoch;
      *(_OWORD *)&time1.unsigned int value = v156;
      time1.CMTimeEpoch epoch = *(void *)&v157[0];
      if ((CMTimeCompare(&refcon, &time1) & 0x80000000) == 0) {
        break;
      }
      refcon.unsigned int value = v202;
      refcon.CMTimeScale timescale = timescale;
      refcon.CMTimeFlags flags = v97;
      refcon.CMTimeEpoch epoch = v98;
      CMTime time1 = *(CMTime *)((char *)v155 + 8);
      if ((CMTimeCompare(&refcon, &time1) & 0x80000000) == 0) {
        break;
      }
      CMBufferRef v99 = CMBufferQueueDequeueAndRetain(*(CMBufferQueueRef *)(a1 + 72));
      if (v99) {
        CFRelease(v99);
      }
    }
  }
  return v21;
}