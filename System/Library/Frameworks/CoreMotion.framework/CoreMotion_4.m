void sub_190458170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  sub_19039A590((PB::Base *)&a9);
  sub_1904373C8(v9 - 72);
  _Unwind_Resume(a1);
}

uint64_t sub_19045818C()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  v2 = v1;
  v3 = (uint64_t *)v0;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = v0 + 8;
  uint64_t v4 = *(void *)(v0 + 8);
  uint64_t v20 = v0 + 8;
  (*(void (**)(uint64_t))(v4 + 16))(v0 + 8);
  __int16 v21 = 256;
  if (*v3)
  {
    sub_190395088(v16);
    sub_1903AD710((uint64_t)v16);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    v19 |= 1u;
    CFAbsoluteTime v17 = Current;
    uint64_t v7 = v18;
    uint64_t v8 = mach_absolute_time();
    double v9 = sub_1902D8D34(v8);
    *(unsigned char *)(v7 + 24) |= 1u;
    *(double *)(v7 + 16) = v9;
    uint64_t v10 = v18;
    sub_1902C3F54(buf, v2);
    uint64_t v11 = *(void *)(v10 + 8);
    if (!v11) {
      operator new();
    }
    if (*(char *)(v11 + 23) < 0) {
      operator delete(*(void **)v11);
    }
    long long v12 = *(_OWORD *)buf;
    *(void *)(v11 + 16) = *(void *)&buf[16];
    *(_OWORD *)uint64_t v11 = v12;
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1580);
    }
    v13 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136380931;
      *(void *)&buf[4] = v2;
      *(_WORD *)&buf[12] = 2049;
      *(CFAbsoluteTime *)&buf[14] = v17;
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_INFO, "[CMSpatialLogger] Logging event: %{private}s timestamp: %{private}f", buf, 0x16u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1580);
      }
      int v22 = 136380931;
      v23 = v2;
      __int16 v24 = 2049;
      CFAbsoluteTime v25 = v17;
      v15 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMSpatialLogger::logEvent(const char *const)", "CoreLocation: %s\n", v15);
      if (v15 != buf) {
        free(v15);
      }
    }
    sub_190387314(*v3, (uint64_t)v16);
    sub_19039A590((PB::Base *)v16);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
}

void sub_1904584B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_19039A590((PB::Base *)va);
  sub_1904373C8((uint64_t)&STACK[0xE38]);
  _Unwind_Resume(a1);
}

uint64_t sub_190458500(uint64_t *a1, int *a2)
{
  uint64_t v5 = a1 + 1;
  uint64_t v4 = a1[1];
  v50 = a1 + 1;
  (*(void (**)(uint64_t *))(v4 + 16))(a1 + 1);
  __int16 v52 = 256;
  if (*a1)
  {
    sub_190395088(v47);
    sub_1903AD8C0((uint64_t)v47);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    v49 |= 1u;
    *(CFAbsoluteTime *)&v47[77] = Current;
    uint64_t v7 = v48;
    int v8 = *a2;
    *(_DWORD *)(v48 + 116) |= 0x10000u;
    *(_DWORD *)(v7 + 92) = v8;
    uint64_t v9 = v48;
    int v10 = a2[4];
    *(_DWORD *)(v48 + 116) |= 0x200u;
    *(_DWORD *)(v9 + 64) = v10;
    uint64_t v11 = v48;
    int v12 = a2[1];
    *(_DWORD *)(v48 + 116) |= 0x20u;
    *(_DWORD *)(v11 + 48) = v12;
    uint64_t v13 = v48;
    int v14 = a2[2];
    *(_DWORD *)(v48 + 116) |= 0x2000u;
    *(_DWORD *)(v13 + 80) = v14;
    uint64_t v15 = v48;
    int v16 = a2[3];
    *(_DWORD *)(v48 + 116) |= 0x400u;
    *(_DWORD *)(v15 + 68) = v16;
    uint64_t v17 = v48;
    LOBYTE(v16) = *((unsigned char *)a2 + 32);
    *(_DWORD *)(v48 + 116) |= 0x100000u;
    *(unsigned char *)(v17 + 108) = v16;
    uint64_t v18 = v48;
    LODWORD(Current) = a2[9];
    *(_DWORD *)(v48 + 116) |= 0x8000u;
    *(_DWORD *)(v18 + 88) = LODWORD(Current);
    uint64_t v19 = v48;
    uint64_t v20 = *((void *)a2 + 5);
    *(_DWORD *)(v48 + 116) |= 4u;
    *(void *)(v19 + 24) = v20;
    uint64_t v21 = v48;
    LOBYTE(v16) = *((unsigned char *)a2 + 48);
    *(_DWORD *)(v48 + 116) |= 0x200000u;
    *(unsigned char *)(v21 + 109) = v16;
    uint64_t v22 = v48;
    int v23 = a2[13];
    *(_DWORD *)(v48 + 116) |= 0x100u;
    *(_DWORD *)(v22 + 60) = v23;
    uint64_t v24 = v48;
    uint64_t v25 = *((void *)a2 + 7);
    *(_DWORD *)(v48 + 116) |= 1u;
    *(void *)(v24 + 8) = v25;
    uint64_t v26 = v48;
    uint64_t v27 = *((void *)a2 + 10);
    *(_DWORD *)(v48 + 116) |= 2u;
    *(void *)(v26 + 16) = v27;
    uint64_t v28 = v48;
    int v29 = a2[22];
    *(_DWORD *)(v48 + 116) |= 0x1000u;
    *(_DWORD *)(v28 + 76) = v29;
    uint64_t v30 = v48;
    int v31 = a2[23];
    *(_DWORD *)(v48 + 116) |= 0x800u;
    *(_DWORD *)(v30 + 72) = v31;
    uint64_t v32 = v48;
    LOBYTE(v31) = a2[24] & 1;
    *(_DWORD *)(v48 + 116) |= 0x2000000u;
    *(unsigned char *)(v32 + 113) = v31;
    uint64_t v33 = v48;
    LOBYTE(v31) = (a2[24] & 2) != 0;
    *(_DWORD *)(v48 + 116) |= 0x1000000u;
    *(unsigned char *)(v33 + 112) = v31;
    uint64_t v34 = v48;
    LOBYTE(v31) = (a2[24] & 4) != 0;
    *(_DWORD *)(v48 + 116) |= 0x400000u;
    *(unsigned char *)(v34 + 110) = v31;
    uint64_t v35 = v48;
    LOBYTE(v31) = (a2[24] & 8) != 0;
    *(_DWORD *)(v48 + 116) |= 0x4000000u;
    *(unsigned char *)(v35 + 114) = v31;
    uint64_t v36 = v48;
    LOBYTE(v31) = (a2[24] & 0x10) != 0;
    *(_DWORD *)(v48 + 116) |= 0x800000u;
    *(unsigned char *)(v36 + 111) = v31;
    uint64_t v37 = v48;
    int v38 = a2[25];
    *(_DWORD *)(v48 + 116) |= 0x40000u;
    *(_DWORD *)(v37 + 100) = v38;
    uint64_t v39 = v48;
    int v40 = a2[26];
    *(_DWORD *)(v48 + 116) |= 0x80000u;
    *(_DWORD *)(v39 + 104) = v40;
    uint64_t v41 = v48;
    uint64_t v42 = *((void *)a2 + 14);
    *(_DWORD *)(v48 + 116) |= 8u;
    *(void *)(v41 + 32) = v42;
    uint64_t v43 = v48;
    uint64_t v44 = *((void *)a2 + 15);
    *(_DWORD *)(v48 + 116) |= 0x10u;
    *(void *)(v43 + 40) = v44;
    uint64_t v45 = v48;
    LODWORD(v44) = a2[32];
    *(_DWORD *)(v48 + 116) |= 0x20000u;
    *(_DWORD *)(v45 + 96) = v44;
    sub_190387314(*a1, (uint64_t)v47);
    uint64_t result = sub_19039A590((PB::Base *)v47);
    if (!HIBYTE(v52)) {
      return result;
    }
    if ((_BYTE)v52) {
      return pthread_mutex_unlock(v51);
    }
    uint64_t v5 = v50;
  }
  return (*(uint64_t (**)(uint64_t *))(*v5 + 24))(v5);
}

void sub_19045884C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_19039A590((PB::Base *)&a9);
  sub_1904373C8(v9 - 56);
  _Unwind_Resume(a1);
}

uint64_t sub_190458868(uint64_t *a1, int *a2)
{
  uint64_t v5 = a1 + 1;
  uint64_t v4 = a1[1];
  v75 = a1 + 1;
  (*(void (**)(uint64_t *))(v4 + 16))(a1 + 1);
  __int16 v76 = 256;
  if (*a1)
  {
    sub_190395088(v71);
    sub_1903AED00((uint64_t)v71);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    v74 |= 1u;
    CFAbsoluteTime v73 = Current;
    sub_19034FB00(v72);
    uint64_t v7 = *(void *)(v72 + 32);
    int v8 = *a2;
    *(unsigned char *)(v7 + 32) |= 2u;
    *(_DWORD *)(v7 + 28) = v8;
    uint64_t v9 = *(void *)(v72 + 32);
    sub_190437600(v9);
    std::string::operator=(*(std::string **)(v9 + 8), (const std::string *)(a2 + 2));
    uint64_t v10 = *(void *)(v72 + 32);
    sub_190437674(v10);
    std::string::operator=(*(std::string **)(v10 + 16), (const std::string *)(a2 + 8));
    uint64_t v11 = *(void *)(v72 + 32);
    int v12 = a2[14];
    *(unsigned char *)(v11 + 32) |= 1u;
    *(_DWORD *)(v11 + 24) = v12;
    uint64_t v13 = v72;
    LOBYTE(v12) = *((unsigned char *)a2 + 76);
    *(unsigned char *)(v72 + 44) |= 1u;
    *(unsigned char *)(v13 + 40) = v12;
    int v14 = (void *)v72;
    int v15 = a2[20];
    int v16 = *(char **)(v72 + 16);
    unint64_t v17 = *(void *)(v72 + 24);
    if ((unint64_t)v16 >= v17)
    {
      uint64_t v19 = *(char **)(v72 + 8);
      uint64_t v20 = (v16 - v19) >> 2;
      if ((unint64_t)(v20 + 1) >> 62) {
        sub_1903479E8();
      }
      unint64_t v21 = v17 - (void)v19;
      unint64_t v22 = (uint64_t)(v17 - (void)v19) >> 1;
      if (v22 <= v20 + 1) {
        unint64_t v22 = v20 + 1;
      }
      if (v21 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v22;
      }
      if (v23)
      {
        uint64_t v24 = (char *)sub_190347D04(v72 + 24, v23);
        uint64_t v19 = (char *)v14[1];
        int v16 = (char *)v14[2];
      }
      else
      {
        uint64_t v24 = 0;
      }
      uint64_t v25 = &v24[4 * v20];
      uint64_t v26 = &v24[4 * v23];
      *(_DWORD *)uint64_t v25 = v15;
      uint64_t v18 = v25 + 4;
      while (v16 != v19)
      {
        int v27 = *((_DWORD *)v16 - 1);
        v16 -= 4;
        *((_DWORD *)v25 - 1) = v27;
        v25 -= 4;
      }
      v14[1] = v25;
      v14[2] = v18;
      v14[3] = v26;
      if (v19) {
        operator delete(v19);
      }
    }
    else
    {
      *(_DWORD *)int v16 = v15;
      uint64_t v18 = v16 + 4;
    }
    v14[2] = v18;
    uint64_t v28 = (void *)v72;
    int v29 = a2[21];
    uint64_t v30 = *(char **)(v72 + 16);
    unint64_t v31 = *(void *)(v72 + 24);
    if ((unint64_t)v30 >= v31)
    {
      uint64_t v33 = *(char **)(v72 + 8);
      uint64_t v34 = (v30 - v33) >> 2;
      if ((unint64_t)(v34 + 1) >> 62) {
        sub_1903479E8();
      }
      unint64_t v35 = v31 - (void)v33;
      unint64_t v36 = (uint64_t)(v31 - (void)v33) >> 1;
      if (v36 <= v34 + 1) {
        unint64_t v36 = v34 + 1;
      }
      if (v35 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v37 = v36;
      }
      if (v37)
      {
        int v38 = (char *)sub_190347D04(v72 + 24, v37);
        uint64_t v33 = (char *)v28[1];
        uint64_t v30 = (char *)v28[2];
      }
      else
      {
        int v38 = 0;
      }
      uint64_t v39 = &v38[4 * v34];
      int v40 = &v38[4 * v37];
      *(_DWORD *)uint64_t v39 = v29;
      uint64_t v32 = v39 + 4;
      while (v30 != v33)
      {
        int v41 = *((_DWORD *)v30 - 1);
        v30 -= 4;
        *((_DWORD *)v39 - 1) = v41;
        v39 -= 4;
      }
      v28[1] = v39;
      v28[2] = v32;
      v28[3] = v40;
      if (v33) {
        operator delete(v33);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v30 = v29;
      uint64_t v32 = v30 + 4;
    }
    v28[2] = v32;
    uint64_t v42 = (void *)v72;
    int v43 = a2[22];
    uint64_t v44 = *(char **)(v72 + 16);
    unint64_t v45 = *(void *)(v72 + 24);
    if ((unint64_t)v44 >= v45)
    {
      v47 = *(char **)(v72 + 8);
      uint64_t v48 = (v44 - v47) >> 2;
      if ((unint64_t)(v48 + 1) >> 62) {
        sub_1903479E8();
      }
      unint64_t v49 = v45 - (void)v47;
      unint64_t v50 = (uint64_t)(v45 - (void)v47) >> 1;
      if (v50 <= v48 + 1) {
        unint64_t v50 = v48 + 1;
      }
      if (v49 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v51 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v51 = v50;
      }
      if (v51)
      {
        __int16 v52 = (char *)sub_190347D04(v72 + 24, v51);
        v47 = (char *)v42[1];
        uint64_t v44 = (char *)v42[2];
      }
      else
      {
        __int16 v52 = 0;
      }
      v53 = &v52[4 * v48];
      v54 = &v52[4 * v51];
      *(_DWORD *)v53 = v43;
      v46 = v53 + 4;
      while (v44 != v47)
      {
        int v55 = *((_DWORD *)v44 - 1);
        v44 -= 4;
        *((_DWORD *)v53 - 1) = v55;
        v53 -= 4;
      }
      v42[1] = v53;
      v42[2] = v46;
      v42[3] = v54;
      if (v47) {
        operator delete(v47);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v44 = v43;
      v46 = v44 + 4;
    }
    v42[2] = v46;
    v56 = (void *)v72;
    int v57 = a2[23];
    v58 = *(char **)(v72 + 16);
    unint64_t v59 = *(void *)(v72 + 24);
    if ((unint64_t)v58 >= v59)
    {
      v61 = *(char **)(v72 + 8);
      uint64_t v62 = (v58 - v61) >> 2;
      if ((unint64_t)(v62 + 1) >> 62) {
        sub_1903479E8();
      }
      unint64_t v63 = v59 - (void)v61;
      unint64_t v64 = (uint64_t)(v59 - (void)v61) >> 1;
      if (v64 <= v62 + 1) {
        unint64_t v64 = v62 + 1;
      }
      if (v63 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v65 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v65 = v64;
      }
      if (v65)
      {
        v66 = (char *)sub_190347D04(v72 + 24, v65);
        v61 = (char *)v56[1];
        v58 = (char *)v56[2];
      }
      else
      {
        v66 = 0;
      }
      v67 = &v66[4 * v62];
      v68 = &v66[4 * v65];
      *(_DWORD *)v67 = v57;
      v60 = v67 + 4;
      while (v58 != v61)
      {
        int v69 = *((_DWORD *)v58 - 1);
        v58 -= 4;
        *((_DWORD *)v67 - 1) = v69;
        v67 -= 4;
      }
      v56[1] = v67;
      v56[2] = v60;
      v56[3] = v68;
      if (v61) {
        operator delete(v61);
      }
    }
    else
    {
      *(_DWORD *)v58 = v57;
      v60 = v58 + 4;
    }
    v56[2] = v60;
    sub_190387314(*a1, (uint64_t)v71);
    sub_19039A590((PB::Base *)v71);
  }
  return (*(uint64_t (**)(uint64_t *))(*v5 + 24))(v5);
}

void sub_190458CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_19039A590((PB::Base *)&a9);
  sub_1904373C8(v9 - 88);
  _Unwind_Resume(a1);
}

uint64_t sub_190458D1C(uint64_t *a1, char *a2, double a3)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  unint64_t v17 = a1 + 1;
  (*(void (**)(uint64_t *))(v6 + 16))(a1 + 1);
  __int16 v18 = 256;
  if (*a1)
  {
    sub_190395088(v14);
    sub_1903AD950((uint64_t)v14);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    v16 |= 1u;
    *(CFAbsoluteTime *)&v14[77] = Current;
    uint64_t v9 = v15;
    sub_1902C3F54(&__p, a2);
    sub_190458E80(v9, &__p);
    if (v13 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
    uint64_t v10 = v15;
    *(unsigned char *)(v15 + 24) |= 1u;
    *(double *)(v10 + 16) = a3;
    sub_190387314(*a1, (uint64_t)v14);
    sub_19039A590((PB::Base *)v14);
  }
  return (*(uint64_t (**)(uint64_t *))(*v7 + 24))(v7);
}

void sub_190458E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_19039A590((PB::Base *)&a16);
  sub_1904373C8(v16 - 88);
  _Unwind_Resume(a1);
}

__n128 sub_190458E80(uint64_t a1, __n128 *a2)
{
  sub_190437600(a1);
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(char *)(v4 + 23) < 0) {
    operator delete(*(void **)v4);
  }
  __n128 result = *a2;
  *(void *)(v4 + 16) = a2[1].n128_u64[0];
  *(__n128 *)uint64_t v4 = result;
  a2[1].n128_u8[7] = 0;
  a2->n128_u8[0] = 0;
  return result;
}

uint64_t sub_190458ED4(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = a1 + 1;
  uint64_t v4 = a1[1];
  uint64_t v32 = a1 + 1;
  (*(void (**)(uint64_t *))(v4 + 16))(a1 + 1);
  __int16 v34 = 256;
  if (*a1)
  {
    sub_190395088(v29);
    sub_1903AED90((uint64_t)v29);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    v31 |= 1u;
    *(CFAbsoluteTime *)&v29[77] = Current;
    uint64_t v7 = v30;
    LODWORD(Current) = *(_DWORD *)a2;
    *(_WORD *)(v30 + 60) |= 8u;
    *(_DWORD *)(v7 + 24) = LODWORD(Current);
    uint64_t v8 = v30;
    LODWORD(Current) = *(_DWORD *)(a2 + 4);
    *(_WORD *)(v30 + 60) |= 0x10u;
    *(_DWORD *)(v8 + 28) = LODWORD(Current);
    uint64_t v9 = v30;
    LODWORD(Current) = *(_DWORD *)(a2 + 8);
    *(_WORD *)(v30 + 60) |= 0x20u;
    *(_DWORD *)(v9 + 32) = LODWORD(Current);
    uint64_t v10 = v30;
    LODWORD(Current) = *(_DWORD *)(a2 + 12);
    *(_WORD *)(v30 + 60) |= 0x40u;
    *(_DWORD *)(v10 + 36) = LODWORD(Current);
    uint64_t v11 = v30;
    LODWORD(Current) = *(_DWORD *)(a2 + 16);
    *(_WORD *)(v30 + 60) |= 0x200u;
    *(_DWORD *)(v11 + 48) = LODWORD(Current);
    uint64_t v12 = v30;
    LODWORD(Current) = *(_DWORD *)(a2 + 20);
    *(_WORD *)(v30 + 60) |= 0x100u;
    *(_DWORD *)(v12 + 44) = LODWORD(Current);
    uint64_t v13 = v30;
    LODWORD(Current) = *(_DWORD *)(a2 + 24);
    *(_WORD *)(v30 + 60) |= 0x400u;
    *(_DWORD *)(v13 + 52) = LODWORD(Current);
    uint64_t v14 = v30;
    char v15 = *(unsigned char *)(a2 + 28);
    *(_WORD *)(v30 + 60) |= 0x4000u;
    *(unsigned char *)(v14 + 59) = v15;
    uint64_t v16 = v30;
    char v17 = *(unsigned char *)(a2 + 29);
    *(_WORD *)(v30 + 60) |= 0x2000u;
    *(unsigned char *)(v16 + 58) = v17;
    uint64_t v18 = v30;
    char v19 = *(unsigned char *)(a2 + 30);
    *(_WORD *)(v30 + 60) |= 0x1000u;
    *(unsigned char *)(v18 + 57) = v19;
    uint64_t v20 = v30;
    char v21 = *(unsigned char *)(a2 + 40);
    *(_WORD *)(v30 + 60) |= 0x800u;
    *(unsigned char *)(v20 + 56) = v21;
    uint64_t v22 = v30;
    LODWORD(Current) = *(_DWORD *)(a2 + 44);
    *(_WORD *)(v30 + 60) |= 2u;
    *(_DWORD *)(v22 + 16) = LODWORD(Current);
    uint64_t v23 = v30;
    LODWORD(Current) = *(_DWORD *)(a2 + 48);
    *(_WORD *)(v30 + 60) |= 4u;
    *(_DWORD *)(v23 + 20) = LODWORD(Current);
    uint64_t v24 = v30;
    int v25 = *(_DWORD *)(a2 + 52);
    *(_WORD *)(v30 + 60) |= 0x80u;
    *(_DWORD *)(v24 + 40) = v25;
    uint64_t v26 = v30;
    uint64_t v27 = *(void *)(a2 + 32);
    *(_WORD *)(v30 + 60) |= 1u;
    *(void *)(v26 + 8) = v27;
    sub_190387314(*a1, (uint64_t)v29);
    uint64_t result = sub_19039A590((PB::Base *)v29);
    if (!HIBYTE(v34)) {
      return result;
    }
    if ((_BYTE)v34) {
      return pthread_mutex_unlock(v33);
    }
    uint64_t v5 = v32;
  }
  return (*(uint64_t (**)(uint64_t *))(*v5 + 24))(v5);
}

void sub_190459134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_19039A590((PB::Base *)&a9);
  sub_1904373C8(v9 - 56);
  _Unwind_Resume(a1);
}

void sub_190459150(uint64_t a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1580);
  }
  uint64_t v4 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67240192;
    int v8 = a2;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEBUG, "[CMSpatialLogger] logStepDetectionResult walking,%{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1580);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMSpatialLogger::logStepDetectionResult(BOOL)", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  if (*(unsigned char *)(a1 + 24))
  {
    if (a2) {
      SystemSoundID v5 = 1547;
    }
    else {
      SystemSoundID v5 = 1430;
    }
    AudioServicesPlaySystemSound(v5);
  }
}

uint64_t sub_19045931C(uint64_t *a1, int a2, double a3)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  uint64_t v16 = a1 + 1;
  (*(void (**)(uint64_t *))(v6 + 16))(a1 + 1);
  __int16 v17 = 256;
  if (*a1)
  {
    sub_190395088(v12);
    sub_1903AEE20((uint64_t)v12);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    v15 |= 1u;
    CFAbsoluteTime v14 = Current;
    uint64_t v9 = v13;
    *(unsigned char *)(v13 + 16) |= 1u;
    *(_DWORD *)(v9 + 8) = a2;
    uint64_t v10 = v13;
    *(float *)&CFAbsoluteTime Current = a3;
    *(unsigned char *)(v13 + 16) |= 2u;
    *(_DWORD *)(v10 + 12) = LODWORD(Current);
    sub_190387314(*a1, (uint64_t)v12);
    sub_19039A590((PB::Base *)v12);
  }
  return (*(uint64_t (**)(uint64_t *))(*v7 + 24))(v7);
}

void sub_19045942C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_19039A590((PB::Base *)&a9);
  sub_1904373C8(v9 - 72);
  _Unwind_Resume(a1);
}

uint64_t sub_190459448(uint64_t *a1, int a2, int a3, double a4)
{
  uint64_t v9 = a1 + 1;
  uint64_t v8 = a1[1];
  uint64_t v18 = a1 + 1;
  (*(void (**)(uint64_t *))(v8 + 16))(a1 + 1);
  __int16 v19 = 256;
  if (*a1)
  {
    sub_190395088(v15);
    sub_1903AEEB0((uint64_t)v15);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    v17 |= 1u;
    *(CFAbsoluteTime *)&v15[77] = Current;
    uint64_t v11 = v16;
    *(float *)&CFAbsoluteTime Current = a4;
    *(unsigned char *)(v16 + 20) |= 4u;
    *(_DWORD *)(v11 + 16) = LODWORD(Current);
    uint64_t v12 = v16;
    *(unsigned char *)(v16 + 20) |= 1u;
    *(_DWORD *)(v12 + 8) = a2;
    uint64_t v13 = v16;
    *(unsigned char *)(v16 + 20) |= 2u;
    *(_DWORD *)(v13 + 12) = a3;
    sub_190387314(*a1, (uint64_t)v15);
    sub_19039A590((PB::Base *)v15);
  }
  return (*(uint64_t (**)(uint64_t *))(*v9 + 24))(v9);
}

void sub_190459578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_19039A590((PB::Base *)&a9);
  sub_1904373C8(v9 - 88);
  _Unwind_Resume(a1);
}

uint64_t sub_190459594(uint64_t *a1, int a2)
{
  SystemSoundID v5 = a1 + 1;
  uint64_t v4 = a1[1];
  uint64_t v12 = a1 + 1;
  (*(void (**)(uint64_t *))(v4 + 16))(a1 + 1);
  __int16 v13 = 256;
  if (*a1)
  {
    sub_190395088(v9);
    sub_1903AEF40((uint64_t)v9);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    v11 |= 1u;
    *(CFAbsoluteTime *)&v9[77] = Current;
    uint64_t v7 = v10;
    *(unsigned char *)(v10 + 12) |= 1u;
    *(_DWORD *)(v7 + 8) = a2;
    sub_190387314(*a1, (uint64_t)v9);
    sub_19039A590((PB::Base *)v9);
  }
  return (*(uint64_t (**)(uint64_t *))(*v5 + 24))(v5);
}

void sub_190459680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_19039A590((PB::Base *)&a9);
  sub_1904373C8(v9 - 56);
  _Unwind_Resume(a1);
}

uint64_t sub_19045969C(uint64_t *a1, uint64_t *a2)
{
  SystemSoundID v5 = a1 + 1;
  uint64_t v4 = a1[1];
  char v21 = a1 + 1;
  (*(void (**)(uint64_t *))(v4 + 16))(a1 + 1);
  __int16 v22 = 256;
  if (*a1)
  {
    sub_190395088(v17);
    sub_1903AD560((uint64_t)v17);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    v20 |= 1u;
    CFAbsoluteTime v19 = Current;
    uint64_t v7 = v18;
    int v8 = *((unsigned __int16 *)a2 + 16);
    *(unsigned char *)(v18 + 32) |= 4u;
    *(_DWORD *)(v7 + 28) = v8;
    sub_19034D3D4(v18);
    uint64_t v9 = *(void *)(v18 + 8);
    uint64_t v10 = *a2;
    *(unsigned char *)(v9 + 32) |= 1u;
    *(void *)(v9 + 8) = v10;
    uint64_t v11 = *(void *)(v18 + 8);
    LODWORD(v10) = *((_DWORD *)a2 + 2);
    *(unsigned char *)(v11 + 32) |= 4u;
    *(_DWORD *)(v11 + 20) = v10;
    uint64_t v12 = *(void *)(v18 + 8);
    LODWORD(v10) = *((_DWORD *)a2 + 3);
    *(unsigned char *)(v12 + 32) |= 8u;
    *(_DWORD *)(v12 + 24) = v10;
    uint64_t v13 = *(void *)(v18 + 8);
    LODWORD(v10) = *((_DWORD *)a2 + 4);
    *(unsigned char *)(v13 + 32) |= 0x10u;
    *(_DWORD *)(v13 + 28) = v10;
    uint64_t v14 = v18;
    uint64_t v15 = a2[3];
    *(unsigned char *)(v18 + 32) |= 1u;
    *(void *)(v14 + 16) = v15;
    sub_190387314(*a1, (uint64_t)v17);
    sub_19039A590((PB::Base *)v17);
  }
  return (*(uint64_t (**)(uint64_t *))(*v5 + 24))(v5);
}

void sub_19045981C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_19039A590((PB::Base *)&a9);
  sub_1904373C8(v9 - 56);
  _Unwind_Resume(a1);
}

uint64_t sub_190459838(uint64_t *a1, uint64_t *a2)
{
  SystemSoundID v5 = a1 + 1;
  uint64_t v4 = a1[1];
  char v21 = a1 + 1;
  (*(void (**)(uint64_t *))(v4 + 16))(a1 + 1);
  __int16 v22 = 256;
  if (*a1)
  {
    sub_190395088(v17);
    sub_1903AD5F0((uint64_t)v17);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    v20 |= 1u;
    CFAbsoluteTime v19 = Current;
    uint64_t v7 = v18;
    int v8 = *((unsigned __int16 *)a2 + 16);
    *(unsigned char *)(v18 + 36) |= 4u;
    *(_DWORD *)(v7 + 28) = v8;
    sub_190350374(v18);
    uint64_t v9 = *(void *)(v18 + 8);
    uint64_t v10 = *a2;
    *(_WORD *)(v9 + 44) |= 1u;
    *(void *)(v9 + 8) = v10;
    uint64_t v11 = *(void *)(v18 + 8);
    LODWORD(v10) = *((_DWORD *)a2 + 2);
    *(_WORD *)(v11 + 44) |= 0x10u;
    *(_DWORD *)(v11 + 28) = v10;
    uint64_t v12 = *(void *)(v18 + 8);
    LODWORD(v10) = *((_DWORD *)a2 + 3);
    *(_WORD *)(v12 + 44) |= 0x20u;
    *(_DWORD *)(v12 + 32) = v10;
    uint64_t v13 = *(void *)(v18 + 8);
    LODWORD(v10) = *((_DWORD *)a2 + 4);
    *(_WORD *)(v13 + 44) |= 0x40u;
    *(_DWORD *)(v13 + 36) = v10;
    uint64_t v14 = v18;
    uint64_t v15 = a2[3];
    *(unsigned char *)(v18 + 36) |= 1u;
    *(void *)(v14 + 16) = v15;
    sub_190387314(*a1, (uint64_t)v17);
    sub_19039A590((PB::Base *)v17);
  }
  return (*(uint64_t (**)(uint64_t *))(*v5 + 24))(v5);
}

void sub_1904599B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_19039A590((PB::Base *)&a9);
  sub_1904373C8(v9 - 56);
  _Unwind_Resume(a1);
}

uint64_t sub_1904599D4()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  v2 = v1;
  v3 = (uint64_t *)v0;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = v0 + 8;
  uint64_t v4 = *(void *)(v0 + 8);
  uint64_t v22 = v0 + 8;
  (*(void (**)(uint64_t))(v4 + 16))(v0 + 8);
  __int16 v23 = 256;
  if (*v3)
  {
    if (v2[1] - *v2 == 16)
    {
      sub_190395088(buf);
      sub_1903AEBE0((uint64_t)buf);
      uint64_t v6 = v30;
      sub_1902C3F54(&v24, "00000000000000000000");
      uint64_t v7 = *(void *)(v6 + 8);
      if (!v7) {
        operator new();
      }
      if (*(char *)(v7 + 23) < 0) {
        operator delete(*(void **)v7);
      }
      long long v8 = v24;
      *(void *)(v7 + 16) = v25;
      *(_OWORD *)uint64_t v7 = v8;
      sub_190387314(*v3, (uint64_t)buf);
      uint64_t v9 = 0;
      __s[32] = 0;
      uint64_t v10 = *v2;
      do
      {
        int v11 = *v10++;
        snprintf(&__s[v9], 0x1FuLL, "%02x", v11);
        v9 += 2;
      }
      while (v9 != 32);
      sub_190395088(&v24);
      sub_1903AEC70((uint64_t)&v24);
      uint64_t v12 = v26;
      sub_1902C3F54(&v20, __s);
      uint64_t v13 = *(void *)(v12 + 8);
      if (!v13) {
        operator new();
      }
      if (*(char *)(v13 + 23) < 0) {
        operator delete(*(void **)v13);
      }
      long long v14 = v20;
      *(void *)(v13 + 16) = v21;
      *(_OWORD *)uint64_t v13 = v14;
      sub_190387314(*v3, (uint64_t)&v24);
      sub_19039A590((PB::Base *)&v24);
      sub_19039A590((PB::Base *)buf);
    }
    else
    {
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFD35E0);
      }
      uint64_t v15 = qword_1EB3BE830;
      if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
      {
        uint64_t v16 = (v2[1] - *v2) >> 2;
        *(_DWORD *)buf = 134217984;
        uint64_t v29 = v16;
        _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_ERROR, "[CMSpatialLogger] Incorrect gyro bias size %zu", buf, 0xCu);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE838 != -1) {
          dispatch_once(&qword_1EB3BE838, &unk_1EDFD35E0);
        }
        uint64_t v18 = (v2[1] - *v2) >> 2;
        LODWORD(v24) = 134217984;
        *(void *)((char *)&v24 + 4) = v18;
        CFAbsoluteTime v19 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "void CMSpatialLogger::logAudioAccessoryGyroBias(const std::vector<float> &)", "CoreLocation: %s\n", v19);
        if (v19 != (char *)buf) {
          free(v19);
        }
      }
    }
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
}

void sub_190459DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *__p, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1904373C8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_190459E20(void *a1, int a2)
{
  if (a2) {
    sub_1902E67BC(a1);
  }
  JUMPOUT(0x190459E18);
}

os_log_t sub_190459E30()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

os_log_t sub_190459E60()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1EB3BE830 = (uint64_t)result;
  return result;
}

uint64_t sub_190459E90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)a1 = 0;
  *(void *)(a1 + 8) = a3;
  *(unsigned char *)(a1 + 16) = 0;
  if (qword_1EB3BE898 != -1) {
    dispatch_once(&qword_1EB3BE898, &unk_1EDFC3788);
  }
  uint64_t v5 = off_1EB3BE890;
  if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v9 = a2;
    _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_INFO, "motion default ignored,'%{public}s'.", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFC3788);
    }
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CLMotionDefaultsWrite<long long>::CLMotionDefaultsWrite(const char *, const T &, const BOOL) [T = long long]", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  return a1;
}

uint64_t sub_19045A050(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a3;
  *(unsigned char *)(a1 + 8) = 0;
  if (qword_1EB3BE898 != -1) {
    dispatch_once(&qword_1EB3BE898, &unk_1EDFC3788);
  }
  uint64_t v5 = off_1EB3BE890;
  if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v9 = a2;
    _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_INFO, "motion default ignored,'%{public}s'.", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFC3788);
    }
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CLMotionDefaultsWrite<unsigned int>::CLMotionDefaultsWrite(const char *, const T &, const BOOL) [T = unsigned int]", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  return a1;
}

uint64_t sub_19045A210(uint64_t a1, uint64_t a2, long long *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)a1 = 0;
  if (*((char *)a3 + 23) < 0)
  {
    sub_190347AFC((unsigned char *)(a1 + 8), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    *(void *)(a1 + 24) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 8) = v5;
  }
  *(unsigned char *)(a1 + 32) = 0;
  if (qword_1EB3BE898 != -1) {
    dispatch_once(&qword_1EB3BE898, &unk_1EDFC3788);
  }
  uint64_t v6 = off_1EB3BE890;
  if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v10 = a2;
    _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_INFO, "motion default ignored,'%{public}s'.", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFC3788);
    }
    long long v8 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CLMotionDefaultsWrite<std::string>::CLMotionDefaultsWrite(const char *, const T &, const BOOL) [T = std::string]", "CoreLocation: %s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  return a1;
}

void sub_19045A400(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19045A420()
{
  uint64_t result = sub_1902B4534();
  if (result) {
    operator new();
  }
  return result;
}

void sub_19045A4A0()
{
}

void sub_19045A4B4(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  long long v8 = _os_activity_create(&dword_1902AF000, "CL: CLGyroBiasEstimatorClientRemote::registerWithGyroBiasEstimatorPrivate", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v8, &state);

  if (qword_1EB3BE858 != -1) {
    dispatch_once(&qword_1EB3BE858, &unk_1EDFD30C0);
  }
  uint64_t v9 = qword_1EB3BE850;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE850, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68290050;
    int v15 = 0;
    __int16 v16 = 2082;
    char v17 = "";
    __int16 v18 = 2082;
    CFAbsoluteTime v19 = "activity";
    __int16 v20 = 1026;
    int v21 = a3;
    __int16 v22 = 2050;
    uint64_t v23 = a1;
    __int16 v24 = 2050;
    uint64_t v25 = a4;
    _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGyroBiasEstimatorClientRemote::registerWithGyroBiasEstimatorPrivate\", \"event\":%{public, location:escape_only}s, \"isBuildingGYTT\":%{public}hhd, \"client\":\"%{public}p\", \"info\":\"%{public}p\"}", buf, 0x36u);
  }
  uint64_t v10 = *(NSObject **)(a1 + 16);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = sub_19045A81C;
  v11[3] = &unk_1E568D640;
  v11[4] = a1;
  v11[5] = a2;
  v11[6] = a4;
  char v12 = a3;
  dispatch_async(v10, v11);
  os_activity_scope_leave(&state);
}

void sub_19045A670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
}

void sub_19045A684(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  v2 = _os_activity_create(&dword_1902AF000, "CL: CLGyroBiasEstimatorClientRemote::unregisterWithGyroBiasEstimatorPrivate", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v2, &state);

  if (qword_1EB3BE858 != -1) {
    dispatch_once(&qword_1EB3BE858, &unk_1EDFD30C0);
  }
  v3 = qword_1EB3BE850;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE850, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289538;
    int v8 = 0;
    __int16 v9 = 2082;
    uint64_t v10 = "";
    __int16 v11 = 2082;
    char v12 = "activity";
    __int16 v13 = 2050;
    uint64_t v14 = a1;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGyroBiasEstimatorClientRemote::unregisterWithGyroBiasEstimatorPrivate\", \"event\":%{public, location:escape_only}s, \"client\":\"%{public}p\"}", buf, 0x26u);
  }
  uint64_t v4 = *(NSObject **)(a1 + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_19045B184;
  block[3] = &unk_1E568CF68;
  block[4] = a1;
  dispatch_async(v4, block);
  os_activity_scope_leave(&state);
}

void sub_19045A808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_19045A81C()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_19045AA18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, std::__shared_weak_count *a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a20) {
    sub_1902D8B58(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_19045AA9C(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v3 = *(CLConnectionMessage **)a2;
  uint64_t v4 = *(std::__shared_weak_count **)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void (**)(float *, uint64_t))(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  CFDictionaryRef Dictionary = (const __CFDictionary *)CLConnectionMessage::getDictionary(v3);
  sub_19045CAD8(v14, Dictionary);
  if ((*(int (**)(void *))(v14[0] + 856))(v14) <= 0)
  {
    if (qword_1EB3BE868 != -1) {
      dispatch_once(&qword_1EB3BE868, &unk_1EDFD33E0);
    }
    int v8 = qword_1EB3BE860;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE860, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "Could not get dictionary for message", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_19;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE868 != -1) {
      dispatch_once(&qword_1EB3BE868, &unk_1EDFD33E0);
    }
    LOWORD(v11[0]) = 0;
    __int16 v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "void CLGyroBiasEstimatorClientRemote::onGyroBiasEstimation(std::shared_ptr<CLConnectionMessage>, CLGyroBiasEstimatorClientCallback, void *)", "CoreLocation: %s\n", v9);
LABEL_25:
    if (v9 != (char *)buf) {
      free(v9);
    }
    goto LABEL_19;
  }
  if (sub_190538840(v11, &v12, &v13, (uint64_t)v14))
  {
    v6(v11, v5);
    goto LABEL_19;
  }
  if (qword_1EB3BE868 != -1) {
    dispatch_once(&qword_1EB3BE868, &unk_1EDFD33E0);
  }
  uint64_t v10 = qword_1EB3BE860;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE860, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_FAULT, "Message does not contain a valid gyro bias object", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE868 != -1) {
      dispatch_once(&qword_1EB3BE868, &unk_1EDFD33E0);
    }
    __int16 v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "void CLGyroBiasEstimatorClientRemote::onGyroBiasEstimation(std::shared_ptr<CLConnectionMessage>, CLGyroBiasEstimatorClientCallback, void *)", "CoreLocation: %s\n", v9);
    goto LABEL_25;
  }
LABEL_19:
  sub_19045CCC8(v14);
  if (v4) {
    sub_1902D8B58(v4);
  }
}

void sub_19045ADF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_19045CCC8((uint64_t *)va);
  if (v9) {
    sub_1902D8B58(v9);
  }
  _Unwind_Resume(a1);
}

void sub_19045AE28(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE868 != -1) {
    dispatch_once(&qword_1EB3BE868, &unk_1EDFD33E0);
  }
  v3 = qword_1EB3BE860;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE860, OS_LOG_TYPE_INFO))
  {
    uint64_t v4 = CLConnectionMessage::name(*a2);
    if (*(char *)(v4 + 23) >= 0) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = *(void *)v4;
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v8 = v5;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_INFO, "Default handler received message %s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE868 != -1) {
      dispatch_once(&qword_1EB3BE868, &unk_1EDFD33E0);
    }
    CLConnectionMessage::name(*a2);
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLGyroBiasEstimatorClientRemote::registerWithGyroBiasEstimatorPrivate(CLGyroBiasEstimatorClientCallback, BOOL, void *)_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
}

os_log_t sub_19045B008()
{
  os_log_t result = os_log_create("com.apple.locationd.Core", "Client");
  qword_1EB3BE850 = (uint64_t)result;
  return result;
}

void *sub_19045B038@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  os_log_t result = sub_19045B09C(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_19045B088(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_19045B09C(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_19045B110((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_19045B0FC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_19045B110(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_19045B168(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19045B184(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = *(void *)(v1 + 8);
  if (result)
  {
    uint64_t v3 = MEMORY[0x192FCC3F0]();
    uint64_t result = MEMORY[0x192FCC980](v3, 0xB0C40BC2CC919);
    *(void *)(v1 + 8) = 0;
  }
  return result;
}

void sub_19045B1C8(uint64_t a1, _OWORD *a2, long long *a3, unint64_t a4, float32x4_t a5)
{
  *(void *)&v63[813] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(unsigned __int16 *)(a1 + 10);
  uint64_t v10 = *(unsigned __int16 *)(a1 + 8);
  if (!*(_WORD *)(a1 + 10))
  {
LABEL_33:
    long long v49 = *a3;
    *(_OWORD *)&v63[1] = *a3;
    unint64_t v50 = *(unsigned int *)(a1 + 12);
    unint64_t v51 = v10 + (unint64_t)v9;
    if (v51 >= v50) {
      uint64_t v52 = *(unsigned int *)(a1 + 12);
    }
    else {
      uint64_t v52 = 0;
    }
    uint64_t v53 = a1 + 40 * (v51 - v52);
    *(_OWORD *)(v53 + 16) = *a2;
    *(_OWORD *)(v53 + 32) = v49;
    *(void *)(v53 + 48) = a4;
    if (v50 <= v9)
    {
      __int16 v54 = v10 + 1;
      if ((unint64_t)v10 + 1 >= v50) {
        __int16 v55 = v50;
      }
      else {
        __int16 v55 = 0;
      }
      *(_WORD *)(a1 + 8) = v54 - v55;
    }
    else
    {
      *(_WORD *)(a1 + 10) = v9 + 1;
    }
    return;
  }
  uint64_t v11 = a1 + 16;
  unint64_t v12 = v9 + v10 - 1;
  unint64_t v13 = *(unsigned int *)(a1 + 12);
  if (v12 < v13) {
    unint64_t v13 = 0;
  }
  unint64_t v14 = v12 - v13;
  uint64_t v15 = (float32x2_t *)(v11 + 40 * (v12 - v13));
  unint64_t v16 = (unint64_t)v15[4];
  if ((double)v16 + 3000.0 <= (double)a4)
  {
    double v25 = (double)(a4 - v16) / 1000000.0;
    a5.i32[1] = 1065646817;
    if (v25 <= 0.01)
    {
      __int32 v27 = v15[1].i32[1];
      a5.f32[0] = -v15[1].f32[0];
      *(float32x2_t *)v58 = vneg_f32(*v15);
      *(_DWORD *)&v58[8] = a5.i32[0];
      v59[0] = v27;
      float32x4_t v28 = sub_1902D9ACC((float32x4_t *)v58, a5);
      *(double *)v29.i64 = sub_1904CF3F4((uint64_t)a2, (float *)v58, (float32x4_t *)buf, v28);
      uint64_t v30 = (float32x2_t *)(v11 + 40 * v14);
      __int32 v31 = v30[3].i32[1];
      v29.f32[0] = -v30[3].f32[0];
      *(float32x2_t *)v57.f32 = vneg_f32(v30[2]);
      v57.i64[1] = __PAIR64__(v31, v29.u32[0]);
      float32x4_t v32 = sub_1902D9ACC(&v57, v29);
      sub_1904CF3F4((uint64_t)a3, v57.f32, (float32x4_t *)v58, v32);
      float v33 = v25;
      float v34 = sub_1904CF8B4((float32x4_t *)buf) / v33;
      float v36 = v35 / v33;
      float v38 = v37 / v33;
      float v39 = sub_1904CF8B4((float32x4_t *)v58) / v33;
      float v42 = v41 / v33;
      unint64_t v43 = *(unsigned int *)(a1 + 260);
      unint64_t v44 = *(unsigned __int16 *)(a1 + 256) + (unint64_t)*(unsigned __int16 *)(a1 + 258);
      if (v44 < v43) {
        unint64_t v43 = 0;
      }
      unint64_t v45 = (float *)(a1 + 256 + 24 * (v44 - v43));
      v45[2] = v34;
      v45[3] = v36;
      v45[4] = v38;
      v45[5] = v39;
      v45[6] = v42;
      v45[7] = v40 / v33;
      unsigned int v46 = *(unsigned __int16 *)(a1 + 258);
      unint64_t v47 = *(unsigned int *)(a1 + 260);
      if (v47 <= v46)
      {
        unint64_t v48 = *(unsigned __int16 *)(a1 + 256) + 1;
        if (v48 < v47) {
          LOWORD(v47) = 0;
        }
        *(_WORD *)(a1 + 256) = v48 - v47;
      }
      else
      {
        *(_WORD *)(a1 + 258) = v46 + 1;
      }
      LODWORD(v9) = *(unsigned __int16 *)(a1 + 10);
      LODWORD(v10) = *(unsigned __int16 *)(a1 + 8);
    }
    else
    {
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
      }
      uint64_t v26 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134349312;
        double v61 = v25;
        __int16 v62 = 2050;
        *(void *)unint64_t v63 = 0x3F847AE147AE147BLL;
        _os_log_impl(&dword_1902AF000, v26, OS_LOG_TYPE_ERROR, "Time interval between feeds is %{public}lf, max value is %{public}f", buf, 0x16u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
        }
        *(_DWORD *)v58 = 134349312;
        *(double *)&v58[4] = v25;
        LOWORD(v59[0]) = 2050;
        *(void *)((char *)v59 + 2) = 0x3F847AE147AE147BLL;
        v56 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMFwdPredictor::feed(const CMOQuaternion &, const CMOQuaternion &, const uint64_t)", "CoreLocation: %s\n", v56);
        if (v56 != (char *)buf) {
          free(v56);
        }
      }
      LODWORD(v10) = 0;
      LODWORD(v9) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 256) = 0;
    }
    goto LABEL_33;
  }
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
  }
  char v17 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
  {
    unint64_t v18 = *(unsigned __int16 *)(a1 + 8) + (unint64_t)*(unsigned __int16 *)(a1 + 10) - 1;
    unint64_t v19 = *(unsigned int *)(a1 + 12);
    if (v18 < v19) {
      unint64_t v19 = 0;
    }
    uint64_t v20 = *(void *)(v11 + 40 * (v18 - v19) + 32);
    *(_DWORD *)buf = 134349312;
    double v61 = *(double *)&a4;
    __int16 v62 = 2050;
    *(void *)unint64_t v63 = v20;
    _os_log_impl(&dword_1902AF000, v17, OS_LOG_TYPE_ERROR, "Timestamp %{public}llu not long enough since previous %{public}llu. Skipping this sample.", buf, 0x16u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
    }
    unint64_t v21 = *(unsigned __int16 *)(a1 + 8) + (unint64_t)*(unsigned __int16 *)(a1 + 10) - 1;
    unint64_t v22 = *(unsigned int *)(a1 + 12);
    if (v21 < v22) {
      unint64_t v22 = 0;
    }
    uint64_t v23 = *(void *)(v11 + 40 * (v21 - v22) + 32);
    *(_DWORD *)v58 = 134349312;
    *(void *)&v58[4] = a4;
    LOWORD(v59[0]) = 2050;
    *(void *)((char *)v59 + 2) = v23;
    __int16 v24 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMFwdPredictor::feed(const CMOQuaternion &, const CMOQuaternion &, const uint64_t)", "CoreLocation: %s\n", v24);
    if (v24 != (char *)buf) {
      free(v24);
    }
  }
}

void sub_19045B770(uint64_t a1@<X0>, unint64_t *a2@<X1>, float32x4_t *a3@<X8>, float32x4_t a4@<Q0>)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(unsigned __int16 *)(a1 + 10);
  if (*(_WORD *)(a1 + 10))
  {
    unint64_t v8 = *a2;
    uint64_t v9 = a1 + 16;
    unint64_t v10 = v5 + *(unsigned __int16 *)(a1 + 8) - 1;
    unint64_t v11 = *(unsigned int *)(a1 + 12);
    if (v10 >= v11) {
      uint64_t v12 = *(unsigned int *)(a1 + 12);
    }
    else {
      uint64_t v12 = 0;
    }
    unint64_t v13 = (float32x4_t *)(v9 + 40 * (v10 - v12));
    unint64_t v14 = v13[2].u64[0];
    if (v8 <= v14)
    {
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
      }
      __int16 v55 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
      {
        unint64_t v56 = *a2;
        unint64_t v57 = *(unsigned __int16 *)(a1 + 8) + (unint64_t)*(unsigned __int16 *)(a1 + 10) - 1;
        unint64_t v58 = *(unsigned int *)(a1 + 12);
        if (v57 < v58) {
          unint64_t v58 = 0;
        }
        uint64_t v59 = *(void *)(v9 + 40 * (v57 - v58) + 32);
        *(_DWORD *)buf = 134349312;
        *(void *)&uint8_t buf[4] = v56;
        __int16 v75 = 2050;
        uint64_t v76 = v59;
        _os_log_impl(&dword_1902AF000, v55, OS_LOG_TYPE_ERROR, "Prediction target timestamp %{public}llu must be after last timestamp in buffer %{public}llu", buf, 0x16u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
        }
        unint64_t v63 = *a2;
        unint64_t v64 = *(unsigned __int16 *)(a1 + 8) + (unint64_t)*(unsigned __int16 *)(a1 + 10) - 1;
        unint64_t v65 = *(unsigned int *)(a1 + 12);
        if (v64 < v65) {
          unint64_t v65 = 0;
        }
        uint64_t v66 = *(void *)(v9 + 40 * (v64 - v65) + 32);
        *(_DWORD *)v77 = 134349312;
        *(void *)&v77[4] = v63;
        *(_WORD *)&v77[12] = 2050;
        *(void *)&v77[14] = v66;
        v67 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "CMOQuaternion CMRelDMFwdPredictor::getPredictedRelAttitude(uint64_t &) const", "CoreLocation: %s\n", v67);
        if (v67 != buf) {
          free(v67);
        }
      }
      unint64_t v60 = *(unsigned __int16 *)(a1 + 8) + (unint64_t)*(unsigned __int16 *)(a1 + 10) - 1;
      unint64_t v61 = *(unsigned int *)(a1 + 12);
      if (v60 < v61) {
        unint64_t v61 = 0;
      }
      *a3 = *(float32x4_t *)(v9 + 40 * (v60 - v61));
    }
    else
    {
      *(double *)a4.i64 = (double)v8;
      if ((double)v14 + 100000.0 <= (double)v8) {
        *(double *)a4.i64 = (double)v14 + 100000.0;
      }
      *a2 = (unint64_t)*(double *)a4.i64;
      uint64_t v15 = v13[2].i64[0];
      a3->i64[0] = 0;
      a3->i64[1] = 0x3F80000000000000;
      if (v11 == v5)
      {
        double v16 = (double)((unint64_t)*(double *)a4.i64 - v15);
        sub_19045C03C(v77, (unint64_t *)a1, (unsigned __int16 *)(a1 + 256), 5 - *(void *)a1);
        sub_19045C03C(&v69, (unint64_t *)a1, (unsigned __int16 *)(a1 + 256), 4 - *(void *)a1);
        uint64_t v17 = *(void *)(sub_19045C34C((unsigned __int16 *)(a1 + 8), 5uLL) + 32);
        double v18 = (double)(unint64_t)(v17 - *(void *)(sub_19045C34C((unsigned __int16 *)(a1 + 8), 4uLL) + 32))
            / 1000000.0;
        if (v18 < 0.003)
        {
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
          }
          unint64_t v21 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 134349056;
            *(void *)&uint8_t buf[4] = 0x3F689374BC6A7EFALL;
            _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_INFO, "[CMRelDMFwdPredictor] dt is less than %{public}f.", buf, 0xCu);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
            }
            *(_DWORD *)CFAbsoluteTime v73 = 134349056;
            *(void *)&v73[4] = 0x3F689374BC6A7EFALL;
            v68 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "CMOQuaternion CMRelDMFwdPredictor::predictKinematics(const CFTimeInterval) const", "CoreLocation: %s\n", v68);
            if (v68 != buf) {
              free(v68);
            }
          }
          double v18 = 0.003;
        }
        uint64_t v22 = 0;
        *(float *)v20.i32 = v18;
        float32x2_t v23 = (float32x2_t)vdup_lane_s32(v20, 0);
        *(float32x2_t *)v19.i8 = vdiv_f32(vsub_f32(*(float32x2_t *)v77, v69), v23);
        *(void *)buf = v19.i64[0];
        float v24 = (float)(*(float *)&v77[8] - v70) / *(float *)v20.i32;
        *(float *)&buf[8] = v24;
        *(float32x2_t *)CFAbsoluteTime v73 = vdiv_f32(vsub_f32((float32x2_t)vext_s8(*(int8x8_t *)&v77[8], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)&v77[8], *(int8x16_t *)&v77[8], 8uLL), 4uLL), v71), v23);
        *(float *)&v73[8] = (float)(*(float *)&v77[20] - v72) / *(float *)v20.i32;
        float v25 = 0.0;
        do
        {
          float v25 = v25 + (float)(*(float *)&v73[v22] * *(float *)&v73[v22]);
          v22 += 4;
        }
        while (v22 != 12);
        float v26 = sqrtf(v25);
        float v27 = 52.36;
        if (v26 <= 52.36)
        {
          uint64_t v28 = 0;
          float v29 = 0.0;
          do
          {
            float v29 = v29 + (float)(*(float *)&v73[v28] * *(float *)&v73[v28]);
            v28 += 4;
          }
          while (v28 != 12);
          float v27 = sqrtf(v29);
        }
        uint64_t v30 = 0;
        float v31 = 0.0;
        do
        {
          float v31 = v31 + (float)(*(float *)&buf[v30] * *(float *)&buf[v30]);
          v30 += 4;
        }
        while (v30 != 12);
        if (sqrtf(v31) > v27)
        {
          uint64_t v32 = 0;
          float v33 = 0.0;
          do
          {
            float v33 = v33 + (float)(*(float *)&buf[v32] * *(float *)&buf[v32]);
            v32 += 4;
          }
          while (v32 != 12);
          float v34 = v27 / sqrtf(v33);
          *(float32x2_t *)v19.i8 = vmul_n_f32(*(float32x2_t *)v19.i8, v34);
          float v24 = v24 * v34;
        }
        float v35 = v16 / 1000000.0;
        *(float32x2_t *)v19.i8 = vmul_n_f32(*(float32x2_t *)v19.i8, v35);
        float32x2_t v36 = vmul_f32(vadd_f32(*(float32x2_t *)v77, vadd_f32(*(float32x2_t *)v77, *(float32x2_t *)v19.i8)), (float32x2_t)0x3F0000003F000000);
        *(float32x2_t *)v77 = v36;
        float32x4_t v37 = (float32x4_t)vextq_s8(*(int8x16_t *)&v77[8], v19, 0xCuLL);
        v37.f32[0] = v24 * v35;
        v37.f32[3] = v24 * v35;
        float32x4_t v38 = vaddq_f32(*(float32x4_t *)&v77[8], vaddq_f32(*(float32x4_t *)&v77[8], v37));
        v37.i64[0] = 0x3F0000003F000000;
        v37.i64[1] = 0x3F0000003F000000;
        float32x4_t v39 = vmulq_f32(v38, v37);
        *(float32x4_t *)&v77[8] = v39;
        float v40 = 0.0;
        for (uint64_t i = 12; i != 24; i += 4)
          float v40 = v40 + (float)(*(float *)&v77[i] * *(float *)&v77[i]);
        float v42 = sqrtf(v40);
        float v43 = 8.7266;
        if (v42 <= 8.7266)
        {
          uint64_t v44 = 0;
          float v45 = 0.0;
          do
          {
            float v45 = v45 + (float)(*(float *)&v77[v44 + 12] * *(float *)&v77[v44 + 12]);
            v44 += 4;
          }
          while (v44 != 12);
          float v43 = sqrtf(v45);
        }
        uint64_t v46 = 0;
        float v47 = 0.0;
        do
        {
          float v47 = v47 + (float)(*(float *)&v77[v46] * *(float *)&v77[v46]);
          v46 += 4;
        }
        while (v46 != 12);
        if (sqrtf(v47) > v43)
        {
          uint64_t v48 = 0;
          float v49 = 0.0;
          do
          {
            float v49 = v49 + (float)(*(float *)&v77[v48] * *(float *)&v77[v48]);
            v48 += 4;
          }
          while (v48 != 12);
          float v50 = v43 / sqrtf(v49);
          float32x2_t v36 = vmul_n_f32(v36, v50);
          v39.f32[0] = v39.f32[0] * v50;
        }
        *(float32x2_t *)CFAbsoluteTime v73 = vmul_n_f32(v36, v35);
        *(float *)&v73[8] = v39.f32[0] * v35;
        *(double *)v51.i64 = sub_1904CF7FC((float32x4_t *)buf, (float *)v73);
        unint64_t v52 = *(unsigned __int16 *)(a1 + 8) + (unint64_t)*(unsigned __int16 *)(a1 + 10) - 1;
        unint64_t v53 = *(unsigned int *)(a1 + 12);
        if (v52 < v53) {
          unint64_t v53 = 0;
        }
        *(double *)a4.i64 = sub_1904CF3F4((uint64_t)buf, (float *)(v9 + 40 * (v52 - v53)), a3, v51);
      }
      else if (v13 != a3)
      {
        a4 = *v13;
        *a3 = *v13;
      }
      sub_1902D9ACC(a3, a4);
    }
  }
  else
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
    }
    __int16 v54 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v54, OS_LOG_TYPE_ERROR, "History buffer is empty, can't predict", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
      }
      *(_WORD *)v77 = 0;
      __int16 v62 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "CMOQuaternion CMRelDMFwdPredictor::getPredictedRelAttitude(uint64_t &) const", "CoreLocation: %s\n", v62);
      if (v62 != buf) {
        free(v62);
      }
    }
    a3->i64[0] = 0;
    a3->i64[1] = 0x3F80000000000000;
  }
}

void sub_19045C03C(void *a1, unint64_t *a2, unsigned __int16 *a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *a2;
  if (a4 + v6 - 1 >= a3[1])
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
    }
    double v18 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_ERROR, "[CMRelDMFwdPredictor] Index out of range of relative w buffer", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD15C0);
      }
      LOWORD(__p) = 0;
      int8x16_t v19 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "CMRelDMFwdPredictor::OmegaState CMRelDMFwdPredictor::medianVector3d(const CMFixedSizeQueue<OmegaState, kQBufferLen - 1> &, const size_t) const", "CoreLocation: %s\n", v19);
      if (v19 != (char *)buf) {
        free(v19);
      }
    }
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    LODWORD(__p) = 0;
    sub_19045C82C(buf, v6, &__p);
    unint64_t v9 = *a2;
    int v20 = 0;
    sub_19045C82C(&__p, v9, &v20);
    for (unint64_t i = 0; i != 3; ++i)
    {
      if (*a2)
      {
        unint64_t v11 = 0;
        do
        {
          uint64_t v12 = sub_19045C54C(a3, a4 + v11);
          float v13 = sub_190448408(v12, i);
          *(float *)(*(void *)buf + 4 * v11) = v13;
          uint64_t v14 = sub_19045C54C(a3, a4 + v11);
          float v15 = sub_190448408(v14 + 12, i);
          *((float *)__p + v11++) = v15;
        }
        while (v11 < *a2);
      }
      float v16 = sub_19045C74C(*(const void **)buf, (uint64_t)v24);
      *(float *)sub_19042D844((uint64_t)a1, i) = v16;
      float v17 = sub_19045C74C(__p, (uint64_t)v22);
      *(float *)sub_19042D844((uint64_t)a1 + 12, i) = v17;
    }
    if (__p)
    {
      uint64_t v22 = __p;
      operator delete(__p);
    }
    if (*(void *)buf)
    {
      float v24 = *(const void **)buf;
      operator delete(*(void **)buf);
    }
  }
}

void sub_19045C30C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19045C34C(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3180);
    }
    char v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3180);
      }
      unint64_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const T &CMQueue<CMRelDMFwdPredictor::AttitudeState>::operator[](const size_t) const [T = CMRelDMFwdPredictor::AttitudeState]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[20 * (v4 - v5) + 4];
}

uint64_t sub_19045C54C(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3180);
    }
    char v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3180);
      }
      unint64_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const T &CMQueue<CMRelDMFwdPredictor::OmegaState>::operator[](const size_t) const [T = CMRelDMFwdPredictor::OmegaState]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[12 * (v4 - v5) + 4];
}

float sub_19045C74C(const void *a1, uint64_t a2)
{
  unint64_t v5 = 0;
  unint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_19045C8B0(&v5, a1, a2, (a2 - (uint64_t)a1) >> 2);
  std::__sort<std::__less<float,float> &,float *>();
  unint64_t v2 = (unint64_t)(v6 - v5) >> 1;
  if (((v6 - v5) & 4) != 0) {
    float v3 = v5[v2];
  }
  else {
    float v3 = (float)(v5[v2 - 1] + v5[v2]) * 0.5;
  }
  unint64_t v6 = v5;
  operator delete(v5);
  return v3;
}

void sub_19045C7E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

os_log_t sub_19045C7FC()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

void *sub_19045C82C(void *a1, unint64_t a2, _DWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_190347CC0(a1, a2);
    unint64_t v6 = (_DWORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_19045C894(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19045C8B0(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    os_log_t result = sub_190347CC0(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      os_log_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_19045C910(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19045CAD8(void *a1, CFDictionaryRef theDict)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *a1 = &unk_1EDFC8380;
  a1[1] = 0;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (theDict) {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v3, 0, theDict);
  }
  else {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  a1[1] = MutableCopy;
  if (!MutableCopy)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    unint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "could not create new mutable dictionary", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v7 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "CLNameValuePair::CLNameValuePair(CFDictionaryRef)", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
  return a1;
}

void *sub_19045CCC8(void *a1)
{
  *a1 = &unk_1EDFC8380;
  unint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_19045CD1C(void *a1)
{
  sub_19045CCC8(a1);

  JUMPOUT(0x192FCC980);
}

__CFString *sub_19045CD54()
{
  return @"Memory";
}

uint64_t sub_19045CD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 928))(a3, a1, a2);
}

uint64_t sub_19045CDA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 896))(a3, a1, a2);
}

uint64_t sub_19045CDDC(void *context, uint64_t a2, int a3)
{
  CFDictionaryRef v4 = *(const __CFDictionary **)(a2 + 8);
  if (a3) {
    unint64_t v5 = (void (__cdecl *)(const void *, const void *, void *))sub_19045CDA0;
  }
  else {
    unint64_t v5 = (void (__cdecl *)(const void *, const void *, void *))sub_19045CD64;
  }
  CFDictionaryApplyFunction(v4, v5, context);
  unint64_t v6 = *(uint64_t (**)(void *))(*(void *)context + 848);

  return v6(context);
}

uint64_t sub_19045CE74(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 872))();
}

uint64_t sub_19045CEA0(uint64_t a1, void *a2, int a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (void *)MEMORY[0x192FCD2F0]();
  uint64_t v7 = (void *)MEMORY[0x1E4F1CB10];
  uint64_t v9 = objc_msgSend_stringWithUTF8String_(NSString, v8, a1);
  uint64_t isDirectory = objc_msgSend_fileURLWithPath_isDirectory_(v7, v10, v9, 0);
  if (isDirectory)
  {
    uint64_t v13 = 536870913;
    if (a3) {
      uint64_t v13 = 1;
    }
    if (a3 == 1) {
      uint64_t v14 = 1073741825;
    }
    else {
      uint64_t v14 = v13;
    }
    float v33 = 0;
    uint64_t v15 = objc_msgSend_writeToURL_options_error_(a2, v12, isDirectory, v14, &v33);
    if ((v15 & 1) == 0)
    {
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      float v16 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_ERROR))
      {
        int8x16_t v19 = objc_msgSend_description(v33, v17, v18);
        uint64_t v22 = objc_msgSend_UTF8String(v19, v20, v21);
        *(_DWORD *)buf = 136446466;
        uint64_t v39 = a1;
        __int16 v40 = 2082;
        uint64_t v41 = v22;
        _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_ERROR, "Could not write data to disk %{public}s, %{public}s", buf, 0x16u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
        }
        uint64_t v25 = objc_msgSend_description(v33, v23, v24);
        uint64_t v28 = objc_msgSend_UTF8String(v25, v26, v27);
        int v34 = 136446466;
        uint64_t v35 = a1;
        __int16 v36 = 2082;
        uint64_t v37 = v28;
        float v29 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "BOOL CLNameValuePair::writeDataToFile(const char *, CFDataRef, CLNVPDataProtection) const", "CoreLocation: %s\n", v29);
        if (v29 != (char *)buf) {
          free(v29);
        }
      }
    }
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    uint64_t v30 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v39 = a1;
      _os_log_impl(&dword_1902AF000, v30, OS_LOG_TYPE_FAULT, "Could not create NSURL for file: %{public}s", buf, 0xCu);
    }
    uint64_t v15 = 0;
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      int v34 = 136446210;
      uint64_t v35 = a1;
      uint64_t v32 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "BOOL CLNameValuePair::writeDataToFile(const char *, CFDataRef, CLNVPDataProtection) const", "CoreLocation: %s\n", v32);
      if (v32 != (char *)buf) {
        free(v32);
      }
      uint64_t v15 = 0;
    }
  }
  return v15;
}

uint64_t sub_19045D25C(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if ((*(unsigned int (**)(uint64_t, CFTypeRef *))(*(void *)a1 + 768))(a1, &cf))
  {
    uint64_t v3 = sub_19045CEA0(a2, (void *)cf, 2);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    CFDictionaryRef v4 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = a2;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "Could not serialize data for file %{public}s", buf, 0xCu);
    }
    uint64_t v3 = 0;
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      int v8 = 136446210;
      uint64_t v9 = a2;
      unint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::saveToFile(const char *) const", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
      uint64_t v3 = 0;
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  return v3;
}

uint64_t sub_19045D470(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  unint64_t v6 = sub_190455700((uint64_t *)v12, (uint64_t)"CLNameValuePair.SaveToBinaryFile", 0);
  uint64_t v7 = (void *)MEMORY[0x192FCD2F0](v6);
  if ((*(unsigned int (**)(uint64_t, CFTypeRef *))(*(void *)a1 + 776))(a1, &cf))
  {
    uint64_t v8 = sub_19045CEA0(a2, (void *)cf, a3);
  }
  else
  {
    if (qword_1E929D6B0 != -1) {
      dispatch_once(&qword_1E929D6B0, &unk_1EDFD3AA0);
    }
    uint64_t v9 = qword_1E929D6A0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6A0, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289282;
      int v15 = 0;
      __int16 v16 = 2082;
      float v17 = "";
      __int16 v18 = 2082;
      uint64_t v19 = a2;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Could not serialize data\", \"file\":%{public, location:escape_only}s}", buf, 0x1Cu);
      if (qword_1E929D6B0 != -1) {
        dispatch_once(&qword_1E929D6B0, &unk_1EDFD3AA0);
      }
    }
    unint64_t v10 = qword_1E929D6A0;
    if (os_signpost_enabled((os_log_t)qword_1E929D6A0))
    {
      *(_DWORD *)buf = 68289282;
      int v15 = 0;
      __int16 v16 = 2082;
      float v17 = "";
      __int16 v18 = 2082;
      uint64_t v19 = a2;
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Could not serialize data", "{\"msg%{public}.0s\":\"Could not serialize data\", \"file\":%{public, location:escape_only}s}", buf, 0x1Cu);
    }
    uint64_t v8 = 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  sub_190455930(v12);
  return v8;
}

void sub_19045D694(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_19045D6B0(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  (*(void (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 880))(a1, v5, a3);

  CFRelease(v5);
}

uint64_t sub_19045D744(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 880))();
}

uint64_t sub_19045D770(CFMutableDictionaryRef *a1)
{
  CFDictionaryRemoveAllValues(a1[1]);
  unint64_t v2 = (uint64_t (*)(CFMutableDictionaryRef *))*((void *)*a1 + 106);

  return v2(a1);
}

void sub_19045D7D4(uint64_t a1, const __CFString *a2, unsigned int a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if ((a3 & 0x80000000) == 0)
  {
    CFTypeRef cf = 0;
    if (!(*(unsigned int (**)(uint64_t, const __CFString *, CFTypeRef *))(*(void *)a1 + 912))(a1, a2, &cf))return; {
    CFTypeID v6 = CFGetTypeID(cf);
    }
    if (v6 == CFArrayGetTypeID())
    {
      if (CFArrayGetCount((CFArrayRef)cf) > a3)
      {
        CFArrayRemoveValueAtIndex((CFMutableArrayRef)cf, a3);
        (*(void (**)(uint64_t))(*(void *)a1 + 848))(a1);
LABEL_42:
        CFRelease(cf);
        return;
      }
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      __int16 v18 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        sub_1902C36AC(a2, (uint64_t)__p);
        int v19 = SBYTE3(v34);
        uint64_t v20 = *(unsigned char **)__p;
        CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
        uint64_t v22 = __p;
        *(_DWORD *)buf = 136446722;
        if (v19 < 0) {
          uint64_t v22 = v20;
        }
        __int16 v36 = v22;
        __int16 v37 = 1026;
        unsigned int v38 = a3;
        __int16 v39 = 2050;
        CFTypeID v40 = Count;
        _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_FAULT, "key %{public}s does not have element %{public}d in array of size %{public}ld", buf, 0x1Cu);
        if (SBYTE3(v34) < 0) {
          operator delete(*(void **)__p);
        }
      }
      if (!sub_1902D8400(115, 0)) {
        goto LABEL_42;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)v27);
      int v23 = v28;
      uint64_t v24 = (void **)v27[0];
      CFIndex v25 = CFArrayGetCount((CFArrayRef)cf);
      float v26 = v27;
      *(_DWORD *)__n128 __p = 136446722;
      if (v23 < 0) {
        float v26 = v24;
      }
      *(void *)&__p[4] = v26;
      __int16 v31 = 1026;
      unsigned int v32 = a3;
      __int16 v33 = 2050;
      CFTypeID v34 = v25;
      float v17 = (char *)_os_log_send_and_compose_impl();
      if (v28 < 0) {
        operator delete(v27[0]);
      }
    }
    else
    {
      if (!a3)
      {
        (*(void (**)(uint64_t, const __CFString *))(*(void *)a1 + 888))(a1, a2);
        goto LABEL_42;
      }
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v8 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        sub_1902C36AC(a2, (uint64_t)__p);
        int v9 = SBYTE3(v34);
        unint64_t v10 = *(unsigned char **)__p;
        CFTypeID v11 = CFGetTypeID(cf);
        uint64_t v12 = __p;
        *(_DWORD *)buf = 136446722;
        if (v9 < 0) {
          uint64_t v12 = v10;
        }
        __int16 v36 = v12;
        __int16 v37 = 1026;
        unsigned int v38 = a3;
        __int16 v39 = 2050;
        CFTypeID v40 = v11;
        _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "key %{public}s does not have element %{public}d in non-array type %{public}lu", buf, 0x1Cu);
        if (SBYTE3(v34) < 0) {
          operator delete(*(void **)__p);
        }
      }
      if (!sub_1902D8400(115, 0)) {
        goto LABEL_42;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)v27);
      int v13 = v28;
      uint64_t v14 = (void **)v27[0];
      CFTypeID v15 = CFGetTypeID(cf);
      __int16 v16 = v27;
      *(_DWORD *)__n128 __p = 136446722;
      if (v13 < 0) {
        __int16 v16 = v14;
      }
      *(void *)&__p[4] = v16;
      __int16 v31 = 1026;
      unsigned int v32 = a3;
      __int16 v33 = 2050;
      CFTypeID v34 = v15;
      float v17 = (char *)_os_log_send_and_compose_impl();
      if (v28 < 0) {
        operator delete(v27[0]);
      }
    }
    sub_1902D398C("Generic", 1, 0, 0, "virtual void CLNameValuePair::clearInternal(const CFStringRef, int)", "CoreLocation: %s\n", v17);
    if (v17 != (char *)buf) {
      free(v17);
    }
    goto LABEL_42;
  }
  uint64_t v7 = *(void (**)(void))(*(void *)a1 + 888);

  v7();
}

void sub_19045DD64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19045DDA4(CFMutableDictionaryRef *a1, const void *a2)
{
  CFDictionaryRemoveValue(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(CFMutableDictionaryRef *))*((void *)*a1 + 106);

  return v3(a1);
}

void sub_19045DE08(uint64_t a1)
{
}

void sub_19045DF68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  *(void *)(v15 + 8) = v16;
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19045DF90(uint64_t a1, const char *a2)
{
  uint64_t v3 = objc_msgSend_stringWithUTF8String_(NSString, a2, (uint64_t)a2);
  CFDictionaryRef v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 920);

  return v4(a1, v3);
}

uint64_t sub_19045E00C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 920))();
}

uint64_t sub_19045E038(uint64_t a1, const char *a2, CFTypeRef *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  uint64_t v6 = sub_19045E0AC(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_19045E0AC(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  *a3 = 0;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 904))(a1);
  if (v4 && *a3) {
    CFAutorelease(*a3);
  }
  return v4;
}

uint64_t sub_19045E114(uint64_t a1, const char *a2, _WORD *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  uint64_t v6 = sub_19045E188(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_19045E188(uint64_t a1, uint64_t a2, _WORD *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)a1 + 904))(a1, a2, &cf)) {
    return 0;
  }
  *(_DWORD *)buf = 0;
  uint64_t v6 = sub_19046092C(cf, buf);
  if (v6)
  {
    *a3 = *(_WORD *)buf;
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    uint64_t v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      *(_DWORD *)buf = 138412546;
      uint64_t v18 = v8;
      __int16 v19 = 2112;
      uint64_t v20 = a2;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Unsupported type at %@:%@ (domain:key)", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      int v13 = 138412546;
      uint64_t v14 = v10;
      __int16 v15 = 2112;
      uint64_t v16 = a2;
      CFTypeID v11 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, uint16_t &, int) const", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_19045E434(uint64_t a1, const char *a2, _WORD *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  uint64_t v6 = sub_19045E4A8(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_19045E4A8(uint64_t a1, uint64_t a2, _WORD *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)a1 + 904))(a1, a2, &cf)) {
    return 0;
  }
  CFNumberRef v6 = (const __CFNumber *)cf;
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 == CFNumberGetTypeID())
  {
    if (!CFNumberGetValue(v6, kCFNumberSInt16Type, a3))
    {
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v8 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "could not get value", buf, 2u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
        }
        LOWORD(v18) = 0;
        int v9 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, short &)", "CoreLocation: %s\n", v9);
        if (v9 != (char *)buf) {
          free(v9);
        }
      }
      goto LABEL_18;
    }
  }
  else
  {
    buf[0] = 0;
    CFTypeID v11 = CFGetTypeID(v6);
    if (v11 != CFBooleanGetTypeID() || (sub_1904606BC(v6, (BOOL *)buf) & 1) == 0)
    {
LABEL_18:
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v12 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
        *(_DWORD *)buf = 138412546;
        uint64_t v23 = v13;
        __int16 v24 = 2112;
        uint64_t v25 = a2;
        _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_FAULT, "Unsupported type at %@:%@ (domain:key)", buf, 0x16u);
      }
      uint64_t v10 = 0;
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
        }
        uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
        int v18 = 138412546;
        uint64_t v19 = v15;
        __int16 v20 = 2112;
        uint64_t v21 = a2;
        uint64_t v16 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, short &, int) const", "CoreLocation: %s\n", v16);
        if (v16 != (char *)buf) {
          free(v16);
        }
        uint64_t v10 = 0;
      }
      goto LABEL_23;
    }
    *a3 = buf[0];
  }
  uint64_t v10 = 1;
LABEL_23:
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t sub_19045E8CC(uint64_t a1, const char *a2, _DWORD *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  uint64_t v6 = sub_19045E940(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_19045E940(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)a1 + 904))(a1, a2, &cf)) {
    return 0;
  }
  *(void *)buf = 0;
  uint64_t v6 = sub_190460728(cf, buf);
  if (v6)
  {
    *a3 = *(_DWORD *)buf;
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    CFTypeID v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      *(_DWORD *)buf = 138412546;
      *(void *)&uint8_t buf[4] = v8;
      __int16 v18 = 2112;
      uint64_t v19 = a2;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Unsupported type at %@:%@ (domain:key)", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      int v13 = 138412546;
      uint64_t v14 = v10;
      __int16 v15 = 2112;
      uint64_t v16 = a2;
      CFTypeID v11 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, uint32_t &, int) const", "CoreLocation: %s\n", v11);
      if (v11 != buf) {
        free(v11);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_19045EBEC(uint64_t a1, const char *a2, void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  uint64_t v6 = sub_19045EC60(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_19045EC60(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)a1 + 904))(a1, a2, &cf)) {
    return 0;
  }
  uint64_t v6 = sub_190460728(cf, a3);
  if ((v6 & 1) == 0)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    CFTypeID v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      *(_DWORD *)buf = 138412546;
      uint64_t v18 = v8;
      __int16 v19 = 2112;
      uint64_t v20 = a2;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Unsupported type at %@:%@ (domain:key)", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      int v13 = 138412546;
      uint64_t v14 = v10;
      __int16 v15 = 2112;
      uint64_t v16 = a2;
      CFTypeID v11 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, int64_t &, int) const", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_19045EEFC(uint64_t a1, const char *a2, void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  uint64_t v6 = sub_19045EF70(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_19045EF70(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)a1 + 904))(a1, a2, &cf)) {
    return 0;
  }
  CFNumberRef v6 = (const __CFNumber *)cf;
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 == CFNumberGetTypeID())
  {
    if (!CFNumberGetValue(v6, kCFNumberLongType, a3))
    {
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v8 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "could not get value", buf, 2u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
        }
        LOWORD(v18) = 0;
        int v9 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, long &)", "CoreLocation: %s\n", v9);
        if (v9 != (char *)buf) {
          free(v9);
        }
      }
      goto LABEL_18;
    }
  }
  else
  {
    buf[0] = 0;
    CFTypeID v11 = CFGetTypeID(v6);
    if (v11 != CFBooleanGetTypeID() || (sub_1904606BC(v6, (BOOL *)buf) & 1) == 0)
    {
LABEL_18:
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v12 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
        *(_DWORD *)buf = 138412546;
        uint64_t v23 = v13;
        __int16 v24 = 2112;
        uint64_t v25 = a2;
        _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_FAULT, "Unsupported type at %@:%@ (domain:key)", buf, 0x16u);
      }
      uint64_t v10 = 0;
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
        }
        uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
        int v18 = 138412546;
        uint64_t v19 = v15;
        __int16 v20 = 2112;
        uint64_t v21 = a2;
        uint64_t v16 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, long &, int) const", "CoreLocation: %s\n", v16);
        if (v16 != (char *)buf) {
          free(v16);
        }
        uint64_t v10 = 0;
      }
      goto LABEL_23;
    }
    *a3 = buf[0];
  }
  uint64_t v10 = 1;
LABEL_23:
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t sub_19045F394(uint64_t a1, const char *a2, float *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  double v9 = 0.0;
  uint64_t v6 = sub_1902C5108(a1, (uint64_t)v5, &v9);
  if (v6)
  {
    float v7 = v9;
    *a3 = v7;
  }
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

float sub_19045F420(uint64_t a1, uint64_t a2, float *a3)
{
  double v5 = 0.0;
  if (sub_1902C5108(a1, a2, &v5))
  {
    float result = v5;
    *a3 = result;
  }
  return result;
}

BOOL sub_19045F468(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_19045F4DC(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_19045F4DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)a1 + 904))(a1, a2, &cf)) {
    return 0;
  }
  BOOL v6 = sub_1902C371C((const __CFString *)cf, a3);
  if (!v6)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    float v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      *(_DWORD *)buf = 138412546;
      uint64_t v18 = v8;
      __int16 v19 = 2112;
      uint64_t v20 = a2;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Unsupported type at %@:%@ (domain:key)", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      int v13 = 138412546;
      uint64_t v14 = v10;
      __int16 v15 = 2112;
      uint64_t v16 = a2;
      CFTypeID v11 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, std::string &, int) const", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_19045F778(uint64_t a1, const char *a2, CFTypeRef *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  uint64_t v6 = sub_19045F7EC(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_19045F7EC(uint64_t a1, const __CFString *a2, CFTypeRef *a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, const __CFString *, CFTypeRef *))(*(void *)a1 + 904))(a1, a2, &cf);
  if (result)
  {
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CFStringGetTypeID())
    {
      CFTypeRef v8 = cf;
      *a3 = cf;
      CFAutorelease(v8);
      return 1;
    }
    else
    {
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      double v9 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        sub_1902C36AC(a2, (uint64_t)__p);
        uint64_t v10 = v27 >= 0 ? __p : *(unsigned char **)__p;
        CFTypeID v11 = CFGetTypeID(cf);
        CFTypeID TypeID = CFStringGetTypeID();
        *(_DWORD *)buf = 136446722;
        uint64_t v30 = v10;
        __int16 v31 = 2050;
        CFTypeID v32 = v11;
        __int16 v33 = 2050;
        CFTypeID v34 = TypeID;
        _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "type IDs do not match for key %{public}s - %{public}lu vs %{public}lu", buf, 0x20u);
        if (SHIBYTE(v27) < 0) {
          operator delete(*(void **)__p);
        }
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
        }
        sub_1902C36AC(a2, (uint64_t)v21);
        if (v22 >= 0) {
          __int16 v15 = v21;
        }
        else {
          __int16 v15 = (void **)v21[0];
        }
        CFTypeID v16 = CFGetTypeID(cf);
        CFTypeID v17 = CFStringGetTypeID();
        *(_DWORD *)__n128 __p = 136446722;
        *(void *)&__p[4] = v15;
        __int16 v25 = 2050;
        CFTypeID v26 = v16;
        __int16 v27 = 2050;
        CFTypeID v28 = v17;
        uint64_t v18 = (char *)_os_log_send_and_compose_impl();
        if (v22 < 0) {
          operator delete(v21[0]);
        }
        sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, CFStringRef &, int) const", "CoreLocation: %s\n", v18);
        if (v18 != (char *)buf) {
          free(v18);
        }
      }
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      int v13 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
        *(_DWORD *)buf = 138412546;
        uint64_t v30 = (unsigned char *)v14;
        __int16 v31 = 2112;
        CFTypeID v32 = (CFTypeID)a2;
        _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_FAULT, "Unsupported type at %@:%@ (domain:key)", buf, 0x16u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
        }
        uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
        *(_DWORD *)__n128 __p = 138412546;
        *(void *)&__p[4] = v19;
        __int16 v25 = 2112;
        CFTypeID v26 = (CFTypeID)a2;
        uint64_t v20 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, CFStringRef &, int) const", "CoreLocation: %s\n", v20);
        if (v20 != (char *)buf) {
          free(v20);
        }
      }
      CFRelease(cf);
      return 0;
    }
  }
  return result;
}

void sub_19045FC7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_19045FCB4(uint64_t a1, const char *a2, const UInt8 **a3, _DWORD *a4, uint64_t a5)
{
  CFStringRef v9 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v10 = sub_19045FD34(a1, (CFTypeID)v9, a3, a4, a5);
  CFRelease(v9);
  return v10;
}

BOOL sub_19045FD34(uint64_t a1, CFTypeID a2, const UInt8 **a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, CFTypeID, CFTypeRef *, uint64_t))(*(void *)a1 + 904))(a1, a2, &cf, a5))return 0; {
  CFDataRef v9 = (const __CFData *)cf;
  }
  CFTypeID v10 = CFGetTypeID(cf);
  BOOL v11 = v10 == CFDataGetTypeID();
  BOOL v12 = v11;
  if (v11)
  {
    *a3 = CFDataGetBytePtr(v9);
    *a4 = CFDataGetLength(v9);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    int v13 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      CFTypeID v14 = CFGetTypeID(v9);
      CFTypeID TypeID = CFDataGetTypeID();
      *(_DWORD *)buf = 134349312;
      CFTypeID v30 = v14;
      __int16 v31 = 2050;
      CFTypeID v32 = TypeID;
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_FAULT, "type IDs do not match - %{public}lu vs %{public}lu", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      CFTypeID v19 = CFGetTypeID(v9);
      CFTypeID v20 = CFDataGetTypeID();
      int v25 = 134349312;
      CFTypeID v26 = v19;
      __int16 v27 = 2050;
      CFTypeID v28 = v20;
      uint64_t v21 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, const char *&, unsigned int &)", "CoreLocation: %s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
    }
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    CFTypeID v16 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      *(_DWORD *)buf = 138412546;
      CFTypeID v30 = v17;
      __int16 v31 = 2112;
      CFTypeID v32 = a2;
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_FAULT, "Unsupported type at %@:%@ (domain:key)", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      int v25 = 138412546;
      CFTypeID v26 = v22;
      __int16 v27 = 2112;
      CFTypeID v28 = a2;
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, const char *&, unsigned int &, int) const", "CoreLocation: %s\n", v23);
      if (v23 != (char *)buf) {
        free(v23);
      }
    }
  }
  CFRelease(cf);
  return v12;
}

BOOL sub_190460180(uint64_t a1, const char *a2, void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_1904601F4(a1, (CFTypeID)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1904601F4(uint64_t a1, CFTypeID a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, CFTypeID, CFTypeRef *))(*(void *)a1 + 904))(a1, a2, &cf)) {
    return 0;
  }
  CFDictionaryRef v6 = (const __CFDictionary *)cf;
  CFTypeID v7 = CFGetTypeID(cf);
  BOOL v8 = v7 == CFDictionaryGetTypeID();
  BOOL v9 = v8;
  if (v8)
  {
    if (v6)
    {
      CFTypeID v10 = (const void *)a3[1];
      if (v10) {
        CFRelease(v10);
      }
      a3[1] = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v6);
      (*(void (**)(void *))(*a3 + 848))(a3);
    }
    else
    {
      (*(void (**)(void *))(*a3 + 872))(a3);
    }
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v11 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      CFTypeID v12 = CFGetTypeID(v6);
      CFTypeID TypeID = CFDictionaryGetTypeID();
      *(_DWORD *)buf = 134349312;
      CFTypeID v28 = v12;
      __int16 v29 = 2050;
      CFTypeID v30 = TypeID;
      _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_FAULT, "type IDs do not match - %{public}lu vs %{public}lu", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      CFTypeID v19 = CFGetTypeID(v6);
      CFTypeID v20 = CFDictionaryGetTypeID();
      int v23 = 134349312;
      CFTypeID v24 = v19;
      __int16 v25 = 2050;
      CFTypeID v26 = v20;
      uint64_t v21 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, CLNameValuePair &)", "CoreLocation: %s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
    }
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    CFTypeID v14 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      *(_DWORD *)buf = 138412546;
      CFTypeID v28 = v15;
      __int16 v29 = 2112;
      CFTypeID v30 = a2;
      _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "Unsupported type at %@:%@ (domain:key)", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840))(a1);
      int v23 = 138412546;
      CFTypeID v24 = v16;
      __int16 v25 = 2112;
      CFTypeID v26 = a2;
      uint64_t v17 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, CLNameValuePair &, int) const", "CoreLocation: %s\n", v17);
      if (v17 != (char *)buf) {
        free(v17);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t sub_1904606BC(const void *a1, BOOL *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFBooleanGetTypeID() && v4 != CFNumberGetTypeID()) {
    return 0;
  }
  *a2 = CFBooleanGetValue((CFBooleanRef)a1) != 0;
  return 1;
}

uint64_t sub_190460728(const void *a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFNumberGetTypeID())
  {
    buf[0] = 0;
    CFTypeID v9 = CFGetTypeID(a1);
    CFTypeID TypeID = CFBooleanGetTypeID();
    uint64_t result = 0;
    if (v9 != TypeID) {
      return result;
    }
    uint64_t result = sub_1904606BC(a1, (BOOL *)buf);
    if (!result) {
      return result;
    }
    *a2 = buf[0];
    return 1;
  }
  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, a2)) {
    return 1;
  }
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
  }
  CFStringRef v5 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "could not get value", buf, 2u);
  }
  int v6 = sub_1902D8400(115, 0);
  uint64_t result = 0;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v8 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, int64_t &)", "CoreLocation: %s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
    return 0;
  }
  return result;
}

uint64_t sub_19046092C(const void *a1, _DWORD *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFNumberGetTypeID())
  {
    buf[0] = 0;
    CFTypeID v9 = CFGetTypeID(a1);
    CFTypeID TypeID = CFBooleanGetTypeID();
    uint64_t result = 0;
    if (v9 != TypeID) {
      return result;
    }
    uint64_t result = sub_1904606BC(a1, (BOOL *)buf);
    if (!result) {
      return result;
    }
    *a2 = buf[0];
    return 1;
  }
  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, a2)) {
    return 1;
  }
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
  }
  CFStringRef v5 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "could not get value", buf, 2u);
  }
  int v6 = sub_1902D8400(115, 0);
  uint64_t result = 0;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v8 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, int &)", "CoreLocation: %s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
    return 0;
  }
  return result;
}

uint64_t sub_190460B30(const void *a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFNumberGetTypeID())
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    int v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134349312;
      CFTypeID v12 = CFGetTypeID(a1);
      __int16 v13 = 2050;
      CFTypeID TypeID = CFNumberGetTypeID();
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "type IDs do not match - %{public}lu vs %{public}lu", buf, 0x16u);
    }
    int v7 = sub_1902D8400(115, 0);
    uint64_t result = 0;
    if (!v7) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    CFGetTypeID(a1);
    CFNumberGetTypeID();
    BOOL v8 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, double &)", "CoreLocation: %s\n", v8);
    if (v8 == (char *)buf) {
      return 0;
    }
LABEL_12:
    free(v8);
    return 0;
  }
  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberFloat64Type, a2)) {
    return 1;
  }
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
  }
  CFTypeID v9 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "could not get value", buf, 2u);
  }
  int v10 = sub_1902D8400(115, 0);
  uint64_t result = 0;
  if (v10)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v8 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, double &)", "CoreLocation: %s\n", v8);
    if (v8 == (char *)buf) {
      return 0;
    }
    goto LABEL_12;
  }
  return result;
}

BOOL sub_190460E88(uint64_t a1, const __CFString *a2, CFTypeRef *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, const __CFString *, CFTypeRef *))(*(void *)a1 + 912))(a1, a2, &cf)) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  BOOL v6 = v5 == CFArrayGetTypeID();
  BOOL v7 = v6;
  if (v6)
  {
    *a3 = cf;
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v8 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      CFTypeID v9 = v23 >= 0 ? __p : *(unsigned char **)__p;
      CFTypeID v10 = CFGetTypeID(cf);
      CFTypeID TypeID = CFArrayGetTypeID();
      *(_DWORD *)buf = 136446722;
      CFTypeID v26 = v9;
      __int16 v27 = 2050;
      CFTypeID v28 = v10;
      __int16 v29 = 2050;
      CFTypeID v30 = TypeID;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "type IDs do not match for key %{public}s - %{public}lu vs %{public}lu", buf, 0x20u);
      if (SHIBYTE(v23) < 0) {
        operator delete(*(void **)__p);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      __int16 v13 = v17;
      sub_1902C36AC(a2, (uint64_t)v17);
      if (v18 < 0) {
        __int16 v13 = (void **)v17[0];
      }
      CFTypeID v14 = CFGetTypeID(cf);
      CFTypeID v15 = CFArrayGetTypeID();
      *(_DWORD *)__n128 __p = 136446722;
      *(void *)&__p[4] = v13;
      __int16 v21 = 2050;
      CFTypeID v22 = v14;
      __int16 v23 = 2050;
      CFTypeID v24 = v15;
      uint64_t v16 = (char *)_os_log_send_and_compose_impl();
      if (v18 < 0) {
        operator delete(v17[0]);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, CFArrayRef &) const", "CoreLocation: %s\n", v16);
      if (v16 != (char *)buf) {
        free(v16);
      }
    }
  }
  CFAutorelease(cf);
  return v7;
}

void sub_19046115C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_190461194(uint64_t a1, const __CFString *a2, CFTypeRef *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, const __CFString *, CFTypeRef *))(*(void *)a1 + 904))(a1, a2, &cf)) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  BOOL v6 = v5 == CFDataGetTypeID();
  BOOL v7 = v6;
  if (v6)
  {
    *a3 = cf;
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v8 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      CFTypeID v9 = v23 >= 0 ? __p : *(unsigned char **)__p;
      CFTypeID v10 = CFGetTypeID(cf);
      CFTypeID TypeID = CFDataGetTypeID();
      *(_DWORD *)buf = 136446722;
      CFTypeID v26 = v9;
      __int16 v27 = 2050;
      CFTypeID v28 = v10;
      __int16 v29 = 2050;
      CFTypeID v30 = TypeID;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "type IDs do not match for key %{public}s - %{public}lu vs %{public}lu", buf, 0x20u);
      if (SHIBYTE(v23) < 0) {
        operator delete(*(void **)__p);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      __int16 v13 = v17;
      sub_1902C36AC(a2, (uint64_t)v17);
      if (v18 < 0) {
        __int16 v13 = (void **)v17[0];
      }
      CFTypeID v14 = CFGetTypeID(cf);
      CFTypeID v15 = CFDataGetTypeID();
      *(_DWORD *)__n128 __p = 136446722;
      *(void *)&__p[4] = v13;
      __int16 v21 = 2050;
      CFTypeID v22 = v14;
      __int16 v23 = 2050;
      CFTypeID v24 = v15;
      uint64_t v16 = (char *)_os_log_send_and_compose_impl();
      if (v18 < 0) {
        operator delete(v17[0]);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::get(CFStringRef, CFDataRef &, int) const", "CoreLocation: %s\n", v16);
      if (v16 != (char *)buf) {
        free(v16);
      }
    }
  }
  CFAutorelease(cf);
  return v7;
}

void sub_190461468(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1904614A0(uint64_t a1, const void *a2)
{
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 8), a2) != 0;
}

uint64_t sub_1904614C4(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  (*(void (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 896))(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return 1;
}

uint64_t sub_190461554(uint64_t a1)
{
  return 1;
}

BOOL sub_190461598(uint64_t a1, const char *a2, unsigned char *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190461604(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190461604(uint64_t a1, const __CFString *a2, unsigned char *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFStringRef v5 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
  if (!*a3) {
    CFStringRef v5 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
  }
  CFTypeRef v6 = *v5;
  CFRetain(*v5);
  if (v6)
  {
    (*(void (**)(uint64_t, const __CFString *, CFTypeRef))(*(void *)a1 + 896))(a1, a2, v6);
    CFRelease(v6);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v8 = v17 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v17 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v13 >= 0) {
        CFTypeID v10 = buf;
      }
      else {
        CFTypeID v10 = *(unsigned char **)buf;
      }
      int v14 = 136446210;
      CFTypeID v15 = v10;
      BOOL v11 = (char *)_os_log_send_and_compose_impl();
      if (v13 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const BOOL &)", "CoreLocation: %s\n", v11);
      if (v11 != (char *)__p) {
        free(v11);
      }
    }
  }
  return v6 != 0;
}

BOOL sub_19046189C(uint64_t a1, const char *a2, unsigned __int16 *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190461908(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190461908(uint64_t a1, const __CFString *a2, unsigned __int16 *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  LODWORD(valuePtr[0]) = *a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, valuePtr);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)valuePtr);
      BOOL v7 = v16 >= 0 ? valuePtr : (void **)valuePtr[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(valuePtr[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(valuePtr, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const uint16_t &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)valuePtr) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190461B9C(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190461C08(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190461C08(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt16Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const short &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190461E90(uint64_t a1, const char *a2, unsigned int *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190461EFC(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190461EFC(uint64_t a1, const __CFString *a2, unsigned int *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  valuePtr[0] = (void *)*a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, valuePtr);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)valuePtr);
      BOOL v7 = v16 >= 0 ? valuePtr : (void **)valuePtr[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(valuePtr[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(valuePtr, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const uint32_t &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)valuePtr) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190462190(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_1904621FC(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1904621FC(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const int64_t &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190462484(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_1904624F0(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1904624F0(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const int &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190462778(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_1904627E4(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1904627E4(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const long &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190462A6C(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190462AD8(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190462AD8(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat64Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const double &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190462D60(uint64_t a1, const char *a2, char *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190462DCC(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190462DCC(uint64_t a1, const __CFString *a2, char *cStr)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x8000100u);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFStringRef))(*(void *)a1 + 896))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const char *)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_19046305C(uint64_t a1, const char *a2, char *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  if (a3[23] >= 0) {
    BOOL v6 = a3;
  }
  else {
    BOOL v6 = *(char **)a3;
  }
  BOOL v7 = sub_190462DCC(a1, v5, v6);
  if (v5) {
    CFRelease(v5);
  }
  return v7;
}

BOOL sub_1904630D4(uint64_t a1, const __CFString *a2, char *a3)
{
  if (a3[23] < 0) {
    a3 = *(char **)a3;
  }
  return sub_190462DCC(a1, a2, a3);
}

uint64_t sub_1904630E8(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  (*(void (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 896))(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return 1;
}

uint64_t sub_190463178(uint64_t a1)
{
  return 1;
}

BOOL sub_1904631BC(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190463228(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190463228(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFDictionaryRef *)(a3 + 8));
  if (Copy)
  {
    (*(void (**)(uint64_t, const __CFString *, CFDictionaryRef))(*(void *)a1 + 896))(a1, a2, Copy);
    CFRelease(Copy);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::set(CFStringRef, const CLNameValuePair &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return Copy != 0;
}

uint64_t sub_1904634B0(CFMutableDictionaryRef *a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(a1[1], a2, a3);
  CFTypeID v4 = (uint64_t (*)(CFMutableDictionaryRef *))*((void *)*a1 + 106);

  return v4(a1);
}

uint64_t sub_190463520(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  (*(void (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 928))(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return 1;
}

uint64_t sub_1904635B0(uint64_t a1)
{
  return 1;
}

BOOL sub_1904635F4(uint64_t a1, const char *a2, unsigned char *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190463660(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190463660(uint64_t a1, const __CFString *a2, unsigned char *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFStringRef v5 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
  if (!*a3) {
    CFStringRef v5 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
  }
  CFTypeRef v6 = *v5;
  CFRetain(*v5);
  if (v6)
  {
    (*(void (**)(uint64_t, const __CFString *, CFTypeRef))(*(void *)a1 + 928))(a1, a2, v6);
    CFRelease(v6);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v8 = v17 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v17 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v13 >= 0) {
        CFTypeID v10 = buf;
      }
      else {
        CFTypeID v10 = *(unsigned char **)buf;
      }
      int v14 = 136446210;
      CFTypeID v15 = v10;
      BOOL v11 = (char *)_os_log_send_and_compose_impl();
      if (v13 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::insert(CFStringRef, const BOOL &)", "CoreLocation: %s\n", v11);
      if (v11 != (char *)__p) {
        free(v11);
      }
    }
  }
  return v6 != 0;
}

BOOL sub_1904638F8(uint64_t a1, const char *a2, unsigned __int16 *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190463964(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190463964(uint64_t a1, const __CFString *a2, unsigned __int16 *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  LODWORD(valuePtr[0]) = *a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, valuePtr);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)valuePtr);
      BOOL v7 = v16 >= 0 ? valuePtr : (void **)valuePtr[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(valuePtr[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(valuePtr, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::insert(CFStringRef, const uint16_t &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)valuePtr) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190463BF8(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190463C64(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190463C64(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt16Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::insert(CFStringRef, const short &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190463EEC(uint64_t a1, const char *a2, unsigned int *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190463F58(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190463F58(uint64_t a1, const __CFString *a2, unsigned int *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  valuePtr[0] = (void *)*a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, valuePtr);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)valuePtr);
      BOOL v7 = v16 >= 0 ? valuePtr : (void **)valuePtr[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(valuePtr[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(valuePtr, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::insert(CFStringRef, const uint32_t &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)valuePtr) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_1904641EC(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190464258(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190464258(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::insert(CFStringRef, const int64_t &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_1904644E0(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_19046454C(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_19046454C(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::insert(CFStringRef, const int &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_1904647D4(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190464840(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190464840(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::insert(CFStringRef, const long &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190464AC8(uint64_t a1, const char *a2, const void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190464B34(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190464B34(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat64Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::insert(CFStringRef, const double &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_190464DBC(uint64_t a1, const char *a2, char *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190464E28(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190464E28(uint64_t a1, const __CFString *a2, char *cStr)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x8000100u);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFStringRef))(*(void *)a1 + 928))(a1, a2, v5);
    CFRelease(v5);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::insert(CFStringRef, const char *)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return v5 != 0;
}

BOOL sub_1904650B8(uint64_t a1, const char *a2, char *a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  if (a3[23] >= 0) {
    BOOL v6 = a3;
  }
  else {
    BOOL v6 = *(char **)a3;
  }
  BOOL v7 = sub_190464E28(a1, v5, v6);
  if (v5) {
    CFRelease(v5);
  }
  return v7;
}

BOOL sub_190465130(uint64_t a1, const __CFString *a2, char *a3)
{
  if (a3[23] < 0) {
    a3 = *(char **)a3;
  }
  return sub_190464E28(a1, a2, a3);
}

uint64_t sub_190465144(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  (*(void (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 928))(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return 1;
}

uint64_t sub_1904651D4(uint64_t a1)
{
  return 1;
}

BOOL sub_190465218(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  BOOL v6 = sub_190465284(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_190465284(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFDictionaryRef *)(a3 + 8));
  if (Copy)
  {
    (*(void (**)(uint64_t, const __CFString *, CFDictionaryRef))(*(void *)a1 + 928))(a1, a2, Copy);
    CFRelease(Copy);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    BOOL v6 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(a2, (uint64_t)__p);
      BOOL v7 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "could not create cf type for key %{public}s", buf, 0xCu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      sub_1902C36AC(a2, (uint64_t)buf);
      if (v12 >= 0) {
        CFTypeID v9 = buf;
      }
      else {
        CFTypeID v9 = *(unsigned char **)buf;
      }
      int v13 = 136446210;
      int v14 = v9;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      if (v12 < 0) {
        operator delete(*(void **)buf);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::insert(CFStringRef, const CLNameValuePair &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)__p) {
        free(v10);
      }
    }
  }
  return Copy != 0;
}

uint64_t sub_19046550C(uint64_t a1, uint64_t a2, const void *a3)
{
  CFTypeRef arg = 0;
  if ((*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)a1 + 912))(a1, a2, &arg))
  {
    CFAutorelease(arg);
    CFTypeID v6 = CFGetTypeID(arg);
    if (v6 == CFArrayGetTypeID())
    {
      Mutable = (void *)arg;
    }
    else
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      CFAutorelease(Mutable);
      CFArrayAppendValue((CFMutableArrayRef)Mutable, arg);
    }
    CFTypeID v8 = CFGetTypeID(a3);
    if (v8 == CFArrayGetTypeID())
    {
      v11.length = CFArrayGetCount((CFArrayRef)a3);
      v11.location = 0;
      CFArrayAppendArray((CFMutableArrayRef)Mutable, (CFArrayRef)a3, v11);
    }
    else
    {
      CFArrayAppendValue((CFMutableArrayRef)Mutable, a3);
    }
  }
  else
  {
    Mutable = (void *)a3;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)a1 + 896))(a1, a2, Mutable);
}

uint64_t sub_190465660(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 856))();
}

CFIndex sub_19046568C(uint64_t a1)
{
  return CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 8));
}

uint64_t sub_1904656A8(uint64_t a1, const char *a2)
{
  CFStringRef v3 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, CFStringRef))(*(void *)a1 + 864))(a1, v3);
  CFRelease(v3);
  return v4;
}

uint64_t sub_190465728(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 864))();
}

uint64_t sub_190465754(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  if (!(*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)a1 + 912))(a1, a2, &cf)) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID v2 = CFGetTypeID(cf);
  if (v2 == CFArrayGetTypeID()) {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
  }
  else {
    CFIndex Count = 1;
  }
  CFRelease(cf);
  return Count;
}

BOOL sub_1904657F0(uint64_t a1)
{
  return (*(int (**)(uint64_t))(*(void *)a1 + 856))(a1) < 1;
}

BOOL sub_190465838(uint64_t a1, const char *a2)
{
  return (int)sub_1904656A8(a1, a2) < 1;
}

BOOL sub_190465858(uint64_t a1)
{
  return (*(int (**)(uint64_t))(*(void *)a1 + 864))(a1) < 1;
}

BOOL sub_1904658A0(uint64_t a1, CFDataRef *a2)
{
  CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFPropertyListRef *)(a1 + 8), kCFPropertyListXMLFormat_v1_0, 0, 0);
  *a2 = Data;
  return Data != 0;
}

uint64_t sub_1904658F0(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  CFErrorRef error = 0;
  if (v4)
  {
    CFStringRef v5 = v4;
    if (!CFWriteStreamOpen(v4))
    {
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      CFTypeID v9 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "could not open write stream", buf, 2u);
      }
      if (!sub_1902D8400(115, 0)) {
        goto LABEL_35;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
      }
      *(_WORD *)CFTypeID v19 = 0;
      CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::serializeBinary(CFDataRef *) const", "CoreLocation: %s\n", v10);
      if (v10 == (char *)buf) {
        goto LABEL_35;
      }
LABEL_51:
      free(v10);
LABEL_35:
      uint64_t v7 = 0;
LABEL_36:
      CFRelease(v5);
      if (error) {
        CFRelease(error);
      }
      return v7;
    }
    CFIndex v6 = CFPropertyListWrite(*(CFPropertyListRef *)(a1 + 8), v5, kCFPropertyListBinaryFormat_v1_0, 0, &error);
    if (!error && v6)
    {
      *a2 = CFWriteStreamCopyProperty(v5, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
      CFWriteStreamClose(v5);
      uint64_t v7 = 1;
      goto LABEL_36;
    }
    if (error)
    {
      CFIndex Code = CFErrorGetCode(error);
      if (error)
      {
        CFStringRef Domain = CFErrorGetDomain(error);
        goto LABEL_26;
      }
    }
    else
    {
      CFIndex Code = 0;
    }
    CFStringRef Domain = @"unknown error";
LABEL_26:
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    int v13 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      sub_1902C36AC(Domain, (uint64_t)buf);
      int v14 = v28 >= 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)CFTypeID v19 = 134349314;
      *(void *)&v19[4] = Code;
      __int16 v20 = 2082;
      __int16 v21 = v14;
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_FAULT, "could not write data, error code, %{public}ld, error domain, %{public}s", v19, 0x16u);
      if (v28 < 0) {
        operator delete(*(void **)buf);
      }
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_35;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    sub_1902C36AC(Domain, (uint64_t)v19);
    if (v22 >= 0) {
      uint64_t v17 = v19;
    }
    else {
      uint64_t v17 = *(unsigned char **)v19;
    }
    int v23 = 134349314;
    CFIndex v24 = Code;
    __int16 v25 = 2082;
    CFTypeID v26 = v17;
    CFTypeID v10 = (char *)_os_log_send_and_compose_impl();
    if (v22 < 0) {
      operator delete(*(void **)v19);
    }
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::serializeBinary(CFDataRef *) const", "CoreLocation: %s\n", v10);
    if (v10 == (char *)buf) {
      goto LABEL_35;
    }
    goto LABEL_51;
  }
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
  }
  CFTypeID v8 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "could not create write stream", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    *(_WORD *)CFTypeID v19 = 0;
    char v16 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::serializeBinary(CFDataRef *) const", "CoreLocation: %s\n", v16);
    if (v16 != (char *)buf) {
      free(v16);
    }
  }
  return 0;
}

BOOL sub_190465E48(void *a1, const __CFData *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v4 = objc_alloc_init(MEMORY[0x1E4F28B28]);
  CFErrorRef error = 0;
  CFPropertyListRef v5 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 1uLL, 0, &error);
  if (v5)
  {
    CFIndex v6 = (const void *)a1[1];
    if (v6) {
      CFRelease(v6);
    }
    a1[1] = v5;
    (*(void (**)(void *))(*a1 + 848))(a1);
    goto LABEL_21;
  }
  if (!error)
  {
    CFIndex Code = 0;
    goto LABEL_9;
  }
  CFIndex Code = CFErrorGetCode(error);
  if (!error)
  {
LABEL_9:
    CFStringRef Domain = @"unknown error";
    goto LABEL_10;
  }
  CFStringRef Domain = CFErrorGetDomain(error);
LABEL_10:
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
  }
  CFTypeID v9 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    if (Domain)
    {
      sub_1902C36AC(Domain, (uint64_t)__p);
      if (v24 >= 0) {
        CFTypeID v10 = __p;
      }
      else {
        CFTypeID v10 = (void **)__p[0];
      }
      *(_DWORD *)buf = 134349314;
      *(void *)&uint8_t buf[4] = Code;
      __int16 v16 = 2082;
      uint64_t v17 = (const char *)v10;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "could not create intermediate property list - %{public}ld (%{public}s)", buf, 0x16u);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      *(_DWORD *)buf = 134349314;
      *(void *)&uint8_t buf[4] = Code;
      __int16 v16 = 2082;
      uint64_t v17 = "unknown error";
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "could not create intermediate property list - %{public}ld (%{public}s)", buf, 0x16u);
    }
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD15E0);
    }
    if (Domain)
    {
      sub_1902C36AC(Domain, (uint64_t)buf);
      if (v18 >= 0) {
        char v12 = buf;
      }
      else {
        char v12 = *(const char **)buf;
      }
    }
    else
    {
      char v12 = "unknown error";
    }
    int v19 = 134349314;
    CFIndex v20 = Code;
    __int16 v21 = 2082;
    char v22 = v12;
    int v13 = (char *)_os_log_send_and_compose_impl();
    if (Domain && v18 < 0) {
      operator delete(*(void **)buf);
    }
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNameValuePair::deserialize(const CFDataRef)", "CoreLocation: %s\n", v13);
    if (v13 != (char *)__p) {
      free(v13);
    }
  }
LABEL_21:
  if (error) {
    CFRelease(error);
  }

  return v5 != 0;
}

void sub_1904661B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1904661EC(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v6 = 0;
  (*(void (**)(uint64_t, void **))(*(void *)a1 + 800))(a1, __p);
  if (qword_1E929DA88 != -1) {
    dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
  }
  uint64_t v1 = qword_1E929DA90;
  if (os_log_type_enabled((os_log_t)qword_1E929DA90, OS_LOG_TYPE_DEBUG))
  {
    CFTypeID v2 = __p;
    if (v6 < 0) {
      CFTypeID v2 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315138;
    CFTypeID v10 = v2;
    _os_log_impl(&dword_1902AF000, v1, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929DA88 != -1) {
      dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
    }
    CFStringRef v3 = __p;
    if (v6 < 0) {
      CFStringRef v3 = (void **)__p[0];
    }
    int v7 = 136315138;
    CFTypeID v8 = v3;
    id v4 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLNameValuePair::print() const", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1904663FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19046641C(uint64_t a1, std::string *a2)
{
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 8);
  if (!v4 || !CFDictionaryGetCount(v4))
  {
    JUMPOUT(0x192FCC770);
  }
  memset(&context, 0, sizeof(context));
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 8), (CFDictionaryApplierFunction)sub_1904664E0, &context);
  std::string::operator=(a2, &context);
  if (SHIBYTE(context.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(context.__r_.__value_.__l.__data_);
  }
}

void sub_1904664C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904664E0(const __CFString *a1, const __CFString *a2, std::string *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v27 = 0;
    sub_1902C371C(a1, (uint64_t)__p);
    CFTypeID v7 = CFGetTypeID(a2);
    if (v7 == CFDictionaryGetTypeID())
    {
      int v8 = SHIBYTE(v27);
      CFTypeID v9 = (void **)__p[0];
      CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a2);
      uint64_t v11 = __p;
      if (v8 < 0) {
        uint64_t v11 = v9;
      }
      snprintf(__str, 0x100uLL, "%s = <dictionary (%ld entries)>:\n", (const char *)v11, Count);
      std::string::append(a3, __str);
      CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)sub_1904664E0, a3);
    }
    else
    {
      CFTypeID v14 = CFGetTypeID(a2);
      if (v14 == CFArrayGetTypeID())
      {
        v15.length = CFArrayGetCount((CFArrayRef)a2);
        __int16 v16 = __p;
        if (v27 < 0) {
          __int16 v16 = (void **)__p[0];
        }
        std::string context = v16;
        uint64_t v24 = 0;
        uint64_t v25 = a3;
        v15.location = 0;
        CFArrayApplyFunction((CFArrayRef)a2, v15, (CFArrayApplierFunction)sub_190467314, &context);
      }
      else
      {
        CFTypeID v17 = CFGetTypeID(a2);
        if (v17 == CFStringGetTypeID())
        {
          std::string context = 0;
          uint64_t v24 = 0;
          uint64_t v25 = 0;
          if (sub_1902C371C(a2, (uint64_t)&context))
          {
            char v18 = __p;
            if (v27 < 0) {
              char v18 = (void **)__p[0];
            }
            p_std::string context = (const char *)&context;
            if (SHIBYTE(v25) < 0) {
              p_std::string context = (const char *)context;
            }
            snprintf(__str, 0x100uLL, "%s = %s\n", (const char *)v18, p_context);
          }
          std::string::append(a3, __str);
          if (SHIBYTE(v25) < 0) {
            operator delete(context);
          }
        }
        else
        {
          CFTypeID v20 = CFGetTypeID(a2);
          if (v20 == CFNumberGetTypeID())
          {
            std::string context = 0;
            if (sub_190460B30(a2, &context))
            {
              __int16 v21 = __p;
              if (v27 < 0) {
                __int16 v21 = (void **)__p[0];
              }
              snprintf(__str, 0x100uLL, "%s = %0.6f\n", (const char *)v21, *(double *)&context);
            }
            std::string::append(a3, __str);
          }
          else
          {
            CFTypeID v22 = CFGetTypeID(a2);
            if (v22 == CFBooleanGetTypeID())
            {
              CFBooleanGetValue((CFBooleanRef)a2);
              snprintf(__str, 0x100uLL, "%s = %d\n");
            }
            else
            {
              CFGetTypeID(a2);
              snprintf(__str, 0x100uLL, "%s = <unhandled value type %lu>\n");
            }
            std::string::append(a3, __str);
          }
        }
      }
    }
    if (SHIBYTE(v27) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    CFTypeID v12 = CFGetTypeID(a1);
    CFTypeID TypeID = CFStringGetTypeID();
    snprintf(__str, 0x100uLL, "type ID does not match - %lu vs %lu\n", v12, TypeID);
    std::string::append(a3, __str);
  }
}

void sub_190466818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_190466860(const __CFString *a1, const __CFString *a2)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    v50[0] = 0;
    v50[1] = 0;
    uint64_t v51 = 0;
    sub_1902C371C(a1, (uint64_t)v50);
    CFTypeID v5 = CFGetTypeID(a2);
    if (v5 == CFDictionaryGetTypeID())
    {
      if (qword_1E929DA88 != -1) {
        dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
      }
      CFTypeID v6 = qword_1E929DA90;
      if (os_log_type_enabled((os_log_t)qword_1E929DA90, OS_LOG_TYPE_DEBUG))
      {
        int v7 = SHIBYTE(v51);
        int v8 = (void **)v50[0];
        CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a2);
        CFTypeID v10 = v50;
        if (v7 < 0) {
          CFTypeID v10 = v8;
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = v10;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = Count;
        _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEBUG, "\t%s = <dictionary (%ld entries)>:", buf, 0x16u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929DA88 != -1) {
          dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
        }
        int v38 = SHIBYTE(v51);
        __int16 v39 = (void **)v50[0];
        CFTypeID v40 = (void *)CFDictionaryGetCount((CFDictionaryRef)a2);
        uint64_t v41 = v50;
        if (v38 < 0) {
          uint64_t v41 = v39;
        }
        LODWORD(__p[0]) = 136315394;
        *(void **)((char *)__p + 4) = v41;
        WORD2(__p[1]) = 2048;
        *(void **)((char *)&__p[1] + 6) = v40;
        uint64_t v42 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "static void CLNameValuePair::printKeyValue(const void *, const void *, void *)", "CoreLocation: %s\n", v42);
        if (v42 != buf) {
          free(v42);
        }
      }
      CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)sub_190466860, 0);
      goto LABEL_63;
    }
    CFTypeID v11 = CFGetTypeID(a2);
    if (v11 == CFArrayGetTypeID())
    {
      v12.length = CFArrayGetCount((CFArrayRef)a2);
      *(_OWORD *)&uint8_t buf[8] = 0uLL;
      int v13 = v50;
      if (v51 < 0) {
        int v13 = (void **)v50[0];
      }
      *(void *)buf = v13;
      v12.location = 0;
      CFArrayApplyFunction((CFArrayRef)a2, v12, (CFArrayApplierFunction)sub_19046728C, buf);
      goto LABEL_63;
    }
    CFTypeID v14 = CFGetTypeID(a2);
    if (v14 == CFStringGetTypeID())
    {
      memset(__p, 0, 24);
      if (sub_1902C371C(a2, (uint64_t)__p))
      {
        if (qword_1E929DA88 != -1) {
          dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
        }
        CFRange v15 = qword_1E929DA90;
        if (os_log_type_enabled((os_log_t)qword_1E929DA90, OS_LOG_TYPE_DEBUG))
        {
          __int16 v16 = v50;
          if (v51 < 0) {
            __int16 v16 = (void **)v50[0];
          }
          CFTypeID v17 = __p;
          if (SHIBYTE(__p[2]) < 0) {
            CFTypeID v17 = (void **)__p[0];
          }
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = v16;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v17;
          _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_DEBUG, "\t%s = %s", buf, 0x16u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929DA88 != -1) {
            dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
          }
          float v43 = v50;
          if (v51 < 0) {
            float v43 = (void **)v50[0];
          }
          uint64_t v44 = __p;
          if (SHIBYTE(__p[2]) < 0) {
            uint64_t v44 = (void **)__p[0];
          }
          *(_DWORD *)unint64_t v52 = 136315394;
          *(void *)&v52[4] = v43;
          __int16 v53 = 2080;
          __int16 v54 = v44;
          float v45 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "static void CLNameValuePair::printKeyValue(const void *, const void *, void *)", "CoreLocation: %s\n", v45);
          if (v45 != buf) {
            free(v45);
          }
        }
      }
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_63;
    }
    CFTypeID v18 = CFGetTypeID(a2);
    if (v18 == CFNumberGetTypeID())
    {
      *(void *)unint64_t v52 = 0;
      if (!sub_190460B30(a2, v52)) {
        goto LABEL_63;
      }
      if (qword_1E929DA88 != -1) {
        dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
      }
      int v19 = qword_1E929DA90;
      if (os_log_type_enabled((os_log_t)qword_1E929DA90, OS_LOG_TYPE_DEBUG))
      {
        CFTypeID v20 = v50;
        if (v51 < 0) {
          CFTypeID v20 = (void **)v50[0];
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = v20;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = *(void *)v52;
        _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_DEBUG, "\t%s = %0.6f", buf, 0x16u);
      }
      if (!sub_1902D8400(115, 2)) {
        goto LABEL_63;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929DA88 != -1) {
        dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
      }
      __int16 v21 = v50;
      if (v51 < 0) {
        __int16 v21 = (void **)v50[0];
      }
      LODWORD(__p[0]) = 136315394;
      *(void **)((char *)__p + 4) = v21;
      WORD2(__p[1]) = 2048;
      *(void **)((char *)&__p[1] + 6) = *(void **)v52;
      CFTypeID v22 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "static void CLNameValuePair::printKeyValue(const void *, const void *, void *)", "CoreLocation: %s\n", v22);
      if (v22 == buf) {
        goto LABEL_63;
      }
    }
    else
    {
      CFTypeID v23 = CFGetTypeID(a2);
      if (v23 == CFBooleanGetTypeID())
      {
        if (qword_1E929DA88 != -1) {
          dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
        }
        uint64_t v24 = qword_1E929DA90;
        if (os_log_type_enabled((os_log_t)qword_1E929DA90, OS_LOG_TYPE_DEBUG))
        {
          int v25 = SHIBYTE(v51);
          CFTypeID v26 = (void **)v50[0];
          int Value = CFBooleanGetValue((CFBooleanRef)a2);
          char v28 = v50;
          if (v25 < 0) {
            char v28 = v26;
          }
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = v28;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = Value;
          _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_DEBUG, "\t%s = %d", buf, 0x12u);
        }
        if (!sub_1902D8400(115, 2)) {
          goto LABEL_63;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1E929DA88 != -1) {
          dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
        }
        int v29 = SHIBYTE(v51);
        CFTypeID v30 = (void **)v50[0];
        int v31 = CFBooleanGetValue((CFBooleanRef)a2);
        CFTypeID v32 = v50;
        if (v29 < 0) {
          CFTypeID v32 = v30;
        }
        LODWORD(__p[0]) = 136315394;
        *(void **)((char *)__p + 4) = v32;
        WORD2(__p[1]) = 1024;
        *(_DWORD *)((char *)&__p[1] + 6) = v31;
        CFTypeID v22 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "static void CLNameValuePair::printKeyValue(const void *, const void *, void *)", "CoreLocation: %s\n", v22);
      }
      else
      {
        if (qword_1E929DA88 != -1) {
          dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
        }
        uint64_t v33 = qword_1E929DA90;
        if (os_log_type_enabled((os_log_t)qword_1E929DA90, OS_LOG_TYPE_DEBUG))
        {
          int v34 = SHIBYTE(v51);
          uint64_t v35 = (void **)v50[0];
          CFTypeID v36 = CFGetTypeID(a2);
          __int16 v37 = v50;
          if (v34 < 0) {
            __int16 v37 = v35;
          }
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = v37;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v36;
          _os_log_impl(&dword_1902AF000, v33, OS_LOG_TYPE_DEBUG, "\t%s = <unhandled value type %lu>", buf, 0x16u);
        }
        if (!sub_1902D8400(115, 2)) {
          goto LABEL_63;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1E929DA88 != -1) {
          dispatch_once(&qword_1E929DA88, &unk_1EDFD3BE0);
        }
        int v46 = SHIBYTE(v51);
        float v47 = (void **)v50[0];
        uint64_t v48 = (void *)CFGetTypeID(a2);
        float v49 = v50;
        if (v46 < 0) {
          float v49 = v47;
        }
        LODWORD(__p[0]) = 136315394;
        *(void **)((char *)__p + 4) = v49;
        WORD2(__p[1]) = 2048;
        *(void **)((char *)&__p[1] + 6) = v48;
        CFTypeID v22 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "static void CLNameValuePair::printKeyValue(const void *, const void *, void *)", "CoreLocation: %s\n", v22);
      }
      if (v22 == buf)
      {
LABEL_63:
        if (SHIBYTE(v51) < 0) {
          operator delete(v50[0]);
        }
        return;
      }
    }
    free(v22);
    goto LABEL_63;
  }
}

void sub_190467220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19046728C(uint64_t a1, uint64_t a2)
{
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s[%d]", *(void *)a2, *(unsigned int *)(a2 + 8));
  sub_190466860(v4, a1);
  ++*(_DWORD *)(a2 + 8);

  CFRelease(v4);
}

void sub_190467314(uint64_t a1, uint64_t a2)
{
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s[%d]", *(void *)a2, *(unsigned int *)(a2 + 8));
  sub_1904664E0(v4, a1, *(void *)(a2 + 16));
  ++*(_DWORD *)(a2 + 8);

  CFRelease(v4);
}

os_log_t sub_1904673A0()
{
  os_log_t result = os_log_create("com.apple.locationd.Core", "Core");
  qword_1E929D6A0 = (uint64_t)result;
  return result;
}

os_log_t sub_1904673D0()
{
  os_log_t result = os_log_create("com.apple.locationd.Legacy", "Direct_deprecated");
  qword_1E929DA90 = (uint64_t)result;
  return result;
}

void *sub_190467400(void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    sub_190347B9C();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    CFTypeID v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    CFTypeID v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

uint64_t sub_1904674AC(uint64_t a1)
{
  *(void *)a1 = &unk_1EDFC7648;
  pthread_mutex_destroy(*(pthread_mutex_t **)(a1 + 8));
  uint64_t v4 = *(void *)(a1 + 8);
  CFTypeID v5 = *(void **)(v4 + 104);
  if (v5)
  {
    free(v5);
    uint64_t v4 = *(void *)(a1 + 8);
    *(void *)(v4 + 104) = 0;
  }
  objc_msgSend_assertInside(*(void **)(v4 + 64), v2, v3);

  uint64_t v6 = *(void *)(a1 + 8);
  if (v6) {
    MEMORY[0x192FCC980](v6, 0x10B0C4016A090D5);
  }
  return a1;
}

void sub_190467544(uint64_t a1)
{
  sub_1904674AC(a1);

  JUMPOUT(0x192FCC980);
}

pthread_t sub_19046757C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  objc_msgSend_assertInside(*(void **)(*(void *)(a1 + 8) + 64), a2, a3);
  if (pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 8)))
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
    }
    CFTypeID v11 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "error == 0";
      _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    CFRange v12 = off_1EB3BE880;
    if (os_signpost_enabled((os_log_t)off_1EB3BE880))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "error == 0";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CSI assertion failed", "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    int v13 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "error == 0";
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    goto LABEL_50;
  }
  pthread_t result = pthread_self();
  uint64_t v5 = *(void *)(a1 + 8);
  int v6 = *(_DWORD *)(v5 + 72);
  if (v6 < 0)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
    }
    CFTypeID v14 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "info->fCount >= 0";
      _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    CFRange v15 = off_1EB3BE880;
    if (os_signpost_enabled((os_log_t)off_1EB3BE880))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "info->fCount >= 0";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CSI assertion failed", "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    __int16 v16 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "info->fCount >= 0";
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    goto LABEL_50;
  }
  size_t v7 = *(_opaque_pthread_t **)(v5 + 80);
  if (!v6)
  {
    if (!v7) {
      goto LABEL_17;
    }
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
    }
    CFTypeID v17 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "(info->fCount > 0) || (info->fOwner == __null)";
      _os_log_impl(&dword_1902AF000, v17, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    CFTypeID v18 = off_1EB3BE880;
    if (os_signpost_enabled((os_log_t)off_1EB3BE880))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "(info->fCount > 0) || (info->fOwner == __null)";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v18, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CSI assertion failed", "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    int v19 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "(info->fCount > 0) || (info->fOwner == __null)";
      _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
LABEL_50:
    abort_report_np();
  }
  if (v7 != result)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
    }
    size_t v8 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "(info->fCount == 0) || (info->fOwner == curThread)";
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    CFTypeID v9 = off_1EB3BE880;
    if (os_signpost_enabled((os_log_t)off_1EB3BE880))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "(info->fCount == 0) || (info->fOwner == curThread)";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CSI assertion failed", "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    CFTypeID v10 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      int v21 = 0;
      __int16 v22 = 2082;
      CFTypeID v23 = "";
      __int16 v24 = 2082;
      int v25 = "assert";
      __int16 v26 = 2081;
      uint64_t v27 = "(info->fCount == 0) || (info->fOwner == curThread)";
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    goto LABEL_50;
  }
LABEL_17:
  *(_DWORD *)(v5 + 72) = v6 + 1;
  *(void *)(v5 + 80) = result;
  return result;
}

uint64_t sub_190467E8C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  objc_msgSend_assertInside(*(void **)(*(void *)(a1 + 8) + 64), a2, a3);
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(_DWORD *)(v4 + 72);
  if (v5 <= 0)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
    }
    size_t v8 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      int v15 = 0;
      __int16 v16 = 2082;
      CFTypeID v17 = "";
      __int16 v18 = 2082;
      int v19 = "assert";
      __int16 v20 = 2081;
      int v21 = "info->fCount > 0";
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    CFTypeID v9 = off_1EB3BE880;
    if (os_signpost_enabled((os_log_t)off_1EB3BE880))
    {
      *(_DWORD *)buf = 68289539;
      int v15 = 0;
      __int16 v16 = 2082;
      CFTypeID v17 = "";
      __int16 v18 = 2082;
      int v19 = "assert";
      __int16 v20 = 2081;
      int v21 = "info->fCount > 0";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CSI assertion failed", "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    CFTypeID v10 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      int v15 = 0;
      __int16 v16 = 2082;
      CFTypeID v17 = "";
      __int16 v18 = 2082;
      int v19 = "assert";
      __int16 v20 = 2081;
      int v21 = "info->fCount > 0";
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
LABEL_27:
    abort_report_np();
  }
  int v6 = v5 - 1;
  *(_DWORD *)(v4 + 72) = v6;
  if (!v6) {
    *(void *)(v4 + 80) = 0;
  }
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)v4);
  if (result)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
    }
    CFTypeID v11 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      int v15 = 0;
      __int16 v16 = 2082;
      CFTypeID v17 = "";
      __int16 v18 = 2082;
      int v19 = "assert";
      __int16 v20 = 2081;
      int v21 = "error == 0";
      _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    CFRange v12 = off_1EB3BE880;
    if (os_signpost_enabled((os_log_t)off_1EB3BE880))
    {
      *(_DWORD *)buf = 68289539;
      int v15 = 0;
      __int16 v16 = 2082;
      CFTypeID v17 = "";
      __int16 v18 = 2082;
      int v19 = "assert";
      __int16 v20 = 2081;
      int v21 = "error == 0";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CSI assertion failed", "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1600);
      }
    }
    int v13 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      int v15 = 0;
      __int16 v16 = 2082;
      CFTypeID v17 = "";
      __int16 v18 = 2082;
      int v19 = "assert";
      __int16 v20 = 2081;
      int v21 = "error == 0";
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    goto LABEL_27;
  }
  return result;
}

BOOL sub_190468368(uint64_t a1, const char *a2, uint64_t a3)
{
  int v3 = (int)a2;
  objc_msgSend_assertInside(*(void **)(*(void *)(a1 + 8) + 64), a2, a3);
  return *(_DWORD *)(*(void *)(a1 + 8) + 72) == v3;
}

BOOL sub_1904683A8(uint64_t a1, const char *a2, uint64_t a3)
{
  objc_msgSend_assertInside(*(void **)(*(void *)(a1 + 8) + 64), a2, a3);
  pthread_t v4 = *(pthread_t *)(*(void *)(a1 + 8) + 80);
  return v4 == pthread_self();
}

BOOL sub_1904683E8(uint64_t a1, const char *a2, uint64_t a3)
{
  objc_msgSend_assertInside(*(void **)(*(void *)(a1 + 8) + 64), a2, a3);
  pthread_t v4 = *(pthread_t *)(*(void *)(a1 + 8) + 80);
  return v4 != pthread_self();
}

uint64_t sub_190468428(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void sub_190468430(uint64_t a1, char a2, int a3, char a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = sub_1902C4008(a1, a3);
  char v8 = *(unsigned char *)(v7 + 8);
  *(void *)(v7 + 256) = 0;
  *(void *)(v7 + 264) = 0;
  *(unsigned char *)(v7 + 272) = 0;
  *(void *)(v7 + 208) = 0;
  *(void *)(v7 + 216) = 0;
  *(_WORD *)(v7 + 224) = 0;
  *(unsigned char *)(v7 + 273) = v8;
  *(void *)uint64_t v7 = &unk_1EDFC98E0;
  *(void *)(v7 + 200) = &unk_1EDFC9950;
  *(_DWORD *)(v7 + 276) = 0;
  *(void *)(v7 + 280) = 0;
  *(_DWORD *)(v7 + 288) = -1;
  *(unsigned char *)(v7 + 292) = a4;
  *(_DWORD *)(v7 + 296) = 1127481344;
  uint64_t v9 = sub_1902B4534();
  *(void *)buf = sub_1902B4DA8(v9, (double *)(a1 + 24));
  sub_190514A64(a1 + 304, buf, a1 + 16, (double *)(a1 + 32), a2);
}

void sub_190468688(_Unwind_Exception *a1)
{
  sub_190515334(v3);
  sub_190445960(v2);
  sub_1905B1F7C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1904686B8(void *a1)
{
  *a1 = &unk_1EDFC98E0;
  CFTypeID v2 = a1 + 25;
  a1[25] = &unk_1EDFC9950;
  sub_19046884C((uint64_t)a1);
  sub_190515334(a1 + 38);
  sub_190445960(v2);

  return sub_1905B1F7C((uint64_t)a1);
}

uint64_t sub_190468744(uint64_t a1)
{
  return sub_1904686B8((void *)(a1 - 200));
}

void sub_19046874C(void *a1)
{
  sub_1904686B8(a1);

  JUMPOUT(0x192FCC980);
}

void sub_190468784(uint64_t a1)
{
  sub_1904686B8((void *)(a1 - 200));

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904687C0(uint64_t a1)
{
  sub_190515454(a1 + 304);
  *(_DWORD *)(a1 + 276) = 0;
  *(void *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 288) = -1;
  *(_DWORD *)(a1 + 296) = 1127481344;
  sub_190445C68(a1 + 200);
  sub_190445A68(a1 + 200);
  sub_190445B8C(a1 + 200);
  sub_190445D5C(a1 + 200);
  uint64_t v3 = 2;
  return sub_1905B224C(a1, &v3);
}

void *sub_19046884C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 200);
  sub_1904459B8((void *)(a1 + 200));
  sub_1902DE10C((uint64_t)v1);
  sub_1902DE0A4(v1);

  return sub_1902DE03C(v1);
}

void sub_190468898(uint64_t a1, int a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 56))
  {
    if (*(unsigned __int8 *)(a1 + 292) != a2)
    {
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1620);
      }
      uint64_t v3 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEFAULT))
      {
        int v4 = *(unsigned __int8 *)(a1 + 292);
        *(_DWORD *)buf = 67240192;
        int v7 = v4;
        _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "North reference overridden as %{public}d by first client", buf, 8u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1620);
        }
        int v5 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionService9Axis::useNorthRef(BOOL)", "CoreLocation: %s\n", v5);
        if (v5 != (char *)buf) {
          free(v5);
        }
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 292) = a2;
  }
}

void sub_190468A64(uint64_t a1, uint64_t a2)
{
  int v4 = (double *)(a1 + 304);
  float v5 = *(float *)(a2 + 12);
  double v26 = *(float *)(a2 + 8);
  *(double *)v25.i64 = v5;
  double v44 = *(float *)(a2 + 16);
  sub_190515774(a1 + 304, (float64x2_t *)&v26, (uint64_t)&v25, &v44, (void *)a2);
  double v7 = *(double *)(a1 + 320);
  double v8 = *(double *)(a1 + 344);
  double v10 = *(double *)(a1 + 328);
  double v9 = *(double *)(a1 + 336);
  if (*(double *)(a1 + 480) <= 0.0)
  {
    float v11 = 0.0;
    float v12 = 0.0;
    float v13 = 0.0;
  }
  else
  {
    float v11 = *(float *)(a1 + 656) - (v8 * (v10 + v10) - v7 * (v9 + v9));
    float v12 = *(float *)(a1 + 660) - (-(v8 * (v7 + v7)) - v10 * (v9 + v9));
    float v13 = *(float *)(a1 + 664) - (v7 * (v7 + v7) + -1.0 + v10 * (v10 + v10));
  }
  int v14 = *(_DWORD *)(a1 + 460);
  v6.i64[0] = *(void *)(a1 + 464);
  uint64_t v24 = v6.i64[0];
  float32x4_t v27 = 0uLL;
  double v26 = -1.0;
  float32x4_t v15 = sub_1902D9ACC(&v27, v6);
  uint64_t v37 = 0;
  int v36 = 0;
  double v26 = *(double *)a2;
  v15.i32[1] = HIDWORD(v26);
  v15.f32[0] = v7;
  *(float *)&unsigned int v16 = v10;
  *(float *)&unsigned int v17 = v9;
  *(float *)&unsigned int v18 = v8;
  v25.i64[0] = __PAIR64__(v16, v15.u32[0]);
  v25.i64[1] = __PAIR64__(v18, v17);
  sub_1902D9ACC(&v25, v15);
  *(void *)&long long v19 = v24;
  float32x4_t v27 = v25;
  float v28 = v11;
  float v29 = v12;
  float v30 = v13;
  int v31 = v14;
  int v20 = *(_DWORD *)(a1 + 284);
  *((void *)&v19 + 1) = *(void *)(a1 + 276);
  long long v32 = v19;
  int v33 = v20;
  char v38 = *(_DWORD *)(a1 + 288);
  float v21 = sub_190516C68(v4);
  int v22 = *(_DWORD *)(a1 + 296);
  float v34 = v21;
  int v35 = v22;
  char v39 = 1;
  __int16 v40 = (*(unsigned __int8 *)(a1 + 312) << 8) | (*(unsigned __int8 *)(a1 + 315) << 13) | (8
                                                                                        * *(unsigned __int8 *)(a1 + 313)) | (16 * *(unsigned __int8 *)(a1 + 252));
  if (*(unsigned char *)(a1 + 292)) {
    int v23 = 15;
  }
  else {
    int v23 = 7;
  }
  int v41 = v23;
  uint64_t v43 = 0;
  char v42 = *(unsigned char *)(a2 + 22);
  sub_1902D9B30(a1, (uint64_t)&v26);
}

void sub_190468C70(uint64_t a1, uint64_t a2)
{
}

void sub_190468C78(uint64_t a1, float32x2_t *a2, float *a3)
{
}

void sub_190468C80(uint64_t a1, float32x2_t *a2, float *a3)
{
}

void sub_190468C88(uint64_t a1, uint64_t a2)
{
  float v2 = *(float *)(a2 + 12);
  double v5 = *(float *)(a2 + 8);
  double v3 = *(float *)(a2 + 16);
  double v4 = v2;
  sub_190516E18(a1 + 304, &v5, &v4, &v3, (void *)a2);
}

void sub_190468CD8(uint64_t a1, uint64_t a2)
{
}

void sub_190468CE0(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  long long v4 = *(_OWORD *)(a2 + 56);
  long long v23 = *(_OWORD *)(a2 + 40);
  long long v24 = v4;
  long long v25 = *(_OWORD *)(a2 + 72);
  uint64_t v26 = *(void *)(a2 + 88);
  long long v5 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)int v22 = *(_OWORD *)(a2 + 8);
  *(_OWORD *)&v22[16] = v5;
  if ((sub_1902CD6B0() & 0x10) != 0 && (DWORD1(v23) - 1) <= 4) {
    DWORD1(v23) = dword_190607B80[DWORD1(v23) - 1];
  }
  buf[0] = *(unsigned char *)(a1 + 272);
  BOOL v6 = sub_190518E94(a1 + 304, (uint64_t *)v22, buf, (unsigned char *)(a1 + 292), (double *)a2);
  unint64_t v20 = 0;
  float v21 = 0.0;
  if (*(unsigned char *)(a1 + 313))
  {
    *(float *)&unsigned int v7 = *(double *)(a1 + 680);
    *(float *)&unsigned int v8 = *(double *)(a1 + 688);
    unint64_t v20 = __PAIR64__(v8, v7);
    float v9 = *(double *)(a1 + 696);
    float v21 = v9;
    double v10 = *(float *)&v7;
    double v11 = *(float *)&v8;
    double v12 = v9;
  }
  else
  {
    double v12 = 0.0;
    double v11 = 0.0;
    double v10 = 0.0;
  }
  if (*(unsigned char *)(a1 + 8))
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1620);
    }
    float v13 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      int v14 = *(unsigned __int8 *)(a1 + 272);
      *(_DWORD *)buf = 134219008;
      double v38 = v10;
      __int16 v39 = 2048;
      double v40 = v11;
      __int16 v41 = 2048;
      double v42 = v12;
      __int16 v43 = 1024;
      int v44 = v14;
      __int16 v45 = 1024;
      BOOL v46 = v6;
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_DEBUG, "correctedCompassExt, %.3f, %.3f, %.3f, %u, %u", buf, 0x2Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1620);
      }
      int v18 = *(unsigned __int8 *)(a1 + 272);
      int v27 = 134219008;
      double v28 = v10;
      __int16 v29 = 2048;
      double v30 = v11;
      __int16 v31 = 2048;
      double v32 = v12;
      __int16 v33 = 1024;
      int v34 = v18;
      __int16 v35 = 1024;
      BOOL v36 = v6;
      long long v19 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionService9Axis::feedCompassData(const CLCompass_Type::Sample *)", "CoreLocation: %s\n", v19);
      if (v19 != (char *)buf) {
        free(v19);
      }
    }
  }
  if (v6)
  {
    uint64_t v15 = sub_190559E34();
    (*(void (**)(uint64_t, uint64_t, unint64_t *))(*(void *)v15 + 64))(v15, 1, &v20);
  }
  int v16 = DWORD1(v23);
  *(_DWORD *)(a1 + 288) = DWORD1(v23);
  *(_DWORD *)(a1 + 296) = v23;
  if (v16 <= 0)
  {
    *(_DWORD *)(a1 + 276) = 0;
    *(void *)(a1 + 280) = 0;
  }
  else
  {
    if ((sub_1902CD6B0() & 0x10) != 0)
    {
      *(_DWORD *)(a1 + 284) = *(_DWORD *)&v22[20];
      uint64_t v17 = *(void *)&v22[12];
    }
    else
    {
      *(_DWORD *)(a1 + 284) = *(_DWORD *)&v22[8];
      uint64_t v17 = *(void *)v22;
    }
    *(void *)(a1 + 276) = v17;
  }
}

void sub_190469050(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_19046A998(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v2 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return sub_190384DEC(a2);
}

void sub_19046A9DC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1902D8B58(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_19046AFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  if (a11) {
    sub_1902D8B58(a11);
  }
  sub_190384FCC((uint64_t)va);
  _Unwind_Resume(a1);
}

os_log_t sub_19046B07C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Fall");
  qword_1E929D8F0 = (uint64_t)result;
  return result;
}

void sub_19046B0AC()
{
}

uint64_t sub_19046B0C4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_19046B0CC(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void sub_19046B0DC()
{
}

BOOL sub_19046B0F0()
{
  CFBooleanRef v0 = (const __CFBoolean *)MGCopyAnswer();
  if (!v0) {
    return 0;
  }
  CFBooleanRef v1 = v0;
  CFTypeID v2 = CFGetTypeID(v0);
  BOOL v3 = v2 == CFBooleanGetTypeID() && CFBooleanGetValue(v1) != 0;
  CFRelease(v1);
  return v3;
}

void sub_19046B164(uint64_t a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BE978, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB3BE978))
  {
    unk_1EB3BEA20 = 0;
    xmmword_1EB3BEA10 = 0uLL;
    __cxa_atexit(MEMORY[0x1E4FBA210], &xmmword_1EB3BEA10, &dword_1902AF000);
    __cxa_guard_release(&qword_1EB3BE978);
  }
  if (qword_1EB3BE980 != -1) {
    dispatch_once(&qword_1EB3BE980, &unk_1EDFC2020);
  }
  if (byte_1EB3BEA27 < 0)
  {
    long long v2 = xmmword_1EB3BEA10;
    sub_190347AFC((unsigned char *)a1, (void *)v2, *((unint64_t *)&v2 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_1EB3BEA10;
    *(void *)(a1 + 16) = unk_1EB3BEA20;
  }
}

void *sub_19046B254()
{
  v19[2] = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v0 = (const __CFDictionary *)_CFCopyServerVersionDictionary();
  if (!v0)
  {
    CFDictionaryRef v0 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
    if (!v0)
    {
      JUMPOUT(0x192FCC770);
    }
  }
  sub_19045CAD8(v18, v0);
  CFRelease(v0);
  v16[0] = 0;
  v16[1] = 0;
  uint64_t v17 = 0;
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v15 = 0;
  __n128 __p = 0;
  std::string::size_type v12 = 0;
  uint64_t v13 = 0;
  if (!sub_19045F4DC((uint64_t)v18, *MEMORY[0x1E4F1CD18], (uint64_t)v14)) {
    MEMORY[0x192FCC770](v14, "<name>");
  }
  if (!sub_19045F4DC((uint64_t)v18, *MEMORY[0x1E4F1CD30], (uint64_t)v16)) {
    MEMORY[0x192FCC770](v16, "<version>");
  }
  if (!sub_19045F4DC((uint64_t)v18, *MEMORY[0x1E4F1CD10], (uint64_t)&__p)) {
    MEMORY[0x192FCC770](&__p, "<build>");
  }
  sub_19046B55C((const void **)v14, v16, (uint64_t)&v9);
  CFBooleanRef v1 = std::string::append(&v9, "/");
  long long v2 = *(_OWORD *)&v1->__r_.__value_.__l.__data_;
  v10.__r_.__value_.__r.__words[2] = v1->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v10.__r_.__value_.__l.__data_ = v2;
  v1->__r_.__value_.__l.__size_ = 0;
  v1->__r_.__value_.__r.__words[2] = 0;
  v1->__r_.__value_.__r.__words[0] = 0;
  if (v13 >= 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if (v13 >= 0) {
    std::string::size_type v4 = HIBYTE(v13);
  }
  else {
    std::string::size_type v4 = v12;
  }
  long long v5 = std::string::append(&v10, p_p, v4);
  std::string::size_type v6 = v5->__r_.__value_.__r.__words[0];
  v19[0] = v5->__r_.__value_.__l.__size_;
  *(void *)((char *)v19 + 7) = *(std::string::size_type *)((char *)&v5->__r_.__value_.__r.__words[1] + 7);
  char v7 = HIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (byte_1EB3BEA27 < 0) {
    operator delete((void *)xmmword_1EB3BEA10);
  }
  *(void *)&xmmword_1EB3BEA10 = v6;
  *((void *)&xmmword_1EB3BEA10 + 1) = v19[0];
  *(void *)((char *)&xmmword_1EB3BEA10 + 15) = *(void *)((char *)v19 + 7);
  byte_1EB3BEA27 = v7;
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)v16[0]);
  }
  return sub_19045CCC8(v18);
}

void sub_19046B4D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  if (*(char *)(v34 - 73) < 0) {
    operator delete(*(void **)(v34 - 96));
  }
  sub_19045CCC8((void *)(v34 - 72));
  _Unwind_Resume(a1);
}

uint64_t sub_19046B55C@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (*((char *)a2 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  uint64_t result = sub_190395000(a3, v6 + v5);
  if (*(char *)(result + 23) >= 0) {
    unsigned int v8 = (char *)result;
  }
  else {
    unsigned int v8 = *(char **)result;
  }
  if (v5)
  {
    if (*((char *)a1 + 23) >= 0) {
      std::string v9 = a1;
    }
    else {
      std::string v9 = *a1;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }
  std::string v10 = &v8[v5];
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0) {
      double v11 = a2;
    }
    else {
      double v11 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v6);
  }
  v10[v6] = 0;
  return result;
}

void sub_19046B628(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BE988, memory_order_acquire) & 1) == 0)
  {
    uint64_t v3 = a1;
    int v4 = __cxa_guard_acquire(&qword_1EB3BE988);
    a1 = v3;
    if (v4)
    {
      unk_1EB3BEA38 = 0;
      xmmword_1EB3BEA28 = 0uLL;
      __cxa_atexit(MEMORY[0x1E4FBA210], &xmmword_1EB3BEA28, &dword_1902AF000);
      __cxa_guard_release(&qword_1EB3BE988);
      a1 = v3;
    }
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_19046B768;
  block[3] = &unk_1E568CF68;
  block[4] = a1;
  if (qword_1EB3BE990 != -1) {
    dispatch_once(&qword_1EB3BE990, block);
  }
  if (byte_1EB3BEA3F < 0)
  {
    sub_190347AFC((unsigned char *)a2, (void *)xmmword_1EB3BEA28, *((unint64_t *)&xmmword_1EB3BEA28 + 1));
  }
  else
  {
    *(_OWORD *)a2 = xmmword_1EB3BEA28;
    *(void *)(a2 + 16) = unk_1EB3BEA38;
  }
}

double sub_19046B768()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  size_t v4 = 128;
  if (sysctlbyname("hw.model", v5, &v4, 0, 0)) {
    CFDictionaryRef v0 = "";
  }
  else {
    CFDictionaryRef v0 = v5;
  }
  sub_1902C3F54(&v2, v0);
  if (byte_1EB3BEA3F < 0) {
    operator delete((void *)xmmword_1EB3BEA28);
  }
  double result = *(double *)&v2;
  xmmword_1EB3BEA28 = v2;
  unk_1EB3BEA38 = v3;
  return result;
}

void sub_19046B82C(uint64_t a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BE998, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB3BE998))
  {
    unk_1EB3BEA50 = 0;
    xmmword_1EB3BEA40 = 0uLL;
    __cxa_atexit(MEMORY[0x1E4FBA210], &xmmword_1EB3BEA40, &dword_1902AF000);
    __cxa_guard_release(&qword_1EB3BE998);
  }
  if (qword_1EB3BE9A0 != -1) {
    dispatch_once(&qword_1EB3BE9A0, &unk_1EDFD4180);
  }
  if (byte_1EB3BEA57 < 0)
  {
    long long v2 = xmmword_1EB3BEA40;
    sub_190347AFC((unsigned char *)a1, (void *)v2, *((unint64_t *)&v2 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_1EB3BEA40;
    *(void *)(a1 + 16) = unk_1EB3BEA50;
  }
}

void sub_19046B91C()
{
  sub_190470604(&__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)p_p, 0x8000100u);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v2)
  {
    CFTypeID v3 = CFGetTypeID(v2);
    if (v3 == CFStringGetTypeID())
    {
      CFURLRef v4 = CFURLCreateWithFileSystemPath(v1, v2, kCFURLPOSIXPathStyle, 0);
      if (v4)
      {
        CFStringRef v5 = (const __CFString *)v4;
        uint64_t v6 = CFBundleCreate(v1, v4);
        if (v6)
        {
          char v7 = v6;
          CFStringRef ValueForInfoDictionaryKey = (const __CFString *)CFBundleGetValueForInfoDictionaryKey(v6, (CFStringRef)*MEMORY[0x1E4F1D020]);
          if (ValueForInfoDictionaryKey)
          {
            CFStringRef v9 = ValueForInfoDictionaryKey;
            CFTypeID v10 = CFGetTypeID(ValueForInfoDictionaryKey);
            if (v10 == CFStringGetTypeID())
            {
              sub_1902C36AC(v9, (uint64_t)&__p);
              if (byte_1EB3BEA40[23] < 0) {
                operator delete(*(void **)byte_1EB3BEA40);
              }
              *(std::string *)byte_1EB3BEA40 = __p;
            }
          }
          CFRelease(v2);
          CFStringRef v2 = v5;
        }
        else
        {
          char v7 = (__CFBundle *)v5;
        }
        CFRelease(v2);
        CFStringRef v2 = (CFStringRef)v7;
      }
    }
    CFRelease(v2);
  }
}

void sub_19046BA78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19046BA94(uint64_t a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BE9A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB3BE9A8))
  {
    unk_1EB3BEA68 = 0;
    xmmword_1EB3BEA58 = 0uLL;
    __cxa_atexit(MEMORY[0x1E4FBA210], &xmmword_1EB3BEA58, &dword_1902AF000);
    __cxa_guard_release(&qword_1EB3BE9A8);
  }
  if (qword_1EB3BE9B0 != -1) {
    dispatch_once(&qword_1EB3BE9B0, &unk_1EDFD41A0);
  }
  if (byte_1EB3BEA6F < 0)
  {
    long long v2 = xmmword_1EB3BEA58;
    sub_190347AFC((unsigned char *)a1, (void *)v2, *((unint64_t *)&v2 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_1EB3BEA58;
    *(void *)(a1 + 16) = unk_1EB3BEA68;
  }
}

uint64_t sub_19046BB84()
{
  mach_port_t v0 = *MEMORY[0x1E4F2EEF0];
  CFDictionaryRef v1 = IOServiceMatching("IOPlatformExpertDevice");
  uint64_t result = IOServiceGetMatchingService(v0, v1);
  if (result)
  {
    io_object_t v3 = result;
    CFStringRef CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(result, @"IOPlatformSerialNumber", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (CFProperty)
    {
      CFStringRef v5 = CFProperty;
      sub_1902C36AC(CFProperty, (uint64_t)&v6);
      if (byte_1EB3BEA6F < 0) {
        operator delete((void *)xmmword_1EB3BEA58);
      }
      xmmword_1EB3BEA58 = v6;
      unk_1EB3BEA68 = v7;
      CFRelease(v5);
    }
    return IOObjectRelease(v3);
  }
  return result;
}

uint64_t sub_19046BC40()
{
  if (qword_1EB3BE9D0 != -1) {
    dispatch_once(&qword_1EB3BE9D0, &unk_1EDFD4220);
  }
  return byte_1EB3BE953;
}

BOOL sub_19046BC84()
{
  if (MGGetBoolAnswer()) {
    return 1;
  }
  if (qword_1EB3BEA08 != -1) {
    dispatch_once(&qword_1EB3BEA08, &unk_1EDFD42E0);
  }
  return byte_1EB3BE958 != 0;
}

uint64_t sub_19046BCE8()
{
  if (qword_1EB3BE9B8 != -1) {
    dispatch_once(&qword_1EB3BE9B8, &unk_1EDFD41C0);
  }
  return byte_1EB3BE950;
}

void sub_19046BD2C()
{
  mach_port_t v0 = (const void *)MGCopyAnswer();
  if (v0)
  {
    CFDictionaryRef v1 = v0;
    if (CFEqual(v0, @"iPad")) {
      byte_1EB3BE950 = 1;
    }
    CFRelease(v1);
  }
}

uint64_t sub_19046BD9C()
{
  if (qword_1EB3BE9C8 != -1) {
    dispatch_once(&qword_1EB3BE9C8, &unk_1EDFD4200);
  }
  return byte_1EB3BE952;
}

uint64_t sub_19046BDE0(uint64_t a1, const char *a2, uint64_t a3)
{
  if (qword_1EB3BE9C0 != -1) {
    dispatch_once(&qword_1EB3BE9C0, &unk_1EDFD41E0);
  }
  if (byte_1EB3BE951 == 1)
  {
    io_object_t v3 = objc_msgSend_processInfo(MEMORY[0x1E4F28F80], a2, a3);
    uint64_t result = objc_msgSend_isiOSAppOnMac(v3, v4, v5);
  }
  else
  {
    uint64_t result = 0;
  }
  byte_1EB3BE952 = result;
  return result;
}

uint64_t sub_19046BE4C()
{
  if (qword_1EB3BE9E0 != -1) {
    dispatch_once(&qword_1EB3BE9E0, &unk_1EDFD4260);
  }
  return byte_1EB3BE955;
}

void sub_19046BE90()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  CFBooleanRef v0 = (const __CFBoolean *)MGCopyAnswer();
  CFBooleanRef v1 = v0;
  if (v0)
  {
    CFTypeID v2 = CFGetTypeID(v0);
    if (v2 == CFBooleanGetTypeID())
    {
      byte_1EB3BE955 = CFBooleanGetValue(v1) != 0;
LABEL_10:
      CFRelease(v1);
      return;
    }
  }
  if (qword_1E929DA68 != -1) {
    dispatch_once(&qword_1E929DA68, &unk_1EDFD42C0);
  }
  io_object_t v3 = qword_1E929DA70;
  if (os_log_type_enabled((os_log_t)qword_1E929DA70, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_FAULT, "unexpected MGCopyAnswer answer", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929DA68 != -1) {
      dispatch_once(&qword_1E929DA68, &unk_1EDFD42C0);
    }
    CFURLRef v4 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "BOOL CLPlatformInfo::supportsCrudeProx()_block_invoke", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  if (v1) {
    goto LABEL_10;
  }
}

uint64_t sub_19046C114()
{
  if (qword_1EB3BE968 != -1) {
    dispatch_once(&qword_1EB3BE968, &unk_1EDFD1660);
  }
  if (qword_1EB3BE970 != -1) {
    dispatch_once(&qword_1EB3BE970, &unk_1EDFC1FE0);
  }
  uint64_t result = 1;
  if (((dword_1EB3BE95C - 139) > 0x2D
     || ((1 << (dword_1EB3BE95C + 117)) & 0x3FFFE000001DLL) == 0)
    && (dword_1EB3BE95C - 219) >= 7
    && (dword_1EB3BE95C - 78) >= 3)
  {
    return 0;
  }
  return result;
}

uint64_t sub_19046C1C4()
{
  if (qword_1EB3BE9B8 != -1) {
    dispatch_once(&qword_1EB3BE9B8, &unk_1EDFD41C0);
  }
  if (byte_1EB3BE950) {
    return 1;
  }
  if (qword_1EB3BE9F8 != -1) {
    dispatch_once(&qword_1EB3BE9F8, &unk_1EDFC1BC0);
  }
  return BYTE2(qword_1EB3BEA00) >> 7;
}

uint64_t sub_19046C248()
{
  if (qword_1EB3BE9E8 != -1) {
    dispatch_once(&qword_1EB3BE9E8, &unk_1EDFD4280);
  }
  return byte_1EB3BE956;
}

uint64_t sub_19046C28C(uint64_t a1, const char *a2, uint64_t a3)
{
  io_object_t v3 = objc_msgSend_processInfo(MEMORY[0x1E4F28F80], a2, a3);
  uint64_t v6 = objc_msgSend_processName(v3, v4, v5);
  uint64_t result = objc_msgSend_compare_(v6, v7, @"locationd");
  byte_1EB3BE956 = result == 0;
  return result;
}

void sub_19046C6E4(uint64_t a1, const char *a2)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = @"IOPropertyMatch";
  v8[0] = &unk_1EE001980;
  CFTypeID v2 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], a2, (uint64_t)v8, &v7, 1);
  io_service_t MatchingService = IOServiceGetMatchingService(*MEMORY[0x1E4F2EEF0], (CFDictionaryRef)v2);
  if (MatchingService)
  {
    byte_1EB3BE957 = 1;
    IOObjectRelease(MatchingService);
  }
  else
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD4300);
    }
    CFURLRef v4 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEFAULT, "Compass service missing", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD4300);
      }
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "static BOOL CLPlatformInfo::supportsCompass()_block_invoke", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
}

uint64_t sub_19046CD44()
{
  if (qword_1EB3BE9D0 != -1) {
    dispatch_once(&qword_1EB3BE9D0, &unk_1EDFD4220);
  }
  return 0;
}

BOOL sub_19046CD84()
{
  if (qword_1EB3BE970 != -1) {
    dispatch_once(&qword_1EB3BE970, &unk_1EDFC1FE0);
  }
  return dword_1EB3BE95C == 196;
}

os_log_t sub_19046CDD0()
{
  os_log_t result = os_log_create("com.apple.locationd.Utility", "Utility");
  qword_1E929DA70 = (uint64_t)result;
  return result;
}

void sub_19046CE00()
{
  CFBooleanRef v0 = (void *)MEMORY[0x192FCD2F0]();
  byte_1EB3BE958 = 0;
  CFStringRef v1 = (const __CFString *)*MEMORY[0x1E4F1D3C8];
  CFPropertyListRef v2 = CFPreferencesCopyValue(@"StoreDemoMode", @"com.apple.demo-settings", @"mobile", (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  if (v2)
  {
    io_object_t v3 = v2;
    CFAutorelease(v2);
    CFTypeID v4 = CFGetTypeID(v3);
    if (v4 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue((CFBooleanRef)v3))
      {
        CFPropertyListRef v5 = CFPreferencesCopyValue(@"FProgramNumber", @"com.apple.demo-settings", @"mobile", v1);
        if (v5)
        {
          uint64_t v6 = v5;
          CFAutorelease(v5);
          CFTypeID v7 = CFGetTypeID(v6);
          if (v7 == CFNumberGetTypeID())
          {
            int valuePtr = 0;
            if (CFNumberGetValue((CFNumberRef)v6, kCFNumberIntType, &valuePtr)) {
              byte_1EB3BE958 = valuePtr == 5;
            }
          }
        }
      }
    }
  }
}

os_log_t sub_19046CF14()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Sensors");
  qword_1E929D7B0 = (uint64_t)result;
  return result;
}

os_log_t sub_19046F940()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Swimming");
  qword_1E929D8C0 = (uint64_t)result;
  return result;
}

void sub_19046F970()
{
}

void sub_19046FA9C(void *a1)
{
}

void sub_19046FAA8(_Unwind_Exception *a1)
{
}

void sub_19046FADC(void *a1@<X8>)
{
  if (qword_1EB3BEA70 != -1) {
    dispatch_once_f(&qword_1EB3BEA70, 0, (dispatch_function_t)sub_19046F970);
  }
  uint64_t v2 = *(void *)(qword_1EB3BEA78 + 144);
  *a1 = *(void *)(qword_1EB3BEA78 + 136);
  a1[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void *sub_19046FB50(void *a1)
{
  *a1 = &unk_1EDFC8788;
  uint64_t v2 = (std::__shared_weak_count *)a1[18];
  if (v2) {
    sub_1902D8B58(v2);
  }

  return sub_19047E7E8((uint64_t)a1);
}

void sub_19046FBB0(void *a1)
{
  sub_19046FB50(a1);

  JUMPOUT(0x192FCC980);
}

void sub_19046FBEC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19046FC28(uint64_t a1, uint64_t a2)
{
  if (sub_1903885B4(a2, (uint64_t)&unk_1EDFC4678)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_190470210(int a1@<W0>, std::string *a2@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1 == 3)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3760);
    }
    CFTypeID v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEFAULT))
    {
      v12.__r_.__value_.__r.__words[0] = 0x304020100;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_DEFAULT, "no mutable store path for type, %{public}d", (uint8_t *)&v12, 8u);
    }
    if (!sub_1902D8400(115, 2)) {
      goto LABEL_28;
    }
    bzero(&v12, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3760);
    }
    v13[0] = (void *)0x304020100;
    unsigned int v8 = (std::string *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "static std::string CLPersistentStore::getMutableStorePath(CLPersistentStoreType)", "CoreLocation: %s\n", (const char *)v8);
    goto LABEL_33;
  }
  if (a1)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3760);
    }
    CFStringRef v9 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      LODWORD(v12.__r_.__value_.__l.__data_) = 67240192;
      HIDWORD(v12.__r_.__value_.__r.__words[0]) = a1;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "could not get mutable store path for type, %{public}d", (uint8_t *)&v12, 8u);
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_28;
    }
    bzero(&v12, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3760);
    }
    LODWORD(v13[0]) = 67240192;
    HIDWORD(v13[0]) = a1;
    unsigned int v8 = (std::string *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "static std::string CLPersistentStore::getMutableStorePath(CLPersistentStoreType)", "CoreLocation: %s\n", (const char *)v8);
LABEL_33:
    if (v8 != &v12) {
      free(v8);
    }
LABEL_28:
    a2->__r_.__value_.__r.__words[0] = 0;
    a2->__r_.__value_.__l.__size_ = 0;
    a2->__r_.__value_.__r.__words[2] = 0;
    return;
  }
  sub_1902C3F54(__p, "root");
  sub_1902B90E0((uint64_t)__p, &v12);
  sub_1902C3F54(v13, "/Library/Caches/locationd/");
  if ((v14 & 0x80u) == 0) {
    CFTypeID v4 = (const std::string::value_type *)v13;
  }
  else {
    CFTypeID v4 = (const std::string::value_type *)v13[0];
  }
  if ((v14 & 0x80u) == 0) {
    std::string::size_type v5 = v14;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)v13[1];
  }
  uint64_t v6 = std::string::append(&v12, v4, v5);
  *a2 = *v6;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if ((char)v14 < 0) {
    operator delete(v13[0]);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
  if (v11 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1904705B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (*(char *)(v23 - 57) < 0) {
    operator delete(*(void **)(v23 - 80));
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_190470604(std::string *a1@<X8>)
{
  sub_1902DF048(&v3);
  uint64_t v2 = std::string::append(&v3, "/System/Library/Frameworks/CoreLocation.framework");
  *a1 = *v2;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v3.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v3.__r_.__value_.__l.__data_);
  }
}

void sub_19047066C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_190471910(_Unwind_Exception *a1)
{
  if (*(char *)(v2 - 49) < 0) {
    operator delete(*(void **)(v2 - 72));
  }
  MEMORY[0x192FCC980](v1, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

uint64_t sub_19047194C(uint64_t a1, CLConnectionMessage **a2)
{
  CFTypeID v4 = NSString;
  uint64_t v5 = CLConnectionMessage::name(*a2);
  if (*(char *)(v5 + 23) >= 0) {
    uint64_t v7 = objc_msgSend_stringWithUTF8String_(v4, v6, v5);
  }
  else {
    uint64_t v7 = objc_msgSend_stringWithUTF8String_(v4, v6, *(void *)v5);
  }
  uint64_t v8 = v7;
  CFStringRef v9 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v10 = objc_opt_class();
  uint64_t v11 = objc_opt_class();
  uint64_t v12 = objc_opt_class();
  uint64_t v13 = objc_opt_class();
  uint64_t v15 = (NSSet *)objc_msgSend_setWithObjects_(v9, v14, v10, v11, v12, v13, 0);
  if (*a2) {
    CLConnectionMessage::getDictionaryOfClasses(*a2, v15);
  }
  uint64_t v16 = *(void *)(a1 + 32);

  return MEMORY[0x1F4181798](v16, sel__handleDaemonMessage_data_, v8);
}

void sub_190471A44(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D978 != -1) {
    dispatch_once(&qword_1E929D978, &unk_1EDFD16C0);
  }
  uint64_t v2 = qword_1E929D980;
  if (os_log_type_enabled((os_log_t)qword_1E929D980, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    v4[0] = 68289283;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    __int16 v7 = 2049;
    uint64_t v8 = v3;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Client connection interrupt\", \"self\":\"%{private}p\"}", (uint8_t *)v4, 0x1Cu);
  }
}

void sub_190471C10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_190472130(uint64_t a1)
{
  objc_loadWeak((id *)(*(void *)(a1 + 32) + 32));
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    id Weak = objc_loadWeak((id *)(*(void *)(a1 + 32) + 32));
    id v4 = objc_loadWeak((id *)(*(void *)(a1 + 32) + 40));
    return MEMORY[0x1F4181798](Weak, sel_distributedSensingManager_didFailToSubscribeToVehicleState_, v4);
  }
  return result;
}

uint64_t sub_1904721B0(uint64_t a1)
{
  objc_loadWeak((id *)(*(void *)(a1 + 32) + 32));
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    id Weak = objc_loadWeak((id *)(*(void *)(a1 + 32) + 32));
    id v4 = objc_loadWeak((id *)(*(void *)(a1 + 32) + 40));
    return MEMORY[0x1F4181798](Weak, sel_distributedSensingManager_didUpdateVehicleState_, v4);
  }
  return result;
}

void sub_1904722A4(uint64_t a1)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(a1 + 32) + 8))
  {
    sub_1902C3F54(&__p, "DistributedSensing/kCLConnectionMessageDistributedSensingVehicleStateUpdate");
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 3221225472;
    v5[3] = sub_190472448;
    v5[4] = &unk_1E568D558;
    v5[5] = *(void *)(a1 + 32);
    CLConnectionClient::setHandlerForMessage();
    if (v8 < 0) {
      operator delete(__p);
    }
    uint64_t v9 = @"kCLConnectionMessageSubscribeKey";
    v10[0] = MEMORY[0x1E4F1CC38];
    v5[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v2, (uint64_t)v10, &v9, 1);
    sub_190472A4C(&__p, v5);
    uint64_t v3 = v7;
    id v4 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v4) {
      sub_1902D8B58(v4);
    }
    if (v3) {
      sub_1902D8B58(v3);
    }
  }
}

void sub_190472404(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  if (v22) {
    sub_1902D8B58(v22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_190472448(uint64_t a1, CLConnectionMessage **a2)
{
  id v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v9 = (NSSet *)objc_msgSend_setWithObjects_(v4, v8, v5, v6, v7, 0);
  CLConnectionMessage::getDictionaryOfClasses(*a2, v9);
  uint64_t v10 = *(void *)(a1 + 32);

  return MEMORY[0x1F4181798](v10, sel__handleDaemonMessage_data_, @"DistributedSensing/kCLConnectionMessageDistributedSensingVehicleStateUpdate");
}

void sub_19047256C(uint64_t a1)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(a1 + 32) + 8))
  {
    sub_1902C3F54(&__p, "DistributedSensing/kCLConnectionMessageDistributedSensingVehicleStateUpdate");
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 3221225472;
    v5[3] = sub_190472710;
    v5[4] = &unk_1E568D558;
    v5[5] = *(void *)(a1 + 32);
    CLConnectionClient::setHandlerForMessage();
    if (v8 < 0) {
      operator delete(__p);
    }
    uint64_t v9 = @"kCLConnectionMessageSubscribeKey";
    v10[0] = MEMORY[0x1E4F1CC28];
    v5[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v2, (uint64_t)v10, &v9, 1);
    sub_190472A4C(&__p, v5);
    uint64_t v3 = v7;
    id v4 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v4) {
      sub_1902D8B58(v4);
    }
    if (v3) {
      sub_1902D8B58(v3);
    }
  }
}

void sub_1904726CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  if (v22) {
    sub_1902D8B58(v22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_190472710(uint64_t a1, CLConnectionMessage **a2)
{
  id v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v9 = (NSSet *)objc_msgSend_setWithObjects_(v4, v8, v5, v6, v7, 0);
  CLConnectionMessage::getDictionaryOfClasses(*a2, v9);
  uint64_t v10 = *(void *)(a1 + 32);

  return MEMORY[0x1F4181798](v10, sel__handleDaemonMessage_data_, @"DistributedSensing/kCLConnectionMessageDistributedSensingVehicleStateUpdate");
}

void sub_1904728F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_19047296C;
  block[3] = &unk_1E568D118;
  block[4] = v1;
  dispatch_sync(v2, block);
}

uint64_t sub_19047296C(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__teardown(*(void **)(a1 + 32), a2, a3);
}

os_log_t sub_190472A1C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "DistributedSensing");
  qword_1E929D980 = (uint64_t)result;
  return result;
}

void sub_190472A4C(void *a1, void *a2)
{
  id v4 = operator new(0x70uLL);
  v4[1] = 0;
  _DWORD v4[2] = 0;
  *id v4 = &unk_1EDFD0DA0;
  sub_1902C3F54(__p, "DistributedSensing/kCLConnectionMessageDistributedSensingVehicleStateUpdate");
  MEMORY[0x192FCC420](v4 + 3, __p, *a2);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_190472AE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::__shared_weak_count::~__shared_weak_count(v15);
  operator delete(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_190472B14()
{
  if (qword_1EB3BE920 != -1) {
    dispatch_once(&qword_1EB3BE920, &unk_1EDFD16E0);
  }
  return qword_1EB3BF7F8;
}

void sub_190472B5C(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v8 = sub_1902D6BD0();
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = sub_190472BF4;
  v9[3] = &unk_1E568D640;
  v9[4] = a1;
  v9[5] = a2;
  char v10 = a3;
  v9[6] = a4;
  sub_1902CDE98(v8, (uint64_t)v9);
}

uint64_t sub_190472BF4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 56), *(void *)(a1 + 48));
}

void sub_190472C28(uint64_t a1)
{
  uint64_t v2 = sub_1902D6BD0();
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = sub_190472CA4;
  v3[3] = &unk_1E568CF68;
  v3[4] = a1;
  sub_1902CDE98(v2, (uint64_t)v3);
}

uint64_t sub_190472CA4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))();
}

uint64_t sub_190473210(uint64_t a1)
{
  *(unsigned char *)a1 = 0;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(void *)(a1 + 36) = 0x3F80000000000000;
  sub_1902D9ACC((float32x4_t *)(a1 + 28), (float32x4_t)0);
  *(_OWORD *)(a1 + 44) = xmmword_190608E30;
  sub_1902D9ACC((float32x4_t *)(a1 + 44), (float32x4_t)xmmword_190608E30);
  unint64_t v2 = 0;
  *(void *)(a1 + 64) = 0xA000000000;
  *(void *)(a1 + 10320) = 0xFFFFFFFFLL;
  *(unsigned char *)(a1 + 10328) = 0;
  *(void *)(a1 + 1352) = 0xA000000000;
  *(_OWORD *)(a1 + 10336) = 0u;
  *(void *)(a1 + 10360) = 0x200000000;
  *(void *)(a1 + 10384) = 0x200000000;
  int v6 = 0;
  memset(v5, 0, sizeof(v5));
  do
  {
    if (v2 > 2)
    {
      uint64_t v3 = (_DWORD *)sub_19047336C((uint64_t)v5, v2, v2);
      if (v2 > 5) {
        _DWORD *v3 = 952607315;
      }
      else {
        _DWORD *v3 = 980151802;
      }
    }
    else
    {
      *(_DWORD *)sub_19047336C((uint64_t)v5, v2, v2) = 944879383;
    }
    ++v2;
  }
  while (v2 != 9);
  sub_1904736CC(a1 + 10668, (uint64_t)v5);
  return a1;
}

uint64_t sub_19047336C(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    uint64_t v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 9;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 77,invalid row %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMMatrix<float, 9>::operator()(size_t, size_t) [T = float, M = 9, N = 9]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (a3 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    uint64_t v9 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a3;
      __int16 v13 = 2048;
      uint64_t v14 = 9;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 78,invalid col %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      char v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMMatrix<float, 9>::operator()(size_t, size_t) [T = float, M = 9, N = 9]", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  return a1 + 4 * (9 * a3 + a2);
}

uint64_t sub_1904736CC(uint64_t a1, uint64_t a2)
{
  BOOL v4 = 0;
  unint64_t v5 = 0;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  while (2)
  {
    unint64_t v6 = v5++;
    unint64_t v7 = v5;
    do
    {
      float v8 = sub_1904794E8(a2, v6, v7);
      float v9 = v8 - sub_1904794E8(a2, v7, v6);
      if (v9 <= 0.0) {
        float v9 = -v9;
      }
      if (v9 > 1.0e-16)
      {
        if (v4) {
          goto LABEL_10;
        }
        return 0;
      }
      ++v7;
    }
    while (v7 != 9);
    BOOL v4 = v6 > 6;
    if (v5 != 8) {
      continue;
    }
    break;
  }
LABEL_10:
  unint64_t v10 = 9;
  unint64_t v11 = 8;
  while (1)
  {
    unint64_t v12 = v11;
    float v13 = sub_1904794E8(a2, v11, v11);
    unint64_t v14 = v10;
    if (v10 <= 8)
    {
      do
      {
        float v15 = *(float *)sub_190479848(a1 + 36, v12, v14);
        float v16 = *(float *)sub_190479848(a1 + 36, v12, v14);
        float v13 = v13 + (float)((float)-(float)(v15 * v16) * *(float *)sub_190479BA4(a1, v14++));
      }
      while (v14 != 9);
    }
    *(float *)sub_190479BA4(a1, v12) = v13;
    if (*(float *)sub_190479BA4(a1, v12) <= 0.0) {
      break;
    }
    if (!v12) {
      return 1;
    }
    unint64_t v17 = v10 - 2;
    do
    {
      unint64_t v18 = v17;
      float v19 = sub_1904794E8(a2, v17, v12);
      unint64_t v20 = v10;
      if (v10 <= 8)
      {
        do
        {
          float v21 = *(float *)sub_190479848(a1 + 36, v18, v20);
          float v22 = *(float *)sub_190479848(a1 + 36, v12, v20);
          float v19 = v19 + (float)((float)-(float)(v21 * v22) * *(float *)sub_190479BA4(a1, v20++));
        }
        while (v20 != 9);
      }
      float v23 = v19 / *(float *)sub_190479BA4(a1, v12);
      *(float *)sub_190479848(a1 + 36, v18, v12) = v23;
      unint64_t v17 = v18 - 1;
    }
    while (v18);
    unint64_t v11 = v12 - 1;
    unint64_t v10 = v12;
  }
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
  }
  long long v24 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134217984;
    unint64_t v28 = v12;
    _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_DEBUG, "D(%zu) <= 0 non-positive definite matrix!", buf, 0xCu);
  }
  uint64_t result = sub_1902D8400(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "BOOL CMFactoredMatrix<float, 9>::factor(const CMMatrix<T, N, N> &) [T = float, N = 9]", "CoreLocation: %s\n", v26);
    if (v26 != (char *)buf) {
      free(v26);
    }
    return 0;
  }
  return result;
}

double sub_190473A70(uint64_t a1)
{
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 1352) = 0;
  *(_DWORD *)(a1 + 10360) = 0;
  *(_DWORD *)(a1 + 10384) = 0;
  *(_OWORD *)uint64_t v3 = 0u;
  *(void *)&v3[16] = 0x3F80000000000000;
  sub_1902D9ACC((float32x4_t *)&v3[8], (float32x4_t)0);
  float32x4_t v4 = (float32x4_t)xmmword_190608E30;
  sub_1902D9ACC(&v4, (float32x4_t)xmmword_190608E30);
  *(_OWORD *)(a1 + 4) = 0u;
  *(void *)(a1 + 20) = *(void *)v3;
  *(_OWORD *)(a1 + 28) = *(_OWORD *)&v3[8];
  *(float32x4_t *)(a1 + 44) = v4;
  *(unsigned char *)a1 = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 10336) = 0u;
  return result;
}

double sub_190473B04(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0;
  uint64_t v5 = a1 + 4;
  uint64_t v6 = a1 + 16;
  do
  {
    float v7 = sub_190473BE4(a2, v4);
    float v8 = (float *)sub_19042D844(v5, v4);
    *float v8 = v7 + *v8;
    float v9 = sub_190473BE4(a2, v4 + 3);
    unint64_t v10 = (float *)sub_19042D844(v6, v4);
    *unint64_t v10 = v9 + *v10;
    ++v4;
  }
  while (v4 != 3);
  int v11 = *(_DWORD *)(a2 + 32);
  uint64_t v16 = *(void *)(a2 + 24);
  int v17 = v11;
  *(double *)v12.i64 = sub_1904CF7FC(&v15, (float *)&v16);
  sub_1904CF3F4((uint64_t)&v15, (float *)(a1 + 28), &v14, v12);
  double result = *(double *)v14.i64;
  *(float32x4_t *)(a1 + 28) = v14;
  return result;
}

float sub_190473BE4(uint64_t a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    uint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 9;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 271,invalid index %zu >= %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMVector<float, 9>::operator[](const size_t) const [T = float, N = 9]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return *(float *)(a1 + 4 * a2);
}

void sub_190473DC0(uint64_t a1, float32x2_t *a2, float *a3, uint64_t a4, float a5, float a6)
{
  uint64_t v10 = 0;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  float v11 = 0.0;
  do
  {
    float v11 = v11 + (float)(a2->f32[v10] * a2->f32[v10]);
    ++v10;
  }
  while (v10 != 3);
  if (sqrtf(v11) <= 0.000001) {
    goto LABEL_22;
  }
  uint64_t v12 = 0;
  float v13 = 0.0;
  do
  {
    float v13 = v13 + (float)(a3[v12] * a3[v12]);
    ++v12;
  }
  while (v12 != 3);
  if (sqrtf(v13) <= 0.000001)
  {
LABEL_22:
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    uint64_t v29 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl(&dword_1902AF000, v29, OS_LOG_TYPE_ERROR, "[CMRelDMSensorFusionMekf] Unexpected 0 accel magnitude.", (uint8_t *)buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      LOWORD(v37[0]) = 0;
      double v30 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMSensorFusionMekf::relativeGravityUpdate(const CMVector3d &, const CMVector3d &, float, float, uint64_t, BOOL)", "CoreLocation: %s\n", v30);
      if (v30 != (char *)buf) {
        free(v30);
      }
    }
  }
  else
  {
    uint64_t v14 = 0;
    int32x2_t v15 = 0;
    do
    {
      *(float *)v15.i32 = *(float *)v15.i32 + (float)(a2->f32[v14] * a2->f32[v14]);
      ++v14;
    }
    while (v14 != 3);
    uint64_t v16 = 0;
    float32x2_t v17 = *a2;
    float v18 = 0.0;
    do
    {
      float v18 = v18 + (float)(a3[v16] * a3[v16]);
      ++v16;
    }
    while (v16 != 3);
    *(float *)v15.i32 = sqrtf(*(float *)v15.i32);
    int32x2_t v31 = v15;
    float v19 = a2[1].f32[0] / *(float *)v15.i32;
    float v20 = sqrtf(v18);
    float v21 = sub_1904CF73C((float *)(a1 + 28), *a3 / v20, a3[1] / v20, a3[2] / v20);
    uint64_t v22 = 0;
    float32x2_t v39 = vsub_f32(vdiv_f32(v17, (float32x2_t)vdup_lane_s32(v31, 0)), (float32x2_t)__PAIR64__(LODWORD(v23), LODWORD(v21)));
    float v40 = v19 - v24;
    memset(buf, 0, 108);
    LODWORD(v34) = 0;
    *((float *)&v34 + 1) = v24;
    *((float *)&v34 + 2) = -v23;
    *((float *)&v34 + 3) = -v24;
    LODWORD(v35) = 0;
    *(void *)((char *)&v35 + 4) = __PAIR64__(LODWORD(v23), LODWORD(v21));
    *((float *)&v35 + 3) = -v21;
    int v36 = 0;
    do
    {
      *(float *)((char *)&v34 + v22) = *(float *)((char *)&v34 + v22) + *(float *)((char *)&v34 + v22);
      v22 += 4;
    }
    while (v22 != 36);
    unint64_t v25 = 0;
    v37[0] = v34;
    v37[1] = v35;
    int v38 = v36;
    do
    {
      for (unint64_t i = 0; i != 3; ++i)
      {
        float v27 = sub_1904741A8((uint64_t)v37, v25, i);
        *(float *)sub_190474508((uint64_t)buf, v25, i + 6) = v27;
      }
      ++v25;
    }
    while (v25 != 3);
    if (a5 == 0.0) {
      a5 = (float)(unint64_t)(a4 - *(void *)(a1 + 10352)) * 0.000001;
    }
    float v28 = (float)((float)(0.0000009617 / a5) + 0.021638) + (float)((float)(0.0000009617 / a5) + 0.021638);
    if (v28 < a6) {
      float v28 = a6;
    }
    *(float *)__int16 v33 = v28;
    *(float *)&v33[1] = v28;
    *(float *)&v33[2] = v28;
    sub_190474868((uint64_t)v32, (float *)(a1 + 10488), (uint64_t)buf, (uint64_t)v33, (uint64_t)&v39);
    sub_190473B04(a1, (uint64_t)v32);
    *(void *)(a1 + 10352) = a4;
  }
}

float sub_1904741A8(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 3)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    float v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 3;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 70,invalid row %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      unint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMMatrix<float, 3>::operator()(size_t, size_t) const [T = float, M = 3, N = 3]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (a3 >= 3)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    __int16 v9 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a3;
      __int16 v13 = 2048;
      uint64_t v14 = 3;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 71,invalid col %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMMatrix<float, 3>::operator()(size_t, size_t) const [T = float, M = 3, N = 3]", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  return *(float *)(a1 + 4 * (3 * a3 + a2));
}

uint64_t sub_190474508(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 3)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    float v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 3;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 77,invalid row %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      unint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMMatrix<float, 3, 9>::operator()(size_t, size_t) [T = float, M = 3, N = 9]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (a3 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    __int16 v9 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a3;
      __int16 v13 = 2048;
      uint64_t v14 = 9;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 78,invalid col %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMMatrix<float, 3, 9>::operator()(size_t, size_t) [T = float, M = 3, N = 9]", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  return a1 + 4 * (3 * a3 + a2);
}

void sub_190474868(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v8 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = (uint64_t)(a2 + 9);
  int v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
LABEL_2:
  unint64_t v10 = 0;
  uint64_t v11 = -1;
  do
  {
    float v12 = sub_190479D80(a3, v8, v10);
    unint64_t v13 = v11;
    if (v10)
    {
      do
      {
        float v14 = sub_190479D80(a3, v8, v13);
        float v12 = v12 + (float)(v14 * *(float *)sub_190479848(v9, v13--, v10));
      }
      while (v13 != -1);
    }
    v46[v10] = v12;
    v45[v10] = v12 * *(float *)sub_190479BA4((uint64_t)a2, v10);
    ++v10;
    ++v11;
  }
  while (v10 != 9);
  float v15 = sub_190448408(a4, v8);
  float v16 = v15 + (float)(v46[0] * v45[0]);
  if (v16 <= 0.0)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    long long v34 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      unint64_t v44 = v8;
      _os_log_impl(&dword_1902AF000, v34, OS_LOG_TYPE_DEBUG, "%zu: alpha <= 0, matrix ! positive definite", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      int v41 = 134217984;
      unint64_t v42 = v8;
LABEL_33:
      long long v35 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "CMVector<T, N> CMFactoredMatrix<float, 9>::biermanObservationalUpdate(const CMMatrix<T, P, N> &, const CMVector<T, P> &, const CMVector<T, P> &) [T = float, N = 9, P = 3UL]", "CoreLocation: %s\n", v35);
      if (v35 != (char *)buf) {
        free(v35);
      }
    }
  }
  else
  {
    float v17 = 1.0 / v16;
    *a2 = *a2 * (float)((float)(1.0 / v16) * sub_190448408(a4, v8));
    unint64_t v18 = 1;
    while (1)
    {
      float v19 = v46[v18];
      float v20 = v16 + (float)(v19 * v45[v18]);
      if (v20 <= 0.0) {
        break;
      }
      float v21 = -(float)(v19 * v17);
      float v17 = 1.0 / v20;
      uint64_t v22 = (float *)sub_190479BA4((uint64_t)a2, v18);
      unint64_t v23 = 0;
      *uint64_t v22 = (float)(v16 * (float)(1.0 / v20)) * *v22;
      do
      {
        float v24 = *(float *)sub_190479848(v9, v23, v18);
        float v25 = v45[v23];
        uint64_t v26 = (float *)sub_190479848(v9, v23, v18);
        float v27 = v45[v18];
        *uint64_t v26 = v24 + (float)(v25 * v21);
        v45[v23++] = v25 + (float)(v27 * v24);
      }
      while (v18 != v23);
      ++v18;
      float v16 = v20;
      if (v18 == 9)
      {
        unint64_t v28 = 0;
        float v29 = v17 * sub_190448408(a5, v8);
        do
        {
          float v30 = v45[v28];
          int32x2_t v31 = (float *)sub_19047A0E0((uint64_t)&v38, v28);
          *int32x2_t v31 = *v31 + (float)(v29 * v30);
          ++v28;
        }
        while (v28 != 9);
        if (++v8 == 3)
        {
          long long v32 = v39;
          *(_OWORD *)a1 = v38;
          *(_OWORD *)(a1 + 16) = v32;
          *(_DWORD *)(a1 + 32) = v40;
          return;
        }
        goto LABEL_2;
      }
    }
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    __int16 v33 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      unint64_t v44 = v8;
      _os_log_impl(&dword_1902AF000, v33, OS_LOG_TYPE_DEBUG, "%zu: alpha <= 0, matrix ! positive definite", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      int v41 = 134217984;
      unint64_t v42 = v8;
      goto LABEL_33;
    }
  }
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
}

void sub_190474D2C(uint64_t a1, float a2, float a3)
{
  uint64_t v6 = 0;
  *(void *)&v11[0] = *(void *)(a1 + 16);
  DWORD2(v11[0]) = *(_DWORD *)(a1 + 24);
  do
  {
    *(float *)((char *)v11 + v6) = -*(float *)((char *)v11 + v6);
    v6 += 4;
  }
  while (v6 != 12);
  unint64_t v7 = 0;
  uint64_t v12 = *(void *)&v11[0];
  int v13 = DWORD2(v11[0]);
  memset(v11, 0, 108);
  do
  {
    *(_DWORD *)sub_190474508((uint64_t)v11, v7, v7 + 3) = 1065353216;
    ++v7;
  }
  while (v7 != 3);
  float v8 = (float)((float)((float)(a2 * 0.021638) * a2) + (float)(a2 * 0.0000009617))
     + (float)((float)((float)(a2 * 0.021638) * a2) + (float)(a2 * 0.0000009617));
  if (v8 <= (float)((float)(a2 * a3) * a2)) {
    float v8 = (float)(a2 * a3) * a2;
  }
  *(float *)unint64_t v10 = v8;
  *(float *)&v10[1] = v8;
  *(float *)&void v10[2] = v8;
  sub_190474868((uint64_t)v9, (float *)(a1 + 10488), (uint64_t)v11, (uint64_t)v10, (uint64_t)&v12);
  sub_190473B04(a1, (uint64_t)v9);
}

uint64_t sub_190474E48(uint64_t a1, float32x2_t *a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t v55 = 0;
  memset(v54, 0, sizeof(v54));
  unint64_t v10 = (_OWORD *)(a1 + 28);
  unint64_t v11 = a2[4].u32[0];
  __int32 v12 = a2[4].i32[1];
  *(float *)&unint64_t v11 = -*(float *)&v11;
  *(float32x2_t *)buf = vneg_f32(a2[3]);
  *(_DWORD *)&uint8_t buf[8] = v11;
  *(_DWORD *)&unsigned char buf[12] = v12;
  float32x4_t v13 = sub_1902D9ACC((float32x4_t *)buf, (float32x4_t)v11);
  sub_1904CF3F4((uint64_t)v10, (float *)buf, &v53, v13);
  for (unint64_t i = 0; i != 3; ++i)
  {
    float v15 = sub_190448408(a3 + 20, i);
    float v16 = v15 - sub_190448408((uint64_t)a2, i);
    *(float *)sub_19042D844((uint64_t)&v50, i) = v16;
    *(_DWORD *)sub_190475528((uint64_t)v54, i, i) = 1065353216;
    *(_DWORD *)sub_190475528((uint64_t)v54, i + 3, i + 6) = 1065353216;
  }
  float v50 = sub_1904CF73C(v53.f32, v50, v51, v52);
  float v51 = v17;
  float v52 = v18;
  __int32 v19 = a2[4].i32[1];
  v20.f32[0] = -a2[4].f32[0];
  *(float32x2_t *)buf = vneg_f32(a2[3]);
  *(_DWORD *)&uint8_t buf[8] = v20.i32[0];
  *(_DWORD *)&unsigned char buf[12] = v19;
  float32x4_t v21 = sub_1902D9ACC((float32x4_t *)buf, v20);
  *(double *)v22.i64 = sub_1904CF3F4(a3, (float *)buf, &v49, v21);
  *(double *)v23.i64 = sub_1904CF3F4((uint64_t)&v53, v49.f32, (float32x4_t *)buf, v22);
  v23.f32[0] = -v53.f32[2];
  *(float32x2_t *)uint64_t v57 = vneg_f32(*(float32x2_t *)v53.f32);
  *(float *)&v57[8] = -v53.f32[2];
  v58[0] = v53.i32[3];
  float32x4_t v24 = sub_1902D9ACC((float32x4_t *)v57, v23);
  sub_1904CF3F4((uint64_t)buf, (float *)v57, &v49, v24);
  unint64_t v25 = 0;
  v48[0] = sub_1904CF8B4(&v49);
  v48[1] = v26;
  v48[2] = v27;
  do
  {
    int v28 = *(_DWORD *)sub_19042D844((uint64_t)&v50, v25);
    *(_DWORD *)sub_190475888((uint64_t)v56, v25) = v28;
    float v29 = sub_190448408((uint64_t)v48, v25);
    *(float *)sub_190475888((uint64_t)v56, v25 + 3) = v29;
    ++v25;
  }
  while (v25 != 3);
  uint64_t v30 = 0;
  float v31 = 0.0;
  do
  {
    float v31 = v31 + (float)(*(float *)((char *)&v50 + v30) * *(float *)((char *)&v50 + v30));
    v30 += 4;
  }
  while (v30 != 12);
  if (sqrtf(v31) > 0.04) {
    goto LABEL_11;
  }
  uint64_t v32 = 0;
  float v33 = 0.0;
  do
  {
    float v33 = v33 + (float)(*(float *)&v48[v32] * *(float *)&v48[v32]);
    ++v32;
  }
  while (v32 != 3);
  if ((float)(sqrtf(v33) * 57.296) <= 4.0)
  {
    *(void *)(a1 + 10344) = a5;
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    uint64_t v37 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = *(void *)(a1 + 10344);
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v38;
      _os_log_impl(&dword_1902AF000, v37, OS_LOG_TYPE_DEFAULT, "[CMRelDMSensorFusionMekf] Converged to anchor, fLastConvergedToAnchorTimestamp: %llu ... .", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      uint64_t v42 = *(void *)(a1 + 10344);
      *(_DWORD *)uint64_t v57 = 134217984;
      *(void *)&v57[4] = v42;
      goto LABEL_35;
    }
  }
  else
  {
LABEL_11:
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    long long v34 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = *(void *)(a1 + 10344);
      *(_DWORD *)buf = 134218240;
      *(void *)&uint8_t buf[4] = v35;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = a5;
      _os_log_impl(&dword_1902AF000, v34, OS_LOG_TYPE_DEFAULT, "[CMRelDMSensorFusionMekf] NOT-Converged to anchor, fLastConvergedToAnchorTimestamp: %llu, timestamp: %llu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      uint64_t v36 = *(void *)(a1 + 10344);
      *(_DWORD *)uint64_t v57 = 134218240;
      *(void *)&v57[4] = v36;
      LOWORD(v58[0]) = 2048;
      *(void *)((char *)v58 + 2) = a5;
LABEL_35:
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMSensorFusionMekf::anchorMeasurementUpdate(const State &, const AnchorData &, BOOL, uint64_t)", "CoreLocation: %s\n", v43);
      if (v43 != buf) {
        free(v43);
      }
    }
  }
  float v39 = atan2f(*(float *)(a3 + 36), *(float *)(a3 + 44));
  if (v39 <= 0.0) {
    float v39 = -v39;
  }
  v44[0] = *(_DWORD *)(a3 + 32);
  v44[1] = v44[0];
  v44[2] = v44[0];
  float v45 = (float)((float)((float)((float)((float)((float)((float)(v39 * 57.296) * 0.01817)
                                              + (float)((float)((float)(v39 * 57.296) * (float)(v39 * 57.296))
                                                      * 0.00008261))
                                      + 1.285)
                              * 0.00030462)
                      + (float)((float)((float)((float)((float)(v39 * 57.296) * 0.050494)
                                              + (float)((float)((float)(v39 * 57.296) * (float)(v39 * 57.296)) * 0.001676))
                                      + 0.41393)
                              * 0.00030462))
              * 0.25)
      + 0.0002514;
  float v46 = v45;
  float v47 = v45;
  if (a4)
  {
    int v60 = *(_DWORD *)(a1 + 10700);
    long long v40 = *(_OWORD *)(a1 + 10684);
    *(_OWORD *)buf = *(_OWORD *)(a1 + 10668);
    *(_OWORD *)&buf[16] = v40;
    long long v66 = *(_OWORD *)(a1 + 10784);
    long long v67 = *(_OWORD *)(a1 + 10800);
    long long v68 = *(_OWORD *)(a1 + 10816);
    long long v69 = *(_OWORD *)(a1 + 10832);
    long long v62 = *(_OWORD *)(a1 + 10720);
    long long v63 = *(_OWORD *)(a1 + 10736);
    long long v64 = *(_OWORD *)(a1 + 10752);
    long long v65 = *(_OWORD *)(a1 + 10768);
    long long v61 = *(_OWORD *)(a1 + 10704);
    sub_190475A64((uint64_t)v57, (float *)buf, (uint64_t)v54, (uint64_t)v44, (uint64_t)v56);
    sub_190473B04(a1, (uint64_t)v57);
    *(_OWORD *)(a1 + 44) = *v10;
  }
  else
  {
    sub_190475A64((uint64_t)v57, (float *)(a1 + 10488), (uint64_t)v54, (uint64_t)v44, (uint64_t)v56);
    sub_190473B04(a1, (uint64_t)v57);
  }
  uint64_t result = sub_190478F28((unsigned __int16 *)(a1 + 1352), *(unsigned __int16 *)(a1 + 1354) - 1);
  if (a1 + 4 != result)
  {
    *(_DWORD *)uint64_t result = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(result + 16) = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(result + 20) = *(_DWORD *)(a1 + 24);
    *(_OWORD *)(result + 24) = *v10;
    *(_OWORD *)(result + 40) = *(_OWORD *)(a1 + 44);
  }
  return result;
}

uint64_t sub_190475528(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 6)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 6;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 77,invalid row %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      float v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMMatrix<float, 6, 9>::operator()(size_t, size_t) [T = float, M = 6, N = 9]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (a3 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    uint64_t v9 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a3;
      __int16 v13 = 2048;
      uint64_t v14 = 9;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 78,invalid col %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      unint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMMatrix<float, 6, 9>::operator()(size_t, size_t) [T = float, M = 6, N = 9]", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  return a1 + 4 * (a2 + 6 * a3);
}

uint64_t sub_190475888(uint64_t a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 6)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    uint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 6;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 277,invalid index %zu >= %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMVector<float, 6>::operator[](const size_t) [T = float, N = 6]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return a1 + 4 * a2;
}

void sub_190475A64(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v8 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = (uint64_t)(a2 + 9);
  int v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
LABEL_2:
  unint64_t v10 = 0;
  uint64_t v11 = -1;
  do
  {
    float v12 = sub_19047A2BC(a3, v8, v10);
    unint64_t v13 = v11;
    if (v10)
    {
      do
      {
        float v14 = sub_19047A2BC(a3, v8, v13);
        float v12 = v12 + (float)(v14 * *(float *)sub_190479848(v9, v13--, v10));
      }
      while (v13 != -1);
    }
    v46[v10] = v12;
    v45[v10] = v12 * *(float *)sub_190479BA4((uint64_t)a2, v10);
    ++v10;
    ++v11;
  }
  while (v10 != 9);
  float v15 = sub_19047A61C(a4, v8);
  float v16 = v15 + (float)(v46[0] * v45[0]);
  if (v16 <= 0.0)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    long long v34 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      unint64_t v44 = v8;
      _os_log_impl(&dword_1902AF000, v34, OS_LOG_TYPE_DEBUG, "%zu: alpha <= 0, matrix ! positive definite", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      int v41 = 134217984;
      unint64_t v42 = v8;
LABEL_33:
      uint64_t v35 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "CMVector<T, N> CMFactoredMatrix<float, 9>::biermanObservationalUpdate(const CMMatrix<T, P, N> &, const CMVector<T, P> &, const CMVector<T, P> &) [T = float, N = 9, P = 6UL]", "CoreLocation: %s\n", v35);
      if (v35 != (char *)buf) {
        free(v35);
      }
    }
  }
  else
  {
    float v17 = 1.0 / v16;
    *a2 = *a2 * (float)((float)(1.0 / v16) * sub_19047A61C(a4, v8));
    unint64_t v18 = 1;
    while (1)
    {
      float v19 = v46[v18];
      float v20 = v16 + (float)(v19 * v45[v18]);
      if (v20 <= 0.0) {
        break;
      }
      float v21 = -(float)(v19 * v17);
      float v17 = 1.0 / v20;
      float32x4_t v22 = (float *)sub_190479BA4((uint64_t)a2, v18);
      unint64_t v23 = 0;
      *float32x4_t v22 = (float)(v16 * (float)(1.0 / v20)) * *v22;
      do
      {
        float v24 = *(float *)sub_190479848(v9, v23, v18);
        float v25 = v45[v23];
        int v26 = (float *)sub_190479848(v9, v23, v18);
        float v27 = v45[v18];
        *int v26 = v24 + (float)(v25 * v21);
        v45[v23++] = v25 + (float)(v27 * v24);
      }
      while (v18 != v23);
      ++v18;
      float v16 = v20;
      if (v18 == 9)
      {
        unint64_t v28 = 0;
        float v29 = v17 * sub_19047A61C(a5, v8);
        do
        {
          float v30 = v45[v28];
          float v31 = (float *)sub_19047A0E0((uint64_t)&v38, v28);
          *float v31 = *v31 + (float)(v29 * v30);
          ++v28;
        }
        while (v28 != 9);
        if (++v8 == 6)
        {
          long long v32 = v39;
          *(_OWORD *)a1 = v38;
          *(_OWORD *)(a1 + 16) = v32;
          *(_DWORD *)(a1 + 32) = v40;
          return;
        }
        goto LABEL_2;
      }
    }
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    float v33 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      unint64_t v44 = v8;
      _os_log_impl(&dword_1902AF000, v33, OS_LOG_TYPE_DEBUG, "%zu: alpha <= 0, matrix ! positive definite", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      int v41 = 134217984;
      unint64_t v42 = v8;
      goto LABEL_33;
    }
  }
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
}

void sub_190475F28(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)a1)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    uint64_t v5 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_DEBUG, "[CMRelDMSensorFusionMekf] Already initialized", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMSensorFusionMekf::initialize(const IMUData &, const IMUData &, const Pose &, uint64_t)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 4) = *a4;
    uint64_t v9 = a1 + 4;
    *(_DWORD *)(a1 + 8) = a4[1];
    *(_DWORD *)(a1 + 12) = a4[2];
    *(void *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    unint64_t v10 = a4 + 3;
    if ((_DWORD *)(a1 + 28) != a4 + 3) {
      *(_OWORD *)(a1 + 28) = *v10;
    }
    if ((_OWORD *)(a1 + 44) != v10) {
      *(_OWORD *)(a1 + 44) = *v10;
    }
    unint64_t v11 = 0;
    int v33 = 0;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    *(_OWORD *)buf = 0u;
    long long v14 = 0u;
    do
    {
      if (v11 > 2)
      {
        float v12 = (_DWORD *)sub_19047336C((uint64_t)buf, v11, v11);
        if (v11 > 5) {
          *float v12 = 983545103;
        }
        else {
          *float v12 = 992204554;
        }
      }
      else
      {
        *(_DWORD *)sub_19047336C((uint64_t)buf, v11, v11) = 1008981770;
      }
      ++v11;
    }
    while (v11 != 9);
    sub_1904736CC(a1 + 10488, (uint64_t)buf);
    sub_1904761D8((unsigned __int16 *)(a1 + 64), v9, a5);
    *(unsigned char *)a1 = 1;
  }
}

uint64_t sub_1904761D8(unsigned __int16 *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_190479128(a1 + 644, a2);
  uint64_t v6 = a1[1];
  unint64_t v7 = *((unsigned int *)a1 + 1);
  uint64_t v8 = *a1;
  if (v8 + v6 >= v7) {
    uint64_t v9 = *((unsigned int *)a1 + 1);
  }
  else {
    uint64_t v9 = 0;
  }
  *(void *)&a1[4 * (v8 + v6 - v9) + 4] = a3;
  if (v7 <= v6)
  {
    if (v8 + 1 < v7) {
      LOWORD(v7) = 0;
    }
    *a1 = v8 + 1 - v7;
  }
  else
  {
    a1[1] = v6 + 1;
  }
  return result;
}

void sub_190476250(uint64_t a1, uint64_t a2, int a3, unint64_t a4)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)a1)
  {
    uint64_t v7 = *(unsigned __int16 *)(a1 + 66);
    if (*(_WORD *)(a1 + 66))
    {
      uint64_t v9 = (unsigned char *)(a1 + 10328);
      *(void *)(a1 + 10320) = 0xFFFFFFFFLL;
      *(unsigned char *)(a1 + 10328) = 0;
      if (v7 <= 0x32) {
        unint64_t v10 = 0;
      }
      else {
        unint64_t v10 = v7 - 50;
      }
      uint64_t v11 = a1 + 72;
      unint64_t v12 = v7 - 1;
      unint64_t v13 = v7 - 1 + *(unsigned __int16 *)(a1 + 64);
      unint64_t v14 = *(unsigned int *)(a1 + 68);
      if (v13 < v14) {
        unint64_t v14 = 0;
      }
      unint64_t v15 = *(void *)(v11 + 8 * (v13 - v14));
      if (v15 <= a4)
      {
        if (v15 + 10000 > a4) {
          goto LABEL_53;
        }
        if ((float)((float)v15 + 500000.0) <= (float)a4) {
          goto LABEL_69;
        }
        *uint64_t v9 = 1;
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
        }
        long long v22 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v23 = *(unsigned __int16 *)(a1 + 64) + (unint64_t)*(unsigned __int16 *)(a1 + 66) - 1;
          unint64_t v24 = *(unsigned int *)(a1 + 68);
          if (v23 < v24) {
            unint64_t v24 = 0;
          }
          uint64_t v25 = *(void *)(v11 + 8 * (v23 - v24));
          *(_DWORD *)buf = 134349312;
          *(void *)&uint8_t buf[4] = a4;
          *(_WORD *)&unsigned char buf[12] = 2050;
          *(void *)&buf[14] = v25;
          _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_DEBUG, "[CMRelDMSensorFusionMekf][hasValidStateAtAnchorTime] Anchor time is ahead of current state time. anchorTime=%{public}llu, newestStateTime=%{public}llu", buf, 0x16u);
        }
        if (!sub_1902D8400(115, 2)) {
          goto LABEL_69;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 == -1) {
          goto LABEL_87;
        }
      }
      else
      {
        if (*(void *)sub_19047A7F8((unsigned __int16 *)(a1 + 64), v10) <= a4)
        {
          unint64_t v26 = *(unsigned __int16 *)(a1 + 66) - 1;
          unint64_t v27 = v26 + *(unsigned __int16 *)(a1 + 64);
          unint64_t v28 = *(unsigned int *)(a1 + 68);
          if (v27 < v28) {
            unint64_t v28 = 0;
          }
          unint64_t v29 = *(unsigned __int16 *)(a1 + 1354)
              - vcvtps_u32_f32((float)(*(void *)(v11 + 8 * (v27 - v28)) - a4) / 5000.0)
              + 2;
          if (v29 >= v26) {
            unint64_t v30 = *(unsigned __int16 *)(a1 + 66) - 1;
          }
          else {
            unint64_t v30 = v29;
          }
          while (v30 + 1 > v10)
          {
            long long v31 = (unint64_t *)sub_19047A7F8((unsigned __int16 *)(a1 + 64), v30--);
            if (*v31 <= a4)
            {
              unint64_t v32 = a4 - *(void *)sub_19047A7F8((unsigned __int16 *)(a1 + 64), v30 + 1);
              if (v32 <= *(void *)sub_19047A7F8((unsigned __int16 *)(a1 + 64), v30 + 2) - a4) {
                unint64_t v12 = v30 + 1;
              }
              else {
                unint64_t v12 = v30 + 2;
              }
              goto LABEL_53;
            }
          }
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
          }
          uint64_t v34 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
          {
            unint64_t v35 = *(unsigned __int16 *)(a1 + 64) + (unint64_t)*(unsigned __int16 *)(a1 + 66) - 1;
            unint64_t v36 = *(unsigned int *)(a1 + 68);
            if (v35 < v36) {
              unint64_t v36 = 0;
            }
            uint64_t v37 = *(void *)(v11 + 8 * (v35 - v36));
            *(_DWORD *)buf = 134349312;
            *(void *)&uint8_t buf[4] = a4;
            *(_WORD *)&unsigned char buf[12] = 2050;
            *(void *)&buf[14] = v37;
            _os_log_impl(&dword_1902AF000, v34, OS_LOG_TYPE_ERROR, "[CMRelDMSensorFusionMekf][hasValidStateAtAnchorTime] Failed to find a valid state idx. anchorTime=%{public}llu, newestStateTime=%{public}llu", buf, 0x16u);
          }
          if (!sub_1902D8400(115, 0)) {
            goto LABEL_69;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
          }
          long long v38 = (uint8_t *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "BOOL CMRelDMSensorFusionMekf::StateHistory::hasValidStateAtAnchorTime(uint64_t)", "CoreLocation: %s\n");
LABEL_88:
          if (v38 != buf) {
            free(v38);
          }
LABEL_69:
          if (*v9)
          {
            unint64_t v40 = *(unsigned int *)(a1 + 10388);
            unint64_t v41 = *(unsigned __int16 *)(a1 + 10384) + (unint64_t)*(unsigned __int16 *)(a1 + 10386);
            if (v41 < v40) {
              unint64_t v40 = 0;
            }
            uint64_t v42 = a1 + 48 * (v41 - v40) + 10384;
            *(_OWORD *)(v42 + 8) = *(_OWORD *)a2;
            long long v43 = *(_OWORD *)(a2 + 16);
            *(_OWORD *)(v42 + 40) = *(_OWORD *)(a2 + 32);
            *(_OWORD *)(v42 + 24) = v43;
            unsigned int v44 = *(unsigned __int16 *)(a1 + 10386);
            unint64_t v45 = *(unsigned int *)(a1 + 10388);
            if (v45 <= v44)
            {
              unint64_t v46 = *(unsigned __int16 *)(a1 + 10384) + 1;
              if (v46 < v45) {
                LOWORD(v45) = 0;
              }
              *(_WORD *)(a1 + 10384) = v46 - v45;
            }
            else
            {
              *(_WORD *)(a1 + 10386) = v44 + 1;
            }
            uint64_t v47 = *(unsigned __int16 *)(a1 + 10362);
            unint64_t v48 = *(unsigned int *)(a1 + 10364);
            uint64_t v49 = *(unsigned __int16 *)(a1 + 10360);
            if (v49 + v47 >= v48) {
              uint64_t v50 = *(unsigned int *)(a1 + 10364);
            }
            else {
              uint64_t v50 = 0;
            }
            *(void *)(a1 + 8 * (v49 + v47 - v50) + 10368) = a4;
            if (v48 <= v47)
            {
              if (v49 + 1 < v48) {
                LOWORD(v48) = 0;
              }
              *(_WORD *)(a1 + 10360) = v49 + 1 - v48;
            }
            else
            {
              *(_WORD *)(a1 + 10362) = v47 + 1;
            }
          }
          return;
        }
        unint64_t v16 = *(void *)sub_19047A7F8((unsigned __int16 *)(a1 + 64), v10) - a4;
        if (v16 >> 4 < 0x271)
        {
          unint64_t v12 = 0;
LABEL_53:
          *(void *)(a1 + 10320) = v12;
          *(_DWORD *)(a1 + 10360) = 0;
          *(_DWORD *)(a1 + 10384) = 0;
          int v33 = (float32x2_t *)sub_190477460(a1 + 64, v12);
          sub_190474E48(a1, v33, a2, (a3 & 0xFFFFFFFD) == 1, a4);
          *(void *)(a1 + 10336) = a4;
          return;
        }
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
        }
        long long v39 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134349312;
          *(void *)&uint8_t buf[4] = a4;
          *(_WORD *)&unsigned char buf[12] = 2050;
          *(void *)&buf[14] = v16;
          _os_log_impl(&dword_1902AF000, v39, OS_LOG_TYPE_DEFAULT, "[CMRelDMSensorFusionMekf][hasValidStateAtAnchorTime] Anchor is too old. anchorTime=%{public}llu, deltaT%{public}llu", buf, 0x16u);
        }
        if (!sub_1902D8400(115, 2)) {
          goto LABEL_69;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 == -1)
        {
LABEL_87:
          long long v38 = (uint8_t *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMSensorFusionMekf::StateHistory::hasValidStateAtAnchorTime(uint64_t)", "CoreLocation: %s\n");
          goto LABEL_88;
        }
      }
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      goto LABEL_87;
    }
  }
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 28);
  *(void *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  if (a1 + 28 != a2) {
    *(_OWORD *)(a1 + 28) = *(_OWORD *)a2;
  }
  if (a1 + 44 != a2) {
    *(_OWORD *)(a1 + 44) = *(_OWORD *)a2;
  }
  unint64_t v17 = 0;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  memset(buf, 0, sizeof(buf));
  int v70 = 0;
  do
  {
    float v18 = *(float *)(a2 + 16);
    if (v17 < 6) {
      float v18 = 0.0009;
    }
    if (v17 >= 3) {
      float v19 = v18;
    }
    else {
      float v19 = *(float *)(a2 + 32);
    }
    *(float *)sub_19047336C((uint64_t)buf, v17, v17) = v19;
    ++v17;
  }
  while (v17 != 9);
  sub_1904736CC(a1 + 10488, (uint64_t)buf);
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 1352) = 0;
  sub_1904761D8((unsigned __int16 *)(a1 + 64), a1 + 4, a4);
  *(unsigned char *)a1 = 1;
  *(void *)(a1 + 10336) = a4;
  *(void *)(a1 + 10344) = a4;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
  }
  long long v20 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134349056;
    *(void *)&uint8_t buf[4] = a4;
    _os_log_impl(&dword_1902AF000, v20, OS_LOG_TYPE_DEFAULT, "[CMRelDMSensorFusionMekf][feedAnchorData] Initialize with anchor. anchorTime=%{public}llu", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    long long v21 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMSensorFusionMekf::feedAnchorData(const AnchorData &, TrackingScheme, uint64_t)", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf) {
      free(v21);
    }
  }
}

void sub_190476BF8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, double a6, float a7)
{
  int v13 = *(_DWORD *)(a2 + 48);
  if (v13 && (int v14 = *(_DWORD *)(a3 + 48)) != 0)
  {
    float v15 = (float)((float)(*(float *)(a2 + 52) + *(float *)(a3 + 52)) * 9.8067) * 9.8067;
    if (a4 == 2 && (v13 == 1 ? (BOOL v16 = v14 == 1) : (BOOL v16 = 0), v16))
    {
      float v17 = a6;
      sub_190474D2C(a1, v17, (float)((float)(*(float *)(a2 + 52) + *(float *)(a3 + 52)) * 9.8067) * 9.8067);
    }
    else
    {
      if (a4 == 1) {
        return;
      }
      float v17 = a6;
    }
    sub_190473DC0(a1, (float32x2_t *)(a2 + 12), (float *)(a3 + 12), a5, v17, v15);
  }
  else if (a7 > 0.0 && a4 != 1)
  {
    float v19 = a6;
    sub_190473DC0(a1, (float32x2_t *)(a2 + 24), (float *)(a3 + 24), a5, v19, a7);
    if (a4 == 2)
    {
      sub_190474D2C(a1, v19, a7);
    }
  }
}

void sub_190476D58(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unint64_t a5, double a6, float a7)
{
  sub_190476BF8(a1, a2, a3, a4, a5, a6, a7);
  sub_1904761D8((unsigned __int16 *)(a1 + 64), a1 + 4, a5);

  sub_190476DC0(a1, (a4 & 0xFFFFFFFD) == 1, a5);
}

void sub_190476DC0(uint64_t a1, int a2, unint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (unsigned __int16 *)(a1 + 10360);
  if (*(_WORD *)(a1 + 10362))
  {
    if ((unint64_t v6 = *(void *)(a1 + 8 * *v3 + 10368), v6 >= a3) && (v6 - a3) >> 3 < 0x271
      || a3 >= v6 && (a3 - v6) >> 3 <= 0x270)
    {
      sub_190474E48(a1, (float32x2_t *)(a1 + 4), a1 + 48 * *(unsigned __int16 *)(a1 + 10384) + 10392, a2, v6);
      *(void *)(a1 + 10336) = a3;
      unsigned __int16 v7 = v3[1];
      if (v7)
      {
        unint64_t v8 = *v3 + 1;
        unint64_t v9 = *(unsigned int *)(a1 + 10364);
        if (v8 < v9) {
          LOWORD(v9) = 0;
        }
        unsigned __int16 *v3 = v8 - v9;
        v3[1] = v7 - 1;
      }
      unsigned __int16 v10 = v3[13];
      if (v10)
      {
        unint64_t v11 = v3[12] + 1;
        unint64_t v12 = *(unsigned int *)(a1 + 10388);
        if (v11 < v12) {
          LOWORD(v12) = 0;
        }
        v3[12] = v11 - v12;
        v3[13] = v10 - 1;
      }
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      int v13 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134217984;
        unint64_t v16 = a3;
        _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_DEBUG, "[CMRelDMSensorFusionMekf] Consumed cached anchor. timestamp %llu", buf, 0xCu);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
        }
        int v14 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMSensorFusionMekf::processCachedAnchorMeasurements(BOOL, uint64_t)", "CoreLocation: %s\n", v14);
        if (v14 != (char *)buf) {
          free(v14);
        }
      }
    }
  }
}

void sub_190477034(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)a1)
  {
    *(_DWORD *)(a1 + 4) = *a2;
    uint64_t v4 = a1 + 4;
    *(_DWORD *)(a1 + 8) = a2[1];
    *(_DWORD *)(a1 + 12) = a2[2];
    uint64_t v5 = a2 + 3;
    if ((_OWORD *)(a1 + 28) != v5) {
      *(_OWORD *)(a1 + 28) = *v5;
    }
    if ((_OWORD *)(a1 + 44) != v5) {
      *(_OWORD *)(a1 + 44) = *v5;
    }
    *(_DWORD *)(a1 + 64) = 0;
    uint64_t v6 = a1 + 64;
    *(_DWORD *)(v6 + 1288) = 0;
    sub_1904761D8((unsigned __int16 *)v6, v4, a3);
  }
  else
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    unsigned __int16 v7 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_ERROR, "[CMRelDMSensorFusionMekf] Must be initialized before bleeding to zero", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      unint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMSensorFusionMekf::bleedToZero(const Pose &, uint64_t)", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
}

void sub_190477254(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = a1 + 64;
    uint64_t v3 = *(unsigned __int16 *)(a1 + 1354);
    if (v3 >= 0x28) {
      unint64_t v4 = v3 - 40;
    }
    else {
      unint64_t v4 = 0;
    }
    uint64_t v5 = sub_190477460(v2, v4);
    *(_OWORD *)buf = *(_OWORD *)(v5 + 24);
    float32x4_t v6 = *(float32x4_t *)buf;
    unsigned int v7 = *(_DWORD *)(v5 + 52);
    v6.f32[0] = -*(float *)(v5 + 48);
    *(float32x2_t *)v12.f32 = vneg_f32(*(float32x2_t *)(v5 + 40));
    v12.i64[1] = __PAIR64__(v7, v6.u32[0]);
    float32x4_t v8 = sub_1902D9ACC(&v12, v6);
    *(double *)v9.i64 = sub_1904CF3F4(a1 + 44, v12.f32, &v13, v8);
    sub_1904CF3F4((uint64_t)&v13, (float *)buf, &v12, v9);
    *(float32x4_t *)(a1 + 44) = v12;
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 1352) = 0;
  }
  else
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    uint64_t v10 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_ERROR, "[CMRelDMSensorFusionMekf] Must be initialized before entering 1-IMU tracking mode", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      v13.i16[0] = 0;
      unint64_t v11 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMSensorFusionMekf::enter1IMUTracking()", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
  }
}

uint64_t sub_190477460(uint64_t a1, unint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (unsigned __int16 *)(a1 + 1288);
  if (*(unsigned __int16 *)(a1 + 1290) <= a2)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    float32x4_t v6 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_ERROR, "[StateHistory::getState] Invalid idx, returning latest index.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      unsigned int v7 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const State &CMRelDMSensorFusionMekf::StateHistory::getState(size_t) const", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    return sub_190478F28(v2, *(unsigned __int16 *)(a1 + 1290) - 1);
  }
  else
  {
    uint64_t v3 = (unsigned __int16 *)(a1 + 1288);
    return sub_190478F28(v3, a2);
  }
}

void sub_190477658(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)a1)
  {
    uint64_t v5 = a1 + 64;
    uint64_t v6 = *(unsigned __int16 *)(a1 + 1354);
    unint64_t v7 = v6 - 160;
    if (v6 < 0xA0) {
      unint64_t v7 = 0;
    }
    unint64_t v8 = v6 - 1;
    if (a3) {
      unint64_t v9 = v8;
    }
    else {
      unint64_t v9 = v7;
    }
    uint64_t v10 = (float32x2_t *)sub_190477460(v5, v9);
    float v11 = sub_1904778D0(a2, (float *)v10, v10 + 5);
    float v13 = v12;
    float v15 = v14;
    unint64_t v16 = (float *)sub_190479348(a2);
    float v17 = sub_1904CF73C(v16, v11, v13, v15);
    float v19 = v18;
    float v21 = v20;
    long long v22 = (float *)sub_1904791A8(a2);
    uint64_t v23 = 0;
    float v24 = v19 + v22[1];
    float v25 = v21 + v22[2];
    *(float *)buf = v17 + *v22;
    float v31 = v24;
    float v32 = v25;
    do
    {
      *(float *)&buf[v23] = -*(float *)&buf[v23];
      v23 += 4;
    }
    while (v23 != 12);
    *(float *)(a1 + 4) = sub_1904CF73C((float *)&v10[3], *(float *)buf, v31, v32);
    *(_DWORD *)(a1 + 8) = v26;
    *(_DWORD *)(a1 + 12) = v27;
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 1352) = 0;
  }
  else
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    unint64_t v28 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v28, OS_LOG_TYPE_ERROR, "[CMRelDMSensorFusionMekf] Must be initialized before exiting 1-IMU tracking mode", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      unint64_t v29 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMSensorFusionMekf::exit1IMUTracking(const BodyFaceTransform &, BOOL)", "CoreLocation: %s\n", v29);
      if (v29 != (char *)buf) {
        free(v29);
      }
    }
  }
}

float sub_1904778D0(uint64_t a1, float *a2, float32x2_t *a3)
{
  uint64_t v6 = (float *)sub_1904791A8(a1);
  __int32 v7 = a3[1].i32[1];
  v8.f32[0] = -a3[1].f32[0];
  *(float32x2_t *)v22.f32 = vneg_f32(*a3);
  v22.i64[1] = __PAIR64__(v7, v8.u32[0]);
  sub_1902D9ACC(&v22, v8);
  float v9 = *v6 + sub_1904CF73C(v22.f32, *a2, a2[1], a2[2]);
  float v11 = v6[1] + v10;
  float v13 = v12 + v6[2];
  float v14 = (float32x2_t *)sub_190479348(a1);
  __int32 v15 = v14[1].i32[1];
  v16.f32[0] = -v14[1].f32[0];
  *(float32x2_t *)v22.f32 = vneg_f32(*v14);
  v22.i64[1] = __PAIR64__(v15, v16.u32[0]);
  sub_1902D9ACC(&v22, v16);
  float v17 = sub_1904CF73C(v22.f32, v9, v11, v13);
  uint64_t v18 = 0;
  *(float *)uint64_t v23 = v17;
  v23[1] = v19;
  v23[2] = v20;
  do
  {
    *(float *)&v23[v18] = -*(float *)&v23[v18];
    ++v18;
  }
  while (v18 != 3);
  return *(float *)v23;
}

float *sub_1904779D0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  for (unint64_t i = 0; i != 3; ++i)
  {
    for (unint64_t j = 0; j != 3; ++j)
    {
      float v8 = sub_1904741A8(a1, i, 0);
      float v9 = v8 * sub_1904741A8(a2, 0, j);
      *(float *)sub_190448B30(a3, i, j) = v9;
      for (unint64_t k = 1; k != 3; ++k)
      {
        float v11 = sub_1904741A8(a1, i, k);
        float v12 = sub_1904741A8(a2, k, j);
        uint64_t result = (float *)sub_190448B30(a3, i, j);
        *uint64_t result = *result + (float)(v11 * v12);
      }
    }
  }
  return result;
}

uint64_t sub_190477AC0(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    __int32 v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 9;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 77,invalid row %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      float v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMMatrix<float, 9, 12>::operator()(size_t, size_t) [T = float, M = 9, N = 12]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (a3 >= 0xC)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    float v9 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a3;
      __int16 v13 = 2048;
      uint64_t v14 = 12;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 78,invalid col %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      float v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMMatrix<float, 9, 12>::operator()(size_t, size_t) [T = float, M = 9, N = 12]", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  return a1 + 4 * (9 * a3 + a2);
}

uint64_t sub_190477E20(uint64_t a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 0xC)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    uint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 12;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 277,invalid index %zu >= %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMVector<float, 12>::operator[](const size_t) [T = float, N = 12]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return a1 + 4 * a2;
}

void sub_190477FFC(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float a5)
{
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)a1)
  {
    __int16 v9 = (float *)(a1 + 28);
    v10.f32[0] = sub_1904CF73C((float *)(a1 + 28), *(float *)a3, *(float *)(a3 + 4), *(float *)(a3 + 8));
    float32_t v12 = (float)(*(float *)(a2 + 8) - v11) * a5;
    v10.i32[1] = v13;
    *(float32x2_t *)__dst[0].f32 = vmul_n_f32(vsub_f32(*(float32x2_t *)a2, v10), a5);
    __dst[0].f32[2] = v12;
    *(double *)v14.i64 = sub_1904CF7FC(buf, __dst[0].f32);
    sub_1904CF3F4((uint64_t)buf, v9, __dst, v14);
    *(float32x4_t *)(a1 + 28) = __dst[0];
    *(float *)v150 = -(float)(sub_1904CF73C((float *)(a1 + 44), *(float *)a3, *(float *)(a3 + 4), *(float *)(a3 + 8))
                            * a5);
    *(float *)&v150[4] = -(float)(v15 * a5);
    *(float *)&v150[8] = -(float)(v16 * a5);
    *(double *)v17.i64 = sub_1904CF7FC(__dst, (float *)v150);
    sub_1904CF3F4((uint64_t)__dst, (float *)(a1 + 44), (float32x4_t *)v150, v17);
    *(_OWORD *)(a1 + 44) = *(_OWORD *)v150;
    float v18 = *(float *)(a3 + 12) * 9.8067;
    float v19 = *(float *)(a3 + 16) * 9.8067;
    float v20 = *(float *)(a3 + 20) * 9.8067;
    float v144 = v20;
    if (a4)
    {
      float v21 = *(float *)(a3 + 12) * 9.8067;
      float v22 = *(float *)(a3 + 16) * 9.8067;
      *(void *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 24) = 0;
    }
    else
    {
      uint64_t v25 = 0;
      float32x2_t v26 = *(float32x2_t *)(a2 + 16);
      float v27 = *(float *)(a2 + 8);
      float v28 = *(float *)(a2 + 12);
      float v29 = *(float *)(a1 + 20);
      float v30 = *(float *)(a1 + 24);
      float v31 = -v27;
      float v32 = *(float *)(a2 + 4);
      float v33 = -(float)(*(float *)a2 * v30);
      float v35 = *(float *)(a1 + 12);
      float v34 = *(float *)(a1 + 16);
      float v36 = (float)(*(float *)a2 * v29) - (float)(v32 * v34);
      float v38 = *(float *)(a1 + 4);
      float v37 = *(float *)(a1 + 8);
      float v39 = (float)(v32 * v35) - (float)(v27 * v37);
      float v40 = (float)(v27 * v38) - (float)(*(float *)a2 * v35);
      float32_t v41 = (float)(*(float *)a2 * v40) - (float)(v32 * v39);
      buf[0].i64[0] = __PAIR64__((float)(v27 * v39)- (float)(*(float *)a2 * (float)((float)(*(float *)a2 * v37) - (float)(v32 * v38))), (float)(v32 * (float)((float)(*(float *)a2 * v37) - (float)(v32 * v38))) - (float)(v27 * v40));
      buf[0].f32[2] = v41;
      do
      {
        buf[0].f32[v25] = -buf[0].f32[v25];
        ++v25;
      }
      while (v25 != 3);
      float32x2_t v42 = vmul_f32(v26, (float32x2_t)vdup_n_s32(0x411CE80Au));
      v43.f32[0] = v33 + (float)(v27 * v34);
      float v44 = v28 * 9.8067;
      float v45 = buf[0].f32[0]
          - (float)((float)((float)(v29 * v31) + (float)(v32 * v30)) + (float)((float)(v29 * v31) + (float)(v32 * v30)));
      v43.f32[1] = v36;
      float32x2_t v46 = vadd_f32(v43, v43);
      float32x2_t v47 = *(float32x2_t *)&buf[0].i32[1];
      float v21 = v18;
      float v22 = v19;
      float v48 = sub_1904CF73C(v9, v18, v19, v20);
      v50.i32[1] = v49;
      v51.i64[0] = *(void *)(a1 + 20);
      float32x4_t v52 = *(float32x4_t *)(a1 + 4);
      int8x16_t v53 = (int8x16_t)vdupq_laneq_s32((int32x4_t)v52, 3);
      float32x4_t v54 = (float32x4_t)vextq_s8(vextq_s8(v53, v53, 4uLL), v51, 0xCuLL);
      v54.f32[3] = v45 - (float)(v44 - v48);
      *(float32x4_t *)(a1 + 4) = vaddq_f32(v52, vmulq_n_f32(v54, a5));
      *(float32x2_t *)(a1 + 20) = vadd_f32(*(float32x2_t *)v51.i8, vmul_n_f32(vsub_f32(vsub_f32(v47, v46), vsub_f32(v42, v50)), a5));
    }
    memset(__src, 0, sizeof(__src));
    float v56 = *(float *)(a2 + 4);
    float v55 = *(float *)(a2 + 8);
    unsigned int v57 = *(_DWORD *)a2;
    float32_t v58 = -*(float *)a2;
    buf[0].i32[0] = 0;
    buf[0].f32[1] = v55;
    buf[0].f32[2] = -v56;
    buf[0].f32[3] = -v55;
    buf[1].i32[0] = 0;
    *(uint64_t *)((char *)buf[1].i64 + 4) = __PAIR64__(LODWORD(v56), v57);
    buf[1].f32[3] = v58;
    buf[2].i32[0] = 0;
    if ((a4 & 1) == 0)
    {
      for (unint64_t i = 0; i != 3; ++i)
        *(_DWORD *)sub_19047336C((uint64_t)__src, i, i + 3) = 1065353216;
      float v60 = sub_1904CF73C(v9, v21, v22, v144);
      __dst[0].i32[0] = 0;
      __dst[0].f32[1] = v62;
      __dst[0].f32[2] = -*(float *)&v61;
      __dst[0].f32[3] = -v62;
      __dst[1].i32[0] = 0;
      *(uint64_t *)((char *)__dst[1].i64 + 4) = __PAIR64__(v61, LODWORD(v60));
      __dst[1].f32[3] = -v60;
      __dst[2].i32[0] = 0;
      sub_1904779D0((uint64_t)buf, (uint64_t)buf, (uint64_t)v150);
      do
      {
        for (unint64_t j = 0; j != 3; ++j)
        {
          float v64 = -sub_1904741A8((uint64_t)v150, i - 3, j);
          *(float *)sub_19047336C((uint64_t)__src, i, j) = v64;
        }
        for (unint64_t k = 0; k != 3; ++k)
        {
          float v66 = sub_1904741A8((uint64_t)buf, i - 3, k) * -2.0;
          *(float *)sub_19047336C((uint64_t)__src, i, k + 3) = v66;
        }
        for (unint64_t m = 0; m != 3; ++m)
        {
          float v68 = sub_1904741A8((uint64_t)__dst, i - 3, m);
          *(float *)sub_19047336C((uint64_t)__src, i, m + 6) = v68 + v68;
        }
        ++i;
      }
      while (i != 6);
    }
    for (unint64_t n = 6; n != 9; ++n)
    {
      for (iunint64_t i = 0; ii != 3; ++ii)
      {
        float v71 = -sub_1904741A8((uint64_t)buf, n - 6, ii);
        *(float *)sub_19047336C((uint64_t)__src, n, ii + 6) = v71;
      }
    }
    unint64_t v72 = 0;
    memset(v147, 0, sizeof(v147));
    int v148 = 0;
    do
    {
      *(_DWORD *)sub_19047336C((uint64_t)v147, v72, v72) = 1065353216;
      ++v72;
    }
    while (v72 != 9);
    memcpy(__dst, __src, 0x144uLL);
    for (junint64_t j = 0; jj != 81; ++jj)
      __dst[0].f32[jj] = __dst[0].f32[jj] * a5;
    memcpy(buf, __dst, 0x144uLL);
    for (kunint64_t k = 0; kk != 81; ++kk)
      *((float *)v147 + kk) = sub_19047A9F4((uint64_t)buf, kk) + *((float *)v147 + kk);
    for (munint64_t m = 0; mm != 9; ++mm)
    {
      for (nunint64_t n = 0; nn != 9; ++nn)
      {
        float v77 = sub_1904794E8((uint64_t)__src, mm, 0);
        float v78 = v77 * sub_1904794E8((uint64_t)__src, 0, nn);
        *(float *)sub_19047336C((uint64_t)v150, mm, nn) = v78;
        for (unint64_t i1 = 1; i1 != 9; ++i1)
        {
          float v80 = sub_1904794E8((uint64_t)__src, mm, i1);
          float v81 = sub_1904794E8((uint64_t)__src, i1, nn);
          v82 = (float *)sub_19047336C((uint64_t)v150, mm, nn);
          float *v82 = *v82 + (float)(v80 * v81);
        }
      }
    }
    for (uint64_t i2 = 0; i2 != 324; i2 += 4)
      *(float *)&v150[i2] = (float)((float)(a5 * 0.5) * a5) * *(float *)&v150[i2];
    memcpy(buf, v150, 0x144uLL);
    for (unint64_t i3 = 0; i3 != 81; ++i3)
      *((float *)v147 + i3) = sub_19047A9F4((uint64_t)buf, i3) + *((float *)v147 + i3);
    memset(__dst, 0, sizeof(__dst));
    sub_1904D08E8(v9, buf[0].f32, 1.0);
    unint64_t v85 = 0;
    float v87 = *(float *)(a1 + 20);
    float v86 = *(float *)(a1 + 24);
    float v88 = *(float *)(a1 + 16);
    *(_DWORD *)v150 = 0;
    *(float *)&v150[4] = v86;
    *(float *)&v150[8] = -v87;
    *(float *)&v150[12] = -v86;
    *(_DWORD *)&v150[16] = 0;
    *(float *)&v150[20] = v88;
    *(float *)&v150[24] = v87;
    *(float *)&v150[28] = -v88;
    *(_DWORD *)&v150[32] = 0;
    do
    {
      if ((a4 & 1) == 0)
      {
        unint64_t v89 = 0;
        *(_DWORD *)sub_190477AC0((uint64_t)__dst, v85 + 3, v85) = -1082130432;
        do
        {
          float v90 = sub_1904741A8((uint64_t)buf, v85, v89);
          *(float *)sub_190477AC0((uint64_t)__dst, v85 + 3, v89 + 3) = v90;
          float v91 = sub_1904741A8((uint64_t)v150, v85, v89);
          *(float *)sub_190477AC0((uint64_t)__dst, v85 + 3, v89 + 6) = v91 + v91;
          ++v89;
        }
        while (v89 != 3);
      }
      *(_DWORD *)sub_190477AC0((uint64_t)__dst, v85 + 6, v85 + 6) = 1056964608;
      *(_DWORD *)sub_190477AC0((uint64_t)__dst, v85 + 6, v85 + 9) = -1090519040;
      ++v85;
    }
    while (v85 != 3);
    unint64_t v92 = 0;
    float v93 = *(float *)(a2 + 20) * 9.8067;
    float32x2_t v94 = (float32x2_t)vdup_n_s32(0x411CE80Au);
    *(float32x2_t *)v150 = vmul_f32(*(float32x2_t *)(a2 + 12), v94);
    *(float *)&v150[8] = v93;
    float v95 = *(float *)(a3 + 20) * 9.8067;
    *(float32x2_t *)v151 = vmul_f32(*(float32x2_t *)(a3 + 12), v94);
    *(float *)&v151[8] = v95;
    float v96 = (float)(a5 * 0.021638) + 0.0000009617;
    do
    {
      float v97 = sub_190448408((uint64_t)v150, v92) * 0.0001;
      float v98 = v96 + (float)((float)(v97 * sub_190448408((uint64_t)v150, v92)) * a5);
      *(float *)sub_190477E20((uint64_t)buf, v92) = v98;
      float v99 = sub_190448408((uint64_t)v151, v92) * 0.0001;
      float v100 = v96 + (float)((float)(v99 * sub_190448408((uint64_t)v151, v92)) * a5);
      *(float *)sub_190477E20((uint64_t)buf, v92 + 3) = v100;
      float v101 = (float)(sub_190448408(a2 + 36, v92) / 50.0) + 0.000000019496;
      float v102 = sub_190448408(a2, v92) * 0.0004;
      float v103 = v101 + (float)((float)(v102 * sub_190448408(a2, v92)) * a5);
      *(float *)sub_190477E20((uint64_t)buf, v92 + 6) = v103;
      float v104 = (float)(sub_190448408(a3 + 36, v92) / 50.0) + 0.000000019496;
      float v105 = sub_190448408(a3, v92) * 0.0004;
      float v106 = v104 + (float)((float)(v105 * sub_190448408(a3, v92)) * a5);
      *(float *)sub_190477E20((uint64_t)buf, v92 + 9) = v106;
      ++v92;
    }
    while (v92 != 3);
    unint64_t v107 = 0;
    uint64_t v108 = a1 + 10848;
    float32x4_t v109 = vmulq_n_f32(buf[1], a5);
    float32x4_t v110 = vmulq_n_f32(buf[2], a5);
    *(float32x4_t *)(a1 + 10848) = vmulq_n_f32(buf[0], a5);
    *(float32x4_t *)(a1 + 10864) = v109;
    *(float32x4_t *)(a1 + 10880) = v110;
    uint64_t v111 = a1 + 10524;
    do
    {
      unint64_t v112 = 8;
      do
      {
        for (unint64_t i4 = 0; i4 != v112; ++i4)
        {
          float v114 = *(float *)sub_19047336C((uint64_t)v147, v107, i4);
          float v115 = *(float *)sub_190479848(a1 + 10524, i4, v112);
          v116 = (float *)sub_19047336C((uint64_t)v147, v107, v112);
          float *v116 = *v116 + (float)(v114 * v115);
        }
        --v112;
      }
      while (v112);
      ++v107;
    }
    while (v107 != 9);
    uint64_t v117 = a1 + 10488;
    for (uint64_t i5 = 8; ; --i5)
    {
      unint64_t v119 = 0;
      *(_DWORD *)&v150[4 * i5] = 0;
      float v120 = 0.0;
      do
      {
        float v121 = *(float *)sub_19047336C((uint64_t)v147, i5, v119);
        float v122 = v121 * *(float *)sub_19047336C((uint64_t)v147, i5, v119);
        float v120 = v120 + (float)(v122 * *(float *)sub_190479BA4(v117, v119));
        *(float *)&v150[4 * i5] = v120;
        ++v119;
      }
      while (v119 != 9);
      for (unint64_t i6 = 0; i6 != 12; ++i6)
      {
        float v124 = *(float *)sub_190477AC0((uint64_t)__dst, i5, i6);
        float v125 = v124 * *(float *)sub_190477AC0((uint64_t)__dst, i5, i6);
        float v120 = v120 + (float)(v125 * sub_19047ABD0(v108, i6));
        *(float *)&v150[4 * i5] = v120;
      }
      if (v120 <= 0.0) {
        break;
      }
      if (!i5)
      {
        do
        {
          int v143 = *(_DWORD *)&v150[4 * i5];
          *(_DWORD *)sub_190479BA4(v117, i5++) = v143;
        }
        while (i5 != 9);
        return;
      }
      for (unint64_t i7 = 0; i7 != i5; ++i7)
      {
        unint64_t v127 = 0;
        float v128 = 0.0;
        do
        {
          float v129 = *(float *)sub_19047336C((uint64_t)v147, i7, v127);
          float v130 = v129 * *(float *)sub_190479BA4(v117, v127);
          float v128 = v128 + (float)(v130 * *(float *)sub_19047336C((uint64_t)v147, i5, v127++));
        }
        while (v127 != 9);
        for (unint64_t i8 = 0; i8 != 12; ++i8)
        {
          float v132 = *(float *)sub_190477AC0((uint64_t)__dst, i7, i8);
          float v133 = v132 * sub_19047ABD0(v108, i8);
          float v128 = v128 + (float)(v133 * *(float *)sub_190477AC0((uint64_t)__dst, i5, i8));
        }
        unint64_t v134 = 0;
        *(float *)sub_190479848(v111, i7, i5) = v128 / v120;
        do
        {
          float v135 = *(float *)sub_190479848(v111, i7, i5);
          float v136 = *(float *)sub_19047336C((uint64_t)v147, i5, v134);
          v137 = (float *)sub_19047336C((uint64_t)v147, i7, v134);
          float *v137 = *v137 - (float)(v135 * v136);
          ++v134;
        }
        while (v134 != 9);
        for (unint64_t i9 = 0; i9 != 12; ++i9)
        {
          float v139 = *(float *)sub_190479848(v111, i7, i5);
          float v140 = *(float *)sub_190477AC0((uint64_t)__dst, i5, i9);
          v141 = (float *)sub_190477AC0((uint64_t)__dst, i7, i9);
          float *v141 = *v141 - (float)(v139 * v140);
        }
      }
    }
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    v142 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEBUG))
    {
      buf[0].i32[0] = 134217984;
      *(uint64_t *)((char *)buf[0].i64 + 4) = i5;
      _os_log_impl(&dword_1902AF000, v142, OS_LOG_TYPE_DEBUG, "D[%zu] <= 0, matrix ! positive definite", (uint8_t *)buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      *(_DWORD *)v151 = 134217984;
      *(void *)&v151[4] = i5;
      float v24 = (float32x4_t *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMFactoredMatrix<float, 9>::thorntonTemporalUpdate(CMMatrix<T, N, N> &, CMMatrix<T, N, M> &, const CMVector<T, M> &) [T = float, N = 9, M = 12UL]", "CoreLocation: %s\n");
LABEL_85:
      if (v24 != buf) {
        free(v24);
      }
    }
  }
  else
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    uint64_t v23 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      buf[0].i16[0] = 0;
      _os_log_impl(&dword_1902AF000, v23, OS_LOG_TYPE_ERROR, "[CMRelDMSensorFusionMekf] Must be initialized before propagating", (uint8_t *)buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      __dst[0].i16[0] = 0;
      float v24 = (float32x4_t *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMSensorFusionMekf::propagate(const IMUData &, const IMUData &, float, BOOL)", "CoreLocation: %s\n");
      goto LABEL_85;
    }
  }
}

os_log_t sub_190478EF8()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

uint64_t sub_190478F28(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    __int32 v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      __int16 v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const T &CMQueue<CMRelDM::State>::operator[](const size_t) const [T = CMRelDM::State]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[28 * (v4 - v5) + 4];
}

uint64_t sub_190479128(unsigned __int16 *a1, uint64_t a2)
{
  unint64_t v3 = *((unsigned int *)a1 + 1);
  unint64_t v4 = *a1 + (unint64_t)a1[1];
  if (v4 < v3) {
    unint64_t v3 = 0;
  }
  uint64_t result = sub_19058AE7C((uint64_t)&a1[28 * (v4 - v3) + 4], a2);
  unsigned int v6 = a1[1];
  unint64_t v7 = *((unsigned int *)a1 + 1);
  if (v7 <= v6)
  {
    unint64_t v8 = *a1 + 1;
    if (v8 < v7) {
      LOWORD(v7) = 0;
    }
    *a1 = v8 - v7;
  }
  else
  {
    a1[1] = v6 + 1;
  }
  return result;
}

uint64_t sub_1904791A8(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 28))
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    uint64_t v2 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_ERROR, "[BodyFaceTransform] BodyFaceTransform has not been set.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      unint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const CMVector3d &CMRelDM::BodyFaceTransform::r_fb() const", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
  return a1;
}

uint64_t sub_190479348(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 28))
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
    }
    uint64_t v2 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_ERROR, "[BodyFaceTransform] BodyFaceTransform has not been set.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1700);
      }
      unint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const CMOQuaternion &CMRelDM::BodyFaceTransform::q_bf() const", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
  return a1 + 12;
}

float sub_1904794E8(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 9;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 70,invalid row %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      unint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMMatrix<float, 9>::operator()(size_t, size_t) const [T = float, M = 9, N = 9]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (a3 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    __int16 v9 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a3;
      __int16 v13 = 2048;
      uint64_t v14 = 9;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 71,invalid col %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      float32x2_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMMatrix<float, 9>::operator()(size_t, size_t) const [T = float, M = 9, N = 9]", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  return *(float *)(a1 + 4 * (9 * a3 + a2));
}

uint64_t sub_190479848(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a3 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a3;
      __int16 v13 = 2048;
      uint64_t v14 = 9;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMFactoredMatrix.h, line 237,invalid col %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      unint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMFactoredMatrix<float, 9>::UnitaryUpperTriangularMatrix::operator()(size_t, size_t) [T = float, N = 9]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (a3 <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    __int16 v9 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a3;
      __int16 v13 = 2048;
      uint64_t v14 = a2;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "Assertion failed: col > row, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMFactoredMatrix.h, line 238,invalid element %zu <= %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      float32x2_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMFactoredMatrix<float, 9>::UnitaryUpperTriangularMatrix::operator()(size_t, size_t) [T = float, N = 9]", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  return a1 + 4 * (a2 + (((a3 - 1) * a3) >> 1));
}

uint64_t sub_190479BA4(uint64_t a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 9;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: row < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMFactoredMatrix.h, line 191,invalid row %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMFactoredMatrix<float, 9>::DiagonalMatrix::operator()(size_t) [T = float, N = 9]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return a1 + 4 * a2;
}

float sub_190479D80(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 3)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 3;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 70,invalid row %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      unint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMMatrix<float, 3, 9>::operator()(size_t, size_t) const [T = float, M = 3, N = 9]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (a3 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    __int16 v9 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a3;
      __int16 v13 = 2048;
      uint64_t v14 = 9;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 71,invalid col %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMMatrix<float, 3, 9>::operator()(size_t, size_t) const [T = float, M = 3, N = 9]", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  return *(float *)(a1 + 4 * (3 * a3 + a2));
}

uint64_t sub_19047A0E0(uint64_t a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 9;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 277,invalid index %zu >= %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMVector<float, 9>::operator[](const size_t) [T = float, N = 9]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return a1 + 4 * a2;
}

float sub_19047A2BC(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 6)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 6;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 70,invalid row %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      unint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMMatrix<float, 6, 9>::operator()(size_t, size_t) const [T = float, M = 6, N = 9]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  if (a3 >= 9)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    __int16 v9 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v12 = a3;
      __int16 v13 = 2048;
      uint64_t v14 = 9;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 71,invalid col %zu > %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMMatrix<float, 6, 9>::operator()(size_t, size_t) const [T = float, M = 6, N = 9]", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  return *(float *)(a1 + 4 * (a2 + 6 * a3));
}

float sub_19047A61C(uint64_t a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 6)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 6;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 271,invalid index %zu >= %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMVector<float, 6>::operator[](const size_t) const [T = float, N = 6]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return *(float *)(a1 + 4 * a2);
}

uint64_t sub_19047A7F8(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      __int16 v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const T &CMQueue<unsigned long long>::operator[](const size_t) const [T = unsigned long long]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[4 * (v4 - v5) + 4];
}

float sub_19047A9F4(uint64_t a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x51)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 81;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: ldx < M*N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 84,invalid element %zu >= %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMMatrix<float, 9>::operator[](size_t) const [T = float, M = 9, N = 9]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return *(float *)(a1 + 4 * a2);
}

float sub_19047ABD0(uint64_t a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 0xC)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
    }
    unint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 12;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 271,invalid index %zu >= %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD34A0);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMVector<float, 12>::operator[](const size_t) const [T = float, N = 12]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return *(float *)(a1 + 4 * a2);
}

uint64_t sub_19047ADAC(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)a1 = sub_19051CBA0(1.536);
  *(_DWORD *)(a1 + 4) = sub_19051CBA0(20.48);
  sub_1905E949C(a1 + 8);
  uint64_t v2 = 0;
  unint64_t v3 = 0;
  unsigned __int16 v4 = 0;
  *(void *)(a1 + 2208) = 0x8000000000;
  *(void *)(a1 + 2728) = 0x8000000000;
  *(void *)(a1 + 3248) = 0x8000000000;
  *(void *)(a1 + 3768) = 0x8000000000;
  *(void *)(a1 + 5832) = 0x300000000;
  *(void *)(a1 + 6008) = 0x8000000000;
  *(void *)(a1 + 6528) = 0x8000000000;
  *(void *)(a1 + 7048) = 0x8000000000;
  *(_DWORD *)(a1 + 7568) = 0;
  *(void *)(a1 + 4800) = 0x8000000000;
  *(void *)(a1 + 7576) = 0;
  *(void *)(a1 + 7592) = 0;
  *(void *)(a1 + 7584) = 0;
  do
  {
    unint64_t v5 = v3 + v4;
    if (v5 >= 0x80) {
      uint64_t v6 = -128;
    }
    else {
      uint64_t v6 = 0;
    }
    *(void *)(a1 + 4808 + 8 * (v6 + v5)) = v2;
    if (v3 > 0x7F)
    {
      if (v4 >= 0x7Fu) {
        __int16 v7 = -128;
      }
      else {
        __int16 v7 = 0;
      }
      v4 += v7 + 1;
      *(_WORD *)(a1 + 4800) = v4;
    }
    else
    {
      *(_WORD *)(a1 + 4802) = ++v3;
    }
    v2 += 20000;
  }
  while (v2 != 2560000);
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1720);
  }
  unint64_t v8 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEFAULT, "[CMAccessoryWalkingDetector] Instantiating Walk Detector.", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1720);
    }
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CMAccessoryWalkingDetector::CMAccessoryWalkingDetector()", "CoreLocation: %s\n", v10);
    if (v10 != (char *)buf) {
      free(v10);
    }
  }
  return a1;
}

void sub_19047B020()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  uint64_t v2 = v1;
  unint64_t v4 = v3;
  uint64_t v6 = (float *)v5;
  uint64_t v7 = v0;
  uint64_t v318 = *MEMORY[0x1E4F143B8];
  __int32 v8 = v5[8].i32[1];
  v9.f32[0] = -v5[8].f32[0];
  *(float32x2_t *)v290 = vneg_f32(v5[7]);
  *(_DWORD *)&v290[8] = v9.i32[0];
  *(_DWORD *)v291 = v8;
  sub_1902D9ACC((float32x4_t *)v290, v9);
  float v10 = sub_1904CF73C((float *)v290, v6[3], v6[4], v6[5]);
  int v12 = v11;
  float v14 = v13;
  __int32 v15 = v2[1].i32[1];
  v16.f32[0] = -v2[1].f32[0];
  *(float32x2_t *)v290 = vneg_f32(*v2);
  *(_DWORD *)&v290[8] = v16.i32[0];
  *(_DWORD *)v291 = v15;
  sub_1902D9ACC((float32x4_t *)v290, v16);
  float v17 = sub_1904CF73C((float *)v290, *v6, v6[1], v6[2]);
  float v19 = v18;
  float v21 = v20;
  uint64_t v22 = *(unsigned __int16 *)(v7 + 3770);
  uint64_t v23 = *(unsigned __int16 *)(v7 + 3768);
  if (*(_WORD *)(v7 + 3770))
  {
    uint64_t v24 = v7 + 3776;
    unint64_t v25 = v22 + v23 - 1;
    unint64_t v26 = *(unsigned int *)(v7 + 3772);
    if (v25 < v26) {
      unint64_t v26 = 0;
    }
    if (*(void *)(v24 + 8 * (v25 - v26)) > v4 + 1000000)
    {
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1720);
      }
      float v27 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
      {
        unint64_t v28 = *(unsigned __int16 *)(v7 + 3768) + (unint64_t)*(unsigned __int16 *)(v7 + 3770) - 1;
        unint64_t v29 = *(unsigned int *)(v7 + 3772);
        if (v28 < v29) {
          unint64_t v29 = 0;
        }
        unint64_t v30 = *(void *)(v24 + 8 * (v28 - v29));
        *(_DWORD *)v290 = 134218496;
        *(double *)&v290[4] = (float)((float)v30 * 0.000001);
        *(_WORD *)v291 = 2048;
        *(double *)&v291[2] = (float)((float)v4 * 0.000001);
        __int16 v292 = 2048;
        double v293 = (float)((float)(v30 - v4) * 0.000001);
        _os_log_impl(&dword_1902AF000, v27, OS_LOG_TYPE_INFO, "[CMAccessoryWalkingDetector], dataBuffers reset due to timestamp going backwards. PreviousTS, %.3f seconds, currentTS, %.3f seconds, gap, %.3f seconds", v290, 0x20u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(v290, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1720);
        }
        unint64_t v226 = *(unsigned __int16 *)(v7 + 3768) + (unint64_t)*(unsigned __int16 *)(v7 + 3770) - 1;
        unint64_t v227 = *(unsigned int *)(v7 + 3772);
        if (v226 < v227) {
          unint64_t v227 = 0;
        }
        unint64_t v228 = *(void *)(v24 + 8 * (v226 - v227));
        LODWORD(__p[0]) = 134218496;
        *(double *)((char *)__p + 4) = (float)((float)v228 * 0.000001);
        WORD2(__p[1]) = 2048;
        *(double *)((char *)&__p[1] + 6) = (float)((float)v4 * 0.000001);
        HIWORD(__p[2]) = 2048;
        *(double *)&__p[3] = (float)((float)(v228 - v4) * 0.000001);
        v229 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CMAccessoryWalkingDetector::resetBuffersIfTimeWentFarBackward(const uint64_t)", "CoreLocation: %s\n", v229);
        if (v229 != v290) {
          free(v229);
        }
      }
      LODWORD(v23) = 0;
      LODWORD(v22) = 0;
      *(_DWORD *)(v7 + 2208) = 0;
      *(_DWORD *)(v7 + 2728) = 0;
      *(_DWORD *)(v7 + 3248) = 0;
      *(_DWORD *)(v7 + 3768) = 0;
      *(_DWORD *)(v7 + 6008) = 0;
      *(_DWORD *)(v7 + 6528) = 0;
      *(_DWORD *)(v7 + 7048) = 0;
    }
  }
  uint64_t v31 = v7 + 3776;
  uint64_t v32 = v23;
  unint64_t v33 = v23 + (unint64_t)v22;
  unint64_t v34 = *(unsigned int *)(v7 + 3772);
  if (v33 - 1 >= v34) {
    uint64_t v35 = *(unsigned int *)(v7 + 3772);
  }
  else {
    uint64_t v35 = 0;
  }
  if (v22 && *(void *)(v31 + 8 * (v33 - 1 - v35)) >= v4)
  {
    ++*(_DWORD *)(v7 + 7568);
    return;
  }
  float v36 = (_WORD *)(v7 + 2208);
  uint64_t v37 = *(unsigned __int16 *)(v7 + 2210);
  unint64_t v38 = *(unsigned int *)(v7 + 2212);
  uint64_t v39 = *(unsigned __int16 *)(v7 + 2208);
  if (v39 + v37 >= v38) {
    uint64_t v40 = *(unsigned int *)(v7 + 2212);
  }
  else {
    uint64_t v40 = 0;
  }
  *(float *)&v36[2 * (v39 + v37 - v40) + 4] = v10;
  if (v38 <= v37)
  {
    if (v39 + 1 < v38) {
      LOWORD(v38) = 0;
    }
    *float v36 = v39 + 1 - v38;
  }
  else
  {
    *(_WORD *)(v7 + 2210) = v37 + 1;
  }
  float32_t v41 = (_WORD *)(v7 + 2728);
  uint64_t v42 = *(unsigned __int16 *)(v7 + 2730);
  unint64_t v43 = *(unsigned int *)(v7 + 2732);
  uint64_t v44 = *(unsigned __int16 *)(v7 + 2728);
  if (v44 + v42 >= v43) {
    uint64_t v45 = *(unsigned int *)(v7 + 2732);
  }
  else {
    uint64_t v45 = 0;
  }
  *(_DWORD *)&v41[2 * (v44 + v42 - v45) + 4] = v12;
  if (v43 <= v42)
  {
    if (v44 + 1 < v43) {
      LOWORD(v43) = 0;
    }
    *float32_t v41 = v44 + 1 - v43;
  }
  else
  {
    *(_WORD *)(v7 + 2730) = v42 + 1;
  }
  float32x2_t v46 = (_WORD *)(v7 + 3248);
  uint64_t v47 = *(unsigned __int16 *)(v7 + 3250);
  unint64_t v48 = *(unsigned int *)(v7 + 3252);
  uint64_t v49 = *(unsigned __int16 *)(v7 + 3248);
  if (v49 + v47 >= v48) {
    uint64_t v50 = *(unsigned int *)(v7 + 3252);
  }
  else {
    uint64_t v50 = 0;
  }
  *(float *)&v46[2 * (v49 + v47 - v50) + 4] = v14 + 1.0;
  if (v48 <= v47)
  {
    if (v49 + 1 < v48) {
      LOWORD(v48) = 0;
    }
    _WORD *v46 = v49 + 1 - v48;
  }
  else
  {
    *(_WORD *)(v7 + 3250) = v47 + 1;
  }
  int8x16_t v51 = (_WORD *)(v7 + 3768);
  if (v33 >= v34) {
    unint64_t v52 = v34;
  }
  else {
    unint64_t v52 = 0;
  }
  *(void *)(v31 + 8 * (v33 - v52)) = v4;
  if (v34 <= v22)
  {
    __int16 v53 = v23 + 1;
    if (v32 + 1 >= v34) {
      __int16 v54 = v34;
    }
    else {
      __int16 v54 = 0;
    }
    LOWORD(v23) = v53 - v54;
    _WORD *v51 = v23;
  }
  else
  {
    LOWORD(v22) = v22 + 1;
    *(_WORD *)(v7 + 3770) = v22;
  }
  uint64_t v55 = *(unsigned __int16 *)(v7 + 6010);
  unint64_t v56 = *(unsigned int *)(v7 + 6012);
  unsigned int v57 = (float *)(v7 + 6016);
  uint64_t v58 = *(unsigned __int16 *)(v7 + 6008);
  if (v58 + v55 >= v56) {
    uint64_t v59 = *(unsigned int *)(v7 + 6012);
  }
  else {
    uint64_t v59 = 0;
  }
  v57[v58 + v55 - v59] = v21;
  if (v56 <= v55)
  {
    if (v58 + 1 < v56) {
      LOWORD(v56) = 0;
    }
    *(_WORD *)(v7 + 6008) = v58 + 1 - v56;
  }
  else
  {
    *(_WORD *)(v7 + 6010) = v55 + 1;
  }
  uint64_t v60 = *(unsigned __int16 *)(v7 + 6530);
  unint64_t v61 = *(unsigned int *)(v7 + 6532);
  float v62 = (float *)(v7 + 6536);
  uint64_t v63 = *(unsigned __int16 *)(v7 + 6528);
  if (v63 + v60 >= v61) {
    uint64_t v64 = *(unsigned int *)(v7 + 6532);
  }
  else {
    uint64_t v64 = 0;
  }
  v62[v63 + v60 - v64] = v17;
  v241 = (unsigned __int16 *)(v7 + 2728);
  v242 = (unsigned __int16 *)(v7 + 2208);
  v239 = (unsigned __int16 *)(v7 + 6008);
  v240 = (unsigned __int16 *)(v7 + 3248);
  v238 = (unsigned __int16 *)(v7 + 6528);
  if (v61 <= v60)
  {
    if (v63 + 1 < v61) {
      LOWORD(v61) = 0;
    }
    *(_WORD *)(v7 + 6528) = v63 + 1 - v61;
  }
  else
  {
    *(_WORD *)(v7 + 6530) = v60 + 1;
  }
  uint64_t v65 = *(unsigned __int16 *)(v7 + 7050);
  unint64_t v66 = *(unsigned int *)(v7 + 7052);
  long long v67 = (float *)(v7 + 7056);
  uint64_t v68 = *(unsigned __int16 *)(v7 + 7048);
  if (v68 + v65 >= v66) {
    uint64_t v69 = *(unsigned int *)(v7 + 7052);
  }
  else {
    uint64_t v69 = 0;
  }
  v67[v68 + v65 - v69] = v19;
  v237 = (unsigned __int16 *)(v7 + 7048);
  if (v66 <= v65)
  {
    if (v68 + 1 < v66) {
      LOWORD(v66) = 0;
    }
    *(_WORD *)(v7 + 7048) = v68 + 1 - v66;
  }
  else
  {
    *(_WORD *)(v7 + 7050) = v65 + 1;
  }
  if ((_WORD)v22)
  {
    unint64_t v70 = (unsigned __int16)v22 + (unint64_t)(unsigned __int16)v23 - 1;
    unint64_t v71 = v70 >= v34 ? v34 : 0;
    uint64_t v72 = *(void *)(v31 + 8 * (v70 - v71));
    CFAbsoluteTime v73 = (void *)sub_19047A7F8((unsigned __int16 *)(v7 + 3768), 0);
    LODWORD(v74) = *(unsigned __int16 *)(v7 + 3770);
    if ((unint64_t)(v72 - *v73 - 2540001) < 0xFFFFFFFFFFD8EFFFLL || v74 == 128)
    {
      if (v74 < 2)
      {
        unint64_t v75 = 0;
      }
      else
      {
        unint64_t v75 = 0;
        unint64_t v76 = 1;
        do
        {
          uint64_t v77 = *(void *)sub_19047A7F8((unsigned __int16 *)(v7 + 3768), v76);
          unint64_t v78 = v76 - 1;
          v79 = (void *)sub_19047A7F8((unsigned __int16 *)(v7 + 3768), v78);
          if (v77 - *v79 > v75) {
            unint64_t v75 = v77 - *v79;
          }
          unint64_t v74 = *(unsigned __int16 *)(v7 + 3770);
          unint64_t v76 = v78 + 2;
        }
        while (v76 < v74);
      }
      unsigned int v80 = *(unsigned __int16 *)(v7 + 2210);
      float v81 = (float)v80 / 2.56;
      BYTE14(v244) = v75 > 0x493E0;
      *((float *)&v245 + 3) = v81;
      *(float *)&uint64_t v246 = (float)v75 / 1000000.0;
      BYTE8(v245) = v74 < 0x80;
      if (v74 <= 0x7F)
      {
        memset(__p, 0, 24);
        if (v74)
        {
          unint64_t v82 = 0;
          do
          {
            uint64_t v83 = *(void *)sub_19047A7F8((unsigned __int16 *)(v7 + 3768), v82);
            float v84 = (float)(unint64_t)(v83 - *(void *)sub_19047A7F8((unsigned __int16 *)(v7 + 3768), 0));
            unint64_t v85 = (char *)__p[1];
            if (__p[1] >= __p[2])
            {
              float v87 = (char *)__p[0];
              int64_t v88 = ((char *)__p[1] - (char *)__p[0]) >> 2;
              unint64_t v89 = v88 + 1;
              if ((unint64_t)(v88 + 1) >> 62) {
                sub_1903479E8();
              }
              int64_t v90 = (char *)__p[2] - (char *)__p[0];
              if (((char *)__p[2] - (char *)__p[0]) >> 1 > v89) {
                unint64_t v89 = v90 >> 1;
              }
              if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v91 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v91 = v89;
              }
              if (v91)
              {
                unint64_t v92 = (char *)sub_190347D04((uint64_t)&__p[2], v91);
                unint64_t v85 = (char *)__p[1];
                float v87 = (char *)__p[0];
              }
              else
              {
                unint64_t v92 = 0;
              }
              float v93 = (float *)&v92[4 * v88];
              *float v93 = v84;
              float v86 = v93 + 1;
              while (v85 != v87)
              {
                int v94 = *((_DWORD *)v85 - 1);
                v85 -= 4;
                *((_DWORD *)v93-- - 1) = v94;
              }
              __p[0] = v93;
              __p[1] = v86;
              __p[2] = &v92[4 * v91];
              if (v87) {
                operator delete(v87);
              }
            }
            else
            {
              *(float *)__p[1] = v84;
              float v86 = v85 + 4;
            }
            __p[1] = v86;
            ++v82;
          }
          while (v82 < *(unsigned __int16 *)(v7 + 3770));
          float v95 = __p[0];
        }
        else
        {
          float v86 = 0;
          float v95 = 0;
        }
        v284[0] = 0;
        v283 = 0;
        v284[1] = 0;
        sub_19045C8B0(&v283, v95, (uint64_t)v86, ((unsigned char *)v86 - (unsigned char *)v95) >> 2);
        sub_19047C7FC(v7, (uint64_t)&v283, v242, 2);
        if (v283)
        {
          v284[0] = v283;
          operator delete(v283);
        }
        v282[0] = 0;
        v281 = 0;
        v282[1] = 0;
        sub_19045C8B0(&v281, __p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
        sub_19047C7FC(v7, (uint64_t)&v281, v241, 2);
        if (v281)
        {
          v282[0] = v281;
          operator delete(v281);
        }
        v279 = 0;
        v278 = 0;
        uint64_t v280 = 0;
        sub_19045C8B0(&v278, __p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
        sub_19047C7FC(v7, (uint64_t)&v278, v240, 2);
        if (v278)
        {
          v279 = v278;
          operator delete(v278);
        }
        v276 = 0;
        v275 = 0;
        uint64_t v277 = 0;
        sub_19045C8B0(&v275, __p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
        sub_19047C7FC(v7, (uint64_t)&v275, v239, 1);
        if (v275)
        {
          v276 = v275;
          operator delete(v275);
        }
        v272 = 0;
        v273 = 0;
        uint64_t v274 = 0;
        sub_19045C8B0(&v272, __p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
        sub_19047C7FC(v7, (uint64_t)&v272, v238, 1);
        if (v272)
        {
          v273 = v272;
          operator delete(v272);
        }
        memset(v247, 0, 24);
        sub_19045C8B0(v247, __p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
        sub_19047C7FC(v7, (uint64_t)v247, v237, 1);
        if (v247[0])
        {
          v247[1] = v247[0];
          operator delete(v247[0]);
        }
        uint64_t v96 = *(void *)sub_19047A7F8((unsigned __int16 *)(v7 + 3768), 0);
        *(_DWORD *)(v7 + 3768) = 0;
        if (*(_DWORD *)(v7 + 4804) != *(_DWORD *)(v7 + 3772))
        {
          if (qword_1EB3BE888 != -1) {
            dispatch_once(&qword_1EB3BE888, &unk_1EDFD2FA0);
          }
          v231 = off_1EB3BE880;
          if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
          {
            uint64_t v232 = *(unsigned int *)(v7 + 3772);
            uint64_t v233 = *(unsigned int *)(v7 + 4804);
            *(_DWORD *)v290 = 134218240;
            *(void *)&v290[4] = v232;
            *(_WORD *)v291 = 2048;
            *(void *)&v291[2] = v233;
            _os_log_impl(&dword_1902AF000, v231, OS_LOG_TYPE_FAULT, "Assertion failed: rhs.capacity() == capacity(), file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 70,capacity,%zu,%zu.", v290, 0x16u);
          }
          if (sub_1902D8400(115, 0))
          {
            bzero(v290, 0x65CuLL);
            if (qword_1EB3BE888 != -1) {
              dispatch_once(&qword_1EB3BE888, &unk_1EDFD2FA0);
            }
            uint64_t v234 = *(unsigned int *)(v7 + 3772);
            uint64_t v235 = *(unsigned int *)(v7 + 4804);
            int v286 = 134218240;
            uint64_t v287 = v234;
            __int16 v288 = 2048;
            uint64_t v289 = v235;
            v236 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 0, "void CMQueue<unsigned long long>::deepCopy(const CMQueue<T> &) [T = unsigned long long]", "CoreLocation: %s\n", v236);
            if (v236 != v290) {
              free(v236);
            }
          }
        }
        if (*(_WORD *)(v7 + 4802))
        {
          unint64_t v97 = 0;
          do
          {
            float v98 = (void *)sub_19047A7F8((unsigned __int16 *)(v7 + 4800), v97);
            uint64_t v99 = *(unsigned __int16 *)(v7 + 3770);
            unint64_t v100 = *(unsigned int *)(v7 + 3772);
            uint64_t v101 = *(unsigned __int16 *)(v7 + 3768);
            if (v101 + v99 >= v100) {
              uint64_t v102 = *(unsigned int *)(v7 + 3772);
            }
            else {
              uint64_t v102 = 0;
            }
            *(void *)(v31 + 8 * (v101 + v99 - v102)) = *v98;
            if (v100 <= v99)
            {
              if (v101 + 1 < v100) {
                LOWORD(v100) = 0;
              }
              _WORD *v51 = v101 + 1 - v100;
            }
            else
            {
              *(_WORD *)(v7 + 3770) = v99 + 1;
            }
            ++v97;
          }
          while (v97 < *(unsigned __int16 *)(v7 + 4802));
          if (*(_WORD *)(v7 + 4802))
          {
            unint64_t v103 = 0;
            do
            {
              float v104 = (void *)sub_19047A7F8((unsigned __int16 *)(v7 + 3768), v103);
              *v104 += v96;
              ++v103;
            }
            while (v103 < *(unsigned __int16 *)(v7 + 4802));
          }
        }
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unsigned int v80 = *(unsigned __int16 *)(v7 + 2210);
      }
      __p[0] = (void *)0x10000000000;
      v283 = (void *)0x10000000000;
      v281 = (void *)0x10000000000;
      if (v80)
      {
        unint64_t v105 = 0;
        do
        {
          float v106 = (_DWORD *)sub_190431610(v242, v105);
          sub_190430014((unsigned __int16 *)__p, v106);
          unint64_t v107 = (_DWORD *)sub_190431610(v241, v105);
          sub_190430014((unsigned __int16 *)&v283, v107);
          uint64_t v108 = (_DWORD *)sub_190431610(v240, v105);
          sub_190430014((unsigned __int16 *)&v281, v108);
          ++v105;
          unint64_t v109 = *(unsigned __int16 *)(v7 + 2210);
        }
        while (v105 < v109);
        if (v109 > 0xFF)
        {
LABEL_177:
          sub_1905E95E8(v7 + 8, &v278, (unsigned __int16 *)__p);
          sub_1905E95E8(v7 + 8, &v275, (unsigned __int16 *)&v283);
          sub_1905E95E8(v7 + 8, &v272, (unsigned __int16 *)&v281);
          float v136 = sub_19051CD64(*(_DWORD *)v7, *(_DWORD *)(v7 + 4), (uint64_t)&v278);
          float v137 = v136 + sub_19051CD64(*(_DWORD *)v7, *(_DWORD *)(v7 + 4), (uint64_t)&v275);
          *(float *)&long long v243 = v137;
          float v138 = sub_19051CD64(*(_DWORD *)v7, *(_DWORD *)(v7 + 4), (uint64_t)&v272);
          float v139 = v138 / v137;
          *((float *)&v243 + 1) = v138;
          *((float *)&v243 + 2) = v138 / v137;
          float v140 = sub_19051CF68(*(_DWORD *)v7, *(_DWORD *)(v7 + 4), (uint64_t)&v272);
          *((float *)&v243 + 3) = v140;
          uint64_t v141 = *(unsigned __int16 *)(v7 + 6010);
          float v142 = 0.0;
          float v143 = 0.0;
          if (*(_WORD *)(v7 + 6010))
          {
            do
            {
              float v144 = *v57++;
              float v143 = v143 + fabsf(v144);
              --v141;
            }
            while (v141);
            float v143 = v143 * 57.2957795 * 20000.0 / 1000000.0;
          }
          *(float *)&long long v244 = v143;
          uint64_t v145 = *(unsigned __int16 *)(v7 + 6530);
          if (*(_WORD *)(v7 + 6530))
          {
            float v146 = 0.0;
            do
            {
              float v147 = *v62++;
              float v146 = v146 + fabsf(v147);
              --v145;
            }
            while (v145);
            float v142 = v146 * 57.2957795 * 20000.0 / 1000000.0;
          }
          *((float *)&v244 + 1) = v142;
          uint64_t v148 = *(unsigned __int16 *)(v7 + 7050);
          if (*(_WORD *)(v7 + 7050))
          {
            float v149 = 0.0;
            do
            {
              float v150 = *v67++;
              float v149 = v149 + fabsf(v150);
              --v148;
            }
            while (v148);
            float v151 = v149 * 57.2957795 * 20000.0 / 1000000.0;
          }
          else
          {
            float v151 = 0.0;
          }
          unsigned __int8 v152 = 0;
          *((float *)&v244 + 2) = v151;
          if (v75 <= 0x493E0 && v81 >= 15.0 && v137 > 1.8)
          {
            BOOL v153 = v139 <= 0.4 || v140 <= 0.25;
            BOOL v154 = v153 || v143 < 5.0;
            if (!v154 && v143 <= 120.0)
            {
              BOOL v156 = v142 >= 5.0;
              if (v142 > 80.0) {
                BOOL v156 = 0;
              }
              unsigned __int8 v152 = v151 >= 0.0 && v156;
            }
          }
          WORD6(v244) = v152;
          v157 = (_WORD *)(v7 + 5832);
          unint64_t v158 = *(unsigned __int16 *)(v7 + 5834);
          if (v158 == 3)
          {
            for (unint64_t i = 1; i < v158; ++i)
            {
              v152 &= *(unsigned char *)(sub_19047CB30((unsigned __int16 *)(v7 + 5832), i) + 28);
              BYTE13(v244) = v152;
              unint64_t v158 = *(unsigned __int16 *)(v7 + 5834);
            }
          }
          unint64_t v160 = *(unsigned __int16 *)(v7 + 3768) + (unint64_t)*(unsigned __int16 *)(v7 + 3770) - 1;
          unint64_t v161 = *(unsigned int *)(v7 + 3772);
          if (v160 < v161) {
            unint64_t v161 = 0;
          }
          *(void *)&long long v245 = *(void *)(v31 + 8 * (v160 - v161));
          HIDWORD(v246) = *(_DWORD *)(v7 + 7568);
          unint64_t v162 = *(unsigned int *)(v7 + 5836);
          uint64_t v163 = v7 + 5840;
          unint64_t v164 = v158 + *(unsigned __int16 *)(v7 + 5832);
          if (v164 < v162) {
            unint64_t v162 = 0;
          }
          uint64_t v165 = v163 + 56 * (v164 - v162);
          *(void *)(v165 + 48) = v246;
          long long v166 = v244;
          *(_OWORD *)uint64_t v165 = v243;
          *(_OWORD *)(v165 + 16) = v166;
          *(_OWORD *)(v165 + 32) = v245;
          unsigned int v167 = *(unsigned __int16 *)(v7 + 5834);
          unint64_t v168 = *(unsigned int *)(v7 + 5836);
          if (v168 <= v167)
          {
            unint64_t v169 = (unsigned __int16)*v157 + 1;
            if (v169 >= v168) {
              __int16 v170 = *(_DWORD *)(v7 + 5836);
            }
            else {
              __int16 v170 = 0;
            }
            _WORD *v157 = v169 - v170;
          }
          else
          {
            LOWORD(v167) = v167 + 1;
            *(_WORD *)(v7 + 5834) = v167;
          }
          v171 = *(void (**)(void, void))(v7 + 7576);
          if (v171 && (unsigned __int16)v167 == 3 && *(void *)(v7 + 7584))
          {
            unint64_t v172 = (unsigned __int16)*v157 + 2;
            if (v172 < v168) {
              unint64_t v168 = 0;
            }
            v171(*(unsigned __int8 *)(v163 + 56 * (v172 - v168) + 29), *(void *)(v163 + 56 * (v172 - v168) + 32));
          }
          v173 = *(uint64_t **)(v7 + 7592);
          if (v173) {
            sub_190458ED4(v173, (uint64_t)&v243);
          }
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1720);
          }
          v174 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)v290 = 134221568;
            *(double *)&v290[4] = *(float *)&v243;
            *(_WORD *)v291 = 2048;
            *(double *)&v291[2] = *((float *)&v243 + 1);
            __int16 v292 = 2048;
            double v293 = *((float *)&v243 + 2);
            __int16 v294 = 2048;
            double v295 = *((float *)&v243 + 3);
            __int16 v296 = 2048;
            double v297 = *(float *)&v244;
            __int16 v298 = 2048;
            double v299 = *((float *)&v244 + 1);
            __int16 v300 = 2048;
            double v301 = *((float *)&v244 + 2);
            __int16 v302 = 1024;
            int v303 = BYTE12(v244);
            __int16 v304 = 1024;
            int v305 = BYTE13(v244);
            __int16 v306 = 1024;
            int v307 = BYTE14(v244);
            __int16 v308 = 2048;
            uint64_t v309 = v245;
            __int16 v310 = 1024;
            int v311 = BYTE8(v245);
            __int16 v312 = 2048;
            double v313 = *((float *)&v245 + 3);
            __int16 v314 = 2048;
            double v315 = *(float *)&v246;
            __int16 v316 = 1024;
            int v317 = HIDWORD(v246);
            _os_log_impl(&dword_1902AF000, v174, OS_LOG_TYPE_INFO, "[CMAccessoryWalkingDetector],pedEnergyPlane,%f,pedEnergyZ,%f,pedEnergyZByPlane,%f,pedEnergyZPeak,%f,thetaRollFaceDeg,%f,thetaPitchFaceDeg,%f,thetaYawFaceDeg,%f,isWalkingRaw,%d,isWalkingFiltered,%d,isMissingSamples,%d,timestamp,%lld,isInterpolated,%d,dataRate,%f,maxSampleDeltaInSecond,%f,reversedTimestampCounts,%d", v290, 0x84u);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(v290, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1720);
            }
            LODWORD(v247[0]) = 134221568;
            *(double *)((char *)v247 + 4) = *(float *)&v243;
            WORD2(v247[1]) = 2048;
            *(double *)((char *)&v247[1] + 6) = *((float *)&v243 + 1);
            HIWORD(v247[2]) = 2048;
            *(double *)&v247[3] = *((float *)&v243 + 2);
            __int16 v248 = 2048;
            double v249 = *((float *)&v243 + 3);
            __int16 v250 = 2048;
            double v251 = *(float *)&v244;
            __int16 v252 = 2048;
            double v253 = *((float *)&v244 + 1);
            __int16 v254 = 2048;
            double v255 = *((float *)&v244 + 2);
            __int16 v256 = 1024;
            int v257 = BYTE12(v244);
            __int16 v258 = 1024;
            int v259 = BYTE13(v244);
            __int16 v260 = 1024;
            int v261 = BYTE14(v244);
            __int16 v262 = 2048;
            uint64_t v263 = v245;
            __int16 v264 = 1024;
            int v265 = BYTE8(v245);
            __int16 v266 = 2048;
            double v267 = *((float *)&v245 + 3);
            __int16 v268 = 2048;
            double v269 = *(float *)&v246;
            __int16 v270 = 1024;
            int v271 = HIDWORD(v246);
            v230 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "void CMAccessoryWalkingDetector::processData()", "CoreLocation: %s\n", v230);
            if (v230 != v290) {
              free(v230);
            }
          }
          unint64_t v175 = *(unsigned __int16 *)(v7 + 5832) + (unint64_t)*(unsigned __int16 *)(v7 + 5834) - 1;
          unint64_t v176 = *(unsigned int *)(v7 + 5836);
          if (v175 < v176) {
            unint64_t v176 = 0;
          }
          if (*(unsigned char *)(v163 + 56 * (v175 - v176) + 30))
          {
            *(_DWORD *)v242 = 0;
            *(_DWORD *)v241 = 0;
            *(_DWORD *)v240 = 0;
            *(_DWORD *)int8x16_t v51 = 0;
            *(_DWORD *)v239 = 0;
            *(_DWORD *)v238 = 0;
            *(_DWORD *)v237 = 0;
          }
          else
          {
            unint64_t v177 = *(unsigned __int16 *)(v7 + 2210);
            if (v177 >= 0x41)
            {
              uint64_t v178 = (v177 - 64);
              uint64_t v179 = *(unsigned __int16 *)(v7 + 2208);
              unint64_t v180 = *(unsigned int *)(v7 + 2212);
              do
              {
                if ((_WORD)v177)
                {
                  unint64_t v181 = v179 + 1;
                  if (v181 >= v180) {
                    __int16 v182 = v180;
                  }
                  else {
                    __int16 v182 = 0;
                  }
                  unsigned __int16 v183 = v181 - v182;
                  uint64_t v179 = v183;
                  *(_WORD *)(v7 + 2208) = v183;
                  LOWORD(v177) = v177 - 1;
                  *(_WORD *)(v7 + 2210) = v177;
                }
                else
                {
                  LOWORD(v177) = 0;
                }
                --v178;
              }
              while (v178);
            }
            unint64_t v184 = *(unsigned __int16 *)(v7 + 2730);
            if (v184 >= 0x41)
            {
              uint64_t v185 = (v184 - 64);
              uint64_t v186 = *(unsigned __int16 *)(v7 + 2728);
              unint64_t v187 = *(unsigned int *)(v7 + 2732);
              do
              {
                if ((_WORD)v184)
                {
                  unint64_t v188 = v186 + 1;
                  if (v188 >= v187) {
                    __int16 v189 = v187;
                  }
                  else {
                    __int16 v189 = 0;
                  }
                  unsigned __int16 v190 = v188 - v189;
                  uint64_t v186 = v190;
                  *(_WORD *)(v7 + 2728) = v190;
                  LOWORD(v184) = v184 - 1;
                  *(_WORD *)(v7 + 2730) = v184;
                }
                else
                {
                  LOWORD(v184) = 0;
                }
                --v185;
              }
              while (v185);
            }
            unint64_t v191 = *(unsigned __int16 *)(v7 + 3250);
            if (v191 >= 0x41)
            {
              uint64_t v192 = (v191 - 64);
              uint64_t v193 = *(unsigned __int16 *)(v7 + 3248);
              unint64_t v194 = *(unsigned int *)(v7 + 3252);
              do
              {
                if ((_WORD)v191)
                {
                  unint64_t v195 = v193 + 1;
                  if (v195 >= v194) {
                    __int16 v196 = v194;
                  }
                  else {
                    __int16 v196 = 0;
                  }
                  unsigned __int16 v197 = v195 - v196;
                  uint64_t v193 = v197;
                  *(_WORD *)(v7 + 3248) = v197;
                  LOWORD(v191) = v191 - 1;
                  *(_WORD *)(v7 + 3250) = v191;
                }
                else
                {
                  LOWORD(v191) = 0;
                }
                --v192;
              }
              while (v192);
            }
            unint64_t v198 = *(unsigned __int16 *)(v7 + 3770);
            if (v198 >= 0x41)
            {
              uint64_t v199 = (v198 - 64);
              uint64_t v200 = *(unsigned __int16 *)(v7 + 3768);
              unint64_t v201 = *(unsigned int *)(v7 + 3772);
              do
              {
                if ((_WORD)v198)
                {
                  unint64_t v202 = v200 + 1;
                  if (v202 >= v201) {
                    __int16 v203 = v201;
                  }
                  else {
                    __int16 v203 = 0;
                  }
                  unsigned __int16 v204 = v202 - v203;
                  uint64_t v200 = v204;
                  *(_WORD *)(v7 + 3768) = v204;
                  LOWORD(v198) = v198 - 1;
                  *(_WORD *)(v7 + 3770) = v198;
                }
                else
                {
                  LOWORD(v198) = 0;
                }
                --v199;
              }
              while (v199);
            }
            unint64_t v205 = *(unsigned __int16 *)(v7 + 6010);
            if (v205 >= 0x41)
            {
              uint64_t v206 = (v205 - 64);
              uint64_t v207 = *(unsigned __int16 *)(v7 + 6008);
              unint64_t v208 = *(unsigned int *)(v7 + 6012);
              do
              {
                if ((_WORD)v205)
                {
                  unint64_t v209 = v207 + 1;
                  if (v209 >= v208) {
                    __int16 v210 = v208;
                  }
                  else {
                    __int16 v210 = 0;
                  }
                  unsigned __int16 v211 = v209 - v210;
                  uint64_t v207 = v211;
                  *(_WORD *)(v7 + 6008) = v211;
                  LOWORD(v205) = v205 - 1;
                  *(_WORD *)(v7 + 6010) = v205;
                }
                else
                {
                  LOWORD(v205) = 0;
                }
                --v206;
              }
              while (v206);
            }
            unint64_t v212 = *(unsigned __int16 *)(v7 + 6530);
            if (v212 >= 0x41)
            {
              uint64_t v213 = (v212 - 64);
              uint64_t v214 = *(unsigned __int16 *)(v7 + 6528);
              unint64_t v215 = *(unsigned int *)(v7 + 6532);
              do
              {
                if ((_WORD)v212)
                {
                  unint64_t v216 = v214 + 1;
                  if (v216 >= v215) {
                    __int16 v217 = v215;
                  }
                  else {
                    __int16 v217 = 0;
                  }
                  unsigned __int16 v218 = v216 - v217;
                  uint64_t v214 = v218;
                  *(_WORD *)(v7 + 6528) = v218;
                  LOWORD(v212) = v212 - 1;
                  *(_WORD *)(v7 + 6530) = v212;
                }
                else
                {
                  LOWORD(v212) = 0;
                }
                --v213;
              }
              while (v213);
            }
            unint64_t v219 = *(unsigned __int16 *)(v7 + 7050);
            if (v219 >= 0x41)
            {
              uint64_t v220 = (v219 - 64);
              uint64_t v221 = *(unsigned __int16 *)(v7 + 7048);
              unint64_t v222 = *(unsigned int *)(v7 + 7052);
              do
              {
                if ((_WORD)v219)
                {
                  unint64_t v223 = v221 + 1;
                  if (v223 >= v222) {
                    __int16 v224 = v222;
                  }
                  else {
                    __int16 v224 = 0;
                  }
                  unsigned __int16 v225 = v223 - v224;
                  uint64_t v221 = v225;
                  *(_WORD *)(v7 + 7048) = v225;
                  LOWORD(v219) = v219 - 1;
                  *(_WORD *)(v7 + 7050) = v219;
                }
                else
                {
                  LOWORD(v219) = 0;
                }
                --v220;
              }
              while (v220);
            }
          }
          *(_DWORD *)(v7 + 7568) = 0;
          return;
        }
        uint64_t v110 = (unsigned __int16)v281;
        uint64_t v111 = (unsigned __int16)v283;
        uint64_t v112 = LOWORD(__p[0]);
        unsigned int v113 = HIDWORD(__p[0]);
        unsigned int v114 = HIDWORD(v283);
        unsigned int v115 = HIDWORD(v281);
        unsigned __int16 v116 = WORD1(__p[0]);
        unsigned __int16 v117 = WORD1(v283);
        unsigned __int16 v118 = WORD1(v281);
      }
      else
      {
        unsigned __int16 v118 = 0;
        unsigned __int16 v117 = 0;
        unsigned __int16 v116 = 0;
        uint64_t v112 = 0;
        uint64_t v111 = 0;
        uint64_t v110 = 0;
        unint64_t v109 = 0;
        unsigned int v115 = 256;
        unsigned int v114 = 256;
        unsigned int v113 = 256;
      }
      unint64_t v119 = v109 - 256;
      do
      {
        unint64_t v120 = v112 + v116;
        if (v120 >= v113) {
          uint64_t v121 = v113;
        }
        else {
          uint64_t v121 = 0;
        }
        *((_DWORD *)&__p[1] + v120 - v121) = 0;
        if (v113 <= v116)
        {
          unint64_t v122 = v112 + 1;
          if (v122 >= v113) {
            __int16 v123 = v113;
          }
          else {
            __int16 v123 = 0;
          }
          unsigned __int16 v124 = v122 - v123;
          uint64_t v112 = v124;
          LOWORD(__p[0]) = v124;
        }
        else
        {
          WORD1(__p[0]) = ++v116;
        }
        unint64_t v125 = v111 + v117;
        if (v125 >= v114) {
          uint64_t v126 = v114;
        }
        else {
          uint64_t v126 = 0;
        }
        *((_DWORD *)v284 + v125 - v126) = 0;
        if (v114 <= v117)
        {
          unint64_t v127 = v111 + 1;
          if (v127 >= v114) {
            __int16 v128 = v114;
          }
          else {
            __int16 v128 = 0;
          }
          unsigned __int16 v129 = v127 - v128;
          uint64_t v111 = v129;
          LOWORD(v283) = v129;
        }
        else
        {
          WORD1(v283) = ++v117;
        }
        unint64_t v130 = v110 + v118;
        if (v130 >= v115) {
          uint64_t v131 = v115;
        }
        else {
          uint64_t v131 = 0;
        }
        *((_DWORD *)v282 + v130 - v131) = 0;
        if (v115 <= v118)
        {
          unint64_t v132 = v110 + 1;
          if (v132 >= v115) {
            __int16 v133 = v115;
          }
          else {
            __int16 v133 = 0;
          }
          unsigned __int16 v134 = v132 - v133;
          uint64_t v110 = v134;
          LOWORD(v281) = v134;
        }
        else
        {
          WORD1(v281) = ++v118;
        }
      }
      while (!__CFADD__(v119++, 1));
      goto LABEL_177;
    }
  }
}

void sub_19047C748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  unint64_t v26 = (void *)STACK[0xF20];
  if (STACK[0xF20])
  {
    STACK[0xF28] = (unint64_t)v26;
    operator delete(v26);
  }
  _Unwind_Resume(a1);
}

void sub_19047C7FC(uint64_t a1, uint64_t a2, unsigned __int16 *a3, int a4)
{
  unint64_t v8 = a3[1];
  uint64_t v45 = 0;
  float32x2_t v46 = 0;
  uint64_t v47 = 0;
  if (v8)
  {
    sub_190347CC0(&v45, v8);
    float32x4_t v9 = (char *)v46;
    bzero(v46, 4 * v8);
    unint64_t v10 = 0;
    float32x2_t v46 = &v9[4 * v8];
    do
    {
      int v11 = (_DWORD *)sub_190431610(a3, v10);
      *((_DWORD *)v45 + v10++) = *v11;
    }
    while (v8 != v10);
  }
  *(_DWORD *)a3 = 0;
  if (*(unsigned __int16 *)(a1 + 4802) >= 0x80u) {
    uint64_t v12 = 128;
  }
  else {
    uint64_t v12 = *(unsigned __int16 *)(a1 + 4802);
  }
  if (v12)
  {
    unint64_t v13 = 0;
    float v14 = (unsigned __int16 *)(a1 + 4800);
    while (1)
    {
      unint64_t v15 = *(void *)sub_19047A7F8(v14, v13);
      std::string __p = 0;
      unint64_t v43 = 0;
      uint64_t v44 = 0;
      sub_19045C8B0(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      sub_19045C8B0(&v39, v45, (uint64_t)v46, ((unsigned char *)v46 - (unsigned char *)v45) >> 2);
      float32x4_t v16 = __p;
      float v17 = v39;
      unint64_t v18 = v40 - v39;
      unint64_t v19 = (unint64_t)(v40 - v39) >> 2;
      if ((int)v19 <= a4) {
        int v20 = (unint64_t)(v40 - v39) >> 2;
      }
      else {
        int v20 = a4 + 1;
      }
      float v21 = (float)v15;
      uint64_t v22 = (float *)v39;
      if (*(float *)__p >= (float)v15) {
        goto LABEL_20;
      }
      uint64_t v23 = (v18 << 30) - 0x100000000;
      if (*(float *)((char *)__p + (v23 >> 30)) <= v21) {
        break;
      }
      if ((int)v19 < 1)
      {
        LODWORD(v24) = 0;
      }
      else
      {
        unint64_t v24 = 0;
        uint64_t v25 = (v18 >> 2);
        while (*((float *)__p + v24) < v21)
        {
          if (v25 == ++v24)
          {
            unint64_t v24 = (unint64_t)(v40 - v39) >> 2;
            break;
          }
        }
      }
      if (v20 < 1)
      {
        float v26 = 0.0;
      }
      else
      {
        uint64_t v31 = 0;
        int v32 = (v24 - (v20 >> 1)) & ~((int)(v24 - (v20 >> 1)) >> 31);
        if (v32 + v20 <= (int)v19) {
          int v33 = v32;
        }
        else {
          int v33 = v19 - v20;
        }
        uint64_t v34 = v33 + v20;
        float v26 = 0.0;
        uint64_t v35 = v33;
        do
        {
          float v36 = 1.0;
          uint64_t v37 = v31;
          uint64_t v38 = v33;
          do
          {
            if (v37) {
              float v36 = (float)(v36 * (float)(v21 - *((float *)__p + v38)))
            }
                  / (float)(*((float *)__p + v35) - *((float *)__p + v38));
            ++v38;
            --v37;
          }
          while (v38 < v34);
          float v26 = v26 + (float)(*(float *)&v39[4 * v35++] * v36);
          ++v31;
        }
        while (v35 < v34);
      }
LABEL_21:
      uint64_t v27 = a3[1];
      unint64_t v28 = *((unsigned int *)a3 + 1);
      uint64_t v29 = *a3;
      if (v29 + v27 >= v28) {
        uint64_t v30 = *((unsigned int *)a3 + 1);
      }
      else {
        uint64_t v30 = 0;
      }
      *(float *)&a3[2 * (v29 + v27 - v30) + 4] = v26;
      if (v28 <= v27)
      {
        if (v29 + 1 < v28) {
          LOWORD(v28) = 0;
        }
        *a3 = v29 + 1 - v28;
        if (!v17) {
          goto LABEL_31;
        }
      }
      else
      {
        a3[1] = v27 + 1;
        if (!v17) {
          goto LABEL_31;
        }
      }
      uint64_t v40 = v17;
      operator delete(v17);
      float32x4_t v16 = __p;
LABEL_31:
      if (v16)
      {
        unint64_t v43 = v16;
        operator delete(v16);
      }
      if (++v13 == v12) {
        goto LABEL_48;
      }
    }
    uint64_t v22 = (float *)&v39[4 * (v23 >> 32)];
LABEL_20:
    float v26 = *v22;
    goto LABEL_21;
  }
LABEL_48:
  if (v45)
  {
    float32x2_t v46 = v45;
    operator delete(v45);
  }
}

void sub_19047CAC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

os_log_t sub_19047CB00()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

uint64_t sub_19047CB30(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD2FA0);
    }
    uint64_t v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD2FA0);
      }
      float32x4_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const T &CMQueue<DistViewDetection>::operator[](const size_t) const [T = DistViewDetection]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[28 * (v4 - v5) + 4];
}

id *sub_19047CD80(id *a1, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (a1)
  {
    v16.receiver = a1;
    v16.super_class = (Class)RMConnectionClient;
    unint64_t v11 = (id *)objc_msgSendSuper2(&v16, sel_init);
    a1 = v11;
    if (v11)
    {
      objc_storeStrong(v11 + 4, a2);
      objc_storeStrong(a1 + 3, a3);
      objc_setProperty_nonatomic_copy(a1, v12, v10, 48);
      uint64_t v13 = objc_opt_new();
      id v14 = a1[7];
      a1[7] = (id)v13;

      *((unsigned char *)a1 + 8) = 1;
    }
  }

  return a1;
}

void sub_19047CE5C(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    id v2 = *(id *)(a1 + 56);
    uint64_t v4 = objc_msgSend_countByEnumeratingWithState_objects_count_(v2, v3, (uint64_t)&v25, v31, 16);
    if (!v4)
    {
      uint64_t v6 = (id *)v2;
LABEL_31:

      return;
    }
    uint64_t v5 = v4;
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)v26;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v26 != v7) {
          objc_enumerationMutation(v2);
        }
        uint64_t v9 = *(void *)(*((void *)&v25 + 1) + 8 * v8);
        if (v9 && *(void *)(v9 + 24))
        {
          id v10 = (id *)(id)v9;
          unint64_t v11 = v6;
          uint64_t v6 = v10;
        }
        else
        {
          if (qword_1E929DE08 != -1) {
            dispatch_once(&qword_1E929DE08, &unk_1EDFD1740);
          }
          SEL v12 = (void *)qword_1E929DE10;
          if (os_log_type_enabled((os_log_t)qword_1E929DE10, OS_LOG_TYPE_DEFAULT))
          {
            if (v9) {
              uint64_t v13 = *(void *)(v9 + 8);
            }
            else {
              uint64_t v13 = 0;
            }
            *(_DWORD *)buf = 138412290;
            uint64_t v30 = v13;
            id v14 = v12;
            _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_DEFAULT, "Sending cached message %@", buf, 0xCu);
          }
          unint64_t v15 = *(void **)(a1 + 16);
          if (v9)
          {
            id v16 = *(id *)(v9 + 8);
            float v17 = *(void **)(v9 + 16);
          }
          else
          {
            id v16 = 0;
            float v17 = 0;
          }
          unint64_t v11 = v15;
          sub_190450E80((uint64_t)v11, v16, v17);
        }
        ++v8;
      }
      while (v5 != v8);
      uint64_t v19 = objc_msgSend_countByEnumeratingWithState_objects_count_(v2, v18, (uint64_t)&v25, v31, 16);
      uint64_t v5 = v19;
    }
    while (v19);

    if (v6)
    {
      if (qword_1E929DE08 != -1) {
        dispatch_once(&qword_1E929DE08, &unk_1EDFD1740);
      }
      int v20 = qword_1E929DE10;
      if (os_log_type_enabled((os_log_t)qword_1E929DE10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v20, OS_LOG_TYPE_DEFAULT, "Restoring the streaming channel", buf, 2u);
      }
      id v21 = v6[1];
      id v22 = v6[3];
      id v23 = v6[2];
      id v24 = v21;
      sub_19047D160(a1, v24, v23, v22);

      goto LABEL_31;
    }
  }
}

id sub_19047D10C()
{
  if (qword_1E929DE08 != -1) {
    dispatch_once(&qword_1E929DE08, &unk_1EDFD1740);
  }
  uint64_t v0 = (void *)qword_1E929DE10;

  return v0;
}

void sub_19047D160(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    if (*(void *)(a1 + 40))
    {
      id v23 = sub_19047D10C();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
      {
        *(void *)long long v28 = 68289539;
        *(_WORD *)&v28[8] = 2082;
        *(void *)&v28[10] = "";
        __int16 v29 = 2082;
        uint64_t v30 = "assert";
        __int16 v31 = 2081;
        uint64_t v32 = "!self.streamingDataCallback";
        _os_log_impl(&dword_1902AF000, v23, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Stream requested while one is already present\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v28, 0x26u);
      }

      id v24 = sub_19047D10C();
      if (os_signpost_enabled(v24))
      {
        *(void *)long long v28 = 68289539;
        *(_WORD *)&v28[8] = 2082;
        *(void *)&v28[10] = "";
        __int16 v29 = 2082;
        uint64_t v30 = "assert";
        __int16 v31 = 2081;
        uint64_t v32 = "!self.streamingDataCallback";
        _os_signpost_emit_with_name_impl(&dword_1902AF000, v24, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Stream requested while one is already present", "{\"msg%{public}.0s\":\"Stream requested while one is already present\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v28, 0x26u);
      }

      long long v25 = sub_19047D10C();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        *(void *)long long v28 = 68289539;
        *(_WORD *)&v28[8] = 2082;
        *(void *)&v28[10] = "";
        __int16 v29 = 2082;
        uint64_t v30 = "assert";
        __int16 v31 = 2081;
        uint64_t v32 = "!self.streamingDataCallback";
        _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Stream requested while one is already present\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v28, 0x26u);
      }

      abort_report_np();
    }
    objc_setProperty_nonatomic_copy((id)a1, v11, v10, 40);
    uint64_t v12 = *(void *)(a1 + 16);
    v26[0] = MEMORY[0x1E4F143A8];
    v26[1] = 3221225472;
    v26[2] = sub_19047D654;
    v26[3] = &unk_1E568D958;
    v26[4] = a1;
    id v13 = v10;
    id v27 = v13;
    sub_190451B40(v12, v8, v9, v26);
    id v14 = *(id *)(a1 + 56);
    unint64_t v15 = [RMConnectionClientCachedMessage alloc];
    id v16 = v8;
    id v17 = v9;
    id v18 = v13;
    if (v15)
    {
      *(void *)long long v28 = v15;
      *(void *)&v28[8] = RMConnectionClientCachedMessage;
      uint64_t v19 = (RMConnectionClientCachedMessage *)objc_msgSendSuper2((objc_super *)v28, sel_init);
      unint64_t v15 = v19;
      if (v19)
      {
        objc_storeStrong((id *)&v19->_name, a2);
        objc_storeStrong((id *)&v15->_data, a3);
        int v20 = _Block_copy(v18);
        streamingCallbacunint64_t k = v15->_streamingCallback;
        v15->_streamingCallbacunint64_t k = v20;
      }
    }

    objc_msgSend_addObject_(v14, v22, (uint64_t)v15);
  }
}

void sub_19047D4E0(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    if (*(unsigned char *)(a1 + 8))
    {
      id v2 = *(id *)(a1 + 24);
      uint64_t v5 = (const char *)objc_msgSend_UTF8String(v2, v3, v4);
      xpc_connection_t mach_service = xpc_connection_create_mach_service(v5, *(dispatch_queue_t *)(a1 + 32), 0);

      uint64_t v6 = [RMConnectionEndpoint alloc];
      id v7 = *(id *)(a1 + 32);
      id v8 = sub_1904509B0(v6, mach_service, v7);
      id v9 = *(void **)(a1 + 16);
      *(void *)(a1 + 16) = v8;

      uint64_t v10 = *(void *)(a1 + 16);
      if (v10 && (objc_storeWeak((id *)(v10 + 16), (id)a1), (uint64_t v11 = *(void *)(a1 + 16)) != 0))
      {
        objc_storeWeak((id *)(v11 + 24), (id)a1);
        uint64_t v12 = *(void *)(a1 + 16);
      }
      else
      {
        uint64_t v12 = 0;
      }
      sub_190450DA4(v12);
    }
    else
    {
      if (qword_1E929DE08 != -1) {
        dispatch_once(&qword_1E929DE08, &unk_1EDFD1740);
      }
      id v13 = qword_1E929DE10;
      if (os_log_type_enabled((os_log_t)qword_1E929DE10, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_FAULT, "Trying to connect after invalidation", buf, 2u);
      }
    }
  }
}

void sub_19047D654(uint64_t a1, void *a2)
{
  id v3 = a2;
  sub_19047D740(*(void *)(a1 + 32));
  if (objc_msgSend_code(v3, v4, v5) == -3
    && ((v6 = *(void *)(a1 + 32)) == 0 ? (uint64_t v7 = 0) : (uint64_t v7 = *(void *)(v6 + 16)), sub_19045271C(v7)))
  {
    if (qword_1E929DE08 != -1) {
      dispatch_once(&qword_1E929DE08, &unk_1EDFD1740);
    }
    id v8 = qword_1E929DE10;
    if (os_log_type_enabled((os_log_t)qword_1E929DE10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v9 = 0;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEFAULT, "#Warning The streaming connection has been interrupted", v9, 2u);
    }
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_19047D740(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    id v2 = *(id *)(a1 + 40);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 16);

      if (v3)
      {
        if (qword_1E929DE08 != -1) {
          dispatch_once(&qword_1E929DE08, &unk_1EDFD1740);
        }
        uint64_t v4 = qword_1E929DE10;
        if (os_log_type_enabled((os_log_t)qword_1E929DE10, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)uint64_t v6 = 0;
          _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEBUG, "Stopping the streaming session", v6, 2u);
        }
        sub_190451AA8(*(void *)(a1 + 16));
        objc_setProperty_nonatomic_copy((id)a1, v5, 0, 40);
      }
    }
  }
}

void sub_19047D810(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    sub_19047D740(a1);
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    id v2 = *(id *)(a1 + 56);
    uint64_t v4 = objc_msgSend_countByEnumeratingWithState_objects_count_(v2, v3, (uint64_t)&v13, v17, 16);
    if (v4)
    {
      uint64_t v6 = v4;
      int v7 = 0;
      uint64_t v8 = *(void *)v14;
      while (2)
      {
        uint64_t v9 = 0;
        int v10 = v7 + v6;
        do
        {
          if (*(void *)v14 != v8) {
            objc_enumerationMutation(v2);
          }
          uint64_t v11 = *(void *)(*((void *)&v13 + 1) + 8 * v9);
          if (v11 && *(void *)(v11 + 24))
          {

            objc_msgSend_removeObjectAtIndex_(*(void **)(a1 + 56), v12, (v7 + v9), (void)v13);
            return;
          }
          ++v9;
        }
        while (v6 != v9);
        uint64_t v6 = objc_msgSend_countByEnumeratingWithState_objects_count_(v2, v5, (uint64_t)&v13, v17, 16);
        int v7 = v10;
        if (v6) {
          continue;
        }
        break;
      }
    }
  }
}

void sub_19047D938(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v4 = *(NSObject **)(a1 + 64);
    if (v4)
    {
      dispatch_source_cancel(v4);
      SEL v5 = *(void **)(a1 + 64);
      *(void *)(a1 + 64) = 0;
    }
    objc_msgSend_removeAllObjects(*(void **)(a1 + 56), v2, v3);
    objc_setProperty_nonatomic_copy((id)a1, v6, 0, 48);
    sub_19047D810(a1);
    sub_190450D00(*(void *)(a1 + 16));
    int v7 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
  }
}

void sub_19047D9C4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 64), a2);
  }
}

void sub_19047D9D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    id v2 = *(NSObject **)(v1 + 32);
  }
  else {
    id v2 = 0;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_19047DA54;
  block[3] = &unk_1E568D980;
  block[4] = v1;
  dispatch_async(v2, block);
}

void sub_19047DA54(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if (*(void *)(v2 + 16))
    {
      sub_19047D9C4(v2, 0);
      return;
    }
    *(void *)(v2 + 72) *= 2;
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3 && *(void *)(v3 + 72) >= 0x81uLL) {
      *(void *)(v3 + 72) = 128;
    }
  }
  if (qword_1E929DE08 != -1) {
    dispatch_once(&qword_1E929DE08, &unk_1EDFD1740);
  }
  uint64_t v4 = qword_1E929DE10;
  if (os_log_type_enabled((os_log_t)qword_1E929DE10, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      uint64_t v5 = *(void *)(v5 + 72);
    }
    int v11 = 134217984;
    uint64_t v12 = v5;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEBUG, "Connection stil invalid, next reconnection attempt will be in %lu seconds", (uint8_t *)&v11, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6)
  {
    int v7 = *(void **)(v6 + 64);
    int64_t v8 = 1000000000 * *(void *)(v6 + 72);
  }
  else
  {
    int v7 = 0;
    int64_t v8 = 0;
  }
  uint64_t v9 = v7;
  dispatch_time_t v10 = dispatch_time(0, v8);
  dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0);
}

void sub_19047E1F4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    if (qword_1E929DE08 != -1) {
      dispatch_once(&qword_1E929DE08, &unk_1EDFD1740);
    }
    uint64_t v2 = qword_1E929DE10;
    if (os_log_type_enabled((os_log_t)qword_1E929DE10, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v4[0]) = 0;
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEBUG, "Reconnection attempt", (uint8_t *)v4, 2u);
    }
    if (!*(void *)(v1 + 16))
    {
      sub_19047D4E0(v1);
      sub_19047CE5C(v1);
      sub_190452758(*(id **)(v1 + 16));
      uint64_t v3 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      v4[0] = MEMORY[0x1E4F143A8];
      v4[1] = 3221225472;
      _DWORD v4[2] = sub_19047D9D4;
      v4[3] = &unk_1E568D980;
      v4[4] = v1;
      xpc_connection_send_barrier(v3, v4);
    }
  }
}

uint64_t sub_19047E3C0()
{
  qword_1E929DE10 = (uint64_t)os_log_create("com.apple.RelativeMotion", "ConnectionClient");

  return MEMORY[0x1F41817F8]();
}

void *sub_19047E7E8(uint64_t a1)
{
  *(void *)a1 = &unk_1EDFC7E20;
  CFRelease(*(CFTypeRef *)(a1 + 72));
  CFRelease(*(CFTypeRef *)(a1 + 80));
  sub_19045CCC8((void *)(a1 + 120));
  sub_19045CCC8((void *)(a1 + 104));
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  return sub_19045CCC8((void *)a1);
}

void sub_19047E880(uint64_t a1)
{
  sub_19047E7E8(a1);

  JUMPOUT(0x192FCC980);
}

void sub_19047E8B8(char *a1, int a2)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  if (a1[96]) {
    return;
  }
  uint64_t v2 = a1;
  if (a2)
  {
    uint64_t v3 = (void **)(a1 + 24);
    int v4 = a1[47];
    uint64_t v5 = a1 + 24;
    if (v4 < 0) {
      uint64_t v5 = (const char *)*v3;
    }
    if (stat(v5, &v57))
    {
      p_cache = (__CFString *)CMDeviceOrientationManager.cache;
      if (qword_1EB3BE888 == -1) {
        goto LABEL_8;
      }
      goto LABEL_80;
    }
    if (v57.st_uid == *((_DWORD *)v2 + 22) && v57.st_gid == *((_DWORD *)v2 + 23) && (~v57.st_mode & 0x1B6) == 0) {
      return;
    }
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
    }
    uint64_t v12 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = v2 + 24;
      if (v2[47] < 0) {
        uint64_t v13 = (char *)*v3;
      }
      gid_t v14 = *((_DWORD *)v2 + 22);
      int v15 = *((_DWORD *)v2 + 23);
      buf[0].st_dev = 136316674;
      *(void *)&buf[0].int st_mode = v13;
      WORD2(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 6) = v57.st_uid;
      HIWORD(buf[0].st_uid) = 1024;
      buf[0].st_gid = v14;
      LOWORD(buf[0].st_rdev) = 1024;
      *(dev_t *)((char *)&buf[0].st_rdev + 2) = v57.st_gid;
      *((_WORD *)&buf[0].st_rdev + 3) = 1024;
      LODWORD(buf[0].st_atimespec.tv_sec) = v15;
      WORD2(buf[0].st_atimespec.tv_sec) = 1024;
      *(_DWORD *)((char *)&buf[0].st_atimespec.tv_sec + 6) = v57.st_mode;
      WORD1(buf[0].st_atimespec.tv_nsec) = 1024;
      HIDWORD(buf[0].st_atimespec.tv_nsec) = 438;
      _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_DEFAULT, "#Warning %s attributes incorrect (uid %d vs %d, gid %d vs %d, mode 0x%x vs 0x%x, resetting", (uint8_t *)buf, 0x30u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
      }
      if (v2[47] < 0) {
        uint64_t v3 = (void **)*v3;
      }
      int v49 = *((_DWORD *)v2 + 22);
      int v50 = *((_DWORD *)v2 + 23);
      int v58 = 136316674;
      uint64_t v59 = v3;
      __int16 v60 = 1024;
      uid_t st_uid = v57.st_uid;
      __int16 v62 = 1024;
      *(_DWORD *)uint64_t v63 = v49;
      *(_WORD *)&v63[4] = 1024;
      *(_DWORD *)&v63[6] = v57.st_gid;
      __int16 v64 = 1024;
      int v65 = v50;
      __int16 v66 = 1024;
      int st_mode = v57.st_mode;
      __int16 v68 = 1024;
      int v69 = 438;
      int8x16_t v51 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLPreferences::setFileAttributes(BOOL)", "CoreLocation: %s\n", v51);
      if (v51 != (char *)buf) {
        free(v51);
      }
    }
  }
  long long v16 = (const char **)(v2 + 24);
  id v17 = v2 + 24;
  if (v2[47] < 0) {
    id v17 = *v16;
  }
  uint64_t v18 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v17, 0x8000100u);
  if (v18)
  {
    id v21 = v18;
    id v22 = objc_msgSend_pathComponents(v18, v19, v20);
    unint64_t v27 = objc_msgSend_count(v22, v23, v24) - 1;
    if (v27 >= 2)
    {
      PathComponent = v21;
      p_cache = @"/tmp";
      while (1)
      {
        PathComponent = objc_msgSend_stringByDeletingLastPathComponent(PathComponent, v25, v26);
        if ((objc_msgSend_isEqualToString_(PathComponent, v29, @"/var") & 1) == 0
          && (objc_msgSend_isEqualToString_(PathComponent, v25, @"/tmp") & 1) == 0)
        {
          uint64_t v30 = (const char *)objc_msgSend_fileSystemRepresentation(PathComponent, v25, v26);
          if (!lstat(v30, buf) && (buf[0].st_mode & 0xF000) == 0xA000) {
            break;
          }
        }
        if (--v27 <= 1) {
          goto LABEL_38;
        }
      }
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
      }
      uint64_t v3 = CMDeviceOrientationManager.cache;
      uint64_t v47 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        buf[0].st_dev = 68289539;
        *(_DWORD *)&buf[0].int st_mode = 0;
        LOWORD(buf[0].st_ino) = 2082;
        *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 2) = (__darwin_ino64_t)"";
        HIWORD(buf[0].st_uid) = 2082;
        *(void *)&buf[0].st_gid = "assert";
        *((_WORD *)&buf[0].st_rdev + 2) = 2081;
        *(void *)((char *)&buf[0].st_rdev + 6) = "!_parentDirContainsSymLink(cfSettingsFile)";
        _os_log_impl(&dword_1902AF000, v47, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)buf, 0x26u);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
        }
      }
      unint64_t v48 = off_1EB3BE880;
      if (os_signpost_enabled((os_log_t)off_1EB3BE880))
      {
        buf[0].st_dev = 68289539;
        *(_DWORD *)&buf[0].int st_mode = 0;
        LOWORD(buf[0].st_ino) = 2082;
        *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 2) = (__darwin_ino64_t)"";
        HIWORD(buf[0].st_uid) = 2082;
        *(void *)&buf[0].st_gid = "assert";
        *((_WORD *)&buf[0].st_rdev + 2) = 2081;
        *(void *)((char *)&buf[0].st_rdev + 6) = "!_parentDirContainsSymLink(cfSettingsFile)";
        _os_signpost_emit_with_name_impl(&dword_1902AF000, v48, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)buf, 0x26u);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
        }
      }
      uint64_t v2 = (char *)off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_INFO))
      {
        buf[0].st_dev = 68289539;
        *(_DWORD *)&buf[0].int st_mode = 0;
        LOWORD(buf[0].st_ino) = 2082;
        *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 2) = (__darwin_ino64_t)"";
        HIWORD(buf[0].st_uid) = 2082;
        *(void *)&buf[0].st_gid = "assert";
        *((_WORD *)&buf[0].st_rdev + 2) = 2081;
        *(void *)((char *)&buf[0].st_rdev + 6) = "!_parentDirContainsSymLink(cfSettingsFile)";
        _os_log_impl(&dword_1902AF000, (os_log_t)v2, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)buf, 0x26u);
      }
      abort_report_np();
LABEL_80:
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
LABEL_8:
      int v7 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEFAULT))
      {
        int64_t v8 = v3;
        if (v2[47] < 0) {
          int64_t v8 = *v3;
        }
        int v9 = *__error();
        buf[0].st_dev = 136315394;
        *(void *)&buf[0].int st_mode = v8;
        WORD2(buf[0].st_ino) = 1024;
        *(_DWORD *)((char *)&buf[0].st_ino + 6) = v9;
        _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_DEFAULT, "#Warning could not check %s (errno %d)", (uint8_t *)buf, 0x12u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (p_cache[68].info != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
        }
        if (v2[47] < 0) {
          uint64_t v3 = (void **)*v3;
        }
        int v10 = *__error();
        int v58 = 136315394;
        uint64_t v59 = v3;
        __int16 v60 = 1024;
        uid_t st_uid = v10;
        int v11 = (stat *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CLPreferences::setFileAttributes(BOOL)", "CoreLocation: %s\n");
LABEL_67:
        if (v11 != buf) {
          free(v11);
        }
        return;
      }
      return;
    }
LABEL_38:
    CFRelease(v21);
  }
  __int16 v31 = v2 + 24;
  if (v2[47] < 0) {
    __int16 v31 = *v16;
  }
  if (!lstat(v31, &v57))
  {
    uint64_t v32 = v2 + 24;
    if (v2[47] < 0) {
      uint64_t v32 = *v16;
    }
    if (lchmod(v32, 0x1B6u))
    {
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
      }
      uint64_t v33 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        uint64_t v34 = v2 + 24;
        if (v2[47] < 0) {
          uint64_t v34 = *v16;
        }
        int v35 = *__error();
        float v36 = __error();
        uint64_t v37 = strerror(*v36);
        buf[0].st_dev = 136446722;
        *(void *)&buf[0].int st_mode = v34;
        WORD2(buf[0].st_ino) = 1026;
        *(_DWORD *)((char *)&buf[0].st_ino + 6) = v35;
        HIWORD(buf[0].st_uid) = 2082;
        *(void *)&buf[0].st_gid = v37;
        _os_log_impl(&dword_1902AF000, v33, OS_LOG_TYPE_FAULT, "could not lchmod %{public}s errno %{public}d (%{public}s)", (uint8_t *)buf, 0x1Cu);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
        }
        unint64_t v52 = v2 + 24;
        if (v2[47] < 0) {
          unint64_t v52 = *v16;
        }
        int v53 = *__error();
        __int16 v54 = __error();
        uint64_t v55 = strerror(*v54);
        int v58 = 136446722;
        uint64_t v59 = (void *)v52;
        __int16 v60 = 1026;
        uid_t st_uid = v53;
        __int16 v62 = 2082;
        *(void *)uint64_t v63 = v55;
        unint64_t v56 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "void CLPreferences::setFileAttributes(BOOL)", "CoreLocation: %s\n", v56);
        if (v56 != (char *)buf) {
          free(v56);
        }
      }
    }
    uint64_t v38 = v2 + 24;
    if (v2[47] < 0) {
      uint64_t v38 = *v16;
    }
    if (lchown(v38, *((_DWORD *)v2 + 22), *((_DWORD *)v2 + 23)))
    {
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
      }
      uint64_t v39 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        uint64_t v40 = v2 + 24;
        if (v2[47] < 0) {
          uint64_t v40 = *v16;
        }
        int v41 = *__error();
        uint64_t v42 = __error();
        unint64_t v43 = strerror(*v42);
        buf[0].st_dev = 136446722;
        *(void *)&buf[0].int st_mode = v40;
        WORD2(buf[0].st_ino) = 1026;
        *(_DWORD *)((char *)&buf[0].st_ino + 6) = v41;
        HIWORD(buf[0].st_uid) = 2082;
        *(void *)&buf[0].st_gid = v43;
        _os_log_impl(&dword_1902AF000, v39, OS_LOG_TYPE_FAULT, "could not lchown %{public}s errno %{public}d (%{public}s)", (uint8_t *)buf, 0x1Cu);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
        }
        if (v2[47] < 0) {
          long long v16 = (const char **)*v16;
        }
        int v44 = *__error();
        uint64_t v45 = __error();
        float32x2_t v46 = strerror(*v45);
        int v58 = 136446722;
        uint64_t v59 = v16;
        __int16 v60 = 1026;
        uid_t st_uid = v44;
        __int16 v62 = 2082;
        *(void *)uint64_t v63 = v46;
        int v11 = (stat *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "void CLPreferences::setFileAttributes(BOOL)", "CoreLocation: %s\n");
        goto LABEL_67;
      }
    }
  }
}

uint64_t sub_19047F3B4(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

CFArrayRef sub_19047F3BC(CFStringRef *a1)
{
  CFStringRef v2 = (const __CFString *)*MEMORY[0x1E4F1D3E0];
  CFArrayRef result = CFPreferencesCopyKeyList(a1[9], a1[10], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
  if (result)
  {
    CFArrayRef v4 = result;
    CFPreferencesSetMultiple(0, result, a1[9], a1[10], v2);
    CFRelease(v4);
    data = (*a1)[26].data;
    return (const __CFArray *)((uint64_t (*)(CFStringRef *))data)(a1);
  }
  return result;
}

uint64_t sub_19047F47C(CFStringRef *a1, CFStringRef key)
{
  CFPreferencesSetValue(key, 0, a1[9], a1[10], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
  data = (*a1)[26].data;

  return ((uint64_t (*)(CFStringRef *))data)(a1);
}

CFIndex sub_19047F500(uint64_t a1)
{
  CFArrayRef v1 = CFPreferencesCopyKeyList(*(CFStringRef *)(a1 + 72), *(CFStringRef *)(a1 + 80), (CFStringRef)*MEMORY[0x1E4F1D3E0]);
  if (!v1) {
    return 0;
  }
  CFArrayRef v2 = v1;
  CFIndex Count = CFArrayGetCount(v1);
  CFRelease(v2);
  return Count;
}

CFIndex sub_19047F558(uint64_t a1, CFStringRef key)
{
  CFArrayRef v2 = (const __CFArray *)CFPreferencesCopyValue(key, *(CFStringRef *)(a1 + 72), *(CFStringRef *)(a1 + 80), (CFStringRef)*MEMORY[0x1E4F1D3E0]);
  if (!v2) {
    return 0;
  }
  CFArrayRef v3 = v2;
  CFTypeID v4 = CFGetTypeID(v2);
  if (v4 == CFArrayGetTypeID()) {
    CFIndex Count = CFArrayGetCount(v3);
  }
  else {
    CFIndex Count = 1;
  }
  CFRelease(v3);
  return Count;
}

uint64_t sub_19047F5D4()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
  }
  uint64_t v0 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "***not supported***", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
    }
    CFArrayRef v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLPreferences::serialize(CFDataRef *) const", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
  return 0;
}

uint64_t sub_19047F760()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
  }
  uint64_t v0 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "***not supported***", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
    }
    CFArrayRef v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLPreferences::serializeBinary(CFDataRef *) const", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
  return 0;
}

uint64_t sub_19047F8EC()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
  }
  uint64_t v0 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "***not supported***", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
    }
    CFArrayRef v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLPreferences::deserialize(const CFDataRef)", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
  return 0;
}

void sub_19047FA78(const __CFString *a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  if ((*(unsigned int (**)(uint64_t, const __CFString *, CFTypeRef *))(*(void *)a2 + 912))(a2, a1, &cf))
  {
    sub_190466860(a1, (const __CFString *)cf);
    CFRelease(cf);
  }
}

void sub_19047FAF8(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (qword_1E929DA88 != -1) {
    dispatch_once(&qword_1E929DA88, &unk_1EDFD2F60);
  }
  if (os_log_type_enabled((os_log_t)qword_1E929DA90, OS_LOG_TYPE_DEBUG))
  {
    if ((*(int (**)(uint64_t))(*(void *)(a1 + 120) + 856))(a1 + 120) >= 1) {
      sub_1904661EC(a1 + 120);
    }
    CFArrayRef v2 = CFPreferencesCopyKeyList(*(CFStringRef *)(a1 + 72), *(CFStringRef *)(a1 + 80), (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    CFArrayRef v3 = v2;
    if (v2 && CFArrayGetCount(v2))
    {
      v11.length = CFArrayGetCount(v3);
      v11.locatiounint64_t n = 0;
      CFArrayApplyFunction(v3, v11, (CFArrayApplierFunction)sub_19047FA78, (void *)a1);
      CFRelease(v3);
      uint64_t v5 = *(void *)(a1 + 104);
      uint64_t v4 = a1 + 104;
      if ((*(int (**)(uint64_t))(v5 + 856))(v4) >= 1)
      {
        sub_1904661EC(v4);
      }
    }
    else
    {
      if (qword_1E929DA88 != -1) {
        dispatch_once(&qword_1E929DA88, &unk_1EDFD2F60);
      }
      uint64_t v6 = qword_1E929DA90;
      if (os_log_type_enabled((os_log_t)qword_1E929DA90, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEBUG, "\t<empty>", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929DA88 != -1) {
          dispatch_once(&qword_1E929DA88, &unk_1EDFD2F60);
        }
        int v7 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual void CLPreferences::print() const", "CoreLocation: %s\n", v7);
        if (v7 != (char *)buf) {
          free(v7);
        }
      }
      if (v3) {
        CFRelease(v3);
      }
    }
  }
}

void sub_19047FDF4()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
  }
  uint64_t v0 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "***not supported***", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
    }
    CFArrayRef v1 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual void CLPreferences::merge(const CLPreferences &, BOOL)", "CoreLocation: %s\n", v1);
    if (v1 != (char *)buf) {
      free(v1);
    }
  }
}

uint64_t sub_19047FF7C()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
  }
  uint64_t v0 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "***not supported***", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
    }
    CFArrayRef v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLPreferences::loadFromFile(const char *)", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
  return 0;
}

uint64_t sub_190480108()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
  }
  uint64_t v0 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "***not supported***", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
    }
    CFArrayRef v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLPreferences::saveToFile(const char *) const", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
  return 0;
}

uint64_t sub_190480294()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE888 != -1) {
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
  }
  uint64_t v0 = off_1EB3BE880;
  if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "***not supported***", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
    }
    CFArrayRef v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLPreferences::saveToBinaryFile(const char *) const", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
  return 0;
}

void sub_190480420(uint64_t a1, CFStringRef key, CFPropertyListRef value)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 96))
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
    }
    uint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      uint64_t v6 = v24;
      sub_1902C36AC(key, (uint64_t)v24);
      if (v27 < 0) {
        uint64_t v6 = *(unsigned char **)v24;
      }
      sub_1902C36AC(*(const __CFString **)(a1 + 72), (uint64_t)v22);
      int v7 = v23;
      int64_t v8 = (void **)v22[0];
      sub_1902C36AC(*(const __CFString **)(a1 + 80), (uint64_t)__p);
      uint64_t v9 = v22;
      if (v7 < 0) {
        uint64_t v9 = v8;
      }
      if (v21 >= 0) {
        int v10 = __p;
      }
      else {
        int v10 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v30 = v6;
      __int16 v31 = 2082;
      uint64_t v32 = v9;
      __int16 v33 = 2082;
      uint64_t v34 = v10;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Attempt to set key %{public}s for read-only preferences %{public}s/%{public}s!", buf, 0x20u);
      if (v21 < 0) {
        operator delete(__p[0]);
      }
      if (v23 < 0) {
        operator delete(v22[0]);
      }
      if (SHIBYTE(v27) < 0) {
        operator delete(*(void **)v24);
      }
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
      }
      sub_1902C36AC(key, (uint64_t)v22);
      if (v23 >= 0) {
        uint64_t v12 = v22;
      }
      else {
        uint64_t v12 = (void **)v22[0];
      }
      sub_1902C36AC(*(const __CFString **)(a1 + 72), (uint64_t)__p);
      int v13 = v21;
      gid_t v14 = (void **)__p[0];
      sub_1902C36AC(*(const __CFString **)(a1 + 80), (uint64_t)v18);
      int v15 = __p;
      if (v13 < 0) {
        int v15 = v14;
      }
      if (v19 >= 0) {
        long long v16 = v18;
      }
      else {
        long long v16 = (void **)v18[0];
      }
      *(_DWORD *)uint64_t v24 = 136446722;
      *(void *)&v24[4] = v12;
      __int16 v25 = 2082;
      uint64_t v26 = v15;
      __int16 v27 = 2082;
      long long v28 = v16;
      id v17 = (char *)_os_log_send_and_compose_impl();
      if (v19 < 0) {
        operator delete(v18[0]);
      }
      if (v21 < 0) {
        operator delete(__p[0]);
      }
      if (v23 < 0) {
        operator delete(v22[0]);
      }
      sub_1902D398C("Generic", 1, 0, 0, "virtual void CLPreferences::setInternal(const CFStringRef, const CFTypeRef)", "CoreLocation: %s\n", v17);
      if (v17 != (char *)buf) {
        free(v17);
      }
    }
  }
  else
  {
    CFPreferencesSetValue(key, value, *(CFStringRef *)(a1 + 72), *(CFStringRef *)(a1 + 80), (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    CFRange v11 = *(void (**)(uint64_t))(*(void *)a1 + 848);
    v11(a1);
  }
}

void sub_1904807D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

void sub_190480840()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE888 != -1) {
    goto LABEL_11;
  }
  while (1)
  {
    uint64_t v0 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      int v4 = 0;
      __int16 v5 = 2082;
      uint64_t v6 = "";
      __int16 v7 = 2082;
      int64_t v8 = "assert";
      __int16 v9 = 2081;
      int v10 = "0";
      _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
      }
    }
    CFArrayRef v1 = off_1EB3BE880;
    if (os_signpost_enabled((os_log_t)off_1EB3BE880))
    {
      *(_DWORD *)buf = 68289539;
      int v4 = 0;
      __int16 v5 = 2082;
      uint64_t v6 = "";
      __int16 v7 = 2082;
      int64_t v8 = "assert";
      __int16 v9 = 2081;
      int v10 = "0";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v1, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
      }
    }
    CFArrayRef v2 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      int v4 = 0;
      __int16 v5 = 2082;
      uint64_t v6 = "";
      __int16 v7 = 2082;
      int64_t v8 = "assert";
      __int16 v9 = 2081;
      int v10 = "0";
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
LABEL_11:
    dispatch_once(&qword_1EB3BE888, &unk_1EDFD1760);
  }
}

__CFString *sub_190480A64()
{
  return @"OtherPref";
}

void sub_190480A70(void *a1)
{
  sub_19045CCC8(a1);

  JUMPOUT(0x192FCC980);
}

os_log_t sub_190480AA8()
{
  os_log_t result = os_log_create("com.apple.locationd.Legacy", "Direct_deprecated");
  qword_1E929DA90 = (uint64_t)result;
  return result;
}

uint64_t sub_190480AD8(uint64_t result, int a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFArrayRef v2 = (unsigned char *)(result + 6336);
  if (*(unsigned __int8 *)(result + 6336) != a2)
  {
    uint64_t v4 = result;
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
    }
    __int16 v5 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
    {
      int v6 = *v2;
      *(_DWORD *)buf = 67109376;
      int v9 = v6;
      __int16 v10 = 1024;
      int v11 = a2;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_INFO, "[CMCorrelatedMotion] Changed tracking behavior from %d to %d.", buf, 0xEu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
      }
      __int16 v7 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMCorrelatedMotion::setTrackingBehavior(CMRelDM::TrackingBehavior)", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    unsigned char *v2 = a2;
    return sub_190480CD4(v4, 0);
  }
  return result;
}

uint64_t sub_190480CD4(uint64_t result, int a2)
{
  *(_DWORD *)os_log_t result = 0;
  *(_DWORD *)(result + 1208) = 0;
  *(_DWORD *)(result + 3288) = 0;
  *(_DWORD *)(result + 2444) = 0;
  *(void *)(result + 2436) = 0;
  *(void *)(result + 2428) = 0;
  *(_OWORD *)(result + 3776) = 0u;
  *(_OWORD *)(result + 3792) = 0u;
  *(void *)(result + 3808) = 0;
  *(void *)(result + 6288) = 0;
  *(void *)(result + 6304) = 0;
  *(void *)(result + 6296) = 0;
  *(unsigned char *)(result + 2416) = 1;
  *(void *)(result + 2872) = 0;
  *(void *)(result + 2864) = 0;
  *(_DWORD *)(result + 2880) = 0;
  *(unsigned char *)(result + 2852) = 1;
  *(_WORD *)(result + 6320) = 0;
  if (a2)
  {
    *(void *)(result + 6312) = 0;
    *(_DWORD *)(result + 3816) = 0;
    *(_OWORD *)(result + 6224) = 0uLL;
  }
  if (*(unsigned char *)(result + 6336) == 1)
  {
    *(void *)(result + 8808) = 0;
    *(void *)(result + 8800) = 0;
    *(_DWORD *)(result + 8816) = 0;
    *(unsigned char *)(result + 8788) = 1;
    *(_DWORD *)(result + 9012) = 0;
    *(void *)(result + 9004) = 0;
    *(void *)(result + 8996) = 0;
    *(unsigned char *)(result + 8984) = 1;
    *(void *)(result + 10048) = 0;
    if (a2)
    {
      *(_DWORD *)(result + 10032) = 0;
      *(void *)(result + 9200) = 0;
      *(void *)(result + 9192) = 0;
      *(_DWORD *)(result + 9208) = 0;
      *(unsigned char *)(result + 9180) = 1;
    }
  }
  return result;
}

void sub_190480DAC(float32x2_t *a1, float32x2_t *a2, uint64_t a3, float *a4, int *a5, unint64_t a6, unint64_t a7, double a8)
{
  unint64_t v9 = a6;
  uint64_t v315 = *MEMORY[0x1E4F143B8];
  int v15 = (float32x2_t *)((char *)a1 + 3780);
  unsigned int v16 = a1->u16[1];
  if (v16 == a1[151].u16[1])
  {
    if (v16 >= a1[411].u16[1]) {
      unsigned int v16 = a1[411].u16[1];
    }
    if (v16 >= 0x28)
    {
      uint64_t v17 = 0;
      float v18 = 0.0;
      do
      {
        float v18 = v18 + (float)(*(float *)(a3 + v17) * *(float *)(a3 + v17));
        v17 += 4;
      }
      while (v17 != 12);
      float v19 = sqrtf(v18);
      if (v19 > 0.17453 || (int v20 = *(_DWORD *)(a3 + 48)) == 0 || (v19 > 0.087266 ? (_ZF = v20 == 2) : (_ZF = 0), _ZF))
      {
        float32_t v22 = a1[789].f32[0] + a8;
        a1[789].f32[0] = v22;
      }
      else if (v20 == 1 && a1[780].f32[1] < 0.043633)
      {
        a1[789].i32[0] = 0;
      }
      float v23 = a1[780].f32[0];
      if (v23 > 0.1309 || a2[6].i32[0] == 0)
      {
        if (v23 > 0.2618) {
          a1[789].i32[1] = 0;
        }
      }
      else
      {
        float32_t v25 = a1[789].f32[1] + a8;
        a1[789].f32[1] = v25;
      }
      uint64_t v26 = (float32x2_t *)((char *)a1 + 3780);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
      }
      long long v28 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
      {
        double v29 = a1[780].f32[1];
        double v30 = a1[780].f32[0];
        int v31 = *(_DWORD *)(a3 + 48);
        __int32 v32 = a2[6].i32[0];
        double v33 = a1[789].f32[0];
        double v34 = a1[789].f32[1];
        *(_DWORD *)buf = 134219264;
        *(double *)&uint8_t buf[4] = v29;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(double *)&buf[14] = v30;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = v31;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v32;
        *(_WORD *)&buf[34] = 2048;
        *(double *)&buf[36] = v33;
        __int16 v311 = 2048;
        double v312 = v34;
        _os_log_impl(&dword_1902AF000, v28, OS_LOG_TYPE_DEBUG, "[CorrelatedMotion] updateSrcAuxMovingDuration: fAuxAvgOmegaShort, %.3f, fSrcAvgOmegaShort, %.3f, aux.qMode, %d, src.qMode, %d, auxMovingDurationSecs, %.3f, srcStaticDurationSecs, %.3f", buf, 0x36u);
      }
      unint64_t v9 = a6;
      int v15 = v26;
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        unint64_t v297 = v9;
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
        }
        double v247 = a1[780].f32[1];
        double v248 = a1[780].f32[0];
        int v249 = *(_DWORD *)(a3 + 48);
        __int32 v250 = a2[6].i32[0];
        double v251 = a1[789].f32[0];
        double v252 = a1[789].f32[1];
        float v304 = 3.8526e-34;
        *(double *)int v305 = v247;
        *(_WORD *)&v305[8] = 2048;
        *(double *)&v305[10] = v248;
        *(_WORD *)&v305[18] = 1024;
        *(_DWORD *)&v305[20] = v249;
        *(_WORD *)&v305[24] = 1024;
        *(_DWORD *)&v305[26] = v250;
        *(_WORD *)&v305[30] = 2048;
        *(double *)&v305[32] = v251;
        __int16 v306 = 2048;
        double v307 = v252;
        double v253 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CMCorrelatedMotion::updateSrcAuxMovingDuration(const IMUData &, const IMUData &, double)", "CoreLocation: %s\n", v253);
        if (v253 != buf) {
          free(v253);
        }
        unint64_t v9 = v297;
      }
    }
  }
  a1[791] = (float32x2_t)v9;
  v35.f32[0] = sub_1904CF73C(a4, *(float *)a3, *(float *)(a3 + 4), *(float *)(a3 + 8));
  float v37 = a2[1].f32[0] - v36;
  v35.i32[1] = v38;
  v15[3] = vadd_f32(vsub_f32(*a2, v35), v15[3]);
  a1[476].f32[1] = v37 + a1[476].f32[1];
  float v39 = a2->f32[0] + a1[472].f32[1];
  a1[472].f32[1] = v39;
  float v40 = a2->f32[1] + a1[473].f32[0];
  a1[473].f32[0] = v40;
  float v41 = a2[1].f32[0] + a1[473].f32[1];
  a1[473].f32[1] = v41;
  a1[474].f32[0] = *(float *)a3 + a1[474].f32[0];
  a1[474].f32[1] = *(float *)(a3 + 4) + a1[474].f32[1];
  a1[475].f32[0] = *(float *)(a3 + 8) + a1[475].f32[0];
  int v42 = a1[472].i32[0] + 1;
  a1[472].i32[0] = v42;
  if (v42 == 4)
  {
    unint64_t v296 = v9;
    double v299 = a5;
    uint64_t v43 = (uint64_t)&a1[1147] + 4;
    *(float *)buf = v39 * 0.25;
    *(float *)&uint8_t buf[4] = v40 * 0.25;
    *(float *)&uint8_t buf[8] = v41 * 0.25;
    sub_19042FFA8((unsigned __int16 *)a1, (uint64_t)buf);
    float v44 = a1[475].f32[0] * 0.25;
    __asm { FMOV            V9.2S, #0.25 }
    *(float32x2_t *)buf = vmul_f32(a1[474], _D9);
    *(float *)&uint8_t buf[8] = v44;
    sub_19042FFA8((unsigned __int16 *)&a1[151], (uint64_t)buf);
    float v49 = a1[475].f32[0] * 0.25;
    *(float32x2_t *)buf = vmul_f32(a1[474], _D9);
    *(float *)&uint8_t buf[8] = v49;
    sub_19042FFA8((unsigned __int16 *)&a1[477], (uint64_t)buf);
    float v50 = a1[473].f32[1] * 0.25;
    *(float32x2_t *)buf = vmul_f32(*v15, _D9);
    *(float *)&uint8_t buf[8] = v50;
    sub_19042FFA8((unsigned __int16 *)&a1[797] + 2, (uint64_t)buf);
    float v51 = a1[476].f32[1] * 0.25;
    *(float32x2_t *)buf = vmul_f32(v15[3], _D9);
    *(float *)&uint8_t buf[8] = v51;
    sub_19042FFA8((unsigned __int16 *)&a1[411], (uint64_t)buf);
    a1[476] = 0;
    *(_OWORD *)a1[472].f32 = 0u;
    *(_OWORD *)a1[474].f32 = 0u;
    a1[786].f32[0] = sub_1904CF514((float *)&a2[7]);
    a1[786].i32[1] = v52;
    a1[787].i32[0] = v53;
    a1[787].f32[1] = sub_1904CF514((float *)(a3 + 56));
    a1[788].i32[0] = v54;
    a1[788].i32[1] = v55;
    float v56 = sub_19042DEC0((unsigned __int16 *)a1);
    *(float *)buf = (float)((float)(v57 * a1[787].f32[0]) + (float)(v58 * a1[786].f32[1]))
                  + (float)(v56 * a1[786].f32[0]);
    double v295 = a1 + 302;
    sub_19042D76C((uint64_t)&a1[302], (float *)buf);
    __int16 v294 = (unsigned __int16 *)&a1[151];
    float v59 = sub_19042DEC0((unsigned __int16 *)&a1[151]);
    *(float *)buf = (float)((float)(v60 * a1[788].f32[1]) + (float)(v61 * a1[788].f32[0]))
                  + (float)(v59 * a1[787].f32[1]);
    __int16 v298 = (char *)&a1[356] + 4;
    sub_19042D76C((uint64_t)&a1[356] + 4, (float *)buf);
    if (v15[319].i8[4] == 1)
    {
      float v62 = sub_19042DEC0((unsigned __int16 *)a1);
      *(float *)buf = (float)((float)(v63 * a1[787].f32[0]) + (float)(v64 * a1[786].f32[1]))
                    + (float)(v62 * a1[786].f32[0]);
      sub_19042D76C((uint64_t)&a1[1147] + 4, (float *)buf);
      float v65 = a1[784].f32[0];
      if (v65 <= 0.0) {
        float v65 = -v65;
      }
      float v66 = a1[783].f32[1];
      if (v66 <= 0.0) {
        float v66 = -v66;
      }
      *(float *)buf = v65 - v66;
      sub_19042D76C((uint64_t)&a1[1098] + 4, (float *)buf);
      sub_19042D76C((uint64_t)&a1[1123], (float *)&a1[783] + 1);
    }
    unint64_t v300 = a7;
    unint64_t v67 = a1->u16[1];
    int v68 = a1[151].u16[1];
    if (v67 == v68)
    {
      unint64_t v69 = a1[411].u16[1];
      if (v67 >= v69) {
        unsigned int v70 = a1[411].u16[1];
      }
      else {
        unsigned int v70 = a1->u16[1];
      }
      if (v70 < 0x28) {
        goto LABEL_100;
      }
      __int16 v292 = (char *)&a1[1098] + 4;
      float v304 = sub_1904308EC((unsigned __int16 *)a1, v67 - 40, v67);
      *(_DWORD *)int v305 = v71;
      *(_DWORD *)&v305[4] = v72;
      v303[0] = sub_1904308EC(v294, v67 - 40, v67);
      v303[1] = v73;
      v303[2] = v74;
      int v75 = v67 - 10;
      v302[0] = sub_1904308EC((unsigned __int16 *)a1, v67 - 10, v67);
      v302[1] = v76;
      v302[2] = v77;
      float v78 = sub_1904308EC(v294, v67 - 10, v67);
      uint64_t v79 = 0;
      *(float *)double v301 = v78;
      v301[1] = v80;
      v301[2] = v81;
      float v82 = 0.0;
      do
      {
        float v82 = v82 + (float)(*(float *)&v302[v79] * *(float *)&v302[v79]);
        ++v79;
      }
      while (v79 != 3);
      uint64_t v83 = 0;
      a1[780].f32[0] = sqrtf(v82);
      float v84 = 0.0;
      do
      {
        float v84 = v84 + (float)(*(float *)&v301[v83] * *(float *)&v301[v83]);
        ++v83;
      }
      while (v83 != 3);
      uint64_t v85 = 0;
      a1[780].f32[1] = sqrtf(v84);
      float v86 = 0.0;
      do
      {
        float v86 = v86 + (float)(*(float *)&v305[v85 - 4] * *(float *)&v305[v85 - 4]);
        v85 += 4;
      }
      while (v85 != 12);
      uint64_t v87 = 0;
      a1[781].f32[0] = sqrtf(v86);
      float v88 = 0.0;
      do
      {
        float v88 = v88 + (float)(*(float *)&v303[v87] * *(float *)&v303[v87]);
        ++v87;
      }
      while (v87 != 3);
      a1[781].f32[1] = sqrtf(v88);
      sub_190484254((unsigned __int16 *)&a1[411], v69 - 10, v69);
      uint64_t v89 = 0;
      *(_DWORD *)buf = v90;
      *(_DWORD *)&uint8_t buf[4] = v91;
      *(_DWORD *)&uint8_t buf[8] = v92;
      float v93 = 0.0;
      do
      {
        float v93 = v93 + (float)(*(float *)&buf[v89] * *(float *)&buf[v89]);
        v89 += 4;
      }
      while (v89 != 12);
      a1[782].f32[0] = sqrtf(v93);
      sub_190484254((unsigned __int16 *)&a1[411], v69 - 40, v69);
      uint64_t v94 = 0;
      *(_DWORD *)buf = v95;
      *(_DWORD *)&uint8_t buf[4] = v96;
      *(_DWORD *)&uint8_t buf[8] = v97;
      float v98 = 0.0;
      do
      {
        float v98 = v98 + (float)(*(float *)&buf[v94] * *(float *)&buf[v94]);
        v94 += 4;
      }
      while (v94 != 12);
      a1[782].f32[1] = sqrtf(v98);
      float v99 = sub_1904308EC((unsigned __int16 *)&a1[411], v69 - 40, v69);
      uint64_t v100 = 0;
      *(float *)buf = v99;
      *(_DWORD *)&uint8_t buf[4] = v101;
      *(_DWORD *)&uint8_t buf[8] = v102;
      float v103 = 0.0;
      do
      {
        float v103 = v103 + (float)(*(float *)&buf[v100] * *(float *)&buf[v100]);
        v100 += 4;
      }
      while (v100 != 12);
      a1[783].f32[0] = sqrtf(v103);
      a1[783].f32[1] = sub_19042FE34((uint64_t)v295, v67 - 40, 40);
      a1[784].f32[0] = sub_19042FE34((uint64_t)v298, v67 - 40, 40);
      a1[784].f32[1] = sub_19042FE34((uint64_t)v295, v75, 10);
      a1[785].f32[0] = sub_19042FE34((uint64_t)v298, v75, 10);
      unint64_t v104 = a1[477].u16[1];
      if (a1[477].i32[1] == v104)
      {
        sub_190484254((unsigned __int16 *)&a1[477], 0, (unint64_t)(float)((float)v104 * 0.9));
        *(_DWORD *)&uint8_t buf[4] = v106;
        *(_DWORD *)&uint8_t buf[8] = v107;
        if (v105 <= 0.0) {
          float v105 = -v105;
        }
        uint64_t v108 = 4;
        uint64_t v43 = (uint64_t)&a1[1147] + 4;
        do
        {
          float v109 = *(float *)&buf[v108];
          if (v109 <= 0.0) {
            float v109 = -v109;
          }
          if (v109 > v105) {
            float v105 = v109;
          }
          v108 += 4;
        }
        while (v108 != 12);
      }
      else
      {
        sub_190484254((unsigned __int16 *)&a1[477], 0, v104);
        *(_DWORD *)&uint8_t buf[4] = v110;
        *(_DWORD *)&uint8_t buf[8] = v111;
        if (v105 <= 0.0) {
          float v105 = -v105;
        }
        uint64_t v112 = 4;
        uint64_t v43 = (uint64_t)&a1[1147] + 4;
        do
        {
          float v113 = *(float *)&buf[v112];
          if (v113 <= 0.0) {
            float v113 = -v113;
          }
          if (v113 > v105) {
            float v105 = v113;
          }
          v112 += 4;
        }
        while (v112 != 12);
      }
      a1[785].f32[1] = sqrtf(v105);
      if (v15[319].i8[4] == 1)
      {
        if (v295->i8[0]) {
          sub_190430068((uint64_t)v295);
        }
        a1[1252].i32[0] = a1[302].i32[1];
        if (a1[356].i8[4]) {
          sub_190430068((uint64_t)v298);
        }
        a1[1252].i32[1] = a1[357].i32[0];
        if (*v292) {
          sub_190430068((uint64_t)v292);
        }
        a1[1254].i32[1] = a1[1099].i32[0];
        if (a1[1123].i8[0]) {
          sub_190430068((uint64_t)&a1[1123]);
        }
        a1[1255].i32[0] = a1[1123].i32[1];
        sub_190484254((unsigned __int16 *)&a1[797] + 2, 0, a1[797].u16[3]);
        *(_DWORD *)&uint8_t buf[4] = v115;
        *(_DWORD *)&uint8_t buf[8] = v116;
        if (v114 <= 0.0) {
          float v114 = -v114;
        }
        for (uint64_t i = 4; i != 12; i += 4)
        {
          float v118 = *(float *)&buf[i];
          if (v118 <= 0.0) {
            float v118 = -v118;
          }
          if (v118 > v114) {
            float v114 = v118;
          }
        }
        a1[1253].f32[0] = sqrtf(v114);
        unsigned int v119 = a1[305].u16[3];
        float v120 = 0.0;
        float v121 = 0.0;
        int v122 = v119 - 40;
        if (v119 >= 0x28)
        {
          float v123 = sub_19042FE34((uint64_t)v295, v119 - 40, 40);
          float v121 = sqrtf(sub_190484A00((uint64_t)v295, v122, 40, v123));
        }
        a1[1253].f32[1] = v121;
        if (a1[1151].i32[1] == *(unsigned __int16 *)(v43 + 30))
        {
          if (*(unsigned char *)v43) {
            sub_190430068(v43);
          }
          float v120 = a1[1148].f32[0] * 4.0;
        }
        a1[1254].f32[0] = v120;
      }
      LODWORD(v67) = a1->u16[1];
      int v68 = a1[151].u16[1];
    }
    _ZF = v67 == v68;
    LODWORD(v67) = v68;
    if (!_ZF) {
      goto LABEL_395;
    }
LABEL_100:
    unsigned int v124 = a1[411].u16[1];
    if (v67 < v124) {
      unsigned int v124 = v67;
    }
    if (v124 < 0x28) {
      goto LABEL_395;
    }
    unint64_t v125 = (unsigned char *)v43;
    if (a1[780].f32[1] <= a1[781].f32[1]) {
      float v126 = a1[781].f32[1];
    }
    else {
      float v126 = a1[780].f32[1];
    }
    float v127 = a1[780].f32[0];
    if (v127 <= a1[781].f32[0]) {
      float v127 = a1[781].f32[0];
    }
    if (v126 <= 0.17453) {
      float v128 = v126;
    }
    else {
      float v128 = 0.17453;
    }
    unsigned __int16 v129 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
    unint64_t v130 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
    if (v127 <= v128)
    {
      unint64_t v132 = v299;
      if (a1[789].f32[1] >= 5.0)
      {
        if (*v298) {
          sub_190430068((uint64_t)v298);
        }
        float v133 = a1[357].f32[0];
        if (v133 <= 0.0) {
          float v134 = -v133;
        }
        else {
          float v134 = a1[357].f32[0];
        }
        float v135 = a1[789].f32[0];
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
        }
        float v136 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
        {
          double v137 = a1[789].f32[0];
          int v138 = *(_DWORD *)(a3 + 48);
          *(_DWORD *)buf = 134218752;
          *(double *)&uint8_t buf[4] = v137;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(double *)&buf[14] = (float)(v134 * 57.296);
          *(_WORD *)&buf[22] = 2048;
          *(double *)&buf[24] = (float)(v126 * 57.296);
          *(_WORD *)&uint8_t buf[32] = 1024;
          *(_DWORD *)&buf[34] = v138;
          _os_log_impl(&dword_1902AF000, v136, OS_LOG_TYPE_DEBUG, "[CorrelatedActivity] auxMovingDuration, %.3f, auxRotGrav, %.3f, auxRot, %.3f, aux.qMode, %d", buf, 0x26u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
          }
          double v267 = a1[789].f32[0];
          int v268 = *(_DWORD *)(a3 + 48);
          float v304 = 3.8523e-34;
          *(double *)int v305 = v267;
          *(_WORD *)&v305[8] = 2048;
          *(double *)&v305[10] = (float)(v134 * 57.296);
          *(_WORD *)&v305[18] = 2048;
          *(double *)&v305[20] = (float)(v126 * 57.296);
          *(_WORD *)&v305[28] = 1024;
          *(_DWORD *)&v305[30] = v268;
          double v269 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "BOOL CMCorrelatedMotion::isLikelyOnGymMachine(const IMUData &, const IMUData &) const", "CoreLocation: %s\n", v269);
          if (v269 != buf) {
            free(v269);
          }
          unint64_t v132 = v299;
        }
        int v131 = v135 > 5.0;
        if (v134 >= 0.17453) {
          int v131 = 0;
        }
      }
      else
      {
        int v131 = 0;
      }
    }
    else
    {
      int v131 = 0;
      unint64_t v132 = v299;
    }
    v15[317].i8[5] = v131;
    if (v15[319].i8[4] != 1)
    {
      if (v9 <= 0xF)
      {
        if ((v131 & 1) == 0 && sub_19058BDA8((uint64_t)v132, v300) <= 10.0 && *v132 != 4 && *v132 != 41)
        {
          double v157 = sub_19058BFAC((uint64_t)v132, v300);
          if (*(float *)&v157 >= 5.0) {
            goto LABEL_271;
          }
        }
        int v131 = v15[317].u8[5];
      }
      if (v131) {
        BOOL v158 = 1;
      }
      else {
        BOOL v158 = *v132 == 4 || *v132 == 41;
      }
      if (v295->i8[0]) {
        sub_190430068((uint64_t)v295);
      }
      float v160 = a1[302].f32[1];
      if (a1[356].i8[4]) {
        sub_190430068((uint64_t)v298);
      }
      float v161 = v160 - a1[357].f32[0];
      if (v161 <= 0.0) {
        float v162 = -v161;
      }
      else {
        float v162 = v160 - a1[357].f32[0];
      }
      if (v158)
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
        }
        uint64_t v163 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
        {
          float v164 = sub_1904308EC(v294, 0, a1[151].u16[1]);
          double v167 = (float)((float)((float)(v165 * a1[788].f32[1]) + (float)(v166 * a1[788].f32[0]))
                       + (float)(v164 * a1[787].f32[1]));
          float v168 = sub_1904308EC((unsigned __int16 *)a1, 0, a1->u16[1]);
          double v171 = (float)((float)((float)(v169 * a1[787].f32[0]) + (float)(v170 * a1[786].f32[1]))
                       + (float)(v168 * a1[786].f32[0]));
          *(_DWORD *)buf = 134218496;
          *(double *)&uint8_t buf[4] = v167;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(double *)&buf[14] = v171;
          *(_WORD *)&buf[22] = 2048;
          *(double *)&buf[24] = v162;
          _os_log_impl(&dword_1902AF000, v163, OS_LOG_TYPE_DEBUG, "[CorrelatedActivity] auxRotGravFull, %.3f, srcRotGravFull, %.3f, diff, %.3f", buf, 0x20u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
          }
          float v276 = sub_1904308EC(v294, 0, a1[151].u16[1]);
          double v279 = (float)((float)((float)(v277 * a1[788].f32[1]) + (float)(v278 * a1[788].f32[0]))
                       + (float)(v276 * a1[787].f32[1]));
          float v280 = sub_1904308EC((unsigned __int16 *)a1, 0, a1->u16[1]);
          double v283 = (float)((float)((float)(v281 * a1[787].f32[0]) + (float)(v282 * a1[786].f32[1]))
                       + (float)(v280 * a1[786].f32[0]));
          float v304 = 3.8522e-34;
          *(double *)int v305 = v279;
          *(_WORD *)&v305[8] = 2048;
          *(double *)&v305[10] = v283;
          *(_WORD *)&v305[18] = 2048;
          *(double *)&v305[20] = v162;
          v284 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "BOOL CMCorrelatedMotion::isLikelyInCorrelatedActivity(const ActivityState &, BOOL, uint64_t) const", "CoreLocation: %s\n", v284);
          if (v284 != buf) {
            free(v284);
          }
          unint64_t v132 = v299;
          unint64_t v130 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
        }
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
        }
        unint64_t v172 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
        {
          double v173 = a1[784].f32[0];
          double v174 = a1[783].f32[1];
          double v175 = a1[783].f32[0];
          *(_DWORD *)buf = 134218496;
          *(double *)&uint8_t buf[4] = v173;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(double *)&buf[14] = v174;
          *(_WORD *)&buf[22] = 2048;
          *(double *)&buf[24] = v175;
          _os_log_impl(&dword_1902AF000, v172, OS_LOG_TYPE_DEBUG, "[CorrelatedActivity] auxRotGrav, %.3f, srcRotGrav, %.3f, relW, %.3f", buf, 0x20u);
        }
        float v176 = 0.2;
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
          }
          double v177 = a1[784].f32[0];
          double v178 = a1[783].f32[1];
          double v179 = a1[783].f32[0];
          float v304 = 3.8522e-34;
          *(double *)int v305 = v177;
          *(_WORD *)&v305[8] = 2048;
          *(double *)&v305[10] = v178;
          *(_WORD *)&v305[18] = 2048;
          *(double *)&v305[20] = v179;
          unint64_t v180 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "BOOL CMCorrelatedMotion::isLikelyInCorrelatedActivity(const ActivityState &, BOOL, uint64_t) const", "CoreLocation: %s\n", v180);
          if (v180 != buf) {
            free(v180);
          }
          unint64_t v132 = v299;
        }
      }
      else
      {
        float v176 = 0.1;
      }
      if (v162 < v176)
      {
        char v140 = 1;
        goto LABEL_272;
      }
      float v181 = a1[784].f32[0];
      float v182 = -v181;
      if (v181 > 0.0) {
        float v182 = a1[784].f32[0];
      }
      if (v182 > 0.2618)
      {
        float v183 = a1[783].f32[1];
        float v184 = v181 - v183;
        if (v184 <= 0.0) {
          float v184 = -v184;
        }
        if (v183 <= 0.0) {
          float v183 = -v183;
        }
        if (v182 >= v183) {
          float v182 = v183;
        }
        if (v182 < 0.17453) {
          float v182 = 0.17453;
        }
        BOOL v185 = v184 > v182;
        goto LABEL_268;
      }
LABEL_271:
      char v140 = 0;
      goto LABEL_272;
    }
    if (v9 <= 0xF)
    {
      if ((v131 & 1) == 0 && sub_19058BDA8((uint64_t)v132, v300) <= 10.0 && *v132 != 4 && *v132 != 41)
      {
        double v139 = sub_19058BFAC((uint64_t)v132, v300);
        if (*(float *)&v139 >= 5.0)
        {
          char v140 = v15[324].i8[4];
          if (!v140)
          {
LABEL_272:
            v15[317].i8[4] = v140;
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
            }
            uint64_t v200 = qword_1E929D8E0;
            if (!os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
            {
LABEL_298:
              if (!sub_1902D8400(115, 2)) {
                goto LABEL_299;
              }
              double v293 = v125;
              bzero(buf, 0x65CuLL);
              if (qword_1E929D8D8 != -1) {
                dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
              }
              int v254 = v15[317].u8[4];
              int v255 = v15[317].u8[5];
              int v256 = *v299;
              BOOL v258 = *v299 == 4 || v256 == 41;
              int v259 = 1;
              if (v256 > 51)
              {
                if (v256 == 52 || v256 == 56) {
                  goto LABEL_417;
                }
              }
              else
              {
                if (!v256) {
                  goto LABEL_420;
                }
                if (v256 == 5)
                {
LABEL_417:
                  if ((v256 & 0xFFFFFFFE) == 0xA) {
                    int v256 = 1;
                  }
                  else {
                    int v256 = v259;
                  }
LABEL_420:
                  if (v299[1] > 1) {
                    int v260 = v256;
                  }
                  else {
                    int v260 = 0;
                  }
                  float v261 = sub_19058BDA8((uint64_t)v299, v300);
                  unsigned int v262 = *v299;
                  BOOL v185 = v261 <= 10.0;
                  float v263 = a1[789].f32[0];
                  int v264 = !v185;
                  float v265 = a1[789].f32[1];
                  float v304 = 1.505e-36;
                  *(_DWORD *)int v305 = v254;
                  *(_WORD *)&v305[4] = 1024;
                  *(_DWORD *)&v305[6] = v255;
                  *(_WORD *)&v305[10] = 1024;
                  *(_DWORD *)&v305[12] = v258;
                  *(_WORD *)&v305[16] = 1024;
                  *(_DWORD *)&v305[18] = v260;
                  *(_WORD *)&v305[22] = 1024;
                  *(_DWORD *)&v305[24] = v264;
                  *(_WORD *)&v305[28] = 1024;
                  *(_DWORD *)&v305[30] = (v262 < 0xC) & (6u >> v262);
                  *(_WORD *)&v305[34] = 1024;
                  *(_DWORD *)&v305[36] = v296 > 0xF;
                  __int16 v306 = 2048;
                  double v307 = v263;
                  __int16 v308 = 2048;
                  double v309 = v265;
                  __int16 v266 = (char *)_os_log_send_and_compose_impl();
                  sub_1902D398C("Generic", 1, 0, 2, "void CMCorrelatedMotion::feed(const IMUData &, const IMUData &, const CMOQuaternion &, const ActivityState &, uint64_t, uint64_t, double)", "CoreLocation: %s\n", v266);
                  if (v266 != buf) {
                    free(v266);
                  }
                  unint64_t v125 = v293;
                  unint64_t v130 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
                  unsigned __int16 v129 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
LABEL_299:
                  if (v15[319].i8[4] != 1)
                  {
LABEL_395:
                    a1[1256] = (float32x2_t)v300;
                    return;
                  }
                  int v214 = v15[323].u8[4];
                  if (v15[324].i8[4])
                  {
                    float v215 = a1[785].f32[1] * 4.0;
                    if (v215 > 1.7453) {
                      float v215 = 1.7453;
                    }
                    if (a1[1253].f32[0] > v215 && a1[1253].f32[1] > 0.87266)
                    {
                      float v216 = a1[1252].f32[0];
                      float v217 = -v216;
                      if (v216 <= 0.0) {
                        float v218 = -v216;
                      }
                      else {
                        float v218 = a1[1252].f32[0];
                      }
                      float v219 = a1[785].f32[0];
                      if (v219 <= 0.0) {
                        float v219 = -v219;
                      }
                      float v220 = v219 - v218;
                      float v221 = 0.5236;
                      goto LABEL_322;
                    }
                    float v222 = a1[783].f32[1];
                    float v218 = -v222;
                    if (v222 <= 0.0) {
                      float v223 = -v222;
                    }
                    else {
                      float v223 = a1[783].f32[1];
                    }
                  }
                  else
                  {
                    float v223 = a1[784].f32[1];
                    if (v223 <= 0.0) {
                      float v223 = -v223;
                    }
                    float v222 = a1[783].f32[1];
                    float v218 = -v222;
                  }
                  float v224 = a1[785].f32[0];
                  if (v224 <= 0.0) {
                    float v224 = -v224;
                  }
                  float v220 = v224 - v223;
                  if (v222 > 0.0) {
                    float v218 = v222;
                  }
                  float v216 = a1[1252].f32[0];
                  float v217 = -v216;
                  float v221 = 0.34907;
LABEL_322:
                  float v225 = a1[784].f32[0];
                  if (v225 <= 0.0) {
                    float v225 = -v225;
                  }
                  if (v216 <= 0.0) {
                    float v216 = v217;
                  }
                  if (!v15[323].i8[4]) {
                    goto LABEL_331;
                  }
                  float v226 = a1[795].f32[0];
                  if (v226 <= 0.0) {
                    float v226 = -v226;
                  }
                  if (v226 > 0.17453) {
                    BOOL v227 = a1[795].f32[1] > 1.9199;
                  }
                  else {
LABEL_331:
                  }
                    BOOL v227 = 0;
                  float32x2_t v228 = a1[1256];
                  float v229 = v225 - v218;
                  float v230 = v225 - v216;
                  if (!v15[324].i8[4] || v227) {
                    goto LABEL_352;
                  }
                  float v231 = a1[1254].f32[1];
                  if (v229 <= v230) {
                    float v232 = v230;
                  }
                  else {
                    float v232 = v229;
                  }
                  if (v231 <= v232) {
                    float v231 = v232;
                  }
                  float v233 = a1[1255].f32[0];
                  if (v233 <= 0.0) {
                    float v233 = -v233;
                  }
                  if (v221 <= v231) {
                    float v221 = v231;
                  }
                  if (v221 > 0.87266) {
                    float v221 = 0.87266;
                  }
                  if (v233 > v221)
                  {
                    v15[323].i8[4] = 0;
                    if (!v214) {
                      goto LABEL_381;
                    }
                  }
                  else
                  {
LABEL_352:
                    if (v15[323].i8[4] && (v230 > 0.34907 || v227 && a1[1254].f32[1] > 0.34907))
                    {
                      int v234 = 1;
                    }
                    else
                    {
                      int v234 = v220 > 0.61087;
                      if (v229 > 0.43633) {
                        int v234 = 1;
                      }
                    }
                    v15[323].i8[4] = v234;
                    if (v214 == v234)
                    {
                      if (!v234 || *(void *)&a1[794]) {
                        goto LABEL_381;
                      }
                      float v235 = a1[795].f32[1];
                      double v236 = a1[795].f32[0];
LABEL_361:
                      unint64_t v237 = a1[360].u16[0] + (unint64_t)a1[360].u16[1] - 1;
                      unint64_t v238 = a1[360].u32[1];
                      if (v237 < v238) {
                        unint64_t v238 = 0;
                      }
                      float v239 = v236 + a1[361].f32[v237 - v238] * ((double)(v300 - *(void *)&v228) * 0.000001);
                      a1[795].f32[0] = v239;
                      if (v239 <= 0.0) {
                        float v239 = -v239;
                      }
                      if (v239 > v235) {
                        a1[795].f32[1] = v239;
                      }
                      if (*((void *)v129 + 283) != -1) {
                        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
                      }
                      v240 = *((void *)v130 + 284);
                      if (os_log_type_enabled(v240, OS_LOG_TYPE_DEBUG))
                      {
                        double v241 = (float)(a1[795].f32[0] * 57.296);
                        *(_DWORD *)buf = 134217984;
                        *(double *)&uint8_t buf[4] = v241;
                        _os_log_impl(&dword_1902AF000, v240, OS_LOG_TYPE_DEBUG, "[UpdateHeadTurnState] headYaw, %.2f", buf, 0xCu);
                      }
                      if (sub_1902D8400(115, 2))
                      {
                        bzero(buf, 0x65CuLL);
                        if (*((void *)v129 + 283) != -1) {
                          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
                        }
                        double v242 = (float)(a1[795].f32[0] * 57.296);
                        float v304 = 3.852e-34;
                        *(double *)int v305 = v242;
LABEL_462:
                        __int16 v288 = (char *)_os_log_send_and_compose_impl();
                        sub_1902D398C("Generic", 1, 0, 2, "void CMCorrelatedMotion::updateHeadTurnState(uint64_t, uint64_t)", "CoreLocation: %s\n", v288);
                        if (v288 != buf) {
                          free(v288);
                        }
                        goto LABEL_381;
                      }
                      goto LABEL_381;
                    }
                    if (v234)
                    {
                      a1[793] = (float32x2_t)v300;
                      a1[795] = 0;
                      double v236 = 0.0;
                      float v235 = 0.0;
                      a1[794] = 0;
                      goto LABEL_361;
                    }
                  }
                  a1[794] = (float32x2_t)v300;
                  if (*(void *)&a1[793] >= v300)
                  {
                    if (*((void *)v129 + 283) != -1) {
                      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
                    }
                    long long v243 = *((void *)v130 + 284);
                    if (os_log_type_enabled(v243, OS_LOG_TYPE_DEBUG))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl(&dword_1902AF000, v243, OS_LOG_TYPE_DEBUG, "[UpdateHeadTurnState] Something is wrong with timestamp.", buf, 2u);
                    }
                    if (sub_1902D8400(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (*((void *)v129 + 283) != -1) {
                        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
                      }
                      LOWORD(v304) = 0;
                      goto LABEL_462;
                    }
                  }
LABEL_381:
                  float v244 = a1[783].f32[1];
                  if (v244 <= 0.0) {
                    float v244 = -v244;
                  }
                  if (v244 > 1.3963)
                  {
                    a1[1150] = 0;
                    a1[1149] = 0;
                    a1[1151].i32[0] = 0;
                    *unint64_t v125 = 1;
                    a1[1254].i32[0] = 0;
                    a1[1257].i32[0] = 0;
                    v15[324].i8[5] = 0;
                    goto LABEL_395;
                  }
                  unsigned int v245 = v15[324].u8[4];
                  if (v15[324].i8[4])
                  {
                    float v246 = a1[1254].f32[0];
                    if (v246 <= 0.0) {
                      float v246 = -v246;
                    }
                    unsigned int v245 = a1[1257].u32[0];
                    if (v246 > 0.61087)
                    {
                      ++v245;
LABEL_393:
                      a1[1257].i32[0] = v245;
                      goto LABEL_394;
                    }
                    if (v245)
                    {
                      --v245;
                      goto LABEL_393;
                    }
                  }
                  else
                  {
                    a1[1257].i32[0] = 0;
                  }
LABEL_394:
                  v15[324].i8[5] = v245 > 0x1E;
                  goto LABEL_395;
                }
              }
              int v259 = 0;
              goto LABEL_417;
            }
            unint64_t v201 = v125;
            int v202 = v15[317].u8[4];
            int v203 = v15[317].u8[5];
            int v204 = *v132;
            BOOL v206 = *v132 == 4 || v204 == 41;
            int v207 = 1;
            if (v204 > 51)
            {
              if (v204 == 52 || v204 == 56) {
                goto LABEL_288;
              }
            }
            else
            {
              if (!v204) {
                goto LABEL_291;
              }
              if (v204 == 5)
              {
LABEL_288:
                if ((v204 & 0xFFFFFFFE) == 0xA) {
                  int v204 = 1;
                }
                else {
                  int v204 = v207;
                }
LABEL_291:
                if (v132[1] > 1) {
                  int v208 = v204;
                }
                else {
                  int v208 = 0;
                }
                float v209 = sub_19058BDA8((uint64_t)v299, v300);
                unsigned int v210 = *v299;
                BOOL v185 = v209 <= 10.0;
                float v211 = a1[789].f32[0];
                int v212 = !v185;
                float v213 = a1[789].f32[1];
                *(_DWORD *)buf = 67111168;
                *(_DWORD *)&uint8_t buf[4] = v202;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v203;
                *(_WORD *)&buf[14] = 1024;
                *(_DWORD *)&uint8_t buf[16] = v206;
                *(_WORD *)&buf[20] = 1024;
                *(_DWORD *)&buf[22] = v208;
                *(_WORD *)&buf[26] = 1024;
                *(_DWORD *)&buf[28] = v212;
                *(_WORD *)&uint8_t buf[32] = 1024;
                *(_DWORD *)&buf[34] = (v210 < 0xC) & (6u >> v210);
                *(_WORD *)&buf[38] = 1024;
                *(_DWORD *)&buf[40] = v296 > 0xF;
                __int16 v311 = 2048;
                double v312 = v211;
                __int16 v313 = 2048;
                double v314 = v213;
                _os_log_impl(&dword_1902AF000, v200, OS_LOG_TYPE_DEBUG, "[CorrelatedMotion] isInCorrelatedActivity, %d, onGymMachine, %d, srcWalking, %d, srcVehicle, %d, srcMovingLT, %d, srcStatic, %d, noBTZLT, %d, auxMovingDurationSecs, %.3f, srcStaticDurationSecs, %.3f", buf, 0x40u);
                unint64_t v125 = v201;
                unint64_t v130 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
                unsigned __int16 v129 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
                goto LABEL_298;
              }
            }
            int v207 = 0;
            goto LABEL_288;
          }
        }
      }
      int v131 = v15[317].u8[5];
    }
    uint64_t v141 = v125;
    if (v131 || *v132 == 4 || *v132 == 41 || (unsigned int v142 = v15[324].u8[4], v15[324].i8[4]))
    {
      unsigned int v142 = v15[324].u8[4];
      float v143 = (float)v142 + 2.0;
      int v144 = 1;
    }
    else
    {
      int v144 = 0;
      float v143 = 1.0;
    }
    float v145 = a1[1252].f32[1];
    float v146 = a1[1252].f32[0] - v145;
    if (v146 <= 0.0) {
      float v147 = -v146;
    }
    else {
      float v147 = a1[1252].f32[0] - v145;
    }
    float v148 = a1[784].f32[0] - a1[783].f32[1];
    if (v148 <= 0.0) {
      float v149 = -v148;
    }
    else {
      float v149 = a1[784].f32[0] - a1[783].f32[1];
    }
    if (!v142) {
      goto LABEL_161;
    }
    float v150 = a1[785].f32[1] * 4.0;
    if (v150 > 1.7453) {
      float v150 = 1.7453;
    }
    if (a1[1253].f32[0] <= v150 || a1[1253].f32[1] <= 0.87266) {
      goto LABEL_161;
    }
    if (v145 <= 0.0) {
      float v147 = -v145;
    }
    else {
      float v147 = a1[1252].f32[1];
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
    }
    float v151 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
    {
      if (*v298) {
        sub_190430068((uint64_t)v298);
      }
      double v152 = a1[357].f32[0];
      if (a1[302].i8[0]) {
        sub_190430068((uint64_t)v295);
      }
      double v153 = a1[302].f32[1];
      *(_DWORD *)buf = 134218496;
      *(double *)&uint8_t buf[4] = v152;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(double *)&buf[14] = v153;
      *(_WORD *)&buf[22] = 2048;
      *(double *)&buf[24] = v147;
      _os_log_impl(&dword_1902AF000, v151, OS_LOG_TYPE_DEBUG, "[CorrelatedActivity] Outdoor, auxRotGravFull, %.3f, srcRotGravFull, %.3f, diff, %.3f", buf, 0x20u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
      }
      if (*v298) {
        sub_190430068((uint64_t)v298);
      }
      double v289 = a1[357].f32[0];
      if (a1[302].i8[0]) {
        sub_190430068((uint64_t)v295);
      }
      double v290 = a1[302].f32[1];
      float v304 = 3.8522e-34;
      *(double *)int v305 = v289;
      *(_WORD *)&v305[8] = 2048;
      *(double *)&v305[10] = v290;
      *(_WORD *)&v305[18] = 2048;
      *(double *)&v305[20] = v147;
      v291 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CMCorrelatedMotion::isLikelyInCorrelatedActivityMusic(const ActivityState &, BOOL, uint64_t) const", "CoreLocation: %s\n", v291);
      if (v291 != buf) {
        free(v291);
      }
      unint64_t v132 = v299;
      unint64_t v130 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
      if (!v144) {
        goto LABEL_239;
      }
    }
    else
    {
LABEL_161:
      if (!v144)
      {
LABEL_239:
        float v192 = a1[785].f32[0];
        if (v192 <= 0.0) {
          float v192 = -v192;
        }
        unint64_t v193 = a1[360].u16[0] + (unint64_t)a1[360].u16[1] - 1;
        unint64_t v194 = a1[360].u32[1];
        if (v193 < v194) {
          unint64_t v194 = 0;
        }
        float v195 = a1[361].f32[v193 - v194];
        if (v195 <= 0.0) {
          float v195 = -v195;
        }
        float v196 = (float)(v192 + v195) * 0.5;
        float v197 = a1[784].f32[0];
        if (v197 <= 0.0) {
          float v197 = -v197;
        }
        if (v197 > v196) {
          float v196 = v197;
        }
        if (v147 < v196) {
          float v196 = v147;
        }
        if (v196 < (float)(v143 * 0.1))
        {
          char v140 = 1;
          unint64_t v125 = v141;
          goto LABEL_272;
        }
        unint64_t v125 = v141;
        if (v15[324].i8[4])
        {
          float v198 = a1[785].f32[1] * 4.0;
          if (v198 > 1.7453) {
            float v198 = 1.7453;
          }
          if (a1[1253].f32[0] > v198)
          {
            char v140 = 0;
            if (v197 <= 0.2618 || a1[1253].f32[1] > 0.87266) {
              goto LABEL_272;
            }
            goto LABEL_261;
          }
        }
        if (v197 > 0.2618)
        {
LABEL_261:
          float v199 = a1[783].f32[1];
          if (v199 <= 0.0) {
            float v199 = -v199;
          }
          if (v197 >= v199) {
            float v197 = v199;
          }
          if (v197 < 0.17453) {
            float v197 = 0.17453;
          }
          BOOL v185 = v149 > v197;
LABEL_268:
          char v140 = !v185;
          goto LABEL_272;
        }
        goto LABEL_271;
      }
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
    }
    BOOL v154 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
    {
      if (!v15[324].i8[4]) {
        goto LABEL_227;
      }
      float v155 = a1[785].f32[1] * 4.0;
      if (v155 > 1.7453) {
        float v155 = 1.7453;
      }
      if (a1[1253].f32[0] > v155) {
        BOOL v156 = a1[1253].f32[1] > 0.87266;
      }
      else {
LABEL_227:
      }
        BOOL v156 = 0;
      if (*v298) {
        sub_190430068((uint64_t)v298);
      }
      double v186 = a1[357].f32[0];
      if (a1[302].i8[0]) {
        sub_190430068((uint64_t)v295);
      }
      double v187 = a1[302].f32[1];
      *(_DWORD *)buf = 67109888;
      *(_DWORD *)&uint8_t buf[4] = v156;
      *(_WORD *)&uint8_t buf[8] = 2048;
      *(double *)&buf[10] = v186;
      *(_WORD *)&buf[18] = 2048;
      *(double *)&buf[20] = v187;
      *(_WORD *)&buf[28] = 2048;
      *(double *)&buf[30] = v147;
      _os_log_impl(&dword_1902AF000, v154, OS_LOG_TYPE_DEBUG, "[CorrelatedActivity] srcInHand, %d, auxRotGravFull, %.3f, srcRotGravFull, %.3f, diff, %.3f", buf, 0x26u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
      }
      if (!v15[324].i8[4]) {
        goto LABEL_451;
      }
      float v270 = a1[785].f32[1] * 4.0;
      if (v270 > 1.7453) {
        float v270 = 1.7453;
      }
      if (a1[1253].f32[0] > v270) {
        BOOL v271 = a1[1253].f32[1] > 0.87266;
      }
      else {
LABEL_451:
      }
        BOOL v271 = 0;
      if (*v298) {
        sub_190430068((uint64_t)v298);
      }
      double v285 = a1[357].f32[0];
      if (a1[302].i8[0]) {
        sub_190430068((uint64_t)v295);
      }
      double v286 = a1[302].f32[1];
      float v304 = 1.5048e-36;
      *(_DWORD *)int v305 = v271;
      *(_WORD *)&v305[4] = 2048;
      *(double *)&v305[6] = v285;
      *(_WORD *)&v305[14] = 2048;
      *(double *)&v305[16] = v286;
      *(_WORD *)&v305[24] = 2048;
      *(double *)&v305[26] = v147;
      uint64_t v287 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CMCorrelatedMotion::isLikelyInCorrelatedActivityMusic(const ActivityState &, BOOL, uint64_t) const", "CoreLocation: %s\n", v287);
      if (v287 != buf) {
        free(v287);
      }
      unint64_t v132 = v299;
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
    }
    unint64_t v188 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
    {
      double v189 = a1[784].f32[0];
      double v190 = a1[783].f32[1];
      double v191 = a1[783].f32[0];
      *(_DWORD *)buf = 134218496;
      *(double *)&uint8_t buf[4] = v189;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(double *)&buf[14] = v190;
      *(_WORD *)&buf[22] = 2048;
      *(double *)&buf[24] = v191;
      _os_log_impl(&dword_1902AF000, v188, OS_LOG_TYPE_DEBUG, "[CorrelatedActivity] auxRotGrav, %.3f, srcRotGrav, %.3f, relW, %.3f", buf, 0x20u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
      }
      double v272 = a1[784].f32[0];
      double v273 = a1[783].f32[1];
      double v274 = a1[783].f32[0];
      float v304 = 3.8522e-34;
      *(double *)int v305 = v272;
      *(_WORD *)&v305[8] = 2048;
      *(double *)&v305[10] = v273;
      *(_WORD *)&v305[18] = 2048;
      *(double *)&v305[20] = v274;
      v275 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CMCorrelatedMotion::isLikelyInCorrelatedActivityMusic(const ActivityState &, BOOL, uint64_t) const", "CoreLocation: %s\n", v275);
      if (v275 != buf) {
        free(v275);
      }
      unint64_t v132 = v299;
    }
    goto LABEL_239;
  }
}

BOOL sub_1904831CC(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  BOOL result = sub_190483284(a1, a2, a3);
  if (result || (BOOL result = sub_19048335C(a1)))
  {
    *(double *)(a1 + 6224) = *(double *)(a1 + 6224) + a4;
    double v7 = *(double *)(a1 + 6232);
    if (v7 > a4) {
      *(double *)(a1 + 6232) = v7 - a4;
    }
  }
  else
  {
    double v8 = *(double *)(a1 + 6232) + a4;
    *(double *)(a1 + 6232) = v8;
    unint64_t v9 = (double *)(a1 + 6224);
    double v10 = *(double *)(a1 + 6224);
    if (v10 > a4)
    {
      double v10 = v10 - a4;
      *unint64_t v9 = v10;
    }
    if (v8 >= 2.5) {
      goto LABEL_11;
    }
    double v11 = v10 * 0.100000001;
    if (v11 < 0.100000001) {
      double v11 = 0.100000001;
    }
    if (v8 >= v11)
    {
LABEL_11:
      *unint64_t v9 = 0.0;
      *(void *)(a1 + 6232) = 0;
    }
  }
  return result;
}

BOOL sub_190483284(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 4) != *(unsigned __int16 *)(a1 + 2)
    || *(_DWORD *)(a1 + 1212) != *(unsigned __int16 *)(a1 + 1210)
    || *(_DWORD *)(a1 + 3292) != *(unsigned __int16 *)(a1 + 3290))
  {
    return 0;
  }
  uint64_t v3 = 0;
  float v4 = 0.0;
  do
  {
    float v4 = v4 + (float)(*(float *)(a2 + 24 + v3) * *(float *)(a2 + 24 + v3));
    v3 += 4;
  }
  while (v3 != 12);
  uint64_t v5 = 0;
  float v6 = 0.0;
  do
  {
    float v6 = v6 + (float)(*(float *)(a3 + 24 + v5) * *(float *)(a3 + 24 + v5));
    v5 += 4;
  }
  while (v5 != 12);
  float v7 = sqrtf(v4) - sqrtf(v6);
  if (v7 <= 0.0) {
    float v8 = -v7;
  }
  else {
    float v8 = v7;
  }
  return sub_1904837CC((unsigned __int16 *)a1) <= 0.10472 && v8 <= 0.05;
}

BOOL sub_19048335C(uint64_t a1)
{
  CFArrayRef v2 = (unsigned char *)(a1 + 6320);
  int v3 = *(unsigned __int16 *)(a1 + 2);
  int v4 = *(_DWORD *)(a1 + 4);
  if (*(unsigned char *)(a1 + 6336) == 1)
  {
    if (v4 == v3
      && *(_DWORD *)(a1 + 1212) == *(unsigned __int16 *)(a1 + 1210)
      && *(_DWORD *)(a1 + 3292) == *(unsigned __int16 *)(a1 + 3290)
      && *v2)
    {
      unint64_t v5 = *(void *)(a1 + 6328);
      float v6 = *(float *)(a1 + 6284);
      if (*(unsigned char *)(a1 + 6321))
      {
        BOOL v8 = v6 >= 0.17453 || v5 > 0x1D;
        unint64_t v9 = (unsigned char *)(a1 + 6376);
        float v10 = (float)((float)v8 + 2.0) * 0.087266;
        if (!*(unsigned char *)(a1 + 6376))
        {
LABEL_64:
          float v33 = *(float *)(a1 + 6272) - *(float *)(a1 + 6268);
          if (v33 <= 0.0) {
            float v33 = -v33;
          }
          BOOL v27 = v33 <= v10;
          if (!*(unsigned char *)(a1 + 6321))
          {
            BOOL v42 = *(float *)(a1 + 6264) <= 0.5236;
            return v27 && v42;
          }
LABEL_67:
          float v43 = sub_19042DEC0((unsigned __int16 *)(a1 + 1208));
          float v44 = v34;
          float v45 = v35;
          float v36 = (float)((float)(v35 * *(float *)(a1 + 6308)) + (float)(v34 * *(float *)(a1 + 6304)))
              + (float)(v43 * *(float *)(a1 + 6300));
          float v37 = -v36;
          if (v36 > 0.0) {
            float v37 = v36;
          }
          if (*v9 && *(float *)(a1 + 6284) >= 0.87266)
          {
            float v38 = *(float *)(a1 + 6280);
            if (v38 <= 0.0) {
              float v38 = -v38;
            }
            float v37 = (float)(v37 + v38) * 0.5;
          }
          if (v6 < 0.17453)
          {
            float v39 = fmaxf(*(float *)(a1 + 6284) * 1.5, 0.087266);
          }
          else if (v5 <= 0x1D)
          {
            float v39 = *(float *)(a1 + 6284) + *(float *)(a1 + 6284);
            if (v39 >= 0.5236) {
              float v39 = 0.5236;
            }
          }
          else
          {
            float v39 = 0.5236;
          }
          uint64_t v40 = 0;
          float v41 = 0.0;
          do
          {
            float v41 = v41 + (float)(*(float *)((char *)&v43 + v40) * *(float *)((char *)&v43 + v40));
            v40 += 4;
          }
          while (v40 != 12);
          BOOL v42 = sqrtf(v41) < 2.7925;
          if (v37 >= v39) {
            BOOL v42 = 0;
          }
          return v27 && v42;
        }
      }
      else
      {
        unint64_t v9 = (unsigned char *)(a1 + 6376);
        if (!*(unsigned char *)(a1 + 6376))
        {
          float v10 = 0.1309;
          goto LABEL_64;
        }
        BOOL v25 = v6 >= 0.17453 || v5 > 0x1D;
        float v10 = (float)((float)v25 + 2.0) * 0.087266;
      }
      float v26 = *(float *)(a1 + 6272);
      if (v26 <= 0.0) {
        float v26 = -v26;
      }
      BOOL v27 = v26 <= v10;
      goto LABEL_67;
    }
    return 0;
  }
  if (v4 != v3
    || *(_DWORD *)(a1 + 1212) != *(unsigned __int16 *)(a1 + 1210)
    || *(_DWORD *)(a1 + 3292) != *(unsigned __int16 *)(a1 + 3290))
  {
    return 0;
  }
  unint64_t v11 = *(void *)(a1 + 6328);
  float v12 = *(float *)(a1 + 6284);
  BOOL v14 = v12 >= 0.17453 || v11 > 0x1D;
  if (*(unsigned char *)(a1 + 6321)) {
    float v15 = (float)((float)v14 + 2.0) * 0.087266;
  }
  else {
    float v15 = 0.1309;
  }
  float v16 = *(float *)(a1 + 6272) - *(float *)(a1 + 6268);
  if (v16 <= 0.0) {
    float v17 = -v16;
  }
  else {
    float v17 = *(float *)(a1 + 6272) - *(float *)(a1 + 6268);
  }
  if (*(unsigned char *)(a1 + 6321))
  {
    float v18 = sub_19042DEC0((unsigned __int16 *)(a1 + 1208));
    float v43 = v18;
    float v44 = v19;
    float v45 = v20;
    if (v12 < 0.17453)
    {
      float v21 = fmaxf(*(float *)(a1 + 6284) * 1.5, 0.087266);
    }
    else if (v11 <= 0x1D)
    {
      float v21 = *(float *)(a1 + 6284) + *(float *)(a1 + 6284);
      if (v21 >= 0.5236) {
        float v21 = 0.5236;
      }
    }
    else
    {
      float v21 = 0.5236;
    }
    uint64_t v28 = 0;
    float v29 = 0.0;
    do
    {
      float v29 = v29 + (float)(*(float *)((char *)&v43 + v28) * *(float *)((char *)&v43 + v28));
      v28 += 4;
    }
    while (v28 != 12);
    if (sqrtf(v29) >= 2.7925)
    {
      BOOL v23 = 0;
    }
    else
    {
      float v30 = (float)((float)(v20 * *(float *)(a1 + 6308)) + (float)(v19 * *(float *)(a1 + 6304)))
          + (float)(v18 * *(float *)(a1 + 6300));
      float v31 = -v30;
      if (v30 > 0.0) {
        float v31 = v30;
      }
      BOOL v23 = v31 < v21;
    }
  }
  else
  {
    BOOL v23 = *(float *)(a1 + 6264) <= 0.5236;
  }
  return v17 <= v15 && *v2 != 0 && v23;
}

float sub_190483750(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  float v3 = 0.0;
  do
  {
    float v3 = v3 + (float)(*(float *)(a1 + 24 + v2) * *(float *)(a1 + 24 + v2));
    v2 += 4;
  }
  while (v2 != 12);
  uint64_t v4 = 0;
  float v5 = 0.0;
  do
  {
    float v5 = v5 + (float)(*(float *)(a2 + 24 + v4) * *(float *)(a2 + 24 + v4));
    v4 += 4;
  }
  while (v4 != 12);
  float v6 = sqrtf(v3) + -1.0;
  if (v6 <= 0.0) {
    float v6 = -v6;
  }
  float v7 = sqrtf(v5) + -1.0;
  if (v7 <= 0.0) {
    float v7 = -v7;
  }
  return v6 + v7;
}

float sub_1904837CC(unsigned __int16 *a1)
{
  float v2 = sub_190484948(a1);
  if (v2 <= sub_1904849A0((uint64_t)a1))
  {
    return sub_1904849A0((uint64_t)a1);
  }
  else
  {
    return sub_190484948(a1);
  }
}

void sub_190483840(uint64_t a1, float *a2, float *a3, float *a4, uint64_t a5)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 4) == *(unsigned __int16 *)(a1 + 2)
    && *(_DWORD *)(a1 + 1212) == *(unsigned __int16 *)(a1 + 1210)
    && *(_DWORD *)(a1 + 3292) == *(unsigned __int16 *)(a1 + 3290))
  {
    uint64_t v9 = 0;
    float v10 = 0.0;
    do
    {
      float v10 = v10 + (float)(a3[v9] * a3[v9]);
      ++v9;
    }
    while (v9 != 3);
    float v11 = sub_1904CF73C(a4, a3[3], a3[4], a3[5]);
    uint64_t v12 = 0;
    float v14 = a2[4] - v13;
    float v16 = a2[5] - v15;
    v27[0] = a2[3] - v11;
    v27[1] = v14;
    v27[2] = v16;
    float v17 = 0.0;
    do
    {
      float v17 = v17 + (float)(v27[v12] * v27[v12]);
      ++v12;
    }
    while (v12 != 3);
    float v18 = sqrtf(v10);
    BOOL v19 = sub_190483284(a1, (uint64_t)a2, (uint64_t)a3);
    float v20 = sub_190483750((uint64_t)a2, (uint64_t)a3);
    if (v18 <= 0.20944)
    {
      float v21 = sqrtf(v17);
      if (v21 <= 0.15 && v19)
      {
        if (qword_1E929D8D8 != -1)
        {
          float v25 = v20;
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
          float v20 = v25;
        }
        float v23 = v21 + v20;
        uint64_t v24 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 134349568;
          double v34 = v23;
          __int16 v35 = 2050;
          double v36 = v18;
          __int16 v37 = 2050;
          uint64_t v38 = a5;
          _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_DEBUG, "[CMRelDMSensorFusionMekf][RelativeGravityConstraints][CorrelatedAnchor] MagnitudeDiffUnity,%{public}.2e, rotationMax,%{public}.2f,timestamp,%{public}llu", buf, 0x20u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
          }
          v27[3] = 3.9124e-34;
          double v28 = v23;
          __int16 v29 = 2050;
          double v30 = v18;
          __int16 v31 = 2050;
          uint64_t v32 = a5;
          float v26 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "float CMCorrelatedMotion::getQuiescentMeasureAnchor(const IMUData &, const IMUData &, const CMOQuaternion &, uint64_t) const", "CoreLocation: %s\n", v26);
          if (v26 != (char *)buf) {
            free(v26);
          }
        }
      }
    }
  }
}

void sub_190483B48(uint64_t a1, uint64_t a2, float *a3, uint64_t a4, float32x4_t a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 4) == *(unsigned __int16 *)(a1 + 2)
    && *(_DWORD *)(a1 + 1212) == *(unsigned __int16 *)(a1 + 1210)
    && *(_DWORD *)(a1 + 3292) == *(unsigned __int16 *)(a1 + 3290))
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = 0x3F80000000000000;
    if (sub_190483E80(a1, a2, a3, (float32x2_t *)buf, 0, a5))
    {
      float v8 = 0.0;
      for (uint64_t i = 12; i != 24; i += 4)
        float v8 = v8 + (float)(*(float *)(a2 + i) * *(float *)(a2 + i));
      float v10 = sqrtf(v8) + -1.0;
      float v11 = 0.0;
      for (uint64_t j = 3; j != 6; ++j)
        float v11 = v11 + (float)(a3[j] * a3[j]);
      if (v10 <= 0.0) {
        float v10 = -v10;
      }
      float v13 = sqrtf(v11) + -1.0;
      if (v13 <= 0.0) {
        float v13 = -v13;
      }
      if (v10 <= v13)
      {
        uint64_t v16 = 0;
        float v15 = 0.0;
        do
        {
          float v15 = v15 + (float)(a3[v16 + 3] * a3[v16 + 3]);
          ++v16;
        }
        while (v16 != 3);
      }
      else
      {
        uint64_t v14 = 0;
        float v15 = 0.0;
        do
        {
          float v15 = v15 + (float)(*(float *)(a2 + 12 + v14) * *(float *)(a2 + 12 + v14));
          v14 += 4;
        }
        while (v14 != 12);
      }
      float v17 = sqrtf(v15) + -1.0;
      if (v17 <= 0.0) {
        float v18 = -v17;
      }
      else {
        float v18 = v17;
      }
      float v19 = sub_190483750(a2, (uint64_t)a3);
      if (qword_1E929D8D8 != -1)
      {
        float v23 = v19;
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
        float v19 = v23;
      }
      float v20 = v19 + v18;
      float v21 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134349312;
        *(double *)&uint8_t buf[4] = (float)(v20 * v20);
        *(_WORD *)&unsigned char buf[12] = 2050;
        *(void *)&buf[14] = a4;
        _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_DEBUG, "[CMRelDMSensorFusionMekf][RelativeGravityConstraints][CorrelatedBTZ] measNoiseVar,%{public}.2e, timestamp,%{public}llu", buf, 0x16u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1780);
        }
        float32_t v22 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "float CMCorrelatedMotion::getQuiescentMeasureIMUOnly(const IMUData &, const IMUData &, uint64_t) const", "CoreLocation: %s\n", v22);
        if (v22 != buf) {
          free(v22);
        }
      }
    }
  }
}

uint64_t sub_190483E80(uint64_t a1, uint64_t a2, float *a3, float32x2_t *a4, int a5, float32x4_t a6)
{
  if (*(_DWORD *)(a1 + 4) != *(unsigned __int16 *)(a1 + 2)
    || *(_DWORD *)(a1 + 1212) != *(unsigned __int16 *)(a1 + 1210)
    || *(_DWORD *)(a1 + 3292) != *(unsigned __int16 *)(a1 + 3290))
  {
    return 0;
  }
  uint64_t v9 = 0;
  a6.i64[0] = 0;
  do
  {
    a6.f32[0] = a6.f32[0] + (float)(a3[v9] * a3[v9]);
    ++v9;
  }
  while (v9 != 3);
  if (a5)
  {
    __int32 v10 = a4[1].i32[1];
    a6.f32[0] = -a4[1].f32[0];
    *(float32x2_t *)v23.f32 = vneg_f32(*a4);
    v23.i64[1] = __PAIR64__(v10, a6.u32[0]);
    sub_1902D9ACC(&v23, a6);
    sub_1904CF73C(v23.f32, *a3, a3[1], a3[2]);
    if (v11 <= 0.0) {
      float v12 = -v11;
    }
    else {
      float v12 = v11;
    }
    float v13 = 0.25;
  }
  else
  {
    float v13 = 0.15;
    float v12 = sqrtf(a6.f32[0]);
  }
  float v15 = 0.0;
  for (uint64_t i = 12; i != 24; i += 4)
    float v15 = v15 + (float)(*(float *)(a2 + i) * *(float *)(a2 + i));
  float v17 = 0.0;
  for (uint64_t j = 3; j != 6; ++j)
    float v17 = v17 + (float)(a3[j] * a3[j]);
  float v19 = sqrtf(v15) - sqrtf(v17);
  if (v19 <= 0.0) {
    float v20 = -v19;
  }
  else {
    float v20 = v19;
  }
  BOOL v21 = sub_190483284(a1, a2, (uint64_t)a3);
  if (sub_190484030(a1) && *(float *)(a1 + 6264) <= 0.17453 || sub_19048335C(a1)) {
    return 1;
  }
  BOOL v22 = v12 <= 0.20944;
  if (v20 > v13) {
    BOOL v22 = 0;
  }
  return v22 & v21;
}

uint64_t sub_190484030(uint64_t a1)
{
  CFArrayRef v1 = (unsigned char *)(a1 + 6320);
  float v2 = *(float *)(a1 + 6252);
  BOOL v3 = *(float *)(a1 + 6264) <= (float)(v2 * 0.5)
    && *(float *)(a1 + 6248) < (float)(v2 + 0.17453)
    && *(float *)(a1 + 6240) < (float)(*(float *)(a1 + 6244) + 0.87266);
  if (*v1 && *(float *)(a1 + 6260) < 2.8074) {
    goto LABEL_21;
  }
  float v4 = *(float *)(a1 + 6268) - *(float *)(a1 + 6272);
  float v5 = -v4;
  if (v4 > 0.0) {
    float v5 = *(float *)(a1 + 6268) - *(float *)(a1 + 6272);
  }
  if (v5 <= 0.34907) {
    goto LABEL_14;
  }
  float v6 = *(float *)(a1 + 6248);
  if (v2 < v6) {
    float v6 = *(float *)(a1 + 6252);
  }
  if (v6 > 0.087266 && *(float *)(a1 + 6260) <= 0.31193)
  {
LABEL_14:
    float v7 = *(float *)(a1 + 6276) - *(float *)(a1 + 6280);
    if (v7 <= 0.0) {
      float v7 = -v7;
    }
    if (v7 > 0.34907)
    {
      float v8 = *(float *)(a1 + 6244);
      if (v8 >= *(float *)(a1 + 6240)) {
        float v8 = *(float *)(a1 + 6240);
      }
      if (v8 > 0.087266)
      {
        BOOL v9 = *(float *)(a1 + 6256) <= 0.31193;
        goto LABEL_23;
      }
      goto LABEL_22;
    }
LABEL_21:
    BOOL v9 = 1;
    goto LABEL_23;
  }
LABEL_22:
  BOOL v9 = 0;
LABEL_23:
  if (*(unsigned char *)(a1 + 6336) == 1)
  {
    if (*v1) {
      BOOL v10 = *(unsigned char *)(a1 + 6376) == 0;
    }
    else {
      BOOL v10 = 0;
    }
    if (!v10 || *(float *)(a1 + 6260) >= 2.8074)
    {
      float v11 = *(float *)(a1 + 6268) - *(float *)(a1 + 6272);
      float v12 = -v11;
      if (v11 > 0.0) {
        float v12 = *(float *)(a1 + 6268) - *(float *)(a1 + 6272);
      }
      if (v12 > 0.34907)
      {
        if (v2 >= *(float *)(a1 + 6248)) {
          float v2 = *(float *)(a1 + 6248);
        }
        if (v2 <= 0.087266 || *(float *)(a1 + 6260) > 0.31193) {
          goto LABEL_45;
        }
      }
      float v13 = *(float *)(a1 + 6276) - *(float *)(a1 + 6280);
      if (v13 <= 0.0) {
        float v13 = -v13;
      }
      if (v13 > 0.34907)
      {
        float v14 = *(float *)(a1 + 6244);
        if (v14 >= *(float *)(a1 + 6240)) {
          float v14 = *(float *)(a1 + 6240);
        }
        if (v14 > 0.087266)
        {
          BOOL v9 = *(float *)(a1 + 6256) <= 0.31193;
          return v3 & v9;
        }
LABEL_45:
        BOOL v9 = 0;
        return v3 & v9;
      }
    }
    BOOL v9 = 1;
  }
  return v3 & v9;
}

float32x2_t *sub_190484254(unsigned __int16 *a1, unint64_t a2, unint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a1[1])
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3400);
    }
    float v18 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_FAULT, "Assertion failed: !empty(), file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMVectorBuffer.h, line 210,variance() on empty buffer.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3400);
      }
      float v19 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const CMVector<T, N> CMVectorBufferBase<float, 3>::variance(size_t, size_t) const [T = float, N = 3]", "CoreLocation: %s\n", v19);
      if (v19 != (char *)buf) {
        free(v19);
      }
    }
  }
  float v21 = 1.0 / (float)(a3 - a2);
  BOOL result = (float32x2_t *)sub_19043049C(a1, a2);
  float v8 = v21;
  float32x2_t v9 = *result;
  float v10 = result[1].f32[0];
  float32x2_t v11 = vmul_n_f32(*result, v21);
  float v12 = v21 * v10;
  unint64_t v13 = a2 + 1;
  if (v13 < a3)
  {
    unint64_t v14 = v13;
    do
    {
      BOOL result = (float32x2_t *)sub_19043049C(a1, v14);
      float v8 = v21;
      float32x2_t v11 = vadd_f32(v11, vmul_n_f32(*result, v21));
      float v12 = v12 + (float)(v21 * result[1].f32[0]);
      ++v14;
    }
    while (a3 != v14);
  }
  float32x2_t v15 = vsub_f32(v9, v11);
  *(float32x2_t *)&long long v7 = vmul_n_f32(vmul_f32(v15, v15), v8);
  float v16 = v8 * (float)((float)(v10 - v12) * (float)(v10 - v12));
  if (v13 < a3)
  {
    do
    {
      long long v20 = v7;
      BOOL result = (float32x2_t *)sub_19043049C(a1, v13);
      *((void *)&v7 + 1) = *((void *)&v20 + 1);
      float32x2_t v17 = vsub_f32(*result, v11);
      *(float32x2_t *)&long long v7 = vadd_f32(*(float32x2_t *)&v20, vmul_n_f32(vmul_f32(v17, v17), v21));
      float v16 = v16 + (float)(v21 * (float)((float)(result[1].f32[0] - v12) * (float)(result[1].f32[0] - v12)));
      ++v13;
    }
    while (a3 != v13);
  }
  return result;
}

float sub_1904844F8(unsigned __int16 *a1)
{
  unint64_t v2 = a1[1];
  float v3 = sub_1904308EC(a1, v2 - 20, v2 - 10);
  float v5 = v4;
  float v7 = v6;
  uint64_t v8 = 0;
  *(float *)BOOL v22 = v3;
  *(float *)&v22[1] = v4;
  *(float *)&v22[2] = v6;
  float v9 = 0.0;
  do
  {
    float v9 = v9 + (float)(*(float *)&v22[v8] * *(float *)&v22[v8]);
    ++v8;
  }
  while (v8 != 3);
  float v10 = sub_1904308EC(a1, v2 - 10, v2);
  uint64_t v13 = 0;
  *(float *)float v21 = v10;
  *(float *)&v21[1] = v11;
  *(float *)&v21[2] = v12;
  float v14 = 0.0;
  do
  {
    float v14 = v14 + (float)(*(float *)&v21[v13] * *(float *)&v21[v13]);
    ++v13;
  }
  while (v13 != 3);
  float v15 = sqrtf(v9);
  float v16 = sqrtf(v14);
  if (v16 >= v15) {
    float v17 = v15;
  }
  else {
    float v17 = v16;
  }
  float v18 = 1.0;
  if (v17 > 0.2618)
  {
    float v19 = (float)((float)((float)(v7 / v15) * (float)(v12 / v16)) + (float)((float)(v5 / v15) * (float)(v11 / v16)))
        + (float)((float)(v3 / v15) * (float)(v10 / v16));
    if (v19 <= 0.0) {
      return -v19;
    }
    else {
      return v19;
    }
  }
  return v18;
}

float sub_190484618(uint64_t a1)
{
  float v2 = sub_1904308EC((unsigned __int16 *)a1, *(unsigned __int16 *)(a1 + 2) - 10, *(unsigned __int16 *)(a1 + 2));
  uint64_t v5 = 0;
  *(float *)float v10 = v2;
  *(float *)&v10[1] = v3;
  *(float *)&void v10[2] = v4;
  float v6 = 0.0;
  do
  {
    float v6 = v6 + (float)(*(float *)&v10[v5] * *(float *)&v10[v5]);
    ++v5;
  }
  while (v5 != 3);
  float v7 = sqrtf(v6);
  float v8 = (float)((float)((float)(v4 / v7) * *(float *)(a1 + 6296)) + (float)((float)(v3 / v7) * *(float *)(a1 + 6292)))
     + (float)((float)(v2 / v7) * *(float *)(a1 + 6288));
  float result = -v8;
  if (v8 > 0.0) {
    return v8;
  }
  return result;
}

BOOL sub_1904846AC(uint64_t a1)
{
  float v1 = *(float *)(a1 + 6240);
  if (v1 < 0.5236) {
    return 0;
  }
  float v3 = *(float *)(a1 + 6244);
  if (v3 > (float)(v1 + 0.087266)) {
    goto LABEL_11;
  }
  float v4 = 0.76;
  if (v3 > 0.43633)
  {
    float v5 = *(float *)(a1 + 6276) - *(float *)(a1 + 6280);
    if (v5 <= 0.0) {
      float v5 = -v5;
    }
    if (v5 <= 0.34907) {
      goto LABEL_11;
    }
    if (v3 < v1) {
      float v1 = *(float *)(a1 + 6244);
    }
    if (v1 > 0.087266 && *(float *)(a1 + 6256) <= 0.31193) {
LABEL_11:
    }
      float v4 = 0.6;
  }
  if (sub_1904844F8((unsigned __int16 *)a1) <= v4) {
    return 1;
  }
  if (sub_190484030(a1)) {
    return 0;
  }
  float v7 = 0.0;
  for (uint64_t i = 1572; i != 1575; ++i)
    float v7 = v7 + (float)(*(float *)(a1 + 4 * i) * *(float *)(a1 + 4 * i));
  return sqrtf(v7) < 0.001 || sub_190484618(a1) <= 0.4;
}

BOOL sub_1904847E8(float *a1)
{
  float v1 = a1[1564];
  if (v1 < 0.030462) {
    return 0;
  }
  float v4 = a1[1560];
  float v5 = a1[1562];
  if (v4 <= v5) {
    float v6 = a1[1562];
  }
  else {
    float v6 = a1[1560];
  }
  if (v6 <= 0.87266) {
    goto LABEL_22;
  }
  if (v1 <= a1[1565]) {
    float v1 = a1[1565];
  }
  if (v1 <= 0.31193)
  {
LABEL_22:
    uint64_t v2 = 0;
    float v7 = a1[1569];
    float v8 = a1[1570];
    float v9 = v7 - v8;
    if ((float)(v7 - v8) <= 0.0) {
      float v9 = -(float)(v7 - v8);
    }
    float v10 = a1[1567] - a1[1568];
    if (v10 <= 0.0) {
      float v10 = -v10;
    }
    if (v9 >= v10) {
      float v9 = v10;
    }
    if (v8 <= 0.0) {
      float v8 = -v8;
    }
    if (v7 <= 0.0) {
      float v7 = -v7;
    }
    if (v8 >= v7 || v9 <= 0.34907) {
      return v2;
    }
  }
  float v11 = a1[1563];
  float v12 = v11 * 1.5;
  if ((float)(v11 * 1.5) < 0.087266) {
    float v12 = 0.087266;
  }
  if (a1[1566] >= v12)
  {
    float v13 = v4 <= v5 ? a1[1560] : a1[1562];
    float v14 = v5 - v11;
    float v15 = v4 - a1[1561];
    if (v14 > v15) {
      float v15 = v14;
    }
    if (v13 > 0.087266 && v15 >= 0.17453) {
      return 1;
    }
  }
  return sub_1904846AC((uint64_t)a1);
}

os_log_t sub_190484918()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

float sub_190484948(unsigned __int16 *a1)
{
  float v1 = sub_1904308EC(a1, 0, a1[1]);
  uint64_t v2 = 0;
  *(float *)float v7 = v1;
  v7[1] = v3;
  v7[2] = v4;
  float v5 = 0.0;
  do
  {
    float v5 = v5 + (float)(*(float *)&v7[v2] * *(float *)&v7[v2]);
    ++v2;
  }
  while (v2 != 3);
  return sqrtf(v5);
}

float sub_1904849A0(uint64_t a1)
{
  float v1 = sub_1904308EC((unsigned __int16 *)(a1 + 1208), 0, *(unsigned __int16 *)(a1 + 1210));
  uint64_t v2 = 0;
  *(float *)float v7 = v1;
  v7[1] = v3;
  v7[2] = v4;
  float v5 = 0.0;
  do
  {
    float v5 = v5 + (float)(*(float *)&v7[v2] * *(float *)&v7[v2]);
    ++v2;
  }
  while (v2 != 3);
  return sqrtf(v5);
}

float sub_190484A00(uint64_t a1, int a2, int a3, float a4)
{
  if (a3 < 1)
  {
    float v13 = 0.0;
  }
  else
  {
    float v6 = (unsigned __int16 *)(a1 + 28);
    unint64_t v7 = a2;
    float v8 = 0.0;
    float v9 = 0.0;
    uint64_t v10 = a3;
    do
    {
      float v11 = (float *)sub_190431610(v6, v7);
      float v12 = (float)((float)(*v11 - a4) * (float)(*v11 - a4)) - v8;
      float v13 = v9 + v12;
      float v8 = (float)((float)(v9 + v12) - v9) - v12;
      ++v7;
      float v9 = v9 + v12;
      --v10;
    }
    while (v10);
  }
  return v13 / (float)a3;
}

void sub_190485910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v15, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

uint64_t sub_1904859C4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t result = *(void *)(v2 + 16);
  if (result)
  {
    uint64_t v4 = MEMORY[0x192FCC3F0]();
    uint64_t result = MEMORY[0x192FCC980](v4, 0xB0C40BC2CC919);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  *(void *)(v2 + 16) = 0;
  return result;
}

void sub_190485D3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16) {
    sub_1902D8B58(a16);
  }
  sub_1902D8B58(v22);
  _Unwind_Resume(a1);
}

void sub_19048608C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16) {
    sub_1902D8B58(a16);
  }
  sub_1902D8B58(v22);
  _Unwind_Resume(a1);
}

void sub_1904864E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16) {
    sub_1902D8B58(a16);
  }
  sub_1902D8B58(v22);
  _Unwind_Resume(a1);
}

void sub_190486914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16) {
    sub_1902D8B58(a16);
  }
  sub_1902D8B58(v22);
  _Unwind_Resume(a1);
}

void sub_190486C28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16) {
    sub_1902D8B58(a16);
  }
  sub_1902D8B58(v22);
  _Unwind_Resume(a1);
}

void sub_190486F4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  sub_1902D8B58(v20);
  _Unwind_Resume(a1);
}

void sub_190487330(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16) {
    sub_1902D8B58(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_190488100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  sub_1902D8B58(v20);
  _Unwind_Resume(a1);
}

os_log_t sub_19048824C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "SensorRecorder");
  qword_1E929D910 = (uint64_t)result;
  return result;
}

void sub_19048827C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1904882F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1904883D0((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void sub_19048830C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_190488344(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    MEMORY[0x192FCC430]();
    JUMPOUT(0x192FCC980);
  }
  return result;
}

uint64_t sub_19048838C(uint64_t a1, uint64_t a2)
{
  if (sub_1903885B4(a2, (uint64_t)&unk_1EDFC71E0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_1904883D0(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    MEMORY[0x192FCC430]();
    JUMPOUT(0x192FCC980);
  }
  return result;
}

uint64_t sub_190488420()
{
  if (qword_1EB3BEA98 != -1) {
    dispatch_once(&qword_1EB3BEA98, &unk_1EDFD17C0);
  }
  return qword_1EB3BEA90;
}

void sub_190488464()
{
}

void sub_1904884EC(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10F1C4075DABF2CLL);
  _Unwind_Resume(a1);
}

void *sub_190488510(void *a1)
{
  *a1 = &unk_1EDFC9290;
  sub_1904885AC((uint64_t)a1, 0, 0);

  return sub_1904DC240(a1);
}

void sub_190488574(void *a1)
{
  sub_190488510(a1);

  JUMPOUT(0x192FCC980);
}

void sub_1904885AC(uint64_t a1, int a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    if (a3)
    {
      if (!*(unsigned char *)(a1 + 80))
      {
        if (qword_1EB3BEA98 != -1) {
          dispatch_once(&qword_1EB3BEA98, &unk_1EDFD17C0);
        }
        uint64_t v5 = qword_1EB3BEA90;
        if (qword_1EB3BE838 != -1) {
          dispatch_once(&qword_1EB3BE838, &unk_1EDFD2FC0);
        }
        float v6 = qword_1EB3BE830;
        if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEBUG, "registering for keyboard updates", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFD2FC0);
          }
          float v9 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CLKeyboardCoverState::registerForKeyboardUpdates()", "CoreLocation: %s\n", v9);
          if (v9 != (char *)buf) {
            free(v9);
          }
        }
        uint64_t v7 = sub_1902D6BD0();
        *(void *)buf = MEMORY[0x1E4F143A8];
        uint64_t v11 = 3221225472;
        float v12 = sub_190488B58;
        float v13 = &unk_1E568CF68;
        uint64_t v14 = v5;
        sub_1902CDE98(v7, (uint64_t)buf);
        *(unsigned char *)(v5 + 80) = 1;
      }
      if (a3 >= 2)
      {
        sub_1904DC8A8(a1, 0, a1 + 81, 1);
      }
    }
    else
    {
      if (qword_1EB3BEA98 != -1) {
        dispatch_once(&qword_1EB3BEA98, &unk_1EDFD17C0);
      }
      uint64_t v8 = qword_1EB3BEA90;
      sub_1904888B8(v8);
    }
  }
}

void sub_1904888B8(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFD2FC0);
  }
  uint64_t v2 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEBUG, "unregistering for keyboard updates", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFD2FC0);
    }
    __int16 v6 = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLKeyboardCoverState::unregisterForKeyboardUpdates()", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  uint64_t v3 = sub_1902D6BD0();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = sub_19048914C;
  v5[3] = &unk_1E568CF68;
  v5[4] = a1;
  sub_1902CDE98(v3, (uint64_t)v5);
  *(unsigned char *)(a1 + 80) = 0;
}

uint64_t sub_190488AA4(uint64_t a1, io_iterator_t iterator)
{
  uint64_t result = IOIteratorNext(iterator);
  if (result)
  {
    io_object_t v5 = result;
    do
    {
      BOOL v6 = sub_1904892BC("AppleHIDKeyboardEventDriverV2");
      BOOL v7 = sub_1904892BC("IOAccessoryIDBusHIDDevice");
      BOOL v8 = v6 || v7;
      if (*(unsigned char *)(a1 + 81) != (v6 || v7))
      {
        *(unsigned char *)(a1 + 81) = v6 || v7;
        sub_1904DC8A8(a1, 0, (uint64_t)&v8, 1);
      }
      IOObjectRelease(v5);
      uint64_t result = IOIteratorNext(iterator);
      io_object_t v5 = result;
    }
    while (result);
  }
  return result;
}

void sub_190488B58(uint64_t a1)
{
  kern_return_t v19;
  IONotificationPort *v20;
  CFDictionaryRef v21;
  kern_return_t v22;
  IONotificationPort *v23;
  CFDictionaryRef v24;
  kern_return_t v25;
  IONotificationPort *v26;
  CFDictionaryRef v27;
  kern_return_t v28;
  io_iterator_t v29;
  NSObject *v30;
  char *v31;
  char *v32;
  uint8_t buf[1640];
  uint64_t v34;
  uint64_t vars8;

  double v34 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  mach_port_t v2 = *MEMORY[0x1E4F2EEF0];
  *(void *)(v1 + 32) = IONotificationPortCreate(*MEMORY[0x1E4F2EEF0]);
  *(void *)(v1 + 40) = IONotificationPortCreate(v2);
  *(void *)(v1 + 48) = IONotificationPortCreate(v2);
  IONotificationPortRef v3 = IONotificationPortCreate(v2);
  *(void *)(v1 + 56) = v3;
  uint64_t v4 = *(IONotificationPort **)(v1 + 32);
  if (v4 && *(void *)(v1 + 40) && (*(void *)(v1 + 48) ? (BOOL v5 = v3 == 0) : (BOOL v5 = 1), !v5))
  {
    RunLoopSource = IONotificationPortGetRunLoopSource(v4);
    BOOL v8 = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(v1 + 40));
    float v9 = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(v1 + 48));
    CFRunLoopSourceRef v10 = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(v1 + 56));
    if (RunLoopSource) {
      BOOL v11 = v8 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11 || v9 == 0 || v10 == 0)
    {
      if (qword_1EB3BEA98 != -1) {
        dispatch_once(&qword_1EB3BEA98, &unk_1EDFD17C0);
      }
      uint64_t v14 = qword_1EB3BEA90;
      sub_1904888B8(v14);
    }
    else
    {
      uint64_t v15 = v10;
      sub_1902D6BD0();
      CFStringRef v16 = (const __CFString *)*MEMORY[0x1E4F1D418];
      CFRunLoopAddSource(*(CFRunLoopRef *)qword_1EB3BF828, RunLoopSource, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
      sub_1902D6BD0();
      CFRunLoopAddSource(*(CFRunLoopRef *)qword_1EB3BF828, v8, v16);
      sub_1902D6BD0();
      CFRunLoopAddSource(*(CFRunLoopRef *)qword_1EB3BF828, v9, v16);
      sub_1902D6BD0();
      CFRunLoopAddSource(*(CFRunLoopRef *)qword_1EB3BF828, v15, v16);
      float v17 = *(IONotificationPort **)(v1 + 32);
      CFDictionaryRef v18 = IOServiceMatching("AppleHIDKeyboardEventDriverV2");
      float v19 = IOServiceAddMatchingNotification(v17, "IOServiceFirstMatch", v18, (IOServiceMatchingCallback)sub_190488AA4, (void *)v1, (io_iterator_t *)(v1 + 64));
      long long v20 = *(IONotificationPort **)(v1 + 40);
      float v21 = IOServiceMatching("AppleHIDKeyboardEventDriverV2");
      BOOL v22 = IOServiceAddMatchingNotification(v20, "IOServiceTerminate", v21, (IOServiceMatchingCallback)sub_190488AA4, (void *)v1, (io_iterator_t *)(v1 + 68));
      uint64_t v23 = *(IONotificationPort **)(v1 + 48);
      uint64_t v24 = IOServiceMatching("IOAccessoryIDBusHIDDevice");
      uint64_t v25 = IOServiceAddMatchingNotification(v23, "IOServiceFirstMatch", v24, (IOServiceMatchingCallback)sub_190488AA4, (void *)v1, (io_iterator_t *)(v1 + 72));
      float v26 = *(IONotificationPort **)(v1 + 56);
      BOOL v27 = IOServiceMatching("IOAccessoryIDBusHIDDevice");
      double v28 = IOServiceAddMatchingNotification(v26, "IOServiceTerminate", v27, (IOServiceMatchingCallback)sub_190488AA4, (void *)v1, (io_iterator_t *)(v1 + 76));
      if (v19 || v22 || v25 || v28)
      {
        if (qword_1EB3BE838 != -1) {
          dispatch_once(&qword_1EB3BE838, &unk_1EDFD2FC0);
        }
        double v30 = qword_1EB3BE830;
        if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1902AF000, v30, OS_LOG_TYPE_DEFAULT, "#Warning Failed to register for keyboard updates. Could not register for notifications from  AppleHIDKeyboardEventDriverV2 service and IOAccessoryIDBusHIDDevice service (for kIOFirstMatchNotification and kIOTerminatedNotification).", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFD2FC0);
          }
          uint64_t v32 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CLKeyboardCoverState::registerForKeyboardUpdates()_block_invoke", "CoreLocation: %s\n", v32);
          if (v32 != (char *)buf) {
            free(v32);
          }
        }
        if (qword_1EB3BEA98 != -1) {
          dispatch_once(&qword_1EB3BEA98, &unk_1EDFD17C0);
        }
        sub_1904888B8(qword_1EB3BEA90);
      }
      else
      {
        sub_190488AA4(v1, *(_DWORD *)(v1 + 64));
        sub_190488AA4(v1, *(_DWORD *)(v1 + 68));
        sub_190488AA4(v1, *(_DWORD *)(v1 + 72));
        __int16 v29 = *(_DWORD *)(v1 + 76);
        sub_190488AA4(v1, v29);
      }
    }
  }
  else
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFD2FC0);
    }
    BOOL v6 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "#Warning Failed to register for keyboard updates. Could not create KeyboardConnectNotificationPort and KeyboardConnectNotificationPort", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFD2FC0);
      }
      __int16 v31 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLKeyboardCoverState::registerForKeyboardUpdates()_block_invoke", "CoreLocation: %s\n", v31);
      if (v31 != (char *)buf) {
        free(v31);
      }
    }
  }
}

uint64_t sub_19048914C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  mach_port_t v2 = *(IONotificationPort **)(v1 + 32);
  if (v2)
  {
    CFRunLoopSourceRef RunLoopSource = IONotificationPortGetRunLoopSource(v2);
    if (RunLoopSource)
    {
      uint64_t v4 = RunLoopSource;
      sub_1902D6BD0();
      CFRunLoopRemoveSource(*(CFRunLoopRef *)qword_1EB3BF828, v4, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
    }
    IONotificationPortDestroy(*(IONotificationPortRef *)(v1 + 32));
    *(void *)(v1 + 32) = 0;
  }
  BOOL v5 = *(IONotificationPort **)(v1 + 40);
  if (v5)
  {
    CFRunLoopSourceRef v6 = IONotificationPortGetRunLoopSource(v5);
    if (v6)
    {
      BOOL v7 = v6;
      sub_1902D6BD0();
      CFRunLoopRemoveSource(*(CFRunLoopRef *)qword_1EB3BF828, v7, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
    }
    IONotificationPortDestroy(*(IONotificationPortRef *)(v1 + 40));
    *(void *)(v1 + 40) = 0;
  }
  BOOL v8 = *(IONotificationPort **)(v1 + 48);
  if (v8)
  {
    CFRunLoopSourceRef v9 = IONotificationPortGetRunLoopSource(v8);
    if (v9)
    {
      CFRunLoopSourceRef v10 = v9;
      sub_1902D6BD0();
      CFRunLoopRemoveSource(*(CFRunLoopRef *)qword_1EB3BF828, v10, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
    }
    IONotificationPortDestroy(*(IONotificationPortRef *)(v1 + 48));
    *(void *)(v1 + 48) = 0;
  }
  BOOL v11 = *(IONotificationPort **)(v1 + 56);
  if (v11)
  {
    CFRunLoopSourceRef v12 = IONotificationPortGetRunLoopSource(v11);
    if (v12)
    {
      float v13 = v12;
      sub_1902D6BD0();
      CFRunLoopRemoveSource(*(CFRunLoopRef *)qword_1EB3BF828, v13, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
    }
    IONotificationPortDestroy(*(IONotificationPortRef *)(v1 + 56));
    *(void *)(v1 + 56) = 0;
  }
  io_object_t v14 = *(_DWORD *)(v1 + 64);
  if (v14)
  {
    IOObjectRelease(v14);
    *(_DWORD *)(v1 + 64) = 0;
  }
  io_object_t v15 = *(_DWORD *)(v1 + 68);
  if (v15)
  {
    IOObjectRelease(v15);
    *(_DWORD *)(v1 + 68) = 0;
  }
  io_object_t v16 = *(_DWORD *)(v1 + 72);
  if (v16)
  {
    IOObjectRelease(v16);
    *(_DWORD *)(v1 + 72) = 0;
  }
  uint64_t result = *(unsigned int *)(v1 + 76);
  if (result)
  {
    uint64_t result = IOObjectRelease(result);
    *(_DWORD *)(v1 + 76) = 0;
  }
  return result;
}

BOOL sub_1904892BC(const char *a1)
{
  io_iterator_t existing = 0;
  mach_port_t v1 = *MEMORY[0x1E4F2EEF0];
  CFDictionaryRef v2 = IOServiceMatching(a1);
  IOServiceGetMatchingServices(v1, v2, &existing);
  io_object_t v3 = IOIteratorNext(existing);
  if (v3)
  {
    io_registry_entry_t v4 = v3;
    BOOL v5 = 0;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      CFBooleanRef CFProperty = (const __CFBoolean *)IORegistryEntryCreateCFProperty(v4, @"RequiresCompassResetOnConnect", v6, 0);
      if (CFProperty)
      {
        CFBooleanRef v8 = CFProperty;
        CFTypeID v9 = CFGetTypeID(CFProperty);
        if (v9 == CFBooleanGetTypeID())
        {
          BOOL v5 = CFBooleanGetValue(v8) != 0;
          CFRelease(v8);
        }
      }
      IOObjectRelease(v4);
      io_registry_entry_t v4 = IOIteratorNext(existing);
    }
    while (v4);
  }
  else
  {
    return 0;
  }
  return v5;
}

os_log_t sub_1904893A8()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1EB3BE830 = (uint64_t)result;
  return result;
}

void sub_1904893D8(uint64_t a1)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  sub_190559F28(a1);
}

void sub_1904896DC(_Unwind_Exception *a1)
{
  sub_19055A8A0(v1);
  _Unwind_Resume(a1);
}

void *sub_190489714(void *a1)
{
  *a1 = &unk_1EDFC7698;
  sub_19048AB74((uint64_t)a1);

  return sub_19055A8A0((uint64_t)a1);
}

void sub_190489770(void *a1)
{
  sub_190489714(a1);

  JUMPOUT(0x192FCC980);
}

void sub_1904897A8(uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
  }
  io_registry_entry_t v4 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67240192;
    int v14 = a2;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEFAULT, "Legacy compass started. Cover attached %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
    }
    CFRunLoopSourceRef v12 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLCompass6::start(BOOL)", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf) {
      free(v12);
    }
  }
  if (!*(void *)(a1 + 200)) {
    operator new();
  }
  if (*(unsigned char *)(a1 + 186))
  {
    if (!*(void *)(a1 + 144))
    {
      uint64_t v5 = sub_1902B35C0();
      *(_DWORD *)buf = 7;
      if (sub_19056F3CC(v5, (int *)buf))
      {
        CFAllocatorRef v6 = [CLDeviceMotionProperties alloc];
        objc_msgSend_initWithMode_(v6, v7, 7);
      }
      else
      {
        uint64_t v8 = sub_1902B35C0();
        *(_DWORD *)buf = 15;
        BOOL v9 = sub_19056F3CC(v8, (int *)buf);
        CFRunLoopSourceRef v10 = [CLDeviceMotionProperties alloc];
        if (v9) {
          objc_msgSend_initWithMode_(v10, v11, 15);
        }
        else {
          objc_msgSend_initWithMode_(v10, v11, 3);
        }
      }
      operator new();
    }
  }
  else if (!*(void *)(a1 + 136))
  {
    operator new();
  }
  if (!*(void *)(a1 + 152)) {
    operator new();
  }
  *(unsigned char *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 164) = 0;
}

void sub_190489D08(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x1081C40D4124DFELL);
  _Unwind_Resume(a1);
}

void sub_190489D80(long long *a1, uint64_t a2)
{
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  long long v93 = *a1;
  uint64_t v94 = *((void *)a1 + 2);
  ++*(_DWORD *)(a2 + 160);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEAA8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB3BEAA8))
  {
    dword_1EB3BEAA0 = (int)(1.5 / *(double *)(a2 + 168));
    __cxa_guard_release(&qword_1EB3BEAA8);
  }
  uint64_t v3 = *(void *)(a2 + 144);
  if (v3)
  {
    io_registry_entry_t v4 = (os_unfair_lock_s *)(v3 + 140);
    os_unfair_lock_lock((os_unfair_lock_t)(v3 + 140));
    double v5 = *(double *)(v3 + 24);
    double v6 = *(double *)(v3 + 32);
    double v7 = *(double *)(v3 + 40);
    double v8 = *(double *)(v3 + 48);
    uint64_t v9 = *(void *)(v3 + 68);
    int v10 = *(_DWORD *)(v3 + 76);
    char v11 = *(unsigned char *)(v3 + 98);
    int v12 = *(unsigned __int8 *)(v3 + 136);
    os_unfair_lock_unlock(v4);
    if (v12)
    {
      float v13 = v6 * (v8 + v8) - v5 * (v7 + v7);
      float v14 = v5 * (v6 + v6) + v7 * (v8 + v8);
      float v15 = 1.0 - v6 * (v6 + v6) - v7 * (v7 + v7);
      float v16 = -v13;
      *(float *)(a2 + 188) = v16;
      *(float *)(a2 + 192) = -v14;
      *(float *)(a2 + 196) = -v15;
      uint64_t v17 = *(void *)(a2 + 200);
      *(float *)(v17 + 80) = v16;
      *(_DWORD *)(v17 + 84) = *(_DWORD *)(a2 + 192);
      *(_DWORD *)(v17 + 88) = *(_DWORD *)(a2 + 196);
      *(double *)(v17 + 16) = v6;
      *(double *)(v17 + 24) = v7;
      *(double *)(v17 + 32) = v8;
      *(double *)(v17 + 40) = v5;
      *(void *)(v17 + 56) = v9;
      *(_DWORD *)(v17 + 64) = v10;
      *(unsigned char *)(v17 + 96) = v11;
    }
  }
  else
  {
    uint64_t v18 = *(void *)(a2 + 136);
    if (v18)
    {
      float v19 = (os_unfair_lock_s *)(v18 + 44);
      os_unfair_lock_lock((os_unfair_lock_t)(v18 + 44));
      buf[0] = *(_OWORD *)(v18 + 16);
      *(void *)&buf[1] = *(void *)(v18 + 32);
      int v20 = *(unsigned __int8 *)(v18 + 40);
      os_unfair_lock_unlock(v19);
      if (v20)
      {
        *(void *)(a2 + 188) = *((void *)&buf[0] + 1);
        *(_DWORD *)(a2 + 196) = buf[1];
        float v21 = *(_DWORD **)(a2 + 200);
        v21[20] = *(_DWORD *)(a2 + 188);
        v21[21] = *(_DWORD *)(a2 + 192);
        v21[22] = *(_DWORD *)(a2 + 196);
      }
    }
  }
  int v90 = -1082130432;
  if (*(float *)(a2 + 188) != 3.4028e38 && sub_190533E34(*(float32x2_t **)(a2 + 200), (uint64_t *)&v93 + 1))
  {
    if (!sub_190534A98(*(void *)(a2 + 200), (uint64_t)&v84, v28, v29, v30, v31, v32, v33, v34, v35, v22, v23, v24, v25, v26, v27))return; {
    v36.n128_u32[1] = DWORD1(v93);
    }
    uint64_t v83 = v93;
    uint64_t v37 = *(void *)(a2 + 200);
    uint64_t v38 = *(void *)(v37 + 1640);
    if (v38) {
      v36.n128_u32[0] = *(_DWORD *)(*(void *)(*(void *)(v37 + 1608)
    }
                                              + (((unint64_t)(v38 + *(void *)(v37 + 1632) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                                  + 4 * ((v38 + *(void *)(v37 + 1632) - 1) & 0x3FF));
    else {
      v36.n128_u64[0] = 0;
    }
    unsigned __int32 v91 = v36.n128_u32[0];
    char v92 = *(unsigned char *)(a2 + 28);
    v36.n128_u32[0] = DWORD2(v86);
    if (*(unsigned char *)(a2 + 185))
    {
      if (*((float *)&v86 + 2) < 0.0)
      {
        *(unsigned char *)(a2 + 185) = 0;
        uint64_t v43 = sub_1904DB124();
        sub_1904DB7DC(v43);
        uint64_t v37 = *(void *)(a2 + 200);
      }
    }
    else if (*((float *)&v86 + 2) >= 0.0)
    {
      *(unsigned char *)(a2 + 185) = 1;
    }
    unsigned __int8 v82 = 0;
    int v44 = (*(uint64_t (**)(void, __n128))(**(void **)(v37 + 104) + 120))(*(void *)(v37 + 104), v36);
    unsigned __int8 v82 = v44;
    if (*(unsigned __int8 *)(a2 + 184) != v44)
    {
      sub_1902D8BCC(a2, 1, (uint64_t)&v82, 1);
      *(unsigned char *)(a2 + 184) = v82;
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
      }
      float v45 = qword_1E929D790;
      if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136315650;
        *(void *)((char *)buf + 4) = "CompassAlignment";
        WORD6(buf[0]) = 1024;
        *(_DWORD *)((char *)buf + 14) = v82;
        WORD1(buf[1]) = 2048;
        *(void *)((char *)&buf[1] + 4) = v93;
        _os_log_impl(&dword_1902AF000, v45, OS_LOG_TYPE_DEBUG, "Type,%s,compassJustAlignedToStableField,%d,timestamp,%20.20f", (uint8_t *)buf, 0x1Cu);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D798 != -1) {
          dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
        }
        LODWORD(v95[0]) = 136315650;
        *(void *)((char *)v95 + 4) = "CompassAlignment";
        WORD2(v95[1]) = 1024;
        *(_DWORD *)((char *)&v95[1] + 6) = v82;
        WORD1(v95[2]) = 2048;
        *(void *)((char *)&v95[2] + 4) = v93;
        int v81 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "static void CLCompass6::onMagnetometerData(const CLMagnetometer::Sample *, void *)", "CoreLocation: %s\n", v81);
        if (v81 != (char *)buf) {
          free(v81);
        }
      }
      if (*(unsigned char *)(a2 + 29))
      {
        v95[0] = &unk_1EDFCA758;
        v95[1] = CFAbsoluteTimeGetCurrent();
        v95[3] = v93;
        LOBYTE(v96[0]) = v82;
        uint64_t v46 = sub_190570220();
        sub_190571738(v46, (uint64_t)v95);
        sub_190395088(buf);
        sub_1903AE6D0((uint64_t)buf);
        v140 |= 1u;
        uint64_t v137 = v95[1];
        uint64_t v47 = v139;
        uint64_t v48 = v93;
        *(unsigned char *)(v139 + 20) |= 1u;
        *(void *)(v47 + 8) = v48;
        uint64_t v49 = v139;
        int v50 = v82;
        *(unsigned char *)(v139 + 20) |= 2u;
        *(_DWORD *)(v49 + 16) = v50;
        sub_19039A590((PB::Base *)buf);
      }
    }
    float v51 = *(float **)(a2 + 200);
    float v52 = v51[338];
    float v53 = v51[339];
    float v54 = v51[340];
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
    }
    __int32 v55 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf[0]) = 136318722;
      *(void *)((char *)buf + 4) = "Compass";
      WORD6(buf[0]) = 2048;
      *(double *)((char *)buf + 14) = *(float *)&v86;
      WORD3(buf[1]) = 2048;
      *((double *)&buf[1] + 1) = *((float *)&v86 + 1);
      __int16 v113 = 2048;
      double v114 = *((float *)&v86 + 2);
      __int16 v115 = 2048;
      double v116 = *(float *)&v84;
      __int16 v117 = 2048;
      double v118 = *((float *)&v84 + 1);
      __int16 v119 = 2048;
      double v120 = v85;
      __int16 v121 = 2048;
      double v122 = v52;
      __int16 v123 = 2048;
      double v124 = v53;
      __int16 v125 = 2048;
      double v126 = v54;
      __int16 v127 = 1024;
      int v128 = HIDWORD(v86);
      __int16 v129 = 2048;
      double v130 = *(float *)&v88;
      __int16 v131 = 2048;
      double v132 = *((float *)&v88 + 1);
      __int16 v133 = 2048;
      double v134 = v89;
      __int16 v135 = 2048;
      uint64_t v136 = v83;
      _os_log_impl(&dword_1902AF000, v55, OS_LOG_TYPE_DEBUG, "Type,%s,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f", (uint8_t *)buf, 0x94u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
      }
      LODWORD(v95[0]) = 136318722;
      *(void *)((char *)v95 + 4) = "Compass";
      WORD2(v95[1]) = 2048;
      *(double *)((char *)&v95[1] + 6) = *(float *)&v86;
      HIWORD(v95[2]) = 2048;
      *(double *)&v95[3] = *((float *)&v86 + 1);
      LOWORD(v96[0]) = 2048;
      *(double *)((char *)v96 + 2) = *((float *)&v86 + 2);
      HIWORD(v96[2]) = 2048;
      *(double *)&v96[3] = *(float *)&v84;
      LOWORD(v97[0]) = 2048;
      *(double *)((char *)v97 + 2) = *((float *)&v84 + 1);
      HIWORD(v97[2]) = 2048;
      double v98 = v85;
      LOWORD(v99[0]) = 2048;
      *(double *)((char *)v99 + 2) = v52;
      HIWORD(v99[2]) = 2048;
      *(double *)&v99[3] = v53;
      __int16 v100 = 2048;
      double v101 = v54;
      __int16 v102 = 1024;
      int v103 = HIDWORD(v86);
      __int16 v104 = 2048;
      double v105 = *(float *)&v88;
      __int16 v106 = 2048;
      double v107 = *((float *)&v88 + 1);
      __int16 v108 = 2048;
      double v109 = v89;
      __int16 v110 = 2048;
      uint64_t v111 = v83;
      uint64_t v79 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "static void CLCompass6::onMagnetometerData(const CLMagnetometer::Sample *, void *)", "CoreLocation: %s\n", v79);
      if (v79 != (char *)buf) {
        free(v79);
      }
    }
    if (*(unsigned char *)(a2 + 29))
    {
      v95[0] = &unk_1EDFCA8D8;
      v95[1] = CFAbsoluteTimeGetCurrent();
      v95[3] = v83;
      *(void *)&long long v56 = *(void *)((char *)&v86 + 4);
      *((void *)&v56 + 1) = v84;
      v96[0] = v86;
      *(_OWORD *)&v96[1] = v56;
      *(float *)int v97 = v85;
      *(float *)&v97[1] = v52;
      *(float *)&v97[2] = v53;
      *(float *)&double v98 = v54;
      BYTE4(v98) = BYTE12(v86);
      *(void *)float v99 = v88;
      *(float *)&v99[2] = v89;
      uint64_t v57 = sub_190570220();
      sub_190571738(v57, (uint64_t)v95);
      sub_190395088(buf);
      sub_1903AE640((uint64_t)buf);
      v140 |= 1u;
      uint64_t v137 = v95[1];
      uint64_t v58 = v138;
      uint64_t v59 = v83;
      *(_WORD *)(v138 + 68) |= 1u;
      *(void *)(v58 + 8) = v59;
      uint64_t v60 = v138;
      *(_WORD *)(v138 + 68) |= 0x800u;
      int v61 = DWORD1(v86);
      *(_DWORD *)(v60 + 56) = v86;
      uint64_t v62 = v138;
      *(_WORD *)(v138 + 68) |= 0x2000u;
      *(_DWORD *)(v62 + 64) = v61;
      uint64_t v63 = v138;
      LODWORD(v59) = DWORD2(v86);
      *(_WORD *)(v138 + 68) |= 2u;
      *(_DWORD *)(v63 + 16) = v59;
      uint64_t v64 = v138;
      int v65 = HIDWORD(v84);
      *(_DWORD *)(v138 + 44) = v84;
      *(_WORD *)(v64 + 68) |= 0x100u;
      uint64_t v66 = v138;
      *(_WORD *)(v138 + 68) |= 0x200u;
      *(_DWORD *)(v66 + 48) = v65;
      uint64_t v67 = v138;
      *(float *)&uint64_t v59 = v85;
      *(_WORD *)(v138 + 68) |= 0x400u;
      *(_DWORD *)(v67 + 52) = v59;
      uint64_t v68 = v138;
      *(_WORD *)(v138 + 68) |= 4u;
      *(float *)(v68 + 20) = v52;
      uint64_t v69 = v138;
      *(_WORD *)(v138 + 68) |= 8u;
      *(float *)(v69 + 24) = v53;
      uint64_t v70 = v138;
      *(_WORD *)(v138 + 68) |= 0x10u;
      *(float *)(v70 + 28) = v54;
      uint64_t v71 = v138;
      int v72 = HIDWORD(v86);
      *(_WORD *)(v138 + 68) |= 0x20u;
      *(_DWORD *)(v71 + 32) = v72;
      uint64_t v73 = v138;
      *(_WORD *)(v138 + 68) |= 0x1000u;
      int v74 = HIDWORD(v88);
      *(_DWORD *)(v73 + 60) = v88;
      uint64_t v75 = v138;
      *(_WORD *)(v138 + 68) |= 0x80u;
      *(_DWORD *)(v75 + 40) = v74;
      uint64_t v76 = v138;
      *(float *)&uint64_t v59 = v89;
      *(_WORD *)(v138 + 68) |= 0x40u;
      *(_DWORD *)(v76 + 36) = v59;
      sub_19039A590((PB::Base *)buf);
    }
    if (SHIDWORD(v86) <= 0 && *(_DWORD *)(*(void *)(a2 + 200) + 376) <= dword_1EB3BEAA0) {
      return;
    }
    sub_1902D8BCC(a2, 0, (uint64_t)&v83, 112);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
    }
    int v77 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
    {
      int v78 = *(_DWORD *)(*(void *)(a2 + 200) + 376);
      LODWORD(buf[0]) = 67109632;
      DWORD1(buf[0]) = v78;
      WORD4(buf[0]) = 1024;
      *(_DWORD *)((char *)buf + 10) = HIDWORD(v86);
      HIWORD(buf[0]) = 2048;
      *(void *)&buf[1] = v83;
      _os_log_impl(&dword_1902AF000, v77, OS_LOG_TYPE_DEBUG, "notified clients. sampleCount,%d,compass.compass.calibrationLevel,%d,compass.timestamp,%f", (uint8_t *)buf, 0x18u);
    }
    if (!sub_1902D8400(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
    }
    int v80 = *(_DWORD *)(*(void *)(a2 + 200) + 376);
    LODWORD(v95[0]) = 67109632;
    HIDWORD(v95[0]) = v80;
    LOWORD(v95[1]) = 1024;
    *(_DWORD *)((char *)&v95[1] + 2) = HIDWORD(v86);
    HIWORD(v95[1]) = 2048;
    v95[2] = v83;
    BOOL v42 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "static void CLCompass6::onMagnetometerData(const CLMagnetometer::Sample *, void *)", "CoreLocation: %s\n", v42);
LABEL_59:
    if (v42 != (char *)buf) {
      free(v42);
    }
    return;
  }
  if (!*(unsigned char *)(a2 + 164) && *(_DWORD *)(*(void *)(a2 + 200) + 376) > dword_1EB3BEAA0)
  {
    *((void *)&v86 + 1) = 3212836864;
    *(void *)&long long v86 = 0;
    float v85 = 0.0;
    char v87 = 0;
    uint64_t v88 = 0;
    float v89 = 0.0;
    unsigned __int32 v91 = 0;
    char v92 = 0;
    uint64_t v83 = v93;
    uint64_t v84 = 0;
    *(unsigned char *)(a2 + 164) = 1;
    sub_1902D8BCC(a2, 0, (uint64_t)&v83, 112);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
    }
    uint64_t v39 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_INFO))
    {
      double v40 = *(double *)(a2 + 168) * (double)*(int *)(*(void *)(a2 + 200) + 376);
      LODWORD(buf[0]) = 134349056;
      *(double *)((char *)buf + 4) = v40;
      _os_log_impl(&dword_1902AF000, v39, OS_LOG_TYPE_INFO, "Notify after %{public}.3f seconds of no event.", (uint8_t *)buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
      }
      double v41 = *(double *)(a2 + 168) * (double)*(int *)(*(void *)(a2 + 200) + 376);
      LODWORD(v95[0]) = 134349056;
      *(double *)((char *)v95 + 4) = v41;
      BOOL v42 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "static void CLCompass6::onMagnetometerData(const CLMagnetometer::Sample *, void *)", "CoreLocation: %s\n", v42);
      goto LABEL_59;
    }
  }
}

void sub_19048AB4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
}

void *sub_19048AB74(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
  }
  CFDictionaryRef v2 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "Legacy compass stopped.", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD17E0);
    }
    int v12 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLCompass6::stop()", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf) {
      free(v12);
    }
  }
  uint64_t v4 = *(void *)(a1 + 144);
  uint64_t v3 = *(void *)(a1 + 152);
  *(void *)(a1 + 144) = 0;
  if (v3)
  {
    uint64_t v5 = sub_1904DB124();
    sub_1902CDE08(v5, 0, *(void *)(a1 + 152));
    uint64_t v6 = *(void *)(a1 + 152);
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    *(void *)(a1 + 152) = 0;
  }
  if (*(unsigned char *)(a1 + 186))
  {
    if (v4)
    {
      uint64_t v7 = sub_1902B35C0();
      sub_1902E02F4(v7, v4);
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  else if (*(void *)(a1 + 136))
  {
    uint64_t v8 = sub_1902DFEC4();
    sub_1902CDE08(v8, 0, *(void *)(a1 + 136));
    uint64_t v9 = *(void *)(a1 + 136);
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    *(void *)(a1 + 136) = 0;
  }
  os_log_t result = *(void **)(a1 + 200);
  if (result)
  {
    char v11 = sub_190533D08(result);
    os_log_t result = (void *)MEMORY[0x192FCC980](v11, 0x10A0C40E4B69569);
    *(void *)(a1 + 200) = 0;
  }
  *(_DWORD *)(a1 + 188) = 2139095039;
  return result;
}

float sub_19048AE0C(uint64_t a1, double *a2)
{
  uint64_t v2 = *(void *)(a1 + 200);
  if (v2) {
    return sub_190534938(v2, a2);
  }
  return result;
}

uint64_t sub_19048AE1C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 200);
  if (v1) {
    return (*(uint64_t (**)(void))(**(void **)(v1 + 104) + 128))();
  }
  return result;
}

os_log_t sub_19048AE50()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Compass");
  qword_1E929D790 = (uint64_t)result;
  return result;
}

void sub_19048AE84(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

void sub_19048AEBC(uint64_t a1, uint64_t a2, long long *a3)
{
  uint64_t v5 = (os_unfair_lock_s *)(a1 + 44);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 44));
  long long v6 = *a3;
  *(void *)(a1 + 32) = *((void *)a3 + 2);
  *(_OWORD *)(a1 + 16) = v6;
  *(unsigned char *)(a1 + 40) = 1;

  os_unfair_lock_unlock(v5);
}

void sub_19048AF24(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

void sub_19048AF5C(uint64_t a1, uint64_t a2, long long *a3)
{
  uint64_t v5 = (os_unfair_lock_s *)(a1 + 140);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 140));
  long long v6 = *a3;
  long long v7 = a3[1];
  long long v8 = a3[3];
  *(_OWORD *)(a1 + 48) = a3[2];
  *(_OWORD *)(a1 + 64) = v8;
  *(_OWORD *)(a1 + 16) = v6;
  *(_OWORD *)(a1 + 32) = v7;
  long long v9 = a3[4];
  long long v10 = a3[5];
  long long v11 = a3[6];
  *(_DWORD *)(a1 + 128) = *((_DWORD *)a3 + 28);
  *(_OWORD *)(a1 + 96) = v10;
  *(_OWORD *)(a1 + 112) = v11;
  *(_OWORD *)(a1 + 80) = v9;
  *(unsigned char *)(a1 + 136) = 1;

  os_unfair_lock_unlock(v5);
}

void sub_19048AFDC(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19048B014(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

unsigned __int16 *sub_19048B0E8(unsigned __int16 *result, void *a2)
{
  unint64_t v2 = *((unsigned int *)result + 1);
  unint64_t v3 = *result + (unint64_t)result[1];
  if (v3 < v2) {
    unint64_t v2 = 0;
  }
  *(void *)&result[4 * (v3 - v2) + 4] = *a2;
  unsigned int v4 = result[1];
  unint64_t v5 = *((unsigned int *)result + 1);
  if (v5 <= v4)
  {
    unint64_t v6 = *result + 1;
    if (v6 < v5) {
      LOWORD(v5) = 0;
    }
    *os_log_t result = v6 - v5;
  }
  else
  {
    result[1] = v4 + 1;
  }
  return result;
}

uint64_t sub_19048B148(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3920);
    }
    long long v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3920);
      }
      long long v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const T &CMQueue<CMVector<float, 2>>::operator[](const size_t) const [T = CMVector<float, 2>]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[4 * (v4 - v5) + 4];
}

uint64_t sub_19048B344()
{
  if (qword_1EB3BEAB8 != -1) {
    dispatch_once(&qword_1EB3BEAB8, &unk_1EDFD1800);
  }
  return qword_1EB3BEAB0;
}

uint64_t sub_19048B388()
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1902BB1DC();
  if ((result & 0x10) != 0) {
    operator new();
  }
  return result;
}

void sub_19048B70C(_Unwind_Exception *a1)
{
  unint64_t v4 = (std::__shared_weak_count *)v1[15];
  if (v4) {
    sub_1902D8B58(v4);
  }
  sub_19048B77C(v2, 0);
  sub_1904DC240(v1);
  MEMORY[0x192FCC980](v1, 0x10F1C40EC541284);
  _Unwind_Resume(a1);
}

uint64_t sub_19048B77C(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_190569F3C(result);
    JUMPOUT(0x192FCC980);
  }
  return result;
}

void sub_19048B7CC(uint64_t a1, _OWORD *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  if (qword_1E929D7B8 != -1) {
    dispatch_once(&qword_1E929D7B8, &unk_1EDFD3200);
  }
  unint64_t v4 = qword_1E929D7B0;
  if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEBUG, "Received Bias Notification", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3200);
    }
    unint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLPressure::onBias(int, const CLPressureBias_Type::Notification &, const CLPressureBias_Type::NotificationData &)", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  *(_OWORD *)long long v7 = *a2;
  *(_OWORD *)&v7[13] = *(_OWORD *)((char *)a2 + 13);
  uint64_t v5 = sub_1902D6BD0();
  *(void *)buf = MEMORY[0x1E4F143A8];
  uint64_t v9 = 3221225472;
  long long v10 = sub_19048BA7C;
  unint64_t v11 = &unk_1E568DA20;
  uint64_t v12 = v3;
  v13[0] = *(_OWORD *)v7;
  *(_OWORD *)((char *)v13 + 13) = *(_OWORD *)&v7[13];
  sub_1902CE9BC(v5, (uint64_t)buf);
}

void *sub_19048B9D8(void *a1)
{
  *a1 = &unk_1EDFC7938;
  unint64_t v2 = (std::__shared_weak_count *)a1[15];
  if (v2) {
    sub_1902D8B58(v2);
  }
  sub_19048B77C(a1 + 5, 0);

  return sub_1904DC240(a1);
}

void sub_19048BA44(void *a1)
{
  sub_19048B9D8(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19048BA7C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  long long v2 = *(_OWORD *)(result + 40);
  *(_OWORD *)(v1 + 81) = *(_OWORD *)(result + 53);
  *(_OWORD *)(v1 + 68) = v2;
  if (*(float *)(result + 52) != 3.4028e38 || *(float *)(result + 44) != 0.0 || *(float *)(result + 48) != 0.0) {
    *(unsigned char *)(v1 + 49) = 1;
  }
  return result;
}

double sub_19048BACC(void *a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a2 <= 1)
  {
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD35C0);
    }
    uint64_t v5 = qword_1E929D780;
    if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = *a3;
      *(_DWORD *)buf = 134349056;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_INFO, "Setting pressure data update interval to %{public}f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D788 != -1) {
        dispatch_once(&qword_1E929D788, &unk_1EDFD35C0);
      }
      uint64_t v31 = *a3;
      *(_DWORD *)uint64_t v37 = 134349056;
      *(void *)&v37[4] = v31;
      double v32 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual CFTimeInterval CLPressure::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v32);
      if (v32 != (char *)buf) {
        free(v32);
      }
    }
    int v7 = 0;
    char v8 = 1;
    double v9 = 0.0;
    do
    {
      char v10 = v8;
      double v11 = sub_1902C1904((uint64_t)a1, v7);
      if (v9 == 0.0 || (v11 > 0.0 ? (BOOL v12 = v11 < v9) : (BOOL v12 = 0), v12)) {
        double v9 = v11;
      }
      char v8 = 0;
      int v7 = 1;
    }
    while ((v10 & 1) != 0);
    a1[7] = 0;
    if (a1[5])
    {
      double v13 = sub_1902C1904((uint64_t)a1, 1);
      uint64_t v14 = a1[5];
      float v15 = *(NSObject **)(v14 + 8);
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 3221225472;
      if (v13 == 0.0) {
        float v16 = sub_19056A478;
      }
      else {
        float v16 = sub_190569F90;
      }
      double v34 = v16;
      double v35 = &unk_1E568CF68;
      uint64_t v36 = v14;
      dispatch_sync(v15, buf);
    }
    if (!a1[14] && (sub_1902BB1DC() & 0x10) != 0)
    {
      int v20 = (void *)sub_1902DF4A8();
      *(void *)uint64_t v37 = 0x3100000020;
      v37[8] = 0;
      sub_19043791C(v20, (uint64_t)v37, (uint64_t *)buf);
      long long v21 = *(_OWORD *)buf;
      memset(buf, 0, sizeof(buf));
      uint64_t v22 = (std::__shared_weak_count *)a1[15];
      *((_OWORD *)a1 + 7) = v21;
      if (v22)
      {
        sub_1902D8B58(v22);
        if (*(void *)&buf[8]) {
          sub_1902D8B58(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      sub_1902CD864(a1[14], (uint64_t)sub_19048C0A8, (uint64_t)a1);
    }
    uint64_t v25 = a1[14];
    uint64_t v24 = a1 + 14;
    uint64_t v23 = v25;
    double v26 = rint(v9 * 1000000.0);
    if (v9 < 0.0) {
      uint64_t v27 = 0;
    }
    else {
      uint64_t v27 = (uint64_t)v26;
    }
    sub_1902CDC50(v23, v27);
    uint64_t v28 = sub_1902CDBA4(*v24, v9);
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD35C0);
    }
    double v29 = qword_1E929D780;
    if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134349056;
      *(void *)&uint8_t buf[4] = v28;
      _os_log_impl(&dword_1902AF000, v29, OS_LOG_TYPE_INFO, "Setting pressure batch interval to: %{public}ld us", buf, 0xCu);
    }
    if (!sub_1902D8400(115, 2)) {
      return v9;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD35C0);
    }
    float v19 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CFTimeInterval CLPressure::setPressureUpdateInterval()", "CoreLocation: %s\n", v19);
LABEL_51:
    if (v19 != (char *)buf) {
      free(v19);
    }
    return v9;
  }
  if (qword_1E929D788 != -1) {
    dispatch_once(&qword_1E929D788, &unk_1EDFD35C0);
  }
  uint64_t v18 = qword_1E929D780;
  if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_FAULT, "Unrecognized pressure notification %{public}d", buf, 8u);
  }
  double v9 = 0.0;
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD35C0);
    }
    *(_DWORD *)uint64_t v37 = 67240192;
    *(_DWORD *)&v37[4] = a2;
    float v19 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual CFTimeInterval CLPressure::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v19);
    goto LABEL_51;
  }
  return v9;
}

void sub_19048C0A8(uint64_t a1)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (IOHIDEventGetType() == 31)
  {
    IOHIDEventGetFloatValue();
    double v3 = v2;
    unint64_t TimeStamp = IOHIDEventGetTimeStamp();
    double v5 = sub_1902D8D34(TimeStamp);
    if (sub_1902C1904(a1, 0) != 0.0 || sub_1902C1904(a1, 1) != 0.0)
    {
      float v6 = v3;
      double v25 = v5;
      uint64_t v26 = LODWORD(v6);
      double v7 = *(double *)(a1 + 56);
      if (v7 == 0.0 || v5 - v7 > *(double *)(a1 + 104))
      {
        uint64_t v8 = *(void *)(a1 + 112);
        if (v8)
        {
          double v9 = (void *)(*(uint64_t (**)(uint64_t, __CFString *))(*(void *)v8 + 24))(v8, @"AppleVoltageDictionary");
          double v11 = objc_msgSend_objectForKeyedSubscript_(v9, v10, @"PRESSURE_TEMP");
          objc_msgSend_floatValue(v11, v12, v13);
          *(float *)(a1 + 64) = v14 / 100.0;

          BOOL v15 = v11 != 0;
        }
        else
        {
          BOOL v15 = 0;
        }
        if (qword_1E929D788 != -1) {
          dispatch_once(&qword_1E929D788, &unk_1EDFD35C0);
        }
        float v16 = qword_1E929D780;
        if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 67109120;
          LODWORD(v38) = v15;
          _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_DEBUG, "Pressure Temperature=%d", buf, 8u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D788 != -1) {
            dispatch_once(&qword_1E929D788, &unk_1EDFD35C0);
          }
          int v27 = 67109120;
          LODWORD(v28) = v15;
          uint64_t v24 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CLPressure::onPressureData(const CLMotionTypePressure &, const CLMotionTypeTimestamp &)", "CoreLocation: %s\n", v24);
          if (v24 != (char *)buf) {
            free(v24);
          }
        }
        *(double *)(a1 + 56) = v5;
      }
      int v17 = *(_DWORD *)(a1 + 64);
      HIDWORD(v26) = v17;
      if (*(unsigned char *)(a1 + 48))
      {
        sub_190395088(buf);
        sub_1903ADA70((uint64_t)buf);
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        v49 |= 1u;
        CFAbsoluteTime v47 = Current;
        sub_19040F40C(v48);
        uint64_t v19 = *(void *)(v48 + 8);
        *(unsigned char *)(v19 + 24) |= 1u;
        *(double *)(v19 + 8) = v5;
        uint64_t v20 = *(void *)(v48 + 8);
        *(unsigned char *)(v20 + 24) |= 2u;
        *(float *)(v20 + 16) = v6;
        uint64_t v21 = *(void *)(v48 + 8);
        *(unsigned char *)(v21 + 24) |= 4u;
        *(_DWORD *)(v21 + 20) = v17;
        sub_19039A590((PB::Base *)buf);
      }
      if (sub_1902C1904(a1, 0) != 0.0) {
        sub_1902D8BCC(a1, 0, (uint64_t)&v25, 16);
      }
      if (*(unsigned char *)(a1 + 49)) {
        *(float *)&uint64_t v26 = *(float *)&v26
      }
                       + (float)((float)-(float)(*(float *)(a1 + 76)
                                               - (float)(*(float *)(a1 + 72)
                                                       * fminf(*(float *)(a1 + 80), *((float *)&v26 + 1))))
                               / -1000.0);
      if (sub_1902C1904(a1, 1) != 0.0) {
        sub_1902D8BCC(a1, 1, (uint64_t)&v25, 16);
      }
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3200);
      }
      uint64_t v22 = qword_1E929D7B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316162;
        uint64_t v38 = "Pressure";
        __int16 v39 = 2048;
        double v40 = *(float *)&v26;
        __int16 v41 = 2048;
        double v42 = *((float *)&v26 + 1);
        __int16 v43 = 2048;
        double v44 = v25;
        __int16 v45 = 2048;
        double v46 = v6;
        _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_DEBUG, "Type,%s,pressure,%.6f,temperature,%.3f,timestamp,%f,rawPressure,%.6f", buf, 0x34u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D7B8 != -1) {
          dispatch_once(&qword_1E929D7B8, &unk_1EDFD3200);
        }
        int v27 = 136316162;
        uint64_t v28 = "Pressure";
        __int16 v29 = 2048;
        double v30 = *(float *)&v26;
        __int16 v31 = 2048;
        double v32 = *((float *)&v26 + 1);
        __int16 v33 = 2048;
        double v34 = v25;
        __int16 v35 = 2048;
        double v36 = v6;
        uint64_t v23 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CLPressure::onPressureData(const CLMotionTypePressure &, const CLMotionTypeTimestamp &)", "CoreLocation: %s\n", v23);
        if (v23 != (char *)buf) {
          free(v23);
        }
      }
    }
  }
}

void sub_19048C63C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_19039A590((PB::Base *)va);
  _Unwind_Resume(a1);
}

os_log_t sub_19048C658()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Sensors");
  qword_1E929D7B0 = (uint64_t)result;
  return result;
}

os_log_t sub_19048C688()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Pressure");
  qword_1E929D780 = (uint64_t)result;
  return result;
}

void sub_19048CA48(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (objc_msgSend_isWakeGestureAvailable(CMWakeGestureManager, a2, a3))
  {
    double v3 = [CMWakeGestureManager alloc];
    qword_1EB3BEAC8 = objc_msgSend_initWithQueue_(v3, v4, 0);
  }
  else
  {
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    double v5 = qword_1EB3BE810;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "CMWakeGestureManager is not supported on this platform!", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE818 != -1) {
        dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
      }
      float v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "+[CMWakeGestureManager sharedManager]_block_invoke", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
}

void sub_19048CF10()
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  size_t size = 0;
  if (!sysctlbyname("kern.bootargs", 0, &size, 0, 0))
  {
    uint64_t v0 = malloc_type_malloc(size, 0x100004077774924uLL);
    if (v0)
    {
      uint64_t v1 = v0;
      if (!sysctlbyname("kern.bootargs", v0, &size, 0, 0))
      {
        double v3 = objc_msgSend_stringWithUTF8String_(NSString, v2, (uint64_t)v1);
        long long v11 = 0u;
        long long v12 = 0u;
        long long v13 = 0u;
        long long v14 = 0u;
        uint64_t v5 = objc_msgSend_countByEnumeratingWithState_objects_count_(&unk_1EE001908, v4, (uint64_t)&v11, v16, 16);
        if (v5)
        {
          uint64_t v7 = v5;
          int v8 = 0;
          uint64_t v9 = *(void *)v12;
          do
          {
            for (uint64_t i = 0; i != v7; ++i)
            {
              if (*(void *)v12 != v9) {
                objc_enumerationMutation(&unk_1EE001908);
              }
              v8 |= objc_msgSend_containsString_(v3, v6, *(void *)(*((void *)&v11 + 1) + 8 * i));
            }
            uint64_t v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(&unk_1EE001908, v6, (uint64_t)&v11, v16, 16);
          }
          while (v7);
        }
        else
        {
          LOBYTE(v8) = 0;
        }
        byte_1E929DED8 = v8 & 1;
      }
      free(v1);
    }
  }
}

void sub_19048D12C(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(*(void *)(a1 + 32) + 140) = 0;
  id Weak = objc_loadWeak((id *)(*(void *)(a1 + 32) + 144));
  objc_storeWeak((id *)(*(void *)(a1 + 32) + 152), Weak);
  objc_loadWeak((id *)(*(void *)(a1 + 32) + 152));
  if (objc_opt_respondsToSelector()) {
    *(_DWORD *)(*(void *)(a1 + 32) + 140) |= 1u;
  }
  objc_loadWeak((id *)(*(void *)(a1 + 32) + 152));
  if (objc_opt_respondsToSelector()) {
    *(_DWORD *)(*(void *)(a1 + 32) + 140) |= 4u;
  }
  objc_loadWeak((id *)(*(void *)(a1 + 32) + 152));
  if (objc_opt_respondsToSelector()) {
    *(_DWORD *)(*(void *)(a1 + 32) + 140) |= 8u;
  }
  objc_loadWeak((id *)(*(void *)(a1 + 32) + 152));
  if (objc_opt_respondsToSelector()) {
    *(_DWORD *)(*(void *)(a1 + 32) + 140) |= 0x10u;
  }
  if (qword_1EB3BE818 != -1) {
    dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
  }
  double v3 = qword_1EB3BE810;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 140);
    *(_DWORD *)buf = 67109120;
    int v7 = v4;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "CMWakeGestureManagerDelegate selectors: %x", buf, 8u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMWakeGestureManager setDelegate:]_block_invoke", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
}

void sub_19048DE70(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_19048DEB0(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onPowerStateUpdated_, a1);
}

uint64_t sub_19048E240(uint64_t a1)
{
  if (!*(void *)(*(void *)(a1 + 32) + 24)) {
    operator new();
  }

  return sub_1905E37CC();
}

void sub_19048E368(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_19048E38C(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onWakeUpdated_, a1);
}

void sub_19048E398(uint64_t a1, uint64_t a2)
{
  double v2 = *(NSObject **)(a2 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_190491E3C;
  block[3] = &unk_1E568D118;
  block[4] = a2;
  dispatch_async(v2, block);
}

uint64_t sub_19048E720(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 32) + 24))
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(DarwinNotifyCenter, *(const void **)(a1 + 32), @"com.apple.CoreMotion.WakeGesturePreferencesChanged", 0);
    uint64_t v5 = objc_msgSend_defaultCenter(MEMORY[0x1E4F28C40], v3, v4);
    objc_msgSend_removeObserver_name_object_(v5, v6, *(void *)(a1 + 32), @"CMSendWakeGestureNotification", 0);
    uint64_t v7 = sub_1905E37CC();
    sub_1902CDE08(v7, 0, *(void *)(*(void *)(a1 + 32) + 24));
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = *(void *)(v8 + 24);
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      uint64_t v8 = *(void *)(a1 + 32);
    }
    *(void *)(v8 + 24) = 0;
  }

  return sub_1905E37CC();
}

void sub_19048EA68(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  double v2 = sub_1905E37CC();
  uint8_t v3 = *(unsigned char *)(a1 + 32);
  *(_DWORD *)buf = 1285;
  _OWORD buf[2] = v3;
  if (!sub_1905E5820(v2, (uint64_t)buf, 4))
  {
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    uint64_t v4 = qword_1EB3BE810;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "Unable to send display state", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE818 != -1) {
        dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
      }
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMWakeGestureManager setBacklightState:]_block_invoke", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
}

void sub_19048EC18(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE818 != -1) {
    dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
  }
  double v2 = qword_1EB3BE810;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v4 = *(unsigned __int8 *)(a1 + 48);
    int v5 = *(unsigned __int8 *)(a1 + 49);
    *(_DWORD *)buf = 67240704;
    int v8 = v3;
    __int16 v9 = 1026;
    int v10 = v4;
    __int16 v11 = 1026;
    int v12 = v5;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "setBacklightState,backlight,%{public}d,displayActive,%{public}u,prevDisplayActive,%{public}u", buf, 0x14u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    float v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMWakeGestureManager setBacklightState:]_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  if (!*(unsigned char *)(a1 + 48)) {
    *(_DWORD *)(*(void *)(a1 + 32) + 56) = 1;
  }
}

BOOL sub_19048EF0C(uint64_t a1)
{
  double v2 = sub_1905E37CC();
  double v3 = *(double *)(a1 + 40);
  __int16 v7 = 259;
  unint64_t v8 = (unint64_t)(v3 * 1000000.0);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_1905E5820(v2, (uint64_t)&v7, 10);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    double v5 = *(double *)(a1 + 48);
    __int16 v7 = 515;
    unint64_t v8 = (unint64_t)(v5 * 1000000.0);
    BOOL result = sub_1905E5820(v2, (uint64_t)&v7, 10);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL result = 0;
  }
  *(unsigned char *)(v4 + 24) = result;
  return result;
}

void sub_19048F040(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  double v2 = objc_opt_class();
  int v4 = objc_msgSend_toRaw_(v2, v3, *(void *)(a1 + 40));
  double v5 = sub_1905E37CC();
  double v6 = *(double *)(a1 + 48);
  buf[0] = 3;
  buf[1] = v4;
  *(void *)&_OWORD buf[2] = (unint64_t)(v6 * 1000000.0);
  if (!sub_1905E5820(v5, (uint64_t)buf, 10))
  {
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    __int16 v7 = qword_1EB3BE810;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 67240448;
      *(_DWORD *)&uint8_t buf[4] = v4;
      *(_WORD *)&uint8_t buf[8] = 2048;
      uint64_t v11 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_ERROR, "Error simulating gesture: %{public}u, delay,%f", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE818 != -1) {
        dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
      }
      __int16 v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMWakeGestureManager simulateGesture:after:]_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != buf) {
        free(v9);
      }
    }
  }
}

void sub_19048F508(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = sub_1905E37CC();
  if (!sub_1905E5DC8(v2, *(_DWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 36)))
  {
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    double v3 = qword_1EB3BE810;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_ERROR, "Wake Gesture: Error sending night stand control mode to detector", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE818 != -1) {
        dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
      }
      int v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMWakeGestureManager setNightStandWakeEnabled:withConfiguration:]_block_invoke", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
}

void sub_19048F71C(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 24))
  {
    int v3 = *(_DWORD *)(v1 + 140);
    if ((v3 & 0x10) != 0)
    {
      __int16 v9 = [CMWakeGestureEvent alloc];
      uint64_t v10 = *(void *)(a1 + 40);
      uint64_t v11 = mach_absolute_time();
      double v12 = sub_1902D8D34(v11);
      id v26 = (id)objc_msgSend_initWithState_type_orientation_timestamp_(v9, v13, v10, 2, 0, v12);
      id Weak = objc_loadWeak((id *)(*(void *)(a1 + 32) + 152));
      objc_msgSend_wakeGestureManager_didUpdateWakeGestureEvent_(Weak, v15, *(void *)(a1 + 32), v26);
    }
    else if ((v3 & 8) != 0)
    {
      id v16 = objc_loadWeak((id *)(v1 + 152));
      uint64_t v18 = *(void *)(a1 + 32);
      uint64_t v17 = *(void *)(a1 + 40);
      uint64_t v20 = mach_absolute_time();
      objc_msgSend_wakeGestureManager_didUpdateWakeGesture_orientation_detectedAt_(v16, v19, v18, v17, 0, v20);
    }
    else if ((v3 & 4) != 0)
    {
      id v21 = objc_loadWeak((id *)(v1 + 152));
      uint64_t v23 = *(void *)(a1 + 32);
      uint64_t v24 = *(void *)(a1 + 40);
      objc_msgSend_wakeGestureManager_didUpdateWakeGesture_orientation_(v21, v22, v23, v24, 0);
    }
    else if (v3)
    {
      id v4 = objc_loadWeak((id *)(v1 + 152));
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = *(void *)(a1 + 40);
      objc_msgSend_wakeGestureManager_didUpdateWakeGesture_(v4, v5, v6, v7);
    }
  }
  else
  {
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    uint64_t v8 = qword_1EB3BE810;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "Unable to invoke delegate. Please call startWakeGestureUpdates first.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE818 != -1) {
        dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
      }
      double v25 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMWakeGestureManager invokeDelegateWithState:]_block_invoke", "CoreLocation: %s\n", v25);
      if (v25 != (char *)buf) {
        free(v25);
      }
    }
  }
}

void sub_19048FD34(_Unwind_Exception *exception_object)
{
}

void sub_19048FF08()
{
}

uint64_t sub_190490284(uint64_t a1, const char *a2)
{
  v5[1] = *MEMORY[0x1E4F143B8];
  id v4 = @"spuLatencyMS";
  v5[0] = objc_msgSend_numberWithUnsignedLongLong_(NSNumber, a2, *(void *)(a1 + 32));
  return objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v2, (uint64_t)v5, &v4, 1);
}

uint64_t sub_190490380(uint64_t a1, const char *a2, uint64_t a3)
{
  v21[4] = *MEMORY[0x1E4F143B8];
  v20[0] = @"notification";
  id v4 = NSNumber;
  uint64_t v5 = objc_msgSend_state(*(void **)(a1 + 32), a2, a3);
  v21[0] = objc_msgSend_numberWithInt_(v4, v6, v5);
  v20[1] = @"whileDisplay";
  v21[1] = objc_msgSend_numberWithInt_(NSNumber, v7, *(unsigned int *)(a1 + 40));
  v20[2] = @"processName";
  uint64_t v10 = objc_msgSend_processInfo(MEMORY[0x1E4F28F80], v8, v9);
  v21[2] = objc_msgSend_processName(v10, v11, v12);
  v20[3] = @"type";
  uint64_t v13 = NSNumber;
  uint64_t v16 = objc_msgSend_type(*(void **)(a1 + 32), v14, v15);
  _DWORD v21[3] = objc_msgSend_numberWithInt_(v13, v17, v16);
  return objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v18, (uint64_t)v21, v20, 4);
}

void sub_190490A18(uint64_t a1)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  if (!objc_loadWeak((id *)(a1 + 40))) {
    return;
  }
  if (!*(void *)(*(void *)(a1 + 32) + 40)) {
    operator new();
  }
  sub_190541E40((unsigned char *)(a1 + 64), *(void *)(*(void *)(a1 + 32) + 40));
  uint64_t v2 = *(unsigned __int8 **)(*(void *)(a1 + 32) + 40);
  uint64_t v3 = v2[9];
  uint64_t v4 = v2[10];
  uint64_t v5 = v2[11];
  uint64_t v6 = v2[12];
  int v7 = v2[13];
  uint64_t v8 = v2[14];
  uint64_t v10 = objc_msgSend_stringForNotification_(CMWakeGestureManager, v9, v3);
  uint64_t v12 = objc_msgSend_stringForMode_(CMWakeGestureManager, v11, v6);
  uint64_t started = objc_msgSend_stringForStartPose_(CMWakeGestureManager, v13, v4);
  uint64_t v16 = objc_msgSend_stringForViewPose_(CMWakeGestureManager, v15, v5);
  if (v7)
  {
    int v17 = 1;
  }
  else
  {
    *(void *)(*(void *)(a1 + 32) + 64) = *(void *)(a1 + 48);
    int v17 = 2;
  }
  *(_DWORD *)(*(void *)(a1 + 32) + 56) = v17;
  if (qword_1EB3BE818 != -1) {
    dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
  }
  uint64_t v18 = qword_1EB3BE810;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67241730;
    *(_DWORD *)int v81 = v3;
    *(_WORD *)&v81[4] = 2114;
    *(void *)&v81[6] = v10;
    *(_WORD *)&v81[14] = 2114;
    *(void *)&v81[16] = v12;
    *(_WORD *)&v81[24] = 2114;
    *(void *)&v81[26] = started;
    __int16 v82 = 2114;
    uint64_t v83 = v16;
    __int16 v84 = 1026;
    int v85 = v7;
    __int16 v86 = 1026;
    int v87 = v8;
    _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_DEFAULT, "Gesture notification: %{public}d(%{public}@), Mode:%{public}@, Start:%{public}@, End:%{public}@, HostAwake, %{public}d, Inferred:%{public}u", buf, 0x3Cu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    int v72 = 67241730;
    *(_DWORD *)uint64_t v73 = v3;
    *(_WORD *)&v73[4] = 2114;
    *(void *)&v73[6] = v10;
    *(_WORD *)&v73[14] = 2114;
    *(void *)&v73[16] = v12;
    *(_WORD *)&v73[24] = 2114;
    *(void *)&v73[26] = started;
    __int16 v74 = 2114;
    uint64_t v75 = v16;
    __int16 v76 = 1026;
    int v77 = v7;
    __int16 v78 = 1026;
    int v79 = v8;
    uint64_t v62 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMWakeGestureManager onWakeUpdated:]_block_invoke", "CoreLocation: %s\n", v62);
    if (v62 != (char *)buf) {
      free(v62);
    }
  }
  uint64_t v19 = objc_opt_class();
  uint64_t v21 = objc_msgSend_toState_(v19, v20, v3);
  double Current = CFAbsoluteTimeGetCurrent();
  if (v21
    && ((double v24 = Current, v25 = *(void *)(a1 + 32), v21 != *(void *)(v25 + 48))
     || Current - *(double *)(v25 + 88) > 1.0))
  {
    if (!objc_msgSend_isEqual_(v12, v22, @"Nightstand")
      || *(unsigned char *)(*(void *)(a1 + 32) + 136))
    {
      if (objc_msgSend_isEqual_(v12, v28, @"Nightstand")) {
        uint64_t v29 = 7;
      }
      else {
        uint64_t v29 = 2;
      }
      double v30 = [CMWakeGestureEvent alloc];
      double v31 = sub_1902D8D34((unint64_t)*(double *)(a1 + 48));
      id v33 = (id)objc_msgSend_initWithState_type_orientation_timestamp_(v30, v32, v21, v29, v8, v31);
      uint64_t v34 = *(void *)(a1 + 32);
      int v35 = *(_DWORD *)(v34 + 140);
      if ((v35 & 0x10) != 0)
      {
        id Weak = objc_loadWeak((id *)(v34 + 152));
        objc_msgSend_wakeGestureManager_didUpdateWakeGestureEvent_(Weak, v38, *(void *)(a1 + 32), v33);
      }
      else if ((v35 & 8) != 0)
      {
        id v39 = objc_loadWeak((id *)(v34 + 152));
        objc_msgSend_wakeGestureManager_didUpdateWakeGesture_orientation_detectedAt_(v39, v40, *(void *)(a1 + 32), v21, v8, (unint64_t)*(double *)(a1 + 48));
      }
      else if ((v35 & 4) != 0)
      {
        id v42 = objc_loadWeak((id *)(v34 + 152));
        objc_msgSend_wakeGestureManager_didUpdateWakeGesture_orientation_(v42, v43, *(void *)(a1 + 32), v21, v8);
      }
      else
      {
        if ((v35 & 1) == 0)
        {
          if (qword_1EB3BE818 != -1) {
            dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
          }
          double v36 = qword_1EB3BE810;
          if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1902AF000, v36, OS_LOG_TYPE_FAULT, "No valid delegate found.", buf, 2u);
          }
          if (sub_1902D8400(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EB3BE818 != -1) {
              dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
            }
            LOWORD(v72) = 0;
            int v27 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 0, "-[CMWakeGestureManager onWakeUpdated:]_block_invoke", "CoreLocation: %s\n", v27);
            goto LABEL_22;
          }
          return;
        }
        id v44 = objc_loadWeak((id *)(v34 + 152));
        objc_msgSend_wakeGestureManager_didUpdateWakeGesture_(v44, v45, *(void *)(a1 + 32), v21);
      }
      sub_1902BAD40();
      uint64_t v46 = mach_absolute_time();
      sub_1902D8D34(v46);
      kdebug_trace();
      if (v6) {
        objc_msgSend_sendWakeTriggerAnalytics_withDisplay_(*(void **)(a1 + 32), v47, (uint64_t)v33, *(double *)(*(void *)(a1 + 32) + 104) <= 0.0);
      }
      uint64_t v48 = *(void *)(a1 + 32);
      if (*(unsigned char *)(v48 + 120))
      {
        v70[0] = @"mode";
        v71[0] = objc_msgSend_numberWithUnsignedChar_(NSNumber, v47, v6);
        v70[1] = @"event";
        v71[1] = objc_msgSend_numberWithUnsignedChar_(NSNumber, v49, v3);
        v70[2] = @"display";
        if (*(double *)(*(void *)(a1 + 32) + 104) <= 0.0) {
          float v51 = &unk_1EE001C18;
        }
        else {
          float v51 = &unk_1EE001C00;
        }
        v71[2] = v51;
        objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v50, (uint64_t)v71, v70, 3);
        PLLogTimeSensitiveRegisteredEvent();
        uint64_t v48 = *(void *)(a1 + 32);
      }
      *(double *)(v48 + 88) = v24;
      if (qword_1EB3BE818 != -1) {
        dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
      }
      float v52 = qword_1EB3BE810;
      if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_DEFAULT))
      {
        float v53 = objc_opt_class();
        uint64_t v55 = objc_msgSend_stringForGestureState_(v53, v54, v21);
        double v56 = sub_1902D8D34(**(void **)(a1 + 56));
        uint64_t v57 = mach_absolute_time();
        double v58 = sub_1902D8D34(v57);
        *(_DWORD *)buf = 138543874;
        *(void *)int v81 = v55;
        *(_WORD *)&v81[8] = 2050;
        *(double *)&v81[10] = v56;
        *(_WORD *)&v81[18] = 2050;
        *(double *)&v81[20] = v58;
        _os_log_impl(&dword_1902AF000, v52, OS_LOG_TYPE_DEFAULT, "Gesture state notified,%{public}@,eventTimestamp,%{public}f,currentTime,%{public}f", buf, 0x20u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE818 != -1) {
          dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
        }
        uint64_t v63 = objc_opt_class();
        uint64_t v65 = objc_msgSend_stringForGestureState_(v63, v64, v21);
        double v66 = sub_1902D8D34(**(void **)(a1 + 56));
        uint64_t v67 = mach_absolute_time();
        double v68 = sub_1902D8D34(v67);
        int v72 = 138543874;
        *(void *)uint64_t v73 = v65;
        *(_WORD *)&v73[8] = 2050;
        *(double *)&v73[10] = v66;
        *(_WORD *)&v73[18] = 2050;
        *(double *)&v73[20] = v68;
        uint64_t v69 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "-[CMWakeGestureManager onWakeUpdated:]_block_invoke", "CoreLocation: %s\n", v69);
        if (v69 != (char *)buf) {
          free(v69);
        }
      }
      uint64_t v61 = *(void *)(a1 + 32);
      if (*(unsigned char *)(v61 + 122) && *(double *)(v61 + 104) < 0.0 && v21 == 1)
      {
        objc_msgSend_playAlert((void *)v61, v59, v60);
        uint64_t v61 = *(void *)(a1 + 32);
      }
      *(void *)(v61 + 48) = v21;
      return;
    }
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    __int16 v41 = qword_1EB3BE810;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v41, OS_LOG_TYPE_DEBUG, "Skipping nightstand mode gestures for non-nightstand clients", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE818 == -1) {
        goto LABEL_21;
      }
      goto LABEL_78;
    }
  }
  else
  {
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    id v26 = qword_1EB3BE810;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v26, OS_LOG_TYPE_DEBUG, "Skipping redundant gesture update", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE818 == -1)
      {
LABEL_21:
        LOWORD(v72) = 0;
        int v27 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "-[CMWakeGestureManager onWakeUpdated:]_block_invoke", "CoreLocation: %s\n", v27);
LABEL_22:
        if (v27 != (char *)buf) {
          free(v27);
        }
        return;
      }
LABEL_78:
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
      goto LABEL_21;
    }
  }
}

id sub_1904915FC(uint64_t a1)
{
  id result = objc_loadWeak((id *)(a1 + 40));
  if (result) {
    *(_DWORD *)(*(void *)(a1 + 32) + 56) = 1;
  }
  return result;
}

void *sub_1904916F0(uint64_t a1)
{
  id result = objc_loadWeak((id *)(a1 + 40));
  if (result && *(_DWORD *)(a1 + 48) == -536870352 && *(_DWORD *)(*(void *)(a1 + 32) + 56) == 2)
  {
    id result = objc_msgSend_logWakeLatency(result, v3, v4);
    *(_DWORD *)(*(void *)(a1 + 32) + 56) = 1;
  }
  return result;
}

void sub_190491844(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE818 != -1) {
    dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
  }
  uint64_t v2 = qword_1EB3BE810;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_INFO, "Attempt re-enabling detected state recognition", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMWakeGestureManager(BiometricKit) reenableDetectedStateRecognition]_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEAD8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB3BEAD8))
  {
    qword_1EB3BEAD0 = &unk_1EE001920;
    __cxa_guard_release(&qword_1EB3BEAD8);
  }
  if ((objc_msgSend_containsObject_((void *)qword_1EB3BEAD0, v3, *(void *)(*(void *)(a1 + 32) + 112)) & 1) == 0)
  {
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    int v7 = qword_1EB3BE810;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      int v12 = 0;
      __int16 v13 = 2082;
      long long v14 = "";
      __int16 v15 = 2082;
      uint64_t v16 = "assert";
      __int16 v17 = 2081;
      uint64_t v18 = "[intendedClientList containsObject:fProcessName]";
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"This is not the SPI you are looking for\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE818 != -1) {
        dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
      }
    }
    uint64_t v8 = qword_1EB3BE810;
    if (os_signpost_enabled((os_log_t)qword_1EB3BE810))
    {
      *(_DWORD *)buf = 68289539;
      int v12 = 0;
      __int16 v13 = 2082;
      long long v14 = "";
      __int16 v15 = 2082;
      uint64_t v16 = "assert";
      __int16 v17 = 2081;
      uint64_t v18 = "[intendedClientList containsObject:fProcessName]";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "This is not the SPI you are looking for", "{\"msg%{public}.0s\":\"This is not the SPI you are looking for\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE818 != -1) {
        dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
      }
    }
    uint64_t v9 = qword_1EB3BE810;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      int v12 = 0;
      __int16 v13 = 2082;
      long long v14 = "";
      __int16 v15 = 2082;
      uint64_t v16 = "assert";
      __int16 v17 = 2081;
      uint64_t v18 = "[intendedClientList containsObject:fProcessName]";
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"This is not the SPI you are looking for\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
    __break(1u);
LABEL_29:
    dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    goto LABEL_10;
  }
  uint64_t v4 = sub_1905E37CC();
  *(_DWORD *)buf = 1797;
  if (sub_1905E5820(v4, (uint64_t)buf, 4)) {
    return;
  }
  if (qword_1EB3BE818 != -1) {
    goto LABEL_29;
  }
LABEL_10:
  uint64_t v5 = qword_1EB3BE810;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE810, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_ERROR, "Unable to send reenable-detected hint", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE818 != -1) {
      dispatch_once(&qword_1EB3BE818, &unk_1EDFC3768);
    }
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMWakeGestureManager(BiometricKit) reenableDetectedStateRecognition]_block_invoke", "CoreLocation: %s\n", v10);
    if (v10 != (char *)buf) {
      free(v10);
    }
  }
}

void sub_190491DA0(_Unwind_Exception *a1)
{
}

os_log_t sub_190491DC0()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "WakeGesture");
  qword_1EB3BE810 = (uint64_t)result;
  return result;
}

void sub_190491DF4()
{
}

__n128 sub_190491E1C(uint64_t a1, __n128 *a2)
{
  __n128 result = *a2;
  *(void *)(a1 + 24) = a2[1].n128_u64[0];
  *(__n128 *)(a1 + 8) = result;
  return result;
}

uint64_t sub_190491E3C(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_loadPreferences(*(void **)(a1 + 32), a2, a3);
}

void sub_190491E48(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_190491E80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_190491E90(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_190491EC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

CMOnBodyStatusManager *sub_190492E90()
{
  __n128 result = objc_alloc_init(CMOnBodyStatusManager);
  qword_1EB3BEAE0 = (uint64_t)result;
  return result;
}

uint64_t sub_190492F30(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startOnBodyStatusDetectionPrivateToQueue_withParameters_handler_, *(void *)(a1 + 40));
}

uint64_t sub_190492FB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_stopOnBodyStatusDetectionPrivate, a3);
}

void sub_190493048(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v5 = v4[1];
  if (!v5) {
    objc_msgSend_connect(v4, a2, a3);
  }
  uint64_t v6 = (std::__shared_weak_count *)operator new(0x70uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0DA0;
  sub_1902C3F54(__p, "kCLConnectionMessageOnBodyDetectionParams");
  MEMORY[0x192FCC420](&v6[1], __p, *(void *)(a1 + 40));
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  CLConnectionClient::sendMessage();
  if (v6) {
    sub_1902D8B58(v6);
  }
  if (!v5) {
    objc_msgSend_disconnect(*(void **)(a1 + 32), v7, v8);
  }
  sub_1902D8B58(v6);
}

void sub_19049312C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  sub_1902D8B58(v17);
  _Unwind_Resume(a1);
}

void sub_1904932A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904932F8(void *a1, CLConnectionMessage **a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v9 = (NSSet *)objc_msgSend_setWithObjects_(v4, v8, v5, v6, v7, 0);
  if (!*a2 || (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9)) == 0)
  {
    uint64_t v16 = a1[4];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_190493634;
    block[3] = &unk_1E568D2D0;
    block[4] = a1[6];
    uint64_t v18 = block;
    goto LABEL_6;
  }
  int v12 = DictionaryOfClasses;
  uint64_t v13 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v11, @"CMErrorMessage");
  uint64_t v15 = objc_msgSend_objectForKeyedSubscript_(v12, v14, @"CMOnBodyStatusData");
  if (v13)
  {
    *(unsigned char *)(a1[5] + 16) = 0;
    uint64_t v16 = a1[4];
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = sub_190493698;
    v24[3] = &unk_1E568D320;
    uint64_t v17 = a1[6];
    v24[4] = v13;
    v24[5] = v17;
    uint64_t v18 = v24;
LABEL_6:
    dispatch_async(v16, v18);
    return;
  }
  if (v15)
  {
    uint64_t v19 = a1[4];
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 3221225472;
    v23[2] = sub_190493710;
    _DWORD v23[3] = &unk_1E568D320;
    uint64_t v20 = a1[6];
    v23[4] = v15;
    v23[5] = v20;
    uint64_t v18 = v23;
    uint64_t v16 = v19;
    goto LABEL_6;
  }
  if (qword_1E929D988 != -1) {
    dispatch_once(&qword_1E929D988, &unk_1EDFD39C0);
  }
  uint64_t v21 = qword_1E929D990;
  if (os_log_type_enabled((os_log_t)qword_1E929D990, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_FAULT, "Unable to parse message when starting updates to queue!", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D988 != -1) {
      dispatch_once(&qword_1E929D988, &unk_1EDFD39C0);
    }
    uint64_t v22 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMOnBodyStatusManager connect]_block_invoke", "CoreLocation: %s\n", v22);
    if (v22 != (char *)buf) {
      free(v22);
    }
  }
}

uint64_t sub_190493634(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_190493698(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

uint64_t sub_190493710(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_190493728(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D988 != -1) {
    dispatch_once(&qword_1E929D988, &unk_1EDFD39C0);
  }
  uint64_t v3 = qword_1E929D990;
  if (os_log_type_enabled((os_log_t)qword_1E929D990, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = CLConnectionMessage::name(*a2);
    if (*(char *)(v4 + 23) >= 0) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = *(void *)v4;
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v8 = v5;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEBUG, "Default handler received message %s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D988 != -1) {
      dispatch_once(&qword_1E929D988, &unk_1EDFD39C0);
    }
    CLConnectionMessage::name(*a2);
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMOnBodyStatusManager connect]_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
}

void sub_190493C38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a12) {
    sub_1902D8B58(a12);
  }
  if (a22) {
    sub_1902D8B58(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_190493D88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a13) {
    sub_1902D8B58(a13);
  }
  _Unwind_Resume(exception_object);
}

os_log_t sub_190493DBC()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "OnBody");
  qword_1E929D990 = (uint64_t)result;
  return result;
}

void *sub_190493DEC@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  os_log_t result = sub_190493E50(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_190493E3C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_190493E50(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_190493EC4((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_190493EB0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_190493EC4(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_190493F1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19049400C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v15, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_1904942C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  int v12 = *(std::__shared_weak_count **)(v10 - 80);
  if (v12) {
    sub_1902D8B58(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_190494304(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  char v7 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v5, 0);
  if (*a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7)) != 0
    && (uint64_t v10 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage")) != 0)
  {
    int v13 = objc_msgSend_intValue(v10, v11, v12);
  }
  else
  {
    int v13 = 103;
  }
  if (qword_1E929D918 != -1) {
    dispatch_once(&qword_1E929D918, &unk_1EDFC3688);
  }
  long long v14 = qword_1E929D920;
  if (os_log_type_enabled((os_log_t)qword_1E929D920, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67240192;
    int v17 = v13;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D918 != -1) {
      dispatch_once(&qword_1E929D918, &unk_1EDFC3688);
    }
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMOdometerProxy _startDaemonConnection]_block_invoke", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
}

uint64_t sub_19049451C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v8 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v6, 0);
  uint64_t result = *a2;
  if (*a2)
  {
    uint64_t result = CLConnectionMessage::getDictionaryOfClasses((CLConnectionMessage *)result, v8);
    if (result)
    {
      uint64_t v11 = objc_msgSend_objectForKeyedSubscript_((void *)result, v10, @"CMOdometerGpsAvailability");
      unsigned int v16 = objc_msgSend_BOOLValue(v11, v12, v13);
      uint64_t result = *(void *)(a1 + 32);
      uint64_t v17 = v16;
      if (*(void *)(result + 40) != v16)
      {
        uint64_t v18 = objc_msgSend_odometer((void *)result, v14, v15);
        objc_msgSend_delegate(v18, v19, v20);
        char v23 = objc_opt_respondsToSelector();
        uint64_t result = *(void *)(a1 + 32);
        if (v23)
        {
          double v24 = objc_msgSend_odometer((void *)result, v21, v22);
          uint64_t v27 = objc_msgSend_delegate(v24, v25, v26);
          uint64_t v30 = objc_msgSend_odometer(*(void **)(a1 + 32), v28, v29);
          objc_msgSend_odometer_didUpdateGpsAvailability_(v27, v31, v30, v17);
          uint64_t result = *(void *)(a1 + 32);
        }
      }
      *(void *)(result + 40) = v17;
    }
  }
  return result;
}

void sub_190494610(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v5 = ExecutablePathFromPid;
    if (qword_1E929D918 != -1) {
      dispatch_once(&qword_1E929D918, &unk_1EDFC3688);
    }
    uint64_t v6 = qword_1E929D920;
    if (os_log_type_enabled((os_log_t)qword_1E929D920, OS_LOG_TYPE_INFO))
    {
      pid_t v7 = getpid();
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412802;
      uint64_t v11 = v5;
      __int16 v12 = 1024;
      pid_t v13 = v7;
      __int16 v14 = 2048;
      uint64_t v15 = v8;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_INFO, "CMOdometer client connection interrupt, %@, %d, %p", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D918 != -1) {
        dispatch_once(&qword_1E929D918, &unk_1EDFC3688);
      }
      getpid();
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMOdometerProxy _startDaemonConnection]_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
}

void sub_19049499C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a19) {
    sub_1902D8B58(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904949E0(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void **)(*(void *)(a1 + 32) + 32);
  if (v4)
  {
    uint64_t v6 = objc_msgSend_copy(v4, a2, a3);
    pid_t v7 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v8 = objc_opt_class();
    uint64_t v9 = objc_opt_class();
    uint64_t v10 = objc_opt_class();
    __int16 v12 = (NSSet *)objc_msgSend_setWithObjects_(v7, v11, v8, v9, v10, 0);
    if (!*(void *)a2) {
      goto LABEL_7;
    }
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v12);
    if (!DictionaryOfClasses) {
      goto LABEL_7;
    }
    uint64_t v15 = DictionaryOfClasses;
    uint64_t v16 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v14, @"CMOdometerDataObject");
    uint64_t v18 = objc_msgSend_objectForKeyedSubscript_(v15, v17, @"CMErrorMessage");
    if (v18)
    {
      uint64_t v21 = *(NSObject **)(*(void *)(a1 + 32) + 16);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = sub_190494DA4;
      block[3] = &unk_1E568D320;
      block[4] = v18;
      void block[5] = v6;
      uint64_t v22 = block;
      char v23 = v21;
    }
    else
    {
      if (!v16)
      {
        if (qword_1E929D918 != -1) {
          dispatch_once(&qword_1E929D918, &unk_1EDFC3688);
        }
        uint64_t v34 = qword_1E929D920;
        if (os_log_type_enabled((os_log_t)qword_1E929D920, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1902AF000, v34, OS_LOG_TYPE_FAULT, "Unable to parse kCLConnectionMessageOdometerUpdate message!", buf, 2u);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D918 != -1) {
            dispatch_once(&qword_1E929D918, &unk_1EDFC3688);
          }
          int v35 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "-[CMOdometerProxy _startOdometerUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v35);
          if (v35 != (char *)buf) {
            free(v35);
          }
        }
        goto LABEL_7;
      }
      objc_msgSend_totalDistance(*(void **)(a1 + 32), v19, v20);
      uint64_t v26 = (void *)MEMORY[0x1E4F1C9C8];
      if (v27 < 0.0)
      {
        objc_msgSend_timeIntervalSinceReferenceDate(MEMORY[0x1E4F1C9C8], v24, v25);
        objc_msgSend_setStartDate_(*(void **)(a1 + 32), v28, v29);
        objc_msgSend_setTotalDistance_(*(void **)(a1 + 32), v30, v31, 0.0);
        objc_msgSend_setAverageSpeed_(*(void **)(a1 + 32), v32, v33, 0.0);
        goto LABEL_7;
      }
      objc_msgSend_startDate(*(void **)(a1 + 32), v24, v25);
      uint64_t v38 = objc_msgSend_dateWithTimeIntervalSinceReferenceDate_(v26, v36, v37);
      id v39 = *(void **)(a1 + 32);
      id v42 = objc_msgSend_distance(v16, v40, v41);
      objc_msgSend_doubleValue(v42, v43, v44);
      double v46 = v45;
      objc_msgSend_totalDistance(v39, v47, v48);
      objc_msgSend_setTotalDistance_(v39, v50, v51, v46 + v49);
      float v54 = objc_msgSend_endDate(v16, v52, v53);
      objc_msgSend_timeIntervalSinceDate_(v54, v55, v38);
      double v59 = v58;
      double v60 = 0.0;
      if (v59 > 0.1)
      {
        objc_msgSend_totalDistance(*(void **)(a1 + 32), v56, v57, 0.0);
        double v60 = v61 / v59;
      }
      objc_msgSend_setAverageSpeed_(*(void **)(a1 + 32), v56, v57, v60);
      uint64_t v62 = *(void *)(a1 + 32);
      char v23 = *(NSObject **)(v62 + 16);
      v63[0] = MEMORY[0x1E4F143A8];
      v63[1] = 3221225472;
      v63[2] = sub_190494E38;
      v63[3] = &unk_1E568DCF8;
      v63[4] = v16;
      v63[5] = v62;
      v63[6] = v38;
      v63[7] = v6;
      uint64_t v22 = v63;
    }
    dispatch_async(v23, v22);
LABEL_7:
  }
}

void sub_190494DA4(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x192FCD2F0]();
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v7 = objc_msgSend_integerValue(*(void **)(a1 + 32), v5, v6);
  uint64_t v9 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v8, @"CMErrorDomain", v7, 0);
  (*(void (**)(uint64_t, void, uint64_t))(v4 + 16))(v4, 0, v9);
}

void sub_190494E38(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x192FCD2F0]();
  id v5 = (id)objc_msgSend_copy(*(void **)(a1 + 32), v3, v4);
  uint64_t v6 = NSNumber;
  objc_msgSend_averageSpeed(*(void **)(a1 + 40), v7, v8);
  uint64_t v11 = objc_msgSend_numberWithDouble_(v6, v9, v10);
  objc_msgSend_setAverageSpeed_(v5, v12, v11);
  pid_t v13 = NSNumber;
  objc_msgSend_totalDistance(*(void **)(a1 + 40), v14, v15);
  uint64_t v18 = objc_msgSend_numberWithDouble_(v13, v16, v17);
  objc_msgSend_setDistance_(v5, v19, v18);
  objc_msgSend_updateStartDate_(v5, v20, *(void *)(a1 + 48));
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_190495010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_1902D8B58(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_19049517C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_1902D8B58(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_190495330(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (v24) {
    sub_1902D8B58(v24);
  }
  _Unwind_Resume(exception_object);
}

void sub_190495374(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v10 = (NSSet *)objc_msgSend_setWithObjects_(v4, v9, v5, v6, v7, v8, 0);
  if (*a2)
  {
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v10);
    if (DictionaryOfClasses)
    {
      pid_t v13 = DictionaryOfClasses;
      __int16 v14 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v12, @"CMCyclingWorkoutDistanceDataArray");
      uint64_t v16 = objc_msgSend_objectForKeyedSubscript_(v13, v15, @"CMErrorMessage");
      if (v16)
      {
        uint64_t v19 = *(NSObject **)(*(void *)(a1 + 32) + 16);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = sub_1904957F8;
        block[3] = &unk_1E568D320;
        uint64_t v20 = *(void *)(a1 + 40);
        block[4] = v16;
        void block[5] = v20;
        uint64_t v21 = block;
        uint64_t v22 = v19;
LABEL_5:
        dispatch_async(v22, v21);
        return;
      }
      if (v14 && objc_msgSend_count(v14, v17, v18))
      {
        objc_msgSend_totalCyclingDistance(*(void **)(a1 + 32), v23, v24);
        if (v27 < 0.0)
        {
          Object = objc_msgSend_firstObject(v14, v25, v26);
          uint64_t v31 = objc_msgSend_endDate(Object, v29, v30);
          objc_msgSend_timeIntervalSinceReferenceDate(v31, v32, v33);
          objc_msgSend_setCyclingStartDate_(*(void **)(a1 + 32), v34, v35);
          objc_msgSend_setTotalCyclingDistance_(*(void **)(a1 + 32), v36, v37, 0.0);
        }
        long long v88 = 0u;
        long long v89 = 0u;
        long long v86 = 0u;
        long long v87 = 0u;
        uint64_t v38 = objc_msgSend_countByEnumeratingWithState_objects_count_(v14, v25, (uint64_t)&v86, v92, 16);
        if (v38)
        {
          uint64_t v41 = v38;
          uint64_t v42 = *(void *)v87;
          do
          {
            for (uint64_t i = 0; i != v41; ++i)
            {
              if (*(void *)v87 != v42) {
                objc_enumerationMutation(v14);
              }
              uint64_t v44 = *(void **)(*((void *)&v86 + 1) + 8 * i);
              double v45 = (void *)MEMORY[0x1E4F1C9C8];
              objc_msgSend_cyclingStartDate(*(void **)(a1 + 32), v39, v40);
              uint64_t v48 = objc_msgSend_dateWithTimeIntervalSinceReferenceDate_(v45, v46, v47);
              double v49 = *(void **)(a1 + 32);
              float v52 = objc_msgSend_distance(v44, v50, v51);
              objc_msgSend_doubleValue(v52, v53, v54);
              double v56 = v55;
              objc_msgSend_totalCyclingDistance(v49, v57, v58);
              objc_msgSend_setTotalCyclingDistance_(v49, v60, v61, v56 + v59);
              uint64_t v64 = objc_msgSend_endDate(v44, v62, v63);
              objc_msgSend_timeIntervalSinceDate_(v64, v65, v48);
              double v69 = v68;
              double v70 = 0.0;
              if (v69 > 0.1)
              {
                objc_msgSend_totalCyclingDistance(*(void **)(a1 + 32), v66, v67, 0.0);
                double v70 = v71 / v69;
              }
              uint64_t v72 = objc_msgSend_numberWithDouble_(NSNumber, v66, v67, v70);
              objc_msgSend_setAverageSpeed_(v44, v73, v72);
              __int16 v74 = NSNumber;
              objc_msgSend_totalCyclingDistance(*(void **)(a1 + 32), v75, v76);
              uint64_t v79 = objc_msgSend_numberWithDouble_(v74, v77, v78);
              objc_msgSend_setDistance_(v44, v80, v79);
              objc_msgSend_updateStartDate_(v44, v81, v48);
            }
            uint64_t v41 = objc_msgSend_countByEnumeratingWithState_objects_count_(v14, v39, (uint64_t)&v86, v92, 16);
          }
          while (v41);
        }
        uint64_t v22 = *(NSObject **)(*(void *)(a1 + 32) + 16);
        v85[0] = MEMORY[0x1E4F143A8];
        v85[1] = 3221225472;
        v85[2] = sub_190495870;
        v85[3] = &unk_1E568D320;
        uint64_t v82 = *(void *)(a1 + 40);
        v85[4] = v14;
        v85[5] = v82;
        uint64_t v21 = v85;
        goto LABEL_5;
      }
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFC36E8);
      }
      uint64_t v83 = off_1EB3BE880;
      if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v83, OS_LOG_TYPE_FAULT, "Unable to parse kCLConnectionMessageCyclingWorkoutDistanceUpdate message!", buf, 2u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE888 != -1) {
          dispatch_once(&qword_1EB3BE888, &unk_1EDFC36E8);
        }
        __int16 v84 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "-[CMOdometerProxy _startCyclingWorkoutDistanceUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v84);
        if (v84 != (char *)buf) {
          free(v84);
        }
      }
    }
  }
}

uint64_t sub_1904957F8(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

uint64_t sub_190495870(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_190495990(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v16) {
    sub_1902D8B58(v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_190495B48(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__teardown(*(void **)(*(void *)(a1 + 32) + 16), a2, a3);
}

uint64_t sub_190495F7C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_odometerProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v6 = *(void *)(a1 + 40);

  return objc_msgSend__startOdometerUpdatesWithHandler_(v4, v5, v6);
}

uint64_t sub_190496038(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = objc_msgSend_odometerProxy(*(void **)(a1 + 32), a2, a3);

  return objc_msgSend__stopOdometerUpdates(v3, v4, v5);
}

void sub_1904961D8(_Unwind_Exception *a1)
{
}

uint64_t sub_1904961F0(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_odometerProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__startCyclingWorkoutDistanceUpdatesWithHandler_, v5);
}

uint64_t sub_19049622C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_odometerProxy(*(void **)(a1 + 32), a2, a3);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = sub_1904962B0;
  _DWORD v7[3] = &unk_1E568DD48;
  v7[4] = *(void *)(a1 + 40);
  return objc_msgSend__startOdometerUpdatesWithHandler_(v4, v5, (uint64_t)v7);
}

uint64_t sub_1904962B0(uint64_t result, const char *a2, uint64_t a3)
{
  v6[1] = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16);
    return v3();
  }
  else if (a2)
  {
    uint64_t v4 = *(void *)(result + 32);
    v6[0] = a2;
    uint64_t v5 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], a2, (uint64_t)v6, 1);
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(v4 + 16))(v4, v5, 0);
  }
  return result;
}

void sub_190496498(_Unwind_Exception *a1)
{
}

uint64_t sub_1904964B0(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = objc_msgSend_odometerProxy(*(void **)(a1 + 32), a2, a3);

  return objc_msgSend__stopCyclingWorkoutDistanceUpdates(v3, v4, v5);
}

uint64_t sub_1904964DC(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = objc_msgSend_odometerProxy(*(void **)(a1 + 32), a2, a3);

  return objc_msgSend__stopOdometerUpdates(v3, v4, v5);
}

os_log_t sub_19049652C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Odometer");
  qword_1E929D920 = (uint64_t)result;
  return result;
}

void *sub_19049655C@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  os_log_t result = sub_1904965C0(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1904965AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1904965C0(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_190496634((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_190496620(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_190496634(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_19049668C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904966A8(void *a1, void *a2)
{
  uint64_t v4 = operator new(0x70uLL);
  v4[1] = 0;
  _DWORD v4[2] = 0;
  *uint64_t v4 = &unk_1EDFD0DA0;
  sub_1902C3F54(__p, "kCLConnectionMessageCyclingWorkoutDistanceUpdate");
  MEMORY[0x192FCC420](v4 + 3, __p, *a2);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_190496740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::__shared_weak_count::~__shared_weak_count(v15);
  operator delete(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_190497828(unsigned __int8 *a1, uint64_t a2)
{
  int v2 = *a1;
  switch(v2)
  {
    case 255:
      return 0;
    case 2:
      (*(void (**)(uint64_t, unsigned __int8 *))(*(void *)a2 + 24))(a2, a1);
      break;
    case 1:
      (*(void (**)(uint64_t, unsigned __int8 *))(*(void *)a2 + 16))(a2, a1);
      break;
  }
  return 1;
}

long double CLClientGetDistanceCoordinates(double a1, double a2, double a3, double a4)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEB10, memory_order_acquire) & 1) == 0)
  {
    double v8 = a4;
    double v9 = a2;
    double v6 = a3;
    double v7 = a1;
    int v5 = __cxa_guard_acquire(&qword_1EB3BEB10);
    a3 = v6;
    a1 = v7;
    a4 = v8;
    a2 = v9;
    if (v5)
    {
      qword_1EB3BEB30 = 0;
      unk_1EB3BEB38 = 0;
      xmmword_1EB3BEB20 = xmmword_190607A90;
      qword_1EB3BEB40 = 0x3FF0000000000000;
      __cxa_guard_release(&qword_1EB3BEB10);
      a3 = v6;
      a1 = v7;
      a4 = v8;
      a2 = v9;
    }
  }

  return sub_1905754A8((double *)&xmmword_1EB3BEB20, a1, a2, a3, a4, 0.0);
}

void CLClientGetDistanceHighPrecision(_OWORD *a1, _OWORD *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEB18, memory_order_acquire) & 1) == 0)
  {
    uint64_t v11 = a2;
    __int16 v12 = a1;
    int v10 = __cxa_guard_acquire(&qword_1EB3BEB18);
    a2 = v11;
    a1 = v12;
    if (v10)
    {
      qword_1EB3BEB60 = 0;
      unk_1EB3BEB68 = 0;
      *(_OWORD *)dbl_1EB3BEB50 = xmmword_190607A90;
      qword_1EB3BEB70 = 0x3FF0000000000000;
      __cxa_guard_release(&qword_1EB3BEB18);
      a2 = v11;
      a1 = v12;
    }
  }
  long long v2 = a1[7];
  v15[6] = a1[6];
  v15[7] = v2;
  v16[0] = a1[8];
  *(_OWORD *)((char *)v16 + 12) = *(_OWORD *)((char *)a1 + 140);
  long long v3 = a1[3];
  v15[2] = a1[2];
  v15[3] = v3;
  long long v4 = a1[5];
  v15[4] = a1[4];
  v15[5] = v4;
  long long v5 = a1[1];
  v15[0] = *a1;
  v15[1] = v5;
  long long v6 = a2[7];
  v13[6] = a2[6];
  v13[7] = v6;
  v14[0] = a2[8];
  *(_OWORD *)((char *)v14 + 12) = *(_OWORD *)((char *)a2 + 140);
  long long v7 = a2[3];
  v13[2] = a2[2];
  v13[3] = v7;
  long long v8 = a2[5];
  v13[4] = a2[4];
  v13[5] = v8;
  long long v9 = a2[1];
  v13[0] = *a2;
  v13[1] = v9;
  sub_190575584(dbl_1EB3BEB50, (uint64_t)v15, (uint64_t)v13);
}

CFStringRef CLClientCreateIso6709Notation(uint64_t a1)
{
  double v2 = *(double *)(a1 + 36);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  double v4 = *(double *)(a1 + 4);
  if (v2 >= 0.0) {
    return CFStringCreateWithFormat(v3, 0, @"%+08.4lf%+09.4lf%+08.3lf/", v4, *(void *)&v4, *(void *)(a1 + 12), *(void *)(a1 + 28));
  }
  else {
    return CFStringCreateWithFormat(v3, 0, @"%+08.4lf%+09.4lf/", v4, *(void *)(a1 + 4), *(void *)(a1 + 12));
  }
}

uint64_t sub_1904980E8(uint64_t a1, double a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *(double *)a1 = a2;
  *(void *)(a1 + 8) = 0x1000000000;
  if (qword_1EB3BE878 != -1) {
    dispatch_once(&qword_1EB3BE878, &unk_1EDFD1880);
  }
  double v4 = off_1EB3BE870;
  if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134217984;
    double v10 = a2;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEBUG, "[CMResampleAccessoryDeviceMotion] Constructed CMResampleAccessoryDeviceMotion. Set output sample period to: %.4f s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1880);
    }
    long long v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CMResampleAccessoryDeviceMotion::CMResampleAccessoryDeviceMotion(const CLMotionTypeTimestamp)", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  if (a2 < 0.005 || a2 > 0.05)
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1880);
    }
    long long v5 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      double v10 = a2;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_ERROR, "[CMResampleAccessoryDeviceMotion] Invalid output sample period: %.4f s", buf, 0xCu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1880);
      }
      long long v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "CMResampleAccessoryDeviceMotion::CMResampleAccessoryDeviceMotion(const CLMotionTypeTimestamp)", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  return a1;
}

uint64_t sub_190498414(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  double v4 = *(double *)a1;
  if (*(double *)a1 >= 0.005 && v4 <= 0.05)
  {
    long long v6 = (unsigned __int16 *)(a1 + 8);
    uint64_t v7 = *(unsigned __int16 *)(a1 + 10);
    if (!*(_WORD *)(a1 + 10))
    {
LABEL_15:
      uint64_t v19 = v6;
      uint64_t v20 = (_OWORD *)a2;
      goto LABEL_16;
    }
    double v8 = *(double *)(a2 + 48);
    uint64_t v9 = a1 + 16;
    uint64_t v10 = *(unsigned __int16 *)(a1 + 8);
    unint64_t v11 = v7 + v10 - 1;
    unint64_t v12 = *(unsigned int *)(a1 + 12);
    if (v11 >= v12) {
      uint64_t v13 = *(unsigned int *)(a1 + 12);
    }
    else {
      uint64_t v13 = 0;
    }
    if (v8 > *(double *)(v9 + ((v11 - v13) << 6) + 48))
    {
      double v14 = *(double *)(v9 + (v10 << 6) + 48);
      double v15 = v8 - v14;
      if (v8 - v14 > v4 + 0.1)
      {
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1880);
        }
        uint64_t v16 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v17 = *(void *)(v9 + ((unint64_t)*v6 << 6) + 48);
          uint64_t v18 = *(void *)(a2 + 48);
          *(_DWORD *)buf = 134218496;
          *(double *)&uint8_t buf[4] = v15;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v17;
          *(_WORD *)&buf[22] = 2048;
          *(void *)&buf[24] = v18;
          _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_DEBUG, "[CMResampleAccessoryDeviceMotion] Sample too far ahead by: %.6f s, last timestamp: %.6f s, this timestamp: %.6f s", buf, 0x20u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1880);
          }
          uint64_t v79 = *(void *)(v9 + ((unint64_t)*v6 << 6) + 48);
          uint64_t v80 = *(void *)(a2 + 48);
          *(_DWORD *)int v90 = 134218496;
          *(double *)&v90[4] = v15;
          *(_WORD *)&v90[12] = 2048;
          *(void *)&v90[14] = v79;
          __int16 v91 = 2048;
          uint64_t v92 = v80;
          int v81 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "BOOL CMResampleAccessoryDeviceMotion::feedDMData(const InputData &)", "CoreLocation: %s\n", v81);
          if (v81 != buf) {
            free(v81);
          }
        }
        *(_DWORD *)long long v6 = 0;
        goto LABEL_15;
      }
      if (v15 >= v4)
      {
        double v43 = v4 + v14;
        if (v4 + v14 >= v8) {
          return 1;
        }
        char v44 = 1;
        while (1)
        {
          unint64_t v45 = *(unsigned __int16 *)(a1 + 8) + (unint64_t)*(unsigned __int16 *)(a1 + 10) - 1;
          unint64_t v46 = *(unsigned int *)(a1 + 12);
          if (v45 < v46) {
            unint64_t v46 = 0;
          }
          uint64_t v47 = v9 + ((v45 - v46) << 6);
          double v48 = *(double *)(v47 + 48);
          if (v43 - v48 < 0.001) {
            break;
          }
          double v49 = (v43 - v48) / (v8 - v48);
          if (v49 < 0.0 || v49 > 1.0)
          {
            if (qword_1EB3BE888 != -1) {
              dispatch_once(&qword_1EB3BE888, &unk_1EDFD3140);
            }
            uint64_t v75 = off_1EB3BE880;
            if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1902AF000, v75, OS_LOG_TYPE_FAULT, "Assertion failed: interpolationRatio >= 0 && interpolationRatio <= 1, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Framework/CoreMotion/Accessory/CMResampleAccessoryDeviceMotion.cpp, line 150,Invalid interpolationRatio..", buf, 2u);
            }
            if (sub_1902D8400(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1EB3BE888 != -1) {
                dispatch_once(&qword_1EB3BE888, &unk_1EDFD3140);
              }
              *(_WORD *)int v90 = 0;
              uint64_t v76 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 0, "void CMResampleAccessoryDeviceMotion::interpolate(const InputData &)", "CoreLocation: %s\n", v76);
              if (v76 != buf) {
                free(v76);
              }
            }
          }
          unint64_t v51 = *(unsigned __int16 *)(a1 + 8) + (unint64_t)*(unsigned __int16 *)(a1 + 10) - 1;
          unint64_t v52 = *(unsigned int *)(a1 + 12);
          if (v51 < v52) {
            unint64_t v52 = 0;
          }
          uint64_t v53 = v9 + ((v51 - v52) << 6);
          float v54 = v49;
          float v89 = v54;
          float v55 = *(float *)(v53 + 36) + (float)((float)(*(float *)(a2 + 36) - *(float *)(v53 + 36)) * v54);
          float32x2_t v56 = vadd_f32(*(float32x2_t *)(v53 + 28), vmul_n_f32(vsub_f32(*(float32x2_t *)(a2 + 28), *(float32x2_t *)(v53 + 28)), v54));
          sub_1904D0B60((float32x4_t *)v53, (float32x4_t *)a2, (float32x4_t *)v90, v54);
          unint64_t v57 = *(unsigned __int16 *)(a1 + 8) + (unint64_t)*(unsigned __int16 *)(a1 + 10) - 1;
          unint64_t v58 = *(unsigned int *)(a1 + 12);
          if (v57 < v58) {
            unint64_t v58 = 0;
          }
          uint64_t v59 = v9 + ((v57 - v58) << 6);
          float v60 = *(float *)(v59 + 16) + sub_1904CF514((float *)v59);
          float v62 = v61 + *(float *)(v59 + 20);
          float v64 = v63 + *(float *)(v59 + 24);
          float v67 = v60 + (float)((float)((float)(*(float *)(a2 + 16) + sub_1904CF514((float *)a2)) - v60) * v89);
          float v68 = v62 + (float)((float)((float)(v65 + *(float *)(a2 + 20)) - v62) * v89);
          float v69 = v64 + (float)((float)((float)(v66 + *(float *)(a2 + 24)) - v64) * v89);
          float v70 = sub_1904CF514((float *)v90);
          double v71 = *(double *)(v59 + 48);
          double v72 = *(double *)(a2 + 48) - v71;
          *(_OWORD *)buf = *(_OWORD *)v90;
          *(float *)&uint8_t buf[16] = v67 - v70;
          *(float *)&buf[20] = v68 - v73;
          *(float *)&buf[24] = v69 - v74;
          *(float32x2_t *)&buf[28] = v56;
          *(float *)&buf[36] = v55;
          buf[40] = *(unsigned char *)(a2 + 40);
          *(_DWORD *)&unsigned char buf[44] = *(_DWORD *)(a2 + 44);
          long long v94 = COERCE_UNSIGNED_INT64(v71 + v72 * v49);
          if (v44) {
            *(_DWORD *)long long v6 = 0;
          }
          sub_190498DE8((unsigned __int16 *)(a1 + 8), buf);
          char v44 = 0;
          double v43 = v43 + *(double *)a1;
          uint64_t result = 1;
          if (v43 >= v8) {
            return result;
          }
        }
        long long v77 = *(_OWORD *)(v47 + 16);
        *(_OWORD *)buf = *(_OWORD *)v47;
        *(_OWORD *)&uint8_t buf[16] = v77;
        long long v78 = *(_OWORD *)(v47 + 48);
        *(_OWORD *)&uint8_t buf[32] = *(_OWORD *)(v47 + 32);
        long long v94 = v78;
        *(_DWORD *)long long v6 = 0;
        uint64_t v20 = buf;
        uint64_t v19 = (unsigned __int16 *)(a1 + 8);
LABEL_16:
        sub_190498DE8(v19, v20);
        return 1;
      }
      if (v12 == v7)
      {
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1880);
        }
        double v36 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_ERROR))
        {
          uint64_t v37 = *(void *)(a2 + 48);
          uint64_t v38 = *(unsigned __int16 *)(a1 + 8);
          uint64_t v39 = *(void *)(v9 + (v38 << 6) + 48);
          unint64_t v40 = v38 + *(unsigned __int16 *)(a1 + 10) - 1;
          unint64_t v41 = *(unsigned int *)(a1 + 12);
          if (v40 < v41) {
            unint64_t v41 = 0;
          }
          uint64_t v42 = *(void *)(v9 + ((v40 - v41) << 6) + 48);
          *(_DWORD *)buf = 134218496;
          *(void *)&uint8_t buf[4] = v37;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v39;
          *(_WORD *)&buf[22] = 2048;
          *(void *)&buf[24] = v42;
          _os_log_impl(&dword_1902AF000, v36, OS_LOG_TYPE_ERROR, "[CMResampleAccessoryDeviceMotion]:[feedDMData] Too many consecutive over-closely spaced sampled received. This suggests an input sampling rate anomaly. Input timestamp: %.4f s, First / last timestamp in the buffer : %.4f s / %.4f s . The resampling will still continue but in a non-ideal rate.", buf, 0x20u);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1880);
          }
          uint64_t v82 = *(void *)(a2 + 48);
          uint64_t v83 = *(unsigned __int16 *)(a1 + 8);
          uint64_t v84 = *(void *)(v9 + (v83 << 6) + 48);
          unint64_t v85 = v83 + *(unsigned __int16 *)(a1 + 10) - 1;
          unint64_t v86 = *(unsigned int *)(a1 + 12);
          if (v85 < v86) {
            unint64_t v86 = 0;
          }
          uint64_t v87 = *(void *)(v9 + ((v85 - v86) << 6) + 48);
          *(_DWORD *)int v90 = 134218496;
          *(void *)&v90[4] = v82;
          *(_WORD *)&v90[12] = 2048;
          *(void *)&v90[14] = v84;
          __int16 v91 = 2048;
          uint64_t v92 = v87;
          long long v88 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "BOOL CMResampleAccessoryDeviceMotion::feedDMData(const InputData &)", "CoreLocation: %s\n", v88);
          if (v88 != buf) {
            free(v88);
          }
        }
      }
      sub_190498DE8(v6, (_OWORD *)a2);
      return 0;
    }
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1880);
    }
    uint64_t v21 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = *(void *)(a2 + 48);
      uint64_t v23 = *(unsigned __int16 *)(a1 + 8);
      uint64_t v24 = *(void *)(v9 + (v23 << 6) + 48);
      unint64_t v25 = v23 + *(unsigned __int16 *)(a1 + 10) - 1;
      unint64_t v26 = *(unsigned int *)(a1 + 12);
      if (v25 < v26) {
        unint64_t v26 = 0;
      }
      uint64_t v27 = *(void *)(v9 + ((v25 - v26) << 6) + 48);
      *(_DWORD *)buf = 134218496;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v24;
      *(_WORD *)&buf[22] = 2048;
      *(void *)&buf[24] = v27;
      _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_ERROR, "[CMResampleAccessoryDeviceMotion]:[feedDMData] Invalid backwards or repeated timestamp, rejecting input. Input timestamp: %.4f s, buffer front: %.4f s, buffer back: %.4f s", buf, 0x20u);
    }
    int v28 = sub_1902D8400(115, 0);
    uint64_t result = 0;
    if (v28)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1880);
      }
      uint64_t v29 = *(void *)(a2 + 48);
      uint64_t v30 = *(unsigned __int16 *)(a1 + 8);
      uint64_t v31 = *(void *)(v9 + (v30 << 6) + 48);
      unint64_t v32 = v30 + *(unsigned __int16 *)(a1 + 10) - 1;
      unint64_t v33 = *(unsigned int *)(a1 + 12);
      if (v32 < v33) {
        unint64_t v33 = 0;
      }
      uint64_t v34 = *(void *)(v9 + ((v32 - v33) << 6) + 48);
      *(_DWORD *)int v90 = 134218496;
      *(void *)&v90[4] = v29;
      *(_WORD *)&v90[12] = 2048;
      *(void *)&v90[14] = v31;
      __int16 v91 = 2048;
      uint64_t v92 = v34;
      uint64_t v35 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "BOOL CMResampleAccessoryDeviceMotion::feedDMData(const InputData &)", "CoreLocation: %s\n", v35);
      if (v35 != buf) {
        free(v35);
      }
      return 0;
    }
  }
  return result;
}

unsigned __int16 *sub_190498DE8(unsigned __int16 *result, _OWORD *a2)
{
  unint64_t v2 = *((unsigned int *)result + 1);
  unint64_t v3 = *result + (unint64_t)result[1];
  if (v3 < v2) {
    unint64_t v2 = 0;
  }
  double v4 = &result[32 * (v3 - v2)];
  *(_OWORD *)(v4 + 4) = *a2;
  long long v6 = a2[1];
  long long v5 = a2[2];
  *(_OWORD *)(v4 + 28) = a2[3];
  *(_OWORD *)(v4 + 12) = v6;
  *(_OWORD *)(v4 + 20) = v5;
  unsigned int v7 = result[1];
  unint64_t v8 = *((unsigned int *)result + 1);
  if (v8 <= v7)
  {
    unint64_t v9 = *result + 1;
    if (v9 < v8) {
      LOWORD(v8) = 0;
    }
    *uint64_t result = v9 - v8;
  }
  else
  {
    result[1] = v7 + 1;
  }
  return result;
}

uint64_t sub_190498E5C(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onAmbientPressure_, a1);
}

uint64_t sub_190498E68(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onCompensatedAmbientPressure_, a1);
}

uint64_t sub_190498E74(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onAccelerometer_, a1);
}

uint64_t sub_190498E80(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onGyro_, a1);
}

uint64_t sub_190498E8C(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onFactoryGyro_, a1);
}

uint64_t sub_190498E98(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onFactoryGyroTemperature_, a1);
}

uint64_t sub_190498EA4(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onMagnetometer_, a1);
}

uint64_t sub_190498EB0(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(uint64_t (**)(uint64_t *, void))(a2 + 448);
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 8);
    int v4 = *(_DWORD *)(result + 16);
    uint64_t v5 = *(void *)result;
    return v2(&v3, *(void *)(a2 + 456));
  }
  return result;
}

uint64_t sub_190498EF8(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(uint64_t (**)(uint64_t *, void))(a2 + 472);
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 8);
    int v4 = *(_DWORD *)(result + 16);
    uint64_t v5 = *(void *)result;
    return v2(&v3, *(void *)(a2 + 480));
  }
  return result;
}

uint64_t sub_190498F40(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(uint64_t (**)(uint64_t *, void))(a2 + 496);
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 8);
    int v4 = *(_DWORD *)(result + 16);
    uint64_t v5 = *(void *)result;
    return v2(&v3, *(void *)(a2 + 504));
  }
  return result;
}

uint64_t sub_190498F88(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(uint64_t (**)(_OWORD *, void))(a2 + 520);
  if (v2)
  {
    long long v3 = *(_OWORD *)(result + 56);
    void v5[2] = *(_OWORD *)(result + 40);
    v5[3] = v3;
    v5[4] = *(_OWORD *)(result + 72);
    uint64_t v6 = *(void *)(result + 88);
    long long v4 = *(_OWORD *)(result + 24);
    v5[0] = *(_OWORD *)(result + 8);
    v5[1] = v4;
    uint64_t v7 = *(void *)result;
    char v8 = *(unsigned char *)(result + 100);
    return v2(v5, *(void *)(a2 + 528));
  }
  return result;
}

uint64_t *sub_190498FF0(uint64_t *result, uint64_t a2)
{
  unint64_t v2 = *(uint64_t (**)(void, uint64_t *, void))(a2 + 592);
  if (v2)
  {
    uint64_t v3 = *result;
    return (uint64_t *)v2(0, &v3, *(void *)(a2 + 600));
  }
  return result;
}

uint64_t sub_19049902C(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onDeviceMotionForKeyboardMotion_, a1);
}

void sub_190499330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_190499348(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), sel_deallocPrivate, a3);
}

uint64_t sub_1904994FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setAccelerometerUpdateIntervalPrivate_, a3);
}

uint64_t sub_190499634(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startAccelerometerUpdatesPrivateToQueue_withHandler_, 0);
}

uint64_t sub_1904996D4(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startAccelerometerUpdatesPrivateToQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_190499760(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_stopAccelerometerUpdatesPrivate(*(void **)(a1 + 32), a2, a3);
}

void sub_1904998FC(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_190499A78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setAmbientPressureUpdateIntervalPrivate_, a3);
}

uint64_t sub_190499B24(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startAmbientPressureUpdatesPrivateToQueue_withHandler_, 0);
}

uint64_t sub_190499BC4(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startAmbientPressureUpdatesPrivateToQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_190499C50(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_stopAmbientPressureUpdatesPrivate(*(void **)(a1 + 32), a2, a3);
}

void sub_19049A01C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
}

void sub_19049A074(uint64_t a1, uint64_t a2)
{
  long long v4 = [CMAmbientPressureData alloc];
  LODWORD(v5) = *(_DWORD *)(a2 + 8);
  LODWORD(v6) = *(_DWORD *)(a2 + 12);
  unint64_t v9 = objc_msgSend_initWithPressure_andTimestamp_(v4, v7, v8, v5, v6, *(double *)a2);
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  v13[2] = sub_19049A114;
  v13[3] = &unk_1E568D320;
  uint64_t v10 = *(void **)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  v13[4] = v9;
  v13[5] = v11;
  objc_msgSend_addOperationWithBlock_(v10, v12, (uint64_t)v13);
}

uint64_t sub_19049A114(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_19049A12C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

void sub_19049A39C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (*(char *)(v45 - 73) < 0) {
    operator delete(v44[204]);
  }
  if (a44 < 0) {
    operator delete(*v44);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19049A464(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setCompensatedAmbientPressureUpdateIntervalPrivate_, a3);
}

uint64_t sub_19049A510(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startCompensatedAmbientPressureUpdatesPrivateToQueue_withHandler_, 0);
}

uint64_t sub_19049A5B0(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startCompensatedAmbientPressureUpdatesPrivateToQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_19049A63C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_stopCompensatedAmbientPressureUpdatesPrivate, a3);
}

void sub_19049A868(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void sub_19049AAA8(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_19049AC2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setGyroUpdateIntervalPrivate_, a3);
}

uint64_t sub_19049AD64(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startGyroUpdatesPrivateToQueue_withHandler_, 0);
}

uint64_t sub_19049AE04(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startGyroUpdatesPrivateToQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_19049AE90(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_stopGyroUpdatesPrivate(*(void **)(a1 + 32), a2, a3);
}

void sub_19049B034(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_19049B404(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = objc_msgSend_attitudeReferenceFrame(v3, a2, a3);

  return MEMORY[0x1F4181798](v3, sel_startDeviceMotionUpdatesPrivateUsingReferenceFrame_toQueue_withHandler_, v4);
}

uint64_t sub_19049B4CC(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startDeviceMotionUpdatesPrivateUsingReferenceFrame_toQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_19049B574(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startDeviceMotionUpdatesPrivateUsingReferenceFrame_toQueue_withHandler_, *(void *)(a1 + 56));
}

uint64_t sub_19049B600(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_stopDeviceMotionUpdatesPrivate(*(void **)(a1 + 32), a2, a3);
}

void sub_19049B8D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a19) {
    sub_1902D8B58(a19);
  }
  if (a22) {
    sub_1902D8B58(a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19049B910(uint64_t a1, char *a2, uint64_t a3)
{
  if (!a2
    || ((uint64_t v5 = objc_msgSend_objectForKeyedSubscript_(a2, a2, @"CMErrorMessage"),
         uint64_t v7 = objc_msgSend_objectForKeyedSubscript_(a2, v6, @"CMReturnCode"),
         !v5)
      ? (BOOL v8 = v7 == 0)
      : (BOOL v8 = 1),
        v8 || (objc_msgSend_BOOLValue(v7, a2, a3) & 1) == 0))
  {
    unint64_t v9 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], a2, a3);
    objc_msgSend_removeItemAtURL_error_(v9, v10, *(void *)(a1 + 32), 0);
  }
  uint64_t v11 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v11();
}

void sub_19049BA48(uint64_t a1)
{
  unint64_t v2 = (void *)sub_1904DF754();
  uint64_t v5 = objc_msgSend_vendor(v2, v3, v4);
  uint64_t v7 = objc_msgSend_proxyForService_(v5, v6, @"CLGyroCalibrationDatabase");
  if (objc_msgSend_syncgetWipeDatabase(v7, v8, v9))
  {
    *(void *)(*(void *)(a1 + 32) + 264) = 0x3F847AE147AE147BLL;
    *(_DWORD *)(*(void *)(a1 + 32) + 296) = 19;
    uint64_t v10 = [CLDeviceMotionProperties alloc];
    unint64_t v12 = objc_msgSend_initWithMode_(v10, v11, *(unsigned int *)(*(void *)(a1 + 32) + 296));
    if (!*(void *)(*(void *)(a1 + 32) + 256)) {
      operator new();
    }

    uint64_t v13 = sub_1902B35C0();
    uint64_t v14 = *(void *)(a1 + 32);
    uint64_t v15 = *(void *)(v14 + 256);
    double v16 = *(double *)(v14 + 264);
    sub_1902E0374(v13, v15, v16);
  }
}

void sub_19049BB80(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_19049BCB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setMagnetometerUpdateIntervalPrivate_, a3);
}

uint64_t sub_19049BDF4(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startMagnetometerUpdatesPrivateToQueue_withHandler_, 0);
}

uint64_t sub_19049BE94(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startMagnetometerUpdatesPrivateToQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_19049BF20(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_stopMagnetometerUpdatesPrivate(*(void **)(a1 + 32), a2, a3);
}

void sub_19049C0C4(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_19049C214(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setShowsDeviceMovementDisplayPrivate_, *(unsigned __int8 *)(a1 + 40));
}

void sub_19049C6BC(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_19049C6E0(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setAccelerometerDataCallback_info_interval_, *(void *)(a1 + 40));
}

uint64_t sub_19049C6F4(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setAccelerometerDataCallback_info_interval_, *(void *)(a1 + 40));
}

void sub_19049C95C(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_19049C980(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setGyroDataCallback_info_interval_, *(void *)(a1 + 40));
}

uint64_t sub_19049C994(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setGyroDataCallback_info_interval_, *(void *)(a1 + 40));
}

void sub_19049CBFC(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_19049CC20(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setMagnetometerDataCallback_info_interval_, *(void *)(a1 + 40));
}

uint64_t sub_19049CC34(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setMagnetometerDataCallback_info_interval_, *(void *)(a1 + 40));
}

uint64_t sub_19049CCC0(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setDeviceMotionCallback_info_interval_fsync_, *(void *)(a1 + 40));
}

void sub_19049D028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23,uint64_t a24,uint64_t a25,uint64_t a26,id location)
{
  objc_destroyWeak(v27);
  objc_destroyWeak(&location);
  objc_destroyWeak(&a23);
  _Unwind_Resume(a1);
}

void *sub_19049D078(uint64_t a1)
{
  uint64_t result = objc_loadWeak((id *)(a1 + 32));
  if (result)
  {
    unint64_t v2 = (void *)result[1];
    uint64_t v3 = v2[72];
    v2[72] = 0;
    if (v3)
    {
      sub_19051309C(v3);
      objc_msgSend_setFDisplayGravityHandler_(v2, v4, 0);
      sub_190512FF4(v3);
      JUMPOUT(0x192FCC980);
    }
  }
  return result;
}

void sub_19049D0F8(_Unwind_Exception *a1)
{
  uint64_t v3 = sub_190512FF4(v1);
  MEMORY[0x192FCC980](v3, 0x1020C407EC6A881);
  _Unwind_Resume(a1);
}

void sub_19049D120(uint64_t a1, uint64_t a2)
{
}

void sub_19049D12C(uint64_t a1)
{
}

id sub_19049D134(uint64_t a1)
{
  to[6] = *(id *)MEMORY[0x1E4F143B8];
  uint64_t v1 = (id *)(a1 + 32);
  id result = objc_loadWeak((id *)(a1 + 32));
  if (result)
  {
    uint64_t v3 = result;
    objc_copyWeak(to, v1);
    objc_msgSend_updateDeviceMotionMode(v3, v4, v5);
    operator new();
  }
  return result;
}

void sub_19049D26C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location, uint64_t a11, char a12)
{
}

double sub_19049D2B8(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  double result = *(double *)(a2 + 40);
  *(double *)(a1 + 40) = result;
  return result;
}

void sub_19049D2F0(uint64_t a1)
{
}

uint64_t sub_19049D2F8(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1EDFC8BB0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  if (sub_1902CD6B0())
  {
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFC20C0);
    }
    double v6 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "[CLIspDataVisitor] setting up oscar callback", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFC20C0);
      }
      __int16 v12 = 0;
      BOOL v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "CLIspDataVisitor::CLIspDataVisitor()", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
    uint64_t v3 = sub_1902D6BD0();
    uint64_t v4 = v11;
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    uint64_t v5 = sub_19049D6D0;
    goto LABEL_15;
  }
  if ((sub_1902CD6B0() & 2) != 0)
  {
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFC20C0);
    }
    unint64_t v2 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "[CLIspDataVisitor] setting up devmotion3 callback", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFC20C0);
      }
      __int16 v12 = 0;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "CLIspDataVisitor::CLIspDataVisitor()", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    uint64_t v3 = sub_1902D6BD0();
    uint64_t v4 = v10;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    uint64_t v5 = sub_19049DAC4;
LABEL_15:
    _DWORD v4[2] = v5;
    v4[3] = &unk_1E568CF68;
    v4[4] = a1;
    sub_1902CDE98(v3, (uint64_t)v4);
  }
  return a1;
}

void sub_19049D690(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (std::__shared_weak_count *)v1[6];
  if (v3) {
    sub_1902D8B58(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)v1[4];
  if (v4) {
    sub_1902D8B58(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)v1[2];
  if (v5) {
    sub_1902D8B58(v5);
  }
  _Unwind_Resume(exception_object);
}

void sub_19049D6D0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unint64_t v2 = (void *)sub_1902DF4A8();
  uint64_t v5 = 0xE0000FF00;
  char v6 = 0;
  sub_19043791C(v2, (uint64_t)&v5, (uint64_t *)&v7);
  long long v3 = v7;
  long long v7 = 0uLL;
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  *(_OWORD *)(v1 + 8) = v3;
  if (v4)
  {
    sub_1902D8B58(v4);
    if (*((void *)&v7 + 1)) {
      sub_1902D8B58(*((std::__shared_weak_count **)&v7 + 1));
    }
  }
  sub_1902CD864(*(void *)(v1 + 8), (uint64_t)sub_19049D758, v1);
}

void sub_19049D758()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  IOHIDEventGetVendorDefinedData();
  if (qword_1E929D700 != -1) {
    dispatch_once(&qword_1E929D700, &unk_1EDFD4360);
  }
  uint64_t v0 = qword_1E929D6F0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "Empty payload", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD4360);
    }
    uint64_t v1 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "static void CLIspDataVisitor::onOscarData(void *, void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v1);
    if (v1 != (char *)buf) {
      free(v1);
    }
  }
}

void sub_19049DAC4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unint64_t v2 = (void *)sub_1902DF4A8();
  uint64_t v5 = 0x10000FF0CLL;
  char v6 = 0;
  sub_19043791C(v2, (uint64_t)&v5, (uint64_t *)&v7);
  long long v3 = v7;
  long long v7 = 0uLL;
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  *(_OWORD *)(v1 + 8) = v3;
  if (v4)
  {
    sub_1902D8B58(v4);
    if (*((void *)&v7 + 1)) {
      sub_1902D8B58(*((std::__shared_weak_count **)&v7 + 1));
    }
  }
  sub_1902CD864(*(void *)(v1 + 8), (uint64_t)sub_19049DB4C, v1);
}

void sub_19049DB4C()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  IOHIDEventGetVendorDefinedData();
  if (qword_1E929D700 != -1) {
    dispatch_once(&qword_1E929D700, &unk_1EDFD4360);
  }
  uint64_t v0 = qword_1E929D6F0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "Empty payload", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD4360);
    }
    uint64_t v1 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "static void CLIspDataVisitor::onCMAData(void *, void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v1);
    if (v1 != (char *)buf) {
      free(v1);
    }
  }
}

uint64_t sub_19049DD04(uint64_t a1)
{
  *(void *)a1 = &unk_1EDFC8BB0;
  uint64_t v2 = sub_1902D6BD0();
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = sub_19049DDD8;
  _DWORD v7[3] = &unk_1E568CF68;
  v7[4] = a1;
  sub_1902CDE98(v2, (uint64_t)v7);

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    sub_1902D8B58(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4) {
    sub_1902D8B58(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5) {
    sub_1902D8B58(v5);
  }
  return a1;
}

void sub_19049DDD8(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void **)(a1 + 32);
  if (qword_1EB3BE898 != -1) {
    dispatch_once(&qword_1EB3BE898, &unk_1EDFC20C0);
  }
  uint64_t v2 = off_1EB3BE890;
  if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "[CLIspDataVisitor] closing HidInterfaces", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFC20C0);
    }
    char v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual CLIspDataVisitor::~CLIspDataVisitor()_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  uint64_t v3 = (std::__shared_weak_count *)v1[2];
  v1[1] = 0;
  v1[2] = 0;
  if (v3) {
    sub_1902D8B58(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)v1[4];
  v1[3] = 0;
  v1[4] = 0;
  if (v4) {
    sub_1902D8B58(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)v1[6];
  v1[5] = 0;
  v1[6] = 0;
  if (v5) {
    sub_1902D8B58(v5);
  }
}

void sub_19049DFA0(uint64_t a1)
{
  sub_19049DD04(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19049DFD8(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 56);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(result + 16))(result, a2 + 1, 54);
  }
  return result;
}

uint64_t sub_19049DFF8(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE898 != -1) {
    dispatch_once(&qword_1EB3BE898, &unk_1EDFC20C0);
  }
  uint64_t v4 = off_1EB3BE890;
  if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void *)(a2 + 1);
    uint64_t v6 = *(void *)(a2 + 9);
    *(_DWORD *)buf = 134218240;
    uint64_t v10 = v5;
    __int16 v11 = 2048;
    uint64_t v12 = v6;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "[CLIspDataVisitor] TimeSync visit machTimestamp,%llu,oscarTimestamp,%llu", buf, 0x16u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFC20C0);
    }
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLIspDataVisitor::visitTimeSync(const CMMotionCoprocessorReply::TimeSync *)", "CoreLocation: %s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  uint64_t result = *(void *)(a1 + 64);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, void))(result + 16))(result, *(void *)(a2 + 1), *(void *)(a2 + 9));
  }
  return result;
}

uint64_t sub_19049E1EC()
{
  return IOHIDEventGetVendorDefinedData();
}

void sub_19049E3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_19049E3F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 560))
  {
    *(unsigned char *)(v1 + 560) = 0;
    uint64_t v3 = sub_1902D6BD0();
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    _DWORD v4[2] = sub_19049E488;
    v4[3] = &unk_1E568D118;
    v4[4] = *(void *)(a1 + 32);
    sub_1902CE9BC(v3, (uint64_t)v4);
  }
}

void sub_19049E488(uint64_t a1, const char *a2)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 560))
  {
    *(unsigned char *)(v2 + 560) = 1;
    v12[0] = @"CMSidebandSensorFusionEnable";
    uint64_t v3 = a1 + 32;
    v13[0] = objc_msgSend_numberWithBool_(NSNumber, a2, *(unsigned __int8 *)(*(void *)(a1 + 32) + 560));
    v12[1] = @"CMSidebandSensorFusionLatency";
    v13[1] = objc_msgSend_numberWithBool_(NSNumber, v4, *(unsigned __int8 *)(*(void *)v3 + 561));
    id v12[2] = @"CMSidebandSensorFusionSnoop";
    v13[2] = objc_msgSend_numberWithBool_(NSNumber, v5, *(unsigned __int8 *)(*(void *)v3 + 562));
    uint64_t v11 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v6, (uint64_t)v13, v12, 3);
    sub_1904A6C38("kCLConnectionMessageSidebandSensorFusionEnable", &v11, &v9);
    long long v7 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessageSync();
    if (v8) {
      sub_1902D8B58(v8);
    }
    if (v7) {
      sub_1902D8B58(v7);
    }
    if (v10) {
      sub_1902D8B58(v10);
    }
  }
}

void sub_19049E5E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a15) {
    sub_1902D8B58(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_19049EFE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,uint64_t a33,uint64_t a34,char a35)
{
  if (a15) {
    sub_1902D8B58(a15);
  }
  if (a32) {
    sub_1902D8B58(a32);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19049F07C(uint64_t a1, const char *a2)
{
  uint64_t result = objc_msgSend_setSidebandSensorFusionEnable_measureLatency_withSnoopHandler_(*(void **)(a1 + 32), a2, *(unsigned __int8 *)(a1 + 56), *(unsigned __int8 *)(a1 + 57), *(void *)(a1 + 40));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = result;
  return result;
}

void sub_19049F7A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
}

void sub_19049F800(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(*(void *)(a1 + 32) + 568))
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFC2080);
    }
    uint64_t v3 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "[MotionManager] CLIspDataVisitor reset", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFC2080);
      }
      __int16 v10 = 0;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMMotionManager setSidebandTimeSyncHandler:]_block_invoke", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    operator new();
  }
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = sub_19049FA90;
  _DWORD v7[3] = &unk_1E568DF18;
  uint64_t v9 = *(void *)(a1 + 48);
  long long v8 = *(_OWORD *)(a1 + 32);
  uint64_t v4 = *(void *)(v8 + 568);
  uint64_t v5 = *(void **)(v4 + 64);
  *(void *)(v4 + 64) = objc_msgSend_copy(v7, a2, a3);
}

void sub_19049FA64(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0xA1C408C38BA87);
  _Unwind_Resume(a1);
}

intptr_t sub_19049FA90(void *a1, uint64_t a2, uint64_t a3)
{
  *(void *)(*(void *)(a1[5] + 8) + 24) = a2;
  *(void *)(*(void *)(a1[6] + 8) + 24) = a3;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1[4] + 1088));
}

uint64_t sub_19049FAB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_190555C5C(*(void *)(*(void *)(a1 + 32) + 8) + 24, (const char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), a3);
}

uint64_t sub_19049FACC(uint64_t result, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 32) + 568);
  if (v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void **)(v3 + 64);
    *(void *)(v3 + 64) = objc_msgSend_copy(*(void **)(result + 40), a2, a3);

    uint64_t v6 = *(void *)(v4 + 32);
    uint64_t result = *(void *)(v6 + 568);
    if (!*(void *)(result + 56) && !*(void *)(result + 64))
    {
      *(void *)(v6 + 568) = 0;
      long long v7 = *(uint64_t (**)(void))(*(void *)result + 8);
      return v7();
    }
  }
  return result;
}

void sub_19049FC00(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if ((objc_msgSend_isDeviceMotionActive(*(void **)(a1 + 32), a2, a3) & 1) != 0
    || (uint64_t v4 = *(void *)(a1 + 40), *(void *)(v4 + 512)))
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFC2080);
    }
    uint64_t v5 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "DeviceMotion is active.  Cannot set power conservation mode", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFC2080);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMMotionManager setPowerConservationMode:]_block_invoke", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    *(_DWORD *)(v4 + 584) = *(_DWORD *)(a1 + 48);
  }
}

void sub_1904A0024(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_1904A0048(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setNotificationCallback_info_, *(void *)(a1 + 40));
}

uint64_t sub_1904A0058(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setNotificationCallback_info_, 0);
}

uint64_t sub_1904A0134(uint64_t a1, const char *a2, uint64_t a3)
{
  if (!*(void *)(a1 + 32))
  {
    uint64_t v12 = objc_msgSend_currentHandler(MEMORY[0x1E4F28B00], a2, a3);
    objc_msgSend_handleFailureInMethod_object_file_lineNumber_description_(v12, v13, *(void *)(a1 + 56), *(void *)(a1 + 40), @"CMMotionManager.mm", 2764, @"Invalid parameter not satisfying: %@", @"queue");
  }
  if (!*(void *)(a1 + 48))
  {
    uint64_t v14 = objc_msgSend_currentHandler(MEMORY[0x1E4F28B00], a2, a3);
    objc_msgSend_handleFailureInMethod_object_file_lineNumber_description_(v14, v15, *(void *)(a1 + 56), *(void *)(a1 + 40), @"CMMotionManager.mm", 2765, @"Invalid parameter not satisfying: %@", @"handler");
  }
  uint64_t result = objc_msgSend_isDeviceMotionAvailable(*(void **)(a1 + 40), a2, a3);
  if ((result & 1) == 0)
  {
    double v16 = objc_msgSend_currentHandler(MEMORY[0x1E4F28B00], v5, v6);
    uint64_t result = objc_msgSend_handleFailureInMethod_object_file_lineNumber_description_(v16, v17, *(void *)(a1 + 56), *(void *)(a1 + 40), @"CMMotionManager.mm", 2767, @"Device motion is unavailable on this platform");
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v8 = *(void **)(v7 + 624);
  if (v8 != *(void **)(a1 + 32))
  {

    uint64_t result = (uint64_t)*(id *)(a1 + 32);
    *(void *)(v7 + 624) = result;
  }
  uint64_t v9 = *(void **)(v7 + 616);
  if (v9 != *(void **)(a1 + 48))
  {

    uint64_t result = objc_msgSend_copy(*(void **)(a1 + 48), v10, v11);
    *(void *)(v7 + 616) = result;
  }
  return result;
}

void sub_1904A02E0(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void **)(v1 + 624);
  if (v2)
  {

    *(void *)(v1 + 624) = 0;
  }
  uint64_t v3 = *(void **)(v1 + 616);
  if (v3)
  {

    *(void *)(v1 + 616) = 0;
  }
}

uint64_t sub_1904A10AC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1904A13B0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1904A1DC0(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void, float))(a1[8] + 16))(a1[8], a1[4], a1[5], a1[7], *(float *)(a1[6] + 712));
}

uint64_t sub_1904A22F8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1904A25D0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

uint64_t sub_1904A25E8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_1904A28DC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1904A2BD4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1904A2C6C(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_willResignActivePrivate_, *(void *)(a1 + 40));
}

void sub_1904A2FC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  sub_1902D8B58(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_1904A3868(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startFactoryGyroUpdatesPrivateToQueue_atUpdateInterval_withHandler_residualHandler_, *(void *)(a1 + 40));
}

uint64_t sub_1904A3924(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startFactoryGyroUpdatesPrivateToQueue_atUpdateInterval_withHandler_residualHandler_, *(void *)(a1 + 40));
}

uint64_t sub_1904A39E0(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startFactoryGyroUpdatesPrivateToQueue_atUpdateInterval_withHandler_residualHandler_, *(void *)(a1 + 40));
}

uint64_t sub_1904A3A70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_stopFactoryGyroUpdatesPrivate, a3);
}

uint64_t sub_1904A3B1C(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startDeviceMotionUpdatesForKeyboardMotionPrivateToQueue_withGravityDeltaThreshold_notificationFrequency_andHandler_, *(void *)(a1 + 40));
}

uint64_t sub_1904A3BAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_stopDeviceMotionUpdatesForKeyboardMotionPrivate, a3);
}

void sub_1904A55A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p)
{
  if (v34) {
    operator delete(v34);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1904A5714(uint64_t a1)
{
  return (*(uint64_t (**)(double))(*(void *)(*(void *)(a1 + 32) + 688) + 16))(0.0);
}

uint64_t sub_1904A5734(uint64_t a1)
{
  return (*(uint64_t (**)(double))(*(void *)(*(void *)(a1 + 32) + 688) + 16))(0.0);
}

uint64_t sub_1904A5754(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_1904A5DA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  MEMORY[0x192FCC980](v5, 0x81C4018A671A6);
  sub_19047E7E8((uint64_t)va);
  _Unwind_Resume(a1);
}

double sub_1904A6238(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v6 = a6;
  float v7 = a5;
  float v8 = a4;
  float v9 = a3;
  float v10 = a2;
  float v11 = a1;
  uint64_t v12 = 0;
  float v39 = a1;
  float v40 = a2;
  float v41 = a3;
  float v13 = 0.0;
  do
  {
    float v13 = v13 + (float)(*(float *)((char *)&v39 + v12) * *(float *)((char *)&v39 + v12));
    v12 += 4;
  }
  while (v12 != 12);
  if (sqrtf(v13) > 0.00000011921)
  {
    uint64_t v14 = 0;
    float v15 = 0.0;
    do
    {
      float v15 = v15 + (float)(*(float *)((char *)&v39 + v14) * *(float *)((char *)&v39 + v14));
      v14 += 4;
    }
    while (v14 != 12);
    float v16 = sqrtf(v15);
    float v11 = v11 / v16;
    float v10 = a2 / v16;
    float v9 = a3 / v16;
  }
  uint64_t v17 = 0;
  float v39 = a4;
  float v40 = a5;
  float v18 = 0.0;
  float v41 = a6;
  do
  {
    float v18 = v18 + (float)(*(float *)((char *)&v39 + v17) * *(float *)((char *)&v39 + v17));
    v17 += 4;
  }
  while (v17 != 12);
  if (sqrtf(v18) > 0.00000011921)
  {
    uint64_t v19 = 0;
    float v20 = 0.0;
    do
    {
      float v20 = v20 + (float)(*(float *)((char *)&v39 + v19) * *(float *)((char *)&v39 + v19));
      v19 += 4;
    }
    while (v19 != 12);
    float v21 = sqrtf(v20);
    float v8 = a4 / v21;
    float v7 = a5 / v21;
    float v6 = a6 / v21;
  }
  float v22 = (float)((float)(v9 * v6) + (float)(v10 * v7)) + (float)(v11 * v8);
  float v23 = 1.0;
  if (v22 < 1.0)
  {
    float v23 = -1.0;
    if (v22 > -1.0) {
      float v23 = (float)((float)(v9 * v6) + (float)(v10 * v7)) + (float)(v11 * v8);
    }
  }
  *(float *)&double result = acosf(v23);
  if (*(float *)&result < 0.7854)
  {
    uint64_t v25 = 0;
    float v39 = (float)(v10 * v6) - (float)(v9 * v7);
    float v40 = (float)(v9 * v8) - (float)(v11 * v6);
    float v41 = (float)(v11 * v7) - (float)(v10 * v8);
    float v26 = 0.0;
    do
    {
      float v26 = v26 + (float)(*(float *)((char *)&v39 + v25) * *(float *)((char *)&v39 + v25));
      v25 += 4;
    }
    while (v25 != 12);
    if (sqrtf(v26) >= 1.0) {
      goto LABEL_34;
    }
    uint64_t v27 = 0;
    v38[0] = (float)(v10 * v6) - (float)(v9 * v7);
    v38[1] = (float)(v9 * v8) - (float)(v11 * v6);
    float v28 = 0.0;
    v38[2] = (float)(v11 * v7) - (float)(v10 * v8);
    do
    {
      float v28 = v28 + (float)(v38[v27] * v38[v27]);
      ++v27;
    }
    while (v27 != 3);
    float v29 = sqrtf(v28);
    float v30 = -1.0;
    if (v29 > -1.0)
    {
LABEL_34:
      uint64_t v31 = 0;
      v37[0] = (float)(v10 * v6) - (float)(v9 * v7);
      v37[1] = (float)(v9 * v8) - (float)(v11 * v6);
      float v32 = 0.0;
      _OWORD v37[2] = (float)(v11 * v7) - (float)(v10 * v8);
      do
      {
        float v32 = v32 + (float)(v37[v31] * v37[v31]);
        ++v31;
      }
      while (v31 != 3);
      float v33 = sqrtf(v32);
      float v30 = 1.0;
      if (v33 < 1.0)
      {
        uint64_t v34 = 0;
        v36[0] = (float)(v10 * v6) - (float)(v9 * v7);
        v36[1] = (float)(v9 * v8) - (float)(v11 * v6);
        float v35 = 0.0;
        v36[2] = (float)(v11 * v7) - (float)(v10 * v8);
        do
        {
          float v35 = v35 + (float)(v36[v34] * v36[v34]);
          ++v34;
        }
        while (v34 != 3);
        float v30 = sqrtf(v35);
      }
    }
    *(float *)&double result = asinf(v30);
  }
  return result;
}

uint64_t sub_1904A64C4(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)(*(void *)(a1 + 32) + 1024) + 16))(*(void *)(*(void *)(a1 + 32) + 1024), a1 + 40, 0);
}

os_log_t sub_1904A661C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Pressure");
  qword_1E929D780 = (uint64_t)result;
  return result;
}

uint64_t sub_1904A664C(uint64_t a1)
{
  return a1;
}

void sub_1904A6678(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 8));

  JUMPOUT(0x192FCC980);
}

id *sub_1904A66C4(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 8);
  uint64_t v2 = (id *)operator new(0x10uLL);
  id *v2 = &unk_1EDFC1EB8;
  objc_copyWeak(v2 + 1, v1);
  return v2;
}

void sub_1904A6718(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EDFC1EB8;
  objc_copyWeak((id *)(a2 + 8), (id *)(a1 + 8));
}

void sub_1904A6744(uint64_t a1)
{
}

void sub_1904A674C(id *a1)
{
  objc_destroyWeak(a1 + 1);

  operator delete(a1);
}

void sub_1904A6788(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (id *)(a1 + 8);
  if (objc_loadWeak((id *)(a1 + 8)))
  {
    uint64_t v4 = [CMDisplayGravity alloc];
    long long v5 = *(_OWORD *)(a2 + 16);
    v12[0] = *(_OWORD *)a2;
    v12[1] = v5;
    id v12[2] = *(_OWORD *)(a2 + 32);
    uint64_t v7 = objc_msgSend_initWithDisplayGravity_timestamp_(v4, v6, (uint64_t)v12, *(double *)(a2 + 48));
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = sub_1904A68CC;
    block[3] = &unk_1EDFC34E8;
    objc_copyWeak(&v8, v3);
    float v9 = (void *)v7;
    objc_copyWeak(v11, &v8);
    v11[1] = v9;
    dispatch_async(MEMORY[0x1E4F14428], block);
    objc_destroyWeak(&v8);
    objc_destroyWeak(v11);
  }
}

uint64_t sub_1904A6880(uint64_t a1, uint64_t a2)
{
  if (sub_1903885B4(a2, (uint64_t)&unk_1EDFC26D8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_1904A68C0()
{
  return &unk_1EDFC26D8;
}

void sub_1904A68CC(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(a1 + 32));
  if (Weak && (long long v5 = (void *)Weak[1], objc_msgSend_fDisplayGravityHandler(v5, v3, v4)))
  {
    uint64_t v8 = objc_msgSend_fDisplayGravityHandler(v5, v6, v7);
    id v9 = *(id *)(a1 + 40);
    float v10 = *(void (**)(uint64_t, id))(v8 + 16);
    v10(v8, v9);
  }
  else
  {
    float v11 = *(void **)(a1 + 40);
  }
}

void sub_1904A695C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
}

void sub_1904A6994(uint64_t a1)
{
}

void *sub_1904A699C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1904A6A20(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_190512FF4(result);
    JUMPOUT(0x192FCC980);
  }
  return result;
}

os_log_t sub_1904A6A70()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "AOP");
  qword_1E929D6F0 = (uint64_t)result;
  return result;
}

void sub_1904A6AA0(uint64_t a1, uint64_t a2)
{
  sub_1904A6AE8(&v2, a2);
}

void sub_1904A6AE8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1904A6B50(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904A6B8C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904A6BC4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1904A6BF4(uint64_t a1, uint64_t a2)
{
  if (sub_1903885B4(a2, (uint64_t)&unk_1EDFC71F8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_1904A6C38@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  float v6 = operator new(0x70uLL);
  uint64_t result = sub_1904A6C9C(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1904A6C88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1904A6C9C(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_1904A6D10((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_1904A6CFC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1904A6D10(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1904A6D68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904A6D88(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904A6DC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void *sub_1904A6DCC(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    sub_190347AC8();
  }
  return operator new(24 * a1);
}

void sub_1904A6E18(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904A6E50(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_1904A6E80(uint64_t a1, uint64_t a2)
{
  if (sub_1903885B4(a2, (uint64_t)&unk_1EDFC72C8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_1904A6EC8(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904A6F00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_1904A6F10(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904A6F48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_1904A6FCC(_Unwind_Exception *a1)
{
}

void sub_1904A7884(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10A0C40538029D6);
  _Unwind_Resume(a1);
}

void sub_1904A9F30(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x1020C4055877F28);
  _Unwind_Resume(a1);
}

void sub_1904AA8F8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1904AA944(uint64_t result, uint64_t a2)
{
  if (result) {
    return MEMORY[0x1F4181798](a2, sel__feedAccessoryConfig_, result);
  }
  return result;
}

uint64_t sub_1904AA958(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel__feedAccessoryInEarStatus_, a1);
}

uint64_t sub_1904AA964(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__startHeadTracking, a3);
}

void sub_1904AB218(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_1904AB26C(uint64_t result, uint64_t a2)
{
  if (result) {
    return MEMORY[0x1F4181798](a2, sel__feedSourceDeviceIMU_, result);
  }
  return result;
}

uint64_t sub_1904AB280(uint64_t result, uint64_t a2)
{
  if (result) {
    return MEMORY[0x1F4181798](a2, sel__feedAccessoryDeviceMotion_, result);
  }
  return result;
}

uint64_t sub_1904AB294(uint64_t a1, void *a2, uint64_t a3)
{
  char v5 = *(unsigned char **)(a1 + 32);
  if (v5[505])
  {
    objc_sync_enter(*(id *)(a1 + 32));
    float v6 = *(uint64_t **)(*(void *)(a1 + 32) + 648);
    id v9 = (int *)objc_msgSend_motionActivity(a2, v7, v8);
    sub_190458500(v6, v9);
    objc_sync_exit(v5);
  }
  float v10 = (int *)objc_msgSend_motionActivity(a2, (const char *)a2, a3);
  int v11 = *v10;
  uint64_t v12 = *(void **)(a1 + 32);
  objc_sync_enter(v12);
  uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!v10[2]) {
    sub_19058AF28(v13 + 5216, (uint64_t)v10);
  }
  sub_190560AE0(*(void *)(v13 + 37488), v10);
  uint64_t v14 = *(void *)(a1 + 32);
  uint64_t v15 = *(void *)(v14 + 240);
  if (v15)
  {
    int v16 = *(_DWORD *)(v14 + 264);
    if ((v16 > 0xB || ((1 << v16) & 0xC06) == 0) && v11 <= 0xB && ((1 << v11) & 0xC06) != 0)
    {
      sub_19050B3B0((double *)(v15 + 32), @"staticActivityStateDuration");
      uint64_t v14 = *(void *)(a1 + 32);
      int v16 = *(_DWORD *)(v14 + 264);
    }
    BOOL v20 = v16 > 0xB || ((1 << v16) & 0xC06) == 0;
    if (!v20 && (v11 > 0xB || ((1 << v11) & 0xC06) == 0))
    {
      sub_19050B590((double *)(*(void *)(v14 + 240) + 32), @"staticActivityStateDuration");
      uint64_t v14 = *(void *)(a1 + 32);
      int v16 = *(_DWORD *)(v14 + 264);
    }
    if (v16 > 51)
    {
      if (v16 == 52 || v16 == 56) {
        goto LABEL_40;
      }
    }
    else
    {
      if (!v16) {
        goto LABEL_30;
      }
      if (v16 == 5) {
        goto LABEL_40;
      }
    }
    if ((v16 & 0xFFFFFFFE) == 0xA) {
      goto LABEL_40;
    }
LABEL_30:
    if (v11 > 51)
    {
      if (v11 != 52 && v11 != 56) {
        goto LABEL_37;
      }
    }
    else
    {
      if (!v11) {
        goto LABEL_40;
      }
      if (v11 != 5)
      {
LABEL_37:
        if ((v11 & 0xFFFFFFFE) != 0xA) {
          goto LABEL_40;
        }
      }
    }
    sub_19050B3B0((double *)(*(void *)(v14 + 240) + 48), @"vehicularActivityStateDuration");
    uint64_t v14 = *(void *)(a1 + 32);
    if (!*(unsigned char *)(*(void *)(v14 + 8) + 16056))
    {
      sub_19050B3B0((double *)(*(void *)(v14 + 240) + 80), @"inVehicle2IMUDuration");
      uint64_t v14 = *(void *)(a1 + 32);
    }
LABEL_40:
    int v21 = *(_DWORD *)(v14 + 264);
    if (v21 > 51)
    {
      if (v21 == 52 || v21 == 56) {
        goto LABEL_47;
      }
    }
    else
    {
      if (!v21) {
        goto LABEL_58;
      }
      if (v21 == 5)
      {
LABEL_47:
        if (v11 > 51)
        {
          if (v11 == 52 || v11 == 56) {
            goto LABEL_58;
          }
        }
        else
        {
          if (!v11)
          {
LABEL_54:
            sub_19050B590((double *)(*(void *)(v14 + 240) + 48), @"vehicularActivityStateDuration");
            uint64_t v14 = *(void *)(a1 + 32);
            uint64_t v22 = *(void *)(v14 + 240);
            if (*(double *)(v22 + 80) > 0.0)
            {
              sub_19050B590((double *)(v22 + 80), &stru_1EDFD5D50);
              uint64_t v14 = *(void *)(a1 + 32);
              uint64_t v22 = *(void *)(v14 + 240);
            }
            double v24 = *(double *)(v22 + 160);
            float v23 = (double *)(v22 + 160);
            if (v24 > 0.0)
            {
              sub_19050B590(v23, &stru_1EDFD5D50);
              uint64_t v14 = *(void *)(a1 + 32);
            }
            goto LABEL_58;
          }
          if (v11 == 5)
          {
LABEL_58:
            unsigned int v25 = *(_DWORD *)(v14 + 264);
            if ((v25 > 0x29 || ((1 << v25) & 0x20000000110) == 0)
              && v11 <= 0x29
              && ((1 << v11) & 0x20000000110) != 0)
            {
              sub_19050B3B0((double *)(*(void *)(v14 + 240) + 64), @"pedestrianActivityStateDuration");
              uint64_t v14 = *(void *)(a1 + 32);
              if (!*(unsigned char *)(*(void *)(v14 + 8) + 16056))
              {
                sub_19050B3B0((double *)(*(void *)(v14 + 240) + 96), @"srcPedestrian2IMUDuration");
                uint64_t v14 = *(void *)(a1 + 32);
              }
            }
            unsigned int v26 = *(_DWORD *)(v14 + 264);
            if (v26 <= 0x29
              && ((1 << v26) & 0x20000000110) != 0
              && (v11 > 0x29 || ((1 << v11) & 0x20000000110) == 0))
            {
              sub_19050B590((double *)(*(void *)(v14 + 240) + 64), @"pedestrianActivityStateDuration");
              uint64_t v14 = *(void *)(a1 + 32);
              uint64_t v28 = *(void *)(v14 + 240);
              if (*(double *)(v28 + 96) > 0.0)
              {
                sub_19050B590((double *)(v28 + 96), &stru_1EDFD5D50);
                uint64_t v14 = *(void *)(a1 + 32);
                uint64_t v28 = *(void *)(v14 + 240);
              }
              double v30 = *(double *)(v28 + 176);
              float v29 = (double *)(v28 + 176);
              if (v30 > 0.0)
              {
                sub_19050B590(v29, &stru_1EDFD5D50);
                uint64_t v14 = *(void *)(a1 + 32);
              }
            }
            *(_DWORD *)(v14 + 264) = v11;
            goto LABEL_65;
          }
        }
        if ((v11 & 0xFFFFFFFE) != 0xA) {
          goto LABEL_54;
        }
        goto LABEL_58;
      }
    }
    if ((v21 & 0xFFFFFFFE) != 0xA) {
      goto LABEL_58;
    }
    goto LABEL_47;
  }
LABEL_65:

  return objc_sync_exit(v12);
}

void sub_1904AB6A8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1904AB744(uint64_t a1)
{
  uint64_t v2 = mach_continuous_time();
  double v3 = sub_1902D8D34(v2);
  double v4 = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v5 + 505))
  {
    sub_190458064(*(uint64_t **)(v5 + 648), v3);
    uint64_t v5 = *(void *)(a1 + 32);
  }
  uint64_t v6 = *(void *)(v5 + 8);
  sub_190501BF0(v6);
  uint64_t v7 = *(void *)(v6 + 37488);

  sub_19055FD68(v7, (unint64_t)(v4 * 1000000.0));
}

void sub_1904AC5B0(uint64_t a1, int a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  if (a2) {
    *(_DWORD *)(a1 + 16) = 0;
  }
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD18C0);
  }
  double v3 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
  {
    double v4 = "No";
    if (a2) {
      double v4 = "Yes";
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v7 = v4;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_INFO, "[RelDM] Resetting UnTimesyncedAuxSampleHelper. Clearing buffer: %s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD18C0);
    }
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMRelDM::UnTimesyncedAuxSampleHelper::reset(BOOL)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
}

void sub_1904ACBB4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1904ACBDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__stopHeadTracking, a3);
}

uint64_t sub_1904AE5E0(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__feedAdaptiveLatencyJitterBufferLevel(*(void **)(a1 + 32), a2, a3);
}

void sub_1904AE664(uint64_t a1, const char *a2, uint64_t a3)
{
  objc_msgSend__stopJitterBufferLevelRetryTimer(*(void **)(a1 + 32), a2, a3);
  *(void *)(*(void *)(a1 + 32) + 672) = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, MEMORY[0x1E4F14428]);
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2020000000;
  int v8 = 5;
  dispatch_source_set_timer(*(dispatch_source_t *)(*(void *)(a1 + 32) + 672), 0, 0x3B9ACA00uLL, 0x3B9ACA00uLL);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(NSObject **)(v4 + 672);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = sub_1904AE764;
  v6[3] = &unk_1E568E110;
  v6[4] = v4;
  v6[5] = v7;
  dispatch_source_set_event_handler(v5, v6);
  dispatch_resume(*(dispatch_object_t *)(*(void *)(a1 + 32) + 672));
  _Block_object_dispose(v7, 8);
}

void sub_1904AE764(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  objc_msgSend__feedAdaptiveLatencyJitterBufferLevel(*(void **)(a1 + 32), a2, a3);
  if (*(__int16 *)(*(void *)(a1 + 32) + 680) != -1)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD18C0);
    }
    uint64_t v4 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(unsigned __int16 *)(*(void *)(a1 + 32) + 680);
      *(_DWORD *)buf = 67240192;
      LODWORD(v13) = v5;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEFAULT, "[CMMediaSession] Initial JBL: %{public}d", buf, 8u);
    }
    if (!sub_1902D8400(115, 2)) {
      goto LABEL_7;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD18C0);
    }
    float v10 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMMediaSession _startJitterBufferLevelRetryTimer]_block_invoke", "CoreLocation: %s\n");
LABEL_26:
    if (v10 != buf) {
      free(v10);
    }
LABEL_7:
    objc_msgSend__stopJitterBufferLevelRetryTimer(*(void **)(a1 + 32), v6, v7);
    return;
  }
  if (*(int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) < 1)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD18C0);
    }
    id v9 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_ERROR, "[CMMediaSession] Failed to feed initial JBL value", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_7;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD18C0);
    }
    float v10 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMMediaSession _startJitterBufferLevelRetryTimer]_block_invoke", "CoreLocation: %s\n");
    goto LABEL_26;
  }
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD18C0);
  }
  int v8 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v13 = 0x3FF0000000000000;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEFAULT, "[CMMediaSession] Failed to feed initial JBL value, retrying in %{public}.1f sec", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD18C0);
    }
    int v11 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMMediaSession _startJitterBufferLevelRetryTimer]_block_invoke", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
  --*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
}

void sub_1904AF51C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1904AF55C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), *(unsigned int *)(a1 + 48));
}

uint64_t sub_1904AF574(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), *(unsigned int *)(a1 + 48));
}

void sub_1904AF82C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1904B0A34(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1904B0D48(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1904B4D8C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1904B58C4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1904B5CD8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1904B6214(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1904B6230(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__startHeadTracking, a3);
}

uint64_t sub_1904B6238(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__stopHeadTracking, a3);
}

uint64_t sub_1904B62BC(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = sub_1905298B4();
  *(_WORD *)(*(void *)(a1 + 32) + 680) = sub_1905A1244(v2);
  uint64_t v3 = mach_continuous_time();
  double v4 = sub_1902D8D34(v3);
  double v5 = v4;
  uint64_t v6 = *(void *)(a1 + 32);
  unsigned int v7 = *(unsigned __int16 *)(v6 + 680);
  if (v7 != 0xFFFF)
  {
    uint64_t v8 = *(void *)(v6 + 8);
    if (v8)
    {
      sub_190544D54(v8, v7, *(unsigned __int16 *)(v6 + 682), (unint64_t)(v4 * 1000000.0));
      uint64_t v6 = *(void *)(a1 + 32);
    }
    uint64_t v9 = *(void *)(v6 + 240);
    if (v9)
    {
      LOWORD(v4) = *(_WORD *)(v6 + 680);
      double v10 = (double)*(unint64_t *)&v4;
      double v11 = *(double *)(v9 + 792);
      if (v11 <= v10) {
        double v11 = v10;
      }
      *(double *)(v9 + 792) = v11;
      double v12 = *(double *)(v9 + 784);
      if (v12 >= v10) {
        double v12 = v10;
      }
      *(double *)(v9 + 784) = v12;
      *(double *)(v9 + 800) = *(double *)(v9 + 800) + v10;
      ++*(_DWORD *)(v9 + 808);
      sub_19043C2D8(*(void *)(*(void *)(a1 + 32) + 240), (const char *)*(unsigned __int16 *)(*(void *)(a1 + 32) + 680));
      uint64_t v13 = *(void *)(a1 + 32);
      if (*(unsigned __int16 *)(v13 + 680) > *(unsigned __int16 *)(v13 + 682))
      {
        uint64_t v14 = *(void *)(v13 + 240);
        int v15 = *(_DWORD *)(v14 + 1292);
        if (v15 != -1) {
          *(_DWORD *)(v14 + 1292) = v15 + 1;
        }
      }
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD18C0);
      }
      int v16 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_INFO, "[CMMediaSession] log JBL CA metric", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD18C0);
        }
        BOOL v20 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "-[CMMediaSession _feedAdaptiveLatencyJitterBufferLevel]_block_invoke", "CoreLocation: %s\n", v20);
        if (v20 != (char *)buf) {
          free(v20);
        }
      }
    }
  }
  uint64_t v17 = *(void **)(a1 + 32);
  objc_sync_enter(v17);
  uint64_t v18 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v18 + 505)) {
    sub_190459448(*(uint64_t **)(v18 + 648), *(unsigned __int16 *)(v18 + 680), *(unsigned __int16 *)(v18 + 682), v5);
  }
  return objc_sync_exit(v17);
}

void sub_1904B6564(_Unwind_Exception *exception_object)
{
}

void sub_1904B6BA0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1904B6EC4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

os_log_t sub_1904B7094()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

uint64_t sub_1904B70C4(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1905443A0(result);
    JUMPOUT(0x192FCC980);
  }
  return result;
}

void sub_1904B7118(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904B7150(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_1904B715C(void *a1)
{
  uint64_t v2 = (void *)a1[189];
  if (v2)
  {
    a1[190] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[183];
  if (v3)
  {
    a1[184] = v3;
    operator delete(v3);
  }

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904B71C0(uint64_t a1)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_1904B7250;
  block[3] = &unk_1E568D118;
  void block[4] = a1;
  if (qword_1E929EAD0 != -1) {
    dispatch_once(&qword_1E929EAD0, block);
  }
  return qword_1E929EAC8;
}

void sub_1904B7250()
{
}

void sub_1904B72C0(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10B3C406D655BBCLL);
  _Unwind_Resume(a1);
}

void sub_1904B72E8(uint64_t a1, const char *a2, uint64_t a3)
{
  sub_1905953E0(a1, a2, a3);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904B7320(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(a1 + 108)) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = (int *)v8;
  v8[0] = 0;
  v8[1] = 0;
  uint64_t v9 = a2;
  uint64_t v3 = (unsigned int *)(a1 + 104);
  ++*(_DWORD *)(a1 + 104);
  double v10 = (_DWORD *)(a1 + 104);
  double v4 = sub_1904B9814((uint64_t **)(a1 + 80), (int *)(a1 + 104), (uint64_t)&unk_1906099C2, &v10);
  if (v4 + 5 != (uint64_t **)&v7) {
    sub_1904B993C(v4 + 5, v7, (int *)v8);
  }
  double v5 = (void *)v8[0];
  v4[8] = v9;
  uint64_t v2 = *v3;
  sub_1904B9BBC((uint64_t)&v7, v5);
  return v2;
}

void sub_1904B73D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_1904B73EC(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  v14[0] = a2;
  if (!*(unsigned char *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      if (v7 >= (int)a2) {
        uint64_t v9 = (uint64_t *)v4;
      }
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)buf = *(_DWORD *)(*(void *)(v6 + 40) + 28);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112))(a1, a2, buf);
      }
      sub_1904B9CD0(v5, v14);
    }
    else
    {
LABEL_12:
      if (qword_1E929D728 != -1) {
        dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
      }
      double v10 = qword_1E929D720;
      if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_FAULT))
      {
        double v11 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          double v11 = (void *)*v11;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v19 = v11;
        __int16 v20 = 1026;
        int v21 = a2;
        _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D728 != -1) {
          dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
        }
        double v12 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          double v12 = (void *)*v12;
        }
        v14[1] = 136446466;
        int v15 = v12;
        __int16 v16 = 1026;
        int v17 = a2;
        uint64_t v13 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v13);
        if (v13 != (char *)buf) {
          free(v13);
        }
      }
    }
  }
}

uint64_t sub_1904B767C(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v7 = sub_1904B9DEC(a4);
  if (v7)
  {
    int v10 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t))(*(void *)a1 + 96))(a1, a2, &v10, v7);
  }
  else
  {
    int v9 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 88))(a1, a2, &v9);
  }
}

uint64_t sub_1904B7730(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 104))(a1, a2, &v4);
}

uint64_t sub_1904B7778(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 112))(a1, a2, &v4);
}

uint64_t sub_1904B77C0(uint64_t a1, int a2)
{
  int v3 = a2;
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 120))(a1, &v3);
}

uint64_t sub_1904B780C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  if (!result)
  {
    int v3 = objc_alloc_init(CLNotifierServiceAdapter);
    *(void *)(a1 + 48) = v3;
    objc_msgSend_setValid_(v3, v4, 1);
    objc_msgSend_setAdaptedNotifier_(*(void **)(a1 + 48), v5, a1);
    return *(void *)(a1 + 48);
  }
  return result;
}

uint64_t sub_1904B785C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96))(a1, a2, a3, &unk_1E929DF40);
}

uint64_t sub_1904B7888(uint64_t a1, int a2, int *a3, char *a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  int v41 = a2;
  if (*(unsigned char *)(a1 + 108)) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        uint64_t v13 = (uint64_t *)v7;
      }
      else {
        uint64_t v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }
    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)uint64_t v42 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          double v24 = (uint64_t *)v18;
        }
        else {
          double v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }
      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          float v29 = (uint64_t *)v25;
        }
        else {
          float v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }
      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v40 = v26;
        uint64_t v35 = *(void *)(v26 + 56);
        char v36 = *a4;
        *(void *)&buf[0] = &v41;
        *((unsigned char *)sub_1904BAC2C((uint64_t **)(v26 + 40), &v41, (uint64_t)&unk_1906099C2, (_DWORD **)buf) + 32) = v36;
        memset(buf, 0, 320);
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, _OWORD *))(*(void *)a1 + 128))(a1, a3, buf))
        {
          sub_1904BA8A8();
        }
        if (v35) {
          goto LABEL_46;
        }
      }
      else
      {
LABEL_42:
        uint64_t v40 = a1 + 64;
        char v30 = byte_1E929DF41;
        int v39 = v17;
        *(void *)&buf[0] = &v39;
        *((unsigned char *)sub_1904BAA54((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_1906099C2, (_DWORD **)buf) + 80) = v30;
        int v39 = *a3;
        *(void *)&buf[0] = &v39;
        uint64_t v31 = sub_1904BAA54((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_1906099C2, (_DWORD **)buf);
        float v32 = (std::__shared_weak_count *)v31[9];
        v31[8] = 0;
        v31[9] = 0;
        if (v32) {
          sub_1902D8B58(v32);
        }
        char v33 = *a4;
        int v39 = *a3;
        *(void *)&buf[0] = &v39;
        uint64_t v34 = sub_1904BAA54((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_1906099C2, (_DWORD **)buf);
        *(void *)&buf[0] = &v41;
        *((unsigned char *)sub_1904BAC2C(v34 + 5, &v41, (uint64_t)&unk_1906099C2, (_DWORD **)buf) + 32) = v33;
      }
      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168))(a1, a3);
LABEL_46:
      if (v21 == v19)
      {
        LODWORD(buf[0]) = *a3;
        sub_1904BB77C((uint64_t **)(*(void *)v42 + 40), (int *)buf, buf);
      }
      return 1;
    }
  }
  if (qword_1E929D728 != -1) {
    dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
  }
  uint64_t v14 = qword_1E929D720;
  if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_FAULT))
  {
    int v15 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      int v15 = (void *)*v15;
    }
    LODWORD(buf[0]) = 136446466;
    *(void *)((char *)buf + 4) = v15;
    WORD6(buf[0]) = 1026;
    *(_DWORD *)((char *)buf + 14) = a2;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist",
      (uint8_t *)buf,
      0x12u);
  }
  int v16 = sub_1902D8400(115, 0);
  uint64_t result = 0;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D728 != -1) {
      dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
    }
    uint64_t v37 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      uint64_t v37 = (void *)*v37;
    }
    *(_DWORD *)uint64_t v42 = 136446466;
    *(void *)&v42[4] = v37;
    __int16 v43 = 1026;
    int v44 = a2;
    uint64_t v38 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v38);
    if (v38 != (char *)buf) {
      free(v38);
    }
    return 0;
  }
  return result;
}

BOOL sub_1904B7D58(uint64_t a1, int a2, int *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v5;
    }
    else {
      int v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }
    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }
  else
  {
LABEL_11:
    if (qword_1E929D728 != -1) {
      dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
    }
    uint64_t v10 = qword_1E929D720;
    if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        int v11 = (void *)*v11;
      }
      *(_DWORD *)buf = 136446466;
      double v24 = v11;
      __int16 v25 = 1026;
      int v26 = a2;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist", buf, 0x12u);
    }
    int v12 = sub_1902D8400(115, 0);
    BOOL result = 0;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D728 != -1) {
        dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
      }
      int v22 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v22);
      if (v22 != (char *)buf) {
        free(v22);
      }
      return 0;
    }
  }
  return result;
}

BOOL sub_1904B7FDC(char *a1, int a2, int *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  int v32 = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        int v12 = v8 + 48;
        uint64_t v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            uint64_t v13 = *v19;
          }
          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1904BB838((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            int v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                __int16 v25 = (uint64_t *)v20;
              }
              else {
                __int16 v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                int v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }
            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1904BB838((uint64_t)(v22 + 40), &v32);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176))(a1, a3);
              }
            }
            else
            {
LABEL_33:
              if (qword_1E929D728 != -1) {
                dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
              }
              int v26 = qword_1E929D720;
              if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_FAULT))
              {
                uint64_t v27 = a1 + 8;
                if (a1[31] < 0) {
                  uint64_t v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160))(__p, a1, a3);
                if (v42 >= 0) {
                  BOOL v28 = __p;
                }
                else {
                  BOOL v28 = (void **)__p[0];
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v34 = 2082;
                uint64_t v35 = v28;
                _os_log_impl(&dword_1902AF000, v26, OS_LOG_TYPE_FAULT, "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v42 < 0) {
                  operator delete(__p[0]);
                }
              }
              if (sub_1902D8400(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1E929D728 != -1) {
                  dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
                }
                float v29 = a1 + 8;
                if (a1[31] < 0) {
                  float v29 = (void *)*v29;
                }
                (*(void (**)(unsigned char *__return_ptr, char *, int *))(*(void *)a1 + 160))(buf, a1, a3);
                if (v36 >= 0) {
                  char v30 = buf;
                }
                else {
                  char v30 = *(unsigned char **)buf;
                }
                int v37 = 136446466;
                uint64_t v38 = v29;
                __int16 v39 = 2082;
                uint64_t v40 = v30;
                uint64_t v31 = (char *)_os_log_send_and_compose_impl();
                if (v36 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v31);
                if (v31 != (char *)__p) {
                  free(v31);
                }
              }
            }
          }
        }
      }
    }
  }
  return v3 == 0;
}

void sub_1904B83B0(uint64_t a1, int *a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v2 = a1 + 64;
  uint64_t v3 = v4;
  if (v4)
  {
    int v5 = *a2;
    uint64_t v6 = v2;
    do
    {
      int v7 = *(_DWORD *)(v3 + 32);
      BOOL v8 = v7 < v5;
      if (v7 >= v5) {
        int v9 = (uint64_t *)v3;
      }
      else {
        int v9 = (uint64_t *)(v3 + 8);
      }
      if (!v8) {
        uint64_t v6 = v3;
      }
      uint64_t v3 = *v9;
    }
    while (*v9);
    if (v6 != v2 && v5 >= *(_DWORD *)(v6 + 32))
    {
      BOOL v10 = *(std::__shared_weak_count **)(v6 + 72);
      *(void *)(v6 + 64) = 0;
      *(void *)(v6 + 72) = 0;
      if (v10) {
        sub_1902D8B58(v10);
      }
    }
  }
}

uint64_t sub_1904B8404(uint64_t a1, int *a2, void *__dst)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }
  while (*v10);
  if (v7 == v3) {
    return 0;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0;
  }
  int v11 = *(const void **)(v7 + 64);
  if (!v11) {
    return 0;
  }
  memcpy(__dst, v11, 0x140uLL);
  return 1;
}

uint64_t sub_1904B8478(uint64_t a1, int *a2, const void *a3)
{
  int v6 = (uint64_t *)operator new(0x158uLL);
  v6[1] = 0;
  void v6[2] = 0;
  *int v6 = (uint64_t)&unk_1EDFD0E10;
  memcpy(v6 + 3, a3, 0x140uLL);
  int v10 = *a2;
  int v11 = &v10;
  uint64_t v7 = sub_1904BAA54((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_1906099C2, &v11);
  int v8 = (std::__shared_weak_count *)v7[9];
  v7[8] = v6 + 3;
  v7[9] = v6;
  if (v8) {
    sub_1902D8B58(v8);
  }
  return 1;
}

void sub_1904B853C(_Unwind_Exception *a1)
{
  sub_1902D8B58(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1904B8550(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  memset(v5, 0, sizeof(v5));
  return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 152))(a1, a2, v5, a3, a4, 0);
}

void sub_1904B8600(uint64_t a1, unsigned int *a2, const void *a3, int a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 108)) {
    return;
  }
  int v8 = _os_activity_create(&dword_1902AF000, "CL: notifyClientsWithData (Fallback)", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
  os_activity_scope_enter(v8, &state);

  if (qword_1E929D728 != -1) {
    dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
  }
  BOOL v9 = qword_1E929D720;
  if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_DEBUG))
  {
    int v10 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      int v10 = (void *)*v10;
    }
    int v11 = (std::__shared_weak_count *)*a2;
    *(_DWORD *)buf = 68289794;
    int v22 = 0;
    __int16 v23 = 2082;
    *(void *)BOOL v24 = "";
    *(_WORD *)&v24[8] = 2082;
    *(void *)&v24[10] = "activity";
    __int16 v25 = 2082;
    int v26 = v10;
    __int16 v27 = 2050;
    BOOL v28 = v11;
    _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"notifyClientsWithData\", \"event\":%{public, location:escape_only}s, \"name\":%{public, location:escape_only}s, \"notification\":%{public}lld}", buf, 0x30u);
  }
  uint64_t v12 = *(void *)(a1 + 64);
  if (!v12) {
    goto LABEL_18;
  }
  int v13 = *a2;
  uint64_t v14 = (uint64_t **)(a1 + 64);
  do
  {
    int v15 = *(_DWORD *)(v12 + 32);
    BOOL v16 = v15 < v13;
    if (v15 >= v13) {
      int v17 = (uint64_t *)v12;
    }
    else {
      int v17 = (uint64_t *)(v12 + 8);
    }
    if (!v16) {
      uint64_t v14 = (uint64_t **)v12;
    }
    uint64_t v12 = *v17;
  }
  while (*v17);
  if (v14 == (uint64_t **)(a1 + 64) || v13 < *((_DWORD *)v14 + 8))
  {
LABEL_18:
    float v29 = v30;
    memset(v30, 0, sizeof(v30));
    uint64_t v31 = 0;
    sub_1904BBF48((uint64_t)buf, a2, (uint64_t)&v29);
    uint64_t v14 = sub_1904BBE10((uint64_t **)(a1 + 56), (__n128 *)buf);
    if (v28) {
      sub_1902D8B58(v28);
    }
    sub_1904B9BBC((uint64_t)&v23, *(void **)&v24[6]);
    if (v31) {
      sub_1902D8B58(v31);
    }
    sub_1904B9BBC((uint64_t)&v29, v30[0]);
  }
  if (a4)
  {
    BOOL v18 = (uint64_t *)operator new(0x158uLL);
    v18[1] = 0;
    void v18[2] = 0;
    *BOOL v18 = (uint64_t)&unk_1EDFD0E10;
    memcpy(v18 + 3, a3, 0x140uLL);
    int v19 = (std::__shared_weak_count *)v14[9];
    v14[8] = v18 + 3;
    v14[9] = v18;
    if (!v19) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  int v19 = (std::__shared_weak_count *)v14[9];
  v14[8] = 0;
  v14[9] = 0;
  if (v19) {
LABEL_27:
  }
    sub_1902D8B58(v19);
LABEL_28:
  if (v14[7]) {
    sub_1904BB96C();
  }
  os_activity_scope_leave(&state);
}

void sub_1904B8BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

uint64_t sub_1904B8C38()
{
  return 1;
}

uint64_t sub_1904B8C40()
{
  return 1;
}

uint64_t sub_1904B8C4C()
{
  return 1;
}

void sub_1904B8C54(uint64_t a1)
{
  *(void *)((char *)&v24[202] + 2) = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 108))
  {
    if (qword_1E929D728 != -1) {
      dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
    }
    uint64_t v2 = qword_1E929D720;
    if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        uint64_t v3 = (void *)*v3;
      }
      *(_DWORD *)buf = 136315138;
      int v22 = v3;
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEBUG, "%s; already shutdown; not listing clients", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D728 != -1) {
        dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
      }
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::listClients() [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
  else
  {
    if (qword_1E929D728 != -1) {
      dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
    }
    uint64_t v5 = qword_1E929D720;
    if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        uint64_t v6 = (void *)*v6;
      }
      uint64_t v7 = *(void *)(a1 + 96);
      *(_DWORD *)buf = 136315394;
      int v22 = v6;
      __int16 v23 = 2048;
      v24[0] = v7;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_DEBUG, "%s; listing clients, num clients: %zu", buf, 0x16u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D728 != -1) {
        dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
      }
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::listClients() [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
    int v8 = *(void **)(a1 + 80);
    if (v8 != (void *)(a1 + 88))
    {
      do
      {
        BOOL v9 = (void *)v8[5];
        if (v9 != v8 + 6)
        {
          do
          {
            if (qword_1E929D728 != -1) {
              dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
            }
            int v10 = qword_1E929D720;
            if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_DEBUG))
            {
              int v11 = (void *)(a1 + 8);
              if (*(char *)(a1 + 31) < 0) {
                int v11 = *(void **)(a1 + 8);
              }
              int v12 = *((_DWORD *)v8 + 8);
              int v13 = *((_DWORD *)v9 + 7);
              *(_DWORD *)buf = 136315650;
              int v22 = v11;
              __int16 v23 = 1024;
              LODWORD(v24[0]) = v12;
              WORD2(v24[0]) = 1024;
              *(_DWORD *)((char *)v24 + 6) = v13;
              _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_DEBUG, "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }
            if (sub_1902D8400(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1E929D728 != -1) {
                dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
              }
              int v17 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 2, "virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::listClients() [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v17);
              if (v17 != (char *)buf) {
                free(v17);
              }
            }
            uint64_t v14 = (void *)v9[1];
            if (v14)
            {
              do
              {
                int v15 = v14;
                uint64_t v14 = (void *)*v14;
              }
              while (v14);
            }
            else
            {
              do
              {
                int v15 = (void *)v9[2];
                BOOL v16 = *v15 == (void)v9;
                BOOL v9 = v15;
              }
              while (!v16);
            }
            BOOL v9 = v15;
          }
          while (v15 != v8 + 6);
        }
        BOOL v18 = (void *)v8[1];
        if (v18)
        {
          do
          {
            int v19 = v18;
            BOOL v18 = (void *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            int v19 = (void *)v8[2];
            BOOL v16 = *v19 == (void)v8;
            int v8 = v19;
          }
          while (!v16);
        }
        int v8 = v19;
      }
      while (v19 != (void *)(a1 + 88));
    }
  }
}

BOOL sub_1904B9200(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v4 = sub_190554EE8(a1, a2, a3);
  if (v4 && (*(unsigned int (**)(uint64_t, unsigned char *))(*(void *)a1 + 216))(a1, v7))
  {
    int v6 = 0;
    (*(void (**)(uint64_t, int *, unsigned char *, void, uint64_t, void))(*(void *)a1 + 152))(a1, &v6, v7, 0, 0xFFFFFFFFLL, 0);
  }
  return v4 != 0;
}

BOOL sub_1904B92F4(uint64_t a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1902D6BD0();
  if (Current != *(CFRunLoopRef *)qword_1EB3BF828) {
    return sub_190554E98((uint64_t)a2, v4, v5) != 0;
  }
  uint64_t v17 = 0;
  BOOL v18 = &v17;
  uint64_t v19 = 0x2020000000;
  char v20 = 0;
  uint64_t v22 = 0;
  __int16 v23 = &v22;
  uint64_t v24 = 0x17012000000;
  __int16 v25 = sub_1902DD120;
  int v26 = nullsub_2;
  __int16 v27 = &unk_190687D59;
  uint64_t v7 = dispatch_semaphore_create(0);
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_1904BC2D4;
  block[3] = &unk_1E568E160;
  void block[5] = &v17;
  void block[6] = &v22;
  void block[4] = v7;
  dispatch_async(global_queue, block);
  dispatch_time_t v9 = dispatch_time(0, 2000000000);
  intptr_t v10 = dispatch_semaphore_wait(v7, v9);
  dispatch_release(v7);
  if (v10 || *((unsigned char *)v18 + 24) != 1)
  {
    bzero(a2, 0x140uLL);
    if (qword_1EB3BE868 != -1) {
      dispatch_once(&qword_1EB3BE868, &unk_1EDFD3C00);
    }
    int v12 = qword_1EB3BE860;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE860, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_INFO, "Warning: can't get GyroBiasFit from CLGyroCalibrationDatabaseGetBiasFitAtTemperature()", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE868 != -1) {
        dispatch_once(&qword_1EB3BE868, &unk_1EDFD3C00);
      }
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLGyroCalibrationDatabaseRemote::getBiasFit(CLMotionTypeGyroBiasFit &)", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
    uint64_t v6 = 0;
  }
  else
  {
    memcpy(a2, v23 + 6, 0x140uLL);
    if (qword_1EB3BE868 != -1) {
      dispatch_once(&qword_1EB3BE868, &unk_1EDFD3C00);
    }
    int v11 = qword_1EB3BE860;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE860, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_INFO, "successfully got GyroBiasFit from CLGyroCalibrationDatabaseGetBiasFitAtTemperature()", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE868 != -1) {
        dispatch_once(&qword_1EB3BE868, &unk_1EDFD3C00);
      }
      int v15 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLGyroCalibrationDatabaseRemote::getBiasFit(CLMotionTypeGyroBiasFit &)", "CoreLocation: %s\n", v15);
      if (v15 != (char *)buf) {
        free(v15);
      }
    }
    uint64_t v6 = 1;
  }
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v17, 8);
  return v6;
}

void sub_1904B9744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(&STACK[0x6D8], 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1904B9770()
{
  return 0;
}

BOOL sub_1904B9778(uint64_t a1, const char *a2, uint64_t a3)
{
  return sub_190554F78(a1, a2, a3) != 0;
}

uint64_t sub_1904B9798(uint64_t a1, const char *a2, uint64_t a3)
{
  unsigned int v4 = -1;
  sub_190554FA8((uint64_t)&v4, a2, a3);
  return v4;
}

BOOL sub_1904B97C8(uint64_t a1, const char *a2, uint64_t a3)
{
  int v4 = 0;
  sub_190555C1C((uint64_t)&v4, a2, a3);
  return v4 != 0;
}

uint64_t sub_1904B97FC()
{
  return 0;
}

uint64_t sub_1904B9804()
{
  return 0;
}

uint64_t sub_1904B980C()
{
  return 0;
}

uint64_t **sub_1904B9814(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        dispatch_time_t v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    dispatch_time_t v9 = a1 + 1;
LABEL_10:
    int v11 = operator new(0x48uLL);
    v11[8] = **a4;
    *((void *)v11 + 7) = 0;
    *((void *)v11 + 8) = 0;
    *((void *)v11 + 6) = 0;
    *((void *)v11 + 5) = v11 + 12;
    sub_1904B98E4(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *sub_1904B98E4(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  uint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  BOOL result = sub_1902DD3B4(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t **sub_1904B993C(uint64_t **result, int *a2, int *a3)
{
  uint64_t v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    *BOOL result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      int v8 = (uint64_t *)v6[1];
    }
    else {
      int v8 = v6;
    }
    uint64_t v14 = result;
    int v15 = v8;
    BOOL v16 = v8;
    if (v8)
    {
      int v15 = sub_1904B9B10((uint64_t)v8);
      if (a2 != a3)
      {
        dispatch_time_t v9 = a2;
        do
        {
          *((_DWORD *)v8 + 7) = v9[7];
          sub_1904B9AA0(v5, (uint64_t)v8);
          int v8 = v15;
          BOOL v16 = v15;
          if (v15) {
            int v15 = sub_1904B9B10((uint64_t)v15);
          }
          int v10 = (int *)*((void *)v9 + 1);
          if (v10)
          {
            do
            {
              a2 = v10;
              int v10 = *(int **)v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (int *)*((void *)v9 + 2);
              BOOL v11 = *(void *)a2 == (void)v9;
              dispatch_time_t v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          dispatch_time_t v9 = a2;
        }
        while (a2 != a3);
      }
    }
    BOOL result = (uint64_t **)sub_1904B9B64((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      BOOL result = (uint64_t **)sub_1904B9C10(v5, a2 + 7);
      int v12 = (int *)*((void *)a2 + 1);
      if (v12)
      {
        do
        {
          int v13 = v12;
          int v12 = *(int **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          int v13 = (int *)*((void *)a2 + 2);
          BOOL v11 = *(void *)v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_1904B9A8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1904B9B64((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1904B9AA0(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = a1 + 1;
  int v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = (uint64_t **)v4;
        if (*(_DWORD *)(a2 + 28) >= *((_DWORD *)v4 + 7)) {
          break;
        }
        int v4 = (uint64_t *)*v4;
        uint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      int v4 = (uint64_t *)v4[1];
    }
    while (v4);
    uint64_t v5 = v3 + 1;
  }
  else
  {
    uint64_t v5 = a1 + 1;
  }
LABEL_8:
  sub_1904B98E4(a1, (uint64_t)v3, v5, (uint64_t *)a2);
  return a2;
}

void *sub_1904B9B10(uint64_t a1)
{
  BOOL result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      *BOOL result = 0;
      while (1)
      {
        int v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          BOOL result = v4;
          int v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          BOOL result = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t sub_1904B9B64(uint64_t a1)
{
  sub_1904B9BBC(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1904B9BBC(*(void *)a1, v2);
  }
  return a1;
}

void sub_1904B9BBC(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1904B9BBC(a1, *a2);
    sub_1904B9BBC(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t *sub_1904B9C10(uint64_t **a1, int *a2)
{
  int v4 = (uint64_t *)operator new(0x20uLL);
  int v5 = *a2;
  *((_DWORD *)v4 + 7) = *a2;
  uint64_t v6 = a1 + 1;
  uint64_t v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v7;
        if (v5 >= *((_DWORD *)v7 + 7)) {
          break;
        }
        uint64_t v7 = (uint64_t *)*v7;
        int v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      uint64_t v7 = (uint64_t *)v7[1];
    }
    while (v7);
    int v8 = v6 + 1;
  }
  else
  {
    int v8 = a1 + 1;
  }
LABEL_8:
  sub_1904B98E4(a1, (uint64_t)v6, v8, v4);
  return v4;
}

os_log_t sub_1904B9CA0()
{
  os_log_t result = os_log_create("com.apple.locationd.Core", "Notifier");
  qword_1E929D720 = (uint64_t)result;
  return result;
}

uint64_t sub_1904B9CD0(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      uint64_t v7 = (uint64_t *)v2;
    }
    else {
      uint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0;
  }
  sub_1904B9D38((uint64_t **)a1, v4);
  return 1;
}

uint64_t *sub_1904B9D38(uint64_t **a1, uint64_t a2)
{
  int v3 = sub_1904B9D78(a1, (uint64_t *)a2);
  sub_1904B9BBC(a2 + 40, *(void **)(a2 + 48));
  operator delete((void *)a2);
  return v3;
}

uint64_t *sub_1904B9D78(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      int v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = a2;
    do
    {
      int v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  BOOL v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_1902CE250(v6, a2);
  return v3;
}

uint64_t sub_1904B9DEC(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    return sub_1904B9E88(a1, v2, v3);
  }
  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      return sub_1904BA204(a1, v5, v6);
    }
    else
    {
      return 0;
    }
  }
}

uint64_t sub_1904B9E88(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend_binaryVersion(a1, a2, a3);
  objc_msgSend_sizeOfType(a1, v5, v6);
  if (!v4) {
    return sub_1904BA5B4((uint64_t)&v15, a1, v7);
  }
  if (!getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_1E929D8A8 != -1) {
      dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
    }
    BOOL v11 = qword_1E929D8B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_FAULT))
    {
      uint64_t v12 = *(void *)(MEMORY[0x1E4FBA380] + 8) & 0x7FFFFFFFFFFFFFFFLL;
      *(_DWORD *)buf = 134218498;
      uint64_t v23 = v4;
      __int16 v24 = 2048;
      uint64_t v25 = 0;
      __int16 v26 = 2080;
      uint64_t v27 = v12;
      _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_FAULT, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
    }
    if (!sub_1902D8400(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8A8 == -1) {
      goto LABEL_18;
    }
    goto LABEL_20;
  }
  if (qword_1E929D8A8 != -1) {
    dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
  }
  int v8 = qword_1E929D8B0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_ERROR))
  {
    uint64_t v9 = *(void *)(MEMORY[0x1E4FBA380] + 8) & 0x7FFFFFFFFFFFFFFFLL;
    *(_DWORD *)buf = 134218498;
    uint64_t v23 = v4;
    __int16 v24 = 2048;
    uint64_t v25 = 0;
    __int16 v26 = 2080;
    uint64_t v27 = v9;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_ERROR, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
  }
  if (!sub_1902D8400(115, 0)) {
    return 0;
  }
  bzero(buf, 0x65CuLL);
  if (qword_1E929D8A8 != -1) {
LABEL_20:
  }
    dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
LABEL_18:
  uint64_t v13 = *(void *)(MEMORY[0x1E4FBA380] + 8) & 0x7FFFFFFFFFFFFFFFLL;
  int v16 = 134218498;
  uint64_t v17 = v4;
  __int16 v18 = 2048;
  uint64_t v19 = 0;
  __int16 v20 = 2080;
  uint64_t v21 = v13;
  uint64_t v14 = (char *)_os_log_send_and_compose_impl();
  sub_1902D398C("Generic", 1, 0, 0, "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = char, Callbacunint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Shared/Intersilo/CLCppContainer.h:241:46)]", "CoreLocation: %s\n", v14);
  if (v14 != (char *)buf) {
    free(v14);
  }
  return 0;
}

uint64_t sub_1904BA204(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend_binaryVersion(a1, a2, a3);
  objc_msgSend_sizeOfType(a1, v5, v6);
  if (v4)
  {
    if (getenv("_INTERSILO_UNIT_TEST"))
    {
      if (qword_1E929D8A8 != -1) {
        dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
      }
      uint64_t v9 = qword_1E929D8B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = *(void *)(MEMORY[0x1E4FBA380] + 8) & 0x7FFFFFFFFFFFFFFFLL;
        *(_DWORD *)buf = 134218498;
        uint64_t v16 = v4;
        __int16 v17 = 2048;
        uint64_t v18 = 0;
        __int16 v19 = 2080;
        uint64_t v20 = v10;
        _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_ERROR, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
      }
      if (!sub_1902D8400(115, 0)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8A8 == -1)
      {
LABEL_20:
        uint64_t v14 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = char, Callbacunint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Shared/Intersilo/CLCppContainer.h:250:46)]", "CoreLocation: %s\n", v14);
        if (v14 != (char *)buf) {
          free(v14);
        }
        return 0;
      }
    }
    else
    {
      if (qword_1E929D8A8 != -1) {
        dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
      }
      uint64_t v12 = qword_1E929D8B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_FAULT))
      {
        uint64_t v13 = *(void *)(MEMORY[0x1E4FBA380] + 8) & 0x7FFFFFFFFFFFFFFFLL;
        *(_DWORD *)buf = 134218498;
        uint64_t v16 = v4;
        __int16 v17 = 2048;
        uint64_t v18 = 0;
        __int16 v19 = 2080;
        uint64_t v20 = v13;
        _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_FAULT, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
      }
      if (!sub_1902D8400(115, 0)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8A8 == -1) {
        goto LABEL_20;
      }
    }
    dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
    goto LABEL_20;
  }

  return objc_msgSend_cppObjectPtr(a1, v7, v8);
}

uint64_t sub_1904BA5B4(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!objc_msgSend_cppObjectPtr(a2, (const char *)a2, a3))
  {
    uint64_t v6 = objc_msgSend_compatibilityInfo(a2, v4, v5);
    if (objc_msgSend_isEqual_(v6, v7, (uint64_t)&unk_1EE001C30))
    {
      uint64_t v8 = objc_msgSend_serialized(a2, v4, v5);
      if (objc_msgSend_length(v8, v9, v10) != 1)
      {
        if (qword_1E929D8A8 != -1) {
          dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
        }
        __int16 v19 = qword_1E929D8B0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 68289539;
          int v23 = 0;
          __int16 v24 = 2082;
          uint64_t v25 = "";
          __int16 v26 = 2082;
          uint64_t v27 = "assert";
          __int16 v28 = 2081;
          float v29 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
          if (qword_1E929D8A8 != -1) {
            dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
          }
        }
        uint64_t v20 = qword_1E929D8B0;
        if (os_signpost_enabled((os_log_t)qword_1E929D8B0))
        {
          *(_DWORD *)buf = 68289539;
          int v23 = 0;
          __int16 v24 = 2082;
          uint64_t v25 = "";
          __int16 v26 = 2082;
          uint64_t v27 = "assert";
          __int16 v28 = 2081;
          float v29 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_signpost_emit_with_name_impl(&dword_1902AF000, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "The total size of the POD types on the 2 architectures is expected to be the same.", "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
          if (qword_1E929D8A8 != -1) {
            dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
          }
        }
        uint64_t v21 = qword_1E929D8B0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 68289539;
          int v23 = 0;
          __int16 v24 = 2082;
          uint64_t v25 = "";
          __int16 v26 = 2082;
          uint64_t v27 = "assert";
          __int16 v28 = 2081;
          float v29 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        }
        abort_report_np();
      }
      uint64_t v13 = objc_msgSend_serialized(a2, v11, v12);
      uint64_t v16 = objc_msgSend_bytes(v13, v14, v15);
      objc_msgSend_setCppObjectPtr_(a2, v17, v16);
    }
  }

  return objc_msgSend_cppObjectPtr(a2, v4, v5);
}

os_log_t sub_1904BA878()
{
  os_log_t result = os_log_create("com.apple.locationd.Support", "Support");
  qword_1E929D8B0 = (uint64_t)result;
  return result;
}

void sub_1904BA8A8()
{
}

uint64_t sub_1904BA95C(uint64_t result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!*(unsigned char *)(result + 108))
  {
    uint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32);
    LODWORD(v14) = *(_DWORD *)(*(void *)a3 + 32);
    uint64_t v9 = sub_1904BAD10(a4);
    uint64_t v10 = *(void *)a3 + 80;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40);
    uint64_t v15 = (int *)(*(void *)a2 + 32);
    uint64_t v12 = sub_1904BAC2C(v11, v15, (uint64_t)&unk_1906099C2, &v15);
    os_log_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t **))(*(void *)v7 + 192))(v7, v8, &v14, v9, v10, v12 + 4);
    if (result) {
      return objc_msgSend_onNotification_withData_(*(void **)(*(void *)a2 + 64), v13, *(unsigned int *)(*(void *)a3 + 32), a4, v14);
    }
  }
  return result;
}

uint64_t **sub_1904BAA54(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  uint64_t v8 = a1 + 1;
  uint64_t v9 = a1 + 1;
  if (v6)
  {
    int v10 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v11 >= v10) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    uint64_t v12 = operator new(0x58uLL);
    v14[1] = v7;
    v12[8] = **a4;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 3) = 0u;
    *((void *)v12 + 9) = 0;
    *((void *)v12 + 10) = 0;
    *((void *)v12 + 5) = v12 + 12;
    *((void *)v12 + 8) = 0;
    char v15 = 1;
    sub_1904B98E4(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0;
    sub_1904BAB54((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

void sub_1904BAB54(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1904BABAC((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void sub_1904BABAC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_1902D8B58(v2);
  }
  uint64_t v3 = *(void **)(a1 + 16);

  sub_1904B9BBC(a1 + 8, v3);
}

uint64_t sub_1904BABF0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_1902D8B58(v2);
  }
  sub_1904B9BBC(a1, *(void **)(a1 + 8));
  return a1;
}

uint64_t **sub_1904BAC2C(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    int v11 = operator new(0x28uLL);
    _OWORD v11[7] = **a4;
    *((unsigned char *)v11 + 32) = 0;
    sub_1904B98E4(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_1904BACF0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    JUMPOUT(0x192FCC980);
  }
  return result;
}

uint64_t sub_1904BAD10(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    return sub_1904BADAC(a1, v2, v3);
  }
  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      return sub_1904BB118(a1, v5, v6);
    }
    else
    {
      return 0;
    }
  }
}

uint64_t sub_1904BADAC(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend_binaryVersion(a1, a2, a3);
  objc_msgSend_sizeOfType(a1, v5, v6);
  if (!v4) {
    return sub_1904BB4B8((uint64_t)&v12, a1, v7);
  }
  if (!getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_1E929D8A8 != -1) {
      dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
    }
    int v10 = qword_1E929D8B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218498;
      uint64_t v20 = v4;
      __int16 v21 = 2048;
      uint64_t v22 = 0;
      __int16 v23 = 2080;
      unint64_t v24 = (unint64_t)"N30CLGyroCalibrationDatabase_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_FAULT, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
    }
    if (!sub_1902D8400(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8A8 == -1) {
      goto LABEL_18;
    }
    goto LABEL_20;
  }
  if (qword_1E929D8A8 != -1) {
    dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
  }
  int v8 = qword_1E929D8B0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134218498;
    uint64_t v20 = v4;
    __int16 v21 = 2048;
    uint64_t v22 = 0;
    __int16 v23 = 2080;
    unint64_t v24 = (unint64_t)"N30CLGyroCalibrationDatabase_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_ERROR, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
  }
  if (!sub_1902D8400(115, 0)) {
    return 0;
  }
  bzero(buf, 0x65CuLL);
  if (qword_1E929D8A8 != -1) {
LABEL_20:
  }
    dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
LABEL_18:
  int v13 = 134218498;
  uint64_t v14 = v4;
  __int16 v15 = 2048;
  uint64_t v16 = 0;
  __int16 v17 = 2080;
  unint64_t v18 = (unint64_t)"N30CLGyroCalibrationDatabase_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
  int v11 = (char *)_os_log_send_and_compose_impl();
  sub_1902D398C("Generic", 1, 0, 0, "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLGyroCalibrationDatabase_Type::NotificationData, Callbacunint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Shared/Intersilo/CLCppContainer.h:241:46)]", "CoreLocation: %s\n", v11);
  if (v11 != (char *)buf) {
    free(v11);
  }
  return 0;
}

uint64_t sub_1904BB118(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend_binaryVersion(a1, a2, a3);
  objc_msgSend_sizeOfType(a1, v5, v6);
  if (v4)
  {
    if (getenv("_INTERSILO_UNIT_TEST"))
    {
      if (qword_1E929D8A8 != -1) {
        dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
      }
      uint64_t v9 = qword_1E929D8B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218498;
        uint64_t v14 = v4;
        __int16 v15 = 2048;
        uint64_t v16 = 0;
        __int16 v17 = 2080;
        unint64_t v18 = (unint64_t)"N30CLGyroCalibrationDatabase_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
        _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_ERROR, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
      }
      if (!sub_1902D8400(115, 0)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8A8 == -1)
      {
LABEL_20:
        char v12 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLGyroCalibrationDatabase_Type::NotificationData, Callbacunint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Shared/Intersilo/CLCppContainer.h:250:46)]", "CoreLocation: %s\n", v12);
        if (v12 != (char *)buf) {
          free(v12);
        }
        return 0;
      }
    }
    else
    {
      if (qword_1E929D8A8 != -1) {
        dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
      }
      int v11 = qword_1E929D8B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 134218498;
        uint64_t v14 = v4;
        __int16 v15 = 2048;
        uint64_t v16 = 0;
        __int16 v17 = 2080;
        unint64_t v18 = (unint64_t)"N30CLGyroCalibrationDatabase_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
        _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_FAULT, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
      }
      if (!sub_1902D8400(115, 0)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8A8 == -1) {
        goto LABEL_20;
      }
    }
    dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
    goto LABEL_20;
  }

  return objc_msgSend_cppObjectPtr(a1, v7, v8);
}

uint64_t sub_1904BB4B8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!objc_msgSend_cppObjectPtr(a2, (const char *)a2, a3))
  {
    uint64_t v6 = objc_msgSend_compatibilityInfo(a2, v4, v5);
    if (objc_msgSend_isEqual_(v6, v7, (uint64_t)&unk_1EE001C30))
    {
      uint64_t v8 = objc_msgSend_serialized(a2, v4, v5);
      if (objc_msgSend_length(v8, v9, v10) != 320)
      {
        if (qword_1E929D8A8 != -1) {
          dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
        }
        uint64_t v19 = qword_1E929D8B0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 68289539;
          int v23 = 0;
          __int16 v24 = 2082;
          uint64_t v25 = "";
          __int16 v26 = 2082;
          uint64_t v27 = "assert";
          __int16 v28 = 2081;
          float v29 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
          if (qword_1E929D8A8 != -1) {
            dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
          }
        }
        uint64_t v20 = qword_1E929D8B0;
        if (os_signpost_enabled((os_log_t)qword_1E929D8B0))
        {
          *(_DWORD *)buf = 68289539;
          int v23 = 0;
          __int16 v24 = 2082;
          uint64_t v25 = "";
          __int16 v26 = 2082;
          uint64_t v27 = "assert";
          __int16 v28 = 2081;
          float v29 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_signpost_emit_with_name_impl(&dword_1902AF000, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "The total size of the POD types on the 2 architectures is expected to be the same.", "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
          if (qword_1E929D8A8 != -1) {
            dispatch_once(&qword_1E929D8A8, &unk_1EDFD2FE0);
          }
        }
        __int16 v21 = qword_1E929D8B0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 68289539;
          int v23 = 0;
          __int16 v24 = 2082;
          uint64_t v25 = "";
          __int16 v26 = 2082;
          uint64_t v27 = "assert";
          __int16 v28 = 2081;
          float v29 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        }
        abort_report_np();
      }
      int v13 = objc_msgSend_serialized(a2, v11, v12);
      uint64_t v16 = objc_msgSend_bytes(v13, v14, v15);
      objc_msgSend_setCppObjectPtr_(a2, v17, v16);
    }
  }

  return objc_msgSend_cppObjectPtr(a2, v4, v5);
}

uint64_t **sub_1904BB77C(uint64_t **a1, int *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    sub_1904B98E4(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t sub_1904BB838(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 28);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      int v7 = (uint64_t *)v2;
    }
    else {
      int v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 28)) {
    return 0;
  }
  sub_1904B9D78((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

void sub_1904BB8B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0E10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1904BB8D4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0E10;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904BB930(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_1902D8B58(v2);
  }
  sub_1904B9BBC(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

void sub_1904BB96C()
{
}

void sub_1904BBA20(uint64_t a1, int *a2, void *a3)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 108))
  {
    uint64_t v5 = a1 + 64;
    uint64_t v4 = *(void *)(a1 + 64);
    if (v4)
    {
      int v8 = *a2;
      uint64_t v9 = a1 + 64;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v4;
        }
        else {
          uint64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          uint64_t v9 = v4;
        }
        uint64_t v4 = *v12;
      }
      while (*v12);
      if (v9 != v5 && v8 >= *(_DWORD *)(v9 + 32))
      {
        uint64_t v49 = v9;
        uint64_t v13 = sub_1904BAD10(a3);
        (*(void (**)(uint64_t, int *, uint64_t, uint64_t))(*(void *)a1 + 184))(a1, a2, v13, v9 + 80);
        uint64_t v14 = *(void **)(v9 + 40);
        if (v14 != (void *)(v9 + 48))
        {
          uint64_t v15 = (uint64_t *)(a1 + 88);
          uint64_t v16 = (uint64_t *)(a1 + 8);
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            uint64_t v19 = a1 + 88;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                uint64_t v22 = (uint64_t *)v17;
              }
              else {
                uint64_t v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                uint64_t v19 = v17;
              }
              uint64_t v17 = *v22;
            }
            while (*v22);
            if ((uint64_t *)v19 != v15 && (int v23 = *(_DWORD *)(v19 + 32), v18 >= v23))
            {
              uint64_t v48 = v19;
              sub_1904BA95C(a1, (uint64_t)&v48, (uint64_t)&v49, a3);
              uint64_t v27 = *(void *)(a1 + 64);
              if (!v27) {
                return;
              }
              int v28 = *a2;
              uint64_t v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  uint64_t v32 = (uint64_t *)v27;
                }
                else {
                  uint64_t v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  uint64_t v29 = v27;
                }
                uint64_t v27 = *v32;
              }
              while (*v32);
              if (v29 == v5 || v28 < *(_DWORD *)(v29 + 32)) {
                return;
              }
              uint64_t v49 = v29;
              uint64_t v34 = *(void *)(v29 + 48);
              uint64_t v14 = (void *)(v29 + 48);
              uint64_t v33 = v34;
              if (v34)
              {
                uint64_t v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    __int16 v39 = (uint64_t *)v36;
                  }
                  else {
                    __int16 v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    uint64_t v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }
                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      char v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      char v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      uint64_t v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }
                  while (*v42);
                }
                else
                {
                  uint64_t v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      uint64_t v14 = v43;
                      uint64_t v43 = (void *)*v43;
                    }
                    while (v43);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      uint64_t v35 = v14;
                    }
                    while (!v44);
                  }
                }
              }
            }
            else
            {
LABEL_25:
              uint64_t v48 = a1 + 88;
              if (qword_1E929D728 != -1) {
                dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
              }
              __int16 v24 = qword_1E929D720;
              if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_FAULT))
              {
                uint64_t v25 = a1 + 8;
                if (*(char *)(a1 + 31) < 0) {
                  uint64_t v25 = *v16;
                }
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)buf = 136446466;
                uint64_t v55 = v25;
                __int16 v56 = 1026;
                int v57 = v26;
                _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_FAULT, "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }
              if (sub_1902D8400(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1E929D728 != -1) {
                  dispatch_once(&qword_1E929D728, &unk_1EDFD18E0);
                }
                uint64_t v45 = a1 + 8;
                if (*(char *)(a1 + 31) < 0) {
                  uint64_t v45 = *v16;
                }
                int v46 = *((_DWORD *)v14 + 7);
                int v50 = 136446466;
                uint64_t v51 = v45;
                __int16 v52 = 1026;
                int v53 = v46;
                uint64_t v47 = (char *)_os_log_send_and_compose_impl();
                sub_1902D398C("Generic", 1, 0, 0, "void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v47);
                if (v47 != (char *)buf) {
                  free(v47);
                }
              }
            }
          }
          while (v14 != (void *)(v49 + 48));
        }
      }
    }
  }
}

uint64_t **sub_1904BBE10(uint64_t **a1, __n128 *a2)
{
  uint64_t v4 = a1 + 1;
  uint64_t v5 = (__n128 *)operator new(0x58uLL);
  v12[0] = v5;
  v12[1] = v4;
  sub_1904BBEF0(v5 + 2, a2);
  char v13 = 1;
  int v7 = a1[1];
  if (v7)
  {
    int v8 = *v6;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v7;
        int v10 = *((_DWORD *)v7 + 8);
        if (v8 >= v10) {
          break;
        }
        int v7 = *v9;
        uint64_t v4 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      int v7 = v9[1];
      if (!v7)
      {
        uint64_t v4 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = v4;
LABEL_10:
    sub_1904B98E4(a1, (uint64_t)v9, v4, (uint64_t *)v5);
    v12[0] = 0;
    uint64_t v9 = (uint64_t **)v5;
  }
  sub_1904BAB54((uint64_t)v12, 0);
  return v9;
}

__n128 sub_1904BBEF0(__n128 *a1, __n128 *a2)
{
  a1->n128_u32[0] = a2->n128_u32[0];
  a1->n128_u64[1] = a2->n128_u64[1];
  uint64_t v2 = a2 + 1;
  unint64_t v3 = a2[1].n128_u64[0];
  a1[1].n128_u64[0] = v3;
  uint64_t v4 = a1 + 1;
  unint64_t v5 = a2[1].n128_u64[1];
  a1[1].n128_u64[1] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2->n128_u64[1] = (unint64_t)v2;
    v2->n128_u64[0] = 0;
    a2[1].n128_u64[1] = 0;
  }
  else
  {
    a1->n128_u64[1] = (unint64_t)v4;
  }
  __n128 result = a2[2];
  a1[2] = result;
  a2[2].n128_u64[0] = 0;
  a2[2].n128_u64[1] = 0;
  a1[3].n128_u8[0] = a2[3].n128_u8[0];
  return result;
}

uint64_t sub_1904BBF48(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)a1 = *a2;
  sub_1904BBFA0((uint64_t *)(a1 + 8), a3);
  uint64_t v5 = *(void *)(a3 + 32);
  *(void *)(a1 + 32) = *(void *)(a3 + 24);
  *(void *)(a1 + 40) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a3 + 40);
  return a1;
}

uint64_t *sub_1904BBFA0(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1904BBFF8(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1904BBFE0(_Unwind_Exception *a1)
{
  sub_1904B9BBC(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1904BBFF8(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    BOOL v6 = result + 1;
    do
    {
      __n128 result = sub_1904BC084(v5, v6, v4 + 7, (uint64_t *)(v4 + 7));
      int v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          int v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1904BC084(uint64_t **a1, uint64_t *a2, int *a3, uint64_t *a4)
{
  BOOL v6 = sub_1904BC10C(a1, a2, &v11, &v10, a3);
  int v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    int v7 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v7 + 28) = *a4;
    sub_1904B98E4(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *sub_1904BC10C(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, int v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    int v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      BOOL v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      char v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        char v13 = v10;
      }
      while (v14);
    }
    int v15 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = (uint64_t *)v16;
          int v18 = *(_DWORD *)(v16 + 28);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      uint64_t v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    uint64_t v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      uint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    uint64_t v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      uint64_t v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 7))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          BOOL v21 = (uint64_t *)v20;
          int v22 = *(_DWORD *)(v20 + 28);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          uint64_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        uint64_t v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      BOOL v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t sub_1904BC2B4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    JUMPOUT(0x192FCC980);
  }
  return result;
}

intptr_t sub_1904BC2D4(void *a1, const char *a2, uint64_t a3)
{
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = sub_190554E98(*(void *)(a1[6] + 8) + 48, a2, a3);
  uint64_t v4 = a1[4];

  return dispatch_semaphore_signal(v4);
}

void sub_1904BC770(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_1904BC7AC(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  int v7 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v5, 0);
  if (*a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7)) != 0
    && (uint64_t v10 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage")) != 0)
  {
    int v13 = objc_msgSend_intValue(v10, v11, v12);
  }
  else
  {
    int v13 = 103;
  }
  if (qword_1E929DA48 != -1) {
    dispatch_once(&qword_1E929DA48, &unk_1EDFD3C40);
  }
  BOOL v14 = qword_1E929DA50;
  if (os_log_type_enabled((os_log_t)qword_1E929DA50, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67240192;
    int v17 = v13;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "Failed with error, %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929DA48 != -1) {
      dispatch_once(&qword_1E929DA48, &unk_1EDFD3C40);
    }
    int v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMSpringTrackerInternal init]_block_invoke", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
}

void sub_1904BC9C4(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v7 = ExecutablePathFromPid;
    if (qword_1E929DA48 != -1) {
      dispatch_once(&qword_1E929DA48, &unk_1EDFD3C40);
    }
    int v8 = qword_1E929DA50;
    if (os_log_type_enabled((os_log_t)qword_1E929DA50, OS_LOG_TYPE_INFO))
    {
      pid_t v9 = getpid();
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412802;
      uint64_t v16 = v7;
      __int16 v17 = 1024;
      pid_t v18 = v9;
      __int16 v19 = 2048;
      uint64_t v20 = v10;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_INFO, "Client connection interrupt, %@, %d, %p", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929DA48 != -1) {
        dispatch_once(&qword_1E929DA48, &unk_1EDFD3C40);
      }
      getpid();
      BOOL v14 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMSpringTrackerInternal init]_block_invoke", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
  }
  uint64_t v11 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v11 + 24))
  {
    id v12 = (id)objc_msgSend_copy(*(void **)(v11 + 32), v5, v6);
    objc_msgSend__startWithHandler_(*(void **)(a1 + 32), v13, (uint64_t)v12);
  }
}

void sub_1904BCD3C(uint64_t a1)
{
  uint64_t v2 = (std::__shared_weak_count *)operator new(0x70uLL);
  v2->__shared_owners_ = 0;
  v2->__shared_weak_owners_ = 0;
  v2->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0DA0;
  sub_1902C3F54(__p, "SpringTracking/kCLConnectionMessageSpringTrackerIsTracking");
  MEMORY[0x192FCC410](&v2[1], __p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  unint64_t v3 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v8 = objc_msgSend_setWithObjects_(v3, v7, v4, v5, v6, 0);
  int v15 = v2 + 1;
  uint64_t v16 = v2;
  atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v11 = objc_msgSend_sendMessage_withReplyClassesSync_(CMMotionUtils, v9, (uint64_t)&v15, v8);
  if (v16) {
    sub_1902D8B58(v16);
  }
  id v12 = objc_msgSend_objectForKeyedSubscript_(v11, v10, @"CMReturnCode");
  if (v11 && v12 && objc_msgSend_BOOLValue(v12, v13, v14)) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  sub_1902D8B58(v2);
}

void sub_1904BCE88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a13) {
    sub_1902D8B58(a13);
  }
  sub_1902D8B58(v19);
  _Unwind_Resume(a1);
}

void sub_1904BCF54(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 32) + 32) = 0;
  *(void *)(*(void *)(a1 + 32) + 32) = *(id *)(a1 + 40);
  uint64_t v2 = (std::__shared_weak_count *)operator new(0x70uLL);
  v2->__shared_owners_ = 0;
  v2->__shared_weak_owners_ = 0;
  v2->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0DA0;
  sub_1902C3F54(v3, "SpringTracking/kCLConnectionMessageSpringTrackerStart");
  MEMORY[0x192FCC410](&v2[1], v3);
  if (v4 < 0) {
    operator delete(v3[0]);
  }
  atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  CLConnectionClient::sendMessage();
  if (v2) {
    sub_1902D8B58(v2);
  }
  sub_1902D8B58(v2);
}

void sub_1904BD088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_1902D8B58(a17);
  }
  sub_1902D8B58(v17);
  _Unwind_Resume(a1);
}

void sub_1904BD0D4(uint64_t a1, const char *a2)
{
  unint64_t v3 = *(void **)(a1 + 32);
  char v4 = (std::__shared_weak_count *)*((void *)a2 + 1);
  uint64_t v5 = *(void *)a2;
  uint64_t v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  objc_msgSend__handleStartStopResponse_handler_(v3, a2, (uint64_t)&v5, *(void *)(a1 + 40));
  if (v6) {
    sub_1902D8B58(v6);
  }
  *(unsigned char *)(*(void *)(a1 + 32) + 24) = 1;
}

void sub_1904BD13C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904BD1C8()
{
  uint64_t v0 = (std::__shared_weak_count *)operator new(0x70uLL);
  v0->__shared_owners_ = 0;
  v0->__shared_weak_owners_ = 0;
  v0->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0DA0;
  sub_1902C3F54(v1, "SpringTracking/kCLConnectionMessageSpringTrackerStop");
  MEMORY[0x192FCC410](&v0[1], v1);
  if (v2 < 0) {
    operator delete(v1[0]);
  }
  atomic_fetch_add_explicit(&v0->__shared_owners_, 1uLL, memory_order_relaxed);
  CLConnectionClient::sendMessage();
  if (v0) {
    sub_1902D8B58(v0);
  }
  sub_1902D8B58(v0);
}

void sub_1904BD2D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_1902D8B58(a17);
  }
  sub_1902D8B58(v17);
  _Unwind_Resume(a1);
}

void sub_1904BD324(uint64_t a1, const char *a2)
{
  unint64_t v3 = *(void **)(a1 + 32);
  char v4 = (std::__shared_weak_count *)*((void *)a2 + 1);
  uint64_t v5 = *(void *)a2;
  uint64_t v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  objc_msgSend__handleStartStopResponse_handler_(v3, a2, (uint64_t)&v5, *(void *)(a1 + 40));
  if (v6) {
    sub_1902D8B58(v6);
  }
  *(unsigned char *)(*(void *)(a1 + 32) + 24) = 0;
}

void sub_1904BD388(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904BD7E0(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  char v4 = *(uint64_t (**)(uint64_t, uint64_t))(v2 + 16);

  return v4(v2, v3);
}

uint64_t sub_1904BD840(uint64_t a1, const char *a2, uint64_t a3)
{
  int v4 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = *(void *)(a1 + 40);
  if (v4 == 100)
  {
    uint64_t v8 = 0;
  }
  else
  {
    pid_t v9 = (void *)MEMORY[0x1E4F28C58];
    int v10 = objc_msgSend_intValue(*(void **)(a1 + 32), v5, v6);
    uint64_t v8 = objc_msgSend_errorWithDomain_code_userInfo_(v9, v11, @"CMErrorDomain", v10, 0);
  }
  id v12 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 16);

  return v12(v7, v8);
}

uint64_t sub_1904BD8D4(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  int v4 = *(uint64_t (**)(uint64_t, uint64_t))(v2 + 16);

  return v4(v2, v3);
}

void sub_1904BD9AC(uint64_t a1, const char *a2)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v16 = @"CMSpringKeyDataRecord";
    v17[0] = v2;
    uint64_t v13 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], a2, (uint64_t)v17, &v16, 1);
  }
  else
  {
    id v3 = objc_alloc(MEMORY[0x1E4F29128]);
    uint64_t v5 = objc_msgSend_initWithUUIDString_(v3, v4, @"00000000-0000-0000-0000-000000000000");
    uint64_t v6 = [CMSleepData alloc];
    uint64_t v8 = objc_msgSend_initWithSessionId_(v6, v7, (uint64_t)v5);
    uint64_t v14 = @"CMSpringKeyDataRecord";
    int v15 = v8;
    uint64_t v13 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v9, (uint64_t)&v15, &v14, 1);
  }
  sub_1904BE50C("SpringTracking/kCLConnectionMessageSpringTrackerQuery", &v13, &v11);
  int v10 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CLConnectionClient::sendMessage();
  if (v10) {
    sub_1902D8B58(v10);
  }
  if (v12) {
    sub_1902D8B58(v12);
  }
}

void sub_1904BDB50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15) {
    sub_1902D8B58(a15);
  }
  if (a17) {
    sub_1902D8B58(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904BDB7C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v4 = (id)objc_msgSend_copy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v11 = (NSSet *)objc_msgSend_setWithObjects_(v5, v10, v6, v7, v8, v9, 0);
  if (*(void *)a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v11)) != 0)
  {
    uint64_t v14 = DictionaryOfClasses;
    uint64_t v15 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v13, @"CMErrorMessage");
    uint64_t v17 = objc_msgSend_objectForKeyedSubscript_(v14, v16, @"CMSpringKeyDataArray");
    if (v15)
    {
      char v18 = v24;
      v24[0] = MEMORY[0x1E4F143A8];
      v24[1] = 3221225472;
      v24[2] = sub_1904BDF64;
      v24[3] = &unk_1E568D320;
      v24[4] = v15;
      v24[5] = v4;
    }
    else if (v17)
    {
      char v18 = v23;
      v23[0] = MEMORY[0x1E4F143A8];
      v23[1] = 3221225472;
      v23[2] = sub_1904BDFDC;
      _DWORD v23[3] = &unk_1E568D320;
      v23[4] = v17;
      v23[5] = v4;
    }
    else
    {
      if (qword_1E929DA48 != -1) {
        dispatch_once(&qword_1E929DA48, &unk_1EDFD3C40);
      }
      __int16 v19 = qword_1E929DA50;
      if (os_log_type_enabled((os_log_t)qword_1E929DA50, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_FAULT, "Error parsing query response.", buf, 2u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929DA48 != -1) {
          dispatch_once(&qword_1E929DA48, &unk_1EDFD3C40);
        }
        __int16 v22 = 0;
        uint64_t v20 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "-[CMSpringTrackerInternal _querySpringDataFromRecord:handler:]_block_invoke", "CoreLocation: %s\n", v20);
        if (v20 != (char *)buf) {
          free(v20);
        }
      }
      char v18 = v21;
      v21[0] = MEMORY[0x1E4F143A8];
      v21[1] = 3221225472;
      v21[2] = sub_1904BDFF4;
      _DWORD v21[3] = &unk_1E568D2D0;
      v21[4] = v4;
    }
  }
  else
  {
    char v18 = block;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_1904BDF00;
    block[3] = &unk_1E568D2D0;
    void block[4] = v4;
  }
  dispatch_async(MEMORY[0x1E4F14428], v18);
}

uint64_t sub_1904BDF00(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  id v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_1904BDF64(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

uint64_t sub_1904BDFDC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1904BDFF4(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_1904BE154(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__teardown(*(void **)(a1 + 32), a2, a3);
}

uint64_t sub_1904BE278(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3);
  uint64_t v6 = *(void *)(a1 + 40);

  return objc_msgSend__startWithHandler_(v4, v5, v6);
}

uint64_t sub_1904BE384(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__stopWithHandler_, v5);
}

uint64_t sub_1904BE498(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__querySpringDataFromRecord_handler_, v5);
}

os_log_t sub_1904BE4DC()
{
  os_log_t result = os_log_create("com.apple.locationd.Position", "Spring");
  qword_1E929DA50 = (uint64_t)result;
  return result;
}

void *sub_1904BE50C@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  os_log_t result = sub_1904BE570(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1904BE55C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1904BE570(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_1904BE5E4((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_1904BE5D0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1904BE5E4(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1904BE63C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904BE658(uint64_t a1, char *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 1560) = 0;
  *(void *)(a1 + 1552) = 0;
  *(unsigned char *)(a1 + 1564) = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  uint64_t context = espresso_create_context();
  *(void *)a1 = context;
  if (context)
  {
    plaunint64_t n = espresso_create_plan();
    *(void *)(a1 + 8) = plan;
    if (plan)
    {
      sub_1902C3F54(&v18, a2);
      uint64_t v6 = std::string::append(&v18, "/model.espresso.net");
      std::string __p = *v6;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v18.__r_.__value_.__l.__data_);
      }
      if (espresso_plan_add_network())
      {
        if (qword_1EB3BE898 != -1) {
          dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
        }
        char v7 = off_1EB3BE890;
        if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v18.__r_.__value_.__l.__data_) = 0;
          _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_ERROR, "Failed to add network to Espresso plan", (uint8_t *)&v18, 2u);
        }
        if (!sub_1902D8400(115, 0)) {
          goto LABEL_57;
        }
        bzero(&v18, 0x65CuLL);
        if (qword_1EB3BE898 == -1) {
          goto LABEL_51;
        }
      }
      else if (espresso_plan_build())
      {
        if (qword_1EB3BE898 != -1) {
          dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
        }
        uint64_t v11 = off_1EB3BE890;
        if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v18.__r_.__value_.__l.__data_) = 0;
          _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_ERROR, "Failed to build Espresso plan", (uint8_t *)&v18, 2u);
        }
        if (!sub_1902D8400(115, 0)) {
          goto LABEL_57;
        }
        bzero(&v18, 0x65CuLL);
        if (qword_1EB3BE898 == -1) {
          goto LABEL_51;
        }
      }
      else if (espresso_network_bind_buffer())
      {
        if (qword_1EB3BE898 != -1) {
          dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
        }
        id v12 = off_1EB3BE890;
        if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v18.__r_.__value_.__l.__data_) = 0;
          _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_ERROR, "Failed to bind input buffer", (uint8_t *)&v18, 2u);
        }
        if (!sub_1902D8400(115, 0)) {
          goto LABEL_57;
        }
        bzero(&v18, 0x65CuLL);
        if (qword_1EB3BE898 == -1) {
          goto LABEL_51;
        }
      }
      else
      {
        if (!espresso_network_bind_buffer())
        {
          *(unsigned char *)(a1 + 1564) = 1;
          if (qword_1EB3BE898 != -1) {
            dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
          }
          uint64_t v15 = off_1EB3BE890;
          if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v18.__r_.__value_.__l.__data_) = 0;
            _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_DEFAULT, "The Espresso Network is ready", (uint8_t *)&v18, 2u);
          }
          if (!sub_1902D8400(115, 2)) {
            goto LABEL_57;
          }
          bzero(&v18, 0x65CuLL);
          if (qword_1EB3BE898 != -1) {
            dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
          }
          uint64_t v14 = (std::string *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "CMPdrMLModel::CMPdrMLModel(const char *)", "CoreLocation: %s\n", (const char *)v14);
          goto LABEL_63;
        }
        if (qword_1EB3BE898 != -1) {
          dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
        }
        uint64_t v13 = off_1EB3BE890;
        if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v18.__r_.__value_.__l.__data_) = 0;
          _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_ERROR, "Failed to bind output buffer", (uint8_t *)&v18, 2u);
        }
        if (!sub_1902D8400(115, 0)) {
          goto LABEL_57;
        }
        bzero(&v18, 0x65CuLL);
        if (qword_1EB3BE898 == -1)
        {
LABEL_51:
          uint64_t v14 = (std::string *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "CMPdrMLModel::CMPdrMLModel(const char *)", "CoreLocation: %s\n", (const char *)v14);
LABEL_63:
          if (v14 != &v18) {
            free(v14);
          }
LABEL_57:
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          return a1;
        }
      }
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
      goto LABEL_51;
    }
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
    }
    uint64_t v9 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_ERROR, "Failed to create Espresso plan", (uint8_t *)&v18, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(&v18, 0x65CuLL);
      if (qword_1EB3BE898 == -1) {
        goto LABEL_26;
      }
      goto LABEL_67;
    }
  }
  else
  {
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
    }
    uint64_t v8 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_ERROR, "Failed to create Espresso context", (uint8_t *)&v18, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(&v18, 0x65CuLL);
      if (qword_1EB3BE898 == -1)
      {
LABEL_26:
        int v10 = (std::string *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "CMPdrMLModel::CMPdrMLModel(const char *)", "CoreLocation: %s\n", (const char *)v10);
        if (v10 != &v18) {
          free(v10);
        }
        return a1;
      }
LABEL_67:
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
      goto LABEL_26;
    }
  }
  return a1;
}

void sub_1904BEFCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1904BF018(void *a1)
{
  if (a1[1]) {
    espresso_plan_destroy();
  }
  if (*a1) {
    espresso_context_destroy();
  }
  return a1;
}

uint64_t sub_1904BF058(uint64_t a1, long long *a2, uint64_t a3)
{
  uint64_t v3 = a1 + 24 * *(int *)(a1 + 1556);
  long long v4 = *a2;
  *(void *)(v3 + 368) = *((void *)a2 + 2);
  *(_OWORD *)(v3 + 352) = v4;
  int v5 = *(_DWORD *)(a1 + 1556);
  if ((v5 + 1) <= 0x31) {
    int v6 = v5 + 1;
  }
  else {
    int v6 = 0;
  }
  *(_DWORD *)(a1 + 1556) = v6;
  if (*(unsigned char *)(a1 + 1560))
  {
    *(_DWORD *)(a1 + 1552) = v6;
    int v7 = v6;
  }
  else
  {
    int v7 = *(_DWORD *)(a1 + 1552);
  }
  *(unsigned char *)(a1 + 1560) = v7 == v6;
  return sub_1904BF0B4(a1, a3);
}

uint64_t sub_1904BF0B4(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 1564)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 1560))
  {
    long long v4 = *(char **)(a1 + 16);
    uint64_t v5 = *(int *)(a1 + 1552);
    size_t v6 = 24 * (50 - v5);
    memcpy(v4, (const void *)(a1 + 352 + 24 * (int)v5), v6);
    uint64_t v7 = *(unsigned int *)(a1 + 1552);
    if ((int)v7 >= 1) {
      memcpy(&v4[v6], (const void *)(a1 + 352), 24 * v7);
    }
    if (espresso_plan_execute_sync())
    {
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
      }
      uint64_t v8 = off_1EB3BE890;
      if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_ERROR, "Failed to execute Espresso plan", buf, 2u);
      }
      int v9 = sub_1902D8400(115, 0);
      uint64_t result = 0;
      if (v9)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE898 == -1)
        {
LABEL_19:
          uint64_t v13 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "BOOL CMPdrMLModel::predict(Velocity &, double)", "CoreLocation: %s\n", v13);
          if (v13 != (char *)buf) {
            free(v13);
          }
          return 0;
        }
LABEL_24:
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(a1 + 184);
      int v15 = *(_DWORD *)(v14 + 8);
      *(void *)a2 = *(void *)v14;
      *(_DWORD *)(a2 + 8) = v15;
      return 1;
    }
  }
  else
  {
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD1920);
    }
    uint64_t v11 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_ERROR, "ImuData Buffer not ready", buf, 2u);
    }
    int v12 = sub_1902D8400(115, 0);
    uint64_t result = 0;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE898 == -1) {
        goto LABEL_19;
      }
      goto LABEL_24;
    }
  }
  return result;
}

void sub_1904BF4D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_1904BF514(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v7 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v5, 0);
  if (*a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7)) != 0
    && (int v10 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage")) != 0)
  {
    int v13 = objc_msgSend_intValue(v10, v11, v12);
  }
  else
  {
    int v13 = 103;
  }
  if (qword_1E929D9B8 != -1) {
    dispatch_once(&qword_1E929D9B8, &unk_1EDFD3C20);
  }
  uint64_t v14 = qword_1E929D9C0;
  if (os_log_type_enabled((os_log_t)qword_1E929D9C0, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67240192;
    int v17 = v13;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "CMIndoorOutdoor, Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D9B8 != -1) {
      dispatch_once(&qword_1E929D9B8, &unk_1EDFD3C20);
    }
    int v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMIndoorOutdoorManagerInternal init]_block_invoke", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
}

unsigned char *sub_1904BF72C(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v7 = ExecutablePathFromPid;
    if (qword_1E929D9B8 != -1) {
      dispatch_once(&qword_1E929D9B8, &unk_1EDFD3C20);
    }
    uint64_t v8 = qword_1E929D9C0;
    if (os_log_type_enabled((os_log_t)qword_1E929D9C0, OS_LOG_TYPE_DEFAULT))
    {
      pid_t v9 = getpid();
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412802;
      uint64_t v14 = v7;
      __int16 v15 = 1024;
      pid_t v16 = v9;
      __int16 v17 = 2048;
      uint64_t v18 = v10;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEFAULT, "CMIndoorOutdoor, client connection interrupt, %@, %d, %p", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D9B8 != -1) {
        dispatch_once(&qword_1E929D9B8, &unk_1EDFD3C20);
      }
      getpid();
      uint64_t v12 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMIndoorOutdoorManagerInternal init]_block_invoke", "CoreLocation: %s\n", v12);
      if (v12 != (char *)buf) {
        free(v12);
      }
    }
  }
  uint64_t result = *(unsigned char **)(a1 + 32);
  if (result[40]) {
    return (unsigned char *)objc_msgSend__startIndoorOutdoorUpdates(result, v5, v6);
  }
  return result;
}

void sub_1904BFA1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904BFAAC(uint64_t a1)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(a1 + 32) + 32))
  {
    sub_1902C3F54(&__p, "kCLConnectionMessageIndoorOutdoorUpdate");
    v4[1] = MEMORY[0x1E4F143A8];
    _DWORD v4[2] = 3221225472;
    v4[3] = sub_1904BFC68;
    v4[4] = &unk_1E568D558;
    void v4[5] = *(void *)(a1 + 32);
    CLConnectionClient::setHandlerForMessage();
    if (v7 < 0) {
      operator delete(__p);
    }
    uint64_t v8 = @"kCLConnectionMessageSubscribeKey";
    v9[0] = MEMORY[0x1E4F1CC38];
    v4[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v2, (uint64_t)v9, &v8, 1);
    sub_19044262C("kCLConnectionMessageIndoorOutdoorUpdate", v4, &__p);
    uint64_t v3 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v3) {
      sub_1902D8B58(v3);
    }
    *(unsigned char *)(*(void *)(a1 + 32) + 40) = 1;
    if (v6) {
      sub_1902D8B58(v6);
    }
  }
}

void sub_1904BFC24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a19) {
    sub_1902D8B58(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904BFC68(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  char v7 = (NSSet *)objc_msgSend_setWithObjects_(v4, v6, v5, 0);
  DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7);
  if (*a2) {
    BOOL v10 = DictionaryOfClasses == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    uint64_t result = objc_opt_respondsToSelector();
    if ((result & 1) == 0) {
      return result;
    }
    uint64_t v13 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], v12, @"CMErrorDomain", 103, 0);
LABEL_11:
    uint64_t v24 = v13;
    uint64_t v25 = *(void *)(a1 + 32);
    int v26 = *(void **)(v25 + 16);
    uint64_t v27 = *(void *)(v25 + 24);
    return objc_msgSend_indoorOutdoorManager_updateFailedWithError_(v26, v14, v27, v24);
  }
  __int16 v15 = DictionaryOfClasses;
  pid_t v16 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage");
  uint64_t v18 = objc_msgSend_objectForKeyedSubscript_(v15, v17, @"CMIndoorOutdoorStateKey");
  if (v16)
  {
    uint64_t result = objc_opt_respondsToSelector();
    if ((result & 1) == 0) {
      return result;
    }
    uint64_t v21 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v22 = (int)objc_msgSend_intValue(v16, v19, v20);
    uint64_t v13 = objc_msgSend_errorWithDomain_code_userInfo_(v21, v23, @"CMErrorDomain", v22, 0);
    goto LABEL_11;
  }
  if (v18)
  {
    uint64_t result = objc_opt_respondsToSelector();
    if (result)
    {
      uint64_t v28 = *(void *)(a1 + 32);
      uint64_t v29 = *(void *)(v28 + 16);
      uint64_t v30 = *(void *)(v28 + 24);
      return MEMORY[0x1F4181798](v29, sel_indoorOutdoorManager_didChangeTo_, v30);
    }
  }
  else
  {
    if (qword_1E929D9B8 != -1) {
      dispatch_once(&qword_1E929D9B8, &unk_1EDFD3C20);
    }
    BOOL v31 = qword_1E929D9C0;
    if (os_log_type_enabled((os_log_t)qword_1E929D9C0, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v31, OS_LOG_TYPE_FAULT, "IndoorOutdoor, unable to parse kCLConnectionMessageIndoorOutdoorUpdate message", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D9B8 != -1) {
        dispatch_once(&qword_1E929D9B8, &unk_1EDFD3C20);
      }
      uint64_t v35 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMIndoorOutdoorManagerInternal _startIndoorOutdoorUpdates]_block_invoke", "CoreLocation: %s\n", v35);
      if (v35 != (char *)buf) {
        free(v35);
      }
    }
    uint64_t result = objc_opt_respondsToSelector();
    if (result)
    {
      uint64_t v33 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], v32, @"CMErrorDomain", 103, 0);
      return objc_msgSend_indoorOutdoorManager_updateFailedWithError_(*(void **)(*(void *)(a1 + 32) + 16), v34, *(void *)(*(void *)(a1 + 32) + 24), v33);
    }
  }
  return result;
}

void sub_1904C0060(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  sub_1902C3F54(&__p, "kCLConnectionMessageIndoorOutdoorUpdate");
  CLConnectionClient::setHandlerForMessage();
  if (v11 < 0) {
    operator delete(__p);
  }
  if (*(unsigned char *)(*(void *)(a1 + 32) + 40))
  {
    char v7 = @"kCLConnectionMessageSubscribeKey";
    uint64_t v8 = MEMORY[0x1E4F1CC28];
    uint64_t v6 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v2, (uint64_t)&v8, &v7, 1);
    sub_19044262C("kCLConnectionMessageIndoorOutdoorUpdate", &v6, &__p);
    uint64_t v5 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v5) {
      sub_1902D8B58(v5);
    }
    *(unsigned char *)(*(void *)(a1 + 32) + 40) = 0;
    if (v10) {
      sub_1902D8B58(v10);
    }
  }
  else
  {
    if (qword_1E929D9B8 != -1) {
      dispatch_once(&qword_1E929D9B8, &unk_1EDFD3C20);
    }
    uint64_t v3 = qword_1E929D9C0;
    if (os_log_type_enabled((os_log_t)qword_1E929D9C0, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "IndoorOutdoor, Error stopping updates, no active clients", (uint8_t *)&__p, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_1E929D9B8 != -1) {
        dispatch_once(&qword_1E929D9B8, &unk_1EDFD3C20);
      }
      LOWORD(v6) = 0;
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMIndoorOutdoorManagerInternal _stopIndoorOutdoorUpdates]_block_invoke", "CoreLocation: %s\n", v4);
      if (v4 != (char *)&__p) {
        free(v4);
      }
    }
  }
}

void sub_1904C02CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, std::__shared_weak_count *a18, int a19, __int16 a20,char a21,char a22)
{
  if (a12) {
    sub_1902D8B58(a12);
  }
  if (a18) {
    sub_1902D8B58(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904C0384(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 32) + 32) && *(void *)(a1 + 40))
  {
    sub_1904C0EF0("kCLConnectionMessageIndoorOutdoorLastKnownState", &v2);
    uint64_t v1 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v1) {
      sub_1902D8B58(v1);
    }
    if (v3) {
      sub_1902D8B58(v3);
    }
  }
}

void sub_1904C0464(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_1902D8B58(a15);
  }
  __int16 v17 = *(std::__shared_weak_count **)(v15 - 32);
  if (v17) {
    sub_1902D8B58(v17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904C0488(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  char v7 = (NSSet *)objc_msgSend_setWithObjects_(v4, v6, v5, 0);
  DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7);
  if (*a2) {
    BOOL v10 = DictionaryOfClasses == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], v9, @"CMErrorDomain", 103, 0);
LABEL_9:
    uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v11 + 16);
    uint64_t v23 = v12;
    uint64_t v24 = v11;
    uint64_t v25 = 0;
LABEL_10:
    return v22(v24, v25, v23);
  }
  uint64_t v13 = DictionaryOfClasses;
  uint64_t v14 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage");
  uint64_t v16 = objc_msgSend_objectForKeyedSubscript_(v13, v15, @"CMIndoorOutdoorStateKey");
  if (v14)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v19 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v20 = (int)objc_msgSend_intValue(v14, v17, v18);
    uint64_t v12 = objc_msgSend_errorWithDomain_code_userInfo_(v19, v21, @"CMErrorDomain", v20, 0);
    goto LABEL_9;
  }
  uint64_t v25 = v16;
  if (v16)
  {
    uint64_t v24 = *(void *)(a1 + 32);
    uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v24 + 16);
    uint64_t v23 = 0;
    goto LABEL_10;
  }
  if (qword_1E929D9B8 != -1) {
    dispatch_once(&qword_1E929D9B8, &unk_1EDFD3C20);
  }
  uint64_t v27 = qword_1E929D9C0;
  if (os_log_type_enabled((os_log_t)qword_1E929D9C0, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v27, OS_LOG_TYPE_FAULT, "IndoorOutdoor, Unable to parse query.", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D9B8 != -1) {
      dispatch_once(&qword_1E929D9B8, &unk_1EDFD3C20);
    }
    BOOL v31 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMIndoorOutdoorManagerInternal _lastKnownIndoorOutdoorStateWithHandler:]_block_invoke", "CoreLocation: %s\n", v31);
    if (v31 != (char *)buf) {
      free(v31);
    }
  }
  uint64_t v29 = *(void *)(a1 + 32);
  uint64_t v30 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], v28, @"CMErrorDomain", 103, 0);
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(v29 + 16))(v29, 0, v30);
}

uint64_t sub_1904C08D4(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__teardown(*(void **)(*(void *)(a1 + 32) + 8), a2, a3);
}

os_log_t sub_1904C0EC0()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "IndoorOutdoor");
  qword_1E929D9C0 = (uint64_t)result;
  return result;
}

void *sub_1904C0EF0@<X0>(char *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x70uLL);
  os_log_t result = sub_1904C0F4C(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1904C0F38(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1904C0F4C(void *a1, char *__s)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_1904C0FBC((int)&v4, (uint64_t)(a1 + 3), __s);
  return a1;
}

void sub_1904C0FA8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1904C0FBC(int a1, uint64_t a2, char *__s)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC410](a2, __p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1904C100C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904C1028()
{
  uint64_t result = sub_1902CD6B0();
  if ((result & 0x200) != 0) {
    operator new();
  }
  return result;
}

void sub_1904C10C4(_Unwind_Exception *a1)
{
  sub_1904DC240(v1);
  MEMORY[0x192FCC980](v1, 0x10F1C40817FB44ELL);
  _Unwind_Resume(a1);
}

void sub_1904C10F8(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D8C8 != -1) {
    dispatch_once(&qword_1E929D8C8, &unk_1EDFD3D20);
  }
  uint64_t v6 = qword_1E929D8D0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8D0, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67240448;
    int v11 = a2;
    __int16 v12 = 2050;
    uint64_t v13 = a3;
    _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEBUG, "NumberOfSpectatorsChanged,notification,%{public}d,num,%{public}zu", buf, 0x12u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8C8 != -1) {
      dispatch_once(&qword_1E929D8C8, &unk_1EDFD3D20);
    }
    pid_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLMagicMountNotifier::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  if (a2)
  {
    if (qword_1E929D8C8 != -1) {
      dispatch_once(&qword_1E929D8C8, &unk_1EDFD3D20);
    }
    char v7 = qword_1E929D8D0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8D0, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67240192;
      int v11 = a2;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Unrecognized notification,%{public}d", buf, 8u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8C8 != -1) {
        dispatch_once(&qword_1E929D8C8, &unk_1EDFD3D20);
      }
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual void CLMagicMountNotifier::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  else if (sub_190595F40(a1 + 32))
  {
    sub_1902CDC50(*(void *)(a1 + 40), a3 != 0);
  }
}

void sub_1904C142C(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D8C8 != -1) {
    dispatch_once(&qword_1E929D8C8, &unk_1EDFD3D20);
  }
  uint64_t v3 = qword_1E929D8D0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8D0, OS_LOG_TYPE_INFO))
  {
    int v4 = *(_DWORD *)(a2 + 1);
    *(_DWORD *)buf = 67240192;
    int v7 = v4;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_INFO, "pong,%{public}u", buf, 8u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8C8 != -1) {
      dispatch_once(&qword_1E929D8C8, &unk_1EDFD3D20);
    }
    char v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLMagicMountNotifier::visitPong(const CMMagicMountReport::Pong *)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
}

uint64_t sub_1904C15E4(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D8C8 != -1) {
    dispatch_once(&qword_1E929D8C8, &unk_1EDFD3D20);
  }
  int v4 = qword_1E929D8D0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8D0, OS_LOG_TYPE_DEBUG))
  {
    int v5 = a2[1];
    int v6 = a2[2];
    int v7 = a2[3];
    uint64_t v8 = *(void *)(a1 + 64);
    uint64_t v9 = mach_absolute_time();
    *(_DWORD *)buf = 67241216;
    *(_DWORD *)&uint8_t buf[4] = v5;
    LOWORD(v14) = 1026;
    *(_DWORD *)((char *)&v14 + 2) = v6;
    HIWORD(v14) = 1026;
    int v15 = v7;
    __int16 v16 = 2050;
    uint64_t v17 = v8;
    __int16 v18 = 2050;
    double v19 = sub_1902D8D34(v9);
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEBUG, "Report,mountStatus,%{public}u,APAwake,%{public}u,isSimulated,%{public}u,timestamp,%{public}lf,now,%{public}lf", buf, 0x28u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8C8 != -1) {
      dispatch_once(&qword_1E929D8C8, &unk_1EDFD3D20);
    }
    uint64_t v11 = mach_absolute_time();
    sub_1902D8D34(v11);
    __int16 v12 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLMagicMountNotifier::visitMagicMountState(const CMMagicMountReport::MagicMountState *)", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf) {
      free(v12);
    }
  }
  uint64_t v14 = 0;
  *(void *)buf = *(void *)(a1 + 64);
  LOBYTE(v14) = a2[1];
  *(_WORD *)((char *)&v14 + 1) = *((_WORD *)a2 + 1);
  return sub_1902D8BCC(a1, 0, (uint64_t)buf, 16);
}

uint64_t sub_1904C185C(uint64_t a1, unsigned __int8 *a2)
{
  return sub_1904C15E4(a1 - 32, a2);
}

void *sub_1904C1864(void *a1)
{
  sub_1904C1960((uint64_t)(a1 + 4));

  return sub_1904DC240(a1);
}

void sub_1904C18A0(void *a1)
{
  sub_1904C1960((uint64_t)(a1 + 4));
  sub_1904DC240(a1);

  JUMPOUT(0x192FCC980);
}

void *sub_1904C18F0(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 - 32);
  sub_1904C1960(a1);

  return sub_1904DC240(v1);
}

void sub_1904C1928(uint64_t a1)
{
}

os_log_t sub_1904C1930()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "MagicMount");
  qword_1E929D8D0 = (uint64_t)result;
  return result;
}

uint64_t sub_1904C1960(uint64_t a1)
{
  *(void *)a1 = &unk_1EDFC9860;
  sub_1904C19F8((void **)(a1 + 24), 0);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_1902D8B58(v2);
  }
  return a1;
}

void sub_1904C19B8(uint64_t a1)
{
  sub_1904C1960(a1);

  JUMPOUT(0x192FCC980);
}

void *sub_1904C19F8(void **a1, void *a2)
{
  os_log_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_190513600(result);
    JUMPOUT(0x192FCC980);
  }
  return result;
}

uint64_t sub_1904C1A48(void *a1)
{
  *a1 = &unk_1EDFC9890;
  sub_1904C1AE8((uint64_t)a1);
  uint64_t v2 = (std::__shared_weak_count *)a1[27];
  if (v2) {
    sub_1902D8B58(v2);
  }

  return sub_1905B1F7C((uint64_t)a1);
}

void sub_1904C1AB0(void *a1)
{
  sub_1904C1A48(a1);

  JUMPOUT(0x192FCC980);
}

void sub_1904C1AE8(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *(void *)buf = 0;
  sub_1902CD6F4(a1, (double *)buf);
  if (*(unsigned char *)(a1 + 202))
  {
    *(unsigned char *)(a1 + 202) = 0;
    sub_1905D06F0(*(void *)(a1 + 208));
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1980);
    }
    uint64_t v2 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = sub_1902B8788(*(void *)(a1 + 208));
      *(_DWORD *)buf = 134349056;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "Fast path closed,serviceRef,%{public}p", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1980);
      }
      sub_1902B8788(*(void *)(a1 + 208));
      int v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionServiceSPU::stop()", "CoreLocation: %s\n", v4);
      if (v4 != buf) {
        free(v4);
      }
    }
  }
}

void sub_1904C1CC8(uint64_t a1, uint64_t a2, float32x4_t a3)
{
  uint64_t v5 = *(void *)(a1 + 208);
  if (v5)
  {
    if (*(unsigned char *)(a1 + 202) && (uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5)) != 0)
    {
      uint64_t v8 = (const void *)v6;
      sub_1902D92FC(v6, a2, v7);
      CFRelease(v8);
    }
    else
    {
      sub_1905B2164(a1, a2);
    }
  }
  else
  {
    *(void *)a2 = 0xBFF0000000000000;
    float32x4_t v9 = 0uLL;
    sub_1902D9ACC(&v9, a3);
    *(float32x4_t *)(a2 + 8) = v9;
    *(void *)(a2 + 24) = 0;
    *(_DWORD *)(a2 + 32) = 0;
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 36) = 0;
    *(void *)(a2 + 52) = 0;
    *(void *)(a2 + 44) = 0;
    *(void *)(a2 + 80) = 0;
    *(unsigned char *)(a2 + 88) = 0;
  }
}

os_log_t sub_1904C1DD4()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "AOP");
  qword_1E929D6F0 = (uint64_t)result;
  return result;
}

void sub_1904C1E04(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0D68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1904C1E24(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0D68;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904C1E78(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

CFTypeRef sub_1904C2CE4(const char *a1, uint64_t a2)
{
  CFDictionaryRef v3 = IOServiceNameMatching(a1);
  if (!v3) {
    return 0;
  }
  io_service_t MatchingService = IOServiceGetMatchingService(*MEMORY[0x1E4F2EEF0], v3);
  if (!MatchingService) {
    return 0;
  }
  io_registry_entry_t v6 = MatchingService;
  CFStringRef v7 = (const __CFString *)objc_msgSend_stringWithUTF8String_(NSString, v5, a2);
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v6, v7, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  IOObjectRelease(v6);
  return CFProperty;
}

const void *sub_1904C2D6C()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  CFTypeRef v0 = sub_1904C2CE4("compass", (uint64_t)"compass-calibration");
  if (!v0)
  {
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
    }
    int v4 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "Invalid cpas data.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
      }
      io_registry_entry_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "CFDataRef CLMagnetometerCoexistenceLocal::copyCompassCalibrationData()", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    return 0;
  }
  uint64_t v1 = v0;
  CFTypeID v2 = CFGetTypeID(v0);
  if (v2 != CFDataGetTypeID())
  {
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
    }
    CFDictionaryRef v3 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_INFO, "The cpas data is not a CFData type.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
      }
      CFStringRef v7 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "CFDataRef CLMagnetometerCoexistenceLocal::copyCompassCalibrationData()", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    CFRelease(v1);
    return 0;
  }
  return v1;
}

BOOL sub_1904C3070()
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  CFDataRef v0 = (const __CFData *)sub_1904C2D6C();
  if (v0)
  {
    CFDataRef v1 = v0;
    BytePtr = CFDataGetBytePtr(v0);
    if (!BytePtr)
    {
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
      }
      uint64_t v9 = qword_1E929D790;
      if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_DEFAULT, "#Warning Cpas pointer is NULL.", buf, 2u);
      }
      if (!sub_1902D8400(115, 2)) {
        goto LABEL_40;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
      }
      BOOL v10 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()", "CoreLocation: %s\n");
      goto LABEL_90;
    }
    CFDictionaryRef v3 = BytePtr;
    CFIndex Length = CFDataGetLength(v1);
    if (Length >= 2)
    {
      int v5 = *v3;
      if (Length == 76 && v5 == 5)
      {
        unint64_t v6 = 5;
      }
      else
      {
        if (Length != 76 || v5 != 6)
        {
          if (qword_1E929D798 != -1) {
            dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
          }
          uint64_t v25 = qword_1E929D790;
          if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 67109120;
            LODWORD(v35) = v5;
            _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_FAULT, "Unexpected cpas version: %u.", buf, 8u);
          }
          if (!sub_1902D8400(115, 0)) {
            goto LABEL_40;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1E929D798 == -1) {
            goto LABEL_89;
          }
          goto LABEL_101;
        }
        unint64_t v6 = 8;
      }
      CFDataRef v11 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3 + 2, v6);
      if (v11)
      {
        CFDataRef v12 = v11;
        uint64_t v13 = CFDataGetBytePtr(v11);
        if (v13)
        {
          uint64_t v14 = v13;
          CFDataRef v15 = (const __CFData *)sub_1904C2CE4("AppleH4CamIn", (uint64_t)"BackCameraSerialNumber");
          CFDataRef v16 = v15;
          if (!v15 || (CFTypeID v17 = CFGetTypeID(v15), v17 != CFDataGetTypeID()))
          {
            if (qword_1E929D798 != -1) {
              dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
            }
            int v26 = qword_1E929D790;
            if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1902AF000, v26, OS_LOG_TYPE_FAULT, "Invalid back camera serial number data.", buf, 2u);
            }
            BOOL v8 = 0;
            if (sub_1902D8400(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1E929D798 != -1) {
                dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
              }
              uint64_t v33 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 0, "BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()", "CoreLocation: %s\n", v33);
              if (v33 != (char *)buf) {
                free(v33);
              }
              BOOL v8 = 0;
            }
LABEL_58:
            CFRelease(v1);
            if (!v16)
            {
LABEL_43:
              if (v12) {
                CFRelease(v12);
              }
              return v8;
            }
LABEL_42:
            CFRelease(v16);
            goto LABEL_43;
          }
          if (CFDataGetLength(v16) == v6)
          {
            __int16 v18 = CFDataGetBytePtr(v16);
            if (v18)
            {
              if (*v14 == *v18)
              {
                uint64_t v19 = 1;
                do
                {
                  unint64_t v20 = v19;
                  if (v6 == v19) {
                    break;
                  }
                  int v21 = v14[v19];
                  int v22 = v18[v19++];
                }
                while (v21 == v22);
                BOOL v8 = v20 >= v6;
                goto LABEL_58;
              }
LABEL_83:
              CFRelease(v1);
              BOOL v8 = 0;
              goto LABEL_42;
            }
            if (qword_1E929D798 != -1) {
              dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
            }
            BOOL v31 = qword_1E929D790;
            if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1902AF000, v31, OS_LOG_TYPE_FAULT, "Current serial number data is NULL.", buf, 2u);
            }
            if (!sub_1902D8400(115, 0)) {
              goto LABEL_83;
            }
            bzero(buf, 0x65CuLL);
            if (qword_1E929D798 != -1) {
              dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
            }
            uint64_t v30 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 0, "BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()", "CoreLocation: %s\n", v30);
            if (v30 == (char *)buf) {
              goto LABEL_83;
            }
          }
          else
          {
            if (qword_1E929D798 != -1) {
              dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
            }
            uint64_t v29 = qword_1E929D790;
            if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 134218240;
              CFIndex v35 = CFDataGetLength(v16);
              __int16 v36 = 2048;
              unint64_t v37 = v6;
              _os_log_impl(&dword_1902AF000, v29, OS_LOG_TYPE_FAULT, "Incorrect back camera serial number length. Actual length %ld. Expected length %lu.", buf, 0x16u);
            }
            if (!sub_1902D8400(115, 0)) {
              goto LABEL_83;
            }
            bzero(buf, 0x65CuLL);
            if (qword_1E929D798 != -1) {
              dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
            }
            CFDataGetLength(v16);
            uint64_t v30 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 0, "BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()", "CoreLocation: %s\n", v30);
            if (v30 == (char *)buf) {
              goto LABEL_83;
            }
          }
          free(v30);
          goto LABEL_83;
        }
        if (qword_1E929D798 != -1) {
          dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
        }
        uint64_t v27 = qword_1E929D790;
        if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1902AF000, v27, OS_LOG_TYPE_FAULT, "Original serial number pointer is NULL.", buf, 2u);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D798 != -1) {
            dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
          }
          uint64_t v28 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()", "CoreLocation: %s\n", v28);
          if (v28 != (char *)buf) {
            free(v28);
          }
        }
LABEL_41:
        BOOL v8 = 0;
        CFDataRef v16 = v1;
        goto LABEL_42;
      }
    }
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
    }
    uint64_t v23 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v23, OS_LOG_TYPE_FAULT, "Original serial number data is NULL.", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_40;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 == -1) {
      goto LABEL_89;
    }
LABEL_101:
    dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
LABEL_89:
    BOOL v10 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()", "CoreLocation: %s\n");
LABEL_90:
    if (v10 != buf) {
      free(v10);
    }
LABEL_40:
    CFDataRef v12 = 0;
    goto LABEL_41;
  }
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
  }
  CFStringRef v7 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_DEFAULT, "#Warning Cpas data is NULL.", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
    }
    uint64_t v32 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()", "CoreLocation: %s\n", v32);
    if (v32 != (char *)buf) {
      free(v32);
    }
  }
  return 0;
}

uint64_t sub_1904C3BA4()
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFNumberRef v0 = (const __CFNumber *)sub_1904C2CE4("AppleH4CamIn", (uint64_t)"BackCameraModuleFocusActuatorID");
  CFNumberRef v1 = v0;
  unsigned int valuePtr = -1;
  if (v0 && (CFTypeID v2 = CFGetTypeID(v0), v2 == CFNumberGetTypeID()))
  {
    if (CFNumberGetType(v1) == kCFNumberSInt32Type)
    {
      if (!CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr)) {
        unsigned int valuePtr = -1;
      }
    }
    else
    {
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
      }
      int v4 = qword_1E929D790;
      if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 67109376;
        int Type = CFNumberGetType(v1);
        __int16 v16 = 1024;
        int v17 = 3;
        _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "VCM actuator ID data type %d does not match expected type %d", buf, 0xEu);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D798 != -1) {
          dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
        }
        int v10 = 67109376;
        int v11 = CFNumberGetType(v1);
        __int16 v12 = 1024;
        int v13 = 3;
        BOOL v8 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "NSNumber *CLMagnetometerCoexistenceLocal::cameraVcmId()", "CoreLocation: %s\n", v8);
        if (v8 != (char *)buf) {
          free(v8);
        }
      }
    }
  }
  else
  {
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
    }
    CFDictionaryRef v3 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_INFO, "Bailing while checking VCM actuator ID.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
      }
      LOWORD(v10) = 0;
      CFStringRef v7 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "NSNumber *CLMagnetometerCoexistenceLocal::cameraVcmId()", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    if (!v1) {
      return 0;
    }
  }
  CFRelease(v1);
  if (valuePtr != -1) {
    return objc_msgSend_numberWithInt_(NSNumber, v5, valuePtr);
  }
  return 0;
}

id sub_1904C3F4C()
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFDataRef v0 = (const __CFData *)sub_1904C2D6C();
  if (v0)
  {
    CFDataRef v1 = v0;
    BytePtr = CFDataGetBytePtr(v0);
    if (BytePtr)
    {
      CFDictionaryRef v3 = BytePtr;
      CFIndex Length = CFDataGetLength(v1);
      if (Length >= 2)
      {
        CFIndex v7 = Length;
        int v8 = *v3;
        id v9 = (id)objc_msgSend_mutableCopy(v1, v5, v6);
        id v11 = v9;
        if (v9)
        {
          if (v7 == 76 && v8 == 5)
          {
            objc_msgSend_resetBytesInRange_(v9, v10, 2, 5);
          }
          else if (v7 == 76 && v8 == 6)
          {
            objc_msgSend_resetBytesInRange_(v9, v10, 2, 8);
          }
        }
        goto LABEL_20;
      }
    }
    else
    {
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
      }
      int v13 = qword_1E929D790;
      if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_DEFAULT, "#Warning CPAS pointer is NULL.", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D798 != -1) {
          dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
        }
        __int16 v16 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "NSData *CLMagnetometerCoexistenceLocal::sanitizedCompassCalibrationData()", "CoreLocation: %s\n", v16);
        if (v16 != (char *)buf) {
          free(v16);
        }
      }
    }
    id v11 = 0;
LABEL_20:
    CFRelease(v1);
    return v11;
  }
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
  }
  __int16 v12 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_DEFAULT, "#Warning CPAS data is NULL.", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD19A0);
    }
    CFDataRef v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "NSData *CLMagnetometerCoexistenceLocal::sanitizedCompassCalibrationData()", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
  return 0;
}

os_log_t sub_1904C42AC()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Compass");
  qword_1E929D790 = (uint64_t)result;
  return result;
}

void sub_1904C4828(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(*(void *)(a1 + 32) + 16)) {
    operator new();
  }
  if (qword_1E929D6B8 != -1) {
    dispatch_once(&qword_1E929D6B8, &unk_1EDFD19C0);
  }
  CFDataRef v1 = qword_1E929D6A8;
  if (os_log_type_enabled((os_log_t)qword_1E929D6A8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v1, OS_LOG_TYPE_ERROR, "CallHandedness service already started!", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6B8 != -1) {
      dispatch_once(&qword_1E929D6B8, &unk_1EDFD19C0);
    }
    CFTypeID v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMCallHandednessManager startCallHandednessUpdates]_block_invoke", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
}

void sub_1904C4BC0(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_1904C4BEC(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onCallHandednessStateUpdated_, a1);
}

void sub_1904C4C98(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(a1 + 32) + 16))
  {
    if (qword_1E929E998 != -1) {
      dispatch_once(&qword_1E929E998, &unk_1EDFD22C0);
    }
    sub_1902CDE08(qword_1E929E990, 0, *(void *)(*(void *)(a1 + 32) + 16));
    uint64_t v2 = *(void *)(a1 + 32);
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
      uint64_t v2 = *(void *)(a1 + 32);
    }
    *(void *)(v2 + 16) = 0;
    if (qword_1E929D6B8 != -1) {
      dispatch_once(&qword_1E929D6B8, &unk_1EDFD19C0);
    }
    uint64_t v4 = qword_1E929D6A8;
    if (os_log_type_enabled((os_log_t)qword_1E929D6A8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 134217984;
      uint64_t v9 = v5;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEFAULT, "Stopped CallHandedness updates. Current Time: %f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6B8 != -1) {
        dispatch_once(&qword_1E929D6B8, &unk_1EDFD19C0);
      }
      uint64_t v6 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMCallHandednessManager stopCallHandednessUpdates]_block_invoke", "CoreLocation: %s\n");
LABEL_23:
      if (v6 != buf) {
        free(v6);
      }
    }
  }
  else
  {
    if (qword_1E929D6B8 != -1) {
      dispatch_once(&qword_1E929D6B8, &unk_1EDFD19C0);
    }
    CFIndex v7 = qword_1E929D6A8;
    if (os_log_type_enabled((os_log_t)qword_1E929D6A8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_ERROR, "CallHandedness service already stopped!", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6B8 != -1) {
        dispatch_once(&qword_1E929D6B8, &unk_1EDFD19C0);
      }
      uint64_t v6 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMCallHandednessManager stopCallHandednessUpdates]_block_invoke", "CoreLocation: %s\n");
      goto LABEL_23;
    }
  }
}

uint64_t sub_1904C5170(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D6B0 != -1) {
    dispatch_once(&qword_1E929D6B0, &unk_1EDFD38C0);
  }
  uint64_t v2 = qword_1E929D6A0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6A0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 134217984;
    uint64_t v11 = v3;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "CallHandedness Detection: %ld", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6B0 != -1) {
      dispatch_once(&qword_1E929D6B0, &unk_1EDFD38C0);
    }
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMCallHandednessManager onCallHandednessStateUpdated:]_block_invoke", "CoreLocation: %s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  uint64_t v6 = objc_msgSend_delegate(*(void **)(a1 + 32), v4, v5);
  return objc_msgSend_callHandednessManager_didUpdateState_(v6, v7, *(void *)(a1 + 32), *(void *)(a1 + 40));
}

os_log_t sub_1904C5344()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Gesture");
  qword_1E929D6A8 = (uint64_t)result;
  return result;
}

os_log_t sub_1904C5374()
{
  os_log_t result = os_log_create("com.apple.locationd.Core", "Core");
  qword_1E929D6A0 = (uint64_t)result;
  return result;
}

void sub_1904C53A8(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904C53E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

uint64_t sub_1904C57A8()
{
  uint64_t result = sub_1902CD6B0();
  if ((result & 0x200000000) != 0)
  {
    if (sub_19046CD84()) {
      operator new();
    }
    operator new();
  }
  return result;
}

void sub_1904C58D4(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10F1C40926F10A7);
  _Unwind_Resume(a1);
}

void *sub_1904C590C(void *a1)
{
  *a1 = &unk_1EDFC8738;
  sub_1904C5974((uint64_t)a1, 0, 0);

  return sub_1904DC240(a1);
}

void sub_1904C5974(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a2) {
    return;
  }
  if (a3 == 1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
    if (qword_1E929D6B8 != -1) {
      dispatch_once(&qword_1E929D6B8, &unk_1EDFD3D40);
    }
    uint64_t v4 = qword_1E929D6A8;
    if (os_log_type_enabled((os_log_t)qword_1E929D6A8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v8 = 1;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEBUG, "CMPickupService started, %zd", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6B8 == -1)
      {
LABEL_18:
        uint64_t v5 = (uint8_t *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual void CMPickupService::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n");
LABEL_27:
        if (v5 != buf) {
          free(v5);
        }
        return;
      }
LABEL_29:
      dispatch_once(&qword_1E929D6B8, &unk_1EDFD3D40);
      goto LABEL_18;
    }
  }
  else if (a3)
  {
    if (qword_1E929D6B8 != -1) {
      dispatch_once(&qword_1E929D6B8, &unk_1EDFD3D40);
    }
    uint64_t v6 = qword_1E929D6A8;
    if (os_log_type_enabled((os_log_t)qword_1E929D6A8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_ERROR, "CMPickupService expects only 1 client", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6B8 != -1) {
        dispatch_once(&qword_1E929D6B8, &unk_1EDFD3D40);
      }
      uint64_t v5 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual void CMPickupService::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n");
      goto LABEL_27;
    }
  }
  else
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    if (qword_1E929D6B8 != -1) {
      dispatch_once(&qword_1E929D6B8, &unk_1EDFD3D40);
    }
    uint64_t v3 = qword_1E929D6A8;
    if (os_log_type_enabled((os_log_t)qword_1E929D6A8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v8 = 0;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEBUG, "CMPickupService stopped, %zd", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6B8 == -1) {
        goto LABEL_18;
      }
      goto LABEL_29;
    }
  }
}

os_log_t sub_1904C5D7C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Gesture");
  qword_1E929D6A8 = (uint64_t)result;
  return result;
}

void sub_1904C638C()
{
}

void sub_1904C642C(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10F1C40E7E486F4);
  _Unwind_Resume(a1);
}

void sub_1904C6454(void *a1)
{
  sub_1905A1098(a1);

  JUMPOUT(0x192FCC980);
}

double sub_1904C648C(uint64_t a1, int a2, double *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
    }
    uint64_t v4 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67240192;
      LODWORD(v16) = a2;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "[AccessoryMagnetometer] Unrecognized update interval notification %{public}d", buf, 8u);
    }
    double v5 = 0.0;
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual CFTimeInterval CLAccessoryMagnetometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    sub_1905A2C68(a1);
    if (*a3 > 0.0) {
      *(unsigned char *)(a1 + 30) = 0;
    }
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
    }
    uint64_t v9 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_INFO))
    {
      double v10 = *a3;
      *(_DWORD *)buf = 134349056;
      double v16 = v10;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_INFO, "[AccessoryMagnetometer] Setting update interval to %{public}f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
      }
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryMagnetometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
    double v11 = rint(*a3 * 1000000.0);
    if (*a3 < 0.0) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = (uint64_t)v11;
    }
    sub_1902CDC50(*(void *)(a1 + 32), v12);
    return *a3;
  }
  return v5;
}

double sub_1904C67E4(uint64_t a1, int a2, double *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
    }
    uint64_t v4 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67240192;
      LODWORD(v14) = a2;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "[AccessoryMagnetometer] Unrecognized batch interval notification %{public}d", buf, 8u);
    }
    double v5 = 0.0;
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual CFTimeInterval CLAccessoryMagnetometer::minimumBatchIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    sub_1905A2C68(a1);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
    }
    uint64_t v9 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_INFO))
    {
      double v10 = *a3;
      *(_DWORD *)buf = 134349056;
      double v14 = v10;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_INFO, "[AccessoryMagnetometer] Setting batch interval to %{public}f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
      }
      uint64_t v12 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryMagnetometer::minimumBatchIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v12);
      if (v12 != (char *)buf) {
        free(v12);
      }
    }
    sub_1902CDBA4(*(void *)(a1 + 32), *a3);
    return *a3;
  }
  return v5;
}

uint64_t sub_1904C6B10(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1904C6B54(uint64_t a1)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (IOHIDEventGetType() == 21)
  {
    IOHIDEventGetFloatValue();
    float v3 = v2;
    float v25 = v3;
    IOHIDEventGetFloatValue();
    float v5 = v4;
    float v26 = v5;
    IOHIDEventGetFloatValue();
    float v7 = v6;
    float v27 = v7;
    unint64_t TimeStamp = IOHIDEventGetTimeStamp();
    double v9 = sub_1902D8D34(TimeStamp);
    double v24 = v9;
    Integerint Value = IOHIDEventGetIntegerValue();
    unsigned __int16 v29 = IntegerValue;
    uint64_t v11 = sub_1905E72B8();
    uint64_t v28 = v11;
    float v12 = *(float *)(a1 + 100);
    float v30 = v12;
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
    }
    int v13 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67241728;
      int isa = IntegerValue;
      __int16 v49 = 2050;
      double v50 = v3;
      __int16 v51 = 2050;
      double v52 = v5;
      __int16 v53 = 2050;
      double v54 = v7;
      __int16 v55 = 2050;
      double v56 = v12;
      __int16 v57 = 2050;
      uint64_t v58 = v11;
      __int16 v59 = 2050;
      double v60 = v9;
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_DEBUG, "[AccessoryMagnetometer] seq,%{public}d,x,%{public}20.20f,y,%{public}20.20f,z,%{public}20.20f,temp,%{public}20.20f,sensorTime,%{public}llu,timestamp,%{public}20.20f", buf, 0x44u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
      }
      LODWORD(v31.isa) = 67241728;
      HIDWORD(v31.isa) = IntegerValue;
      *(_WORD *)uint64_t v32 = 2050;
      *(double *)&v32[2] = v3;
      __int16 v33 = 2050;
      double v34 = v5;
      __int16 v35 = 2050;
      *(double *)__int16 v36 = v7;
      *(_WORD *)&v36[8] = 2050;
      double v37 = v12;
      __int16 v38 = 2050;
      *(void *)__int16 v39 = v11;
      *(_WORD *)&v39[8] = 2050;
      double v40 = v9;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLAccessoryMagnetometer::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v19);
      if (v19 != (char *)buf) {
        free(v19);
      }
    }
    sub_1902D8BCC(a1, 0, (uint64_t)&v24, 40);
    if (!*(unsigned char *)(a1 + 30))
    {
      *(unsigned char *)(a1 + 30) = 1;
      LODWORD(v31.isa) = 0;
      sub_1902C3F54(v32, "N/A");
      sub_1902C3F54(&v36[2], "N/A");
      *(_DWORD *)&v39[6] = 0;
      if (sub_1905A3184((const char *)a1, &v31))
      {
        if (qword_1EB3BE838 != -1) {
          dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
        }
        double v14 = qword_1EB3BE830;
        if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEBUG))
        {
          if (v36[1] >= 0) {
            double v15 = COERCE_DOUBLE(v32);
          }
          else {
            double v15 = *(double *)v32;
          }
          if (v39[5] >= 0) {
            double v16 = COERCE_DOUBLE(&v36[2]);
          }
          else {
            double v16 = *(double *)&v36[2];
          }
          *(_DWORD *)buf = 67240707;
          int isa = (int)v31.isa;
          __int16 v49 = 2081;
          double v50 = v15;
          __int16 v51 = 2081;
          double v52 = v16;
          _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_DEBUG, "[AccessoryMagnetometer] config,side,%{public}d,configuration,%{private}s,serialNumber,%{private}s", buf, 0x1Cu);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
          }
          if (v36[1] >= 0) {
            unint64_t v20 = v32;
          }
          else {
            unint64_t v20 = *(unsigned char **)v32;
          }
          if (v39[5] >= 0) {
            int v21 = &v36[2];
          }
          else {
            int v21 = *(unsigned char **)&v36[2];
          }
          int v41 = 67240707;
          int v42 = (int)v31.isa;
          __int16 v43 = 2081;
          BOOL v44 = v20;
          __int16 v45 = 2081;
          int v46 = v21;
          int v22 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryMagnetometer::onMagnetometerData(const Sample &)", "CoreLocation: %s\n", v22);
          if (v22 != (char *)buf) {
            free(v22);
          }
        }
        sub_1902D8BCC(a1, 1, (uint64_t)&v31, 64);
      }
      else
      {
        if (qword_1EB3BE838 != -1) {
          dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
        }
        uint64_t v18 = qword_1EB3BE830;
        if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_FAULT, "[AccessoryMagnetometer] Service not found!", buf, 2u);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFD2E60);
          }
          LOWORD(v41) = 0;
          uint64_t v23 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "void CLAccessoryMagnetometer::onMagnetometerData(const Sample &)", "CoreLocation: %s\n", v23);
          if (v23 != (char *)buf) {
            free(v23);
          }
        }
      }
      if ((v39[5] & 0x80000000) != 0) {
        operator delete(*(void **)&v36[2]);
      }
      if ((v36[1] & 0x80000000) != 0) {
        operator delete(*(void **)v32);
      }
    }
  }
  else if (IOHIDEventGetType() == 15)
  {
    IOHIDEventGetFloatValue();
    *(float *)&double v17 = v17;
    *(_DWORD *)(a1 + 100) = LODWORD(v17);
  }
}

void sub_1904C71F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

os_log_t sub_1904C7230()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1EB3BE830 = (uint64_t)result;
  return result;
}

void *sub_1904C7260(void *a1)
{
  *a1 = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 3);
  return a1;
}

void sub_1904C72A8(void *a1)
{
  *a1 = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 3);

  JUMPOUT(0x192FCC980);
}

void sub_1904C730C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x400;
  unint64_t v4 = v2 - 1024;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    double v6 = (char *)a1[3];
    a1[4] = v4;
    float v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_190347A00(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      double v37 = &v34[8 * v36];
      __int16 v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      double v9 = (char *)a1[1];
    }
    uint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_190393FFC(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_190394114((uint64_t)a1, &v54);
    BOOL v44 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    double v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_190347A00((uint64_t)(a1 + 3), v46);
      __int16 v35 = &v34[8 * (v46 >> 2)];
      double v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        __int16 v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)__int16 v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      __int16 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  double v56 = a1 + 3;
  *(void *)&long long v54 = sub_190347A00((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  __int16 v53 = operator new(0x1000uLL);
  sub_190394234(&v54, &v53);
  float v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_19039434C((uint64_t)&v54, v27);
  }
  unsigned __int16 v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1904C75D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1904C7AD0(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)(a1 + 56) = xmmword_190609C30;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
  }
  uint64_t v1 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v1, OS_LOG_TYPE_DEBUG, "[SitStandDetector] Set linkModel initial angles from LyingDown state", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
    }
    unint64_t v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMSitStandDetector::setLinkModelJointAngles(const EventT *) [T = CMSitStandDetector::ELyingDown]", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
}

void sub_1904C7C64()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
  }
  CFDataRef v0 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_INFO, "[SitStandDetector] resetFSM forced FSM to init state.", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
    }
    uint64_t v1 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMSitStandDetector::logReset(const EventT *) [T = CMSitStandDetector::EReset]", "CoreLocation: %s\n", v1);
    if (v1 != (char *)buf) {
      free(v1);
    }
  }
}

void sub_1904C7DEC(uint64_t a1, float a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1EDFC39B8;
  *(void *)(a1 + 8) = 9;
  *(_WORD *)(a1 + 16) = 512;
  double v3 = a2;
  *(double *)(a1 + 24) = v3;
  *(float64x2_t *)(a1 + 32) = vmulq_n_f64((float64x2_t)xmmword_190609C40, v3);
  *(double *)(a1 + 48) = v3 * 0.3;
  *(_OWORD *)(a1 + 56) = xmmword_190609C50;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 1065353216;
  *(unsigned char *)(a1 + 92) = 0;
  *(unsigned char *)(a1 + 96) = 1;
  *(void *)(a1 + 116) = 0;
  *(void *)(a1 + 108) = 0;
  *(void *)(a1 + 124) = 0x6400000000;
  *(unsigned char *)(a1 + 532) = 1;
  *(void *)(a1 + 552) = 0;
  *(void *)(a1 + 544) = 0;
  *(void *)(a1 + 560) = 0x6400000000;
  *(void *)(a1 + 968) = 0x6400000000;
  *(void *)(a1 + 1776) = 0x6400000000;
  *(void *)(a1 + 4984) = 0x6400000000;
  *(unsigned char *)(a1 + 10592) = 1;
  *(void *)(a1 + 10612) = 0;
  *(void *)(a1 + 10604) = 0;
  *(void *)(a1 + 10620) = 0x200000000;
  *(unsigned char *)(a1 + 10636) = 1;
  *(void *)(a1 + 10648) = 0;
  *(void *)(a1 + 10656) = 0;
  *(void *)(a1 + 10664) = 0x200000000;
  *(unsigned char *)(a1 + 10680) = 1;
  *(void *)(a1 + 10692) = 0;
  *(void *)(a1 + 10708) = 0x700000000;
  *(void *)(a1 + 10700) = 0;
  *(unsigned char *)(a1 + 10744) = 1;
  *(void *)(a1 + 10756) = 0;
  *(void *)(a1 + 10764) = 0;
  *(void *)(a1 + 10772) = 0x700000000;
  *(unsigned char *)(a1 + 10816) = 0;
  *(void *)(a1 + 10808) = 0;
  *(_OWORD *)(a1 + 10840) = 0u;
  *(_OWORD *)(a1 + 10856) = 0u;
  *(_OWORD *)(a1 + 10824) = 0u;
  *(void *)(a1 + 10872) = 0x3F80000000000000;
  sub_1902D9ACC((float32x4_t *)(a1 + 10864), (float32x4_t)0);
  *(_OWORD *)(a1 + 10912) = 0u;
  *(_OWORD *)(a1 + 10896) = 0u;
  *(_OWORD *)(a1 + 10880) = 0u;
  sub_1904C8228();
}

void sub_1904C81DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = 0;
  uint64_t v4 = v1 + 10904;
  while (1)
  {
    uint64_t v5 = *(void *)(v4 + v3);
    *(void *)(v4 + v3) = 0;
    if (v5) {
      MEMORY[0x192FCC980](v5, 0x1000C40FF89C88ELL);
    }
    v3 -= 8;
    if (v3 == -24) {
      _Unwind_Resume(exception_object);
    }
  }
}

void sub_1904C8228()
{
}

void sub_1904C832C(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 16) == 2)
  {
    *(unsigned char *)(a1 + 92) = 0;
    return;
  }
  if (a2)
  {
    char v5 = 1;
  }
  else
  {
    if (!*(unsigned char *)(a1 + 92)) {
      return;
    }
    char v5 = -1;
  }
  unsigned __int8 v6 = v5 + *(unsigned char *)(a1 + 92);
  *(unsigned char *)(a1 + 92) = v6;
  if (v6 >= 2u)
  {
    sub_1905EC3A8(a1, 2, (uint64_t)&v10);
    float v7 = *(void (**)(uint64_t, uint64_t))(a1 + 10912);
    if (v7 && *(void *)(a1 + 10920)) {
      v7(1, a3);
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
    }
    uint64_t v8 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEBUG, "[SitStandDetector] Walking detection forced FSM to standing state.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
      }
      double v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMSitStandDetector::walkingDetectorCallback(BOOL, uint64_t)", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
}

void sub_1904C8528(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned __int8 *)(a1 + 16) | 2) == 2)
  {
    sub_1905EC3A8(a1, 1, (uint64_t)&v7);
    uint64_t v4 = *(void (**)(uint64_t, uint64_t))(a1 + 10912);
    if (v4 && *(void *)(a1 + 10920)) {
      v4(2, a2);
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
    }
    char v5 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_DEBUG, "[SitStandDetector] Strict period of head static forced FSM from standing/init state to sitting state.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
      }
      unsigned __int8 v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMSitStandDetector::auxSustainedStaticEventCallback(uint64_t)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
}

uint64_t sub_1904C86F0(uint64_t a1, float *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&unk_1EB3BEBB0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v19 = a2;
    int v20 = __cxa_guard_acquire((__guard *)&unk_1EB3BEBB0);
    a2 = v19;
    if (v20)
    {
      xmmword_1EB3BED58 = xmmword_190609D28;
      unk_1EB3BED68 = unk_190609D38;
      xmmword_1EB3BED78 = xmmword_190609D48;
      unk_1EB3BED88 = unk_190609D58;
      xmmword_1EB3BED18 = xmmword_190609CE8;
      unk_1EB3BED28 = unk_190609CF8;
      xmmword_1EB3BED38 = xmmword_190609D08;
      unk_1EB3BED48 = unk_190609D18;
      xmmword_1EB3BECD8 = xmmword_190609CA8;
      unk_1EB3BECE8 = unk_190609CB8;
      xmmword_1EB3BECF8 = xmmword_190609CC8;
      unk_1EB3BED08 = unk_190609CD8;
      __cxa_guard_release((__guard *)&unk_1EB3BEBB0);
      a2 = v19;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEBB8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v21 = a2;
    int v22 = __cxa_guard_acquire(&qword_1EB3BEBB8);
    a2 = v21;
    if (v22)
    {
      memcpy(&qword_1EB3BF108, &unk_190609D68, 0x110uLL);
      __cxa_guard_release(&qword_1EB3BEBB8);
      a2 = v21;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEBC0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v23 = a2;
    int v24 = __cxa_guard_acquire(&qword_1EB3BEBC0);
    a2 = v23;
    if (v24)
    {
      xmmword_1EB3BEEF8 = xmmword_190609F18;
      unk_1EB3BEF08 = unk_190609F28;
      xmmword_1EB3BEF18 = xmmword_190609F38;
      xmmword_1EB3BEEB8 = xmmword_190609ED8;
      unk_1EB3BEEC8 = unk_190609EE8;
      xmmword_1EB3BEED8 = xmmword_190609EF8;
      unk_1EB3BEEE8 = unk_190609F08;
      xmmword_1EB3BEE78 = xmmword_190609E98;
      unk_1EB3BEE88 = unk_190609EA8;
      xmmword_1EB3BEE98 = xmmword_190609EB8;
      unk_1EB3BEEA8 = unk_190609EC8;
      xmmword_1EB3BEE58 = xmmword_190609E78;
      unk_1EB3BEE68 = unk_190609E88;
      __cxa_guard_release(&qword_1EB3BEBC0);
      a2 = v23;
    }
  }
  uint64_t v3 = (unsigned char *)(a1 + 10592);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEBC8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v26 = a2;
    int v25 = __cxa_guard_acquire(&qword_1EB3BEBC8);
    a2 = v26;
    if (v25)
    {
      xmmword_1EB3BF0C8 = xmmword_19060A008;
      xmmword_1EB3BF0D8 = unk_19060A018;
      xmmword_1EB3BF0E8 = xmmword_19060A028;
      xmmword_1EB3BF0F8 = unk_19060A038;
      xmmword_1EB3BF088 = xmmword_190609FC8;
      xmmword_1EB3BF098 = unk_190609FD8;
      xmmword_1EB3BF0A8 = xmmword_190609FE8;
      xmmword_1EB3BF0B8 = unk_190609FF8;
      xmmword_1EB3BF048 = xmmword_190609F88;
      xmmword_1EB3BF058 = unk_190609F98;
      xmmword_1EB3BF068 = xmmword_190609FA8;
      xmmword_1EB3BF078 = unk_190609FB8;
      xmmword_1EB3BF008 = xmmword_190609F48;
      xmmword_1EB3BF018 = unk_190609F58;
      xmmword_1EB3BF028 = xmmword_190609F68;
      xmmword_1EB3BF038 = unk_190609F78;
      __cxa_guard_release(&qword_1EB3BEBC8);
      a2 = v26;
    }
  }
  uint64_t v4 = 0;
  char v5 = (double *)&xmmword_1EB3BECD8;
  do
  {
    if (*v5 >= a2[2]) {
      break;
    }
    ++v4;
    v5 += 2;
  }
  while (v4 != 12);
  uint64_t v6 = 0;
  double v7 = *((double *)&unk_1EB3BEBB0 + 2 * v4 + 38);
  uint64_t v8 = (double *)&qword_1EB3BF108;
  do
  {
    if (*v8 >= a2[3]) {
      break;
    }
    ++v6;
    v8 += 2;
  }
  while (v6 != 17);
  uint64_t v9 = 0;
  double v10 = v7 * *((double *)&unk_1EB3BEBB0 + 2 * v6 + 172);
  uint64_t v11 = (double *)&xmmword_1EB3BEE58;
  do
  {
    if (*v11 >= a2[6]) {
      break;
    }
    ++v9;
    v11 += 2;
  }
  while (v9 != 13);
  uint64_t v12 = 0;
  double v13 = v10 * *((double *)&unk_1EB3BEBB0 + 2 * v9 + 86);
  BOOL v14 = (double *)&xmmword_1EB3BF008;
  do
  {
    if (*v14 >= a2[8]) {
      break;
    }
    ++v12;
    v14 += 2;
  }
  while (v12 != 16);
  double v15 = v13 * *((double *)&unk_1EB3BEBB0 + 2 * v12 + 140);
  if (a2[4] < 0.05) {
    double v15 = 0.0;
  }
  float v16 = v15;
  float v28 = v16;
  sub_19042D76C((uint64_t)v3, &v28);
  if (*(_DWORD *)(a1 + 10624) != *(unsigned __int16 *)(a1 + 10622)) {
    return 0;
  }
  if (*v3) {
    sub_190430068((uint64_t)v3);
  }
  if (((float v27 = *(float *)(a1 + 10596), v27 >= 40.0) || *(_WORD *)(a1 + 10710))
    && (sub_19042D76C(a1 + 10680, &v27),
        *(void *)(a1 + 10612) = 0,
        *(void *)(a1 + 10604) = 0,
        *(_DWORD *)(a1 + 10620) = 0,
        unsigned char *v3 = 1,
        *(_DWORD *)(a1 + 10712) == *(unsigned __int16 *)(a1 + 10710))
    && (uint64_t v17 = (unsigned __int16 *)(a1 + 10708),
        sub_19043180C(v17, (unsigned int (*)(float, float))sub_190431A18, 0) >= 20.0)
    && sub_19043180C(v17, (unsigned int (*)(float, float))sub_190431A0C, 0) >= 40.0)
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1904C8B44(uint64_t a1, float *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEBD0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v19 = a2;
    int v20 = __cxa_guard_acquire(&qword_1EB3BEBD0);
    a2 = v19;
    if (v20)
    {
      unk_1EB3BEC28 = xmmword_19060A068;
      unk_1EB3BEC38 = unk_19060A078;
      unk_1EB3BEC48 = xmmword_19060A088;
      unk_1EB3BEC58 = unk_19060A098;
      *(_OWORD *)&qword_1EB3BEC08 = xmmword_19060A048;
      unk_1EB3BEC18 = unk_19060A058;
      __cxa_guard_release(&qword_1EB3BEBD0);
      a2 = v19;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEBD8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v21 = a2;
    int v22 = __cxa_guard_acquire(&qword_1EB3BEBD8);
    a2 = v21;
    if (v22)
    {
      xmmword_1EB3BECA8 = xmmword_19060A0E8;
      unk_1EB3BECB8 = unk_19060A0F8;
      xmmword_1EB3BECC8 = xmmword_19060A108;
      xmmword_1EB3BEC68 = xmmword_19060A0A8;
      unk_1EB3BEC78 = unk_19060A0B8;
      xmmword_1EB3BEC88 = xmmword_19060A0C8;
      unk_1EB3BEC98 = unk_19060A0D8;
      __cxa_guard_release(&qword_1EB3BEBD8);
      a2 = v21;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEBE0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v23 = a2;
    int v24 = __cxa_guard_acquire(&qword_1EB3BEBE0);
    a2 = v23;
    if (v24)
    {
      xmmword_1EB3BEFC8 = xmmword_19060A1B8;
      unk_1EB3BEFD8 = unk_19060A1C8;
      xmmword_1EB3BEFE8 = xmmword_19060A1D8;
      unk_1EB3BEFF8 = unk_19060A1E8;
      xmmword_1EB3BEF88 = xmmword_19060A178;
      unk_1EB3BEF98 = unk_19060A188;
      xmmword_1EB3BEFA8 = xmmword_19060A198;
      unk_1EB3BEFB8 = unk_19060A1A8;
      xmmword_1EB3BEF48 = xmmword_19060A138;
      unk_1EB3BEF58 = unk_19060A148;
      xmmword_1EB3BEF68 = xmmword_19060A158;
      unk_1EB3BEF78 = unk_19060A168;
      xmmword_1EB3BEF28 = xmmword_19060A118;
      unk_1EB3BEF38 = unk_19060A128;
      __cxa_guard_release(&qword_1EB3BEBE0);
      a2 = v23;
    }
  }
  uint64_t v3 = (unsigned char *)(a1 + 10636);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEBE8, memory_order_acquire) & 1) == 0)
  {
    int v25 = a2;
    int v26 = __cxa_guard_acquire(&qword_1EB3BEBE8);
    a2 = v25;
    if (v26)
    {
      xmmword_1EB3BEE18 = xmmword_19060A278;
      unk_1EB3BEE28 = unk_19060A288;
      xmmword_1EB3BEE38 = xmmword_19060A298;
      unk_1EB3BEE48 = unk_19060A2A8;
      xmmword_1EB3BEDD8 = xmmword_19060A238;
      unk_1EB3BEDE8 = unk_19060A248;
      xmmword_1EB3BEDF8 = xmmword_19060A258;
      unk_1EB3BEE08 = unk_19060A268;
      xmmword_1EB3BED98 = xmmword_19060A1F8;
      unk_1EB3BEDA8 = unk_19060A208;
      xmmword_1EB3BEDB8 = xmmword_19060A218;
      unk_1EB3BEDC8 = unk_19060A228;
      __cxa_guard_release(&qword_1EB3BEBE8);
      a2 = v25;
    }
  }
  uint64_t v4 = 0;
  char v5 = (double *)&qword_1EB3BEC08;
  do
  {
    if (*v5 >= a2[2]) {
      break;
    }
    ++v4;
    v5 += 2;
  }
  while (v4 != 6);
  uint64_t v6 = 0;
  double v7 = *((double *)&unk_1EB3BEBB0 + 2 * v4 + 12);
  uint64_t v8 = (double *)&xmmword_1EB3BEC68;
  do
  {
    if (*v8 >= a2[3]) {
      break;
    }
    ++v6;
    v8 += 2;
  }
  while (v6 != 7);
  uint64_t v9 = 0;
  double v10 = v7 * *((double *)&unk_1EB3BEBB0 + 2 * v6 + 24);
  uint64_t v11 = (double *)&xmmword_1EB3BEF28;
  do
  {
    if (*v11 >= a2[5]) {
      break;
    }
    ++v9;
    v11 += 2;
  }
  while (v9 != 14);
  uint64_t v12 = 0;
  double v13 = v10 * *((double *)&unk_1EB3BEBB0 + 2 * v9 + 112);
  BOOL v14 = (double *)&xmmword_1EB3BED98;
  do
  {
    if (*v14 >= a2[7]) {
      break;
    }
    ++v12;
    v14 += 2;
  }
  while (v12 != 12);
  double v15 = v13 * *((double *)&unk_1EB3BEBB0 + 2 * v12 + 62);
  if (a2[4] < 0.05) {
    double v15 = 0.0;
  }
  float v16 = v15;
  float v28 = v16;
  sub_19042D76C((uint64_t)v3, &v28);
  if (*(_DWORD *)(a1 + 10668) != *(unsigned __int16 *)(a1 + 10666)) {
    return 0;
  }
  if (*v3) {
    sub_190430068((uint64_t)v3);
  }
  if (((float v27 = *(float *)(a1 + 10640), v27 >= 25.0) || *(_WORD *)(a1 + 10774))
    && (sub_19042D76C(a1 + 10744, &v27),
        *(void *)(a1 + 10656) = 0,
        *(void *)(a1 + 10648) = 0,
        *(_DWORD *)(a1 + 10664) = 0,
        unsigned char *v3 = 1,
        *(_DWORD *)(a1 + 10776) == *(unsigned __int16 *)(a1 + 10774))
    && (uint64_t v17 = (unsigned __int16 *)(a1 + 10772),
        sub_19043180C(v17, (unsigned int (*)(float, float))sub_190431A18, 0) >= 15.0)
    && sub_19043180C(v17, (unsigned int (*)(float, float))sub_190431A0C, 0) >= 25.0)
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

double sub_1904C8F28(uint64_t a1, float32x2_t *a2, float32x4_t a3)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BEBF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB3BEBF0))
  {
    qword_1EB3BEBF8 = 0;
    dword_1EB3BEC00 = -1082130432;
    __cxa_guard_release(&qword_1EB3BEBF0);
  }
  __int32 v5 = a2[5].i32[1];
  *(float *)&unsigned int v6 = -a2[5].f32[0];
  *(float32x2_t *)a3.f32 = vneg_f32(a2[4]);
  v30.i64[0] = a3.i64[0];
  v30.i64[1] = __PAIR64__(v5, v6);
  sub_1902D9ACC(&v30, a3);
  float v7 = sub_1904CF73C(v30.f32, -a2[2].f32[1], -a2[3].f32[0], -a2[3].f32[1]);
  float v9 = v8;
  float v11 = v10;
  float v12 = 0.0;
  for (uint64_t i = 5; i != 8; ++i)
    float v12 = v12 + (float)(a2->f32[i] * a2->f32[i]);
  v30.i32[0] = sqrtf(v12);
  sub_19042D76C(a1 + 96, v30.f32);
  unsigned int v14 = *(_DWORD *)(a1 + 88);
  v15.f32[0] = -*(float *)(a1 + 84);
  *(float32x2_t *)v29.f32 = vneg_f32(*(float32x2_t *)(a1 + 76));
  v29.i64[1] = __PAIR64__(v14, v15.u32[0]);
  float32x4_t v16 = sub_1902D9ACC(&v29, v15);
  sub_1904CF3F4((uint64_t)&v29, (float *)&a2[4], &v30, v16);
  float v17 = sub_1904CF73C(v30.f32, v7, v9, 0.0);
  float v19 = v18;
  float v21 = v20;
  sub_1904CF73C(v30.f32, *(float *)&qword_1EB3BEBF8, *((float *)&qword_1EB3BEBF8 + 1), *(float *)&dword_1EB3BEC00);
  float v22 = sqrtf((float)(v21 * v21) + (float)(v19 * v19));
  if (v24 >= (float)-v23) {
    float v25 = v19;
  }
  else {
    float v25 = v21;
  }
  float v26 = v22 * (float)(int)((__PAIR64__(v25 > 0.0, LODWORD(v25)) - COERCE_UNSIGNED_INT(0.0)) >> 32);
  double v27 = *(double *)a2;
  v29.f32[0] = v11;
  sub_19042D76C(a1 + 532, v29.f32);
  sub_19042FABC(*(float **)(a1 + 10888), v26);
  sub_19042FABC(*(float **)(a1 + 10896), v17);
  sub_19042FABC(*(float **)(a1 + 10904), v11);
  return v27;
}

void sub_1904C915C(uint64_t a1)
{
  double v2 = *(double *)(a1 + 64);
  double v3 = 3.14159265 - *(double *)(a1 + 56);
  double v4 = *(double *)(a1 + 32);
  __double2 v5 = __sincos_stret(v3);
  double v6 = *(double *)(a1 + 40);
  __double2 v7 = __sincos_stret(v3 + v2);
  if (*(_WORD *)(a1 + 1778))
  {
    unint64_t v8 = 0;
    float v9 = -(v6 * v7.__cosval) - v4 * v5.__cosval;
    float v10 = v6 * v7.__sinval + v4 * v5.__sinval;
    float v41 = v10;
    float v42 = v9;
    do
    {
      if (v8)
      {
        uint64_t v11 = sub_1904CB494((unsigned __int16 *)(a1 + 4984), v8 - 1);
        float v12 = (float *)sub_19048B148((unsigned __int16 *)(a1 + 968), v8);
        float v13 = *(float *)(v11 + 8) + *v12;
        float v14 = *(float *)(v11 + 12) + v12[1];
        float32x4_t v15 = (float *)sub_19048B148((unsigned __int16 *)(a1 + 968), v8 - 1);
        float v43 = v13 - *v15;
        float v16 = v14 - v15[1];
      }
      else
      {
        float v17 = (float *)sub_19048B148((unsigned __int16 *)(a1 + 968), 0);
        float v43 = *v17 + v42;
        float v16 = v17[1] + v41;
      }
      float v46 = v16;
      double v18 = *(double *)(a1 + 32);
      __double2 v19 = __sincos_stret(v3);
      float v20 = -(v18 * v19.__cosval);
      float v21 = v19.__sinval * v18;
      double v22 = *(double *)(a1 + 40);
      __double2 v23 = __sincos_stret(v3 + v2);
      float v24 = -(v22 * v23.__cosval) - v18 * v19.__cosval;
      float v25 = v23.__sinval * v22 + v18 * v19.__sinval;
      uint64_t v26 = *(void *)sub_1904CB694((unsigned __int16 *)(a1 + 1776), v8);
      uint64_t v27 = sub_1904CB494((unsigned __int16 *)(a1 + 4984), v8);
      *(void *)uint64_t v27 = v26;
      *(float *)(v27 + 8) = v24;
      *(float *)(v27 + 12) = v25;
      *(float *)(v27 + 16) = v20;
      *(float *)(v27 + 20) = v21;
      *(void *)(v27 + 24) = 0;
      *(double *)(v27 + 32) = 3.14159265 - v3;
      *(double *)(v27 + 40) = v2;
      *(double *)(v27 + 48) = v3 + 1.57079633;
      long double v28 = *(double *)(a1 + 32);
      long double v29 = pow(v28, 4.0);
      long double v45 = v28 * v28;
      double v30 = *(double *)(a1 + 40) * *(double *)(a1 + 40);
      long double v44 = *(double *)(a1 + 40);
      float v31 = v43;
      double v32 = (float)(v31 * v31);
      double v33 = (float)(v46 * v46);
      long double v34 = (v45 + v45) * v32
          - (v29
           - (v45 + v45) * v30)
          + (v45 + v45) * v33
          - pow(v44, 4.0)
          - (float)((float)(v46 * v46) * (float)((float)(v31 * v31) + (float)(v31 * v31)))
          + (v30 + v30) * v32
          + (v30 + v30) * v33;
      long double v35 = v34 - pow(v43, 4.0);
      double v36 = sqrt(v35 - pow(v46, 4.0));
      long double v37 = atan(-(v36 - (v28 + v28) * v46) / (v28 * v28 + v28 * -2.0 * v43 - v30 + v32 + v33));
      double v38 = v37 + v37;
      long double v39 = (v28 + v28) * v44 - v28 * v28 - v30 + v32 + v33;
      long double v40 = atan(sqrt(v39 * (v28 * v28 + (v28 + v28) * v44 + v30 - v32 - v33)) / v39);
      double v3 = v38;
      double v2 = v40 + v40;
      ++v8;
    }
    while (v8 < *(unsigned __int16 *)(a1 + 1778));
  }
}

void sub_1904C947C(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  __asm { FMOV            V0.2S, #-1.0 }
  *(void *)(a1 + 28) = _D0;
  if (*(_WORD *)(a2 + 1778))
  {
    unint64_t v9 = 0;
    float v10 = (unsigned __int16 *)(a2 + 1776);
    double v11 = 0.0;
    double v12 = 0.0;
    do
    {
      uint64_t v13 = sub_1904CB694(v10, v9);
      double v11 = v11 + *(double *)(v13 + 8) * *(double *)(v13 + 8);
      uint64_t v14 = sub_1904CB694(v10, v9);
      double v12 = v12 + *(double *)(v14 + 16) * *(double *)(v14 + 16);
      ++v9;
    }
    while (v9 < *(unsigned __int16 *)(a2 + 1778));
    double v15 = sub_1904C98F4(v10, (unsigned int (*)(double, double, double, double, double, double, double, double))sub_1904C9B3C);
    double v17 = v16;
    double v18 = sub_1904C98F4(v10, (unsigned int (*)(double, double, double, double, double, double, double, double))sub_1904C9B48);
    int v20 = *(unsigned __int8 *)(a2 + 96);
    unint64_t v21 = *(unsigned __int16 *)(a2 + 1776) + (unint64_t)*(unsigned __int16 *)(a2 + 1778) - 1;
    unint64_t v22 = *(unsigned int *)(a2 + 1780);
    if (v21 < v22) {
      unint64_t v22 = 0;
    }
    *(void *)a1 = *(void *)(a2 + 1776 + 32 * (v21 - v22) + 8);
    float v23 = v12;
    float v24 = v11 + 0.000000999999997;
    float v25 = (v19 - v17) * (double)((v18 - v15 > 0.0) - (v18 - v15 < 0.0));
    *(float *)(a1 + 8) = sqrtf(v23) / sqrtf(v24);
    *(float *)(a1 + 12) = v25;
    if (v20) {
      sub_190430068(a2 + 96);
    }
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 100);
    sub_1904C9B54((long long *)buf, (unsigned __int16 *)(a2 + 4984), (uint64_t (*)(uint64_t *, _OWORD *))sub_1904C9E1C);
    double v41 = v46;
    sub_1904C9B54(&v43, (unsigned __int16 *)(a2 + 4984), (uint64_t (*)(uint64_t *, _OWORD *))sub_1904C9E30);
    v26.f64[0] = v41;
    double v42 = v44;
    v26.f64[1] = v44;
    *(float32x2_t *)(a1 + 20) = vcvt_f32_f64(vmulq_f64(v26, (float64x2_t)vdupq_n_s64(0x404CA5DC20000000uLL)));
    if (v41 >= 1.74532926) {
      double v27 = v41;
    }
    else {
      double v27 = 1.74532926;
    }
    double v28 = *(double *)sub_1904CB494((unsigned __int16 *)(a2 + 4984), 0);
    double v29 = 0.0;
    double v30 = 0.0;
    if (*(_WORD *)(a2 + 4986))
    {
      unint64_t v31 = 0;
      while (*(double *)(sub_1904CB494((unsigned __int16 *)(a2 + 4984), v31) + 48) > v27)
      {
        if (++v31 >= *(unsigned __int16 *)(a2 + 4986))
        {
          double v30 = 0.0;
          goto LABEL_26;
        }
      }
      double v30 = *(double *)sub_1904CB494((unsigned __int16 *)(a2 + 4984), v31);
    }
LABEL_26:
    if (v30 == 0.0) {
      double v34 = 0.0;
    }
    else {
      double v34 = v30 - v28;
    }
    float v35 = v34;
    *(float *)(a1 + 28) = v35;
    if (v42 <= 2.53072739) {
      double v36 = v42;
    }
    else {
      double v36 = 2.53072739;
    }
    double v37 = *(double *)sub_1904CB494((unsigned __int16 *)(a2 + 4984), 0);
    if (*(_WORD *)(a2 + 4986))
    {
      unint64_t v38 = 0;
      while (*(double *)(sub_1904CB494((unsigned __int16 *)(a2 + 4984), v38) + 48) < v36)
      {
        if (++v38 >= *(unsigned __int16 *)(a2 + 4986)) {
          goto LABEL_38;
        }
      }
      double v29 = *(double *)sub_1904CB494((unsigned __int16 *)(a2 + 4984), v38);
    }
LABEL_38:
    double v39 = v29 - v37;
    if (v29 == 0.0) {
      double v39 = 0.0;
    }
    float v40 = v39;
    *(float *)(a1 + 32) = v40;
  }
  else
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
    }
    double v32 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = 0;
      _os_log_impl(&dword_1902AF000, v32, OS_LOG_TYPE_ERROR, "[SitStandDetector] startIdx out of range. =%d", buf, 8u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
      }
      *(void *)&long long v43 = 67109120;
      double v33 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "SitStandDetectorFeatures CMSitStandDetector::calcEpochFeatures(int)", "CoreLocation: %s\n", v33);
      if (v33 != (char *)buf) {
        free(v33);
      }
    }
  }
}

double sub_1904C98F4(unsigned __int16 *a1, unsigned int (*a2)(double, double, double, double, double, double, double, double))
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a1[1];
  if (!a1[1])
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3700);
    }
    double v17 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v17, OS_LOG_TYPE_FAULT, "Assertion failed: n > 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 179,.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3700);
      }
      double v18 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMQueue<SitStandDetector::DecomposedUserAccel>::getComparison(int (*)(const T, const T), size_t) const [T = SitStandDetector::DecomposedUserAccel]", "CoreLocation: %s\n", v18);
      if (v18 != (char *)buf) {
        free(v18);
      }
    }
  }
  __double2 v5 = (double *)sub_1904CB694(a1, 0);
  double v6 = *v5;
  double v7 = v5[3];
  if (v4)
  {
    unint64_t v8 = 0;
    double v9 = v5[1];
    double v10 = v5[2];
    do
    {
      uint64_t v11 = sub_1904CB694(a1, v8);
      double v12 = *(double *)v11;
      double v13 = *(double *)(v11 + 8);
      double v14 = *(double *)(v11 + 16);
      double v15 = *(double *)(v11 + 24);
      if (a2(*(double *)v11, v13, v14, v15, v6, v9, v10, v7))
      {
        double v6 = v12;
        double v9 = v13;
        double v10 = v14;
        double v7 = v15;
      }
      ++v8;
    }
    while (v4 != v8);
  }
  return v6;
}

BOOL sub_1904C9B3C(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  return a4 < a8;
}

BOOL sub_1904C9B48(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  return a4 > a8;
}

uint64_t sub_1904C9B54(long long *a1, unsigned __int16 *a2, uint64_t (*a3)(uint64_t *, _OWORD *))
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2[1];
  if (a2[1])
  {
    uint64_t v7 = sub_1904CB494(a2, 0);
    unint64_t v8 = 0;
    long long v9 = *(_OWORD *)(v7 + 16);
    *a1 = *(_OWORD *)v7;
    a1[1] = v9;
    a1[2] = *(_OWORD *)(v7 + 32);
    *((void *)a1 + 6) = *(void *)(v7 + 48);
    do
    {
      uint64_t v10 = sub_1904CB494(a2, v8);
      uint64_t v11 = *(void *)v10;
      int v12 = *(_DWORD *)(v10 + 8);
      int v13 = *(_DWORD *)(v10 + 12);
      int v14 = *(_DWORD *)(v10 + 16);
      int v15 = *(_DWORD *)(v10 + 20);
      int v16 = *(_DWORD *)(v10 + 24);
      int v17 = *(_DWORD *)(v10 + 28);
      *(_OWORD *)buf = *(_OWORD *)(v10 + 32);
      uint64_t v38 = *(void *)(v10 + 48);
      uint64_t v27 = v11;
      int v28 = v12;
      int v29 = v13;
      int v30 = v14;
      int v31 = v15;
      int v32 = v16;
      int v33 = v17;
      long long v18 = *(_OWORD *)(v10 + 32);
      uint64_t v35 = *(void *)(v10 + 48);
      long long v34 = v18;
      uint64_t v26 = *((void *)a1 + 6);
      long long v19 = *a1;
      long long v20 = a1[2];
      v25[1] = a1[1];
      v25[2] = v20;
      v25[0] = v19;
      uint64_t result = a3(&v27, v25);
      if (result)
      {
        *(void *)a1 = v11;
        *((_DWORD *)a1 + 2) = v12;
        *((_DWORD *)a1 + 3) = v13;
        *((_DWORD *)a1 + 4) = v14;
        *((_DWORD *)a1 + 5) = v15;
        *((_DWORD *)a1 + 6) = v16;
        *((_DWORD *)a1 + 7) = v17;
        a1[2] = *(_OWORD *)buf;
        *((void *)a1 + 6) = v38;
      }
      ++v8;
    }
    while (v5 != v8);
  }
  else
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3700);
    }
    unint64_t v22 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_FAULT, "Assertion failed: n > 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 179,.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3700);
      }
      __int16 v36 = 0;
      float v24 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMQueue<SitStandDetector::TwoLinkPositionSample>::getComparison(int (*)(const T, const T), size_t) const [T = SitStandDetector::TwoLinkPositionSample]", "CoreLocation: %s\n", v24);
      if (v24 != (char *)buf) {
        free(v24);
      }
    }
    uint64_t result = sub_1904CB494(a2, 0);
    long long v23 = *(_OWORD *)(result + 16);
    *a1 = *(_OWORD *)result;
    a1[1] = v23;
    a1[2] = *(_OWORD *)(result + 32);
    *((void *)a1 + 6) = *(void *)(result + 48);
  }
  return result;
}

BOOL sub_1904C9E1C(uint64_t a1, uint64_t a2)
{
  return *(double *)(a1 + 48) < *(double *)(a2 + 48);
}

BOOL sub_1904C9E30(uint64_t a1, uint64_t a2)
{
  return *(double *)(a1 + 48) > *(double *)(a2 + 48);
}

void sub_1904C9E44(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)(a1 + 56) = xmmword_190609C50;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
  }
  uint64_t v1 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v1, OS_LOG_TYPE_DEBUG, "[SitStandDetector] Set linkModel initial angles from Sitting state", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
    }
    double v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMSitStandDetector::setLinkModelJointAngles(const EventT *) [T = CMSitStandDetector::ESitting]", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
}

void sub_1904C9FD8(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)(a1 + 56) = xmmword_190609C60;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
  }
  uint64_t v1 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v1, OS_LOG_TYPE_DEBUG, "[SitStandDetector] Set linkModel initial angles from Standing state", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
    }
    double v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMSitStandDetector::setLinkModelJointAngles(const EventT *) [T = CMSitStandDetector::EStanding]", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
}

void sub_1904CA16C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  sub_1905EC3A8(a1, 2, a2);
  *(_DWORD *)(a1 + 72) = 1;
  uint64_t v5 = *(void (**)(uint64_t, uint64_t))(a1 + 10912);
  if (v5 && *(void *)(a1 + 10920)) {
    v5(1, a3);
  }
  *(void *)(a1 + 10824) = a3 + 500000;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
  }
  double v6 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "[SitStandDetector] Detected Sit->Stand", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
    }
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMSitStandDetector::notifyWithDetection(const EventT *, uint64_t) [EventT = CMSitStandDetector::EStanding]", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  *(_DWORD *)(a1 + 1776) = 0;
  *(_DWORD *)(a1 + 968) = 0;
  *(_DWORD *)(a1 + 10620) = 0;
  *(void *)(a1 + 10612) = 0;
  *(void *)(a1 + 10604) = 0;
  *(unsigned char *)(a1 + 10592) = 1;
  *(void *)(a1 + 10656) = 0;
  *(void *)(a1 + 10648) = 0;
  *(_DWORD *)(a1 + 10664) = 0;
  *(unsigned char *)(a1 + 10636) = 1;
  *(_DWORD *)(a1 + 10708) = 0;
  *(void *)(a1 + 10700) = 0;
  *(void *)(a1 + 10692) = 0;
  *(unsigned char *)(a1 + 10680) = 1;
  *(_DWORD *)(a1 + 10772) = 0;
  *(void *)(a1 + 10764) = 0;
  *(void *)(a1 + 10756) = 0;
  *(unsigned char *)(a1 + 10744) = 1;
  sub_1904C8228();
}

void sub_1904CA3B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  sub_1905EC3A8(a1, 1, a2);
  *(_DWORD *)(a1 + 72) = 2;
  uint64_t v5 = *(void (**)(uint64_t, uint64_t))(a1 + 10912);
  if (v5 && *(void *)(a1 + 10920)) {
    v5(2, a3);
  }
  *(void *)(a1 + 10824) = a3 + 2000000;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
  }
  double v6 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "[SitStandDetector] Detected Stand->Sit", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
    }
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMSitStandDetector::notifyWithDetection(const EventT *, uint64_t) [EventT = CMSitStandDetector::ESitting]", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  *(_DWORD *)(a1 + 1776) = 0;
  *(_DWORD *)(a1 + 968) = 0;
  *(_DWORD *)(a1 + 10620) = 0;
  *(void *)(a1 + 10612) = 0;
  *(void *)(a1 + 10604) = 0;
  *(unsigned char *)(a1 + 10592) = 1;
  *(void *)(a1 + 10656) = 0;
  *(void *)(a1 + 10648) = 0;
  *(_DWORD *)(a1 + 10664) = 0;
  *(unsigned char *)(a1 + 10636) = 1;
  *(_DWORD *)(a1 + 10708) = 0;
  *(void *)(a1 + 10700) = 0;
  *(void *)(a1 + 10692) = 0;
  *(unsigned char *)(a1 + 10680) = 1;
  *(_DWORD *)(a1 + 10772) = 0;
  *(void *)(a1 + 10764) = 0;
  *(void *)(a1 + 10756) = 0;
  *(unsigned char *)(a1 + 10744) = 1;
  sub_1904C8228();
}

unsigned __int16 *sub_1904CA5FC(unsigned __int16 *result, long long *a2)
{
  unint64_t v2 = *((unsigned int *)result + 1);
  unint64_t v3 = *result + (unint64_t)result[1];
  if (v3 < v2) {
    unint64_t v2 = 0;
  }
  uint64_t v4 = &result[16 * (v3 - v2)];
  long long v5 = *a2;
  *(_OWORD *)(v4 + 12) = a2[1];
  *(_OWORD *)(v4 + 4) = v5;
  unsigned int v6 = result[1];
  unint64_t v7 = *((unsigned int *)result + 1);
  if (v7 <= v6)
  {
    unint64_t v8 = *result + 1;
    if (v8 < v7) {
      LOWORD(v7) = 0;
    }
    *uint64_t result = v8 - v7;
  }
  else
  {
    result[1] = v6 + 1;
  }
  return result;
}

uint64_t sub_1904CA660(uint64_t a1, uint64_t a2, float32x4_t a3)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  double v4 = *(double *)a2 * 1000000.0;
  if (*(void *)(a1 + 10824) <= (unint64_t)v4)
  {
    unint64_t v56 = (unint64_t)v4;
    if (*(_WORD *)(a1 + 1778))
    {
      float v6 = *(double *)a2 - *(double *)(a1 + 10832);
      if (v6 > 0.5)
      {
        *(_DWORD *)(a1 + 1776) = 0;
        *(_DWORD *)(a1 + 968) = 0;
        *(_DWORD *)(a1 + 10620) = 0;
        *(void *)(a1 + 10612) = 0;
        *(void *)(a1 + 10604) = 0;
        *(unsigned char *)(a1 + 10592) = 1;
        *(void *)(a1 + 10656) = 0;
        *(void *)(a1 + 10648) = 0;
        *(_DWORD *)(a1 + 10664) = 0;
        *(unsigned char *)(a1 + 10636) = 1;
        *(_DWORD *)(a1 + 10708) = 0;
        *(void *)(a1 + 10700) = 0;
        *(void *)(a1 + 10692) = 0;
        *(unsigned char *)(a1 + 10680) = 1;
        *(_DWORD *)(a1 + 10772) = 0;
        *(void *)(a1 + 10764) = 0;
        *(void *)(a1 + 10756) = 0;
        *(unsigned char *)(a1 + 10744) = 1;
        sub_1904C8228();
      }
      if (v6 > 0.04)
      {
        float v7 = rintf(v6 * 50.0);
        int v8 = (int)v7;
        float32x4_t v57 = *(float32x4_t *)(a1 + 10840);
        float32x4_t v58 = *(float32x4_t *)(a2 + 8);
        float32x2_t v9 = *(float32x2_t *)(a2 + 24);
        float32x2_t v10 = *(float32x2_t *)(a1 + 10856);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
        }
        uint64_t v11 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 134218240;
          *(double *)&uint8_t buf[4] = v6;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v8 - 1;
          _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_DEBUG, "[SitStandDetector] data gap of %.3f seconds, interpolating to %d samples.", buf, 0x12u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
          }
          *(_DWORD *)float v68 = 134218240;
          *(double *)&v68[4] = v6;
          *(_WORD *)&v68[12] = 1024;
          *(_DWORD *)&v68[14] = v8 - 1;
          uint64_t v52 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CMSitStandDetector::insertInterpolatedSamplesIfDataGap(const ImuData &)", "CoreLocation: %s\n", v52);
          if (v52 != buf) {
            free(v52);
          }
        }
        if (v8 >= 2)
        {
          float v12 = (float)(int)v7;
          a3.f32[0] = 1.0 / v12;
          double v13 = (float)((float)(1.0 / v12) * v6);
          float32x4_t v59 = vmulq_n_f32(vsubq_f32(v58, v57), 1.0 / v12);
          float32x2_t v14 = vmul_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)a3.f32, 0), vsub_f32(v9, v10));
          for (int i = 1; i != v8; ++i)
          {
            memset(buf, 0, sizeof(buf));
            int v67 = 1065353216;
            sub_1902D9ACC((float32x4_t *)&buf[32], (float32x4_t)0);
            double v16 = (double)i;
            *(float *)&double v16 = (float)i;
            *(double *)buf = *(double *)(a1 + 10832) + (double)i * v13;
            *(float32x4_t *)&uint8_t buf[8] = vaddq_f32(vmulq_n_f32(v59, (float)i), *(float32x4_t *)(a1 + 10840));
            *(float32x2_t *)&buf[24] = vadd_f32(vmul_f32(v14, (float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)&v16, 0)), *(float32x2_t *)(a1 + 10856));
            sub_1904D0B60((float32x4_t *)(a1 + 10864), (float32x4_t *)(a2 + 32), (float32x4_t *)&buf[32], (float)i / v12);
            *(void *)float v68 = sub_1904C8F28(a1, (float32x2_t *)buf, v17);
            *(void *)&v68[8] = v18;
            *(void *)&v68[16] = v19;
            *(void *)&v68[24] = v20;
            sub_1904CA5FC((unsigned __int16 *)(a1 + 1776), (long long *)v68);
          }
        }
      }
    }
    a3.i64[0] = *(void *)a2;
    *(void *)(a1 + 10832) = *(void *)a2;
    *(_DWORD *)(a1 + 10840) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 10844) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 10848) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 10852) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 10856) = *(_DWORD *)(a2 + 24);
    a3.i32[0] = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a1 + 10860) = a3.i32[0];
    if (a1 + 10832 != a2)
    {
      a3 = *(float32x4_t *)(a2 + 32);
      *(float32x4_t *)(a1 + 10864) = a3;
    }
    *(void *)&long long v60 = sub_1904C8F28(a1, (float32x2_t *)a2, a3);
    *((void *)&v60 + 1) = v21;
    uint64_t v61 = v22;
    uint64_t v62 = v23;
    sub_1904CA5FC((unsigned __int16 *)(a1 + 1776), &v60);
    if (*(_DWORD *)(a1 + 1780) == *(unsigned __int16 *)(a1 + 1778))
    {
      double v24 = *(double *)(sub_1904CB694((unsigned __int16 *)(a1 + 1776), 0) + 8);
      double v25 = *(double *)(sub_1904CB694((unsigned __int16 *)(a1 + 1776), 0) + 24);
      *(void *)buf = 0;
      sub_19048B0E8((unsigned __int16 *)(a1 + 968), buf);
      if (*(unsigned __int16 *)(a1 + 1778) >= 2u)
      {
        unint64_t v26 = 1;
        double v27 = v25 * 0.02;
        double v28 = v24 * 0.02;
        double v29 = 0.0;
        double v30 = 0.0;
        do
        {
          double v31 = *(double *)sub_1904CB694((unsigned __int16 *)(a1 + 1776), v26);
          unint64_t v32 = v26 - 1;
          double v33 = v31 - *(double *)sub_1904CB694((unsigned __int16 *)(a1 + 1776), v32);
          if (v33 < 0.0)
          {
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
            }
            long long v34 = qword_1E929D8E0;
            if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = 0;
              _os_log_impl(&dword_1902AF000, v34, OS_LOG_TYPE_ERROR, "[SitStandDetector] Timestamp went backwards. dt = %f", buf, 0xCu);
            }
            double v33 = 0.0;
            if (sub_1902D8400(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1E929D8D8 != -1) {
                dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
              }
              *(_DWORD *)float v68 = 134217984;
              *(void *)&v68[4] = 0;
              float v40 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 0, "void CMSitStandDetector::integrateUserAccel()", "CoreLocation: %s\n", v40);
              if (v40 != buf) {
                free(v40);
              }
            }
          }
          double v35 = *(double *)(sub_1904CB694((unsigned __int16 *)(a1 + 1776), v32) + 8);
          double v36 = (v35 + *(double *)(sub_1904CB694((unsigned __int16 *)(a1 + 1776), v32 + 1) + 8)) * 0.5;
          double v37 = *(double *)(sub_1904CB694((unsigned __int16 *)(a1 + 1776), v32) + 24);
          double v38 = (v37 + *(double *)(sub_1904CB694((unsigned __int16 *)(a1 + 1776), v32 + 1) + 24)) * 0.5;
          double v28 = v28 + v36 * 9.80665016 * v33;
          double v27 = v27 + v38 * 9.80665016 * v33;
          double v29 = v29 + v33 * v33 * (v36 * 4.90332508) + v28 * v33;
          double v30 = v30 + v33 * v33 * (v38 * 4.90332508) + v27 * v33;
          *(float *)&double v38 = v29;
          float v39 = v30;
          *(_DWORD *)buf = LODWORD(v38);
          *(float *)&uint8_t buf[4] = v39;
          sub_19048B0E8((unsigned __int16 *)(a1 + 968), buf);
          unint64_t v26 = v32 + 2;
        }
        while (v26 < *(unsigned __int16 *)(a1 + 1778));
      }
      if (*(unsigned char *)(a1 + 16))
      {
        sub_1904C915C(a1);
        sub_1904C947C((uint64_t)v68, a1);
        int v41 = *(unsigned __int8 *)(a1 + 16);
        if (v41 == 2)
        {
          if (sub_1904C8B44(a1, (float *)v68)) {
            sub_1904CA3B4(a1, (uint64_t)buf, v56);
          }
        }
        else if (v41 == 1)
        {
          if (sub_1904C86F0(a1, (float *)v68)) {
            sub_1904CA16C(a1, (uint64_t)buf, v56);
          }
        }
        else
        {
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
          }
          uint64_t v48 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
          {
            unint64_t v49 = *(char *)(a1 + 16);
            if (v49 > 3) {
              uint64_t v50 = "Unknown";
            }
            else {
              uint64_t v50 = off_1E568E1A8[v49];
            }
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v50;
            _os_log_impl(&dword_1902AF000, v48, OS_LOG_TYPE_INFO, "[SitStandDetector] Wrong FSM state, %s", buf, 0xCu);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1A20);
            }
            unint64_t v53 = *(char *)(a1 + 16);
            if (v53 > 3) {
              long long v54 = "Unknown";
            }
            else {
              long long v54 = off_1E568E1A8[v53];
            }
            int v64 = 136315138;
            float v65 = v54;
            long long v55 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "BOOL CMSitStandDetector::detectStateTransitions(uint64_t)", "CoreLocation: %s\n", v55);
            if (v55 != buf) {
              free(v55);
            }
          }
        }
      }
      else
      {
        sub_1904C9E44(a1);
        sub_1904C915C(a1);
        sub_1904C947C((uint64_t)buf, a1);
        int v42 = sub_1904C86F0(a1, (float *)buf);
        sub_1904C9FD8(a1);
        sub_1904C915C(a1);
        sub_1904C947C((uint64_t)v68, a1);
        *(_OWORD *)buf = *(_OWORD *)v68;
        *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)&v68[16];
        *(_DWORD *)&uint8_t buf[32] = v69;
        int v43 = sub_1904C8B44(a1, (float *)buf);
        int v44 = v43;
        if ((v42 & 1) != 0 || (v43 & 1) != 0 || *(void *)(a1 + 10880))
        {
          if (v42)
          {
            if (*(unsigned char *)(a1 + 10680)) {
              sub_190430068(a1 + 10680);
            }
            float v45 = *(float *)(a1 + 10684) / 40.0;
            if (v45 > *(float *)(a1 + 10808)) {
              *(float *)(a1 + 10808) = v45;
            }
          }
          if (v44)
          {
            if (*(unsigned char *)(a1 + 10744)) {
              sub_190430068(a1 + 10744);
            }
            float v46 = *(float *)(a1 + 10748) / 25.0;
            if (v46 > *(float *)(a1 + 10812)) {
              *(float *)(a1 + 10812) = v46;
            }
          }
          unint64_t v47 = *(void *)(a1 + 10880);
          if (v47)
          {
            if (v47 <= v56)
            {
              if (*(float *)(a1 + 10808) > *(float *)(a1 + 10812)) {
                sub_1904CA16C(a1, (uint64_t)&v63, v56);
              }
              sub_1904CA3B4(a1, (uint64_t)&v64, v56);
            }
          }
          else
          {
            *(void *)(a1 + 10880) = v56 + 800000;
          }
        }
      }
    }
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 72) = 0;
  return result;
}

os_log_t sub_1904CB464()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

uint64_t sub_1904CB494(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3700);
    }
    float v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3700);
      }
      float32x2_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const T &CMQueue<SitStandDetector::TwoLinkPositionSample>::operator[](const size_t) const [T = SitStandDetector::TwoLinkPositionSample]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[28 * (v4 - v5) + 4];
}

uint64_t sub_1904CB694(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3700);
    }
    float v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3700);
      }
      float32x2_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const T &CMQueue<SitStandDetector::DecomposedUserAccel>::operator[](const size_t) const [T = SitStandDetector::DecomposedUserAccel]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[16 * (v4 - v5) + 4];
}

uint64_t sub_1904CBBE8(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D788 != -1) {
    dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
  }
  unint64_t v2 = qword_1E929D780;
  if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_INFO, "Closing PressureSample", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
    }
    unint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CLPressureSampleDatabase::~CLPressureSampleDatabase()", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
  sqlite3_reset(*(sqlite3_stmt **)(a1 + 16));
  sqlite3_close(*(sqlite3 **)(a1 + 8));
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1904CBDB0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1902E67BC(a1);
}

uint64_t sub_1904CBDBC(uint64_t a1, const char *a2, long long *a3, long long *a4)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 16) = 0;
  int v8 = (sqlite3_stmt **)(a1 + 16);
  if (*((char *)a3 + 23) < 0)
  {
    sub_190347AFC((unsigned char *)(a1 + 24), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    *(void *)(a1 + 40) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 24) = v9;
  }
  if (*((char *)a4 + 23) < 0)
  {
    sub_190347AFC((unsigned char *)(a1 + 48), *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v10 = *a4;
    *(void *)(a1 + 64) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 48) = v10;
  }
  pStmt = 0;
  if (a2[23] >= 0) {
    unint64_t v11 = a2;
  }
  else {
    unint64_t v11 = *(const char **)a2;
  }
  __int16 v12 = (sqlite3 **)(a1 + 8);
  uint64_t v13 = *((unsigned __int8 *)a3 + 23);
  if ((v13 & 0x80u) != 0) {
    uint64_t v13 = *((void *)a3 + 1);
  }
  if (v13) {
    int v14 = 6;
  }
  else {
    int v14 = 1;
  }
  if (!sqlite3_open_v2(v11, (sqlite3 **)(a1 + 8), v14, 0))
  {
    if (sqlite3_prepare_v2(*v12, "SELECT COUNT(*) FROM PressureSample", -1, &pStmt, 0) || sqlite3_step(pStmt) != 100)
    {
      uint64_t v34 = *((unsigned __int8 *)a3 + 23);
      if ((v34 & 0x80u) != 0) {
        uint64_t v34 = *((void *)a3 + 1);
      }
      if (!v34)
      {
        if (qword_1E929D788 != -1) {
          dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
        }
        unint64_t v49 = qword_1E929D780;
        if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
        {
          if (a2[23] >= 0) {
            uint64_t v50 = a2;
          }
          else {
            uint64_t v50 = *(const char **)a2;
          }
          *(_DWORD *)buf = 136315138;
          float v73 = v50;
          _os_log_impl(&dword_1902AF000, v49, OS_LOG_TYPE_FAULT, "No PressureSample table in %s", buf, 0xCu);
        }
        if (!sub_1902D8400(115, 0)) {
          goto LABEL_24;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1E929D788 != -1) {
          dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
        }
        if (a2[23] >= 0) {
          __int16 v51 = a2;
        }
        else {
          __int16 v51 = *(const char **)a2;
        }
        int v68 = 136315138;
        int v69 = v51;
        uint64_t v52 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "CLPressureSampleDatabase::CLPressureSampleDatabase(const std::string &, const std::string &, const std::string &)", "CoreLocation: %s\n", v52);
        goto LABEL_115;
      }
      if (sqlite3_prepare_v2(*v12, "CREATE TABLE PressureSample (CFTime FLOAT, Timestamp FLOAT, Run TEXT, Tag TEXT, degC FLOAT, kPa FLOAT)", -1, &pStmt, 0)|| sqlite3_step(pStmt) != 101)
      {
        if (qword_1E929D788 != -1) {
          dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
        }
        int v42 = qword_1E929D780;
        if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
        {
          int v43 = a2[23];
          int v44 = *(const char **)a2;
          float v45 = sqlite3_errmsg(*v12);
          if (v43 >= 0) {
            float v46 = a2;
          }
          else {
            float v46 = v44;
          }
          *(_DWORD *)buf = 136315394;
          float v73 = v46;
          __int16 v74 = 2080;
          uint64_t v75 = v45;
          _os_log_impl(&dword_1902AF000, v42, OS_LOG_TYPE_FAULT, "Can't create table in %s: %s", buf, 0x16u);
        }
        if (!sub_1902D8400(115, 0)) {
          goto LABEL_24;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1E929D788 != -1) {
          dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
        }
        int v47 = a2[23];
        uint64_t v48 = *(const char **)a2;
        unint64_t v32 = sqlite3_errmsg(*v12);
        if (v47 >= 0) {
          double v33 = a2;
        }
        else {
          double v33 = v48;
        }
      }
      else
      {
        sqlite3_finalize(pStmt);
        pStmt = 0;
        if (sqlite3_prepare_v2(*v12, "CREATE INDEX TheIdx ON PressureSample (Run, Tag, CFTime)", -1, &pStmt, 0)
          || sqlite3_step(pStmt) != 101)
        {
          if (qword_1E929D788 != -1) {
            dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
          }
          unint64_t v53 = qword_1E929D780;
          if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
          {
            int v54 = a2[23];
            long long v55 = *(const char **)a2;
            unint64_t v56 = sqlite3_errmsg(*v12);
            if (v54 >= 0) {
              float32x4_t v57 = a2;
            }
            else {
              float32x4_t v57 = v55;
            }
            *(_DWORD *)buf = 136315394;
            float v73 = v57;
            __int16 v74 = 2080;
            uint64_t v75 = v56;
            _os_log_impl(&dword_1902AF000, v53, OS_LOG_TYPE_FAULT, "Can't create index in %s: %s", buf, 0x16u);
          }
          if (!sub_1902D8400(115, 0)) {
            goto LABEL_24;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1E929D788 != -1) {
            dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
          }
          int v58 = a2[23];
          float32x4_t v59 = *(const char **)a2;
          unint64_t v32 = sqlite3_errmsg(*v12);
          if (v58 >= 0) {
            double v33 = a2;
          }
          else {
            double v33 = v59;
          }
        }
        else
        {
          if (!sqlite3_prepare_v2(*v12, "INSERT INTO PressureSample VALUES (?,?,?,?,?,?)", -1, v8, 0) && *v8)
          {
LABEL_119:
            sqlite3_finalize(pStmt);
            char v20 = 1;
            goto LABEL_25;
          }
          if (qword_1E929D788 != -1) {
            dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
          }
          double v35 = qword_1E929D780;
          if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
          {
            int v36 = a2[23];
            double v37 = *(const char **)a2;
            double v38 = sqlite3_errmsg(*v12);
            if (v36 >= 0) {
              float v39 = a2;
            }
            else {
              float v39 = v37;
            }
            *(_DWORD *)buf = 136315394;
            float v73 = v39;
            __int16 v74 = 2080;
            uint64_t v75 = v38;
            _os_log_impl(&dword_1902AF000, v35, OS_LOG_TYPE_FAULT, "Can't create insert statment in %s: %s", buf, 0x16u);
          }
          if (!sub_1902D8400(115, 0)) {
            goto LABEL_24;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1E929D788 != -1) {
            dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
          }
          int v40 = a2[23];
          int v41 = *(const char **)a2;
          unint64_t v32 = sqlite3_errmsg(*v12);
          if (v40 >= 0) {
            double v33 = a2;
          }
          else {
            double v33 = v41;
          }
        }
      }
    }
    else
    {
      if (qword_1E929D788 != -1) {
        dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
      }
      uint64_t v22 = qword_1E929D780;
      if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_INFO))
      {
        if (a2[23] >= 0) {
          uint64_t v23 = a2;
        }
        else {
          uint64_t v23 = *(const char **)a2;
        }
        *(_DWORD *)buf = 136315138;
        float v73 = v23;
        _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_INFO, "Found PressureSample table already in %s", buf, 0xCu);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D788 != -1) {
          dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
        }
        if (a2[23] >= 0) {
          float v65 = a2;
        }
        else {
          float v65 = *(const char **)a2;
        }
        int v68 = 136315138;
        int v69 = v65;
        float v66 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "CLPressureSampleDatabase::CLPressureSampleDatabase(const std::string &, const std::string &, const std::string &)", "CoreLocation: %s\n", v66);
        if (v66 != (char *)buf) {
          free(v66);
        }
      }
      uint64_t v24 = *((unsigned __int8 *)a3 + 23);
      if ((v24 & 0x80u) != 0) {
        uint64_t v24 = *((void *)a3 + 1);
      }
      if (!v24 || !sqlite3_prepare_v2(*v12, "INSERT INTO PressureSample VALUES (?,?,?,?,?,?)", -1, v8, 0) && *v8) {
        goto LABEL_119;
      }
      if (qword_1E929D788 != -1) {
        dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
      }
      double v25 = qword_1E929D780;
      if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
      {
        int v26 = a2[23];
        double v27 = *(const char **)a2;
        double v28 = sqlite3_errmsg(*v12);
        if (v26 >= 0) {
          double v29 = a2;
        }
        else {
          double v29 = v27;
        }
        *(_DWORD *)buf = 136315394;
        float v73 = v29;
        __int16 v74 = 2080;
        uint64_t v75 = v28;
        _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_FAULT, "Can't create insert statment in %s: %s", buf, 0x16u);
      }
      if (!sub_1902D8400(115, 0)) {
        goto LABEL_24;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D788 != -1) {
        dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
      }
      int v30 = a2[23];
      double v31 = *(const char **)a2;
      unint64_t v32 = sqlite3_errmsg(*v12);
      if (v30 >= 0) {
        double v33 = a2;
      }
      else {
        double v33 = v31;
      }
    }
    int v68 = 136315394;
    int v69 = v33;
    __int16 v70 = 2080;
    double v71 = v32;
    uint64_t v52 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "CLPressureSampleDatabase::CLPressureSampleDatabase(const std::string &, const std::string &, const std::string &)", "CoreLocation: %s\n", v52);
LABEL_115:
    if (v52 != (char *)buf) {
      free(v52);
    }
    goto LABEL_24;
  }
  if (qword_1E929D788 != -1) {
    dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
  }
  int v15 = qword_1E929D780;
  if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
  {
    int v16 = a2[23];
    float32x4_t v17 = *(const char **)a2;
    uint64_t v18 = sqlite3_errmsg(*v12);
    if (v16 >= 0) {
      uint64_t v19 = a2;
    }
    else {
      uint64_t v19 = v17;
    }
    *(_DWORD *)buf = 136315394;
    float v73 = v19;
    __int16 v74 = 2080;
    uint64_t v75 = v18;
    _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_FAULT, "Can't open %s: %s", buf, 0x16u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
    }
    int v60 = a2[23];
    uint64_t v61 = *(const char **)a2;
    uint64_t v62 = sqlite3_errmsg(*v12);
    if (v60 >= 0) {
      char v63 = a2;
    }
    else {
      char v63 = v61;
    }
    int v68 = 136315394;
    int v69 = v63;
    __int16 v70 = 2080;
    double v71 = v62;
    int v64 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "CLPressureSampleDatabase::CLPressureSampleDatabase(const std::string &, const std::string &, const std::string &)", "CoreLocation: %s\n", v64);
    if (v64 != (char *)buf) {
      free(v64);
    }
  }
LABEL_24:
  sqlite3_finalize(pStmt);
  char v20 = 0;
  *int v8 = 0;
LABEL_25:
  *(unsigned char *)a1 = v20;
  return a1;
}

void sub_1904CCAE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void **a11)
{
  if (*(char *)(v11 + 71) < 0) {
    operator delete(*v12);
  }
  if (*(char *)(v11 + 47) < 0) {
    operator delete(*a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904CCB6C(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  ppStmt = 0;
  sub_1902C3F54(&v21, "SELECT Timestamp, degC, kPa FROM PressureSample WHERE ");
  if (!*(unsigned char *)a1)
  {
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
    }
    int v16 = qword_1E929D780;
    if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_FAULT, "Table PressureSample invalid", (uint8_t *)&__p, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_38;
    }
    bzero(&__p, 0x65CuLL);
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
    }
    LOWORD(v23) = 0;
    int v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "BOOL CLPressureSampleDatabase::iterate(const std::string &, CLPressureSampleDatabase::OnSample)", "CoreLocation: %s\n", v15);
    if (v15 == (char *)&__p) {
      goto LABEL_38;
    }
    goto LABEL_48;
  }
  if (*((char *)a2 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  p_p = &__p;
  sub_190395000((uint64_t)&__p, v6 + 20);
  if ((v26 & 0x80u) != 0) {
    p_p = (long long *)__p;
  }
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0) {
      int v8 = a2;
    }
    else {
      int v8 = *a2;
    }
    memmove(p_p, v8, v6);
  }
  strcpy((char *)p_p + v6, " ORDER BY CFTime ASC");
  if ((v26 & 0x80u) == 0) {
    long long v9 = (const std::string::value_type *)&__p;
  }
  else {
    long long v9 = (const std::string::value_type *)__p;
  }
  if ((v26 & 0x80u) == 0) {
    std::string::size_type v10 = v26;
  }
  else {
    std::string::size_type v10 = *((void *)&__p + 1);
  }
  std::string::append(&v21, v9, v10);
  if ((char)v26 < 0) {
    operator delete((void *)__p);
  }
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v11 = &v21;
  }
  else {
    uint64_t v11 = (std::string *)v21.__r_.__value_.__r.__words[0];
  }
  if (!sqlite3_prepare_v2(*(sqlite3 **)(a1 + 8), (const char *)v11, -1, &ppStmt, 0))
  {
    while (sqlite3_step(ppStmt) == 100)
    {
      *(void *)&long long __p = sqlite3_column_double(ppStmt, 0);
      float v18 = sqlite3_column_double(ppStmt, 1);
      *((float *)&__p + 3) = v18;
      float v19 = sqlite3_column_double(ppStmt, 2);
      *((float *)&__p + 2) = v19;
      (*(void (**)(uint64_t, long long *))(a3 + 16))(a3, &__p);
    }
    uint64_t v17 = 1;
    goto LABEL_42;
  }
  if (qword_1E929D788 != -1) {
    dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
  }
  __int16 v12 = qword_1E929D780;
  if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
  {
    uint64_t v13 = sqlite3_errmsg(*(sqlite3 **)(a1 + 8));
    LODWORD(__p) = 136315138;
    *(void *)((char *)&__p + 4) = v13;
    _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_FAULT, "Can't create query %s", (uint8_t *)&__p, 0xCu);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
    }
    int v14 = sqlite3_errmsg(*(sqlite3 **)(a1 + 8));
    int v23 = 136315138;
    uint64_t v24 = v14;
    int v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "BOOL CLPressureSampleDatabase::iterate(const std::string &, CLPressureSampleDatabase::OnSample)", "CoreLocation: %s\n", v15);
    if (v15 != (char *)&__p) {
LABEL_48:
    }
      free(v15);
  }
LABEL_38:
  uint64_t v17 = 0;
LABEL_42:
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  return v17;
}

void sub_1904CCFD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904CD02C(const char *a1, char *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  memset(buf, 0, sizeof(buf));
  memset(v25, 0, 24);
  sub_1904CBDBC((uint64_t)v23, a1, (long long *)buf, (long long *)v25);
  if (v23[0])
  {
    ppStmt = 0;
    sub_1902C3F54(v25, "SELECT Run, MAX(degC) + MIN(degC) AS Midx2, MAX(degC) - MIN(degC) AS Range FROM PressureSample GROUP BY Run HAVING Range > 5 ORDER BY Midx2");
    if (v23[0])
    {
      if (SHIBYTE(v25[2]) >= 0) {
        unint64_t v2 = v25;
      }
      else {
        unint64_t v2 = (void **)v25[0];
      }
      if (!sqlite3_prepare_v2(db, (const char *)v2, -1, &ppStmt, 0)) {
        operator new();
      }
      if (qword_1E929D788 != -1) {
        dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
      }
      unint64_t v3 = qword_1E929D780;
      if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
      {
        unint64_t v4 = sqlite3_errmsg(db);
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = v4;
        _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_FAULT, "Can't create query %s", buf, 0xCu);
      }
      if (!sub_1902D8400(115, 0)) {
        goto LABEL_29;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D788 != -1) {
        dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
      }
      unint64_t v5 = sqlite3_errmsg(db);
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v5;
      size_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "std::unique_ptr<std::vector<std::string>> CLPressureSampleDatabase::findRuns()", "CoreLocation: %s\n", v6);
    }
    else
    {
      if (qword_1E929D788 != -1) {
        dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
      }
      long long v9 = qword_1E929D780;
      if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = "PressureSample";
        _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_FAULT, "Table %s invalid", buf, 0xCu);
      }
      if (!sub_1902D8400(115, 0)) {
        goto LABEL_29;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D788 != -1) {
        dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = "PressureSample";
      size_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "std::unique_ptr<std::vector<std::string>> CLPressureSampleDatabase::findRuns()", "CoreLocation: %s\n", v6);
    }
    if (v6 != (char *)buf) {
      free(v6);
    }
LABEL_29:
    uint64_t v22 = 0;
    if (SHIBYTE(v25[2]) < 0) {
      operator delete(v25[0]);
    }
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
    }
    std::string::size_type v10 = qword_1E929D780;
    if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
    {
      if (a1[23] >= 0) {
        uint64_t v11 = (uint64_t *)a1;
      }
      else {
        uint64_t v11 = *(uint64_t **)a1;
      }
      if (a2[23] >= 0) {
        __int16 v12 = a2;
      }
      else {
        __int16 v12 = *(char **)a2;
      }
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v12;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_FAULT, "%s has no runs for clause %s", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D788 != -1) {
        dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
      }
      if (a1[23] >= 0) {
        int v16 = (uint64_t *)a1;
      }
      else {
        int v16 = *(uint64_t **)a1;
      }
      if (a2[23] >= 0) {
        uint64_t v17 = a2;
      }
      else {
        uint64_t v17 = *(char **)a2;
      }
      LODWORD(v25[0]) = 136315394;
      *(void **)((char *)v25 + 4) = v16;
      WORD2(v25[1]) = 2080;
      *(void **)((char *)&v25[1] + 6) = v17;
      float v18 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLPressureSampleDatabase::getPRTT(const std::string &, const std::string &, struct CLNonlinearPrtt::Syscfg &)", "CoreLocation: %s\n", v18);
      if (v18 != (char *)buf) {
        free(v18);
      }
    }
    sub_1904CED84(&v22);
    goto LABEL_45;
  }
  if (qword_1E929D788 != -1) {
    dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
  }
  float v7 = qword_1E929D780;
  if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_FAULT))
  {
    if (a1[23] >= 0) {
      int v8 = (uint64_t *)a1;
    }
    else {
      int v8 = *(uint64_t **)a1;
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "%s is invalid", buf, 0xCu);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
    }
    if (a1[23] >= 0) {
      int v14 = (uint64_t *)a1;
    }
    else {
      int v14 = *(uint64_t **)a1;
    }
    LODWORD(v25[0]) = 136315138;
    *(void **)((char *)v25 + 4) = v14;
    int v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLPressureSampleDatabase::getPRTT(const std::string &, const std::string &, struct CLNonlinearPrtt::Syscfg &)", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
LABEL_45:
  sub_1904CBBE8((uint64_t)v23);
  return 0;
}

void sub_1904CE960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void **a39,__int16 a40)
{
}

void sub_1904CEAC0(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D788 != -1) {
    dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
  }
  unint64_t v4 = qword_1E929D780;
  if (os_log_type_enabled((os_log_t)qword_1E929D780, OS_LOG_TYPE_DEBUG))
  {
    double v5 = *(float *)(a2 + 12);
    double v6 = *(float *)(a2 + 8);
    *(_DWORD *)buf = 134218240;
    double v9 = v5;
    __int16 v10 = 2048;
    double v11 = v6;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEBUG, "Feeding %f %f to median estimator", buf, 0x16u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D788 != -1) {
      dispatch_once(&qword_1E929D788, &unk_1EDFD1A40);
    }
    float v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "static BOOL CLPressureSampleDatabase::getPRTT(const std::string &, const std::string &, struct CLNonlinearPrtt::Syscfg &)_block_invoke", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  sub_1902D2B84(*(void *)(a1 + 32), a2);
}

os_log_t sub_1904CECAC()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Pressure");
  qword_1E929D780 = (uint64_t)result;
  return result;
}

uint64_t sub_1904CECDC(void *a1)
{
  unint64_t v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 512;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    float v7 = *v2++;
    operator delete(v7);
  }

  return sub_1902D5C18((uint64_t)a1);
}

void ***sub_1904CED84(void ***result)
{
  uint64_t v1 = *result;
  *os_log_t result = 0;
  if (v1)
  {
    unint64_t v2 = v1;
    sub_190387A4C(&v2);
    return (void ***)MEMORY[0x192FCC980](v1, 0x20C40960023A9);
  }
  return result;
}

void sub_1904CEDD8(void *a1)
{
  if (a1)
  {
    sub_1904CEDD8(*a1);
    sub_1904CEDD8(a1[1]);
    unint64_t v2 = (void *)a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

uint64_t **sub_1904CEE34(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        float v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    float v7 = a1 + 1;
LABEL_9:
    double v9 = (uint64_t *)v7;
    float v7 = (uint64_t **)operator new(0x40uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[6] = 0;
    v7[7] = 0;
    void v7[5] = 0;
    *float v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    __int16 v10 = (uint64_t *)**a1;
    double v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      double v11 = *v6;
    }
    sub_1902DD3B4(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

float sub_1904CEF08(uint64_t a1, float *a2)
{
  uint64_t v2 = (uint64_t)a2 - a1;
  if ((uint64_t)a2 - a1 <= 3) {
    __assert_rtn("getMedianInPlace", "CMPressureUtilities.h", 163, "size > 0");
  }
  unint64_t v3 = (float *)a1;
  unint64_t v4 = (unint64_t)(v2 >> 2) >> 1;
  unint64_t v5 = (float *)(a1 + 4 * v4);
  if (v5 != a2) {
    sub_1904CF000(a1, (float *)(a1 + 4 * v4), a2);
  }
  if (((v2 >> 2) & 0x8000000000000001) == 1) {
    return *v5;
  }
  if ((unint64_t)v2 >= 8 && v4 != 1)
  {
    float v7 = v3 + 1;
    float v8 = *v3;
    uint64_t v9 = 4 * v4 - 4;
    __int16 v10 = v3 + 1;
    do
    {
      float v11 = *v10++;
      float v12 = v11;
      if (v8 < v11)
      {
        float v8 = v12;
        unint64_t v3 = v7;
      }
      float v7 = v10;
      v9 -= 4;
    }
    while (v9);
  }
  return *v3 + (float)((float)(*v5 - *v3) * 0.5);
}

uint64_t sub_1904CF000(uint64_t result, float *a2, float *a3)
{
  if (a3 != a2)
  {
    unint64_t v3 = a3;
    unint64_t v5 = (float *)result;
    do
    {
      unint64_t v6 = v3 - v5;
      if (v6 < 2) {
        break;
      }
      if (v6 == 3)
      {
        return sub_1904CF2AC(v5, v5 + 1, v3 - 1);
      }
      if (v6 == 2)
      {
        float v33 = *(v3 - 1);
        float v34 = *v5;
        if (v33 < *v5)
        {
          *unint64_t v5 = v33;
          *(v3 - 1) = v34;
        }
        return result;
      }
      if ((char *)v3 - (char *)v5 <= 31)
      {
        return (uint64_t)sub_1904CF334(v5, v3);
      }
      float v7 = &v5[v6 >> 1];
      float v8 = v3 - 1;
      os_log_t result = sub_1904CF2AC(v5, v7, v3 - 1);
      float v9 = *v5;
      if (*v5 >= *v7)
      {
        __int16 v10 = v3 - 1;
        while (--v10 != v5)
        {
          if (*v10 < *v7)
          {
            *unint64_t v5 = *v10;
            *__int16 v10 = v9;
            os_log_t result = (result + 1);
            goto LABEL_13;
          }
        }
        uint64_t v22 = v5 + 1;
        if (v9 >= *v8)
        {
          while (v22 != v8)
          {
            float v23 = *v22;
            if (v9 < *v22)
            {
              *v22++ = *v8;
              *float v8 = v23;
              goto LABEL_45;
            }
            ++v22;
          }
          return result;
        }
LABEL_45:
        if (v22 == v8) {
          return result;
        }
        while (1)
        {
          float v27 = *v5;
          do
          {
            float v28 = *v22++;
            float v29 = v28;
          }
          while (v27 >= v28);
          int v30 = v22 - 1;
          do
          {
            float v31 = *--v8;
            float v32 = v31;
          }
          while (v27 < v31);
          if (v30 >= v8) {
            break;
          }
          *int v30 = v32;
          *float v8 = v29;
        }
        unint64_t v5 = v22 - 1;
        if (v30 > a2) {
          return result;
        }
      }
      else
      {
        __int16 v10 = v3 - 1;
LABEL_13:
        float v11 = v5 + 1;
        if (v5 + 1 >= v10)
        {
          int v16 = v5 + 1;
        }
        else
        {
          float v12 = v5 + 1;
          while (1)
          {
            float v13 = *v7;
            do
            {
              float v14 = *v12++;
              float v15 = v14;
            }
            while (v14 < v13);
            int v16 = v12 - 1;
            do
            {
              float v17 = *--v10;
              float v18 = v17;
            }
            while (v17 >= v13);
            if (v16 >= v10) {
              break;
            }
            *int v16 = v18;
            *__int16 v10 = v15;
            os_log_t result = (result + 1);
            if (v16 == v7) {
              float v7 = v10;
            }
          }
        }
        if (v16 != v7)
        {
          float v19 = *v16;
          if (*v7 < *v16)
          {
            *int v16 = *v7;
            *float v7 = v19;
            os_log_t result = (result + 1);
          }
        }
        if (v16 == a2) {
          return result;
        }
        if (!result)
        {
          if (v16 <= a2)
          {
            uint64_t v24 = v16 + 1;
            while (v24 != v3)
            {
              float v26 = *(v24 - 1);
              float v25 = *v24++;
              if (v25 < v26) {
                goto LABEL_29;
              }
            }
          }
          else
          {
            while (v11 != v16)
            {
              float v21 = *(v11 - 1);
              float v20 = *v11++;
              if (v20 < v21) {
                goto LABEL_29;
              }
            }
          }
          return result;
        }
LABEL_29:
        if (v16 <= a2) {
          unint64_t v5 = v16 + 1;
        }
        else {
          unint64_t v3 = v16;
        }
      }
    }
    while (v3 != a2);
  }
  return result;
}

uint64_t sub_1904CF2AC(float *a1, float *a2, float *a3)
{
  float v3 = *a2;
  float v4 = *a1;
  float v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    float v6 = *a1;
    if (*a2 >= *a1) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

float *sub_1904CF334(float *result, float *a2)
{
  while (result != a2 - 1)
  {
    uint64_t v2 = result++;
    if (v2 != a2 && result != a2)
    {
      float v3 = *v2;
      float v4 = *v2;
      float v5 = result;
      float v6 = v2;
      float v7 = result;
      do
      {
        float v8 = *v7++;
        float v9 = v8;
        if (v8 < v4)
        {
          float v4 = v9;
          float v6 = v5;
        }
        float v5 = v7;
      }
      while (v7 != a2);
      if (v6 != v2)
      {
        float *v2 = *v6;
        *float v6 = v3;
      }
    }
  }
  return result;
}

void sub_1904CF3A8(void *a1)
{
  if (a1)
  {
    sub_1904CF3A8(*a1);
    sub_1904CF3A8(a1[1]);
    operator delete(a1);
  }
}

double sub_1904CF3F4@<D0>(uint64_t a1@<X0>, float *a2@<X1>, float32x4_t *a3@<X8>, float32x4_t a4@<Q0>)
{
  float v4 = *(float *)(a1 + 8);
  a4.i32[0] = *(_DWORD *)(a1 + 12);
  float v5 = a2[1];
  float v6 = *(float *)(a1 + 4);
  float v7 = a2[2];
  float v8 = a2[3];
  float32_t v9 = (float)((float)((float)(v4 * v5) + (float)(a4.f32[0] * *a2)) - (float)(v6 * v7)) + (float)(*(float *)a1 * v8);
  float32_t v10 = (float)((float)((float)(a4.f32[0] * v5) - (float)(v4 * *a2)) + (float)(*(float *)a1 * v7)) + (float)(v6 * v8);
  float32_t v11 = (float)((float)((float)(v6 * *a2) - (float)(*(float *)a1 * v5)) + (float)(a4.f32[0] * v7)) + (float)(v4 * v8);
  float v12 = (float)((float)-(float)(v6 * v5) - (float)(*(float *)a1 * *a2)) - (float)(v4 * v7);
  a3->f32[0] = v9;
  a3->f32[1] = v10;
  a4.f32[0] = v12 + (float)(a4.f32[0] * v8);
  a3->f32[2] = v11;
  a3->i32[3] = a4.i32[0];
  *(void *)&double result = sub_1902D9ACC(a3, a4).u64[0];
  return result;
}

double sub_1904CF454@<D0>(float32x2_t *a1@<X0>, float32x4_t *a2@<X8>, float32x4_t a3@<Q0>)
{
  __int32 v3 = a1[1].i32[1];
  a3.f32[0] = -a1[1].f32[0];
  *(float32x2_t *)a2->f32 = vneg_f32(*a1);
  a2->i32[2] = a3.i32[0];
  a2->i32[3] = v3;
  *(void *)&double result = sub_1902D9ACC(a2, a3).u64[0];
  return result;
}

float32x4_t sub_1904CF474@<Q0>(float32x4_t *a1@<X0>, float32x4_t *a2@<X8>)
{
  if (a1->f32[3] >= 0.0)
  {
    float32x4_t result = *a1;
    *a2 = *a1;
  }
  else
  {
    float32x4_t v2 = vnegq_f32(*a1);
    *a2 = v2;
    result.i64[0] = sub_1902D9ACC(a2, v2).u64[0];
  }
  return result;
}

double sub_1904CF4AC@<D0>(float32x2_t *a1@<X0>, uint64_t a2@<X1>, float32x4_t *a3@<X8>, float32x4_t a4@<Q0>)
{
  __int32 v6 = a1[1].i32[1];
  a4.f32[0] = -a1[1].f32[0];
  *(float32x2_t *)v9.f32 = vneg_f32(*a1);
  v9.i64[1] = __PAIR64__(v6, a4.u32[0]);
  float32x4_t v7 = sub_1902D9ACC(&v9, a4);
  sub_1904CF3F4(a2, v9.f32, &v10, v7);
  *(void *)&double result = sub_1904CF474(&v10, a3).u64[0];
  return result;
}

float sub_1904CF514(float *a1)
{
  uint64_t v1 = 0;
  float v2 = a1[2];
  float v3 = a1[3];
  float v4 = a1[1];
  float result = (float)((float)(v3 * v4) - (float)(*a1 * v2)) + (float)((float)(v3 * v4) - (float)(*a1 * v2));
  float v6 = (float)-(float)(v3 * *a1) - (float)(v4 * v2);
  float v7 = (float)((float)((float)(v4 * v4) + (float)(*a1 * *a1)) * 2.0) + -1.0;
  *(float *)float32_t v11 = result;
  *(float *)&v11[1] = v6 + v6;
  *(float *)&id v11[2] = v7;
  float v8 = 0.0;
  do
  {
    float v8 = v8 + (float)(*(float *)&v11[v1] * *(float *)&v11[v1]);
    ++v1;
  }
  while (v1 != 3);
  if (sqrtf(v8) > 0.00000011921)
  {
    uint64_t v9 = 0;
    float v10 = 0.0;
    do
    {
      float v10 = v10 + (float)(*(float *)&v11[v9] * *(float *)&v11[v9]);
      ++v9;
    }
    while (v9 != 3);
    return result / sqrtf(v10);
  }
  return result;
}

float sub_1904CF5C4(float *a1)
{
  uint64_t v1 = 0;
  float v2 = a1[1];
  float v4 = a1[2];
  float v3 = a1[3];
  float result = (float)((float)((float)(*a1 * *a1) + (float)(v3 * v3)) * 2.0) + -1.0;
  float v6 = (float)((float)(*a1 * v2) - (float)(v3 * v4)) + (float)((float)(*a1 * v2) - (float)(v3 * v4));
  float v7 = (float)((float)(v3 * v2) + (float)(*a1 * v4)) + (float)((float)(v3 * v2) + (float)(*a1 * v4));
  v11[0] = result;
  v11[1] = v6;
  id v11[2] = v7;
  float v8 = 0.0;
  do
  {
    float v8 = v8 + (float)(v11[v1] * v11[v1]);
    ++v1;
  }
  while (v1 != 3);
  if (sqrtf(v8) > 0.00000011921)
  {
    uint64_t v9 = 0;
    float v10 = 0.0;
    do
    {
      float v10 = v10 + (float)(v11[v9] * v11[v9]);
      ++v9;
    }
    while (v9 != 3);
    return result / sqrtf(v10);
  }
  return result;
}

float sub_1904CF674(uint64_t a1, float *a2)
{
  for (unint64_t i = 0; i != 3; ++i)
  {
    float v5 = sub_1904741A8(a1, i, 0) * *a2;
    *(float *)sub_19042D844((uint64_t)&v11, i) = v5;
    for (unint64_t j = 1; j != 3; ++j)
    {
      float v7 = sub_1904741A8(a1, i, j);
      float v8 = sub_190448408((uint64_t)a2, j);
      uint64_t v9 = (float *)sub_19042D844((uint64_t)&v11, i);
      *uint64_t v9 = *v9 + (float)(v7 * v8);
    }
  }
  return v11;
}

float sub_1904CF73C(float *a1, float a2, float a3, float a4)
{
  v5[0] = a2;
  v5[1] = a3;
  void v5[2] = a4;
  sub_1904D08E8(a1, v6, 1.0);
  return sub_1904CF674((uint64_t)v6, v5);
}

void sub_1904CF778(float *a1, uint64_t a2)
{
  sub_1904D08E8(a1, v5, -1.0);
  *(float *)a2 = sub_1904CF674((uint64_t)v5, (float *)a2);
  *(_DWORD *)(a2 + 4) = v3;
  *(_DWORD *)(a2 + 8) = v4;
}

float sub_1904CF7C0(float *a1, float a2, float a3, float a4)
{
  v5[0] = a2;
  v5[1] = a3;
  void v5[2] = a4;
  sub_1904D08E8(a1, v6, -1.0);
  return sub_1904CF674((uint64_t)v6, v5);
}

double sub_1904CF7FC(float32x4_t *a1, float *a2)
{
  uint64_t v4 = 0;
  float v5 = 0.0;
  do
  {
    float v5 = v5 + (float)(a2[v4] * a2[v4]);
    ++v4;
  }
  while (v4 != 3);
  float v6 = sqrtf(v5);
  float v7 = 0.5;
  float v8 = v6 * 0.5;
  if ((float)(v6 * 0.5) > 0.0) {
    float v7 = (float)(sinf(v6 * 0.5) / v8) * 0.5;
  }
  a1->f32[0] = v7 * *a2;
  a1->f32[1] = v7 * a2[1];
  a1->f32[2] = v7 * a2[2];
  v9.f32[0] = cosf(v8);
  a1->i32[3] = v9.i32[0];

  *(void *)&double result = sub_1902D9ACC(a1, v9).u64[0];
  return result;
}

float sub_1904CF8B4(float32x4_t *a1)
{
  float32x4_t v8 = *a1;
  sub_1904CF474(&v8, &v7);
  uint64_t v1 = 0;
  float32x4_t v8 = v7;
  float v2 = v7.f32[0];
  float v3 = 0.0;
  do
  {
    float v3 = v3 + (float)(v7.f32[v1] * v7.f32[v1]);
    ++v1;
  }
  while (v1 != 3);
  float v4 = sqrtf(v3);
  if (v4 >= 0.00000011921)
  {
    float v5 = atan2f(v4, v8.f32[3]);
    return v2 * (float)((float)(v5 + v5) / v4);
  }
  return v2;
}

BOOL sub_1904CF974(float *a1, float32x4_t *a2, uint64_t a3, float a4, float a5, float a6, float a7, float a8, float a9, double a10, double a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17, float a18)
{
  uint64_t v177 = *MEMORY[0x1E4F143B8];
  float v168 = a4;
  float v169 = a5;
  float v170 = a6;
  float v165 = a7;
  float v166 = a8;
  float v167 = a9;
  unint64_t v163 = a17;
  float v164 = a18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF220, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB3BF220))
  {
    dword_1EB3BF218 = 1043452116;
    __cxa_guard_release(&qword_1EB3BF220);
  }
  uint64_t v19 = 0;
  float v20 = 0.0;
  do
  {
    float v20 = v20 + (float)(*(float *)((char *)&v168 + v19) * *(float *)((char *)&v168 + v19));
    v19 += 4;
  }
  while (v19 != 12);
  if (sqrtf(v20) == 0.0) {
    return 0;
  }
  uint64_t v21 = 0;
  float v22 = 0.0;
  do
  {
    float v22 = v22 + (float)(*(float *)((char *)&v165 + v21) * *(float *)((char *)&v165 + v21));
    v21 += 4;
  }
  while (v21 != 12);
  if (sqrtf(v22) == 0.0) {
    return 0;
  }
  uint64_t v23 = 0;
  float v24 = v168;
  float v25 = v169;
  float v26 = v170;
  *(float *)buf = v168;
  *(float *)&uint8_t buf[4] = v169;
  *(float *)&uint8_t buf[8] = v170;
  float v27 = 0.0;
  do
  {
    float v27 = v27 + (float)(*(float *)&buf[v23] * *(float *)&buf[v23]);
    v23 += 4;
  }
  while (v23 != 12);
  if (sqrtf(v27) > 0.00000011921)
  {
    uint64_t v28 = 0;
    float v29 = 0.0;
    do
    {
      float v29 = v29 + (float)(*(float *)&buf[v28] * *(float *)&buf[v28]);
      v28 += 4;
    }
    while (v28 != 12);
    float v30 = sqrtf(v29);
    float v24 = v168 / v30;
    float v25 = v169 / v30;
    float v26 = v170 / v30;
  }
  uint64_t v31 = 0;
  float v168 = v24;
  float v169 = v25;
  float v170 = v26;
  float v32 = v165;
  float v33 = v166;
  float v34 = v167;
  *(float *)buf = v165;
  *(float *)&uint8_t buf[4] = v166;
  *(float *)&uint8_t buf[8] = v167;
  float v35 = 0.0;
  do
  {
    float v35 = v35 + (float)(*(float *)&buf[v31] * *(float *)&buf[v31]);
    v31 += 4;
  }
  while (v31 != 12);
  if (sqrtf(v35) > 0.00000011921)
  {
    uint64_t v36 = 0;
    float v37 = 0.0;
    do
    {
      float v37 = v37 + (float)(*(float *)&buf[v36] * *(float *)&buf[v36]);
      v36 += 4;
    }
    while (v36 != 12);
    float v38 = sqrtf(v37);
    float v32 = v165 / v38;
    float v33 = v166 / v38;
    float v34 = v167 / v38;
  }
  uint64_t v39 = 0;
  float v165 = v32;
  float v166 = v33;
  float v167 = v34;
  float v40 = (float)(v25 * v34) - (float)(v26 * v33);
  float v41 = (float)(v26 * v32) - (float)(v24 * v34);
  float v42 = (float)(v24 * v33) - (float)(v25 * v32);
  float v160 = v40;
  float v161 = v41;
  float v162 = v42;
  float v43 = 0.0;
  do
  {
    float v43 = v43 + (float)(*(float *)((char *)&v160 + v39) * *(float *)((char *)&v160 + v39));
    v39 += 4;
  }
  while (v39 != 12);
  float v44 = sqrtf(v43);
  if (v44 < *(float *)&dword_1EB3BF218)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1A60);
    }
    float v45 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      *(double *)&uint8_t buf[4] = v44;
      _os_log_impl(&dword_1902AF000, v45, OS_LOG_TYPE_DEBUG, "n and g are too close %f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1A60);
      }
      LODWORD(v171) = 134217984;
      *(double *)((char *)&v171 + 4) = v44;
      __int16 v106 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "static BOOL CMOQuaternion::northAndGravity(CMVector<float, 3>, CMVector<float, 3>, CMVector<float, 3>, const float *, CMOQuaternion &, CMMatrix<float, 3> &)", "CoreLocation: %s\n", v106);
      if (v106 != (char *)buf) {
        free(v106);
      }
    }
    return 0;
  }
  uint64_t v48 = 0;
  float v49 = v40 / v44;
  float v50 = v41 / v44;
  float v160 = v40 / v44;
  float v161 = v41 / v44;
  float v51 = v42 / v44;
  float v162 = v42 / v44;
  float v53 = *((float *)&v163 + 1);
  LODWORD(v52) = v163;
  float v54 = v164;
  *(void *)buf = v163;
  *(float *)&uint8_t buf[8] = v164;
  float v55 = 0.0;
  do
  {
    float v55 = v55 + (float)(*(float *)&buf[v48] * *(float *)&buf[v48]);
    v48 += 4;
  }
  while (v48 != 12);
  if (sqrtf(v55) > 0.00000011921)
  {
    uint64_t v56 = 0;
    float v57 = 0.0;
    do
    {
      float v57 = v57 + (float)(*(float *)&buf[v56] * *(float *)&buf[v56]);
      v56 += 4;
    }
    while (v56 != 12);
    float v58 = sqrtf(v57);
    float v52 = *(float *)&v163 / v58;
    float v53 = *((float *)&v163 + 1) / v58;
    float v54 = v164 / v58;
  }
  uint64_t v59 = 0;
  unint64_t v163 = __PAIR64__(LODWORD(v53), LODWORD(v52));
  float v164 = v54;
  unint64_t v158 = 0;
  float v159 = -1.0;
  float v60 = (float)(v54 * -0.0) - v53;
  float v61 = 0.0;
  float v62 = v52 + (float)(v54 * 0.0);
  float v63 = (float)(v53 * -0.0) + (float)(v52 * 0.0);
  *(float *)buf = v60;
  *(float *)&uint8_t buf[4] = v62;
  *(float *)&uint8_t buf[8] = v63;
  do
  {
    float v61 = v61 + (float)(*(float *)&buf[v59] * *(float *)&buf[v59]);
    v59 += 4;
  }
  while (v59 != 12);
  if (sqrtf(v61) > 0.00000011921)
  {
    uint64_t v64 = 0;
    float v65 = 0.0;
    do
    {
      float v65 = v65 + (float)(*(float *)&buf[v64] * *(float *)&buf[v64]);
      v64 += 4;
    }
    while (v64 != 12);
    float v66 = sqrtf(v65);
    float v60 = v60 / v66;
    float v62 = v62 / v66;
    float v63 = v63 / v66;
  }
  uint64_t v67 = 0;
  *(float *)double v157 = v60;
  *(float *)&v157[1] = v62;
  *(float *)&v157[2] = v63;
  float v68 = (float)(v33 * v51) - (float)(v34 * v50);
  float v69 = (float)(v34 * v49) - (float)(v32 * v51);
  float v70 = (float)(v32 * v50) - (float)(v33 * v49);
  *(float *)buf = v68;
  *(float *)&uint8_t buf[4] = v69;
  *(float *)&uint8_t buf[8] = v70;
  float v71 = 0.0;
  do
  {
    float v71 = v71 + (float)(*(float *)&buf[v67] * *(float *)&buf[v67]);
    v67 += 4;
  }
  while (v67 != 12);
  if (sqrtf(v71) > 0.00000011921)
  {
    uint64_t v72 = 0;
    float v73 = 0.0;
    do
    {
      float v73 = v73 + (float)(*(float *)&buf[v72] * *(float *)&buf[v72]);
      v72 += 4;
    }
    while (v72 != 12);
    float v74 = sqrtf(v73);
    float v68 = v68 / v74;
    float v69 = v69 / v74;
    float v70 = v70 / v74;
  }
  float v168 = v68;
  float v169 = v69;
  float v170 = v70;
  sub_1904D0698((uint64_t)&v171, (uint64_t)&v168, (uint64_t)&v163);
  sub_1904D0698((uint64_t)&v154, (uint64_t)&v165, (uint64_t)&v158);
  sub_1904D0698((uint64_t)v152, (uint64_t)&v160, (uint64_t)v157);
  float v75 = (float)((float)(a1[1] * a1[1]) + (float)(*a1 * *a1)) + (float)((float)(*a1 + *a1) * a1[1]);
  if (v75 == 0.0)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1A60);
    }
    double v107 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v107, OS_LOG_TYPE_FAULT, "Assertion failed: lambda2 != 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMOQuaternion.cpp, line 208,invalid weights.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1A60);
      }
      LOWORD(v150[0]) = 0;
      __int16 v108 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "static BOOL CMOQuaternion::northAndGravity(CMVector<float, 3>, CMVector<float, 3>, CMVector<float, 3>, const float *, CMOQuaternion &, CMMatrix<float, 3> &)", "CoreLocation: %s\n", v108);
      if (v108 != (char *)buf) {
        free(v108);
      }
    }
  }
  v150[0] = v152[0];
  v150[1] = v152[1];
  int v151 = v153;
  float v76 = *a1;
  long long v144 = v171;
  long long v145 = v172;
  int v146 = v173;
  int v132 = 0;
  float v133 = v170;
  float v134 = -v169;
  float v135 = -v170;
  int v136 = 0;
  float v137 = v168;
  float v138 = v169;
  float v139 = -v168;
  int v140 = 0;
  sub_1904779D0((uint64_t)&v132, (uint64_t)v152, (uint64_t)v141);
  int v124 = 0;
  float v125 = v164;
  float v126 = -*((float *)&v163 + 1);
  float v127 = -v164;
  int v128 = 0;
  unint64_t v129 = v163;
  float v130 = -*(float *)&v163;
  int v131 = 0;
  sub_1904779D0((uint64_t)v141, (uint64_t)&v124, (uint64_t)v142);
  for (unint64_t i = 0; i != 9; ++i)
    *((float *)&v144 + i) = *((float *)&v144 + i) - sub_19044CC24((uint64_t)v142, i);
  uint64_t v78 = 0;
  float v79 = 1.0 / sqrtf(v75);
  long long v147 = v144;
  long long v148 = v145;
  int v149 = v146;
  do
  {
    *(float *)((char *)&v147 + v78) = (float)(v79 * v76) * *(float *)((char *)&v147 + v78);
    v78 += 4;
  }
  while (v78 != 36);
  unint64_t v80 = 0;
  *(_OWORD *)buf = v147;
  long long v175 = v148;
  int v176 = v149;
  do
  {
    *((float *)v150 + v80) = sub_19044CC24((uint64_t)buf, v80) + *((float *)v150 + v80);
    ++v80;
  }
  while (v80 != 9);
  float v81 = a1[1];
  long long v118 = v154;
  long long v119 = v155;
  int v120 = v156;
  int v132 = 0;
  float v133 = v167;
  float v134 = -v166;
  float v135 = -v167;
  int v136 = 0;
  float v137 = v165;
  float v138 = v166;
  float v139 = -v165;
  int v140 = 0;
  sub_1904779D0((uint64_t)&v132, (uint64_t)v152, (uint64_t)v141);
  int v124 = 0;
  float v125 = v159;
  float v126 = -*((float *)&v158 + 1);
  float v127 = -v159;
  int v128 = 0;
  unint64_t v129 = v158;
  float v130 = -*(float *)&v158;
  int v131 = 0;
  sub_1904779D0((uint64_t)v141, (uint64_t)&v124, (uint64_t)v142);
  for (unint64_t j = 0; j != 9; ++j)
    *((float *)&v118 + j) = *((float *)&v118 + j) - sub_19044CC24((uint64_t)v142, j);
  uint64_t v83 = 0;
  long long v121 = v118;
  long long v122 = v119;
  int v123 = v120;
  do
  {
    *(float *)((char *)&v121 + v83) = (float)(v79 * v81) * *(float *)((char *)&v121 + v83);
    v83 += 4;
  }
  while (v83 != 36);
  unint64_t v84 = 0;
  *(_OWORD *)buf = v121;
  long long v175 = v122;
  int v176 = v123;
  do
  {
    v85.f32[0] = sub_19044CC24((uint64_t)buf, v84) + *((float *)v150 + v84);
    *((_DWORD *)v150 + v84++) = v85.i32[0];
  }
  while (v84 != 9);
  sub_1904D072C(a2, (float *)v150, v85);
  uint64_t v86 = 0;
  float v87 = *a1;
  long long v112 = v171;
  long long v113 = v172;
  int v114 = v173;
  do
  {
    *(float *)((char *)&v112 + v86) = v87 * *(float *)((char *)&v112 + v86);
    v86 += 4;
  }
  while (v86 != 36);
  uint64_t v88 = 0;
  int v117 = v114;
  long long v115 = v112;
  long long v116 = v113;
  float v89 = a1[1];
  int v111 = v156;
  long long v109 = v154;
  long long v110 = v155;
  do
  {
    *(float *)((char *)&v109 + v88) = v89 * *(float *)((char *)&v109 + v88);
    v88 += 4;
  }
  while (v88 != 36);
  unint64_t v90 = 0;
  *(_OWORD *)buf = v109;
  long long v175 = v110;
  int v176 = v111;
  do
  {
    *((float *)&v115 + v90) = sub_19044CC24((uint64_t)buf, v90) + *((float *)&v115 + v90);
    ++v90;
  }
  while (v90 != 9);
  uint64_t v91 = 0;
  v142[0] = v115;
  v142[1] = v116;
  int v143 = v117;
  float v92 = 0.0;
  do
  {
    float v92 = v92 + (float)(*(float *)((char *)v142 + v91) * *(float *)((char *)v142 + v91));
    v91 += 4;
  }
  while (v91 != 36);
  float v93 = sqrtf(v92);
  float v94 = (float)(v75 - (float)(v93 * v93)) * 0.5;
  BOOL v46 = v94 != 0.0;
  if (v94 == 0.0)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1A60);
    }
    __int16 v104 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1902AF000, v104, OS_LOG_TYPE_DEBUG, "kappa zero!", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1A60);
      }
      v141[0] = 0;
      double v105 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "static BOOL CMOQuaternion::northAndGravity(CMVector<float, 3>, CMVector<float, 3>, CMVector<float, 3>, const float *, CMOQuaternion &, CMMatrix<float, 3> &)", "CoreLocation: %s\n", v105);
      if (v105 != (char *)buf) {
        free(v105);
      }
    }
  }
  else
  {
    unint64_t v95 = 0;
    float v96 = v79 * (float)(1.0 / v94);
    do
    {
      for (unint64_t k = 0; k != 3; ++k)
      {
        unint64_t v98 = 0;
        *(_DWORD *)sub_190448B30(a3, v95, k) = 0;
        do
        {
          float v99 = sub_1904741A8((uint64_t)v142, v95, v98);
          float v100 = sub_1904741A8((uint64_t)v142, k, v98);
          double v101 = (float *)sub_190448B30(a3, v95, k);
          *double v101 = *v101 + (float)(v99 * v100);
          ++v98;
        }
        while (v98 != 3);
        __int16 v102 = (float *)sub_190448B30(a3, v95, k);
        *__int16 v102 = v96 * *v102;
      }
      int v103 = (float *)sub_190448B30(a3, v95, v95);
      *int v103 = v79 + *v103;
      ++v95;
    }
    while (v95 != 3);
  }
  return v46;
}

float *sub_1904D0698(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (unint64_t i = 0; i != 3; ++i)
  {
    for (unint64_t j = 0; j != 3; ++j)
    {
      float v8 = sub_190448408(a2, i);
      float v9 = v8 * sub_190448408(a3, j);
      double result = (float *)sub_190448B30(a1, i, j);
      *double result = v9;
    }
  }
  return result;
}

double sub_1904D072C(float32x4_t *a1, float *a2, float32x4_t a3)
{
  float v3 = *a2;
  float v4 = a2[4];
  float v5 = a2[8];
  float v6 = (float)(*a2 + v4) + v5;
  if (v6 <= 0.0)
  {
    if (v3 > v4)
    {
      BOOL v8 = v3 == v5;
      BOOL v9 = v3 < v5;
    }
    else
    {
      BOOL v8 = 1;
      BOOL v9 = 0;
    }
    if (v9 || v8)
    {
      if (v4 <= v5)
      {
        float v15 = (float)((float)((float)-v3 - v4) + v5) + 1.0;
        float v16 = 0.5 / sqrtf(v15);
        a1->f32[2] = v15 * v16;
        a1->f32[3] = v16 * (float)(a2[3] - a2[1]);
        a1->f32[0] = v16 * (float)(a2[2] + a2[6]);
        a3.f32[0] = v16 * (float)(a2[7] + a2[5]);
        a1->i32[1] = a3.i32[0];
      }
      else
      {
        float v10 = (float)((float)(v4 - v3) - v5) + 1.0;
        float v11 = 0.5 / sqrtf(v10);
        a1->f32[1] = v10 * v11;
        a1->f32[0] = v11 * (float)(a2[3] + a2[1]);
        a1->f32[3] = v11 * (float)(a2[2] - a2[6]);
        a3.f32[0] = v11 * (float)(a2[7] + a2[5]);
        a1->i32[2] = a3.i32[0];
      }
    }
    else
    {
      float v13 = (float)((float)(v3 - v4) - v5) + 1.0;
      float v14 = 0.5 / sqrtf(v13);
      a1->f32[0] = v13 * v14;
      a1->f32[1] = v14 * (float)(a2[3] + a2[1]);
      a1->f32[2] = v14 * (float)(a2[2] + a2[6]);
      a3.f32[0] = v14 * (float)(a2[7] - a2[5]);
      a1->i32[3] = a3.i32[0];
    }
  }
  else
  {
    float v7 = 0.5 / sqrtf(v6 + 1.0);
    a1->f32[3] = (float)(v6 + 1.0) * v7;
    a1->f32[2] = v7 * (float)(a2[3] - a2[1]);
    a1->f32[1] = v7 * (float)(a2[2] - a2[6]);
    a3.f32[0] = v7 * (float)(a2[7] - a2[5]);
    a1->i32[0] = a3.i32[0];
  }
  *(void *)&double result = sub_1902D9ACC(a1, a3).u64[0];
  return result;
}

float sub_1904D08E8@<S0>(float *a1@<X0>, float *a2@<X8>, float a3@<S0>)
{
  float v4 = a1[2];
  float v3 = a1[3];
  float v5 = v3 + v3;
  float v6 = *a1;
  float v7 = a1[1];
  float v8 = v7 + v7;
  float v9 = v3 * (float)(v3 + v3);
  float v10 = (float)((float)(v7 + v7) * v7) + -1.0;
  float v11 = (float)((float)(v4 + v4) * v4) + -1.0;
  float v12 = (float)(v6 + v6) * v7;
  float v13 = (float)(v6 + v6) * v4;
  float v14 = v3 * (float)(v6 + v6);
  float v15 = v8 * v4;
  float v16 = v3 * v8;
  float v17 = v5 * v4;
  float v18 = v9 + (float)((float)((float)(v6 + v6) * v6) + -1.0);
  float v19 = v12 - (float)(v17 * a3);
  float v20 = v13 + (float)(v16 * a3);
  float v21 = v12 + (float)(v17 * a3);
  float v22 = v9 + v10;
  float v23 = v15 - (float)(v14 * a3);
  float v24 = v13 - (float)(v16 * a3);
  float result = v15 + (float)(v14 * a3);
  *a2 = v18;
  a2[1] = v19;
  a2[2] = v20;
  a2[3] = v21;
  a2[4] = v22;
  a2[5] = v23;
  a2[6] = v24;
  a2[7] = result;
  a2[8] = v9 + v11;
  return result;
}

void sub_1904D0968(float *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF228, memory_order_acquire) & 1) == 0)
  {
    float v14 = a1;
    int v13 = __cxa_guard_acquire(&qword_1EB3BF228);
    a1 = v14;
    if (v13)
    {
      dword_1EB3BF21C = 1043452116;
      __cxa_guard_release(&qword_1EB3BF228);
      a1 = v14;
    }
  }
  float v3 = sub_1904CF514(a1);
  uint64_t v4 = 0;
  float v5 = sqrtf((float)(v1 * v1) + (float)(v3 * v3));
  float v6 = -1.0;
  if (v2 > v5) {
    float v6 = 1.0;
  }
  uint64_t v17 = 0x3F80000000000000;
  int v18 = 0;
  float v7 = (float)(v2 * -0.0) + (float)(v1 * v6);
  float v8 = 0.0;
  float v9 = (float)(v2 * 0.0) - (float)(v3 * v6);
  float v10 = (float)(v1 * -0.0) + (float)(v3 * 0.0);
  v16[0] = v7;
  v16[1] = v9;
  _OWORD v16[2] = v10;
  do
  {
    float v8 = v8 + (float)(v16[v4] * v16[v4]);
    ++v4;
  }
  while (v4 != 3);
  float v11 = sqrtf(v8);
  if (v11 > *(float *)&dword_1EB3BF21C)
  {
    float v12 = (float)-atan2f(v5, v2 * v6) / v11;
    v19[0] = v7 * v12;
    v19[1] = v9 * v12;
    v19[2] = v10 * v12;
    sub_1904CF7FC(&v15, v19);
    sub_1904D08E8(v15.f32, v19, -1.0);
    sub_1904CF674((uint64_t)v19, (float *)&v17);
  }
}

float sub_1904D0AD0(float *a1)
{
  sub_1904D0968(a1);
  float v5 = sub_1904CF7C0(a1, v2, v3, v4);
  for (float result = atan2f(-v6, v5) * 57.296; result < 0.0; float result = result + 360.0)
    ;
  for (; result >= 360.0; float result = result + -360.0)
    ;
  return result;
}

void sub_1904D0B60(float32x4_t *a1@<X0>, float32x4_t *a2@<X1>, float32x4_t *a3@<X8>, float a4@<S0>)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (a4 < 0.0 || a4 > 1.0)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1A60);
    }
    float v24 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      buf.i16[0] = 0;
      _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_FAULT, "Assertion failed: t >= 0 && t <= 1, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMOQuaternion.cpp, line 375,Invalid time t for slerp.", (uint8_t *)&buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1A60);
      }
      v30.i16[0] = 0;
      float v25 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "static CMOQuaternion CMOQuaternion::slerp(const CMOQuaternion &, const CMOQuaternion &, const float)", "CoreLocation: %s\n", v25);
      if (v25 != (char *)&buf) {
        free(v25);
      }
    }
  }
  float32x4_t buf = *a1;
  sub_1902D9ACC(&buf, buf);
  float32x4_t v30 = *a2;
  sub_1902D9ACC(&v30, v30);
  uint64_t v9 = v30.i64[0];
  float v11 = buf.f32[2];
  float v10 = buf.f32[3];
  uint64_t v12 = v30.i64[1];
  float v13 = fmaxf(fminf((float)((float)((float)(buf.f32[1] * v30.f32[1]) + (float)(buf.f32[0] * v30.f32[0]))+ (float)(buf.f32[2] * v30.f32[2]))+ (float)(buf.f32[3] * v30.f32[3]), 1.0), -1.0);
  float v14 = -v13;
  if (v13 > 0.0) {
    float v14 = v13;
  }
  float v15 = v14 + -1.0;
  if ((float)(v14 + -1.0) <= 0.0) {
    float v15 = -v15;
  }
  if (v15 >= 0.00000011921)
  {
    float v27 = 1.0 - a4;
    float v28 = buf.f32[0];
    float v29 = buf.f32[1];
    float v16 = acosf(v13);
    float v26 = a4;
    float v17 = sinf(v16);
    float v18 = sinf(v27 * v16);
    float v19 = v16 * v26;
    float v20 = v18 / v17;
    float v21 = sinf(v19) / v17;
    float32_t v22 = (float)(*(float *)&v12 * v21) + (float)(v20 * v11);
    a3->f32[0] = (float)(*(float *)&v9 * v21) + (float)(v20 * v28);
    a3->f32[1] = (float)(*((float *)&v9 + 1) * v21) + (float)(v20 * v29);
    v23.f32[0] = (float)(*((float *)&v12 + 1) * v21) + (float)(v20 * v10);
    a3->f32[2] = v22;
    a3->i32[3] = v23.i32[0];
    sub_1902D9ACC(a3, v23);
  }
  else
  {
    *a3 = *a1;
  }
}

uint64_t sub_1904D115C()
{
  id v0 = objc_alloc_init(MEMORY[0x1E4F28C10]);
  qword_1EB3BF230 = (uint64_t)v0;

  return MEMORY[0x1F4181798](v0, sel_setDateFormat_, @"yyyy-MM-dd HH:mm:ss Z");
}

uint64_t sub_1904D119C(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int32x4_t v2 = vdupq_n_s32(0x7FC00000u);
  *(int32x4_t *)(a1 + 8) = v2;
  *(int32x4_t *)(a1 + 24) = v2;
  *(int32x4_t *)(a1 + 40) = v2;
  *(int64x2_t *)(a1 + 72) = vdupq_n_s64(0x7FF8000000000000uLL);
  *(_OWORD *)(a1 + 120) = xmmword_19060A318;
  *(_OWORD *)(a1 + 136) = unk_19060A328;
  *(_OWORD *)(a1 + 152) = xmmword_19060A338;
  *(_OWORD *)(a1 + 168) = unk_19060A348;
  *(_OWORD *)(a1 + 88) = xmmword_19060A2F8;
  *(_OWORD *)(a1 + 104) = unk_19060A308;
  *(_OWORD *)(a1 + 248) = xmmword_19060A398;
  *(_OWORD *)(a1 + 232) = unk_19060A388;
  *(_OWORD *)(a1 + 216) = xmmword_19060A378;
  *(_OWORD *)(a1 + 200) = unk_19060A368;
  *(_OWORD *)(a1 + 184) = xmmword_19060A358;
  *(_OWORD *)(a1 + 264) = unk_19060A3A8;
  *(_OWORD *)(a1 + 280) = xmmword_19060A3B8;
  *(_OWORD *)(a1 + 312) = xmmword_19060A3D8;
  *(_OWORD *)(a1 + 328) = unk_19060A3E8;
  *(void *)a1 = 0x7FF8000000000000;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 61) = 0;
  *(_OWORD *)(a1 + 296) = unk_19060A3C8;
  *(void *)(a1 + 344) = a1 + 88;
  *(_DWORD *)(a1 + 400) = 0;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(void *)(a1 + 408) = a1 + 88;
  *(_DWORD *)(a1 + 464) = 0;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(void *)(a1 + 472) = a1 + 88;
  *(_DWORD *)(a1 + 528) = 0;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(void *)(a1 + 536) = a1 + 88;
  *(_DWORD *)(a1 + 592) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(void *)(a1 + 600) = a1 + 88;
  *(_DWORD *)(a1 + 656) = 0;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(void *)(a1 + 664) = a1 + 88;
  *(_DWORD *)(a1 + 720) = 0;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  if (qword_1E929D998 != -1) {
    dispatch_once(&qword_1E929D998, &unk_1EDFD1AA0);
  }
  float v3 = qword_1E929D9A0;
  if (os_log_type_enabled((os_log_t)qword_1E929D9A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)float32x4_t buf = 0;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "Constructing CMPdrInputs.", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D998 != -1) {
      dispatch_once(&qword_1E929D998, &unk_1EDFD1AA0);
    }
    float v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CMPdrInputs::CMPdrInputs()", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  return a1;
}

void sub_1904D1440(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 68) = 0;
  uint64_t v4 = 0;
  float v5 = *(float *)(a1 + 20);
  float v6 = *(float *)(a1 + 24);
  float v7 = *(float *)(a1 + 28);
  float v8 = *(float *)(a1 + 44);
  float v9 = *(float *)(a1 + 48);
  float v10 = *(float *)(a1 + 52);
  float v11 = *(float *)a2;
  float v12 = *(float *)a2 - *(float *)(a1 + 8);
  float v33 = v12;
  float32x2_t v13 = vsub_f32(*(float32x2_t *)(a2 + 4), *(float32x2_t *)(a1 + 12));
  float32x2_t v34 = v13;
  *(float *)(a1 + 8) = v11;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 8);
  float v14 = 0.0;
  do
  {
    float v14 = v14 + (float)(*(float *)((char *)&v33 + v4) * *(float *)((char *)&v33 + v4));
    v4 += 4;
  }
  while (v4 != 12);
  float v15 = sqrtf(v14);
  *(float *)(a1 + 56) = v15;
  if (v15 >= 0.005)
  {
    float v17 = v12 / v15;
    float v18 = v13.f32[0] / v15;
    *(float *)(a1 + 20) = v17;
    *(float *)(a1 + 24) = v13.f32[0] / v15;
    v13.f32[0] = v13.f32[1] / v15;
    *(float *)(a1 + 28) = v13.f32[1] / v15;
    uint64_t v19 = 0;
    float v20 = v17 - v5;
    float v21 = v18 - v6;
    float v22 = (float)(v13.f32[1] / v15) - v7;
    int v37 = LODWORD(v20);
    unint64_t v38 = __PAIR64__(LODWORD(v22), LODWORD(v21));
    float v23 = 0.0;
    do
    {
      float v23 = v23 + (float)(*(float *)((char *)&v37 + v19) * *(float *)((char *)&v37 + v19));
      v19 += 4;
    }
    while (v19 != 12);
    float v24 = sqrtf(v23);
    *(float *)(a1 + 60) = v24;
    if (v24 >= 0.005)
    {
      float v27 = v20 / v24;
      float v28 = v21 / v24;
      float v29 = v22 / v24;
      *(float *)(a1 + 32) = v27;
      *(float *)(a1 + 36) = v28;
      float v30 = (float)(v18 * v29) - (float)(v13.f32[0] * v28);
      float v31 = (float)(v13.f32[0] * v27) - (float)(v17 * v29);
      float v32 = (float)(v17 * v28) - (float)(v18 * v27);
      *(float *)(a1 + 40) = v29;
      *(float *)(a1 + 44) = v30;
      *(float *)(a1 + 48) = v31;
      *(float *)(a1 + 52) = v32;
      *(float *)(a1 + 64) = -(float)((float)((float)(v29 * (float)(v32 - v10)) + (float)(v28 * (float)(v31 - v9)))
                                   + (float)(v27 * (float)(v30 - v8)));
      *(unsigned char *)(a1 + 68) = 1;
      *(double *)a1 = a3;
      return;
    }
    if (qword_1E929D998 != -1) {
      dispatch_once(&qword_1E929D998, &unk_1EDFD1AA0);
    }
    float v25 = qword_1E929D9A0;
    if (os_log_type_enabled((os_log_t)qword_1E929D9A0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)float32x4_t buf = 134217984;
      double v40 = a3;
      _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_DEBUG, "[CMTNBDoTEstimatorBase::TNBFrame] Failed to obtain a new normal(N) vector, time %f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D998 != -1) {
        dispatch_once(&qword_1E929D998, &unk_1EDFD1AA0);
      }
      int v35 = 134217984;
      double v36 = a3;
      goto LABEL_23;
    }
  }
  else
  {
    *(int32x2_t *)(a1 + 20) = vdup_n_s32(0x7FC00000u);
    *(_DWORD *)(a1 + 28) = 2143289344;
    if (qword_1E929D998 != -1) {
      dispatch_once(&qword_1E929D998, &unk_1EDFD1AA0);
    }
    float v16 = qword_1E929D9A0;
    if (os_log_type_enabled((os_log_t)qword_1E929D9A0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)float32x4_t buf = 134217984;
      double v40 = a3;
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_DEBUG, "[CMTNBDoTEstimatorBase::TNBFrame] Failed to obtain a new tangent(T) vector, time %f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D998 != -1) {
        dispatch_once(&qword_1E929D998, &unk_1EDFD1AA0);
      }
      int v37 = 134217984;
      unint64_t v38 = *(void *)&a3;
LABEL_23:
      float v26 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMPdrInputs::AccelTNBFrame::updateFrame(const CMVector3d &, double)", "CoreLocation: %s\n", v26);
      if (v26 != (char *)buf) {
        free(v26);
      }
    }
  }
}

void sub_1904D1860(uint64_t a1, uint64_t a2, float32x4_t a3)
{
  double v5 = *(double *)a2 - *(double *)(a1 + 72);
  *(double *)a3.i64 = v5;
  *(void *)(a1 + 72) = *(void *)a2;
  *(double *)(a1 + 80) = v5;
  unsigned int v6 = *(_DWORD *)(a2 + 44);
  a3.f32[0] = -*(float *)(a2 + 40);
  *(float32x2_t *)v19.f32 = vneg_f32(*(float32x2_t *)(a2 + 32));
  v19.i64[1] = __PAIR64__(v6, a3.u32[0]);
  sub_1902D9ACC(&v19, a3);
  v20[0] = sub_1904CF73C(v19.f32, -*(float *)(a2 + 20), -*(float *)(a2 + 24), -*(float *)(a2 + 28));
  v20[1] = v7;
  v20[2] = v8;
  unsigned int v9 = *(_DWORD *)(a2 + 44);
  v10.f32[0] = -*(float *)(a2 + 40);
  *(float32x2_t *)v19.f32 = vneg_f32(*(float32x2_t *)(a2 + 32));
  v19.i64[1] = __PAIR64__(v9, v10.u32[0]);
  sub_1902D9ACC(&v19, v10);
  unint64_t v11 = 0;
  v18[0] = sub_1904CF73C(v19.f32, *(float *)(a2 + 8), *(float *)(a2 + 12), *(float *)(a2 + 16));
  v18[1] = v12;
  void v18[2] = v13;
  uint64_t v14 = a1 + 344;
  do
  {
    float v15 = sub_190448408((uint64_t)v20, v11);
    sub_1904D19A4(v14, v15);
    int v16 = *(_DWORD *)(v14 + 8);
    *(_DWORD *)sub_19042D844((uint64_t)&v19, v11) = v16;
    float v17 = sub_190448408((uint64_t)v18, v11);
    sub_1904D19A4(v14 + 192, v17);
    ++v11;
    v14 += 64;
  }
  while (v11 != 3);
  sub_1904D1440(a1, (uint64_t)&v19, *(double *)a2);
}

void sub_1904D19A4(uint64_t a1, float a2)
{
  float v3 = sub_1904D1A20((void *)a1, 0, a2);
  *(float *)(a1 + 8) = v3;
  for (uint64_t i = 1; i != 4; ++i)
  {
    float v3 = sub_1904D1A20((void *)a1, i, v3);
    *(float *)(a1 + 8) = v3;
  }
}

os_log_t sub_1904D19F0()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "MotionContext");
  qword_1E929D9A0 = (uint64_t)result;
  return result;
}

float sub_1904D1A20(void *a1, uint64_t a2, float a3)
{
  uint64_t v4 = *a1;
  float v3 = (char *)a1 + 12;
  uint64_t v5 = v4 + 8 * a2;
  uint64_t v6 = 3 * a2 + 1;
  float v7 = *(float *)&v3[4 * v6];
  uint64_t v8 = 3 * a2 + 2;
  double v9 = *(float *)&v3[4 * v8];
  float v10 = *(double *)(v4 + 96 + 24 * a2) * a3 * *(double *)(v5 + 192)
      - *(double *)(v4 + 96 + 8 * v6) * v7
      - *(double *)(v4 + 96 + 8 * v8) * v9;
  double v11 = *(double *)(v5 + 224)
      * (*(double *)(v4 + 8 * v6) * v7 + *(double *)(v4 + 24 * a2) * v10 + *(double *)(v4 + 8 * v8) * v9);
  *(float *)&v3[4 * v8] = v7;
  float result = v11;
  *(float *)&v3[4 * v6] = v10;
  *(_DWORD *)&v3[12 * a2] = 0;
  return result;
}

BOOL sub_1904D1AA8(unsigned char *a1, uint64_t a2)
{
  switch(*a1)
  {
    case 1:
      (*(void (**)(uint64_t, unsigned char *))(*(void *)a2 + 16))(a2, a1);
      return 1;
    case 2:
      (*(void (**)(uint64_t, unsigned char *))(*(void *)a2 + 24))(a2, a1);
      return 1;
    case 3:
      (*(void (**)(uint64_t, unsigned char *))(*(void *)a2 + 32))(a2, a1);
      return 1;
    case 4:
      return 1;
    case 5:
      (*(void (**)(uint64_t, unsigned char *))(*(void *)a2 + 56))(a2, a1);
      return 1;
    default:
      return *a1 != 255;
  }
}

void sub_1904D1BD4(uint64_t a1, void *a2, uint64_t a3, char a4)
{
  *(_WORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1EDFC9100;
  *(unsigned char *)(a1 + 10) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0x3FF0000000000000;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0x7FEFFFFFFFFFFFFFLL;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 168) = _Q0;
  *(unsigned char *)(a1 + 196) = a4;
  *(void *)(a1 + 200) = *a2;
  *(_DWORD *)(a1 + 208) = 4;
  *(void *)(a1 + 216) = 0x3FA0A3D70A3D70A4;
  *(unsigned char *)(a1 + 224) = 1;
  *(void *)(a1 + 232) = &unk_1EDFC93B0;
  *(void *)(a1 + 240) = 100;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = &unk_1EDFC8F88;
  *(void *)(a1 + 312) = 20;
  *(void *)(a1 + 320) = &unk_1EDFC9390;
  *(void *)(a1 + 328) = 20;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(void *)(a1 + 400) = &unk_1EDFC9390;
  *(void *)(a1 + 408) = 20;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(void *)(a1 + 480) = &unk_1EDFC9390;
  *(void *)(a1 + 488) = 20;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_DWORD *)(a1 + 600) = 0;
  *(void *)(a1 + 608) = 0xBFF0000000000000;
  *(_DWORD *)(a1 + 616) = 0;
  operator new[]();
}

void sub_1904D23A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  sub_1904D5F08(v13);
  *(void *)(v12 + 232) = a12;
  sub_1902D5B70((void *)(v12 + 256));
  _Unwind_Resume(a1);
}

void *sub_1904D23D4(void *a1)
{
  *a1 = &unk_1EDFC9100;
  uint64_t v2 = a1[16];
  if (v2) {
    MEMORY[0x192FCC960](v2, 0x1000C8052888210);
  }
  sub_1904D5F08(a1 + 38);
  a1[29] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 32);
  return a1;
}

void sub_1904D2464(void *a1)
{
  sub_1904D23D4(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904D249C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 8);
}

void sub_1904D24A4(uint64_t a1)
{
  *(unsigned char *)(a1 + 8) = 0;
  bzero((void *)(a1 + 16), 0x20uLL);
  *(void *)(a1 + 40) = 0x3FF0000000000000;
  bzero((void *)(a1 + 64), 0x30uLL);
  bzero(*(void **)(a1 + 120), 0x18uLL);
  bzero(*(void **)(a1 + 112), 0x3CuLL);
  uint64_t v2 = *(void *)(a1 + 120);
  memset_pattern16((void *)v2, &unk_19060A520, 0xCuLL);
  memset_pattern16((void *)(v2 + 12), &unk_19060A530, 0xCuLL);
  *(unsigned char *)(a1 + 10) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 168) = _Q0;
  bzero((void *)(a1 + 184), 0xCuLL);
  bzero((void *)(a1 + 156), 0xCuLL);
  bzero((void *)(a1 + 136), 0xCuLL);
  *(_DWORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  bzero((void *)(a1 + 560), 0xCuLL);
  bzero((void *)(a1 + 576), 0x18uLL);
  *(_DWORD *)(a1 + 600) = 0;
  *(void *)(a1 + 608) = 0xBFF0000000000000;
  *(_DWORD *)(a1 + 616) = 0;
  sub_1904D5FC0((void *)(a1 + 320));
  sub_1904D5FC0((void *)(a1 + 400));
  sub_1904D5FC0((void *)(a1 + 480));

  sub_1902B5164((void *)(a1 + 232));
}

void sub_1904D25B4(uint64_t a1, float64x2_t *a2, uint64_t a3, double *a4, void *a5)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 168) = *a5;
  ++*(_DWORD *)(a1 + 152);
  float v7 = *a4;
  float32x2_t v8 = vcvt_f32_f64(vsubq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(*a2), (float32x2_t)vdup_n_s32(0x3C8EFA35u))), *(float64x2_t *)(a1 + 88)));
  float v9 = (float)(v7 * 0.017453) - *(double *)(a1 + 104);
  *(float32x2_t *)(a1 + 156) = v8;
  *(float *)(a1 + 164) = v9;
  float32x2_t v29 = v8;
  if (*(unsigned char *)(a1 + 224))
  {
    float v10 = v8.f32[1];
    LODWORD(v45.f64[0]) = sqrtf(vmlas_n_f32(vmuls_lane_f32(v8.f32[1], v8, 1), v8.f32[0], v8.f32[0]) + (float)(v9 * v9));
    sub_1902D9094(a1 + 232, (float *)&v45);
    if (*(unsigned char *)(a1 + 196))
    {
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
      }
      double v11 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)float32x4_t buf = 134218752;
        double v36 = (float)(*(float *)v45.f64 / 0.017453);
        __int16 v37 = 2048;
        double v38 = (float)(v29.f32[0] * 57.296);
        __int16 v39 = 2048;
        double v40 = (float)(v10 * 57.296);
        __int16 v41 = 2048;
        double v42 = (float)(v9 * 57.296);
        _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_INFO, "omegaMag6, %.3f, omega, %.3f, %.3f, %.3f", buf, 0x2Au);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
        }
        *(_DWORD *)float v30 = 134218752;
        *(double *)&v30[4] = (float)(*(float *)v45.f64 / 0.017453);
        *(_WORD *)&v30[12] = 2048;
        *(double *)&v30[14] = (float)(v29.f32[0] * 57.296);
        *(_WORD *)&v30[22] = 2048;
        *(double *)&v30[24] = (float)(v10 * 57.296);
        __int16 v31 = 2048;
        double v32 = (float)(v9 * 57.296);
        float v27 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedGyroData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v27);
        if (v27 != (char *)buf) {
          free(v27);
        }
      }
    }
    float32x2_t v8 = v29;
  }
  double v28 = *(double *)(a1 + 200);
  float64x2_t v45 = vmulq_n_f64(vcvtq_f64_f32(v8), v28);
  double v46 = v28 * v9;
  sub_1904D38C0((double *)buf, v45.f64);
  sub_1904D39A0((double *)v30, (double *)buf, (double *)(a1 + 16));
  long long v12 = *(_OWORD *)&v30[16];
  *(_OWORD *)(a1 + 16) = *(_OWORD *)v30;
  *(_OWORD *)(a1 + 32) = v12;
  float32x2_t v13 = vadd_f32(*(float32x2_t *)(a1 + 136), v29);
  *(float32x2_t *)(a1 + 136) = v13;
  *(float *)&long long v12 = *(float *)(a1 + 144) + v9;
  *(_DWORD *)(a1 + 144) = v12;
  ++*(_DWORD *)(a1 + 148);
  double v14 = v28
      * (v28
       * (float)(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v13, v13).i32[1]), v13.f32[0], v13.f32[0])
               + (float)(*(float *)&v12 * *(float *)&v12)));
  if (v14 > 0.122500002) {
    sub_1904D2B0C(a1, v14, (int32x2_t)0x3FBF5C2900000000);
  }
  if (*(unsigned char *)(a1 + 196))
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3940);
    }
    float v15 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v16 = *(double *)(a1 + 16);
      double v17 = *(double *)(a1 + 24);
      double v18 = *(double *)(a1 + 32);
      double v19 = *(double *)(a1 + 40);
      uint64_t v20 = *a5;
      *(_DWORD *)float32x4_t buf = 134219008;
      double v36 = v16;
      __int16 v37 = 2048;
      double v38 = v17;
      __int16 v39 = 2048;
      double v40 = v18;
      __int16 v41 = 2048;
      double v42 = v19;
      __int16 v43 = 2048;
      uint64_t v44 = v20;
      _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_DEBUG, "[AppleQuaternion] x,%f,y,%f,z,%f,w,%f,timestamp,%f", buf, 0x34u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3940);
      }
      uint64_t v21 = *(void *)(a1 + 16);
      uint64_t v22 = *(void *)(a1 + 24);
      uint64_t v23 = *(void *)(a1 + 32);
      double v24 = *(double *)(a1 + 40);
      uint64_t v25 = *a5;
      *(_DWORD *)float v30 = 134219008;
      *(void *)&v30[4] = v21;
      *(_WORD *)&v30[12] = 2048;
      *(void *)&v30[14] = v22;
      *(_WORD *)&v30[22] = 2048;
      *(void *)&v30[24] = v23;
      __int16 v31 = 2048;
      double v32 = v24;
      __int16 v33 = 2048;
      uint64_t v34 = v25;
      float v26 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedGyroData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v26);
      if (v26 != (char *)buf) {
        free(v26);
      }
    }
  }
}

uint64_t sub_1904D2B0C(uint64_t result, double a2, int32x2_t a3)
{
  uint64_t v117 = *MEMORY[0x1E4F143B8];
  int v3 = *(_DWORD *)(result + 148);
  if (v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = result + 136;
    *(float *)a3.i32 = (float)v3;
    int32x2_t v91 = a3;
    float v6 = *(float *)(result + 136) / (float)v3;
    double v7 = *(double *)(result + 200) * (double)v3;
    *(_DWORD *)(result + 148) = 0;
    double v90 = exp(v7 / -5000.0);
    float32x2_t v88 = vdiv_f32(*(float32x2_t *)(v5 + 4), (float32x2_t)vdup_lane_s32(v91, 0));
    bzero((void *)v5, 0xCuLL);
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    *(float64x2_t *)(v5 - 48) = vmulq_n_f64(*(float64x2_t *)(v5 - 48), v90);
    *(double *)(v5 - 32) = v90 * *(double *)(v5 - 32);
    v108[0] = 0;
    float32x2_t v10 = v88;
    float v11 = v88.f32[1];
    v108[1] = v88.i32[1];
    float32x2_t v109 = vneg_f32(v88);
    int v110 = 0;
    float v111 = v6;
    __int32 v112 = v88.i32[0];
    float v113 = -v6;
    int v114 = 0;
    float v89 = vmul_f32(v10, v10).f32[0];
    v100[0] = -(float)(v89 + (float)(v11 * v11));
    v100[1] = v6 * v88.f32[0];
    float v101 = vmuls_lane_f32(v6, v88, 1);
    float v102 = v6 * v88.f32[0];
    float v103 = -(float)((float)(v6 * v6) + (float)(v11 * v11));
    float v104 = vmuls_lane_f32(v88.f32[0], v88, 1);
    float v105 = v101;
    float v106 = v104;
    float v107 = -(float)((float)(v6 * v6) + (float)(v10.f32[0] * v10.f32[0]));
    float v12 = v7;
    float v13 = -v12;
    double v14 = v7 * v7 * 0.5;
    float v15 = v14;
    do
    {
      for (uint64_t i = 0; i != 3; ++i)
        *(float *)&v95[v8 * 4 + i * 4] = (float)(v100[v8 + i] * v15) + (float)(v13 * *(float *)&v108[v8 + i]);
      *(float *)&v95[16 * v9] = *(float *)&v95[16 * v9] + 1.0;
      ++v9;
      v8 += 3;
    }
    while (v9 != 3);
    uint64_t v17 = 0;
    double v18 = v98;
    do
    {
      *(void *)double v18 = *(void *)&v95[v17];
      void v18[2] = *(float *)&v95[v17 + 8];
      v17 += 12;
      v18 += 6;
    }
    while (v17 != 36);
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    float v21 = v14 / 5000.0 - v7;
    do
    {
      for (uint64_t j = 0; j != 3; ++j)
        *(float *)&v95[v19 * 4 + j * 4] = *(float *)&v108[v19 + j] * v15;
      *(float *)&v95[16 * v20] = *(float *)&v95[16 * v20] + v21;
      ++v20;
      v19 += 3;
    }
    while (v20 != 3);
    uint64_t v23 = 0;
    double v24 = &v99;
    do
    {
      *(void *)double v24 = *(void *)&v95[v23];
      v24[2] = *(_DWORD *)&v95[v23 + 8];
      v23 += 12;
      v24 += 6;
    }
    while (v23 != 36);
    for (uint64_t k = 3; k != 21; k += 6)
      bzero(&v98[k], 0xCuLL);
    for (uint64_t m = 21; m != 39; m += 6)
    {
      bzero(&v98[m], 0xCuLL);
      float v26 = v90;
      v98[k] = v26;
      k += 7;
    }
    uint64_t v28 = 0;
    uint64_t v29 = *(void *)(v4 + 112);
    float v30 = v98;
    do
    {
      uint64_t v31 = v28 + 30;
      uint64_t v32 = 5;
      LODWORD(v33) = 6;
      do
      {
        uint64_t v34 = 0;
        int v35 = v33 - 2;
        unint64_t v33 = v32;
        float v36 = v98[v31];
        uint64_t v37 = v29 + 4 * (v35 * (int)v32 / 2);
        double v38 = v30;
        do
        {
          float v39 = *v38;
          v38 += 6;
          float v36 = v36 + (float)(v39 * *(float *)(v37 + 4 * v34++));
        }
        while (v33 != v34);
        v98[v31] = v36;
        uint64_t v32 = v33 - 1;
        uint64_t v31 = v28 + 6 * (v33 - 1);
      }
      while (v33 > 1);
      ++v28;
      ++v30;
    }
    while (v28 != 6);
    v92[0] = v94;
    v92[1] = v93;
    uint64_t v40 = 0;
    double v41 = 2.76135698e-10
        / (7.0 / (exp((0.11 - sqrtf((float)(v89 + (float)(v6 * v6)) + (float)(v88.f32[1] * v88.f32[1]))) / 0.012) + 1.0)
         + 1.0);
    __int16 v43 = (float *)v95;
    do
    {
      bzero(&v95[v40], 0xCuLL);
      float v42 = (v7 * -0.25 / 5000.0 + 0.333333333) * (v7 * (v7 * (v7 * v41)))
          + (float)(*(float *)v91.i32 * 0.00000021323) * 0.5 * v7;
      *__int16 v43 = v42;
      v43 += 7;
      v40 += 24;
    }
    while (v40 != 72);
    double v44 = expm1(-(v7 / 5000.0));
    long double v45 = exp(-(v7 / 5000.0));
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    long double v48 = v41 * -0.5 * 1.24999999e11 * (v45 * (v7 / 5000.0 * (v7 / 5000.0) + v7 / 5000.0 * 2.0) + v44 * 2.0);
    float v49 = v45 * (v7 * (v7 * (v41 * -0.5)));
    float v50 = v48;
    do
    {
      for (uint64_t n = 0; n != 3; ++n)
        *(float *)((char *)&v115 + v46 * 4 + n * 4) = *(float *)&v108[v46 + n] * v50;
      *((float *)&v115 + 4 * v47) = *((float *)&v115 + 4 * v47) + v49;
      ++v47;
      v46 += 3;
    }
    while (v47 != 3);
    float v52 = &v96;
    float v53 = &v97;
    float v54 = &v115;
    uint64_t v55 = 3;
    do
    {
      uint64_t v56 = 0;
      float v57 = v52;
      do
      {
        int v58 = *(_DWORD *)((char *)v54 + v56 * 4);
        v53[v56] = v58;
        *(_DWORD *)float v57 = v58;
        v57 += 3;
        ++v56;
      }
      while (v56 != 3);
      ++v55;
      float v52 = (uint64_t *)((char *)v52 + 4);
      v53 += 6;
      float v54 = (long long *)((char *)v54 + 12);
    }
    while (v55 != 6);
    float v59 = (1.0 - exp(v7 * -2.0 / 5000.0)) * (v41 * 5000.0) * 0.5;
    uint64_t v60 = 84;
    for (iuint64_t i = 84; ii != 156; ii += 24)
    {
      bzero(&v95[ii], 0xCuLL);
      *(float *)&v95[v60] = v59;
      v60 += 28;
    }
    uint64_t v62 = 6;
    sub_1904D3A74(v92, (uint64_t)v95, 6);
    uint64_t v63 = 0;
    uint64_t v64 = 5;
    uint64_t v66 = *(void *)(v4 + 112);
    uint64_t v65 = *(void *)(v4 + 120);
    uint64_t v67 = 5;
    float result = v65;
    while (1)
    {
      uint64_t v68 = 0;
      uint64_t v69 = v62 - 1;
      float v70 = 0.0;
      uint64_t v71 = v67 * 4;
      do
      {
        float v70 = v70
            + (float)((float)(*(float *)((char *)v98 + v71) * *(float *)((char *)v98 + v71)) * *(float *)(v65 + v68));
        v68 += 4;
        v71 += 24;
      }
      while (v68 != 24);
      if (v62 > 5)
      {
        float v74 = (float *)&v93[v69];
        float v75 = v70 + *v74;
        *((float *)&v115 + v69) = v75;
      }
      else
      {
        uint64_t v72 = v63;
        do
        {
          float v73 = v94[v69 + ((int)v72 + 5) * ((int)v72 + 6) / 2];
          float v70 = v70 + (float)((float)(v73 * v73) * *(float *)&v93[v72++ + 6]);
        }
        while (v72);
        float v74 = (float *)&v93[v69];
        float v75 = v70 + *v74;
        *((float *)&v115 + v69) = v75;
        if (v62 < 2)
        {
          *(_OWORD *)float result = v115;
          *(void *)(result + 16) = v116;
          return result;
        }
      }
      uint64_t v76 = 0;
      uint64_t v77 = 0;
      float result = *(void *)(v4 + 120);
      uint64_t v78 = (uint64_t)(int)(v69 * (v62 - 2) + ((int)v69 * ((int)v62 - 2) < 0)) >> 1;
      do
      {
        uint64_t v79 = 0;
        float v80 = 0.0;
        float v81 = v98;
        do
        {
          float v80 = v80 + (float)((float)(v81[v67] * *(float *)(result + v79)) * v81[v76]);
          v79 += 4;
          v81 += 6;
        }
        while (v79 != 24);
        uint64_t v82 = v77 + v78;
        float v83 = v80 + (float)(*v74 * v94[v77 + v78]);
        uint64_t v84 = v63;
        if (v62 <= 5)
        {
          do
          {
            float v83 = v83
                + (float)((float)(v94[v69 + ((int)v84 + 5) * ((int)v84 + 6) / 2] * v94[v84])
                        * v94[v77 + ((int)v84 + 5) * ((int)v84 + 6) / 2]);
            ++v84;
          }
          while (v84);
        }
        uint64_t v85 = 0;
        float v86 = v83 / v75;
        *(float *)(v66 + 4 * v82) = v86;
        do
        {
          v98[v76 + v85] = v98[v76 + v85] + (float)((float)-v86 * v98[v67 + v85]);
          v85 += 6;
        }
        while (v85 != 36);
        int v87 = v64;
        if (v62 <= 5)
        {
          do
          {
            v94[v77 + v87 * (v87 + 1) / 2] = v94[v77 + v87 * (v87 + 1) / 2]
                                           - (float)(*(float *)(v66 + 4 * v82) * v94[v69 + v87 * (v87 + 1) / 2]);
            ++v87;
          }
          while (v87 != 5);
          float v86 = *(float *)(v66 + 4 * v82);
        }
        v94[v82] = v94[v82] - v86;
        ++v77;
        ++v76;
      }
      while (v77 != v64);
      --v64;
      --v67;
      --v63;
      --v62;
    }
  }
  return result;
}

void sub_1904D3318(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, uint64_t a8)
{
  bzero(a1, 8 * a6);
  if (a7 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = a8 + 4 * a6;
    do
    {
      sub_1904D5C78(a8, *a2, a3 + 4 * v13, a7, a6);
      if (a6 >= 1)
      {
        float v15 = (float *)a2[1];
        double v16 = v15;
        uint64_t v17 = (float *)a8;
        uint64_t v18 = a6;
        do
        {
          float v19 = *v16++;
          v17[a6] = v19 * *v17;
          ++v17;
          --v18;
        }
        while (v18);
        uint64_t v20 = 0;
        float v21 = *(float *)(a5 + 4 * v13);
        float v22 = *(float *)(a4 + 4 * v13);
        uint64_t v23 = *a2;
        float v24 = 1.0 / v22;
        do
        {
          float v25 = v22;
          float v26 = *(float *)(a8 + 4 * v20);
          float v22 = v22 + (float)(v26 * *(float *)(v14 + 4 * v20));
          v15[v20] = v15[v20] * (float)(v25 * (float)(1.0 / v22));
          if (v20)
          {
            uint64_t v27 = 0;
            float v28 = -(float)(v26 * v24);
            uint64_t v29 = v23 + 4 * (((int)v20 - 1) * (int)v20 / 2);
            do
            {
              float v30 = *(float *)(v29 + 4 * v27);
              *(float *)(v29 + 4 * v27) = v30 + (float)(*(float *)(v14 + 4 * v27) * v28);
              *(float *)(v14 + 4 * v27) = *(float *)(v14 + 4 * v27) + (float)(*(float *)(v14 + 4 * v20) * v30);
              ++v27;
            }
            while (v20 != v27);
          }
          ++v20;
          float v24 = 1.0 / v22;
        }
        while (v20 != a6);
        float v31 = v21 * (float)(1.0 / v22);
        uint64_t v32 = (float *)(a8 + 4 * a6);
        unint64_t v33 = (double *)a1;
        uint64_t v34 = a6;
        do
        {
          float v35 = *v32++;
          *unint64_t v33 = *v33 + (float)(v31 * v35);
          ++v33;
          --v34;
        }
        while (v34);
      }
      ++v13;
    }
    while (v13 != a7);
  }
}

void sub_1904D34D0(uint64_t a1, float32x2_t *a2, float *a3)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 196))
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3940);
    }
    float v6 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v7 = a2->f32[0];
      double v8 = a2->f32[1];
      double v9 = a2[1].f32[0];
      double v10 = *a3;
      double v11 = a3[1];
      double v12 = a3[2];
      *(_DWORD *)float32x4_t buf = 134219264;
      double v46 = v7;
      __int16 v47 = 2048;
      double v48 = v8;
      __int16 v49 = 2048;
      double v50 = v9;
      __int16 v51 = 2048;
      double v52 = v10;
      __int16 v53 = 2048;
      double v54 = v11;
      LOWORD(v55[0]) = 2048;
      *(double *)((char *)v55 + 2) = v12;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEBUG, "[Bias,Var] bias.x,%f,bias.y,%f,bias.z,%f,var.x,%f,var.y,%f,var.z,%f", buf, 0x3Eu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3940);
      }
      double v22 = a2->f32[0];
      double v23 = a2->f32[1];
      double v24 = a2[1].f32[0];
      double v25 = *a3;
      double v26 = a3[1];
      double v27 = a3[2];
      int v33 = 134219264;
      double v34 = v22;
      __int16 v35 = 2048;
      double v36 = v23;
      __int16 v37 = 2048;
      double v38 = v24;
      __int16 v39 = 2048;
      double v40 = v25;
      __int16 v41 = 2048;
      double v42 = v26;
      __int16 v43 = 2048;
      double v44 = v27;
      float v28 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedGyroBias(const CLMotionTypeRotationRate &, const CLMotionTypeVector3 &)", "CoreLocation: %s\n", v28);
      if (v28 != (char *)buf) {
        free(v28);
      }
    }
  }
  if (*(unsigned char *)(a1 + 10))
  {
    uint64_t v13 = 0;
    uint64_t v31 = *(void *)a3;
    int v32 = *((_DWORD *)a3 + 2);
    do
    {
      float v14 = *(float *)((char *)&v31 + v13);
      if (v14 < 0.000001) {
        float v14 = 0.000001;
      }
      *(float *)((char *)&v31 + v13) = v14;
      v13 += 4;
    }
    while (v13 != 12);
    int v15 = *(_DWORD *)(a1 + 152);
    if (v15 >= 1)
    {
      int v16 = 0;
      if (v15 >= 50) {
        int v17 = 50;
      }
      else {
        int v17 = *(_DWORD *)(a1 + 152);
      }
      uint64_t v18 = v31;
      int v19 = v32;
      do
      {
        float32x2_t v29 = vcvt_f32_f64(vsubq_f64(vcvtq_f64_f32(*a2), *(float64x2_t *)(a1 + 88)));
        float v20 = a2[1].f32[0] - *(double *)(a1 + 104);
        float v30 = v20;
        bzero(buf, 0x48uLL);
        *(_DWORD *)((char *)&v52 + 2) = 1065353216;
        v55[0] = 1065353216;
        v55[4] = 1065353216;
        uint64_t v57 = v18;
        int v58 = v19;
        sub_1904D3318(&v33, (uint64_t *)(a1 + 112), (uint64_t)buf, (uint64_t)&v57, (uint64_t)&v29, 6, 3, (uint64_t)v56);
        for (uint64_t i = 0; i != 24; i += 8)
          *(double *)(a1 + i + 88) = *(double *)((char *)&v38 + i) + *(double *)(a1 + i + 88);
        ++v16;
      }
      while (v16 != v17);
    }
    *(_DWORD *)(a1 + 152) = 0;
  }
  else
  {
    *(float64x2_t *)(a1 + 88) = vcvtq_f64_f32(*a2);
    *(double *)(a1 + 104) = a2[1].f32[0];
    *(unsigned char *)(a1 + 10) = 1;
  }
}

void sub_1904D38C0(double *a1, double *a2)
{
  double v4 = *a2;
  double v5 = sqrt(a2[1] * a2[1] + v4 * v4 + a2[2] * a2[2]);
  if (v5 >= 0.00000002)
  {
    __double2 v13 = __sincos_stret(v5 * 0.5);
    double cosval = v13.__cosval;
    *a1 = v4 * v13.__sinval / v5;
    a1[1] = v13.__sinval * a2[1] / v5;
    double v11 = v13.__sinval * a2[2] / v5;
  }
  else
  {
    *a1 = v4 * 0.5;
    double v6 = a2[1] * 0.5;
    a1[1] = v6;
    double v7 = a2[2] * 0.5;
    double v8 = v5 * v5 * 0.125;
    double v9 = 1.0 - v8;
    double v10 = sqrt(v8 + 1.0);
    *a1 = v4 * 0.5 / v10;
    a1[1] = v6 / v10;
    double v11 = v7 / v10;
    double cosval = v9 / v10;
  }
  a1[2] = v11;
  a1[3] = cosval;
}

double sub_1904D39A0(double *a1, double *a2, double *a3)
{
  double v4 = a2[2];
  double v3 = a2[3];
  double v5 = a3[1];
  double v6 = a2[1];
  double v7 = a3[2];
  double v8 = a3[3];
  *a1 = v4 * v5 + v3 * *a3 - v6 * v7 + *a2 * v8;
  double v9 = *a3;
  double v10 = *a2;
  a1[1] = v3 * v5 - v4 * *a3 + *a2 * v7 + v6 * v8;
  double v11 = a2[1];
  double v12 = a3[1];
  a1[2] = v11 * v9 - v10 * v12 + v3 * v7 + v4 * v8;
  double result = -(v11 * v12) - v10 * v9 - a2[2] * a3[2] + v3 * v8;
  a1[3] = result;
  return result;
}

double sub_1904D3A1C(double *a1, double *a2)
{
  *a1 = a2[3] * (a2[1] + a2[1]) - *a2 * (a2[2] + a2[2]);
  a1[1] = -(a2[3] * (*a2 + *a2)) - a2[1] * (a2[2] + a2[2]);
  double result = *a2 * (*a2 + *a2) + -1.0 + a2[1] * (a2[1] + a2[1]);
  a1[2] = result;
  return result;
}

void sub_1904D3A74(void **a1, uint64_t a2, int a3)
{
  bzero(*a1, 4 * ((a3 - 1) * a3 / 2));
  bzero(a1[1], 4 * a3);
  if (a3 >= 1)
  {
    int v6 = 0;
    double v7 = (float *)*a1;
    double v8 = (float *)a1[1];
    uint64_t v9 = a3 - 2;
    uint64_t v10 = a3 - 1;
    double v11 = &v8[a3];
    uint64_t v12 = v10;
    int v13 = a3;
    while (1)
    {
      float v14 = *(float *)(a2 + 4 * (v12 + (int)v12 * a3));
      if (v12 < v10)
      {
        uint64_t v15 = 0;
        do
        {
          float v14 = v14
              + (float)((float)-(float)(v7[v12 + (v13 - 1 + (int)v15) * (v13 + (int)v15) / 2]
                                      * v7[v12 + (v13 - 1 + (int)v15) * (v13 + (int)v15) / 2])
                      * v11[v15]);
          ++v15;
        }
        while (v6 != v15);
      }
      v8[v12] = v14;
      if (v12 < 1) {
        break;
      }
      int v16 = (float *)*a1;
      uint64_t v17 = v9;
      do
      {
        float v18 = *(float *)(a2 + 4 * (v17 + v12 * a3));
        if (v12 < v10)
        {
          uint64_t v19 = 0;
          do
          {
            float v18 = v18
                + (float)((float)-(float)(v16[v17 + (v13 - 1 + (int)v19) * (v13 + (int)v19) / 2]
                                        * v16[v12 + (v13 - 1 + (int)v19) * (v13 + (int)v19) / 2])
                        * v11[v19]);
            ++v19;
          }
          while (v6 != v19);
        }
        v7[v17 + ((uint64_t)(int)((v12 - 1) * v12 + (((int)v12 - 1) * (int)v12 < 0)) >> 1)] = v18 / v8[v12];
      }
      while (v17-- > 0);
      --v13;
      --v9;
      ++v6;
      --v11;
      --v12;
    }
  }
}

void sub_1904D3C0C(uint64_t a1, double *a2, double *a3, double *a4, void *a5)
{
  uint64_t v194 = *MEMORY[0x1E4F143B8];
  v10.f64[0] = *a2;
  float v11 = *a2;
  *(float *)(a1 + 184) = v11;
  double v12 = *a3;
  float v13 = *a3;
  *(float *)(a1 + 188) = v13;
  double v14 = *a4;
  float v15 = *a4;
  *(float *)(a1 + 192) = v15;
  if (*(double *)(a1 + 176) < 0.0)
  {
    sub_1904F1364(a1 + 16, a2, a3, a4);
    *(void *)(a1 + 176) = *a5;
    float v16 = *a2;
    *(float *)(a1 + 560) = v16;
    float v17 = *a3;
    *(float *)(a1 + 564) = v17;
    float v18 = *a4;
    *(float *)(a1 + 568) = v18;
    *(_DWORD *)(a1 + 600) = 0;
    sub_1904D3A1C((double *)(a1 + 576), (double *)(a1 + 16));
    *(unsigned char *)(a1 + 8) = 1;
    return;
  }
  if (*(unsigned char *)(a1 + 224))
  {
    v10.f64[1] = v12;
    float32x2_t v19 = vcvt_f32_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)(a1 + 560)), (float64x2_t)vdupq_n_s64(0x3FB999999999999AuLL)), (float64x2_t)vdupq_n_s64(0x3FECCCCCCCCCCCCDuLL), v10));
    *(float32x2_t *)(a1 + 560) = v19;
    float v20 = *(float *)(a1 + 568) * 0.1 + v14 * 0.9;
    *(float *)(a1 + 568) = v20;
    *(double *)float32x4_t buf = v19.f32[0];
    *(double *)unint64_t v163 = v19.f32[1];
    double v183 = v20;
    sub_1904D603C(a1 + 320, (double *)buf);
    sub_1904D603C(a1 + 400, (double *)v163);
    sub_1904D603C(a1 + 480, &v183);
  }
  *(void *)(a1 + 176) = *a5;
  if (!*(_DWORD *)(a1 + 148)) {
    return;
  }
  double v21 = *(double *)a5;
  double v22 = *(double *)(a1 + 168);
  if (*(double *)a5 < v22) {
    return;
  }
  if (*(unsigned char *)(a1 + 196))
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3940);
    }
    double v23 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v24 = *a2;
      double v25 = *a3;
      double v26 = *a4;
      double v27 = *(float *)(a1 + 560);
      double v28 = *(float *)(a1 + 564);
      double v29 = *(float *)(a1 + 568);
      uint64_t v30 = *a5;
      *(_DWORD *)float32x4_t buf = 134219520;
      *(double *)&uint8_t buf[4] = v24;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(double *)&buf[14] = v25;
      *(_WORD *)&buf[22] = 2048;
      double v174 = v26;
      __int16 v175 = 2048;
      double v176 = v27;
      __int16 v177 = 2048;
      double v178 = v28;
      __int16 v179 = 2048;
      double v180 = v29;
      __int16 v181 = 2048;
      uint64_t v182 = v30;
      _os_log_impl(&dword_1902AF000, v23, OS_LOG_TYPE_DEBUG, "[Accelerometer6] x,%.4f,y,%.4f,z,%.4f,lpf, %.4f, %.4f, %.4f, timestamp,%lf", buf, 0x48u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3940);
      }
      double v117 = *a2;
      double v118 = *a3;
      double v119 = *a4;
      double v120 = *(float *)(a1 + 560);
      double v121 = *(float *)(a1 + 564);
      double v122 = *(float *)(a1 + 568);
      uint64_t v123 = *a5;
      *(_DWORD *)unint64_t v163 = 134219520;
      *(double *)&v163[4] = v117;
      *(_WORD *)&v163[12] = 2048;
      *(double *)&v163[14] = v118;
      *(_WORD *)&v163[22] = 2048;
      double v164 = v119;
      __int16 v165 = 2048;
      double v166 = v120;
      __int16 v167 = 2048;
      double v168 = v121;
      __int16 v169 = 2048;
      double v170 = v122;
      __int16 v171 = 2048;
      uint64_t v172 = v123;
      int v124 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v124);
      if (v124 != buf) {
        free(v124);
      }
    }
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3940);
    }
    uint64_t v31 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v32 = *(float *)(a1 + 156);
      double v33 = *(float *)(a1 + 160);
      double v34 = *(float *)(a1 + 164);
      unint64_t v35 = *(void *)(a1 + 296);
      float v36 = 0.0;
      if (v35)
      {
        float v37 = *(float *)(a1 + 248);
        double v38 = (float)(v37 / (float)v35);
        if (v35 != 1)
        {
          float v39 = (float)((float)v35 * *(float *)(a1 + 252)) - (float)(v37 * v37);
          if (v39 >= 0.0) {
            float v36 = v39 / (float)((v35 - 1) * v35);
          }
        }
      }
      else
      {
        double v38 = 0.0;
      }
      *(_DWORD *)float32x4_t buf = 134219008;
      *(double *)&uint8_t buf[4] = v32;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(double *)&buf[14] = v33;
      *(_WORD *)&buf[22] = 2048;
      double v174 = v34;
      __int16 v175 = 2048;
      double v176 = v38;
      __int16 v177 = 2048;
      double v178 = v36;
      _os_log_impl(&dword_1902AF000, v31, OS_LOG_TYPE_DEBUG, "[RotationRate6X] %.3f, %.3f, %.3f, %.3f, %.3f", buf, 0x34u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3940);
      }
      double v125 = *(float *)(a1 + 156);
      double v126 = *(float *)(a1 + 160);
      double v127 = *(float *)(a1 + 164);
      unint64_t v128 = *(void *)(a1 + 296);
      float v129 = 0.0;
      if (v128)
      {
        float v130 = *(float *)(a1 + 248);
        double v131 = (float)(v130 / (float)v128);
        if (v128 != 1)
        {
          float v132 = (float)((float)v128 * *(float *)(a1 + 252)) - (float)(v130 * v130);
          if (v132 >= 0.0) {
            float v129 = v132 / (float)((v128 - 1) * v128);
          }
        }
      }
      else
      {
        double v131 = 0.0;
      }
      *(_DWORD *)unint64_t v163 = 134219008;
      *(double *)&v163[4] = v125;
      *(_WORD *)&v163[12] = 2048;
      *(double *)&v163[14] = v126;
      *(_WORD *)&v163[22] = 2048;
      double v164 = v127;
      __int16 v165 = 2048;
      double v166 = v131;
      __int16 v167 = 2048;
      double v168 = v129;
      float v139 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v139);
      if (v139 != buf) {
        free(v139);
      }
    }
  }
  double v40 = *a2;
  double v41 = *a3;
  double v42 = *a4;
  LODWORD(v22) = *(_DWORD *)(a1 + 136);
  LODWORD(v21) = *(_DWORD *)(a1 + 140);
  float v43 = *(float *)(a1 + 144);
  float v159 = *(float *)&v21;
  float v160 = *(float *)&v22;
  int v44 = *(_DWORD *)(a1 + 148);
  sub_1904D2B0C(a1, v21, *(int32x2_t *)&v22);
  double v45 = sqrt(v41 * v41 + v40 * v40 + v42 * v42);
  double v46 = fabs(v45 + -1.0) / v45;
  if (v46 > 0.1) {
    return;
  }
  if (!*(unsigned char *)(a1 + 224) || *(_DWORD *)(a1 + 616)) {
    goto LABEL_26;
  }
  float v88 = fabsf(*(float *)(a1 + 156));
  if (v88 > 10.0) {
    goto LABEL_92;
  }
  float v89 = fabsf(*(float *)(a1 + 160));
  if (v89 > 10.0) {
    goto LABEL_92;
  }
  float v90 = fabsf(*(float *)(a1 + 164));
  if (v90 > 10.0) {
    goto LABEL_92;
  }
  unint64_t v91 = *(void *)(a1 + 296);
  if (v91)
  {
    if ((float)(*(float *)(a1 + 248) / (float)v91) > 10.0) {
      goto LABEL_92;
    }
  }
  if (v88 > 3.14159265
    || v89 > 3.14159265
    || v90 > 3.14159265
    || (!v91 ? (float v92 = 0.0) : (float v92 = *(float *)(a1 + 248) / (float)v91), v92 > 3.14159265))
  {
    if (v91 < 2
      || (float v93 = (float)((float)v91 * *(float *)(a1 + 252)) - (float)(*(float *)(a1 + 248) * *(float *)(a1 + 248)),
          v93 < 0.0)
      || (float)(v93 / (float)((v91 - 1) * v91)) < 1.25)
    {
      sub_1904D3A1C((double *)(a1 + 576), (double *)(a1 + 16));
      if (!*(unsigned char *)(a1 + 196))
      {
        *(_DWORD *)(a1 + 600) = 0;
        goto LABEL_32;
      }
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
      }
      float v94 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)float32x4_t buf = 0;
        _os_log_impl(&dword_1902AF000, v94, OS_LOG_TYPE_DEBUG, "rotating and going through.", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
        }
        *(_WORD *)unint64_t v163 = 0;
        unint64_t v95 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v95);
        if (v95 != buf) {
          free(v95);
        }
      }
LABEL_26:
      int v47 = *(unsigned __int8 *)(a1 + 196);
      *(_DWORD *)(a1 + 600) = 0;
      if (v47)
      {
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
        }
        double v48 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)float32x4_t buf = 134218752;
          *(double *)&uint8_t buf[4] = v40;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(double *)&buf[14] = v41;
          *(_WORD *)&buf[22] = 2048;
          double v174 = v42;
          __int16 v175 = 2048;
          double v176 = v45;
          _os_log_impl(&dword_1902AF000, v48, OS_LOG_TYPE_DEBUG, "accM, (%.4f, %.4f, %.4f), mag, %.3f", buf, 0x2Au);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
          }
          *(_DWORD *)unint64_t v163 = 134218752;
          *(double *)&v163[4] = v40;
          *(_WORD *)&v163[12] = 2048;
          *(double *)&v163[14] = v41;
          *(_WORD *)&v163[22] = 2048;
          double v164 = v42;
          __int16 v165 = 2048;
          double v166 = v45;
          float v138 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v138);
          if (v138 != buf) {
            free(v138);
          }
        }
      }
LABEL_32:
      double v49 = v46
          * (0.015
           / (exp((0.9- sqrtf((float)((float)((float)(v159 / (float)v44) * (float)(v159 / (float)v44))+ (float)((float)(v160 / (float)v44) * (float)(v160 / (float)v44)))+ (float)((float)(v43 / (float)v44) * (float)(v43 / (float)v44))))/ 0.08)+ 1.0))+ 0.00000900000032;
      if (*(unsigned char *)(a1 + 224) && !*(_DWORD *)(a1 + 616)) {
        double v49 = v49 * 0.85;
      }
      uint64_t v50 = 0;
      uint64_t v51 = 0;
      double v52 = v41 / v45;
      double v53 = *(double *)(a1 + 16);
      double v54 = *(double *)(a1 + 24);
      double v55 = *(double *)(a1 + 32) + *(double *)(a1 + 32);
      double v56 = *(double *)(a1 + 40);
      double v57 = v56 * (v54 + v54) - v53 * v55;
      double v58 = -(v56 * (v53 + v53)) - v54 * v55;
      double v59 = v53 * (v53 + v53) + -1.0 + v54 * (v54 + v54);
      *(float *)&double v53 = v58;
      *(float *)&double v55 = v59;
      LODWORD(v189) = 0;
      HIDWORD(v189) = LODWORD(v55);
      *(float *)&double v190 = -*(float *)&v53;
      *(float *)&double v54 = v57;
      *((float *)&v190 + 1) = -*(float *)&v55;
      LODWORD(v191) = 0;
      HIDWORD(v191) = LODWORD(v54);
      LODWORD(v192) = LODWORD(v53);
      *((float *)&v192 + 1) = -*(float *)&v54;
      int v193 = 0;
      do
      {
        for (uint64_t i = 0; i != 36; i += 12)
          *(_DWORD *)&buf[v50 + i] = *(_DWORD *)((char *)&v189 + v50 + i);
        ++v51;
        v50 += 4;
      }
      while (v51 != 3);
      bzero((char *)&v176 + 2, 0x24uLL);
      float v61 = v49;
      *(float *)unint64_t v188 = v61;
      *(float *)&v188[1] = v61;
      *(float *)&v188[2] = v61;
      float v62 = v40 / v45 - v57;
      float v63 = v52 - v58;
      *(float *)double v187 = v62;
      *(float *)&v187[1] = v63;
      float v64 = v42 / v45 - v59;
      *(float *)&v187[2] = v64;
      sub_1904D3318(v163, (uint64_t *)(a1 + 112), (uint64_t)buf, (uint64_t)v188, (uint64_t)v187, 6, 3, (uint64_t)&v183);
      double v65 = v58 * *(double *)&v163[8] + *(double *)v163 * v57 + *(double *)&v163[16] * v59;
      *(double *)unint64_t v163 = *(double *)v163 - v65 * v57;
      *(double *)&v163[8] = *(double *)&v163[8] - v65 * v58;
      *(double *)&v163[16] = *(double *)&v163[16] - v65 * v59;
      sub_1904D38C0(v162, (double *)v163);
      sub_1904D39A0((double *)v161, v162, (double *)(a1 + 16));
      uint64_t v66 = 0;
      long long v67 = v161[1];
      *(_OWORD *)(a1 + 16) = v161[0];
      *(_OWORD *)(a1 + 32) = v67;
      do
      {
        *(double *)(a1 + 88 + v66) = *(double *)&v163[v66 + 24] + *(double *)(a1 + 88 + v66);
        v66 += 8;
      }
      while (v66 != 24);
      if (*(unsigned char *)(a1 + 224)) {
        sub_1904D3A1C((double *)(a1 + 576), (double *)(a1 + 16));
      }
      *(void *)(a1 + 608) = *a5;
      int v68 = *(_DWORD *)(a1 + 616);
      BOOL v69 = __OFSUB__(v68, 1);
      int v70 = v68 - 1;
      if (v70 < 0 == v69)
      {
        *(_DWORD *)(a1 + 616) = v70;
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
        }
        uint64_t v71 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)float32x4_t buf = 0;
          _os_log_impl(&dword_1902AF000, v71, OS_LOG_TYPE_DEBUG, "Doing some crude updates to catch up.", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
          }
          *(_WORD *)unint64_t v163 = 0;
          float v137 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v137);
          if (v137 != buf) {
            free(v137);
          }
        }
      }
      if (*(unsigned char *)(a1 + 196))
      {
        if (qword_1E929D7B8 != -1) {
          dispatch_once(&qword_1E929D7B8, &unk_1EDFD3940);
        }
        uint64_t v72 = qword_1E929D7B0;
        if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v73 = *(void *)(a1 + 64);
          uint64_t v74 = *(void *)(a1 + 72);
          double v75 = *(double *)(a1 + 80);
          double v76 = *(double *)(a1 + 88);
          double v77 = *(double *)(a1 + 96);
          double v78 = *(double *)(a1 + 104);
          uint64_t v79 = *a5;
          *(_DWORD *)float32x4_t buf = 134219520;
          *(void *)&uint8_t buf[4] = v73;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v74;
          *(_WORD *)&buf[22] = 2048;
          double v174 = v75;
          __int16 v175 = 2048;
          double v176 = v76;
          __int16 v177 = 2048;
          double v178 = v77;
          __int16 v179 = 2048;
          double v180 = v78;
          __int16 v181 = 2048;
          uint64_t v182 = v79;
          _os_log_impl(&dword_1902AF000, v72, OS_LOG_TYPE_DEBUG, "[KalmanFilterStates] %f,%f,%f,%f,%f,%f,%f", buf, 0x48u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D7B8 != -1) {
            dispatch_once(&qword_1E929D7B8, &unk_1EDFD3940);
          }
          uint64_t v80 = *(void *)(a1 + 64);
          uint64_t v81 = *(void *)(a1 + 72);
          double v82 = *(double *)(a1 + 80);
          double v83 = *(double *)(a1 + 88);
          double v84 = *(double *)(a1 + 96);
          double v85 = *(double *)(a1 + 104);
          uint64_t v86 = *a5;
          *(_DWORD *)unint64_t v163 = 134219520;
          *(void *)&v163[4] = v80;
          *(_WORD *)&v163[12] = 2048;
          *(void *)&v163[14] = v81;
          *(_WORD *)&v163[22] = 2048;
          double v164 = v82;
          __int16 v165 = 2048;
          double v166 = v83;
          __int16 v167 = 2048;
          double v168 = v84;
          __int16 v169 = 2048;
          double v170 = v85;
          __int16 v171 = 2048;
          uint64_t v172 = v86;
          int v87 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v87);
LABEL_58:
          if (v87 != buf) {
            free(v87);
          }
          return;
        }
      }
      return;
    }
  }
  sub_1904D5B20(a1 + 304, (uint64_t)&v183);
  double v158 = sqrt(v185 * v185 + v184 * v184 + v186 * v186);
  double v96 = *(double *)(a1 + 608);
  if (v96 > 0.0 && *(double *)(a1 + 176) - v96 > 15.0 && v158 < 0.3)
  {
    sub_1904D5C00(a1 + 304, (uint64_t)buf);
    if (fabs(sqrt(*(double *)&buf[16] * *(double *)&buf[16] + *(double *)&buf[8] * *(double *)&buf[8] + v174 * v174)+ -1.0) <= 0.1)
    {
      *(_DWORD *)(a1 + 616) = 10;
      if (!*(unsigned char *)(a1 + 196)) {
        goto LABEL_190;
      }
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
      }
      long long v115 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)float32x4_t buf = 0;
        _os_log_impl(&dword_1902AF000, v115, OS_LOG_TYPE_DEBUG, "it's been too long. go through.", buf, 2u);
      }
      if (!sub_1902D8400(115, 2)) {
        goto LABEL_190;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 == -1) {
        goto LABEL_125;
      }
      goto LABEL_222;
    }
  }
  if (*(_DWORD *)(a1 + 392) <= (int)((double)*(unint64_t *)(a1 + 312) * 0.5))
  {
LABEL_92:
    sub_1904D3A1C((double *)(a1 + 576), (double *)(a1 + 16));
    return;
  }
  uint64_t v97 = *(void *)(a1 + 296);
  if (v97) {
    float v98 = *(float *)(*(void *)(*(void *)(a1 + 264)
  }
                               + (((unint64_t)(v97 + *(void *)(a1 + 288) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                   + 4 * ((v97 + *(void *)(a1 + 288) - 1) & 0x3FF));
  else {
    float v98 = 0.0;
  }
  if (v98 > 0.2)
  {
    sub_1904D3A1C((double *)(a1 + 576), (double *)(a1 + 16));
    if (*(unsigned char *)(a1 + 196))
    {
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
      }
      int v99 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v100 = *(void *)(a1 + 576);
        uint64_t v101 = *(void *)(a1 + 584);
        double v102 = *(double *)(a1 + 592);
        *(_DWORD *)float32x4_t buf = 134218496;
        *(void *)&uint8_t buf[4] = v100;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v101;
        *(_WORD *)&buf[22] = 2048;
        double v174 = v102;
        _os_log_impl(&dword_1902AF000, v99, OS_LOG_TYPE_DEBUG, "grabing gravity, %.4f, %.4f, %.4f", buf, 0x20u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
        }
        uint64_t v147 = *(void *)(a1 + 576);
        uint64_t v148 = *(void *)(a1 + 584);
        double v149 = *(double *)(a1 + 592);
        *(_DWORD *)unint64_t v163 = 134218496;
        *(void *)&v163[4] = v147;
        *(_WORD *)&v163[12] = 2048;
        *(void *)&v163[14] = v148;
        *(_WORD *)&v163[22] = 2048;
        double v164 = v149;
        float v150 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v150);
        if (v150 != buf) {
          free(v150);
        }
      }
    }
  }
  if (v158 <= *(double *)(a1 + 216) * 0.75) {
    goto LABEL_190;
  }
  double v103 = *(double *)(a1 + 576);
  double v104 = *(double *)(a1 + 584);
  double v105 = *(double *)(a1 + 592);
  double v106 = fabs(v185 * v104 + v184 * v103 + v186 * v105);
  double v157 = v158 - v106;
  double v107 = *(double *)(a1 + 336);
  double v108 = *(double *)(a1 + 416);
  double v109 = *(double *)(a1 + 496);
  double v189 = &unk_1EDFC7D40;
  double v110 = v104 * v108 + v107 * v103 + v109 * v105;
  double v190 = v107 - v110 * v103;
  double v191 = v108 - v110 * v104;
  double v192 = v109 - v110 * v105;
  double v155 = v110;
  double v156 = fabs(v192) + fabs(v190) + fabs(v191);
  if (*(unsigned char *)(a1 + 196))
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
    }
    float v111 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)float32x4_t buf = 134219264;
      *(double *)&uint8_t buf[4] = v184;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(double *)&buf[14] = v185;
      *(_WORD *)&buf[22] = 2048;
      double v174 = v186;
      __int16 v175 = 2048;
      double v176 = v158;
      __int16 v177 = 2048;
      double v178 = v106;
      __int16 v179 = 2048;
      double v180 = v158 - v106;
      _os_log_impl(&dword_1902AF000, v111, OS_LOG_TYPE_DEBUG, "std, %.3f, %.3f, %.3f, mag, %.3f, dot, %.3f, leftover, %.3f", buf, 0x3Eu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
      }
      *(_DWORD *)unint64_t v163 = 134219264;
      *(double *)&v163[4] = v184;
      *(_WORD *)&v163[12] = 2048;
      *(double *)&v163[14] = v185;
      *(_WORD *)&v163[22] = 2048;
      double v164 = v186;
      __int16 v165 = 2048;
      double v166 = v158;
      __int16 v167 = 2048;
      double v168 = v106;
      __int16 v169 = 2048;
      double v170 = v158 - v106;
      int v151 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v151);
      if (v151 != buf) {
        free(v151);
      }
    }
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
    }
    __int32 v112 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)float32x4_t buf = 134219008;
      *(double *)&uint8_t buf[4] = v190;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(double *)&buf[14] = v191;
      *(_WORD *)&buf[22] = 2048;
      double v174 = v192;
      __int16 v175 = 2048;
      double v176 = v155;
      __int16 v177 = 2048;
      double v178 = v156;
      _os_log_impl(&dword_1902AF000, v112, OS_LOG_TYPE_DEBUG, "sum, %.3f, %.3f, %.3f, dot, %.3f, leftover, %.3f", buf, 0x34u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
      }
      *(_DWORD *)unint64_t v163 = 134219008;
      *(double *)&v163[4] = v190;
      *(_WORD *)&v163[12] = 2048;
      *(double *)&v163[14] = v191;
      *(_WORD *)&v163[22] = 2048;
      double v164 = v192;
      __int16 v165 = 2048;
      double v166 = v155;
      __int16 v167 = 2048;
      double v168 = v156;
      double v152 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v152);
      if (v152 != buf) {
        free(v152);
      }
    }
  }
  if (v157 > *(double *)(a1 + 216)) {
    goto LABEL_141;
  }
  unint64_t v113 = *(void *)(a1 + 296);
  if (v113) {
    float v114 = *(float *)(a1 + 248) / (float)v113;
  }
  else {
    float v114 = 0.0;
  }
  BOOL v133 = v114 <= 1.57079633;
  double v134 = 0.0;
  if (!v133) {
    double v134 = 1.0;
  }
  if (v156 > (v134 * 0.5 + 1.0) * 6.0)
  {
LABEL_141:
    *(_DWORD *)(a1 + 600) = 0;
    return;
  }
  if (v157 >= 0.01 || v156 >= 0.6)
  {
    int v140 = *(_DWORD *)(a1 + 600) + 1;
    *(_DWORD *)(a1 + 600) = v140;
    if (!v113) {
      goto LABEL_180;
    }
    uint64_t v141 = (int *)(a1 + 600);
    float v135 = *(float *)(a1 + 248) / (float)v113;
  }
  else
  {
    if (!v113)
    {
      int v140 = *(_DWORD *)(a1 + 600) + 1;
      *(_DWORD *)(a1 + 600) = v140;
      goto LABEL_180;
    }
    float v135 = *(float *)(a1 + 248) / (float)v113;
    if (v135 > 0.5)
    {
      if (!*(unsigned char *)(a1 + 196)) {
        goto LABEL_190;
      }
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
      }
      int v136 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)float32x4_t buf = 0;
        _os_log_impl(&dword_1902AF000, v136, OS_LOG_TYPE_DEBUG, "===========Skip ahead.", buf, 2u);
      }
      if (!sub_1902D8400(115, 2)) {
        goto LABEL_190;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 == -1) {
        goto LABEL_125;
      }
LABEL_222:
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
LABEL_125:
      *(_WORD *)unint64_t v163 = 0;
      uint64_t v116 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v116);
      if (v116 != buf) {
        free(v116);
      }
      goto LABEL_190;
    }
    uint64_t v141 = (int *)(a1 + 600);
    int v140 = *(_DWORD *)(a1 + 600) + 1;
    *(_DWORD *)(a1 + 600) = v140;
  }
  if (v135 > 1.0
    && *(float *)(*(void *)(*(void *)(a1 + 264) + (((v113 + *(void *)(a1 + 288) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                + 4 * ((v113 + *(void *)(a1 + 288) - 1) & 0x3FF)) < 0.2)
  {
    sub_1904D5C00(a1 + 304, (uint64_t)buf);
    double v142 = sqrt(*(double *)&buf[16] * *(double *)&buf[16] + *(double *)&buf[8] * *(double *)&buf[8] + v174 * v174);
    if (fabs(v142 + -1.0) / v142 >= 0.025)
    {
      int v140 = *v141;
    }
    else
    {
      if (*(unsigned char *)(a1 + 196))
      {
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
        }
        int v143 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)float32x4_t buf = 0;
          _os_log_impl(&dword_1902AF000, v143, OS_LOG_TYPE_DEBUG, "Skip ahead------.", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
          }
          *(_WORD *)unint64_t v163 = 0;
          long long v154 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v154);
          if (v154 != buf) {
            free(v154);
          }
        }
      }
      int v140 = *v141 + 2;
      int *v141 = v140;
    }
  }
LABEL_180:
  if (v140 >= *(_DWORD *)(a1 + 208))
  {
LABEL_190:
    if (*(unsigned char *)(a1 + 224))
    {
      if (v158 > 0.2)
      {
        unint64_t v145 = *(void *)(a1 + 296);
        if (!v145
          || *(float *)(*(void *)(*(void *)(a1 + 264)
                                  + (((v145 + *(void *)(a1 + 288) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                      + 4 * ((v145 + *(void *)(a1 + 288) - 1) & 0x3FF)) < 0.75
          && (float)(*(float *)(a1 + 248) / (float)v145) < 1.0)
        {
          sub_1904D5C00(a1 + 304, (uint64_t)v163);
          double v40 = *(double *)&v163[8];
          double v41 = *(double *)&v163[16];
          double v42 = v164;
          if (*(unsigned char *)(a1 + 196))
          {
            if (qword_1EB3BE878 != -1) {
              dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
            }
            int v146 = off_1EB3BE870;
            if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)float32x4_t buf = 0;
              _os_log_impl(&dword_1902AF000, v146, OS_LOG_TYPE_DEBUG, "using mean accel", buf, 2u);
            }
            if (sub_1902D8400(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1EB3BE878 != -1) {
                dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
              }
              LOWORD(v183) = 0;
              int v153 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v153);
              if (v153 != buf) {
                free(v153);
              }
            }
          }
          double v45 = sqrt(v41 * v41 + v40 * v40 + v42 * v42);
          double v46 = fabs(v45 + -1.0) / v45;
        }
      }
    }
    goto LABEL_26;
  }
  if (*(unsigned char *)(a1 + 196))
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
    }
    long long v144 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)float32x4_t buf = 0;
      _os_log_impl(&dword_1902AF000, v144, OS_LOG_TYPE_DEBUG, "Taking another look.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AC0);
      }
      *(_WORD *)unint64_t v163 = 0;
      int v87 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v87);
      goto LABEL_58;
    }
  }
}

double sub_1904D5B20@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = *(void *)(a1 + 88);
  double v3 = 0.0;
  double v4 = 0.0;
  if (v2 >= 2)
  {
    double v5 = (double)v2 * *(double *)(a1 + 40) - *(double *)(a1 + 32) * *(double *)(a1 + 32);
    double v4 = 0.0;
    if (v5 >= 0.0) {
      double v4 = v5 / (double)((v2 - 1) * v2);
    }
  }
  unint64_t v6 = *(void *)(a1 + 168);
  if (v6 >= 2)
  {
    double v7 = (double)v6 * *(double *)(a1 + 120) - *(double *)(a1 + 112) * *(double *)(a1 + 112);
    if (v7 >= 0.0) {
      double v3 = v7 / (double)((v6 - 1) * v6);
    }
  }
  unint64_t v8 = *(void *)(a1 + 248);
  double v9 = 0.0;
  if (v8 >= 2)
  {
    double v10 = (double)v8 * *(double *)(a1 + 200) - *(double *)(a1 + 192) * *(double *)(a1 + 192);
    if (v10 >= 0.0) {
      double v9 = v10 / (double)((v8 - 1) * v8);
    }
  }
  *(void *)a2 = &unk_1EDFC7D40;
  *(double *)(a2 + 8) = sqrt(v4);
  *(double *)(a2 + 16) = sqrt(v3);
  double result = sqrt(v9);
  *(double *)(a2 + 24) = result;
  return result;
}

uint64_t sub_1904D5C00@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = *(void *)(result + 88);
  double v3 = 0.0;
  double v4 = 0.0;
  if (v2) {
    double v4 = *(double *)(result + 32) / (double)v2;
  }
  unint64_t v5 = *(void *)(result + 168);
  if (v5) {
    double v3 = *(double *)(result + 112) / (double)v5;
  }
  unint64_t v6 = *(void *)(result + 248);
  if (v6) {
    double v7 = *(double *)(result + 192) / (double)v6;
  }
  else {
    double v7 = 0.0;
  }
  *(void *)a2 = &unk_1EDFC7D40;
  *(double *)(a2 + 8) = v4;
  *(double *)(a2 + 16) = v3;
  *(double *)(a2 + 24) = v7;
  return result;
}

uint64_t sub_1904D5C78(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = 0;
    unint64_t v6 = (float *)(a3 - 4 * a4);
    do
    {
      float v7 = *(float *)(a3 + 4 * v5 * a4);
      *(float *)(result + 4 * v5) = v7;
      if (v5)
      {
        unint64_t v8 = v6;
        uint64_t v9 = v5;
        do
        {
          float v7 = v7 + (float)(*v8 * *(float *)(a2 - 4 + 4 * (((int)v5 - 1) * (int)v5 / 2) + 4 * v9));
          *(float *)(result + 4 * v5) = v7;
          v8 -= a4;
        }
        while (v9-- > 1);
      }
      ++v5;
      v6 += a4;
    }
    while (v5 != a5);
  }
  return result;
}

uint64_t sub_1904D5CFC()
{
  return 0;
}

double sub_1904D5D04(uint64_t a1)
{
  return *(double *)(a1 + 16);
}

double sub_1904D5D0C(uint64_t a1)
{
  return *(double *)(a1 + 24);
}

double sub_1904D5D14(uint64_t a1)
{
  return *(double *)(a1 + 32);
}

double sub_1904D5D1C(uint64_t a1)
{
  return *(double *)(a1 + 40);
}

uint64_t sub_1904D5D24(_DWORD *a1, _DWORD *a2)
{
  *a2 = a1[39];
  a2[1] = a1[40];
  a2[2] = a1[41];
  return 1;
}

BOOL sub_1904D5D44(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a1 + 176);
  if (v2 <= 0.0)
  {
    *(void *)a2 = 0;
    float v10 = 0.0;
  }
  else
  {
    double v3 = *(double *)(a1 + 40);
    double v4 = *(double *)(a1 + 32) + *(double *)(a1 + 32);
    double v5 = *(double *)(a1 + 16);
    double v6 = *(double *)(a1 + 24);
    double v7 = v3 * (v6 + v6) - v5 * v4;
    double v8 = -(v3 * (v5 + v5)) - v6 * v4;
    double v9 = v5 * (v5 + v5) + -1.0 + v6 * (v6 + v6);
    *(float *)&double v5 = *(float *)(a1 + 184) - v7;
    *(_DWORD *)a2 = LODWORD(v5);
    *(float *)&double v8 = *(float *)(a1 + 188) - v8;
    *(_DWORD *)(a2 + 4) = LODWORD(v8);
    float v10 = *(float *)(a1 + 192) - v9;
  }
  BOOL result = v2 > 0.0;
  *(float *)(a2 + 8) = v10;
  return result;
}

uint64_t sub_1904D5DD4()
{
  return 0;
}

uint64_t sub_1904D5DDC()
{
  return 0;
}

uint64_t sub_1904D5DE4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 9);
}

float sub_1904D5DEC(uint64_t a1)
{
  return *(double *)(a1 + 64);
}

os_log_t sub_1904D5DF8()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Sensors");
  qword_1E929D7B0 = (uint64_t)result;
  return result;
}

void *sub_1904D5E28(void *a1)
{
  *a1 = &unk_1EDFC9390;
  sub_1904CECDC(a1 + 4);
  return a1;
}

void sub_1904D5E6C(void *a1)
{
  sub_1904D5F08(a1);

  JUMPOUT(0x192FCC980);
}

void sub_1904D5EA4(void *a1)
{
  *a1 = &unk_1EDFC9390;
  sub_1904CECDC(a1 + 4);

  JUMPOUT(0x192FCC980);
}

void *sub_1904D5F08(void *a1)
{
  *a1 = &unk_1EDFC8F88;
  a1[22] = &unk_1EDFC9390;
  sub_1904CECDC(a1 + 26);
  a1[12] = &unk_1EDFC9390;
  sub_1904CECDC(a1 + 16);
  a1[2] = &unk_1EDFC9390;
  sub_1904CECDC(a1 + 6);
  return a1;
}

void sub_1904D5FC0(void *a1)
{
  double v2 = (void **)a1[5];
  uint64_t v3 = a1[6];
  a1[9] = 0;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = a1[6];
      double v2 = (void **)(a1[5] + 8);
      a1[5] = v2;
      unint64_t v4 = v5 - (void)v2;
    }
    while (v4 > 0x10);
  }
  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 256;
    goto LABEL_7;
  }
  if (v4 >> 3 == 2)
  {
    uint64_t v6 = 512;
LABEL_7:
    a1[8] = v6;
  }
  a1[2] = 0;
  a1[3] = 0;
}

double sub_1904D603C(uint64_t a1, double *a2)
{
  uint64_t v4 = a1 + 32;
  sub_1904D60E4((void *)(a1 + 32), a2);
  unint64_t v5 = *(void *)(a1 + 72);
  if (v5 > *(void *)(a1 + 8))
  {
    unint64_t v6 = *(void *)(a1 + 64);
    double v7 = *(double *)(*(void *)(*(void *)(a1 + 40) + ((v6 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v6 & 0x1FF));
    double v8 = *(double *)(a1 + 16) - v7;
    double v9 = *(double *)(a1 + 24) - v7 * v7;
    *(double *)(a1 + 16) = v8;
    *(double *)(a1 + 24) = v9;
    *(void *)(a1 + 64) = v6 + 1;
    *(void *)(a1 + 72) = v5 - 1;
    sub_1904D6484(v4, 1);
  }
  double v10 = *(double *)(a1 + 24);
  *(double *)(a1 + 16) = *a2 + *(double *)(a1 + 16);
  double result = v10 + *a2 * *a2;
  *(double *)(a1 + 24) = result;
  return result;
}

double sub_1904D60E4(void *a1, double *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_1904D616C(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  double result = *a2;
  *(double *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
  return result;
}

void sub_1904D616C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_190347A00(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      float v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    float32x2_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      double v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_190393FFC(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_190394114((uint64_t)a1, &v54);
    int v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    double v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_190347A00((uint64_t)(a1 + 3), v46);
      unint64_t v35 = &v34[8 * (v46 >> 2)];
      float v37 = &v34[8 * v47];
      double v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      float v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  double v56 = a1 + 3;
  *(void *)&long long v54 = sub_190347A00((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  double v53 = operator new(0x1000uLL);
  sub_190394234(&v54, &v53);
  double v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_19039434C((uint64_t)&v54, v27);
  }
  double v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1904D6438(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1904D6484(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x200) {
    a2 = 1;
  }
  if (v2 < 0x400) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 512;
  }
  return v4 ^ 1u;
}

void sub_1904D64E4()
{
}

uint64_t sub_1904D64F8(uint64_t a1, int a2)
{
  uint64_t v3 = sub_1902C4008(a1, a2);
  char v4 = *(unsigned char *)(v3 + 8);
  *(void *)(v3 + 256) = 0;
  *(void *)(v3 + 264) = 0;
  *(unsigned char *)(v3 + 272) = 0;
  *(void *)(v3 + 208) = 0;
  *(void *)(v3 + 216) = 0;
  *(_WORD *)(v3 + 224) = 0;
  *(unsigned char *)(v3 + 273) = v4;
  *(void *)uint64_t v3 = &unk_1EDFC9A38;
  *(void *)(v3 + 200) = &unk_1EDFC9AA0;
  *(unsigned char *)(v3 + 274) = 0;
  *(void *)(v3 + 280) = 0;
  uint64_t v5 = v3 + 288;
  sub_1905C058C(v3 + 288);
  sub_1905C29EC(a1 + 1112, v5);
  return a1;
}

void sub_1904D65A0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 288) = &unk_1EDFC93D0;
  sub_190445960(v2);
  sub_1905B1F7C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1904D65D8(void *a1)
{
  *a1 = &unk_1EDFC9A38;
  unint64_t v2 = a1 + 25;
  a1[25] = &unk_1EDFC9AA0;
  sub_1902DE10C((uint64_t)(a1 + 25));
  sub_1902DE0A4(v2);
  sub_1902DE03C(v2);
  a1[36] = &unk_1EDFC93D0;
  sub_190445960(v2);

  return sub_1905B1F7C((uint64_t)a1);
}

uint64_t sub_1904D6690(uint64_t a1)
{
  return sub_1904D65D8((void *)(a1 - 200));
}

void sub_1904D6698(void *a1)
{
  sub_1904D65D8(a1);

  JUMPOUT(0x192FCC980);
}

void sub_1904D66D0(uint64_t a1)
{
  sub_1904D65D8((void *)(a1 - 200));

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904D670C(uint64_t a1)
{
  *(unsigned char *)(a1 + 1122) = 0;
  *(void *)(a1 + 1124) = 0;
  *(void *)(a1 + 1132) = 0x3F80000000000000;
  v3[0] = xmmword_19060CE04;
  v3[1] = unk_19060CE14;
  int v4 = 973279855;
  sub_190555CD4(a1 + 1140, (uint64_t)v3);
  *(unsigned char *)(a1 + 1120) = 0;
  *(void *)(a1 + 1176) = 0;
  *(_DWORD *)(a1 + 1184) = 0;
  *(void *)(a1 + 1192) = 1;
  sub_1905C0668(a1 + 288);
  sub_190445C68(a1 + 200);
  sub_190445A68(a1 + 200);
  sub_190445B8C(a1 + 200);
  *(void *)&v3[0] = 2;
  uint64_t result = sub_1905B224C(a1, v3);
  *(unsigned char *)(a1 + 274) = 0;
  *(void *)(a1 + 280) = 0;
  return result;
}

void *sub_1904D67C8(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 200);
  sub_1902DE10C(a1 + 200);
  sub_1902DE0A4(v1);

  return sub_1902DE03C(v1);
}

void sub_1904D680C(uint64_t a1, int a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE878 != -1) {
    dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AE0);
  }
  int v4 = off_1EB3BE870;
  if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)float32x4_t buf = 67109120;
    int v7 = a2;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "Application state changed, %d", buf, 8u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AE0);
    }
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionService6AxisAP::applicationStateChanged(BOOL)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  *(unsigned char *)(a1 + 274) = a2 ^ 1;
}

void sub_1904D69C4(uint64_t a1, uint64_t a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (unint64_t)(*(double *)a2 * 1000000.0);
  float v5 = *(float *)(a2 + 16) * 0.017453;
  float32x2_t v27 = vmul_f32(*(float32x2_t *)(a2 + 8), (float32x2_t)vdup_n_s32(0x3C8EFA35u));
  float v28 = v5;
  uint64_t v6 = a1 + 1112;
  sub_1905C377C(a1 + 1112, &v27, v4);
  sub_1905C09F0(a1 + 288, &v27, v4);
  *(_OWORD *)unint64_t v22 = 0uLL;
  double v21 = -1.0;
  sub_1902D9ACC((float32x4_t *)v22, v7);
  memset(&v22[4], 0, 36);
  *(_OWORD *)&v22[13] = xmmword_190609AC0;
  uint64_t v23 = 0x1FF00000000;
  int v24 = 0;
  char v25 = 0;
  uint64_t v26 = 0;
  double v21 = *(double *)a2;
  uint64_t v8 = (_OWORD *)(a1 + 1124);
  if (v22 != (_DWORD *)(a1 + 1124)) {
    *(_OWORD *)unint64_t v22 = *v8;
  }
  sub_1905C3414(v6);
  v22[4] = v9;
  v22[5] = v10;
  v22[6] = v11;
  uint64_t v12 = *(void *)(a1 + 1168);
  *(void *)&v22[7] = *(void *)(v12 + 432);
  v22[9] = *(_DWORD *)(v12 + 440);
  WORD2(v23) = 511;
  *(_OWORD *)&v22[10] = xmmword_190609AD0;
  v22[14] = -1082130432;
  if (*(unsigned char *)(v12 + 416) && *(void *)(v12 + 408) && *(unsigned char *)(a1 + 1122)) {
    __int16 v13 = HIWORD(v23) & 0xFFEF | (16 * *(unsigned __int8 *)(a1 + 252)) | 0x100;
  }
  else {
    __int16 v13 = HIWORD(v23) & 0xFEEF | (16 * *(unsigned __int8 *)(a1 + 252)) & 0xFEFF;
  }
  HIWORD(v23) = v13;
  int v24 = 3;
  uint64_t v26 = 0;
  char v25 = *(unsigned char *)(a2 + 22);
  double v14 = *(double *)a2;
  double v15 = *(double *)(a1 + 280);
  if (v15 != 0.0)
  {
    double v16 = v14 - v15;
    if (v14 - v15 > 0.100000001)
    {
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AE0);
      }
      uint64_t v17 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf[0]) = 134217984;
        *(double *)((char *)buf + 4) = v16;
        _os_log_impl(&dword_1902AF000, v17, OS_LOG_TYPE_INFO, "Large time gap, %lf", (uint8_t *)buf, 0xCu);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AE0);
        }
        int v29 = 134217984;
        double v30 = v16;
        float32x2_t v19 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionService6AxisAP::feedGyroData(const CLGyro::Sample *)", "CoreLocation: %s\n", v19);
        if (v19 != (char *)buf) {
          free(v19);
        }
      }
      if (*(unsigned char *)(a1 + 274))
      {
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AE0);
        }
        uint64_t v18 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf[0]) = 0;
          _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_DEFAULT, "Reset while backgrounded", (uint8_t *)buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1AE0);
          }
          LOWORD(v29) = 0;
          int64_t v20 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusionService6AxisAP::feedGyroData(const CLGyro::Sample *)", "CoreLocation: %s\n", v20);
          if (v20 != (char *)buf) {
            free(v20);
          }
        }
        *(unsigned char *)(a1 + 1122) = 0;
        *(void *)uint64_t v8 = 0;
        *(_DWORD *)(a1 + 1132) = 0;
        *(_DWORD *)(a1 + 1136) = 1065353216;
        buf[0] = xmmword_19060CE04;
        buf[1] = unk_19060CE14;
        int v32 = 973279855;
        sub_190555CD4(a1 + 1140, (uint64_t)buf);
        *(unsigned char *)(a1 + 1120) = 0;
        *(void *)(a1 + 1176) = 0;
        *(_DWORD *)(a1 + 1184) = 0;
        *(void *)(a1 + 1192) = 1;
      }
    }
  }
  *(double *)(a1 + 280) = v14;
  sub_1902D9B30(a1, (uint64_t)&v21);
}

void sub_1904D6E88(uint64_t a1, uint64_t a2)
{
}

float sub_1904D6E90(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  float result = *(float *)(a2 + 8);
  int v4 = *((_DWORD *)a3 + 2);
  *(unsigned char *)(a1 + 704) = 1;
  uint64_t v5 = *a3;
  *(void *)(a1 + 732) = *(void *)a2;
  *(float *)(a1 + 740) = result;
  *(void *)(a1 + 708) = v5;
  *(_DWORD *)(a1 + 716) = v4;
  return result;
}

float sub_1904D6EC0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  float result = *(float *)(a2 + 8);
  int v4 = *((_DWORD *)a3 + 2);
  *(unsigned char *)(a1 + 504) = 1;
  uint64_t v5 = *a3;
  *(void *)(a1 + 532) = *(void *)a2;
  *(float *)(a1 + 540) = result;
  *(void *)(a1 + 508) = v5;
  *(_DWORD *)(a1 + 516) = v4;
  return result;
}

uint64_t sub_1904D6EF0(float32x2_t *a1, uint64_t a2)
{
  uint64_t v3 = (unint64_t)(*(double *)a2 * 1000000.0);
  int v4 = *(_DWORD *)(a2 + 16);
  float32x2_t v6 = *(float32x2_t *)(a2 + 8);
  int v7 = v4;
  sub_1905C0704((uint64_t)&a1[36], &v6, v3);
  return sub_1905C3A84(a1 + 139);
}

uint64_t sub_1904D6F58(uint64_t a1, uint64_t a2)
{
  return sub_1904D6EF0((float32x2_t *)(a1 - 200), a2);
}

void *sub_1904D7FD4(void *a1)
{
  *a1 = &unk_1EDFC82F0;
  unint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_1902D8B58(v2);
  }

  return sub_1904DC240(a1);
}

void sub_1904D8034(void *a1)
{
  sub_1904D7FD4(a1);

  JUMPOUT(0x192FCC980);
}

os_log_t sub_1904D806C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accel");
  qword_1EB3BE840 = (uint64_t)result;
  return result;
}

void *sub_1904D809C(uint64_t a1)
{
  *(void *)a1 = &unk_1EDFCA210;
  *(void *)(a1 + 64) = 0;
  sub_1902BFA30(a1, *(_DWORD *)(a1 + 32));
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_1902D8B58(v2);
  }

  return sub_1904DC240((void *)a1);
}

void sub_1904D810C(uint64_t a1)
{
  sub_1904D809C(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904D8144(uint64_t a1)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  uint64_t result = IOHIDEventGetType();
  if (result == 20)
  {
    IOHIDEventGetFloatValue();
    double v4 = v3;
    IOHIDEventGetFloatValue();
    double v6 = v5;
    IOHIDEventGetFloatValue();
    double v8 = v7;
    unint64_t TimeStamp = IOHIDEventGetTimeStamp();
    double v10 = sub_1902D8D34(TimeStamp);
    Integerint Value = IOHIDEventGetIntegerValue();
    double v12 = *(double *)(a1 + 72);
    if (v12 > 0.0 && v10 > v12 + *(double *)(a1 + 48))
    {
      double v49 = v10;
      if (sub_1902BFD08(a1))
      {
        __int16 v13 = (void *)(*(uint64_t (**)(void, __CFString *))(**(void **)(a1 + 80) + 24))(*(void *)(a1 + 80), @"AppleVoltageDictionary");
        double v15 = objc_msgSend_objectForKeyedSubscript_(v13, v14, @"GYRO_TEMP");
        objc_msgSend_floatValue(v15, v16, v17);
        float v50 = v18 / 100.0;

        BOOL v19 = v15 != 0;
      }
      else
      {
        BOOL v19 = 0;
      }
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3F20);
      }
      int64_t v20 = qword_1E929D7B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)float32x4_t buf = 136446466;
        double v68 = COERCE_DOUBLE("CLGyro");
        __int16 v69 = 1026;
        LODWORD(v70) = v19;
        _os_log_impl(&dword_1902AF000, v20, OS_LOG_TYPE_DEBUG, "Type,%{public}s,ret=%{public}d", buf, 0x12u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D7B8 != -1) {
          dispatch_once(&qword_1E929D7B8, &unk_1EDFD3F20);
        }
        *(_DWORD *)long long v55 = 136446466;
        *(void *)&v55[4] = "CLGyro";
        *(_WORD *)&v55[12] = 1026;
        *(_DWORD *)&v55[14] = v19;
        uint64_t v47 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CLGyro::onGyroData(const CLMotionTypeRotationRate &, const CLMotionTypeTimestamp &, unsigned int)", "CoreLocation: %s\n", v47);
        if (v47 != (char *)buf) {
          free(v47);
        }
      }
      if (v19)
      {
        if (qword_1E929D7B8 != -1) {
          dispatch_once(&qword_1E929D7B8, &unk_1EDFD3F20);
        }
        double v21 = qword_1E929D7B0;
        if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)float32x4_t buf = 136446466;
          double v68 = COERCE_DOUBLE("GyroTemperature");
          __int16 v69 = 2050;
          double v70 = v50;
          _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_DEBUG, "Type,%{public}s,temperature,%{public}f", buf, 0x16u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D7B8 != -1) {
            dispatch_once(&qword_1E929D7B8, &unk_1EDFD3F20);
          }
          *(_DWORD *)long long v55 = 136446466;
          *(void *)&v55[4] = "GyroTemperature";
          *(_WORD *)&v55[12] = 2050;
          *(double *)&v55[14] = v50;
          double v48 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CLGyro::onGyroData(const CLMotionTypeRotationRate &, const CLMotionTypeTimestamp &, unsigned int)", "CoreLocation: %s\n", v48);
          if (v48 != (char *)buf) {
            free(v48);
          }
        }
        if (*(unsigned char *)(a1 + 96))
        {
          *(void *)long long v55 = &unk_1EDFCA718;
          *(void *)&v55[8] = CFAbsoluteTimeGetCurrent();
          *(float *)&v55[20] = v50;
          uint64_t v22 = sub_190570220();
          sub_190571738(v22, (uint64_t)v55);
          sub_190395088(buf);
          sub_1903AE400((uint64_t)buf);
          v88 |= 1u;
          uint64_t v85 = *(void *)&v55[8];
          uint64_t v23 = v87;
          float v24 = v50;
          *(unsigned char *)(v87 + 16) |= 2u;
          *(float *)(v23 + 12) = v24;
          sub_19039A590((PB::Base *)buf);
        }
        sub_1902D8BCC(a1, 1, (uint64_t)&v49, 16);
      }
      *(double *)(a1 + 48) = v10;
    }
    float v25 = v4;
    float v26 = v6;
    float v27 = v8;
    double v49 = v10;
    float v50 = v25;
    float v51 = v26;
    float v52 = v27;
    __int16 v53 = HIWORD(IntegerValue);
    BOOL v54 = (~IntegerValue & 0x300) == 0;
    if (qword_1EB3BE868 != -1) {
      dispatch_once(&qword_1EB3BE868, &unk_1EDFD3EE0);
    }
    float v28 = qword_1EB3BE860;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE860, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v29 = mach_absolute_time();
      double v30 = sub_1902D8D34(v29);
      *(_DWORD *)float32x4_t buf = 134220032;
      double v68 = v25;
      __int16 v69 = 2048;
      double v70 = v26;
      __int16 v71 = 2048;
      double v72 = v27;
      __int16 v73 = 2048;
      double v74 = v10;
      __int16 v75 = 1024;
      unsigned int v76 = IntegerValue;
      __int16 v77 = 1024;
      unsigned int v78 = HIWORD(IntegerValue) % 3u;
      __int16 v79 = 1024;
      int v80 = (IntegerValue >> 8) & 1;
      __int16 v81 = 1024;
      int v82 = (IntegerValue >> 9) & 1;
      __int16 v83 = 2048;
      double v84 = v30;
      _os_log_impl(&dword_1902AF000, v28, OS_LOG_TYPE_DEBUG, "[CLGyro] x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,subType,%d,sampleNum%%3,%d,triggerEnabled,%d,triggerOn,%d,now,%f", buf, 0x4Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE868 != -1) {
        dispatch_once(&qword_1EB3BE868, &unk_1EDFD3EE0);
      }
      uint64_t v42 = mach_absolute_time();
      double v43 = sub_1902D8D34(v42);
      *(_DWORD *)long long v55 = 134220032;
      *(double *)&v55[4] = v25;
      *(_WORD *)&v55[12] = 2048;
      *(double *)&v55[14] = v26;
      *(_WORD *)&v55[22] = 2048;
      double v56 = v27;
      *(_WORD *)double v57 = 2048;
      *(double *)&v57[2] = v10;
      *(_WORD *)&v57[10] = 1024;
      unsigned int v58 = IntegerValue;
      __int16 v59 = 1024;
      unsigned int v60 = HIWORD(IntegerValue) % 3u;
      __int16 v61 = 1024;
      int v62 = (IntegerValue >> 8) & 1;
      __int16 v63 = 1024;
      int v64 = (IntegerValue >> 9) & 1;
      __int16 v65 = 2048;
      double v66 = v43;
      int v44 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLGyro::onGyroData(const CLMotionTypeRotationRate &, const CLMotionTypeTimestamp &, unsigned int)", "CoreLocation: %s\n", v44);
      if (v44 != (char *)buf) {
        free(v44);
      }
    }
    if (v10 < *(double *)(a1 + 56))
    {
      if (qword_1EB3BE868 != -1) {
        dispatch_once(&qword_1EB3BE868, &unk_1EDFD3EE0);
      }
      long long v31 = qword_1EB3BE860;
      if (os_log_type_enabled((os_log_t)qword_1EB3BE860, OS_LOG_TYPE_ERROR))
      {
        double v32 = *(double *)(a1 + 56);
        *(_DWORD *)float32x4_t buf = 134218240;
        double v68 = v32;
        __int16 v69 = 2048;
        double v70 = v10;
        _os_log_impl(&dword_1902AF000, v31, OS_LOG_TYPE_ERROR, "Gyro time rollback, last timestamp, %f, current timestamp, %f", buf, 0x16u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE868 != -1) {
          dispatch_once(&qword_1EB3BE868, &unk_1EDFD3EE0);
        }
        uint64_t v45 = *(void *)(a1 + 56);
        *(_DWORD *)long long v55 = 134218240;
        *(void *)&v55[4] = v45;
        *(_WORD *)&v55[12] = 2048;
        *(double *)&v55[14] = v10;
        unint64_t v46 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "void CLGyro::onGyroData(const CLMotionTypeRotationRate &, const CLMotionTypeTimestamp &, unsigned int)", "CoreLocation: %s\n", v46);
        if (v46 != (char *)buf) {
          free(v46);
        }
      }
    }
    if (*(unsigned char *)(a1 + 96))
    {
      *(void *)long long v55 = &unk_1EDFCA818;
      *(void *)&v55[8] = CFAbsoluteTimeGetCurrent();
      double v56 = v10;
      *(float *)double v57 = v25;
      *(float *)&v57[4] = v26;
      *(float *)&v57[8] = v8;
      unsigned int v58 = IntegerValue;
      LOBYTE(v59) = HIWORD(IntegerValue) % 3u;
      HIBYTE(v59) = BYTE1(IntegerValue) & 1;
      LOBYTE(v60) = (IntegerValue & 0x200) != 0;
      uint64_t v33 = sub_190570220();
      sub_190571738(v33, (uint64_t)v55);
      sub_190395088(buf);
      sub_1903AE370((uint64_t)buf);
      v88 |= 1u;
      uint64_t v85 = *(void *)&v55[8];
      uint64_t v34 = v86;
      *(_WORD *)(v86 + 44) |= 1u;
      *(double *)(v34 + 8) = v10;
      uint64_t v35 = v86;
      *(_WORD *)(v86 + 44) |= 0x10u;
      *(float *)(v35 + 28) = v25;
      uint64_t v36 = v86;
      *(_WORD *)(v86 + 44) |= 0x20u;
      *(float *)(v36 + 32) = v26;
      uint64_t v37 = v86;
      *(_WORD *)(v86 + 44) |= 0x40u;
      *(float *)(v37 + 36) = v27;
      uint64_t v38 = v86;
      *(_WORD *)(v86 + 44) |= 8u;
      *(_DWORD *)(v38 + 24) = IntegerValue;
      uint64_t v39 = v86;
      *(_WORD *)(v86 + 44) |= 4u;
      *(_DWORD *)(v39 + 20) = HIWORD(IntegerValue) % 3u;
      uint64_t v40 = v86;
      *(_WORD *)(v86 + 44) |= 0x80u;
      *(unsigned char *)(v40 + 40) = BYTE1(IntegerValue) & 1;
      uint64_t v41 = v86;
      *(_WORD *)(v86 + 44) |= 0x100u;
      *(unsigned char *)(v41 + 41) = (IntegerValue & 0x200) != 0;
      sub_19039A590((PB::Base *)buf);
    }
    uint64_t result = sub_1902D8BCC(a1, 0, (uint64_t)&v49, 24);
    *(double *)(a1 + 56) = v10;
  }
  return result;
}

void sub_1904D8BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  sub_19039A590((PB::Base *)va);
  _Unwind_Resume(a1);
}

double sub_1904D8BE0(uint64_t a1, int a2, double *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a2 == 1)
  {
    if (qword_1EB3BE868 != -1) {
      dispatch_once(&qword_1EB3BE868, &unk_1EDFD3EE0);
    }
    double v14 = qword_1EB3BE860;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE860, OS_LOG_TYPE_INFO))
    {
      double v15 = *a3;
      *(_DWORD *)float32x4_t buf = 134349056;
      double v23 = v15;
      _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_INFO, "Setting gyro temperature update interval to %{public}f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE868 != -1) {
        dispatch_once(&qword_1EB3BE868, &unk_1EDFD3EE0);
      }
      double v20 = *a3;
      *(_DWORD *)uint64_t v29 = 134349056;
      *(double *)&v29[4] = v20;
      double v21 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual CFTimeInterval CLGyro::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
    }
    double v16 = *a3;
    if (*a3 < 1.0 && v16 != 0.0) {
      double v16 = 1.0;
    }
    *(double *)(a1 + 72) = v16;
    sub_1902BFA30(a1, *(_DWORD *)(a1 + 32));
    return *(double *)(a1 + 72);
  }
  else if (a2)
  {
    if (qword_1EB3BE868 != -1) {
      dispatch_once(&qword_1EB3BE868, &unk_1EDFD3EE0);
    }
    float v18 = qword_1EB3BE860;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE860, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)float32x4_t buf = 67240192;
      LODWORD(v23) = a2;
      _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_FAULT, "Unrecognized gyro notification %{public}d", buf, 8u);
    }
    double v6 = 0.0;
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE868 != -1) {
        dispatch_once(&qword_1EB3BE868, &unk_1EDFD3EE0);
      }
      *(_DWORD *)uint64_t v29 = 67240192;
      *(_DWORD *)&v29[4] = a2;
      __int16 v13 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual CFTimeInterval CLGyro::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v13);
      goto LABEL_37;
    }
  }
  else
  {
    *(double *)(a1 + 64) = *a3;
    sub_1902BFA30(a1, *(_DWORD *)(a1 + 32));
    double v6 = sub_1902B4DA8(a1, (double *)(a1 + 64));
    if (*(unsigned char *)(a1 + 96))
    {
      *(void *)uint64_t v29 = &unk_1EDFCA898;
      *(void *)&v29[8] = CFAbsoluteTimeGetCurrent();
      float v7 = v6;
      *(float *)&v29[20] = v7;
      uint64_t v8 = sub_190570220();
      sub_190571738(v8, (uint64_t)v29);
      sub_190395088(buf);
      sub_1903AE520((uint64_t)buf);
      v28 |= 1u;
      uint64_t v26 = *(void *)&v29[8];
      uint64_t v9 = v27;
      *(unsigned char *)(v27 + 12) |= 1u;
      *(float *)(v9 + 8) = v7;
      sub_19039A590((PB::Base *)buf);
    }
    if (qword_1EB3BE868 != -1) {
      dispatch_once(&qword_1EB3BE868, &unk_1EDFD3EE0);
    }
    double v10 = qword_1EB3BE860;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE860, OS_LOG_TYPE_INFO))
    {
      double v11 = *a3;
      *(_DWORD *)float32x4_t buf = 134349312;
      double v23 = v11;
      __int16 v24 = 2050;
      double v25 = v6;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_INFO, "Set gyro data update interval to %{public}f,dt,%{public}f", buf, 0x16u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE868 != -1) {
        dispatch_once(&qword_1EB3BE868, &unk_1EDFD3EE0);
      }
      double v12 = *a3;
      *(_DWORD *)uint64_t v29 = 134349312;
      *(double *)&v29[4] = v12;
      *(_WORD *)&v29[12] = 2050;
      *(double *)&v29[14] = v6;
      __int16 v13 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual CFTimeInterval CLGyro::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v13);
LABEL_37:
      if (v13 != (char *)buf) {
        free(v13);
      }
    }
  }
  return v6;
}

void sub_1904D9144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_19039A590((PB::Base *)va);
  _Unwind_Resume(a1);
}

os_log_t sub_1904D9160()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accel");
  qword_1EB3BE840 = (uint64_t)result;
  return result;
}

os_log_t sub_1904D9190()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Sensors");
  qword_1E929D7B0 = (uint64_t)result;
  return result;
}

void sub_1904D9304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_1904D9340(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  double v3 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  float v7 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v5, 0);
  if (*a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7)) != 0
    && (double v10 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage")) != 0)
  {
    int v13 = objc_msgSend_intValue(v10, v11, v12);
  }
  else
  {
    int v13 = 103;
  }
  if (qword_1EB3BE898 != -1) {
    dispatch_once(&qword_1EB3BE898, &unk_1EDFD3DE0);
  }
  double v14 = off_1EB3BE890;
  if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)float32x4_t buf = 67240192;
    int v17 = v13;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "ExericseMinute, Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD3DE0);
    }
    double v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMExerciseMinuteInternal init]_block_invoke", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
}

void sub_1904D9558(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v7 = ExecutablePathFromPid;
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD3DE0);
    }
    uint64_t v8 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_DEFAULT))
    {
      pid_t v9 = getpid();
      uint64_t v10 = *(void *)(a1 + 32);
      int v11 = *(unsigned __int8 *)(v10 + 32);
      *(_DWORD *)float32x4_t buf = 138413058;
      uint64_t v20 = v7;
      __int16 v21 = 1024;
      pid_t v22 = v9;
      __int16 v23 = 1024;
      int v24 = v11;
      __int16 v25 = 2048;
      uint64_t v26 = v10;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEFAULT, "ExericseMinute, client connection interrupt, %@, %d, %d, %p", buf, 0x22u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD3DE0);
      }
      getpid();
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMExerciseMinuteInternal init]_block_invoke", "CoreLocation: %s\n", v18);
      if (v18 != (char *)buf) {
        free(v18);
      }
    }
  }
  uint64_t v12 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v12 + 32))
  {
    id v13 = (id)objc_msgSend_copy(*(void **)(v12 + 48), v5, v6);
    id v16 = (id)objc_msgSend_copy(*(void **)(*(void *)(a1 + 32) + 40), v14, v15);
    objc_msgSend__startUpdatesFromRecord_handler_(*(void **)(a1 + 32), v17, (uint64_t)v16, v13);
  }
}

void sub_1904D98B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904D9994(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  sub_1902C3F54(&__p, "kCLConnectionMessageExerciseMinuteUpdate");
  CLConnectionClient::setHandlerForMessage();
  if (v12 < 0) {
    operator delete(__p);
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v3 + 32) && *(void *)(v3 + 48))
  {
    uint64_t v8 = @"kCLConnectionMessageSubscribeKey";
    uint64_t v9 = MEMORY[0x1E4F1CC28];
    uint64_t v7 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v2, (uint64_t)&v9, &v8, 1);
    sub_190445684("kCLConnectionMessageExerciseMinuteUpdate", &v7, &__p);
    uint64_t v6 = v11;
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v6) {
      sub_1902D8B58(v6);
    }

    *(void *)(*(void *)(a1 + 32) + 48) = 0;
    *(void *)(*(void *)(a1 + 32) + 40) = 0;
    *(unsigned char *)(*(void *)(a1 + 32) + 32) = 0;
    if (v11) {
      sub_1902D8B58(v11);
    }
  }
  else
  {
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD3DE0);
    }
    uint64_t v4 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEFAULT, "ExerciseMinute, Error stopping updates, no active clients.", (uint8_t *)&__p, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD3DE0);
      }
      LOWORD(v7) = 0;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMExerciseMinuteInternal _stopUpdates]_block_invoke", "CoreLocation: %s\n", v5);
      if (v5 != (char *)&__p) {
        free(v5);
      }
    }
  }
}

void sub_1904D9C30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, std::__shared_weak_count *a18, int a19, __int16 a20,char a21,char a22)
{
  if (a12) {
    sub_1902D8B58(a12);
  }
  if (a18) {
    sub_1902D8B58(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904D9CF0(uint64_t a1)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 8) && *(void *)(a1 + 40))
  {

    *(void *)(*(void *)(a1 + 32) + 48) = 0;
    *(void *)(*(void *)(a1 + 32) + 48) = *(id *)(a1 + 40);
    sub_1902C3F54(&__p, "kCLConnectionMessageExerciseMinuteUpdate");
    v5[1] = MEMORY[0x1E4F143A8];
    void v5[2] = 3221225472;
    float v5[3] = sub_1904D9EE8;
    v5[4] = &unk_1E568D558;
    _OWORD v5[5] = *(void *)(a1 + 32);
    CLConnectionClient::setHandlerForMessage();
    if (v8 < 0) {
      operator delete(__p);
    }
    uint64_t v9 = @"kCLConnectionMessageSubscribeKey";
    v10[0] = MEMORY[0x1E4F1CC38];
    v5[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v3, (uint64_t)v10, &v9, 1);
    sub_190445684("kCLConnectionMessageExerciseMinuteUpdate", v5, &__p);
    uint64_t v4 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v4) {
      sub_1902D8B58(v4);
    }
    *(unsigned char *)(*(void *)(a1 + 32) + 32) = 1;
    if (v7) {
      sub_1902D8B58(v7);
    }
  }
}

void sub_1904D9EA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a19) {
    sub_1902D8B58(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904D9EE8(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void **)(*(void *)(a1 + 32) + 48);
  if (v4)
  {
    id v6 = (id)objc_msgSend_copy(v4, a2, a3);
    uint64_t v7 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v8 = objc_opt_class();
    uint64_t v9 = objc_opt_class();
    uint64_t v10 = objc_opt_class();
    uint64_t v11 = objc_opt_class();
    uint64_t v13 = (NSSet *)objc_msgSend_setWithObjects_(v7, v12, v8, v9, v10, v11, 0);
    if (*(void *)a2
      && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v13)) != 0)
    {
      id v16 = DictionaryOfClasses;
      uint64_t v17 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v15, @"CMErrorMessage");
      uint64_t v19 = objc_msgSend_objectForKeyedSubscript_(v16, v18, @"CMExerciseMinuteDataArray");
      if (v17)
      {
        *(unsigned char *)(*(void *)(a1 + 32) + 32) = 0;
        uint64_t v20 = *(NSObject **)(*(void *)(a1 + 32) + 24);
        v30[0] = MEMORY[0x1E4F143A8];
        v30[1] = 3221225472;
        v30[2] = sub_1904DA338;
        v30[3] = &unk_1E568D320;
        v30[4] = v17;
        v30[5] = v6;
        __int16 v21 = v30;
      }
      else
      {
        pid_t v22 = (void *)v19;
        if (v19)
        {

          *(void *)(*(void *)(a1 + 32) + 40) = 0;
          *(void *)(*(void *)(a1 + 32) + 40) = (id)objc_msgSend_lastObject(v22, v23, v24);
          uint64_t v20 = *(NSObject **)(*(void *)(a1 + 32) + 24);
          v29[0] = MEMORY[0x1E4F143A8];
          v29[1] = 3221225472;
          v29[2] = sub_1904DA3B0;
          v29[3] = &unk_1E568D320;
          v29[4] = v22;
          v29[5] = v6;
          __int16 v21 = v29;
        }
        else
        {
          if (qword_1EB3BE898 != -1) {
            dispatch_once(&qword_1EB3BE898, &unk_1EDFD3DE0);
          }
          __int16 v25 = off_1EB3BE890;
          if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)float32x4_t buf = 0;
            _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_FAULT, "ExerciseMinute, Unable to parse update.", buf, 2u);
          }
          if (sub_1902D8400(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EB3BE898 != -1) {
              dispatch_once(&qword_1EB3BE898, &unk_1EDFD3DE0);
            }
            __int16 v28 = 0;
            uint64_t v26 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 0, "-[CMExerciseMinuteInternal _startUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v26);
            if (v26 != (char *)buf) {
              free(v26);
            }
          }
          uint64_t v20 = *(NSObject **)(*(void *)(a1 + 32) + 24);
          v27[0] = MEMORY[0x1E4F143A8];
          v27[1] = 3221225472;
          v27[2] = sub_1904DA3C8;
          v27[3] = &unk_1E568D2D0;
          float v27[4] = v6;
          __int16 v21 = v27;
        }
      }
    }
    else
    {
      uint64_t v20 = *(NSObject **)(*(void *)(a1 + 32) + 24);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = sub_1904DA2D4;
      block[3] = &unk_1E568D2D0;
      void block[4] = v6;
      __int16 v21 = block;
    }
    dispatch_async(v20, v21);
  }
}

uint64_t sub_1904DA2D4(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_1904DA338(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

uint64_t sub_1904DA3B0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1904DA3C8(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

void sub_1904DA4A4(uint64_t a1, const char *a2, uint64_t a3)
{
  v32[1] = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(a1 + 32) + 8) && *(void *)(a1 + 48))
  {
    uint64_t v4 = *(void **)(a1 + 40);
    if (v4)
    {
      v29[0] = @"CMExerciseMinuteRecordId";
      int v5 = NSNumber;
      uint64_t v6 = objc_msgSend_recordId(v4, a2, a3);
      v30[0] = objc_msgSend_numberWithInteger_(v5, v7, v6);
      v29[1] = @"CMExerciseMinuteStartDate";
      uint64_t v8 = NSNumber;
      uint64_t started = objc_msgSend_startDate(*(void **)(a1 + 40), v9, v10);
      objc_msgSend_timeIntervalSinceReferenceDate(started, v12, v13);
      v30[1] = objc_msgSend_numberWithDouble_(v8, v14, v15);
      v29[2] = @"CMExerciseMinuteSourceId";
      if (objc_msgSend_sourceId(*(void **)(a1 + 40), v16, v17)) {
        uint64_t v20 = objc_msgSend_sourceId(*(void **)(a1 + 40), v18, v19);
      }
      else {
        uint64_t v20 = objc_msgSend_UUID(MEMORY[0x1E4F29128], v18, v19);
      }
      v30[2] = objc_msgSend_UUIDString(v20, v21, v22);
      uint64_t v23 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v24, (uint64_t)v30, v29, 3);
    }
    else
    {
      long long v31 = @"CMExerciseMinuteRecordId";
      v32[0] = &unk_1EE001C78;
      uint64_t v23 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], a2, (uint64_t)v32, &v31, 1);
    }
    uint64_t v28 = v23;
    sub_19044262C("kCLConnectionMessageExerciseMinuteQuery", &v28, &v26);
    __int16 v25 = v27;
    if (v27) {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v25) {
      sub_1902D8B58(v25);
    }
    if (v27) {
      sub_1902D8B58(v27);
    }
  }
}

void sub_1904DA6A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a17) {
    sub_1902D8B58(a17);
  }
  if (a19) {
    sub_1902D8B58(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904DA6D0(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v5 = (id)objc_msgSend_copy(*(void **)(a1 + 40), a2, a3);
  uint64_t v6 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  char v12 = (NSSet *)objc_msgSend_setWithObjects_(v6, v11, v7, v8, v9, v10, 0);
  if (*(void *)a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v12)) != 0)
  {
    uint64_t v15 = DictionaryOfClasses;
    uint64_t v16 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v14, @"CMErrorMessage");
    uint64_t v18 = objc_msgSend_objectForKeyedSubscript_(v15, v17, @"CMExerciseMinuteDataArray");
    if (v16)
    {
      uint64_t v19 = *(NSObject **)(*(void *)(a1 + 32) + 24);
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 3221225472;
      v27[2] = sub_1904DAAE8;
      v27[3] = &unk_1E568D320;
      float v27[4] = v16;
      void v27[5] = v5;
      uint64_t v20 = v27;
    }
    else if (v18)
    {
      __int16 v21 = *(NSObject **)(*(void *)(a1 + 32) + 24);
      v26[0] = MEMORY[0x1E4F143A8];
      v26[1] = 3221225472;
      v26[2] = sub_1904DAB60;
      v26[3] = &unk_1E568D320;
      v26[4] = v18;
      void v26[5] = v5;
      uint64_t v20 = v26;
      uint64_t v19 = v21;
    }
    else
    {
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD3DE0);
      }
      uint64_t v22 = off_1EB3BE890;
      if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)float32x4_t buf = 0;
        _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_FAULT, "ExerciseMinute, Unable to parse query.", buf, 2u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE898 != -1) {
          dispatch_once(&qword_1EB3BE898, &unk_1EDFD3DE0);
        }
        __int16 v25 = 0;
        uint64_t v23 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "-[CMExerciseMinuteInternal _queryExerciseMinutesFromRecord:handler:]_block_invoke", "CoreLocation: %s\n", v23);
        if (v23 != (char *)buf) {
          free(v23);
        }
      }
      uint64_t v19 = *(NSObject **)(*(void *)(a1 + 32) + 24);
      v24[0] = MEMORY[0x1E4F143A8];
      v24[1] = 3221225472;
      v24[2] = sub_1904DAB78;
      v24[3] = &unk_1E568D2D0;
      v24[4] = v5;
      uint64_t v20 = v24;
    }
  }
  else
  {
    uint64_t v19 = *(NSObject **)(*(void *)(a1 + 32) + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_1904DAA84;
    block[3] = &unk_1E568D2D0;
    void block[4] = v5;
    uint64_t v20 = block;
  }
  dispatch_async(v19, v20);
}

uint64_t sub_1904DAA84(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_1904DAAE8(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

uint64_t sub_1904DAB60(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1904DAB78(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_1904DACDC(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__teardown(*(void **)(*(void *)(a1 + 32) + 8), a2, a3);
}

uint64_t sub_1904DAE18(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);

  return objc_msgSend__startUpdatesFromRecord_handler_(v4, v5, v6, v7);
}

uint64_t sub_1904DAECC(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3);

  return MEMORY[0x1F4181798](v3, sel__stopUpdates, v4);
}

uint64_t sub_1904DAFC8(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3);
  uint64_t v6 = *(void *)(a1 + 40);

  return objc_msgSend__startUpdatesWithHandler_(v4, v5, v6);
}

uint64_t sub_1904DB0EC(uint64_t a1, const char *a2)
{
  uint64_t result = objc_msgSend_isAuthorizedForEntitlement_(CMMotionUtils, a2, @"com.apple.locationd.activity");
  qword_1EB3BF270 = result;
  return result;
}

uint64_t sub_1904DB124()
{
  if (qword_1EB3BF288 != -1) {
    dispatch_once(&qword_1EB3BF288, &unk_1EDFD1B60);
  }
  return qword_1EB3BF280;
}

uint64_t sub_1904DB168()
{
  uint64_t result = sub_1902BB1DC();
  if (result) {
    operator new();
  }
  return result;
}

void sub_1904DB250(_Unwind_Exception *a1)
{
  if (v2) {
    sub_1902D8B58(v2);
  }
  uint64_t v4 = (std::__shared_weak_count *)v1[11];
  if (v4) {
    sub_1902D8B58(v4);
  }
  sub_1904DC240(v1);
  MEMORY[0x192FCC980](v1, 0x10F1C40A45ED163);
  _Unwind_Resume(a1);
}

void *sub_1904DB2A4(void *a1)
{
  *a1 = &unk_1EDFC8228;
  uint64_t v5 = 0;
  sub_1904DB328((uint64_t)a1, (double *)&v5);
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  a1[10] = 0;
  a1[11] = 0;
  if (v2)
  {
    sub_1902D8B58(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[11];
    if (v3) {
      sub_1902D8B58(v3);
    }
  }

  return sub_1904DC240(a1);
}

uint64_t sub_1904DB328(uint64_t a1, double *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1902BB1DC();
  if (result)
  {
    if (!*(void *)(a1 + 80))
    {
      uint64_t v5 = (void *)sub_1902DF4A8();
      uint64_t v32 = 0xA0000FF00;
      char v33 = 0;
      sub_19043791C(v5, (uint64_t)&v32, (uint64_t *)buf);
      long long v8 = *(_OWORD *)buf;
      memset(buf, 0, sizeof(buf));
      uint64_t v9 = *(std::__shared_weak_count **)(a1 + 88);
      *(_OWORD *)(a1 + 80) = v8;
      if (v9)
      {
        sub_1902D8B58(v9);
        if (*(void *)&buf[8]) {
          sub_1902D8B58(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      uint64_t v10 = objc_msgSend_mutableCopy(&unk_1EE001A70, v6, v7);
      unsigned int v31 = 0;
      uint64_t v11 = sub_1902D6BD0();
      uint64_t v12 = *(void *)(v11 + 24);
      uint64_t v13 = *(std::__shared_weak_count **)(v11 + 32);
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v14 = sub_19045E8CC(v12, "MagLocationID", &v31);
      uint64_t v16 = v31;
      if (v31) {
        int v17 = 1;
      }
      else {
        int v17 = v14;
      }
      if (v13) {
        sub_1902D8B58(v13);
      }
      if (v17)
      {
        uint64_t v18 = objc_msgSend_numberWithUnsignedInt_(NSNumber, v15, v16);
        objc_msgSend_setObject_forKey_(v10, v19, v18, @"LocationID");
        if (qword_1EB3BE848 != -1) {
          dispatch_once(&qword_1EB3BE848, &unk_1EDFD3520);
        }
        uint64_t v20 = qword_1EB3BE840;
        if (os_log_type_enabled((os_log_t)qword_1EB3BE840, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)float32x4_t buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v16;
          _os_log_impl(&dword_1902AF000, v20, OS_LOG_TYPE_DEFAULT, "Setting Mag matching properties with IMULocationID %d", buf, 8u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE848 != -1) {
            dispatch_once(&qword_1EB3BE848, &unk_1EDFD3520);
          }
          int v34 = 67109120;
          LODWORD(v35) = v16;
          uint64_t v30 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "BOOL CLMagnetometer::setMagnetometerInterval(const CFTimeInterval &)", "CoreLocation: %s\n", v30);
          if (v30 != (char *)buf) {
            free(v30);
          }
        }
      }
      sub_1905D661C(*(void **)(a1 + 80), v10);
      sub_1902CD864(*(void *)(a1 + 80), (uint64_t)sub_1904DB864, a1);
    }
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD37E0);
    }
    __int16 v21 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_INFO))
    {
      double v22 = *a2;
      *(_DWORD *)float32x4_t buf = 134349056;
      *(double *)&uint8_t buf[4] = v22;
      _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_INFO, "Setting magnetometer update and batch interval to %{public}f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD37E0);
      }
      uint64_t v28 = *(void *)a2;
      int v34 = 134349056;
      uint64_t v35 = v28;
      uint64_t v29 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CLMagnetometer::setMagnetometerInterval(const CFTimeInterval &)", "CoreLocation: %s\n", v29);
      if (v29 != (char *)buf) {
        free(v29);
      }
    }
    uint64_t v25 = *(void *)(a1 + 80);
    uint64_t v24 = (uint64_t *)(a1 + 80);
    uint64_t v23 = v25;
    double v26 = rint(*a2 * 1000000.0);
    if (*a2 < 0.0) {
      uint64_t v27 = 0;
    }
    else {
      uint64_t v27 = (uint64_t)v26;
    }
    sub_1902CDC50(v23, v27);
    return sub_1902CDBA4(*v24, *a2);
  }
  return result;
}

void sub_1904DB76C(_Unwind_Exception *exception_object)
{
}

void sub_1904DB7A4(void *a1)
{
  sub_1904DB2A4(a1);

  JUMPOUT(0x192FCC980);
}

BOOL sub_1904DB7DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  if (v1)
  {
    id v3 = objc_alloc(NSNumber);
    uint64_t v5 = objc_msgSend_initWithBool_(v3, v4, 1);
    (*(void (**)(void, __CFString *, void *))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), @"IOHIDCompasssResetDAC", v5);
  }
  return v1 != 0;
}

uint64_t sub_1904DB864(uint64_t a1)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t result = IOHIDEventGetType();
  if (result == 21)
  {
    IOHIDEventGetFloatValue();
    float v4 = v3;
    IOHIDEventGetFloatValue();
    float v6 = v5;
    IOHIDEventGetFloatValue();
    float v8 = v7;
    unint64_t TimeStamp = IOHIDEventGetTimeStamp();
    double v10 = sub_1902D8D34(TimeStamp);
    if (v10 > *(double *)(a1 + 64) + 1.0)
    {
      uint64_t v11 = (void *)(*(uint64_t (**)(void, __CFString *))(**(void **)(a1 + 80) + 24))(*(void *)(a1 + 80), @"AppleVoltageDictionary");
      uint64_t v13 = objc_msgSend_objectForKeyedSubscript_(v11, v12, @"COMPASS_TEMP");
      objc_msgSend_floatValue(v13, v14, v15);
      *(float *)(a1 + 72) = v16 / 100.0;
      *(double *)(a1 + 64) = v10;
    }
    double v28 = v10;
    float v17 = v6 - *(float *)(a1 + 52);
    float v29 = v4 - *(float *)(a1 + 48);
    float v30 = v17;
    int v18 = *(_DWORD *)(a1 + 72);
    float v31 = v8 - *(float *)(a1 + 56);
    int v32 = v18;
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD37E0);
    }
    uint64_t v19 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)float32x4_t buf = 136316162;
      int v34 = "Magnetometer";
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v6;
      __int16 v39 = 2048;
      double v40 = v8;
      __int16 v41 = 2048;
      double v42 = v10;
      _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_DEBUG, "Type,%s,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f", buf, 0x34u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD37E0);
      }
      *(_DWORD *)unint64_t v46 = 136316162;
      *(void *)&v46[4] = "Magnetometer";
      *(_WORD *)&v46[12] = 2048;
      *(double *)&v46[14] = v4;
      __int16 v47 = 2048;
      double v48 = v6;
      *(_WORD *)double v49 = 2048;
      *(double *)&v49[2] = v8;
      *(_WORD *)&v49[10] = 2048;
      double v50 = v10;
      uint64_t v27 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLMagnetometer::onMagnetometerData(const CLMotionTypeMagneticField &, const CLMotionTypeTimestamp &)", "CoreLocation: %s\n", v27);
      if (v27 != (char *)buf) {
        free(v27);
      }
    }
    if (*(unsigned char *)(a1 + 32))
    {
      *(void *)unint64_t v46 = &unk_1EDFCA6D8;
      *(void *)&v46[8] = CFAbsoluteTimeGetCurrent();
      double v48 = v10;
      *(float *)double v49 = v4;
      *(float *)&v49[4] = v6;
      *(float *)&v49[8] = v8;
      uint64_t v20 = sub_190570220();
      sub_190571738(v20, (uint64_t)v46);
      sub_190395088(buf);
      sub_1903AE5B0((uint64_t)buf);
      v45 |= 1u;
      uint64_t v43 = *(void *)&v46[8];
      uint64_t v21 = v44;
      *(unsigned char *)(v44 + 36) |= 1u;
      *(double *)(v21 + 8) = v10;
      uint64_t v22 = v44;
      *(unsigned char *)(v44 + 36) |= 8u;
      *(float *)(v22 + 24) = v4;
      uint64_t v23 = v44;
      *(unsigned char *)(v44 + 36) |= 0x10u;
      *(float *)(v23 + 28) = v6;
      uint64_t v24 = v44;
      *(unsigned char *)(v44 + 36) |= 0x20u;
      *(float *)(v24 + 32) = v8;
      uint64_t v25 = v44;
      int v26 = *(_DWORD *)(a1 + 72);
      *(unsigned char *)(v44 + 36) |= 4u;
      *(_DWORD *)(v25 + 20) = v26;
      sub_19039A590((PB::Base *)buf);
    }
    return sub_1902D8BCC(a1, 0, (uint64_t)&v28, 24);
  }
  return result;
}

void sub_1904DBC7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_19039A590((PB::Base *)va);
  _Unwind_Resume(a1);
}

double sub_1904DBC98(uint64_t a1, int a2, double *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD37E0);
    }
    float v4 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)float32x4_t buf = 67240192;
      int v13 = a2;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "Unrecognized magnetometer notification %{public}d", buf, 8u);
    }
    double v5 = 0.0;
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD37E0);
      }
      float v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual CFTimeInterval CLMagnetometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    sub_1904DB328(a1, a3);
    if (*a3 > 0.0 && !*(void *)(a1 + 40))
    {
      *(void *)(a1 + 48) = 0;
      *(_DWORD *)(a1 + 56) = 0;
      operator new();
    }
    if (*a3 <= 0.0 && *(void *)(a1 + 40))
    {
      uint64_t v9 = sub_190557F14();
      sub_1902CDE08(v9, 0, *(void *)(a1 + 40));
      uint64_t v10 = *(void *)(a1 + 40);
      if (v10) {
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      }
      *(void *)(a1 + 40) = 0;
    }
    return *a3;
  }
  return v5;
}

void sub_1904DBF5C(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void sub_1904DBF88(float *a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D7B8 != -1) {
    dispatch_once(&qword_1E929D7B8, &unk_1EDFD37E0);
  }
  float v4 = qword_1E929D7B0;
  if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_INFO))
  {
    double v5 = *a1;
    double v6 = a1[1];
    double v7 = a1[2];
    *(_DWORD *)float32x4_t buf = 134218496;
    double v11 = v5;
    __int16 v12 = 2048;
    double v13 = v6;
    __int16 v14 = 2048;
    double v15 = v7;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "Received magnetometer offset (%f, %f, %f)", buf, 0x20u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD37E0);
    }
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "static void CLMagnetometer::onOffset(const CLMotionTypeMagneticField *, void *)", "CoreLocation: %s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  uint64_t v8 = *(void *)a1;
  *(float *)(a2 + 56) = a1[2];
  *(void *)(a2 + 48) = v8;
}

os_log_t sub_1904DC198()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accel");
  qword_1EB3BE840 = (uint64_t)result;
  return result;
}

os_log_t sub_1904DC1C8()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Sensors");
  qword_1E929D7B0 = (uint64_t)result;
  return result;
}

void sub_1904DC1FC(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904DC234(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void *sub_1904DC240(void *a1)
{
  *a1 = &unk_1EDFC8E50;
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 80 * v3;
      do
      {
        sub_1904DCBD4((void *)(v2 + v4 - 24));
        sub_1904B9BBC(v2 + v4 - 48, *(void **)(v2 + v4 - 40));
        v4 -= 80;
      }
      while (v4);
    }
    MEMORY[0x192FCC960](v2 - 16, 0x1020C80BCAB735ELL);
  }
  return a1;
}

void sub_1904DC2E8(void *a1)
{
  sub_1904DC240(a1);

  JUMPOUT(0x192FCC980);
}

void sub_1904DC320(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_1902D6BD0();
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  void v9[2] = sub_1904DC3B8;
  v9[3] = &unk_1E568E338;
  int v10 = a2;
  v9[4] = a1;
  v9[5] = a3;
  v9[6] = a4;
  sub_1902CDE98(v8, (uint64_t)v9);
}

void sub_1904DC3B8(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(unsigned int *)(a1 + 56);
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(double **)(a1 + 48);
  unsigned int v5 = (*(uint64_t (**)(unint64_t))(*(void *)v3 + 24))(v3);
  uint64_t v6 = v2[2];
  uint64_t v7 = v6 + 80 * (int)v1;
  int v10 = *(void **)(v7 + 40);
  uint64_t v8 = (double *)(v7 + 40);
  uint64_t v9 = v10;
  if (!v10) {
    goto LABEL_12;
  }
  double v11 = *v4;
  __int16 v12 = v8;
  do
  {
    unint64_t v13 = v9[4];
    BOOL v14 = v13 >= v3;
    if (v13 >= v3) {
      double v15 = v9;
    }
    else {
      double v15 = v9 + 1;
    }
    if (v14) {
      __int16 v12 = (double *)v9;
    }
    uint64_t v9 = (void *)*v15;
  }
  while (*v15);
  if (v12 != v8 && *((void *)v12 + 4) <= v3)
  {
    v12[6] = v11;
    v12[7] = v11 * (double)v5;
    if (*(double *)(v6 + 80 * (int)v1 + 16) <= 0.0)
    {
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD1B80);
      }
      float v17 = off_1EB3BE890;
      if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_FAULT))
      {
        uint64_t v18 = *((void *)v12 + 6);
        uint64_t v19 = *(void *)(v2[2] + 80 * (int)v1 + 16);
        *(_DWORD *)float32x4_t buf = 134218240;
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v19;
        _os_log_impl(&dword_1902AF000, v17, OS_LOG_TYPE_FAULT, "CLMotionNotifier::setUpdateIntervalPrivate RequestedUpdateInterval:%f, UpdateInterval:%f", buf, 0x16u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE898 != -1) {
          dispatch_once(&qword_1EB3BE898, &unk_1EDFD1B80);
        }
        uint64_t v28 = *((void *)v12 + 6);
        uint64_t v29 = *(void *)(v2[2] + 80 * (int)v1 + 16);
        *(_DWORD *)float v31 = 134218240;
        *(void *)&v31[4] = v28;
        *(_WORD *)&v31[12] = 2048;
        *(void *)&v31[14] = v29;
        float v30 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "void CLMotionNotifier::setUpdateIntervalPrivate(int, Dispatcher *, const CFTimeInterval &)", "CoreLocation: %s\n", v30);
        if (v30 != buf) {
          free(v30);
        }
      }
    }
    uint64_t v20 = v2[2];
    uint64_t v21 = (double *)(v20 + 80 * (int)v1);
    *((_DWORD *)v12 + 11) = llround(v12[6] / v21[2]);
    double v22 = sub_1902CE5D4(v20, v1);
    *(double *)float32x4_t buf = v22;
    if (v22 != *v21)
    {
      *uint64_t v21 = v22;
      *(double *)(v2[2] + 80 * (int)v1 + 16) = (*(double (**)(void *, uint64_t, unsigned char *))(*v2 + 16))(v2, v1, buf);
      sub_1902CE6F4((uint64_t)v2, v1);
      uint64_t v20 = v2[2];
    }
    double v23 = sub_1902CE664(v20, v1);
    *(double *)float v31 = v23;
    uint64_t v24 = v20 + 80 * (int)v1;
    double v26 = *(double *)(v24 + 8);
    uint64_t v25 = (double *)(v24 + 8);
    if (v23 != v26)
    {
      *uint64_t v25 = v23;
      *(double *)(v2[2] + 80 * (int)v1 + 24) = (*(double (**)(void *, uint64_t, unsigned char *))(*v2 + 24))(v2, v1, v31);
    }
  }
  else
  {
LABEL_12:
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD1B80);
    }
    uint64_t v16 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)float32x4_t buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v1;
      *(_WORD *)&uint8_t buf[8] = 2048;
      *(void *)&unsigned char buf[10] = v3;
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_FAULT, "Unknown (notification,dispatcher) pair: (%d, %p)", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD1B80);
      }
      *(_DWORD *)float v31 = 67109376;
      *(_DWORD *)&v31[4] = v1;
      *(_WORD *)&v31[8] = 2048;
      *(void *)&v31[10] = v3;
      uint64_t v27 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CLMotionNotifier::setUpdateIntervalPrivate(int, Dispatcher *, const CFTimeInterval &)", "CoreLocation: %s\n", v27);
      if (v27 != buf) {
        free(v27);
      }
    }
  }
}

uint64_t sub_1904DC8A8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *(void *)(result + 16);
  int v9 = a2;
  uint64_t v10 = v8 + 80 * (int)a2;
  double v11 = *(void **)(v10 + 32);
  if (v11 != (void *)(v10 + 40))
  {
    do
    {
      os_log_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)v11[4] + 16))(v11[4], a2, a3, a4);
      *((_DWORD *)v11 + 10) = (*((_DWORD *)v11 + 10) + 1) % *((_DWORD *)v11 + 11);
      __int16 v12 = (void *)v11[1];
      if (v12)
      {
        do
        {
          unint64_t v13 = v12;
          __int16 v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unint64_t v13 = (void *)v11[2];
          BOOL v14 = *v13 == (void)v11;
          double v11 = v13;
        }
        while (!v14);
      }
      uint64_t v8 = *(void *)(v7 + 16);
      double v11 = v13;
    }
    while (v13 != (void *)(v8 + 80 * v9 + 40));
  }
  uint64_t v15 = v8 + 80 * v9;
  uint64_t v16 = *(void *)(v15 + 64);
  if (v16 != v15 + 56)
  {
    do
    {
      os_log_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v16 + 16) + 16))(*(void *)(v16 + 16), a2, a3, a4);
      uint64_t v16 = *(void *)(v16 + 8);
    }
    while (v16 != *(void *)(v7 + 16) + 80 * v9 + 56);
  }
  return result;
}

uint64_t sub_1904DCA04(uint64_t a1, int a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 24) > a2) {
    return *(void *)(*(void *)(a1 + 16) + 80 * a2 + 72);
  }
  if (qword_1EB3BE898 != -1) {
    dispatch_once(&qword_1EB3BE898, &unk_1EDFD1B80);
  }
  uint64_t v4 = off_1EB3BE890;
  if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)float32x4_t buf = 67109120;
    int v7 = a2;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "Unknown notification %d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD1B80);
    }
    unsigned int v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "ssize_t CLMotionNotifier::numberOfSpectators(int)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  return -1;
}

void *sub_1904DCBD4(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    os_log_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        os_log_t result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

uint64_t sub_1904DE71C()
{
  if (qword_1EB3BF298 != -1) {
    dispatch_once(&qword_1EB3BF298, &unk_1EDFD1BC0);
  }
  return qword_1EB3BF290;
}

void sub_1904DEBE8()
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BF298 != -1) {
    dispatch_once(&qword_1EB3BF298, &unk_1EDFD1BC0);
  }
  uint64_t v0 = qword_1EB3BF290;
  int v1 = sub_1904DF584();
  uint64_t v2 = (const char *)sub_1904DF274();
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFD2F80);
  }
  uint64_t v3 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)float32x4_t buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v1;
    LOWORD(v16) = 1024;
    *(_DWORD *)((char *)&v16 + 2) = v2;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "KeyboardMotion preferences changed,dataCollection,%d,accelStreaming,%d", buf, 0xEu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFD2F80);
    }
    int v11 = 67109376;
    BOOL v12 = v1;
    __int16 v13 = 1024;
    int v14 = (int)v2;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLKeyboardMotionNotifier::dataCollectionSettingsChanged()", "CoreLocation: %s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  sub_1904DF1F4(v0, v2);
  if (*(unsigned __int8 *)(v0 + 89) != v1)
  {
    buf[0] = -60;
    buf[1] = v1;
    if (objc_msgSend_setReport_payload_length_(*(void **)(v0 + 40), v4, 196, buf, 2)) {
      *(unsigned char *)(v0 + 89) = v1;
    }
  }
  if (*(unsigned __int8 *)(v0 + 90) != v2)
  {
    buf[0] = 105;
    buf[1] = v2;
    if (objc_msgSend_setReport_payload_length_(*(void **)(v0 + 48), v4, 105, buf, 2)) {
      *(unsigned char *)(v0 + 90) = (_BYTE)v2;
    }
  }
  BOOL v10 = 0;
  sub_19046FADC(buf);
  int v5 = sub_1902C47F8(*(uint64_t *)buf, "MotionLoggerLogKeyboardMotion", &v10);
  if (v16) {
    sub_1902D8B58(v16);
  }
  if (v5)
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFD2F80);
    }
    uint64_t v6 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float32x4_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v10;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "KeyboardMotion,Msl Logging,%d", buf, 8u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFD2F80);
      }
      int v11 = 67109120;
      BOOL v12 = v10;
      int v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLKeyboardMotionNotifier::dataCollectionSettingsChanged()", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    sub_19046FADC(buf);
    sub_190461598(*(uint64_t *)buf, "MslLogger.Enable", &v10);
    if (v16) {
      sub_1902D8B58(v16);
    }
    sub_19046FADC(buf);
    if (v10) {
      int v7 = 15;
    }
    else {
      int v7 = 255;
    }
    int v11 = v7;
    sub_190462484(*(uint64_t *)buf, "MslLogger.FlushTimeout", &v11);
    if (v16) {
      sub_1902D8B58(v16);
    }
  }
}

void sub_1904DF04C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1902D8B58(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904DF074()
{
  sub_1902BAD40();
  uint64_t result = sub_19046BCE8();
  if (result) {
    operator new();
  }
  return result;
}

void sub_1904DF1C0(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10F1C406BBC6232);
  _Unwind_Resume(a1);
}

uint64_t sub_1904DF1F4(uint64_t result, const char *a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    if (!*(void *)(result + 40))
    {
      uint64_t result = objc_msgSend_registerForDeviceMatching_(*(void **)(result + 32), a2, (uint64_t)&unk_1EE001B60);
      *(void *)(v2 + 40) = result;
    }
  }
  else
  {
    uint64_t result = sub_1904DCA04(result, 1);
    if (!result)
    {
      uint64_t result = sub_1904DCA04(v2, 2);
      if (!result)
      {
        uint64_t result = sub_1904DCA04(v2, 4);
        if (!result)
        {
          uint64_t result = objc_msgSend_unregisterForDeviceMatching_(*(void **)(v2 + 32), v3, *(void *)(v2 + 40));
          *(void *)(v2 + 40) = 0;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1904DF274()
{
  BOOL v4 = 0;
  sub_19046FADC(&v2);
  unsigned int v0 = sub_1902C47F8(v2, "EnableKeyboardMotionAccelStream", &v4);
  if (v3) {
    sub_1902D8B58(v3);
  }
  if (v4) {
    return v0;
  }
  else {
    return 0;
  }
}

void sub_1904DF2D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1904DF2F0(id *a1)
{
  *a1 = &unk_1EDFC9820;
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(DarwinNotifyCenter, a1, @"com.apple.locationd.KeyboardMotion.DataCollectionMode", 0);

  objc_msgSend_invalidate(a1[10], v3, v4);

  return sub_1904DC240(a1);
}

void sub_1904DF390(id *a1)
{
  sub_1904DF2F0(a1);

  JUMPOUT(0x192FCC980);
}

void sub_1904DF3C8(uint64_t a1, const char *a2, uint64_t a3)
{
  switch((int)a2)
  {
    case 0:
      if (a3)
      {
        if (!*(void *)(a1 + 48)) {
          *(void *)(a1 + 48) = objc_msgSend_registerForDeviceMatching_(*(void **)(a1 + 32), a2, (uint64_t)&unk_1EE001A98);
        }
      }
      else
      {
        objc_msgSend_unregisterForDeviceMatching_(*(void **)(a1 + 32), a2, *(void *)(a1 + 48));

        *(void *)(a1 + 48) = 0;
      }
      break;
    case 1:
    case 4:
      sub_1904DF1F4(a1, (const char *)(a3 != 0));
      break;
    case 2:
      sub_1904DF1F4(a1, (const char *)(a3 != 0));
      if (a3)
      {
        uint64_t v5 = mach_absolute_time();
        sub_1902D8D34(v5);
        sub_1902D8BCC(a1, 2, a1 + 91, 1);
      }
      break;
    case 3:
      uint64_t v6 = *(void *)(a1 + 64);
      if (a3)
      {
        if (!v6)
        {
          int v7 = [CLHidEventMonitorManager alloc];
          uint64_t v8 = *(void *)(a1 + 56);
          dispatch_queue_global_t global_queue = dispatch_get_global_queue(0, 0);
          uint64_t v11 = objc_msgSend_initWithDelegate_queue_matching_(v7, v10, v8, global_queue, &unk_1EE001B38);
          *(void *)(a1 + 64) = v11;
          MEMORY[0x1F4181798](v11, sel_addSystemClientMatching_, &unk_1EE001B38);
        }
      }
      else
      {
        MEMORY[0x1F4181798](v6, sel_removeSystemClientmatching_, &unk_1EE001B38);
      }
      break;
    default:
      return;
  }
}

uint64_t sub_1904DF584()
{
  BOOL v4 = 0;
  sub_19046FADC(&v2);
  unsigned int v0 = sub_1902C47F8(v2, "EnableKeyboardMotionDataCollectionMode", &v4);
  if (v3) {
    sub_1902D8B58(v3);
  }
  if (v4) {
    return v0;
  }
  else {
    return 0;
  }
}

void sub_1904DF5E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  _Unwind_Resume(exception_object);
}

Class sub_1904DF600()
{
  if (qword_1EB3BF2A8 != -1) {
    dispatch_once(&qword_1EB3BF2A8, &unk_1EDFC36A8);
  }
  Class result = objc_getClass("SBSSmartCoverService");
  qword_1EB3BF2A0 = (uint64_t)result;
  off_1EC20D458 = sub_1904DF664;
  return result;
}

uint64_t sub_1904DF664()
{
  return qword_1EB3BF2A0;
}

void *sub_1904DF670()
{
  Class result = dlopen("/System/Library/PrivateFrameworks/SpringBoardServices.framework/SpringBoardServices", 2);
  qword_1EB3BF2B0 = (uint64_t)result;
  return result;
}

os_log_t sub_1904DF69C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1EB3BE830 = (uint64_t)result;
  return result;
}

uint64_t sub_1904DF6CC(uint64_t a1)
{
  if (qword_1EB3BF2A8 != -1) {
    dispatch_once(&qword_1EB3BF2A8, &unk_1EDFC36A8);
  }
  uint64_t v2 = (uint64_t (*)())dlsym((void *)qword_1EB3BF2B0, "NSStringFromSBSSmartCoverState");
  off_1EC20D460 = v2;

  return ((uint64_t (*)(uint64_t))v2)(a1);
}

uint64_t sub_1904DF748(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_main(MEMORY[0x1E4F73058], a2, a3);
}

uint64_t sub_1904DF754()
{
  if (qword_1EB3BF2C0 != -1) {
    dispatch_once(&qword_1EB3BF2C0, &unk_1EDFD3B20);
  }
  return qword_1EB3BF2B8;
}

uint64_t sub_1904DF798(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F73040];
  uint64_t v4 = objc_msgSend_main(MEMORY[0x1E4F73058], a2, a3);
  uint64_t result = objc_msgSend_newSharedVendorUniverseWithSilo_(v3, v5, v4);
  qword_1EB3BF2B8 = result;
  return result;
}

uint64_t sub_1904DF7DC(uint64_t a1, int a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  char v10 = 0;
  if (qword_1EB3BE930 != -1) {
    dispatch_once(&qword_1EB3BE930, &unk_1EDFD1BE0);
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = sub_1904DF8CC;
  float v5[3] = &unk_1E568E360;
  v5[4] = &v7;
  int v6 = a2;
  sub_1902CDE98(a1, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v3;
}

void sub_1904DF8B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1904DF8CC(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v8 = 0;
  uint64_t v2 = pthread_self();
  int v3 = pthread_getschedparam(v2, &v8, &v9);
  if (v3)
  {
    int v4 = v3;
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3960);
    }
    uint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)float32x4_t buf = 67240192;
      int v13 = v4;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Could not get scheduling parameters for motion thread, CFErrorRef error = %{public}d", buf, 8u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3960);
      }
      int v10 = 67240192;
      int v11 = v4;
      uint64_t v7 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "BOOL CLMotionCore::setMotionThreadPriority(int)_block_invoke", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  else
  {
    if (*(int *)(a1 + 40) >= 1) {
      v9.sched_priority = *(_DWORD *)(a1 + 40);
    }
    int v6 = pthread_self();
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = pthread_setschedparam(v6, v8, &v9) == 0;
  }
}

void sub_1904DFAD8()
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  if (qword_1EB3BE930 != -1) {
    dispatch_once(&qword_1EB3BE930, &unk_1EDFD1BE0);
  }
  if (Current != *(CFRunLoopRef *)qword_1EB3BF828)
  {
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD3A00);
    }
    uint64_t v1 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)float32x4_t buf = 68289539;
      int v5 = 0;
      __int16 v6 = 2082;
      uint64_t v7 = "";
      __int16 v8 = 2082;
      sched_param v9 = "assert";
      __int16 v10 = 2081;
      int v11 = "runningOnMotionThread";
      _os_log_impl(&dword_1902AF000, v1, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Not running on motion thread!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD3A00);
      }
    }
    uint64_t v2 = off_1EB3BE890;
    if (os_signpost_enabled((os_log_t)off_1EB3BE890))
    {
      *(_DWORD *)float32x4_t buf = 68289539;
      int v5 = 0;
      __int16 v6 = 2082;
      uint64_t v7 = "";
      __int16 v8 = 2082;
      sched_param v9 = "assert";
      __int16 v10 = 2081;
      int v11 = "runningOnMotionThread";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Not running on motion thread!", "{\"msg%{public}.0s\":\"Not running on motion thread!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD3A00);
      }
    }
    int v3 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)float32x4_t buf = 68289539;
      int v5 = 0;
      __int16 v6 = 2082;
      uint64_t v7 = "";
      __int16 v8 = 2082;
      sched_param v9 = "assert";
      __int16 v10 = 2081;
      int v11 = "runningOnMotionThread";
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Not running on motion thread!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
}

void sub_1904DFD78(int a1, uint64_t a2, CFArrayRef theArray)
{
  if (a2 == 1) {
    goto LABEL_6;
  }
  if (a2 == 128 || a2 == 32)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count <= 0) {
      __assert_rtn("wrapRunLoopWithAutoreleasePoolHandler", "CLMotionCore.mm", 218, "count > 0");
    }
    CFIndex v6 = Count - 1;
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, Count - 1);
    MEMORY[0x192FCC230](ValueAtIndex);
    CFArrayRemoveValueAtIndex(theArray, v6);
    if (a2 == 32)
    {
LABEL_6:
      __int16 v8 = (const void *)MEMORY[0x192FCC240](0);
      CFArrayAppendValue(theArray, v8);
    }
  }
}

void sub_1904DFE44()
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (qword_1EB3BE898 != -1) {
    dispatch_once(&qword_1EB3BE898, &unk_1EDFD3A00);
  }
  unsigned int v0 = off_1EB3BE890;
  if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_DEFAULT))
  {
    int v1 = *(_DWORD *)(qword_1EB3BF828 + 48);
    *(_DWORD *)float32x4_t buf = 67109120;
    int v13 = v1;
    _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_DEFAULT, "Motion thread deadlock watchdog after %d petting", buf, 8u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD3A00);
    }
    int v11 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "static void *CLMotionCore::runMotionThread(void *)_block_invoke", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
  if (MEMORY[0x1E4F49EC0])
  {
    ADClientAddValueForScalarKey();
    id v2 = [NSString alloc];
    int v5 = objc_msgSend_processInfo(MEMORY[0x1E4F28F80], v3, v4);
    uint64_t v8 = objc_msgSend_processName(v5, v6, v7);
    __int16 v10 = objc_msgSend_initWithFormat_(v2, v9, @"%@.%@", @"com.apple.CoreMotion.ThreadDeadlockCount", v8);
    ADClientAddValueForScalarKey();
  }
}

void sub_1904E0064(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904E009C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1904E00CC(uint64_t a1, uint64_t a2)
{
  if (sub_1903885B4(a2, (uint64_t)&unk_1EDFC71B0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_1904E0110()
{
  if (qword_1EB3BF2D0 != -1) {
    dispatch_once(&qword_1EB3BF2D0, &unk_1EDFD1C00);
  }
  return qword_1EB3BF2C8;
}

void sub_1904E0154()
{
}

void sub_1904E01EC(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10F1C40417077C4);
  _Unwind_Resume(a1);
}

void *sub_1904E0210(uint64_t a1, const char *a2, uint64_t a3)
{
  *(void *)a1 = &unk_1EDFC9350;
  sub_1904E02C8((io_object_t *)a1, a2, a3);
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }

  return sub_1904DC240((void *)a1);
}

void sub_1904E02C8(io_object_t *notifier, const char *a2, uint64_t a3)
{
  if (*((void *)notifier + 5))
  {
    uint64_t v4 = sub_190576BA8();
    sub_1902CDE08(v4, 1, *((void *)notifier + 5));
  }
  if (*((void *)notifier + 6))
  {
    if (qword_1E929E9F0 != -1) {
      dispatch_once(&qword_1E929E9F0, &unk_1EDFD23C0);
    }
    sub_1902CDE08(qword_1E929E9E8, 0, *((void *)notifier + 6));
  }
  uint64_t v5 = (void *)*((void *)notifier + 8);
  if (v5)
  {

    *((void *)notifier + 8) = 0;
  }
  CFIndex v6 = (void *)*((void *)notifier + 7);
  if (v6)
  {
    objc_msgSend_stopActivityUpdates(v6, a2, a3);

    *((void *)notifier + 7) = 0;
  }
  uint64_t v7 = *((void *)notifier + 9);
  if (v7)
  {
    dispatch_release(v7);
    *((void *)notifier + 9) = 0;
  }
  if (notifier[20])
  {
    IODeregisterForSystemPower(notifier + 20);
    notifier[20] = 0;
  }
  io_connect_t v8 = notifier[21];
  if (v8)
  {
    IOServiceClose(v8);
    notifier[21] = 0;
  }
  sched_param v9 = (IONotificationPort *)*((void *)notifier + 11);
  if (v9)
  {
    IONotificationPortDestroy(v9);
    *((void *)notifier + 11) = 0;
  }
}

void sub_1904E03B8(uint64_t a1, const char *a2, uint64_t a3)
{
  sub_1904E0210(a1, a2, a3);

  JUMPOUT(0x192FCC980);
}

void sub_1904E03F0(long long *a1, uint64_t a2)
{
  long long v4 = *a1;
  id v2 = *(NSObject **)(a2 + 72);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_1904E250C;
  block[3] = &unk_1E568E3E0;
  void block[4] = a2;
  dispatch_async(v2, block);
}

void sub_1904E0468(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 8);
  kdebug_trace();
  long long v4 = *(NSObject **)(a2 + 72);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = sub_1904E1FC0;
  float v5[3] = &unk_1E568E3C0;
  v5[4] = a2;
  int v6 = v3;
  dispatch_async(v4, v5);
}

uint64_t sub_1904E0504(uint64_t a1, void *a2, uint64_t a3)
{
  int v3 = *(int **)(a1 + 32);
  if (objc_msgSend_stationary(a2, (const char *)a2, a3)) {
    int v4 = 2;
  }
  else {
    int v4 = 1;
  }
  unsigned char v3[24] = v4;

  return sub_1904E0AFC(v3);
}

void sub_1904E0550(uint64_t a1, int a2, int a3, intptr_t notificationID)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a3 > -536870145)
  {
    if (a3 == -536870144)
    {
      if (qword_1E929D778 != -1) {
        dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
      }
      uint64_t v16 = qword_1E929D770;
      if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)float32x4_t buf = 0;
        _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_INFO, "received HasPoweredOn", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D778 != -1) {
          dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
        }
        LOWORD(v21[0]) = 0;
        uint64_t v20 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::onSystemPowerChanged(io_service_t, uint32_t, void *)", "CoreLocation: %s\n", v20);
        if (v20 != (char *)buf) {
          free(v20);
        }
      }
    }
    else if (a3 == -536870112)
    {
      if (qword_1E929D778 != -1) {
        dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
      }
      uint64_t v7 = qword_1E929D770;
      if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)float32x4_t buf = 0;
        _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_INFO, "received WillPowerOn", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D778 != -1) {
          dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
        }
        LOWORD(v21[0]) = 0;
        uint64_t v19 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::onSystemPowerChanged(io_service_t, uint32_t, void *)", "CoreLocation: %s\n", v19);
        if (v19 != (char *)buf) {
          free(v19);
        }
      }
      *(unsigned char *)(a1 + 120) = 1;
      objc_msgSend_stopActivityUpdates(*(void **)(a1 + 56), v8, v9);
      __int16 v10 = *(void **)(a1 + 56);
      uint64_t v11 = *(void *)(a1 + 64);
      *(void *)float32x4_t buf = MEMORY[0x1E4F143A8];
      uint64_t v23 = 3221225472;
      uint64_t v24 = sub_1904E23FC;
      uint64_t v25 = &unk_1E568E3A0;
      uint64_t v26 = a1;
      objc_msgSend_startActivityUpdatesToQueue_withHandler_(v10, v12, v11, buf);
      if ((sub_1902CD6B0() & 0x40) != 0)
      {
        if (*(unsigned char *)(a1 + 120) && !*(_DWORD *)(a1 + 100))
        {
          uint64_t v17 = sub_1902D6BD0();
          v21[0] = MEMORY[0x1E4F143A8];
          v21[1] = 3221225472;
          v21[2] = sub_1904E2448;
          _DWORD v21[3] = &unk_1E568CF68;
          v21[4] = a1;
          sub_1902CE9BC(v17, (uint64_t)v21);
        }
      }
      else
      {
        uint64_t v13 = sub_190576BA8();
        sub_1902CDE08(v13, 1, *(void *)(a1 + 40));
        uint64_t v14 = sub_190576BA8();
        sub_1902B1FEC(v14, 1, *(void *)(a1 + 40), -1.0);
      }
    }
  }
  else if (a3 == -536870288)
  {
    io_connect_t v15 = *(_DWORD *)(a1 + 84);
    IOAllowPowerChange(v15, notificationID);
  }
  else if (a3 == -536870272)
  {
    if (qword_1E929D778 != -1) {
      dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
    }
    int v6 = qword_1E929D770;
    if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)float32x4_t buf = 0;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_INFO, "received WillSleep", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D778 != -1) {
        dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
      }
      LOWORD(v21[0]) = 0;
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::onSystemPowerChanged(io_service_t, uint32_t, void *)", "CoreLocation: %s\n", v18);
      if (v18 != (char *)buf) {
        free(v18);
      }
    }
    *(unsigned char *)(a1 + 120) = 0;
    IOAllowPowerChange(*(_DWORD *)(a1 + 84), notificationID);
    *(void *)(a1 + 96) = 0;
    *(_DWORD *)(a1 + 104) = 0;
  }
}

uint64_t sub_1904E0AFC(int *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D778 != -1) {
    dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
  }
  id v2 = qword_1E929D770;
  if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = a1[24];
    if (v3 > 2) {
      int v4 = 0;
    }
    else {
      int v4 = off_1E568E420[v3];
    }
    uint64_t v5 = a1[25];
    if (v5 > 2) {
      int v6 = 0;
    }
    else {
      int v6 = off_1E568E438[v5];
    }
    uint64_t v7 = a1[26];
    if (v7 > 2) {
      io_connect_t v8 = 0;
    }
    else {
      io_connect_t v8 = off_1E568E490[v7];
    }
    *(_DWORD *)float32x4_t buf = 136315650;
    uint64_t v16 = v4;
    __int16 v17 = 2080;
    uint64_t v18 = v6;
    __int16 v19 = 2080;
    uint64_t v20 = v8;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEBUG, "Device Stationary?, %s, Orientation, %s, Proximity, %s", buf, 0x20u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D778 != -1) {
      dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
    }
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::determineState()", "CoreLocation: %s\n", v14);
    if (v14 != (char *)buf) {
      free(v14);
    }
  }
  int v9 = a1[25];
  if (a1[26] == 2)
  {
    if (v9 != 2 || a1[24] != 2)
    {
      __int16 v10 = "2 not (FaceDown and static)";
      uint64_t v11 = (uint64_t)a1;
      int v12 = 4;
      return sub_1904E0E20(v11, v12, v10);
    }
    __int16 v10 = "1 prox corroborated";
  }
  else
  {
    if (v9 != 2)
    {
      __int16 v10 = "5 not FaceDown, prox uncovered";
      uint64_t v11 = (uint64_t)a1;
      int v12 = 3;
      return sub_1904E0E20(v11, v12, v10);
    }
    if (a1[24] != 2)
    {
      __int16 v10 = "4 FaceDown only";
      uint64_t v11 = (uint64_t)a1;
      int v12 = 1;
      return sub_1904E0E20(v11, v12, v10);
    }
    __int16 v10 = "3 no prox";
  }
  uint64_t v11 = (uint64_t)a1;
  int v12 = 2;
  return sub_1904E0E20(v11, v12, v10);
}

uint64_t sub_1904E0E20(uint64_t result, int a2, char *a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (int *)(result + 32);
  if (*(_DWORD *)(result + 32) != a2)
  {
    int v6 = (int *)result;
    if (qword_1E929D778 != -1) {
      dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
    }
    uint64_t v7 = qword_1E929D770;
    if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *v3;
      if (v8 > 4) {
        int v9 = 0;
      }
      else {
        int v9 = off_1E568E450[v8];
      }
      if ((a2 - 1) > 3) {
        __int16 v10 = 0;
      }
      else {
        __int16 v10 = off_1E568E400[a2 - 1];
      }
      *(_DWORD *)float32x4_t buf = 136315650;
      double v26 = *(double *)&v9;
      __int16 v27 = 2080;
      uint64_t v28 = v10;
      __int16 v29 = 2080;
      float v30 = a3;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_DEFAULT, "Transition, From: %s, To: %s, %s", buf, 0x20u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D778 != -1) {
        dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
      }
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::transitionToState(CLPocketStateInternalType, const char *)", "CoreLocation: %s\n", v23);
      if (v23 != (char *)buf) {
        free(v23);
      }
    }
    int *v3 = a2;
    if (qword_1E929D778 != -1) {
      dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
    }
    uint64_t v11 = qword_1E929D770;
    if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = mach_absolute_time();
      double v13 = sub_1902D8D34(v12);
      uint64_t v14 = v6[24];
      if (v14 > 2) {
        io_connect_t v15 = 0;
      }
      else {
        io_connect_t v15 = off_1E568E420[v14];
      }
      uint64_t v16 = v6[25];
      if (v16 > 2) {
        __int16 v17 = 0;
      }
      else {
        __int16 v17 = off_1E568E438[v16];
      }
      uint64_t v18 = v6[26];
      if (v18 > 2) {
        __int16 v19 = 0;
      }
      else {
        __int16 v19 = off_1E568E490[v18];
      }
      uint64_t v20 = *v3;
      if (v20 > 4) {
        uint64_t v21 = 0;
      }
      else {
        uint64_t v21 = off_1E568E450[v20];
      }
      *(_DWORD *)float32x4_t buf = 134219010;
      double v26 = v13;
      __int16 v27 = 2080;
      uint64_t v28 = v15;
      __int16 v29 = 2080;
      float v30 = v17;
      __int16 v31 = 2080;
      int v32 = v19;
      __int16 v33 = 2080;
      int v34 = v21;
      _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_DEFAULT, "%f: Device Stationary?, %s, Orientation, %s, Proximity, %s, State, %s", buf, 0x34u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D778 != -1) {
        dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
      }
      uint64_t v22 = mach_absolute_time();
      sub_1902D8D34(v22);
      uint64_t v24 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::transitionToState(CLPocketStateInternalType, const char *)", "CoreLocation: %s\n", v24);
      if (v24 != (char *)buf) {
        free(v24);
      }
    }
    return sub_1904DC8A8((uint64_t)v6, 0, (uint64_t)v3, 4);
  }
  return result;
}

void sub_1904E1348(void *refcon, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    if (!*((void *)refcon + 5)) {
      operator new();
    }
    if (!*((void *)refcon + 6))
    {
      sub_1902BAD40();
      if (sub_19046BE4C()) {
        operator new();
      }
    }
    if (!*((void *)refcon + 9)) {
      *((void *)refcon + 9) = dispatch_queue_create("com.apple.CoreMotion.CLPocketStateService", 0);
    }
    if (!*((void *)refcon + 8))
    {
      int v4 = objc_opt_new();
      *((void *)refcon + 8) = v4;
      objc_msgSend_setUnderlyingQueue_(v4, v5, *((void *)refcon + 9));
    }
    if (!*((void *)refcon + 7))
    {
      int v6 = objc_alloc_init(CMMotionActivityManager);
      *((void *)refcon + 7) = v6;
      uint64_t v7 = *((void *)refcon + 8);
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 3221225472;
      v20[2] = sub_1904E0504;
      _DWORD v20[3] = &unk_1E568E3A0;
      void v20[4] = refcon;
      objc_msgSend_startActivityUpdatesToQueue_withHandler_(v6, v8, v7, v20);
    }
    if (*((void *)refcon + 11)) {
      goto LABEL_16;
    }
    io_connect_t v9 = IORegisterForSystemPower(refcon, (IONotificationPortRef *)refcon + 11, (IOServiceInterestCallback)sub_1904E0550, (io_object_t *)refcon + 20);
    *((_DWORD *)refcon + 21) = v9;
    if (v9)
    {
      IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)refcon + 11), *((dispatch_queue_t *)refcon + 9));
LABEL_16:
      if (qword_1E929D778 != -1) {
        dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
      }
      __int16 v10 = qword_1E929D770;
      if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)float32x4_t buf = 0;
        _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_DEFAULT, "enabled detection successfully", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D778 != -1) {
          dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
        }
        uint64_t v11 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::enableDetection()", "CoreLocation: %s\n", v11);
        if (v11 != (char *)buf) {
          free(v11);
        }
      }
      return;
    }
    if (qword_1E929D778 != -1) {
      dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
    }
    io_connect_t v15 = qword_1E929D770;
    if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)float32x4_t buf = 0;
      _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_FAULT, "Could not subscribe to system power notifications", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D778 != -1) {
        dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
      }
      __int16 v19 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CLPocketStateService::enableDetection()", "CoreLocation: %s\n", v19);
      if (v19 != (char *)buf) {
        free(v19);
      }
    }
    sub_1904E02C8((io_object_t *)refcon, v16, v17);
  }
  else
  {
    if (qword_1E929D778 != -1) {
      dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
    }
    uint64_t v12 = qword_1E929D770;
    if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)float32x4_t buf = 0;
      _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_DEFAULT, "disable Detection", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D778 != -1) {
        dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
      }
      LOWORD(v20[0]) = 0;
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLPocketStateService::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v18);
      if (v18 != (char *)buf) {
        free(v18);
      }
    }
    sub_1904E02C8((io_object_t *)refcon, v13, v14);
  }
}

void sub_1904E19D8(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_1904E1A08(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = objc_msgSend_processInfo(MEMORY[0x1E4F28F80], a2, a3);
  uint64_t v6 = objc_msgSend_processName(v3, v4, v5);
  id v7 = [NSString alloc];
  uint64_t result = objc_msgSend_initWithFormat_(v7, v8, @"com.apple.CoreMotion.PocketState.%@", v6);
  qword_1EB3BF2D8 = result;
  return result;
}

void sub_1904E1A64(uint64_t a1, double a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  uint64_t v4 = mach_absolute_time();
  double v5 = sub_1902D8D34(v4);
  unint64_t v6 = BKSHIDServicesRequestEstimatedProximityEvents();
  kdebug_trace();
  uint64_t v7 = mach_absolute_time();
  double v8 = sub_1902D8D34(v7);
  if (qword_1E929D778 != -1) {
    dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
  }
  double v9 = v8 - v5;
  __int16 v10 = qword_1E929D770;
  if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = mach_absolute_time();
    double v12 = sub_1902D8D34(v11);
    if (v6 > 2) {
      double v13 = 0;
    }
    else {
      double v13 = off_1E568E478[v6];
    }
    *(_DWORD *)float32x4_t buf = 134219010;
    double v21 = v12;
    __int16 v22 = 2048;
    double v23 = a2;
    __int16 v24 = 2048;
    double v25 = a2 + 2.0;
    __int16 v26 = 2048;
    double v27 = v9;
    __int16 v28 = 2080;
    __int16 v29 = v13;
    _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_DEFAULT, "%f: monitorTime, %f, bksMonitorTime, %f, bksDelay, %f, proxStatus, %s", buf, 0x34u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D778 != -1) {
      dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
    }
    uint64_t v18 = mach_absolute_time();
    sub_1902D8D34(v18);
    __int16 v19 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::queryInitiated(NSTimeInterval)", "CoreLocation: %s\n", v19);
    if (v19 != (char *)buf) {
      free(v19);
    }
  }
  if (v6 == 2)
  {
    uint64_t v16 = @"proxStatus.ignored";
  }
  else if (v6 == 1)
  {
    uint64_t v16 = @"proxStatus.extended";
  }
  else
  {
    if (v6) {
      return;
    }
    uint64_t v15 = mach_absolute_time();
    *(double *)(a1 + 112) = sub_1902D8D34(v15);
    *(_DWORD *)(a1 + 104) = 0;
    uint64_t v16 = @"proxStatus.started";
  }
  if (MEMORY[0x1E4F49EC0])
  {
    uint64_t v17 = NSString;
    if (qword_1EB3BF2E0 != -1) {
      dispatch_once(&qword_1EB3BF2E0, &unk_1EDFD36A0);
    }
    objc_msgSend_stringWithFormat_(v17, v14, @"%@.%@", qword_1EB3BF2D8, v16);
    ADClientAddValueForScalarKey();
  }
}

uint64_t sub_1904E1DD8(int *a1, int a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D778 != -1) {
    dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
  }
  uint64_t v4 = qword_1E929D770;
  if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_DEBUG))
  {
    int v5 = a1[25];
    *(_DWORD *)float32x4_t buf = 67240448;
    int v10 = a2;
    __int16 v11 = 1026;
    int v12 = v5;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEBUG, "New orientation,%{public}d,Prev orientation,%{public}d", buf, 0xEu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D778 != -1) {
      dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
    }
    double v8 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::feedDeviceOrientationData(const CLOrientationNotifier::Sample *)", "CoreLocation: %s\n", v8);
    if (v8 != (char *)buf) {
      free(v8);
    }
  }
  if (a2 == 6) {
    int v6 = 2;
  }
  else {
    int v6 = 1;
  }
  a1[25] = v6;
  return sub_1904E0AFC(a1);
}

uint64_t sub_1904E1FC0(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_DWORD *)(a1 + 40) & 0x100) != 0) {
    int v3 = 2;
  }
  else {
    int v3 = 1;
  }
  if (*(double *)(v2 + 112) != 0.0 && !*(_DWORD *)(v2 + 104) && (*(_DWORD *)(a1 + 40) & 0x100) != 0)
  {
    uint64_t v5 = mach_absolute_time();
    double v6 = sub_1902D8D34(v5);
    double v7 = *(double *)(v2 + 112);
    *(void *)(v2 + 112) = 0;
    if (qword_1E929D778 != -1) {
      dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
    }
    double v8 = v6 - v7;
    double v9 = qword_1E929D770;
    if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = mach_absolute_time();
      *(_DWORD *)float32x4_t buf = 134218240;
      *(void *)__int16 v22 = sub_1902D8D34(v10);
      *(_WORD *)&v22[8] = 2048;
      *(double *)&v22[10] = v8;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_INFO, "%f: ProxDelay,%f", buf, 0x16u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D778 != -1) {
        dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
      }
      uint64_t v19 = mach_absolute_time();
      sub_1902D8D34(v19);
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::feedProximityData(const uint32_t)_block_invoke", "CoreLocation: %s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
    int v12 = NSString;
    if (qword_1EB3BF2E0 != -1) {
      dispatch_once(&qword_1EB3BF2E0, &unk_1EDFD36A0);
    }
    objc_msgSend_stringWithFormat_(v12, v11, @"%@.%@", qword_1EB3BF2D8, @"proxBootDelay");
    ADClientPushValueForDistributionKey();
  }
  *(_DWORD *)(v2 + 104) = v3;
  if (qword_1E929D778 != -1) {
    dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
  }
  uint64_t v13 = qword_1E929D770;
  if (os_log_type_enabled((os_log_t)qword_1E929D770, OS_LOG_TYPE_INFO))
  {
    int v14 = *(_DWORD *)(a1 + 40);
    uint64_t v15 = *(int *)(v2 + 104);
    if (v15 > 2) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = off_1E568E490[v15];
    }
    *(_DWORD *)float32x4_t buf = 67109378;
    *(_DWORD *)__int16 v22 = v14;
    *(_WORD *)&v22[4] = 2080;
    *(void *)&v22[6] = v16;
    _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_INFO, "Proximity detection mask: %u, Last prox state: %s", buf, 0x12u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D778 != -1) {
      dispatch_once(&qword_1E929D778, &unk_1EDFD3B00);
    }
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLPocketStateService::feedProximityData(const uint32_t)_block_invoke", "CoreLocation: %s\n", v18);
    if (v18 != (char *)buf) {
      free(v18);
    }
  }
  return sub_1904E0AFC((int *)v2);
}

uint64_t sub_1904E23FC(uint64_t a1, void *a2, uint64_t a3)
{
  int v3 = *(int **)(a1 + 32);
  if (objc_msgSend_stationary(a2, (const char *)a2, a3)) {
    int v4 = 2;
  }
  else {
    int v4 = 1;
  }
  unsigned char v3[24] = v4;

  return sub_1904E0AFC(v3);
}

void sub_1904E2448(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 120))
  {
    if (!*(_DWORD *)(v1 + 100))
    {
      uint64_t v2 = sub_190576BA8();
      uint64_t v3 = sub_19057BB34(v2, 0);
      int v4 = *(NSObject **)(v1 + 72);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = sub_1904E24E8;
      block[3] = &unk_1E568E3E0;
      void block[4] = v1;
      void block[5] = v3;
      void block[6] = v5;
      dispatch_async(v4, block);
    }
  }
}

uint64_t sub_1904E24E8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (*(unsigned char *)(result + 120))
  {
    if (!*(_DWORD *)(result + 100)) {
      return sub_1904E1DD8((int *)result, *(_DWORD *)(a1 + 48));
    }
  }
  return result;
}

uint64_t sub_1904E250C(uint64_t a1)
{
  return sub_1904E1DD8(*(int **)(a1 + 32), *(_DWORD *)(a1 + 48));
}

os_log_t sub_1904E251C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Pocket");
  qword_1E929D770 = (uint64_t)result;
  return result;
}

void sub_1904E2550(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904E2588(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_1904E2598(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904E25D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_1904E2714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_1904E2750(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  double v7 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v5, 0);
  if (*a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7)) != 0
    && (uint64_t v10 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage")) != 0
    && (uint64_t v13 = v10, objc_msgSend_intValue(v10, v11, v12) != 100))
  {
    int v16 = objc_msgSend_intValue(v13, v14, v15);
  }
  else
  {
    int v16 = 103;
  }
  if (qword_1E929D6C8 != -1) {
    dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
  }
  uint64_t v17 = qword_1E929D6C0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6C0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)float32x4_t buf = 67240192;
    int v20 = v16;
    _os_log_impl(&dword_1902AF000, v17, OS_LOG_TYPE_ERROR, "Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6C8 != -1) {
      dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
    }
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMMotionAlarmManagerInternal init]_block_invoke", "CoreLocation: %s\n", v18);
    if (v18 != (char *)buf) {
      free(v18);
    }
  }
}

void sub_1904E297C(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v5 = ExecutablePathFromPid;
    if (qword_1E929D6C8 != -1) {
      dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
    }
    double v6 = qword_1E929D6C0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6C0, OS_LOG_TYPE_INFO))
    {
      pid_t v7 = getpid();
      uint64_t v8 = *(void *)(a1 + 32);
      int v9 = *(unsigned __int8 *)(v8 + 32);
      *(_DWORD *)float32x4_t buf = 138413058;
      uint64_t v12 = v5;
      __int16 v13 = 1024;
      pid_t v14 = v7;
      __int16 v15 = 1024;
      int v16 = v9;
      __int16 v17 = 2048;
      uint64_t v18 = v8;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_INFO, "CMMotionAlarmManager client connection interrupt, %@, %d, %d, %p", buf, 0x22u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6C8 != -1) {
        dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
      }
      getpid();
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMMotionAlarmManagerInternal init]_block_invoke", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
}

id sub_1904E2C34(uint64_t a1)
{
  id result = objc_alloc_init(*(Class *)(a1 + 32));
  qword_1EB3BF2F0 = (uint64_t)result;
  return result;
}

void sub_1904E2EE8(uint64_t a1)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(*(void *)(a1 + 32) + 32))
  {
    sub_1902C3F54(&__p, "kCLConnectionMessageMotionAlarmFire");
    v4[1] = MEMORY[0x1E4F143A8];
    _DWORD v4[2] = 3221225472;
    v4[3] = sub_1904E30A8;
    v4[4] = &unk_1E568D558;
    void v4[5] = *(void *)(a1 + 32);
    CLConnectionClient::setHandlerForMessage();
    if (v7 < 0) {
      operator delete(__p);
    }
    uint64_t v8 = @"kCLConnectionMessageSubscribeKey";
    v9[0] = MEMORY[0x1E4F1CC38];
    v4[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v2, (uint64_t)v9, &v8, 1);
    sub_190493DEC("kCLConnectionMessageMotionAlarmFire", v4, &__p);
    uint64_t v3 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v3) {
      sub_1902D8B58(v3);
    }
    *(unsigned char *)(*(void *)(a1 + 32) + 32) = 1;
    if (v6) {
      sub_1902D8B58(v6);
    }
  }
}

void sub_1904E3064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a19) {
    sub_1902D8B58(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904E30A8(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  int v9 = (NSSet *)objc_msgSend_setWithObjects_(v4, v8, v5, v6, v7, 0);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v9);

  return MEMORY[0x1F4181798](v10, sel__handleAlarmFire_, DictionaryOfClasses);
}

void sub_1904E31C8(uint64_t a1, const char *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(*(void *)(a1 + 32) + 32))
  {
    uint64_t v7 = @"kCLConnectionMessageSubscribeKey";
    uint64_t v8 = MEMORY[0x1E4F1CC28];
    uint64_t v6 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], a2, (uint64_t)&v8, &v7, 1);
    sub_190493DEC("kCLConnectionMessageMotionAlarmFire", &v6, buf);
    uint64_t v5 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v5) {
      sub_1902D8B58(v5);
    }
    *(unsigned char *)(*(void *)(a1 + 32) + 32) = 0;
    if (v10) {
      sub_1902D8B58(v10);
    }
  }
  else
  {
    if (qword_1E929D6C8 != -1) {
      dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
    }
    uint64_t v3 = qword_1E929D6C0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6C0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)float32x4_t buf = 0;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_INFO, "Unable to stop MotionAlarm data updates as we are are not receiving updates.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6C8 != -1) {
        dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
      }
      LOWORD(v6) = 0;
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMMotionAlarmManagerInternal _stopListeners]_block_invoke", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
}

void sub_1904E33FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a12) {
    sub_1902D8B58(a12);
  }
  if (a18) {
    sub_1902D8B58(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904E38E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  objc_sync_exit(v28);
  _Unwind_Resume(a1);
}

void sub_1904E3924(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  int v9 = (NSSet *)objc_msgSend_setWithObjects_(v4, v8, v5, v6, v7, 0);
  if (*a2 && (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9)) != 0)
  {
    uint64_t v12 = DictionaryOfClasses;
    __int16 v13 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v11, @"CMErrorMessage");
    uint64_t v15 = objc_msgSend_objectForKeyedSubscript_(v12, v14, @"CMMotionAlarmKey");
    if (objc_msgSend_intValue(v13, v16, v17) == 100)
    {
      if (v15)
      {
        objc_msgSend_copyPropertiesFromAlarm_(*(void **)(a1 + 32), v18, v15);
        uint64_t v19 = v24;
        v24[0] = MEMORY[0x1E4F143A8];
        v24[1] = 3221225472;
        v24[2] = sub_1904E3EA8;
        v24[3] = &unk_1E568D118;
        v24[4] = *(void *)(a1 + 32);
      }
      else
      {
        if (qword_1E929D6C8 != -1) {
          dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
        }
        int v20 = qword_1E929D6C0;
        if (os_log_type_enabled((os_log_t)qword_1E929D6C0, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)float32x4_t buf = 0;
          _os_log_impl(&dword_1902AF000, v20, OS_LOG_TYPE_ERROR, "Unable to parse kCLConnectionMessageMotionAlarmRegister message.", buf, 2u);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D6C8 != -1) {
            dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
          }
          __int16 v23 = 0;
          uint64_t v21 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "-[CMMotionAlarmManagerInternal _registerAlarm:error:]_block_invoke", "CoreLocation: %s\n", v21);
          if (v21 != (char *)buf) {
            free(v21);
          }
        }
        uint64_t v19 = block;
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = sub_1904E3F14;
        block[3] = &unk_1E568D118;
        void block[4] = *(void *)(a1 + 32);
      }
    }
    else
    {
      uint64_t v19 = v25;
      v25[0] = MEMORY[0x1E4F143A8];
      v25[1] = 3221225472;
      v25[2] = sub_1904E3DA4;
      _OWORD v25[3] = &unk_1E568D190;
      v25[4] = *(void *)(a1 + 32);
      v25[5] = v13;
    }
  }
  else
  {
    uint64_t v19 = v26;
    v26[0] = MEMORY[0x1E4F143A8];
    v26[1] = 3221225472;
    v26[2] = sub_1904E3CB0;
    v26[3] = &unk_1E568D118;
    v26[4] = *(void *)(a1 + 32);
  }
  dispatch_async(MEMORY[0x1E4F14428], v19);
}

uint64_t sub_1904E3CB0(uint64_t a1, const char *a2, uint64_t a3)
{
  v22[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend_manager(*(void **)(a1 + 32), a2, a3);
  objc_msgSend_delegate(v4, v5, v6);
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v10 = objc_msgSend_manager(*(void **)(a1 + 32), v8, v9);
    __int16 v13 = objc_msgSend_delegate(v10, v11, v12);
    uint64_t v14 = *(void *)(a1 + 32);
    uint64_t v15 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v21 = *MEMORY[0x1E4F28568];
    v22[0] = @"Alarm registration response missing";
    uint64_t v17 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v16, (uint64_t)v22, &v21, 1);
    uint64_t v19 = objc_msgSend_errorWithDomain_code_userInfo_(v15, v18, @"CMErrorDomain", 103, v17);
    return objc_msgSend_alarmDidRegister_error_(v13, v20, v14, v19);
  }
  return result;
}

uint64_t sub_1904E3DA4(uint64_t a1, const char *a2, uint64_t a3)
{
  v25[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend_manager(*(void **)(a1 + 32), a2, a3);
  objc_msgSend_delegate(v4, v5, v6);
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v10 = objc_msgSend_manager(*(void **)(a1 + 32), v8, v9);
    __int16 v13 = objc_msgSend_delegate(v10, v11, v12);
    uint64_t v14 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v15 = *(void *)(a1 + 32);
    uint64_t v18 = (int)objc_msgSend_intValue(*(void **)(a1 + 40), v16, v17);
    uint64_t v24 = *MEMORY[0x1E4F28568];
    v25[0] = @"Alarm registration returned an error";
    uint64_t v20 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v19, (uint64_t)v25, &v24, 1);
    uint64_t v22 = objc_msgSend_errorWithDomain_code_userInfo_(v14, v21, @"CMErrorDomain", v18, v20);
    return objc_msgSend_alarmDidRegister_error_(v13, v23, v15, v22);
  }
  return result;
}

uint64_t sub_1904E3EA8(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_manager(*(void **)(a1 + 32), a2, a3);
  objc_msgSend_delegate(v4, v5, v6);
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v10 = objc_msgSend_manager(*(void **)(a1 + 32), v8, v9);
    __int16 v13 = objc_msgSend_delegate(v10, v11, v12);
    uint64_t v15 = *(void *)(a1 + 32);
    return objc_msgSend_alarmDidRegister_error_(v13, v14, v15, 0);
  }
  return result;
}

uint64_t sub_1904E3F14(uint64_t a1, const char *a2, uint64_t a3)
{
  v22[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend_manager(*(void **)(a1 + 32), a2, a3);
  objc_msgSend_delegate(v4, v5, v6);
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v10 = objc_msgSend_manager(*(void **)(a1 + 32), v8, v9);
    __int16 v13 = objc_msgSend_delegate(v10, v11, v12);
    uint64_t v14 = *(void *)(a1 + 32);
    uint64_t v15 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v21 = *MEMORY[0x1E4F28568];
    v22[0] = @"Unable to parse alarm registration response";
    uint64_t v17 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v16, (uint64_t)v22, &v21, 1);
    uint64_t v19 = objc_msgSend_errorWithDomain_code_userInfo_(v15, v18, @"CMErrorDomain", 103, v17);
    return objc_msgSend_alarmDidRegister_error_(v13, v20, v14, v19);
  }
  return result;
}

void sub_1904E44AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  objc_sync_exit(v28);
  _Unwind_Resume(a1);
}

void sub_1904E4530(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v9 = (NSSet *)objc_msgSend_setWithObjects_(v4, v8, v5, v6, v7, 0);
  if (!*a2 || (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9)) == 0)
  {
    v38[0] = MEMORY[0x1E4F143A8];
    v38[1] = 3221225472;
    v38[2] = sub_1904E4A94;
    float v38[3] = &unk_1E568D118;
    v38[4] = *(void *)(a1 + 32);
    double v27 = MEMORY[0x1E4F14428];
    uint64_t v28 = v38;
LABEL_15:
    dispatch_async(v27, v28);
    return;
  }
  uint64_t v12 = DictionaryOfClasses;
  __int16 v13 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v11, @"CMErrorMessage");
  uint64_t v15 = objc_msgSend_objectForKeyedSubscript_(v12, v14, @"CMMotionAlarmKey");
  if (objc_msgSend_intValue(v13, v16, v17) != 100)
  {
    v37[0] = MEMORY[0x1E4F143A8];
    v37[1] = 3221225472;
    _OWORD v37[2] = sub_1904E4B28;
    float v37[3] = &unk_1E568D190;
    v37[4] = *(void *)(a1 + 32);
    v37[5] = v13;
    double v27 = MEMORY[0x1E4F14428];
    uint64_t v28 = v37;
    goto LABEL_15;
  }
  if (!v15)
  {
    if (qword_1E929D6C8 != -1) {
      dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
    }
    __int16 v29 = qword_1E929D6C0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6C0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)float32x4_t buf = 0;
      _os_log_impl(&dword_1902AF000, v29, OS_LOG_TYPE_ERROR, "Unable to parse kCLConnectionMessageMotionAlarmUnregister message.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6C8 != -1) {
        dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
      }
      LOWORD(v39) = 0;
      int v34 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMMotionAlarmManagerInternal _unregisterAlarm:error:]_block_invoke", "CoreLocation: %s\n", v34);
      if (v34 != (char *)buf) {
        free(v34);
      }
    }
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 3221225472;
    v35[2] = sub_1904E4C40;
    v35[3] = &unk_1E568D118;
    v35[4] = *(void *)(a1 + 32);
    double v27 = MEMORY[0x1E4F14428];
    uint64_t v28 = v35;
    goto LABEL_15;
  }
  id Weak = objc_loadWeak((id *)(a1 + 40));
  if (Weak)
  {
    uint64_t v19 = Weak;
    objc_sync_enter(Weak);
    id v20 = *(id *)(a1 + 32);
    objc_msgSend_copyPropertiesFromAlarm_(*(void **)(a1 + 32), v21, v15);
    uint64_t v22 = (void *)v19[3];
    uint64_t v25 = objc_msgSend_name(*(void **)(a1 + 32), v23, v24);
    objc_msgSend_removeObjectForKey_(v22, v26, v25);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_1904E4BD8;
    block[3] = &unk_1E568D118;
    void block[4] = *(void *)(a1 + 32);
    dispatch_async(MEMORY[0x1E4F14428], block);
    objc_sync_exit(v19);
  }
  else
  {
    if (qword_1E929D6C8 != -1) {
      dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
    }
    uint64_t v30 = qword_1E929D6C0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6C0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v31 = *(void *)(a1 + 32);
      *(_DWORD *)float32x4_t buf = 138543362;
      uint64_t v42 = v31;
      _os_log_impl(&dword_1902AF000, v30, OS_LOG_TYPE_DEFAULT, "Alarm manager no longer exists, cannot unregister alarm: %{public}@", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6C8 != -1) {
        dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
      }
      uint64_t v32 = *(void *)(a1 + 32);
      int v39 = 138543362;
      uint64_t v40 = v32;
      __int16 v33 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMMotionAlarmManagerInternal _unregisterAlarm:error:]_block_invoke", "CoreLocation: %s\n", v33);
      if (v33 != (char *)buf) {
        free(v33);
      }
    }
  }
}

void sub_1904E4A78(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1904E4A94(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_manager(*(void **)(a1 + 32), a2, a3);
  objc_msgSend_delegate(v4, v5, v6);
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v10 = objc_msgSend_manager(*(void **)(a1 + 32), v8, v9);
    __int16 v13 = objc_msgSend_delegate(v10, v11, v12);
    uint64_t v16 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], v14, @"CMErrorDomain", 103, 0);
    return objc_msgSend_alarmDidUnregister_error_(v13, v15, 0, v16);
  }
  return result;
}

uint64_t sub_1904E4B28(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_manager(*(void **)(a1 + 32), a2, a3);
  objc_msgSend_delegate(v4, v5, v6);
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v10 = objc_msgSend_manager(*(void **)(a1 + 32), v8, v9);
    __int16 v13 = objc_msgSend_delegate(v10, v11, v12);
    uint64_t v14 = (void *)MEMORY[0x1E4F28C58];
    int v17 = objc_msgSend_intValue(*(void **)(a1 + 40), v15, v16);
    uint64_t v20 = objc_msgSend_errorWithDomain_code_userInfo_(v14, v18, @"CMErrorDomain", v17, 0);
    return objc_msgSend_alarmDidUnregister_error_(v13, v19, 0, v20);
  }
  return result;
}

void sub_1904E4BD8(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_manager(*(void **)(a1 + 32), a2, a3);
  objc_msgSend_delegate(v4, v5, v6);
  if (objc_opt_respondsToSelector())
  {
    uint64_t v9 = objc_msgSend_manager(*(void **)(a1 + 32), v7, v8);
    uint64_t v12 = objc_msgSend_delegate(v9, v10, v11);
    objc_msgSend_alarmDidUnregister_error_(v12, v13, *(void *)(a1 + 32), 0);
  }
  uint64_t v14 = *(void **)(a1 + 32);
}

uint64_t sub_1904E4C40(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_manager(*(void **)(a1 + 32), a2, a3);
  objc_msgSend_delegate(v4, v5, v6);
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v10 = objc_msgSend_manager(*(void **)(a1 + 32), v8, v9);
    __int16 v13 = objc_msgSend_delegate(v10, v11, v12);
    uint64_t v16 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], v14, @"CMErrorDomain", 103, 0);
    return objc_msgSend_alarmDidUnregister_error_(v13, v15, 0, v16);
  }
  return result;
}

void sub_1904E4FC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  objc_sync_exit(v24);
  _Unwind_Resume(a1);
}

void sub_1904E5020(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v9 = (NSSet *)objc_msgSend_setWithObjects_(v4, v8, v5, v6, v7, 0);
  if (!*a2 || (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9)) == 0)
  {
    if (qword_1E929D6C8 != -1) {
      dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
    }
    double v38 = qword_1E929D6C0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6C0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)float32x4_t buf = 0;
      _os_log_impl(&dword_1902AF000, v38, OS_LOG_TYPE_ERROR, "Unable to parse kCLConnectionMessageMotionAlarmAcknowledge message.", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6C8 == -1) {
      goto LABEL_41;
    }
    goto LABEL_44;
  }
  uint64_t v12 = DictionaryOfClasses;
  __int16 v13 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v11, @"CMErrorMessage");
  uint64_t v15 = objc_msgSend_objectForKeyedSubscript_(v12, v14, @"CMMotionAlarmKey");
  if (objc_msgSend_intValue(v13, v16, v17) != 100)
  {
    if (qword_1E929D6C8 != -1) {
      dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
    }
    int v39 = qword_1E929D6C0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6C0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float32x4_t buf = 67109120;
      LODWORD(v48) = objc_msgSend_intValue(v13, v40, v41);
      _os_log_impl(&dword_1902AF000, v39, OS_LOG_TYPE_ERROR, "Unable to call kCLConnectionMessageMotionAlarmAcknowledge message. Code: %d", buf, 8u);
    }
    if (!sub_1902D8400(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6C8 != -1) {
      dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
    }
    objc_msgSend_intValue(v13, v42, v43);
    uint64_t v44 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMMotionAlarmManagerInternal _acknowledgeAlarm:error:]_block_invoke", "CoreLocation: %s\n", v44);
LABEL_42:
    if (v44 != (char *)buf) {
      free(v44);
    }
    return;
  }
  if (!v15)
  {
    if (qword_1E929D6C8 != -1) {
      dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
    }
    char v45 = qword_1E929D6C0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6C0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)float32x4_t buf = 0;
      _os_log_impl(&dword_1902AF000, v45, OS_LOG_TYPE_ERROR, "Unable to parse kCLConnectionMessageMotionAlarmAcknowledge message.", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6C8 == -1) {
      goto LABEL_41;
    }
    goto LABEL_44;
  }
  id Weak = objc_loadWeak((id *)(a1 + 32));
  if (Weak)
  {
    uint64_t v19 = Weak;
    objc_sync_enter(Weak);
    uint64_t v20 = (void *)v19[3];
    uint64_t v23 = objc_msgSend_name(v15, v21, v22);
    uint64_t v25 = objc_msgSend_objectForKey_(v20, v24, v23);
    if ((objc_msgSend_repeats(v25, v26, v27) & 1) == 0)
    {
      uint64_t v30 = objc_msgSend_alarmId(v15, v28, v29);
      if (v30 == objc_msgSend_alarmId(v25, v31, v32))
      {
        uint64_t v35 = (void *)v19[3];
        uint64_t v36 = objc_msgSend_name(v25, v33, v34);
        objc_msgSend_removeObjectForKey_(v35, v37, v36);
      }
    }
    objc_sync_exit(v19);
    return;
  }
  if (qword_1E929D6C8 != -1) {
    dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
  }
  unint64_t v46 = qword_1E929D6C0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6C0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)float32x4_t buf = 138543362;
    double v48 = v15;
    _os_log_impl(&dword_1902AF000, v46, OS_LOG_TYPE_ERROR, "Alarm manager no longer exists, cannot acknowledge alarm: %{public}@", buf, 0xCu);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6C8 == -1)
    {
LABEL_41:
      uint64_t v44 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMMotionAlarmManagerInternal _acknowledgeAlarm:error:]_block_invoke", "CoreLocation: %s\n", v44);
      goto LABEL_42;
    }
LABEL_44:
    dispatch_once(&qword_1E929D6C8, &unk_1EDFD2F00);
    goto LABEL_41;
  }
}

void sub_1904E56AC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1904E57EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15) {
    sub_1902D8B58(a15);
  }
  sub_1902D8B58(v22);
  objc_sync_exit(v21);
  _Unwind_Resume(a1);
}

void sub_1904E5848(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v8 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v6, 0);
  if (*a2 && (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v8)) != 0)
  {
    uint64_t v11 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v10, @"CMErrorMessage");
    if (objc_msgSend_intValue(v11, v12, v13) == 100)
    {
      uint64_t v14 = v15;
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 3221225472;
      v15[2] = sub_1904E5AA8;
      v15[3] = &unk_1E568D118;
      v15[4] = *(void *)(a1 + 32);
    }
    else
    {
      uint64_t v14 = block;
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = sub_1904E5A38;
      block[3] = &unk_1E568D190;
      void block[4] = *(void *)(a1 + 32);
      void block[5] = v11;
    }
  }
  else
  {
    uint64_t v14 = v17;
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 3221225472;
    void v17[2] = sub_1904E59DC;
    v17[3] = &unk_1E568D118;
    v17[4] = *(void *)(a1 + 32);
  }
  dispatch_async(MEMORY[0x1E4F14428], v14);
}

uint64_t sub_1904E59DC(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);

  return MEMORY[0x1F4181798](v2, sel_remoteAppLaunchedWithResult_error_, 1);
}

uint64_t sub_1904E5A38(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = objc_msgSend_intValue(*(void **)(a1 + 40), a2, a3);
  objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);

  return MEMORY[0x1F4181798](v4, sel_remoteAppLaunchedWithResult_error_, 1);
}

uint64_t sub_1904E5AA8(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_remoteAppLaunchedWithResult_error_, 0);
}

void sub_1904E5EEC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1904E5F18(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_manager(*(void **)(a1 + 32), a2, a3);
  objc_msgSend_delegate(v4, v5, v6);
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v10 = objc_msgSend_manager(*(void **)(a1 + 32), v8, v9);
    uint64_t v13 = objc_msgSend_delegate(v10, v11, v12);
    uint64_t v14 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v15 = *(void *)(a1 + 32);
    int v18 = objc_msgSend_intValue(*(void **)(a1 + 40), v16, v17);
    objc_msgSend_errorWithDomain_code_userInfo_(v14, v19, @"CMErrorDomain", v18, 0);
    return MEMORY[0x1F4181798](v13, sel_alarmDidFire_error_, v15);
  }
  return result;
}

uint64_t sub_1904E5FD4(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_manager(*(void **)(a1 + 32), a2, a3);
  objc_msgSend_delegate(v4, v5, v6);
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v10 = objc_msgSend_manager(*(void **)(a1 + 32), v8, v9);
    uint64_t v13 = objc_msgSend_delegate(v10, v11, v12);
    uint64_t v14 = *(void *)(a1 + 32);
    return MEMORY[0x1F4181798](v13, sel_alarmDidFire_error_, v14);
  }
  return result;
}

id sub_1904E6184(uint64_t a1)
{
  id result = objc_alloc_init(*(Class *)(a1 + 32));
  qword_1EB3BF300 = (uint64_t)result;
  return result;
}

os_log_t sub_1904E6428()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "MotionAlarm");
  qword_1E929D6C0 = (uint64_t)result;
  return result;
}

void *sub_1904E6458@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  os_log_t result = sub_1904E64BC(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1904E64A8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1904E64BC(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_1904E6530((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_1904E651C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1904E6530(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1904E6588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904E65A4(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>, float32x4_t a5@<Q0>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 728) == 2)
  {
    double v9 = sub_19059390C();
  }
  else
  {
    if (!*(void *)(a1 + 6664)) {
      operator new();
    }
    sub_1904D1860(a1, (uint64_t)a2, a5);
    sub_1902DE3E8(*(void *)(a1 + 6664), (uint64_t)a2, (uint64_t)a3, *(_DWORD *)(a1 + 728) != 0);
  }
  *(unsigned char *)a4 = 0;
  *(int64x2_t *)(a4 + 8) = vdupq_n_s64(0x7FF8000000000000uLL);
  *(void *)(a4 + 40) = 0;
  *(void *)(a4 + 64) = 0x3F80000000000000;
  *(void *)(a4 + 56) = 0;
  *(void *)(a4 + 24) = v10;
  *(void *)(a4 + 32) = v11;
  float v13 = v9;
  *(float *)(a4 + 44) = v13;
  *(void *)(a4 + 48) = v12;
  float v14 = v9 * 0.0174532924;
  uint64_t v25 = 0;
  float v26 = v14;
  sub_1904CF7FC((float32x4_t *)(a4 + 56), (float *)&v25);
  uint64_t v15 = a3[1];
  int v16 = ++dword_1E929E810;
  *(void *)(a4 + 8) = *a3;
  *(void *)(a4 + 16) = v15;
  *(unsigned char *)a4 = 1;
  *(_DWORD *)(a4 + 40) = v16;
  if (qword_1E929D998 != -1) {
    dispatch_once(&qword_1E929D998, &unk_1EDFD1C40);
  }
  uint64_t v17 = qword_1E929D9A0;
  if (os_log_type_enabled((os_log_t)qword_1E929D9A0, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v18 = *a2;
    uint64_t v19 = *a3;
    uint64_t v20 = a3[1];
    *(_DWORD *)float32x4_t buf = 134218752;
    uint64_t v36 = v18;
    __int16 v37 = 2048;
    uint64_t v38 = v19;
    __int16 v39 = 2048;
    uint64_t v40 = v20;
    __int16 v41 = 1024;
    int v42 = dword_1E929E810;
    _os_log_impl(&dword_1902AF000, v17, OS_LOG_TYPE_DEBUG, "[CMPdr] StepImpulse,time,%f,%f,%f, totalSteps,%d\n", buf, 0x26u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D998 != -1) {
      dispatch_once(&qword_1E929D998, &unk_1EDFD1C40);
    }
    uint64_t v21 = *a2;
    uint64_t v22 = *a3;
    uint64_t v23 = a3[1];
    int v27 = 134218752;
    uint64_t v28 = v21;
    __int16 v29 = 2048;
    uint64_t v30 = v22;
    __int16 v31 = 2048;
    uint64_t v32 = v23;
    __int16 v33 = 1024;
    int v34 = dword_1E929E810;
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CMPdr::PdrResults CMPdr::feedImuData(const AccessoryActivity::ImuData *const, const CMAccessoryStepDetector::Impulse &)", "CoreLocation: %s\n", v24);
    if (v24 != (char *)buf) {
      free(v24);
    }
  }
}

void sub_1904E68CC(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x1060C406F52CB89);
  _Unwind_Resume(a1);
}

os_log_t sub_1904E68F8()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "MotionContext");
  qword_1E929D9A0 = (uint64_t)result;
  return result;
}

void sub_1904E6928()
{
}

void sub_1904E69C0(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10F1C40E59F67ADLL);
  _Unwind_Resume(a1);
}

void sub_1904E69E8(void *a1)
{
  sub_1905A1098(a1);

  JUMPOUT(0x192FCC980);
}

double sub_1904E6A20(uint64_t a1, int a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3848);
    }
    uint64_t v4 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)float32x4_t buf = 67240192;
      LODWORD(v13) = a2;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "[AccessoryPPG] Unrecognized update interval notification %{public}d", buf, 8u);
    }
    double v5 = 0.0;
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC3848);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual CFTimeInterval CLAccessoryPPG::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    sub_1905A2C68(a1);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3848);
    }
    uint64_t v8 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = *a3;
      *(_DWORD *)float32x4_t buf = 134349056;
      uint64_t v13 = v9;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_INFO, "[AccessoryPPG] Setting update interval to %{public}f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC3848);
      }
      uint64_t v11 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryPPG::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
    return *(double *)a3;
  }
  return v5;
}

void sub_1904E6D3C(uint64_t a1)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  Dataint Value = (unsigned __int8 *)IOHIDEventGetDataValue();
  Integerint Value = IOHIDEventGetIntegerValue();
  if (!DataValue)
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3848);
    }
    uint64_t v13 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)float32x4_t buf = 0;
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_ERROR, "[AccessoryPPG] Invalid payload", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3848);
    }
    LOWORD(v34) = 0;
LABEL_30:
    int v16 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual void CLAccessoryPPG::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v16);
    if (v16 != (char *)buf) {
      free(v16);
    }
    return;
  }
  int v4 = IntegerValue;
  if (IntegerValue == 32)
  {
    unint64_t TimeStamp = IOHIDEventGetTimeStamp();
    double v6 = sub_1902D8D34(TimeStamp);
    *(double *)uint64_t v17 = v6;
    char v7 = *(unsigned __int8 **)(DataValue + 2);
    v17[1] = v7;
    int v8 = *DataValue;
    char v18 = *DataValue;
    unsigned __int8 v19 = DataValue[1];
    __int16 v9 = *((_WORD *)DataValue + 5);
    unsigned __int8 v21 = DataValue[12];
    __int16 v20 = v9;
    LOBYTE(v9) = DataValue[15];
    __int16 v22 = *(_WORD *)(DataValue + 13);
    char v23 = v9;
    __int16 v10 = *((_WORD *)DataValue + 8);
    unsigned __int8 v25 = DataValue[18];
    __int16 v24 = v10;
    __int16 v11 = *(_WORD *)(DataValue + 19);
    unsigned __int8 v27 = DataValue[21];
    __int16 v26 = v11;
    LOBYTE(v11) = DataValue[24];
    __int16 v28 = *((_WORD *)DataValue + 11);
    char v29 = v11;
    LOBYTE(v11) = DataValue[27];
    __int16 v30 = *(_WORD *)(DataValue + 25);
    char v31 = v11;
    __int16 v32 = *((_WORD *)DataValue + 14);
    __int16 v33 = *((_WORD *)DataValue + 15);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3848);
    }
    uint64_t v12 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)float32x4_t buf = 67241219;
      int v45 = v8;
      __int16 v46 = 2050;
      __int16 v47 = v7;
      __int16 v48 = 2050;
      double v49 = v6;
      __int16 v50 = 1040;
      int v51 = 32;
      __int16 v52 = 2097;
      __int16 v53 = DataValue;
      _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_DEBUG, "[AccessoryPPG] frameNum,%{public}d,sensorTime,%{public}llu,timestamp,%{public}20.20f,payload,{%{private}.*P}", buf, 0x2Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC3848);
      }
      int v34 = 67241219;
      int v35 = v8;
      __int16 v36 = 2050;
      __int16 v37 = v7;
      __int16 v38 = 2050;
      double v39 = v6;
      __int16 v40 = 1040;
      int v41 = 32;
      __int16 v42 = 2097;
      uint64_t v43 = DataValue;
      uint64_t v15 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLAccessoryPPG::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v15);
      if (v15 != (char *)buf) {
        free(v15);
      }
    }
    sub_1902D8BCC(a1, 0, (uint64_t)v17, 40);
    return;
  }
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC3848);
  }
  uint64_t v14 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)float32x4_t buf = 68157955;
    int v45 = v4;
    __int16 v46 = 2097;
    __int16 v47 = DataValue;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_ERROR, "[AccessoryPPG] Invalid payload: %{private}.*P", buf, 0x12u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3848);
    }
    int v34 = 68157955;
    int v35 = v4;
    __int16 v36 = 2097;
    __int16 v37 = DataValue;
    goto LABEL_30;
  }
}

os_log_t sub_1904E7280()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1EB3BE830 = (uint64_t)result;
  return result;
}

uint64_t sub_1904E72B0(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_feedOdometryData_, a1);
}

void sub_1904E73F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1904E7408(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t result = objc_msgSend_initPrivate(*(void **)(a1 + 32), a2, a3);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = result;
  return result;
}

void sub_1904E7588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1904E75A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), sel_deallocPrivate, a3);
}

void sub_1904E76F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_1904E7730(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D9D8 != -1) {
    dispatch_once(&qword_1E929D9D8, &unk_1EDFC35A8);
  }
  uint64_t v3 = qword_1E929D9E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D9E0, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = CLConnectionMessage::name(*a2);
    if (*(char *)(v4 + 23) >= 0) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = *(void *)v4;
    }
    *(_DWORD *)float32x4_t buf = 136446210;
    uint64_t v8 = v5;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEBUG, "Default handler received message %{public}s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D9D8 != -1) {
      dispatch_once(&qword_1E929D9D8, &unk_1EDFC35A8);
    }
    CLConnectionMessage::name(*a2);
    double v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMOdometryManager setupBIO]_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
}

void sub_1904E7910(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v5 = ExecutablePathFromPid;
    if (qword_1E929D9D8 != -1) {
      dispatch_once(&qword_1E929D9D8, &unk_1EDFC35A8);
    }
    double v6 = qword_1E929D9E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D9E0, OS_LOG_TYPE_DEFAULT))
    {
      pid_t v7 = getpid();
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)float32x4_t buf = 138478339;
      uint64_t v11 = v5;
      __int16 v12 = 1025;
      pid_t v13 = v7;
      __int16 v14 = 2049;
      uint64_t v15 = v8;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "Client connection interrupt, %{private}@, %{private}d, %{private}p", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D9D8 != -1) {
        dispatch_once(&qword_1E929D9D8, &unk_1EDFC35A8);
      }
      getpid();
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMOdometryManager setupBIO]_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
}

void sub_1904E7BC4(uint64_t a1)
{
}

uint64_t sub_1904E7C5C(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startOdometryUpdatesPrivateUsingReferenceFrame_toQueue_withHandler_, 1);
}

uint64_t sub_1904E7D04(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startOdometryUpdatesPrivateUsingReferenceFrame_toQueue_withHandler_, *(void *)(a1 + 56));
}

uint64_t sub_1904E7D90(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_stopOdometryUpdatesPrivate(*(void **)(a1 + 32), a2, a3);
}

uint64_t sub_1904E7E30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_setOdometryUpdateIntervalPrivate_, a3);
}

uint64_t sub_1904E7EEC(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startOdometryUpdatesPrivateUsingReferenceFrame_toQueue_withHandler_, *(void *)(a1 + 56));
}

uint64_t sub_1904E7F90(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_startBackgroundUpdatesPrivateUsingReferenceFrame_toQueue_withHandler_, *(void *)(a1 + 56));
}

uint64_t sub_1904E8790(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

uint64_t sub_1904E87A8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1904E89AC(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 32) + 8);
  *(_OWORD *)(v3 + 56) = *(_OWORD *)(v3 + 168);
  *(_OWORD *)(v3 + 72) = *(_OWORD *)(v3 + 184);
  *(_OWORD *)(v3 + 88) = *(_OWORD *)(v3 + 200);
  *(_OWORD *)(v3 + 104) = *(_OWORD *)(v3 + 216);
  *(_OWORD *)(v3 + 8) = *(_OWORD *)(v3 + 120);
  *(_OWORD *)(v3 + 24) = *(_OWORD *)(v3 + 136);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(v3 + 152);
  uint64_t v4 = *(_OWORD **)(result + 40);
  long long v5 = v4[3];
  long long v6 = v4[4];
  long long v7 = v4[5];
  *(_OWORD *)(v3 + 216) = v4[6];
  *(_OWORD *)(v3 + 200) = v7;
  *(_OWORD *)(v3 + 184) = v6;
  *(_OWORD *)(v3 + 168) = v5;
  long long v9 = v4[1];
  long long v8 = v4[2];
  *(_OWORD *)(v3 + 120) = *v4;
  *(_OWORD *)(v3 + 136) = v9;
  *(_OWORD *)(v3 + 152) = v8;
  if (*(unsigned char *)(v3 + 232)) {
    return MEMORY[0x1F4181798](*(void *)(result + 32), sel_sendOdometryToClientPrivate, a3);
  }
  *(unsigned char *)(v3 + 232) = 1;
  return result;
}

void sub_1904E9068(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void sub_1904E96E8(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v3 = (id *)(a1 + 32);
  id Weak = objc_loadWeak((id *)(a1 + 32));
  if (Weak)
  {
    long long v5 = Weak;
    if (Weak[4])
    {
      long long v6 = (void *)MEMORY[0x1E4F1CAD0];
      uint64_t v7 = objc_opt_class();
      uint64_t v8 = objc_opt_class();
      uint64_t v9 = objc_opt_class();
      uint64_t v11 = (NSSet *)objc_msgSend_setWithObjects_(v6, v10, v7, v8, v9, 0);
      uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v11);
      __int16 v14 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v13, @"CMBackgroundInertialOdometry");
      uint64_t v17 = v14;
      if (v5[6] == 8) {
        objc_msgSend_rotateArbitraryToTrueNorth(v14, v15, v16);
      }
      uint64_t v18 = objc_msgSend_copy((void *)v5[4], v15, v16);
      uint64_t v19 = (void *)v5[5];
      v21[0] = MEMORY[0x1E4F143A8];
      v21[1] = 3221225472;
      v21[2] = sub_1904E9848;
      _DWORD v21[3] = &unk_1E568D3C0;
      objc_copyWeak(&v22, v3);
      v21[4] = v17;
      void v21[5] = v18;
      objc_msgSend_addOperationWithBlock_(v19, v20, (uint64_t)v21);
      objc_destroyWeak(&v22);
    }
  }
}

void sub_1904E9834(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1904E9848(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(a1 + 48));
  uint64_t v3 = *(void (***)(void, void, void))(a1 + 40);
  if (Weak)
  {
    v3[2](v3, *(void *)(a1 + 32), 0);
    uint64_t v3 = *(void (***)(void, void, void))(a1 + 40);
  }
}

void sub_1904E98A4(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id Weak = objc_loadWeak((id *)(a1 + 56));
  if (Weak)
  {
    uint64_t v3 = Weak;
    if (qword_1E929D9D8 != -1) {
      dispatch_once(&qword_1E929D9D8, &unk_1EDFC35A8);
    }
    uint64_t v4 = qword_1E929D9E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D9E0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 64);
      *(_DWORD *)float32x4_t buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v5;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEFAULT, "Starting background InertialOdometry updates with reference frame: %{public}d", buf, 8u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D9D8 != -1) {
        dispatch_once(&qword_1E929D9D8, &unk_1EDFC35A8);
      }
      uint64_t v17 = *(void *)(a1 + 64);
      LODWORD(v22) = 67240192;
      HIDWORD(v22) = v17;
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMOdometryManager startBackgroundUpdatesPrivateUsingReferenceFrame:toQueue:withHandler:]_block_invoke", "CoreLocation: %s\n", v18);
      if (v18 != (char *)buf) {
        free(v18);
      }
    }
    long long v6 = (void *)v3[4];
    if (v6 != *(void **)(a1 + 40))
    {

      v3[4] = objc_msgSend_copy(*(void **)(a1 + 40), v7, v8);
    }
    uint64_t v9 = (void *)v3[5];
    if (v9 != *(void **)(a1 + 32))
    {

      void v3[5] = *(id *)(a1 + 32);
    }
    v3[6] = *(void *)(a1 + 64);
    sub_1902C3F54(buf, "PedestrianFence/kCLConnectionMessageBackgroundInertialOdometry");
    CLConnectionClient::setHandlerForMessage();
    if (v25 < 0) {
      operator delete(*(void **)buf);
    }
    v20[0] = @"kCLConnectionMessageSubscribeKey";
    v20[1] = @"CMPedestrianFenceClientIdentifier";
    v21[0] = MEMORY[0x1E4F1CC38];
    __int16 v12 = objc_msgSend_processInfo(MEMORY[0x1E4F28F80], v10, v11);
    v21[1] = objc_msgSend_processName(v12, v13, v14);
    uint64_t v22 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v15, (uint64_t)v21, v20, 2);
    sub_1904E9F7C(buf, &v22);
    uint64_t v16 = v24;
    uint64_t v19 = v24;
    if (v24) {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v19) {
      sub_1902D8B58(v19);
    }
    if (v16) {
      sub_1902D8B58(v16);
    }
  }
}

void sub_1904E9B88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a12) {
    sub_1902D8B58(a12);
  }
  if (v24) {
    sub_1902D8B58(v24);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904E9C7C(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id Weak = (id *)objc_loadWeak((id *)(a1 + 32));
  if (Weak)
  {
    uint64_t v2 = Weak;
    if (qword_1E929D9D8 != -1) {
      dispatch_once(&qword_1E929D9D8, &unk_1EDFC35A8);
    }
    uint64_t v3 = qword_1E929D9E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D9E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)float32x4_t buf = 0;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "Stopping background InertialOdometry updates", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D9D8 != -1) {
        dispatch_once(&qword_1E929D9D8, &unk_1EDFC35A8);
      }
      LOWORD(v8) = 0;
      long long v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMOdometryManager stopBackgroundUpdatesPrivate]_block_invoke", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    if (v2[4])
    {
      uint64_t v9 = @"kCLConnectionMessageSubscribeKey";
      uint64_t v10 = MEMORY[0x1E4F1CC28];
      uint64_t v8 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v4, (uint64_t)&v10, &v9, 1);
      sub_1904E9F7C(buf, &v8);
      uint64_t v5 = v12;
      uint64_t v7 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      CLConnectionClient::sendMessage();
      if (v7) {
        sub_1902D8B58(v7);
      }

      v2[4] = 0;
      v2[5] = 0;
      if (v5) {
        sub_1902D8B58(v5);
      }
    }
  }
}

void sub_1904E9EBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1902D8B58(a12);
  }
  if (v12) {
    sub_1902D8B58(v12);
  }
  _Unwind_Resume(exception_object);
}

os_log_t sub_1904E9F04()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "InertialOdometry");
  qword_1E929D9E0 = (uint64_t)result;
  return result;
}

void sub_1904E9F38(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904E9F70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_1904E9F7C(void *a1, void *a2)
{
  uint64_t v4 = operator new(0x70uLL);
  v4[1] = 0;
  _DWORD v4[2] = 0;
  *uint64_t v4 = &unk_1EDFD0DA0;
  sub_1902C3F54(__p, "PedestrianFence/kCLConnectionMessageBackgroundInertialOdometry");
  MEMORY[0x192FCC420](v4 + 3, __p, *a2);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_1904EA014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::__shared_weak_count::~__shared_weak_count(v15);
  operator delete(v17);
  _Unwind_Resume(a1);
}

os_log_t sub_1904EB1DC()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "HealthColdStorage");
  qword_1E929DA00 = (uint64_t)result;
  return result;
}

void sub_1904EB334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_1904EB370(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v7 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v5, 0);
  if (*a2
    && (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7)) != 0
    && (uint64_t v10 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage")) != 0)
  {
    int v13 = objc_msgSend_intValue(v10, v11, v12);
  }
  else
  {
    int v13 = 103;
  }
  if (qword_1E929D760 != -1) {
    dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
  }
  uint64_t v14 = qword_1E929D768;
  if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)float32x4_t buf = 67240192;
    int v17 = v13;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_ERROR, "Calorie response failed with error %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
    }
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMNatalimeterInternal init]_block_invoke", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
}

void sub_1904EB588(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v5 = ExecutablePathFromPid;
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
    }
    char v6 = qword_1E929D768;
    if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_DEFAULT))
    {
      pid_t v7 = getpid();
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)float32x4_t buf = 138412802;
      uint64_t v11 = v5;
      __int16 v12 = 1024;
      pid_t v13 = v7;
      __int16 v14 = 2048;
      uint64_t v15 = v8;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "Client connection interrupt, %@, %d, %p", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D760 != -1) {
        dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
      }
      getpid();
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMNatalimeterInternal init]_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
}

void sub_1904EB8B0(uint64_t a1, const char *a2)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  pid_t v7 = @"CMNatalimetryRecordId";
  v8[0] = objc_msgSend_numberWithInteger_(NSNumber, a2, *(void *)(a1 + 48));
  uint64_t v6 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v2, (uint64_t)v8, &v7, 1);
  sub_1904EF0B0("kCLConnectionMessageNatalimetryQuery", &v6, &v4);
  uint64_t v3 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CLConnectionClient::sendMessage();
  if (v3) {
    sub_1902D8B58(v3);
  }
  if (v5) {
    sub_1902D8B58(v5);
  }
}

void sub_1904EB9F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a17) {
    sub_1902D8B58(a17);
  }
  if (a19) {
    sub_1902D8B58(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904EBA1C(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)a2 + 1);
  uint64_t v5 = *(void *)a2;
  uint64_t v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  objc_msgSend__handleQueryResponse_withHandler_(v3, a2, (uint64_t)&v5, *(void *)(a1 + 40));
  if (v6) {
    sub_1902D8B58(v6);
  }
}

void sub_1904EBA78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904EBB08(uint64_t a1)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v7 = ExecutablePathFromPid;
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
    }
    uint64_t v8 = qword_1E929D768;
    if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_DEBUG))
    {
      pid_t v9 = getpid();
      uint64_t v10 = @" ";
      uint64_t v11 = *(void *)(a1 + 40);
      if (*(void *)(a1 + 32)) {
        uint64_t v10 = *(__CFString **)(a1 + 32);
      }
      int buf = 138413058;
      *(void *)buf_4 = v7;
      *(_WORD *)&buf_4[8] = 1024;
      *(_DWORD *)&buf_4[10] = v9;
      __int16 v77 = 2112;
      unsigned int v78 = v10;
      __int16 v79 = 2048;
      uint64_t v80 = v11;
      _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEBUG, "%@, pid, %d, query since record, %@, %p", (uint8_t *)&buf, 0x26u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1E929D760 != -1) {
        dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
      }
      pid_t v58 = getpid();
      __int16 v59 = @" ";
      uint64_t v60 = *(void *)(a1 + 40);
      if (*(void *)(a1 + 32)) {
        __int16 v59 = *(__CFString **)(a1 + 32);
      }
      *(_DWORD *)double v70 = 138413058;
      *(void *)&v70[4] = v7;
      *(_WORD *)&v70[12] = 1024;
      *(_DWORD *)&v70[14] = v58;
      __int16 v71 = 2112;
      double v72 = v59;
      __int16 v73 = 2048;
      uint64_t v74 = v60;
      __int16 v61 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMNatalimeterInternal _queryAbsoluteNatalimetryDataSinceDataRecord:withHandler:]_block_invoke", "CoreLocation: %s\n", v61);
      if (v61 != (char *)&buf) {
        free(v61);
      }
    }
  }
  uint64_t started = objc_msgSend_startDate(*(void **)(a1 + 32), v5, v6);
  objc_msgSend_timeIntervalSinceReferenceDate(started, v13, v14);
  if (v17 != 0.0)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    unsigned __int8 v21 = objc_msgSend_startDate(*(void **)(a1 + 32), v19, v20);
    objc_msgSend_timeIntervalSinceReferenceDate(v21, v22, v23);
    if (vabdd_f64(Current, v24) > 86400.0)
    {
      if (qword_1E929D760 != -1) {
        dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
      }
      char v25 = qword_1E929D768;
      if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_ERROR))
      {
        pid_t v26 = getpid();
        uint64_t v29 = objc_msgSend_startDate(*(void **)(a1 + 32), v27, v28);
        int buf = 67109378;
        *(_DWORD *)buf_4 = v26;
        *(_WORD *)&buf_4[4] = 2112;
        *(void *)&buf_4[6] = v29;
        _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_ERROR, "Attempting to request data older than 24 hours, pid, %d, startDate %@", (uint8_t *)&buf, 0x12u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1E929D760 != -1) {
          dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
        }
        pid_t v62 = getpid();
        uint64_t v65 = objc_msgSend_startDate(*(void **)(a1 + 32), v63, v64);
        *(_DWORD *)double v70 = 67109378;
        *(_DWORD *)&v70[4] = v62;
        *(_WORD *)&v70[8] = 2112;
        *(void *)&v70[10] = v65;
        double v66 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "-[CMNatalimeterInternal _queryAbsoluteNatalimetryDataSinceDataRecord:withHandler:]_block_invoke", "CoreLocation: %s\n", v66);
        if (v66 != (char *)&buf) {
          free(v66);
        }
      }
    }
  }
  v68[0] = @"CMNatalimetryNatalieDataStartDate";
  __int16 v30 = NSNumber;
  char v31 = objc_msgSend_startDate(*(void **)(a1 + 32), v15, v16);
  objc_msgSend_timeIntervalSinceReferenceDate(v31, v32, v33);
  v69[0] = objc_msgSend_numberWithDouble_(v30, v34, v35);
  v68[1] = @"CMNatalimetryNatalieDataMets";
  v69[1] = objc_msgSend_mets(*(void **)(a1 + 32), v36, v37);
  v68[2] = @"CMNatalimetryNatalieDataNatalies";
  v69[2] = objc_msgSend_natalies(*(void **)(a1 + 32), v38, v39);
  v68[3] = @"CMNatalimetryNatalieDataBasalNatalies";
  v69[3] = objc_msgSend_basalNatalies(*(void **)(a1 + 32), v40, v41);
  v68[4] = @"CMNatalimetrySessionId";
  __int16 v42 = NSNumber;
  uint64_t v45 = objc_msgSend_activityType(*(void **)(a1 + 32), v43, v44);
  v69[4] = objc_msgSend_numberWithInteger_(v42, v46, v45);
  v68[5] = @"CMNatalimetryRecordId";
  __int16 v47 = NSNumber;
  uint64_t v50 = objc_msgSend_recordId(*(void **)(a1 + 32), v48, v49);
  v69[5] = objc_msgSend_numberWithInteger_(v47, v51, v50);
  v68[6] = @"CMNatalimetryNatalieDataSourceId";
  uint64_t v54 = objc_msgSend_sourceId(*(void **)(a1 + 32), v52, v53);
  v69[6] = objc_msgSend_UUIDString(v54, v55, v56);
  *(void *)double v70 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v57, (uint64_t)v69, v68, 7);
  sub_1904EF0B0("kCLConnectionMessageNatalimetryQuery", v70, &buf);
  long long v67 = *(std::__shared_weak_count **)&buf_4[4];
  if (*(void *)&buf_4[4]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf_4[4] + 8), 1uLL, memory_order_relaxed);
  }
  CLConnectionClient::sendMessage();
  if (v67) {
    sub_1902D8B58(v67);
  }
  if (*(void *)&buf_4[4]) {
    sub_1902D8B58(*(std::__shared_weak_count **)&buf_4[4]);
  }
}

void sub_1904EC10C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,std::__shared_weak_count *a42)
{
  if (a19) {
    sub_1902D8B58(a19);
  }
  if (a42) {
    sub_1902D8B58(a42);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904EC138(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)a2 + 1);
  uint64_t v5 = *(void *)a2;
  uint64_t v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  objc_msgSend__handleQueryResponse_withHandler_(v3, a2, (uint64_t)&v5, *(void *)(a1 + 40));
  if (v6) {
    sub_1902D8B58(v6);
  }
}

void sub_1904EC194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904EC3C8(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_1904EC42C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

uint64_t sub_1904EC4A4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1904EC4BC(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

void sub_1904EC594(uint64_t a1)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 32);
  if (v3 != *(void **)(a1 + 40) || !*(unsigned char *)(v2 + 24))
  {

    *(void *)(*(void *)(a1 + 32) + 32) = objc_msgSend_copy(*(void **)(a1 + 40), v4, v5);
    sub_1902C3F54(&__p, "kCLConnectionMessageNatalimetryUpdate");
    v8[1] = MEMORY[0x1E4F143A8];
    void v8[2] = 3221225472;
    v8[3] = sub_1904EC788;
    v8[4] = &unk_1E568D558;
    v8[5] = *(void *)(a1 + 32);
    CLConnectionClient::setHandlerForMessage();
    if (v11 < 0) {
      operator delete(__p);
    }
    __int16 v12 = @"kCLConnectionMessageSubscribeKey";
    v13[0] = MEMORY[0x1E4F1CC38];
    v8[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v6, (uint64_t)v13, &v12, 1);
    sub_1904EF1FC("kCLConnectionMessageNatalimetryUpdate", v8, &__p);
    uint64_t v7 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v7) {
      sub_1902D8B58(v7);
    }
    *(unsigned char *)(*(void *)(a1 + 32) + 24) = 1;
    if (v10) {
      sub_1902D8B58(v10);
    }
  }
}

void sub_1904EC744(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a19) {
    sub_1902D8B58(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904EC788(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void **)(*(void *)(a1 + 32) + 32);
  if (v4)
  {
    id v6 = (id)objc_msgSend_copy(v4, a2, a3);
    uint64_t v7 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v8 = objc_opt_class();
    uint64_t v9 = objc_opt_class();
    uint64_t v10 = objc_opt_class();
    __int16 v12 = (NSSet *)objc_msgSend_setWithObjects_(v7, v11, v8, v9, v10, 0);
    if (!*(void *)a2
      || (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v12)) == 0)
    {
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = sub_1904ECAE8;
      block[3] = &unk_1E568D2D0;
      void block[4] = v6;
      uint64_t v19 = MEMORY[0x1E4F14428];
      uint64_t v20 = block;
      goto LABEL_7;
    }
    uint64_t v15 = DictionaryOfClasses;
    uint64_t v16 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v14, @"CMErrorMessage");
    uint64_t v18 = objc_msgSend_objectForKeyedSubscript_(v15, v17, @"CMNatalimetryNatalieData");
    if (v16)
    {
      *(unsigned char *)(*(void *)(a1 + 32) + 24) = 0;
      v25[0] = MEMORY[0x1E4F143A8];
      v25[1] = 3221225472;
      void v25[2] = sub_1904ECB4C;
      _OWORD v25[3] = &unk_1E568D320;
      v25[4] = v16;
      v25[5] = v6;
      uint64_t v19 = MEMORY[0x1E4F14428];
      uint64_t v20 = v25;
LABEL_7:
      dispatch_async(v19, v20);
      return;
    }
    if (v18)
    {
      v24[0] = MEMORY[0x1E4F143A8];
      v24[1] = 3221225472;
      v24[2] = sub_1904ECBC4;
      v24[3] = &unk_1E568D398;
      uint64_t v21 = *(void *)(a1 + 32);
      v24[4] = v18;
      void v24[5] = v21;
      void v24[6] = v6;
      uint64_t v19 = MEMORY[0x1E4F14428];
      uint64_t v20 = v24;
      goto LABEL_7;
    }
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
    }
    uint64_t v22 = qword_1E929D768;
    if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_FAULT, "Error parsing update.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D760 != -1) {
        dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
      }
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMNatalimeterInternal _startAbsoluteNatalimetryDataUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v23);
      if (v23 != (char *)buf) {
        free(v23);
      }
    }
  }
}

uint64_t sub_1904ECAE8(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_1904ECB4C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

uint64_t sub_1904ECBC4(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v5 = ExecutablePathFromPid;
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
    }
    id v6 = qword_1E929D768;
    if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_DEBUG))
    {
      pid_t v7 = getpid();
      uint64_t v8 = a1[4];
      uint64_t v9 = a1[5];
      *(_DWORD *)int buf = 138413058;
      uint64_t v13 = v5;
      __int16 v14 = 1024;
      pid_t v15 = v7;
      __int16 v16 = 2112;
      uint64_t v17 = v8;
      __int16 v18 = 2048;
      uint64_t v19 = v9;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEBUG, "%@, pid, %d, update, %@, %p", buf, 0x26u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D760 != -1) {
        dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
      }
      getpid();
      char v11 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMNatalimeterInternal _startAbsoluteNatalimetryDataUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
  }
  return (*(uint64_t (**)(void))(a1[6] + 16))();
}

void sub_1904ECE78(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  sub_1902C3F54(&__p, "kCLConnectionMessageNatalimetryUpdate");
  CLConnectionClient::setHandlerForMessage();
  if (v12 < 0) {
    operator delete(__p);
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v3 + 24) && *(void *)(v3 + 32))
  {
    uint64_t v8 = @"kCLConnectionMessageSubscribeKey";
    uint64_t v9 = MEMORY[0x1E4F1CC28];
    uint64_t v7 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v2, (uint64_t)&v9, &v8, 1);
    sub_1904EF1FC("kCLConnectionMessageNatalimetryUpdate", &v7, &__p);
    id v6 = v11;
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v6) {
      sub_1902D8B58(v6);
    }

    *(void *)(*(void *)(a1 + 32) + 32) = 0;
    *(unsigned char *)(*(void *)(a1 + 32) + 24) = 0;
    if (v11) {
      sub_1902D8B58(v11);
    }
  }
  else
  {
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
    }
    uint64_t v4 = qword_1E929D768;
    if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_INFO))
    {
      LOWORD(__p) = 0;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "Error stopping calorie updates, not active clients.", (uint8_t *)&__p, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_1E929D760 != -1) {
        dispatch_once(&qword_1E929D760, &unk_1EDFD2F40);
      }
      LOWORD(v7) = 0;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMNatalimeterInternal _stopAbsoluteNatalimetryDataUpdates]_block_invoke", "CoreLocation: %s\n", v5);
      if (v5 != (char *)&__p) {
        free(v5);
      }
    }
  }
}

void sub_1904ED100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, std::__shared_weak_count *a18, int a19, __int16 a20,char a21,char a22)
{
  if (a18) {
    sub_1902D8B58(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904ED50C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1902D8B58(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904ED65C(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__teardown(*(void **)(*(void *)(a1 + 32) + 8), a2, a3);
}

void sub_1904ED8B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_1902D8B58(a16);
  }
  objc_sync_exit(v16);
  _Unwind_Resume(a1);
}

void sub_1904EDCB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_1902D8B58(a15);
  }
  objc_sync_exit(v15);
  _Unwind_Resume(a1);
}

void sub_1904EE2A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_1902D8B58(a14);
  }
  objc_sync_exit(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_1904EE418(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 48);

  return MEMORY[0x1F4181798](v4, sel__queryAbsoluteNatalimetryDataSinceRecord_withHandler_, v5);
}

uint64_t sub_1904EE5A0(uint64_t a1, const char *a2)
{
  uint64_t result = objc_msgSend_isAuthorizedForEntitlement_(CMMotionUtils, a2, @"com.apple.locationd.activity");
  qword_1EB3BF308 = result;
  return result;
}

uint64_t sub_1904EE6A0(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__startAbsoluteNatalimetryDataUpdatesWithHandler_, v5);
}

uint64_t sub_1904EE754(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3);

  return MEMORY[0x1F4181798](v3, sel__stopAbsoluteNatalimetryDataUpdates, v4);
}

os_log_t sub_1904EF080()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Calorimetry");
  qword_1E929D768 = (uint64_t)result;
  return result;
}

void *sub_1904EF0B0@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  id v6 = operator new(0x70uLL);
  os_log_t result = sub_1904EF114(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1904EF100(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1904EF114(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_1904EF188((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_1904EF174(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1904EF188(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1904EF1E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1904EF1FC@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  id v6 = operator new(0x70uLL);
  os_log_t result = sub_1904EF260(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1904EF24C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1904EF260(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_1904EF2D4((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_1904EF2C0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1904EF2D4(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1904EF32C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1904EF348@<X0>(char *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x70uLL);
  os_log_t result = sub_1904EF3A4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1904EF390(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1904EF3A4(void *a1, char *__s)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_1904EF414((int)&v4, (uint64_t)(a1 + 3), __s);
  return a1;
}

void sub_1904EF400(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1904EF414(int a1, uint64_t a2, char *__s)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC410](a2, __p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1904EF464(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1904EF480@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  id v6 = operator new(0x70uLL);
  os_log_t result = sub_1904EF4E4(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1904EF4D0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1904EF4E4(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_1904EF558((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_1904EF544(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1904EF558(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1904EF5B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904EF5CC(uint64_t a1)
{
  uint64_t v2 = *(__IOHIDDevice **)a1;
  if (v2 && *(unsigned char *)(a1 + 8))
  {
    IOHIDDeviceClose(v2, 0);
    *(unsigned char *)(a1 + 8) = 0;
    uint64_t v2 = *(__IOHIDDevice **)a1;
  }

  return a1;
}

uint64_t sub_1904EF618()
{
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EB3BF320, memory_order_acquire) != -1)
  {
    uint64_t v3 = &v1;
    uint64_t v2 = &v3;
    std::__call_once(&qword_1EB3BF320, &v2, (void (__cdecl *)(void *))sub_1904EFC84);
  }
  return qword_1EB3BF318;
}

void *sub_1904EF680(uint64_t a1, const char *a2, uint64_t a3)
{
  char v4 = (IOHIDDeviceRef *)(a1 + 32);
  if (*(void *)(a1 + 32))
  {
    objc_msgSend_invalidate(*(void **)(a1 + 48), a2, a3);

    if (*v4)
    {
      if (*(unsigned char *)(a1 + 40))
      {
        IOHIDDeviceClose(*v4, 0);
        *(unsigned char *)(a1 + 40) = 0;
      }
    }
  }
  sub_1904EF5CC((uint64_t)v4);

  return sub_1904DC240((void *)a1);
}

void sub_1904EF6FC(uint64_t a1, const char *a2, uint64_t a3)
{
  sub_1904EF680(a1, a2, a3);

  JUMPOUT(0x192FCC980);
}

void sub_1904EF734(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(__IOHIDDevice **)(v1 + 32);
  if (v2)
  {
    if (!*(unsigned char *)(v1 + 40)) {
      __assert_rtn("lidAngle", "CLLidAngleNotifier.mm", 70, "fIsOpen");
    }
    pReportCFIndex Length = 5;
    IOReturn v3 = IOHIDDeviceGetReport(v2, kIOHIDReportTypeInput, 7, &report, &pReportLength);
    if (v3) {
      BOOL v5 = 0;
    }
    else {
      BOOL v5 = pReportLength == 5;
    }
    if (v5)
    {
      LODWORD(v4) = v11;
      *(double *)int buf = (double)v4 * 0.01;
      sub_1904DC8A8(v1, 0, (uint64_t)buf, 8);
    }
    else
    {
      IOReturn v6 = v3;
      if (qword_1E929DA28 != -1) {
        dispatch_once(&qword_1E929DA28, &unk_1EDFD1CE0);
      }
      char v7 = qword_1E929DA30;
      if (os_log_type_enabled((os_log_t)qword_1E929DA30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "std::optional<double> CLLidAngleNotifier::LidAngleSensor::lidAngle() const";
        __int16 v17 = 1026;
        IOReturn v18 = v6;
        _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_ERROR, "[LidAngleSensor] %{public}s; reading lid angle sensor failed with status = %{public}d",
          buf,
          0x12u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929DA28 != -1) {
          dispatch_once(&qword_1E929DA28, &unk_1EDFD1CE0);
        }
        int v12 = 136446466;
        uint64_t v13 = "std::optional<double> CLLidAngleNotifier::LidAngleSensor::lidAngle() const";
        __int16 v14 = 1026;
        IOReturn v15 = v6;
        uint64_t v8 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "std::optional<double> CLLidAngleNotifier::LidAngleSensor::lidAngle() const", "CoreLocation: %s\n", v8);
        if (v8 != buf) {
          free(v8);
        }
      }
    }
  }
}

void sub_1904EF990(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    if (a3)
    {
      if (a3 == 1)
      {
        unint64_t v4 = *(__IOHIDDevice **)(a1 + 32);
        if (v4)
        {
          if (!*(unsigned char *)(a1 + 40))
          {
            IOReturn v5 = IOHIDDeviceOpen(v4, 0);
            *(unsigned char *)(a1 + 40) = v5 == 0;
            if (!v5) {
              goto LABEL_14;
            }
            IOReturn v7 = v5;
            if (qword_1E929DA28 != -1) {
              dispatch_once(&qword_1E929DA28, &unk_1EDFD1CE0);
            }
            uint64_t v8 = qword_1E929DA30;
            if (os_log_type_enabled((os_log_t)qword_1E929DA30, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "BOOL CLLidAngleNotifier::LidAngleSensor::open()";
              *(_WORD *)&unsigned char buf[12] = 1026;
              *(_DWORD *)&buf[14] = v7;
              _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_ERROR, "[LidAngleSensor] %{public}s; opening lid angle sensor failed with status = %{public}d",
                buf,
                0x12u);
            }
            if (sub_1902D8400(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1E929DA28 != -1) {
                dispatch_once(&qword_1E929DA28, &unk_1EDFD1CE0);
              }
              __int16 v14 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 0, "BOOL CLLidAngleNotifier::LidAngleSensor::open()", "CoreLocation: %s\n", v14);
              if (v14 != buf) {
                free(v14);
              }
            }
            if (*(unsigned char *)(a1 + 40))
            {
LABEL_14:
              *(void *)int buf = MEMORY[0x1E4F143A8];
              *(void *)&uint8_t buf[8] = 3221225472;
              *(void *)&uint8_t buf[16] = sub_1904EF734;
              __int16 v16 = &unk_1E568E5B0;
              uint64_t v17 = a1;
              uint64_t v9 = objc_msgSend_scheduledTimerWithTimeInterval_repeats_block_(MEMORY[0x1E4F1CB00], v6, 1, buf, 0.033);
              *(void *)(a1 + 48) = v9;
              id v10 = v9;
              objc_msgSend_fire(*(void **)(a1 + 48), v11, v12);
            }
          }
        }
      }
    }
    else if (*(void *)(a1 + 32))
    {
      objc_msgSend_invalidate(*(void **)(a1 + 48), a2, 0);

      uint64_t v13 = *(__IOHIDDevice **)(a1 + 32);
      if (v13)
      {
        if (*(unsigned char *)(a1 + 40))
        {
          IOHIDDeviceClose(v13, 0);
          *(unsigned char *)(a1 + 40) = 0;
        }
      }
    }
  }
}

os_log_t sub_1904EFC54()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "DisplayGravity");
  qword_1E929DA30 = (uint64_t)result;
  return result;
}

void sub_1904EFC84()
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v0 = IOHIDManagerCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (v0)
  {
    uint64_t v1 = v0;
    IOReturn v2 = IOHIDManagerOpen(v0, 0);
    if (v2)
    {
      IOReturn v3 = v2;
      if (qword_1E929DA28 != -1) {
        dispatch_once(&qword_1E929DA28, &unk_1EDFD1CE0);
      }
      unint64_t v4 = qword_1E929DA30;
      if (os_log_type_enabled((os_log_t)qword_1E929DA30, OS_LOG_TYPE_ERROR))
      {
        int buf = 136446466;
        buf_4 = "IOHIDDeviceRef lidAngleSensorDevice()";
        __int16 v12 = 1026;
        IOReturn v13 = v3;
        _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_ERROR, "[LidAngleSensor] %{public}s; opening HID manager failed with status = %{public}d",
          (uint8_t *)&buf,
          0x12u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1E929DA28 != -1) {
          dispatch_once(&qword_1E929DA28, &unk_1EDFD1CE0);
        }
        uint64_t v9 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "IOHIDDeviceRef lidAngleSensorDevice()", "CoreLocation: %s\n", v9);
        if (v9 != (char *)&buf) {
          free(v9);
        }
      }
      CFRelease(v1);
    }
    else
    {
      IOHIDManagerSetDeviceMatching(v1, (CFDictionaryRef)&unk_1EE001B88);
      CFSetRef v5 = IOHIDManagerCopyDevices(v1);
      id v8 = (id)objc_msgSend_anyObject(v5, v6, v7);
      IOHIDManagerClose(v1, 0);
      CFRelease(v1);

      if (v8) {
        operator new();
      }
    }
  }
}

void sub_1904EFF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1904EF5CC((uint64_t)va);
  MEMORY[0x192FCC980](v7, 0x10F1C40B49A3D6ELL);
  _Unwind_Resume(a1);
}

void sub_1904EFF90(void *a1@<X8>)
{
  v21[9] = *MEMORY[0x1E4F143B8];
  IOReturn v2 = operator new(0xF0uLL);
  v2[12] = xmmword_19060ABB0;
  v2[13] = unk_19060ABC0;
  v2[14] = xmmword_19060ABD0;
  v2[8] = xmmword_19060AB70;
  v2[9] = unk_19060AB80;
  v2[10] = xmmword_19060AB90;
  v2[11] = unk_19060ABA0;
  v2[4] = xmmword_19060AB30;
  v2[5] = unk_19060AB40;
  v2[6] = xmmword_19060AB50;
  v2[7] = unk_19060AB60;
  _OWORD *v2 = xmmword_19060AAF0;
  v2[1] = unk_19060AB00;
  v2[2] = xmmword_19060AB10;
  v2[3] = unk_19060AB20;
  v21[0] = v2;
  v21[1] = v2 + 15;
  void v21[2] = v2 + 15;
  IOReturn v3 = operator new(0xF0uLL);
  v3[12] = xmmword_19060ACA0;
  v3[13] = unk_19060ACB0;
  v3[14] = xmmword_19060ACC0;
  v3[8] = xmmword_19060AC60;
  v3[9] = unk_19060AC70;
  v3[10] = xmmword_19060AC80;
  v3[11] = unk_19060AC90;
  v3[4] = xmmword_19060AC20;
  void v3[5] = unk_19060AC30;
  v3[6] = xmmword_19060AC40;
  v3[7] = unk_19060AC50;
  _OWORD *v3 = xmmword_19060ABE0;
  v3[1] = unk_19060ABF0;
  _OWORD v3[2] = xmmword_19060AC00;
  v3[3] = unk_19060AC10;
  _DWORD v21[3] = v3;
  v21[4] = v3 + 15;
  void v21[5] = v3 + 15;
  unint64_t v4 = operator new(0xF0uLL);
  v21[8] = v4 + 15;
  v4[12] = xmmword_19060AD90;
  v4[13] = unk_19060ADA0;
  v4[14] = xmmword_19060ADB0;
  v4[8] = xmmword_19060AD50;
  v4[9] = unk_19060AD60;
  v4[10] = xmmword_19060AD70;
  v4[11] = unk_19060AD80;
  v4[4] = xmmword_19060AD10;
  void v4[5] = unk_19060AD20;
  void v4[6] = xmmword_19060AD30;
  v4[7] = unk_19060AD40;
  *unint64_t v4 = xmmword_19060ACD0;
  v4[1] = unk_19060ACE0;
  _DWORD v4[2] = xmmword_19060ACF0;
  v4[3] = unk_19060AD00;
  void v21[6] = v4;
  v21[7] = v4 + 15;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  CFSetRef v5 = (char *)operator new(0x48uLL);
  uint64_t v6 = 0;
  *a1 = v5;
  a1[1] = v5;
  __int16 v16 = a1;
  a1[2] = v5 + 72;
  uint64_t v19 = v5;
  uint64_t v20 = v5;
  v17[0] = a1 + 2;
  v17[1] = &v19;
  void v17[2] = &v20;
  char v18 = 0;
  do
  {
    uint64_t v7 = &v5[v6 * 8];
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = 0;
    uint64_t v9 = (unsigned char *)v21[v6];
    id v8 = (unsigned char *)v21[v6 + 1];
    int64_t v10 = v8 - v9;
    if (v8 != v9)
    {
      if (0xAAAAAAAAAAAAAAABLL * (v10 >> 4) >= 0x555555555555556) {
        sub_1903479E8();
      }
      int v11 = (char *)operator new(v10);
      __int16 v12 = &v5[v6 * 8];
      *(void *)__int16 v12 = v11;
      *((void *)v12 + 1) = v11;
      IOReturn v13 = &v11[16 * (v10 >> 4)];
      *((void *)v12 + 2) = v13;
      memcpy(v11, v9, v10);
      *((void *)v12 + 1) = v13;
    }
    uint64_t v20 = v7 + 24;
    v6 += 3;
  }
  while (v6 != 9);
  char v18 = 1;
  sub_1904F0FC0((uint64_t)v17);
  uint64_t v14 = 0;
  v16[1] = v5 + 72;
  do
  {
    IOReturn v15 = (void *)v21[v14 + 6];
    if (v15)
    {
      v21[v14 + 7] = v15;
      operator delete(v15);
    }
    v14 -= 3;
  }
  while (v14 != -9);
}

void sub_1904F0244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  sub_1904F1028(&a10);
  uint64_t v19 = 0;
  while (1)
  {
    uint64_t v20 = *(void **)(&a18 + v19 + 48);
    if (v20)
    {
      *(void *)(&a18 + v19 + 56) = v20;
      operator delete(v20);
    }
    v19 -= 24;
    if (v19 == -72) {
      _Unwind_Resume(a1);
    }
  }
}

void sub_1904F02E4(uint64_t *a1@<X0>, void **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (a1[1] != *a1)
  {
    IOReturn v3 = a1;
    unint64_t v4 = 0;
    uint64_t v32 = (uint64_t)(a2 + 2);
    do
    {
      int v5 = sub_1904F059C(v4);
      uint64_t v6 = *v3;
      if (*(void *)(*v3 + 24 * v4 + 8) != *(void *)(*v3 + 24 * v4))
      {
        int v7 = v5;
        unint64_t v8 = 0;
        unint64_t v31 = v4;
        do
        {
          unint64_t v9 = sub_1904F0764(v8);
          int v10 = v9;
          unint64_t v11 = HIDWORD(v9);
          __int16 v12 = (uint64_t *)(*(void *)(*v3 + 24 * v4) + 48 * v8);
          IOReturn v13 = &dword_19060ADC0;
          do
          {
            int v14 = *v13;
            uint64_t v15 = *v12;
            uint64_t v16 = v12[2];
            switch(*v13)
            {
              case 0:
                break;
              case 1:
                uint64_t v15 = v12[2];
                uint64_t v16 = v12[3];
                break;
              case 2:
                uint64_t v15 = v12[3];
                uint64_t v16 = v12[4];
                break;
              case 3:
                uint64_t v16 = v12[5];
                uint64_t v15 = v12[4];
                break;
              default:
                uint64_t v15 = 0;
                uint64_t v16 = 0;
                break;
            }
            char v18 = (char *)a2[1];
            uint64_t v17 = (char *)a2[2];
            if (v18 >= v17)
            {
              uint64_t v20 = (char *)*a2;
              uint64_t v21 = (v18 - (unsigned char *)*a2) >> 5;
              unint64_t v22 = v21 + 1;
              if ((unint64_t)(v21 + 1) >> 59) {
                sub_1903479E8();
              }
              uint64_t v23 = v17 - v20;
              if (v23 >> 4 > v22) {
                unint64_t v22 = v23 >> 4;
              }
              if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v24 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v24 = v22;
              }
              if (v24)
              {
                char v25 = (char *)sub_1904F10D4(v32, v24);
                uint64_t v20 = (char *)*a2;
                char v18 = (char *)a2[1];
              }
              else
              {
                char v25 = 0;
              }
              pid_t v26 = &v25[32 * v21];
              *(_DWORD *)pid_t v26 = v7;
              *((_DWORD *)v26 + 1) = v10;
              *((_DWORD *)v26 + 2) = v11;
              *((_DWORD *)v26 + 3) = v14;
              *((void *)v26 + 2) = v15;
              *((void *)v26 + 3) = v16;
              if (v18 == v20)
              {
                uint64_t v29 = &v25[32 * v21];
              }
              else
              {
                unsigned __int8 v27 = &v25[32 * v21];
                do
                {
                  long long v28 = *((_OWORD *)v18 - 1);
                  uint64_t v29 = v27 - 32;
                  *((_OWORD *)v27 - 2) = *((_OWORD *)v18 - 2);
                  *((_OWORD *)v27 - 1) = v28;
                  v18 -= 32;
                  v27 -= 32;
                }
                while (v18 != v20);
              }
              uint64_t v19 = v26 + 32;
              *a2 = v29;
              a2[1] = v26 + 32;
              a2[2] = &v25[32 * v24];
              if (v20) {
                operator delete(v20);
              }
            }
            else
            {
              *(_DWORD *)char v18 = v7;
              *((_DWORD *)v18 + 1) = v10;
              *((_DWORD *)v18 + 2) = v11;
              *((_DWORD *)v18 + 3) = v14;
              uint64_t v19 = v18 + 32;
              *((void *)v18 + 2) = v15;
              *((void *)v18 + 3) = v16;
            }
            a2[1] = v19;
            ++v13;
          }
          while (v13 != (int *)qword_19060ADD0);
          ++v8;
          IOReturn v3 = a1;
          unint64_t v4 = v31;
          uint64_t v6 = *a1;
        }
        while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(*a1 + 24 * v31 + 8) - *(void *)(*a1 + 24 * v31)) >> 4) > v8);
      }
      ++v4;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((v3[1] - v6) >> 3) > v4);
  }
}

void sub_1904F0564(_Unwind_Exception *exception_object)
{
  IOReturn v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904F059C(unsigned int a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a1 < 3) {
    return a1 + 1;
  }
  if (qword_1E929D928 != -1) {
    dispatch_once(&qword_1E929D928, &unk_1EDFD1D00);
  }
  IOReturn v3 = qword_1E929D930;
  if (os_log_type_enabled((os_log_t)qword_1E929D930, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)int buf = 67174657;
    unsigned int v7 = a1;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_FAULT, "VO2MaxClassifier: Invalid biologicalSex index %{private}d", buf, 8u);
  }
  int v4 = sub_1902D8400(115, 0);
  uint64_t result = 0;
  if (v4)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D928 != -1) {
      dispatch_once(&qword_1E929D928, &unk_1EDFD1D00);
    }
    int v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "static CLHKBiologicalSex CLVO2MaxClassifier::getBiologicalSexFromIndex(int)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1904F0764(unsigned int a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1 >= 5)
  {
    if (qword_1E929D928 != -1) {
      dispatch_once(&qword_1E929D928, &unk_1EDFD1D00);
    }
    int v4 = qword_1E929D930;
    if (os_log_type_enabled((os_log_t)qword_1E929D930, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 67240192;
      unsigned int v8 = a1;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "Invalid age index: %{public}d", buf, 8u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D928 != -1) {
        dispatch_once(&qword_1E929D928, &unk_1EDFD1D00);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "static std::pair<int, int> CLVO2MaxClassifier::getAgeRangeFromIndex(int)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
    uint64_t v2 = 0;
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v2 = 10 * a1 + 20;
    uint64_t v3 = qword_19060ADD0[a1];
  }
  return v3 | v2;
}

unint64_t sub_1904F0940@<X0>(void *a1@<X0>, int a2@<W1>, unsigned int a3@<W2>, char **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  switch(a2)
  {
    case 0:
    case 3:
      unsigned int v6 = 2;
      goto LABEL_4;
    case 1:
      unsigned int v6 = 0;
LABEL_4:
      int v7 = 1;
      break;
    case 2:
      int v7 = 1;
      unsigned int v6 = 1;
      break;
    default:
      int v7 = 0;
      unsigned int v6 = -1;
      break;
  }
  unint64_t result = sub_1904F0C0C(a3);
  unsigned int v9 = result;
  if (result == -1) {
    int v10 = 0;
  }
  else {
    int v10 = v7;
  }
  if (v10 == 1)
  {
    uint64_t v11 = sub_1904F059C(v6);
    unint64_t result = sub_1904F0764(v9);
    __int16 v12 = 0;
    unint64_t v13 = HIDWORD(result);
    int v14 = (uint64_t *)(*(void *)(*a1 + 24 * v6) + 48 * v9);
    uint64_t v15 = a4 + 2;
    uint64_t v16 = &dword_19060ADC0;
    do
    {
      int v17 = *v16;
      uint64_t v18 = *v14;
      uint64_t v19 = v14[2];
      switch(*v16)
      {
        case 0:
          break;
        case 1:
          uint64_t v18 = v14[2];
          uint64_t v19 = v14[3];
          break;
        case 2:
          uint64_t v18 = v14[3];
          uint64_t v19 = v14[4];
          break;
        case 3:
          uint64_t v19 = v14[5];
          uint64_t v18 = v14[4];
          break;
        default:
          uint64_t v18 = 0;
          uint64_t v19 = 0;
          break;
      }
      if ((unint64_t)v12 >= *v15)
      {
        unint64_t v20 = result;
        uint64_t v21 = v11;
        unint64_t v22 = *a4;
        uint64_t v23 = (v12 - *a4) >> 5;
        unint64_t v24 = v23 + 1;
        if ((unint64_t)(v23 + 1) >> 59) {
          sub_1903479E8();
        }
        uint64_t v25 = *v15 - (void)v22;
        if (v25 >> 4 > v24) {
          unint64_t v24 = v25 >> 4;
        }
        if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v26 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v26 = v24;
        }
        if (v26)
        {
          unsigned __int8 v27 = (char *)sub_1904F10D4((uint64_t)v15, v26);
          unint64_t v22 = *a4;
          __int16 v12 = a4[1];
          uint64_t v15 = a4 + 2;
        }
        else
        {
          unsigned __int8 v27 = 0;
        }
        long long v28 = &v27[32 * v23];
        uint64_t v11 = v21;
        *(_DWORD *)long long v28 = v21;
        *((_DWORD *)v28 + 1) = v20;
        *((_DWORD *)v28 + 2) = v13;
        *((_DWORD *)v28 + 3) = v17;
        *((void *)v28 + 2) = v18;
        *((void *)v28 + 3) = v19;
        if (v12 == v22)
        {
          unint64_t v31 = v28;
        }
        else
        {
          uint64_t v29 = v28;
          do
          {
            long long v30 = *((_OWORD *)v12 - 1);
            unint64_t v31 = v29 - 32;
            *((_OWORD *)v29 - 2) = *((_OWORD *)v12 - 2);
            *((_OWORD *)v29 - 1) = v30;
            v12 -= 32;
            v29 -= 32;
          }
          while (v12 != v22);
        }
        __int16 v12 = v28 + 32;
        *a4 = v31;
        a4[1] = v28 + 32;
        a4[2] = &v27[32 * v26];
        if (v22)
        {
          operator delete(v22);
          uint64_t v15 = a4 + 2;
        }
        unint64_t result = v20;
      }
      else
      {
        *(_DWORD *)__int16 v12 = v11;
        *((_DWORD *)v12 + 1) = result;
        *((_DWORD *)v12 + 2) = v13;
        *((_DWORD *)v12 + 3) = v17;
        *((void *)v12 + 2) = v18;
        *((void *)v12 + 3) = v19;
        v12 += 32;
      }
      a4[1] = v12;
      ++v16;
    }
    while (v16 != (int *)qword_19060ADD0);
  }
  return result;
}

void sub_1904F0BC0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904F0C0C(unsigned int a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a1 - 20 >= 0xB5)
  {
    if (qword_1E929D928 != -1) {
      dispatch_once(&qword_1E929D928, &unk_1EDFD1D00);
    }
    unsigned int v6 = qword_1E929D930;
    if (os_log_type_enabled((os_log_t)qword_1E929D930, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 67174657;
      unsigned int v9 = a1;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_ERROR, "Invalid parameter in getIndexFromAge: %{private}d", buf, 8u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D928 != -1) {
        dispatch_once(&qword_1E929D928, &unk_1EDFD1D00);
      }
      int v7 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "static int CLVO2MaxClassifier::getIndexFromAge(int)", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    if (a1 < 0x3C) {
      int v2 = 3;
    }
    else {
      int v2 = 4;
    }
    if (a1 >= 0x32) {
      int v3 = v2;
    }
    else {
      int v3 = 2;
    }
    if (a1 >= 0x28) {
      unsigned int v4 = v3;
    }
    else {
      unsigned int v4 = 1;
    }
    if (a1 >= 0x1E) {
      return v4;
    }
    else {
      return 0;
    }
  }
}

uint64_t sub_1904F0DF8@<X0>(void *a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t *a4@<X8>, double a5@<D0>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if (a2 >= 4)
  {
    return sub_1904F0C0C(a3);
  }
  else
  {
    unsigned int v8 = dword_19060AE00[a2];
    uint64_t result = sub_1904F0C0C(a3);
    if (result != -1)
    {
      unsigned int v10 = result;
      int v11 = sub_1904F059C(v8);
      unint64_t v12 = sub_1904F0764(v10);
      int v13 = v12;
      uint64_t v14 = 0;
      uint64_t v15 = *(void *)(*a1 + 24 * v8) + 48 * v10;
      do
      {
        int v16 = dword_19060ADC0[v14];
        uint64_t v17 = *(void *)v15;
        double v18 = *(double *)(v15 + 16);
        switch(v16)
        {
          case 0:
            break;
          case 1:
            uint64_t v17 = *(void *)(v15 + 16);
            double v18 = *(double *)(v15 + 24);
            break;
          case 2:
            uint64_t v17 = *(void *)(v15 + 24);
            double v18 = *(double *)(v15 + 32);
            break;
          case 3:
            double v18 = *(double *)(v15 + 40);
            uint64_t v17 = *(void *)(v15 + 32);
            break;
          default:
            uint64_t v17 = 0;
            double v18 = 0.0;
            break;
        }
      }
      while (v18 <= a5 && v14++ != 3);
      unint64_t v20 = HIDWORD(v12);
      uint64_t result = (uint64_t)operator new(0x20uLL);
      *(_DWORD *)uint64_t result = v11;
      *(_DWORD *)(result + 4) = v13;
      *(_DWORD *)(result + 8) = v20;
      *(_DWORD *)(result + 12) = v16;
      *(void *)(result + 16) = v17;
      *(double *)(result + 24) = v18;
      a4[1] = result + 32;
      a4[2] = result + 32;
      *a4 = result;
    }
  }
  return result;
}

os_log_t sub_1904F0F90()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Health");
  qword_1E929D930 = (uint64_t)result;
  return result;
}

uint64_t sub_1904F0FC0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v2 = **(void **)(a1 + 8);
    uint64_t v3 = **(void **)(a1 + 16);
    if (v3 != v2)
    {
      uint64_t v4 = **(void **)(a1 + 16);
      do
      {
        unsigned int v6 = *(void **)(v4 - 24);
        v4 -= 24;
        int v5 = v6;
        if (v6)
        {
          *(void *)(v3 - 16) = v5;
          operator delete(v5);
        }
        uint64_t v3 = v4;
      }
      while (v4 != v2);
    }
  }
  return a1;
}

void sub_1904F1028(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1904F107C((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_1904F107C(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      unsigned int v6 = *(void **)(v4 - 24);
      v4 -= 24;
      int v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void *sub_1904F10D4(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_190347AC8();
  }
  return operator new(32 * a2);
}

float sub_1904F110C(uint64_t a1, double *a2)
{
  double v3 = *a2;
  double v2 = a2[1];
  float v4 = v2 + v2;
  double v5 = a2[2];
  double v6 = a2[3];
  float v7 = v5 + v5;
  float v8 = v6 + v6;
  double v9 = v4;
  float v10 = v2 * v9;
  double v11 = v7;
  float v12 = v5 * v11;
  double v13 = v8;
  *(float *)&double v6 = v6 * v13;
  double v14 = v12;
  double v15 = 1.0 - v10;
  double v16 = *(float *)&v6;
  float v17 = 1.0 - v14 - v16;
  *(float *)&double v16 = v15 - v16;
  *(float *)&double v15 = v15 - v14;
  *(_DWORD *)(a1 + 32) = LODWORD(v15);
  *(float *)&double v5 = v5 * v13;
  *(float *)&double v9 = v3 * v9;
  *(float *)&double v15 = *(float *)&v5 - *(float *)&v9;
  *(_DWORD *)(a1 + 16) = LODWORD(v16);
  *(float *)(a1 + 20) = *(float *)&v5 + *(float *)&v9;
  *(float *)&double v9 = v2 * v11;
  *(float *)&double v5 = v3 * v13;
  *(float *)a1 = v17;
  *(float *)(a1 + 4) = *(float *)&v9 + *(float *)&v5;
  *(float *)&double v2 = v2 * v13;
  *(float *)&double v3 = v3 * v11;
  *(float *)(a1 + 8) = *(float *)&v2 - *(float *)&v3;
  *(float *)(a1 + 12) = *(float *)&v9 - *(float *)&v5;
  float result = *(float *)&v2 + *(float *)&v3;
  *(float *)(a1 + 24) = result;
  *(_DWORD *)(a1 + 28) = LODWORD(v15);
  return result;
}

long double sub_1904F11E0(double *a1)
{
  double v1 = a1[2];
  return -atan2(a1[1] * (a1[3] + a1[3]) - *a1 * (v1 + v1), 1.0 - a1[1] * (a1[1] + a1[1]) - v1 * (v1 + v1));
}

long double sub_1904F1224(double *a1)
{
  double v1 = a1[3];
  return -atan2(a1[1] * (a1[2] + a1[2]) - *a1 * (v1 + v1), 1.0 - a1[1] * (a1[1] + a1[1]) - v1 * (v1 + v1));
}

double sub_1904F1268(double *a1, double *a2)
{
  return *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2] - a1[3] * a2[3];
}

double sub_1904F12BC(double *a1, double *a2)
{
  double v2 = *a2;
  double v3 = a2[1];
  double v4 = v2 + v2;
  double v5 = v3 + v3;
  double v6 = a2[2];
  double v7 = v6 + v6;
  double v8 = v3 * (v3 + v3);
  double v9 = v6 * (v6 + v6);
  *a1 = 1.0 - v8 - v9;
  double v10 = 1.0 - v2 * (v2 + v2);
  a1[4] = v10 - v9;
  a1[8] = v10 - v8;
  double v11 = v7 * a2[1];
  double v12 = v4 * a2[3];
  a1[7] = v11 - v12;
  a1[5] = v11 + v12;
  double v13 = v5 * *a2;
  double v14 = v7 * a2[3];
  a1[3] = v13 - v14;
  a1[1] = v13 + v14;
  double v15 = v7 * *a2;
  double v16 = v5 * a2[3];
  a1[2] = v15 - v16;
  double result = v15 + v16;
  a1[6] = result;
  return result;
}

uint64_t sub_1904F1364(uint64_t result, double *a2, double *a3, double *a4)
{
  double v4 = sqrt(*a3 * *a3 + *a2 * *a2 + *a4 * *a4);
  double v5 = -*a3 / v4;
  *(double *)double result = v5;
  double v6 = *a2 / v4;
  *(double *)(result + 8) = v6;
  *(void *)(result + 16) = 0;
  double v7 = sqrt((1.0 - *a4 / v4) * 0.5);
  *(double *)(result + 24) = v7;
  double v8 = v6 * v6 + v5 * v5;
  if (v8 <= 0.000001)
  {
    if (*a4 <= 0.0)
    {
      *(void *)double result = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      *(void *)(result + 24) = 0x3FF0000000000000;
    }
    else
    {
      *(void *)double result = 0x3FF0000000000000;
      *(void *)(result + 16) = 0;
      *(void *)(result + 24) = 0;
      *(void *)(result + 8) = 0;
    }
  }
  else
  {
    double v9 = sqrt((1.0 - v7 * v7) / v8);
    *(double *)double result = v5 * v9;
    *(float64x2_t *)(result + 8) = vmulq_n_f64((float64x2_t)*(unint64_t *)&v6, v9);
  }
  return result;
}

void sub_1904F1430(uint64_t a1, float a2, double a3)
{
  if (a3 >= 0.0)
  {
    v23[4] = v8;
    v23[5] = v7;
    void v23[6] = v6;
    v23[7] = v5;
    v23[10] = v3;
    v23[11] = v4;
    double v11 = *(double *)(a1 + 16);
    double v12 = *(double *)(a1 + 24) + *(double *)(a1 + 24);
    double v13 = *(double *)(a1 + 8);
    float v14 = v13 * v12 - *(double *)a1 * (v11 + v11);
    float v15 = (v13 + v13) * *(double *)a1 + v11 * v12;
    float v16 = 1.0 - v13 * (v13 + v13) - v11 * (v11 + v11);
    __double2 v17 = __sincos_stret(a2 * -0.5 * 0.0174532924);
    v23[0] = v17.__cosval;
    v23[1] = v17.__sinval * v14;
    v23[2] = v17.__sinval * v15;
    _DWORD v23[3] = v17.__sinval * v16;
    sub_1902DAB58((double *)v22, v23, (double *)a1);
    long long v18 = v22[1];
    *(_OWORD *)a1 = v22[0];
    *(_OWORD *)(a1 + 16) = v18;
    float v19 = *(float *)(a1 + 76);
    if (v19 >= 0.0)
    {
      float v20 = v19 + a2;
      *(float *)(a1 + 76) = v20;
      float v21 = 360.0;
      if (v20 >= 360.0)
      {
        float v21 = -360.0;
      }
      else if (v20 >= 0.0)
      {
        return;
      }
      *(float *)(a1 + 76) = v20 + v21;
    }
  }
}

double sub_1904F1548(double *a1, float *a2, float *a3, float *a4)
{
  a1[1] = 0.0;
  a1[2] = 0.0;
  double v4 = a1 + 2;
  a1[3] = 0.0;
  double v5 = a1 + 3;
  *a1 = 1.0;
  float v6 = *a2;
  float v7 = a3[1];
  float v8 = a4[2];
  if (*a2 <= v7 || v6 <= v8)
  {
    if (v7 <= v6 || v7 <= v8)
    {
      double v11 = sqrt(v8 + 1.0 - v6 - v7);
      double result = v11 + v11;
      if (result <= 1.0e-10) {
        return result;
      }
      float v13 = a2[2];
      float v14 = *a3 - a2[1];
      float v15 = *a4;
      a1[3] = result * 0.25;
      *a1 = v14 / result;
      a1[1] = (float)(v15 + v13) / result;
      float v16 = a3 + 2;
      a3 = a4 + 1;
      a4 = v16;
      double v5 = v4;
    }
    else
    {
      double v18 = sqrt(v7 + 1.0 - v8 - v6);
      double result = v18 + v18;
      if (result <= 1.0e-10) {
        return result;
      }
      float v19 = a4[1];
      *a1 = (float)(a2[2] - *a4) / result;
      double v20 = (float)(a3[2] + v19) / result;
      a1[2] = result * 0.25;
      a1[3] = v20;
      a4 = a2 + 1;
      double v5 = a1 + 1;
    }
  }
  else
  {
    double v17 = sqrt(v6 + 1.0 - v7 - v8);
    double result = v17 + v17;
    if (result <= 1.0e-10) {
      return result;
    }
    *a1 = (float)(a4[1] - a3[2]) / result;
    a1[1] = result * 0.25;
    a1[2] = (float)(a2[1] + *a3) / result;
    a3 = a2 + 2;
  }
  double result = (float)(*a4 + *a3) / result;
  *double v5 = result;
  return result;
}

uint64_t sub_1904F1708@<X0>(int a1@<W0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (a1 > 65663)
  {
    if (a1 > 589887)
    {
      if (a1 > 851979)
      {
        if (a1 >= 0x100000)
        {
          if (a1 == 0x100000)
          {
            double v2 = "kTypeMachineWorkout";
            return MEMORY[0x192FCC770](a2, v2);
          }
          if (a1 == 0x200000)
          {
            double v2 = "kTypeWorkout";
            return MEMORY[0x192FCC770](a2, v2);
          }
        }
        else
        {
          if (a1 == 851980)
          {
            double v2 = "kTypeSemiStationaryPocket";
            return MEMORY[0x192FCC770](a2, v2);
          }
          if (a1 == 917516)
          {
            double v2 = "kTypeSemiStationaryArm";
            return MEMORY[0x192FCC770](a2, v2);
          }
        }
      }
      else if (a1 > 720911)
      {
        if (a1 == 720912)
        {
          double v2 = "kTypeWalkingLeg";
          return MEMORY[0x192FCC770](a2, v2);
        }
        if (a1 == 786448)
        {
          double v2 = "kTypeWalkingArm";
          return MEMORY[0x192FCC770](a2, v2);
        }
      }
      else
      {
        if (a1 == 589888)
        {
          double v2 = "kTypeRunningLeg";
          return MEMORY[0x192FCC770](a2, v2);
        }
        if (a1 == 655424)
        {
          double v2 = "kTypeRunningArm";
          return MEMORY[0x192FCC770](a2, v2);
        }
      }
    }
    else if (a1 > 327807)
    {
      if (a1 >= 462848)
      {
        if (a1 == 462848)
        {
          double v2 = "kTypeDrivingArm";
          return MEMORY[0x192FCC770](a2, v2);
        }
        if (a1 == 528384)
        {
          double v2 = "kTypeDrivingStowed";
          return MEMORY[0x192FCC770](a2, v2);
        }
      }
      else
      {
        if (a1 == 327808)
        {
          double v2 = "kTypeCyclingTorso";
          return MEMORY[0x192FCC770](a2, v2);
        }
        if (a1 == 397312)
        {
          double v2 = "kTypeDrivingSeat";
          return MEMORY[0x192FCC770](a2, v2);
        }
      }
    }
    else if (a1 >= 196608)
    {
      if (a1 == 196608)
      {
        double v2 = "kTypeCyclingLeg";
        return MEMORY[0x192FCC770](a2, v2);
      }
      if (a1 == 262272)
      {
        double v2 = "kTypeCyclingArm";
        return MEMORY[0x192FCC770](a2, v2);
      }
    }
    else
    {
      if (a1 == 65664)
      {
        double v2 = "kTypeCyclingSeat";
        return MEMORY[0x192FCC770](a2, v2);
      }
      if (a1 == 131200)
      {
        double v2 = "kTypeCyclingChassis";
        return MEMORY[0x192FCC770](a2, v2);
      }
    }
LABEL_63:
    double v2 = "ERROR";
    return MEMORY[0x192FCC770](a2, v2);
  }
  if (a1 > 255)
  {
    if (a1 >= 0x2000)
    {
      if (a1 >= 0x4000)
      {
        if (a1 == 0x4000)
        {
          double v2 = "kTypeDrivingMounted";
          return MEMORY[0x192FCC770](a2, v2);
        }
        if (a1 == 0x8000)
        {
          double v2 = "kTypeMotorcycle";
          return MEMORY[0x192FCC770](a2, v2);
        }
      }
      else
      {
        if (a1 == 0x2000)
        {
          double v2 = "kTypeVehicularInHand";
          return MEMORY[0x192FCC770](a2, v2);
        }
        if (a1 == 12288)
        {
          double v2 = "kTypeDrivingOther";
          return MEMORY[0x192FCC770](a2, v2);
        }
      }
    }
    else if (a1 > 4095)
    {
      if (a1 == 4096)
      {
        double v2 = "kTypeDriving";
        return MEMORY[0x192FCC770](a2, v2);
      }
      if (a1 == 4128)
      {
        double v2 = "kTypeDrivingOrWalkingSlow";
        return MEMORY[0x192FCC770](a2, v2);
      }
    }
    else
    {
      if (a1 == 256)
      {
        double v2 = "kTypeInVehicleFrozen";
        return MEMORY[0x192FCC770](a2, v2);
      }
      if (a1 == 512)
      {
        double v2 = "kTypeInVehicleStatic";
        return MEMORY[0x192FCC770](a2, v2);
      }
    }
    goto LABEL_63;
  }
  if (a1 > 15)
  {
    if (a1 > 63)
    {
      if (a1 == 64)
      {
        double v2 = "kTypeRunning";
        return MEMORY[0x192FCC770](a2, v2);
      }
      if (a1 == 128)
      {
        double v2 = "kTypeCycling";
        return MEMORY[0x192FCC770](a2, v2);
      }
    }
    else
    {
      if (a1 == 16)
      {
        double v2 = "kTypeWalking";
        return MEMORY[0x192FCC770](a2, v2);
      }
      if (a1 == 32)
      {
        double v2 = "kTypeWalkingSlow";
        return MEMORY[0x192FCC770](a2, v2);
      }
    }
    goto LABEL_63;
  }
  double v2 = "kTypeFrozen";
  switch(a1)
  {
    case 0:
      double v2 = "kTypeUnknown";
      break;
    case 1:
      return MEMORY[0x192FCC770](a2, v2);
    case 2:
      double v2 = "kTypeStatic";
      break;
    case 3:
      goto LABEL_63;
    case 4:
      double v2 = "kTypeMoving";
      break;
    default:
      if (a1 != 12) {
        goto LABEL_63;
      }
      double v2 = "kTypeSemiStationary";
      break;
  }
  return MEMORY[0x192FCC770](a2, v2);
}

void sub_1904F1AB8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1904F1AE8(uint64_t a1)
{
  *(void *)a1 = &unk_1EDFCA1E0;
  sub_1904F1B5C(a1, 0, 0);
  dispatch_release(*(dispatch_object_t *)(a1 + 208));
  double v2 = *(std::__shared_weak_count **)(a1 + 224);
  if (v2) {
    sub_1902D8B58(v2);
  }

  return sub_190592398((void *)a1);
}

uint64_t sub_1904F1B5C(uint64_t a1, FILE *a2, char a3)
{
  float v6 = (void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)(a1 + 40) + 16))(a1 + 40);
  float v7 = (FILE *)v6[18];
  if (v7 != a2)
  {
    *(void *)(a1 + 184) = a2;
    if (v7 && *(unsigned char *)(a1 + 156)) {
      fclose(v7);
    }
    *(unsigned char *)(a1 + 156) = a3;
  }
  return (*(uint64_t (**)(void *))(*v6 + 24))(v6);
}

void sub_1904F1C0C(uint64_t a1)
{
  sub_1904F1AE8(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1904F1C44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10 = a1 + 40;
  (*(void (**)(uint64_t))(*(void *)(a1 + 40) + 16))(a1 + 40);
  sub_1902D50B4(a1, "Generic", 0, 2, "void CLLog::logHeader()", "%s\n", &a9);
  return (*(uint64_t (**)(uint64_t))(*(void *)v10 + 24))(v10);
}

void sub_1904F1D04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1904373C8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1904F1D18(uint64_t a1, const char *a2, int a3, signed int a4, const char *a5, char *__src, va_list a7)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int v13 = strncpy(__dst, __src, 0x65CuLL);
  sub_1904F1DD0(v13, __dst);
  return sub_1902D50B4(a1, a2, a3, a4, a5, __dst, a7);
}

BOOL sub_1904F1DD0(int a1, char *__s)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int64_t v3 = strlen(__s);
  if (v3 < 1) {
    return 1;
  }
  double v4 = &__s[v3];
  double v5 = __s;
  while (1)
  {
    if (*v5 != 37)
    {
      float v6 = v5;
      goto LABEL_18;
    }
    float v6 = v5 + 1;
    int v7 = v5[1];
    if (v7 == 123) {
      break;
    }
LABEL_11:
    float v6 = v5 + 1;
    double v12 = v5 + 1;
    if (v7 != 64)
    {
      if (v7 != 46) {
        goto LABEL_18;
      }
      if (v5[2] != 42) {
        goto LABEL_18;
      }
      double v12 = v5 + 3;
      if (v5[3] != 80) {
        goto LABEL_18;
      }
      *(_WORD *)(v5 + 1) = 9572;
    }
    *double v12 = 112;
LABEL_18:
    double v5 = v6 + 1;
    if (v6 + 1 >= v4) {
      return 1;
    }
  }
  if (v6 != v4)
  {
    uint64_t v8 = 0;
    while (1)
    {
      double v9 = &v5[v8 + 2];
      if (v9 == v4) {
        break;
      }
      ++v8;
      if (*v9 == 125)
      {
        if (v8 == -1) {
          goto LABEL_18;
        }
        uint64_t v10 = &v5[v8];
        uint64_t v11 = (uint64_t)&v5[v8 + 1];
        memmove(v5, v6, v8 + 1);
        v10[1] = 37;
        int v7 = v10[2];
        double v5 = (char *)v11;
        goto LABEL_11;
      }
    }
  }
  if (qword_1E929D6B0 != -1) {
    dispatch_once(&qword_1E929D6B0, &unk_1EDFD3C80);
  }
  float v14 = qword_1E929D6A0;
  BOOL result = os_log_type_enabled((os_log_t)qword_1E929D6A0, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v15 = 136446210;
    uint64_t v16 = __s;
    _os_log_error_impl(&dword_1902AF000, v14, OS_LOG_TYPE_ERROR, "Failed parse os_log format specifier for shimming:missing closing brace,format,%{public}s", (uint8_t *)&v15, 0xCu);
    return 0;
  }
  return result;
}

uint64_t sub_1904F1FA0(uint64_t a1, int a2, FILE *a3)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1 + 40;
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v12 = a1 + 40;
  (*(void (**)(uint64_t))(v5 + 16))(a1 + 40);
  __int16 v13 = 256;
  CFAbsoluteTimeGetCurrent();
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v19 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)float v14 = 0u;
  int v7 = backtrace(v14, 128);
  int v8 = a2 + 1;
  if (a2 + 1 < v7)
  {
    double v9 = (const void **)&v14[v8];
    do
    {
      if (dladdr(*v9, &v11))
      {
        if (v11.dli_sname)
        {
          basename((char *)v11.dli_fname);
          fprintf(a3, "%s,%s,Time,%08.3f,%d\t%s\t0x%08lx %s + %lu\n", "STATUS");
        }
        else
        {
          basename((char *)v11.dli_fname);
          fprintf(a3, "%s,%s,Time,%08.3f,%d\t%s\t0x%08lx 0x%08lx + %lu\n", "STATUS");
        }
      }
      else
      {
        fprintf(a3, "%s,%s,Time,%08.3f,%d\t0x%08lx\n");
      }
      ++v8;
      ++v9;
    }
    while (v7 != v8);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
}

void sub_1904F21D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a2) {
    sub_1902E67BC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904F21FC(uint64_t a1, const char *a2, uint64_t a3)
{
  v38[2] = *MEMORY[0x1E4F143B8];
  objc_msgSend_assertInside(*(void **)(*(void *)(a1 + 48) + 64), a2, a3);
  pthread_self();
  sub_1902C47F8(*(void *)(a1 + 24), "ShowError", (BOOL *)(a1 + 154));
  sub_1902C47F8(*(void *)(a1 + 24), "LogShowUI", (BOOL *)(a1 + 155));
  sub_1902B44C0(*(void *)(a1 + 24), "LogFileLevel", (_DWORD *)(a1 + 160));
  sub_1902B44C0(*(void *)(a1 + 24), "LogBufferLevel", (_DWORD *)(a1 + 164));
  sub_1902B44C0(*(void *)(a1 + 24), "LogConsoleLevel", (_DWORD *)(a1 + 168));
  sub_1902B44C0(*(void *)(a1 + 24), "LogStackLevel", (_DWORD *)(a1 + 172));
  sub_19045F468(*(void *)(a1 + 24), "LogFileDirectory", a1 + 56);
  sub_19045F468(*(void *)(a1 + 24), "LogFilePrefix", a1 + 80);
  sub_1902C47F8(*(void *)(a1 + 24), "LogFileFlush", (BOOL *)(a1 + 157));
  sub_1902C47F8(*(void *)(a1 + 24), "LogFence", (BOOL *)(a1 + 153));
  int v37 = 0;
  sub_1902B44C0(*(void *)(a1 + 24), "LogBufferSize", &v37);
  if ((*(_DWORD *)(a1 + 160) & 0x80000000) != 0)
  {
    sub_1904F1B5C(a1, 0, 0);
    goto LABEL_75;
  }
  uint64_t v4 = *(void *)(a1 + 184);
  long long __p = 0;
  __uint64_t n = 0uLL;
  if (!sub_19045F468(*(void *)(a1 + 24), "LogFile", (uint64_t)&__p)) {
    goto LABEL_6;
  }
  uint64_t v5 = HIBYTE(__n);
  if (__n < 0) {
    uint64_t v5 = __n;
  }
  if (!v5)
  {
LABEL_6:
    if (*(char *)(a1 + 79) < 0)
    {
      if (!*(void *)(a1 + 64)) {
        goto LABEL_43;
      }
    }
    else if (!*(unsigned char *)(a1 + 79))
    {
      goto LABEL_43;
    }
    if (*(char *)(a1 + 103) < 0)
    {
      if (!*(void *)(a1 + 88)) {
        goto LABEL_43;
      }
    }
    else if (!*(unsigned char *)(a1 + 103))
    {
      goto LABEL_43;
    }
    if (*(char *)(a1 + 79) >= 0) {
      size_t v6 = *(unsigned __int8 *)(a1 + 79);
    }
    else {
      size_t v6 = *(void *)(a1 + 64);
    }
    int v7 = &v33;
    sub_190395000((uint64_t)&v33, v6 + 1);
    if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v7 = (std::string *)v33.__r_.__value_.__r.__words[0];
    }
    if (v6)
    {
      if (*(char *)(a1 + 79) >= 0) {
        int v8 = (const void *)(a1 + 56);
      }
      else {
        int v8 = *(const void **)(a1 + 56);
      }
      memmove(v7, v8, v6);
    }
    *(_WORD *)((char *)&v7->__r_.__value_.__l.__data_ + v6) = 47;
    int v9 = *(char *)(a1 + 103);
    if (v9 >= 0) {
      uint64_t v10 = (const std::string::value_type *)(a1 + 80);
    }
    else {
      uint64_t v10 = *(const std::string::value_type **)(a1 + 80);
    }
    if (v9 >= 0) {
      std::string::size_type v11 = *(unsigned __int8 *)(a1 + 103);
    }
    else {
      std::string::size_type v11 = *(void *)(a1 + 88);
    }
    uint64_t v12 = std::string::append(&v33, v10, v11);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v34.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    int v14 = *(char *)(a1 + 127);
    if (v14 >= 0) {
      long long v15 = (const std::string::value_type *)(a1 + 104);
    }
    else {
      long long v15 = *(const std::string::value_type **)(a1 + 104);
    }
    if (v14 >= 0) {
      std::string::size_type v16 = *(unsigned __int8 *)(a1 + 127);
    }
    else {
      std::string::size_type v16 = *(void *)(a1 + 112);
    }
    long long v17 = std::string::append(&v34, v15, v16);
    long long v18 = (void *)v17->__r_.__value_.__r.__words[0];
    v38[0] = v17->__r_.__value_.__l.__size_;
    *(void *)((char *)v38 + 7) = *(std::string::size_type *)((char *)&v17->__r_.__value_.__r.__words[1] + 7);
    char v19 = HIBYTE(v17->__r_.__value_.__r.__words[2]);
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__n) < 0) {
      operator delete(__p);
    }
    long long __p = v18;
    *(void *)&__uint64_t n = v38[0];
    *(void *)((char *)&__n + 7) = *(void *)((char *)v38 + 7);
    HIBYTE(__n) = v19;
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v34.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v33.__r_.__value_.__l.__data_);
    }
  }
LABEL_43:
  if (__n >= 0) {
    uint64_t v20 = HIBYTE(__n);
  }
  else {
    uint64_t v20 = __n;
  }
  if (v20)
  {
    if (v4)
    {
      uint64_t v21 = *(unsigned __int8 *)(a1 + 151);
      int v22 = (char)v21;
      if ((v21 & 0x80u) != 0) {
        uint64_t v21 = *(void *)(a1 + 136);
      }
      if (v20 == v21)
      {
        if (v22 >= 0) {
          long long v23 = (unsigned __int8 *)(a1 + 128);
        }
        else {
          long long v23 = *(unsigned __int8 **)(a1 + 128);
        }
        if ((HIBYTE(__n) & 0x80) != 0)
        {
          long long v26 = (char *)__p;
          if (memcmp(__p, v23, __n)) {
            goto LABEL_63;
          }
        }
        else if (HIBYTE(__n))
        {
          p_p = &__p;
          uint64_t v25 = HIBYTE(__n);
          while (*(unsigned __int8 *)p_p == *v23)
          {
            p_p = (void **)((char *)p_p + 1);
            ++v23;
            if (!--v25) {
              goto LABEL_66;
            }
          }
          goto LABEL_60;
        }
LABEL_66:
        sub_1904F2DFC(a1, *(unsigned __int8 *)(a1 + 157));
        long long v28 = (const char *)&__p;
        if (__n < 0) {
          long long v28 = (const char *)__p;
        }
        if (*(unsigned char *)(a1 + 157)) {
          long long v29 = " and flushing immediately";
        }
        else {
          long long v29 = " no flush";
        }
        syslog(5, "%s,%s,logging locations to %s%s\n", "NOTICE", "CLLog", v28, v29);
        goto LABEL_73;
      }
    }
LABEL_60:
    if (__n >= 0) {
      long long v26 = (char *)&__p;
    }
    else {
      long long v26 = (char *)__p;
    }
LABEL_63:
    sub_1904F287C(a1, v26);
    if (!v4)
    {
      uint64_t v27 = *(void *)(a1 + 216);
      if (v27) {
        sub_1904F65A0(v27, *(FILE **)(a1 + 184));
      }
    }
    goto LABEL_66;
  }
  sub_1904F1B5C(a1, 0, 0);
LABEL_73:
  if (SHIBYTE(__n) < 0) {
    operator delete(__p);
  }
LABEL_75:
  if ((*(_DWORD *)(a1 + 164) & 0x80000000) != 0 || (int v30 = v37, v37 < 1))
  {
    long long v32 = *(std::__shared_weak_count **)(a1 + 224);
    *(void *)(a1 + 216) = 0;
    *(void *)(a1 + 224) = 0;
    if (v32) {
      sub_1902D8B58(v32);
    }
    *(void *)(a1 + 192) = 0;
  }
  else
  {
    if (v37 > 0xA00000)
    {
      int v30 = 10485760;
      int v37 = 10485760;
    }
    uint64_t v31 = *(void *)(a1 + 216);
    if (!v31 || *(_DWORD *)(v31 + 16) != v30) {
      operator new();
    }
    *(void *)(a1 + 192) = sub_1904F632C((FILE **)v31);
    syslog(5, "%s,%s,logging locations to an internal buffer with capacity %d\n", "NOTICE", "CLLog", v37);
  }
}

void sub_1904F27E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904F287C(uint64_t a1, char *a2)
{
  *(void *)&v67[1526] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a1 + 40;
  (*(void (**)(uint64_t))(*(void *)(a1 + 40) + 16))(a1 + 40);
  if (a2)
  {
    uid_t v5 = getuid();
    gid_t v6 = getgid();
    sub_190453FC4(a2, v5, v6);
    int v7 = fopen(a2, "a");
    if (v7)
    {
      MEMORY[0x192FCC770](a1 + 128, a2);
      sub_1904F1B5C(a1, v7, 1);
      sub_1904F2DFC(a1, *(unsigned __int8 *)(a1 + 157));
      int v8 = *(FILE **)(a1 + 184);
      if (v8) {
        sub_1904553FC(v8);
      }
      sub_1902BAD40();
      sub_19046B82C((uint64_t)__p);
      if (__p[23] >= 0) {
        int v9 = __p;
      }
      else {
        int v9 = *(char **)__p;
      }
      sub_1902C3F54(v63, v9);
      if (__p[23] < 0) {
        operator delete(*(void **)__p);
      }
      unint64_t v10 = v64;
      unsigned __int8 v11 = v64;
      if ((v64 & 0x80u) != 0) {
        unint64_t v10 = (unint64_t)v63[1];
      }
      if (!v10)
      {
        MEMORY[0x192FCC770](v63, "Unplugged!");
        unsigned __int8 v11 = v64;
      }
      bzero(__p, 0x65CuLL);
      uint64_t v12 = v63;
      if ((v11 & 0x80u) != 0) {
        uint64_t v12 = (void **)v63[0];
      }
      snprintf(__p, 0x65CuLL, "CoreLocation-%s\n", (const char *)v12);
      sub_1904F1C44(a1, v13, 0, v14, v15, v16, v17, v18, (char)__p);
      bzero(__p, 0x65CuLL);
      snprintf(__p, 0x65CuLL, "locationd was compiled on %s at %s\n", "Nov 21 2024", "19:58:38");
      sub_1904F1C44(a1, v19, 0, v20, v21, v22, v23, v24, (char)__p);
      bufsize_t size = 1024;
      if (_NSGetExecutablePath(buf, &bufsize))
      {
        bzero(__p, 0x65CuLL);
        uint64_t v25 = sub_1902BAD40();
        long long v26 = v60;
        sub_19046B628(v25, (uint64_t)v60);
        if (v61 < 0) {
          long long v26 = (void **)v60[0];
        }
        sub_1902BAD40();
        sub_19046B164((uint64_t)v58);
        if (v59 >= 0) {
          uint64_t v27 = v58;
        }
        else {
          uint64_t v27 = (void **)v58[0];
        }
        snprintf(__p, 0x65CuLL, "/usr/libexec/locationd @ system model %s / version %s\n", (const char *)v26, (const char *)v27);
        if (v59 < 0) {
          operator delete(v58[0]);
        }
        if (v61 < 0) {
          operator delete(v60[0]);
        }
      }
      else
      {
        bzero(__p, 0x65CuLL);
        uint64_t v35 = sub_1902BAD40();
        long long v36 = v60;
        sub_19046B628(v35, (uint64_t)v60);
        if (v61 < 0) {
          long long v36 = (void **)v60[0];
        }
        sub_1902BAD40();
        sub_19046B164((uint64_t)v58);
        if (v59 >= 0) {
          int v37 = v58;
        }
        else {
          int v37 = (void **)v58[0];
        }
        snprintf(__p, 0x65CuLL, "%s @ system model %s / version %s\n", buf, (const char *)v36, (const char *)v37);
        if (v59 < 0) {
          operator delete(v58[0]);
        }
        if (v61 < 0) {
          operator delete(v60[0]);
        }
      }
      sub_1904F1C44(a1, v28, 0, v29, v30, v31, v32, v33, (char)__p);
      bzero(__p, 0x65CuLL);
      sub_1902BAD40();
      sub_19046BA94((uint64_t)v60);
      if (v61 >= 0) {
        long long v38 = v60;
      }
      else {
        long long v38 = (void **)v60[0];
      }
      snprintf(__p, 0x65CuLL, "IOPlatformSerialNumber: %s\n", (const char *)v38);
      if (v61 < 0) {
        operator delete(v60[0]);
      }
      sub_1904F1C44(a1, v39, 0, v40, v41, v42, v43, v44, (char)__p);
      bzero(v67, 0x5EAuLL);
      strcpy(__p, "Begin settings dump (read at construction of CLSettings or upon darwin notification 'com.apple.locationd/prefs')\n");
      sub_1904F1C44(a1, v45, 0, v46, v47, v48, v49, v50, (char)__p);
      (*(void (**)(void))(**(void **)(a1 + 24) + 792))(*(void *)(a1 + 24));
      bzero(&__p[19], 0x649uLL);
      strcpy(__p, "End settings dump\n");
      sub_1904F1C44(a1, v51, 0, v52, v53, v54, v55, v56, (char)__p);
      if ((char)v64 < 0) {
        operator delete(v63[0]);
      }
    }
    else
    {
      std::string v34 = __error();
      syslog(3, "%s,%s,could not open locations log %s, errno %d\n", "ERROR", "CLLog", a2, *v34);
    }
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
}

void sub_1904F2D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  sub_1904373C8((uint64_t)&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_1904F2DFC(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 40;
  (*(void (**)(uint64_t))(*(void *)(a1 + 40) + 16))(a1 + 40);
  *(unsigned char *)(v3 + 117) = a2 != 0;
  uint64_t v4 = *(FILE **)(v3 + 144);
  if (v4) {
    setvbuf(v4, 0, a2 != 0, 0);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);
}

uint64_t sub_1904F2E9C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)(a1 + 40) + 16))(a1 + 40);
  double v2 = (FILE *)v1[18];
  if (v2) {
    fflush(v2);
  }
  return (*(uint64_t (**)(void *))(*v1 + 24))(v1);
}

uint64_t sub_1904F2F1C(uint64_t a1, char *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 40);
  sub_1902C3F54(v21, a2);
  if (*(char *)(a1 + 71) >= 0) {
    size_t v5 = *(unsigned __int8 *)(a1 + 71);
  }
  else {
    size_t v5 = *(void *)(a1 + 56);
  }
  gid_t v6 = v19;
  sub_190395000((uint64_t)v19, v5 + 1);
  if (v20 < 0) {
    gid_t v6 = (void **)v19[0];
  }
  if (v5)
  {
    if (*(char *)(a1 + 71) >= 0) {
      int v7 = (const void *)(a1 + 48);
    }
    else {
      int v7 = *(const void **)(a1 + 48);
    }
    memmove(v6, v7, v5);
  }
  *(_WORD *)((char *)v6 + v5) = 95;
  if (sub_190592D90(v4, (char **)v21, (char *)v19))
  {
    sub_1902C3F54(v17, a2);
    sub_1902C3F54(v15, ".log.bz2");
    if (sub_190592E68(v4, v17, (char *)v15))
    {
      int v8 = 1;
    }
    else
    {
      sub_1902C3F54(v13, a2);
      sub_1902C3F54(__p, ".log");
      int v8 = sub_190592E68(v4, v13, (char *)__p);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
      if (v14 < 0) {
        operator delete(v13[0]);
      }
    }
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    if (v18 < 0) {
      operator delete(v17[0]);
    }
  }
  else
  {
    int v8 = 0;
  }
  if (v20 < 0) {
    operator delete(v19[0]);
  }
  if (v22 < 0)
  {
    operator delete(v21[0]);
    if (!v8) {
      return 1;
    }
  }
  else if (!v8)
  {
    return 1;
  }
  if (++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) > *(_DWORD *)(a1 + 96))
  {
    LOBYTE(v21[0]) = 0;
    int v9 = (const char *)(a1 + 72);
    if (*(char *)(a1 + 95) < 0) {
      int v9 = *(const char **)v9;
    }
    if (snprintf((char *)v21, 0x400uLL, "%s/%s", v9, a2) > 1023)
    {
      syslog(3, "%s,%s,Rotation path is too long, could not delete old logs.\n", "ERROR", "CLLog");
    }
    else if (unlink((const char *)v21))
    {
      perror("Failed to delete log");
    }
  }
  return 1;
}

void sub_1904F3188(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_1904F320C(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 71) < 0)
  {
    sub_190347AFC((unsigned char *)(a1 + 48), *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)(a1 + 48) = v4;
  }
  BOOL result = (unsigned char *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0) {
    return sub_190347AFC(result, *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  long long v6 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)BOOL result = v6;
  return result;
}

void sub_1904F3294(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 71) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904F32B0(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 48);
    operator delete(v2);
  }
}

void sub_1904F3308(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 112)) {
    goto LABEL_7;
  }
  uint64_t v2 = (const char *)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    uint64_t v2 = *(const char **)v2;
  }
  uint64_t v3 = (const char *)(a1 + 64);
  long long v4 = (const char *)(a1 + 64);
  if (*(char *)(a1 + 87) < 0) {
    long long v4 = *(const char **)v3;
  }
  if (!sub_190454728(v2, v4))
  {
    if (*(char *)(a1 + 87) < 0) {
      uint64_t v3 = *(const char **)v3;
    }
    syslog(3, "%s,%s,Failed to write %s\n", "ERROR", "CLLog", v3);
  }
  else
  {
LABEL_7:
    size_t v5 = (const char *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      size_t v5 = *(const char **)v5;
    }
    unlink(v5);
  }
  if ((*(_DWORD *)(a1 + 112) & 0x80000000) == 0)
  {
    long long v6 = (void *)(a1 + 88);
    if (*(char *)(a1 + 111) < 0) {
      long long v6 = (void *)*v6;
    }
    uint64_t v7 = *(void *)(a1 + 32);
    sub_190506800((uint64_t)v6, v7);
  }
}

unsigned char *sub_1904F33EC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_190347AFC((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  if (*(char *)(a2 + 87) < 0)
  {
    sub_190347AFC((unsigned char *)(a1 + 64), *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v5;
  }
  BOOL result = (unsigned char *)(a1 + 88);
  if (*(char *)(a2 + 111) < 0) {
    return sub_190347AFC(result, *(void **)(a2 + 88), *(void *)(a2 + 96));
  }
  long long v7 = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(_OWORD *)BOOL result = v7;
  return result;
}

void sub_1904F34A4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 87) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904F34D8(uint64_t a1)
{
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

uint64_t sub_1904F3540(uint64_t a1)
{
  uint64_t v3 = a1 + 40;
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v75 = a1 + 40;
  (*(void (**)(uint64_t))(v2 + 16))(a1 + 40);
  __int16 v76 = 256;
  uint64_t v6 = sub_190592D84(a1, v4, v5);
  if (*(char *)(a1 + 79) < 0)
  {
    sub_190347AFC(&__dst, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    long long __dst = *(_OWORD *)(a1 + 56);
    uint64_t v74 = *(void *)(a1 + 72);
  }
  if (*(char *)(a1 + 103) < 0)
  {
    sub_190347AFC(&v71, *(void **)(a1 + 80), *(void *)(a1 + 88));
  }
  else
  {
    long long v71 = *(_OWORD *)(a1 + 80);
    uint64_t v72 = *(void *)(a1 + 96);
  }
  if (*(void *)(a1 + 216))
  {
    syslog(5, "%s,%s,dumping internal buffer\n", "NOTICE", "CLLog");
    sub_190592CB4(a1, (std::string *)&v77);
    if ((v77.st_gid & 0x80000000) == 0) {
      long long v7 = &v77;
    }
    else {
      long long v7 = *(stat **)&v77.st_dev;
    }
    int v8 = fopen((const char *)v7, "a");
    int v9 = v8;
    if (SHIBYTE(v77.st_gid) < 0)
    {
      operator delete(*(void **)&v77.st_dev);
      if (v9) {
        goto LABEL_13;
      }
    }
    else if (v8)
    {
LABEL_13:
      sub_1904F65A0(*(void *)(a1 + 216), v9);
      fclose(v9);
      char v10 = 1;
      goto LABEL_16;
    }
  }
  char v10 = 0;
LABEL_16:
  if (v74 >= 0) {
    p_dst = (const char *)&__dst;
  }
  else {
    p_dst = (const char *)__dst;
  }
  if (!stat(p_dst, &v77))
  {
    char v12 = HIBYTE(v74);
    if (v74 >= 0) {
      uint64_t v13 = &__dst;
    }
    else {
      uint64_t v13 = (long long *)__dst;
    }
    v66[0] = MEMORY[0x1E4F143A8];
    v66[1] = 3321888768;
    v66[2] = sub_1904F40EC;
    v66[3] = &unk_1EDFD12D0;
    v66[4] = a1;
    if (SHIBYTE(v72) < 0)
    {
      sub_190347AFC(&v67, (void *)v71, *((unint64_t *)&v71 + 1));
      char v12 = HIBYTE(v74);
    }
    else
    {
      long long v67 = v71;
      uint64_t v68 = v72;
    }
    if (v12 < 0)
    {
      sub_190347AFC(&__p, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long __p = __dst;
      uint64_t v70 = v74;
    }
    sub_190506800((uint64_t)v13, (uint64_t)v66);
    if (SHIBYTE(v70) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v68) < 0) {
      operator delete((void *)v67);
    }
  }
  sub_1904F2E9C(a1);
  char v14 = (char *)(a1 + 128);
  uint64_t v15 = (const char *)(a1 + 128);
  if (*(char *)(a1 + 151) < 0) {
    uint64_t v15 = *(const char **)v14;
  }
  if (!stat(v15, &v77))
  {
    sub_190592CB4(a1, (std::string *)&v77);
    uint64_t v17 = (const std::__fs::filesystem::path *)(a1 + 128);
    if (*(char *)(a1 + 151) < 0) {
      uint64_t v17 = *(const std::__fs::filesystem::path **)v14;
    }
    if ((v77.st_gid & 0x80000000) == 0) {
      char v18 = &v77;
    }
    else {
      char v18 = *(stat **)&v77.st_dev;
    }
    rename(v17, (const std::__fs::filesystem::path *)v18, v16);
    if ((v77.st_gid & 0x80000000) == 0) {
      uint64_t v19 = &v77;
    }
    else {
      uint64_t v19 = *(stat **)&v77.st_dev;
    }
    sub_190453F70((const char *)v19);
    if (*(char *)(a1 + 151) < 0) {
      char v14 = *(char **)v14;
    }
    sub_1904F287C(a1, v14);
    if (SHIBYTE(v77.st_gid) < 0) {
      operator delete(*(void **)&v77.st_dev);
    }
    char v10 = 1;
  }
  BOOL v65 = 0;
  sub_19046FADC(&v77);
  if (sub_1902C47F8(*(uint64_t *)&v77.st_dev, "LogNatalimetry", &v65))
  {
    char v20 = 1;
  }
  else
  {
    sub_19046FADC(v63);
    char v20 = sub_1902C47F8((uint64_t)v63[0], "LogCalorimetry", &v65);
    if (v63[1]) {
      sub_1902D8B58((std::__shared_weak_count *)v63[1]);
    }
  }
  if (v77.st_ino) {
    sub_1902D8B58((std::__shared_weak_count *)v77.st_ino);
  }
  if (v20)
  {
    if (v65)
    {
      sub_190470210(0, &v62);
      uint64_t v21 = std::string::append(&v62, "userinfo");
      long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
      *(void *)&v77.uid_t st_uid = *((void *)&v21->__r_.__value_.__l + 2);
      *(_OWORD *)&v77.st_dev = v22;
      v21->__r_.__value_.__l.__size_ = 0;
      v21->__r_.__value_.__r.__words[2] = 0;
      v21->__r_.__value_.__r.__words[0] = 0;
      uint64_t v23 = std::string::append((std::string *)&v77, ".plist");
      long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      int64_t v64 = v23->__r_.__value_.__r.__words[2];
      *(_OWORD *)__int16 v63 = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v77.st_gid) < 0) {
        operator delete(*(void **)&v77.st_dev);
      }
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v62.__r_.__value_.__l.__data_);
      }
      if (v64 >= 0) {
        uint64_t v25 = v63;
      }
      else {
        uint64_t v25 = (void **)v63[0];
      }
      if (!stat((const char *)v25, &v77))
      {
        sub_190592768((uint64_t)&v60);
        long long v26 = std::string::append(&v60, "/");
        long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
        v61.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v27;
        v26->__r_.__value_.__l.__size_ = 0;
        v26->__r_.__value_.__r.__words[2] = 0;
        v26->__r_.__value_.__r.__words[0] = 0;
        uint64_t v28 = std::string::append(&v61, "userinfo");
        long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
        v62.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v62.__r_.__value_.__l.__data_ = v29;
        v28->__r_.__value_.__l.__size_ = 0;
        v28->__r_.__value_.__r.__words[2] = 0;
        v28->__r_.__value_.__r.__words[0] = 0;
        uint64_t v30 = std::string::append(&v62, ".log");
        long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
        *(void *)&v77.uid_t st_uid = *((void *)&v30->__r_.__value_.__l + 2);
        *(_OWORD *)&v77.st_dev = v31;
        v30->__r_.__value_.__l.__size_ = 0;
        v30->__r_.__value_.__r.__words[2] = 0;
        v30->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v62.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v61.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v60.__r_.__value_.__l.__data_);
        }
        if (v64 >= 0) {
          uint64_t v32 = v63;
        }
        else {
          uint64_t v32 = (void **)v63[0];
        }
        if ((v77.st_gid & 0x80000000) == 0) {
          uint64_t v33 = &v77;
        }
        else {
          uint64_t v33 = *(stat **)&v77.st_dev;
        }
        sub_1904540C0((const char *)v32, (const char *)v33);
        if ((v77.st_gid & 0x80000000) == 0) {
          std::string v34 = &v77;
        }
        else {
          std::string v34 = *(stat **)&v77.st_dev;
        }
        sub_190453F70((const char *)v34);
        if (SHIBYTE(v77.st_gid) < 0) {
          operator delete(*(void **)&v77.st_dev);
        }
      }
      sub_190470210(0, &v61);
      uint64_t v35 = std::string::append(&v61, "cache");
      long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
      *(void *)&v77.uid_t st_uid = *((void *)&v35->__r_.__value_.__l + 2);
      *(_OWORD *)&v77.st_dev = v36;
      v35->__r_.__value_.__l.__size_ = 0;
      v35->__r_.__value_.__r.__words[2] = 0;
      v35->__r_.__value_.__r.__words[0] = 0;
      int v37 = std::string::append((std::string *)&v77, ".plist");
      long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
      v62.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v62.__r_.__value_.__l.__data_ = v38;
      v37->__r_.__value_.__l.__size_ = 0;
      v37->__r_.__value_.__r.__words[2] = 0;
      v37->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v77.st_gid) < 0) {
        operator delete(*(void **)&v77.st_dev);
      }
      if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v61.__r_.__value_.__l.__data_);
      }
      if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v39 = &v62;
      }
      else {
        uint64_t v39 = (std::string *)v62.__r_.__value_.__r.__words[0];
      }
      if (!stat((const char *)v39, &v77))
      {
        sub_190592768((uint64_t)&v59);
        uint64_t v40 = std::string::append(&v59, "/");
        long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
        v60.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v41;
        v40->__r_.__value_.__l.__size_ = 0;
        v40->__r_.__value_.__r.__words[2] = 0;
        v40->__r_.__value_.__r.__words[0] = 0;
        uint64_t v42 = std::string::append(&v60, "cache");
        long long v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
        v61.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v43;
        v42->__r_.__value_.__l.__size_ = 0;
        v42->__r_.__value_.__r.__words[2] = 0;
        v42->__r_.__value_.__r.__words[0] = 0;
        uint64_t v44 = std::string::append(&v61, ".log");
        long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
        *(void *)&v77.uid_t st_uid = *((void *)&v44->__r_.__value_.__l + 2);
        *(_OWORD *)&v77.st_dev = v45;
        v44->__r_.__value_.__l.__size_ = 0;
        v44->__r_.__value_.__r.__words[2] = 0;
        v44->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v61.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v60.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v59.__r_.__value_.__l.__data_);
        }
        if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v46 = &v62;
        }
        else {
          uint64_t v46 = (std::string *)v62.__r_.__value_.__r.__words[0];
        }
        if ((v77.st_gid & 0x80000000) == 0) {
          uint64_t v47 = &v77;
        }
        else {
          uint64_t v47 = *(stat **)&v77.st_dev;
        }
        sub_1904540C0((const char *)v46, (const char *)v47);
        if ((v77.st_gid & 0x80000000) == 0) {
          uint64_t v48 = &v77;
        }
        else {
          uint64_t v48 = *(stat **)&v77.st_dev;
        }
        sub_190453F70((const char *)v48);
        if (SHIBYTE(v77.st_gid) < 0) {
          operator delete(*(void **)&v77.st_dev);
        }
      }
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v62.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v64) < 0) {
        operator delete(v63[0]);
      }
    }
  }
  else
  {
    BOOL v65 = 0;
  }
  sub_190592588((uint64_t)&v61);
  uint64_t v49 = std::string::append(&v61, "/");
  long long v50 = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
  v62.__r_.__value_.__r.__words[2] = v49->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v62.__r_.__value_.__l.__data_ = v50;
  v49->__r_.__value_.__l.__size_ = 0;
  v49->__r_.__value_.__r.__words[2] = 0;
  v49->__r_.__value_.__r.__words[0] = 0;
  uint64_t v51 = std::string::append(&v62, "com.apple.timed");
  long long v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
  *(void *)&v77.uid_t st_uid = *((void *)&v51->__r_.__value_.__l + 2);
  *(_OWORD *)&v77.st_dev = v52;
  v51->__r_.__value_.__l.__size_ = 0;
  v51->__r_.__value_.__r.__words[2] = 0;
  v51->__r_.__value_.__r.__words[0] = 0;
  uint64_t v53 = std::string::append((std::string *)&v77, ".plist");
  long long v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
  int64_t v64 = v53->__r_.__value_.__r.__words[2];
  *(_OWORD *)__int16 v63 = v54;
  v53->__r_.__value_.__l.__size_ = 0;
  v53->__r_.__value_.__r.__words[2] = 0;
  v53->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v77.st_gid) < 0) {
    operator delete(*(void **)&v77.st_dev);
  }
  if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v62.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v61.__r_.__value_.__l.__data_);
  }
  if (v64 >= 0) {
    uint64_t v55 = v63;
  }
  else {
    uint64_t v55 = (void **)v63[0];
  }
  if (stat((const char *)v55, &v77)) {
    goto LABEL_137;
  }
  sub_190592484((uint64_t)&v62);
  sub_1902C3F54(&v61, "com.apple.timed");
  sub_1902C3F54(&v60, ".plist.log");
  sub_190592948((const void **)&v62.__r_.__value_.__l.__data_, (uint64_t)&v61, (uint64_t)&v60, v6, (std::string *)&v77);
  if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v60.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v61.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v62.__r_.__value_.__l.__data_);
  }
  if (v64 >= 0) {
    uint64_t v56 = v63;
  }
  else {
    uint64_t v56 = (void **)v63[0];
  }
  if ((v77.st_gid & 0x80000000) == 0) {
    double v57 = &v77;
  }
  else {
    double v57 = *(stat **)&v77.st_dev;
  }
  if (sub_1904540C0((const char *)v56, (const char *)v57) == 1) {
    syslog(5, "%s,%s,could not copy %s log\n", "WARNING", "CLLog", "com.apple.timed");
  }
  if ((SHIBYTE(v77.st_gid) & 0x80000000) == 0)
  {
LABEL_137:
    if (v10) {
      goto LABEL_139;
    }
    goto LABEL_138;
  }
  operator delete(*(void **)&v77.st_dev);
  if ((v10 & 1) == 0) {
LABEL_138:
  }
    syslog(5, "%s,%s,could not dump log file\n", "WARNING", "CLLog");
LABEL_139:
  if (SHIBYTE(v64) < 0) {
    operator delete(v63[0]);
  }
  if (SHIBYTE(v72) < 0) {
    operator delete((void *)v71);
  }
  if (SHIBYTE(v74) < 0) {
    operator delete((void *)__dst);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);
}

void sub_1904F3E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a63 < 0) {
    operator delete(a58);
  }
  if (*(char *)(v63 - 233) < 0) {
    operator delete(*(void **)(v63 - 256));
  }
  sub_1904373C8(v63 - 232);
  _Unwind_Resume(a1);
}

uint64_t sub_1904F40EC(uint64_t a1, char *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  sub_1902C3F54(&v31, a2);
  if (*(char *)(a1 + 63) >= 0) {
    size_t v5 = *(unsigned __int8 *)(a1 + 63);
  }
  else {
    size_t v5 = *(void *)(a1 + 48);
  }
  uint64_t v6 = &v30;
  sub_190395000((uint64_t)&v30, v5 + 1);
  if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v6 = (std::string *)v30.__r_.__value_.__r.__words[0];
  }
  if (v5)
  {
    if (*(char *)(a1 + 63) >= 0) {
      long long v7 = (const void *)(a1 + 40);
    }
    else {
      long long v7 = *(const void **)(a1 + 40);
    }
    memmove(v6, v7, v5);
  }
  *(_WORD *)((char *)&v6->__r_.__value_.__l.__data_ + v5) = 95;
  if (sub_190592D90(v4, (char **)&v31, (char *)&v30))
  {
    sub_1902C3F54(&v29, a2);
    sub_1902C3F54(v27, ".log.bz2");
    if (sub_190592E68(v4, (void **)&v29.__r_.__value_.__l.__data_, (char *)v27))
    {
      int v8 = 1;
    }
    else
    {
      sub_1902C3F54(v25, a2);
      sub_1902C3F54(__p, ".log");
      int v8 = sub_190592E68(v4, v25, (char *)__p);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v26 < 0) {
        operator delete(v25[0]);
      }
    }
    if (v28 < 0) {
      operator delete(v27[0]);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    int v8 = 0;
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v32) < 0)
  {
    operator delete((void *)v31);
    if (!v8) {
      return 1;
    }
  }
  else if (!v8)
  {
    return 1;
  }
  sub_190592768((uint64_t)&v29);
  int v9 = std::string::append(&v29, "/");
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  unsigned __int8 v11 = std::string::append(&v30, a2);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  int64_t v32 = v11->__r_.__value_.__r.__words[2];
  long long v31 = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  if (*(char *)(a1 + 87) >= 0) {
    size_t v13 = *(unsigned __int8 *)(a1 + 87);
  }
  else {
    size_t v13 = *(void *)(a1 + 72);
  }
  char v14 = &v29;
  sub_190395000((uint64_t)&v29, v13 + 1);
  if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    char v14 = (std::string *)v29.__r_.__value_.__r.__words[0];
  }
  if (v13)
  {
    if (*(char *)(a1 + 87) >= 0) {
      uint64_t v15 = (const void *)(a1 + 64);
    }
    else {
      uint64_t v15 = *(const void **)(a1 + 64);
    }
    memmove(v14, v15, v13);
  }
  *(_WORD *)((char *)&v14->__r_.__value_.__l.__data_ + v13) = 47;
  char v16 = std::string::append(&v29, a2);
  std::string v30 = *v16;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  int v18 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
  uint64_t v19 = (void *)v30.__r_.__value_.__r.__words[0];
  if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v20 = (const std::__fs::filesystem::path *)&v30;
  }
  else {
    char v20 = (const std::__fs::filesystem::path *)v30.__r_.__value_.__r.__words[0];
  }
  if (v32 >= 0) {
    uint64_t v21 = (const std::__fs::filesystem::path *)&v31;
  }
  else {
    uint64_t v21 = (const std::__fs::filesystem::path *)v31;
  }
  rename(v20, v21, v17);
  sub_190453F70((const char *)v21);
  if (v18 < 0) {
    operator delete(v19);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete((void *)v31);
  }
  return 1;
}

void sub_1904F43EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (*(char *)(v35 - 57) < 0) {
    operator delete(*(void **)(v35 - 80));
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_1904F44BC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_190347AFC((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  BOOL result = (unsigned char *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0) {
    return sub_190347AFC(result, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  long long v6 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)BOOL result = v6;
  return result;
}

void sub_1904F4544(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904F4560(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

os_log_t sub_1904F45B8()
{
  os_log_t result = os_log_create("com.apple.locationd.Core", "Core");
  qword_1E929D6A0 = (uint64_t)result;
  return result;
}

void sub_1904F45EC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FCC980);
}

FILE **sub_1904F4624(uint64_t a1)
{
  os_log_t result = *(FILE ***)(a1 + 24);
  if (result)
  {
    sub_1904F6218(result);
    JUMPOUT(0x192FCC980);
  }
  return result;
}

uint64_t sub_1904F466C(uint64_t a1, uint64_t a2)
{
  if (sub_1903885B4(a2, (uint64_t)&unk_1EDFC71C8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

FILE **sub_1904F46B0(FILE ***a1)
{
  os_log_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1904F6218(result);
    JUMPOUT(0x192FCC980);
  }
  return result;
}

void sub_1904F4704(uint64_t a1)
{
  sub_19047E7E8(a1);

  JUMPOUT(0x192FCC980);
}

BOOL sub_1904F4740(uint64_t a1, const __CFString *a2, const void *a3)
{
  sub_190480420(a1, a2, a3);

  return sub_1902B41B0(a1);
}

os_log_t sub_1904F4E8C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Altimeter");
  qword_1E929D750 = (uint64_t)result;
  return result;
}

uint64_t sub_1904F4EBC(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)a1 = 0;
  *(float *)(a1 + 4) = a3;
  *(unsigned char *)(a1 + 8) = 0;
  if (qword_1EB3BE898 != -1) {
    dispatch_once(&qword_1EB3BE898, &unk_1EDFD3A20);
  }
  size_t v5 = off_1EB3BE890;
  if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)int buf = 136446210;
    uint64_t v9 = a2;
    _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_INFO, "motion default ignored,'%{public}s'.", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD3A20);
    }
    long long v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CLMotionDefaultsWrite<float>::CLMotionDefaultsWrite(const char *, const T &, const BOOL) [T = float]", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  return a1;
}

void sub_1904F514C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v15, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_1904F52B8(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  long long v7 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v5, 0);
  if (*a2
    && (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7)) != 0
    && (uint64_t v10 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage")) != 0)
  {
    int v13 = objc_msgSend_intValue(v10, v11, v12);
  }
  else
  {
    int v13 = 103;
  }
  if (qword_1EB3BE898 != -1) {
    dispatch_once(&qword_1EB3BE898, &unk_1EDFD3E80);
  }
  char v14 = off_1EB3BE890;
  if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)int buf = 67240192;
    int v17 = v13;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD3E80);
    }
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMOdometerSuitabilityManagerProxy _startDaemonConnection]_block_invoke", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
}

void sub_1904F54D0(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v5 = ExecutablePathFromPid;
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD3E80);
    }
    long long v6 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_INFO))
    {
      pid_t v7 = getpid();
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)int buf = 138412802;
      uint64_t v11 = v5;
      __int16 v12 = 1024;
      pid_t v13 = v7;
      __int16 v14 = 2048;
      uint64_t v15 = v8;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_INFO, "CMOdometerSuitability client connection interrupt, %@, %d, %p", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD3E80);
      }
      getpid();
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMOdometerSuitabilityManagerProxy _startDaemonConnection]_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
}

void sub_1904F5848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  if (v22) {
    sub_1902D8B58(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1904F588C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void **)(*(void *)(a1 + 32) + 32);
  if (v4)
  {
    long long v6 = objc_msgSend_copy(v4, a2, a3);
    pid_t v7 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v8 = objc_opt_class();
    uint64_t v9 = objc_opt_class();
    uint64_t v10 = objc_opt_class();
    __int16 v12 = (NSSet *)objc_msgSend_setWithObjects_(v7, v11, v8, v9, v10, 0);
    if (*(void *)a2)
    {
      uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v12);
      if (DictionaryOfClasses)
      {
        uint64_t v15 = DictionaryOfClasses;
        uint64_t v16 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v14, @"CMOdometerSuitabilityObject");
        uint64_t v18 = objc_msgSend_objectForKeyedSubscript_(v15, v17, @"CMErrorMessage");
        if (v18)
        {
          uint64_t v19 = *(NSObject **)(*(void *)(a1 + 32) + 16);
          v25[0] = MEMORY[0x1E4F143A8];
          v25[1] = 3221225472;
          void v25[2] = sub_1904F5B88;
          _OWORD v25[3] = &unk_1E568D320;
          v25[4] = v18;
          v25[5] = v6;
          char v20 = v25;
          uint64_t v21 = v19;
        }
        else
        {
          if (!v16)
          {
            if (qword_1EB3BE898 != -1) {
              dispatch_once(&qword_1EB3BE898, &unk_1EDFD3E80);
            }
            long long v22 = off_1EB3BE890;
            if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)int buf = 0;
              _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_FAULT, "Unable to parse kCLConnectionMessageOdometerSuitabilityUpdate message!", buf, 2u);
            }
            if (sub_1902D8400(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1EB3BE898 != -1) {
                dispatch_once(&qword_1EB3BE898, &unk_1EDFD3E80);
              }
              uint64_t v23 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 0, "-[CMOdometerSuitabilityManagerProxy _startOdometerSuitabilityUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v23);
              if (v23 != (char *)buf) {
                free(v23);
              }
            }
            goto LABEL_9;
          }
          uint64_t v21 = *(NSObject **)(*(void *)(a1 + 32) + 16);
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 3221225472;
          block[2] = sub_1904F5C1C;
          block[3] = &unk_1E568D2F8;
          void block[4] = v16;
          void block[5] = v6;
          char v20 = block;
        }
        dispatch_async(v21, v20);
      }
    }
LABEL_9:
  }
}

void sub_1904F5B88(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x192FCD2F0]();
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v7 = objc_msgSend_integerValue(*(void **)(a1 + 32), v5, v6);
  uint64_t v9 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v8, @"CMErrorDomain", v7, 0);
  (*(void (**)(uint64_t, void, uint64_t))(v4 + 16))(v4, 0, v9);
}

void sub_1904F5C1C(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x192FCD2F0]();
  uint64_t v3 = [CMOdometerSuitability alloc];
  uint64_t started = objc_msgSend_startDate(*(void **)(a1 + 32), v4, v5);
  uint64_t v9 = objc_msgSend_suitableForRunning(*(void **)(a1 + 32), v7, v8);
  uint64_t v12 = objc_msgSend_suitableForWalking(*(void **)(a1 + 32), v10, v11);
  id v14 = (id)objc_msgSend_initWithStartDate_suitableForRunning_suitableForWalking_(v3, v13, started, v9, v12);
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1904F5DE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16)
{
  if (v16) {
    sub_1902D8B58(v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1904F5F80(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__teardown(*(void **)(*(void *)(a1 + 32) + 8), a2, a3);
}

uint64_t sub_1904F6060(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_odometerSuitabilityManagerProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__startOdometerSuitabilityUpdatesWithHandler_, v5);
}

uint64_t sub_1904F611C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = objc_msgSend_odometerSuitabilityManagerProxy(*(void **)(a1 + 32), a2, a3);

  return objc_msgSend__stopOdometerSuitabilityUpdates(v3, v4, v5);
}

void sub_1904F6150(void *a1, void *a2)
{
  uint64_t v4 = operator new(0x70uLL);
  v4[1] = 0;
  _DWORD v4[2] = 0;
  *uint64_t v4 = &unk_1EDFD0DA0;
  sub_1902C3F54(__p, "kCLConnectionMessageOdometerSuitabilityUpdate");
  MEMORY[0x192FCC420](v4 + 3, __p, *a2);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_1904F61E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::__shared_weak_count::~__shared_weak_count(v15);
  operator delete(v17);
  _Unwind_Resume(a1);
}

FILE **sub_1904F6218(FILE **a1)
{
  return a1;
}

uint64_t sub_1904F624C(FILE **a1)
{
  uint64_t v2 = a1 + 4;
  (*(void (**)(FILE **))&a1[4]->_flags)(a1 + 4);
  uint64_t v3 = *a1;
  if (*a1)
  {
    *a1 = 0;
    fclose(v3);
  }
  uint64_t v4 = a1[1];
  if (v4)
  {
    free(v4);
    a1[1] = 0;
    uint64_t v5 = 1;
  }
  else
  {
    uint64_t v5 = 0;
  }
  sub_1904F6528((uint64_t)a1);
  (*(void (**)(void *))(*v2 + 24))(v2);
  return v5;
}

void sub_1904F6318(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1904373C8((uint64_t)va);
  _Unwind_Resume(a1);
}

FILE *sub_1904F632C(FILE **a1)
{
  uint64_t v2 = (char *)(a1 + 4);
  (*(void (**)(FILE **))&a1[4]->_flags)(a1 + 4);
  uint64_t v3 = *a1;
  if (!*a1)
  {
    uint64_t v4 = (FILE *)malloc_type_malloc(*((int *)a1 + 4), 0x100004077774924uLL);
    a1[1] = v4;
    if (v4)
    {
      *a1 = funopen(a1, 0, (int (__cdecl *)(void *, const char *, int))sub_1904F6440, 0, (int (__cdecl *)(void *))sub_1904F6524);
      sub_1904F6528((uint64_t)a1);
    }
    uint64_t v3 = *a1;
  }
  (*(void (**)(char *))(*(void *)v2 + 24))(v2);
  return v3;
}

void sub_1904F6428(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1904373C8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1904F6440(uint64_t a1, const void *a2, int a3)
{
  LODWORD(v3) = a3;
  uint64_t v6 = a1 + 32;
  (*(void (**)(uint64_t))(*(void *)(a1 + 32) + 16))(a1 + 32);
  uint64_t v7 = *(void *)(v6 - 24);
  if (v7)
  {
    uint64_t v8 = *(int *)(a1 + 20);
    int v9 = *(_DWORD *)(a1 + 16) - v8;
    if (v9 >= (int)v3) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v9;
    }
    memcpy((void *)(v7 + v8), a2, (int)v3);
    int v10 = *(_DWORD *)(a1 + 16);
    int v11 = (*(_DWORD *)(a1 + 20) + (int)v3) % v10;
    if (*(_DWORD *)(a1 + 24) + (int)v3 < v10) {
      int v10 = *(_DWORD *)(a1 + 24) + v3;
    }
    *(_DWORD *)(a1 + 20) = v11;
    *(_DWORD *)(a1 + 24) = v10;
  }
  else
  {
    uint64_t v3 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  return v3;
}

uint64_t sub_1904F6528(uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  (*(void (**)(uint64_t))(*(void *)(a1 + 32) + 16))(a1 + 32);
  *(void *)(v1 - 12) = 0;
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 24))(v1);
}

uint64_t sub_1904F65A0(uint64_t a1, FILE *a2)
{
  uint64_t v4 = a1 + 32;
  (*(void (**)(uint64_t))(*(void *)(a1 + 32) + 16))(a1 + 32);
  uint64_t v5 = *(void *)(v4 - 24);
  if (v5)
  {
    if (*(void *)a1)
    {
      fflush(*(FILE **)a1);
      uint64_t v5 = *(void *)(a1 + 8);
    }
    uint64_t v6 = *(unsigned int *)(a1 + 24);
    uint64_t v7 = *(int *)(a1 + 16);
    if ((int)v6 >= (int)v7)
    {
      uint64_t v8 = v7 + v5;
      int v9 = *(char *)(v8 - 1);
      *(unsigned char *)(v8 - 1) = 0;
      fputs((const char *)(*(void *)(a1 + 8) + *(int *)(a1 + 20)), a2);
      fputc(v9, a2);
      uint64_t v5 = *(void *)(a1 + 8);
    }
    *(unsigned char *)(v5 + *(int *)(a1 + 20)) = 0;
    fputs(*(const char **)(a1 + 8), a2);
    sub_1904F6528(a1);
  }
  else
  {
    uint64_t v6 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  return v6;
}

void sub_1904F66BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1904373C8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1904F6C48(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)a1 = 0;
  uint64_t v4 = a1 + 15020;
  *(_DWORD *)(a1 + 3) = 0;
  uint64_t v5 = (unsigned char *)(a1 + 14628);
  *(_DWORD *)(a1 + 40) = a3;
  uint64_t v6 = a1 + 5196;
  *(_WORD *)(a1 + 44) = 257;
  *(_DWORD *)(a1 + 46) = 0;
  *(unsigned char *)(a1 + 50) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 88) = 1065353216;
  sub_1902D9ACC((float32x4_t *)(a1 + 76), (float32x4_t)0);
  *(unsigned char *)(a1 + 92) = 0;
  *(void *)(a1 + 100) = 0x3200000000;
  *(unsigned char *)(a1 + 708) = 1;
  *(_OWORD *)(a1 + 720) = 0u;
  *(void *)(a1 + 736) = 0x3200000000;
  *(void *)(a1 + 944) = 0x6400000000;
  *(void *)(a1 + 2152) = 0x6400000000;
  *(void *)(a1 + 3760) = 0x6400000000;
  *(void *)(a1 + 4568) = 0x3200000000;
  *(_DWORD *)(a1 + 5176) = 0;
  *(void *)(a1 + 5184) = 0;
  *(_DWORD *)(a1 + 5192) = 0;
  *(_OWORD *)uint64_t v6 = xmmword_19060AF80;
  *(_OWORD *)(a1 + 5216) = 0u;
  *(_OWORD *)(a1 + 5232) = 0u;
  *(_OWORD *)(a1 + 5248) = 0u;
  *(_OWORD *)(a1 + 5264) = 0u;
  *(_OWORD *)(a1 + 5280) = 0u;
  *(_DWORD *)(a1 + 5296) = 0;
  *(_DWORD *)(a1 + 5300) = 973279855;
  int32x2_t v7 = vdup_n_s32(0x3A03126Fu);
  *(int32x2_t *)(a1 + 5304) = v7;
  *(_DWORD *)(a1 + 5312) = 0;
  *(_OWORD *)(v6 + 120) = xmmword_19060AF90;
  *(_DWORD *)(a1 + 5332) = 1065353216;
  sub_1902D9ACC((float32x4_t *)(a1 + 5320), (float32x4_t)xmmword_19060AF90);
  *(_OWORD *)(a1 + 5336) = 0u;
  *(_OWORD *)(a1 + 5352) = 0u;
  *(void *)(a1 + 5368) = 0x3A03126F00000000;
  *(int32x2_t *)(a1 + 5376) = v7;
  *(_DWORD *)(a1 + 5384) = 0;
  *(_OWORD *)(v6 + 192) = xmmword_19060AF90;
  *(_DWORD *)(a1 + 5404) = 1065353216;
  sub_1902D9ACC((float32x4_t *)(a1 + 5392), (float32x4_t)xmmword_19060AF90);
  *(_OWORD *)(a1 + 5408) = 0u;
  *(void *)(a1 + 5424) = 0x200000000;
  *(unsigned char *)(v6 + 244) = 1;
  *(_OWORD *)(a1 + 5452) = 0u;
  *(void *)(a1 + 5468) = 0x4B00000000;
  *(_OWORD *)(a1 + 5776) = 0u;
  *(_DWORD *)(a1 + 5792) = 0;
  bzero((void *)(a1 + 5800), 0x2778uLL);
  *(_DWORD *)(a1 + 5844) = 100;
  *(_DWORD *)(a1 + 7052) = 100;
  *(unsigned char *)(a1 + 8256) = 1;
  *(_OWORD *)(a1 + 8268) = 0u;
  *(_DWORD *)(a1 + 8288) = 100;
  *(unsigned char *)(a1 + 8692) = 1;
  *(_OWORD *)(a1 + 8704) = 0u;
  *(_DWORD *)(a1 + 8724) = 100;
  *(_DWORD *)(a1 + 9132) = 40;
  *(_OWORD *)(a1 + 9616) = 0u;
  *(_OWORD *)(a1 + 9632) = 0u;
  *(void *)(a1 + 9648) = 0;
  *(_DWORD *)(a1 + 9660) = 200;
  *(void *)(a1 + 12184) = 0;
  *(_OWORD *)(a1 + 12192) = 0u;
  *(unsigned char *)(a1 + 12208) = 0;
  *(_WORD *)(a1 + 12160) = 0;
  *(_OWORD *)(a1 + 12144) = 0u;
  *(_OWORD *)(a1 + 12128) = 0u;
  *(_OWORD *)(a1 + 12112) = 0u;
  *(_OWORD *)(a1 + 12096) = 0u;
  *(_OWORD *)(a1 + 12080) = 0u;
  *(_OWORD *)(a1 + 12064) = 0u;
  *(_DWORD *)(a1 + 12224) = 200;
  *uint64_t v5 = 1;
  *(_OWORD *)(a1 + 14640) = 0u;
  *(_DWORD *)(a1 + 14660) = 40;
  *(_OWORD *)(a1 + 14836) = 0u;
  v5[196] = 1;
  *(_DWORD *)(a1 + 14856) = 40;
  *(unsigned char *)uint64_t v4 = 1;
  *(_OWORD *)(a1 + 15032) = 0u;
  *(_DWORD *)(a1 + 15052) = 200;
  *(void *)(a1 + 15872) = 0;
  *(_DWORD *)(a1 + 15880) = 0;
  *(_OWORD *)(a1 + 15856) = 0u;
  __asm { FMOV            V0.2S, #5.0 }
  *(void *)(a1 + 15904) = _D0;
  *(void *)(a1 + 15928) = 0;
  *(void *)(a1 + 15912) = 0;
  *(void *)(a1 + 15920) = 0;
  *(_DWORD *)(a1 + 15936) = 1065353216;
  sub_1902D9ACC((float32x4_t *)(a1 + 15924), (float32x4_t)_D0);
  *(unsigned char *)(v4 + 920) = 0;
  *(_DWORD *)(a1 + 15944) = 0;
  *(_OWORD *)(a1 + 15952) = 0u;
  *(_OWORD *)(a1 + 15968) = 0u;
  *(_OWORD *)(a1 + 15984) = 0u;
  *(_OWORD *)(a1 + 16000) = 0u;
  *(_DWORD *)(a1 + 16016) = 1065353216;
  sub_1902D9ACC((float32x4_t *)(a1 + 16004), (float32x4_t)0);
  *(unsigned char *)(v4 + 1000) = 0;
  *(void *)(a1 + 16024) = 0;
  *(_DWORD *)(a1 + 16032) = 0;
  *(unsigned char *)(v4 + 1016) = 0;
  *(unsigned char *)(v4 + 1020) = 0;
  *(void *)(a1 + 16048) = 0;
  *(_DWORD *)(a1 + 16056) = 1;
  *(_WORD *)(v4 + 1040) = 1;
  *(unsigned char *)(v4 + 1042) = 0;
  sub_190473210(a1 + 16064);
  *(void *)(a1 + 26968) = 0x600000000;
  *(void *)(a1 + 27216) = 0x500000000;
  *(void *)(a1 + 26960) = 4;
  sub_19050F2A8(a1 + 27344);
  *(_WORD *)(a1 + 27520) = 0;
  *(_WORD *)(a1 + 27532) = 0;
  *(_DWORD *)(a1 + 27536) = 0;
  *(void *)(a1 + 27544) = 0;
  sub_19042B3BC(a1 + 27552);
}

void sub_1904F71CC(_Unwind_Exception *a1)
{
  sub_19050212C(v2);
  sub_1905021A8((void *)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1904F71FC(unsigned int *a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*a1 != a2)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    uint64_t v4 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
    {
      unsigned int v5 = *a1;
      *(_DWORD *)int buf = 67109376;
      unsigned int v12 = v5;
      __int16 v13 = 1024;
      unsigned int v14 = a2;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "[RelDMService] Client mode changed from %d to %d", buf, 0xEu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      int v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::setClientMode(const CMRelDM::ClientMode, const BOOL)", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    *a1 = a2;
    if (a2 >= 5)
    {
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      int32x2_t v7 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 67109120;
        unsigned int v12 = a2;
        _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_ERROR, "[RelDMService] Received unexpected client type: %d. Defaulting behavior to kVideo.", buf, 8u);
      }
      int v8 = sub_1902D8400(115, 0);
      LOBYTE(v6) = 0;
      if (v8)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        int v10 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMService::setClientMode(const CMRelDM::ClientMode, const BOOL)", "CoreLocation: %s\n", v10);
        if (v10 != (char *)buf) {
          free(v10);
        }
        LOBYTE(v6) = 0;
      }
    }
    else
    {
      unint64_t v6 = 0x1010100uLL >> (8 * a2);
    }
    sub_1904F7554((uint64_t)a1, v6);
  }
}

void sub_1904F7554(uint64_t a1, int a2)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (unsigned char *)(a1 + 37449);
  unsigned int v5 = (unsigned __int8 *)(a1 + 16058);
  int v6 = *(unsigned __int8 *)(a1 + 4);
  if (v6 == a2) {
    int v7 = 0;
  }
  else {
    int v7 = *(unsigned char *)(a1 + 4) && (*v4 ? (v8 = a2 == 0) : (v8 = 0), v8 ? (v9 = v6 == 1) : (v9 = 0), v9)
  }
      || (*(unsigned __int8 *)(a1 + 16059) | *(unsigned __int8 *)(a1 + 16058)) != 0;
  if (*(unsigned char *)(a1 + 5)) {
    char v10 = v7;
  }
  else {
    char v10 = 1;
  }
  if (*(unsigned __int8 *)(a1 + 5) == v7)
  {
    if (v7) {
      return;
    }
    goto LABEL_17;
  }
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  uint64_t v15 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
  {
    int v16 = *(unsigned __int8 *)(a1 + 5);
    int v17 = *(unsigned __int8 *)(a1 + 4);
    if (*(unsigned char *)(a1 + 4)) {
      BOOL v18 = *v4 != 0;
    }
    else {
      BOOL v18 = 0;
    }
    int v19 = v5[1];
    int v20 = *v5;
    *(_DWORD *)int buf = 67110656;
    int v37 = v16;
    __int16 v38 = 1024;
    int v39 = v7;
    __int16 v40 = 1024;
    BOOL v41 = v17;
    __int16 v42 = 1024;
    int v43 = a2;
    __int16 v44 = 1024;
    BOOL v45 = v18;
    __int16 v46 = 1024;
    int v47 = v19;
    __int16 v48 = 1024;
    int v49 = v20;
    _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_INFO, "[RelDMService] fDelaySetTrackingBehaviorState changed from %d to %d, current fTrackingBehavior: %d, requested trackingBehavior %d, getInSteadyStatePedestrian: %d, fInComplexTransitionState: %d, fDisableTracking: %d.", buf, 0x2Cu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    long long v31 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::setTrackingBehavior(CMRelDM::TrackingBehavior)", "CoreLocation: %s\n", v31);
    if (v31 != (char *)buf) {
      free(v31);
    }
  }
  *(unsigned char *)(a1 + 5) = v7;
  if (v7)
  {
    *(unsigned char *)(a1 + 6) = a2;
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    uint64_t v21 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
    {
      int v22 = *(unsigned __int8 *)(a1 + 4);
      if (*(unsigned char *)(a1 + 4)) {
        int v23 = *v4;
      }
      else {
        int v23 = 0;
      }
      int v27 = v5[1];
      int v28 = *v5;
      *(_DWORD *)int buf = 67110144;
      int v37 = v22;
      __int16 v38 = 1024;
      int v39 = a2;
      __int16 v40 = 1024;
      BOOL v41 = v23;
      __int16 v42 = 1024;
      int v43 = v27;
      __int16 v44 = 1024;
      BOOL v45 = v28;
      _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_INFO, "[RelDMService] Delaying tracking behavior update from %d to %d, getInSteadyStatePedestrian: %d, inComplexTransitionState: %d, fDisableTracking: %d.", buf, 0x20u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      uint64_t v33 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::setTrackingBehavior(CMRelDM::TrackingBehavior)", "CoreLocation: %s\n", v33);
      if (v33 != (char *)buf) {
        free(v33);
      }
    }
  }
  else if (*(unsigned __int8 *)(a1 + 4) != a2)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    char v24 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
    {
      int v25 = *(unsigned __int8 *)(a1 + 4);
      if (*(unsigned char *)(a1 + 4)) {
        BOOL v26 = *v4 != 0;
      }
      else {
        BOOL v26 = 0;
      }
      int v29 = v5[1];
      int v30 = *v5;
      *(_DWORD *)int buf = 67110144;
      int v37 = v25;
      __int16 v38 = 1024;
      int v39 = a2;
      __int16 v40 = 1024;
      BOOL v41 = v26;
      __int16 v42 = 1024;
      int v43 = v29;
      __int16 v44 = 1024;
      BOOL v45 = v30;
      _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_INFO, "[RelDMService] The previously delayed tracking behavior update from %d to %d will now occur, getInSteadyStatePedestrian: %d, inComplexTransitionState: %d, fDisableTracking: %d.", buf, 0x20u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      std::string v34 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::setTrackingBehavior(CMRelDM::TrackingBehavior)", "CoreLocation: %s\n", v34);
      if (v34 != (char *)buf) {
        free(v34);
      }
    }
    if (!*(unsigned char *)(a1 + 5))
    {
LABEL_17:
      if (*(unsigned __int8 *)(a1 + 4) != a2)
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        int v11 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
        {
          int v12 = *(unsigned __int8 *)(a1 + 4);
          *(_DWORD *)int buf = 67109376;
          int v37 = v12;
          __int16 v38 = 1024;
          int v39 = a2;
          _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_INFO, "[RelDMService] Tracking behavior changed from %d to %d", buf, 0xEu);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          int64_t v32 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::setTrackingBehavior(CMRelDM::TrackingBehavior)", "CoreLocation: %s\n", v32);
          if (v32 != (char *)buf) {
            free(v32);
          }
        }
        *(unsigned char *)(a1 + 4) = a2;
        sub_19042B644((unint64_t *)(a1 + 27552), a2);
        sub_190563264(a1 + 15904, a2);
        sub_190480AD8(a1 + 5840, a2);
        if ((v10 & 1) == 0 && *(void *)(a1 + 32))
        {
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          __int16 v13 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)int buf = 0;
            _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_INFO, "[RelDMService] Notifying delayed tracking behavior update callback subscribers.", buf, 2u);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
            }
            uint64_t v35 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::setTrackingBehavior(CMRelDM::TrackingBehavior)", "CoreLocation: %s\n", v35);
            if (v35 != (char *)buf) {
              free(v35);
            }
          }
          uint64_t v14 = *(void *)(a1 + 32);
          if (!v14) {
            sub_19050222C();
          }
          (*(void (**)(uint64_t))(*(void *)v14 + 48))(v14);
        }
      }
    }
  }
}

void *sub_1904F7EFC(uint64_t a1, void *a2)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 32))
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    uint64_t v4 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "[RelDMService] Overwriting existing fDelayedTrackingBehaviorUpdateCallback", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      LOWORD(v13[0]) = 0;
      char v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::subscribeDelayedTrackingBehaviorUpdateCallback(std::function<void ()>)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  unsigned int v5 = (void *)a2[3];
  if (v5)
  {
    if (v5 == a2)
    {
      int v12 = buf;
      (*(void (**)(void *, uint8_t *))(*a2 + 24))(a2, buf);
    }
    else
    {
      int v12 = (uint8_t *)(*(uint64_t (**)(void *))(*v5 + 16))(v5);
    }
  }
  else
  {
    int v12 = 0;
  }
  uint64_t v6 = a1 + 8;
  if (buf != (uint8_t *)(a1 + 8))
  {
    int v7 = v12;
    uint64_t v8 = *(void *)(a1 + 32);
    if (v12 == buf)
    {
      if (v8 == v6)
      {
        (*(void (**)(uint8_t *, void *))(*(void *)buf + 24))(buf, v13);
        (*(void (**)(uint8_t *))(*(void *)v12 + 32))(v12);
        int v12 = 0;
        (*(void (**)(void, uint8_t *))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32), buf);
        (*(void (**)(void))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32));
        *(void *)(a1 + 32) = 0;
        int v12 = buf;
        (*(void (**)(void *, uint64_t))(v13[0] + 24))(v13, a1 + 8);
        (*(void (**)(void *))(v13[0] + 32))(v13);
      }
      else
      {
        (*(void (**)(uint8_t *, uint64_t))(*(void *)buf + 24))(buf, a1 + 8);
        (*(void (**)(uint8_t *))(*(void *)v12 + 32))(v12);
        int v12 = *(uint8_t **)(a1 + 32);
      }
      *(void *)(a1 + 32) = v6;
    }
    else if (v8 == v6)
    {
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v6 + 24))(a1 + 8, buf);
      (*(void (**)(void))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32));
      *(void *)(a1 + 32) = v12;
      int v12 = buf;
    }
    else
    {
      int v12 = *(uint8_t **)(a1 + 32);
      *(void *)(a1 + 32) = v7;
    }
  }
  return sub_1905021A8(buf);
}

void sub_1904F833C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_1902E67BC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1904F8348(uint64_t a1, int a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1 + 5196;
  if (a2)
  {
    *(_DWORD *)(a1 + 5192) = 0;
    *(_OWORD *)uint64_t v3 = xmmword_19060AFA0;
    *(_DWORD *)(a1 + 5176) = 0;
    *(void *)(a1 + 5184) = 0;
    *(_DWORD *)(a1 + 944) = 0;
    *(_DWORD *)(a1 + 2152) = 0;
    *(_DWORD *)(a1 + 3760) = 0;
    *(_DWORD *)(a1 + 100) = 0;
    *(_OWORD *)(a1 + 720) = 0u;
    *(_DWORD *)(a1 + 736) = 0;
    *(_OWORD *)(a1 + 5408) = 0u;
    *(unsigned char *)(a1 + 708) = 1;
    *(_DWORD *)(a1 + 4568) = 0;
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    uint64_t v4 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEFAULT, "[RelDMService] Clearing src buffers.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      unsigned int v5 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::clearAll(BOOL)", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
  *(_DWORD *)(a1 + 5424) = 0;
  *(_DWORD *)(a1 + 5468) = 0;
  *(void *)(a1 + 5460) = 0;
  *(void *)(a1 + 5452) = 0;
  *(unsigned char *)(v3 + 244) = 1;
  sub_190480CD4(a1 + 5840, 0);
  sub_19042B5C8((unint64_t *)(a1 + 27552));
}

void sub_1904F86F0(uint64_t a1, int a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  sub_1904F8348(a1, a2 ^ 1);
}

void sub_1904F893C(uint64_t a1, int a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 52) = 0;
  *(void *)(a1 + 57) = 0;
  *(_DWORD *)(a1 + 92) = 1;
  *(_DWORD *)(a1 + 96) = 1065749138;
  *(_DWORD *)(a1 + 160) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  if (a2)
  {
    uint64_t v7 = 0;
    *(_OWORD *)int buf = 0u;
    long long v6 = 0u;
    *(_DWORD *)&unsigned char buf[12] = 1065353216;
    sub_1902D9ACC((float32x4_t *)buf, (float32x4_t)0);
    *(_OWORD *)a1 = *(_OWORD *)buf;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 92) = 0;
  }
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  uint64_t v3 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "[PerceptualFilter] resetting", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMAudioPerceptualFilter::reset(BOOL)", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
}

void sub_1904F8B2C(_DWORD *a1, int a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a1[10] != a2)
  {
    a1[10] = a2;
    if (!a2)
    {
      a1[6606] = 0;
      a1[6612] = 0;
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    uint64_t v3 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = a1[10];
      *(_DWORD *)int buf = 67240192;
      int v7 = v4;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "[RelDMService] Setting scheme to %{public}d", buf, 8u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      unsigned int v5 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::setScheme(TrackingScheme)", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf) {
        free(v5);
      }
    }
  }
}

void sub_1904F8D04(uint64_t a1, int a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (unsigned char *)(a1 + 37408);
  if (*(unsigned __int8 *)(a1 + 37408) != a2)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    unsigned int v5 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      long long v6 = "true";
      if (*v2) {
        int v7 = "true";
      }
      else {
        int v7 = "false";
      }
      if (!a2) {
        long long v6 = "false";
      }
      *(_DWORD *)int buf = 136315394;
      int v11 = v7;
      __int16 v12 = 2080;
      __int16 v13 = v6;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_DEFAULT, "[RelDMService] Online headToHeadsetTransformationEstimation changed from: %s  to:%s", buf, 0x16u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      BOOL v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::enableOnlineHeadToHeadsetTransformationEstimator(BOOL)", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
    unsigned char *v2 = a2;
    if ((a2 & 1) == 0) {
      sub_1905E1560(a1 + 33656, v8);
    }
  }
}

uint64_t sub_1904F8F44(uint64_t result)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(result + 16058))
  {
    *(unsigned char *)(result + 16058) = 1;
    sub_1904F86F0(result, 1);
  }
  return result;
}

void sub_1904F90EC(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 16058))
  {
    *(unsigned char *)(a1 + 16058) = 0;
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    uint64_t v1 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v1, OS_LOG_TYPE_DEFAULT, "[RelDMService] Tracking is re-enabled.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      uint64_t v2 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::enableTracking()", "CoreLocation: %s\n", v2);
      if (v2 != (char *)buf) {
        free(v2);
      }
    }
  }
}

BOOL sub_1904F9288(uint64_t a1, unint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 16058))
  {
    BOOL result = 0;
    *(void *)(a1 + 5256) = 0;
    return result;
  }
  if (*(unsigned char *)(a1 + 708)) {
    sub_190430068(a1 + 708);
  }
  float v4 = *(float *)(a1 + 716);
  if (v4 < 0.0) {
    float v4 = 0.0;
  }
  if (v4 >= 0.00005)
  {
    *(void *)(a1 + 5256) = a2;
    unint64_t v5 = a2;
    if (a2) {
      goto LABEL_8;
    }
LABEL_11:
    float v6 = 3.4028e38;
    goto LABEL_12;
  }
  unint64_t v5 = *(void *)(a1 + 5256);
  if (!v5) {
    goto LABEL_11;
  }
LABEL_8:
  float v6 = (float)(a2 - v5) * 0.000001;
LABEL_12:
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  float32x4_t v8 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
  {
    double v9 = sub_19058BDA8(a1 + 5216, a2);
    if (*(unsigned char *)(a1 + 708)) {
      sub_190430068(a1 + 708);
    }
    float v10 = *(float *)(a1 + 716);
    if (v10 < 0.0) {
      float v10 = 0.0;
    }
    *(_DWORD *)int buf = 134218496;
    double v13 = v9;
    __int16 v14 = 2048;
    double v15 = v10;
    __int16 v16 = 2048;
    double v17 = v6;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEBUG, "[RelDMService] moveDuration, %.3f, var, %.4f, timeSinceAccelNonStatic, %.3f", buf, 0x20u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    sub_19058BDA8(a1 + 5216, a2);
    if (*(unsigned char *)(a1 + 708)) {
      sub_190430068(a1 + 708);
    }
    int v11 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::isSrcInMovingStateWhenTrackingDisabled(uint64_t)", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
  return sub_19058BDA8(a1 + 5216, a2) >= 0.4 && v6 <= 0.4;
}

uint64_t sub_1904F959C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(void *)(a1 + 5784);
  if (v8) {
    BOOL v9 = v8 >= a3;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    float v10 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = 0;
      double v12 = *(double *)(a1 + 5784);
      float v13 = 0.0;
      do
      {
        float v13 = v13 + (float)(*(float *)(a2 + v11) * *(float *)(a2 + v11));
        v11 += 4;
      }
      while (v11 != 12);
      int v14 = *(_DWORD *)(a2 + 48);
      *(_DWORD *)int buf = 134219008;
      double v42 = v12;
      __int16 v43 = 2048;
      unint64_t v44 = a3;
      __int16 v45 = 2048;
      double v46 = (float)(sqrtf(v13) * 57.296);
      __int16 v47 = 1024;
      int v48 = v14;
      __int16 v49 = 2048;
      double v50 = (float)((float)(a3 - *(void *)&v12) / 1000000.0);
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_DEBUG, "[RelDMService] ReEnable/SitStandFSM: ts, %llu, inputTS, %llu, rot, %.3f, qMode, %d, staticDuration, %.3f", buf, 0x30u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      uint64_t v35 = 0;
      float v36 = 0.0;
      do
      {
        float v36 = v36 + (float)(*(float *)(a2 + v35) * *(float *)(a2 + v35));
        v35 += 4;
      }
      while (v35 != 12);
      int v37 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::isAuxInStaticState(const IMUData &, const uint64_t, const uint64_t)", "CoreLocation: %s\n", v37);
      if (v37 != (char *)buf) {
        free(v37);
      }
    }
  }
  uint64_t v15 = *(void *)(a1 + 5776);
  if (v15) {
    BOOL v16 = v15 + 1000000 >= a3;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16)
  {
    *(void *)(a1 + 5784) = 0;
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    double v17 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
    {
      double v18 = (float)((float)(a3 - *(void *)(a1 + 5776)) / 1000000.0);
      *(_DWORD *)int buf = 134217984;
      double v42 = v18;
      _os_log_impl(&dword_1902AF000, v17, OS_LOG_TYPE_DEBUG, "[RelDMService] large gap in aux data, %.3f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      __int16 v38 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::isAuxInStaticState(const IMUData &, const uint64_t, const uint64_t)", "CoreLocation: %s\n", v38);
      if (v38 != (char *)buf) {
        free(v38);
      }
    }
  }
  uint64_t v19 = 0;
  unint64_t v20 = *(void *)(a1 + 5776);
  *(void *)(a1 + 5776) = a3;
  float v21 = 0.0;
  do
  {
    float v21 = v21 + (float)(*(float *)(a2 + v19) * *(float *)(a2 + v19));
    v19 += 4;
  }
  while (v19 != 12);
  if (a3 <= v20 || v20 == 0) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = a3 - v20;
  }
  if (sqrtf(v21) > 0.34907) {
    ++*(_DWORD *)(a1 + 5792);
  }
  int v24 = *(_DWORD *)(a2 + 48);
  if (!v24 || *(_DWORD *)(a1 + 5792) >= 3u)
  {
    if (*(unsigned char *)(a1 + 16058) && *(void *)(a1 + 5784))
    {
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      int v25 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_DEBUG, "[RelDMService] ReEnable/SitStandFSM: movement terminated static period.", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        int v39 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::isAuxInStaticState(const IMUData &, const uint64_t, const uint64_t)", "CoreLocation: %s\n", v39);
        if (v39 != (char *)buf) {
          free(v39);
        }
      }
    }
    uint64_t result = 0;
    *(void *)(a1 + 5784) = 0;
    *(_DWORD *)(a1 + 5792) = 0;
    return result;
  }
  uint64_t v27 = *(void *)(a1 + 5784);
  if (v27)
  {
    if (v24 == 2)
    {
      v27 += v23;
      *(void *)(a1 + 5784) = v27;
    }
    if (v27 + a4 < a3)
    {
      if (*(unsigned char *)(a1 + 16058))
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        int v28 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          double v29 = (float)((a3 - *(void *)(a1 + 5784)) / 0xF4240);
          *(_DWORD *)int buf = 134349056;
          double v42 = v29;
          _os_log_impl(&dword_1902AF000, v28, OS_LOG_TYPE_DEFAULT, "[RelDMService] ReEnable: reached staticDuration, %{public}.3f", buf, 0xCu);
        }
        if (!sub_1902D8400(115, 2)) {
          goto LABEL_69;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 == -1)
        {
LABEL_86:
          __int16 v40 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::isAuxInStaticState(const IMUData &, const uint64_t, const uint64_t)", "CoreLocation: %s\n", v40);
          if (v40 != (char *)buf) {
            free(v40);
          }
LABEL_69:
          *(_DWORD *)(a1 + 5792) = 0;
          return 1;
        }
      }
      else
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        uint64_t v33 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
        {
          double v34 = (float)((a3 - *(void *)(a1 + 5784)) / 0xF4240);
          *(_DWORD *)int buf = 134349056;
          double v42 = v34;
          _os_log_impl(&dword_1902AF000, v33, OS_LOG_TYPE_DEBUG, "[RelDMService] SitStandFSM: reached staticDuration, %{public}.3f", buf, 0xCu);
        }
        if (!sub_1902D8400(115, 2)) {
          goto LABEL_69;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 == -1) {
          goto LABEL_86;
        }
      }
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      goto LABEL_86;
    }
  }
  else
  {
    *(void *)(a1 + 5784) = a3;
  }
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  int v30 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
  {
    double v31 = *(double *)(a1 + 5784);
    *(_DWORD *)int buf = 134217984;
    double v42 = v31;
    _os_log_impl(&dword_1902AF000, v30, OS_LOG_TYPE_DEBUG, "[RelDMService] ReEnable/SitStandFSM: gettingStatic, ts, %llu", buf, 0xCu);
  }
  uint64_t result = sub_1902D8400(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    int64_t v32 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::isAuxInStaticState(const IMUData &, const uint64_t, const uint64_t)", "CoreLocation: %s\n", v32);
    if (v32 != (char *)buf) {
      free(v32);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1904F9FE8(uint64_t a1, unint64_t a2, unsigned char *a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  *a3 = 0;
  if (!*(_WORD *)(a1 + 3762)) {
    return 1;
  }
  uint64_t v5 = a1 + 3768;
  unint64_t v6 = *(unsigned __int16 *)(a1 + 3762) + (unint64_t)*(unsigned __int16 *)(a1 + 3760) - 1;
  unint64_t v7 = *(unsigned int *)(a1 + 3764);
  if (v6 < v7) {
    unint64_t v7 = 0;
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v6 - v7));
  if (v8 >= a2)
  {
    if (v8 - a2 <= 0x9C3)
    {
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      uint64_t v15 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
      {
        unint64_t v16 = *(unsigned __int16 *)(a1 + 3760) + (unint64_t)*(unsigned __int16 *)(a1 + 3762) - 1;
        unint64_t v17 = *(unsigned int *)(a1 + 3764);
        if (v16 < v17) {
          unint64_t v17 = 0;
        }
        unint64_t v18 = *(void *)(v5 + 8 * (v16 - v17));
        *(_DWORD *)int buf = 134349312;
        unint64_t v32 = a2;
        __int16 v33 = 2050;
        unint64_t v34 = v18;
        _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_DEBUG, "[RelDMService] Src IMU timestamp went backwards. curr=%{public}llu, last=%{public}llu", buf, 0x16u);
      }
      uint64_t result = sub_1902D8400(115, 2);
      if (!result) {
        return result;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      uint64_t v19 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::checkSrcIMUTimestamp(uint64_t, BOOL &) const", "CoreLocation: %s\n");
LABEL_49:
      if (v19 != buf) {
        free(v19);
      }
      return 0;
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    unint64_t v20 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      unint64_t v21 = *(unsigned __int16 *)(a1 + 3760) + (unint64_t)*(unsigned __int16 *)(a1 + 3762) - 1;
      unint64_t v22 = *(unsigned int *)(a1 + 3764);
      if (v21 < v22) {
        unint64_t v22 = 0;
      }
      unint64_t v23 = *(void *)(v5 + 8 * (v21 - v22));
      *(_DWORD *)int buf = 134349312;
      unint64_t v32 = a2;
      __int16 v33 = 2050;
      unint64_t v34 = v23;
      _os_log_impl(&dword_1902AF000, v20, OS_LOG_TYPE_ERROR, "[RelDMService] Src IMU sample time went backwards. curr=%{public}llu, last=%{public}llu", buf, 0x16u);
    }
    int v24 = sub_1902D8400(115, 0);
    uint64_t result = 0;
    if (!v24) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 == -1)
    {
LABEL_48:
      uint64_t v19 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "BOOL CMRelDMService::checkSrcIMUTimestamp(uint64_t, BOOL &) const", "CoreLocation: %s\n");
      goto LABEL_49;
    }
LABEL_52:
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    goto LABEL_48;
  }
  unint64_t v9 = a2 - v8;
  if (a2 - v8 < 0x1D4D) {
    return 1;
  }
  if (v9 <= 0x4E20)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    float v10 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v11 = *(unsigned __int16 *)(a1 + 3760) + (unint64_t)*(unsigned __int16 *)(a1 + 3762) - 1;
      unint64_t v12 = *(unsigned int *)(a1 + 3764);
      if (v11 < v12) {
        unint64_t v12 = 0;
      }
      unint64_t v13 = *(void *)(v5 + 8 * (v11 - v12));
      *(_DWORD *)int buf = 134350080;
      unint64_t v32 = v13;
      __int16 v33 = 2050;
      unint64_t v34 = a2;
      __int16 v35 = 1026;
      int v36 = 7500;
      __int16 v37 = 2050;
      unint64_t v38 = v9;
      __int16 v39 = 1026;
      int v40 = 20000;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_DEBUG, "[RelDMService] Src IMU sample time interval is large. last=%{public}llu, new=%{public}llu, %{public}u < dt=%{public}llu <= %{public}u", buf, 0x2Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      int v30 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::checkSrcIMUTimestamp(uint64_t, BOOL &) const", "CoreLocation: %s\n", v30);
      if (v30 != (char *)buf) {
        free(v30);
      }
    }
    return 1;
  }
  *a3 = 1;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  int v25 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
  {
    unint64_t v26 = *(unsigned __int16 *)(a1 + 3760) + (unint64_t)*(unsigned __int16 *)(a1 + 3762) - 1;
    unint64_t v27 = *(unsigned int *)(a1 + 3764);
    if (v26 < v27) {
      unint64_t v27 = 0;
    }
    unint64_t v28 = *(void *)(v5 + 8 * (v26 - v27));
    *(_DWORD *)int buf = 134349824;
    unint64_t v32 = v28;
    __int16 v33 = 2050;
    unint64_t v34 = a2;
    __int16 v35 = 1026;
    int v36 = 7500;
    __int16 v37 = 2050;
    unint64_t v38 = v9;
    _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_ERROR, "[RelDMService] Src IMU sample time interval is unexpectedly large. last=%{public}lluus , new=%{public}lluus, %{public}u < dt=%{public}lluus", buf, 0x26u);
  }
  int v29 = sub_1902D8400(115, 0);
  uint64_t result = 0;
  if (v29)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 == -1) {
      goto LABEL_48;
    }
    goto LABEL_52;
  }
  return result;
}

uint64_t sub_1904FA778(uint64_t a1, unint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 16064))
  {
    unint64_t v3 = *(void *)(a1 + 5408);
    if (v3)
    {
      if ((float)((float)v3 + 1000000.0) < (float)a2)
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        uint64_t v5 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
        {
          uint64_t v6 = *(void *)(a1 + 5408);
          *(_DWORD *)int buf = 134349568;
          unint64_t v10 = a2;
          __int16 v11 = 2050;
          uint64_t v12 = v6;
          __int16 v13 = 2050;
          double v14 = (double)(a2 - v6) * 0.000001;
          _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_ERROR, "[RelDMService] Unexpectedly large time interval since last aux IMU sample, resetting. timestamp, %{public}llu, fLastAuxGyroTimestamp, %{public}llu, dt, %{public}f s", buf, 0x20u);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          unint64_t v8 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "BOOL CMRelDMService::checkForLargeAuxDataGap(const uint64_t)", "CoreLocation: %s\n", v8);
          if (v8 != (char *)buf) {
            free(v8);
          }
        }
        sub_1904F86F0(a1, 1);
      }
    }
  }
  return 0;
}

uint64_t sub_1904FA9F0(float32x2_t *a1, _OWORD *a2, float32x2_t *a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  sub_19058B97C((int *)&a1[652], a6);
  sub_1904FA778((uint64_t)a1, a6);
  char v24 = 0;
  uint64_t result = sub_1904F9FE8((uint64_t)a1, a6, &v24);
  if (result)
  {
    sub_1904FABA0(a1 + 649, a3);
    __int32 v13 = a1[647].i32[0];
    if ((v13 & 1) == 0)
    {
      sub_19042FFA8((unsigned __int16 *)&a1[12] + 2, (uint64_t)a3);
      uint64_t v14 = 0;
      float v15 = 0.0;
      do
      {
        float v15 = v15 + (float)(a3->f32[v14] * a3->f32[v14]);
        ++v14;
      }
      while (v14 != 3);
      float v23 = sqrtf(v15);
      sub_19042D76C((uint64_t)&a1[88] + 4, &v23);
      sub_19042FFA8((unsigned __int16 *)&a1[571], a5);
      __int32 v13 = 0;
    }
    a1[647].i32[0] = v13 + 1;
    sub_19042FFA8((unsigned __int16 *)&a1[118], a4);
    uint64_t result = (uint64_t)sub_1904FAC28((unsigned __int16 *)&a1[269], a2);
    uint64_t v16 = a1[470].u16[1];
    unint64_t v17 = a1[470].u32[1];
    uint64_t v18 = a1[470].u16[0];
    if (v18 + v16 >= v17) {
      uint64_t v19 = a1[470].u32[1];
    }
    else {
      uint64_t v19 = 0;
    }
    a1[v18 + v16 - v19 + 471] = (float32x2_t)a6;
    if (v17 <= v16)
    {
      unint64_t v20 = v18 + 1;
      if (v20 >= v17) {
        __int16 v21 = v17;
      }
      else {
        __int16 v21 = 0;
      }
      a1[470].i16[0] = v20 - v21;
    }
    else
    {
      LOWORD(v16) = v16 + 1;
      a1[470].i16[1] = v16;
      LODWORD(v16) = (unsigned __int16)v16;
    }
    float32x2_t v22 = a1[648];
    if (v22)
    {
      if (v17 == v16) {
        a1[648] = (float32x2_t)(*(void *)&v22 - 1);
      }
    }
  }
  else if (v24)
  {
    sub_1904F8348((uint64_t)a1, 1);
  }
  return result;
}

float32x2_t *sub_1904FABA0(float32x2_t *result, float32x2_t *a2)
{
  int v2 = result->i32[0];
  int v3 = result->i32[0] + 1;
  result->i32[0] = v3;
  float v4 = a2[1].f32[0];
  if (v2 > 2)
  {
    float v7 = result->f32[1];
    float v8 = result[2].f32[0];
    result[1] = vsub_f32(result[1], vmul_n_f32(vsub_f32(result[1], *a2), v7));
    float v6 = v8 - (float)(v7 * (float)(v8 - v4));
  }
  else
  {
    float v5 = 1.0 / (float)v3;
    float v6 = v5 * (float)((float)(result[2].f32[0] * (float)v2) + v4);
    result[1] = vmul_n_f32(vadd_f32(vmul_n_f32(result[1], (float)v2), *a2), v5);
  }
  result[2].f32[0] = v6;
  return result;
}

unsigned __int16 *sub_1904FAC28(unsigned __int16 *result, _OWORD *a2)
{
  unint64_t v2 = *((unsigned int *)result + 1);
  unint64_t v3 = *result + (unint64_t)result[1];
  if (v3 < v2) {
    unint64_t v2 = 0;
  }
  *(_OWORD *)&result[8 * (v3 - v2) + 4] = *a2;
  unsigned int v4 = result[1];
  unint64_t v5 = *((unsigned int *)result + 1);
  if (v5 <= v4)
  {
    unint64_t v6 = *result + 1;
    if (v6 < v5) {
      LOWORD(v5) = 0;
    }
    *uint64_t result = v6 - v5;
  }
  else
  {
    result[1] = v4 + 1;
  }
  return result;
}

void sub_1904FAC88(uint64_t a1, float32x2_t *a2, float *a3, unint64_t a4, float a5)
{
  uint64_t v184 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = (float32x2_t *)(a1 + 33592);
  uint64_t v11 = a1 + 15940;
  if ((*(_DWORD *)(a1 + 40) == 1 || *(unsigned char *)(a1 + 37408)) && *(unsigned char *)(a1 + 33672))
  {
    sub_1905E224C(a1 + 33656, a2, a4, 180.0);
    __int32 v12 = v10[9].i32[1];
    v13.f32[0] = -v10[9].f32[0];
    *(float32x2_t *)int buf = vneg_f32(v10[8]);
    *(_DWORD *)&uint8_t buf[8] = v13.i32[0];
    *(_DWORD *)&unsigned char buf[12] = v12;
    sub_1902D9ACC((float32x4_t *)buf, v13);
    sub_1904CF474((float32x4_t *)buf, &v121);
    uint64_t v14 = (float32x2_t *)sub_190479348(a1 + 64);
    __int32 v15 = v14[1].i32[1];
    v16.f32[0] = -v14[1].f32[0];
    *(float32x2_t *)BOOL v133 = vneg_f32(*v14);
    *(_DWORD *)&v133[8] = v16.i32[0];
    *(_DWORD *)double v134 = v15;
    float32x4_t v17 = sub_1902D9ACC((float32x4_t *)v133, v16);
    sub_1904CF3F4((uint64_t)&v121, (float *)v133, (float32x4_t *)buf, v17);
    float v18 = sub_1904CF8B4((float32x4_t *)buf);
    uint64_t v19 = 0;
    v130.i64[0] = __PAIR64__(v20, LODWORD(v18));
    v130.i32[2] = v21;
    float v22 = 0.0;
    do
    {
      float v22 = v22 + (float)(v130.f32[v19] * v130.f32[v19]);
      ++v19;
    }
    while (v19 != 3);
    float v23 = sqrtf(v22);
    if (v23 > 0.017453)
    {
      sub_1904CF474((float32x4_t *)(a1 + 37392), &v130);
      char v24 = a3;
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      int v25 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
      {
        double v116 = *(float *)sub_190479348(a1 + 64);
        double v114 = *(float *)(sub_190479348(a1 + 64) + 4);
        double v112 = *(float *)(sub_190479348(a1 + 64) + 8);
        double v26 = *(float *)(sub_190479348(a1 + 64) + 12);
        double v27 = v121.f32[0];
        float v119 = a5;
        double v28 = v121.f32[1];
        double v29 = v121.f32[2];
        double v30 = v130.f32[0];
        double v31 = v130.f32[1];
        double v32 = v130.f32[2];
        double v108 = v130.f32[3];
        double v109 = v121.f32[3];
        *(double *)v33.i64 = v23;
        float v34 = sub_1905E24A8(v10 + 8, v33);
        *(_DWORD *)int buf = 134352384;
        *(double *)&uint8_t buf[4] = v116;
        *(_WORD *)&unsigned char buf[12] = 2050;
        *(double *)&buf[14] = v114;
        __int16 v160 = 2050;
        double v161 = v112;
        __int16 v162 = 2050;
        double v163 = v26;
        __int16 v164 = 2050;
        double v165 = v27;
        __int16 v166 = 2050;
        double v167 = v28;
        a5 = v119;
        __int16 v168 = 2050;
        double v169 = v29;
        __int16 v170 = 2050;
        double v171 = v109;
        __int16 v172 = 2050;
        double v173 = v30;
        __int16 v174 = 2050;
        double v175 = v31;
        __int16 v176 = 2050;
        double v177 = v32;
        __int16 v178 = 2050;
        double v179 = v108;
        __int16 v180 = 2050;
        double v181 = v23;
        __int16 v182 = 2050;
        double v183 = v34;
        _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_DEBUG, "[RelDMService] Head to Headset attitude updated. Previous q_bf: %{public}.6f %{public}.6f %{public}.6f %{public}.6f , New q_bf: %{public}.6f %{public}.6f %{public}.6f %{public}.6f, Default q_bf: %{public}.6f %{public}.6f %{public}.6f %{public}.6f, angle between previous: %{public}.2f deg, angle between default: %{public}.2f deg", buf, 0x8Eu);
      }
      a3 = v24;
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        float v120 = a5;
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        double v118 = *(float *)sub_190479348(a1 + 64);
        double v115 = *(float *)(sub_190479348(a1 + 64) + 4);
        double v113 = *(float *)(sub_190479348(a1 + 64) + 8);
        double v86 = *(float *)(sub_190479348(a1 + 64) + 12);
        double v87 = v121.f32[0];
        double v88 = v121.f32[1];
        double v89 = v121.f32[2];
        double v90 = v130.f32[0];
        double v91 = v130.f32[1];
        double v92 = v130.f32[2];
        *(double *)v93.i64 = v130.f32[3];
        double v110 = v130.f32[3];
        double v111 = v121.f32[3];
        float v94 = sub_1905E24A8(v10 + 8, v93);
        *(_DWORD *)BOOL v133 = 134352384;
        *(double *)&v133[4] = v118;
        *(_WORD *)double v134 = 2050;
        *(double *)&v134[2] = v115;
        __int16 v135 = 2050;
        double v136 = v113;
        __int16 v137 = 2050;
        double v138 = v86;
        __int16 v139 = 2050;
        double v140 = v87;
        __int16 v141 = 2050;
        double v142 = v88;
        __int16 v143 = 2050;
        double v144 = v89;
        __int16 v145 = 2050;
        double v146 = v111;
        __int16 v147 = 2050;
        double v148 = v90;
        __int16 v149 = 2050;
        double v150 = v91;
        __int16 v151 = 2050;
        double v152 = v92;
        __int16 v153 = 2050;
        double v154 = v110;
        __int16 v155 = 2050;
        double v156 = v23;
        __int16 v157 = 2050;
        double v158 = v94;
        unint64_t v95 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedAnchor(const CMOQuaternion &, const CMVector3d &, float, const uint64_t)", "CoreLocation: %s\n", v95);
        if (v95 != buf) {
          free(v95);
        }
        a5 = v120;
        a3 = v24;
      }
    }
    float32x4_t v35 = v121;
    *(float32x4_t *)(a1 + 76) = v121;
    *(unsigned char *)(a1 + 92) = 1;
    *(float32x4_t *)(a1 + 15924) = v35;
    *(unsigned char *)uint64_t v11 = 1;
  }
  if (*(unsigned char *)(v11 + 118))
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    int v36 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v36, OS_LOG_TYPE_INFO, "[RelDMService] Tracking will be re-enabled from getting anchor.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      *(_WORD *)BOOL v133 = 0;
      uint64_t v85 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedAnchor(const CMOQuaternion &, const CMVector3d &, float, const uint64_t)", "CoreLocation: %s\n", v85);
      if (v85 != buf) {
        free(v85);
      }
    }
    *(unsigned char *)(v11 + 122) = 1;
    return;
  }
  if (!*(_DWORD *)(a1 + 40) || !*(unsigned char *)(a1 + 92)) {
    return;
  }
  if (sub_1904847E8((float *)(a1 + 5840)))
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    __int16 v37 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 134217984;
      *(void *)&uint8_t buf[4] = a4;
      _os_log_impl(&dword_1902AF000, v37, OS_LOG_TYPE_DEFAULT, "[RelDMService][feedAnchor] anchor is SKIPPED, timestamp: %llu", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      *(_DWORD *)BOOL v133 = 134217984;
      *(void *)&v133[4] = a4;
LABEL_86:
      unint64_t v44 = (unsigned char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedAnchor(const CMOQuaternion &, const CMVector3d &, float, const uint64_t)", "CoreLocation: %s\n");
LABEL_87:
      if (v44 != buf) {
        free(v44);
      }
      return;
    }
    return;
  }
  uint64_t v39 = v11 + 124;
  int v38 = *(unsigned __int8 *)(v11 + 124);
  if (*(unsigned char *)(v11 + 124))
  {
    uint64_t v40 = *(void *)(a1 + 5408);
    if (v40)
    {
      if (v40 + 250000 < a4)
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        uint64_t v41 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
        {
          uint64_t v42 = *(void *)(a1 + 5408);
          *(_DWORD *)int buf = 134349312;
          *(void *)&uint8_t buf[4] = a4;
          *(_WORD *)&unsigned char buf[12] = 2050;
          *(void *)&buf[14] = v42;
          _os_log_impl(&dword_1902AF000, v41, OS_LOG_TYPE_ERROR, "[RelDMService] anchor data is far ahead of IMU: anchor, %{public}llu, auxIMU, %{public}llu", buf, 0x16u);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          uint64_t v43 = *(void *)(a1 + 5408);
          *(_DWORD *)BOOL v133 = 134349312;
          *(void *)&v133[4] = a4;
          *(_WORD *)double v134 = 2050;
          *(void *)&v134[2] = v43;
          unint64_t v44 = (unsigned char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMService::feedAnchor(const CMOQuaternion &, const CMVector3d &, float, const uint64_t)", "CoreLocation: %s\n");
          goto LABEL_87;
        }
        return;
      }
    }
  }
  uint64_t v117 = a1 + 64;
  if (*(unsigned char *)(v11 + 116))
  {
    if (*(_DWORD *)(a1 + 40) != 1)
    {
      *(_WORD *)(v11 + 116) = 256;
      if (v38)
      {
        sub_190477658(v11 + 124, v117, 1);
        __int16 v45 = a3;
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        double v46 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v46, OS_LOG_TYPE_DEFAULT, "[RelDMService] Entering 2-IMU with anchored tracking.", buf, 2u);
        }
        a3 = v45;
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          *(_WORD *)BOOL v133 = 0;
          double v107 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedAnchor(const CMOQuaternion &, const CMVector3d &, float, const uint64_t)", "CoreLocation: %s\n", v107);
          if (v107 != buf) {
            free(v107);
          }
          a3 = v45;
        }
      }
    }
  }
  __int16 v47 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
  int v48 = a3;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  __int16 v49 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    double v50 = *v48;
    double v51 = v48[1];
    double v52 = v48[2];
    double v53 = a2->f32[0];
    double v54 = a2->f32[1];
    double v55 = a2[1].f32[0];
    double v56 = a2[1].f32[1];
    *(_DWORD *)int buf = 134220032;
    *(void *)&uint8_t buf[4] = a4;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(double *)&buf[14] = a5;
    __int16 v160 = 2048;
    double v161 = v50;
    __int16 v162 = 2048;
    double v163 = v51;
    __int16 v164 = 2048;
    double v165 = v52;
    __int16 v166 = 2048;
    double v167 = v53;
    __int16 v168 = 2048;
    double v169 = v54;
    __int16 v170 = 2048;
    double v171 = v55;
    __int16 v172 = 2048;
    double v173 = v56;
    _os_log_impl(&dword_1902AF000, v49, OS_LOG_TYPE_DEFAULT, "[RelDMService][feedAnchor][AnchorBeforeTransform], timestamp: %llu, lidAngleDeg: %.1f, _r_fc: (%.2f, %.2f, %.2f), _q_cf: (%.3f, %.3f, %.3f, %.3f)", buf, 0x5Cu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    double v96 = *v48;
    double v97 = v48[1];
    double v98 = v48[2];
    double v99 = a2->f32[0];
    double v100 = a2->f32[1];
    double v101 = a2[1].f32[0];
    double v102 = a2[1].f32[1];
    *(_DWORD *)BOOL v133 = 134220032;
    *(void *)&v133[4] = a4;
    *(_WORD *)double v134 = 2048;
    *(double *)&v134[2] = a5;
    __int16 v135 = 2048;
    double v136 = v96;
    __int16 v137 = 2048;
    double v138 = v97;
    __int16 v139 = 2048;
    double v140 = v98;
    __int16 v141 = 2048;
    double v142 = v99;
    __int16 v143 = 2048;
    double v144 = v100;
    __int16 v145 = 2048;
    double v146 = v101;
    __int16 v147 = 2048;
    double v148 = v102;
    double v103 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedAnchor(const CMOQuaternion &, const CMVector3d &, float, const uint64_t)", "CoreLocation: %s\n", v103);
    if (v103 != buf) {
      free(v103);
    }
    __int16 v47 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
  }
  uint64_t v131 = 0x80000000;
  int v132 = 0;
  sub_1904CF7FC(&v130, (float *)&v131);
  if (*((void *)v47 + 283) != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  double v57 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 134218752;
    *(double *)&uint8_t buf[4] = v130.f32[0];
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(double *)&buf[14] = v130.f32[1];
    __int16 v160 = 2048;
    double v161 = v130.f32[2];
    __int16 v162 = 2048;
    double v163 = v130.f32[3];
    _os_log_impl(&dword_1902AF000, v57, OS_LOG_TYPE_DEFAULT, "[SourceAnchorTransform] q_sc: [%.3f, %.3f, %.3f, %.3f] ", buf, 0x2Au);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    *(_DWORD *)BOOL v133 = 134218752;
    *(double *)&v133[4] = v130.f32[0];
    *(_WORD *)double v134 = 2048;
    *(double *)&v134[2] = v130.f32[1];
    __int16 v135 = 2048;
    double v136 = v130.f32[2];
    __int16 v137 = 2048;
    double v138 = v130.f32[3];
    double v104 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "AnchorData CMRelDM::SourceAnchorTransform::transformAnchor(const CMVector3d &, const CMOQuaternion &, const BodyFaceTransform &, const float) const", "CoreLocation: %s\n", v104);
    if (v104 != buf) {
      free(v104);
    }
  }
  sub_1904CF3F4((uint64_t)&v130, (float *)a2, (float32x4_t *)v133, v58);
  std::string v59 = (float32x2_t *)sub_190479348(v117);
  __int32 v60 = v59[1].i32[1];
  v61.f32[0] = -v59[1].f32[0];
  *(float32x2_t *)v121.f32 = vneg_f32(*v59);
  v121.i64[1] = __PAIR64__(v60, v61.u32[0]);
  float32x4_t v62 = sub_1902D9ACC(&v121, v61);
  sub_1904CF3F4((uint64_t)v133, v121.f32, (float32x4_t *)buf, v62);
  float v63 = sub_1904CF73C(v130.f32, *v48, v48[1], v48[2]);
  float v65 = v64;
  float v67 = v66;
  uint64_t v68 = (float *)sub_1904791A8(v117);
  float v69 = sub_1904CF73C((float *)buf, *v68, v68[1], v68[2]);
  float v71 = v70;
  float v73 = v72;
  __int32 v74 = a2[1].i32[1];
  v75.f32[0] = -a2[1].f32[0];
  *(float32x2_t *)BOOL v133 = vneg_f32(*a2);
  *(_DWORD *)&v133[8] = v75.i32[0];
  *(_DWORD *)double v134 = v74;
  sub_1902D9ACC((float32x4_t *)v133, v75);
  uint64_t v76 = 0;
  v121.i64[0] = *(void *)v48;
  v121.f32[2] = v48[2];
  do
  {
    v121.f32[v76] = -v121.f32[v76];
    ++v76;
  }
  while (v76 != 3);
  float v77 = sub_1904CF73C((float *)v133, v121.f32[0], v121.f32[1], v121.f32[2]);
  float32x4_t v121 = *(float32x4_t *)buf;
  int v122 = 969384531;
  float v123 = (float)(v63 - v69) + 0.0;
  float v124 = (float)(v65 - v71) + 0.0;
  float v125 = (float)(v67 - v73) + 0.0;
  int v126 = 961656599;
  float v127 = v77;
  int v128 = v78;
  int v129 = v79;
  sub_190420FA8((uint64_t)v10, &v121, a4);
  if (v10->i8[0])
  {
    sub_190476250(v39, (uint64_t)&v121, *(_DWORD *)(a1 + 40), a4);
    uint64_t v80 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    uint64_t v81 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 134220032;
      *(void *)&uint8_t buf[4] = a4;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(double *)&buf[14] = a5;
      __int16 v160 = 2048;
      double v161 = v123;
      __int16 v162 = 2048;
      double v163 = v124;
      __int16 v164 = 2048;
      double v165 = v125;
      __int16 v166 = 2048;
      double v167 = v121.f32[0];
      __int16 v168 = 2048;
      double v169 = v121.f32[1];
      __int16 v170 = 2048;
      double v171 = v121.f32[2];
      __int16 v172 = 2048;
      double v173 = v121.f32[3];
      _os_log_impl(&dword_1902AF000, v81, OS_LOG_TYPE_DEFAULT, "[RelDMService][feedAnchor] timestamp: %llu, lidAngleDeg: %.1f, r_bs: (%.2f, %.2f, %.2f), q_sb: (%.3f, %.3f, %.3f, %.3f)", buf, 0x5Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      *(_DWORD *)BOOL v133 = 134220032;
      *(void *)&v133[4] = a4;
      *(_WORD *)double v134 = 2048;
      *(double *)&v134[2] = a5;
      __int16 v135 = 2048;
      double v136 = v123;
      __int16 v137 = 2048;
      double v138 = v124;
      __int16 v139 = 2048;
      double v140 = v125;
      __int16 v141 = 2048;
      double v142 = v121.f32[0];
      __int16 v143 = 2048;
      double v144 = v121.f32[1];
      __int16 v145 = 2048;
      double v146 = v121.f32[2];
      __int16 v147 = 2048;
      double v148 = v121.f32[3];
      double v105 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedAnchor(const CMOQuaternion &, const CMVector3d &, float, const uint64_t)", "CoreLocation: %s\n", v105);
      if (v105 != buf) {
        free(v105);
      }
      uint64_t v80 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
    }
    if (*(void *)(a1 + 26400) == a4)
    {
      *(_OWORD *)(a1 + 15968) = 0u;
      *(_OWORD *)(a1 + 15952) = 0u;
      *(void *)(a1 + 16048) = 0;
      if (*((void *)v80 + 283) != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      int v82 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 134217984;
        *(void *)&uint8_t buf[4] = a4;
        _os_log_impl(&dword_1902AF000, v82, OS_LOG_TYPE_DEFAULT, "[RelDMService][feedAnchor] anchor is VALID, timestamp: %llu", buf, 0xCu);
      }
      if (!sub_1902D8400(115, 2)) {
        goto LABEL_94;
      }
      bzero(buf, 0x65CuLL);
      if (*((void *)v80 + 283) != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      *(_DWORD *)BOOL v133 = 134217984;
      *(void *)&v133[4] = a4;
    }
    else
    {
      if (*((void *)v80 + 283) != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      double v84 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 134217984;
        *(void *)&uint8_t buf[4] = a4;
        _os_log_impl(&dword_1902AF000, v84, OS_LOG_TYPE_DEFAULT, "[RelDMService][feedAnchor] anchor is NOT-VALID, timestamp: %llu", buf, 0xCu);
      }
      if (!sub_1902D8400(115, 2)) {
        goto LABEL_94;
      }
      bzero(buf, 0x65CuLL);
      if (*((void *)v80 + 283) != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      *(_DWORD *)BOOL v133 = 134217984;
      *(void *)&v133[4] = a4;
    }
    double v106 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedAnchor(const CMOQuaternion &, const CMVector3d &, float, const uint64_t)", "CoreLocation: %s\n", v106);
    if (v106 != buf) {
      free(v106);
    }
LABEL_94:
    *(void *)(a1 + 5808) = a4;
    return;
  }
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  __int16 v83 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 134217984;
    *(void *)&uint8_t buf[4] = a4;
    _os_log_impl(&dword_1902AF000, v83, OS_LOG_TYPE_DEFAULT, "[RelDMService] [feedAnchor][AnchorMotionCorrespondence] anchor is IGNORED, timestamp: %llu", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    *(_DWORD *)BOOL v133 = 134217984;
    *(void *)&v133[4] = a4;
    goto LABEL_86;
  }
}

void sub_1904FC278(uint64_t a1, unint64_t a2, float *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 92))
  {
    uint64_t v6 = a1 + 27428;
    uint64_t v7 = a1 + 64;
    uint64_t v8 = a1 + 5336;
    float v9 = sub_1904CF514((float *)(a1 + 5392));
    float v11 = v10;
    float v13 = v12;
    uint64_t v14 = (float32x2_t *)sub_190479348(v7);
    __int32 v15 = v14[1].i32[1];
    v16.f32[0] = -v14[1].f32[0];
    *(float32x2_t *)buf[0].f32 = vneg_f32(*v14);
    buf[0].i64[1] = __PAIR64__(v15, v16.u32[0]);
    sub_1902D9ACC(buf, v16);
    v30[0] = sub_1904CF73C(buf[0].f32, v9, v11, v13);
    v30[1] = v17;
    v30[2] = v18;
    sub_19050F5D8(a1 + 27344, v30);
    uint64_t v19 = 0;
    float v20 = 0.0;
    do
    {
      float v20 = v20 + (float)(*(float *)(v8 + v19) * *(float *)(v8 + v19));
      v19 += 4;
    }
    while (v19 != 12);
    *(float *)(v6 + 76) = sqrtf(v20);
    if (*(_DWORD *)(a1 + 40))
    {
      __int32 v21 = (float *)sub_190479348(v7);
      sub_1904CF7C0(v21, *a3, a3[1], a3[2]);
      if (v22 <= 0.0) {
        float v23 = -v22;
      }
      else {
        float v23 = v22;
      }
      if (*(unsigned char *)(v6 + 10))
      {
        if (!*(unsigned char *)(v6 + 92) && v23 > 0.87266)
        {
          *(unsigned char *)(v6 + 10) = 0;
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          char v24 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
          {
            buf[0].i32[0] = 134349056;
            *(double *)((char *)buf[0].i64 + 4) = (float)(v23 * 57.296);
            _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_DEFAULT, "[RelDMService] Turn OFF convergingToAnchorMode in perceptualFilter. headRawDps %{public}.3f", (uint8_t *)buf, 0xCu);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
            }
            int v31 = 134349056;
            double v32 = (float)(v23 * 57.296);
LABEL_30:
            double v29 = (float32x4_t *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::perceptualFilterUpdate(const uint64_t, const CMVector3d &)", "CoreLocation: %s\n", (const char *)v29);
            if (v29 != buf) {
              free(v29);
            }
          }
        }
      }
      else
      {
        uint64_t v25 = *(void *)(a1 + 26400);
        if (v25 && v25 + 250000 > a2)
        {
          *(unsigned char *)(v6 + 10) = 1;
          *(unsigned char *)uint64_t v6 = 0;
          *(_DWORD *)(v6 + 4) = 0;
          *(void *)(a1 + 27396) = 0;
          *(void *)(a1 + 27401) = 0;
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          double v26 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
          {
            double v27 = (float)((float)(a2 - *(void *)(a1 + 26400)) * 0.000001);
            buf[0].i32[0] = 134349056;
            *(double *)((char *)buf[0].i64 + 4) = v27;
            _os_log_impl(&dword_1902AF000, v26, OS_LOG_TYPE_DEFAULT, "[RelDMService] Turn ON convergingToAnchorMode in perceptualFilter. timeSinceAnchorSeconds %{public}.2f", (uint8_t *)buf, 0xCu);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
            }
            double v28 = (float)((float)(a2 - *(void *)(a1 + 26400)) * 0.000001);
            int v31 = 134349056;
            double v32 = v28;
            goto LABEL_30;
          }
        }
      }
    }
  }
}

void sub_1904FC6BC(uint64_t a1, float32x2_t *a2, unint64_t a3)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (unsigned __int8 *)(a1 + 27520);
  uint64_t v7 = (unsigned __int8 *)(a1 + 16058);
  if (*(_DWORD *)(a1 + 40) != 1) {
    goto LABEL_33;
  }
  if (*(unsigned char *)(a1 + 44))
  {
    int v8 = *v6;
    if (*v7)
    {
      sub_190593554(a1 + 27520, *(void *)(a1 + 5784), a3, *(unsigned __int8 *)(a1 + 37448));
    }
    else
    {
      unint64_t v10 = *(void *)(a1 + 26400);
      BOOL v11 = a3 <= v10 || v10 == 0;
      float v12 = 3.4028e38;
      if (!v11) {
        float v12 = (float)(a3 - v10) * 0.000001;
      }
      float v13 = *(double *)(a1 + 16048);
      sub_190592F48(a1 + 27520, a1 + 15904, *(unsigned char *)(a1 + 16064), a3, v13, v12);
    }
    if ((v8 != 0) != (*v6 != 0))
    {
      if (*v6)
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        uint64_t v14 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          int v15 = *v7;
          *(_DWORD *)int buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = v15;
          _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_DEFAULT, "[RelDMService] Started requesting anchor, in DV %{public}d.", buf, 8u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          int v16 = *v7;
          int v66 = 67240192;
          LODWORD(v67) = v16;
LABEL_121:
          double v55 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::camControllerUpdate(const uint64_t)", "CoreLocation: %s\n", v55);
          if (v55 != buf) {
            free(v55);
          }
        }
      }
      else
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        float v17 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          int v18 = *v7;
          *(_DWORD *)int buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = v18;
          _os_log_impl(&dword_1902AF000, v17, OS_LOG_TYPE_DEFAULT, "[RelDMService] Stopped requesting anchor, in DV %{public}d.", buf, 8u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          int v54 = *v7;
          int v66 = 67240192;
          LODWORD(v67) = v54;
          goto LABEL_121;
        }
      }
    }
  }
  else
  {
    *uint64_t v6 = 0;
    if (*(unsigned char *)(a1 + 45))
    {
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      float v9 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_DEFAULT, "[RelDMService] Stop requesting anchor if screen is locked or off.", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        LOWORD(v66) = 0;
        double v53 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::camControllerUpdate(const uint64_t)", "CoreLocation: %s\n", v53);
        if (v53 != buf) {
          free(v53);
        }
      }
      *(unsigned char *)(a1 + 45) = *(unsigned char *)(a1 + 44);
    }
  }
LABEL_33:
  if (*(_WORD *)(a1 + 3762))
  {
    if (*(void *)(a1 + 5416) && (unint64_t v19 = *(void *)(a1 + 5408)) != 0)
    {
      BOOL v20 = a3 >= v19;
      unint64_t v21 = a3 - v19;
      if (v21 != 0 && v20 && v21 > 0x9CE)
      {
        if (v21 < 0x75301)
        {
          unint64_t v29 = *(unint64_t *)(a1 + 5184);
          if (sub_1904FD76C(a1, a3))
          {
            if (*(void *)(a1 + 5184) == v29)
            {
              if (qword_1E929D8D8 != -1) {
                dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
              }
              int v31 = qword_1E929D8E0;
              if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)int buf = 134349312;
                *(void *)&uint8_t buf[4] = a3;
                *(_WORD *)&unsigned char buf[12] = 2050;
                *(void *)&buf[14] = v29;
                _os_log_impl(&dword_1902AF000, v31, OS_LOG_TYPE_ERROR, "[RelDMService] Unexpected. activeIndex unchanged. %{public}llu, last, %{public}lu", buf, 0x16u);
              }
              if (sub_1902D8400(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1E929D8D8 != -1) {
                  dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
                }
                int v66 = 134349312;
                double v67 = *(double *)&a3;
                __int16 v68 = 2050;
                double v69 = *(double *)&v29;
                __int32 v60 = (char *)_os_log_send_and_compose_impl();
                sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMService::feedAuxIMU(const IMUData &, const uint64_t)", "CoreLocation: %s\n", v60);
                if (v60 != buf) {
                  free(v60);
                }
              }
              ++*((void *)v6 + 1239);
            }
            else
            {
              if (!v7[6]) {
                sub_1904FDE64(a1, a2, v30);
              }
              *(double *)v34.i64 = sub_1904CF454((float32x2_t *)(a1 + 5392), (float32x4_t *)buf, v30);
              double v35 = sub_1904CF3F4((uint64_t)&a2[7], (float *)buf, &v65, v34);
              *(float *)&double v35 = (float)(a3 - *(void *)(a1 + 5408));
              int32x2_t v62 = *(int32x2_t *)&v35;
              v36.f32[0] = sub_1904CF8B4(&v65);
              uint64_t v37 = 0;
              v36.i32[1] = v39;
              float32x2_t v63 = vdiv_f32(vmul_f32(v36, (float32x2_t)vdup_n_s32(0x49742400u)), (float32x2_t)vdup_lane_s32(v62, 0));
              float v64 = (float)(v38 * 1000000.0) / *(float *)v62.i32;
              float v40 = 0.0;
              do
              {
                float v40 = v40 + (float)(a2->f32[v37] * a2->f32[v37]);
                ++v37;
              }
              while (v37 != 3);
              uint64_t v41 = 0;
              float v42 = 0.0;
              do
              {
                float v42 = v42 + (float)(v63.f32[v41] * v63.f32[v41]);
                ++v41;
              }
              while (v41 != 3);
              float v43 = sqrtf(v40);
              if (v43 > 0.1)
              {
                float v44 = sqrtf(v42);
                if (v44 > (float)(v43 * 100.0))
                {
                  if (qword_1E929D8D8 != -1) {
                    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
                  }
                  __int16 v45 = qword_1E929D8E0;
                  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)int buf = 134349312;
                    *(double *)&uint8_t buf[4] = v44;
                    *(_WORD *)&unsigned char buf[12] = 2050;
                    *(double *)&buf[14] = v43;
                    _os_log_impl(&dword_1902AF000, v45, OS_LOG_TYPE_DEFAULT, "[RelDMService] Unexpected large discrepency between avgAuxOmega and instAuxOmega. avg, %{public}.3f, inst, %{public}.3f", buf, 0x16u);
                  }
                  if (sub_1902D8400(115, 2))
                  {
                    bzero(buf, 0x65CuLL);
                    if (qword_1E929D8D8 != -1) {
                      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
                    }
                    int v66 = 134349312;
                    double v67 = v44;
                    __int16 v68 = 2050;
                    double v69 = v43;
                    float32x4_t v61 = (char *)_os_log_send_and_compose_impl();
                    sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedAuxIMU(const IMUData &, const uint64_t)", "CoreLocation: %s\n", v61);
                    if (v61 != buf) {
                      free(v61);
                    }
                  }
                }
              }
              long long v46 = *(_OWORD *)(a1 + 5352);
              *(_OWORD *)int buf = *(_OWORD *)(a1 + 5336);
              *(_OWORD *)&uint8_t buf[16] = v46;
              long long v71 = *(_OWORD *)(a1 + 5368);
              uint64_t v72 = *(void *)(a1 + 5384);
              long long v73 = *(_OWORD *)(a1 + 5392);
              sub_1904FE0A4(a1 + 5336, (uint64_t)a2);
              *(double *)(a1 + 5408) = *(double *)&a3;
              sub_1904FC278(a1, a3, (float *)&v63);
              if (v7[6]) {
                goto LABEL_141;
              }
              float v47 = (float)*(unint64_t *)(a1 + 5416) + 1500000.0;
              int v48 = *(_DWORD *)(a1 + 40);
              if (v47 <= (float)a3 && v48 == 2)
              {
                int v48 = 1;
                *(_DWORD *)(a1 + 40) = 1;
              }
              BOOL v50 = v47 <= (float)a3 && v48 == 1;
              BOOL v51 = v50;
              if (!v48 || v51)
              {
LABEL_141:
                if (!*v7) {
                  sub_1904FE120(a1, (uint64_t)buf, &v63, v29);
                }
              }
            }
          }
          else
          {
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
            }
            double v32 = qword_1E929D8E0;
            if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
            {
              uint64_t v33 = *(void *)(a1 + 5184);
              *(_DWORD *)int buf = 134349312;
              *(void *)&uint8_t buf[4] = a3;
              *(_WORD *)&unsigned char buf[12] = 2050;
              *(void *)&buf[14] = v33;
              _os_log_impl(&dword_1902AF000, v32, OS_LOG_TYPE_ERROR, "[RelDMService] failed to find new activeIdxSrc, %{public}llu, last, %{public}lu", buf, 0x16u);
            }
            if (sub_1902D8400(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1E929D8D8 != -1) {
                dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
              }
              double v58 = *(double *)(a1 + 5184);
              int v66 = 134349312;
              double v67 = *(double *)&a3;
              __int16 v68 = 2050;
              double v69 = v58;
              std::string v59 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMService::feedAuxIMU(const IMUData &, const uint64_t)", "CoreLocation: %s\n", v59);
              if (v59 != buf) {
                free(v59);
              }
            }
            ++*((void *)v6 + 1238);
          }
        }
        else
        {
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          double v27 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
          {
            uint64_t v28 = *(void *)(a1 + 5408);
            *(_DWORD *)int buf = 134349312;
            *(void *)&uint8_t buf[4] = a3;
            *(_WORD *)&unsigned char buf[12] = 2050;
            *(void *)&buf[14] = v28;
            _os_log_impl(&dword_1902AF000, v27, OS_LOG_TYPE_ERROR, "[RelDMService] Aux data timestamp has large gap: current, %{public}llu, last, %{public}llu", buf, 0x16u);
          }
          if (sub_1902D8400(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
            }
            double v56 = *(double *)(a1 + 5408);
            int v66 = 134349312;
            double v67 = *(double *)&a3;
            __int16 v68 = 2050;
            double v69 = v56;
            double v57 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMService::feedAuxIMU(const IMUData &, const uint64_t)", "CoreLocation: %s\n", v57);
            if (v57 != buf) {
              free(v57);
            }
          }
          sub_1904FD6A0(a1, (uint64_t)a2, a3);
          sub_190480CD4(a1 + 5840, 0);
          *(_DWORD *)(a1 + 16128) = 0;
          *(_DWORD *)(a1 + 17416) = 0;
          *(_DWORD *)(a1 + 26424) = 0;
          *(_DWORD *)(a1 + 26448) = 0;
          *(_DWORD *)(a1 + 26968) = 0;
          *(_DWORD *)(a1 + 27216) = 0;
          ++*((void *)v6 + 1237);
        }
      }
      else
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        float v22 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v23 = *(void *)(a1 + 5408);
          *(_DWORD *)int buf = 134349312;
          *(void *)&uint8_t buf[4] = a3;
          *(_WORD *)&unsigned char buf[12] = 2050;
          *(void *)&buf[14] = v23;
          _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_DEBUG, "[RelDMService] Aux data timestamp stayed the same or went backwards: current, %{public}llu, last, %{public}llu", buf, 0x16u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          double v24 = *(double *)(a1 + 5408);
          int v66 = 134349312;
          double v67 = *(double *)&a3;
          __int16 v68 = 2050;
          double v69 = v24;
          uint64_t v25 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedAuxIMU(const IMUData &, const uint64_t)", "CoreLocation: %s\n", v25);
          if (v25 != buf) {
            free(v25);
          }
        }
      }
    }
    else
    {
      sub_1904FD6A0(a1, (uint64_t)a2, a3);
    }
  }
  else
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    double v26 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v26, OS_LOG_TYPE_ERROR, "[RelDMService] Source IMU data missing", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      LOWORD(v66) = 0;
      double v52 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMService::feedAuxIMU(const IMUData &, const uint64_t)", "CoreLocation: %s\n", v52);
      if (v52 != buf) {
        free(v52);
      }
    }
    ++*((void *)v6 + 1240);
  }
}

uint64_t sub_1904FD6A0(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)(a1 + 5184) = 0;
  *(void *)(a1 + 5408) = 0;
  uint64_t result = sub_1904FD76C(a1, a3);
  if (result)
  {
    *(_DWORD *)(a1 + 5336) = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 5340) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 5344) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 5348) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 5352) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 5356) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 5360) = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a1 + 5364) = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a1 + 5368) = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 5372) = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a1 + 5376) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 5380) = *(_DWORD *)(a2 + 44);
    *(void *)(a1 + 5384) = *(void *)(a2 + 48);
    if (a1 + 5336 != a2) {
      *(_OWORD *)(a1 + 5392) = *(_OWORD *)(a2 + 56);
    }
    *(void *)(a1 + 5408) = a3;
    *(void *)(a1 + 5416) = a3;
  }
  return result;
}

uint64_t sub_1904FD76C(uint64_t a1, unint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (!*(_WORD *)(a1 + 3762))
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    int v16 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_ERROR, "[RelDMService] calcActiveIndexSrc: srcBuffer is empty.", buf, 2u);
    }
    int v17 = sub_1902D8400(115, 0);
    uint64_t result = 0;
    if (!v17) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 == -1) {
      goto LABEL_48;
    }
    goto LABEL_51;
  }
  unsigned int v4 = (unsigned __int16 *)(a1 + 3760);
  unint64_t v5 = *(void *)sub_19047A7F8((unsigned __int16 *)(a1 + 3760), 0);
  unint64_t v6 = a2 + 5000;
  unint64_t v7 = *(void *)sub_19047A7F8(v4, 0);
  if (v5 <= a2 + 5000)
  {
    if (v7 >= a2 && *(void *)sub_19047A7F8(v4, 0) <= v6)
    {
      *(void *)(a1 + 5184) = 0;
      return 1;
    }
    uint64_t v18 = a1 + 3768;
    unint64_t v19 = *(unsigned __int16 *)(a1 + 3762);
    unint64_t v20 = *(unsigned __int16 *)(a1 + 3760) + v19 - 1;
    unint64_t v21 = *(unsigned int *)(a1 + 3764);
    if (v20 < v21) {
      unint64_t v21 = 0;
    }
    uint64_t v22 = *(void *)(v18 + 8 * (v20 - v21));
    if (v22 + 10000 >= a2)
    {
      unint64_t v33 = *(void *)(a1 + 5184);
      while (v19 > v33)
      {
        if (*(void *)sub_19047A7F8(v4, --v19) <= a2)
        {
          float32x4_t v34 = (void *)sub_19047A7F8(v4, v19);
          if (v19 >= (unint64_t)*(unsigned __int16 *)(a1 + 3762) - 1
            || (unint64_t v35 = v19 + 1, v36 = a2 - *v34, *(void *)sub_19047A7F8(v4, v19 + 1) - a2 >= v36))
          {
            unint64_t v35 = v19;
          }
          *(void *)(a1 + 5184) = v35;
          return 1;
        }
      }
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      uint64_t v37 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v37, OS_LOG_TYPE_ERROR, "[RelDMService] Should not end up here.", buf, 2u);
      }
      int v38 = sub_1902D8400(115, 0);
      uint64_t result = 0;
      if (v38)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          goto LABEL_51;
        }
        goto LABEL_48;
      }
      return result;
    }
    float v23 = (float)(a2 - v22);
    uint64_t v24 = mach_absolute_time();
    double v25 = sub_1902D8D34(v24) * 1000000.0;
    if (qword_1E929D8D8 != -1)
    {
      double v39 = v25;
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      double v25 = v39;
    }
    float v26 = v23 * 0.001;
    unint64_t v27 = (unint64_t)v25;
    uint64_t v28 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      unint64_t v29 = *(unsigned __int16 *)(a1 + 3760) + (unint64_t)*(unsigned __int16 *)(a1 + 3762) - 1;
      unint64_t v30 = *(unsigned int *)(a1 + 3764);
      if (v29 < v30) {
        unint64_t v30 = 0;
      }
      uint64_t v31 = *(void *)(v18 + 8 * (v29 - v30));
      *(_DWORD *)int buf = 134349824;
      unint64_t v42 = v27;
      __int16 v43 = 2050;
      unint64_t v44 = a2;
      __int16 v45 = 2050;
      uint64_t v46 = v31;
      __int16 v47 = 2050;
      double v48 = v26;
      _os_log_impl(&dword_1902AF000, v28, OS_LOG_TYPE_ERROR, "[RelDMService] calcActiveIndexSrc: Unexpected Aux data is ahead of source IMU data. {current: %{public}llu aux: %{public}llu source: %{public}llu diffMS: %{public}f}", buf, 0x2Au);
    }
    int v32 = sub_1902D8400(115, 0);
    uint64_t result = 0;
    if (!v32) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 == -1)
    {
LABEL_48:
      float v40 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "BOOL CMRelDMService::calcActiveIndexSrc(const uint64_t)", "CoreLocation: %s\n", v40);
      if (v40 != (char *)buf) {
        free(v40);
      }
      return 0;
    }
LABEL_51:
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    goto LABEL_48;
  }
  float v8 = (float)(v7 - v6);
  uint64_t v9 = mach_absolute_time();
  double v10 = sub_1902D8D34(v9) * 1000000.0;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  float v11 = v8 * 0.001;
  float v12 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
  {
    uint64_t v13 = *(void *)sub_19047A7F8(v4, 0);
    *(_DWORD *)int buf = 134349824;
    unint64_t v42 = (unint64_t)v10;
    __int16 v43 = 2050;
    unint64_t v44 = v6;
    __int16 v45 = 2050;
    uint64_t v46 = v13;
    __int16 v47 = 2050;
    double v48 = v11;
    _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_ERROR, "[RelDMService] calcActiveIndexSrc: Aux data is too old compared to source data. {current: %{public}llu aux: %{public}llu source: %{public}llu diffMS: %{public}f}", buf, 0x2Au);
  }
  int v14 = sub_1902D8400(115, 0);
  uint64_t result = 0;
  if (v14)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    sub_19047A7F8(v4, 0);
    goto LABEL_48;
  }
  return result;
}

void sub_1904FDE64(uint64_t a1, float32x2_t *a2, float32x4_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 16064))
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    unint64_t v3 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      buf[0].i16[0] = 0;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_ERROR, "[RelDMService] Calling feed initCheckBuffers when tracking already initialized", (uint8_t *)buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      unsigned int v4 = (float32x4_t *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMService::feedInitCheckBuffers(const IMUData &)", "CoreLocation: %s\n", (const char *)v4);
      if (v4 != buf) {
        free(v4);
      }
    }
  }
  else
  {
    __int32 v7 = a2[8].i32[1];
    a3.f32[0] = -a2[8].f32[0];
    *(float32x2_t *)buf[0].f32 = vneg_f32(a2[7]);
    buf[0].i64[1] = __PAIR64__(v7, a3.u32[0]);
    sub_1902D9ACC(buf, a3);
    sub_1904CF73C(buf[0].f32, a2->f32[0], a2->f32[1], a2[1].f32[0]);
    float v9 = -v8;
    if (v8 > 0.0) {
      float v9 = v8;
    }
    uint64_t v10 = *(unsigned __int16 *)(a1 + 5426);
    unint64_t v11 = *(unsigned int *)(a1 + 5428);
    uint64_t v12 = *(unsigned __int16 *)(a1 + 5424);
    if (v12 + v10 >= v11) {
      uint64_t v13 = *(unsigned int *)(a1 + 5428);
    }
    else {
      uint64_t v13 = 0;
    }
    *(float *)(a1 + 5424 + 4 * (v12 + v10 - v13) + 8) = v9;
    if (v11 <= v10)
    {
      if (v12 + 1 < v11) {
        LOWORD(v11) = 0;
      }
      *(_WORD *)(a1 + 5424) = v12 + 1 - v11;
    }
    else
    {
      *(_WORD *)(a1 + 5426) = v10 + 1;
    }
    buf[0].f32[0] = v8;
    sub_19042D76C(a1 + 5440, buf[0].f32);
  }
}

__n128 sub_1904FE0A4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  result.n128_u32[0] = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 44) = result.n128_u32[0];
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  if (a1 != a2)
  {
    __n128 result = *(__n128 *)(a2 + 56);
    *(__n128 *)(a1 + 56) = result;
  }
  return result;
}

void *sub_1904FE120(uint64_t a1, uint64_t a2, float32x2_t *a3, unint64_t a4)
{
  uint64_t v6 = 0;
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  double v57 = (unsigned char *)(a1 + 33594);
  int v54 = (unsigned char *)(a1 + 27520);
  double v55 = (_DWORD *)(a1 + 26968);
  float32x2_t v62 = *a3;
  float v63 = a3[1].f32[0];
  __int32 v7 = (unsigned char *)(a1 + 16040);
  float v8 = (float)(*(float *)(a2 + 20) + *(float *)(a1 + 5356)) * -0.5;
  float32x2_t v64 = vmul_f32(vadd_f32(*(float32x2_t *)(a2 + 12), *(float32x2_t *)(a1 + 5348)), (float32x2_t)0xBF000000BF000000);
  float v65 = v8;
  *(void *)int buf = *(void *)(a1 + 5360);
  *(_DWORD *)&uint8_t buf[8] = *(_DWORD *)(a1 + 5368);
  do
  {
    *(float *)&buf[v6] = -*(float *)&buf[v6];
    v6 += 4;
  }
  while (v6 != 12);
  uint64_t v66 = *(void *)buf;
  int v67 = *(_DWORD *)&buf[8];
  uint64_t v68 = *(void *)(a1 + 5372);
  int v9 = *(_DWORD *)(a1 + 5384);
  int v69 = *(_DWORD *)(a1 + 5380);
  int v70 = v9;
  int v71 = *(_DWORD *)(a1 + 5388);
  long long v72 = *(_OWORD *)(a1 + 5392);
  float v10 = -1.0;
  if (*(_DWORD *)(a1 + 740) != *(unsigned __int16 *)(a1 + 738) || (unint64_t v11 = *(void *)(a1 + 5184), v11 < 0x30))
  {
LABEL_5:
    int v12 = 0;
    goto LABEL_6;
  }
  int v42 = (v11 >> 1) - 24;
  float v43 = sub_19042FE34(a1 + 708, v42, 25);
  float v44 = sub_190484A00(a1 + 708, v42, 25, v43);
  float v45 = sub_19042FE34(a1 + 708, v42, 25) + -1.0;
  float v46 = -v45;
  if (v45 > 0.0) {
    float v46 = v45;
  }
  float v10 = v44 + (float)(v46 * v46);
  if (v44 < 0.000025 && v46 < 0.05)
  {
    unint64_t v47 = *(unsigned __int16 *)(a1 + 736) + (unint64_t)*(unsigned __int16 *)(a1 + 738) - 1;
    unint64_t v48 = *(unsigned int *)(a1 + 740);
    if (v47 < v48) {
      unint64_t v48 = 0;
    }
    float v49 = *(float *)(a1 + 736 + 4 * (v47 - v48) + 8) + -1.0;
    if (v49 <= 0.0) {
      float v49 = -v49;
    }
    if (v49 < 0.05)
    {
      int v12 = 1;
      goto LABEL_6;
    }
  }
  int v12 = 0;
  if (v44 < 0.01 && v46 < 0.1)
  {
    unint64_t v50 = *(unsigned __int16 *)(a1 + 736) + (unint64_t)*(unsigned __int16 *)(a1 + 738) - 1;
    unint64_t v51 = *(unsigned int *)(a1 + 740);
    if (v50 < v51) {
      unint64_t v51 = 0;
    }
    float v52 = *(float *)(a1 + 736 + 4 * (v50 - v51) + 8) + -1.0;
    if (v52 <= 0.0) {
      float v52 = -v52;
    }
    if (v52 < 0.1)
    {
      int v12 = 2;
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_6:
  uint64_t v13 = 0;
  memset(v58, 0, 24);
  int v14 = *(_DWORD *)(a1 + 5208);
  *(void *)int buf = *(void *)(a1 + 5200);
  *(_DWORD *)&uint8_t buf[8] = v14;
  do
  {
    *(float *)&buf[v13] = -*(float *)&buf[v13];
    v13 += 4;
  }
  while (v13 != 12);
  *(void *)&v58[24] = *(void *)buf;
  LODWORD(v59) = *(_DWORD *)&buf[8];
  *(int32x2_t *)((char *)&v59 + 4) = vdup_n_s32(0x3A03126Fu);
  HIDWORD(v59) = 973279855;
  unint64_t v60 = __PAIR64__(LODWORD(v10), v12);
  float32x4_t v61 = (float32x4_t)xmmword_190608E30;
  sub_1902D9ACC(&v61, (float32x4_t)xmmword_190608E30);
  unint64_t v15 = a4 + 1;
  unint64_t v16 = *(void *)(a1 + 5184);
  if (a4 + 1 <= v16)
  {
    double v56 = v7;
    do
    {
      unint64_t v18 = v15;
      if (v15 == v16)
      {
        float v19 = (float)(a3[1].f32[0] + *(float *)(a1 + 5344)) * 0.5;
        float32x2_t v62 = vmul_f32(vadd_f32(*a3, *(float32x2_t *)(a1 + 5336)), (float32x2_t)0x3F0000003F000000);
        float v63 = v19;
      }
      if (v15)
      {
        unint64_t v20 = a4 >> 1;
        double v25 = (float32x2_t *)sub_1904FE96C((unsigned __int16 *)(a1 + 100), a4 >> 1);
        if ((a4 >> 1) + 1 < (unint64_t)*(unsigned __int16 *)(a1 + 102) - 1) {
          unint64_t v26 = v20 + 1;
        }
        else {
          unint64_t v26 = *(unsigned __int16 *)(a1 + 102) - 1;
        }
        unint64_t v27 = (float32x2_t *)sub_1904FE96C((unsigned __int16 *)(a1 + 100), v26);
        float32x2_t v23 = vmul_f32(vadd_f32(*v25, *v27), (float32x2_t)0xBF000000BF000000);
        float v24 = (float)(v25[1].f32[0] + v27[1].f32[0]) * -0.5;
      }
      else
      {
        unint64_t v20 = v15 >> 1;
        uint64_t v21 = sub_1904FE96C((unsigned __int16 *)(a1 + 100), v15 >> 1);
        uint64_t v22 = 0;
        *(void *)int buf = *(void *)v21;
        *(_DWORD *)&uint8_t buf[8] = *(_DWORD *)(v21 + 8);
        do
        {
          *(float *)&buf[v22] = -*(float *)&buf[v22];
          v22 += 4;
        }
        while (v22 != 12);
        float32x2_t v23 = *(float32x2_t *)buf;
        float v24 = *(float *)&buf[8];
      }
      *(float32x2_t *)&unsigned char v58[12] = v23;
      *(float *)&v58[20] = v24;
      uint64_t v28 = (float32x2_t *)sub_1904FE96C((unsigned __int16 *)(a1 + 944), a4);
      unint64_t v29 = (float32x2_t *)sub_1904FE96C((unsigned __int16 *)(a1 + 944), v18);
      float v30 = (float)(v28[1].f32[0] + v29[1].f32[0]) * 0.5;
      *(float32x2_t *)double v58 = vmul_f32(vadd_f32(*v28, *v29), (float32x2_t)0x3F0000003F000000);
      *(float *)&v58[8] = v30;
      uint64_t v31 = sub_1904FE96C((unsigned __int16 *)(a1 + 4568), v20);
      *(void *)((char *)&v59 + 4) = *(void *)v31;
      HIDWORD(v59) = *(_DWORD *)(v31 + 8);
      int v32 = (float32x4_t *)sub_1905022B4((unsigned __int16 *)(a1 + 2152), v18);
      if (&v61 != v32) {
        float32x4_t v61 = *v32;
      }
      long long v33 = *(_OWORD *)&v58[16];
      *(_OWORD *)(a1 + 5264) = *(_OWORD *)v58;
      *(_OWORD *)(a1 + 5280) = v33;
      *(_OWORD *)(a1 + 5296) = v59;
      *(void *)(a1 + 5312) = v60;
      if ((unsigned char *)(a1 + 5264) != v58) {
        *(float32x4_t *)(a1 + 5320) = v61;
      }
      uint64_t v34 = *(void *)sub_19047A7F8((unsigned __int16 *)(a1 + 3760), v18);
      unint64_t v35 = v34 - *(void *)sub_19047A7F8((unsigned __int16 *)(a1 + 3760), a4);
      if (v35 >= 0x4E21)
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        unint64_t v36 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 134349056;
          *(void *)&uint8_t buf[4] = v35;
          _os_log_impl(&dword_1902AF000, v36, OS_LOG_TYPE_ERROR, "[RelDMService] Unexpected large IMU dt passed to EKF. dt=%{public}llu", buf, 0xCu);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          int v73 = 134349056;
          unint64_t v74 = v35;
          uint64_t v41 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "void CMRelDMService::processIMUData(const IMUData &, const CMVector3d &, const size_t)", "CoreLocation: %s\n", v41);
          if (v41 != buf) {
            free(v41);
          }
        }
      }
      float v37 = (double)v35 / 1000000.0;
      unint64_t v38 = *(void *)sub_19047A7F8((unsigned __int16 *)(a1 + 3760), v18);
      double v39 = v37;
      sub_1904FEB34(a1, (uint64_t)v58, &v62, v38, v39);
      if ((*(_DWORD *)(a1 + 40) == 1 || v57[3814]) && v57[78])
      {
        sub_1905E1A34(a1 + 33656, (uint64_t)v58, (uint64_t *)&v62, v38, v39);
        *double v57 = *v54;
        sub_190420660(a1 + 33592, (float32x2_t *)v58, (float *)&v62, v38, v39);
      }
      if (!v56[24] || *v56 || v56[17])
      {
        *double v55 = 0;
        v55[62] = 0;
      }
      else
      {
        *(void *)int buf = *(void *)(a1 + 16068);
        *(_DWORD *)&uint8_t buf[8] = *(_DWORD *)(a1 + 16076);
        float v40 = (float32x4_t *)(a1 + 16092);
        if (v56[16]) {
          float v40 = (float32x4_t *)(a1 + 16108);
        }
        v76[0] = *v40;
        sub_19045B1C8(a1 + 26960, v76, (long long *)(a1 + 16108), v38, v76[0]);
      }
      unint64_t v15 = v18 + 1;
      unint64_t v16 = *(void *)(a1 + 5184);
      a4 = v18;
    }
    while (v18 + 1 <= v16);
  }
  __n128 result = (void *)sub_19047A7F8((unsigned __int16 *)(a1 + 3760), v16);
  *(void *)(a1 + 5800) = *result;
  return result;
}

uint64_t sub_1904FE96C(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1[1] <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD2E00);
    }
    unint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 134217984;
      unint64_t v8 = a2;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: i < size(), file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMVectorBuffer.h, line 39,out of buffer range %zu.", buf, 0xCu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD2E00);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "Element &CMVectorBufferBase<float, 3>::operator[](const size_t) [T = float, N = 3]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return sub_19043049C(a1, a2);
}

void sub_1904FEB34(uint64_t a1, uint64_t a2, float32x2_t *a3, unint64_t a4, double a5)
{
  uint64_t v145 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 5)) {
    sub_1904F7554(a1, *(unsigned __int8 *)(a1 + 6));
  }
  if (!*(unsigned char *)(a1 + 92))
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    int v14 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_DEFAULT, "[RelDMService] Missing BodyFace transform prevented feedEKFWithData.", buf, 2u);
    }
    if (!sub_1902D8400(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    LOWORD(v134) = 0;
    goto LABEL_20;
  }
  float v10 = (unsigned char *)(a1 + 12176);
  if (*(unsigned char *)(a1 + 4) == 1)
  {
    int v11 = *(unsigned __int8 *)(a1 + 37449);
    *(unsigned char *)(a1 + 37449) = 0;
    unsigned int v12 = *(_DWORD *)(a1 + 5216);
    if (v12 <= 0x29 && ((1 << v12) & 0x20000000110) != 0 && (v12 == 8 || *(int *)(a1 + 5220) > 1)
      || sub_19058BDA8(a1 + 5216, a4) > 3.0 && *(unsigned char *)(a1 + 37448))
    {
      int v13 = 1;
      *(unsigned char *)(a1 + 37449) = 1;
      *(void *)(a1 + 37456) = a4;
    }
    else if (*(void *)(a1 + 37456) && sub_19058BBA4(a1 + 5216, a4) < 2.0 && *(void *)(a1 + 37456) + 10000000 > a4)
    {
      int v13 = 1;
      *(unsigned char *)(a1 + 37449) = 1;
    }
    else
    {
      int v13 = *(unsigned __int8 *)(a1 + 37449);
    }
    if (v13 != v11)
    {
      unint64_t v16 = (float *)(a1 + 15904);
      if (v13)
      {
        if (*v16 > 2.25) {
          sub_19050109C(v16, 2.25);
        }
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        int v17 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v17, OS_LOG_TYPE_DEFAULT, "[RelDMService, Entering steadyStatePedestrian.", buf, 2u);
        }
        if (!sub_1902D8400(115, 2)) {
          goto LABEL_44;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        LOWORD(v134) = 0;
      }
      else
      {
        sub_19050109C(v16, *(float *)(a1 + 15908));
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        unint64_t v18 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_DEFAULT, "[RelDMService], Exiting steadyStatePedestrian.", buf, 2u);
        }
        if (!sub_1902D8400(115, 2)) {
          goto LABEL_44;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        LOWORD(v134) = 0;
      }
      uint64_t v117 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::shortenBTZHorizonForMusic(const uint64_t)", "CoreLocation: %s\n", v117);
      if (v117 != (char *)buf) {
        free(v117);
      }
    }
LABEL_44:
    if (*(unsigned char *)(a1 + 4) == 1) {
      *(unsigned char *)(a1 + 12216) = *(unsigned char *)(a1 + 37449);
    }
  }
  int v129 = (float *)(a1 + 16092);
  float32x4_t v130 = (float *)(a1 + 5840);
  sub_190480DAC((float32x2_t *)(a1 + 5840), (float32x2_t *)a2, (uint64_t)a3, (float *)(a1 + 16092), (int *)(a1 + 5216), (unint64_t)*(double *)(a1 + 16048), a4, a5);
  if (*(unsigned char *)(a1 + 16056)) {
    unsigned __int8 v20 = *(unsigned char *)(a1 + 12208) == 0;
  }
  else {
    unsigned __int8 v20 = 0;
  }
  if (*v10) {
    unsigned __int8 v21 = *(unsigned char *)(a1 + 12216) != 0;
  }
  else {
    unsigned __int8 v21 = 0;
  }
  v19.i32[0] = *(_DWORD *)(a1 + 15856);
  sub_19042B914((unsigned __int8 *)(a1 + 27552), (float32x2_t *)a2, a3, v20, v21, (long long *)(a1 + 12184), a4, v19, *(float *)(a1 + 12088));
  if (*(unsigned char *)(a1 + 4) == 1)
  {
    if (*(double *)(a1 + 16048) <= 0.00499999989)
    {
      *(_DWORD *)(a1 + 37468) = 0;
    }
    else
    {
      double v22 = *(double *)(a1 + 15960);
      if (v22 > 1.0)
      {
        float v23 = v22 + *(double *)(a1 + 15952) * 2.0;
        *(float *)(a1 + 37472) = v23;
      }
      if (v22 == 0.0)
      {
        float v24 = *(float *)(a1 + 37472);
        if (v24 > 0.0)
        {
          *(float *)(a1 + 37468) = v24 + *(float *)(a1 + 37468);
          *(_DWORD *)(a1 + 37472) = 0;
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          double v25 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
          {
            double v26 = *(float *)(a1 + 37468);
            *(_DWORD *)int buf = 134217984;
            *(double *)&uint8_t buf[4] = v26;
            _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_DEBUG, "[RelDMService], fAccumulatedShortQuiescenceSeconds, %.3f", buf, 0xCu);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
            }
            double v27 = *(float *)(a1 + 37468);
            int v134 = 134217984;
            double v135 = v27;
            uint64_t v28 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::updateKeepBoresightCenteredState()", "CoreLocation: %s\n", v28);
            if (v28 != (char *)buf) {
              free(v28);
            }
          }
        }
      }
    }
    if (*(unsigned char *)(a1 + 37464))
    {
      if (*(double *)(a1 + 16048) < 0.00499999989 && (*(unsigned char *)(a1 + 37449) || *(double *)(a1 + 15952) >= 1.0))
      {
        *(unsigned char *)(a1 + 37464) = 0;
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        unint64_t v29 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v29, OS_LOG_TYPE_DEFAULT, "[RelDMService] keepBoresightCentered: Release boresight to normal tracking.", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          LOWORD(v134) = 0;
          double v115 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::updateKeepBoresightCenteredState()", "CoreLocation: %s\n", v115);
          if (v115 != (char *)buf) {
            free(v115);
          }
        }
      }
    }
    else
    {
      float v30 = *(float *)(a1 + 37468);
      BOOL v31 = v30 <= 12.5 && *(unsigned char *)(a1 + 37449) == 0;
      if (v31) {
        float v32 = 25.0;
      }
      else {
        float v32 = 50.0;
      }
      double v33 = *(double *)(a1 + 16048);
      if (v33 > (float)(v30 + v32) || *(unsigned char *)(a1 + 37449) && v33 > v32)
      {
        *(unsigned char *)(a1 + 37464) = 1;
        sub_1904F8348(a1, 0);
      }
    }
  }
  if ((*(_DWORD *)(a1 + 40) & 0xFFFFFFFE) == 2)
  {
LABEL_91:
    unint64_t v34 = *(void *)(a1 + 5808) + 210000;
    unsigned int v35 = *(_DWORD *)(a1 + 40) & 0xFFFFFFFE;
    int v36 = v35 != 2 || v34 < a4;
    if (v34 < a4 && v35 == 2)
    {
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      float v37 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v34 < a4;
        _os_log_impl(&dword_1902AF000, v37, OS_LOG_TYPE_DEFAULT, "[RelDMService] LongTimeSinceAnchor %d.", buf, 8u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        int v134 = 67109120;
        LODWORD(v135) = v34 < a4;
        double v114 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedEKFWithData(const IMUData &, const IMUData &, double, const uint64_t)", "CoreLocation: %s\n", v114);
        if (v114 != (char *)buf) {
          free(v114);
        }
      }
    }
    int v38 = *(_DWORD *)(a1 + 40);
    if (v38 == 3) {
      a5 = 0.0;
    }
    if (v34 < a4 && v38 == 2)
    {
      uint64_t v39 = 0;
      int32x2_t v40 = 0;
      do
      {
        *(float *)v40.i32 = *(float *)v40.i32 + (float)(*(float *)(a2 + 12 + v39) * *(float *)(a2 + 12 + v39));
        v39 += 4;
      }
      while (v39 != 12);
      *(float *)v40.i32 = sqrtf(*(float *)v40.i32);
      float32x2_t v41 = vdiv_f32(*(float32x2_t *)(a2 + 12), (float32x2_t)vdup_lane_s32(v40, 0));
      float v42 = *(float *)(a2 + 20);
      memset(buf, 0, sizeof(buf));
      *(float32x2_t *)__int16 v139 = v41;
      *(float *)&v139[8] = v42 / *(float *)v40.i32;
      *(void *)&v139[12] = *(void *)(a2 + 24);
      int v140 = *(_DWORD *)(a2 + 32);
      uint64_t v141 = *(void *)(a2 + 36);
      int v142 = *(_DWORD *)(a2 + 44);
      uint64_t v143 = 1;
      long long v144 = *(_OWORD *)(a2 + 56);
      uint64_t v43 = a1 + 16064;
      float v44 = a5;
      float v45 = buf;
    }
    else
    {
      uint64_t v43 = a1 + 16064;
      float v44 = a5;
      float v45 = (uint8_t *)a2;
    }
    sub_190477FFC(v43, (uint64_t)v45, (uint64_t)a3, v36, v44);
    if (!*(_DWORD *)(a2 + 48) || (float v54 = 0.0, !a3[6].i32[0]))
    {
      if (*(_DWORD *)(a1 + 40) == 2) {
        sub_190483840((uint64_t)v130, (float *)a2, (float *)a3, v129, a4);
      }
      else {
        sub_190483B48((uint64_t)v130, a2, (float *)a3, a4, v53);
      }
      float v54 = (float)(v55 * 9.8067) * 9.8067;
    }
    sub_190476D58(a1 + 16064, a2, (uint64_t)a3, *(_DWORD *)(a1 + 40), a4, a5, v54);
    if (*(_DWORD *)(a1 + 40) == 1 && *(void *)(a1 + 26400) == a4)
    {
      *(_OWORD *)(a1 + 15968) = 0u;
      *(_OWORD *)(a1 + 15952) = 0u;
LABEL_326:
      *(void *)(a1 + 16048) = 0;
      return;
    }
    return;
  }
  uint64_t v46 = a1 + 16064;
  *(unsigned char *)(a1 + 16057) = 0;
  if (*(unsigned char *)(a1 + 16064))
  {
    uint64_t v126 = a1 + 64;
    unint64_t v47 = (float32x2_t *)sub_190479348(a1 + 64);
    int v127 = sub_190483E80((uint64_t)v130, a2, (float *)a3, v47, *(unsigned __int8 *)(a1 + 46), v48);
    int v49 = *(unsigned __int8 *)(a1 + 16059);
    int v50 = *(unsigned __int8 *)(a1 + 32604);
    *(unsigned char *)(a1 + 16059) = v50;
    int v51 = *(unsigned __int8 *)(a1 + 4);
    if (v51 == 1)
    {
      int v52 = *v10;
      if (*v10)
      {
        int v52 = *(unsigned __int8 *)(a1 + 12216);
        if (*(unsigned char *)(a1 + 12216)) {
          int v52 = (!*(unsigned char *)(a1 + 27552) || !*(unsigned char *)(a1 + 33512)) && *(unsigned char *)(a1 + 12208) != 0;
        }
      }
      BOOL v31 = v50 == 0;
      int v50 = v52 ^ 1;
      if (v31) {
        int v50 = 0;
      }
      *(unsigned char *)(a1 + 16059) = v50;
    }
    if (v49 != v50)
    {
      if (v50)
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        float32x4_t v61 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v61, OS_LOG_TYPE_DEFAULT, "[RelDMService] Entering complex transition.", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          LOWORD(v134) = 0;
LABEL_386:
          float v119 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::determineBTZ(const IMUData &, const IMUData &, const double, const uint64_t)", "CoreLocation: %s\n", v119);
          if (v119 != (char *)buf) {
            free(v119);
          }
        }
      }
      else
      {
        if (v51 == 1)
        {
          sub_19050109C((float *)(a1 + 15904), 1.0);
          *(unsigned char *)(a1 + 47) = 1;
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          float32x2_t v62 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)int buf = 0;
            _os_log_impl(&dword_1902AF000, v62, OS_LOG_TYPE_DEFAULT, "[RelDMService] Shorten Pedestrian BTZ horizon upon exiting complex transition.", buf, 2u);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
            }
            LOWORD(v134) = 0;
            float32x4_t v121 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::determineBTZ(const IMUData &, const IMUData &, const double, const uint64_t)", "CoreLocation: %s\n", v121);
            if (v121 != (char *)buf) {
              free(v121);
            }
          }
        }
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        float v63 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v63, OS_LOG_TYPE_DEFAULT, "[RelDMService] Exiting complex transition.", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          LOWORD(v134) = 0;
          goto LABEL_386;
        }
      }
    }
    int v64 = *v10;
    if (!*v10 || !*(unsigned char *)(a1 + 12216))
    {
      *(unsigned char *)(a1 + 50) = 0;
      goto LABEL_219;
    }
    *(void *)int buf = *(void *)(a1 + 16068);
    *(_DWORD *)&uint8_t buf[8] = *(_DWORD *)(a1 + 16076);
    float v65 = (_OWORD *)(a1 + 16092);
    if (*(unsigned char *)(a1 + 16056)) {
      float v65 = (_OWORD *)(a1 + 16108);
    }
    *(_OWORD *)__int16 v139 = *v65;
    float v131 = sub_1904778D0(v126, (float *)buf, (float32x2_t *)v139);
    int v132 = v66;
    int v133 = v67;
    float v68 = sub_19058AD48(&v131);
    if (*(unsigned char *)(a1 + 50))
    {
      if (!*(unsigned char *)(a1 + 16059) && !*(unsigned char *)(a1 + 16040) && a4 - *(void *)(a1 + 56) <= 0x6ACFC0 && v68 >= 0.43633) {
        goto LABEL_218;
      }
      sub_19050109C((float *)(a1 + 15904), 2.25);
      *(unsigned char *)(a1 + 50) = 0;
      *(void *)(a1 + 56) = 0;
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      int v69 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v69, OS_LOG_TYPE_DEFAULT, "[RelDMService] Exit lengthened BTZ horizon.", buf, 2u);
      }
      if (!sub_1902D8400(115, 2)) {
        goto LABEL_218;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      LOWORD(v134) = 0;
    }
    else
    {
      if (*(unsigned char *)(a1 + 12208))
      {
        char v71 = 1;
      }
      else
      {
        uint64_t v73 = *(void *)(a1 + 12192);
        BOOL v31 = v73 == 0;
        unint64_t v74 = v73 + 2000000;
        char v71 = v31 || v74 <= a4;
      }
      if (*(unsigned char *)(a1 + 47)) {
        goto LABEL_218;
      }
      if (*(unsigned __int8 *)(a1 + 16059) | *(unsigned __int8 *)(a1 + 49)) {
        char v71 = 1;
      }
      if (v71) {
        goto LABEL_218;
      }
      float v76 = *(float *)(a1 + 12200);
      if (v76 <= 0.0) {
        float v76 = -v76;
      }
      if (v76 <= 0.43633 || v68 <= 0.7854) {
        goto LABEL_218;
      }
      sub_19050109C((float *)(a1 + 15904), 5.0);
      *(unsigned char *)(a1 + 50) = 1;
      *(void *)(a1 + 56) = a4;
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      uint64_t v77 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
      {
        float v78 = *(float *)(a1 + 12200);
        if (v78 <= 0.0) {
          float v78 = -v78;
        }
        *(_DWORD *)int buf = 134218240;
        *(double *)&uint8_t buf[4] = (float)(v78 * 57.296);
        *(_WORD *)__int16 v139 = 2048;
        *(double *)&v139[2] = (float)(v68 * 57.296);
        _os_log_impl(&dword_1902AF000, v77, OS_LOG_TYPE_DEFAULT, "[RelDMService] Enter lengthened BTZ horizon. headYaw, %.2f, boreSightAngle, %.2f", buf, 0x16u);
      }
      if (!sub_1902D8400(115, 2)) {
        goto LABEL_218;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      float v125 = *(float *)(a1 + 12200);
      if (v125 <= 0.0) {
        float v125 = -v125;
      }
      int v134 = 134218240;
      double v135 = (float)(v125 * 57.296);
      __int16 v136 = 2048;
      double v137 = (float)(v68 * 57.296);
    }
    int v70 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::updateBTZHorizonAfterPedestrianHeadTurn(uint64_t)", "CoreLocation: %s\n", v70);
    if (v70 != (char *)buf) {
      free(v70);
    }
LABEL_218:
    int v64 = *v10;
LABEL_219:
    if (v64)
    {
      if (!*(unsigned char *)(a1 + 49))
      {
        if (*(unsigned char *)(a1 + 12217))
        {
          *(unsigned char *)(a1 + 49) = 1;
          sub_19050109C((float *)(a1 + 15904), 1.0);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          uint64_t v81 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)int buf = 0;
            _os_log_impl(&dword_1902AF000, v81, OS_LOG_TYPE_DEFAULT, "[RelDMService] Enter ForceShortendBTZHorizon due to likelySlowBodyTurn.", buf, 2u);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
            }
            LOWORD(v134) = 0;
            goto LABEL_391;
          }
        }
LABEL_244:
        sub_1905643C4(a1 + 15904, a2, (uint64_t)a3, v129, v127, *(unsigned __int8 *)(a1 + 16059), a4, a5);
        if (*(_DWORD *)(a1 + 40) == 1)
        {
          unint64_t v82 = *(void *)(a1 + 26400);
          BOOL v83 = a4 <= v82 || v82 == 0;
          float v84 = (float)(a4 - v82) * 0.000001;
          if (v83) {
            float v84 = 3.4028e38;
          }
          unint64_t v85 = *(void *)(a1 + 5816);
          if (v85 <= *(void *)(a1 + 5824)) {
            unint64_t v85 = *(void *)(a1 + 5824);
          }
          BOOL v86 = a4 <= v85 || v85 == 0;
          float v87 = (float)(a4 - v85) * 0.000001;
          if (v86) {
            float v87 = 3.4028e38;
          }
          unint64_t v88 = *(void *)(a1 + 5832);
          BOOL v89 = a4 <= v88 || v88 == 0;
          float v90 = (float)(a4 - v88) * 0.000001;
          if (v89) {
            float v90 = 3.4028e38;
          }
          sub_190564000(a1 + 15904, v84, v87, v90);
        }
        uint64_t v128 = a1 + 16064;
        int v91 = *(unsigned __int8 *)(a1 + 16040);
        if (*(unsigned char *)(a1 + 15946))
        {
          int v92 = *(unsigned __int8 *)(a1 + 27520);
          *(unsigned char *)(a1 + 16040) = v92 ^ 1;
          if (v91 == (v92 ^ 1)) {
            goto LABEL_314;
          }
          if (!v92)
          {
            if (*(unsigned char *)(a1 + 47) && !*(unsigned char *)(a1 + 48)) {
              *(unsigned char *)(a1 + 48) = *(unsigned char *)(a1 + 16059) ^ 1;
            }
            *(unsigned char *)(a1 + 27428) = 0;
            *(_DWORD *)(a1 + 27432) = 0;
            *(void *)(a1 + 27396) = 0;
            *(void *)(a1 + 27401) = 0;
            *(unsigned char *)(a1 + 27436) = 1;
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
            }
            float32x4_t v93 = qword_1E929D8E0;
            if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)int buf = 0;
              _os_log_impl(&dword_1902AF000, v93, OS_LOG_TYPE_DEFAULT, "[RelDMService] Entering BTZ.", buf, 2u);
            }
            if (sub_1902D8400(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1E929D8D8 != -1) {
                dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
              }
              LOWORD(v134) = 0;
LABEL_372:
              double v116 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::determineBTZ(const IMUData &, const IMUData &, const double, const uint64_t)", "CoreLocation: %s\n", v116);
              if (v116 != (char *)buf) {
                free(v116);
              }
              goto LABEL_314;
            }
            goto LABEL_314;
          }
        }
        else
        {
          *(unsigned char *)(a1 + 16040) = 0;
          if (!v91) {
            goto LABEL_314;
          }
        }
        if (*(unsigned char *)(a1 + 48))
        {
          if (!*(unsigned char *)(a1 + 49))
          {
            if (*v10)
            {
              float v94 = 2.25;
              if (!*(unsigned char *)(a1 + 12216)) {
                float v94 = 5.0;
              }
            }
            else
            {
              float v94 = 5.0;
            }
            sub_19050109C((float *)(a1 + 15904), v94);
          }
          *(_WORD *)(a1 + 47) = 0;
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          double v104 = qword_1E929D8E0;
          if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)int buf = 0;
            _os_log_impl(&dword_1902AF000, v104, OS_LOG_TYPE_DEFAULT, "[RelDMService] Reset BTZ horizon upon first BTZ after shortened horizon due to CT.", buf, 2u);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
            }
            LOWORD(v134) = 0;
            double v118 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::determineBTZ(const IMUData &, const IMUData &, const double, const uint64_t)", "CoreLocation: %s\n", v118);
            if (v118 != (char *)buf) {
              free(v118);
            }
          }
        }
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        double v105 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v105, OS_LOG_TYPE_DEFAULT, "[RelDMService] Exiting BTZ.", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
          }
          LOWORD(v134) = 0;
          goto LABEL_372;
        }
LABEL_314:
        *(double *)(a1 + 16048) = *(double *)(a1 + 16048) + a5;
        sub_1904831CC((uint64_t)v130, a2, (uint64_t)a3, a5);
        double v106 = *(double *)(a1 + 12064);
        if (*(unsigned char *)(a1 + 4) == 1 && *(unsigned char *)(a1 + 37464) || *(unsigned char *)(a1 + 15944)) {
          goto LABEL_324;
        }
        int v107 = *(unsigned __int8 *)(a1 + 46);
        if (!*(unsigned char *)(a1 + 16040))
        {
          if (!*(unsigned char *)(a1 + 46))
          {
            if (*(double *)(a1 + 16048) < v106) {
              double v106 = *(double *)(a1 + 16048);
            }
            if (v106 > 15.0)
            {
              *(unsigned char *)(a1 + 46) = 1;
              float v108 = 3.0;
              if (*(float *)(a1 + 15908) > 3.0) {
                goto LABEL_323;
              }
            }
            goto LABEL_324;
          }
          int v107 = 1;
        }
        if (v106 < a5 && v107)
        {
          *(unsigned char *)(a1 + 46) = 0;
          float v108 = *(float *)(a1 + 15908);
LABEL_323:
          sub_19050109C((float *)(a1 + 15904), v108);
        }
LABEL_324:
        if (*(unsigned char *)(a1 + 16040))
        {
          *(void *)int buf = *(void *)(a1 + 15992);
          *(_DWORD *)&uint8_t buf[8] = *(_DWORD *)(a1 + 16000);
          *(_OWORD *)__int16 v139 = *(_OWORD *)(a1 + 16004);
          sub_190477034(v128, buf, a4);
          goto LABEL_326;
        }
        if (*(_DWORD *)(a1 + 40))
        {
          uint64_t v109 = *(void *)(a1 + 26400);
          if (v109)
          {
            if (v109 + 250000 > a4) {
              goto LABEL_91;
            }
          }
        }
        unsigned int v110 = *(unsigned __int16 *)(a1 + 5842);
        if (v110 == *(unsigned __int16 *)(a1 + 7050))
        {
          if (v110 >= *(unsigned __int16 *)(a1 + 9130)) {
            unsigned int v110 = *(unsigned __int16 *)(a1 + 9130);
          }
          if (v110 >= 0x28)
          {
            if (sub_1904847E8(v130))
            {
              *(void *)(a1 + 5832) = a4;
              if (!*(unsigned char *)(a1 + 16056))
              {
                *(_WORD *)(a1 + 16056) = 257;
                sub_190477254(v128);
                if (qword_1E929D8D8 != -1) {
                  dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
                }
                double v111 = qword_1E929D8E0;
                if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)int buf = 0;
                  _os_log_impl(&dword_1902AF000, v111, OS_LOG_TYPE_DEFAULT, "[RelDMService] Entering 1-IMU.", buf, 2u);
                }
                if (!sub_1902D8400(115, 2)) {
                  goto LABEL_91;
                }
                bzero(buf, 0x65CuLL);
                if (qword_1E929D8D8 != -1) {
                  dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
                }
                LOWORD(v134) = 0;
                goto LABEL_360;
              }
            }
            else if (*(unsigned char *)(a1 + 16056) && (sub_190484030((uint64_t)v130) & 1) != 0)
            {
              *(_WORD *)(a1 + 16056) = 256;
              sub_190477658(v128, v126, 0);
              if (qword_1E929D8D8 != -1) {
                dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
              }
              double v112 = qword_1E929D8E0;
              if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)int buf = 0;
                _os_log_impl(&dword_1902AF000, v112, OS_LOG_TYPE_DEFAULT, "[RelDMService] Entering 2-IMU.", buf, 2u);
              }
              if (!sub_1902D8400(115, 2)) {
                goto LABEL_91;
              }
              bzero(buf, 0x65CuLL);
              if (qword_1E929D8D8 != -1) {
                dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
              }
              LOWORD(v134) = 0;
LABEL_360:
              double v113 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedEKFWithData(const IMUData &, const IMUData &, double, const uint64_t)", "CoreLocation: %s\n", v113);
              if (v113 != (char *)buf) {
                free(v113);
              }
              goto LABEL_91;
            }
          }
        }
        *(unsigned char *)(a1 + 16057) = 0;
        goto LABEL_91;
      }
      if (*(unsigned char *)(a1 + 12217)) {
        goto LABEL_244;
      }
      *(unsigned char *)(a1 + 49) = 0;
      if (!*(unsigned char *)(a1 + 47))
      {
        float v79 = 2.25;
        if (!*(unsigned char *)(a1 + 12216)) {
          float v79 = 5.0;
        }
        goto LABEL_229;
      }
    }
    else
    {
      if (!*(unsigned char *)(a1 + 49)) {
        goto LABEL_244;
      }
      *(unsigned char *)(a1 + 49) = 0;
      if (!*(unsigned char *)(a1 + 47))
      {
        float v79 = 5.0;
LABEL_229:
        sub_19050109C((float *)(a1 + 15904), v79);
      }
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    uint64_t v80 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v80, OS_LOG_TYPE_DEFAULT, "[RelDMService] Exit ForceShortendBTZHorizon.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      LOWORD(v134) = 0;
LABEL_391:
      float v120 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CMRelDMService::determineBTZ(const IMUData &, const IMUData &, const double, const uint64_t)", "CoreLocation: %s\n", v120);
      if (v120 != (char *)buf) {
        free(v120);
      }
      goto LABEL_244;
    }
    goto LABEL_244;
  }
  if (!*(unsigned char *)(a1 + 16061))
  {
    if (*(_DWORD *)(a1 + 5428) == *(unsigned __int16 *)(a1 + 5426)) {
      goto LABEL_129;
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    long long v72 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v72, OS_LOG_TYPE_DEFAULT, "[RelDMService] Can't initialize due to accessory IMU buffers not being full.", buf, 2u);
    }
    if (!sub_1902D8400(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    LOWORD(v134) = 0;
LABEL_20:
    unint64_t v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedEKFWithData(const IMUData &, const IMUData &, double, const uint64_t)", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
    return;
  }
  if (*(_DWORD *)(a1 + 5472) != *(unsigned __int16 *)(a1 + 5470)) {
    return;
  }
LABEL_129:
  float v56 = 0.0;
  for (uint64_t i = 3; i != 6; ++i)
    float v56 = v56 + (float)(a3->f32[i] * a3->f32[i]);
  float v58 = sqrtf(v56) + -1.0;
  if (v58 <= 0.0) {
    float v58 = -v58;
  }
  if (v58 < 0.5)
  {
    if (*(unsigned char *)(a1 + 16061))
    {
      if (*(unsigned char *)(a1 + 5440)) {
        sub_190430068(a1 + 5440);
      }
      long long v59 = (unsigned char *)(a1 + 5440);
      BOOL v60 = *(float *)(a1 + 5444) < 0.2618
         && sub_19043180C((unsigned __int16 *)(a1 + 5424), (unsigned int (*)(float, float))sub_190431A0C, 0) < 0.5236;
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      unint64_t v95 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
      {
        if (*v59) {
          sub_190430068(a1 + 5440);
        }
        double v96 = *(float *)(a1 + 5444);
        float v97 = sub_19043180C((unsigned __int16 *)(a1 + 5424), (unsigned int (*)(float, float))sub_190431A0C, 0);
        *(_DWORD *)int buf = 134218240;
        *(double *)&uint8_t buf[4] = v96;
        *(_WORD *)__int16 v139 = 2048;
        *(double *)&v139[2] = v97;
        _os_log_impl(&dword_1902AF000, v95, OS_LOG_TYPE_DEBUG, "[RelDMService] fResetTrackingAfterAuxGap, mean %.3f, maxCurr %.3f", buf, 0x16u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
        }
        if (*v59) {
          sub_190430068(a1 + 5440);
        }
        double v122 = *(float *)(a1 + 5444);
        int v134 = 134218240;
        double v135 = v122;
        __int16 v136 = 2048;
        double v137 = sub_19043180C((unsigned __int16 *)(a1 + 5424), (unsigned int (*)(float, float))sub_190431A0C, 0);
        float v123 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedEKFWithData(const IMUData &, const IMUData &, double, const uint64_t)", "CoreLocation: %s\n", v123);
        if (v123 != (char *)buf) {
          free(v123);
        }
        uint64_t v46 = a1 + 16064;
        if (!v60) {
          return;
        }
      }
      else if (!v60)
      {
        return;
      }
    }
    else if (sub_19043180C((unsigned __int16 *)(a1 + 5424), (unsigned int (*)(float, float))sub_190431A0C, 0) >= 0.34907)
    {
      return;
    }
    *(_DWORD *)int buf = sub_1904CF514((float *)(a2 + 56));
    *(_DWORD *)&uint8_t buf[4] = v98;
    *(_DWORD *)&uint8_t buf[8] = v99;
    v100.f32[0] = sub_1904CF514((float *)&a3[7]);
    float v131 = v100.f32[0];
    int v132 = v101;
    int v133 = v102;
    sub_190563F68(a1 + 15904, (float *)buf, &v131, v129, (uint64_t)&v134, v100);
    sub_190475F28(v46, a2, (uint64_t)a3, &v134, a4);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    double v103 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v103, OS_LOG_TYPE_DEFAULT, "[RelDMService] Initializing EKF.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      LOWORD(v131) = 0;
      float v124 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::feedEKFWithData(const IMUData &, const IMUData &, double, const uint64_t)", "CoreLocation: %s\n", v124);
      if (v124 != (char *)buf) {
        free(v124);
      }
    }
    *(unsigned char *)(a1 + 16061) = 0;
  }
}

void sub_19050109C(float *a1, float a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  *a1 = a2;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  unint64_t v3 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
  {
    double v4 = *a1;
    *(_DWORD *)int buf = 134217984;
    double v7 = v4;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEBUG, "[CMBleedToZero] Setting BTZ horizon to %.2f seconds", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    unint64_t v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMBleedToZero::setMinRequiredQuiescentPeriod(float)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
}

void sub_19050125C(uint64_t a1, float32x2_t *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 92))
  {
    double v4 = (float *)sub_190479348(a1 + 64);
    if (*v4 != a2->f32[0] || v4[1] != a2->f32[1] || v4[2] != a2[1].f32[0] || v4[3] != a2[1].f32[1]) {
      sub_1904F86F0(a1, 1);
    }
  }
  else
  {
    if ((float32x2_t *)(a1 + 76) != a2) {
      *(_OWORD *)(a1 + 76) = *(_OWORD *)a2->f32;
    }
    *(unsigned char *)(a1 + 92) = 1;
    if ((float32x2_t *)(a1 + 15924) != a2) {
      *(_OWORD *)(a1 + 15924) = *(_OWORD *)a2->f32;
    }
    *(unsigned char *)(a1 + 15940) = 1;
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    unint64_t v5 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      double v6 = a2->f32[0];
      double v7 = a2->f32[1];
      double v8 = a2[1].f32[0];
      double v9 = a2[1].f32[1];
      *(_DWORD *)int buf = 134284289;
      double v13 = v6;
      __int16 v14 = 2049;
      double v15 = v7;
      __int16 v16 = 2049;
      double v17 = v8;
      __int16 v18 = 2049;
      double v19 = v9;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_DEFAULT, "[RelDMService] Headset orientation q_bf set to [%{private}f,%{private}f,%{private}f,%{private}f]", buf, 0x2Au);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
      }
      int v11 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::setFixedTransforms(const CMOQuaternion &)", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
    if (*(_DWORD *)(a1 + 40) == 1 || *(unsigned char *)(a1 + 37408)) {
      sub_1905E1798(a1 + 33656, a2, v10);
    }
  }
}

BOOL sub_19050166C(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 4) != 1 || !*(unsigned char *)(a1 + 37464))
      && !*(unsigned char *)(a1 + 16058)
      && *(double *)(a1 + 16048) > 0.100000001
      && *(_WORD *)(a1 + 26970)
      && *(unsigned char *)(a1 + 16057) == 0;
}

float sub_1905016D4(float32x2_t *a1, float32x4_t a2)
{
  a2.f32[0] = -a1[666].f32[0];
  __int32 v3 = a1[666].i32[1];
  *(float32x2_t *)v6.f32 = vneg_f32(a1[665]);
  v6.i64[1] = __PAIR64__(v3, a2.u32[0]);
  sub_1902D9ACC(&v6, a2);
  sub_1904CF73C(v6.f32, a1[658].f32[0], a1[658].f32[1], a1[659].f32[0]);
  return v4;
}

float sub_190501738(float32x2_t *a1, float32x4_t a2)
{
  a2.f32[0] = -a1[675].f32[0];
  __int32 v3 = a1[675].i32[1];
  *(float32x2_t *)v6.f32 = vneg_f32(a1[674]);
  v6.i64[1] = __PAIR64__(v3, a2.u32[0]);
  sub_1902D9ACC(&v6, a2);
  sub_1904CF73C(v6.f32, a1[667].f32[0], a1[667].f32[1], a1[668].f32[0]);
  return v4;
}

void sub_19050179C(uint64_t a1, float32x4_t *a2, float *a3, void *a4, void *a5)
{
  float32x4_t v10 = (unsigned char *)(a1 + 16056);
  if (*(unsigned char *)(a1 + 4))
  {
    BOOL v11 = *(unsigned char *)(a1 + 37464) != 0;
    if (*(unsigned char *)(a1 + 37464)) {
      goto LABEL_14;
    }
  }
  else
  {
    BOOL v11 = 0;
  }
  if (!*(unsigned char *)(a1 + 16064))
  {
LABEL_14:
    a2->i64[0] = 0;
    a2->i64[1] = 0x3F80000000000000;
    double v17 = sub_190501944();
    *a3 = *(float *)&v17;
    *((_DWORD *)a3 + 1) = v18;
    *((_DWORD *)a3 + 2) = v19;
    uint64_t v20 = *(unsigned __int16 *)(a1 + 3762);
    if (*(_WORD *)(a1 + 3762))
    {
      unint64_t v21 = v20 + *(unsigned __int16 *)(a1 + 3760) - 1;
      unint64_t v22 = *(unsigned int *)(a1 + 3764);
      if (v21 < v22) {
        unint64_t v22 = 0;
      }
      uint64_t v20 = *(void *)(a1 + 3760 + 8 * (v21 - v22) + 8);
    }
    *a5 = v20;
    if (v10[2]) {
      int v23 = 1;
    }
    else {
      int v23 = v11;
    }
    if (!v23) {
      uint64_t v20 = 0;
    }
    *a4 = v20;
    return;
  }
  int v26 = *(_DWORD *)(a1 + 16076);
  uint64_t v25 = *(void *)(a1 + 16068);
  if (*v10) {
    unsigned int v12 = (_OWORD *)(a1 + 16108);
  }
  else {
    unsigned int v12 = (_OWORD *)(a1 + 16092);
  }
  *(_OWORD *)v27[0].f32 = *v12;
  sub_1905019E8(a1 + 64, (uint64_t)v27, &v24);
  if (&v24 != a2) {
    *a2 = v24;
  }
  *a3 = sub_1904778D0(a1 + 64, (float *)&v25, v27);
  *((_DWORD *)a3 + 1) = v13;
  *((_DWORD *)a3 + 2) = v14;
  *a4 = *(void *)(a1 + 5800);
  unint64_t v15 = *(unsigned __int16 *)(a1 + 3760) + (unint64_t)*(unsigned __int16 *)(a1 + 3762) - 1;
  unint64_t v16 = *(unsigned int *)(a1 + 3764);
  if (v15 < v16) {
    unint64_t v16 = 0;
  }
  *a5 = *(void *)(a1 + 3760 + 8 * (v15 - v16) + 8);
}

double sub_190501944()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E929E0D0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E929E0D0))
  {
    sub_1902BAD40();
    int v1 = sub_19046BCE8();
    float v2 = -0.34907;
    if (!v1) {
      float v2 = 0.0;
    }
    dword_1E929E0C8 = LODWORD(v2);
    __cxa_guard_release(&qword_1E929E0D0);
  }
  __sincosf_stret(*(float *)&dword_1E929E0C8);
  return 0.0;
}

void sub_1905019D0(_Unwind_Exception *a1)
{
}

double sub_1905019E8@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float32x4_t *a3@<X8>)
{
  unint64_t v5 = (float *)sub_190479348(a1);
  *(double *)v8.i64 = sub_1904CF3F4(a2, v5, &v10, v6);
  __int32 v7 = v10.i32[3];
  v8.f32[0] = -v10.f32[2];
  *(float32x2_t *)a3->f32 = vneg_f32(*(float32x2_t *)v10.f32);
  a3->i32[2] = v8.i32[0];
  a3->i32[3] = v7;

  *(void *)&double result = sub_1902D9ACC(a3, v8).u64[0];
  return result;
}

void sub_190501A54(uint64_t a1, unint64_t *a2, float32x4_t *a3, uint64_t a4, uint64_t *a5, uint64_t *a6, unsigned char *a7)
{
  int v14 = (unsigned char *)(a1 + 16056);
  if (*(unsigned char *)(a1 + 16060)) {
    BOOL v15 = *a2 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15)
  {
    *a7 = 0;
LABEL_16:
    sub_19050179C(a1, a3, (float *)a4, a5, a6);
    uint64_t v23 = *a5;
    *a2 = *a5;
    uint64_t v22 = *a6;
    goto LABEL_17;
  }
  BOOL v16 = sub_19050166C(a1);
  *a7 = v16;
  if (!v16) {
    goto LABEL_16;
  }
  int v26 = *(_DWORD *)(a1 + 16076);
  uint64_t v25 = *(void *)(a1 + 16068);
  if (*v14) {
    double v17 = (float32x4_t *)(a1 + 16108);
  }
  else {
    double v17 = (float32x4_t *)(a1 + 16092);
  }
  float32x4_t v27 = *v17;
  sub_19045B770(a1 + 26960, a2, &v27, v27);
  sub_1905019E8(a1 + 64, (uint64_t)&v27, &v24);
  if (&v24 != a3) {
    *a3 = v24;
  }
  *(float *)a4 = sub_1904778D0(a1 + 64, (float *)&v25, (float32x2_t *)&v27);
  *(_DWORD *)(a4 + 4) = v18;
  *(_DWORD *)(a4 + 8) = v19;
  *a5 = *(void *)(a1 + 5800);
  unint64_t v20 = *(unsigned __int16 *)(a1 + 3760) + (unint64_t)*(unsigned __int16 *)(a1 + 3762) - 1;
  unint64_t v21 = *(unsigned int *)(a1 + 3764);
  if (v20 < v21) {
    unint64_t v21 = 0;
  }
  uint64_t v22 = *(void *)(a1 + 3760 + 8 * (v20 - v21) + 8);
  *a6 = v22;
  uint64_t v23 = *a2;
LABEL_17:
  sub_19050F830(a1 + 27344, (float *)a4, v23, v22);
}

uint64_t sub_190501BF0(uint64_t result)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(result + 4))
  {
    if (*(unsigned char *)(result + 37464))
    {
      *(unsigned char *)(result + 37464) = 0;
      sub_1904F86F0(result, 1);
    }
  }
  return result;
}

void sub_190501D9C(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 5816) = a2;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  __int32 v3 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)int buf = 134217984;
    uint64_t v6 = a2;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEBUG, "[RelDMService], walk or step detected. timestamp %llu", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    float v4 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::setTimestampAuxLastDetectedWalking(uint64_t)", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
}

void sub_190501F4C(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 5824) = a2;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
  }
  __int32 v3 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)int buf = 134217984;
    uint64_t v6 = a2;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEBUG, "[RelDMService], sit->stand detected. timestamp %llu", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1D80);
    }
    float v4 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMRelDMService::setTimestampAuxLastDetectedSitToStand(uint64_t)", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
  }
}

os_log_t sub_1905020FC()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

void **sub_19050212C(void **a1)
{
  __int32 v3 = a1 + 647;
  sub_19042FEF0(&v3);
  __int32 v3 = a1 + 644;
  sub_19042FEF0(&v3);
  __int32 v3 = a1 + 641;
  sub_19042FEF0(&v3);
  __int32 v3 = a1 + 638;
  sub_19042FEF0(&v3);
  return a1;
}

void *sub_1905021A8(void *a1)
{
  float v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_19050222C()
{
  exceptiouint64_t n = __cxa_allocate_exception(8uLL);
  *exceptiouint64_t n = &unk_1EDFD0C20;
  __cxa_throw(exception, (struct type_info *)&unk_1EDFC73A8, (void (*)(void *))std::exception::~exception);
}

void sub_19050227C(std::exception *a1)
{
  std::exception::~exception(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1905022B4(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD2E00);
    }
    uint64_t v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)int buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD2E00);
      }
      double v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const T &CMQueue<CMOQuaternion>::operator[](const size_t) const [T = CMOQuaternion]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[8 * (v4 - v5) + 4];
}

void sub_190502900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_1902D8B58(a15);
  }
  objc_sync_exit(v15);
  _Unwind_Resume(a1);
}

os_log_t sub_190502954()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "PredictedWalkDistance");
  qword_1E929D960 = (uint64_t)result;
  return result;
}

void sub_190502F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  sub_1902D8B58(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_1905031E4(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__disconnect(*(void **)(a1 + 32), a2, a3);
}

void sub_190503264(uint64_t a1)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  long long v1 = *(_OWORD *)(a1 + 32);
  float v2 = *(NSObject **)(*(void *)(a1 + 32) + 16);
  _OWORD v3[2] = sub_1905032DC;
  v3[3] = &unk_1E568D190;
  long long v4 = v1;
  dispatch_async(v2, v3);
}

uint64_t sub_1905032DC(uint64_t a1)
{
  objc_storeWeak((id *)(*(void *)(a1 + 32) + 24), *(id *)(a1 + 40));
  id Weak = objc_loadWeak((id *)(*(void *)(a1 + 32) + 24));
  unint64_t v5 = *(void **)(a1 + 32);
  if (Weak)
  {
    return objc_msgSend__connect(v5, v2, v3);
  }
  else
  {
    return objc_msgSend__disconnect(v5, v2, v3);
  }
}

void sub_19050356C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  sub_1902D8B58(v30);
  objc_destroyWeak(v29);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_19050361C(uint64_t a1, uint64_t *a2)
{
  id Weak = (id *)objc_loadWeak((id *)(a1 + 32));
  if (Weak)
  {
    long long v4 = Weak;
    if (objc_loadWeak(Weak + 3))
    {
      uint64_t v6 = (std::__shared_weak_count *)a2[1];
      uint64_t v7 = *a2;
      int v8 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      objc_msgSend__handleMessage_(v4, v5, (uint64_t)&v7);
      if (v8) {
        sub_1902D8B58(v8);
      }
    }
  }
}

void sub_190503690(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_190503A2C(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(*(void *)(a1 + 32) + 24));
  uint64_t v3 = *(void *)(a1 + 32);

  return MEMORY[0x1F4181798](Weak, sel_manager_didUpdateEvent_, v3);
}

uint64_t sub_190503A6C(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(*(void *)(a1 + 32) + 24));
  uint64_t v3 = *(void *)(a1 + 32);

  return MEMORY[0x1F4181798](Weak, sel_manager_didUpdateMeasurement_, v3);
}

uint64_t sub_190503AAC(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(*(void *)(a1 + 32) + 24));
  uint64_t v3 = *(void *)(a1 + 32);

  return MEMORY[0x1F4181798](Weak, sel_manager_didUpdateTemperature_, v3);
}

uint64_t sub_190503AEC(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(*(void *)(a1 + 32) + 24));
  uint64_t v3 = *(void *)(a1 + 32);

  return MEMORY[0x1F4181798](Weak, sel_manager_errorOccurred_, v3);
}

void sub_190503E90()
{
  uint64_t v0 = sub_1902D6BD0();
  uint64_t v1 = *(void *)(v0 + 24);
  float v2 = *(std::__shared_weak_count **)(v0 + 32);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1902C47F8(v1, "ForceAnomalyDetectionAvailable", (BOOL *)&byte_1EB3BF328);
  if (v2)
  {
    sub_1902D8B58(v2);
  }
}

void sub_190503F08(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1902D8B58(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1905040F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_190504148(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v163 = *MEMORY[0x1E4F143B8];
  float v2 = *a2;
  if (*a2)
  {
    long long v4 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v5 = objc_opt_class();
    uint64_t v7 = (NSSet *)objc_msgSend_setWithObject_(v4, v6, v5);
    uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(v2, v7);
    if (DictionaryOfClasses)
    {
      id v10 = (id)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMAnomalyDetectorEvent");
      if (qword_1E929D8E8 != -1) {
        dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
      }
      unint64_t v11 = qword_1E929D8F0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = objc_msgSend_identifier(v10, v12, v13);
        objc_msgSend_absoluteTimestamp(v10, v15, v16);
        uint64_t v18 = v17;
        objc_msgSend_updateTimestamp(v10, v19, v20);
        *(_DWORD *)int buf = 68290819;
        __int16 v147 = 2082;
        int v146 = 0;
        double v148 = "";
        __int16 v149 = 2050;
        uint64_t v150 = v14;
        __int16 v151 = 2049;
        uint64_t v152 = v18;
        __int16 v153 = 2049;
        uint64_t v154 = v29;
        __int16 v155 = 2049;
        uint64_t v156 = objc_msgSend_state(v10, v21, v22);
        __int16 v157 = 2049;
        uint64_t v158 = objc_msgSend_response(v10, v23, v24);
        __int16 v159 = 2049;
        uint64_t v160 = objc_msgSend_resolution(v10, v25, v26);
        __int16 v161 = 2049;
        uint64_t v162 = objc_msgSend_sosState(v10, v27, v28);
        _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CMAnomalyManager received event notification\", \"identifier\":%{public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\":\"%{private}f\", \"state\":%{private}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \"sosState\":%{private}ld}", buf, 0x58u);
      }
      uint64_t v30 = objc_msgSend_identifier(v10, v12, v13);
      if (v30 == objc_msgSend_identifier(*(void **)(*(void *)(a1 + 32) + 40), v31, v32)
        && objc_msgSend_state(*(void **)(*(void *)(a1 + 32) + 40), v33, v34) == 2
        && objc_msgSend_state(v10, v33, v34) == 1)
      {
        if (qword_1E929D8E8 != -1) {
          dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
        }
        unsigned int v35 = qword_1E929D8F0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_FAULT))
        {
          uint64_t v38 = objc_msgSend_identifier(v10, v36, v37);
          *(_DWORD *)int buf = 68289282;
          int v146 = 0;
          __int16 v147 = 2082;
          double v148 = "";
          __int16 v149 = 2050;
          uint64_t v150 = v38;
          _os_log_impl(&dword_1902AF000, v35, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received same event identifier but state went from recovered to detected\", \"identifier\":%{public}llu}", buf, 0x1Cu);
          if (qword_1E929D8E8 != -1) {
            dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
          }
        }
        uint64_t v39 = qword_1E929D8F0;
        if (!os_signpost_enabled((os_log_t)qword_1E929D8F0)) {
          goto LABEL_46;
        }
        uint64_t v42 = objc_msgSend_identifier(v10, v40, v41);
        *(_DWORD *)int buf = 68289282;
        int v146 = 0;
        __int16 v147 = 2082;
        double v148 = "";
        __int16 v149 = 2050;
        uint64_t v150 = v42;
        uint64_t v43 = "Received same event identifier but state went from recovered to detected";
        float v44 = "{\"msg%{public}.0s\":\"Received same event identifier but state went from recovered to detected\", \"ident"
              "ifier\":%{public}llu}";
      }
      else
      {
        if (objc_msgSend_state(v10, v33, v34) >= 1 && objc_msgSend_state(v10, v45, v46) < 4)
        {
          if (objc_msgSend_identifier(v10, v47, v48))
          {
            uint64_t v58 = objc_msgSend_identifier(v10, v56, v57);
            if (v58 == objc_msgSend_identifier(*(void **)(*(void *)(a1 + 32) + 40), v59, v60)
              && (uint64_t v63 = objc_msgSend_state(v10, v61, v62),
                  v63 == objc_msgSend_state(*(void **)(*(void *)(a1 + 32) + 40), v64, v65)))
            {
              if (qword_1E929D8E8 != -1) {
                dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
              }
              uint64_t v66 = qword_1E929D8F0;
              if (!os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_46;
              }
              uint64_t v69 = objc_msgSend_identifier(v10, v67, v68);
              objc_msgSend_absoluteTimestamp(v10, v70, v71);
              uint64_t v73 = v72;
              objc_msgSend_updateTimestamp(v10, v74, v75);
              uint64_t v77 = v76;
              uint64_t v80 = objc_msgSend_state(v10, v78, v79);
              uint64_t v83 = objc_msgSend_response(v10, v81, v82);
              uint64_t v86 = objc_msgSend_resolution(v10, v84, v85);
              uint64_t v89 = objc_msgSend_sosState(v10, v87, v88);
              *(_DWORD *)int buf = 68290819;
              __int16 v147 = 2082;
              int v146 = 0;
              double v148 = "";
              __int16 v149 = 2050;
              uint64_t v150 = v69;
              __int16 v151 = 2049;
              uint64_t v152 = v73;
              __int16 v153 = 2049;
              uint64_t v154 = v77;
              __int16 v155 = 2049;
              uint64_t v156 = v80;
              __int16 v157 = 2049;
              uint64_t v158 = v83;
              __int16 v159 = 2049;
              uint64_t v160 = v86;
              __int16 v161 = 2049;
              uint64_t v162 = v89;
              float v90 = "{\"msg%{public}.0s\":\"CMAnomalyManager dispatch avoided, this event state has already been dispatch"
                    "ed before\", \"identifier\":%{public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\""
                    ":\"%{private}f\", \"state\":%{private}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \""
                    "sosState\":%{private}ld}";
            }
            else
            {
              if (!objc_msgSend_resolution(v10, v61, v62))
              {
                uint64_t v140 = *(void *)(a1 + 32);
                uint64_t v141 = *(NSObject **)(v140 + 16);
                v144[0] = MEMORY[0x1E4F143A8];
                v144[1] = 3221225472;
                v144[2] = sub_1905049D4;
                v144[3] = &unk_1E568D190;
                v144[4] = v140;
                v144[5] = v10;
                dispatch_async(v141, v144);
                goto LABEL_46;
              }
              if (qword_1E929D8E8 != -1) {
                dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
              }
              uint64_t v66 = qword_1E929D8F0;
              if (!os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_46;
              }
              uint64_t v93 = objc_msgSend_identifier(v10, v91, v92);
              objc_msgSend_absoluteTimestamp(v10, v94, v95);
              uint64_t v97 = v96;
              objc_msgSend_updateTimestamp(v10, v98, v99);
              uint64_t v101 = v100;
              uint64_t v104 = objc_msgSend_state(v10, v102, v103);
              uint64_t v107 = objc_msgSend_response(v10, v105, v106);
              uint64_t v110 = objc_msgSend_resolution(v10, v108, v109);
              uint64_t v113 = objc_msgSend_sosState(v10, v111, v112);
              *(_DWORD *)int buf = 68290819;
              __int16 v147 = 2082;
              int v146 = 0;
              double v148 = "";
              __int16 v149 = 2050;
              uint64_t v150 = v93;
              __int16 v151 = 2049;
              uint64_t v152 = v97;
              __int16 v153 = 2049;
              uint64_t v154 = v101;
              __int16 v155 = 2049;
              uint64_t v156 = v104;
              __int16 v157 = 2049;
              uint64_t v158 = v107;
              __int16 v159 = 2049;
              uint64_t v160 = v110;
              __int16 v161 = 2049;
              uint64_t v162 = v113;
              float v90 = "{\"msg%{public}.0s\":\"CMAnomalyManager dispatch avoided, this event state is already resolved\", \""
                    "identifier\":%{public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\":\"%{private}f"
                    "\", \"state\":%{private}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \"sosState\":%{private}ld}";
            }
            double v114 = v66;
            os_log_type_t v115 = OS_LOG_TYPE_DEFAULT;
          }
          else
          {
            if (qword_1E929D8E8 != -1) {
              dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
            }
            uint64_t v116 = qword_1E929D8F0;
            if (!os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_46;
            }
            uint64_t v119 = objc_msgSend_identifier(v10, v117, v118);
            objc_msgSend_absoluteTimestamp(v10, v120, v121);
            uint64_t v123 = v122;
            objc_msgSend_updateTimestamp(v10, v124, v125);
            uint64_t v127 = v126;
            uint64_t v130 = objc_msgSend_state(v10, v128, v129);
            uint64_t v133 = objc_msgSend_response(v10, v131, v132);
            uint64_t v136 = objc_msgSend_resolution(v10, v134, v135);
            uint64_t v139 = objc_msgSend_sosState(v10, v137, v138);
            *(_DWORD *)int buf = 68290819;
            __int16 v147 = 2082;
            int v146 = 0;
            double v148 = "";
            __int16 v149 = 2050;
            uint64_t v150 = v119;
            __int16 v151 = 2049;
            uint64_t v152 = v123;
            __int16 v153 = 2049;
            uint64_t v154 = v127;
            __int16 v155 = 2049;
            uint64_t v156 = v130;
            __int16 v157 = 2049;
            uint64_t v158 = v133;
            __int16 v159 = 2049;
            uint64_t v160 = v136;
            __int16 v161 = 2049;
            uint64_t v162 = v139;
            float v90 = "{\"msg%{public}.0s\":\"CMAnomalyManager dispatch avoided, this event is non event\", \"identifier\":%{"
                  "public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\":\"%{private}f\", \"state\":%{p"
                  "rivate}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \"sosState\":%{private}ld}";
            double v114 = v116;
            os_log_type_t v115 = OS_LOG_TYPE_DEBUG;
          }
          _os_log_impl(&dword_1902AF000, v114, v115, v90, buf, 0x58u);
LABEL_46:

          *(void *)(*(void *)(a1 + 32) + 32) = objc_msgSend_copy(v10, v142, v143);
          return;
        }
        if (qword_1E929D8E8 != -1) {
          dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
        }
        int v49 = qword_1E929D8F0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_FAULT))
        {
          uint64_t v52 = objc_msgSend_state(v10, v50, v51);
          *(_DWORD *)int buf = 68289282;
          int v146 = 0;
          __int16 v147 = 2082;
          double v148 = "";
          __int16 v149 = 2050;
          uint64_t v150 = v52;
          _os_log_impl(&dword_1902AF000, v49, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Invalid event state\", \"state\":%{public}ld}", buf, 0x1Cu);
          if (qword_1E929D8E8 != -1) {
            dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
          }
        }
        uint64_t v39 = qword_1E929D8F0;
        if (!os_signpost_enabled((os_log_t)qword_1E929D8F0)) {
          goto LABEL_46;
        }
        uint64_t v55 = objc_msgSend_state(v10, v53, v54);
        *(_DWORD *)int buf = 68289282;
        int v146 = 0;
        __int16 v147 = 2082;
        double v148 = "";
        __int16 v149 = 2050;
        uint64_t v150 = v55;
        uint64_t v43 = "Invalid event state";
        float v44 = "{\"msg%{public}.0s\":\"Invalid event state\", \"state\":%{public}ld}";
      }
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v39, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, v43, v44, buf, 0x1Cu);
      goto LABEL_46;
    }
  }
}

void sub_1905049D4(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v202 = *MEMORY[0x1E4F143B8];
  if (objc_msgSend_delegate(*(void **)(a1 + 32), a2, a3))
  {
    objc_msgSend_delegate(*(void **)(a1 + 32), v4, v5);
    if (objc_opt_respondsToSelector())
    {
      if (qword_1E929D8E8 != -1) {
        dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
      }
      int v8 = qword_1E929D8F0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = objc_msgSend_identifier(*(void **)(a1 + 40), v9, v10);
        objc_msgSend_absoluteTimestamp(*(void **)(a1 + 40), v12, v13);
        uint64_t v15 = v14;
        objc_msgSend_updateTimestamp(*(void **)(a1 + 40), v16, v17);
        uint64_t v19 = v18;
        uint64_t v22 = objc_msgSend_state(*(void **)(a1 + 40), v20, v21);
        uint64_t v25 = objc_msgSend_response(*(void **)(a1 + 40), v23, v24);
        uint64_t v28 = objc_msgSend_resolution(*(void **)(a1 + 40), v26, v27);
        uint64_t v31 = objc_msgSend_sosState(*(void **)(a1 + 40), v29, v30);
        int v184 = 68290819;
        __int16 v186 = 2082;
        int v185 = 0;
        double v187 = "";
        __int16 v188 = 2050;
        uint64_t v189 = v11;
        __int16 v190 = 2049;
        uint64_t v191 = v15;
        __int16 v192 = 2049;
        uint64_t v193 = v19;
        __int16 v194 = 2049;
        uint64_t v195 = v22;
        __int16 v196 = 2049;
        uint64_t v197 = v25;
        __int16 v198 = 2049;
        uint64_t v199 = v28;
        __int16 v200 = 2049;
        uint64_t v201 = v31;
        _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CMAnomalyManager dispatches event through onAnomalyEvent\", \"identifier\":%{public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\":\"%{private}f\", \"state\":%{private}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \"sosState\":%{private}ld}", (uint8_t *)&v184, 0x58u);
      }

      *(void *)(*(void *)(a1 + 32) + 40) = objc_msgSend_copy(*(void **)(a1 + 40), v32, v33);
      objc_msgSend_setAcknowledgement_(*(void **)(*(void *)(a1 + 32) + 40), v34, 1);
      objc_msgSend__sendRegistrationForAnomalyEvent_(*(void **)(a1 + 32), v35, *(void *)(*(void *)(a1 + 32) + 40));
      uint64_t v38 = objc_msgSend_delegate(*(void **)(a1 + 32), v36, v37);
      objc_msgSend_anomalyManager_onAnomalyEvent_(v38, v39, *(void *)(a1 + 32), *(void *)(a1 + 40));
      return;
    }
    objc_msgSend_delegate(*(void **)(a1 + 32), v6, v7);
    if (objc_opt_respondsToSelector())
    {
      if (qword_1E929D8E8 != -1) {
        dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
      }
      float v90 = qword_1E929D8F0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_FAULT))
      {
        uint64_t v93 = objc_msgSend_identifier(*(void **)(a1 + 40), v91, v92);
        objc_msgSend_absoluteTimestamp(*(void **)(a1 + 40), v94, v95);
        uint64_t v97 = v96;
        objc_msgSend_updateTimestamp(*(void **)(a1 + 40), v98, v99);
        uint64_t v101 = v100;
        uint64_t v104 = objc_msgSend_state(*(void **)(a1 + 40), v102, v103);
        uint64_t v107 = objc_msgSend_response(*(void **)(a1 + 40), v105, v106);
        uint64_t v110 = objc_msgSend_resolution(*(void **)(a1 + 40), v108, v109);
        uint64_t v113 = objc_msgSend_sosState(*(void **)(a1 + 40), v111, v112);
        int v184 = 68290819;
        __int16 v186 = 2082;
        int v185 = 0;
        double v187 = "";
        __int16 v188 = 2050;
        uint64_t v189 = v93;
        __int16 v190 = 2049;
        uint64_t v191 = v97;
        __int16 v192 = 2049;
        uint64_t v193 = v101;
        __int16 v194 = 2049;
        uint64_t v195 = v104;
        __int16 v196 = 2049;
        uint64_t v197 = v107;
        __int16 v198 = 2049;
        uint64_t v199 = v110;
        __int16 v200 = 2049;
        uint64_t v201 = v113;
        _os_log_impl(&dword_1902AF000, v90, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CMAnomalyManager did not dispatch event through didDetectAnomalyEvent, function was deprecated\", \"identifier\":%{public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\":\"%{private}f\", \"state\":%{private}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \"sosState\":%{private}ld}", (uint8_t *)&v184, 0x58u);
        if (qword_1E929D8E8 != -1) {
          dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
        }
      }
      int v64 = qword_1E929D8F0;
      if (os_signpost_enabled((os_log_t)qword_1E929D8F0))
      {
        uint64_t v116 = objc_msgSend_identifier(*(void **)(a1 + 40), v114, v115);
        objc_msgSend_absoluteTimestamp(*(void **)(a1 + 40), v117, v118);
        uint64_t v120 = v119;
        objc_msgSend_updateTimestamp(*(void **)(a1 + 40), v121, v122);
        uint64_t v124 = v123;
        uint64_t v127 = objc_msgSend_state(*(void **)(a1 + 40), v125, v126);
        uint64_t v130 = objc_msgSend_response(*(void **)(a1 + 40), v128, v129);
        uint64_t v133 = objc_msgSend_resolution(*(void **)(a1 + 40), v131, v132);
        uint64_t v136 = objc_msgSend_sosState(*(void **)(a1 + 40), v134, v135);
        int v184 = 68290819;
        __int16 v186 = 2082;
        int v185 = 0;
        double v187 = "";
        __int16 v188 = 2050;
        uint64_t v189 = v116;
        __int16 v190 = 2049;
        uint64_t v191 = v120;
        __int16 v192 = 2049;
        uint64_t v193 = v124;
        __int16 v194 = 2049;
        uint64_t v195 = v127;
        __int16 v196 = 2049;
        uint64_t v197 = v130;
        __int16 v198 = 2049;
        uint64_t v199 = v133;
        __int16 v200 = 2049;
        uint64_t v201 = v136;
        uint64_t v88 = "CMAnomalyManager did not dispatch event through didDetectAnomalyEvent, function was deprecated";
        uint64_t v89 = "{\"msg%{public}.0s\":\"CMAnomalyManager did not dispatch event through didDetectAnomalyEvent, function was"
              " deprecated\", \"identifier\":%{public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\":\""
              "%{private}f\", \"state\":%{private}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \"sosState\":%{private}ld}";
        goto LABEL_30;
      }
    }
    else
    {
      if (qword_1E929D8E8 != -1) {
        dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
      }
      double v137 = qword_1E929D8F0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_FAULT))
      {
        uint64_t v140 = objc_msgSend_identifier(*(void **)(a1 + 40), v138, v139);
        objc_msgSend_absoluteTimestamp(*(void **)(a1 + 40), v141, v142);
        uint64_t v144 = v143;
        objc_msgSend_updateTimestamp(*(void **)(a1 + 40), v145, v146);
        uint64_t v148 = v147;
        uint64_t v151 = objc_msgSend_state(*(void **)(a1 + 40), v149, v150);
        uint64_t v154 = objc_msgSend_response(*(void **)(a1 + 40), v152, v153);
        uint64_t v157 = objc_msgSend_resolution(*(void **)(a1 + 40), v155, v156);
        uint64_t v160 = objc_msgSend_sosState(*(void **)(a1 + 40), v158, v159);
        int v184 = 68290819;
        int v185 = 0;
        __int16 v186 = 2082;
        double v187 = "";
        __int16 v188 = 2050;
        uint64_t v189 = v140;
        __int16 v190 = 2049;
        uint64_t v191 = v144;
        __int16 v192 = 2049;
        uint64_t v193 = v148;
        __int16 v194 = 2049;
        uint64_t v195 = v151;
        __int16 v196 = 2049;
        uint64_t v197 = v154;
        __int16 v198 = 2049;
        uint64_t v199 = v157;
        __int16 v200 = 2049;
        uint64_t v201 = v160;
        _os_log_impl(&dword_1902AF000, v137, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CMAnomalyManager did not dispatch event - no suitable selector\", \"identifier\":%{public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\":\"%{private}f\", \"state\":%{private}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \"sosState\":%{private}ld}", (uint8_t *)&v184, 0x58u);
        if (qword_1E929D8E8 != -1) {
          dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
        }
      }
      int v64 = qword_1E929D8F0;
      if (os_signpost_enabled((os_log_t)qword_1E929D8F0))
      {
        uint64_t v163 = objc_msgSend_identifier(*(void **)(a1 + 40), v161, v162);
        objc_msgSend_absoluteTimestamp(*(void **)(a1 + 40), v164, v165);
        uint64_t v167 = v166;
        objc_msgSend_updateTimestamp(*(void **)(a1 + 40), v168, v169);
        uint64_t v171 = v170;
        uint64_t v174 = objc_msgSend_state(*(void **)(a1 + 40), v172, v173);
        uint64_t v177 = objc_msgSend_response(*(void **)(a1 + 40), v175, v176);
        uint64_t v180 = objc_msgSend_resolution(*(void **)(a1 + 40), v178, v179);
        uint64_t v183 = objc_msgSend_sosState(*(void **)(a1 + 40), v181, v182);
        int v184 = 68290819;
        int v185 = 0;
        __int16 v186 = 2082;
        double v187 = "";
        __int16 v188 = 2050;
        uint64_t v189 = v163;
        __int16 v190 = 2049;
        uint64_t v191 = v167;
        __int16 v192 = 2049;
        uint64_t v193 = v171;
        __int16 v194 = 2049;
        uint64_t v195 = v174;
        __int16 v196 = 2049;
        uint64_t v197 = v177;
        __int16 v198 = 2049;
        uint64_t v199 = v180;
        __int16 v200 = 2049;
        uint64_t v201 = v183;
        uint64_t v88 = "CMAnomalyManager did not dispatch event - no suitable selector";
        uint64_t v89 = "{\"msg%{public}.0s\":\"CMAnomalyManager did not dispatch event - no suitable selector\", \"identifier\":%{"
              "public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\":\"%{private}f\", \"state\":%{priva"
              "te}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \"sosState\":%{private}ld}";
        goto LABEL_30;
      }
    }
  }
  else
  {
    if (qword_1E929D8E8 != -1) {
      dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
    }
    int32x2_t v40 = qword_1E929D8F0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_FAULT))
    {
      uint64_t v43 = objc_msgSend_identifier(*(void **)(a1 + 40), v41, v42);
      objc_msgSend_absoluteTimestamp(*(void **)(a1 + 40), v44, v45);
      uint64_t v47 = v46;
      objc_msgSend_updateTimestamp(*(void **)(a1 + 40), v48, v49);
      uint64_t v51 = v50;
      uint64_t v54 = objc_msgSend_state(*(void **)(a1 + 40), v52, v53);
      uint64_t v57 = objc_msgSend_response(*(void **)(a1 + 40), v55, v56);
      uint64_t v60 = objc_msgSend_resolution(*(void **)(a1 + 40), v58, v59);
      uint64_t v63 = objc_msgSend_sosState(*(void **)(a1 + 40), v61, v62);
      int v184 = 68290819;
      __int16 v186 = 2082;
      int v185 = 0;
      double v187 = "";
      __int16 v188 = 2050;
      uint64_t v189 = v43;
      __int16 v190 = 2049;
      uint64_t v191 = v47;
      __int16 v192 = 2049;
      uint64_t v193 = v51;
      __int16 v194 = 2049;
      uint64_t v195 = v54;
      __int16 v196 = 2049;
      uint64_t v197 = v57;
      __int16 v198 = 2049;
      uint64_t v199 = v60;
      __int16 v200 = 2049;
      uint64_t v201 = v63;
      _os_log_impl(&dword_1902AF000, v40, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CMAnomalyManager did not dispatch event - registered delegate was released\", \"identifier\":%{public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\":\"%{private}f\", \"state\":%{private}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \"sosState\":%{private}ld}", (uint8_t *)&v184, 0x58u);
      if (qword_1E929D8E8 != -1) {
        dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
      }
    }
    int v64 = qword_1E929D8F0;
    if (os_signpost_enabled((os_log_t)qword_1E929D8F0))
    {
      uint64_t v67 = objc_msgSend_identifier(*(void **)(a1 + 40), v65, v66);
      objc_msgSend_absoluteTimestamp(*(void **)(a1 + 40), v68, v69);
      uint64_t v71 = v70;
      objc_msgSend_updateTimestamp(*(void **)(a1 + 40), v72, v73);
      uint64_t v75 = v74;
      uint64_t v78 = objc_msgSend_state(*(void **)(a1 + 40), v76, v77);
      uint64_t v81 = objc_msgSend_response(*(void **)(a1 + 40), v79, v80);
      uint64_t v84 = objc_msgSend_resolution(*(void **)(a1 + 40), v82, v83);
      uint64_t v87 = objc_msgSend_sosState(*(void **)(a1 + 40), v85, v86);
      int v184 = 68290819;
      __int16 v186 = 2082;
      int v185 = 0;
      double v187 = "";
      __int16 v188 = 2050;
      uint64_t v189 = v67;
      __int16 v190 = 2049;
      uint64_t v191 = v71;
      __int16 v192 = 2049;
      uint64_t v193 = v75;
      __int16 v194 = 2049;
      uint64_t v195 = v78;
      __int16 v196 = 2049;
      uint64_t v197 = v81;
      __int16 v198 = 2049;
      uint64_t v199 = v84;
      __int16 v200 = 2049;
      uint64_t v201 = v87;
      uint64_t v88 = "CMAnomalyManager did not dispatch event - registered delegate was released";
      uint64_t v89 = "{\"msg%{public}.0s\":\"CMAnomalyManager did not dispatch event - registered delegate was released\", \"ident"
            "ifier\":%{public}llu, \"anomaly timestamp\":\"%{private}f\", \"update timestamp\":\"%{private}f\", \"state\""
            ":%{private}ld, \"response\":%{private}ld, \"resolution\":%{private}ld, \"sosState\":%{private}ld}";
LABEL_30:
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v64, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, v88, v89, (uint8_t *)&v184, 0x58u);
    }
  }
}

void sub_190505248(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v5 = (void *)ExecutablePathFromPid;
    if (qword_1E929D8E8 != -1) {
      dispatch_once(&qword_1E929D8E8, &unk_1EDFD2E20);
    }
    uint64_t v6 = qword_1E929D8F0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8F0, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = objc_msgSend_UTF8String(v5, v7, v8);
      pid_t v10 = getpid();
      uint64_t v11 = *(void *)(a1 + 32);
      v12[0] = 68289795;
      v12[1] = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 2082;
      uint64_t v16 = v9;
      __int16 v17 = 2050;
      uint64_t v18 = v10;
      __int16 v19 = 2049;
      uint64_t v20 = v11;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CMAnomalyManager client connection interrupt\", \"path\":%{public, location:escape_only}s, \"pid\":%{public}llu, \"self\":\"%{private}p\"}", (uint8_t *)v12, 0x30u);
    }
  }
}

void sub_190505458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_190505C6C(uint64_t a1, const char *a2)
{
  _DWORD v12[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 24))
  {
    v11[0] = @"kCLConnectionMessageSubscribeKey";
    uint64_t v4 = objc_msgSend_numberWithBool_(NSNumber, a2, *(unsigned __int8 *)(v2 + 48));
    v11[1] = @"CMAnomalyDetectorEvent";
    uint64_t v5 = *(void *)(a1 + 40);
    v12[0] = v4;
    v12[1] = v5;
    uint64_t v10 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v6, (uint64_t)v12, v11, 2);
    sub_1905066B4("kCLConnectionMessageAnomalyEvent", &v10, &v8);
    uint64_t v7 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v7) {
      sub_1902D8B58(v7);
    }
    if (v9) {
      sub_1902D8B58(v9);
    }
  }
}

void sub_190505D78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a13) {
    sub_1902D8B58(a13);
  }
  _Unwind_Resume(exception_object);
}

os_log_t sub_190506684()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Fall");
  qword_1E929D8F0 = (uint64_t)result;
  return result;
}

void *sub_1905066B4@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  os_log_t result = sub_190506718(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_190506704(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_190506718(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_19050678C((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_190506778(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_19050678C(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1905067E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_190506800(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v4 = objc_alloc_init(MEMORY[0x1E4F28CB8]);
  uint64_t v6 = objc_msgSend_stringWithUTF8String_(NSString, v5, a1);
  uint64_t v8 = objc_msgSend_contentsOfDirectoryAtPath_error_(v4, v7, v6, 0);
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v11 = objc_msgSend_reverseObjectEnumerator(v8, v9, v10, 0);
  uint64_t v13 = objc_msgSend_countByEnumeratingWithState_objects_count_(v11, v12, (uint64_t)&v20, v24, 16);
  if (v13)
  {
    uint64_t v16 = v13;
    uint64_t v17 = *(void *)v21;
LABEL_3:
    uint64_t v18 = 0;
    while (1)
    {
      if (*(void *)v21 != v17) {
        objc_enumerationMutation(v11);
      }
      uint64_t v19 = objc_msgSend_UTF8String(*(void **)(*((void *)&v20 + 1) + 8 * v18), v14, v15);
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, v19)) {
        break;
      }
      if (v16 == ++v18)
      {
        uint64_t v16 = objc_msgSend_countByEnumeratingWithState_objects_count_(v11, v14, (uint64_t)&v20, v24, 16);
        if (v16) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
}

uint64_t sub_190506940(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onAudioAccessoryAccelerometer_, a1);
}

uint64_t sub_19050694C(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onAudioAccessoryGyro_, a1);
}

uint64_t sub_190506958(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onAudioAccessoryMagnetometer_, a1);
}

uint64_t sub_190506964(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onAudioAccessoryDeviceMotion_, a1);
}

uint64_t sub_190506970(uint64_t result, uint64_t a2)
{
  if (result) {
    return MEMORY[0x1F4181798](a2, sel_onAudioAccessoryActivity_, result);
  }
  return result;
}

uint64_t sub_190506984(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onAudioAccessoryDeviceMotionConfig_, a1);
}

uint64_t sub_190506990(uint64_t a1, void *a2)
{
  return objc_msgSend_onAudioAccessoryDeviceMotionStatus_(a2, (const char *)a2, a1);
}

uint64_t sub_19050699C(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onAudioAccessoryHeartRate_, a1);
}

uint64_t sub_1905069A8(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4181798](a2, sel_onAudioAccessoryPPG_, a1);
}

void sub_190506BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_190506BD8(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t result = objc_msgSend_initPrivate(*(void **)(a1 + 32), a2, a3);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = result;
  return result;
}

void sub_190506D48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_190506D60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), sel_deallocPrivate, a3);
}

uint64_t sub_1905070A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__setAudioAccessoryAccelerometerUpdateIntervalPrivate_, a3);
}

uint64_t sub_190507148(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__isAudioAccessoryAccelerometerAvailablePrivate, a3);
}

uint64_t sub_190507280(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__startAudioAccessoryAccelerometerUpdatesPrivateToQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_19050730C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__stopAudioAccessoryAccelerometerUpdatesPrivate, a3);
}

void sub_190507508(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_190507674(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__setAudioAccessoryGyroUpdateIntervalPrivate_, a3);
}

uint64_t sub_190507714(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__isAudioAccessoryGyroAvailablePrivate, a3);
}

uint64_t sub_19050784C(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__startAudioAccessoryGyroUpdatesPrivateToQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_1905078D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__stopAudioAccessoryGyroUpdatesPrivate, a3);
}

void sub_190507AD4(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_190507C40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__setAudioAccessoryMagnetometerUpdateIntervalPrivate_, a3);
}

uint64_t sub_190507CE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__isAudioAccessoryMagnetometerAvailablePrivate, a3);
}

uint64_t sub_190507E18(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__startAudioAccessoryMagnetometerUpdatesPrivateToQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_190507EA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__stopAudioAccessoryMagnetometerUpdatesPrivate, a3);
}

void sub_1905080A0(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_190508204(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__isAudioAccessoryDeviceMotionAvailablePrivate, a3);
}

uint64_t sub_190508298(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__setAudioAccessoryDeviceMotionUpdateIntervalPrivate_, a3);
}

void sub_19050834C()
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  BOOL v8 = 0;
  uint64_t v0 = sub_1902D6BD0();
  uint64_t v1 = *(void *)(v0 + 24);
  uint64_t v2 = *(std::__shared_weak_count **)(v0 + 32);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v3 = sub_1902C47F8(v1, "CMHeadphoneMotionManagerEnable50HzUpdateInterval", &v8);
  if (v8) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v2) {
    sub_1902D8B58(v2);
  }
  if (v4)
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1DE0);
    }
    char v5 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_DEFAULT, "Headphone Motion API set to 50Hz for user study.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1DE0);
      }
      LOWORD(v9) = 0;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMAudioAccessoryManager _startAudioAccessoryDeviceMotionUpdatesToQueue:lowLatencyMode:withHandler:]_block_invoke", "CoreLocation: %s\n", v6);
LABEL_26:
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1DE0);
    }
    char v7 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 134349056;
      uint64_t v12 = 0x3FA47AE147AE147BLL;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_DEBUG, "Standard DM6 report interval in use: %{public}f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1DE0);
      }
      int v9 = 134349056;
      uint64_t v10 = 0x3FA47AE147AE147BLL;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMAudioAccessoryManager _startAudioAccessoryDeviceMotionUpdatesToQueue:lowLatencyMode:withHandler:]_block_invoke", "CoreLocation: %s\n", v6);
      goto LABEL_26;
    }
  }
  operator new();
}

void sub_1905086F0(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x1000C4021477895);
  _Unwind_Resume(a1);
}

uint64_t sub_1905087AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__stopAudioAccessoryDeviceMotionUpdatesPrivate, a3);
}

uint64_t sub_190508844(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__startAudioAccessoryDeviceMotionStatusUpdatesPrivate_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_1905088D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__stopAudioAccessoryDeviceMotionStatusUpdatesPrivate, a3);
}

void sub_190508B14(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void sub_190508D2C(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_190508E64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__isAudioAccessoryActivityAvailablePrivate, a3);
}

uint64_t sub_190508EF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__setAudioAccessoryActivityUpdateIntervalPrivate_, a3);
}

uint64_t sub_190508FA4(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__startAudioAccessoryActivityUpdatesPrivate_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_190509030(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__stopAudioAccessoryActivityUpdatesPrivate, a3);
}

void sub_190509200(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_190509340(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__setAudioAccessoryHeartRateUpdateIntervalPrivate_, a3);
}

uint64_t sub_1905093E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__isAudioAccessoryHeartRateAvailablePrivate, a3);
}

uint64_t sub_190509478(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__startAudioAccessoryHeartRateUpdatesPrivateToQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_190509504(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__stopAudioAccessoryHeartRateUpdatesPrivate, a3);
}

void sub_190509700(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_190509864(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__isAudioAccessoryPPGAvailablePrivate, a3);
}

uint64_t sub_1905098FC(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__startAudioAccessoryPPGUpdatesPrivateToQueue_withHandler_, *(void *)(a1 + 40));
}

uint64_t sub_190509988(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__stopAudioAccessoryPPGUpdatesPrivate, a3);
}

void sub_190509AE0(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_190509E64(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_19050A124(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_19050A3E0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_19050A894(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD43A0);
    }
    char v7 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)int buf = 134218240;
      unint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD43A0);
      }
      int v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "const T &CMQueue<CMResampleAccessoryDeviceMotion::InputData>::operator[](const size_t) const [T = CMResampleAccessoryDeviceMotion::InputData]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0;
  }
  return (uint64_t)&a1[32 * (v4 - v5) + 4];
}

uint64_t sub_19050AA90(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_19050AB7C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), 0);
}

uint64_t sub_19050AEF4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_19050AF0C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

uint64_t sub_19050AFEC(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = objc_msgSend_numberWithUnsignedInt_(NSNumber, a2, *(unsigned int *)(*(void *)(a1 + 40) + 8));
  LODWORD(v5) = *(_DWORD *)(*(void *)(a1 + 40) + 12);
  uint64_t v8 = objc_msgSend_numberWithFloat_(NSNumber, v6, v7, v5);
  int v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v3 + 16);

  return v9(v3, v4, v8);
}

uint64_t sub_19050B12C(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = objc_msgSend_numberWithUnsignedChar_(NSNumber, a2, *(unsigned __int8 *)(*(void *)(a1 + 40) + 16));
  uint64_t v6 = objc_msgSend_numberWithUnsignedLongLong_(NSNumber, v5, *(void *)(*(void *)(a1 + 40) + 8));
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v3 + 16);

  return v7(v3, v4, v6);
}

os_log_t sub_19050B1D0()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1EB3BE830 = (uint64_t)result;
  return result;
}

void sub_19050B204(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19050B23C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_19050B24C(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19050B284(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_19050B294(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19050B2CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_19050B2DC(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19050B314(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_19050B324(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19050B35C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_19050B36C(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19050B3A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void sub_19050B3B0(double *a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (*a1 >= 0.0)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E00);
    }
    double v5 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136315138;
      uint64_t v12 = objc_msgSend_UTF8String(a2, v6, v7);
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_ERROR, "[CMMediaSessionAnalyticsTracker] Metric %s: Calling start when we've already started.", buf, 0xCu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E00);
      }
      objc_msgSend_UTF8String(a2, v8, v9);
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMCoreAnalyticsUtil::AccumulatedEvent::start(const NSString *)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  else
  {
    uint64_t v3 = mach_continuous_time();
    *a1 = sub_1902D8D34(v3);
  }
}

void sub_19050B590(double *a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (*a1 <= 0.0)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E00);
    }
    double v5 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136315138;
      uint64_t v12 = objc_msgSend_UTF8String(a2, v6, v7);
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_ERROR, "[CMMediaSessionAnalyticsTracker] Metric %s: Calling stop when we haven't started.", buf, 0xCu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E00);
      }
      objc_msgSend_UTF8String(a2, v8, v9);
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMCoreAnalyticsUtil::AccumulatedEvent::stop(const NSString *)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
  else
  {
    uint64_t v3 = mach_continuous_time();
    a1[1] = a1[1] + sub_1902D8D34(v3) - *a1;
    *a1 = -1.0;
  }
}

os_log_t sub_19050B784()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

void sub_19050B7FC(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (*a2)
  {
    CFDictionaryRef Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
    if (objc_msgSend_objectForKeyedSubscript_(Dictionary, v3, @"CMErrorMessage"))
    {
      double v5 = objc_msgSend_objectForKeyedSubscript_(Dictionary, v4, @"CMErrorMessage");
      uint64_t v6 = (void *)MEMORY[0x1E4F28C58];
      uint64_t v9 = objc_msgSend_integerValue(v5, v7, v8);
      uint64_t v11 = objc_msgSend_errorWithDomain_code_userInfo_(v6, v10, @"CMErrorDomain", v9, 0);
      if (qword_1E929D6E8 != -1) {
        dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
      }
      uint64_t v12 = qword_1E929D6E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D6E0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 138543362;
        uint64_t v16 = v11;
        _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_ERROR, "Failed with error %{public}@", buf, 0xCu);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D6E8 == -1)
        {
LABEL_17:
          uint64_t v14 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "-[CMVO2MaxRetrocomputeManager connect]_block_invoke", "CoreLocation: %s\n", v14);
          if (v14 != (char *)buf) {
            free(v14);
          }
          return;
        }
LABEL_19:
        dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
        goto LABEL_17;
      }
    }
  }
  else
  {
    if (qword_1E929D6E8 != -1) {
      dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
    }
    uint64_t v13 = qword_1E929D6E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_ERROR, "Failed with unknown internal error.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6E8 == -1) {
        goto LABEL_17;
      }
      goto LABEL_19;
    }
  }
}

void sub_19050BADC(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id Weak = objc_loadWeak((id *)(a1 + 40));
  uint64_t v3 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v4, v3);
  if (ExecutablePathFromPid)
  {
    uint64_t v8 = (void *)ExecutablePathFromPid;
    if (qword_1E929D6E8 != -1) {
      dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
    }
    uint64_t v9 = qword_1E929D6E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6E0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)int buf = 136446722;
      uint64_t v17 = objc_msgSend_UTF8String(v8, v10, v11);
      __int16 v18 = 1026;
      pid_t v19 = getpid();
      __int16 v20 = 2050;
      id v21 = Weak;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_INFO, "Client connection interrupt, %{public}s, %{public}d, %{public}p", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6E8 != -1) {
        dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
      }
      objc_msgSend_UTF8String(v8, v13, v14);
      getpid();
      uint64_t v15 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMVO2MaxRetrocomputeManager connect]_block_invoke", "CoreLocation: %s\n", v15);
      if (v15 != (char *)buf) {
        free(v15);
      }
    }
  }
  if (*(unsigned char *)(*(void *)(a1 + 32) + 24)) {
    BOOL v12 = Weak == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12) {
    objc_msgSend_startRetrocomputeStatusUpdates(Weak, v6, v7);
  }
}

void sub_19050C098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19050C0DC(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v7 = (NSSet *)objc_msgSend_setWithObjects_(v4, v6, v5, 0);
  if (*a2 && (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7)) != 0)
  {
    uint64_t v10 = DictionaryOfClasses;
    uint64_t v11 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage");
    if (v11)
    {
      uint64_t v13 = v11;
      id v14 = v11;
      uint64_t v15 = v27;
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 3221225472;
      float32x2_t v27[2] = sub_19050C5F4;
      v27[3] = &unk_1E568E6B8;
      float v27[4] = v13;
      long long v28 = *(_OWORD *)(a1 + 32);
    }
    else
    {
      uint64_t v17 = objc_msgSend_objectForKeyedSubscript_(v10, v12, @"CMVO2MaxRetrocomputeRecord");
      if (v17)
      {
        __int16 v18 = v17;
        id v19 = v17;
        uint64_t v15 = v24;
        v24[0] = MEMORY[0x1E4F143A8];
        v24[1] = 3221225472;
        v24[2] = sub_19050C890;
        v24[3] = &unk_1E568D320;
        uint64_t v20 = *(void *)(a1 + 32);
        v24[4] = v18;
        void v24[5] = v20;
      }
      else
      {
        if (qword_1E929D6E8 != -1) {
          dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
        }
        id v21 = qword_1E929D6E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D6E0, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_ERROR, "Error in retrocomputeStatusWithHandler: Unable to parse query response", buf, 2u);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D6E8 != -1) {
            dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
          }
          __int16 v31 = 0;
          long long v23 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "-[CMVO2MaxRetrocomputeManager retrocomputeStatusWithHandler:]_block_invoke", "CoreLocation: %s\n", v23);
          if (v23 != (char *)buf) {
            free(v23);
          }
        }
        uint64_t v15 = v25;
        v25[0] = MEMORY[0x1E4F143A8];
        v25[1] = 3221225472;
        void v25[2] = sub_19050C808;
        _OWORD v25[3] = &unk_1E568E690;
        long long v26 = *(_OWORD *)(a1 + 32);
      }
    }
  }
  else
  {
    if (qword_1E929D6E8 != -1) {
      dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
    }
    uint64_t v16 = qword_1E929D6E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_ERROR, "Response invalid for retrocomputeStatusWithHandler. Internal error occured.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6E8 != -1) {
        dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
      }
      __int16 v31 = 0;
      uint64_t v22 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMVO2MaxRetrocomputeManager retrocomputeStatusWithHandler:]_block_invoke", "CoreLocation: %s\n", v22);
      if (v22 != (char *)buf) {
        free(v22);
      }
    }
    uint64_t v15 = block;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_19050C56C;
    block[3] = &unk_1E568E690;
    long long v30 = *(_OWORD *)(a1 + 32);
  }
  dispatch_async(MEMORY[0x1E4F14428], v15);
}

void sub_19050C56C(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v5 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  (*(void (**)(uint64_t, uint64_t, void, void, uint64_t))(v3 + 16))(v3, v4, 0, 0, v5);
  uint64_t v6 = *(void **)(a1 + 32);
}

void sub_19050C5F4(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F28C58];
  int v5 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v4, v6, @"CMErrorDomain", v5, 0);
  if (qword_1E929D6E8 != -1) {
    dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
  }
  uint64_t v8 = qword_1E929D6E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6E0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 138543362;
    uint64_t v11 = v7;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_ERROR, "Received error for retrocomputeStatusWithHandler: %{public}@", buf, 0xCu);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6E8 != -1) {
      dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
    }
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMVO2MaxRetrocomputeManager retrocomputeStatusWithHandler:]_block_invoke", "CoreLocation: %s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_19050C808(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v5 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  (*(void (**)(uint64_t, uint64_t, void, void, uint64_t))(v3 + 16))(v3, v4, 0, 0, v5);
  uint64_t v6 = *(void **)(a1 + 32);
}

void sub_19050C890(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = objc_msgSend_status(*(void **)(a1 + 32), a2, a3);
  uint64_t started = objc_msgSend_startDate(*(void **)(a1 + 32), v6, v7);
  uint64_t v11 = objc_msgSend_endDate(*(void **)(a1 + 32), v9, v10);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(v4 + 16))(v4, v5, started, v11, 0);

  uint64_t v12 = *(void **)(a1 + 40);
}

void sub_19050C914(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  (*(void (**)(uint64_t, void, uint64_t))(v3 + 16))(v3, 0, v4);
  uint64_t v5 = *(void **)(a1 + 32);
}

void sub_19050C984(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F28C58];
  int v5 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v4, v6, @"CMErrorDomain", v5, 0);
  if (qword_1E929D6E8 != -1) {
    dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
  }
  uint64_t v8 = qword_1E929D6E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6E0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 138543362;
    uint64_t v11 = v7;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_ERROR, "Received error for retrocomputeStateWithHandler: %{public}@", buf, 0xCu);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6E8 != -1) {
      dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
    }
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMVO2MaxRetrocomputeManager retrocomputeStateWithHandler:]_block_invoke", "CoreLocation: %s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_19050CB8C(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  (*(void (**)(uint64_t, void, uint64_t))(v3 + 16))(v3, 0, v4);
  int v5 = *(void **)(a1 + 32);
}

void sub_19050CE8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a18) {
    sub_1902D8B58(a18);
  }
  if (a22) {
    sub_1902D8B58(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_19050CEB8(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*a2)
  {
    CFDictionaryRef Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
    if (!objc_msgSend_objectForKeyedSubscript_(Dictionary, v4, @"CMErrorMessage"))
    {
      uint64_t v12 = 0;
      goto LABEL_22;
    }
    uint64_t v6 = objc_msgSend_objectForKeyedSubscript_(Dictionary, v5, @"CMErrorMessage");
    uint64_t v7 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v10 = objc_msgSend_integerValue(v6, v8, v9);
    uint64_t v12 = objc_msgSend_errorWithDomain_code_userInfo_(v7, v11, @"CMErrorDomain", v10, 0);
    if (qword_1E929D6E8 != -1) {
      dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
    }
    uint64_t v13 = qword_1E929D6E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6E0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 138543362;
      uint64_t v22 = v12;
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_ERROR, "Received error for triggerVO2MaxRetrocompute: %{public}@", buf, 0xCu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6E8 != -1) {
        dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
      }
      int v19 = 138543362;
      uint64_t v20 = v12;
LABEL_19:
      uint64_t v15 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMVO2MaxRetrocomputeManager triggerRetrocomputeWithHandler:]_block_invoke", "CoreLocation: %s\n", v15);
      if (v15 != (char *)buf) {
        free(v15);
      }
    }
  }
  else
  {
    uint64_t v12 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], (const char *)a2, @"CMErrorDomain", 103, 0);
    if (qword_1E929D6E8 != -1) {
      dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
    }
    id v14 = qword_1E929D6E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_ERROR, "Response invalid for triggerVO2MaxRetrocompute.  Internal error occured.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D6E8 != -1) {
        dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
      }
      LOWORD(v19) = 0;
      goto LABEL_19;
    }
  }
LABEL_22:
  id v16 = v12;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_19050D224;
  block[3] = &unk_1E568D320;
  uint64_t v17 = *(void *)(a1 + 32);
  void block[4] = v12;
  void block[5] = v17;
  dispatch_async(MEMORY[0x1E4F14428], block);
}

void sub_19050D224(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x192FCD2F0]();
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_19050D5A8(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(a1 + 32) + 8))
  {
    sub_1902C3F54(&__p, "kCLConnectionMessageVO2MaxRetrocomputeStatusUpdate");
    CLConnectionClient::setHandlerForMessage();
    if (v11 < 0) {
      operator delete(__p);
    }
    if (*(unsigned char *)(*(void *)(a1 + 32) + 24))
    {
      uint64_t v7 = @"kCLConnectionMessageSubscribeKey";
      uint64_t v8 = MEMORY[0x1E4F1CC28];
      uint64_t v6 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v2, (uint64_t)&v8, &v7, 1);
      sub_1902DD634("kCLConnectionMessageVO2MaxRetrocomputeStatusUpdate", &v6, &__p);
      int v5 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      CLConnectionClient::sendMessage();
      if (v5) {
        sub_1902D8B58(v5);
      }
      *(unsigned char *)(*(void *)(a1 + 32) + 24) = 0;
      if (v10) {
        sub_1902D8B58(v10);
      }
    }
    else
    {
      if (qword_1E929D6E8 != -1) {
        dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
      }
      uint64_t v3 = qword_1E929D6E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D6E0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p) = 0;
        _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEFAULT, "Error stopping retrocompute status updates, no active clients", (uint8_t *)&__p, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(&__p, 0x65CuLL);
        if (qword_1E929D6E8 != -1) {
          dispatch_once(&qword_1E929D6E8, &unk_1EDFD3E40);
        }
        LOWORD(v6) = 0;
        uint64_t v4 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "-[CMVO2MaxRetrocomputeManager stopRetrocomputeStatusUpdates]_block_invoke", "CoreLocation: %s\n", v4);
        if (v4 != (char *)&__p) {
          free(v4);
        }
      }
    }
  }
}

void sub_19050D818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, std::__shared_weak_count *a18, int a19, __int16 a20,char a21,char a22)
{
  if (a12) {
    sub_1902D8B58(a12);
  }
  if (a18) {
    sub_1902D8B58(a18);
  }
  _Unwind_Resume(exception_object);
}

os_log_t sub_19050D86C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "VO2Max");
  qword_1E929D6E0 = (uint64_t)result;
  return result;
}

void sub_19050D9CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_19050DA08(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v7 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v5, 0);
  if (*a2
    && (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7)) != 0
    && (uint64_t v10 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage")) != 0)
  {
    int v13 = objc_msgSend_intValue(v10, v11, v12);
  }
  else
  {
    int v13 = 103;
  }
  if (qword_1E929D928 != -1) {
    dispatch_once(&qword_1E929D928, &unk_1EDFD3C60);
  }
  id v14 = qword_1E929D930;
  if (os_log_type_enabled((os_log_t)qword_1E929D930, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)int buf = 67240192;
    int v17 = v13;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "Failed with code %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D928 != -1) {
      dispatch_once(&qword_1E929D928, &unk_1EDFD3C60);
    }
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMHealthTrackerInternal init]_block_invoke", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
}

void sub_19050DC20(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v5 = ExecutablePathFromPid;
    if (qword_1E929D928 != -1) {
      dispatch_once(&qword_1E929D928, &unk_1EDFD3C60);
    }
    uint64_t v6 = qword_1E929D930;
    if (os_log_type_enabled((os_log_t)qword_1E929D930, OS_LOG_TYPE_DEFAULT))
    {
      pid_t v7 = getpid();
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)int buf = 138412802;
      uint64_t v11 = v5;
      __int16 v12 = 1024;
      pid_t v13 = v7;
      __int16 v14 = 2048;
      uint64_t v15 = v8;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "Client connection interrupt, %@, %d, %p", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D928 != -1) {
        dispatch_once(&qword_1E929D928, &unk_1EDFD3C60);
      }
      getpid();
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMHealthTrackerInternal init]_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
}

void sub_19050DF48(uint64_t a1)
{
  v19[1] = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(a1 + 32) + 8) && *(void *)(a1 + 56))
  {
    uint64_t v2 = [CMMotionTimeRange alloc];
    objc_msgSend_timeIntervalSinceReferenceDate(*(void **)(a1 + 40), v3, v4);
    double v6 = v5;
    objc_msgSend_timeIntervalSinceReferenceDate(*(void **)(a1 + 48), v7, v8);
    uint64_t started = objc_msgSend_initWithStartDate_endDate_(v2, v9, v10, v6, v11);
    uint64_t v18 = @"CMTimeRangeKey";
    v19[0] = started;
    uint64_t v14 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v13, (uint64_t)v19, &v18, 1);

    uint64_t v15 = (std::__shared_weak_count *)operator new(0x70uLL);
    v15->__shared_owners_ = 0;
    v15->__shared_weak_owners_ = 0;
    v15->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0DA0;
    sub_1902C3F54(__p, "Health/kCLConnectionMessageMetMinutesQuery");
    MEMORY[0x192FCC420](&v15[1], __p, v14);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    CLConnectionClient::sendMessage();
    if (v15) {
      sub_1902D8B58(v15);
    }
    sub_1902D8B58(v15);
  }
}

void sub_19050E10C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16) {
    sub_1902D8B58(a16);
  }
  sub_1902D8B58(v22);
  _Unwind_Resume(a1);
}

void sub_19050E160(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v5 = (id)objc_msgSend_copy(*(void **)(a1 + 40), a2, a3);
  double v6 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  __int16 v12 = (NSSet *)objc_msgSend_setWithObjects_(v6, v11, v7, v8, v9, v10, 0);
  if (*(void *)a2
    && (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v12)) != 0)
  {
    uint64_t v15 = DictionaryOfClasses;
    uint64_t v16 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v14, @"CMErrorMessage");
    uint64_t v18 = objc_msgSend_objectForKeyedSubscript_(v15, v17, @"CMMetMinutesArray");
    if (v16)
    {
      uint64_t v19 = *(NSObject **)(*(void *)(a1 + 32) + 24);
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 3221225472;
      float32x2_t v27[2] = sub_19050E578;
      v27[3] = &unk_1E568D320;
      float v27[4] = v16;
      void v27[5] = v5;
      uint64_t v20 = v27;
    }
    else if (v18)
    {
      id v21 = *(NSObject **)(*(void *)(a1 + 32) + 24);
      v26[0] = MEMORY[0x1E4F143A8];
      v26[1] = 3221225472;
      v26[2] = sub_19050E5F0;
      v26[3] = &unk_1E568D320;
      v26[4] = v18;
      void v26[5] = v5;
      uint64_t v20 = v26;
      uint64_t v19 = v21;
    }
    else
    {
      if (qword_1E929D928 != -1) {
        dispatch_once(&qword_1E929D928, &unk_1EDFD3C60);
      }
      uint64_t v22 = qword_1E929D930;
      if (os_log_type_enabled((os_log_t)qword_1E929D930, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_FAULT, "METMinutes,Unable to parse query response", buf, 2u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D928 != -1) {
          dispatch_once(&qword_1E929D928, &unk_1EDFD3C60);
        }
        __int16 v25 = 0;
        uint64_t v23 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "-[CMHealthTrackerInternal _queryMetMinutesFromDate:toDate:handler:]_block_invoke", "CoreLocation: %s\n", v23);
        if (v23 != (char *)buf) {
          free(v23);
        }
      }
      uint64_t v19 = *(NSObject **)(*(void *)(a1 + 32) + 24);
      v24[0] = MEMORY[0x1E4F143A8];
      v24[1] = 3221225472;
      v24[2] = sub_19050E608;
      v24[3] = &unk_1E568D2D0;
      v24[4] = v5;
      uint64_t v20 = v24;
    }
  }
  else
  {
    uint64_t v19 = *(NSObject **)(*(void *)(a1 + 32) + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_19050E514;
    block[3] = &unk_1E568D2D0;
    void block[4] = v5;
    uint64_t v20 = block;
  }
  dispatch_async(v19, v20);
}

uint64_t sub_19050E514(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_19050E578(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

uint64_t sub_19050E5F0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_19050E608(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

void sub_19050E6E4(void *a1, const char *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1[4] + 8) && a1[6])
  {
    uint64_t v2 = a1[5];
    if (v2)
    {
      double v11 = @"CMVO2MaxInputsRecord";
      uint64_t v12 = v2;
      uint64_t v10 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], a2, (uint64_t)&v12, &v11, 1);
    }
    else
    {
      memset(v15, 0, sizeof(v15));
      long long v19 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      uint64_t v22 = 0;
      uint64_t v3 = [CMVO2MaxInputs alloc];
      unint64_t v16 = 0xFFEFFFFFFFFFFFFFLL;
      uint64_t v17 = 0;
      unint64_t v18 = 0xFFEFFFFFFFFFFFFFLL;
      int v5 = objc_msgSend_initWithSample_(v3, v4, (uint64_t)v15);
      pid_t v13 = @"CMVO2MaxInputsRecord";
      uint64_t v14 = v5;
      uint64_t v10 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v6, (uint64_t)&v14, &v13, 1);
    }
    sub_19050F15C("Health/kCLConnectionMessageVO2MaxInputsQuery", &v10, &v8);
    uint64_t v7 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CLConnectionClient::sendMessage();
    if (v7) {
      sub_1902D8B58(v7);
    }
    if (v9) {
      sub_1902D8B58(v9);
    }
  }
}

void sub_19050E8A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a16) {
    sub_1902D8B58(a16);
  }
  if (a18) {
    sub_1902D8B58(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_19050E8D4(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v5 = (id)objc_msgSend_copy(*(void **)(a1 + 40), a2, a3);
  double v6 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  uint64_t v12 = (NSSet *)objc_msgSend_setWithObjects_(v6, v11, v7, v8, v9, v10, 0);
  if (*(void *)a2
    && (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v12)) != 0)
  {
    uint64_t v15 = DictionaryOfClasses;
    uint64_t v16 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v14, @"CMErrorMessage");
    uint64_t v18 = objc_msgSend_objectForKeyedSubscript_(v15, v17, @"CMVO2MaxInputsArray");
    if (v16)
    {
      long long v19 = *(NSObject **)(*(void *)(a1 + 32) + 24);
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 3221225472;
      float32x2_t v27[2] = sub_19050ECEC;
      v27[3] = &unk_1E568D320;
      float v27[4] = v16;
      void v27[5] = v5;
      long long v20 = v27;
    }
    else if (v18)
    {
      long long v21 = *(NSObject **)(*(void *)(a1 + 32) + 24);
      v26[0] = MEMORY[0x1E4F143A8];
      v26[1] = 3221225472;
      v26[2] = sub_19050ED64;
      v26[3] = &unk_1E568D320;
      v26[4] = v18;
      void v26[5] = v5;
      long long v20 = v26;
      long long v19 = v21;
    }
    else
    {
      if (qword_1E929D928 != -1) {
        dispatch_once(&qword_1E929D928, &unk_1EDFD3C60);
      }
      uint64_t v22 = qword_1E929D930;
      if (os_log_type_enabled((os_log_t)qword_1E929D930, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_FAULT, "VO2MaxData,Unable to parse query response", buf, 2u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D928 != -1) {
          dispatch_once(&qword_1E929D928, &unk_1EDFD3C60);
        }
        __int16 v25 = 0;
        uint64_t v23 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "-[CMHealthTrackerInternal _queryVO2MaxInputsFromRecord:handler:]_block_invoke", "CoreLocation: %s\n", v23);
        if (v23 != (char *)buf) {
          free(v23);
        }
      }
      long long v19 = *(NSObject **)(*(void *)(a1 + 32) + 24);
      v24[0] = MEMORY[0x1E4F143A8];
      v24[1] = 3221225472;
      v24[2] = sub_19050ED7C;
      v24[3] = &unk_1E568D2D0;
      v24[4] = v5;
      long long v20 = v24;
    }
  }
  else
  {
    long long v19 = *(NSObject **)(*(void *)(a1 + 32) + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_19050EC88;
    block[3] = &unk_1E568D2D0;
    void block[4] = v5;
    long long v20 = block;
  }
  dispatch_async(v19, v20);
}

uint64_t sub_19050EC88(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_19050ECEC(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

uint64_t sub_19050ED64(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_19050ED7C(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_19050EEE0(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__teardown(*(void **)(*(void *)(a1 + 32) + 8), a2, a3);
}

os_log_t sub_19050F12C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Health");
  qword_1E929D930 = (uint64_t)result;
  return result;
}

void *sub_19050F15C@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  double v6 = operator new(0x70uLL);
  os_log_t result = sub_19050F1C0(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_19050F1AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_19050F1C0(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_19050F234((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_19050F220(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_19050F234(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_19050F28C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19050F2A8(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_190608E30;
  sub_1902D9ACC((float32x4_t *)a1, (float32x4_t)xmmword_190608E30);
  *(_OWORD *)(a1 + 68) = xmmword_19060B210;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  sub_1902D9ACC((float32x4_t *)(a1 + 68), (float32x4_t)xmmword_19060B210);
  *(unsigned char *)(a1 + 84) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 1065749138;
  *(unsigned char *)(a1 + 100) = 1;
  sub_190511648(a1 + 104, 0.0, 6.2832, 0.01, 100.0, 1.0);
  *(_DWORD *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 164) = 0;
  *(_DWORD *)(a1 + 168) = -1;
  *(unsigned char *)(a1 + 172) = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_1E929EA60, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_1E929EA60))
  {
    xmmword_1E929EA50 = xmmword_19060B220;
    __cxa_guard_release(qword_1E929EA60);
  }
  sub_19050F410(a1 + 104, &xmmword_1E929EA50);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E929EA80, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E929EA80))
  {
    xmmword_1E929EA70 = xmmword_19060B230;
    __cxa_guard_release(&qword_1E929EA80);
  }
  sub_19050F4FC(a1 + 104, &xmmword_1E929EA70);
  return a1;
}

uint64_t sub_19050F410(uint64_t a1, _DWORD *a2)
{
  unint64_t v4 = 0;
  while (sub_19042F198((uint64_t)a2, v4) >= *(float *)a1 && sub_19042F198((uint64_t)a2, v4) <= *(float *)(a1 + 4))
  {
    if (++v4 == 4)
    {
      unint64_t v5 = 1;
      while (1)
      {
        float v6 = *(float *)sub_190511704(a1 + 24, v5);
        unint64_t v7 = v5 - 1;
        if (v6 < (float)(*(float *)sub_190511704(a1 + 24, v7) + 0.000001)) {
          break;
        }
        unint64_t v5 = v7 + 2;
        if (v5 == 4)
        {
          *(_DWORD *)(a1 + 24) = *a2;
          *(_DWORD *)(a1 + 28) = a2[1];
          *(_DWORD *)(a1 + 32) = a2[2];
          *(_DWORD *)(a1 + 36) = a2[3];
          return 1;
        }
      }
      return 0;
    }
  }
  return 0;
}

BOOL sub_19050F4FC(uint64_t a1, _DWORD *a2)
{
  if (sub_19042F198((uint64_t)a2, 0) < *(float *)(a1 + 8) || sub_19042F198((uint64_t)a2, 0) > *(float *)(a1 + 12)) {
    return 0;
  }
  unint64_t v5 = 0;
  while (v5 != 3)
  {
    unint64_t v6 = v5;
    unint64_t v7 = v5 + 1;
    if (sub_19042F198((uint64_t)a2, v5 + 1) >= *(float *)(a1 + 8))
    {
      float v8 = sub_19042F198((uint64_t)a2, v7);
      unint64_t v5 = v6 + 1;
      if (v8 <= *(float *)(a1 + 12)) {
        continue;
      }
    }
    return v6 > 2;
  }
  *(_DWORD *)(a1 + 40) = *a2;
  *(_DWORD *)(a1 + 44) = a2[1];
  *(_DWORD *)(a1 + 48) = a2[2];
  *(_DWORD *)(a1 + 52) = a2[3];
  return 1;
}

void sub_19050F5D8(uint64_t a1, float *a2)
{
  uint64_t v4 = 0;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  float v5 = 0.0;
  do
  {
    float v5 = v5 + (float)(a2[v4] * a2[v4]);
    ++v4;
  }
  while (v4 != 3);
  if (fabsf(sqrtf(v5) + -1.0) <= 0.000001)
  {
    *(float *)(a1 + 40) = sub_1904CF73C((float *)(a1 + 68), *a2, a2[1], a2[2]);
    *(_DWORD *)(a1 + 44) = v11;
    *(_DWORD *)(a1 + 48) = v12;
  }
  else
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
    }
    unint64_t v6 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      double v7 = *a2;
      double v8 = a2[1];
      double v9 = a2[2];
      *(_DWORD *)int buf = 134349568;
      double v14 = v7;
      __int16 v15 = 2050;
      double v16 = v8;
      __int16 v17 = 2050;
      double v18 = v9;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_ERROR, "[CMPerceptualFilter] Gravity vector must be unity norm. gravity.x,%{public}f,.y,%{public}f,.z,%{public}f", buf, 0x20u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
      }
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMAudioPerceptualFilter::feedGravity(const CMVector3d &)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf) {
        free(v10);
      }
    }
  }
}

void sub_19050F830(uint64_t a1, float *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v130 = *MEMORY[0x1E4F143B8];
  long long v6 = *(_OWORD *)(a1 + 16);
  float32x4_t v88 = *(float32x4_t *)a1;
  long long v89 = v6;
  __int16 v90 = *(_WORD *)(a1 + 32);
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  float v7 = sub_1904CF73C((float *)(a1 + 68), *a2, a2[1], a2[2]);
  uint64_t v10 = 0;
  float v11 = 0.0;
  do
  {
    float v11 = v11 + (float)(a2[v10] * a2[v10]);
    ++v10;
  }
  while (v10 != 3);
  float v12 = sqrtf(v11);
  if (v12 < 0.001)
  {
    if (*(unsigned char *)(a1 + 100))
    {
      *(unsigned char *)(a1 + 100) = 0;
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
      }
      pid_t v13 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_ERROR, "Error -- cannot set listener orientation using boresight vector at 0 distance.", buf, 2u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
        }
        LOWORD(v97) = 0;
        uint64_t v76 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "void CMAudioPerceptualFilter::feed(const CMVector3d &, uint64_t, uint64_t)", "CoreLocation: %s\n", v76);
        if (v76 != buf) {
          free(v76);
        }
      }
    }
    sub_1904F893C(a1, 0);
    return;
  }
  *(unsigned char *)(a1 + 100) = 1;
  float v14 = v7 / v12;
  float v15 = v8 / v12;
  v86.f32[0] = v7 / v12;
  v86.f32[1] = v8 / v12;
  float v16 = v9 / v12;
  float v87 = v9 / v12;
  if (*(unsigned char *)(a1 + 84))
  {
    sub_190510C24((float32x4_t *)buf, (float *)&v86);
    if (*(unsigned char *)(a1 + 172))
    {
      float32x4_t v17 = *(float32x4_t *)buf;
      float32x4_t v85 = *(float32x4_t *)buf;
    }
    else
    {
      v91.i32[0] = sub_1904CF73C((float *)buf, *(float *)(a1 + 52), *(float *)(a1 + 56), *(float *)(a1 + 60));
      *(uint64_t *)((char *)v91.i64 + 4) = __PAIR64__(v23, v22);
      float v24 = *(float *)(a1 + 40);
      float v25 = *(float *)(a1 + 44);
      float v26 = *(float *)(a1 + 48);
      float v27 = (float)((float)(v26 * v16) + (float)(v25 * v15)) + (float)(v24 * v14);
      float v93 = v24 - (float)(v14 * v27);
      float v94 = v25 - (float)(v15 * v27);
      float v95 = v26 - (float)(v16 * v27);
      sub_190510DBC((float32x4_t *)&v97, a1, &v93, v91.f32, &v86);
      *(double *)v17.i64 = sub_1904CF3F4((uint64_t)&v97, (float *)buf, &v85, v28);
    }
    goto LABEL_33;
  }
  sub_190510C24((float32x4_t *)&v97, (float *)&v86);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF340, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB3BF340))
  {
    qword_1EB3BF360 = 0x3F80000000000000;
    dword_1EB3BF368 = 0;
    __cxa_guard_release(&qword_1EB3BF340);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF348, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB3BF348))
  {
    qword_1EB3BF370 = 0;
    dword_1EB3BF378 = 1065353216;
    __cxa_guard_release(&qword_1EB3BF348);
  }
  float v93 = sub_1904CF73C((float *)&v97, *(float *)&qword_1EB3BF360, *((float *)&qword_1EB3BF360 + 1), *(float *)&dword_1EB3BF368);
  float v94 = v18;
  float v95 = v19;
  v92[0] = (float)(*((float *)&qword_1EB3BF370 + 1) * v87) - (float)(*(float *)&dword_1EB3BF378 * v86.f32[1]);
  v92[1] = (float)(*(float *)&dword_1EB3BF378 * v86.f32[0]) - (float)(*(float *)&qword_1EB3BF370 * v87);
  v92[2] = (float)(*(float *)&qword_1EB3BF370 * v86.f32[1]) - (float)(*((float *)&qword_1EB3BF370 + 1) * v86.f32[0]);
  sub_190510DBC(&v91, a1, v92, &v93, &v86);
  sub_1904CF3F4((uint64_t)&v91, (float *)&v97, &v85, v20);
  if (*(unsigned char *)(a1 + 84))
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
    }
    long long v21 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_ERROR, "[PerceptualFilter] already initialized, should not be calling initializeAmbienceBedGravity", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_33;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 == -1) {
      goto LABEL_125;
    }
LABEL_140:
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
LABEL_125:
    __int16 v96 = 0;
    uint64_t v75 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "void CMAudioPerceptualFilter::initializeAmbienceBedGravity(const CMOQuaternion &)", "CoreLocation: %s\n", v75);
LABEL_126:
    if (v75 != buf) {
      free(v75);
    }
    goto LABEL_33;
  }
  uint64_t v29 = 0;
  uint64_t v30 = a1 + 52;
  float v31 = 0.0;
  do
  {
    float v31 = v31 + (float)(*(float *)(v30 + v29) * *(float *)(v30 + v29));
    v29 += 4;
  }
  while (v29 != 12);
  if (sqrtf(v31) != 0.0)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
    }
    uint64_t v32 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v32, OS_LOG_TYPE_ERROR, "[PerceptualFilter] fAmbienceBedGravity has already been set, cannot re-initialize ambience bed gravity direction.", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_33;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 == -1) {
      goto LABEL_125;
    }
    goto LABEL_140;
  }
  uint64_t v52 = 0;
  int v53 = *(_DWORD *)(a1 + 168);
  v17.i64[0] = 0;
  do
  {
    v17.f32[0] = v17.f32[0] + (float)(*(float *)(a1 + 40 + v52) * *(float *)(a1 + 40 + v52));
    v52 += 4;
  }
  while (v52 != 12);
  if (sqrtf(v17.f32[0]) < 0.000001)
  {
    *(_DWORD *)(a1 + 168) = 0;
    if (!v53) {
      goto LABEL_33;
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
    }
    uint64_t v54 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v54, OS_LOG_TYPE_ERROR, "[PerceptualFilter] Accessory gravity has not been set.", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_33;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 == -1) {
      goto LABEL_125;
    }
    goto LABEL_140;
  }
  *(_DWORD *)(a1 + 168) = 1;
  if (v53 != 1)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
    }
    uint64_t v68 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v68, OS_LOG_TYPE_DEFAULT, "[PerceptualFilter] Accessory gravity is available", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
      }
      __int16 v96 = 0;
      uint64_t v84 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CMAudioPerceptualFilter::initializeAmbienceBedGravity(const CMOQuaternion &)", "CoreLocation: %s\n", v84);
      if (v84 != buf) {
        free(v84);
      }
    }
  }
  v17.f32[0] = -v85.f32[2];
  *(float32x2_t *)int buf = vneg_f32(*(float32x2_t *)v85.f32);
  *(float *)&uint8_t buf[8] = -v85.f32[2];
  *(_DWORD *)&uint8_t buf[12] = v85.i32[3];
  sub_1902D9ACC((float32x4_t *)buf, v17);
  sub_1904CF73C((float *)buf, *(float *)(a1 + 40), *(float *)(a1 + 44), *(float *)(a1 + 48));
  uint64_t v71 = 0;
  *(float *)(a1 + 56) = v69;
  *(float *)(a1 + 60) = v70;
  v17.i64[0] = 0;
  *(_DWORD *)(a1 + 52) = 0;
  do
  {
    v17.f32[0] = v17.f32[0] + (float)(*(float *)(v30 + v71) * *(float *)(v30 + v71));
    v71 += 4;
  }
  while (v71 != 12);
  if (sqrtf(v17.f32[0]) >= 0.087156)
  {
    uint64_t v72 = 0;
    v17.i64[0] = 0;
    do
    {
      v17.f32[0] = v17.f32[0] + (float)(*(float *)(v30 + v72) * *(float *)(v30 + v72));
      v72 += 4;
    }
    while (v72 != 12);
    float v73 = sqrtf(v17.f32[0]);
    *(float *)(a1 + 52) = 0.0 / v73;
    *(float *)(a1 + 56) = v69 / v73;
    *(float *)(a1 + 60) = v70 / v73;
    *(unsigned char *)(a1 + 84) = 1;
    if (*(unsigned char *)(a1 + 92)) {
      goto LABEL_33;
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
    }
    uint64_t v74 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v74, OS_LOG_TYPE_DEFAULT, "[PerceptualFilter] Initialized ambience bed orientation with fixed gravity direction", buf, 2u);
    }
    if (!sub_1902D8400(115, 2)) {
      goto LABEL_33;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
    }
    __int16 v96 = 0;
    uint64_t v75 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMAudioPerceptualFilter::initializeAmbienceBedGravity(const CMOQuaternion &)", "CoreLocation: %s\n", v75);
    goto LABEL_126;
  }
  *(void *)(a1 + 56) = 0;
LABEL_33:
  v17.f32[0] = -v88.f32[2];
  *(float32x2_t *)int buf = vneg_f32(*(float32x2_t *)v88.f32);
  *(float *)&uint8_t buf[8] = -v88.f32[2];
  *(_DWORD *)&uint8_t buf[12] = v88.i32[3];
  float32x4_t v33 = sub_1902D9ACC((float32x4_t *)buf, v17);
  sub_1904CF3F4((uint64_t)&v85, (float *)buf, &v91, v33);
  float v34 = sub_1904CF8B4(&v91);
  float v36 = v35;
  float v38 = v37;
  uint64_t v39 = 0;
  float v93 = v34;
  float v94 = v35;
  float v95 = v37;
  v40.i32[0] = 0;
  do
  {
    v40.f32[0] = v40.f32[0] + (float)(*(float *)((char *)&v93 + v39) * *(float *)((char *)&v93 + v39));
    v39 += 4;
  }
  while (v39 != 12);
  float v41 = sqrtf(v40.f32[0]);
  if ((_BYTE)v90)
  {
    v40.i64[0] = 0x3FA65718498ADC00;
    if (v41 > 0.017453 && (*(unsigned char *)(a1 + 92) || *(unsigned char *)(a1 + 94)))
    {
      if (*(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a1 + 93))
      {
        if (*(unsigned char *)(a1 + 94))
        {
          if (*(unsigned char *)(a1 + 95))
          {
            float v42 = *(float *)(a1 + 164);
          }
          else
          {
            *(_DWORD *)(a1 + 164) = 0;
            float v42 = 0.0;
          }
          if (v41 > v42)
          {
            sub_190510AE0(a1 + 104, v41);
            float v55 = 0.1;
            if (v56 >= 0.1)
            {
              sub_190510AE0(a1 + 104, v41);
              float v55 = v57;
            }
            *(float *)(a1 + 96) = v41 / v55;
            if (qword_1E929D8D8 != -1) {
              dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
            }
            uint64_t v58 = qword_1E929D8E0;
            if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
            {
              double v59 = *(float *)(a1 + 96);
              double v60 = *(float *)(a1 + 160);
              *(_DWORD *)int buf = 134218752;
              *(double *)&uint8_t buf[4] = v41;
              *(_WORD *)&uint8_t buf[12] = 2048;
              *(double *)&buf[14] = v55;
              __int16 v116 = 2048;
              double v117 = v59;
              __int16 v118 = 2048;
              double v119 = v60;
              _os_log_impl(&dword_1902AF000, v58, OS_LOG_TYPE_DEFAULT, "[PerceptualFilterAnchor] thetaNormRad %.3f, sweepDurationS, %.3f, fPerceptualAngularVelocityRps, %.3f, fLastAuxYawRateRps, %.3f", buf, 0x2Au);
            }
            if (sub_1902D8400(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1E929D8D8 != -1) {
                dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
              }
              double v81 = *(float *)(a1 + 96);
              double v82 = *(float *)(a1 + 160);
              int v97 = 134218752;
              double v98 = v41;
              __int16 v99 = 2048;
              double v100 = v55;
              __int16 v101 = 2048;
              double v102 = v81;
              __int16 v103 = 2048;
              double v104 = v82;
              uint64_t v83 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 2, "void CMAudioPerceptualFilter::feed(const CMVector3d &, uint64_t, uint64_t)", "CoreLocation: %s\n", v83);
              if (v83 != buf) {
                free(v83);
              }
            }
            *(float *)(a1 + 164) = v41;
          }
        }
      }
      else
      {
        sub_190510AE0(a1 + 104, v41);
        float v44 = v43;
        float v45 = 0.1;
        if (v44 >= 0.1) {
          sub_190510AE0(a1 + 104, v41);
        }
        *(float *)(a1 + 96) = v41 / v45;
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
        }
        uint64_t v46 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
        {
          double v47 = *(float *)(a1 + 96);
          double v48 = *(float *)(a1 + 160);
          *(_DWORD *)int buf = 134218496;
          *(double *)&uint8_t buf[4] = v41;
          *(_WORD *)&uint8_t buf[12] = 2048;
          *(double *)&buf[14] = v47;
          __int16 v116 = 2048;
          double v117 = v48;
          _os_log_impl(&dword_1902AF000, v46, OS_LOG_TYPE_DEFAULT, "[PerceptualFilterBTZ] thetaNormRad %.3f, fPerceptualAngularVelocityRps, %.3f, fLastAuxYawRateRps, %.3f", buf, 0x20u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
          }
          double v49 = *(float *)(a1 + 96);
          double v50 = *(float *)(a1 + 160);
          int v97 = 134218496;
          double v98 = v41;
          __int16 v99 = 2048;
          double v100 = v49;
          __int16 v101 = 2048;
          double v102 = v50;
          uint64_t v51 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CMAudioPerceptualFilter::feed(const CMVector3d &, uint64_t, uint64_t)", "CoreLocation: %s\n", v51);
          if (v51 != buf) {
            free(v51);
          }
        }
      }
      float v61 = *(float *)(a1 + 96);
      if (v61 <= *(float *)(a1 + 160)) {
        float v61 = *(float *)(a1 + 160);
      }
      *(double *)v40.i64 = v61 * 0.00499999989;
    }
    if (v41 >= 0.000001)
    {
      if (*(double *)v40.i64 <= v41)
      {
        float v62 = *(double *)v40.i64;
        float v63 = v62;
      }
      else
      {
        float v63 = v41;
      }
      *(float *)int buf = (float)(v34 * v63) / v41;
      *(float *)&uint8_t buf[4] = (float)(v36 * v63) / v41;
      *(float *)&uint8_t buf[8] = (float)(v38 * v63) / v41;
      *(double *)v40.i64 = sub_1904CF7FC(&v91, (float *)buf);
    }
    else
    {
      v91.i64[0] = 0;
      v91.i64[1] = 0x3F80000000000000;
    }
    sub_1904CF3F4((uint64_t)&v91, v88.f32, (float32x4_t *)buf, v40);
    *(_OWORD *)a1 = *(_OWORD *)buf;
    if (v41 >= 0.017453)
    {
      if (*(unsigned char *)(a1 + 92) || *(unsigned char *)(a1 + 94))
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
        }
        int v64 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v65 = *(void *)(a1 + 16);
          int v66 = *(unsigned __int8 *)(a1 + 92);
          int v67 = *(unsigned __int8 *)(a1 + 94);
          *(_DWORD *)int buf = 134220032;
          *(void *)&uint8_t buf[4] = v65;
          *(_WORD *)&uint8_t buf[12] = 2048;
          *(void *)&buf[14] = v89;
          __int16 v116 = 2048;
          double v117 = v91.f32[0];
          __int16 v118 = 2048;
          double v119 = v91.f32[1];
          __int16 v120 = 2048;
          double v121 = v91.f32[2];
          __int16 v122 = 2048;
          double v123 = v91.f32[3];
          __int16 v124 = 2048;
          double v125 = v41;
          __int16 v126 = 1024;
          int v127 = v66;
          __int16 v128 = 1024;
          int v129 = v67;
          _os_log_impl(&dword_1902AF000, v64, OS_LOG_TYPE_DEBUG, "[PerceptualFilter] currTimestamp %llu, prevTimestamp, %llu, dq [%.3f, %.3f, %.3f, %.3f], dthetaNorm, %.3f, inBTZ, %d, inAnchorConvergence, %d", buf, 0x54u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
          }
          double v77 = *(double *)(a1 + 16);
          int v78 = *(unsigned __int8 *)(a1 + 92);
          int v79 = *(unsigned __int8 *)(a1 + 94);
          int v97 = 134220032;
          double v98 = v77;
          __int16 v99 = 2048;
          double v100 = *(double *)&v89;
          __int16 v101 = 2048;
          double v102 = v91.f32[0];
          __int16 v103 = 2048;
          double v104 = v91.f32[1];
          __int16 v105 = 2048;
          double v106 = v91.f32[2];
          __int16 v107 = 2048;
          double v108 = v91.f32[3];
          __int16 v109 = 2048;
          double v110 = v41;
          __int16 v111 = 1024;
          int v112 = v78;
          __int16 v113 = 1024;
          int v114 = v79;
          uint64_t v80 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CMAudioPerceptualFilter::feed(const CMVector3d &, uint64_t, uint64_t)", "CoreLocation: %s\n", v80);
          if (v80 != buf) {
            free(v80);
          }
        }
      }
    }
    else
    {
      *(unsigned char *)(a1 + 92) = 0;
      *(unsigned char *)(a1 + 94) = 0;
    }
  }
  else
  {
    *(float32x4_t *)a1 = v85;
    *(unsigned char *)(a1 + 92) = 0;
  }
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 33) = v41 >= 0.0017453;
  *(unsigned char *)(a1 + 93) = *(unsigned char *)(a1 + 92);
  *(unsigned char *)(a1 + 95) = *(unsigned char *)(a1 + 94);
}

void sub_190510AE0(uint64_t a1, float a2)
{
  if (*(unsigned char *)(a1 + 20))
  {
    if (*(float *)a1 <= a2 && *(float *)(a1 + 4) >= a2)
    {
      uint64_t v4 = a1 + 24;
      if (*(float *)(a1 + 24) <= a2)
      {
        unint64_t v5 = -1;
        while (v5 != 2)
        {
          float v6 = sub_19042F198(a1 + 24, v5 + 2);
          ++v5;
          if (v6 > a2)
          {
            uint64_t v7 = a1 + 40;
            sub_19042F198(v7, v5 + 1);
            sub_19042F198(v7, v5);
            sub_19042F198(v4, v5 + 1);
            sub_19042F198(v4, v5);
            sub_19042F198(v4, v5);
            sub_19042F198(v7, v5);
            return;
          }
        }
      }
    }
  }
}

void sub_190510C24(float32x4_t *a1, float *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF338, memory_order_acquire) & 1) == 0)
  {
    float32x4_t v17 = a2;
    int v18 = __cxa_guard_acquire(&qword_1EB3BF338);
    a2 = v17;
    if (v18)
    {
      qword_1EB3BF350 = 1065353216;
      dword_1EB3BF358 = 0;
      __cxa_guard_release(&qword_1EB3BF338);
      a2 = v17;
    }
  }
  float v3 = *a2;
  float v4 = a2[1];
  float v5 = a2[2];
  float v6 = (float)((float)(v5 * *(float *)&dword_1EB3BF358) + (float)(v4 * *((float *)&qword_1EB3BF350 + 1)))
     + (float)(*a2 * *(float *)&qword_1EB3BF350);
  float v7 = 1.0;
  if (v6 < 1.0)
  {
    float v7 = -1.0;
    if (v6 > -1.0) {
      float v7 = (float)((float)(v5 * *(float *)&dword_1EB3BF358) + (float)(v4 * *((float *)&qword_1EB3BF350 + 1)))
    }
         + (float)(*a2 * *(float *)&qword_1EB3BF350);
  }
  uint64_t v8 = 0;
  float v9 = (float)(v4 * *(float *)&dword_1EB3BF358) - (float)(v5 * *((float *)&qword_1EB3BF350 + 1));
  float v10 = (float)(v5 * *(float *)&qword_1EB3BF350) - (float)(v3 * *(float *)&dword_1EB3BF358);
  float v11 = (float)(v3 * *((float *)&qword_1EB3BF350 + 1)) - (float)(v4 * *(float *)&qword_1EB3BF350);
  *(float *)&uint64_t v20 = v9;
  *((float *)&v20 + 1) = v10;
  float v21 = v11;
  float v12 = 0.0;
  do
  {
    float v12 = v12 + (float)(*(float *)((char *)&v20 + v8) * *(float *)((char *)&v20 + v8));
    v8 += 4;
  }
  while (v8 != 12);
  if (sqrtf(v12) < 0.000001)
  {
    uint64_t v20 = 0x3F80000000000000;
    float v21 = 0.0;
    float v10 = 1.0;
    float v11 = 0.0;
    float v9 = 0.0;
  }
  uint64_t v13 = 0;
  float v14 = 0.0;
  do
  {
    float v14 = v14 + (float)(*(float *)((char *)&v20 + v13) * *(float *)((char *)&v20 + v13));
    v13 += 4;
  }
  while (v13 != 12);
  float v15 = acosf(v7);
  float v16 = sqrtf(v14);
  v19[0] = (float)(v9 / v16) * v15;
  v19[1] = (float)(v10 / v16) * v15;
  void v19[2] = (float)(v11 / v16) * v15;
  sub_1904CF7FC(a1, v19);
}

void sub_190510DBC(float32x4_t *a1, uint64_t a2, float *a3, float *a4, float32x2_t *a5)
{
  uint64_t v10 = 0;
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  float v11 = a5->f32[1];
  float v12 = a5[1].f32[0];
  float v13 = (float)((float)(v12 * a4[2]) + (float)(a4[1] * v11)) + (float)(*a4 * a5->f32[0]);
  int v14 = *(unsigned __int8 *)(a2 + 64);
  float v15 = 0.0;
  do
  {
    float v15 = v15 + (float)(a3[v10] * a3[v10]);
    ++v10;
  }
  while (v10 != 3);
  if (sqrtf(v15) >= 0.087156)
  {
    uint64_t v17 = 0;
    float v18 = 0.0;
    do
    {
      float v18 = v18 + (float)(a4[v17] * a4[v17]);
      ++v17;
    }
    while (v17 != 3);
    BOOL v16 = sqrtf(v18) < 0.087156;
  }
  else
  {
    BOOL v16 = 1;
  }
  double v19 = (float)((float)((float)(a3[2] * v12) + (float)(a3[1] * v11)) + (float)(*a3 * a5->f32[0]));
  *(unsigned char *)(a2 + 64) = v16;
  if (v14 || !v16)
  {
    if (v14) {
      char v21 = v16;
    }
    else {
      char v21 = 1;
    }
    if ((v21 & 1) == 0)
    {
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
      }
      unsigned int v22 = qword_1E929D8E0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_DEFAULT, "[PerceptualFilter] Exiting ambience bed constraints singularity", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
        }
        v64.i16[0] = 0;
        goto LABEL_64;
      }
    }
  }
  else
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
    }
    uint64_t v20 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v20, OS_LOG_TYPE_DEFAULT, "[PerceptualFilter] Entering ambience bed constraints singularity", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
      }
      v64.i16[0] = 0;
LABEL_64:
      float v62 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "CMOQuaternion CMAudioPerceptualFilter::rollAboutBoresightToAlignVectors(const CMVector3d &, const CMVector3d &, const CMVector3d &)", "CoreLocation: %s\n", v62);
      if (v62 != (char *)buf) {
        free(v62);
      }
    }
  }
  if (v19 >= 0.001 || v13 >= 0.001)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
    }
    float v41 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v41, OS_LOG_TYPE_ERROR, "[PerceptualFilter] Vectors to align are not perpendicular to boresight vector", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
      }
      v64.i16[0] = 0;
      float v61 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "CMOQuaternion CMAudioPerceptualFilter::rollAboutBoresightToAlignVectors(const CMVector3d &, const CMVector3d &, const CMVector3d &)", "CoreLocation: %s\n", v61);
      if (v61 != (char *)buf) {
        free(v61);
      }
    }
    float v42 = *(float *)(a2 + 88);
    unsigned int v23 = (float *)(a2 + 88);
    float v25 = v42;
    *(float32x2_t *)int buf = *a5;
    float v67 = a5[1].f32[0];
  }
  else
  {
    float v24 = *(float *)(a2 + 88);
    unsigned int v23 = (float *)(a2 + 88);
    float v25 = v24;
    *(float32x2_t *)int buf = *a5;
    float v67 = a5[1].f32[0];
    if (!*((unsigned char *)v23 - 24))
    {
      uint64_t v26 = 0;
      float v27 = 0.0;
      do
      {
        float v27 = v27 + (float)(a3[v26] * a3[v26]);
        ++v26;
      }
      while (v26 != 3);
      uint64_t v28 = 0;
      float v29 = 0.0;
      do
      {
        float v29 = v29 + (float)(a4[v28] * a4[v28]);
        ++v28;
      }
      while (v28 != 3);
      float v30 = sqrtf(v27);
      float v31 = a3[1] / v30;
      float v32 = *a3 / v30;
      float v33 = a3[2] / v30;
      float v34 = sqrtf(v29);
      float v35 = a4[1] / v34;
      float v36 = a4[2] / v34;
      float v37 = (float)(v33 * v36) + (float)(v31 * v35);
      float v38 = *a4 / v34;
      float v39 = v37 + (float)(v32 * v38);
      float v40 = 1.0;
      if (v39 < 1.0)
      {
        float v40 = -1.0;
        if (v39 > -1.0) {
          float v40 = v37 + (float)(v32 * v38);
        }
      }
      float v25 = acosf(v40);
      *(float *)int buf = (float)(v31 * v36) - (float)(v33 * v35);
      *(float *)&uint8_t buf[4] = (float)(v33 * v38) - (float)(v32 * v36);
      float v67 = (float)(v32 * v35) - (float)(v31 * v38);
    }
  }
  uint64_t v43 = 0;
  float v44 = 0.0;
  do
  {
    float v44 = v44 + (float)(*(float *)&buf[v43] * *(float *)&buf[v43]);
    v43 += 4;
  }
  while (v43 != 12);
  float v45 = sqrtf(v44);
  float v46 = 0.0;
  if (v45 >= 0.000001)
  {
    uint64_t v47 = 0;
    float v48 = 0.0;
    do
    {
      float v48 = v48 + (float)(*(float *)&buf[v47] * *(float *)&buf[v47]);
      v47 += 4;
    }
    while (v47 != 12);
    uint64_t v49 = 0;
    float v50 = sqrtf(v48);
    float v51 = *(float *)buf / v50;
    float v52 = *(float *)&buf[4] / v50;
    float v53 = v67 / v50;
    float v54 = a5->f32[0];
    float v55 = a5->f32[1];
    float v56 = a5[1].f32[0];
    v64.f32[0] = (float)-(float)(*(float *)buf / v50) - a5->f32[0];
    v64.f32[1] = (float)-(float)(*(float *)&buf[4] / v50) - v55;
    float v65 = (float)-(float)(v67 / v50) - v56;
    float v57 = 0.0;
    do
    {
      float v57 = v57 + (float)(v64.f32[v49] * v64.f32[v49]);
      ++v49;
    }
    while (v49 != 3);
    uint64_t v58 = 0;
    v63[0] = v51 - v54;
    v63[1] = v52 - v55;
    v63[2] = v53 - v56;
    float v59 = 0.0;
    do
    {
      float v59 = v59 + (float)(v63[v58] * v63[v58]);
      ++v58;
    }
    while (v58 != 3);
    if (sqrtf(v57) >= sqrtf(v59)) {
      float v46 = v25;
    }
    else {
      float v46 = -v25;
    }
  }
  float *v23 = v46;
  float v60 = v46 * a5[1].f32[0];
  float32x2_t v64 = vmul_n_f32(*a5, v46);
  float v65 = v60;
  sub_1904CF7FC(a1, (float *)&v64);
}

void sub_190511488(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 172) = 1;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
  }
  uint64_t v1 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v1, OS_LOG_TYPE_DEFAULT, "[PerceptualFilter] Bypassing ambience bed alignment. This should only be used for E2E latency testing.", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E60);
    }
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMAudioPerceptualFilter::enableBypassAmbienceBedForE2ELatencyTesting()", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf) {
      free(v2);
    }
  }
}

os_log_t sub_190511618()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

uint64_t sub_190511648(uint64_t a1, float a2, float a3, float a4, float a5, float a6)
{
  unint64_t v7 = 0;
  *(float *)a1 = a2;
  *(float *)(a1 + 4) = a3;
  *(float *)(a1 + 8) = a4;
  *(float *)(a1 + 12) = a5;
  *(float *)(a1 + 16) = a6;
  BOOL v8 = (float)(a2 + 0.000001) <= a3;
  if (a5 < a4) {
    BOOL v8 = 0;
  }
  *(unsigned char *)(a1 + 20) = v8;
  uint64_t v9 = a1 + 24;
  uint64_t v10 = a1 + 40;
  float v11 = (float)(a3 - a2) * 0.25;
  if (v11 >= 0.000001) {
    float v12 = v11;
  }
  else {
    float v12 = 0.000001;
  }
  do
  {
    int v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)sub_190511704(v10, v7) = v13;
    float v14 = *(float *)a1 + (float)((float)(int)v7 * v12);
    *(float *)sub_190511704(v9, v7++) = v14;
  }
  while (v7 != 4);
  return a1;
}

uint64_t sub_190511704(uint64_t a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 4)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3600);
    }
    float v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 4;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 277,invalid index %zu >= %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3600);
      }
      float v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T &CMVector<float, 4>::operator[](const size_t) [T = float, N = 4]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return a1 + 4 * a2;
}

uint64_t sub_1905118E0(uint64_t a1, double a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *(double *)a1 = a2;
  *(void *)(a1 + 8) = 0x1000000000;
  *(void *)(a1 + 144) = 0x1000000000;
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
  }
  uint64_t v4 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)int buf = 134217984;
    double v10 = a2;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "[CMResampleIMUData] Constructed CMResampleIMUData. Set output sample period to: %.4f s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
    }
    unint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CMResampleIMUData::CMResampleIMUData(const double)", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
  }
  if (a2 < 0.005 || a2 > 0.05)
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
    }
    float v5 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 134217984;
      double v10 = a2;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_ERROR, "[CMResampleIMUData] Invalid output sample period: %.4f s", buf, 0xCu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
      }
      unint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "CMResampleIMUData::CMResampleIMUData(const double)", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  return a1;
}

uint64_t sub_190511C10(uint64_t a1, unsigned char *a2, unint64_t a3)
{
  uint64_t result = 0;
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  double v5 = *(double *)a1;
  if (*(double *)a1 >= 0.005 && v5 <= 0.05)
  {
    uint64_t v6 = (uint64_t)a2;
    double v7 = (double)a3 * 0.000001;
    if (!*(_WORD *)(a1 + 10))
    {
      unint64_t v16 = *(unsigned __int16 *)(a1 + 8);
      unint64_t v17 = *(unsigned int *)(a1 + 12);
      if (v16 >= v17) {
        uint64_t v18 = *(unsigned int *)(a1 + 12);
      }
      else {
        uint64_t v18 = 0;
      }
      *(double *)(a1 + 8 + 8 * (v16 - v18) + 8) = v7;
      if (v17) {
        *(_WORD *)(a1 + 10) = 1;
      }
      else {
        *(_WORD *)(a1 + 8) = v16 + 1;
      }
      float v15 = (unsigned __int16 *)(a1 + 144);
      goto LABEL_45;
    }
    uint64_t v8 = a1 + 16;
    uint64_t v9 = *(unsigned __int16 *)(a1 + 8);
    unint64_t v10 = *(unsigned __int16 *)(a1 + 10) + v9 - 1;
    unint64_t v11 = *(unsigned int *)(a1 + 12);
    if (v10 >= v11) {
      uint64_t v12 = *(unsigned int *)(a1 + 12);
    }
    else {
      uint64_t v12 = 0;
    }
    double v13 = *(double *)(v8 + 8 * (v10 - v12));
    if (v7 > v13)
    {
      double v14 = *(double *)(v8 + 8 * v9);
      if (v7 - v14 > 0.1)
      {
        *(_DWORD *)(a1 + 144) = 0;
        float v15 = (unsigned __int16 *)(a1 + 144);
        *(_DWORD *)(a1 + 8) = 0;
        *(double *)(a1 + 16) = v7;
        if (v11) {
          *(_WORD *)(a1 + 10) = 1;
        }
        else {
          *(_WORD *)(a1 + 8) = 1;
        }
LABEL_45:
        sub_190512450(v15, (uint64_t)a2);
        return 1;
      }
      if (v7 - v14 >= v5)
      {
        double v42 = v5 + v14;
        double v43 = v5 + v14 - v13;
        if (v43 >= 0.001)
        {
          double v48 = v43 / (v7 - v13);
          if (v48 < 0.0 || v48 > 1.0)
          {
            if (qword_1EB3BE888 != -1) {
              dispatch_once(&qword_1EB3BE888, &unk_1EDFD31A0);
            }
            float32x2_t v64 = off_1EB3BE880;
            if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)int buf = 0;
              _os_log_impl(&dword_1902AF000, v64, OS_LOG_TYPE_FAULT, "Assertion failed: interpolationRatio >= 0 && interpolationRatio <= 1, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Shared/Motion/DeviceMotion/RelativeDeviceMotion/CMResampleIMUData.cpp, line 157,Invalid interpolationRatio..", buf, 2u);
            }
            if (sub_1902D8400(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1EB3BE888 != -1) {
                dispatch_once(&qword_1EB3BE888, &unk_1EDFD31A0);
              }
              *(_WORD *)float v69 = 0;
              float v65 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 0, "void CMResampleIMUData::interpolate(const CMRelDM::IMUData &, double)", "CoreLocation: %s\n", v65);
              if (v65 != buf) {
                free(v65);
              }
            }
          }
          float v50 = (_DWORD *)(a1 + 144);
          unint64_t v51 = *(unsigned __int16 *)(a1 + 144) + (unint64_t)*(unsigned __int16 *)(a1 + 146) - 1;
          unint64_t v52 = *(unsigned int *)(a1 + 148);
          if (v51 < v52) {
            unint64_t v52 = 0;
          }
          float v53 = &v50[18 * (v51 - v52)];
          float v54 = v48;
          unsigned int v55 = *(_DWORD *)(v6 + 48);
          *(float *)&unsigned int v56 = *((float *)v53 + 15) + (float)(*(float *)(v6 + 52) - *((float *)v53 + 15)) * v48;
          float32x4_t v67 = vaddq_f32(*(float32x4_t *)(v53 + 6), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v6 + 16), *(float32x4_t *)(v53 + 6)), v54));
          float32x4_t v68 = vaddq_f32(*(float32x4_t *)(v53 + 2), vmulq_n_f32(vsubq_f32(*(float32x4_t *)v6, *(float32x4_t *)(v53 + 2)), v54));
          float32x4_t v66 = vaddq_f32(*(float32x4_t *)(v53 + 10), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v6 + 32), *(float32x4_t *)(v53 + 10)), v54));
          sub_1904D0B60((float32x4_t *)v53 + 4, (float32x4_t *)(v6 + 56), (float32x4_t *)v69, v54);
          *(float32x4_t *)int buf = v68;
          *(float32x4_t *)&uint8_t buf[16] = v67;
          float32x4_t v73 = v66;
          unint64_t v74 = __PAIR64__(v56, v55);
          long long v75 = *(_OWORD *)v69;
          *(_DWORD *)(a1 + 8) = 0;
          _DWORD *v50 = 0;
          int v57 = *(_DWORD *)(a1 + 12);
          *(double *)(a1 + 16) = v42;
          if (v57) {
            *(_WORD *)(a1 + 10) = 1;
          }
          else {
            *(_WORD *)(a1 + 8) = 1;
          }
          a2 = buf;
          float v15 = (unsigned __int16 *)(a1 + 144);
        }
        else
        {
          float v15 = (unsigned __int16 *)(a1 + 144);
          unint64_t v44 = *(unsigned __int16 *)(a1 + 144) + (unint64_t)*(unsigned __int16 *)(a1 + 146) - 1;
          unint64_t v45 = *(unsigned int *)(a1 + 148);
          if (v44 < v45) {
            unint64_t v45 = 0;
          }
          float v46 = &v15[36 * (v44 - v45)];
          long long v47 = *(_OWORD *)(v46 + 12);
          *(_OWORD *)int buf = *(_OWORD *)(v46 + 4);
          *(_OWORD *)&uint8_t buf[16] = v47;
          float32x4_t v73 = *(float32x4_t *)(v46 + 20);
          unint64_t v74 = *((void *)v46 + 7);
          long long v75 = *((_OWORD *)v46 + 4);
          *(_DWORD *)(a1 + 8) = 0;
          *(_DWORD *)float v15 = 0;
          *(double *)(a1 + 16) = v13;
          if (v11) {
            *(_WORD *)(a1 + 10) = 1;
          }
          else {
            *(_WORD *)(a1 + 8) = 1;
          }
          a2 = buf;
        }
        goto LABEL_45;
      }
      if (*(_DWORD *)(a1 + 148) == *(unsigned __int16 *)(a1 + 146))
      {
        if (qword_1E929D8D8 != -1) {
          dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
        }
        float v32 = qword_1E929D8E0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
        {
          uint64_t v33 = *(unsigned __int16 *)(a1 + 8);
          uint64_t v34 = *(void *)(v8 + 8 * v33);
          unint64_t v35 = v33 + *(unsigned __int16 *)(a1 + 10) - 1;
          unint64_t v36 = *(unsigned int *)(a1 + 12);
          if (v35 < v36) {
            unint64_t v36 = 0;
          }
          uint64_t v37 = *(void *)(v8 + 8 * (v35 - v36));
          *(_DWORD *)int buf = 134218496;
          *(double *)&uint8_t buf[4] = v7;
          *(_WORD *)&uint8_t buf[12] = 2048;
          *(void *)&buf[14] = v34;
          *(_WORD *)&unsigned char buf[22] = 2048;
          *(void *)&uint8_t buf[24] = v37;
          _os_log_impl(&dword_1902AF000, v32, OS_LOG_TYPE_ERROR, "[CMResampleIMUData]:[feedIMUData] Too many consecutive over-closely spaced sampled received. This suggests an input sampling rate anomaly. Input timestamp: %.4f s, First / last timestamp in the buffer : %.4f s / %.4f s . The resampling will still continue but in a non-ideal rate.", buf, 0x20u);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D8D8 != -1) {
            dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
          }
          uint64_t v58 = *(unsigned __int16 *)(a1 + 8);
          uint64_t v59 = *(void *)(v8 + 8 * v58);
          unint64_t v60 = v58 + *(unsigned __int16 *)(a1 + 10) - 1;
          unint64_t v61 = *(unsigned int *)(a1 + 12);
          if (v60 < v61) {
            unint64_t v61 = 0;
          }
          uint64_t v62 = *(void *)(v8 + 8 * (v60 - v61));
          *(_DWORD *)float v69 = 134218496;
          *(double *)&v69[4] = v7;
          *(_WORD *)&v69[12] = 2048;
          *(void *)&v69[14] = v59;
          __int16 v70 = 2048;
          uint64_t v71 = v62;
          float v63 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "BOOL CMResampleIMUData::feedIMUData(const CMRelDM::IMUData &, const uint64_t)", "CoreLocation: %s\n", v63);
          if (v63 != buf) {
            free(v63);
          }
        }
      }
      uint64_t v38 = *(unsigned __int16 *)(a1 + 10);
      unint64_t v39 = *(unsigned int *)(a1 + 12);
      uint64_t v40 = *(unsigned __int16 *)(a1 + 8);
      if (v40 + v38 >= v39) {
        uint64_t v41 = *(unsigned int *)(a1 + 12);
      }
      else {
        uint64_t v41 = 0;
      }
      *(double *)(v8 + 8 * (v40 + v38 - v41)) = v7;
      if (v39 <= v38)
      {
        if (v40 + 1 < v39) {
          LOWORD(v39) = 0;
        }
        *(_WORD *)(a1 + 8) = v40 + 1 - v39;
      }
      else
      {
        *(_WORD *)(a1 + 10) = v38 + 1;
      }
      sub_190512450((unsigned __int16 *)(a1 + 144), v6);
      return 0;
    }
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
    }
    double v19 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = *(unsigned __int16 *)(a1 + 8);
      uint64_t v21 = *(void *)(v8 + 8 * v20);
      unint64_t v22 = v20 + *(unsigned __int16 *)(a1 + 10) - 1;
      unint64_t v23 = *(unsigned int *)(a1 + 12);
      if (v22 < v23) {
        unint64_t v23 = 0;
      }
      uint64_t v24 = *(void *)(v8 + 8 * (v22 - v23));
      *(_DWORD *)int buf = 134218496;
      *(double *)&uint8_t buf[4] = v7;
      *(_WORD *)&uint8_t buf[12] = 2048;
      *(void *)&buf[14] = v21;
      *(_WORD *)&unsigned char buf[22] = 2048;
      *(void *)&uint8_t buf[24] = v24;
      _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_ERROR, "[CMResampleIMUData]:[feedIMUData] Invalid backwards or repeated timestamp, rejecting input. Input timestamp: %.4f s, buffer front: %.4f s, buffer back: %.4f s", buf, 0x20u);
    }
    int v25 = sub_1902D8400(115, 0);
    uint64_t result = 0;
    if (v25)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
      }
      uint64_t v26 = *(unsigned __int16 *)(a1 + 8);
      uint64_t v27 = *(void *)(v8 + 8 * v26);
      unint64_t v28 = v26 + *(unsigned __int16 *)(a1 + 10) - 1;
      unint64_t v29 = *(unsigned int *)(a1 + 12);
      if (v28 < v29) {
        unint64_t v29 = 0;
      }
      uint64_t v30 = *(void *)(v8 + 8 * (v28 - v29));
      *(_DWORD *)float v69 = 134218496;
      *(double *)&v69[4] = v7;
      *(_WORD *)&v69[12] = 2048;
      *(void *)&v69[14] = v27;
      __int16 v70 = 2048;
      uint64_t v71 = v30;
      float v31 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "BOOL CMResampleIMUData::feedIMUData(const CMRelDM::IMUData &, const uint64_t)", "CoreLocation: %s\n", v31);
      if (v31 != buf) {
        free(v31);
      }
      return 0;
    }
  }
  return result;
}

unsigned __int16 *sub_190512450(unsigned __int16 *result, uint64_t a2)
{
  unint64_t v2 = *((unsigned int *)result + 1);
  unint64_t v3 = *result + (unint64_t)result[1];
  if (v3 < v2) {
    unint64_t v2 = 0;
  }
  uint64_t v4 = &result[36 * (v3 - v2)];
  long long v6 = *(_OWORD *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 32);
  uint64_t v7 = *(void *)(a2 + 48);
  *(_OWORD *)(v4 + 4) = *(_OWORD *)a2;
  *((void *)v4 + 7) = v7;
  *(_OWORD *)(v4 + 20) = v5;
  *(_OWORD *)(v4 + 12) = v6;
  *((_OWORD *)v4 + 4) = *(_OWORD *)(a2 + 56);
  unsigned int v8 = result[1];
  unint64_t v9 = *((unsigned int *)result + 1);
  if (v9 <= v8)
  {
    unint64_t v10 = *result + 1;
    if (v10 < v9) {
      LOWORD(v9) = 0;
    }
    *uint64_t result = v10 - v9;
  }
  else
  {
    result[1] = v8 + 1;
  }
  return result;
}

double sub_1905124D0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*(_WORD *)(a1 + 10))
  {
    uint64_t v3 = a1 + 144 + 72 * *(unsigned __int16 *)(a1 + 144);
    long long v4 = *(_OWORD *)(v3 + 24);
    *(_OWORD *)a2 = *(_OWORD *)(v3 + 8);
    *(_OWORD *)(a2 + 16) = v4;
    *(_OWORD *)(a2 + 32) = *(_OWORD *)(v3 + 40);
    *(void *)(a2 + 48) = *(void *)(v3 + 56);
    long long v5 = *(_OWORD *)(v3 + 64);
    *(_OWORD *)(a2 + 56) = v5;
  }
  else
  {
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
    }
    long long v6 = qword_1E929D8E0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_ERROR, "[CMResampleIMUData]:[getResampledIMU] Called getResampledIMU before any valid samples were fed to the resampler. This should not occur under normal conditions. Returning zero-IMU data. This is a serious error, investigate further.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8D8 != -1) {
        dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
      }
      uint64_t v7 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "CMRelDM::IMUData CMResampleIMUData::getResampledIMU() const", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
    *(_DWORD *)(a2 + 32) = 0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(int32x2_t *)(a2 + 36) = vdup_n_s32(0x3A03126Fu);
    *(void *)(a2 + 44) = 973279855;
    *(_OWORD *)(a2 + 52) = xmmword_19060AF90;
    *(_DWORD *)(a2 + 68) = 1065353216;
    *(void *)&long long v5 = sub_1902D9ACC((float32x4_t *)(a2 + 56), (float32x4_t)xmmword_19060AF90).u64[0];
  }
  return *(double *)&v5;
}

unint64_t sub_1905126DC(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (*(_WORD *)(a1 + 10)) {
    return (unint64_t)(*(double *)(a1 + 8 + 8 * *(unsigned __int16 *)(a1 + 8) + 8) * 1000000.0);
  }
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
  }
  unint64_t v2 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_ERROR, "[CMResampleIMUData]:[getResampledTimestampMicroSeconds] Called getResampledTimestampMicroSeconds before any valid samples were fed to the resampler. This should not occur under normal conditions. Returning zero-timestamp. This is a serious error, investigate further.", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD1E80);
    }
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "uint64_t CMResampleIMUData::getResampledTimestampMicroSeconds() const", "CoreLocation: %s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  return 0;
}

os_log_t sub_190512890()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

void sub_1905128E8(uint64_t a1, double a2, uint64_t a3, uint64_t a4)
{
  long long v6 = (void *)(a4 + 24);
  uint64_t v7 = *(void *)(a4 + 24);
  if (v7)
  {
    if (v7 == a4)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v6 + 24))(*v6, a1);
LABEL_7:
      *(void *)(a1 + 32) = 0;
      *(void *)(a1 + 40) = 0;
      *(double *)(a1 + 48) = a2;
      *(unsigned char *)(a1 + 64) = 0;
      operator new();
    }
    *(void *)(a1 + 24) = v7;
  }
  else
  {
    long long v6 = (void *)(a1 + 24);
  }
  *long long v6 = 0;
  goto LABEL_7;
}

void sub_190512ADC(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v2, 0x81C4018A671A6);
  uint64_t v5 = v1[5];
  v1[5] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *v3;
  uint64_t *v3 = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  sub_1904A699C(v1);
  _Unwind_Resume(a1);
}

double sub_190512B7C(double *a1, uint64_t a2)
{
  if (!a1) {
    __assert_rtn("onLidAngleChange", "CLDisplayGravityService.mm", 22, "data");
  }
  if (!a2) {
    __assert_rtn("onLidAngleChange", "CLDisplayGravityService.mm", 23, "info");
  }
  double result = *a1;
  *(double *)(a2 + 56) = *a1;
  return result;
}

void sub_190512BE0(uint64_t *a1, uint64_t a2)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    __assert_rtn("onDeviceMotion", "CLDisplayGravityService.mm", 15, "sample");
  }
  if (!a2) {
    __assert_rtn("onDeviceMotion", "CLDisplayGravityService.mm", 16, "info");
  }
  float v4 = *(double *)(a2 + 56);
  if (v4 < 0.0) {
    float v5 = 180.0;
  }
  else {
    float v5 = *(double *)(a2 + 56);
  }
  float v37 = (float)(180.0 - v5) * -0.017453;
  uint64_t v38 = 0;
  sub_1904CF7FC(&v36, &v37);
  int8x16_t v6 = (int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 1)), *(float64x2_t *)(a1 + 3));
  float32x4_t v35 = (float32x4_t)vextq_s8(v6, v6, 4uLL);
  sub_1902D9ACC(&v35, v35);
  float v7 = sub_1902DAF50((double *)a1 + 1);
  float v9 = v8;
  float v11 = v10;
  float v12 = -v36.f32[0];
  *(float *)&unsigned int v13 = -v36.f32[1];
  __int32 v15 = v36.i32[3];
  v14.i32[0] = v36.i32[2];
  *(float *)&unsigned int v16 = -v36.f32[2];
  *(float *)int buf = -v36.f32[0];
  *(float *)&unsigned int v56 = -v36.f32[1];
  *((float *)&v56 + 1) = -v36.f32[2];
  *(_DWORD *)int v57 = v36.i32[3];
  float32x4_t v17 = sub_1902D9ACC((float32x4_t *)buf, v14);
  *(double *)v18.i64 = sub_1904CF3F4((uint64_t)buf, v35.f32, &v34, v17);
  *(float *)int buf = v12;
  unsigned int v56 = (const char *)__PAIR64__(v16, v13);
  *(_DWORD *)int v57 = v15;
  sub_1902D9ACC((float32x4_t *)buf, v18);
  float v20 = sub_1904CF73C((float *)buf, v7, v9, v11);
  float v22 = v21;
  double v33 = *(double *)a1;
  float64x2_t v28 = vcvtq_f64_f32(*(float32x2_t *)v34.f32);
  double v29 = v34.f32[2];
  double v27 = v34.f32[3];
  float v30 = v20;
  float v31 = v21;
  float v32 = v19;
  uint64_t v23 = *(void *)(a2 + 24);
  if (!v23) {
    sub_19050222C();
  }
  float v24 = v19;
  (*(void (**)(uint64_t, double *))(*(void *)v23 + 48))(v23, &v27);
  if (qword_1E929DA28 != -1) {
    dispatch_once(&qword_1E929DA28, &unk_1EDFD1EA0);
  }
  int v25 = qword_1E929DA30;
  if (os_log_type_enabled((os_log_t)qword_1E929DA30, OS_LOG_TYPE_DEBUG))
  {
    *(float *)int buf = 4.876e-34;
    unsigned int v56 = "void CLDisplayGravityService::notifyDeviceMotion(const CLDeviceMotion::Sample &)";
    *(_WORD *)int v57 = 2050;
    *(double *)&v57[2] = v7;
    __int16 v58 = 2050;
    double v59 = v9;
    __int16 v60 = 2050;
    double v61 = v11;
    __int16 v62 = 2050;
    double v63 = v5;
    __int16 v64 = 2050;
    double v65 = v20;
    __int16 v66 = 2050;
    double v67 = v22;
    __int16 v68 = 2050;
    double v69 = v24;
    _os_log_impl(&dword_1902AF000, v25, OS_LOG_TYPE_DEBUG, "[CLDisplayGravityService] %{public}s : gravity=%{public}f, %{public}f ,%{public}f, lidAngleDeg=%{public}f, gravityCameraFrame=%{public}f, %{public}f ,%{public}f", buf, 0x52u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929DA28 != -1) {
      dispatch_once(&qword_1E929DA28, &unk_1EDFD1EA0);
    }
    int v39 = 136448002;
    uint64_t v40 = "void CLDisplayGravityService::notifyDeviceMotion(const CLDeviceMotion::Sample &)";
    __int16 v41 = 2050;
    double v42 = v7;
    __int16 v43 = 2050;
    double v44 = v9;
    __int16 v45 = 2050;
    double v46 = v11;
    __int16 v47 = 2050;
    double v48 = v5;
    __int16 v49 = 2050;
    double v50 = v20;
    __int16 v51 = 2050;
    double v52 = v22;
    __int16 v53 = 2050;
    double v54 = v24;
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLDisplayGravityService::notifyDeviceMotion(const CLDeviceMotion::Sample &)", "CoreLocation: %s\n", v26);
    if (v26 != (char *)buf) {
      free(v26);
    }
  }
}

void *sub_190512FF4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64)) {
    sub_19051309C(a1);
  }
  uint64_t v2 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }

  return sub_1904A699C((void *)a1);
}

void sub_19051309C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v2 = sub_1904EF618();
    sub_1902CDE08(v2, 0, *(void *)(a1 + 40));
    uint64_t v3 = sub_1902B35C0();
    sub_1902E02F4(v3, *(void *)(a1 + 32));
    *(unsigned char *)(a1 + 64) = 0;
  }
}

void sub_190513114(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 64) && (sub_1902BB1DC() & 4) != 0)
  {
    if (sub_1904EF618())
    {
      uint64_t v2 = sub_1904EF618();
      sub_1902B1FEC(v2, 0, *(void *)(a1 + 40), -1.0);
      uint64_t v3 = sub_1902B35C0();
      sub_1902E0374(v3, *(void *)(a1 + 32), *(double *)(a1 + 48));
      *(unsigned char *)(a1 + 64) = 1;
    }
  }
}

os_log_t sub_190513178()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "DisplayGravity");
  qword_1E929DA30 = (uint64_t)result;
  return result;
}

void sub_1905131AC(uint64_t a1)
{
  sub_1902BC548(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_1905131E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 16))(a3, *(void *)(a1 + 24));
}

void *sub_190513328(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  a1[2] = 0;
  a1[3] = 0;
  sub_190513384();
  return a1;
}

void sub_19051336C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_1902D8B58(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_190513384()
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  uint64_t result = sub_1902D6BD0();
  if (Current != *(CFRunLoopRef *)qword_1EB3BF828)
  {
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    uint64_t v2 = qword_1E929D6F0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 68289539;
      int v6 = 0;
      __int16 v7 = 2082;
      float v8 = "";
      __int16 v9 = 2082;
      float v10 = "assert";
      __int16 v11 = 2081;
      float v12 = "runningOnMotionThread";
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CLSPUHIDDriverInterface calls must be made on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1E929D700 != -1) {
        dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
      }
    }
    uint64_t v3 = qword_1E929D6F0;
    if (os_signpost_enabled((os_log_t)qword_1E929D6F0))
    {
      *(_DWORD *)int buf = 68289539;
      int v6 = 0;
      __int16 v7 = 2082;
      float v8 = "";
      __int16 v9 = 2082;
      float v10 = "assert";
      __int16 v11 = 2081;
      float v12 = "runningOnMotionThread";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v3, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLSPUHIDDriverInterface calls must be made on motion thread", "{\"msg%{public}.0s\":\"CLSPUHIDDriverInterface calls must be made on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1E929D700 != -1) {
        dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
      }
    }
    float v4 = qword_1E929D6F0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)int buf = 68289539;
      int v6 = 0;
      __int16 v7 = 2082;
      float v8 = "";
      __int16 v9 = 2082;
      float v10 = "assert";
      __int16 v11 = 2081;
      float v12 = "runningOnMotionThread";
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CLSPUHIDDriverInterface calls must be made on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
  return result;
}

void *sub_190513600(void *a1)
{
  sub_190513638(a1);
  uint64_t v2 = (std::__shared_weak_count *)a1[1];
  if (v2) {
    sub_1902D8B58(v2);
  }
  return a1;
}

void sub_190513638(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  sub_190513384();
  if (!*a1) {
    return;
  }
  if (qword_1E929D700 != -1) {
    dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
  }
  uint64_t v2 = qword_1E929D6F0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEBUG, "[CLSPUHIDDriverInterface] Close hid driver interface", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    __int16 v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLSPUHIDDriverInterface::closeHIDDriverInterface()", "CoreLocation: %s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  uint64_t v3 = (IOCFPlugInInterface **)a1[2];
  uint64_t v4 = a1[3];
  float v5 = a1 + 2;
  if (v4)
  {
    (*(void (**)(void, void))(*(void *)v4 + 72))(a1[3], 0);
    if (!v3) {
      goto LABEL_12;
    }
  }
  else if (!v3)
  {
    *(void *)(*a1 + 8) = 0;
    *float v5 = 0;
    a1[3] = 0;
    return;
  }
  ((void (*)(IOCFPlugInInterface **))(*v3)->Release)(v3);
  IODestroyPlugInInterface(v3);
LABEL_12:
  *(void *)(*a1 + 8) = 0;
  *float v5 = 0;
  a1[3] = 0;
  if (qword_1E929D700 != -1) {
    dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
  }
  int v6 = qword_1E929D6F0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = a1[2];
    uint64_t v8 = a1[3];
    *(_DWORD *)int buf = 134218752;
    float v12 = v3;
    __int16 v13 = 2048;
    uint64_t v14 = v4;
    __int16 v15 = 2048;
    uint64_t v16 = v7;
    __int16 v17 = 2048;
    uint64_t v18 = v8;
    _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "[CLSPUHIDDriverInterface] Closed hid driver interface, {cfPlugInInterface, hidDriverInterface} was then {%p,%p}, is now {%p,%p}", buf, 0x2Au);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    float v10 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLSPUHIDDriverInterface::closeHIDDriverInterface()", "CoreLocation: %s\n", v10);
    if (v10 != (char *)buf) {
      free(v10);
    }
  }
}

void sub_1905139C0(uint64_t *a1)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  sub_190513384();
  if (qword_1E929D700 != -1) {
    dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
  }
  uint64_t v2 = qword_1E929D6F0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEBUG, "[CLSPUHIDDriverInterface] Open hid driver interface", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    LOWORD(v49) = 0;
    float v37 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "CoreLocation: %s\n", v37);
    if (v37 != (char *)buf) {
      free(v37);
    }
  }
  uint64_t v3 = *a1;
  if (!*a1) {
    return;
  }
  theInterface = 0;
  uint64_t valuePtr = 0;
  uint64_t v46 = 0;
  uint64_t v4 = (__IOHIDServiceClient *)sub_1902B8788(v3);
  if (!v4)
  {
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    uint64_t v19 = qword_1E929D6F0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_INFO, "[CLSPUHIDDriverInterface] IoHidDevice is not ready", buf, 2u);
    }
    if (!sub_1902D8400(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    LOWORD(v49) = 0;
    uint64_t v18 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "CoreLocation: %s\n");
LABEL_35:
    if (v18 == buf) {
      return;
    }
    goto LABEL_36;
  }
  float v5 = v4;
  CFNumberRef RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(v4);
  CFNumberGetValue(RegistryID, kCFNumberSInt64Type, &valuePtr);
  mach_port_t v7 = *MEMORY[0x1E4F2EEF0];
  CFDictionaryRef v8 = IORegistryEntryIDMatching(valuePtr);
  io_service_t MatchingService = IOServiceGetMatchingService(v7, v8);
  if (!MatchingService)
  {
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    float v20 = qword_1E929D6F0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v20, OS_LOG_TYPE_FAULT, "[CLSPUHIDDriverInterface] Service doesn't exist", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    LOWORD(v49) = 0;
    uint64_t v18 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "CoreLocation: %s\n");
    goto LABEL_35;
  }
  io_service_t v10 = MatchingService;
  SInt32 theScore = 0;
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CFB0];
  CFUUIDRef v12 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], 0x3Bu, 0xC5u, 0xCCu, 0x87u, 0x84u, 0x5Eu, 0x48u, 0xABu, 0xA9u, 0xC2u, 0x94u, 0x36u, 0, 0x1Bu, 0xA6u, 0x8Au);
  CFUUIDRef v13 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  mach_error_t v14 = IOCreatePlugInInterfaceForService(v10, v12, v13, &theInterface, &theScore);
  IOObjectRelease(v10);
  if (v14)
  {
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    __int16 v15 = qword_1E929D6F0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_FAULT))
    {
      uint64_t v16 = mach_error_string(v14);
      *(_DWORD *)int buf = 67240706;
      *(_DWORD *)unsigned int v56 = v14;
      *(_WORD *)&v56[4] = 2082;
      *(void *)&v56[6] = v16;
      *(_WORD *)&v56[14] = 2114;
      *(void *)&v56[16] = v5;
      _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_FAULT, "[CLSPUHIDDriverInterface] Unable to create plugin interface,retCode,0x%{public}x,retStr,%{public}s,service,%{public}@", buf, 0x1Cu);
    }
    if (!sub_1902D8400(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    __int16 v17 = mach_error_string(v14);
    int v49 = 67240706;
    *(_DWORD *)double v50 = v14;
    *(_WORD *)&v50[4] = 2082;
    *(void *)&v50[6] = v17;
    *(_WORD *)&v50[14] = 2114;
    *(void *)&v50[16] = v5;
    uint64_t v18 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "CoreLocation: %s\n", (const char *)v18);
    if (v18 == buf) {
      return;
    }
LABEL_36:
    free(v18);
    return;
  }
  float v21 = theInterface;
  QueryInterface = (*theInterface)->QueryInterface;
  CFUUIDRef v23 = CFUUIDGetConstantUUIDWithBytes(v11, 0x6Eu, 0xBEu, 0xBAu, 0x6Eu, 9u, 0x1Eu, 0x45u, 0x2Eu, 0x82u, 0xEAu, 0x29u, 0x79u, 0x81u, 0x6Fu, 0xB1u, 0xB5u);
  CFUUIDBytes v24 = CFUUIDGetUUIDBytes(v23);
  mach_error_t v25 = ((uint64_t (*)(IOCFPlugInInterface **, void, void, uint64_t *))QueryInterface)(v21, *(void *)&v24.byte0, *(void *)&v24.byte8, &v46);
  if (v25)
  {
    mach_error_t v26 = v25;
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    double v27 = qword_1E929D6F0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_FAULT))
    {
      float64x2_t v28 = mach_error_string(v26);
      *(_DWORD *)int buf = 67240706;
      *(_DWORD *)unsigned int v56 = v26;
      *(_WORD *)&v56[4] = 2082;
      *(void *)&v56[6] = v28;
      *(_WORD *)&v56[14] = 2114;
      *(void *)&v56[16] = v5;
      _os_log_impl(&dword_1902AF000, v27, OS_LOG_TYPE_FAULT, "[CLSPUHIDDriverInterface] Unable to set up query interface,retCode,0x%{public}x,retStr,%{public}s,service,%{public}@", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D700 != -1) {
        dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
      }
      uint64_t v38 = mach_error_string(v26);
      int v49 = 67240706;
      *(_DWORD *)double v50 = v26;
      *(_WORD *)&v50[4] = 2082;
      *(void *)&v50[6] = v38;
      *(_WORD *)&v50[14] = 2114;
      *(void *)&v50[16] = v5;
      int v39 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "CoreLocation: %s\n", v39);
      if (v39 != (char *)buf) {
        free(v39);
      }
    }
LABEL_43:
    if (theInterface)
    {
      ((void (*)(IOCFPlugInInterface **))(*theInterface)->Release)(theInterface);
      IODestroyPlugInInterface(theInterface);
    }
    return;
  }
  mach_error_t v29 = (*(uint64_t (**)(uint64_t, void))(*(void *)v46 + 64))(v46, 0);
  if (v29)
  {
    mach_error_t v30 = v29;
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    float v31 = qword_1E929D6F0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_FAULT))
    {
      float v32 = mach_error_string(v30);
      *(_DWORD *)int buf = 67240706;
      *(_DWORD *)unsigned int v56 = v30;
      *(_WORD *)&v56[4] = 2082;
      *(void *)&v56[6] = v32;
      *(_WORD *)&v56[14] = 2114;
      *(void *)&v56[16] = v5;
      _os_log_impl(&dword_1902AF000, v31, OS_LOG_TYPE_FAULT, "[CLSPUHIDDriverInterface] Unable to open hid driver interface,retCode,0x%{public}x,retStr,%{public}s,service,%{public}@", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D700 != -1) {
        dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
      }
      uint64_t v40 = mach_error_string(v30);
      int v49 = 67240706;
      *(_DWORD *)double v50 = v30;
      *(_WORD *)&v50[4] = 2082;
      *(void *)&v50[6] = v40;
      *(_WORD *)&v50[14] = 2114;
      *(void *)&v50[16] = v5;
      __int16 v41 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "CoreLocation: %s\n", v41);
      if (v41 != (char *)buf) {
        free(v41);
      }
    }
    if (v46) {
      (*(void (**)(uint64_t, void))(*(void *)v46 + 72))(v46, 0);
    }
    goto LABEL_43;
  }
  if (qword_1E929D700 != -1) {
    dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
  }
  double v33 = qword_1E929D6F0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = a1[2];
    uint64_t v35 = a1[3];
    *(_DWORD *)int buf = 134219008;
    *(void *)unsigned int v56 = valuePtr;
    *(_WORD *)&v56[8] = 2048;
    *(void *)&v56[10] = v34;
    *(_WORD *)&v56[18] = 2048;
    *(void *)&v56[20] = v35;
    __int16 v57 = 2048;
    __int16 v58 = theInterface;
    __int16 v59 = 2048;
    uint64_t v60 = v46;
    _os_log_impl(&dword_1902AF000, v33, OS_LOG_TYPE_DEFAULT, "[CLSPUHIDDriverInterface] Opened hid driver interface, registryID %llx, {cfPlugInInterface, hidDriverInterface} was then {%p,%p}, is now {%p,%p}", buf, 0x34u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    uint64_t v42 = a1[2];
    uint64_t v43 = a1[3];
    int v49 = 134219008;
    *(void *)double v50 = valuePtr;
    *(_WORD *)&v50[8] = 2048;
    *(void *)&v50[10] = v42;
    *(_WORD *)&v50[18] = 2048;
    *(void *)&v50[20] = v43;
    __int16 v51 = 2048;
    double v52 = theInterface;
    __int16 v53 = 2048;
    uint64_t v54 = v46;
    double v44 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "CoreLocation: %s\n", v44);
    if (v44 != (char *)buf) {
      free(v44);
    }
  }
  *(void *)(*a1 + 8) = valuePtr;
  uint64_t v36 = v46;
  a1[2] = (uint64_t)theInterface;
  a1[3] = v36;
}

uint64_t sub_1905145B0(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D700 != -1) {
    dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
  }
  io_service_t v10 = qword_1E929D6F0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)int buf = 134217984;
    float v20 = a3;
    _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_DEBUG, "[CLSPUHIDDriverInterface] Attempting to send command with reply to SPU,length,%zu", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "IOReturn CLSPUHIDDriverInterface::sendCommand(const void *, size_t, void *, size_t *)", "CoreLocation: %s\n", v18);
    if (v18 != (char *)buf) {
      free(v18);
    }
  }
  uint64_t v11 = *(void *)(a1 + 24);
  if (v11)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t, uint64_t))(*(void *)v11 + 80))(v11, a2, a3, a4, a5);
    if (v12)
    {
      if (qword_1E929D700 != -1) {
        dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
      }
      CFUUIDRef v13 = qword_1E929D6F0;
      if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_FAULT))
      {
        mach_error_t v14 = mach_error_string(v12);
        *(_DWORD *)int buf = 136446466;
        float v20 = v14;
        __int16 v21 = 1026;
        int v22 = v12;
        _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_FAULT, "[CLSPUHIDDriverInterface] sendCommand() = %{public}s (0x%{public}x)", buf, 0x12u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D700 != -1) {
          dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
        }
        mach_error_string(v12);
        __int16 v15 = (uint8_t *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "IOReturn CLSPUHIDDriverInterface::sendCommand(const void *, size_t, void *, size_t *)", "CoreLocation: %s\n");
LABEL_29:
        if (v15 != buf) {
          free(v15);
        }
      }
    }
  }
  else
  {
    if (qword_1E929D700 != -1) {
      dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
    }
    uint64_t v16 = qword_1E929D6F0;
    if (os_log_type_enabled((os_log_t)qword_1E929D6F0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_INFO, "[CLSPUHIDDriverInterface] hidDriverInterface NULL, unable to send command", buf, 2u);
    }
    uint64_t v12 = 3758097084;
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D700 != -1) {
        dispatch_once(&qword_1E929D700, &unk_1EDFD1EC0);
      }
      __int16 v15 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "IOReturn CLSPUHIDDriverInterface::sendCommand(const void *, size_t, void *, size_t *)", "CoreLocation: %s\n");
      goto LABEL_29;
    }
  }
  return v12;
}

os_log_t sub_190514A34()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "AOP");
  qword_1E929D6F0 = (uint64_t)result;
  return result;
}

void sub_190514A64(uint64_t a1, void *a2, uint64_t a3, double *a4, char a5)
{
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1EDFC96B0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 9) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0x3FF0000000000000;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0x7FEFFFFFFFFFFFFFLL;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 168) = _Q0;
  *(_OWORD *)(a1 + 184) = _Q0;
  *(void *)(a1 + 200) = 0xBFF0000000000000;
  uint64_t v10 = (int)(0.100000001 / *a4);
  *(void *)(a1 + 208) = &unk_1EDFC93B0;
  *(void *)(a1 + 216) = v10;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(void *)(a1 + 272) = 0;
  uint64_t v11 = (int)(0.100000001 / *a4);
  *(void *)(a1 + 280) = &unk_1EDFC93B0;
  *(void *)(a1 + 288) = v11;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 432) = 0;
  *(_WORD *)(a1 + 440) = 0;
  *(unsigned char *)(a1 + 472) = a5;
  *(void *)(a1 + 480) = *a2;
  *(double *)(a1 + 488) = *a4;
  *(_DWORD *)(a1 + 496) = 4;
  *(void *)(a1 + 504) = 0x3FA0A3D70A3D70A4;
  *(unsigned char *)(a1 + 512) = 1;
  *(void *)(a1 + 520) = &unk_1EDFC93B0;
  *(void *)(a1 + 528) = 100;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(void *)(a1 + 584) = 0;
  *(void *)(a1 + 592) = &unk_1EDFC8F88;
  *(void *)(a1 + 600) = 20;
  *(void *)(a1 + 608) = &unk_1EDFC9390;
  *(void *)(a1 + 616) = 20;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(void *)(a1 + 688) = &unk_1EDFC9390;
  *(void *)(a1 + 696) = 20;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(void *)(a1 + 768) = &unk_1EDFC9390;
  *(void *)(a1 + 776) = 20;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_DWORD *)(a1 + 888) = 0;
  *(void *)(a1 + 896) = 0xBFF0000000000000;
  *(_DWORD *)(a1 + 904) = 0;
  operator new[]();
}

void sub_1905152E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  sub_1904D5F08(v15);
  v14[65] = a12;
  sub_1902D5B70(v14 + 68);
  v14[35] = a13;
  sub_1902D5B70(v14 + 38);
  v14[26] = a14;
  sub_1902D5B70(v14 + 29);
  _Unwind_Resume(a1);
}

void *sub_190515334(void *a1)
{
  *a1 = &unk_1EDFC96B0;
  uint64_t v2 = a1[16];
  if (v2) {
    MEMORY[0x192FCC960](v2, 0x1000C8052888210);
  }
  sub_1904D5F08(a1 + 74);
  a1[65] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 68);
  a1[35] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 38);
  a1[26] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 29);
  return a1;
}

void sub_190515414(void *a1)
{
  sub_190515334(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19051544C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 8);
}

void sub_190515454(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 11) = 0;
  bzero((void *)(a1 + 16), 0x20uLL);
  *(void *)(a1 + 40) = 0x3FF0000000000000;
  bzero((void *)(a1 + 64), 0x30uLL);
  bzero(*(void **)(a1 + 120), 0x18uLL);
  bzero(*(void **)(a1 + 112), 0x3CuLL);
  uint64_t v2 = *(void *)(a1 + 120);
  memset_pattern16((void *)v2, &unk_19060B340, 0xCuLL);
  memset_pattern16((void *)(v2 + 12), &unk_19060B350, 0xCuLL);
  *(unsigned char *)(a1 + 12) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 168) = _Q0;
  *(void *)(a1 + 184) = 0xBFF0000000000000;
  bzero((void *)(a1 + 352), 0xCuLL);
  bzero((void *)(a1 + 364), 0xCuLL);
  bzero((void *)(a1 + 376), 0x18uLL);
  bzero((void *)(a1 + 156), 0xCuLL);
  bzero((void *)(a1 + 136), 0xCuLL);
  *(_DWORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  bzero((void *)(a1 + 448), 0x18uLL);
  bzero((void *)(a1 + 400), 0x18uLL);
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 432) = 0;
  *(_WORD *)(a1 + 440) = 0;
  bzero((void *)(a1 + 848), 0xCuLL);
  bzero((void *)(a1 + 864), 0x18uLL);
  *(_DWORD *)(a1 + 888) = 0;
  *(void *)(a1 + 896) = 0xBFF0000000000000;
  *(_DWORD *)(a1 + 904) = 0;
  sub_1904D5FC0((void *)(a1 + 608));
  sub_1904D5FC0((void *)(a1 + 688));
  sub_1904D5FC0((void *)(a1 + 768));
  sub_1902B5164((void *)(a1 + 520));
  sub_1902B5164((void *)(a1 + 208));
  sub_1902B5164((void *)(a1 + 280));
  if (qword_1EB3BE878 != -1) {
    dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
  }
  CFDictionaryRef v8 = off_1EB3BE870;
  if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v9 = *(void *)(a1 + 600);
    *(_DWORD *)int buf = 134217984;
    uint64_t v12 = v9;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEBUG, "fAccelBuffer,size,%zu", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
    }
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::reset()", "CoreLocation: %s\n", v10);
    if (v10 != (char *)buf) {
      free(v10);
    }
  }
}

BOOL sub_19051573C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  int v2 = *(unsigned __int8 *)(a1 + 9);
  if (*(unsigned char *)(a1 + 9))
  {
    *(float32x2_t *)a2 = vcvt_f32_f64(*(float64x2_t *)(a1 + 376));
    float v3 = *(double *)(a1 + 392);
    *(float *)(a2 + 8) = v3;
  }
  return v2 != 0;
}

void sub_190515774(uint64_t a1, float64x2_t *a2, uint64_t a3, double *a4, void *a5)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 168) = *a5;
  ++*(_DWORD *)(a1 + 152);
  float v7 = *a4;
  float32x2_t v8 = vcvt_f32_f64(vsubq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(*a2), (float32x2_t)vdup_n_s32(0x3C8EFA35u))), *(float64x2_t *)(a1 + 88)));
  float v9 = (float)(v7 * 0.017453) - *(double *)(a1 + 104);
  *(float32x2_t *)(a1 + 156) = v8;
  *(float *)(a1 + 164) = v9;
  float v10 = v8.f32[1];
  float32x2_t v29 = v8;
  float v30 = sqrtf(vmlas_n_f32(vmuls_lane_f32(v8.f32[1], v8, 1), v8.f32[0], v8.f32[0]) + (float)(v9 * v9));
  sub_1902D9094(a1 + 520, &v30);
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
    }
    uint64_t v11 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 134218752;
      double v37 = (float)(v30 / 0.017453);
      __int16 v38 = 2048;
      double v39 = (float)(v29.f32[0] / 0.017453);
      __int16 v40 = 2048;
      double v41 = (float)(v10 / 0.017453);
      __int16 v42 = 2048;
      double v43 = (float)(v9 / 0.017453);
      _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_DEBUG, "omegaMag9, %.3f, omega, %.3f, %.3f, %.3f", buf, 0x2Au);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      *(_DWORD *)float v31 = 134218752;
      *(double *)&v31[4] = (float)(v30 / 0.017453);
      *(_WORD *)&v31[12] = 2048;
      *(double *)&v31[14] = (float)(v29.f32[0] / 0.017453);
      *(_WORD *)&unsigned char v31[22] = 2048;
      *(double *)&v31[24] = (float)(v10 / 0.017453);
      __int16 v32 = 2048;
      double v33 = (float)(v9 / 0.017453);
      __int16 v21 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedGyroData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
    }
  }
  double v28 = *(double *)(a1 + 480);
  float64x2_t v46 = vmulq_n_f64(vcvtq_f64_f32(v29), v28);
  double v47 = v28 * v9;
  sub_190516B90((double *)buf, v46.f64);
  sub_1904D39A0((double *)v31, (double *)buf, (double *)(a1 + 16));
  long long v12 = *(_OWORD *)&v31[16];
  *(_OWORD *)(a1 + 16) = *(_OWORD *)v31;
  *(_OWORD *)(a1 + 32) = v12;
  float32x2_t v13 = vadd_f32(*(float32x2_t *)(a1 + 136), v29);
  *(float32x2_t *)(a1 + 136) = v13;
  *(float *)&long long v12 = *(float *)(a1 + 144) + v9;
  *(_DWORD *)(a1 + 144) = v12;
  ++*(_DWORD *)(a1 + 148);
  double v14 = v28
      * (v28
       * (float)(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v13, v13).i32[1]), v13.f32[0], v13.f32[0])
               + (float)(*(float *)&v12 * *(float *)&v12)));
  if (v14 > 0.122500002) {
    sub_190515CC0(a1, v14, (int32x2_t)0x3FBF5C2900000000);
  }
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    __int16 v15 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v16 = *(double *)(a1 + 16);
      double v17 = *(double *)(a1 + 24);
      double v18 = *(double *)(a1 + 32);
      double v19 = *(double *)(a1 + 40);
      uint64_t v20 = *a5;
      *(_DWORD *)int buf = 134219008;
      double v37 = v16;
      __int16 v38 = 2048;
      double v39 = v17;
      __int16 v40 = 2048;
      double v41 = v18;
      __int16 v42 = 2048;
      double v43 = v19;
      __int16 v44 = 2048;
      uint64_t v45 = v20;
      _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_DEBUG, "[AppleQuaternion9] x,%f,y,%f,z,%f,w,%f,timestamp,%f", buf, 0x34u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      uint64_t v22 = *(void *)(a1 + 16);
      uint64_t v23 = *(void *)(a1 + 24);
      uint64_t v24 = *(void *)(a1 + 32);
      double v25 = *(double *)(a1 + 40);
      uint64_t v26 = *a5;
      *(_DWORD *)float v31 = 134219008;
      *(void *)&v31[4] = v22;
      *(_WORD *)&v31[12] = 2048;
      *(void *)&v31[14] = v23;
      *(_WORD *)&unsigned char v31[22] = 2048;
      *(void *)&v31[24] = v24;
      __int16 v32 = 2048;
      double v33 = v25;
      __int16 v34 = 2048;
      uint64_t v35 = v26;
      double v27 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedGyroData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v27);
      if (v27 != (char *)buf) {
        free(v27);
      }
    }
  }
}

uint64_t sub_190515CC0(uint64_t result, double a2, int32x2_t a3)
{
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  int v3 = *(_DWORD *)(result + 148);
  if (v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = result + 136;
    *(float *)a3.i32 = (float)v3;
    int32x2_t v102 = a3;
    float v6 = *(float *)(result + 136) / (float)v3;
    double v7 = *(double *)(result + 480) * (double)v3;
    *(_DWORD *)(result + 148) = 0;
    double v101 = exp(v7 / -5000.0);
    float32x2_t v100 = vdiv_f32(*(float32x2_t *)(v5 + 4), (float32x2_t)vdup_lane_s32(v102, 0));
    bzero((void *)v5, 0xCuLL);
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    float32x2_t v10 = v100;
    *(float64x2_t *)(v5 - 48) = vmulq_n_f64(*(float64x2_t *)(v5 - 48), v101);
    *(double *)(v5 - 32) = v101 * *(double *)(v5 - 32);
    v120[0] = 0;
    v120[1] = v100.i32[1];
    float32x2_t v121 = vneg_f32(v100);
    int v122 = 0;
    float v123 = v6;
    __int32 v124 = v100.i32[0];
    float v125 = -v6;
    int v126 = 0;
    float v11 = vmul_f32(v10, v10).f32[0];
    float v12 = vmuls_lane_f32(v100.f32[1], v100, 1);
    v112[0] = -(float)(v11 + v12);
    v112[1] = v6 * v100.f32[0];
    float v113 = vmuls_lane_f32(v6, v100, 1);
    float v114 = v6 * v100.f32[0];
    float v115 = -(float)((float)(v6 * v6) + v12);
    float v116 = vmuls_lane_f32(v10.f32[0], v10, 1);
    float v117 = v113;
    float v118 = v116;
    v100.f32[0] = v11;
    float v119 = -(float)((float)(v6 * v6) + v11);
    float v13 = v7;
    float v14 = -v13;
    double v15 = v7 * v7 * 0.5;
    float v16 = v15;
    do
    {
      for (uint64_t i = 0; i != 3; ++i)
        *(float *)&v107[v8 * 4 + i * 4] = (float)(v112[v8 + i] * v16) + (float)(v14 * *(float *)&v120[v8 + i]);
      *(float *)&v107[16 * v9] = *(float *)&v107[16 * v9] + 1.0;
      ++v9;
      v8 += 3;
    }
    while (v9 != 3);
    uint64_t v18 = 0;
    double v19 = v110;
    do
    {
      *(void *)double v19 = *(void *)&v107[v18];
      void v19[2] = *(float *)&v107[v18 + 8];
      v18 += 12;
      v19 += 6;
    }
    while (v18 != 36);
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    float v22 = v15 / 5000.0 - v7;
    do
    {
      for (uint64_t j = 0; j != 3; ++j)
        *(float *)&v107[v20 * 4 + j * 4] = *(float *)&v120[v20 + j] * v16;
      *(float *)&v107[16 * v21] = *(float *)&v107[16 * v21] + v22;
      ++v21;
      v20 += 3;
    }
    while (v21 != 3);
    uint64_t v24 = 0;
    double v25 = &v111;
    do
    {
      *double v25 = *(void *)&v107[v24];
      *((_DWORD *)v25 + 2) = *(_DWORD *)&v107[v24 + 8];
      v24 += 12;
      v25 += 3;
    }
    while (v24 != 36);
    for (uint64_t k = 3; k != 21; k += 6)
      bzero(&v110[k], 0xCuLL);
    for (uint64_t m = 21; m != 39; m += 6)
    {
      bzero(&v110[m], 0xCuLL);
      float v27 = v101;
      v110[k] = v27;
      k += 7;
    }
    uint64_t v29 = 0;
    uint64_t v30 = *(void *)(v4 + 112);
    float v31 = v110;
    do
    {
      uint64_t v32 = v29 + 30;
      uint64_t v33 = 5;
      LODWORD(v34) = 6;
      do
      {
        uint64_t v35 = 0;
        int v36 = v34 - 2;
        unint64_t v34 = v33;
        float v37 = v110[v32];
        uint64_t v38 = v30 + 4 * (v36 * (int)v33 / 2);
        double v39 = v31;
        do
        {
          float v40 = *v39;
          v39 += 6;
          float v37 = v37 + (float)(v40 * *(float *)(v38 + 4 * v35++));
        }
        while (v34 != v35);
        v110[v32] = v37;
        uint64_t v33 = v34 - 1;
        uint64_t v32 = v29 + 6 * (v34 - 1);
      }
      while (v34 > 1);
      ++v29;
      ++v31;
    }
    while (v29 != 6);
    uint64_t v41 = 0;
    double v42 = 2.76135698e-10
        / (7.0
         / (exp((0.11 - sqrtf((float)(v100.f32[0] + (float)(v6 * v6)) + (float)(v100.f32[1] * v100.f32[1]))) / 0.012)
          + 1.0)
         + 1.0);
    __int16 v44 = (float *)v107;
    do
    {
      bzero(&v107[v41], 0xCuLL);
      float v43 = (v7 * -0.25 / 5000.0 + 0.333333333) * (v7 * (v7 * (v7 * v42)))
          + (float)(*(float *)v102.i32 * 0.00000021323) * 0.5 * v7;
      *__int16 v44 = v43;
      v44 += 7;
      v41 += 24;
    }
    while (v41 != 72);
    double v45 = expm1(-(v7 / 5000.0));
    long double v46 = exp(-(v7 / 5000.0));
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    long double v49 = v42 * -0.5 * 1.24999999e11 * (v46 * (v7 / 5000.0 * (v7 / 5000.0) + v7 / 5000.0 * 2.0) + v45 * 2.0);
    float v50 = v46 * (v7 * (v7 * (v42 * -0.5)));
    float v51 = v49;
    do
    {
      for (uint64_t n = 0; n != 3; ++n)
        v106[v47 + n] = *(float *)&v120[v47 + n] * v51;
      v106[4 * v48] = v106[4 * v48] + v50;
      ++v48;
      v47 += 3;
    }
    while (v48 != 3);
    __int16 v53 = &v108;
    uint64_t v54 = &v109;
    unsigned int v55 = v106;
    uint64_t v56 = 3;
    do
    {
      uint64_t v57 = 0;
      __int16 v58 = v53;
      do
      {
        float v59 = v55[v57];
        *(float *)((char *)v54 + v57 * 4) = v59;
        *(float *)__int16 v58 = v59;
        v58 += 6;
        ++v57;
      }
      while (v57 != 3);
      ++v56;
      ++v53;
      v54 += 3;
      v55 += 3;
    }
    while (v56 != 6);
    float v60 = (1.0 - exp(v7 * -2.0 / 5000.0)) * (v42 * 5000.0) * 0.5;
    uint64_t v61 = 84;
    for (iuint64_t i = 84; ii != 156; ii += 24)
    {
      bzero(&v107[ii], 0xCuLL);
      *(float *)&v107[v61] = v60;
      v61 += 28;
    }
    bzero(v106, 0x3CuLL);
    bzero(v105, 0x18uLL);
    uint64_t v63 = 0;
    uint64_t v64 = 4;
    for (juint64_t j = 5; ; --jj)
    {
      float v66 = *(float *)&v107[24 * (int)jj + 4 * jj];
      if (jj > 4)
      {
        v105[jj] = v66;
      }
      else
      {
        uint64_t v67 = v63;
        do
        {
          float v68 = v106[jj + ((int)v67 + 5) * ((int)v67 + 6) / 2];
          float v66 = v66 + (float)((float)-(float)(v68 * v68) * v105[v67++ + 6]);
        }
        while (v67);
        v105[jj] = v66;
        if (jj < 1)
        {
          uint64_t v73 = 0;
          uint64_t v74 = *(void *)(v4 + 120);
          uint64_t v75 = 6;
          uint64_t v76 = 5;
          uint64_t v77 = 5;
          os_log_t result = v74;
          while (1)
          {
            uint64_t v78 = 0;
            uint64_t v79 = v75 - 1;
            float v80 = 0.0;
            uint64_t v81 = v77 * 4;
            do
            {
              float v80 = v80
                  + (float)((float)(*(float *)((char *)v110 + v81) * *(float *)((char *)v110 + v81))
                          * *(float *)(v74 + v78));
              v78 += 4;
              v81 += 24;
            }
            while (v78 != 24);
            if (v75 > 5)
            {
              float v84 = v105[v79];
              float v85 = v80 + v84;
              *((float *)&v103 + v79) = v85;
            }
            else
            {
              uint64_t v82 = v73;
              do
              {
                float v83 = v106[v79 + ((int)v82 + 5) * ((int)v82 + 6) / 2];
                float v80 = v80 + (float)((float)(v83 * v83) * v105[v82++ + 6]);
              }
              while (v82);
              float v84 = v105[v79];
              float v85 = v80 + v84;
              *((float *)&v103 + v79) = v85;
              if (v75 < 2)
              {
                *(_OWORD *)os_log_t result = v103;
                *(void *)(result + 16) = v104;
                return result;
              }
            }
            uint64_t v86 = 0;
            uint64_t v87 = 0;
            os_log_t result = *(void *)(v4 + 120);
            uint64_t v88 = (uint64_t)(int)(v79 * (v75 - 2) + ((int)v79 * ((int)v75 - 2) < 0)) >> 1;
            do
            {
              uint64_t v89 = 0;
              float v90 = 0.0;
              float32x4_t v91 = v110;
              do
              {
                float v90 = v90 + (float)((float)(v91[v77] * *(float *)(result + v89)) * v91[v86]);
                v89 += 4;
                v91 += 6;
              }
              while (v89 != 24);
              uint64_t v92 = v87 + v88;
              float v93 = v106[v87 + v88];
              float v94 = v90 + (float)(v84 * v93);
              uint64_t v95 = v73;
              if (v75 <= 5)
              {
                do
                {
                  float v94 = v94
                      + (float)((float)(v106[v79 + ((int)v95 + 5) * ((int)v95 + 6) / 2] * v106[v95])
                              * v106[v87 + ((int)v95 + 5) * ((int)v95 + 6) / 2]);
                  ++v95;
                }
                while (v95);
              }
              uint64_t v96 = 0;
              float v97 = v94 / v85;
              *(float *)(v30 + 4 * v92) = v97;
              do
              {
                v110[v86 + v96] = v110[v86 + v96] + (float)((float)-v97 * v110[v77 + v96]);
                v96 += 6;
              }
              while (v96 != 36);
              int v98 = v76;
              if (v75 <= 5)
              {
                do
                {
                  int v99 = v98 + 1;
                  v106[v87 + v98 * v99 / 2] = v106[v87 + v98 * v99 / 2]
                                            + (float)((float)-v97 * v106[v79 + v98 * v99 / 2]);
                  ++v98;
                }
                while (v99 != 5);
                float v93 = v106[v92];
              }
              v106[v92] = v93 - v97;
              ++v87;
              ++v86;
            }
            while (v87 != v76);
            --v76;
            --v77;
            --v73;
            --v75;
          }
        }
      }
      uint64_t v69 = v64;
      do
      {
        float v70 = *(float *)&v107[24 * jj + 4 * v69];
        uint64_t v71 = v63;
        if (jj <= 4)
        {
          do
          {
            float v70 = v70
                + (float)((float)-(float)(v106[v69 + ((int)v71 + 5) * ((int)v71 + 6) / 2]
                                        * v106[jj + ((int)v71 + 5) * ((int)v71 + 6) / 2])
                        * v106[v71]);
            ++v71;
          }
          while (v71);
        }
        v106[v69 + ((uint64_t)(int)((jj - 1) * jj + (((int)jj - 1) * (int)jj < 0)) >> 1)] = v70 / v66;
      }
      while (v69-- > 0);
      --v64;
      --v63;
    }
  }
  return result;
}

void sub_1905165DC(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = a6 + 24;
  bzero(a1, 0x30uLL);
  uint64_t v13 = 0;
  uint64_t v14 = a2[1];
  uint64_t v15 = *a2 - 4;
  float v16 = (float *)(a3 - 12);
  do
  {
    uint64_t v17 = 0;
    uint64_t v18 = v16;
    do
    {
      float v19 = *(float *)(a3 + 4 * v13 + 12 * v17);
      *(float *)(a6 + 4 * v17) = v19;
      if (v17)
      {
        uint64_t v20 = v18;
        uint64_t v21 = v17;
        do
        {
          float v22 = *v20;
          v20 -= 3;
          float v19 = v19 + (float)(v22 * *(float *)(v15 + 4 * (((int)v17 - 1) * (int)v17 / 2) + 4 * v21));
          *(float *)(a6 + 4 * v17) = v19;
        }
        while (v21-- > 1);
      }
      ++v17;
      v18 += 3;
    }
    while (v17 != 6);
    for (uint64_t i = 0; i != 24; i += 4)
      *(float *)(a6 + i + 24) = *(float *)(v14 + i) * *(float *)(a6 + i);
    uint64_t v25 = 0;
    float v26 = *(float *)(a5 + 4 * v13);
    float v27 = *(float *)(a4 + 4 * v13);
    uint64_t v28 = *a2;
    float v29 = 1.0 / v27;
    do
    {
      float v30 = v27;
      float v31 = *(float *)(a6 + 4 * v25);
      float v27 = v27 + (float)(v31 * *(float *)(v12 + 4 * v25));
      *(float *)(v14 + 4 * v25) = *(float *)(v14 + 4 * v25) * (float)(v30 * (float)(1.0 / v27));
      if (v25)
      {
        uint64_t v32 = 0;
        float v33 = -(float)(v31 * v29);
        uint64_t v34 = v28 + 4 * (((int)v25 - 1) * (int)v25 / 2);
        do
        {
          float v35 = *(float *)(v34 + 4 * v32);
          *(float *)(v34 + 4 * v32) = v35 + (float)(*(float *)(v12 + 4 * v32) * v33);
          *(float *)(v12 + 4 * v32) = *(float *)(v12 + 4 * v32) + (float)(*(float *)(v12 + 4 * v25) * v35);
          ++v32;
        }
        while (v25 != v32);
      }
      ++v25;
      float v29 = 1.0 / v27;
    }
    while (v25 != 6);
    uint64_t v36 = 0;
    float v37 = v26 * (float)(1.0 / v27);
    do
    {
      *((double *)a1 + v36) = *((double *)a1 + v36) + (float)(v37 * *(float *)(v12 + 4 * v36));
      ++v36;
    }
    while (v36 != 6);
    ++v13;
    ++v16;
  }
  while (v13 != 3);
}

void sub_1905167A8(uint64_t a1, float32x2_t *a2, float *a3)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    float v6 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v7 = a2->f32[0];
      double v8 = a2->f32[1];
      double v9 = a2[1].f32[0];
      double v10 = *a3;
      double v11 = a3[1];
      double v12 = a3[2];
      *(_DWORD *)int buf = 134219264;
      double v46 = v7;
      __int16 v47 = 2048;
      double v48 = v8;
      __int16 v49 = 2048;
      double v50 = v9;
      __int16 v51 = 2048;
      double v52 = v10;
      __int16 v53 = 2048;
      double v54 = v11;
      LOWORD(v55[0]) = 2048;
      *(double *)((char *)v55 + 2) = v12;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEBUG, "[Bias,Var] bias.x,%f,bias.y,%f,bias.z,%f,var.x,%f,var.y,%f,var.z,%f", buf, 0x3Eu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      double v22 = a2->f32[0];
      double v23 = a2->f32[1];
      double v24 = a2[1].f32[0];
      double v25 = *a3;
      double v26 = a3[1];
      double v27 = a3[2];
      int v33 = 134219264;
      double v34 = v22;
      __int16 v35 = 2048;
      double v36 = v23;
      __int16 v37 = 2048;
      double v38 = v24;
      __int16 v39 = 2048;
      double v40 = v25;
      __int16 v41 = 2048;
      double v42 = v26;
      __int16 v43 = 2048;
      double v44 = v27;
      uint64_t v28 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedGyroBias(const CLMotionTypeRotationRate &, const CLMotionTypeVector3 &)", "CoreLocation: %s\n", v28);
      if (v28 != (char *)buf) {
        free(v28);
      }
    }
  }
  if (*(unsigned char *)(a1 + 12))
  {
    uint64_t v13 = 0;
    uint64_t v31 = *(void *)a3;
    int v32 = *((_DWORD *)a3 + 2);
    do
    {
      float v14 = *(float *)((char *)&v31 + v13);
      if (v14 < 0.000001) {
        float v14 = 0.000001;
      }
      *(float *)((char *)&v31 + v13) = v14;
      v13 += 4;
    }
    while (v13 != 12);
    int v15 = *(_DWORD *)(a1 + 152);
    if (v15 >= 1)
    {
      int v16 = 0;
      if (v15 >= 50) {
        int v17 = 50;
      }
      else {
        int v17 = *(_DWORD *)(a1 + 152);
      }
      uint64_t v18 = v31;
      int v19 = v32;
      do
      {
        float32x2_t v29 = vcvt_f32_f64(vsubq_f64(vcvtq_f64_f32(*a2), *(float64x2_t *)(a1 + 88)));
        float v20 = a2[1].f32[0] - *(double *)(a1 + 104);
        float v30 = v20;
        bzero(buf, 0x48uLL);
        *(_DWORD *)((char *)&v52 + 2) = 1065353216;
        v55[0] = 1065353216;
        v55[4] = 1065353216;
        uint64_t v57 = v18;
        int v58 = v19;
        sub_1905165DC(&v33, (uint64_t *)(a1 + 112), (uint64_t)buf, (uint64_t)&v57, (uint64_t)&v29, (uint64_t)v56);
        for (uint64_t i = 0; i != 24; i += 8)
          *(double *)(a1 + i + 88) = *(double *)((char *)&v38 + i) + *(double *)(a1 + i + 88);
        ++v16;
      }
      while (v16 != v17);
    }
    *(_DWORD *)(a1 + 152) = 0;
  }
  else
  {
    *(float64x2_t *)(a1 + 88) = vcvtq_f64_f32(*a2);
    *(double *)(a1 + 104) = a2[1].f32[0];
    *(unsigned char *)(a1 + 12) = 1;
  }
}

void sub_190516B90(double *a1, double *a2)
{
  double v4 = *a2;
  double v5 = sqrt(a2[1] * a2[1] + v4 * v4 + a2[2] * a2[2]);
  if (v5 >= 0.00000002)
  {
    __double2 v13 = __sincos_stret(v5 * 0.5);
    double cosval = v13.__cosval;
    *a1 = v4 * (v13.__sinval / v5);
    a1[1] = v13.__sinval / v5 * a2[1];
    double v11 = v13.__sinval / v5 * a2[2];
  }
  else
  {
    *a1 = v4 * 0.5;
    double v6 = a2[1] * 0.5;
    a1[1] = v6;
    double v7 = a2[2] * 0.5;
    double v8 = v5 * v5 * 0.125;
    double v9 = 1.0 - v8;
    double v10 = sqrt(v8 + 1.0);
    *a1 = v4 * 0.5 / v10;
    a1[1] = v6 / v10;
    double v11 = v7 / v10;
    double cosval = v9 / v10;
  }
  a1[2] = v11;
  a1[3] = cosval;
}

double sub_190516C68(double *a1)
{
  _DWORD v20[3] = *(double *)MEMORY[0x1E4F143B8];
  sub_190516D64(a1 + 2, a1 + 47, v20);
  double v2 = a1[5];
  double v3 = a1[4] + a1[4];
  double v4 = a1[2];
  double v5 = a1[3];
  double v6 = v2 * (v5 + v5) - v4 * v3;
  double v7 = -(v2 * (v4 + v4)) - v5 * v3;
  double v8 = -1.0;
  double v9 = v4 * (v4 + v4) + -1.0 + v5 * (v5 + v5);
  uint64_t v19 = 0x3F8000003F800000;
  v17.i64[0] = 0;
  v17.i64[1] = 0x3F80000000000000;
  *(float *)&double v3 = v20[0];
  *(float *)&double v2 = v20[1];
  *(float *)&double v4 = v20[2];
  *(float *)&double v5 = v6;
  float v10 = v7;
  *(float *)&double v6 = v9;
  if (sub_1904CF974((float *)&v19, &v17, (uint64_t)v18, *(float *)&v3, *(float *)&v2, *(float *)&v4, *(float *)&v5, v10, *(float *)&v6, v9, v7, v11, v12, v13, v14, v15, 0x3F800000uLL, 0.0))
  {
    return sub_1904D0AD0(v17.f32);
  }
  return v8;
}

double sub_190516D64(double *a1, double *a2, double *a3)
{
  double v4 = a1[2];
  double v3 = a1[3];
  double v5 = v3 + v3;
  double v6 = a1[1];
  double v7 = *a1 + *a1;
  double v8 = v6 + v6;
  double v9 = v3 * (v3 + v3);
  double v10 = (v6 + v6) * v6 + -1.0;
  double v11 = (v4 + v4) * v4 + -1.0;
  double v12 = v7 * v6;
  double v13 = v7 * v4;
  double v14 = v3 * v7;
  double v15 = v8 * v4;
  double v16 = v3 * v8;
  double v17 = v5 * v4;
  *a3 = (v12 + v17) * a2[1] + (v9 + (*a1 + *a1) * *a1 + -1.0) * *a2 + (v13 - v16) * a2[2];
  a3[1] = (v9 + v10) * a2[1] + (v12 - v17) * *a2 + (v14 + v15) * a2[2];
  double result = (v15 - v14) * a2[1] + (v13 + v16) * *a2 + (v9 + v11) * a2[2];
  a3[2] = result;
  return result;
}

void sub_190516E18(uint64_t a1, double *a2, double *a3, double *a4, void *a5)
{
  uint64_t v198 = *MEMORY[0x1E4F143B8];
  v10.f64[0] = *a2;
  float v11 = *a2;
  *(float *)(a1 + 352) = v11;
  double v12 = *a3;
  float v13 = *a3;
  *(float *)(a1 + 356) = v13;
  double v14 = *a4;
  float v15 = *a4;
  *(float *)(a1 + 360) = v15;
  if (*(double *)(a1 + 176) < 0.0)
  {
    sub_1904F1364(a1 + 16, a2, a3, a4);
    *(void *)(a1 + 176) = *a5;
    float v16 = *a2;
    *(float *)(a1 + 848) = v16;
    float v17 = *a3;
    *(float *)(a1 + 852) = v17;
    float v18 = *a4;
    *(float *)(a1 + 856) = v18;
    *(_DWORD *)(a1 + 888) = 0;
    sub_1904D3A1C((double *)(a1 + 864), (double *)(a1 + 16));
    *(unsigned char *)(a1 + 8) = 1;
    return;
  }
  v10.f64[1] = v12;
  float32x2_t v19 = vcvt_f32_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)(a1 + 848)), (float64x2_t)vdupq_n_s64(0x3FB999999999999AuLL)), (float64x2_t)vdupq_n_s64(0x3FECCCCCCCCCCCCDuLL), v10));
  *(float32x2_t *)(a1 + 848) = v19;
  float v20 = *(float *)(a1 + 856) * 0.1 + v14 * 0.9;
  *(float *)(a1 + 856) = v20;
  *(double *)int buf = v19.f32[0];
  *(double *)double v187 = v19.f32[1];
  *(double *)uint64_t v160 = v20;
  sub_1904D603C(a1 + 608, (double *)buf);
  sub_1904D603C(a1 + 688, (double *)v187);
  sub_1904D603C(a1 + 768, (double *)v160);
  *(void *)(a1 + 176) = *a5;
  if (!*(_DWORD *)(a1 + 148)) {
    return;
  }
  double v21 = *(double *)a5;
  double v22 = *(double *)(a1 + 168);
  if (*(double *)a5 < v22) {
    return;
  }
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    double v23 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v24 = *a2;
      double v25 = *a3;
      double v26 = *a4;
      double v27 = *(double *)a5;
      *(_DWORD *)int buf = 134218752;
      *(double *)&uint8_t buf[4] = v24;
      *(_WORD *)&uint8_t buf[12] = 2048;
      *(double *)&buf[14] = v25;
      *(_WORD *)&unsigned char buf[22] = 2048;
      double v171 = v26;
      __int16 v172 = 2048;
      double v173 = v27;
      _os_log_impl(&dword_1902AF000, v23, OS_LOG_TYPE_DEBUG, "[Accelerometer9] x,%f,y,%f,z,%f,timestamp,%lf", buf, 0x2Au);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      double v116 = *a2;
      double v117 = *a3;
      double v118 = *a4;
      double v119 = *(double *)a5;
      *(_DWORD *)double v187 = 134218752;
      *(double *)&v187[4] = v116;
      *(_WORD *)&v187[12] = 2048;
      *(double *)&v187[14] = v117;
      *(_WORD *)&v187[22] = 2048;
      double v188 = v118;
      __int16 v189 = 2048;
      double v190 = v119;
      __int16 v120 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v120);
      if (v120 != buf) {
        free(v120);
      }
    }
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    uint64_t v28 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v29 = *(float *)(a1 + 156);
      double v30 = *(float *)(a1 + 160);
      double v31 = *(float *)(a1 + 164);
      unint64_t v32 = *(void *)(a1 + 584);
      if (v32) {
        float v33 = *(float *)(a1 + 536) / (float)v32;
      }
      else {
        float v33 = 0.0;
      }
      *(_DWORD *)int buf = 134218752;
      *(double *)&uint8_t buf[4] = v29;
      *(_WORD *)&uint8_t buf[12] = 2048;
      *(double *)&buf[14] = v30;
      *(_WORD *)&unsigned char buf[22] = 2048;
      double v171 = v31;
      __int16 v172 = 2048;
      double v173 = v33;
      _os_log_impl(&dword_1902AF000, v28, OS_LOG_TYPE_DEBUG, "[RotationRate9] %.3f, %.3f, %.3f, %.3f", buf, 0x2Au);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      double v121 = *(float *)(a1 + 156);
      double v122 = *(float *)(a1 + 160);
      double v123 = *(float *)(a1 + 164);
      unint64_t v124 = *(void *)(a1 + 584);
      if (v124) {
        float v125 = *(float *)(a1 + 536) / (float)v124;
      }
      else {
        float v125 = 0.0;
      }
      *(_DWORD *)double v187 = 134218752;
      *(double *)&v187[4] = v121;
      *(_WORD *)&v187[12] = 2048;
      *(double *)&v187[14] = v122;
      *(_WORD *)&v187[22] = 2048;
      double v188 = v123;
      __int16 v189 = 2048;
      double v190 = v125;
      double v137 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v137);
      if (v137 != buf) {
        free(v137);
      }
    }
  }
  double v34 = *a2;
  double v35 = *a3;
  double v36 = *a4;
  LODWORD(v22) = *(_DWORD *)(a1 + 136);
  float v158 = *(float *)(a1 + 140);
  float v159 = *(float *)&v22;
  LODWORD(v21) = *(_DWORD *)(a1 + 144);
  int v37 = *(_DWORD *)(a1 + 148);
  float v157 = *(float *)&v21;
  sub_190515CC0(a1, v21, *(int32x2_t *)&v22);
  double v38 = sqrt(v35 * v35 + v34 * v34 + v36 * v36);
  double v39 = fabs(v38 + -1.0) / v38;
  if (v39 > 0.1) {
    return;
  }
  if (!*(unsigned char *)(a1 + 512) || *(_DWORD *)(a1 + 904)) {
    goto LABEL_22;
  }
  float v87 = fabsf(*(float *)(a1 + 156));
  if (v87 > 10.0) {
    goto LABEL_92;
  }
  float v88 = fabsf(*(float *)(a1 + 160));
  if (v88 > 10.0) {
    goto LABEL_92;
  }
  float v89 = fabsf(*(float *)(a1 + 164));
  if (v89 > 10.0) {
    goto LABEL_92;
  }
  unint64_t v90 = *(void *)(a1 + 584);
  if (v90)
  {
    if ((float)(*(float *)(a1 + 536) / (float)v90) > 10.0) {
      goto LABEL_92;
    }
  }
  if (v87 > 3.14159265
    || v88 > 3.14159265
    || v89 > 3.14159265
    || (!v90 ? (float v91 = 0.0) : (float v91 = *(float *)(a1 + 536) / (float)v90), v91 > 3.14159265))
  {
    if (v90 < 2
      || (float v92 = (float)((float)v90 * *(float *)(a1 + 540)) - (float)(*(float *)(a1 + 536) * *(float *)(a1 + 536)),
          v92 < 0.0)
      || (float)(v92 / (float)((v90 - 1) * v90)) < 1.25)
    {
      sub_1904D3A1C((double *)(a1 + 864), (double *)(a1 + 16));
      if (!*(unsigned char *)(a1 + 472))
      {
        *(_DWORD *)(a1 + 888) = 0;
        goto LABEL_28;
      }
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      float v93 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v93, OS_LOG_TYPE_DEBUG, "rotating and going through.", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        *(_WORD *)double v187 = 0;
        float v94 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v94);
        if (v94 != buf) {
          free(v94);
        }
      }
LABEL_22:
      int v40 = *(unsigned __int8 *)(a1 + 472);
      *(_DWORD *)(a1 + 888) = 0;
      if (v40)
      {
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        __int16 v41 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 134218752;
          *(double *)&uint8_t buf[4] = v34;
          *(_WORD *)&uint8_t buf[12] = 2048;
          *(double *)&buf[14] = v35;
          *(_WORD *)&unsigned char buf[22] = 2048;
          double v171 = v36;
          __int16 v172 = 2048;
          double v173 = v38;
          _os_log_impl(&dword_1902AF000, v41, OS_LOG_TYPE_DEBUG, "accM, (%.4f, %.4f, %.4f), mag, %.3f", buf, 0x2Au);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
          }
          *(_DWORD *)double v187 = 134218752;
          *(double *)&v187[4] = v34;
          *(_WORD *)&v187[12] = 2048;
          *(double *)&v187[14] = v35;
          *(_WORD *)&v187[22] = 2048;
          double v188 = v36;
          __int16 v189 = 2048;
          double v190 = v38;
          uint64_t v136 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v136);
          if (v136 != buf) {
            free(v136);
          }
        }
      }
LABEL_28:
      double v42 = v39
          * (0.015
           / (exp((0.9- sqrtf((float)((float)((float)(v158 / (float)v37) * (float)(v158 / (float)v37))+ (float)((float)(v159 / (float)v37) * (float)(v159 / (float)v37)))+ (float)((float)(v157 / (float)v37) * (float)(v157 / (float)v37))))/ 0.08)+ 1.0))+ 0.00000900000032;
      if (*(unsigned char *)(a1 + 512) && !*(_DWORD *)(a1 + 904)) {
        double v42 = v42 * 0.85;
      }
      uint64_t v43 = 0;
      uint64_t v44 = 0;
      double v45 = v35 / v38;
      double v46 = *(double *)(a1 + 16);
      double v47 = *(double *)(a1 + 24);
      double v48 = *(double *)(a1 + 32) + *(double *)(a1 + 32);
      double v49 = *(double *)(a1 + 40);
      double v50 = v49 * (v47 + v47) - v46 * v48;
      double v51 = -(v49 * (v46 + v46)) - v47 * v48;
      double v52 = v46 * (v46 + v46) + -1.0 + v47 * (v47 + v47);
      *(float *)&double v46 = v51;
      *(float *)&double v48 = v52;
      v197[0] = 0;
      v197[1] = LODWORD(v48);
      *(float *)&v197[2] = -*(float *)&v46;
      *(float *)&double v47 = v50;
      *(float *)&v197[3] = -*(float *)&v48;
      v197[4] = 0;
      v197[5] = LODWORD(v47);
      v197[6] = LODWORD(v46);
      *(float *)&v197[7] = -*(float *)&v47;
      v197[8] = 0;
      do
      {
        for (uint64_t i = 0; i != 9; i += 3)
          *(_DWORD *)&v187[v43 * 4 + i * 4] = v197[v43 + i];
        ++v44;
        ++v43;
      }
      while (v44 != 3);
      bzero((char *)&v190 + 2, 0x24uLL);
      float v54 = v42;
      *(float *)__int16 v186 = v54;
      *(float *)&v186[1] = v54;
      *(float *)&v186[2] = v54;
      float v55 = v34 / v38 - v50;
      float v56 = v45 - v51;
      *(float *)int v185 = v55;
      *(float *)&v185[1] = v56;
      float v57 = v36 / v38 - v52;
      *(float *)&v185[2] = v57;
      sub_1905165DC(&v181, (uint64_t *)(a1 + 112), (uint64_t)v187, (uint64_t)v186, (uint64_t)v185, (uint64_t)v180);
      double v58 = v51 * v182 + v181 * v50 + v183 * v52;
      double v59 = v181 - v58 * v50;
      double v60 = v182 - v58 * v51;
      double v181 = v59;
      double v182 = v60;
      double v61 = v183 - v58 * v52;
      double v183 = v61;
      sub_190518DE4(a1, &v181);
      if (*(unsigned char *)(a1 + 472))
      {
        if (qword_1E929D7B8 != -1) {
          dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
        }
        __int16 v62 = qword_1E929D7B0;
        if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
        {
          double v63 = *(double *)(a1 + 88);
          double v64 = *(double *)(a1 + 96);
          double v65 = *(double *)(a1 + 104);
          uint64_t v66 = *(void *)(a1 + 176);
          *(_DWORD *)int buf = 134219520;
          *(double *)&uint8_t buf[4] = v59;
          *(_WORD *)&uint8_t buf[12] = 2048;
          *(double *)&buf[14] = v60;
          *(_WORD *)&unsigned char buf[22] = 2048;
          double v171 = v61;
          __int16 v172 = 2048;
          double v173 = v63;
          __int16 v174 = 2048;
          double v175 = v64;
          __int16 v176 = 2048;
          double v177 = v65;
          __int16 v178 = 2048;
          uint64_t v179 = v66;
          _os_log_impl(&dword_1902AF000, v62, OS_LOG_TYPE_DEBUG, "[KalmanFilterStates9-AccelUpdate] %f,%f,%f,%f,%f,%f,%f", buf, 0x48u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D7B8 != -1) {
            dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
          }
          uint64_t v130 = *(void *)(a1 + 88);
          uint64_t v131 = *(void *)(a1 + 96);
          uint64_t v132 = *(void *)(a1 + 104);
          uint64_t v133 = *(void *)(a1 + 176);
          *(_DWORD *)uint64_t v160 = 134219520;
          *(double *)&v160[4] = v59;
          *(_WORD *)&v160[12] = 2048;
          *(double *)&v160[14] = v60;
          *(_WORD *)&v160[22] = 2048;
          double v161 = v61;
          __int16 v162 = 2048;
          uint64_t v163 = v130;
          __int16 v164 = 2048;
          uint64_t v165 = v131;
          __int16 v166 = 2048;
          uint64_t v167 = v132;
          __int16 v168 = 2048;
          uint64_t v169 = v133;
          int v134 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CLSensorFusion9AxisMekf::doAccelerometerMeasurementUpdate(double *, double)", "CoreLocation: %s\n", v134);
          if (v134 != buf) {
            free(v134);
          }
        }
      }
      if (*(unsigned char *)(a1 + 512)) {
        sub_1904D3A1C((double *)(a1 + 864), (double *)(a1 + 16));
      }
      *(void *)(a1 + 896) = *a5;
      int v67 = *(_DWORD *)(a1 + 904);
      BOOL v68 = __OFSUB__(v67, 1);
      int v69 = v67 - 1;
      if (v69 < 0 == v68)
      {
        *(_DWORD *)(a1 + 904) = v69;
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        float v70 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v70, OS_LOG_TYPE_DEBUG, "Doing some crude updates to catch up.", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
          }
          *(_WORD *)double v187 = 0;
          uint64_t v135 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v135);
          if (v135 != buf) {
            free(v135);
          }
        }
      }
      if (*(unsigned char *)(a1 + 472))
      {
        if (qword_1E929D7B8 != -1) {
          dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
        }
        uint64_t v71 = qword_1E929D7B0;
        if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v72 = *(void *)(a1 + 64);
          uint64_t v73 = *(void *)(a1 + 72);
          double v74 = *(double *)(a1 + 80);
          double v75 = *(double *)(a1 + 88);
          double v76 = *(double *)(a1 + 96);
          double v77 = *(double *)(a1 + 104);
          uint64_t v78 = *a5;
          *(_DWORD *)int buf = 134219520;
          *(void *)&uint8_t buf[4] = v72;
          *(_WORD *)&uint8_t buf[12] = 2048;
          *(void *)&buf[14] = v73;
          *(_WORD *)&unsigned char buf[22] = 2048;
          double v171 = v74;
          __int16 v172 = 2048;
          double v173 = v75;
          __int16 v174 = 2048;
          double v175 = v76;
          __int16 v176 = 2048;
          double v177 = v77;
          __int16 v178 = 2048;
          uint64_t v179 = v78;
          _os_log_impl(&dword_1902AF000, v71, OS_LOG_TYPE_DEBUG, "[KalmanFilterStates9] %f,%f,%f,%f,%f,%f,%f", buf, 0x48u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D7B8 != -1) {
            dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
          }
          uint64_t v79 = *(void *)(a1 + 64);
          uint64_t v80 = *(void *)(a1 + 72);
          double v81 = *(double *)(a1 + 80);
          double v82 = *(double *)(a1 + 88);
          double v83 = *(double *)(a1 + 96);
          double v84 = *(double *)(a1 + 104);
          uint64_t v85 = *a5;
          *(_DWORD *)double v187 = 134219520;
          *(void *)&v187[4] = v79;
          *(_WORD *)&v187[12] = 2048;
          *(void *)&v187[14] = v80;
          *(_WORD *)&v187[22] = 2048;
          double v188 = v81;
          __int16 v189 = 2048;
          double v190 = v82;
          __int16 v191 = 2048;
          double v192 = v83;
          __int16 v193 = 2048;
          double v194 = v84;
          __int16 v195 = 2048;
          uint64_t v196 = v85;
          uint64_t v86 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v86);
LABEL_58:
          if (v86 != buf) {
            free(v86);
          }
          return;
        }
      }
      return;
    }
  }
  sub_1904D5B20(a1 + 592, (uint64_t)v160);
  double v156 = sqrt(*(double *)&v160[16] * *(double *)&v160[16] + *(double *)&v160[8] * *(double *)&v160[8] + v161 * v161);
  double v95 = *(double *)(a1 + 896);
  if (v95 > 0.0 && *(double *)(a1 + 176) - v95 > 15.0 && v156 < 0.3)
  {
    sub_1904D5C00(a1 + 592, (uint64_t)buf);
    if (fabs(sqrt(*(double *)&buf[16] * *(double *)&buf[16] + *(double *)&buf[8] * *(double *)&buf[8] + v171 * v171)+ -1.0) <= 0.1)
    {
      *(_DWORD *)(a1 + 904) = 10;
      if (!*(unsigned char *)(a1 + 472)) {
        goto LABEL_192;
      }
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      float v114 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v114, OS_LOG_TYPE_DEBUG, "it's been too long. go through.", buf, 2u);
      }
      if (!sub_1902D8400(115, 2)) {
        goto LABEL_192;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 == -1) {
        goto LABEL_125;
      }
      goto LABEL_224;
    }
  }
  if (*(_DWORD *)(a1 + 680) <= (int)((double)*(unint64_t *)(a1 + 600) * 0.5))
  {
LABEL_92:
    sub_1904D3A1C((double *)(a1 + 864), (double *)(a1 + 16));
    return;
  }
  uint64_t v96 = *(void *)(a1 + 584);
  if (v96) {
    float v97 = *(float *)(*(void *)(*(void *)(a1 + 552)
  }
                               + (((unint64_t)(v96 + *(void *)(a1 + 576) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                   + 4 * ((v96 + *(void *)(a1 + 576) - 1) & 0x3FF));
  else {
    float v97 = 0.0;
  }
  if (v97 > 0.2)
  {
    sub_1904D3A1C((double *)(a1 + 864), (double *)(a1 + 16));
    if (*(unsigned char *)(a1 + 472))
    {
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      int v98 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v99 = *(void *)(a1 + 864);
        uint64_t v100 = *(void *)(a1 + 872);
        double v101 = *(double *)(a1 + 880);
        *(_DWORD *)int buf = 134218496;
        *(void *)&uint8_t buf[4] = v99;
        *(_WORD *)&uint8_t buf[12] = 2048;
        *(void *)&buf[14] = v100;
        *(_WORD *)&unsigned char buf[22] = 2048;
        double v171 = v101;
        _os_log_impl(&dword_1902AF000, v98, OS_LOG_TYPE_DEBUG, "grabing gravity, %.4f, %.4f, %.4f", buf, 0x20u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        uint64_t v145 = *(void *)(a1 + 864);
        uint64_t v146 = *(void *)(a1 + 872);
        double v147 = *(double *)(a1 + 880);
        *(_DWORD *)double v187 = 134218496;
        *(void *)&v187[4] = v145;
        *(_WORD *)&v187[12] = 2048;
        *(void *)&v187[14] = v146;
        *(_WORD *)&v187[22] = 2048;
        double v188 = v147;
        uint64_t v148 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v148);
        if (v148 != buf) {
          free(v148);
        }
      }
    }
  }
  if (v156 <= *(double *)(a1 + 504) * 0.75) {
    goto LABEL_192;
  }
  double v102 = *(double *)(a1 + 864);
  double v103 = *(double *)(a1 + 872);
  double v104 = *(double *)(a1 + 880);
  double v105 = fabs(*(double *)&v160[16] * v103 + *(double *)&v160[8] * v102 + v161 * v104);
  double v155 = v156 - v105;
  double v106 = *(double *)(a1 + 624);
  double v107 = *(double *)(a1 + 704);
  double v108 = *(double *)(a1 + 784);
  double v181 = COERCE_DOUBLE(&unk_1EDFC7D40);
  double v109 = v103 * v107 + v106 * v102 + v108 * v104;
  double v182 = v106 - v109 * v102;
  double v183 = v107 - v109 * v103;
  double v184 = v108 - v109 * v104;
  double v153 = v109;
  double v154 = fabs(v184) + fabs(v182) + fabs(v183);
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
    }
    double v110 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 134219264;
      *(void *)&uint8_t buf[4] = *(void *)&v160[8];
      *(_WORD *)&uint8_t buf[12] = 2048;
      *(void *)&buf[14] = *(void *)&v160[16];
      *(_WORD *)&unsigned char buf[22] = 2048;
      double v171 = v161;
      __int16 v172 = 2048;
      double v173 = v156;
      __int16 v174 = 2048;
      double v175 = v105;
      __int16 v176 = 2048;
      double v177 = v156 - v105;
      _os_log_impl(&dword_1902AF000, v110, OS_LOG_TYPE_DEBUG, "std, %.3f, %.3f, %.3f, mag, %.3f, dot, %.3f, leftover, %.3f", buf, 0x3Eu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      *(_DWORD *)double v187 = 134219264;
      *(void *)&v187[4] = *(void *)&v160[8];
      *(_WORD *)&v187[12] = 2048;
      *(void *)&v187[14] = *(void *)&v160[16];
      *(_WORD *)&v187[22] = 2048;
      double v188 = v161;
      __int16 v189 = 2048;
      double v190 = v156;
      __int16 v191 = 2048;
      double v192 = v105;
      __int16 v193 = 2048;
      double v194 = v156 - v105;
      __int16 v149 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v149);
      if (v149 != buf) {
        free(v149);
      }
    }
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
    }
    uint64_t v111 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 134219008;
      *(double *)&uint8_t buf[4] = v182;
      *(_WORD *)&uint8_t buf[12] = 2048;
      *(double *)&buf[14] = v183;
      *(_WORD *)&unsigned char buf[22] = 2048;
      double v171 = v184;
      __int16 v172 = 2048;
      double v173 = v153;
      __int16 v174 = 2048;
      double v175 = v154;
      _os_log_impl(&dword_1902AF000, v111, OS_LOG_TYPE_DEBUG, "sum, %.3f, %.3f, %.3f, dot, %.3f, leftover, %.3f", buf, 0x34u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      *(_DWORD *)double v187 = 134219008;
      *(double *)&v187[4] = v182;
      *(_WORD *)&v187[12] = 2048;
      *(double *)&v187[14] = v183;
      *(_WORD *)&v187[22] = 2048;
      double v188 = v184;
      __int16 v189 = 2048;
      double v190 = v153;
      __int16 v191 = 2048;
      double v192 = v154;
      uint64_t v150 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v150);
      if (v150 != buf) {
        free(v150);
      }
    }
  }
  if (v155 > *(double *)(a1 + 504)) {
    goto LABEL_139;
  }
  unint64_t v112 = *(void *)(a1 + 584);
  if (v112) {
    float v113 = *(float *)(a1 + 536) / (float)v112;
  }
  else {
    float v113 = 0.0;
  }
  BOOL v126 = v113 <= 1.57079633;
  double v127 = 0.0;
  if (!v126) {
    double v127 = 1.0;
  }
  if (v154 > (v127 * 0.5 + 1.0) * 6.0)
  {
LABEL_139:
    *(_DWORD *)(a1 + 888) = 0;
    return;
  }
  if (v155 >= 0.01 || v154 >= 0.6)
  {
    int v138 = *(_DWORD *)(a1 + 888) + 1;
    *(_DWORD *)(a1 + 888) = v138;
    if (!v112) {
      goto LABEL_182;
    }
    uint64_t v139 = (int *)(a1 + 888);
    float v128 = *(float *)(a1 + 536) / (float)v112;
  }
  else
  {
    if (!v112)
    {
      int v138 = *(_DWORD *)(a1 + 888) + 1;
      *(_DWORD *)(a1 + 888) = v138;
      goto LABEL_182;
    }
    float v128 = *(float *)(a1 + 536) / (float)v112;
    if (v128 > 0.5)
    {
      if (!*(unsigned char *)(a1 + 472)) {
        goto LABEL_192;
      }
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      int v129 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v129, OS_LOG_TYPE_DEBUG, "===========Skip ahead.", buf, 2u);
      }
      if (!sub_1902D8400(115, 2)) {
        goto LABEL_192;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 == -1) {
        goto LABEL_125;
      }
LABEL_224:
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
LABEL_125:
      *(_WORD *)double v187 = 0;
      float v115 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v115);
      if (v115 != buf) {
        free(v115);
      }
      goto LABEL_192;
    }
    uint64_t v139 = (int *)(a1 + 888);
    int v138 = *(_DWORD *)(a1 + 888) + 1;
    *(_DWORD *)(a1 + 888) = v138;
  }
  if (v128 > 1.0
    && *(float *)(*(void *)(*(void *)(a1 + 552) + (((v112 + *(void *)(a1 + 576) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                + 4 * ((v112 + *(void *)(a1 + 576) - 1) & 0x3FF)) < 0.2)
  {
    sub_1904D5C00(a1 + 592, (uint64_t)buf);
    double v140 = sqrt(*(double *)&buf[16] * *(double *)&buf[16] + *(double *)&buf[8] * *(double *)&buf[8] + v171 * v171);
    if (fabs(v140 + -1.0) / v140 >= 0.025)
    {
      int v138 = *v139;
    }
    else
    {
      if (*(unsigned char *)(a1 + 472))
      {
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        uint64_t v141 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v141, OS_LOG_TYPE_DEBUG, "Skip ahead------.", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
          }
          *(_WORD *)double v187 = 0;
          uint64_t v152 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v152);
          if (v152 != buf) {
            free(v152);
          }
        }
      }
      int v138 = *v139 + 2;
      *uint64_t v139 = v138;
    }
  }
LABEL_182:
  if (v138 >= *(_DWORD *)(a1 + 496))
  {
LABEL_192:
    if (*(unsigned char *)(a1 + 512))
    {
      if (v156 > 0.2)
      {
        unint64_t v143 = *(void *)(a1 + 584);
        if (!v143
          || *(float *)(*(void *)(*(void *)(a1 + 552)
                                  + (((v143 + *(void *)(a1 + 576) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                      + 4 * ((v143 + *(void *)(a1 + 576) - 1) & 0x3FF)) < 0.75
          && (float)(*(float *)(a1 + 536) / (float)v143) < 1.0)
        {
          sub_1904D5C00(a1 + 592, (uint64_t)v187);
          double v34 = *(double *)&v187[8];
          double v35 = *(double *)&v187[16];
          double v36 = v188;
          if (*(unsigned char *)(a1 + 472))
          {
            if (qword_1EB3BE878 != -1) {
              dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
            }
            uint64_t v144 = off_1EB3BE870;
            if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)int buf = 0;
              _os_log_impl(&dword_1902AF000, v144, OS_LOG_TYPE_DEBUG, "using mean accel", buf, 2u);
            }
            if (sub_1902D8400(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1EB3BE878 != -1) {
                dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
              }
              *(_WORD *)uint64_t v160 = 0;
              uint64_t v151 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v151);
              if (v151 != buf) {
                free(v151);
              }
            }
          }
          double v38 = sqrt(v35 * v35 + v34 * v34 + v36 * v36);
          double v39 = fabs(v38 + -1.0) / v38;
        }
      }
    }
    goto LABEL_22;
  }
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
    }
    uint64_t v142 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v142, OS_LOG_TYPE_DEBUG, "Taking another look.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      *(_WORD *)double v187 = 0;
      uint64_t v86 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)", "CoreLocation: %s\n", v86);
      goto LABEL_58;
    }
  }
}

double sub_190518DE4(uint64_t a1, double *a2)
{
  sub_190516B90(v9, a2);
  sub_1904D39A0((double *)v8, v9, (double *)(a1 + 16));
  uint64_t v4 = 0;
  long long v5 = v8[1];
  *(_OWORD *)(a1 + 16) = v8[0];
  *(_OWORD *)(a1 + 32) = v5;
  uint64_t v6 = a1 + 88;
  do
  {
    double result = a2[v4 + 3] + *(double *)(v6 + v4 * 8);
    *(double *)(v6 + v4 * 8) = result;
    ++v4;
  }
  while (v4 != 3);
  return result;
}

void sub_190518E58(uint64_t a1)
{
  *(_WORD *)(a1 + 440) = 256;
  *(_DWORD *)(a1 + 436) = 0;
}

BOOL sub_190518E94(uint64_t a1, uint64_t *a2, unsigned char *a3, unsigned char *a4, double *a5)
{
  uint64_t v164 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 9) = 0;
  int v10 = *((_DWORD *)a2 + 9);
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    float v11 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v12 = *a5;
      int v13 = *a3;
      int v14 = *a4;
      *(_DWORD *)int buf = 134218752;
      *(double *)&uint8_t buf[4] = v12;
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = v10;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v13;
      LOWORD(v161) = 1024;
      *(_DWORD *)((char *)&v161 + 2) = v14;
      _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_DEBUG, "[CompassIntoKF] timestamp,%f,calibration level %d, compassHasAlignedToStableField %d, useMagneticRefX %d", buf, 0x1Eu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      double v111 = *a5;
      int v112 = *a3;
      int v113 = *a4;
      *(_DWORD *)__int16 v149 = 134218752;
      *(double *)&v149[4] = v111;
      *(_WORD *)&v149[12] = 1024;
      *(_DWORD *)&v149[14] = v10;
      *(_WORD *)&v149[18] = 1024;
      *(_DWORD *)&v149[20] = v112;
      LOWORD(v150) = 1024;
      *(_DWORD *)((char *)&v150 + 2) = v113;
      float v114 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v114);
      if (v114 != buf) {
        free(v114);
      }
    }
  }
  if (v10 <= 2)
  {
    if (v10 <= 0)
    {
      BOOL v15 = 0;
      *(void *)(a1 + 184) = 0xBFF0000000000000;
      *(unsigned char *)(a1 + 441) = 1;
      *(unsigned char *)(a1 + 11) = 0;
      return v15;
    }
    return 0;
  }
  if (*a4 && !*(unsigned char *)(a1 + 11) || *(double *)(a1 + 184) < 0.0) {
    *(unsigned char *)(a1 + 441) = 1;
  }
  if (*(double *)(a1 + 176) < 0.0)
  {
    if (!*(unsigned char *)(a1 + 472)) {
      return 0;
    }
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    float v16 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v17 = *(void *)(a1 + 176);
      *(_DWORD *)int buf = 134217984;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_DEBUG, "[CompassIntoKF] fLastAccelTime,%f", buf, 0xCu);
    }
    if (!sub_1902D8400(115, 2)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    uint64_t v115 = *(void *)(a1 + 176);
    *(_DWORD *)__int16 v149 = 134217984;
    *(void *)&v149[4] = v115;
    goto LABEL_175;
  }
  if (*a3)
  {
    if (*(unsigned char *)(a1 + 472))
    {
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      float v18 = qword_1E929D7B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_DEBUG, "[CompassIntoKF] magneticFieldAdjusted!", buf, 2u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D7B8 != -1) {
          dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
        }
        *(_WORD *)__int16 v149 = 0;
        double v117 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v117);
        if (v117 != buf) {
          free(v117);
        }
      }
    }
    BOOL v15 = 0;
    *(_WORD *)(a1 + 440) = 1;
    *(_DWORD *)(a1 + 432) = 0;
    return v15;
  }
  double v20 = *(double *)(a1 + 40);
  double v21 = *(double *)(a1 + 32) + *(double *)(a1 + 32);
  double v22 = *(double *)(a1 + 16);
  double v23 = *(double *)(a1 + 24);
  double v24 = v20 * (v23 + v23) - v22 * v21;
  double v25 = -(v20 * (v22 + v22)) - v23 * v21;
  v159[0] = v24;
  v159[1] = v25;
  double v26 = v22 * (v22 + v22) + -1.0 + v23 * (v23 + v23);
  v159[2] = v26;
  float v27 = v25 * *(float *)(a1 + 160) + *(float *)(a1 + 156) * v24 + *(float *)(a1 + 164) * v26;
  *(float *)&double v21 = *(float *)(a1 + 436) + (float)(v27 * 57.296) * *(double *)(a1 + 488);
  *(_DWORD *)(a1 + 436) = LODWORD(v21);
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
    }
    uint64_t v28 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      double v29 = *(float *)(a1 + 436);
      *(_DWORD *)int buf = 134218240;
      *(double *)&uint8_t buf[4] = v27;
      *(_WORD *)&uint8_t buf[12] = 2048;
      *(double *)&buf[14] = v29;
      _os_log_impl(&dword_1902AF000, v28, OS_LOG_TYPE_DEBUG, "rotAroundGrav, %.3f, sum, %.3f", buf, 0x16u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      double v118 = *(float *)(a1 + 436);
      *(_DWORD *)__int16 v149 = 134218240;
      *(double *)&v149[4] = v27;
      *(_WORD *)&v149[12] = 2048;
      *(double *)&v149[14] = v118;
      double v119 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v119);
      if (v119 != buf) {
        free(v119);
      }
    }
  }
  unint64_t v30 = *(void *)(a1 + 584);
  float v31 = 0.0;
  if (v30)
  {
    float v32 = *(float *)(a1 + 536);
    float v33 = v32 / (float)v30;
    if (v30 != 1)
    {
      float v34 = (float)((float)v30 * *(float *)(a1 + 540)) - (float)(v32 * v32);
      if (v34 >= 0.0) {
        float v31 = v34 / (float)((v30 - 1) * v30);
      }
    }
  }
  else
  {
    float v33 = 0.0;
  }
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    double v35 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 134218240;
      *(double *)&uint8_t buf[4] = v33;
      *(_WORD *)&uint8_t buf[12] = 2048;
      *(double *)&buf[14] = v31;
      _os_log_impl(&dword_1902AF000, v35, OS_LOG_TYPE_DEBUG, "[CompassIntoKF] omegaMag, %.3f, omegaVar, %.3f", buf, 0x16u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      *(_DWORD *)__int16 v149 = 134218240;
      *(double *)&v149[4] = v33;
      *(_WORD *)&v149[12] = 2048;
      *(double *)&v149[14] = v31;
      __int16 v120 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v120);
      if (v120 != buf) {
        free(v120);
      }
    }
  }
  *(_DWORD *)(a1 + 364) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 368) = *((_DWORD *)a2 + 1);
  *(_DWORD *)(a1 + 372) = *((_DWORD *)a2 + 2);
  if (!*a4 && *(unsigned char *)(a1 + 440))
  {
    BOOL v15 = 0;
    if (v31 >= 2.25 || fabsf(*(float *)(a1 + 436)) <= 90.0 || v33 >= 1.57079633) {
      return v15;
    }
    sub_1902D9094(a1 + 208, (float *)a2 + 11);
    sub_1902D9094(a1 + 280, (float *)a2 + 12);
    unint64_t v61 = *(void *)(a1 + 272);
    if (v61 < *(void *)(a1 + 216)) {
      return 0;
    }
    float v62 = 0.0;
    float v63 = 0.0;
    if (v61) {
      float v63 = *(float *)(a1 + 224) / (float)v61;
    }
    unint64_t v64 = *(void *)(a1 + 344);
    if (v64) {
      float v62 = *(float *)(a1 + 296) / (float)v64;
    }
    float v65 = *(float *)(a1 + 424);
    float v66 = 0.0;
    float v67 = 0.0;
    if (v61 >= 2)
    {
      float v68 = (float)((float)v61 * *(float *)(a1 + 228)) - (float)(*(float *)(a1 + 224) * *(float *)(a1 + 224));
      if (v68 >= 0.0) {
        float v67 = v68 / (float)((v61 - 1) * v61);
      }
    }
    float v69 = vabds_f32(v63, v65);
    if (v64 >= 2)
    {
      float v70 = (float)((float)v64 * *(float *)(a1 + 300)) - (float)(*(float *)(a1 + 296) * *(float *)(a1 + 296));
      uint64_t v71 = (v64 - 1) * v64;
      if (v70 >= 0.0) {
        float v66 = v70 / (float)(unint64_t)v71;
      }
      else {
        float v66 = 0.0;
      }
    }
    float v72 = vabds_f32(v62, *(float *)(a1 + 428));
    float v73 = v69 / v65;
    if (*(unsigned char *)(a1 + 472))
    {
      float v143 = v72;
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      double v74 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 134218752;
        *(double *)&uint8_t buf[4] = v73;
        *(_WORD *)&uint8_t buf[12] = 2048;
        *(double *)&buf[14] = v143;
        *(_WORD *)&unsigned char buf[22] = 2048;
        double v161 = v67;
        __int16 v162 = 2048;
        *(double *)uint64_t v163 = v66;
        _os_log_impl(&dword_1902AF000, v74, OS_LOG_TYPE_DEBUG, "FieldDiff, %.3f, %.3f, %.3f, %.3f", buf, 0x2Au);
      }
      int v75 = sub_1902D8400(115, 2);
      float v72 = v143;
      if (v75)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        *(_DWORD *)__int16 v149 = 134218752;
        *(double *)&v149[4] = v73;
        *(_WORD *)&v149[12] = 2048;
        *(double *)&v149[14] = v143;
        *(_WORD *)&v149[22] = 2048;
        double v150 = v67;
        __int16 v151 = 2048;
        *(double *)uint64_t v152 = v66;
        uint64_t v141 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v141);
        if (v141 != buf) {
          free(v141);
        }
        float v72 = v143;
      }
    }
    if (v73 < 0.07 && v72 < 4.0 && v67 < 2.25 && v66 < 4.0)
    {
      *(_DWORD *)(a1 + 432) = 0;
    }
    else
    {
      int v79 = *(_DWORD *)(a1 + 432);
      *(_DWORD *)(a1 + 432) = v79 + 1;
      if (v79 < 2)
      {
        sub_1902B5164((void *)(a1 + 208));
        sub_1902B5164((void *)(a1 + 280));
        if (!*(unsigned char *)(a1 + 472)) {
          return 0;
        }
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        double v107 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
        {
          int v108 = *(_DWORD *)(a1 + 432);
          *(_DWORD *)int buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v108;
          _os_log_impl(&dword_1902AF000, v107, OS_LOG_TYPE_DEBUG, "Checking again for magField. checkcount, %d", buf, 8u);
        }
        if (!sub_1902D8400(115, 2)) {
          return 0;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        int v109 = *(_DWORD *)(a1 + 432);
        *(_DWORD *)__int16 v149 = 67109120;
        *(_DWORD *)&v149[4] = v109;
        goto LABEL_175;
      }
      if (*(unsigned char *)(a1 + 472))
      {
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        uint64_t v80 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v80, OS_LOG_TYPE_DEBUG, "Aborted yawUpdate.", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
          }
          *(_WORD *)__int16 v149 = 0;
          uint64_t v142 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v142);
          if (v142 != buf) {
            free(v142);
          }
        }
      }
      sub_190518E58(a1);
    }
  }
  double v36 = (float32x2_t *)(a1 + 364);
  if (*(unsigned char *)(a1 + 441))
  {
    if (!*a4)
    {
      *(void *)(a1 + 424) = *(uint64_t *)((char *)a2 + 44);
      *(float64x2_t *)double v153 = vcvtq_f64_f32(*v36);
      *(double *)&v153[16] = *(float *)(a1 + 372);
      *(float64x2_t *)__int16 v149 = vnegq_f64(*(float64x2_t *)(a1 + 16));
      double v81 = *(double *)(a1 + 40);
      *(double *)&v149[16] = -*(double *)(a1 + 32);
      double v150 = v81;
      sub_190516D64((double *)v149, (double *)v153, (double *)(a1 + 400));
      double v83 = *(double *)(a1 + 400);
      double v82 = *(double *)(a1 + 408);
      double v84 = *(double *)(a1 + 416);
      double v85 = sqrt(v82 * v82 + v83 * v83 + v84 * v84);
      if (v85 <= 0.0)
      {
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        double v105 = off_1EB3BE870;
        if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_1902AF000, v105, OS_LOG_TYPE_INFO, "Warning: Compass outputs field magnitude 0.", buf, 2u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE878 != -1) {
            dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
          }
          *(_WORD *)float v157 = 0;
          uint64_t v131 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v131);
          if (v131 != buf) {
            free(v131);
          }
        }
        *(void *)(a1 + 184) = 0xBFF0000000000000;
      }
      else
      {
        *(double *)(a1 + 448) = v83 / v85;
        *(double *)(a1 + 456) = v82 / v85;
        *(double *)(a1 + 464) = v84 / v85;
        if (*(unsigned char *)(a1 + 472))
        {
          if (qword_1E929D7B8 != -1) {
            dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
          }
          uint64_t v86 = qword_1E929D7B0;
          if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v87 = *(void *)(a1 + 448);
            uint64_t v88 = *(void *)(a1 + 456);
            double v89 = *(double *)(a1 + 464);
            *(_DWORD *)int buf = 134218496;
            *(void *)&uint8_t buf[4] = v87;
            *(_WORD *)&uint8_t buf[12] = 2048;
            *(void *)&buf[14] = v88;
            *(_WORD *)&unsigned char buf[22] = 2048;
            double v161 = v89;
            _os_log_impl(&dword_1902AF000, v86, OS_LOG_TYPE_DEBUG, "[!!!CompassInertialReference] x,%f,y,%f,z,%f", buf, 0x20u);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1E929D7B8 != -1) {
              dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
            }
            uint64_t v132 = *(void *)(a1 + 448);
            uint64_t v133 = *(void *)(a1 + 456);
            uint64_t v134 = *(void *)(a1 + 464);
            *(_DWORD *)float v157 = 134218496;
            *(void *)&v157[4] = v132;
            *(_WORD *)&v157[12] = 2048;
            *(void *)&v157[14] = v133;
            *(_WORD *)&v157[22] = 2048;
            uint64_t v158 = v134;
            uint64_t v135 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v135);
            if (v135 != buf) {
              free(v135);
            }
          }
        }
        *(double *)(a1 + 184) = *a5;
        *(double *)(a1 + 200) = *a5;
      }
      return 0;
    }
    if (!*(unsigned char *)(a1 + 11))
    {
      double v90 = *(double *)(a1 + 40);
      double v91 = *(double *)(a1 + 32) + *(double *)(a1 + 32);
      double v92 = *(double *)(a1 + 16);
      double v93 = *(double *)(a1 + 24);
      float v94 = v90 * (v93 + v93) - v92 * v91;
      *(float *)&double v91 = -(v90 * (v92 + v92)) - v93 * v91;
      *(float *)&double v90 = -*(float *)&v91;
      *(float *)&double v92 = v92 * (v92 + v92) + -1.0 + v93 * (v93 + v93);
      *(float *)&double v91 = sqrtf((float)((float)(*(float *)&v91 * *(float *)&v91) + (float)(v94 * v94))+ (float)(*(float *)&v92 * *(float *)&v92));
      v147[0] = (float)-v94 / *(float *)&v91;
      v147[1] = *(float *)&v90 / *(float *)&v91;
      float v148 = (float)-*(float *)&v92 / *(float *)&v91;
      uint64_t v145 = *a2;
      float v146 = *((float *)a2 + 2);
      float v95 = (float)((float)(*(float *)&v90 / *(float *)&v91) * v146) - (float)(v148 * *((float *)&v145 + 1));
      *(float *)&double v93 = (float)(v148 * *(float *)&v145) - (float)(v147[0] * v146);
      float v96 = (float)(v147[0] * *((float *)&v145 + 1))
          - (float)((float)(*(float *)&v90 / *(float *)&v91) * *(float *)&v145);
      float v97 = sqrtf((float)((float)(*(float *)&v93 * *(float *)&v93) + (float)(v95 * v95)) + (float)(v96 * v96));
      v144[0] = v95 / v97;
      v144[1] = *(float *)&v93 / v97;
      v144[2] = v96 / v97;
      *(float *)&uint64_t v145 = (float)((float)(*(float *)&v93 / v97) * v148)
                      - (float)((float)(v96 / v97) * (float)(*(float *)&v90 / *(float *)&v91));
      *((float *)&v145 + 1) = (float)((float)(v96 / v97) * v147[0]) - (float)((float)(v95 / v97) * v148);
      float v146 = (float)((float)(v95 / v97) * (float)(*(float *)&v90 / *(float *)&v91))
           - (float)((float)(*(float *)&v93 / v97) * v147[0]);
      sub_1904F1548((double *)v149, (float *)&v145, v144, v147);
      double v98 = *(double *)&v149[16];
      double v99 = v150;
      long long v100 = *(_OWORD *)v149;
      *(void *)(a1 + 16) = *(void *)&v149[8];
      *(double *)(a1 + 24) = v98;
      *(double *)(a1 + 32) = v99;
      *(void *)(a1 + 40) = v100;
      *(unsigned char *)(a1 + 11) = 1;
      *(double *)(a1 + 184) = *a5;
      *(unsigned char *)(a1 + 441) = 0;
      *(double *)float v157 = -*((double *)&v100 + 1);
      *(double *)&v157[8] = -v98;
      *(double *)&v157[16] = -v99;
      uint64_t v158 = v100;
      float64x2_t v155 = vcvtq_f64_f32(*v36);
      double v156 = *(float *)(a1 + 372);
      sub_190516D64((double *)v157, v155.f64, (double *)(a1 + 376));
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      double v101 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v102 = *(void *)(a1 + 376);
        uint64_t v103 = *(void *)(a1 + 384);
        double v104 = *(double *)(a1 + 392);
        *(_DWORD *)int buf = 134218496;
        *(void *)&uint8_t buf[4] = v102;
        *(_WORD *)&uint8_t buf[12] = 2048;
        *(void *)&buf[14] = v103;
        *(_WORD *)&unsigned char buf[22] = 2048;
        double v161 = v104;
        _os_log_impl(&dword_1902AF000, v101, OS_LOG_TYPE_DEBUG, "fCorrected, %.3f, %.3f, %.3f", buf, 0x20u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE878 != -1) {
          dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
        }
        uint64_t v127 = *(void *)(a1 + 376);
        uint64_t v128 = *(void *)(a1 + 384);
        uint64_t v129 = *(void *)(a1 + 392);
        *(_DWORD *)double v153 = 134218496;
        *(void *)&v153[4] = v127;
        *(_WORD *)&v153[12] = 2048;
        *(void *)&v153[14] = v128;
        *(_WORD *)&v153[22] = 2048;
        uint64_t v154 = v129;
        uint64_t v130 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v130);
        if (v130 != buf) {
          free(v130);
        }
      }
      BOOL v15 = 1;
      *(unsigned char *)(a1 + 9) = 1;
      *(void *)(a1 + 456) = 0;
      *(void *)(a1 + 464) = 0;
      *(void *)(a1 + 448) = 0x3FF0000000000000;
      *(double *)(a1 + 200) = *a5;
      return v15;
    }
    if (*(unsigned char *)(a1 + 472))
    {
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      int v37 = qword_1E929D7B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v38 = *(void *)(a1 + 448);
        uint64_t v39 = *(void *)(a1 + 456);
        double v40 = *(double *)(a1 + 464);
        double v41 = *a5;
        *(_DWORD *)int buf = 134219008;
        *(void *)&uint8_t buf[4] = v38;
        *(_WORD *)&uint8_t buf[12] = 2048;
        *(void *)&buf[14] = v39;
        *(_WORD *)&unsigned char buf[22] = 2048;
        double v161 = v40;
        __int16 v162 = 1024;
        *(_DWORD *)uint64_t v163 = v10;
        *(_WORD *)&v163[4] = 2048;
        *(double *)&v163[6] = v41;
        _os_log_impl(&dword_1902AF000, v37, OS_LOG_TYPE_DEBUG, "[!!!CompassInertialReference] x,%f,y,%f,z,%f,calibrationLevel,%d,timestamp,%lf", buf, 0x30u);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D7B8 != -1) {
          dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
        }
        uint64_t v122 = *(void *)(a1 + 448);
        uint64_t v123 = *(void *)(a1 + 456);
        double v124 = *(double *)(a1 + 464);
        double v125 = *a5;
        *(_DWORD *)__int16 v149 = 134219008;
        *(void *)&v149[4] = v122;
        *(_WORD *)&v149[12] = 2048;
        *(void *)&v149[14] = v123;
        *(_WORD *)&v149[22] = 2048;
        double v150 = v124;
        __int16 v151 = 1024;
        *(_DWORD *)uint64_t v152 = v10;
        *(_WORD *)&v152[4] = 2048;
        *(double *)&v152[6] = v125;
        BOOL v126 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v126);
        if (v126 != buf) {
          free(v126);
        }
      }
    }
  }
  if (!*(unsigned char *)(a1 + 440)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
    }
    double v42 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v42, OS_LOG_TYPE_DEBUG, "UpdatingYaw!", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      *(_WORD *)__int16 v149 = 0;
      double v121 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v121);
      if (v121 != buf) {
        free(v121);
      }
    }
  }
  BOOL v15 = 0;
  if (v33 <= 5.0 && v31 <= 8.0)
  {
    if (*a5 < *(double *)(a1 + 168)) {
      return 0;
    }
    *(double *)(a1 + 184) = *a5;
    if (*(unsigned char *)(a1 + 472))
    {
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      uint64_t v43 = qword_1E929D7B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
      {
        double v44 = *(float *)(a1 + 364);
        double v45 = *(float *)(a1 + 368);
        double v46 = *(float *)(a1 + 372);
        double v47 = *a5;
        *(_DWORD *)int buf = 134218752;
        *(double *)&uint8_t buf[4] = v44;
        *(_WORD *)&uint8_t buf[12] = 2048;
        *(double *)&buf[14] = v45;
        *(_WORD *)&unsigned char buf[22] = 2048;
        double v161 = v46;
        __int16 v162 = 2048;
        *(double *)uint64_t v163 = v47;
        _os_log_impl(&dword_1902AF000, v43, OS_LOG_TYPE_DEBUG, "[Magnetometer9] x,%f,y,%f,z,%f,timestamp,%lf", buf, 0x2Au);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D7B8 != -1) {
          dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
        }
        double v136 = *(float *)(a1 + 364);
        double v137 = *(float *)(a1 + 368);
        double v138 = *(float *)(a1 + 372);
        double v139 = *a5;
        *(_DWORD *)__int16 v149 = 134218752;
        *(double *)&v149[4] = v136;
        *(_WORD *)&v149[12] = 2048;
        *(double *)&v149[14] = v137;
        *(_WORD *)&v149[22] = 2048;
        double v150 = v138;
        __int16 v151 = 2048;
        *(double *)uint64_t v152 = v139;
        double v140 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v140);
        if (v140 != buf) {
          free(v140);
        }
      }
    }
    double v48 = *(float *)(a1 + 364);
    double v49 = *(float *)(a1 + 368);
    double v50 = *(float *)(a1 + 372);
    double v51 = sqrt(v49 * v49 + v48 * v48 + v50 * v50);
    if (v51 <= 0.0)
    {
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      double v106 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v106, OS_LOG_TYPE_INFO, "Warning: Hey! Compass outputs field magnitude 0.", buf, 2u);
      }
      if (!sub_1902D8400(115, 2)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      *(_WORD *)__int16 v149 = 0;
    }
    else
    {
      double v52 = v48 / v51;
      double v53 = v49 / v51;
      *(double *)__int16 v149 = v52;
      *(double *)&v149[8] = v53;
      double v54 = v50 / v51;
      *(double *)&v149[16] = v54;
      int v55 = *a4;
      if (!*a4) {
        goto LABEL_80;
      }
      uint64_t v56 = 0;
      double v57 = -(v25 * v53 + v52 * v24 + v54 * v26);
      do
      {
        *(double *)&v149[v56 * 8] = *(double *)&v149[v56 * 8] + v57 * v159[v56];
        ++v56;
      }
      while (v56 != 3);
      double v58 = sqrt(*(double *)&v149[8] * *(double *)&v149[8]+ *(double *)v149 * *(double *)v149+ *(double *)&v149[16] * *(double *)&v149[16]);
      if (v58 > 0.001)
      {
        *(double *)__int16 v149 = *(double *)v149 / v58;
        *(double *)&v149[8] = *(double *)&v149[8] / v58;
        *(double *)&v149[16] = *(double *)&v149[16] / v58;
LABEL_80:
        float v59 = sub_19051AB98(a1, (double *)v149, v10, v55 != 0);
        *(float64x2_t *)int buf = vnegq_f64(*(float64x2_t *)(a1 + 16));
        double v60 = *(double *)(a1 + 40);
        *(double *)&uint8_t buf[16] = -*(double *)(a1 + 32);
        double v161 = v60;
        *(float64x2_t *)float v157 = vcvtq_f64_f32(*v36);
        *(double *)&v157[16] = *(float *)(a1 + 372);
        sub_190516D64((double *)buf, (double *)v157, (double *)(a1 + 376));
        BOOL v15 = v59 >= 0.1;
        if (v59 < 0.1)
        {
          sub_190518E58(a1);
          *(unsigned char *)(a1 + 440) = 0;
        }
        return v15;
      }
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      double v110 = off_1EB3BE870;
      if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v110, OS_LOG_TYPE_INFO, "Warning: Hey! Compass outputs field magnitude 0.", buf, 2u);
      }
      if (!sub_1902D8400(115, 2)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1EE0);
      }
      *(_WORD *)float v157 = 0;
    }
LABEL_175:
    double v116 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const BOOL &, const BOOL &, const CFTimeInterval &)", "CoreLocation: %s\n", v116);
    if (v116 != buf) {
      free(v116);
    }
    return 0;
  }
  return v15;
}

float sub_19051AB98(uint64_t a1, double *a2, int a3, int a4)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 9) = 1;
  sub_190516D64((double *)(a1 + 16), (double *)(a1 + 448), &v83);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  double v10 = *(double *)(a1 + 32);
  double v11 = *(double *)(a1 + 40);
  double v13 = *(double *)(a1 + 16);
  double v12 = *(double *)(a1 + 24);
  double v14 = v11 * (v12 + v12);
  double v15 = -(v11 * (v13 + v13));
  double v16 = v83;
  double v17 = v84;
  float v18 = v83;
  float v19 = v84;
  double v20 = v85;
  float v21 = v85;
  v82[0] = 0;
  *(float *)&v82[1] = v21;
  *(float *)&v82[2] = -v19;
  float v52 = -v19;
  *(float *)&v82[3] = -v21;
  v82[4] = 0;
  *(float *)&v82[5] = v18;
  *(float *)&v82[6] = v19;
  float v53 = v19;
  *(float *)&v82[7] = -v18;
  v82[8] = 0;
  do
  {
    for (uint64_t i = 0; i != 9; i += 3)
      *(_DWORD *)&v80[v8 * 4 + i * 4] = v82[v8 + i];
    ++v9;
    ++v8;
  }
  while (v9 != 3);
  double v23 = v10 + v10;
  double v24 = v14 - v13 * v23;
  double v25 = v15 - v12 * v23;
  double v26 = v13 * (v13 + v13) + -1.0 + v12 * (v12 + v12);
  bzero(&v81, 0x24uLL);
  int32x2_t v78 = vdup_n_s32(0x368637BDu);
  int v79 = 914765757;
  float v27 = *a2 - v16;
  float v28 = a2[1] - v17;
  *(float *)double v77 = v27;
  *(float *)&v77[1] = v28;
  float v29 = a2[2] - v20;
  *(float *)&v77[2] = v29;
  sub_1905165DC(&v74, (uint64_t *)(a1 + 112), (uint64_t)v80, (uint64_t)&v78, (uint64_t)v77, (uint64_t)v73);
  double v30 = v25 * v75 + v74 * v24 + v76 * v26;
  double v74 = v24 * v30;
  double v75 = v25 * v30;
  double v31 = v26 * v30;
  double v32 = v24 * v30;
  double v76 = v31;
  double v54 = v75;
  float v33 = sqrt(v75 * v75 + v74 * v74 + v31 * v31) * 57.2957802;
  if (*(unsigned char *)(a1 + 472))
  {
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    float v34 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v35 = *(void *)(a1 + 184);
      *(_DWORD *)int buf = 134218752;
      double v56 = v16;
      __int16 v57 = 2048;
      double v58 = v17;
      __int16 v59 = 2048;
      double v60 = v20;
      __int16 v61 = 2048;
      *(void *)float v62 = v35;
      _os_log_impl(&dword_1902AF000, v34, OS_LOG_TYPE_DEBUG, "[ExpectedCompass] %f,%f,%f,%f", buf, 0x2Au);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      double v48 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "float CLSensorFusion9AxisMekf::doCompassMeasurementUpdate(double *, double, int, BOOL)", "CoreLocation: %s\n", v48);
      if (v48 != (char *)buf) {
        free(v48);
      }
    }
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    double v36 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v37 = *a2;
      double v38 = a2[1];
      double v39 = a2[2];
      uint64_t v40 = *(void *)(a1 + 184);
      *(_DWORD *)int buf = 134219008;
      double v56 = v37;
      __int16 v57 = 2048;
      double v58 = v38;
      __int16 v59 = 2048;
      double v60 = v39;
      __int16 v61 = 1024;
      *(_DWORD *)float v62 = a3;
      *(_WORD *)&v62[4] = 2048;
      *(void *)&v62[6] = v40;
      _os_log_impl(&dword_1902AF000, v36, OS_LOG_TYPE_DEBUG, "[TrueCompass] %f,%f,%f,%d,%f", buf, 0x30u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      double v49 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "float CLSensorFusion9AxisMekf::doCompassMeasurementUpdate(double *, double, int, BOOL)", "CoreLocation: %s\n", v49);
      if (v49 != (char *)buf) {
        free(v49);
      }
    }
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    double v41 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v42 = *(void *)(a1 + 184);
      *(_DWORD *)int buf = 134220288;
      double v56 = 0.0;
      __int16 v57 = 2048;
      double v58 = v21;
      __int16 v59 = 2048;
      double v60 = v52;
      __int16 v61 = 2048;
      *(double *)float v62 = (float)-v21;
      *(_WORD *)&v62[8] = 2048;
      *(void *)&v62[10] = 0;
      __int16 v63 = 2048;
      double v64 = v18;
      __int16 v65 = 2048;
      double v66 = v53;
      __int16 v67 = 2048;
      double v68 = (float)-v18;
      __int16 v69 = 2048;
      uint64_t v70 = 0;
      __int16 v71 = 2048;
      uint64_t v72 = v42;
      _os_log_impl(&dword_1902AF000, v41, OS_LOG_TYPE_DEBUG, "[MagCCross] %f,%f,%f,%f,%f,%f,%f,%f,%f,%f", buf, 0x66u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      double v50 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "float CLSensorFusion9AxisMekf::doCompassMeasurementUpdate(double *, double, int, BOOL)", "CoreLocation: %s\n", v50);
      if (v50 != (char *)buf) {
        free(v50);
      }
    }
    if (qword_1E929D7B8 != -1) {
      dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
    }
    uint64_t v43 = qword_1E929D7B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D7B0, OS_LOG_TYPE_DEBUG))
    {
      double v44 = fabsf(*(float *)(a1 + 436));
      double v45 = *(double *)(a1 + 184);
      *(_DWORD *)int buf = 134219264;
      double v56 = v32;
      __int16 v57 = 2048;
      double v58 = v54;
      __int16 v59 = 2048;
      double v60 = v31;
      __int16 v61 = 2048;
      *(double *)float v62 = v33;
      *(_WORD *)&v62[8] = 2048;
      *(double *)&v62[10] = v44;
      __int16 v63 = 2048;
      double v64 = v45;
      _os_log_impl(&dword_1902AF000, v43, OS_LOG_TYPE_DEBUG, "[MagCorrectionDX] %f,%f,%f,angle,%.3f,sumRot,%.3f,%f", buf, 0x3Eu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7B8 != -1) {
        dispatch_once(&qword_1E929D7B8, &unk_1EDFD3B60);
      }
      double v51 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "float CLSensorFusion9AxisMekf::doCompassMeasurementUpdate(double *, double, int, BOOL)", "CoreLocation: %s\n", v51);
      if (v51 != (char *)buf) {
        free(v51);
      }
    }
  }
  if (a4 && v33 > 3.0)
  {
    double v46 = (float)(sqrtf(v33) / v33);
    double v74 = v32 * v46;
    double v75 = v54 * v46;
    double v76 = v31 * v46;
  }
  sub_190518DE4(a1, &v74);
  return v33;
}

double sub_19051B53C(uint64_t a1)
{
  return *(double *)(a1 + 16);
}

double sub_19051B544(uint64_t a1)
{
  return *(double *)(a1 + 24);
}

double sub_19051B54C(uint64_t a1)
{
  return *(double *)(a1 + 32);
}

double sub_19051B554(uint64_t a1)
{
  return *(double *)(a1 + 40);
}

uint64_t sub_19051B55C(_DWORD *a1, _DWORD *a2)
{
  *a2 = a1[39];
  a2[1] = a1[40];
  a2[2] = a1[41];
  return 1;
}

BOOL sub_19051B57C(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a1 + 176);
  if (v2 <= 0.0)
  {
    *(void *)a2 = 0;
    float v10 = 0.0;
  }
  else
  {
    double v3 = *(double *)(a1 + 40);
    double v4 = *(double *)(a1 + 32) + *(double *)(a1 + 32);
    double v5 = *(double *)(a1 + 16);
    double v6 = *(double *)(a1 + 24);
    double v7 = v3 * (v6 + v6) - v5 * v4;
    double v8 = -(v3 * (v5 + v5)) - v6 * v4;
    double v9 = v5 * (v5 + v5) + -1.0 + v6 * (v6 + v6);
    *(float *)&double v5 = *(float *)(a1 + 352) - v7;
    *(_DWORD *)a2 = LODWORD(v5);
    *(float *)&double v8 = *(float *)(a1 + 356) - v8;
    *(_DWORD *)(a2 + 4) = LODWORD(v8);
    float v10 = *(float *)(a1 + 360) - v9;
  }
  BOOL result = v2 > 0.0;
  *(float *)(a2 + 8) = v10;
  return result;
}

uint64_t sub_19051B60C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 9);
}

uint64_t sub_19051B614(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 10);
}

float sub_19051B61C(uint64_t a1)
{
  return *(double *)(a1 + 64);
}

os_log_t sub_19051B628()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Sensors");
  qword_1E929D7B0 = (uint64_t)result;
  return result;
}

uint64_t sub_19051CBA0(float a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a1 < 0.0)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1F00);
    }
    double v3 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 134217984;
      double v6 = a1;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_FAULT, "Assertion failed: arg >= 0.0, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMFFTProcessor.cpp, line 41,arg,%f.", buf, 0xCu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1F00);
      }
      double v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "static int CMFFTProcessor::idxRound(scalar_32)", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
  return (int)(float)(a1 + 0.5);
}

float sub_19051CD64(int a1, int a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1 >= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1F00);
    }
    float v10 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 67109376;
      int v13 = a1;
      __int16 v14 = 1024;
      int v15 = a2;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_FAULT, "Assertion failed: start < end, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMFFTProcessor.cpp, line 74,start,%d,end,%d.", buf, 0xEu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1F00);
      }
      double v11 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "static float CMFFTProcessor::getSum(int, int, const FrequencyData *)", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
    }
  }
  float result = 0.0;
  if (a1 <= a2)
  {
    int v7 = a2 - a1 + 1;
    double v8 = (float *)(a3 + 4 * a1);
    do
    {
      float v9 = *v8++;
      float result = result + v9;
      --v7;
    }
    while (v7);
  }
  return result;
}

float sub_19051CF68(int a1, int a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1 >= a2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD1F00);
    }
    int v13 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 67109376;
      int v16 = a1;
      __int16 v17 = 1024;
      int v18 = a2;
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_FAULT, "Assertion failed: start < end, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMFFTProcessor.cpp, line 96,start,%d,end,%d.", buf, 0xEu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD1F00);
      }
      __int16 v14 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "static float CMFFTProcessor::getMaxInRange(int, int, const FrequencyData *)", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
    return *(float *)(a3 + 4 * a1);
  }
  else
  {
    double v6 = (float *)(a3 + 4 * a1);
    float v8 = *v6;
    int v7 = v6 + 1;
    float result = v8;
    uint64_t v10 = a2 - (uint64_t)a1;
    do
    {
      float v11 = *v7++;
      float v12 = v11;
      if (v11 > result) {
        float result = v12;
      }
      --v10;
    }
    while (v10);
  }
  return result;
}

void sub_19051D170()
{
}

void sub_19051D208(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10F1C40E59F67ADLL);
  _Unwind_Resume(a1);
}

void sub_19051D230(void *a1)
{
  sub_1905A1098(a1);

  JUMPOUT(0x192FCC980);
}

double sub_19051D268(uint64_t a1, int a2, double *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3868);
    }
    double v4 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 67240192;
      LODWORD(v16) = a2;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "[AccessoryHeartRate] Unrecognized update interval notification %{public}d", buf, 8u);
    }
    double v5 = 0.0;
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC3868);
      }
      double v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual CFTimeInterval CLAccessoryHeartRate::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  else
  {
    sub_1905A2C68(a1);
    double v9 = *a3;
    if (*a3 > 0.0) {
      *(unsigned char *)(a1 + 30) = 0;
    }
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3868);
    }
    double v5 = fmax(v9, 1.0);
    uint64_t v10 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)int buf = 134349056;
      double v16 = v5;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_INFO, "[AccessoryHeartRate] Setting update interval to %{public}f", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC3868);
      }
      __int16 v14 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryHeartRate::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
    double v11 = rint(v5 * 1000000.0);
    if (v5 < 0.0) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = (uint64_t)v11;
    }
    sub_1902CDC50(*(void *)(a1 + 32), v12);
  }
  return v5;
}

void sub_19051D5B8(uint64_t a1)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  Dataint Value = IOHIDEventGetDataValue();
  Integerint Value = IOHIDEventGetIntegerValue();
  if (!DataValue)
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3868);
    }
    int v18 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_ERROR, "[AccessoryHeartRate] Invalid payload", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3868);
    }
    LOWORD(v28) = 0;
LABEL_30:
    double v22 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual void CLAccessoryHeartRate::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v22);
    if (v22 != (char *)buf) {
      free(v22);
    }
    return;
  }
  int v4 = IntegerValue;
  if (IntegerValue == 16)
  {
    unint64_t TimeStamp = IOHIDEventGetTimeStamp();
    double v6 = sub_1902D8D34(TimeStamp);
    double v23 = v6;
    int v7 = *(unsigned __int8 *)(DataValue + 13);
    int v24 = v7;
    _H9 = *(_WORD *)(DataValue + 14);
    __asm { FCVT            S0, H9 }
    int v25 = _S0;
    uint64_t v14 = *(void *)(DataValue + 5);
    uint64_t v26 = v14;
    int v15 = *(_DWORD *)(DataValue + 1);
    int v27 = v15;
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3868);
    }
    double v16 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEBUG))
    {
      __asm { FCVT            D1, H9 }
      *(_DWORD *)int buf = 67241731;
      int v41 = v15;
      __int16 v42 = 1025;
      *(_DWORD *)uint64_t v43 = v7;
      *(_WORD *)&v43[4] = 2050;
      *(void *)&v43[6] = _D1;
      __int16 v44 = 2050;
      uint64_t v45 = v14;
      __int16 v46 = 2050;
      double v47 = v6;
      __int16 v48 = 1040;
      int v49 = 16;
      __int16 v50 = 2097;
      uint64_t v51 = DataValue;
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_DEBUG, "[AccessoryHeartRate] seq,%{public}d,heartrate,%{private}u,confidence,%{public}10.10f,sensorTime,%{public}llu,timestamp,%{public}20.20f,payload,{%{private}.*P}", buf, 0x3Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC3868);
      }
      __asm { FCVT            D0, H9 }
      int v28 = 67241731;
      int v29 = v15;
      __int16 v30 = 1025;
      *(_DWORD *)double v31 = v7;
      *(_WORD *)&v31[4] = 2050;
      *(void *)&v31[6] = _D0;
      __int16 v32 = 2050;
      uint64_t v33 = v14;
      __int16 v34 = 2050;
      double v35 = v6;
      __int16 v36 = 1040;
      int v37 = 16;
      __int16 v38 = 2097;
      uint64_t v39 = DataValue;
      float v21 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLAccessoryHeartRate::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v21);
      if (v21 != (char *)buf) {
        free(v21);
      }
    }
    sub_1902D8BCC(a1, 0, (uint64_t)&v23, 32);
    return;
  }
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC3868);
  }
  uint64_t v19 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 68157955;
    int v41 = v4;
    __int16 v42 = 2097;
    *(void *)uint64_t v43 = DataValue;
    _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_ERROR, "[AccessoryHeartRate] Invalid payload: %{private}.*P", buf, 0x12u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC3868);
    }
    int v28 = 68157955;
    int v29 = v4;
    __int16 v30 = 2097;
    *(void *)double v31 = DataValue;
    goto LABEL_30;
  }
}

os_log_t sub_19051DAD4()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1EB3BE830 = (uint64_t)result;
  return result;
}

void sub_19051E260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a12) {
    sub_1902D8B58(a12);
  }
  sub_1902D8B58(v35);
  _Unwind_Resume(a1);
}

void *sub_19051E300(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Dictionary = (const __CFDictionary *)CLConnectionMessage::getDictionary(*a2);
  sub_19045CAD8(v17, Dictionary);
  if ((*(int (**)(void *))(v17[0] + 856))(v17) > 0)
  {
    if (!*(void *)(*(void *)(a1 + 32) + 24)) {
      return sub_19045CCC8(v17);
    }
    memset(&v16, 0, sizeof(v16));
    sub_19045F468((uint64_t)v17, "kCLConnectionMessageNameKey", (uint64_t)&v16);
    if (!std::string::compare(&v16, "GestureDetected"))
    {
      int v10 = 0;
    }
    else
    {
      if (std::string::compare(&v16, "GestureCanceled"))
      {
        if (qword_1E929D6D0 != -1) {
          dispatch_once(&qword_1E929D6D0, &unk_1EDFD3AE0);
        }
        int v4 = qword_1E929D6D8;
        if (os_log_type_enabled((os_log_t)qword_1E929D6D8, OS_LOG_TYPE_FAULT))
        {
          double v5 = &v16;
          if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            double v5 = (std::string *)v16.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)int buf = 136446210;
          float v21 = v5;
          _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "Unexpected ear gesture state received: %{public}s", buf, 0xCu);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D6D0 != -1) {
            dispatch_once(&qword_1E929D6D0, &unk_1EDFD3AE0);
          }
          double v6 = &v16;
          if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            double v6 = (std::string *)v16.__r_.__value_.__r.__words[0];
          }
          int v18 = 136446210;
          uint64_t v19 = v6;
          int v7 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "-[CMGestureManagerInternal startGestureUpdatesWithHandlerPrivate:]_block_invoke", "CoreLocation: %s\n", v7);
          if (v7 != (char *)buf) {
            free(v7);
          }
        }
LABEL_34:
        if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v16.__r_.__value_.__l.__data_);
        }
        return sub_19045CCC8(v17);
      }
      int v10 = 1;
    }
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = sub_19051E7A0;
    block[3] = &unk_1EDFD1268;
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      sub_190347AFC(&__p, v16.__r_.__value_.__l.__data_, v16.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v16;
    }
    void block[4] = v11;
    int v15 = v10;
    dispatch_async(MEMORY[0x1E4F14428], block);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    goto LABEL_34;
  }
  if (qword_1E929D6D0 != -1) {
    dispatch_once(&qword_1E929D6D0, &unk_1EDFD3AE0);
  }
  float v8 = qword_1E929D6D8;
  if (os_log_type_enabled((os_log_t)qword_1E929D6D8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_ERROR, "Could not get dictionary for kCLConnectionMessageGesture", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6D0 != -1) {
      dispatch_once(&qword_1E929D6D0, &unk_1EDFD3AE0);
    }
    LOWORD(v16.__r_.__value_.__l.__data_) = 0;
    double v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMGestureManagerInternal startGestureUpdatesWithHandlerPrivate:]_block_invoke", "CoreLocation: %s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
  return sub_19045CCC8(v17);
}

void sub_19051E760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  sub_19045CCC8(&a28);
  _Unwind_Resume(a1);
}

uint64_t sub_19051E7A0(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D6D0 != -1) {
    dispatch_once(&qword_1E929D6D0, &unk_1EDFD3AE0);
  }
  double v2 = qword_1E929D6D8;
  if (os_log_type_enabled((os_log_t)qword_1E929D6D8, OS_LOG_TYPE_DEFAULT))
  {
    double v3 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      double v3 = (void *)*v3;
    }
    *(_DWORD *)int buf = 136446210;
    int v7 = v3;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "Dispatching ear gesture %{public}s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6D0 != -1) {
      dispatch_once(&qword_1E929D6D0, &unk_1EDFD3AE0);
    }
    double v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMGestureManagerInternal startGestureUpdatesWithHandlerPrivate:]_block_invoke", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void *sub_19051E980(uint64_t a1, uint64_t a2)
{
  os_log_t result = (void *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0) {
    return sub_190347AFC(result, *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  long long v3 = *(_OWORD *)(a2 + 40);
  result[2] = *(void *)(a2 + 56);
  *(_OWORD *)os_log_t result = v3;
  return result;
}

void sub_19051E9B0(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

void sub_19051E9C4(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D6D0 != -1) {
    dispatch_once(&qword_1E929D6D0, &unk_1EDFD3AE0);
  }
  long long v3 = qword_1E929D6D8;
  if (os_log_type_enabled((os_log_t)qword_1E929D6D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = CLConnectionMessage::name(*a2);
    if (*(char *)(v4 + 23) >= 0) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = *(void *)v4;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v8 = v5;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEBUG, "Default handler received message %{public}s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6D0 != -1) {
      dispatch_once(&qword_1E929D6D0, &unk_1EDFD3AE0);
    }
    CLConnectionMessage::name(*a2);
    double v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMGestureManagerInternal startGestureUpdatesWithHandlerPrivate:]_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
}

uint64_t sub_19051EE88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_stopGestureUpdatesPrivate, a3);
}

uint64_t sub_19051EF04(uint64_t a1)
{
  uint64_t v3 = a1 + 32;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v3 + 8);
  if (v2) {
    return MEMORY[0x1F4181798](v1, sel_startGestureUpdatesWithHandlerPrivate_, v2);
  }
  else {
    return MEMORY[0x1F4181798](v1, sel_stopGestureUpdatesPrivate, 0);
  }
}

void sub_19051EFE4(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D6D0 != -1) {
    dispatch_once(&qword_1E929D6D0, &unk_1EDFD3AE0);
  }
  uint64_t v2 = qword_1E929D6D8;
  if (os_log_type_enabled((os_log_t)qword_1E929D6D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "#Notice Calling ear gesture handler", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6D0 != -1) {
      dispatch_once(&qword_1E929D6D0, &unk_1EDFD3AE0);
    }
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMGestureManager gestureHandler]_block_invoke", "CoreLocation: %s\n", v3);
    if (v3 != (char *)buf) {
      free(v3);
    }
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = *(void *)(*(void *)(a1 + 32) + 24);
}

os_log_t sub_19051F1F4()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "EarGesture");
  qword_1E929D6D8 = (uint64_t)result;
  return result;
}

uint64_t sub_19051F284(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_19051F298(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v8 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v6, 0);
  if (*a2
    && (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v8),
        (uint64_t v11 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v10, @"CMMotionStateSimResult")) != 0)&& (v14 = *(void *)(a1 + 32), *(void *)(v14 + 72))&& *(unsigned char *)(v14 + 88))
  {
    *(void *)(*(void *)(a1 + 32) + 96) = objc_msgSend_integerValue(v11, v12, v13);
    *(unsigned char *)(*(void *)(a1 + 32) + 88) = 0;
    int v15 = *(NSObject **)(*(void *)(a1 + 32) + 72);
    dispatch_semaphore_signal(v15);
  }
  else
  {
    if (qword_1E929D7A0 != -1) {
      dispatch_once(&qword_1E929D7A0, &unk_1EDFD3EA0);
    }
    std::string v16 = qword_1E929D7A8;
    if (os_log_type_enabled((os_log_t)qword_1E929D7A8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v16, OS_LOG_TYPE_ERROR, "Could not parse dictionary for kCLConnectionMessageMotionStateSim", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D7A0 != -1) {
        dispatch_once(&qword_1E929D7A0, &unk_1EDFD3EA0);
      }
      uint64_t v17 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMActivityManagerInternal connect]_block_invoke", "CoreLocation: %s\n", v17);
      if (v17 != (char *)buf) {
        free(v17);
      }
    }
  }
}

intptr_t sub_19051F4F8(intptr_t result)
{
  intptr_t v1 = result;
  uint64_t v2 = *(void *)(result + 32);
  if (*(unsigned char *)(v2 + 56) && *(void *)(v2 + 40))
  {
    *(unsigned char *)(v2 + 56) = 0;
    *(void *)(*(void *)(result + 32) + 64) = 3;
    os_log_t result = dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(result + 32) + 40));
    uint64_t v2 = *(void *)(v1 + 32);
  }
  if (*(unsigned char *)(v2 + 88) && *(void *)(v2 + 72))
  {
    *(unsigned char *)(v2 + 88) = 0;
    *(void *)(*(void *)(v1 + 32) + 96) = 3;
    uint64_t v3 = *(NSObject **)(*(void *)(v1 + 32) + 72);
    return dispatch_semaphore_signal(v3);
  }
  return result;
}

void sub_19051F590(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D7A0 != -1) {
    dispatch_once(&qword_1E929D7A0, &unk_1EDFD3EA0);
  }
  uint64_t v3 = qword_1E929D7A8;
  if (os_log_type_enabled((os_log_t)qword_1E929D7A8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = CLConnectionMessage::name(*a2);
    if (*(char *)(v4 + 23) >= 0) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = *(void *)v4;
    }
    *(_DWORD *)int buf = 136315138;
    uint64_t v8 = v5;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEBUG, "Default handler received message %s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D7A0 != -1) {
      dispatch_once(&qword_1E929D7A0, &unk_1EDFD3EA0);
    }
    CLConnectionMessage::name(*a2);
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "-[CMActivityManagerInternal connect]_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
}

void sub_19051F8C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  if (v10) {
    sub_1902D8B58(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_19051FA8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a13) {
    sub_1902D8B58(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_19051FC08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15) {
    sub_1902D8B58(a15);
  }
  if (a17) {
    sub_1902D8B58(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19051FC34(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v3 = *a2;
  if (*a2
    && (uint64_t v4 = (objc_class *)objc_opt_class(),
        (ObjectOfClass = (void *)CLConnectionMessage::getObjectOfClass(v3, v4)) != 0))
  {
    uint64_t result = objc_msgSend_integerValue(ObjectOfClass, v6, v7);
  }
  else
  {
    uint64_t result = 3;
  }
  *(void *)(*(void *)(a1 + 32) + 104) = result;
  return result;
}

uint64_t sub_19051FDB0(uint64_t a1)
{
  uint64_t v3 = a1 + 32;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v3 + 8);
  if (v2) {
    return MEMORY[0x1F4181798](v1, sel_startActivityUpdatesWithHandlerPrivate_, v2);
  }
  else {
    return MEMORY[0x1F4181798](v1, sel_stopActivityUpdatesPrivate, 0);
  }
}

uint64_t sub_19051FE90(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 40) + 8) + 40) = *(void *)(*(void *)(result + 32) + 16);
  return result;
}

dispatch_queue_t sub_190520000(dispatch_queue_t result)
{
  if (!*((void *)result[4].isa + 5))
  {
    dispatch_queue_t v1 = result;
    *((void *)result[4].isa + 5) = dispatch_semaphore_create(0);
    if (!*((void *)v1[4].isa + 5)) {
      *(void *)(*((void *)v1[5].isa + 1) + 24) = 3;
    }
    uint64_t result = dispatch_queue_create("com.apple.CoreMotion.SidebandOverride", 0);
    *((void *)v1[4].isa + 6) = result;
    if (!*((void *)v1[4].isa + 6)) {
      *(void *)(*((void *)v1[5].isa + 1) + 24) = 3;
    }
  }
  return result;
}

uint64_t sub_19052008C(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_overrideOscarSideband_withState_, *(unsigned __int8 *)(a1 + 48));
}

uint64_t sub_19052009C(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_simulateMotionState_withState_, *(unsigned __int8 *)(a1 + 48));
}

uint64_t sub_1905200AC(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_simulateMotionStateYouthWithState_, *(void *)(a1 + 40));
}

os_log_t sub_1905200B8()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Activity");
  qword_1E929D7A8 = (uint64_t)result;
  return result;
}

void *sub_1905200E8(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_1902C3EE0((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_190520148(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19052015C(uint64_t a1)
{
  return a1;
}

void sub_1905201A0(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  uint64_t v2 = *(void ***)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a1 + 48) = 0;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *(void *)(a1 + 24);
      uint64_t v2 = (void **)(*(void *)(a1 + 16) + 8);
      *(void *)(a1 + 16) = v2;
      unint64_t v4 = v5 - (void)v2;
    }
    while (v4 > 0x10);
  }
  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 512;
    goto LABEL_7;
  }
  if (v4 >> 3 == 2)
  {
    uint64_t v6 = 1024;
LABEL_7:
    *(void *)(a1 + 40) = v6;
  }
  sub_190520394(a1 + 56, *(void **)(a1 + 64));
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 64) = 0;
  uint64_t v8 = *(void **)(a1 + 88);
  uint64_t v7 = (void *)(a1 + 88);
  *(v7 - 2) = 0;
  sub_1904B9BBC((uint64_t)(v7 - 1), v8);
  *(v7 - 1) = v7;
  *uint64_t v7 = 0;
  v7[1] = 0;
}

void sub_19052024C(uint64_t a1, void *a2)
{
  unint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)sub_1902C0520(v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      int v15 = *(uint64_t **)(a1 + 8);
      std::string v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        std::string v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      float v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        unint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

os_log_t sub_190520364()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Pressure");
  qword_1E929D780 = (uint64_t)result;
  return result;
}

void sub_190520394(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_190520394(a1, *a2);
    sub_190520394(a1, a2[1]);
    sub_190520B54(a2 + 5);
    operator delete(a2);
  }
}

float sub_1905203F0(char *a1, uint64_t a2, char *a3, uint64_t a4)
{
  if (a2 == a4
    || (uint64_t v4 = a4,
        uint64_t v5 = a3,
        uint64_t v6 = (float *)a2,
        uint64_t v7 = a1,
        uint64_t v8 = a2 - *(void *)a1,
        ((a4 - *(void *)a3) >> 2) + ((a3 - a1) << 7) - (v8 >> 2) <= 0))
  {
    __assert_rtn("getMedianInPlace", "CMPressureUtilities.h", 163, "size > 0");
  }
  unint64_t v90 = ((a4 - *(void *)a3) >> 2) + ((a3 - a1) << 7) - (v8 >> 2);
  uint64_t v9 = (char *)sub_190520A78(a1, a2, v90 >> 1);
  unint64_t v11 = v10;
  if (v10 != (float *)v4)
  {
    uint64_t v12 = v9;
    uint64_t v13 = v6;
    uint64_t v14 = v6;
    int v15 = v7;
    while (1)
    {
      if ((float *)v4 == v14) {
        goto LABEL_124;
      }
      std::string v16 = *(float **)v5;
      uint64_t v17 = *(float **)v15;
      uint64_t v18 = ((v4 - *(void *)v5) >> 2) + ((v5 - v15) << 7) - (((uint64_t)v14 - *(void *)v15) >> 2);
      if ((unint64_t)v18 < 2) {
        goto LABEL_124;
      }
      if (v18 == 3)
      {
        uint64_t v72 = v14 + 1;
        uint64_t v73 = (uint64_t)v15;
        if ((char *)(v14 + 1) - (char *)v17 == 4096)
        {
          uint64_t v73 = (uint64_t)(v15 + 8);
          uint64_t v72 = (float *)*((void *)v15 + 1);
        }
        if ((float *)v4 == v16)
        {
          uint64_t v74 = *((void *)v5 - 1);
          v5 -= 8;
          uint64_t v4 = v74 + 4096;
        }
        sub_190520ACC((uint64_t)v15, v14, v73, v72, (uint64_t)v5, (float *)(v4 - 4));
        goto LABEL_124;
      }
      if (v18 == 2)
      {
        if ((float *)v4 == v16) {
          uint64_t v4 = *((void *)v5 - 1) + 4096;
        }
        float v75 = *(float *)(v4 - 4);
        if (v75 < *v14)
        {
          float v76 = *v13;
          float *v13 = v75;
          *(float *)(v4 - 4) = v76;
        }
        goto LABEL_124;
      }
      if (v18 <= 7)
      {
        uint64_t v77 = v4;
        if (v16 == (float *)v4) {
          uint64_t v77 = *((void *)v5 - 1) + 4096;
        }
        int32x2_t v78 = (float *)(v77 - 4);
        while (v13 != v78)
        {
          int v79 = (float *)v4;
          if (v13 != (float *)v4)
          {
            uint64_t v80 = v17;
            int v79 = v13;
            uint64_t v81 = v13;
            double v82 = v15;
            while (1)
            {
              if ((char *)++v81 - (char *)v80 == 4096)
              {
                double v83 = (float *)*((void *)v82 + 1);
                v82 += 8;
                uint64_t v80 = v83;
                uint64_t v81 = v83;
              }
              if (v81 == (float *)v4) {
                break;
              }
              if (*v81 < *v79) {
                int v79 = v81;
              }
            }
          }
          if (v79 != v13)
          {
            float v84 = *v13;
            float *v13 = *v79;
            float *v79 = v84;
          }
          if ((char *)++v13 - (char *)v17 == 4096)
          {
            double v85 = (float *)*((void *)v15 + 1);
            v15 += 8;
            uint64_t v17 = v85;
            uint64_t v13 = v85;
          }
        }
        goto LABEL_124;
      }
      uint64_t v20 = sub_190520A78(v15, (uint64_t)v14, (unint64_t)v18 >> 1);
      float v21 = v19;
      double v91 = v5;
      uint64_t v22 = v4;
      if ((float *)v4 == v16)
      {
        v5 -= 8;
        uint64_t v22 = *((void *)v91 - 1) + 4096;
      }
      double v23 = (float *)(v22 - 4);
      int v24 = sub_190520ACC((uint64_t)v15, v14, (uint64_t)v20, v19, (uint64_t)v5, (float *)(v22 - 4));
      float v25 = *v14;
      if (*v14 >= *v21) {
        break;
      }
LABEL_19:
      int v28 = v14 + 1;
      int v29 = *(float **)v15;
      __int16 v30 = *(float **)v15;
      double v31 = v15;
      if ((float *)((char *)v14 - *(void *)v15 + 4) == (float *)4096)
      {
        double v31 = v15 + 8;
        __int16 v30 = (float *)*((void *)v15 + 1);
        int v28 = v30;
      }
      if (v31 < v5 || v31 == v5 && v28 < v23)
      {
        while (1)
        {
          float v32 = *v21;
          while (1)
          {
            float v33 = *v28;
            if (*v28 >= v32) {
              break;
            }
            if ((char *)++v28 - (char *)v30 == 4096)
            {
              __int16 v34 = (float *)*((void *)v31 + 1);
              v31 += 8;
              __int16 v30 = v34;
              int v28 = v34;
            }
          }
          double v35 = *(float **)v5;
          do
          {
            if (v23 == v35)
            {
              __int16 v36 = (float *)*((void *)v5 - 1);
              v5 -= 8;
              double v35 = v36;
              double v23 = v36 + 1024;
            }
            float v37 = *--v23;
            float v38 = v37;
          }
          while (v37 >= v32);
          if (v31 >= v5 && (v31 != v5 || v28 >= v23)) {
            break;
          }
          BOOL v39 = v21 == v28;
          *v28++ = v38;
          float *v23 = v33;
          ++v24;
          if (v39) {
            float v21 = v23;
          }
          if ((char *)v28 - (char *)v30 == 4096)
          {
            uint64_t v40 = (float *)*((void *)v31 + 1);
            v31 += 8;
            __int16 v30 = v40;
            int v28 = v40;
          }
        }
      }
      uint64_t v5 = v91;
      if (v28 != v21)
      {
        float v41 = *v28;
        if (*v21 < *v28)
        {
          *int v28 = *v21;
          *float v21 = v41;
          ++v24;
        }
      }
      if (v28 == v11) {
        goto LABEL_124;
      }
      if (!v24)
      {
        if (v31 > v12 || (uint64_t v43 = v30, v44 = v28, v45 = v31, v28 > v11) && (uint64_t v43 = v30, v44 = v28, v45 = v31, v31 == v12))
        {
          __int16 v46 = v14;
          double v47 = v15;
          while (1)
          {
            __int16 v48 = v46 + 1;
            if ((char *)(v46 + 1) - (char *)v29 == 4096)
            {
              int v49 = (float *)*((void *)v47 + 1);
              v47 += 8;
              int v29 = v49;
              __int16 v48 = v49;
            }
            if (v48 == v28) {
              break;
            }
            BOOL v50 = *v48 < *v46;
            __int16 v46 = v48;
            if (v50) {
              goto LABEL_44;
            }
          }
        }
        else
        {
          while (1)
          {
            uint64_t v51 = v44 + 1;
            if ((char *)(v44 + 1) - (char *)v43 == 4096)
            {
              uint64_t v52 = (float *)*((void *)v45 + 1);
              v45 += 8;
              uint64_t v43 = v52;
              uint64_t v51 = v52;
            }
            if (v51 == (float *)v4) {
              break;
            }
            BOOL v50 = *v51 < *v44;
            __int16 v44 = v51;
            if (v50) {
              goto LABEL_44;
            }
          }
        }
        goto LABEL_124;
      }
LABEL_44:
      if (v31 <= v12)
      {
        if (v28 <= v11 || v31 != v12)
        {
          __int16 v42 = v28 + 1;
          if ((char *)(v28 + 1) - (char *)v30 == 4096)
          {
            uint64_t v70 = (float *)*((void *)v31 + 1);
            v31 += 8;
            __int16 v42 = v70;
          }
          int v15 = v31;
LABEL_94:
          uint64_t v14 = v42;
          goto LABEL_95;
        }
        __int16 v42 = v14;
        uint64_t v4 = (uint64_t)v28;
        uint64_t v5 = v12;
      }
      else
      {
        __int16 v42 = v14;
        uint64_t v4 = (uint64_t)v28;
        uint64_t v5 = v31;
      }
LABEL_95:
      uint64_t v13 = v14;
      uint64_t v14 = v42;
      if ((float *)v4 == v11) {
        goto LABEL_124;
      }
    }
    uint64_t v26 = *(float **)v5;
    while (1)
    {
      if (v23 == v26)
      {
        int v27 = (float *)*((void *)v5 - 1);
        v5 -= 8;
        uint64_t v26 = v27;
        double v23 = v27 + 1024;
      }
      if (v14 == --v23) {
        break;
      }
      if (*v23 < *v21)
      {
        *uint64_t v14 = *v23;
        float *v23 = v25;
        ++v24;
        goto LABEL_19;
      }
    }
    __int16 v42 = v14 + 1;
    float v53 = *(float **)v15;
    if ((float *)((char *)v14 - *(void *)v15 + 4) == (float *)4096)
    {
      double v54 = (float *)*((void *)v15 + 1);
      v15 += 8;
      float v53 = v54;
      __int16 v42 = v54;
    }
    uint64_t v5 = v91;
    int v55 = *(float **)v91;
    double v56 = v91;
    uint64_t v57 = v4;
    if (v4 == *(void *)v91)
    {
      double v56 = v91 - 8;
      int v55 = (float *)*((void *)v91 - 1);
      uint64_t v57 = (uint64_t)(v55 + 1024);
    }
    float v59 = *(float *)(v57 - 4);
    double v58 = (float *)(v57 - 4);
    float v60 = v59;
    if (v25 >= v59)
    {
      while (v42 != v58)
      {
        float v68 = *v42;
        if (v25 < *v42)
        {
          *v42++ = v60;
          float *v58 = v68;
          if ((char *)v42 - (char *)v53 == 4096)
          {
            __int16 v71 = (float *)*((void *)v15 + 1);
            v15 += 8;
            float v53 = v71;
            __int16 v42 = v71;
          }
          goto LABEL_70;
        }
        if ((char *)++v42 - (char *)v53 == 4096)
        {
          __int16 v69 = (float *)*((void *)v15 + 1);
          v15 += 8;
          float v53 = v69;
          __int16 v42 = v69;
        }
      }
      goto LABEL_124;
    }
LABEL_70:
    if (v42 == v58) {
      goto LABEL_124;
    }
    while (1)
    {
      float v61 = *v14;
      while (1)
      {
        float v62 = *v42;
        if (v61 < *v42) {
          break;
        }
        if ((char *)++v42 - (char *)v53 == 4096)
        {
          __int16 v63 = (float *)*((void *)v15 + 1);
          v15 += 8;
          float v53 = v63;
          __int16 v42 = v63;
        }
      }
      do
      {
        if (v58 == v55)
        {
          double v64 = (float *)*((void *)v56 - 1);
          v56 -= 8;
          int v55 = v64;
          double v58 = v64 + 1024;
        }
        float v65 = *--v58;
        float v66 = v65;
      }
      while (v61 < v65);
      if (v15 >= v56 && (v15 != v56 || v42 >= v58)) {
        break;
      }
      *v42++ = v66;
      float *v58 = v62;
      if ((char *)v42 - (char *)v53 == 4096)
      {
        __int16 v67 = (float *)*((void *)v15 + 1);
        v15 += 8;
        float v53 = v67;
        __int16 v42 = v67;
      }
    }
    if (v15 > v12 || v42 > v11 && v15 == v12) {
      goto LABEL_124;
    }
    goto LABEL_94;
  }
LABEL_124:
  if ((v90 & 0x8000000000000001) == 1) {
    return *v11;
  }
  if (v6 != v11)
  {
    uint64_t v87 = *(float **)v7;
    uint64_t v88 = v6;
    while (1)
    {
      if ((char *)++v88 - (char *)v87 == 4096)
      {
        double v89 = (float *)*((void *)v7 + 1);
        v7 += 8;
        uint64_t v87 = v89;
        uint64_t v88 = v89;
      }
      if (v88 == v11) {
        break;
      }
      if (*v6 < *v88) {
        uint64_t v6 = v88;
      }
    }
  }
  return *v6 + (float)((float)(*v11 - *v6) * 0.5);
}

void *sub_190520A78(void *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = a3 + ((a2 - *result) >> 2);
    if (v3 < 1) {
      result -= (unint64_t)(1023 - v3) >> 10;
    }
    else {
      result += (unint64_t)v3 >> 10;
    }
  }
  return result;
}

uint64_t sub_190520ACC(uint64_t a1, float *a2, uint64_t a3, float *a4, uint64_t a5, float *a6)
{
  float v6 = *a4;
  float v7 = *a2;
  float v8 = *a6;
  if (*a4 < *a2)
  {
    if (v8 < v6)
    {
      *a2 = v8;
      *a6 = v7;
      return 1;
    }
    *a2 = v6;
    *a4 = v7;
    if (*a6 >= v7) {
      return 1;
    }
    *a4 = *a6;
    *a6 = v7;
    return 2;
  }
  if (v8 < v6)
  {
    *a4 = v8;
    *a6 = v6;
    float v9 = *a2;
    if (*a4 >= *a2) {
      return 1;
    }
    *a2 = *a4;
    *a4 = v9;
    return 2;
  }
  return 0;
}

uint64_t sub_190520B54(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 128;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 256;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    float v7 = *v2++;
    operator delete(v7);
  }

  return sub_1902D5C18((uint64_t)a1);
}

void sub_190520BFC(uint64_t a1, char a2)
{
  unint64_t v3 = *(void *)(a1 + 32);
  if (v3 < 0x100) {
    a2 = 1;
  }
  if (v3 > 0x1FF || (a2 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 256;
  }
}

void sub_190520C58(void **a1)
{
  uint64_t v2 = a1[2];
  unint64_t v3 = a1[1];
  uint64_t v4 = (unsigned char *)a1[3] - (unsigned char *)*a1;
  unint64_t v5 = (v2 - v3) >> 3;
  if (v5 >= v4 >> 3) {
    return;
  }
  if (v2 == v3)
  {
    float v9 = 0;
    uint64_t v6 = 0;
    goto LABEL_8;
  }
  uint64_t v6 = (char *)sub_1902C0520(v5);
  float v7 = a1[1];
  uint64_t v2 = a1[2];
  float v9 = &v6[8 * v8];
  uint64_t v10 = v2 - v7;
  if (v2 == v7)
  {
LABEL_8:
    uint64_t v13 = v2;
    goto LABEL_9;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 8 * (v10 >> 3);
  do
  {
    *(void *)&v6[v11] = *(void *)&v7[v11];
    v11 += 8;
  }
  while (v12 != v11);
  uint64_t v2 = a1[1];
  uint64_t v13 = a1[2];
LABEL_9:
  int64_t v14 = v13 - v2;
  int v15 = *a1;
  *a1 = v6;
  a1[1] = v6;
  a1[2] = &v6[v14];
  a1[3] = v9;
  if (v15)
  {
    operator delete(v15);
  }
}

uint64_t sub_190520D28(unint64_t a1)
{
  if (a1 > 0x42) {
    return 4;
  }
  else {
    return qword_19060B3C0[a1];
  }
}

void sub_190520FB8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 89) < 0) {
    operator delete(*(void **)(v1 - 112));
  }
  _Unwind_Resume(exception_object);
}

void sub_190521010(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  float v9 = (NSSet *)objc_msgSend_setWithObjects_(v4, v6, v5, 0);
  uint64_t v10 = *(void *)(a1 + 32);
  if (!*(void *)(v10 + 40)) {
    goto LABEL_18;
  }
  uint64_t v11 = *a2;
  if (!*a2)
  {
    double v91 = objc_msgSend_currentHandler(MEMORY[0x1E4F28B00], v7, v8);
    objc_msgSend_handleFailureInMethod_object_file_lineNumber_description_(v91, v92, *(void *)(a1 + 40), *(void *)(a1 + 32), @"CMPedometer.mm", 111, @"Empty pedometer update.");
    uint64_t v11 = *a2;
  }
  uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(v11, v9);
  if (DictionaryOfClasses)
  {
    int64_t v14 = DictionaryOfClasses;
    uint64_t v15 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v13, @"CMErrorMessage");
    uint64_t v17 = objc_msgSend_objectForKeyedSubscript_(v14, v16, @"CMPedometerDataObject");
    id v20 = (id)objc_msgSend_copy(*(void **)(*(void *)(a1 + 32) + 40), v18, v19);
    float v21 = *(NSObject **)(*(void *)(a1 + 32) + 16);
    if (v15)
    {
      uint64_t v22 = v96;
      v96[0] = MEMORY[0x1E4F143A8];
      v96[1] = 3221225472;
      double v23 = sub_190521768;
    }
    else
    {
      uint64_t v22 = block;
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      double v23 = sub_1905217E0;
      uint64_t v15 = v17;
    }
    _OWORD v22[2] = v23;
    _DWORD v22[3] = &unk_1E568D320;
    v22[4] = v15;
    v22[5] = v20;
    dispatch_async(v21, v22);
    uint64_t v10 = *(void *)(a1 + 32);
LABEL_18:
    uint64_t v26 = *(const void **)(v10 + 32);
    if (!v26) {
      return;
    }
    int v27 = _Block_copy(v26);
    if (*a2 && (int v28 = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9)) != 0)
    {
      __int16 v30 = v28;
      uint64_t v31 = objc_msgSend_objectForKeyedSubscript_(v28, v29, @"CMErrorMessage");
      float v33 = objc_msgSend_objectForKeyedSubscript_(v30, v32, @"CMPedometerDataObject");
      if (v31)
      {
        __int16 v36 = *(NSObject **)(*(void *)(a1 + 32) + 16);
        v94[0] = MEMORY[0x1E4F143A8];
        v94[1] = 3221225472;
        v94[2] = sub_190521864;
        v94[3] = &unk_1E568D320;
        v94[4] = v31;
        v94[5] = v27;
        float v37 = v94;
LABEL_40:
        dispatch_async(v36, v37);
LABEL_41:
        _Block_release(v27);
        return;
      }
      uint64_t v40 = v33;
      if (v33)
      {
        if (*(void *)(*(void *)(a1 + 32) + 48) == -1)
        {
          float v41 = objc_msgSend_numberOfSteps(v33, v34, v35);
          *(void *)(*(void *)(a1 + 32) + 48) = objc_msgSend_integerValue(v41, v42, v43);
          __int16 v46 = objc_msgSend_numberOfPushes(v40, v44, v45);
          *(void *)(*(void *)(a1 + 32) + 56) = objc_msgSend_integerValue(v46, v47, v48);
          uint64_t v51 = objc_msgSend_distance(v40, v49, v50);
          objc_msgSend_doubleValue(v51, v52, v53);
          *(void *)(*(void *)(a1 + 32) + 80) = v54;
          uint64_t v57 = objc_msgSend_floorsAscended(v40, v55, v56);
          *(_DWORD *)(*(void *)(a1 + 32) + 96) = objc_msgSend_intValue(v57, v58, v59);
          float v62 = objc_msgSend_floorsDescended(v40, v60, v61);
          *(_DWORD *)(*(void *)(a1 + 32) + 104) = objc_msgSend_intValue(v62, v63, v64);
          active = objc_msgSend_activeTime(v40, v65, v66);
          objc_msgSend_doubleValue(active, v68, v69);
          *(void *)(*(void *)(a1 + 32) + 112) = v70;
          uint64_t v73 = objc_msgSend_elevationAscended(v40, v71, v72);
          *(_DWORD *)(*(void *)(a1 + 32) + 160) = objc_msgSend_intValue(v73, v74, v75);
          int32x2_t v78 = objc_msgSend_elevationDescended(v40, v76, v77);
          *(_DWORD *)(*(void *)(a1 + 32) + 168) = objc_msgSend_intValue(v78, v79, v80);
        }
        uint64_t v81 = objc_msgSend_numberOfSteps(v40, v34, v35);
        if (!objc_msgSend_integerValue(v81, v82, v83))
        {
          uint64_t v86 = objc_msgSend_numberOfPushes(v40, v84, v85);
          if (!objc_msgSend_integerValue(v86, v87, v88))
          {
            *(void *)(*(void *)(a1 + 32) + 48) = 0;
            *(void *)(*(void *)(a1 + 32) + 56) = 0;
            *(void *)(*(void *)(a1 + 32) + 80) = 0;
            *(_DWORD *)(*(void *)(a1 + 32) + 96) = 0;
            *(_DWORD *)(*(void *)(a1 + 32) + 104) = 0;
            *(void *)(*(void *)(a1 + 32) + 112) = 0;
            *(_DWORD *)(*(void *)(a1 + 32) + 160) = 0;
            *(_DWORD *)(*(void *)(a1 + 32) + 168) = 0;
          }
        }
        uint64_t v89 = *(void *)(a1 + 32);
        __int16 v36 = *(NSObject **)(v89 + 16);
        v93[0] = MEMORY[0x1E4F143A8];
        v93[1] = 3221225472;
        v93[2] = sub_1905218DC;
        v93[3] = &unk_1E568D398;
        v93[4] = v40;
        v93[5] = v89;
        _DWORD v93[6] = v27;
        float v37 = v93;
        goto LABEL_40;
      }
      if (qword_1E929D748 != -1) {
        dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
      }
      unint64_t v90 = qword_1E929D740;
      if (os_log_type_enabled((os_log_t)qword_1E929D740, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 138543362;
        long long v100 = v30;
        _os_log_impl(&dword_1902AF000, v90, OS_LOG_TYPE_FAULT, "Unable to parse message (%{public}@) when starting updates to queue", buf, 0xCu);
      }
      if (!sub_1902D8400(115, 0)) {
        goto LABEL_41;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D748 != -1) {
        dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
      }
      int v97 = 138543362;
      double v98 = v30;
    }
    else
    {
      if (qword_1E929D748 != -1) {
        dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
      }
      float v38 = qword_1E929D740;
      if (os_log_type_enabled((os_log_t)qword_1E929D740, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl(&dword_1902AF000, v38, OS_LOG_TYPE_ERROR, "Unable to parse message when starting updates to queue!", buf, 2u);
      }
      if (!sub_1902D8400(115, 0)) {
        goto LABEL_41;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D748 != -1) {
        dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
      }
      LOWORD(v97) = 0;
    }
    BOOL v39 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMPedometerProxy init]_block_invoke", "CoreLocation: %s\n", v39);
    if (v39 != (char *)buf) {
      free(v39);
    }
    goto LABEL_41;
  }
  if (qword_1E929D6B0 != -1) {
    dispatch_once(&qword_1E929D6B0, &unk_1EDFD3480);
  }
  int v24 = qword_1E929D6A0;
  if (os_log_type_enabled((os_log_t)qword_1E929D6A0, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_ERROR, "Empty pedometer dictionary.", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D6B0 != -1) {
      dispatch_once(&qword_1E929D6B0, &unk_1EDFD3480);
    }
    LOWORD(v97) = 0;
    float v25 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMPedometerProxy init]_block_invoke", "CoreLocation: %s\n", v25);
    if (v25 != (char *)buf) {
      free(v25);
    }
  }
}

uint64_t sub_190521768(uint64_t a1, const char *a2, uint64_t a3)
{
  unint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

uint64_t sub_1905217E0(uint64_t a1, const char *a2)
{
  v5[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  v5[0] = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], a2, (uint64_t)v5, 1);
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(v2 + 16))(v2, v3, 0);
}

uint64_t sub_190521864(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16);

  return v8(v4, 0, v7);
}

void sub_1905218DC(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x192FCD2F0]();
  uint64_t v5 = objc_msgSend_numberOfSteps(*(void **)(a1 + 32), v3, v4);
  uint64_t v8 = objc_msgSend_integerValue(v5, v6, v7)
     - *(void *)(*(void *)(a1 + 40) + 48)
     + *(void *)(*(void *)(a1 + 40) + 64);
  uint64_t v11 = objc_msgSend_numberOfPushes(*(void **)(a1 + 32), v9, v10);
  uint64_t v14 = objc_msgSend_integerValue(v11, v12, v13);
  uint64_t v17 = *(void **)(a1 + 40);
  uint64_t v18 = v17[8];
  uint64_t v19 = v14 - v17[7];
  uint64_t v20 = v17[9];
  unsigned int v21 = v19 + v20;
  uint64_t v22 = (v19 + v20);
  if (v18 < v8 || v22 > v20)
  {
    int v24 = objc_msgSend_distance(*(void **)(a1 + 32), v15, v16);
    objc_msgSend_doubleValue(v24, v25, v26);
    double v28 = v27;
    uint64_t v29 = *(void *)(a1 + 40);
    double v31 = *(double *)(v29 + 80);
    double v30 = *(double *)(v29 + 88);
    __int16 v34 = objc_msgSend_floorsAscended(*(void **)(a1 + 32), v32, v33);
    int v37 = objc_msgSend_intValue(v34, v35, v36);
    uint64_t v38 = *(void *)(a1 + 40);
    int v40 = *(_DWORD *)(v38 + 96);
    int v39 = *(_DWORD *)(v38 + 100);
    uint64_t v43 = objc_msgSend_floorsDescended(*(void **)(a1 + 32), v41, v42);
    int v124 = objc_msgSend_intValue(v43, v44, v45);
    uint64_t v46 = *(void *)(a1 + 40);
    int v47 = *(_DWORD *)(v46 + 104);
    int v48 = *(_DWORD *)(v46 + 108);
    active = objc_msgSend_activeTime(*(void **)(a1 + 32), v49, v50);
    objc_msgSend_doubleValue(active, v52, v53);
    double v55 = v54;
    uint64_t v56 = *(void *)(a1 + 40);
    double v57 = *(double *)(v56 + 112);
    double v58 = *(double *)(v56 + 120);
    uint64_t v61 = objc_msgSend_elevationAscended(*(void **)(a1 + 32), v59, v60);
    int v117 = objc_msgSend_intValue(v61, v62, v63);
    uint64_t v64 = *(void *)(a1 + 40);
    int v115 = *(_DWORD *)(v64 + 160);
    int v116 = *(_DWORD *)(v64 + 164);
    __int16 v67 = objc_msgSend_elevationDescended(*(void **)(a1 + 32), v65, v66);
    int v114 = objc_msgSend_intValue(v67, v68, v69);
    uint64_t v70 = *(void *)(a1 + 40);
    int v112 = *(_DWORD *)(v70 + 168);
    int v113 = *(_DWORD *)(v70 + 172);
    StepTime = objc_msgSend_firstStepTime(*(void **)(a1 + 32), v71, v72);
    uint64_t v123 = [CMPedometerData alloc];
    double v122 = *(double *)(*(void *)(a1 + 40) + 128);
    float v76 = objc_msgSend_endDate(*(void **)(a1 + 32), v74, v75);
    objc_msgSend_timeIntervalSinceReferenceDate(v76, v77, v78);
    double v82 = v81;
    if (*(unsigned char *)(*(void *)(a1 + 40) + 137))
    {
      uint64_t v118 = objc_msgSend_numberWithInt_(NSNumber, v79, (v37 - v40 + v39));
      if (*(unsigned char *)(*(void *)(a1 + 40) + 137))
      {
        uint64_t v119 = objc_msgSend_numberWithInt_(NSNumber, v79, (v124 - v47 + v48));
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v118 = 0;
    }
    uint64_t v119 = 0;
LABEL_10:
    uint64_t v85 = objc_msgSend_recordId(*(void **)(a1 + 32), v79, v80);
    if (*(unsigned char *)(*(void *)(a1 + 40) + 138))
    {
      uint64_t v121 = objc_msgSend_currentPace(*(void **)(a1 + 32), v83, v84);
      if (*(unsigned char *)(*(void *)(a1 + 40) + 138))
      {
        uint64_t v86 = objc_msgSend_currentCadence(*(void **)(a1 + 32), v83, v84);
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v121 = 0;
    }
    uint64_t v86 = 0;
LABEL_15:
    uint64_t v120 = v8;
    uint64_t v87 = v86;
    if (StepTime)
    {
      objc_msgSend_timeIntervalSinceReferenceDate(StepTime, v83, v84);
      double v89 = v88;
    }
    else
    {
      double v89 = 0.0;
    }
    double v90 = v28 - v31;
    uint64_t v125 = v85;
    if (*(unsigned char *)(*(void *)(a1 + 40) + 138)) {
      uint64_t v91 = objc_msgSend_numberWithDouble_(NSNumber, v83, v84, v55 - v57 + v58);
    }
    else {
      uint64_t v91 = 0;
    }
    double v92 = v90 + v30;
    uint64_t v93 = objc_msgSend_sourceId(*(void **)(a1 + 32), v83, v84);
    float v94 = NSNumber;
    uint64_t isOdometerDistance = objc_msgSend_isOdometerDistance(*(void **)(a1 + 32), v95, v96);
    uint64_t v99 = objc_msgSend_numberWithBool_(v94, v98, isOdometerDistance);
    long long v100 = NSNumber;
    uint64_t isOdometerPace = objc_msgSend_isOdometerPace(*(void **)(a1 + 32), v101, v102);
    uint64_t v106 = objc_msgSend_numberWithBool_(v100, v104, isOdometerPace);
    uint64_t v107 = *(void *)(a1 + 40);
    unsigned int v108 = *(_DWORD *)(v107 + 156);
    if (*(unsigned char *)(v107 + 176))
    {
      uint64_t v109 = objc_msgSend_numberWithInt_(NSNumber, v105, (v117 - v115 + v116));
      uint64_t v107 = *(void *)(a1 + 40);
      if (*(unsigned char *)(v107 + 176))
      {
        uint64_t v110 = objc_msgSend_numberWithInt_(NSNumber, v105, (v114 - v112 + v113));
        uint64_t v107 = *(void *)(a1 + 40);
LABEL_26:
        id v111 = objc_autorelease((id)objc_msgSend_initWithStartDate_endDate_steps_distance_floorsAscended_floorsDescended_recordID_currentPace_currentCadence_firstStepTime_activeTime_sourceId_isOdometerDistance_isOdometerPace_pushes_workoutType_elevationAscended_elevationDescended_distanceSource_(v123, v105, v120, v118, v119, v125, v121, v87, v122, v82, v92, v89, v91, v93, v99, v106, __PAIR64__(v108, v21), v109, v110,
                                      *(_DWORD *)(v107 + 180)));
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v109 = 0;
    }
    uint64_t v110 = 0;
    goto LABEL_26;
  }
LABEL_27:
}

void sub_190521C60(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 144) && !*(unsigned char *)(v2 + 152))
  {
    uint64_t v5 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v6 = objc_opt_class();
    uint64_t v7 = objc_opt_class();
    uint64_t v8 = objc_opt_class();
    uint64_t v10 = (NSSet *)objc_msgSend_setWithObjects_(v5, v9, v6, v7, v8, 0);
    uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v10);
    uint64_t v13 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 144));
    if (DictionaryOfClasses)
    {
      if (objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v12, @"CMErrorMessage"))
      {
        uint64_t v15 = *(NSObject **)(*(void *)(a1 + 32) + 16);
        v22[0] = MEMORY[0x1E4F143A8];
        v22[1] = 3221225472;
        _OWORD v22[2] = sub_190522098;
        _DWORD v22[3] = &unk_1E568D2F8;
        v22[4] = DictionaryOfClasses;
        v22[5] = v13;
        uint64_t v16 = v22;
      }
      else if (objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v14, @"CMPedometerEventKey"))
      {
        uint64_t v18 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v17, @"CMPedometerEventKey");
        uint64_t v19 = *(NSObject **)(*(void *)(a1 + 32) + 16);
        v21[0] = MEMORY[0x1E4F143A8];
        v21[1] = 3221225472;
        void v21[2] = sub_1905222D0;
        _DWORD v21[3] = &unk_1E568D320;
        v21[4] = v18;
        void v21[5] = v13;
        uint64_t v16 = v21;
        uint64_t v15 = v19;
      }
      else
      {
        uint64_t v15 = *(NSObject **)(*(void *)(a1 + 32) + 16);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = sub_1905222E8;
        block[3] = &unk_1E568D2D0;
        void block[4] = v13;
        uint64_t v16 = block;
      }
    }
    else
    {
      uint64_t v15 = *(NSObject **)(*(void *)(a1 + 32) + 16);
      v23[0] = MEMORY[0x1E4F143A8];
      v23[1] = 3221225472;
      v23[2] = sub_190521EC8;
      _DWORD v23[3] = &unk_1E568D2D0;
      v23[4] = v13;
      uint64_t v16 = v23;
    }
    dispatch_async(v15, v16);
    _Block_release(v13);
  }
}

uint64_t sub_190521EC8(uint64_t a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  if (qword_1E929D748 != -1) {
    dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
  }
  uint64_t v3 = qword_1E929D740;
  if (os_log_type_enabled((os_log_t)qword_1E929D740, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_FAULT, "nil pedometer event dictionary received", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D748 != -1) {
      dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
    }
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMPedometerProxy init]_block_invoke", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_190522098(uint64_t a1, const char *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = objc_msgSend_objectForKeyedSubscript_(*(void **)(a1 + 32), a2, @"CMErrorMessage");
  uint64_t v7 = objc_msgSend_integerValue(v4, v5, v6);
  objc_msgSend_errorWithDomain_code_userInfo_(v3, v8, @"CMErrorDomain", v7, 0);
  if (qword_1E929D748 != -1) {
    dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
  }
  float v9 = qword_1E929D740;
  if (os_log_type_enabled((os_log_t)qword_1E929D740, OS_LOG_TYPE_ERROR))
  {
    uint64_t v11 = objc_msgSend_objectForKeyedSubscript_(*(void **)(a1 + 32), v10, @"CMErrorMessage");
    *(_DWORD *)int buf = 134349056;
    uint64_t v21 = objc_msgSend_integerValue(v11, v12, v13);
    _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_ERROR, "Error pedometer event, %{public}ld", buf, 0xCu);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D748 != -1) {
      dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
    }
    uint64_t v16 = objc_msgSend_objectForKeyedSubscript_(*(void **)(a1 + 32), v15, @"CMErrorMessage");
    objc_msgSend_integerValue(v16, v17, v18);
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMPedometerProxy init]_block_invoke", "CoreLocation: %s\n", v19);
    if (v19 != (char *)buf) {
      free(v19);
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

uint64_t sub_1905222D0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1905222E8(uint64_t a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  if (qword_1E929D748 != -1) {
    dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
  }
  uint64_t v3 = qword_1E929D740;
  if (os_log_type_enabled((os_log_t)qword_1E929D740, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_FAULT, "Unrecognizable pedometer event dictionary", buf, 2u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D748 != -1) {
      dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
    }
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMPedometerProxy init]_block_invoke", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1905224B8(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v5 = ExecutablePathFromPid;
    if (qword_1E929D748 != -1) {
      dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
    }
    uint64_t v6 = qword_1E929D740;
    if (os_log_type_enabled((os_log_t)qword_1E929D740, OS_LOG_TYPE_INFO))
    {
      pid_t v7 = getpid();
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)int buf = 138412802;
      uint64_t v11 = v5;
      __int16 v12 = 1024;
      pid_t v13 = v7;
      __int16 v14 = 2048;
      uint64_t v15 = v8;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_INFO, "CMPedometer client connection interrupt, %@, %d, %p", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D748 != -1) {
        dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
      }
      getpid();
      float v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMPedometerProxy init]_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
}

void sub_1905227C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_190522968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a17) {
    sub_1902D8B58(a17);
  }
  if (a19) {
    sub_1902D8B58(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_190522994(void *a1, const char *a2)
{
  uint64_t v3 = (void *)a1[4];
  uint64_t v4 = (std::__shared_weak_count *)*((void *)a2 + 1);
  uint64_t v5 = *(void *)a2;
  uint64_t v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  objc_msgSend__handleQueryResponse_onQueue_withHandler_(v3, a2, (uint64_t)&v5, a1[5], a1[6]);
  if (v6) {
    sub_1902D8B58(v6);
  }
}

void sub_1905229F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_190522A80(uint64_t a1, const char *a2)
{
  return objc_msgSend__internalQueryPedometerDataFromDate_toDate_onQueue_withHandler_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(*(void *)(a1 + 32) + 16), *(void *)(a1 + 56));
}

void sub_190522B0C(void *a1, const char *a2, uint64_t a3)
{
  char isStepCountingAvailable = objc_msgSend_isStepCountingAvailable(CMPedometer, a2, a3);
  uint64_t v7 = a1[4];
  if (isStepCountingAvailable)
  {
    *(void *)(v7 + 48) = -1;
    *(unsigned char *)(a1[4] + 136) = 0;
    uint64_t v8 = (void *)a1[4];
    uint64_t v9 = a1[5];
    uint64_t v10 = objc_msgSend_date(MEMORY[0x1E4F1C9C8], v5, v6);
    uint64_t v11 = a1[4];
    uint64_t v12 = *(void *)(v11 + 8);
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    _OWORD v16[2] = sub_190522C98;
    float v16[3] = &unk_1E568E938;
    uint64_t v13 = a1[6];
    v16[4] = v11;
    v16[5] = v13;
    objc_msgSend__internalQueryPedometerDataFromDate_toDate_onQueue_withHandler_(v8, v14, v9, v10, v12, v16);
  }
  else
  {
    uint64_t v15 = *(NSObject **)(v7 + 16);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_190522C34;
    block[3] = &unk_1E568D2D0;
    void block[4] = a1[6];
    dispatch_async(v15, block);
  }
}

uint64_t sub_190522C34(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 104, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

void sub_190522C98(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    if (qword_1E929D748 != -1) {
      dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
    }
    uint64_t v6 = qword_1E929D740;
    if (os_log_type_enabled((os_log_t)qword_1E929D740, OS_LOG_TYPE_ERROR))
    {
      int buf = 138543362;
      *(void *)buf_4 = objc_msgSend_localizedDescription(a4, v7, v8);
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_ERROR, "Error occurred: %{public}@", (uint8_t *)&buf, 0xCu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1E929D748 != -1) {
        dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
      }
      LODWORD(v65[0]) = 138543362;
      *(void *)((char *)v65 + 4) = objc_msgSend_localizedDescription(a4, v57, v58);
      uint64_t v59 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMPedometerProxy _startPedometerUpdatesFromDate:withHandler:]_block_invoke", "CoreLocation: %s\n", v59);
      if (v59 != (char *)&buf) {
        free(v59);
      }
    }
    uint64_t v9 = *(NSObject **)(*(void *)(a1 + 32) + 16);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_1905230C8;
    block[3] = &unk_1E568D320;
    uint64_t v10 = *(void *)(a1 + 40);
    void block[4] = a4;
    void block[5] = v10;
    dispatch_async(v9, block);
  }
  else if (!*(unsigned char *)(*(void *)(a1 + 32) + 136))
  {
    uint64_t v12 = objc_msgSend_numberOfSteps(a2, (const char *)a2, a3);
    *(void *)(*(void *)(a1 + 32) + 64) = objc_msgSend_integerValue(v12, v13, v14);
    uint64_t v17 = objc_msgSend_numberOfPushes(a2, v15, v16);
    *(void *)(*(void *)(a1 + 32) + 72) = objc_msgSend_integerValue(v17, v18, v19);
    uint64_t v22 = objc_msgSend_distance(a2, v20, v21);
    objc_msgSend_doubleValue(v22, v23, v24);
    *(void *)(*(void *)(a1 + 32) + 88) = v25;
    double v28 = objc_msgSend_floorsAscended(a2, v26, v27);
    *(_DWORD *)(*(void *)(a1 + 32) + 100) = objc_msgSend_intValue(v28, v29, v30);
    uint64_t v33 = objc_msgSend_floorsDescended(a2, v31, v32);
    *(_DWORD *)(*(void *)(a1 + 32) + 108) = objc_msgSend_intValue(v33, v34, v35);
    uint64_t started = objc_msgSend_startDate(a2, v36, v37);
    objc_msgSend_timeIntervalSinceReferenceDate(started, v39, v40);
    *(void *)(*(void *)(a1 + 32) + 128) = v41;
    __int16 v44 = objc_msgSend_elevationAscended(a2, v42, v43);
    *(_DWORD *)(*(void *)(a1 + 32) + 164) = objc_msgSend_intValue(v44, v45, v46);
    int v49 = objc_msgSend_elevationDescended(a2, v47, v48);
    *(_DWORD *)(*(void *)(a1 + 32) + 172) = objc_msgSend_intValue(v49, v50, v51);
    uint64_t v53 = *(void **)(a1 + 32);
    if (v53[8] || v53[9])
    {
      double v54 = v53[2];
      v61[0] = MEMORY[0x1E4F143A8];
      v61[1] = 3221225472;
      v61[2] = sub_1905230E0;
      v61[3] = &unk_1E568D320;
      uint64_t v55 = *(void *)(a1 + 40);
      v61[4] = a2;
      v61[5] = v55;
      dispatch_async(v54, v61);
      uint64_t v53 = *(void **)(a1 + 32);
    }
    uint64_t v56 = (const void *)v53[4];
    if (v56)
    {
      _Block_release(v56);
    }
    else
    {
      uint64_t v63 = @"kCLConnectionMessageSubscribeKey";
      uint64_t v64 = MEMORY[0x1E4F1CC38];
      v65[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v52, (uint64_t)&v64, &v63, 1);
      sub_1905255CC("kCLConnectionMessageStepCountUpdate", v65, &buf);
      uint64_t v60 = *(std::__shared_weak_count **)&buf_4[4];
      if (*(void *)&buf_4[4]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf_4[4] + 8), 1uLL, memory_order_relaxed);
      }
      CLConnectionClient::sendMessage();
      if (v60) {
        sub_1902D8B58(v60);
      }
      if (*(void *)&buf_4[4]) {
        sub_1902D8B58(*(std::__shared_weak_count **)&buf_4[4]);
      }
    }
    *(void *)(*(void *)(a1 + 32) + 32) = _Block_copy(*(const void **)(a1 + 40));
  }
}

void sub_19052309C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (a13) {
    sub_1902D8B58(a13);
  }
  if (a32) {
    sub_1902D8B58(a32);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1905230C8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

uint64_t sub_1905230E0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_19052316C(uint64_t a1, const char *a2)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = @"kCLConnectionMessageSubscribeKey";
  v8[0] = MEMORY[0x1E4F1CC28];
  uint64_t v4 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], a2, (uint64_t)v8, &v7, 1);
  sub_1905255CC("kCLConnectionMessageStepCountUpdate", &v4, &v5);
  uint64_t v3 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CLConnectionClient::sendMessage();
  if (v3) {
    sub_1902D8B58(v3);
  }
  _Block_release(*(const void **)(*(void *)(a1 + 32) + 32));
  *(void *)(*(void *)(a1 + 32) + 32) = 0;

  *(void *)(*(void *)(a1 + 32) + 40) = 0;
  *(unsigned char *)(*(void *)(a1 + 32) + 136) = 1;
  if (v6) {
    sub_1902D8B58(v6);
  }
}

void sub_190523284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a14) {
    sub_1902D8B58(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_190523734(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = objc_msgSend_integerValue(*(void **)(a1 + 40), a2, a3);
  uint64_t v8 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v7, @"CMErrorDomain", v6, 0);
  uint64_t v9 = *(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v5 + 16);

  return v9(v5, 0, v4, v8);
}

void sub_1905237B4(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x192FCD2F0]();
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_190523808(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)a2 + 1);
  uint64_t v5 = *(void *)a2;
  uint64_t v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  objc_msgSend__handleRecordQueryResponse_withHandler_shouldStartUpdates_(v3, a2, (uint64_t)&v5, *(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48));
  if (v6) {
    sub_1902D8B58(v6);
  }
}

void sub_190523868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1902D8B58(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_190523880(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 16);

  return v4(v2, 0, v3);
}

uint64_t sub_1905238E4(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v6 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v8 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v7, @"CMErrorDomain", v6, 0);
  uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(v4 + 16))(v4, 0, v8);
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 48);
    return MEMORY[0x1F4181798](v10, sel__subscribeToCumulativePedometerUpdates_, v11);
  }
  return result;
}

unint64_t sub_190523984(uint64_t a1)
{
  unint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
  if (*(unsigned char *)(a1 + 56))
  {
    unint64_t v5 = objc_msgSend_count(*(void **)(a1 + 32), v3, v4);
    uint64_t v8 = objc_msgSend_maxPedometerEntries(CMPedometerData, v6, v7);
    unint64_t result = objc_msgSend_unsignedIntegerValue(v8, v9, v10);
    if (v5 < result)
    {
      uint64_t v11 = *(void *)(a1 + 40);
      uint64_t v12 = *(void *)(a1 + 48);
      return MEMORY[0x1F4181798](v11, sel__subscribeToCumulativePedometerUpdates_, v12);
    }
  }
  return result;
}

void sub_190523A08(uint64_t a1, const char *a2)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = @"kCLConnectionMessageSubscribeKey";
  v8[0] = MEMORY[0x1E4F1CC38];
  uint64_t v6 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], a2, (uint64_t)v8, &v7, 1);
  sub_1902BB770("kCLConnectionMessagePedometerEvent", &v6, &v4);
  uint64_t v3 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CLConnectionClient::sendMessage();
  if (v3) {
    sub_1902D8B58(v3);
  }
  *(void *)(*(void *)(a1 + 32) + 144) = _Block_copy(*(const void **)(a1 + 40));
  *(unsigned char *)(*(void *)(a1 + 32) + 152) = 0;
  if (v5) {
    sub_1902D8B58(v5);
  }
}

void sub_190523B04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_1902D8B58(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_190523BAC(uint64_t a1, const char *a2)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = @"kCLConnectionMessageSubscribeKey";
  v8[0] = MEMORY[0x1E4F1CC28];
  uint64_t v6 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], a2, (uint64_t)v8, &v7, 1);
  sub_1902BB770("kCLConnectionMessagePedometerEvent", &v6, &v4);
  uint64_t v3 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CLConnectionClient::sendMessage();
  if (v3) {
    sub_1902D8B58(v3);
  }
  *(unsigned char *)(*(void *)(a1 + 32) + 152) = 1;
  if (v5) {
    sub_1902D8B58(v5);
  }
}

void sub_190523C9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a11) {
    sub_1902D8B58(a11);
  }
  if (a13) {
    sub_1902D8B58(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_190524048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a22) {
    sub_1902D8B58(a22);
  }
  if (a36) {
    sub_1902D8B58(a36);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19052407C(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, void, uint64_t))(v2 + 16);

  return v4(v2, 0, 0, v3);
}

void sub_1905240E4(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v4 = objc_msgSend_objectForKeyedSubscript_(a2, (const char *)a2, @"CMErrorMessage");
    uint64_t v6 = objc_msgSend_objectForKeyedSubscript_(a2, v5, @"CMPedometerCalibrationBins");
    uint64_t v8 = objc_msgSend_objectForKeyedSubscript_(a2, v7, @"CLMotionSyncStoreLastUpdate");
    uint64_t v9 = *(NSObject **)(*(void *)(a1 + 32) + 16);
    if (v4)
    {
      v18[0] = MEMORY[0x1E4F143A8];
      v18[1] = 3221225472;
      void v18[2] = sub_1905243DC;
      _DWORD v18[3] = &unk_1E568D320;
      uint64_t v10 = *(void *)(a1 + 40);
      v18[4] = v4;
      v18[5] = v10;
      uint64_t v11 = v18;
    }
    else
    {
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = sub_190524458;
      block[3] = &unk_1E568E960;
      uint64_t v13 = *(void *)(a1 + 40);
      void block[5] = v8;
      void block[6] = v13;
      void block[4] = v6;
      uint64_t v11 = block;
    }
  }
  else
  {
    if (qword_1E929D748 != -1) {
      dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
    }
    uint64_t v12 = qword_1E929D740;
    if (os_log_type_enabled((os_log_t)qword_1E929D740, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v12, OS_LOG_TYPE_ERROR, "Unable to parse message when checking for availability!", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D748 != -1) {
        dispatch_once(&qword_1E929D748, &unk_1EDFD3500);
      }
      __int16 v16 = 0;
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMPedometerProxy _queryPedometerCalibrationBinsWithHandler:forType:forRemote:]_block_invoke", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf) {
        free(v14);
      }
    }
    uint64_t v9 = *(NSObject **)(*(void *)(a1 + 32) + 16);
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    _OWORD v15[2] = sub_190524474;
    v15[3] = &unk_1E568D2D0;
    v15[4] = *(void *)(a1 + 40);
    uint64_t v11 = v15;
  }
  dispatch_async(v9, v11);
}

uint64_t sub_1905243DC(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3);
  uint64_t v7 = objc_msgSend_errorWithDomain_code_userInfo_(v3, v6, @"CMErrorDomain", v5, 0);
  uint64_t v8 = *(uint64_t (**)(uint64_t, void, void, uint64_t))(v4 + 16);

  return v8(v4, 0, 0, v7);
}

uint64_t sub_190524458(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5], 0);
}

uint64_t sub_190524474(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E4F28C58], a2, @"CMErrorDomain", 103, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, void, uint64_t))(v2 + 16);

  return v4(v2, 0, 0, v3);
}

void sub_1905245DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_190524650;
  block[3] = &unk_1E568D118;
  void block[4] = v1;
  dispatch_sync(v2, block);
}

uint64_t sub_190524650(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__teardown(*(void **)(a1 + 32), a2, a3);
}

uint64_t sub_190524980(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_pedometerProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  void v9[2] = sub_190524A08;
  v9[3] = &unk_1E568EA00;
  double v9[4] = *(void *)(a1 + 56);
  return objc_msgSend__queryPedometerDataFromDate_toDate_withHandler_(v4, v7, v5, v6, v9);
}

uint64_t sub_190524A08(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_190524B34(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_pedometerProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__startPedometerUpdatesFromDate_withHandler_, v5);
}

uint64_t sub_190524BE8(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = objc_msgSend_pedometerProxy(*(void **)(a1 + 32), a2, a3);

  return MEMORY[0x1F4181798](v3, sel__stopPedometerUpdates, v4);
}

uint64_t sub_190524D7C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v6 = objc_msgSend_pedometerProxy(*(void **)(a1 + 40), a2, a3);
  if (v4) {
    uint64_t v7 = *(void *)(a1 + 32);
  }
  else {
    uint64_t v7 = objc_msgSend__pedometerDataWithRecordID_(*(void **)(a1 + 40), v5, 0);
  }

  return MEMORY[0x1F4181798](v6, sel__startPedometerUpdatesSinceDataRecord_withHandler_, v7);
}

uint64_t sub_190525094(uint64_t a1, const char *a2)
{
  uint64_t result = objc_msgSend_isAuthorizedForEntitlement_(CMMotionUtils, a2, @"com.apple.locationd.activity");
  qword_1EB3BF380 = result;
  return result;
}

uint64_t sub_190525194(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_pedometerProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__startPedometerEventUpdatesWithHandler_, v5);
}

uint64_t sub_190525248(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = objc_msgSend_pedometerProxy(*(void **)(a1 + 32), a2, a3);

  return MEMORY[0x1F4181798](v3, sel__stopPedometerEventUpdates, v4);
}

uint64_t sub_1905252EC(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_pedometerProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__queryPedometerCalibrationBinsWithHandler_forType_forRemote_, v5);
}

uint64_t sub_1905253A8(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_pedometerProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__queryPedometerCalibrationBinsWithHandler_forType_forRemote_, v5);
}

uint64_t sub_190525464(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_pedometerProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__queryPedometerCalibrationBinsWithHandler_forType_forRemote_, v5);
}

uint64_t sub_190525520(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_pedometerProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v4, sel__queryPedometerCalibrationBinsWithHandler_forType_forRemote_, v5);
}

os_log_t sub_19052556C()
{
  os_log_t result = os_log_create("com.apple.locationd.Core", "Core");
  qword_1E929D6A0 = (uint64_t)result;
  return result;
}

os_log_t sub_19052559C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Pedometer");
  qword_1E929D740 = (uint64_t)result;
  return result;
}

void *sub_1905255CC@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  os_log_t result = sub_190525630(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_19052561C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_190525630(void *a1, char *__s, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EDFD0DA0;
  sub_1905256A4((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_190525690(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1905256A4(int a1, uint64_t a2, char *__s, void *a4)
{
  sub_1902C3F54(__p, __s);
  MEMORY[0x192FCC420](a2, __p, *a4);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1905256FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMotionActivity::remapActivityTypeForWheelchairUsers(uint64_t result)
{
  if (result <= 0x3E && ((1 << result) & 0x6000020000000110) != 0) {
    return 11805;
  }
  return result;
}

uint64_t CLMotionActivity::isMoving(CLMotionActivity *this)
{
  return (this->type > 0xBu) | (0x3F8u >> this->type) & 1;
}

uint64_t CLMotionActivity::isStaticNotFrozen(CLMotionActivity *this)
{
  return (this->type < 0xCu) & (0x804u >> this->type);
}

BOOL CLMotionActivity::isWalking(CLMotionActivity *this)
{
  return this->type == 4 || this->type == 41;
}

BOOL CLMotionActivity::isTypeWalking(int a1)
{
  return a1 == 4 || a1 == 41;
}

BOOL CLMotionActivity::isRunning(CLMotionActivity *this)
{
  return this->type == 8;
}

uint64_t CLMotionActivity::isDriving(CLMotionActivity *this)
{
  return (this->type < 0x39uLL) & (0x110000000000020uLL >> this->type);
}

BOOL CLMotionActivity::isVehicularHighConfidence(CLMotionActivity *this)
{
  return this[1].conservativeMountedState > 1;
}

BOOL CLMotionActivity::isVehicularHighConfidence(int a1)
{
  return a1 > 1;
}

BOOL CLMotionActivity::isMounted(int a1)
{
  return a1 == 1;
}

BOOL CLMotionActivity::isTypeCycling(int a1)
{
  return a1 == 6;
}

uint64_t CLMotionActivity::isUnclassifiedMoving(CLMotionActivity *this)
{
  return (this->type < 0xAu) & (0x289u >> this->type);
}

uint64_t CLMotionActivity::isTypeUnclassifiedMoving(unsigned int a1)
{
  return (a1 < 0xA) & (0x289u >> a1);
}

BOOL CLMotionActivity::isTypeStationaryCycling(int a1)
{
  return a1 == 2010;
}

BOOL CLMotionActivity::isTypeElliptical(int a1)
{
  return a1 == 2048;
}

BOOL CLMotionActivity::isTypeRowing(int a1)
{
  return a1 == 2071;
}

BOOL CLMotionActivity::isTypeDancing(int a1)
{
  return a1 == 3015;
}

BOOL CLMotionActivity::isTypeFunctionalStrength(int a1)
{
  return a1 == 2022;
}

BOOL CLMotionActivity::isTypeCoolDown(int a1)
{
  return a1 == 2101;
}

BOOL CLMotionActivity::isTypeCoreTraining(int a1)
{
  return a1 == 2024;
}

BOOL CLMotionActivity::isTypeTaiChi(int a1)
{
  return a1 == 15670;
}

BOOL CLMotionActivity::isTypePilates(int a1)
{
  return a1 == 2105;
}

BOOL CLMotionActivity::isTypeKickboxing(int a1)
{
  return a1 == 15110;
}

BOOL CLMotionActivity::isTypeStairClimbing(int a1)
{
  return a1 == 2065;
}

BOOL CLMotionActivity::isTypeSwimming(int a1)
{
  return a1 == 18240;
}

BOOL CLMotionActivity::isTypePushingWheelchair(int a1)
{
  return a1 == 11805;
}

BOOL CLMotionActivity::isTypeWheelchairPush(int a1)
{
  return a1 == 11805 || a1 == 90603;
}

uint64_t CLMotionActivity::isTypeIndoorActivity(int a1)
{
  uint64_t result = 1;
  if (a1 <= 2100)
  {
    if (((a1 - 2010) > 0x3D || ((1 << (a1 + 38)) & 0x2088004000005001) == 0)
      && a1 != 64)
    {
      return 0;
    }
  }
  else if (a1 <= 12149)
  {
    if (((a1 - 2101) > 0x31 || ((1 << (a1 - 53)) & 0x2000000000011) == 0)
      && a1 != 3015)
    {
      return 0;
    }
  }
  else
  {
    if (a1 <= 15359)
    {
      if (a1 == 12150) {
        return result;
      }
      int v3 = 15110;
    }
    else
    {
      if (a1 == 15360 || a1 == 17150) {
        return result;
      }
      int v3 = 19030;
    }
    if (a1 != v3) {
      return 0;
    }
  }
  return result;
}

BOOL CLMotionActivity::isTypeCalisthenics(int a1)
{
  return a1 == 2020;
}

BOOL CLMotionActivity::isTypeGolfing(int a1)
{
  return a1 == 15255;
}

BOOL CLMotionActivity::isTypeCrossCountrySkiing(int a1)
{
  return a1 == 19090;
}

BOOL CLMotionActivity::isTypeSnowboarding(int a1)
{
  return a1 == 519150;
}

BOOL CLMotionActivity::isTypePaddleSports(int a1)
{
  return a1 == 18100;
}

BOOL CLMotionActivity::isTypeOutdoorSoccer(int a1)
{
  return a1 == 15610;
}

BOOL CLMotionActivity::isTypeIndoorSoccer(int a1)
{
  return a1 == 64;
}

BOOL CLMotionActivity::isTypeAustralianFootball(int a1)
{
  return a1 == 65;
}

BOOL CLMotionActivity::isTypeAmericanFootball(int a1)
{
  return a1 == 15230;
}

BOOL CLMotionActivity::isTypeDiscSports(int a1)
{
  return a1 == 15250;
}

BOOL CLMotionActivity::isTypeRugby(int a1)
{
  return a1 == 15560;
}

BOOL CLMotionActivity::isTypeLacrosse(int a1)
{
  return a1 == 15460;
}

BOOL CLMotionActivity::isTypeOutdoorSkatingSports(int a1)
{
  return a1 == 15592;
}

BOOL CLMotionActivity::isTypeIndoorSkatingSports(int a1)
{
  return a1 == 19030;
}

BOOL CLMotionActivity::isTypeIndoorHockey(int a1)
{
  return a1 == 15360;
}

BOOL CLMotionActivity::isTypeOutdoorHockey(int a1)
{
  return a1 == 15350;
}

BOOL CLMotionActivity::isTypeBasketball(int a1)
{
  return a1 == 15055;
}

BOOL CLMotionActivity::isTypeTennis(int a1)
{
  return a1 == 15675;
}

BOOL CLMotionActivity::isTypeBadminton(int a1)
{
  return a1 == 15030;
}

BOOL CLMotionActivity::isTypeRacquetball(int a1)
{
  return a1 == 515652;
}

BOOL CLMotionActivity::isTypePickleball(int a1)
{
  return a1 == 66;
}

BOOL CLMotionActivity::isTypeVolleyball(int a1)
{
  return a1 == 15711;
}

BOOL CLMotionActivity::isTypeSquash(int a1)
{
  return a1 == 15652;
}

BOOL CLMotionActivity::isTypeHandball(int a1)
{
  return a1 == 15330;
}

BOOL CLMotionActivity::isTypeTrackAndField(int a1)
{
  return a1 == 15733;
}

BOOL CLMotionActivity::isTypeSoftball(int a1)
{
  return a1 == 15620;
}

BOOL CLMotionActivity::isTypeBaseball(int a1)
{
  return a1 == 515621;
}

BOOL CLMotionActivity::isTypeCricket(int a1)
{
  return a1 == 15150;
}

BOOL CLMotionActivity::isTypeTableTennis(int a1)
{
  return a1 == 15660;
}

BOOL CLMotionActivity::isTypeJumpRope(int a1)
{
  return a1 == 2068;
}

BOOL CLMotionActivity::isTypeBoxing(int a1)
{
  return a1 == 15100;
}

BOOL CLMotionActivity::isTypeStepTraining(int a1)
{
  return a1 == 3016;
}

uint64_t CLMotionActivity::indexToActivityType(CLMotionActivity *this)
{
  if (this <= 0xA) {
    return (this + 1);
  }
  if ((this - 11) > 0x3B) {
    return 0;
  }
  return dword_19060B5D8[(int)this - 11];
}

uint64_t CLMotionActivity::activityTypeToIndex(int a1)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 <= 12149)
  {
    if (a1 > 99)
    {
      if (a1 > 2067)
      {
        if (a1 == 11805) {
          int v21 = 25;
        }
        else {
          int v21 = -1;
        }
        if (a1 == 3016) {
          unsigned int v6 = 70;
        }
        else {
          unsigned int v6 = v21;
        }
        if (a1 == 3015) {
          int v22 = 24;
        }
        else {
          int v22 = -1;
        }
        if (a1 == 2150) {
          int v23 = 23;
        }
        else {
          int v23 = v22;
        }
        if (a1 <= 3015) {
          unsigned int v6 = v23;
        }
        if (a1 == 2105) {
          int v24 = 36;
        }
        else {
          int v24 = -1;
        }
        if (a1 == 2101) {
          unsigned int v10 = 33;
        }
        else {
          unsigned int v10 = v24;
        }
        if (a1 == 2071) {
          int v25 = 22;
        }
        else {
          int v25 = -1;
        }
        if (a1 == 2068) {
          int v26 = 68;
        }
        else {
          int v26 = v25;
        }
        if (a1 <= 2100) {
          unsigned int v10 = v26;
        }
        BOOL v13 = a1 <= 2149;
      }
      else
      {
        if (a1 == 2065) {
          int v5 = 21;
        }
        else {
          int v5 = -1;
        }
        if (a1 == 2061) {
          unsigned int v6 = 20;
        }
        else {
          unsigned int v6 = v5;
        }
        if (a1 == 2048) {
          int v7 = 19;
        }
        else {
          int v7 = -1;
        }
        if (a1 == 2024) {
          int v8 = 34;
        }
        else {
          int v8 = v7;
        }
        if (a1 <= 2060) {
          unsigned int v6 = v8;
        }
        if (a1 == 2022) {
          int v9 = 32;
        }
        else {
          int v9 = -1;
        }
        if (a1 == 2020) {
          unsigned int v10 = 18;
        }
        else {
          unsigned int v10 = v9;
        }
        if (a1 == 2010) {
          int v11 = 17;
        }
        else {
          int v11 = -1;
        }
        if (a1 == 100) {
          int v12 = 16;
        }
        else {
          int v12 = v11;
        }
        if (a1 <= 2019) {
          unsigned int v10 = v12;
        }
        BOOL v13 = a1 <= 2023;
      }
      if (v13) {
        return v10;
      }
      else {
        return v6;
      }
    }
    else if ((a1 - 1) >= 0xB)
    {
      switch(a1)
      {
        case '4':
          uint64_t result = 12;
          break;
        case '5':
        case '6':
        case '7':
        case '9':
        case ':':
        case ';':
        case '<':
          return result;
        case '8':
          uint64_t result = 13;
          break;
        case '=':
          uint64_t result = 14;
          break;
        case '>':
          uint64_t result = 15;
          break;
        case '?':
          uint64_t result = 37;
          break;
        case '@':
          uint64_t result = 45;
          break;
        case 'A':
          uint64_t result = 46;
          break;
        case 'B':
          uint64_t result = 59;
          break;
        default:
          BOOL v3 = a1 == 41;
          unsigned int v4 = 11;
          goto LABEL_144;
      }
    }
    else
    {
      return (a1 - 1);
    }
    return result;
  }
  if (a1 <= 15651)
  {
    if (a1 <= 15254)
    {
      if (a1 > 15109)
      {
        int v14 = 15229;
        if (a1 == 15250) {
          int v30 = 48;
        }
        else {
          int v30 = -1;
        }
        if (a1 == 15230) {
          unsigned int v16 = 47;
        }
        else {
          unsigned int v16 = v30;
        }
        int v17 = 15110;
        int v18 = 39;
        BOOL v19 = a1 == 15150;
        int v20 = 66;
      }
      else
      {
        int v14 = 15054;
        if (a1 == 15100) {
          int v15 = 69;
        }
        else {
          int v15 = -1;
        }
        if (a1 == 15055) {
          unsigned int v16 = 55;
        }
        else {
          unsigned int v16 = v15;
        }
        int v17 = 12150;
        int v18 = 26;
        BOOL v19 = a1 == 15030;
        int v20 = 57;
      }
    }
    else
    {
      if (a1 > 15459)
      {
        if (a1 > 15591)
        {
          if (a1 == 15592) {
            return 51;
          }
          if (a1 == 15610) {
            return 44;
          }
          BOOL v3 = a1 == 15620;
          unsigned int v4 = 64;
          goto LABEL_144;
        }
        int v32 = 15460;
        unsigned int v33 = 50;
        BOOL v34 = a1 == 15560;
        unsigned int v35 = 49;
        goto LABEL_134;
      }
      int v14 = 15349;
      if (a1 == 15360) {
        int v28 = 53;
      }
      else {
        int v28 = -1;
      }
      if (a1 == 15350) {
        unsigned int v16 = 54;
      }
      else {
        unsigned int v16 = v28;
      }
      int v17 = 15255;
      int v18 = 27;
      BOOL v19 = a1 == 15330;
      int v20 = 62;
    }
  }
  else if (a1 > 18199)
  {
    if (a1 > 19149)
    {
      if (a1 > 515620)
      {
        if (a1 == 515621) {
          return 65;
        }
        if (a1 == 515652) {
          return 58;
        }
        BOOL v3 = a1 == 519150;
        unsigned int v4 = 42;
        goto LABEL_144;
      }
      int v32 = 19150;
      unsigned int v33 = 31;
      BOOL v34 = a1 == 90603;
      unsigned int v35 = 30;
LABEL_134:
      if (!v34) {
        unsigned int v35 = -1;
      }
      if (a1 == v32) {
        return v33;
      }
      else {
        return v35;
      }
    }
    int v14 = 19029;
    if (a1 == 19090) {
      int v29 = 41;
    }
    else {
      int v29 = -1;
    }
    if (a1 == 19030) {
      unsigned int v16 = 52;
    }
    else {
      unsigned int v16 = v29;
    }
    int v17 = 18200;
    int v18 = 38;
    BOOL v19 = a1 == 18240;
    int v20 = 29;
  }
  else
  {
    if (a1 > 15710)
    {
      if (a1 > 17149)
      {
        if (a1 == 17150) {
          return 28;
        }
        if (a1 == 18050) {
          return 40;
        }
        BOOL v3 = a1 == 18100;
        unsigned int v4 = 43;
LABEL_144:
        if (v3) {
          return v4;
        }
        else {
          return 0xFFFFFFFFLL;
        }
      }
      int v32 = 15711;
      unsigned int v33 = 60;
      BOOL v34 = a1 == 15733;
      unsigned int v35 = 63;
      goto LABEL_134;
    }
    int v14 = 15669;
    if (a1 == 15675) {
      int v27 = 56;
    }
    else {
      int v27 = -1;
    }
    if (a1 == 15670) {
      unsigned int v16 = 35;
    }
    else {
      unsigned int v16 = v27;
    }
    int v17 = 15652;
    int v18 = 61;
    BOOL v19 = a1 == 15660;
    int v20 = 67;
  }
  if (!v19) {
    int v20 = -1;
  }
  if (a1 == v17) {
    unsigned int v31 = v18;
  }
  else {
    unsigned int v31 = v20;
  }
  if (a1 <= v14) {
    return v31;
  }
  else {
    return v16;
  }
}

const char *CLMotionActivity::activityTypeToString(int a1)
{
  uint64_t result = "frozen";
  if (a1 <= 11804)
  {
    if (a1 > 99)
    {
      if (a1 <= 2064)
      {
        int v7 = "Elliptical";
        int v12 = "Cross Training";
        if (a1 != 2061) {
          int v12 = "frozen";
        }
        if (a1 != 2048) {
          int v7 = v12;
        }
        BOOL v13 = "Functional Strength Training";
        int v14 = "Core Training";
        if (a1 != 2024) {
          int v14 = "frozen";
        }
        if (a1 != 2022) {
          BOOL v13 = v14;
        }
        if (a1 <= 2047) {
          int v7 = v13;
        }
        int v9 = "cycling leg";
        int v15 = "Stationary Cycling";
        unsigned int v16 = "Calisthenics";
        if (a1 != 2020) {
          unsigned int v16 = "frozen";
        }
        if (a1 != 2010) {
          int v15 = v16;
        }
        if (a1 != 100) {
          int v9 = v15;
        }
        BOOL v11 = a1 <= 2021;
      }
      else if (a1 > 2104)
      {
        int v7 = "Dancing";
        int v25 = "Step Training";
        if (a1 != 3016) {
          int v25 = "frozen";
        }
        if (a1 != 3015) {
          int v7 = v25;
        }
        int v9 = "Pilates";
        int v26 = "Yoga";
        if (a1 != 2150) {
          int v26 = "frozen";
        }
        if (a1 != 2105) {
          int v9 = v26;
        }
        BOOL v11 = a1 <= 3014;
      }
      else
      {
        int v7 = "Rowing";
        int v8 = "Cool Down";
        if (a1 != 2101) {
          int v8 = "frozen";
        }
        if (a1 != 2071) {
          int v7 = v8;
        }
        int v9 = "Stair Climbing";
        unsigned int v10 = "Jump Rope";
        if (a1 != 2068) {
          unsigned int v10 = "frozen";
        }
        if (a1 != 2065) {
          int v9 = v10;
        }
        BOOL v11 = a1 <= 2070;
      }
      if (v11) {
        return v9;
      }
      else {
        return v7;
      }
    }
    else
    {
      switch(a1)
      {
        case 0:
LABEL_28:
          uint64_t result = "Unknown";
          break;
        case 1:
          return result;
        case 2:
          uint64_t result = "static";
          break;
        case 3:
          uint64_t result = "moving";
          break;
        case 4:
          uint64_t result = "walking";
          break;
        case 5:
          uint64_t result = "driving";
          break;
        case 6:
          uint64_t result = "cycling";
          break;
        case 7:
          uint64_t result = "semi-stationary";
          break;
        case 8:
          uint64_t result = "running";
          break;
        case 9:
          uint64_t result = "moving coarse";
          break;
        case 10:
          uint64_t result = "in vehicle frozen";
          break;
        case 11:
          uint64_t result = "in vehicle static";
          break;
        default:
          switch(a1)
          {
            case '4':
              uint64_t result = "vehicular in hand";
              break;
            case '5':
            case '6':
            case '7':
            case '9':
            case ':':
            case ';':
            case '<':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
              return result;
            case '8':
              uint64_t result = "driving other";
              break;
            case '=':
            case '>':
            case 'G':
              goto LABEL_28;
            case '?':
              uint64_t result = "Multi Sport Transition";
              break;
            case '@':
              uint64_t result = "Indoor Soccer";
              break;
            case 'A':
              uint64_t result = "Australian Football";
              break;
            case 'B':
              uint64_t result = "Pickleball";
              break;
            default:
              if (a1 == 41) {
                uint64_t result = "walking slow";
              }
              break;
          }
          break;
      }
    }
    return result;
  }
  if (a1 > 15651)
  {
    if (a1 > 18199)
    {
      if (a1 > 19149)
      {
        if (a1 <= 515620)
        {
          int v3 = 19150;
          unsigned int v4 = "DownhillSkiing";
          BOOL v5 = a1 == 90603;
          unsigned int v6 = "Outdoor Wheelchair Activity";
        }
        else
        {
          if (a1 == 515621) {
            return "Baseball";
          }
          int v3 = 515652;
          unsigned int v4 = "Racquetball";
          BOOL v5 = a1 == 519150;
          unsigned int v6 = "Snowboarding";
        }
        goto LABEL_101;
      }
      int v17 = 19029;
      int v28 = "Cross Country Skiing";
      if (a1 != 19090) {
        int v28 = "frozen";
      }
      if (a1 == 19030) {
        BOOL v19 = "Indoor Skating Sports";
      }
      else {
        BOOL v19 = v28;
      }
      int v20 = "Scuba Diving";
      BOOL v21 = a1 == 18240;
      int v22 = "Swimming";
      int v23 = 18200;
    }
    else
    {
      if (a1 > 15710)
      {
        if (a1 <= 17149)
        {
          int v3 = 15711;
          unsigned int v4 = "Volleyball";
          BOOL v5 = a1 == 15733;
          unsigned int v6 = "Track and Field";
        }
        else
        {
          if (a1 == 17150) {
            return "Indoor Walking";
          }
          int v3 = 18050;
          unsigned int v4 = "Outdoor Rowing";
          BOOL v5 = a1 == 18100;
          unsigned int v6 = "Paddle Sports";
        }
        goto LABEL_101;
      }
      int v17 = 15669;
      int v24 = "Tennis";
      if (a1 != 15675) {
        int v24 = "frozen";
      }
      if (a1 == 15670) {
        BOOL v19 = "Tai Chi";
      }
      else {
        BOOL v19 = v24;
      }
      int v20 = "Squash";
      BOOL v21 = a1 == 15660;
      int v22 = "Table Tennis";
      int v23 = 15652;
    }
  }
  else if (a1 > 15254)
  {
    if (a1 > 15459)
    {
      if (a1 <= 15591)
      {
        int v3 = 15460;
        unsigned int v4 = "Lacrosse";
        BOOL v5 = a1 == 15560;
        unsigned int v6 = "Rugby";
      }
      else
      {
        if (a1 == 15592) {
          return "Outdoor Skating Sports";
        }
        int v3 = 15610;
        unsigned int v4 = "Outdoor Soccer";
        BOOL v5 = a1 == 15620;
        unsigned int v6 = "Softball";
      }
      goto LABEL_101;
    }
    int v17 = 15349;
    int v27 = "Indoor Hockey";
    if (a1 != 15360) {
      int v27 = "frozen";
    }
    if (a1 == 15350) {
      BOOL v19 = "Outdoor Hockey";
    }
    else {
      BOOL v19 = v27;
    }
    int v20 = "Golfing";
    BOOL v21 = a1 == 15330;
    int v22 = "Handball";
    int v23 = 15255;
  }
  else
  {
    if (a1 > 15099)
    {
      if (a1 <= 15149)
      {
        int v3 = 15100;
        unsigned int v4 = "Boxing";
        BOOL v5 = a1 == 15110;
        unsigned int v6 = "Kickboxing";
      }
      else
      {
        if (a1 == 15150) {
          return "Cricket";
        }
        int v3 = 15230;
        unsigned int v4 = "American Football";
        BOOL v5 = a1 == 15250;
        unsigned int v6 = "Disc Sports";
      }
LABEL_101:
      if (!v5) {
        unsigned int v6 = "frozen";
      }
      if (a1 == v3) {
        return v4;
      }
      else {
        return v6;
      }
    }
    int v17 = 15029;
    int v18 = "Basketball";
    if (a1 != 15055) {
      int v18 = "frozen";
    }
    if (a1 == 15030) {
      BOOL v19 = "Badminton";
    }
    else {
      BOOL v19 = v18;
    }
    int v20 = "Pushing Wheelchair";
    BOOL v21 = a1 == 12150;
    int v22 = "Indoor Running";
    int v23 = 11805;
  }
  if (!v21) {
    int v22 = "frozen";
  }
  if (a1 != v23) {
    int v20 = v22;
  }
  if (a1 <= v17) {
    return v20;
  }
  else {
    return v19;
  }
}

const char *CLMotionActivity::activityConfidenceToString(unsigned int a1)
{
  if (a1 > 2) {
    return "unknown";
  }
  else {
    return off_1E568EA20[a1];
  }
}

void sub_190526714(uint64_t a1, int *a2, double a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  double v5 = *(double *)a1;
  if (*(double *)a1 <= 0.0 || (*(_WORD *)(a1 + 82) & 0x100) == 0)
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1FC0);
    }
    int v7 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_DEBUG, "Device motion not initialized, returning", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE878 != -1) {
        dispatch_once(&qword_1EB3BE878, &unk_1EDFD1FC0);
      }
      *(_WORD *)BOOL v21 = 0;
      int v18 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLSensorFusionService_Predict::applyConstantRotationRate(CFTimeInterval, CLSensorFusionService::Sample &, CMError &)", "CoreLocation: %s\n", v18);
      if (v18 != (char *)buf) {
        free(v18);
      }
    }
    int v8 = 109;
    goto LABEL_25;
  }
  if (v5 > a3)
  {
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1FC0);
    }
    int v9 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_INFO))
    {
      double v10 = *(double *)a1;
      *(_DWORD *)int buf = 134218240;
      double v23 = v10;
      __int16 v24 = 2048;
      double v25 = a3;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_INFO, "Target prediction timestamp must be in the future,lastSample.timestamp,%f,targetTimestamp,%f", buf, 0x16u);
    }
    if (!sub_1902D8400(115, 2)) {
      goto LABEL_24;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1FC0);
    }
    double v11 = *(double *)a1;
    *(_DWORD *)BOOL v21 = 134218240;
    *(double *)&v21[4] = v11;
    *(_WORD *)&v21[12] = 2048;
    *(double *)&v21[14] = a3;
LABEL_34:
    BOOL v19 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLSensorFusionService_Predict::applyConstantRotationRate(CFTimeInterval, CLSensorFusionService::Sample &, CMError &)", "CoreLocation: %s\n", v19);
    if (v19 != (char *)buf) {
      free(v19);
    }
LABEL_24:
    int v8 = 107;
LABEL_25:
    *a2 = v8;
    return;
  }
  float v12 = a3 - v5;
  if (v12 > 2.0)
  {
    float v20 = a3 - v5;
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1FC0);
    }
    BOOL v13 = off_1EB3BE870;
    if (os_log_type_enabled((os_log_t)off_1EB3BE870, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)int buf = 134218240;
      double v23 = v20;
      __int16 v24 = 2048;
      double v25 = 2.0;
      _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_INFO, "Prediction interval above limit,interval,%f,limit,%f", buf, 0x16u);
    }
    if (!sub_1902D8400(115, 2)) {
      goto LABEL_24;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE878 != -1) {
      dispatch_once(&qword_1EB3BE878, &unk_1EDFD1FC0);
    }
    *(_DWORD *)BOOL v21 = 134218240;
    *(double *)&v21[4] = v20;
    *(_WORD *)&v21[12] = 2048;
    *(void *)&v21[14] = 0x4000000000000000;
    goto LABEL_34;
  }
  int v14 = (_OWORD *)(a1 + 8);
  float v15 = *(float *)(a1 + 44) * v12;
  *(float32x2_t *)BOOL v21 = vmul_n_f32(*(float32x2_t *)(a1 + 36), v12);
  *(float *)&v21[8] = v15;
  *(double *)v16.i64 = sub_1904CF7FC((float32x4_t *)buf, (float *)v21);
  *(double *)v17.i64 = sub_1904CF3F4((uint64_t)buf, (float *)(a1 + 8), (float32x4_t *)v21, v16);
  sub_1902D9ACC((float32x4_t *)v21, v17);
  *(double *)a1 = a3;
  *int v14 = *(_OWORD *)v21;
}

void sub_190526CF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_190526D2C(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v3 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  int v7 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v5, 0);
  if (*a2
    && (uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v7)) != 0
    && (double v10 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v9, @"CMErrorMessage")) != 0)
  {
    int v13 = objc_msgSend_intValue(v10, v11, v12);
  }
  else
  {
    int v13 = 103;
  }
  if (qword_1E929D760 != -1) {
    dispatch_once(&qword_1E929D760, &unk_1EDFD3A60);
  }
  int v14 = qword_1E929D768;
  if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)int buf = 67240192;
    int v17 = v13;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD3A60);
    }
    float v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMBikeSensorInternal init]_block_invoke", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf) {
      free(v15);
    }
  }
}

void sub_190526F44(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = getpid();
  uint64_t ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2);
  if (ExecutablePathFromPid)
  {
    uint64_t v5 = ExecutablePathFromPid;
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD3A60);
    }
    unsigned int v6 = qword_1E929D768;
    if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_INFO))
    {
      pid_t v7 = getpid();
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)int buf = 138412802;
      uint64_t v11 = v5;
      __int16 v12 = 1024;
      pid_t v13 = v7;
      __int16 v14 = 2048;
      uint64_t v15 = v8;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_INFO, "CMBikeSensor client connection interrupt, %@, %d, %p", buf, 0x1Cu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D760 != -1) {
        dispatch_once(&qword_1E929D760, &unk_1EDFD3A60);
      }
      getpid();
      int v9 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CMBikeSensorInternal init]_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf) {
        free(v9);
      }
    }
  }
}

void sub_1905272B0(uint64_t a1)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  objc_msgSend_setWithObjects_(v2, v5, v3, v4, 0);
  uint64_t v6 = *(void *)(a1 + 32);
  __int16 v12 = @"CMFitnessMachineDataRecord";
  v13[0] = v6;
  uint64_t v11 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v7, (uint64_t)v13, &v12, 1);
  sub_19045B038("kCLConnectionMessageFitnessMachineData", &v11, &v9);
  uint64_t v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CLConnectionClient::sendMessage();
  if (v8) {
    sub_1902D8B58(v8);
  }
  if (v10) {
    sub_1902D8B58(v10);
  }
}

void sub_19052741C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a19) {
    sub_1902D8B58(a19);
  }
  if (a21) {
    sub_1902D8B58(a21);
  }
  _Unwind_Resume(exception_object);
}

void sub_190527448(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!*a2)
  {
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD3A60);
    }
    uint64_t v9 = qword_1E929D768;
    if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_ERROR, "Error feeding external fitness data: the response is nill", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_24;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D760 == -1)
    {
LABEL_26:
      uint64_t v11 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CMBikeSensorInternal _feedBikeSensorData:]_block_invoke", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf) {
        free(v11);
      }
      goto LABEL_24;
    }
LABEL_28:
    dispatch_once(&qword_1E929D760, &unk_1EDFD3A60);
    goto LABEL_26;
  }
  uint64_t DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, *(NSSet **)(a1 + 32));
  if (!DictionaryOfClasses)
  {
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD3A60);
    }
    double v10 = qword_1E929D768;
    if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_ERROR, "Error feeding external fitness data content. There is not any expected classes (NSString, CMFitnessMachineData).", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      goto LABEL_24;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D760 == -1) {
      goto LABEL_26;
    }
    goto LABEL_28;
  }
  uint64_t v5 = DictionaryOfClasses;
  if (objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v4, @"CMErrorMessage"))
  {
    if (qword_1E929D760 != -1) {
      dispatch_once(&qword_1E929D760, &unk_1EDFD3A60);
    }
    uint64_t v6 = qword_1E929D768;
    if (os_log_type_enabled((os_log_t)qword_1E929D768, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 138412290;
      uint64_t v13 = objc_msgSend_objectForKeyedSubscript_(v5, v7, @"CMErrorMessage");
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_ERROR, "Error feeding external fitness data, %@", buf, 0xCu);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D760 != -1) {
        dispatch_once(&qword_1E929D760, &unk_1EDFD3A60);
      }
      objc_msgSend_objectForKeyedSubscript_(v5, v8, @"CMErrorMessage");
      goto LABEL_26;
    }
  }
LABEL_24:
}

uint64_t sub_190527908(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend__teardown(*(void **)(a1 + 32), a2, a3);
}

uint64_t sub_190527BB8(uint64_t a1, const char *a2)
{
  uint64_t result = objc_msgSend_isAuthorizedForEntitlement_(CMMotionUtils, a2, @"com.apple.locationd.activity");
  qword_1EB3BF390 = result;
  return result;
}

os_log_t sub_190527BF0()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Calorimetry");
  qword_1E929D768 = (uint64_t)result;
  return result;
}

void sub_190527C20(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = *a2;
  float v2 = 1.0 / *(double *)a2;
  *(float *)(a1 + 16) = v2;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 23) = 0;
  *(void *)(a1 + 32) = &unk_1EDFC7D60;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1EDFC9BD0;
  *(_DWORD *)(a1 + 56) = 256;
  *(unsigned char *)(a1 + 60) = 0;
  *(void *)(a1 + 64) = &unk_1EDFC7D60;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = &unk_1EDFC7D60;
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = &unk_1EDFC7D60;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EDFC7D60;
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = &unk_1EDFC7D80;
  *(void *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  *(_WORD *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = &unk_1EDFC7D60;
  *(void *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  *(unsigned char *)(a1 + 220) = 0;
  *(void *)(a1 + 228) = 0;
  *(unsigned char *)(a1 + 244) = 0;
  *(void *)(a1 + 256) = &unk_1EDFC7D60;
  *(void *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = &unk_1EDFC7D60;
  *(void *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 320) = 3;
  *(_WORD *)(a1 + 332) = 0;
  *(void *)(a1 + 324) = 0;
  *(void *)(a1 + 336) = &unk_1EDFC7758;
  *(void *)(a1 + 344) = &unk_1EDFC7D60;
  *(void *)(a1 + 352) = 1065353216;
  *(_DWORD *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = &unk_1EDFC7D60;
  *(void *)(a1 + 376) = 0x3F80000000000000;
  *(_DWORD *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = &unk_1EDFC7D60;
  *(void *)(a1 + 400) = 0;
  *(_DWORD *)(a1 + 408) = 1065353216;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 440) = 0x3FF0000000000000;
  *(void *)(a1 + 448) = &unk_1EDFC7D60;
  *(void *)(a1 + 456) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  *(_DWORD *)(a1 + 472) = 0;
  *(void *)(a1 + 480) = &unk_1EDFC7D60;
  *(void *)(a1 + 488) = 0;
  *(_DWORD *)(a1 + 496) = 0;
  *(_DWORD *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = &unk_1EDFC7D60;
  *(void *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 528) = 0;
  double v3 = v2;
  unint64_t v4 = vcvtad_u64_f64(v3 * 0.125);
  *(void *)(a1 + 536) = &unk_1EDFC8FA8;
  *(void *)(a1 + 544) = v4;
  *(void *)(a1 + 552) = &unk_1EDFC93B0;
  *(void *)(a1 + 560) = v4;
  *(void *)(a1 + 616) = 0;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(void *)(a1 + 624) = &unk_1EDFC93B0;
  *(void *)(a1 + 632) = v4;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(void *)(a1 + 688) = 0;
  *(void *)(a1 + 696) = &unk_1EDFC93B0;
  *(void *)(a1 + 704) = v4;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_OWORD *)(a1 + 728) = 0u;
  *(_OWORD *)(a1 + 744) = 0u;
  *(void *)(a1 + 760) = 0;
  unint64_t v5 = vcvtad_u64_f64(v3 * 0.625);
  *(void *)(a1 + 768) = &unk_1EDFC8FA8;
  *(void *)(a1 + 776) = v5;
  *(void *)(a1 + 784) = &unk_1EDFC93B0;
  *(void *)(a1 + 792) = v5;
  *(void *)(a1 + 848) = 0;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(void *)(a1 + 856) = &unk_1EDFC93B0;
  *(void *)(a1 + 864) = v5;
  *(_OWORD *)(a1 + 872) = 0u;
  *(_OWORD *)(a1 + 888) = 0u;
  *(_OWORD *)(a1 + 904) = 0u;
  *(void *)(a1 + 920) = 0;
  *(void *)(a1 + 928) = &unk_1EDFC93B0;
  *(void *)(a1 + 936) = v5;
  *(_OWORD *)(a1 + 944) = 0u;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  unint64_t v6 = vcvtad_u64_f64(*(float *)(a1 + 16) * 0.75);
  *(void *)(a1 + 1008) = &unk_1EDFC93B0;
  *(void *)(a1 + 1016) = v6;
  *(void *)(a1 + 1072) = 0;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(void *)(a1 + 1080) = &unk_1EDFC93B0;
  *(void *)(a1 + 1088) = v6;
  *(void *)(a1 + 1144) = 0;
  *(_OWORD *)(a1 + 1112) = 0u;
  *(_OWORD *)(a1 + 1128) = 0u;
  *(_OWORD *)(a1 + 1096) = 0u;
  *(void *)(a1 + 1152) = &unk_1EDFC93B0;
  *(void *)(a1 + 1160) = v6;
  *(_OWORD *)(a1 + 1212) = 0u;
  *(_OWORD *)(a1 + 1200) = 0u;
  *(_OWORD *)(a1 + 1184) = 0u;
  *(_OWORD *)(a1 + 1168) = 0u;
  *(void *)(a1 + 1232) = &unk_1EDFC8FA8;
  *(void *)(a1 + 1240) = 2;
  *(void *)(a1 + 1248) = &unk_1EDFC93B0;
  *(void *)(a1 + 1256) = 2;
  *(void *)(a1 + 1312) = 0;
  *(_OWORD *)(a1 + 1296) = 0u;
  *(_OWORD *)(a1 + 1280) = 0u;
  *(_OWORD *)(a1 + 1264) = 0u;
  *(void *)(a1 + 1320) = &unk_1EDFC93B0;
  *(void *)(a1 + 1328) = 2;
  *(void *)(a1 + 1384) = 0;
  *(_OWORD *)(a1 + 1368) = 0u;
  *(_OWORD *)(a1 + 1352) = 0u;
  *(_OWORD *)(a1 + 1336) = 0u;
  *(void *)(a1 + 1392) = &unk_1EDFC93B0;
  *(void *)(a1 + 1400) = 2;
  *(_OWORD *)(a1 + 1452) = 0u;
  *(_OWORD *)(a1 + 1440) = 0u;
  *(_OWORD *)(a1 + 1424) = 0u;
  *(_OWORD *)(a1 + 1408) = 0u;
  *(_OWORD *)(a1 + 1560) = 0u;
  *(_OWORD *)(a1 + 1576) = 0u;
  operator new[]();
}

void sub_19052832C(_Unwind_Exception *a1)
{
  sub_1902D5AB8(v7);
  v1[144] = v6;
  sub_1902D5B70(v1 + 147);
  v1[135] = v5;
  sub_1902D5B70(v1 + 138);
  v1[126] = v4;
  sub_1902D5B70(v1 + 129);
  sub_1902D5AB8(v3);
  sub_1902D5AB8(v2);
  _Unwind_Resume(a1);
}

void *sub_190528380(void *a1)
{
  *a1 = &unk_1EDFC9BD0;
  uint64_t v2 = a1[195];
  if (v2) {
    MEMORY[0x192FCC960](v2, 0x1000C8052888210);
  }
  uint64_t v3 = a1[196];
  if (v3) {
    MEMORY[0x192FCC960](v3, 0x1000C8052888210);
  }
  uint64_t v4 = a1[197];
  if (v4) {
    MEMORY[0x192FCC960](v4, 0x1000C8052888210);
  }
  uint64_t v5 = a1[198];
  if (v5) {
    MEMORY[0x192FCC960](v5, 0x1000C8052888210);
  }
  sub_1902D5AB8(a1 + 154);
  a1[144] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 147);
  a1[135] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 138);
  a1[126] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 129);
  sub_1902D5AB8(a1 + 96);
  sub_1902D5AB8(a1 + 67);
  return a1;
}

void sub_1905284C4(void *a1)
{
  sub_190528380(a1);

  JUMPOUT(0x192FCC980);
}

float sub_1905284FC(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 1000))
  {
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD2000);
    }
    uint64_t v2 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_FAULT, "RotationStability buffer not set.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD2000);
      }
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CLAttitudeDependentKFCalibrator::init()", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
  *(_DWORD *)(a1 + 472) = 0;
  *(_DWORD *)(a1 + 228) = 0;
  if (!*(unsigned char *)(a1 + 333))
  {
    *(_DWORD *)(a1 + 248) = 0;
    *(_DWORD *)(a1 + 232) = 0;
    *(_WORD *)(a1 + 184) = 0;
    *(unsigned char *)(a1 + 220) = 0;
    *(_DWORD *)(a1 + 224) = 0;
    *(_DWORD *)(a1 + 324) = 0;
    *(_DWORD *)(a1 + 1608) = 0;
    sub_1902B5164((void *)(a1 + 1080));
    sub_1902B5164((void *)(a1 + 1008));
    sub_1902B5164((void *)(a1 + 1152));
    sub_1902B5164((void *)(a1 + 1248));
    sub_1902B5164((void *)(a1 + 1320));
    sub_1902B5164((void *)(a1 + 1392));
    *(_DWORD *)(a1 + 1224) = 0;
    *(void *)(a1 + 264) = 0;
    *(_DWORD *)(a1 + 272) = 0;
    *(void *)(a1 + 288) = 0;
    *(_DWORD *)(a1 + 296) = 0;
    *(void *)(a1 + 304) = 0;
    *(_WORD *)(a1 + 312) = 0;
    *(_DWORD *)(a1 + 328) = 0;
  }
  *(unsigned char *)(a1 + 244) = 0;
  sub_1902B5164((void *)(a1 + 552));
  sub_1902B5164((void *)(a1 + 624));
  sub_1902B5164((void *)(a1 + 696));
  sub_1902B5164((void *)(a1 + 784));
  sub_1902B5164((void *)(a1 + 856));
  sub_1902B5164((void *)(a1 + 928));
  float result = *(double *)(a1 + 1536);
  *(float32x2_t *)(a1 + 144) = vcvt_f32_f64(*(float64x2_t *)(a1 + 1520));
  *(float *)(a1 + 152) = result;
  *(void *)(a1 + 488) = 0;
  *(_DWORD *)(a1 + 496) = 0;
  *(_DWORD *)(a1 + 504) = 0;
  *(_WORD *)(a1 + 59) = 0;
  return result;
}

void sub_190528774(void *a1)
{
  sub_1902B5164(a1 + 2);
  sub_1902B5164(a1 + 11);

  sub_1902B5164(a1 + 20);
}

float sub_1905287B8(float64x2_t *a1, float *a2, int *a3, float *a4, double *a5)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a5 && *a3 > 0)
  {
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD2000);
    }
    double v10 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
    {
      double v11 = a2[2];
      double v12 = a2[3];
      double v13 = a2[4];
      int v14 = *a3;
      *(_DWORD *)int buf = 134218752;
      double v30 = v11;
      __int16 v31 = 2048;
      double v32 = v12;
      __int16 v33 = 2048;
      double v34 = v13;
      __int16 v35 = 1024;
      int v36 = v14;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_DEBUG, "setting bias (%.3f/%.3f/%.3f) level (%d)", buf, 0x26u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD2000);
      }
      int v28 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLAttitudeDependentKFCalibrator::setBias(const CLVector3d<float> &, const CLMotionTypeCompassCalibrationLevel &, const CLVector3d<float> &, const CLClientQuaternion *)", "CoreLocation: %s\n", v28);
      if (v28 != (char *)buf) {
        free(v28);
      }
    }
    BYTE5(a1[20].f64[1]) = 0;
    BYTE1(a1[3].f64[1]) = 0;
    LOBYTE(a1[1].f64[1]) = 1;
    BYTE4(a1[15].f64[1]) = 0;
    sub_190528CE0((float32x2_t *)&a1[21], a5);
    if (&a1[4] == (float64x2_t *)a2)
    {
      float v15 = *(float *)&a1[4].f64[1];
      float v16 = *((float *)&a1[4].f64[1] + 1);
      float v17 = *(float *)a1[5].f64;
    }
    else
    {
      float v15 = a2[2];
      *(float *)&a1[4].f64[1] = v15;
      float v16 = a2[3];
      *((float *)&a1[4].f64[1] + 1) = v16;
      float v17 = a2[4];
      *(float *)a1[5].f64 = v17;
    }
    int v21 = *a3;
    HIDWORD(a1[1].f64[0]) = *a3;
    a1[6].f64[0] = 0.0;
    LODWORD(a1[6].f64[1]) = 0;
    float v22 = a4[4] - v17;
    float v23 = a4[2] - v15;
    float v24 = a4[3] - v16;
    float v25 = (float)((float)(*(float *)a1[24].f64 * v24) + (float)(v23 * *(float *)&a1[22].f64[1]))
        + (float)(v22 * *(float *)&a1[25].f64[1]);
    *(float32x2_t *)&a1[7].f64[1] = vmla_n_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)&a1[23].f64[1], v24), *(float32x2_t *)&a1[22].f64[0], v23), *(float32x2_t *)&a1[25].f64[0], v22);
    *(float *)a1[8].f64 = v25;
    *(void *)&a1[10].f64[1] = 0x100000001;
    LODWORD(a1[11].f64[0]) = 1;
    HIDWORD(a1[1].f64[1]) = v21;
    *(float *)&a1[32].f64[1] = v15;
    *((float *)&a1[32].f64[1] + 1) = v16;
    LODWORD(a1[33].f64[0]) = LODWORD(a1[5].f64[0]);
    HIDWORD(a1[20].f64[0]) = 0;
    bzero(&a1[92], 0x48uLL);
    a1[92] = vcvtq_f64_f32(*(float32x2_t *)&a1[4].f64[1]);
    a1[93].f64[0] = *(float *)a1[5].f64;
    a1[95] = vcvtq_f64_f32(*(float32x2_t *)&a1[7].f64[1]);
    a1[96].f64[0] = *(float *)a1[8].f64;
    bzero(*(void **)&a1[98].f64[0], 0x144uLL);
    float v26 = 9.0 / (float)*a3;
    float64_t v27 = a1[98].f64[0];
    **(float **)&float64_t v27 = v26;
    *(float *)(*(void *)&v27 + 40) = v26;
    *(float *)(*(void *)&v27 + 80) = v26;
    *(_DWORD *)(*(void *)&v27 + 120) = 869711765;
    *(_DWORD *)(*(void *)&v27 + 160) = 869711765;
    *(_DWORD *)(*(void *)&v27 + 200) = 869711765;
    *(float *)(*(void *)&v27 + 240) = v26;
    *(float *)(*(void *)&v27 + 280) = v26;
    *(float *)(*(void *)&v27 + 320) = v26;
    if (LOBYTE(a1[3].f64[1]))
    {
      LOBYTE(a1[3].f64[1]) = 0;
      BYTE4(a1[20].f64[1]) = 0;
    }
    sub_1905284FC((uint64_t)a1);
    sub_1902B4E0C((uint64_t)a1, 0);
    sub_1902D9094((uint64_t)&a1[78], (float *)&a1[4].f64[1]);
    sub_1902D9094((uint64_t)&a1[82].f64[1], (float *)&a1[4].f64[1] + 1);
    return sub_1902D9094((uint64_t)&a1[87], (float *)&a1[5]);
  }
  else
  {
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD2000);
    }
    uint64_t v18 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1902AF000, v18, OS_LOG_TYPE_FAULT, "Could not set bias retrieved from database", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD2000);
      }
      float v20 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual void CLAttitudeDependentKFCalibrator::setBias(const CLVector3d<float> &, const CLMotionTypeCompassCalibrationLevel &, const CLVector3d<float> &, const CLClientQuaternion *)", "CoreLocation: %s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
  }
  return result;
}

float32_t sub_190528CE0(float32x2_t *a1, double *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  sub_1904F12BC(v6.f64, a2);
  float32_t result = v11;
  float32_t v4 = v9;
  float32_t v5 = v7;
  a1[2] = vcvt_f32_f64(v6);
  a1[3].f32[0] = v5;
  a1[5] = vcvt_f32_f64(v8);
  a1[6].f32[0] = v4;
  a1[8] = vcvt_f32_f64(v10);
  a1[9].f32[0] = result;
  return result;
}

float sub_190528D84(uint64_t a1, uint64_t a2)
{
  float result = *(float *)(a2 + 16);
  int v3 = *(_DWORD *)(a2 + 20);
  int v4 = *(_DWORD *)(a2 + 40);
  int v5 = *(_DWORD *)(a2 + 44);
  int v6 = *(_DWORD *)(a2 + 64);
  int v7 = *(_DWORD *)(a2 + 68);
  int v8 = *(_DWORD *)(a2 + 24);
  int v9 = *(_DWORD *)(a2 + 48);
  int v10 = *(_DWORD *)(a2 + 72);
  *(void *)a1 = &unk_1EDFC7758;
  *(void *)(a1 + 8) = &unk_1EDFC7D60;
  *(float *)(a1 + 16) = result;
  *(_DWORD *)(a1 + 20) = v4;
  *(_DWORD *)(a1 + 24) = v6;
  *(void *)(a1 + 32) = &unk_1EDFC7D60;
  *(_DWORD *)(a1 + 40) = v3;
  *(_DWORD *)(a1 + 44) = v5;
  *(_DWORD *)(a1 + 48) = v7;
  *(void *)(a1 + 56) = &unk_1EDFC7D60;
  *(_DWORD *)(a1 + 64) = v8;
  *(_DWORD *)(a1 + 68) = v9;
  *(_DWORD *)(a1 + 72) = v10;
  return result;
}

float sub_190528E34(uint64_t a1, float *a2, float *a3, float *a4)
{
  sub_1902D9094(a1 + 16, a2);
  sub_1902D9094(a1 + 88, a3);

  return sub_1902D9094(a1 + 160, a4);
}

void sub_190528E90(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 184) = 1;
  if (!*(unsigned char *)(a1 + 333) && *(unsigned char *)(a1 + 57))
  {
    float v1 = *(float *)(a1 + 200);
    float v2 = *(float *)(a1 + 204);
    *(float *)(a1 + 120) = v1;
    *(float *)(a1 + 124) = v2;
    float v3 = *(float *)(a1 + 208);
    *(float *)(a1 + 128) = v3;
    *(double *)(a1 + 1520) = v1;
    *(double *)(a1 + 1528) = v2;
    *(double *)(a1 + 1536) = v3;
  }
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD2000);
  }
  int v4 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEBUG, "enters coasting", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD2000);
    }
    int v5 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLAttitudeDependentKFCalibrator::enterCoasting()", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf) {
      free(v5);
    }
  }
}

float sub_190529058(float *a1, float *a2)
{
  float v2 = a1[2];
  float v3 = a1[3];
  float v4 = a1[4];
  float v5 = sqrtf((float)((float)(v3 * v3) + (float)(v2 * v2)) + (float)(v4 * v4));
  if (v5 > 0.0
    && (float v6 = a2[2],
        float v7 = a2[3],
        float v8 = a2[4],
        float v9 = sqrtf((float)((float)(v7 * v7) + (float)(v6 * v6)) + (float)(v8 * v8)),
        v9 > 0.0)
    && (float v10 = (float)((float)((float)((float)(v3 * v7) + (float)(v6 * v2)) + (float)(v8 * v4)) / v5) / v9, v10 <= 1.0))
  {
    return acosf(v10);
  }
  else
  {
    return 0.0;
  }
}

uint64_t sub_1905290C4(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 1312);
  double v2 = 0.0;
  double v3 = 0.0;
  if (v1) {
    double v3 = (float)(*(float *)(result + 1264) / (float)v1);
  }
  unint64_t v4 = *(void *)(result + 1384);
  unint64_t v5 = *(void *)(result + 1456);
  *(double *)(result + 1472) = v3;
  if (v4) {
    double v2 = (float)(*(float *)(result + 1336) / (float)v4);
  }
  *(double *)(result + 1480) = v2;
  if (v5) {
    double v6 = (float)(*(float *)(result + 1408) / (float)v5);
  }
  else {
    double v6 = 0.0;
  }
  *(double *)(result + 1488) = v6;
  *(_DWORD *)(result + 236) = 0;
  *(unsigned char *)(result + 244) = 1;
  return result;
}

float sub_190529138(uint64_t a1, float a2, float a3, float a4)
{
  float v10 = a3;
  float v11 = a2;
  float v9 = a4;
  if (!*(unsigned char *)(a1 + 24)) {
    *(unsigned char *)(a1 + 57) = 1;
  }
  *(unsigned char *)(a1 + 333) = 0;
  uint64_t v5 = a1 + 1248;
  sub_1902B5164((void *)(a1 + 1248));
  uint64_t v6 = a1 + 1320;
  sub_1902B5164((void *)(a1 + 1320));
  float v7 = (void *)(a1 + 1392);
  sub_1902B5164(v7);
  sub_1902D9094(v5, &v11);
  sub_1902D9094(v6, &v10);
  return sub_1902D9094((uint64_t)v7, &v9);
}

float32_t sub_1905291CC(float32x2_t *a1, float32x2_t *a2)
{
  if ((*(unsigned int (**)(float32x2_t *))(*(void *)a1 + 72))(a1))
  {
    float32_t v5 = (a1[13].f32[0] + 1.0) * a2[2].f32[0];
    a2[2].f32[0] = v5;
    float32_t result = v5 - a1[10].f32[0];
    __asm { FMOV            V2.2D, #1.0 }
    float32x2_t v11 = vcvt_f32_f64(vmulq_f64(vaddq_f64(vcvtq_f64_f32(a1[12]), _Q2), vcvtq_f64_f32(a2[1])));
    a2[1] = v11;
    a2[1] = vsub_f32(v11, a1[9]);
    a2[2].f32[0] = result;
  }
  return result;
}

float32_t sub_190529278(float32x2_t *a1, float *a2, float32x2_t *a3, double *a4)
{
  sub_190528CE0(a1 + 42, a4);
  float v7 = a1[48].f32[0];
  float v8 = a1[47].f32[0];
  float v9 = a1[47].f32[1];
  uint64_t v10 = 51;
  if (!a1[23].i8[0]) {
    uint64_t v10 = 31;
  }
  uint64_t v11 = 25;
  if (!a1[23].i8[0]) {
    uint64_t v11 = 15;
  }
  uint64_t v12 = 26;
  if (!a1[23].i8[0]) {
    uint64_t v12 = 16;
  }
  float v13 = a1[v12].f32[0];
  float v14 = a1[v11].f32[0];
  float v15 = a1->f32[v10];
  float v16 = (float)((float)(v15 * a1[50].f32[1]) + (float)(v14 * a1[50].f32[0])) + (float)(v13 * a1[51].f32[0]);
  a2[2] = (float)((float)(v15 * a1[44].f32[1]) + (float)(v14 * a1[44].f32[0])) + (float)(v13 * a1[45].f32[0]);
  a2[3] = (float)((float)(v15 * v9) + (float)(v14 * v8)) + (float)(v13 * v7);
  a2[4] = v16;

  return sub_1905291CC(a1, a3);
}

float32_t sub_190529354(float32x2_t *a1, float32x2_t *a2, double *a3)
{
  if (a1[23].i8[0])
  {
    sub_190528CE0(a1 + 42, a3);
    float v6 = a1[25].f32[1];
    float v5 = a1[26].f32[0];
    float v7 = a1[25].f32[0];
    float32_t v8 = (float)((float)(v6 * a1[50].f32[1]) + (float)(v7 * a1[50].f32[0])) + (float)(v5 * a1[51].f32[0]);
    float32_t v9 = (float)((float)(v6 * a1[47].f32[1]) + (float)(v7 * a1[47].f32[0])) + (float)(v5 * a1[48].f32[0]);
    float32_t result = (float)((float)(v6 * a1[44].f32[1]) + (float)(v7 * a1[44].f32[0])) + (float)(v5 * a1[45].f32[0]);
    a2[1].f32[0] = result;
    a2[1].f32[1] = v9;
    a2[2].f32[0] = v8;
  }
  else
  {
    return sub_1905291CC(a1, a2);
  }
  return result;
}

float sub_190529408(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = *a2;
  float result = 1.0 / *(double *)a2;
  *(float *)(a1 + 16) = result;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 23) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  return result;
}

float sub_19052943C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(void *)a2 = *(void *)(a1 + 72);
  float result = *(float *)(a1 + 80);
  *(float *)(a2 + 8) = result;
  *a3 = *(_DWORD *)(a1 + 20);
  return result;
}

BOOL sub_190529458(uint64_t a1)
{
  return *(_DWORD *)(a1 + 20) > 0;
}

BOOL sub_190529468(uint64_t a1)
{
  return *(_DWORD *)(a1 + 20) > 3;
}

uint64_t sub_190529478(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 25);
}

uint64_t sub_190529480(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 24);
}

uint64_t sub_190529488(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 332);
}

uint64_t sub_190529490()
{
  return 5;
}

uint64_t sub_190529498(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 59);
}

os_log_t sub_1905294A0()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Compass");
  qword_1E929D790 = (uint64_t)result;
  return result;
}

void sub_1905294D0()
{
}

void sub_1905294E4()
{
}

void sub_1905294F8()
{
}

void sub_19052950C(int a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    double v3 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 67174657;
      LODWORD(v15) = a1;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_ERROR, "[AccessoryDeviceMotion] Received unsupported event %{private}d from AudioAccessoryInterface", buf, 8u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      unint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CLAccessoryDeviceMotion::onAudioAccessoryInterfaceCallback(CLAudioAccessoryInterface::Event)", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
  else
  {
    *(_DWORD *)(a2 + 284) = sub_1905A11D4();
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    float v6 = (unsigned int *)(a2 + 284);
    float v7 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
    {
      float32_t v8 = sub_1905A1130(*v6);
      *(_DWORD *)int buf = 138543362;
      float v15 = v8;
      _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Received InEar status update from AudioAccessoryInterface - %{public}@", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      sub_1905A1130(*v6);
      float v13 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::onAudioAccessoryInterfaceCallback(CLAudioAccessoryInterface::Event)", "CoreLocation: %s\n", v13);
      if (v13 != (char *)buf) {
        free(v13);
      }
    }
    (*(void (**)(uint64_t))(*(void *)a2 + 48))(a2);
    int v9 = *(_DWORD *)(a2 + 284);
    if (v9 == 4 || v9 == 2)
    {
      uint64_t v10 = a2 + 96;
      int v11 = 4;
    }
    else
    {
      uint64_t v10 = a2 + 96;
      int v11 = 5;
    }
    sub_1905EC3A8(v10, v11, (uint64_t)buf);
    uint64_t v12 = mach_absolute_time();
    sub_1902D8D34(v12);
    sub_1902D8BCC(a2, 3, a2 + 284, 4);
    if (!*(_DWORD *)(a2 + 48)) {
      *(unsigned char *)(a2 + 30) = 0;
    }
  }
}

uint64_t sub_1905298B4()
{
  if (qword_1EB3BF3B0 != -1) {
    dispatch_once(&qword_1EB3BF3B0, &unk_1EDFD2020);
  }
  return qword_1EB3BF3A8;
}

void sub_1905298F8()
{
}

void sub_190529A10(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10F1C40A0B8E96ALL);
  _Unwind_Resume(a1);
}

void sub_190529A34(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v1 = a1 - 96;
  }
  else {
    uint64_t v1 = 0;
  }
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  double v2 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(v1 + 272);
    unint64_t v4 = *(char *)(v1 + 112);
    if (v4 > 3) {
      float v5 = @"?";
    }
    else {
      float v5 = off_1E568EA88[v4];
    }
    *(_DWORD *)int buf = 134349314;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&uint8_t buf[12] = 2114;
    *(void *)&buf[14] = v5;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Setting update interval to %{public}f. State=%{public}@", buf, 0x16u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    float v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::enable(const T *) [T = CLAccessoryDeviceMotion::ETempestMode]", "CoreLocation: %s\n", v7);
    if (v7 != buf) {
      free(v7);
    }
  }
  uint64_t v6 = sub_1902D6BD0();
  *(void *)int buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 3221225472;
  *(void *)&uint8_t buf[16] = sub_19052EADC;
  int v9 = &unk_1E568CF68;
  uint64_t v10 = v1;
  sub_1902CDE98(v6, (uint64_t)buf);
}

BOOL sub_190529CA4(uint64_t a1)
{
  uint64_t v1 = a1 - 96;
  if (!a1) {
    uint64_t v1 = 0;
  }
  if (!*(unsigned char *)(v1 + 288)) {
    return 1;
  }
  int v2 = *(_DWORD *)(v1 + 284);
  return v2 == 2 || v2 == 4;
}

void sub_190529CD4(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v1 = a1 - 96;
  }
  else {
    uint64_t v1 = 0;
  }
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  int v2 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(v1 + 272);
    unint64_t v4 = *(char *)(v1 + 112);
    if (v4 > 3) {
      float v5 = @"?";
    }
    else {
      float v5 = off_1E568EA88[v4];
    }
    *(_DWORD *)int buf = 134349314;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&uint8_t buf[12] = 2114;
    *(void *)&buf[14] = v5;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Setting update interval to %{public}f. State=%{public}@", buf, 0x16u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    float v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::enable(const T *) [T = CLAccessoryDeviceMotion::EMotionAPIMode]", "CoreLocation: %s\n", v7);
    if (v7 != buf) {
      free(v7);
    }
  }
  uint64_t v6 = sub_1902D6BD0();
  *(void *)int buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 3221225472;
  *(void *)&uint8_t buf[16] = sub_19052EB08;
  int v9 = &unk_1E568CF68;
  uint64_t v10 = v1;
  sub_1902CDE98(v6, (uint64_t)buf);
}

BOOL sub_190529F44(uint64_t a1)
{
  uint64_t v1 = a1 - 96;
  if (!a1) {
    uint64_t v1 = 0;
  }
  if (!*(unsigned char *)(v1 + 288)) {
    return 0;
  }
  int v2 = *(_DWORD *)(v1 + 284);
  return v2 != 2 && v2 != 4;
}

void sub_190529F78(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v1 = a1 - 96;
  }
  else {
    uint64_t v1 = 0;
  }
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  int v2 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v3 = *(char *)(v1 + 112);
    if (v3 > 3) {
      unint64_t v4 = @"?";
    }
    else {
      unint64_t v4 = off_1E568EA88[v3];
    }
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v4;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Setting update interval to 0.0. State=%{public}@", (uint8_t *)&buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::disable(const T *) [T = CLAccessoryDeviceMotion::EDisable]", "CoreLocation: %s\n", v6);
    if (v6 != (char *)&buf) {
      free(v6);
    }
  }
  uint64_t v5 = sub_1902D6BD0();
  *(void *)&long long buf = MEMORY[0x1E4F143A8];
  *((void *)&buf + 1) = 3221225472;
  float32_t v8 = sub_19052EB34;
  int v9 = &unk_1E568CF68;
  uint64_t v10 = v1;
  sub_1902CDE98(v5, (uint64_t)&buf);
}

void sub_19052A1C8(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v1 = a1 - 96;
  }
  else {
    uint64_t v1 = 0;
  }
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  int v2 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v3 = *(char *)(v1 + 112);
    if (v3 > 3) {
      unint64_t v4 = @"?";
    }
    else {
      unint64_t v4 = off_1E568EA88[v3];
    }
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v4;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Setting update interval to 0.0. State=%{public}@", (uint8_t *)&buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::disable(const T *) [T = CLAccessoryDeviceMotion::EMotionAPIMode]", "CoreLocation: %s\n", v6);
    if (v6 != (char *)&buf) {
      free(v6);
    }
  }
  uint64_t v5 = sub_1902D6BD0();
  *(void *)&long long buf = MEMORY[0x1E4F143A8];
  *((void *)&buf + 1) = 3221225472;
  float32_t v8 = sub_19052EB4C;
  int v9 = &unk_1E568CF68;
  uint64_t v10 = v1;
  sub_1902CDE98(v5, (uint64_t)&buf);
}

void sub_19052A418(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v1 = a1 - 96;
  }
  else {
    uint64_t v1 = 0;
  }
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  int v2 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(v1 + 272);
    unint64_t v4 = *(char *)(v1 + 112);
    if (v4 > 3) {
      uint64_t v5 = @"?";
    }
    else {
      uint64_t v5 = off_1E568EA88[v4];
    }
    *(_DWORD *)long long buf = 134349314;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&uint8_t buf[12] = 2114;
    *(void *)&buf[14] = v5;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Setting update interval to %{public}f. State=%{public}@", buf, 0x16u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    float v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::enable(const T *) [T = CLAccessoryDeviceMotion::EInEar]", "CoreLocation: %s\n", v7);
    if (v7 != buf) {
      free(v7);
    }
  }
  uint64_t v6 = sub_1902D6BD0();
  *(void *)long long buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 3221225472;
  *(void *)&uint8_t buf[16] = sub_19052EB64;
  int v9 = &unk_1E568CF68;
  uint64_t v10 = v1;
  sub_1902CDE98(v6, (uint64_t)buf);
}

BOOL sub_19052A688(uint64_t a1)
{
  uint64_t v1 = a1 - 96;
  if (!a1) {
    uint64_t v1 = 0;
  }
  if (!*(unsigned char *)(v1 + 288)) {
    return 0;
  }
  int v2 = *(_DWORD *)(v1 + 284);
  return v2 != 2 && v2 != 4;
}

void sub_19052A6B8(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v1 = a1 - 96;
  }
  else {
    uint64_t v1 = 0;
  }
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  int v2 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v3 = *(char *)(v1 + 112);
    if (v3 > 3) {
      unint64_t v4 = @"?";
    }
    else {
      unint64_t v4 = off_1E568EA88[v3];
    }
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v4;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Setting update interval to 0.0. State=%{public}@", (uint8_t *)&buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::disable(const T *) [T = CLAccessoryDeviceMotion::EOutOfEar]", "CoreLocation: %s\n", v6);
    if (v6 != (char *)&buf) {
      free(v6);
    }
  }
  uint64_t v5 = sub_1902D6BD0();
  *(void *)&long long buf = MEMORY[0x1E4F143A8];
  *((void *)&buf + 1) = 3221225472;
  float32_t v8 = sub_19052EB90;
  int v9 = &unk_1E568CF68;
  uint64_t v10 = v1;
  sub_1902CDE98(v5, (uint64_t)&buf);
}

void sub_19052A90C(void *a1)
{
  sub_1905A1098(a1);

  JUMPOUT(0x192FCC980);
}

double sub_19052A944(uint64_t a1, int a2, double *a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    sub_1905A2C68(a1);
    double v9 = *a3;
    *(double *)(a1 + 272) = *a3;
    if (v9 <= 0.00001)
    {
      if (*(unsigned char *)(a1 + 29)) {
        (*(void (**)(void, __CFString *, void *))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32), @"MaxFIFOEvents", &unk_1EE001DB0);
      }
      uint64_t v13 = sub_1905D878C();
      sub_1905DA32C(v13, a1);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      float v14 = qword_1EB3BE830;
      if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Low latency mode and time sync reset", buf, 2u);
      }
      if (!sub_1902D8400(115, 2))
      {
LABEL_38:
        double v18 = *(double *)(a1 + 272);
        uint64_t v19 = a1 + 96;
        if (v18 < 0.00001)
        {
          sub_1905EC3A8(v19, 3, (uint64_t)&v31);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
          }
          float v20 = qword_1EB3BE830;
          if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_1902AF000, v20, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Disabling", buf, 2u);
          }
          if (sub_1902D8400(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EB3BE838 != -1) {
              dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
            }
            LOWORD(v32) = 0;
            int v29 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryDeviceMotion::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v29);
            if (v29 != (char *)buf) {
              free(v29);
            }
          }
          sub_19052B268(a1 + 296);
          return *(double *)(a1 + 272);
        }
        if (v18 <= 0.0200100001)
        {
          sub_1905EC3A8(v19, 1, (uint64_t)&v31);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
          }
          float v24 = qword_1EB3BE830;
          if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Entering Tempest Mode", buf, 2u);
          }
          if (!sub_1902D8400(115, 2)) {
            goto LABEL_59;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
          }
          LOWORD(v32) = 0;
        }
        else
        {
          sub_1905EC3A8(v19, 2, (uint64_t)&v31);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
          }
          int v21 = qword_1EB3BE830;
          if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
          {
            float v22 = *(const char **)(a1 + 272);
            *(_DWORD *)long long buf = 134349056;
            uint64_t v37 = v22;
            _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Entering Motion API mode with rate: %{public}f", buf, 0xCu);
          }
          if (!sub_1902D8400(115, 2)) {
            goto LABEL_59;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
          }
          float v23 = *(const char **)(a1 + 272);
          int v32 = 134349056;
          __int16 v33 = v23;
        }
        double v30 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryDeviceMotion::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v30);
        if (v30 != (char *)buf) {
          free(v30);
        }
LABEL_59:
        sub_19052B3D0(a1 + 296, *(_DWORD *)(a1 + 52), *(double *)(a1 + 272));
        return *(double *)(a1 + 272);
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      LOWORD(v32) = 0;
LABEL_68:
      int v28 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryDeviceMotion::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v28);
      if (v28 != (char *)buf) {
        free(v28);
      }
      goto LABEL_38;
    }
    *(unsigned char *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 220) = 0;
    *(void *)(a1 + 176) = 0;
    *(_DWORD *)(a1 + 228) = 0;
    if (*(unsigned char *)(a1 + 28))
    {
      if (*(unsigned char *)(a1 + 29))
      {
        (*(void (**)(void, __CFString *, void *))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32), @"MaxFIFOEvents", &unk_1EE001D98);
        double v10 = *(double *)(a1 + 272);
        uint64_t v11 = sub_1905D878C();
        if (v10 <= 0.0200100001)
        {
          sub_1905DA228(v11, a1, 1);
          int v12 = 2;
LABEL_30:
          *(_DWORD *)(a1 + 264) = v12;
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
          }
          float v15 = qword_1EB3BE830;
          if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
          {
            int v16 = *(_DWORD *)(a1 + 264);
            if (*(unsigned char *)(a1 + 28)) {
              float v17 = "YES";
            }
            else {
              float v17 = "NO";
            }
            *(_DWORD *)long long buf = 136446466;
            uint64_t v37 = v17;
            __int16 v38 = 1026;
            int v39 = v16;
            _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Low latency mode: %{public}s. TimeSync type: %{public}d", buf, 0x12u);
          }
          if (!sub_1902D8400(115, 2)) {
            goto LABEL_38;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
          }
          if (*(unsigned char *)(a1 + 28)) {
            float v26 = "YES";
          }
          else {
            float v26 = "NO";
          }
          int v27 = *(_DWORD *)(a1 + 264);
          int v32 = 136446466;
          __int16 v33 = v26;
          __int16 v34 = 1026;
          int v35 = v27;
          goto LABEL_68;
        }
LABEL_29:
        sub_1905DA228(v11, a1, 0);
        int v12 = 1;
        goto LABEL_30;
      }
    }
    else if (*(unsigned char *)(a1 + 29))
    {
      (*(void (**)(void, __CFString *, void *))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32), @"MaxFIFOEvents", &unk_1EE001DB0);
    }
    uint64_t v11 = sub_1905D878C();
    goto LABEL_29;
  }
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  unint64_t v4 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v37) = a2;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_FAULT, "[AccessoryDeviceMotion] Unrecognized interval notification %{public}d", buf, 8u);
  }
  double v5 = 0.0;
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    int v32 = 67240192;
    LODWORD(v33) = a2;
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual CFTimeInterval CLAccessoryDeviceMotion::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  return v5;
}

void sub_19052B268(uint64_t a1)
{
  sub_19052E350(a1);
  int v2 = *(__CFRunLoopTimer **)(a1 + 192);
  if (v2)
  {
    CFRunLoopTimerInvalidate(v2);
    CFRelease(*(CFTypeRef *)(a1 + 192));
    *(void *)(a1 + 192) = 0;
  }
  uint64_t v3 = mach_absolute_time();
  double v4 = sub_1902D8D34(v3);
  if (*(double *)(a1 + 80) >= 0.00001 && v4 - *(double *)a1 >= 5.0)
  {
    uint64_t v6 = 64;
    if (!*(unsigned char *)(a1 + 92)) {
      uint64_t v6 = 68;
    }
    sub_1905A1108(*(_DWORD *)(a1 + v6));
    AnalyticsSendEventLazy();
  }
  *(void *)(a1 + 80) = 0;
}

void sub_19052B3D0(uint64_t a1, int a2, double a3)
{
  double v6 = *(double *)(a1 + 80);
  if (v6 != a3 && v6 > 0.00001) {
    sub_19052B268(a1);
  }
  *(double *)(a1 + 80) = a3;
  uint64_t v7 = mach_absolute_time();
  *(double *)a1 = sub_1902D8D34(v7);
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0;
  uint64_t v8 = *(void *)(a1 + 80);
  *(void *)(a1 + 48) = v8;
  *(void *)(a1 + 56) = v8;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = a2;
  *(_WORD *)(a1 + 94) = 0;
  if (qword_1EB3BF3B0 != -1) {
    dispatch_once(&qword_1EB3BF3B0, &unk_1EDFD2020);
  }
  *(unsigned char *)(a1 + 92) = !sub_1905A11A4(qword_1EB3BF3A8);
  if (qword_1EB3BF3B0 != -1) {
    dispatch_once(&qword_1EB3BF3B0, &unk_1EDFD2020);
  }
  *(unsigned char *)(a1 + 93) = sub_1905A11D4() == 4;
  *(void *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 144) = 0;
  *(void *)(a1 + 124) = 0;
  *(void *)(a1 + 116) = 0;
  *(_OWORD *)(a1 + 152) = xmmword_19060B820;
  *(void *)(a1 + 168) = 0;
  context.versiouint64_t n = 0;
  context.info = (void *)a1;
  memset(&context.retain, 0, 24);
  CFRunLoopTimerRef v9 = CFRunLoopTimerCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1.79769313e308, 1.79769313e308, 0, 0, (CFRunLoopTimerCallBack)sub_19052E2C8, &context);
  *(void *)(a1 + 192) = v9;
  if (v9)
  {
    sub_1902D6BD0();
    CFRunLoopAddTimer(*(CFRunLoopRef *)qword_1EB3BF828, *(CFRunLoopTimerRef *)(a1 + 192), (CFRunLoopMode)*MEMORY[0x1E4F1D410]);
  }
  *(void *)(a1 + 184) = 0x3FF0000000000000;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a1 + 176) = Current;
  CFRunLoopTimerSetNextFireDate(*(CFRunLoopTimerRef *)(a1 + 192), Current + *(double *)(a1 + 184));
}

BOOL sub_19052B594(BOOL result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = result;
    sub_1905A2C68(result);
    os_log_t result = sub_1905A11A4(v3);
    *(_DWORD *)(v3 + 280) = result;
  }
  return result;
}

uint64_t sub_19052B5CC(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  BOOL v2 = sub_1905A11A4(a1);
  int v3 = *(_DWORD *)(a1 + 280);
  uint64_t result = sub_1905A11A4(a1);
  if (v3 != result)
  {
    double v5 = (int *)(a1 + 280);
    *(_DWORD *)(a1 + 280) = v2;
    if (v2 <= 1)
    {
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      double v6 = qword_1EB3BE830;
      if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = sub_1905A1154(*v5);
        *(_DWORD *)long long buf = 138543362;
        uint64_t v11 = v7;
        _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] sending accessory status to clients: %{public}@", buf, 0xCu);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE838 != -1) {
          dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
        }
        sub_1905A1154(*v5);
        CFRunLoopTimerRef v9 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "virtual void CLAccessoryDeviceMotion::sendAccessoryStatus()", "CoreLocation: %s\n", v9);
        if (v9 != (char *)buf) {
          free(v9);
        }
      }
      uint64_t v8 = mach_absolute_time();
      sub_1902D8D34(v8);
      return sub_1902D8BCC(a1, 2, a1 + 280, 4);
    }
  }
  return result;
}

void *sub_19052B7D8()
{
  dword_1EB3BF4E0 = 0;
  sub_1902C3F54(&xmmword_1EB3BF4E8, "N/A");
  uint64_t result = sub_1902C3F54(&xmmword_1EB3BF500, "N/A");
  qword_1EB3BF518 = 0;
  unk_1EB3BF520 = 0;
  dword_1EB3BF528 = 1065353216;
  *(void *)&xmmword_1EB3BF530 = 0;
  *((void *)&xmmword_1EB3BF530 + 1) = 0x3F80000000000000;
  return result;
}

void sub_19052B83C(_Unwind_Exception *exception_object)
{
  if (byte_1EB3BF4FF < 0) {
    operator delete((void *)xmmword_1EB3BF4E8);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19052B860(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_19052B8A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v188 = *MEMORY[0x1E4F143B8];
  Dataint Value = (unsigned __int8 *)IOHIDEventGetDataValue();
  Integerint Value = IOHIDEventGetIntegerValue();
  if (DataValue) {
    BOOL v8 = IntegerValue == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return;
  }
  uint64_t v9 = IntegerValue;
  *(void *)&long long v128 = 0;
  *((void *)&v128 + 1) = 0x3F80000000000000;
  unsigned __int16 v132 = 0;
  long long v133 = 0uLL;
  unint64_t TimeStamp = IOHIDEventGetTimeStamp();
  double v134 = sub_1902D8D34(TimeStamp);
  long long v137 = 0u;
  memset(v138, 0, sizeof(v138));
  int v139 = 0;
  char v127 = 0;
  CFArrayRef v11 = sub_1905E79C0(a4, &v127);
  uint64_t v12 = (const char *)v11;
  *(void *)((char *)v138 + 4) = v11;
  v13.i32[1] = HIDWORD(v134);
  *((double *)&v133 + 1) = v134;
  if (v127 && v11)
  {
    if (*(double *)(a1 + 304) < 0.00001) {
      *(double *)(a1 + 304) = v134;
    }
    uint64_t v14 = sub_1905D878C();
    unint64_t v16 = sub_1905DAB50(v14, v12, v15);
    unint64_t v17 = v16;
    if (v16)
    {
      double v18 = sub_1902D8D34(v16);
      double v19 = v134 - v18;
      if (v134 - v18 > -3600.0 && v19 < 3600.0)
      {
        *(double *)((char *)v138 + 12) = v134 - v18;
        *((double *)&v133 + 1) = v18;
        LODWORD(v138[0]) = *(_DWORD *)(a1 + 264);
        if (v19 <= 0.100000001)
        {
          if (v19 > 0.0)
          {
            if (qword_1EB3BE838 != -1) {
              dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
            }
            double v30 = qword_1EB3BE830;
            if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v31 = *(void *)((char *)v138 + 4);
              uint64_t v32 = IOHIDEventGetTimeStamp();
              *(_DWORD *)long long buf = 134349824;
              *(void *)&uint8_t buf[4] = v31;
              *(_WORD *)&uint8_t buf[12] = 2050;
              *(void *)&buf[14] = v32;
              *(_WORD *)&unsigned char buf[22] = 2050;
              *(void *)&unsigned char buf[24] = v17;
              *(_WORD *)&unsigned char buf[32] = 2050;
              *(void *)&buf[34] = (uint64_t)(*(double *)((char *)v138 + 12) * 1000000000.0);
              _os_log_impl(&dword_1902AF000, v30, OS_LOG_TYPE_DEBUG, "[AccessoryDeviceMotion] W2 btclk(ns):%{public}llu local abs:%{public}llu Synced ts:%{public}llu remote->local latency(ns):%{public}lld", buf, 0x2Au);
            }
            if (!sub_1902D8400(115, 2)) {
              goto LABEL_47;
            }
            bzero(buf, 0x65CuLL);
            if (qword_1EB3BE838 != -1) {
              dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
            }
            uint64_t v33 = *(void *)((char *)v138 + 4);
            uint64_t v34 = IOHIDEventGetTimeStamp();
            int v141 = 134349824;
            *(void *)uint64_t v142 = v33;
            v142[4] = 2050;
            *(void *)&v142[5] = v34;
            v142[9] = 2050;
            *(void *)&v142[10] = v17;
            v142[14] = 2050;
            *(void *)&v142[15] = (uint64_t)(*(double *)((char *)v138 + 12) * 1000000000.0);
            int v35 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 2, "virtual void CLAccessoryDeviceMotion::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v35);
            goto LABEL_268;
          }
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
          }
          int v36 = qword_1EB3BE830;
          if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
          {
            uint64_t v37 = *(void *)((char *)v138 + 4);
            uint64_t v38 = IOHIDEventGetTimeStamp();
            *(_DWORD *)long long buf = 134349824;
            *(void *)&uint8_t buf[4] = v37;
            *(_WORD *)&uint8_t buf[12] = 2050;
            *(void *)&buf[14] = v38;
            *(_WORD *)&unsigned char buf[22] = 2050;
            *(void *)&unsigned char buf[24] = v17;
            *(_WORD *)&unsigned char buf[32] = 2050;
            *(void *)&buf[34] = (uint64_t)(*(double *)((char *)v138 + 12) * 1000000000.0);
            _os_log_impl(&dword_1902AF000, v36, OS_LOG_TYPE_ERROR, "[AccessoryDeviceMotion] Zero or Negative TimeSync Latency! W2 btclk(ns):%{public}llu local abs:%{public}llu Synced ts:%{public}llu remote->local latency(ns):%{public}lld", buf, 0x2Au);
          }
          if (!sub_1902D8400(115, 0)) {
            goto LABEL_47;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE838 == -1)
          {
LABEL_267:
            uint64_t v123 = *(void *)((char *)v138 + 4);
            uint64_t v124 = IOHIDEventGetTimeStamp();
            int v141 = 134349824;
            *(void *)uint64_t v142 = v123;
            v142[4] = 2050;
            *(void *)&v142[5] = v124;
            v142[9] = 2050;
            *(void *)&v142[10] = v17;
            v142[14] = 2050;
            *(void *)&v142[15] = (uint64_t)(*(double *)((char *)v138 + 12) * 1000000000.0);
            int v35 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 0, "virtual void CLAccessoryDeviceMotion::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v35);
LABEL_268:
            if (v35 != buf) {
              free(v35);
            }
LABEL_47:
            double v39 = v134;
            v13.i64[0] = *(void *)((char *)v138 + 12);
            ++*(_DWORD *)(a1 + 392);
            if (*(double *)(a1 + 312) < 0.00001) {
              *(double *)(a1 + 312) = v39;
            }
            double v40 = *(double *)(a1 + 320);
            if (v40 >= 0.00001)
            {
              double v41 = *(double *)(a1 + 328);
              double v42 = *(double *)(a1 + 336);
              if (v41 > *(double *)v13.i64) {
                double v41 = *(double *)v13.i64;
              }
              if (v42 < *(double *)v13.i64) {
                double v42 = *(double *)v13.i64;
              }
              *(double *)(a1 + 328) = v41;
              *(double *)(a1 + 336) = v42;
            }
            else
            {
              *(void *)(a1 + 328) = v13.i64[0];
              *(void *)(a1 + 336) = v13.i64[0];
            }
            *(double *)(a1 + 320) = *(double *)v13.i64 + v40;
            if (*(double *)v13.i64 > 0.100000001) {
              ++*(_DWORD *)(a1 + 400);
            }
            goto LABEL_58;
          }
        }
        else
        {
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
          }
          float v20 = qword_1EB3BE830;
          if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
          {
            uint64_t v21 = *(void *)((char *)v138 + 4);
            uint64_t v22 = IOHIDEventGetTimeStamp();
            *(_DWORD *)long long buf = 134349824;
            *(void *)&uint8_t buf[4] = v21;
            *(_WORD *)&uint8_t buf[12] = 2050;
            *(void *)&buf[14] = v22;
            *(_WORD *)&unsigned char buf[22] = 2050;
            *(void *)&unsigned char buf[24] = v17;
            *(_WORD *)&unsigned char buf[32] = 2050;
            *(void *)&buf[34] = (uint64_t)(*(double *)((char *)v138 + 12) * 1000000000.0);
            _os_log_impl(&dword_1902AF000, v20, OS_LOG_TYPE_ERROR, "[AccessoryDeviceMotion] High TimeSync Latency! W2 btclk(ns):%{public}llu local abs:%{public}llu Synced ts:%{public}llu remote->local latency(ns):%{public}lld", buf, 0x2Au);
          }
          if (!sub_1902D8400(115, 0)) {
            goto LABEL_47;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1EB3BE838 == -1) {
            goto LABEL_267;
          }
        }
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
        goto LABEL_267;
      }
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      float v24 = qword_1EB3BE830;
      if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = *(void *)((char *)v138 + 4);
        uint64_t v26 = IOHIDEventGetTimeStamp();
        *(_DWORD *)long long buf = 134349824;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&uint8_t buf[12] = 2050;
        *(void *)&buf[14] = v26;
        *(_WORD *)&unsigned char buf[22] = 2050;
        *(void *)&unsigned char buf[24] = v17;
        *(_WORD *)&unsigned char buf[32] = 2050;
        *(void *)&buf[34] = (uint64_t)(*(double *)((char *)v138 + 12) * 1000000000.0);
        _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_ERROR, "[AccessoryDeviceMotion] Abnormal TimeSync Latency! W2 btclk(ns):%{public}llu local abs:%{public}llu Synced ts:%{public}llu remote->local latency(ns):%{public}lld", buf, 0x2Au);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE838 != -1) {
          dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
        }
        uint64_t v27 = *(void *)((char *)v138 + 4);
        uint64_t v28 = IOHIDEventGetTimeStamp();
        int v141 = 134349824;
        *(void *)uint64_t v142 = v27;
        v142[4] = 2050;
        *(void *)&v142[5] = v28;
        v142[9] = 2050;
        *(void *)&v142[10] = v17;
        v142[14] = 2050;
        *(void *)&v142[15] = (uint64_t)(*(double *)((char *)v138 + 12) * 1000000000.0);
        int v29 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "virtual void CLAccessoryDeviceMotion::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v29);
        if (v29 != buf) {
          free(v29);
        }
      }
    }
    else
    {
      v13.i64[0] = *(void *)(a1 + 312);
      if (*(double *)v13.i64 > 0.00001) {
        ++*(_DWORD *)(a1 + 396);
      }
    }
  }
  else if (!v127)
  {
    LODWORD(v138[0]) = *(_DWORD *)(a1 + 264);
    uint64_t v23 = mach_absolute_time();
    *(double *)v13.i64 = sub_1902D8D34(v23);
    double v134 = *(double *)v13.i64;
  }
LABEL_58:
  unsigned int v43 = *DataValue;
  if ((v43 < 4 || v9 != 47) && (v43 != 3 || v9 != 49))
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    uint64_t v56 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 134349312;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&uint8_t buf[12] = 1026;
      *(_DWORD *)&buf[14] = v43;
      _os_log_impl(&dword_1902AF000, v56, OS_LOG_TYPE_FAULT, "[AccessoryDeviceMotion] Invalid accessory device motion packet size %{public}ld and version %{public}d", buf, 0x12u);
    }
    if (!sub_1902D8400(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    int v141 = 134349312;
    *(void *)uint64_t v142 = v9;
    v142[4] = 1026;
    *(_DWORD *)&v142[5] = v43;
    double v57 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual void CLAccessoryDeviceMotion::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v57);
LABEL_185:
    if (v57 != buf) {
      free(v57);
    }
    return;
  }
  unsigned int v44 = *(unsigned __int16 *)(DataValue + 45);
  DWORD2(v137) = v44;
  if ((DataValue[1] & 0x80) != 0)
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    uint64_t v55 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1902AF000, v55, OS_LOG_TYPE_ERROR, "[AccessoryDeviceMotion] Invalid IMU error on accessory", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      LOWORD(v141) = 0;
      int v115 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual void CLAccessoryDeviceMotion::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v115);
      if (v115 != buf) {
        free(v115);
      }
    }
    *(unsigned char *)(a1 + 391) = 1;
    return;
  }
  unint64_t v45 = *(void *)(DataValue + 3);
  *(void *)&long long v133 = v45;
  float v46 = (float)*(__int16 *)(DataValue + 13) / 32767.0;
  float v47 = (float)*(__int16 *)(DataValue + 15) / 32767.0;
  *(float *)long long buf = (float)*(__int16 *)(DataValue + 11) / 32767.0;
  *(float *)&uint8_t buf[4] = v46;
  v13.f32[0] = sqrtf(fmaxf((float)((float)(1.0 - (float)(*(float *)buf * *(float *)buf)) - (float)(v46 * v46))- (float)(v47 * v47), 0.0));
  *(float *)&uint8_t buf[8] = v47;
  *(_DWORD *)&uint8_t buf[12] = v13.i32[0];
  sub_1902D9ACC((float32x4_t *)buf, v13);
  long long v128 = *(_OWORD *)buf;
  float v48 = (float)*(__int16 *)(DataValue + 31) * 0.00097656;
  float v49 = (float)*(__int16 *)(DataValue + 33) * 0.00097656;
  *((float *)&v130 + 2) = (float)*(__int16 *)(DataValue + 29) * 0.00097656;
  *((float *)&v130 + 3) = v48;
  float v131 = v49;
  float v50 = (float)*(__int16 *)(DataValue + 17) * 0.0019531;
  float v51 = (float)*(__int16 *)(DataValue + 21);
  float v52 = (float)*(__int16 *)(DataValue + 19) * 0.0019531;
  *(float *)&long long v129 = v50;
  *((float *)&v129 + 1) = v52;
  *((float *)&v129 + 2) = v51 * 0.0019531;
  if (v43 < 5)
  {
    *(_WORD *)((char *)&v139 + 1) = 0;
    LOWORD(v50) = *(_WORD *)(DataValue + 23);
    LOWORD(v52) = *(_WORD *)(DataValue + 25);
    LOWORD(v51) = *(_WORD *)(DataValue + 27);
    *((float *)&v129 + 3) = (float)LODWORD(v50) * 0.00000011921;
    *(float *)&long long v130 = (float)LODWORD(v52) * 0.00000011921;
    *((float *)&v130 + 1) = (float)LODWORD(v51) * 0.00000011921;
  }
  else
  {
    LOWORD(v50) = *(_WORD *)(DataValue + 23);
    *((float *)&v129 + 3) = (float)LODWORD(v50) * 0.00000011921;
    *(float *)&long long v130 = *((float *)&v129 + 3);
    *((float *)&v130 + 1) = *((float *)&v129 + 3);
    if (v43 == 5)
    {
      char v53 = 0;
      unsigned __int8 v54 = 0;
    }
    else
    {
      unsigned __int8 v54 = DataValue[25];
      char v53 = 1;
    }
    BYTE2(v139) = v53;
    BYTE1(v139) = v54;
    if (DataValue[26] || DataValue[27] || (LOBYTE(v58) = DataValue[28], (_BYTE)v58)) {
      int v58 = (*(unsigned __int16 *)(DataValue + 1) >> 9) & 1;
    }
    LOBYTE(v139) = v58;
    *((float *)&v138[1] + 1) = (float)(char)DataValue[26] / 127.0;
    *((float *)&v138[1] + 2) = (float)(char)DataValue[27] / 127.0;
    *((float *)&v138[1] + 3) = (float)(char)DataValue[28] / 127.0;
  }
  float v59 = (float)*(__int16 *)(DataValue + 37) * 0.00097656;
  float v60 = (float)*(__int16 *)(DataValue + 39) * 0.00097656;
  *(float *)&uint64_t v135 = (float)*(__int16 *)(DataValue + 35) * 0.00097656;
  *((float *)&v135 + 1) = v59;
  float v136 = v60;
  LODWORD(v137) = *(_DWORD *)(DataValue + 41);
  unsigned int v61 = *(unsigned __int16 *)(DataValue + 1);
  int v62 = (v61 >> 14) & 2;
  if ((v61 & 0x4000) != 0) {
    int v62 = 1;
  }
  DWORD1(v137) = v62;
  __int16 v63 = v61 & 0x3FFF;
  unsigned __int16 v132 = v61 & 0x3FFF;
  int v64 = *(_DWORD *)(a1 + 284);
  BOOL v66 = v64 == 4 || v64 == 2;
  HIBYTE(v139) = v66;
  int v67 = v138[0];
  double v68 = *(double *)((char *)v138 + 12);
  *(_WORD *)(a1 + 424) = v44;
  *(void *)(a1 + 432) = v45;
  *(_DWORD *)(a1 + 420) = v67;
  *(_WORD *)(a1 + 426) = v63;
  *(unsigned char *)(a1 + 440) = v43;
  ++*(_DWORD *)(a1 + 412);
  if (v67)
  {
    ++*(_DWORD *)(a1 + 416);
    double v69 = *(double *)(a1 + 456);
    if (v69 > v68) {
      double v69 = v68;
    }
    *(double *)(a1 + 448) = v68 + *(double *)(a1 + 448);
    *(double *)(a1 + 456) = v69;
    if (*(double *)(a1 + 464) >= v68) {
      double v68 = *(double *)(a1 + 464);
    }
    *(double *)(a1 + 464) = v68;
  }
  int v70 = *(_DWORD *)(a1 + 228);
  unsigned int v71 = *(_DWORD *)(a1 + 220);
  if (v67)
  {
    if (v67 == v70)
    {
      unsigned int v72 = v44 - v71;
      if (v44 > v71)
      {
        double v73 = (*((double *)&v133 + 1) - *(double *)(a1 + 184)) / (double)v72;
        double v74 = *(double *)(a1 + 344);
        if (v73 < v74) {
          double v74 = (*((double *)&v133 + 1) - *(double *)(a1 + 184)) / (double)v72;
        }
        if (*(double *)(a1 + 352) >= v73) {
          double v73 = *(double *)(a1 + 352);
        }
        *(double *)(a1 + 344) = v74;
        *(double *)(a1 + 352) = v73;
      }
    }
  }
  if (!v44 || v44 != v71)
  {
    if (v44 < 3 || v44 >= v71)
    {
      if (v45 < 0xC351 || v45 >= *(void *)(a1 + 176))
      {
        if (v67 && v70 && *((double *)&v133 + 1) < *(double *)(a1 + 184))
        {
          ++*(_DWORD *)(a1 + 404);
          if (qword_1EB3BE838 != -1) {
            dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
          }
          uint64_t v87 = qword_1EB3BE830;
          if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
          {
            int v88 = *(_DWORD *)(a1 + 220);
            uint64_t v89 = *(void *)(a1 + 184);
            *(_DWORD *)long long buf = 67240960;
            *(_DWORD *)&uint8_t buf[4] = v88;
            *(_WORD *)&uint8_t buf[8] = 2050;
            *(void *)&unsigned char buf[10] = v89;
            *(_WORD *)&buf[18] = 1026;
            *(_DWORD *)&buf[20] = DWORD2(v137);
            *(_WORD *)&unsigned char buf[24] = 2050;
            *(void *)&buf[26] = *((void *)&v133 + 1);
            _os_log_impl(&dword_1902AF000, v87, OS_LOG_TYPE_ERROR, "[AccessoryDeviceMotion] TimeSynced timestamp went backward: lastSeq,%{public}d,lastTimestamp,%{public}.3f,currSeq,%{public}d,currTimestamp,%{public}.3f", buf, 0x22u);
          }
          if (sub_1902D8400(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EB3BE838 != -1) {
              dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
            }
            int v125 = *(_DWORD *)(a1 + 220);
            uint64_t v126 = *(void *)(a1 + 184);
            int v141 = 67240960;
            *(_DWORD *)uint64_t v142 = v125;
            _OWORD v142[2] = 2050;
            *(void *)&v142[3] = v126;
            v142[7] = 1026;
            *(_DWORD *)&v142[8] = DWORD2(v137);
            v142[10] = 2050;
            *(void *)&v142[11] = *((void *)&v133 + 1);
            uint64_t v86 = (char *)_os_log_send_and_compose_impl();
            sub_1902D398C("Generic", 1, 0, 0, "virtual void CLAccessoryDeviceMotion::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v86);
            goto LABEL_136;
          }
        }
        goto LABEL_146;
      }
      ++*(_DWORD *)(a1 + 404);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      double v81 = qword_1EB3BE830;
      if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
      {
        int v82 = *(_DWORD *)(a1 + 220);
        uint64_t v83 = *(void *)(a1 + 176);
        *(_DWORD *)long long buf = 67240960;
        *(_DWORD *)&uint8_t buf[4] = v82;
        *(_WORD *)&uint8_t buf[8] = 2050;
        *(void *)&unsigned char buf[10] = v83;
        *(_WORD *)&buf[18] = 1026;
        *(_DWORD *)&buf[20] = DWORD2(v137);
        *(_WORD *)&unsigned char buf[24] = 2050;
        *(void *)&buf[26] = v133;
        _os_log_impl(&dword_1902AF000, v81, OS_LOG_TYPE_ERROR, "[AccessoryDeviceMotion] Received backward W2 GTB timestamp: lastSeq,%{public}d,lastSensorTime,%{public}llu,currSeq,%{public}d,currSensorTime,%{public}llu", buf, 0x22u);
      }
      if (!sub_1902D8400(115, 0)) {
        goto LABEL_146;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 == -1)
      {
LABEL_135:
        int v84 = *(_DWORD *)(a1 + 220);
        uint64_t v85 = *(void *)(a1 + 176);
        int v141 = 67240960;
        *(_DWORD *)uint64_t v142 = v84;
        _OWORD v142[2] = 2050;
        *(void *)&v142[3] = v85;
        v142[7] = 1026;
        *(_DWORD *)&v142[8] = DWORD2(v137);
        v142[10] = 2050;
        *(void *)&v142[11] = v133;
        uint64_t v86 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "virtual void CLAccessoryDeviceMotion::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v86);
LABEL_136:
        if (v86 != buf) {
          free(v86);
        }
        goto LABEL_146;
      }
    }
    else
    {
      ++*(_DWORD *)(a1 + 404);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      uint64_t v78 = qword_1EB3BE830;
      if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
      {
        int v79 = *(_DWORD *)(a1 + 220);
        uint64_t v80 = *(void *)(a1 + 176);
        *(_DWORD *)long long buf = 67240960;
        *(_DWORD *)&uint8_t buf[4] = v79;
        *(_WORD *)&uint8_t buf[8] = 2050;
        *(void *)&unsigned char buf[10] = v80;
        *(_WORD *)&buf[18] = 1026;
        *(_DWORD *)&buf[20] = DWORD2(v137);
        *(_WORD *)&unsigned char buf[24] = 2050;
        *(void *)&buf[26] = v133;
        _os_log_impl(&dword_1902AF000, v78, OS_LOG_TYPE_ERROR, "[AccessoryDeviceMotion] Received backward sequence number: lastSeq,%{public}d,lastSensorTime,%{public}llu,currSeq,%{public}d,currSensorTime,%{public}llu", buf, 0x22u);
      }
      if (!sub_1902D8400(115, 0)) {
        goto LABEL_146;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 == -1) {
        goto LABEL_135;
      }
    }
LABEL_307:
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    goto LABEL_135;
  }
  ++*(_DWORD *)(a1 + 408);
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  uint64_t v75 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_ERROR))
  {
    int v76 = *(_DWORD *)(a1 + 220);
    uint64_t v77 = *(void *)(a1 + 176);
    *(_DWORD *)long long buf = 67240960;
    *(_DWORD *)&uint8_t buf[4] = v76;
    *(_WORD *)&uint8_t buf[8] = 2050;
    *(void *)&unsigned char buf[10] = v77;
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = DWORD2(v137);
    *(_WORD *)&unsigned char buf[24] = 2050;
    *(void *)&buf[26] = v133;
    _os_log_impl(&dword_1902AF000, v75, OS_LOG_TYPE_ERROR, "[AccessoryDeviceMotion] Received duplicate packets: lastSeq,%{public}d,lastSensorTime,%{public}llu,currSeq,%{public}d,currSensorTime,%{public}llu", buf, 0x22u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 == -1) {
      goto LABEL_135;
    }
    goto LABEL_307;
  }
LABEL_146:
  if ((long long *)(a1 + 120) != &v128) {
    *(_OWORD *)(a1 + 120) = v128;
  }
  long long v90 = v130;
  *(_OWORD *)(a1 + 136) = v129;
  *(_OWORD *)(a1 + 152) = v90;
  *(float *)(a1 + 168) = v131;
  *(_WORD *)(a1 + 172) = v132;
  *(_OWORD *)(a1 + 176) = v133;
  *(double *)(a1 + 192) = v134;
  *(void *)(a1 + 200) = v135;
  *(float *)(a1 + 208) = v136;
  long long v91 = v137;
  long long v92 = v138[0];
  long long v93 = v138[1];
  *(_DWORD *)(a1 + 260) = v139;
  *(_OWORD *)(a1 + 244) = v93;
  *(_OWORD *)(a1 + 228) = v92;
  *(_OWORD *)(a1 + 212) = v91;
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  float v94 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67241216;
    *(_DWORD *)&uint8_t buf[4] = DWORD2(v137);
    *(_WORD *)&uint8_t buf[8] = 2050;
    *(void *)&unsigned char buf[10] = v133;
    *(_WORD *)&buf[18] = 2050;
    *(void *)&buf[20] = *((void *)&v133 + 1);
    *(_WORD *)&buf[28] = 1026;
    *(_DWORD *)&buf[30] = v138[0];
    *(_WORD *)&buf[34] = 2050;
    *(void *)&buf[36] = *(void *)((char *)v138 + 12);
    _os_log_impl(&dword_1902AF000, v94, OS_LOG_TYPE_INFO, "[AccessoryDeviceMotion] seq,%{public}d,sensorTime,%{public}llu,timestamp,%{public}20.20f,TimeSyncStatus,%{public}u,latency,%{public}20.20f", buf, 0x2Cu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    int v141 = 67241216;
    *(_DWORD *)uint64_t v142 = DWORD2(v137);
    _OWORD v142[2] = 2050;
    *(void *)&v142[3] = v133;
    v142[7] = 2050;
    *(void *)&v142[8] = *((void *)&v133 + 1);
    v142[12] = 1026;
    *(_DWORD *)&v142[13] = v138[0];
    v142[15] = 2050;
    *(void *)&v142[16] = *(void *)((char *)v138 + 12);
    int v116 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLAccessoryDeviceMotion::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v116);
    if (v116 != buf) {
      free(v116);
    }
  }
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  float v95 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134353664;
    *(double *)&uint8_t buf[4] = *(float *)&v128;
    *(_WORD *)&uint8_t buf[12] = 2050;
    *(double *)&buf[14] = *((float *)&v128 + 1);
    *(_WORD *)&unsigned char buf[22] = 2050;
    *(double *)&unsigned char buf[24] = *((float *)&v128 + 2);
    *(_WORD *)&unsigned char buf[32] = 2050;
    *(double *)&buf[34] = *((float *)&v128 + 3);
    *(_WORD *)&buf[42] = 2050;
    *(double *)&unsigned char buf[44] = *(float *)&v129;
    *(_WORD *)&buf[52] = 2050;
    *(double *)&buf[54] = *((float *)&v129 + 1);
    *(_WORD *)&buf[62] = 2050;
    *(double *)&buf[64] = *((float *)&v129 + 2);
    *(_WORD *)&buf[72] = 2050;
    *(double *)&buf[74] = *((float *)&v129 + 3);
    *(_WORD *)&buf[82] = 2050;
    *(double *)&buf[84] = *(float *)&v130;
    *(_WORD *)&buf[92] = 2050;
    *(double *)&buf[94] = *((float *)&v130 + 1);
    __int16 v170 = 2050;
    double v171 = *((float *)&v130 + 2);
    __int16 v172 = 2050;
    double v173 = *((float *)&v130 + 3);
    __int16 v174 = 2050;
    double v175 = v131;
    __int16 v176 = 2050;
    double v177 = *(float *)&v135;
    __int16 v178 = 2050;
    double v179 = *((float *)&v135 + 1);
    __int16 v180 = 2050;
    double v181 = v136;
    __int16 v182 = 1026;
    int v183 = v132;
    __int16 v184 = 2050;
    double v185 = *(float *)&v137;
    __int16 v186 = 1026;
    int v187 = DWORD1(v137);
    _os_log_impl(&dword_1902AF000, v95, OS_LOG_TYPE_DEBUG, "[AccessoryDeviceMotion] q.x,%{public}20.20f,q.y,%{public}20.20f,q.z,%{public}20.20f,q.w,%{public}20.20f,rotationRate.x,%{public}20.20f,rotationRate.y,%{public}20.20f,rotationRate.z,%{public}20.20f,variance.x,%{public}20.20f,variance.y,%{public}20.20f,variance.z,%{public}20.20f,userAccel.x,%{public}20.20f,userAccel.y,%{public}20.20f,userAccel.z,%{public}20.20f,filteredAccel.x,%{public}20.20f,filteredAccel.y,%{public}20.20f,filteredAccel.z,%{public}20.20f,status,%{public}04x,quiescentNoise,%{public}20.20f,quiescentMode,%{public}d", buf, 0xB8u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    int v141 = 134353664;
    *(double *)uint64_t v142 = *(float *)&v128;
    v142[4] = 2050;
    *(double *)&v142[5] = *((float *)&v128 + 1);
    v142[9] = 2050;
    *(double *)&v142[10] = *((float *)&v128 + 2);
    v142[14] = 2050;
    *(double *)&v142[15] = *((float *)&v128 + 3);
    v142[19] = 2050;
    *(double *)&v142[20] = *(float *)&v129;
    v142[24] = 2050;
    *(double *)&v142[25] = *((float *)&v129 + 1);
    v142[29] = 2050;
    double v143 = *((float *)&v129 + 2);
    __int16 v144 = 2050;
    double v145 = *((float *)&v129 + 3);
    __int16 v146 = 2050;
    double v147 = *(float *)&v130;
    __int16 v148 = 2050;
    double v149 = *((float *)&v130 + 1);
    __int16 v150 = 2050;
    double v151 = *((float *)&v130 + 2);
    __int16 v152 = 2050;
    double v153 = *((float *)&v130 + 3);
    __int16 v154 = 2050;
    double v155 = v131;
    __int16 v156 = 2050;
    double v157 = *(float *)&v135;
    __int16 v158 = 2050;
    double v159 = *((float *)&v135 + 1);
    __int16 v160 = 2050;
    double v161 = v136;
    __int16 v162 = 1026;
    int v163 = v132;
    __int16 v164 = 2050;
    double v165 = *(float *)&v137;
    __int16 v166 = 1026;
    int v167 = DWORD1(v137);
    int v117 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLAccessoryDeviceMotion::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v117);
    if (v117 != buf) {
      free(v117);
    }
  }
  uint64_t v140 = *((void *)&v133 + 1);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF410, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB3BF410))
  {
    sub_19052B7D8();
    __cxa_atexit((void (*)(void *))sub_19052B860, &dword_1EB3BF4E0, &dword_1902AF000);
    __cxa_guard_release(&qword_1EB3BF410);
  }
  if (*(unsigned char *)(a1 + 30)) {
    goto LABEL_160;
  }
  *(unsigned char *)(a1 + 30) = 1;
  *(_DWORD *)long long buf = 0;
  sub_1902C3F54(&buf[8], "N/A");
  sub_1902C3F54(&buf[32], "N/A");
  *(void *)&buf[56] = 0;
  *(void *)&buf[64] = 0;
  *(_DWORD *)&buf[72] = 1065353216;
  buf[76] = 0;
  *(void *)&buf[80] = 0;
  *(void *)&buf[88] = 0x3F80000000000000;
  dword_1EB3BF4E0 = *(_DWORD *)buf;
  if (byte_1EB3BF4FF < 0) {
    operator delete((void *)xmmword_1EB3BF4E8);
  }
  char v96 = 0;
  xmmword_1EB3BF4E8 = *(_OWORD *)&buf[8];
  unk_1EB3BF4F8 = *(void *)&buf[24];
  buf[31] = 0;
  uint8_t buf[8] = 0;
  if (byte_1EB3BF517 < 0)
  {
    operator delete((void *)xmmword_1EB3BF500);
    char v96 = buf[31];
  }
  xmmword_1EB3BF500 = *(_OWORD *)&buf[32];
  unk_1EB3BF510 = *(void *)&buf[48];
  buf[55] = 0;
  unsigned char buf[32] = 0;
  LODWORD(qword_1EB3BF518) = *(_DWORD *)&buf[56];
  *(_OWORD *)((char *)&qword_1EB3BF518 + 4) = *(_OWORD *)&buf[60];
  byte_1EB3BF52C = buf[76];
  xmmword_1EB3BF530 = *(_OWORD *)&buf[80];
  if (v96 < 0) {
    operator delete(*(void **)&buf[8]);
  }
  if (!sub_1905A3184((const char *)a1, &dword_1EB3BF4E0))
  {
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    uint64_t v101 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1902AF000, v101, OS_LOG_TYPE_FAULT, "[AccessoryDeviceMotion] Service not found!", buf, 2u);
    }
    if (!sub_1902D8400(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    LOWORD(v141) = 0;
    double v57 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "void CLAccessoryDeviceMotion::onDeviceMotionData(AudioAccessorySample &, CLMotionTypeTimestamp)", "CoreLocation: %s\n", v57);
    goto LABEL_185;
  }
  int v97 = (__IOHIDServiceClient *)sub_1902B8788(*(void *)(a1 + 32));
  if (sub_1905E84F4(&v168, v97, @"H2HTransformation", 8uLL))
  {
    byte_1EB3BF52C = 1;
    *(float32x4_t *)long long buf = vmulq_f32(vcvtq_f32_s32(vmovl_s16(v168)), (float32x4_t)vdupq_n_s32(0x38000100u));
    sub_1902D9ACC((float32x4_t *)buf, *(float32x4_t *)buf);
    xmmword_1EB3BF530 = *(_OWORD *)buf;
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    double v98 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134349824;
      *(double *)&uint8_t buf[4] = *(float *)&xmmword_1EB3BF530;
      *(_WORD *)&uint8_t buf[12] = 2050;
      *(double *)&buf[14] = *((float *)&xmmword_1EB3BF530 + 1);
      *(_WORD *)&unsigned char buf[22] = 2050;
      *(double *)&unsigned char buf[24] = *((float *)&xmmword_1EB3BF530 + 2);
      *(_WORD *)&unsigned char buf[32] = 2050;
      *(double *)&buf[34] = *((float *)&xmmword_1EB3BF530 + 3);
      _os_log_impl(&dword_1902AF000, v98, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Received headset to head transformation {%{public}f, %{public}f, %{public}f, %{public}f} from IORegistry", buf, 0x2Au);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      int v141 = 134349824;
      *(double *)uint64_t v142 = *(float *)&xmmword_1EB3BF530;
      v142[4] = 2050;
      *(double *)&v142[5] = *((float *)&xmmword_1EB3BF530 + 1);
      v142[9] = 2050;
      *(double *)&v142[10] = *((float *)&xmmword_1EB3BF530 + 2);
      v142[14] = 2050;
      *(double *)&v142[15] = *((float *)&xmmword_1EB3BF530 + 3);
      long long v100 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::onDeviceMotionData(AudioAccessorySample &, CLMotionTypeTimestamp)", "CoreLocation: %s\n", v100);
LABEL_273:
      if (v100 != buf) {
        free(v100);
      }
    }
  }
  else
  {
    byte_1EB3BF52C = 0;
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    uint64_t v102 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1902AF000, v102, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Warning! Headset to Head transformation is not available from the accessory.", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      LOWORD(v141) = 0;
      long long v100 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::onDeviceMotionData(AudioAccessorySample &, CLMotionTypeTimestamp)", "CoreLocation: %s\n", v100);
      goto LABEL_273;
    }
  }
  if (byte_1EB3BF52C)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF418, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF418))
    {
      xmmword_1EB3BF4D0 = xmmword_19060B830;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF4D0, (float32x4_t)xmmword_19060B830);
      __cxa_guard_release(&qword_1EB3BF418);
    }
    sub_1904CF3F4((uint64_t)&xmmword_1EB3BF530, (float *)&xmmword_1EB3BF4D0, (float32x4_t *)buf, v99);
    *(_OWORD *)((char *)&qword_1EB3BF518 + 4) = *(_OWORD *)buf;
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    uint64_t v103 = qword_1EB3BE830;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134349824;
      *(double *)&uint8_t buf[4] = *((float *)&qword_1EB3BF518 + 1);
      *(_WORD *)&uint8_t buf[12] = 2050;
      *(double *)&buf[14] = unk_1EB3BF520;
      *(_WORD *)&unsigned char buf[22] = 2050;
      *(double *)&unsigned char buf[24] = *(float *)&dword_1EB3BF524;
      *(_WORD *)&unsigned char buf[32] = 2050;
      *(double *)&buf[34] = *(float *)&dword_1EB3BF528;
      _os_log_impl(&dword_1902AF000, v103, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Derived device frame orientation {%{public}f, %{public}f, %{public}f, %{public}f} from IORegistry", buf, 0x2Au);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE838 != -1) {
        dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
      }
      int v141 = 134349824;
      *(double *)uint64_t v142 = *((float *)&qword_1EB3BF518 + 1);
      v142[4] = 2050;
      *(double *)&v142[5] = unk_1EB3BF520;
      v142[9] = 2050;
      *(double *)&v142[10] = *(float *)&dword_1EB3BF524;
      v142[14] = 2050;
      *(double *)&v142[15] = *(float *)&dword_1EB3BF528;
      double v104 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::onDeviceMotionData(AudioAccessorySample &, CLMotionTypeTimestamp)", "CoreLocation: %s\n", v104);
      if (v104 != buf) {
        free(v104);
      }
    }
  }
  else
  {
    int v105 = qword_1EB3BF518;
    int v106 = dword_1EB3BF4E0;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF3B8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF3B8))
    {
      xmmword_1EB3BF420 = xmmword_190608E30;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF420, (float32x4_t)xmmword_190608E30);
      __cxa_guard_release(&qword_1EB3BF3B8);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF3C0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF3C0))
    {
      xmmword_1EB3BF430 = xmmword_19060B840;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF430, (float32x4_t)xmmword_19060B840);
      __cxa_guard_release(&qword_1EB3BF3C0);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF3C8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF3C8))
    {
      xmmword_1EB3BF440 = xmmword_19060B850;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF440, (float32x4_t)xmmword_19060B850);
      __cxa_guard_release(&qword_1EB3BF3C8);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF3D0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF3D0))
    {
      xmmword_1EB3BF450 = xmmword_19060B860;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF450, (float32x4_t)xmmword_19060B860);
      __cxa_guard_release(&qword_1EB3BF3D0);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF3D8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF3D8))
    {
      xmmword_1EB3BF460 = xmmword_19060B870;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF460, (float32x4_t)xmmword_19060B870);
      __cxa_guard_release(&qword_1EB3BF3D8);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF3E0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF3E0))
    {
      xmmword_1EB3BF470 = xmmword_19060B880;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF470, (float32x4_t)xmmword_19060B880);
      __cxa_guard_release(&qword_1EB3BF3E0);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF3E8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF3E8))
    {
      xmmword_1EB3BF480 = xmmword_19060B890;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF480, (float32x4_t)xmmword_19060B890);
      __cxa_guard_release(&qword_1EB3BF3E8);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF3F0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF3F0))
    {
      xmmword_1EB3BF490 = xmmword_19060B8A0;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF490, (float32x4_t)xmmword_19060B8A0);
      __cxa_guard_release(&qword_1EB3BF3F0);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF3F8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF3F8))
    {
      xmmword_1EB3BF4A0 = xmmword_19060B840;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF4A0, (float32x4_t)xmmword_19060B840);
      __cxa_guard_release(&qword_1EB3BF3F8);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF400, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF400))
    {
      xmmword_1EB3BF4B0 = xmmword_19060B850;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF4B0, (float32x4_t)xmmword_19060B850);
      __cxa_guard_release(&qword_1EB3BF400);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB3BF408, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB3BF408))
    {
      xmmword_1EB3BF4C0 = xmmword_19060B8B0;
      sub_1902D9ACC((float32x4_t *)&xmmword_1EB3BF4C0, (float32x4_t)xmmword_19060B8B0);
      __cxa_guard_release(&qword_1EB3BF408);
    }
    switch(v105)
    {
      case 1:
        uint64_t v107 = &xmmword_1EB3BF430;
        goto LABEL_219;
      case 2:
        uint64_t v107 = &xmmword_1EB3BF450;
        break;
      case 3:
        uint64_t v107 = &xmmword_1EB3BF460;
        goto LABEL_219;
      case 4:
        uint64_t v107 = &xmmword_1EB3BF480;
        goto LABEL_219;
      case 5:
        uint64_t v107 = &xmmword_1EB3BF4A0;
LABEL_219:
        if (v106 != 2) {
          ++v107;
        }
        break;
      case 6:
        uint64_t v107 = &xmmword_1EB3BF4C0;
        break;
      default:
        uint64_t v107 = &xmmword_1EB3BF420;
        break;
    }
    *(_OWORD *)((char *)&qword_1EB3BF518 + 4) = *v107;
  }
  int v108 = dword_1EB3BF4E0;
  if (qword_1EB3BF518 > 8)
  {
    int v109 = 0;
  }
  else
  {
    int v109 = 1;
    if (((1 << qword_1EB3BF518) & 0x1BB) != 0)
    {
      if (dword_1EB3BF4E0 == 2) {
        int v109 = 1;
      }
      else {
        int v109 = 2;
      }
    }
  }
  dword_1EB3BF3A0 = v109;
  *(_DWORD *)(a1 + 360) = qword_1EB3BF518;
  *(_DWORD *)(a1 + 368) = v108;
  *(unsigned char *)(a1 + 390) = 1;
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  uint64_t v110 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
  {
    id v111 = sub_1905A1108(qword_1EB3BF518);
    int v112 = sub_1905A1180(dword_1EB3BF3A0);
    if (byte_1EB3BF4FF >= 0) {
      int v113 = &xmmword_1EB3BF4E8;
    }
    else {
      int v113 = (long long *)xmmword_1EB3BF4E8;
    }
    if (byte_1EB3BF517 >= 0) {
      int v114 = &xmmword_1EB3BF500;
    }
    else {
      int v114 = (long long *)xmmword_1EB3BF500;
    }
    *(_DWORD *)long long buf = 138479107;
    *(void *)&uint8_t buf[4] = v111;
    *(_WORD *)&uint8_t buf[12] = 2114;
    *(void *)&buf[14] = v112;
    *(_WORD *)&unsigned char buf[22] = 1026;
    *(_DWORD *)&unsigned char buf[24] = dword_1EB3BF4E0;
    *(_WORD *)&buf[28] = 2081;
    *(void *)&buf[30] = v113;
    *(_WORD *)&buf[38] = 2081;
    *(void *)&buf[40] = v114;
    *(_WORD *)&uint8_t buf[48] = 1026;
    *(_DWORD *)&buf[50] = qword_1EB3BF518;
    _os_log_impl(&dword_1902AF000, v110, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] config,%{private}@,location,%{public}@,side,%{public}d,configuration,%{private}s,serialNumber,%{private}s,hardwareModel,%{public}d", buf, 0x36u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    uint64_t v118 = sub_1905A1108(qword_1EB3BF518);
    uint64_t v119 = sub_1905A1180(dword_1EB3BF3A0);
    if (byte_1EB3BF4FF >= 0) {
      uint64_t v120 = &xmmword_1EB3BF4E8;
    }
    else {
      uint64_t v120 = (long long *)xmmword_1EB3BF4E8;
    }
    if (byte_1EB3BF517 >= 0) {
      uint64_t v121 = &xmmword_1EB3BF500;
    }
    else {
      uint64_t v121 = (long long *)xmmword_1EB3BF500;
    }
    int v141 = 138479107;
    *(void *)uint64_t v142 = v118;
    v142[4] = 2114;
    *(void *)&v142[5] = v119;
    v142[9] = 1026;
    *(_DWORD *)&v142[10] = dword_1EB3BF4E0;
    v142[12] = 2081;
    *(void *)&v142[13] = v120;
    v142[17] = 2081;
    *(void *)&v142[18] = v121;
    v142[22] = 1026;
    *(_DWORD *)&v142[23] = qword_1EB3BF518;
    double v122 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::onDeviceMotionData(AudioAccessorySample &, CLMotionTypeTimestamp)", "CoreLocation: %s\n", v122);
    if (v122 != buf) {
      free(v122);
    }
  }
  sub_1902D8BCC(a1, 1, (uint64_t)&dword_1EB3BF4E0, 96);
  if (*(unsigned char *)(a1 + 30))
  {
LABEL_160:
    HIDWORD(v137) = dword_1EB3BF3A0;
    sub_1902D8BCC(a1, 0, (uint64_t)&v128, 144);
  }
}

void sub_19052E278(_Unwind_Exception *a1)
{
}

void sub_19052E2C8(uint64_t a1, uint64_t a2)
{
  sub_19052E350(a2);
  *(void *)(a2 + 136) = 0;
  *(unsigned char *)(a2 + 144) = 0;
  *(void *)(a2 + 124) = 0;
  *(void *)(a2 + 116) = 0;
  *(_OWORD *)(a2 + 152) = xmmword_19060B820;
  *(void *)(a2 + 168) = 0;
  double v3 = *(double *)(a2 + 184);
  if (v3 < 5.0) {
    *(double *)(a2 + 184) = v3 + 1.0;
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a2 + 176) = Current;
  double v5 = *(__CFRunLoopTimer **)(a2 + 192);
  double v6 = Current + *(double *)(a2 + 184);

  CFRunLoopTimerSetNextFireDate(v5, v6);
}

void sub_19052E350(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  double Current = CFAbsoluteTimeGetCurrent();
  unsigned int v3 = *(_DWORD *)(a1 + 120);
  if (v3) {
    double v4 = *(double *)(a1 + 152) / (double)v3;
  }
  else {
    double v4 = 0.0;
  }
  double v5 = *(double *)(a1 + 176);
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  double v6 = Current - v5;
  uint64_t v7 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(_DWORD *)(a1 + 116);
    int v9 = *(_DWORD *)(a1 + 120);
    uint64_t v10 = *(void *)(a1 + 160);
    uint64_t v11 = *(void *)(a1 + 168);
    int v12 = *(_DWORD *)(a1 + 124);
    int v13 = *(unsigned __int16 *)(a1 + 128);
    uint64_t v14 = *(void *)(a1 + 136);
    int v15 = *(unsigned __int16 *)(a1 + 130);
    int v16 = *(unsigned __int8 *)(a1 + 144);
    *(_DWORD *)long long buf = 134351616;
    double v19 = v6;
    __int16 v20 = 1026;
    int v21 = v8;
    __int16 v22 = 1026;
    int v23 = v9;
    __int16 v24 = 2050;
    double v25 = v4;
    __int16 v26 = 2050;
    uint64_t v27 = v10;
    __int16 v28 = 2050;
    uint64_t v29 = v11;
    __int16 v30 = 1026;
    int v31 = v12;
    __int16 v32 = 1026;
    int v33 = v13;
    __int16 v34 = 2050;
    uint64_t v35 = v14;
    __int16 v36 = 1026;
    int v37 = v15;
    __int16 v38 = 1026;
    int v39 = v16;
    _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Duration,%{public}.3f,Samples,%{public}u,TimeSyncedSamples,%{public}u,MeanLatency,%{public}.6f,MinLatency,%{public}.6f,MaxLatency,%{public}.6f,TimeSyncStatus,%{public}u,Seq,%{public}u,SensorTime,%{public}llu,Status,0x%{public}04x,Version,%{public}d", buf, 0x58u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    unint64_t v17 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::Tracker::logSensorStatistics() const", "CoreLocation: %s\n", v17);
    if (v17 != (char *)buf) {
      free(v17);
    }
  }
}

uint64_t sub_19052E624(uint64_t a1, const char *a2)
{
  v45[21] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 40);
  v44[0] = @"precisionType";
  uint64_t v4 = objc_msgSend_numberWithInt_(NSNumber, a2, *(unsigned int *)(a1 + 80));
  double v6 = *(__CFString **)(a1 + 32);
  if (!v6) {
    double v6 = @"unknown";
  }
  v45[0] = v4;
  v45[1] = v6;
  v44[1] = @"accessoryHardwareModel";
  v44[2] = @"accessoryBudLocation";
  v45[2] = objc_msgSend_numberWithInt_(NSNumber, v5, *(unsigned int *)(v3 + 72));
  _DWORD v44[3] = @"headTrackingClientMode";
  v45[3] = objc_msgSend_numberWithInt_(NSNumber, v7, *(unsigned int *)(v3 + 88));
  v44[4] = @"sessionDuration";
  v45[4] = objc_msgSend_numberWithDouble_(NSNumber, v8, v9, *(double *)(a1 + 48));
  v44[5] = @"delayBTClock";
  v45[5] = objc_msgSend_numberWithDouble_(NSNumber, v10, v11, *(double *)(a1 + 56));
  v44[6] = @"delayTimeSync";
  v45[6] = objc_msgSend_numberWithDouble_(NSNumber, v12, v13, *(double *)(a1 + 64));
  v44[7] = @"timeSyncedSamplesPerSecond";
  v45[7] = objc_msgSend_numberWithDouble_(NSNumber, v14, v15, (float)*(unsigned int *)(v3 + 96) / *(double *)(a1 + 48));
  v44[8] = @"timeSyncInvalidated";
  v45[8] = objc_msgSend_numberWithBool_(NSNumber, v16, *(_DWORD *)(v3 + 100) != 0);
  v44[9] = @"highLatencySamplesPerMinute";
  float v45[9] = objc_msgSend_numberWithDouble_(NSNumber, v17, v18, (float)((float)*(unsigned int *)(v3 + 104) * 60.0) / *(double *)(a1 + 48));
  v44[10] = @"backwardSamplesPerMinute";
  v45[10] = objc_msgSend_numberWithDouble_(NSNumber, v19, v20, (float)((float)*(unsigned int *)(v3 + 108) * 60.0) / *(double *)(a1 + 48));
  v44[11] = @"repeatedSamplesPerMinute";
  v45[11] = objc_msgSend_numberWithDouble_(NSNumber, v21, v22, (float)((float)*(unsigned int *)(v3 + 112) * 60.0) / *(double *)(a1 + 48));
  v44[12] = @"minLatency";
  v45[12] = objc_msgSend_numberWithDouble_(NSNumber, v23, v24, *(double *)(v3 + 32));
  v44[13] = @"maxLatency";
  v45[13] = objc_msgSend_numberWithDouble_(NSNumber, v25, v26, *(double *)(v3 + 40));
  v44[14] = @"averageLatency";
  v45[14] = objc_msgSend_numberWithDouble_(NSNumber, v27, v28, *(double *)(a1 + 72));
  v44[15] = @"minInterval";
  v45[15] = objc_msgSend_numberWithDouble_(NSNumber, v29, v30, *(double *)(v3 + 48));
  v44[16] = @"maxInterval";
  v45[16] = objc_msgSend_numberWithDouble_(NSNumber, v31, v32, *(double *)(v3 + 56));
  v44[17] = @"isAccessoryServiceValid";
  v45[17] = objc_msgSend_numberWithBool_(NSNumber, v33, *(unsigned __int8 *)(v3 + 92));
  v44[18] = @"hasValidConfig";
  v45[18] = objc_msgSend_numberWithBool_(NSNumber, v34, *(unsigned __int8 *)(v3 + 94));
  v44[19] = @"isBothBudsInEar";
  v45[19] = objc_msgSend_numberWithBool_(NSNumber, v35, *(unsigned __int8 *)(v3 + 93));
  v44[20] = @"isIMUInvalid";
  v45[20] = objc_msgSend_numberWithBool_(NSNumber, v36, *(unsigned __int8 *)(v3 + 95));
  uint64_t v38 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v37, (uint64_t)v45, v44, 21);
  if (qword_1EB3BE838 != -1) {
    dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
  }
  int v39 = qword_1EB3BE830;
  if (os_log_type_enabled((os_log_t)qword_1EB3BE830, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138477827;
    uint64_t v43 = v38;
    _os_log_impl(&dword_1902AF000, v39, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Sending analytics: \n%{private}@", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EB3BE838 != -1) {
      dispatch_once(&qword_1EB3BE838, &unk_1EDFC36C8);
    }
    double v41 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::Tracker::stop()_block_invoke", "CoreLocation: %s\n", v41);
    if (v41 != (char *)buf) {
      free(v41);
    }
  }
  return v38;
}

os_log_t sub_19052EAAC()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1EB3BE830 = (uint64_t)result;
  return result;
}

uint64_t sub_19052EADC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  double v2 = *(double *)(v1 + 272);
  double v3 = rint(v2 * 1000000.0);
  if (v2 < 0.0) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = (uint64_t)v3;
  }
  return sub_1902CDC50(*(void *)(v1 + 32), v4);
}

uint64_t sub_19052EB08(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  double v2 = *(double *)(v1 + 272);
  double v3 = rint(v2 * 1000000.0);
  if (v2 < 0.0) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = (uint64_t)v3;
  }
  return sub_1902CDC50(*(void *)(v1 + 32), v4);
}

uint64_t sub_19052EB34(uint64_t a1)
{
  return sub_1902CDC50(*(void *)(*(void *)(a1 + 32) + 32), (uint64_t)rint(0.0));
}

uint64_t sub_19052EB4C(uint64_t a1)
{
  return sub_1902CDC50(*(void *)(*(void *)(a1 + 32) + 32), (uint64_t)rint(0.0));
}

uint64_t sub_19052EB64(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  double v2 = *(double *)(v1 + 272);
  double v3 = rint(v2 * 1000000.0);
  if (v2 < 0.0) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = (uint64_t)v3;
  }
  return sub_1902CDC50(*(void *)(v1 + 32), v4);
}

uint64_t sub_19052EB90(uint64_t a1)
{
  return sub_1902CDC50(*(void *)(*(void *)(a1 + 32) + 32), (uint64_t)rint(0.0));
}

os_log_t sub_19052EF4C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Calorimetry");
  qword_1E929D768 = (uint64_t)result;
  return result;
}

void *sub_19052EF7C(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    double v6 = result;
    os_log_t result = sub_1903479A4(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      os_log_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_19052EFDC(_Unwind_Exception *exception_object)
{
  double v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19052FDE4(void *a1)
{
  a1[32] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 35);
  a1[22] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 25);
  a1[11] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 14);
  a1[2] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 5);
  return a1;
}

void sub_19052FEA8(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5, unsigned int a6, unsigned int a7, _DWORD *a8, char a9)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 4) = *a3;
  *(_DWORD *)(a1 + 12) = *a4;
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)(a1 + 24) = a5;
  sub_1902B5164((void *)(a1 + 16));
  *(void *)(a1 + 96) = a6;
  sub_1902B5164((void *)(a1 + 88));
  *(void *)(a1 + 160) = a7 / a5;
  *(_DWORD *)(a1 + 168) = *a8;
  *(void *)(a1 + 184) = a6;
  sub_1902B5164((void *)(a1 + 176));
  *(unsigned char *)(a1 + 248) = a9;
  if (a9) {
    unint64_t v14 = vcvtad_u64_f64(*(float *)a1 * 0.25);
  }
  else {
    unint64_t v14 = 1;
  }
  *(void *)(a1 + 264) = v14;
  sub_1902B5164((void *)(a1 + 256));
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD2060);
  }
  uint64_t v15 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
  {
    double v16 = *(float *)a1;
    double v17 = *(float *)(a1 + 4);
    double v18 = *(float *)(a1 + 12);
    int v19 = *(_DWORD *)(a1 + 160);
    double v20 = *(float *)(a1 + 168);
    *(_DWORD *)long long buf = 134219008;
    double v23 = v16;
    __int16 v24 = 2048;
    double v25 = v17;
    __int16 v26 = 2048;
    double v27 = v18;
    __int16 v28 = 1024;
    int v29 = v19;
    __int16 v30 = 2048;
    double v31 = v20;
    _os_log_impl(&dword_1902AF000, v15, OS_LOG_TYPE_DEBUG, "sample rate (%.3f) observation rate (%.3f) observation threshold (%.3f) deviation count threshold (%d) standard deviation threshold (%.3f)", buf, 0x30u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD2060);
    }
    int v21 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLThreshold::init(const float &, const float &, const float &, const unsigned int, const unsigned int, const unsigned int, const float &, const BOOL)", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf) {
      free(v21);
    }
  }
}

uint64_t sub_190530188(uint64_t a1, float *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  ++*(_DWORD *)(a1 + 8);
  if (*(unsigned char *)(a1 + 248) && *(void *)(a1 + 320) < *(void *)(a1 + 264)) {
    sub_1902D9094(a1 + 256, a2);
  }
  sub_1902D9094(a1 + 16, a2);
  if ((unint64_t)*(unsigned int *)(a1 + 8) % *(void *)(a1 + 24)) {
    return 0;
  }
  unint64_t v4 = *(void *)(a1 + 80);
  float v5 = 0.0;
  float v6 = 0.0;
  if (v4) {
    float v6 = *(float *)(a1 + 32) / (float)v4;
  }
  *(float *)long long buf = v6;
  sub_1902D9094(a1 + 88, (float *)buf);
  unint64_t v7 = *(void *)(a1 + 152);
  if (v7) {
    float v5 = *(float *)(a1 + 104) / (float)v7;
  }
  v35[0] = (float)(*a2 - v5) * (float)(*a2 - v5);
  sub_1902D9094(a1 + 176, v35);
  if (*(_DWORD *)(a1 + 8) % (float)(*(float *)a1 / *(float *)(a1 + 4))) {
    return 0;
  }
  unint64_t v9 = *(void *)(a1 + 152);
  float v10 = 0.0;
  float v11 = 0.0;
  if (v9) {
    float v11 = *(float *)(a1 + 104) / (float)v9;
  }
  unint64_t v12 = *(void *)(a1 + 320);
  if (v12) {
    float v10 = *(float *)(a1 + 272) / (float)v12;
  }
  float v13 = vabds_f32(v11, v10);
  unint64_t v14 = *(void *)(a1 + 240);
  if (v14) {
    float v15 = *(float *)(a1 + 192) / (float)v14;
  }
  else {
    float v15 = 0.0;
  }
  int v16 = *(_DWORD *)(a1 + 164);
  if (v13 <= *(float *)(a1 + 12))
  {
    if (!v16) {
      return 0;
    }
    int v17 = -1;
  }
  else
  {
    int v17 = 1;
  }
  uint64_t result = 0;
  unsigned int v18 = v17 + v16;
  *(_DWORD *)(a1 + 164) = v18;
  if (v18 > *(_DWORD *)(a1 + 160) && sqrtf(v15) != 0.0)
  {
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD2060);
    }
    int v19 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v20 = *(void *)(a1 + 320);
      if (v20) {
        double v21 = (float)(*(float *)(a1 + 272) / (float)v20);
      }
      else {
        double v21 = 0.0;
      }
      double v22 = *(float *)(a1 + 12);
      double v23 = *a2;
      unint64_t v24 = *(void *)(a1 + 240);
      if (v24) {
        float v25 = *(float *)(a1 + 192) / (float)v24;
      }
      else {
        float v25 = 0.0;
      }
      int v26 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)long long buf = 134219008;
      double v46 = v22;
      __int16 v47 = 2048;
      double v48 = v23;
      __int16 v49 = 2048;
      double v50 = v21;
      __int16 v51 = 2048;
      double v52 = sqrtf(fabsf(v25));
      __int16 v53 = 1024;
      int v54 = v26;
      _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_DEBUG, "threshold (%f) was exceeded with observed value (%f) and base value (%f) and standard deviation (%f) and count of (%d)", buf, 0x30u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD2060);
      }
      unint64_t v27 = *(void *)(a1 + 320);
      if (v27) {
        double v28 = (float)(*(float *)(a1 + 272) / (float)v27);
      }
      else {
        double v28 = 0.0;
      }
      double v29 = *(float *)(a1 + 12);
      double v30 = *a2;
      unint64_t v31 = *(void *)(a1 + 240);
      if (v31) {
        float v32 = *(float *)(a1 + 192) / (float)v31;
      }
      else {
        float v32 = 0.0;
      }
      int v33 = *(_DWORD *)(a1 + 164);
      v35[1] = 3.8524e-34;
      double v36 = v29;
      __int16 v37 = 2048;
      double v38 = v30;
      __int16 v39 = 2048;
      double v40 = v28;
      __int16 v41 = 2048;
      double v42 = sqrtf(fabsf(v32));
      __int16 v43 = 1024;
      int v44 = v33;
      __int16 v34 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CLThreshold::update(const float &)", "CoreLocation: %s\n", v34);
      if (v34 != (char *)buf) {
        free(v34);
      }
    }
    return 1;
  }
  return result;
}

float sub_1905305B0(uint64_t a1, int a2)
{
  if (a2)
  {
    unint64_t v3 = *(void *)(a1 + 320);
    if (v3) {
      float v4 = *(float *)(a1 + 272) / (float)v3;
    }
    else {
      float v4 = 0.0;
    }
    float v6 = v4;
    *(_DWORD *)(a1 + 8) = 0;
    sub_1902B5164((void *)(a1 + 16));
    sub_1902B5164((void *)(a1 + 88));
    *(_DWORD *)(a1 + 164) = 0;
    sub_1902B5164((void *)(a1 + 176));
    return sub_19053066C((void *)a1, &v6);
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    sub_1902B5164((void *)(a1 + 16));
    sub_1902B5164((void *)(a1 + 88));
    *(_DWORD *)(a1 + 164) = 0;
    sub_1902B5164((void *)(a1 + 176));
    sub_1902B5164((void *)(a1 + 256));
  }
  return result;
}

float sub_19053066C(void *a1, float *a2)
{
  uint64_t v4 = (uint64_t)(a1 + 32);
  sub_1902B5164(a1 + 32);
  while (a1[40] < a1[33])
    float result = sub_1902D9094(v4, a2);
  return result;
}

os_log_t sub_1905306C4()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Compass");
  qword_1E929D790 = (uint64_t)result;
  return result;
}

uint64_t sub_190530934(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float a5, float a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)a1 = -1082130432;
  *(unsigned char *)(a1 + 4) = 0;
  *(float *)(a1 + 8) = a5;
  *(float *)(a1 + 12) = a6;
  *(_DWORD *)(a1 + 16) = 5;
  *(void *)(a1 + 24) = &unk_1EDFC93B0;
  *(void *)(a1 + 32) = a2;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = &unk_1EDFC8EB8;
  *(void *)(a1 + 104) = a3;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = &unk_1EDFC93B0;
  *(void *)(a1 + 192) = a2;
  *(void *)(a1 + 248) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(unsigned char *)(a1 + 256) = a4;
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD2080);
  }
  float v10 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
  {
    double v11 = *(float *)(a1 + 8);
    double v12 = *(float *)(a1 + 12);
    *(_DWORD *)long long buf = 134219008;
    double v16 = v11;
    __int16 v17 = 2048;
    double v18 = v12;
    __int16 v19 = 2048;
    uint64_t v20 = a2;
    __int16 v21 = 2048;
    uint64_t v22 = a3;
    __int16 v23 = 1024;
    int v24 = a4;
    _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_DEBUG, "mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd), coverAttached (%d)", buf, 0x30u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD2080);
    }
    unint64_t v14 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "CLCompassAccuracy::CLCompassAccuracy(const float, const float, const size_t, const size_t, const BOOL)", "CoreLocation: %s\n", v14);
    if (v14 != (char *)buf) {
      free(v14);
    }
  }
  return a1;
}

void sub_190530C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  void v12[23] = v15;
  sub_1902D5B70(v12 + 26);
  v12[12] = v13;
  sub_1902D5B70(v14);
  void v12[3] = a12;
  sub_1902D5B70(v12 + 6);
  _Unwind_Resume(a1);
}

void *sub_190530C6C(void *a1)
{
  *a1 = &unk_1EDFC8EB8;
  sub_1902D5B70(a1 + 5);
  return a1;
}

void *sub_190530CB0(void *a1)
{
  a1[23] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 26);
  a1[12] = &unk_1EDFC8EB8;
  sub_1902D5B70(a1 + 17);
  a1[3] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 6);
  return a1;
}

void sub_190530D4C(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)a1 = -1082130432;
  *(float *)(a1 + 8) = a4;
  *(float *)(a1 + 12) = a5;
  *(void *)(a1 + 32) = a2;
  sub_1902B5164((void *)(a1 + 24));
  *(void *)(a1 + 104) = a3;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD2080);
  }
  size_t v8 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
  {
    double v9 = *(float *)(a1 + 8);
    double v10 = *(float *)(a1 + 12);
    *(_DWORD *)long long buf = 134218752;
    double v13 = v9;
    __int16 v14 = 2048;
    double v15 = v10;
    __int16 v16 = 2048;
    uint64_t v17 = a2;
    __int16 v18 = 2048;
    uint64_t v19 = a3;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEBUG, "mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd)", buf, 0x2Au);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD2080);
    }
    double v11 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLCompassAccuracy::init(const float, const float, const size_t, const size_t)", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf) {
      free(v11);
    }
  }
}

float sub_190530F80(uint64_t a1, float a2, float a3)
{
  float v9 = a3;
  if (*(unsigned char *)(a1 + 4))
  {
    float v8 = (float)(a2 - *(float *)(a1 + 8)) * (float)(a2 - *(float *)(a1 + 8));
    sub_1902D9094(a1 + 24, &v8);
    unint64_t v4 = *(void *)(a1 + 88);
    if (v4) {
      float v5 = *(float *)(a1 + 40) / (float)v4;
    }
    else {
      float v5 = 0.0;
    }
    float v7 = v5;
    sub_190531008(a1 + 96, &v7);
  }
  return sub_1902D9094(a1 + 184, &v9);
}

void sub_190531008(uint64_t a1, float *a2)
{
  uint64_t v4 = a1 + 40;
  sub_1902D913C((void *)(a1 + 40), a2);
  unint64_t v5 = *(void *)(a1 + 80);
  if (v5 > *(void *)(a1 + 8))
  {
    ++*(void *)(a1 + 72);
    *(void *)(a1 + 80) = v5 - 1;
    sub_1902D91C4(v4, 1);
  }
  if (*a2 <= *(float *)(a1 + 16))
  {
    unint64_t v6 = *(void *)(a1 + 24) + 1;
    *(void *)(a1 + 24) = v6;
    if (v6 >= *(void *)(a1 + 8))
    {
      sub_190531448(a1);
    }
  }
  else
  {
    *(float *)(a1 + 16) = *a2;
    *(void *)(a1 + 24) = 0;
  }
}

float sub_1905310C4(uint64_t a1)
{
  double v2 = *(void ***)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 56);
  *(void *)(a1 + 80) = 0;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *(void *)(a1 + 56);
      double v2 = (void **)(*(void *)(a1 + 48) + 8);
      *(void *)(a1 + 48) = v2;
      unint64_t v4 = v5 - (void)v2;
    }
    while (v4 > 0x10);
  }
  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 512;
    goto LABEL_7;
  }
  if (v4 >> 3 == 2)
  {
    uint64_t v6 = 1024;
LABEL_7:
    *(void *)(a1 + 72) = v6;
  }
  float result = *(float *)(a1 + 32);
  *(float *)(a1 + 16) = result;
  *(void *)(a1 + 24) = 0;
  return result;
}

float sub_190531148(uint64_t a1, int a2)
{
  if (a2 < 1) {
    return *(float *)a1;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 16) - a2;
  if (v3 > 4) {
    float v4 = 40.0;
  }
  else {
    float v4 = flt_19060B900[v3];
  }
  if (*(unsigned char *)(a1 + 4))
  {
    float v5 = sub_190531254(a1);
    if (*(float *)(a1 + 8) >= 70.0) {
      float v6 = v4 + 10.0;
    }
    else {
      float v6 = v4;
    }
    if (v5 < v6) {
      float v4 = v6;
    }
    else {
      float v4 = v5;
    }
  }
  if (*(unsigned char *)(a1 + 256))
  {
    float v7 = v4 + sub_190531308(a1);
    float v4 = -1.0;
    if (v7 > 0.0)
    {
      float v4 = 10.0;
      if (v7 > 10.0)
      {
        float v4 = 15.0;
        if (v7 > 15.0)
        {
          float v4 = 20.0;
          if (v7 > 20.0)
          {
            float v4 = 25.0;
            if (v7 > 25.0)
            {
              float v4 = 30.0;
              if (v7 > 30.0)
              {
                if (v7 <= 35.0) {
                  return 35.0;
                }
                else {
                  return 40.0;
                }
              }
            }
          }
        }
      }
    }
  }
  return v4;
}

float sub_190531254(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    float v2 = sqrtf(*(float *)(a1 + 112)) / sqrt((double)v1);
  }
  else {
    float v2 = 0.0;
  }
  float v3 = v2 * *(float *)(a1 + 12);
  float result = 10.0;
  if (v3 >= 15.0)
  {
    float result = 15.0;
    if (v3 >= 30.0)
    {
      float result = 20.0;
      if (v3 >= 45.0)
      {
        float result = 25.0;
        if (v3 >= 60.0)
        {
          float result = 30.0;
          if (v3 >= 75.0)
          {
            if (v3 >= 90.0) {
              return 40.0;
            }
            else {
              return 35.0;
            }
          }
        }
      }
    }
  }
  return result;
}

float sub_190531308(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 192);
  if (v1 && (unint64_t v2 = *(void *)(a1 + 248), v2 >= v1)) {
    return sub_190531338(*(float *)(a1 + 200) / (float)v2, 5.0);
  }
  else {
    return 0.0;
  }
}

float sub_190531338(float a1, float a2)
{
  if (a2 > a1) {
    return 180.0;
  }
  float v5 = (float)-a2 / a1;
  float v6 = acosf(v5);
  float v7 = sinf(v6);
  return fabsf(atan2f(v7 * a2, a1 + (float)(a2 * v5))) * 57.2957795;
}

os_log_t sub_1905313B4()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Compass");
  qword_1E929D790 = (uint64_t)result;
  return result;
}

void sub_1905313E4(void *a1)
{
  *a1 = &unk_1EDFC8EB8;
  sub_1902D5B70(a1 + 5);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_190531448(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 72);
  uint64_t v2 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 56);
  float v4 = (char *)(v2 + 8 * (v1 >> 10));
  if (v3 == v2)
  {
    uint64_t v6 = 0;
    uint64_t v5 = *(void *)(result + 72) & 0x3FFLL;
  }
  else
  {
    uint64_t v5 = *(void *)(result + 72) & 0x3FFLL;
    uint64_t v6 = *(void *)v4 + 4 * v5;
  }
  float v7 = *(float *)(result + 32);
  *(float *)(result + 16) = v7;
  uint64_t v8 = *(void *)(result + 80);
  *(void *)(result + 24) = v8 - 1;
  unint64_t v9 = v8 + v1;
  double v10 = (char *)(v2 + 8 * (v9 >> 10));
  uint64_t v11 = v9 & 0x3FF;
  double v12 = v4;
LABEL_5:
  double v13 = (float *)v6;
  while (1)
  {
    unint64_t v14 = v3 == v2 ? 0 : *(void *)v10 + 4 * v11;
    BOOL v15 = (unint64_t)v13 < v14 && v12 == v10;
    if (v12 >= v10 && !v15) {
      return result;
    }
    float v16 = *v13;
    if (*v13 > v7)
    {
      *(float *)(result + 16) = v16;
      if (v3 == v2) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = *(void *)v4 + 4 * v5;
      }
      if (v13 == (float *)v17) {
        uint64_t v18 = 0;
      }
      else {
        uint64_t v18 = ((v12 - v4) << 7) + ((v6 - *(void *)v12) >> 2) - ((v17 - *(void *)v4) >> 2);
      }
      *(void *)(result + 24) = v18;
      float v7 = v16;
    }
    ++v13;
    v6 += 4;
    if (*(void *)v12 + 4096 == v6)
    {
      uint64_t v19 = *((void *)v12 + 1);
      v12 += 8;
      uint64_t v6 = v19;
      goto LABEL_5;
    }
  }
}

uint64_t sub_19053155C(float *a1, float *a2, float *a3)
{
  float v4 = a2[4];
  float v5 = fabsf(v4);
  float v6 = a2[2];
  float v7 = 0.0;
  if (v5 > fabsf(v6))
  {
    float v8 = fabsf(a2[3]);
    BOOL v9 = v4 <= 0.0 || v5 <= v8;
    float v7 = 0.0625;
    if (v9) {
      float v7 = 0.0;
    }
  }
  float v10 = a1[2];
  float v11 = a1[3];
  float v12 = a1[4];
  float v13 = sqrtf((float)((float)(v11 * v11) + (float)(v10 * v10)) + (float)(v12 * v12));
  if (v13 > 0.0)
  {
    float v10 = v10 / v13;
    float v11 = v11 / v13;
    float v12 = v12 / v13;
  }
  float v14 = (float)(v11 + (float)(v10 * 0.0)) + (float)(v12 * 0.0);
  float v15 = v11 * 0.0;
  float v16 = (float)((float)(v11 * 0.0) - v10) + (float)(v12 * 0.0);
  float v17 = v12 + (float)(v15 + (float)(v10 * 0.0));
  float v18 = a2[3];
  float v19 = sqrtf((float)((float)(v18 * v18) + (float)(v6 * v6)) + (float)(v4 * v4));
  if (v19 > 0.0)
  {
    float v6 = v6 / v19;
    float v18 = v18 / v19;
    float v4 = v4 / v19;
  }
  float v20 = (float)(v18 + (float)(v6 * 0.0)) + (float)(v4 * 0.0);
  float v21 = v18 * 0.0;
  float v22 = (float)((float)(v18 * 0.0) - v6) + (float)(v4 * 0.0);
  float v23 = v4 + (float)(v21 + (float)(v6 * 0.0));
  float v24 = (float)(v16 * v23) - (float)(v17 * v22);
  float v25 = (float)(v17 * v20) - (float)(v14 * v23);
  float v26 = (float)(v14 * v22) - (float)(v16 * v20);
  float v27 = sqrtf((float)((float)(v25 * v25) + (float)(v24 * v24)) + (float)(v26 * v26));
  if (v27 > 0.0)
  {
    float v24 = v24 / v27;
    float v25 = v25 / v27;
    float v26 = v26 / v27;
  }
  float v28 = (float)(v22 * v26) - (float)(v23 * v25);
  float v29 = (float)(v23 * v24) - (float)(v20 * v26);
  float v30 = (float)(v20 * v25) - (float)(v22 * v24);
  float v31 = sqrtf((float)((float)(v29 * v29) + (float)(v28 * v28)) + (float)(v30 * v30));
  if (v31 > 0.0)
  {
    float v28 = v28 / v31;
    float v29 = v29 / v31;
    float v30 = v30 / v31;
  }
  float v32 = sqrtf((float)((float)(v22 * v22) + (float)(v20 * v20)) + (float)(v23 * v23));
  if (v32 <= 0.0) {
    float v33 = 1.0;
  }
  else {
    float v33 = v32;
  }
  if (v7 != 0.0)
  {
    float v39 = (float)((float)(v29 * 0.0) + (float)(v28 * v7)) + (float)(v30 * 0.0);
    float v40 = (float)((float)(v25 * 0.0) + (float)(v24 * v7)) + (float)(v26 * 0.0);
    if (v39 != 0.0 || v40 != 0.0)
    {
      float v38 = atan2f(-v40, v39) * 57.2957795;
      if (v38 >= 0.0)
      {
        for (; v38 >= 360.0; float v38 = v38 + -360.0)
          ;
        goto LABEL_43;
      }
      for (; v38 < -360.0; float v38 = v38 + 360.0)
        ;
      goto LABEL_37;
    }
    return 0;
  }
  if (v30 != 0.0 || (float v34 = 0.0, v26 != 0.0)) {
    float v34 = atan2f(v26, v30);
  }
  float v42 = v34;
  __float2 v35 = __sincosf_stret(v34);
  if ((float)((float)(v26 * v35.__sinval) + (float)(v35.__cosval * v30)) == 0.0 && (float)((float)-v23 / v33) == 0.0) {
    return 0;
  }
  float v36 = (float)(v25 * v35.__cosval) - (float)(v35.__sinval * v29);
  float v37 = (float)(v24 * v35.__cosval) - (float)(v35.__sinval * v28);
  if (v36 == 0.0 && v37 == 0.0) {
    return 0;
  }
  float v38 = (float)((float)-atan2f(v37, v36) - v42) * 57.2957795;
  if (v38 >= 0.0)
  {
    for (; v38 >= 360.0; float v38 = v38 + -360.0)
      ;
    goto LABEL_43;
  }
  for (; v38 < -360.0; float v38 = v38 + 360.0)
    ;
LABEL_37:
  float v38 = v38 + 360.0;
LABEL_43:
  *a3 = v38;
  return 1;
}

uint64_t sub_1905318CC()
{
  uint64_t result = sub_1902CD6B0();
  if ((result & 0x100) != 0) {
    operator new();
  }
  return result;
}

void sub_19053196C(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10F1C409DD59B8BLL);
  _Unwind_Resume(a1);
}

void *sub_190531990(void *a1)
{
  *a1 = &unk_1EDFC8ED8;
  a1[4] = &unk_1EDFC8F38;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_1902D8B58(v2);
  }

  return sub_1904DC240(a1);
}

void *sub_190531A10(uint64_t a1)
{
  return sub_190531990((void *)(a1 - 32));
}

void sub_190531A18(void *a1)
{
  sub_190531990(a1);

  JUMPOUT(0x192FCC980);
}

void sub_190531A50(uint64_t a1)
{
  sub_190531990((void *)(a1 - 32));

  JUMPOUT(0x192FCC980);
}

double sub_190531A8C@<D0>(void *a1@<X8>)
{
  char v4 = 0;
  double v3 = 0.0;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  if (qword_1E929E9C8 != -1) {
    dispatch_once(&qword_1E929E9C8, &unk_1EDFD2160);
  }
  if (sub_190538E84(qword_1E929E9C0, (uint64_t)&v4, (uint64_t)&v3))
  {
    double result = v3;
    *(double *)a1 = v3;
    *((unsigned char *)a1 + 8) = v4;
  }
  return result;
}

uint64_t sub_190531B14@<X0>(uint64_t a1@<X8>)
{
  *(_WORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (qword_1E929E9C8 != -1) {
    dispatch_once(&qword_1E929E9C8, &unk_1EDFD2160);
  }
  uint64_t v2 = qword_1E929E9C0;

  return sub_190538F5C(v2, a1);
}

void sub_190531B84(uint64_t a1, int a2)
{
  if (qword_1E929E9C8 != -1) {
    dispatch_once(&qword_1E929E9C8, &unk_1EDFD2160);
  }
  uint64_t v3 = qword_1E929E9C0;

  sub_1905395C8(v3, a2);
}

void sub_190531BE8()
{
  if (qword_1E929E9C8 != -1) {
    dispatch_once(&qword_1E929E9C8, &unk_1EDFD2160);
  }
  uint64_t v0 = qword_1E929E9C0;

  sub_1905398C8(v0);
}

void sub_190531C3C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D708 != -1) {
    dispatch_once(&qword_1E929D708, &unk_1EDFD31C0);
  }
  float v6 = off_1E929D6F8;
  if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67240448;
    *(_DWORD *)&uint8_t buf[4] = a2;
    *(_WORD *)&uint8_t buf[8] = 2050;
    *(void *)&unsigned char buf[10] = a3;
    _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_DEFAULT, "NumberOfSpectatorsChanged,notification,%{public}d,num,%{public}zu", buf, 0x12u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D708 != -1) {
      dispatch_once(&qword_1E929D708, &unk_1EDFD31C0);
    }
    LODWORD(v16) = 67240448;
    HIDWORD(v16) = a2;
    __int16 v17 = 2050;
    uint64_t v18 = a3;
    float v15 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLEclipseNotifier::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v15);
    if (v15 != buf) {
      free(v15);
    }
  }
  if (a2 != 2)
  {
    if (a2 >= 2)
    {
      if (qword_1E929D708 != -1) {
        dispatch_once(&qword_1E929D708, &unk_1EDFD31C0);
      }
      float v7 = off_1E929D6F8;
      if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = a2;
        _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_FAULT, "Unrecognized notification,%{public}d", buf, 8u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D708 != -1) {
          dispatch_once(&qword_1E929D708, &unk_1EDFD31C0);
        }
        LODWORD(v16) = 67240192;
        HIDWORD(v16) = a2;
        float v8 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "virtual void CLEclipseNotifier::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v8);
        goto LABEL_26;
      }
    }
    else
    {
      __int16 v9 = sub_1902CD6B0();
      if ((v9 & 0x100) != 0)
      {
        uint64_t v11 = *(void *)(a1 + 56);
        if (!v11)
        {
          float v12 = (void *)sub_1902DF4A8();
          uint64_t v16 = 0x140000FF0CLL;
          LOBYTE(v17) = 0;
          sub_19043791C(v12, (uint64_t)&v16, (uint64_t *)buf);
          long long v13 = *(_OWORD *)buf;
          *(void *)long long buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          float v14 = *(std::__shared_weak_count **)(a1 + 64);
          *(_OWORD *)(a1 + 56) = v13;
          if (v14)
          {
            sub_1902D8B58(v14);
            if (*(void *)&buf[8]) {
              sub_1902D8B58(*(std::__shared_weak_count **)&buf[8]);
            }
          }
          sub_1902CD864(*(void *)(a1 + 56), (uint64_t)sub_1902BDB28, a1);
          uint64_t v11 = *(void *)(a1 + 56);
        }
        sub_1902CDC50(v11, a3 != 0);
        if (qword_1E929E9C8 != -1) {
          dispatch_once(&qword_1E929E9C8, &unk_1EDFD2160);
        }
        sub_190538B9C(qword_1E929E9C0);
      }
      else
      {
        if (qword_1E929D708 != -1) {
          dispatch_once(&qword_1E929D708, &unk_1EDFD31C0);
        }
        float v10 = off_1E929D6F8;
        if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_FAULT, "Service unavailable.", buf, 2u);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D708 != -1) {
            dispatch_once(&qword_1E929D708, &unk_1EDFD31C0);
          }
          float v8 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "BOOL CLEclipseNotifier::openHidDevice()", "CoreLocation: %s\n", v8);
LABEL_26:
          if (v8 != buf) {
            free(v8);
          }
        }
      }
    }
  }
}

uint64_t sub_190532134(uint64_t a1, uint64_t a2)
{
  return sub_1902DF0C4(a1 - 32, a2);
}

uint64_t sub_19053213C(uint64_t a1, long long *a2)
{
  uint64_t v8 = 0;
  uint64_t v4 = *(void *)(a1 + 48);
  long long v2 = a2[1];
  long long v5 = *a2;
  long long v6 = v2;
  long long v7 = a2[2];
  LODWORD(v8) = *((_DWORD *)a2 + 12);
  return sub_1902D8BCC(a1, 1, (uint64_t)&v4, 64);
}

uint64_t sub_190532194(uint64_t a1, long long *a2)
{
  uint64_t v8 = 0;
  uint64_t v4 = *(void *)(a1 + 16);
  long long v2 = a2[1];
  long long v5 = *a2;
  long long v6 = v2;
  long long v7 = a2[2];
  LODWORD(v8) = *((_DWORD *)a2 + 12);
  return sub_1902D8BCC(a1 - 32, 1, (uint64_t)&v4, 64);
}

uint64_t sub_1905321F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v3 = *(void *)(a1 + 48);
  LOWORD(v4) = *(_WORD *)(a2 + 1);
  return sub_1904DC8A8(a1, 2, (uint64_t)&v3, 16);
}

uint64_t sub_190532234(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v3 = *(void *)(a1 + 16);
  LOWORD(v4) = *(_WORD *)(a2 + 1);
  return sub_1904DC8A8(a1 - 32, 2, (uint64_t)&v3, 16);
}

os_log_t sub_190532284()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Eclipse");
  off_1E929D6F8 = result;
  return result;
}

uint64_t sub_1905322B4(int a1, uint32_t __upper_bound)
{
  return arc4random_uniform(__upper_bound);
}

void sub_1905322C4()
{
}

void sub_1905322D8(uint64_t a1, void *a2, char a3, int a4)
{
  *(void *)a1 = *a2;
  float v4 = 1.0 / *(double *)a2;
  *(float *)(a1 + 8) = v4;
  uint64_t v5 = a1 + 8;
  *(unsigned char *)(a1 + 12) = 0;
  *(unsigned char *)(a1 + 13) = a3;
  *(void *)(a1 + 14) = 0;
  *(void *)(a1 + 30) = 0;
  *(void *)(a1 + 22) = 0;
  *(_WORD *)(a1 + 38) = 0;
  *(void *)(a1 + 40) = 0x3FF0000000000000;
  *(void *)(a1 + 48) = &unk_1EDFC7D60;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = &unk_1EDFC7D60;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  sub_190530934(a1 + 112, 10, 30, a4, 61.056, 2.0);
  *(void *)(v5 + 368) = 0xF00000000;
  *(_DWORD *)(v5 + 376) = 15;
  float v6 = *(float *)v5;
  double v7 = *(float *)v5;
  unint64_t v8 = vcvtad_u64_f64(v7 * 0.125);
  *(void *)(v5 + 384) = &unk_1EDFC8FA8;
  *(void *)(v5 + 392) = v8;
  *(void *)(v5 + 400) = &unk_1EDFC93B0;
  *(void *)(v5 + 408) = v8;
  *(_OWORD *)(v5 + 416) = 0u;
  *(_OWORD *)(v5 + 432) = 0u;
  *(_OWORD *)(v5 + 448) = 0u;
  *(void *)(v5 + 464) = 0;
  *(void *)(v5 + 472) = &unk_1EDFC93B0;
  *(void *)(v5 + 480) = v8;
  *(_OWORD *)(v5 + 488) = 0u;
  *(_OWORD *)(v5 + 504) = 0u;
  *(_OWORD *)(v5 + 520) = 0u;
  *(void *)(v5 + 536) = 0;
  *(void *)(v5 + 544) = &unk_1EDFC93B0;
  *(void *)(v5 + 620) = 0xBF8000003F000000;
  *(void *)(v5 + 552) = v8;
  *(_OWORD *)(v5 + 604) = 0u;
  *(_OWORD *)(v5 + 576) = 0u;
  *(_OWORD *)(v5 + 592) = 0u;
  *(_OWORD *)(v5 + 560) = 0u;
  *(_DWORD *)(v5 + 628) = -1082130432;
  *(void *)(v5 + 632) = &unk_1EDFC8268;
  *(_DWORD *)(v5 + 640) = 0;
  *(_OWORD *)(v5 + 648) = 0u;
  *(_OWORD *)(v5 + 664) = 0u;
  *(_OWORD *)(v5 + 680) = 0u;
  *(void *)(v5 + 704) = 0;
  *(void *)(v5 + 712) = 0;
  *(void *)(v5 + 696) = v5 + 704;
  *(void *)(v5 + 720) = &unk_1EDFC8268;
  *(_DWORD *)(v5 + 728) = 0;
  *(_OWORD *)(v5 + 752) = 0u;
  *(_OWORD *)(v5 + 768) = 0u;
  *(_OWORD *)(v5 + 736) = 0u;
  *(void *)(v5 + 800) = 0;
  *(void *)(v5 + 792) = 0;
  *(void *)(v5 + 784) = v5 + 792;
  unint64_t v9 = vcvtad_u64_f64(v7 * 0.05);
  *(void *)(v5 + 808) = &unk_1EDFC8FA8;
  *(void *)(v5 + 816) = v9;
  *(void *)(v5 + 824) = &unk_1EDFC93B0;
  *(void *)(v5 + 832) = v9;
  *(_OWORD *)(v5 + 840) = 0u;
  *(_OWORD *)(v5 + 856) = 0u;
  *(_OWORD *)(v5 + 872) = 0u;
  *(void *)(v5 + 888) = 0;
  *(void *)(v5 + 896) = &unk_1EDFC93B0;
  *(void *)(v5 + 904) = v9;
  *(_OWORD *)(v5 + 912) = 0u;
  *(_OWORD *)(v5 + 928) = 0u;
  *(_OWORD *)(v5 + 944) = 0u;
  *(void *)(v5 + 960) = 0;
  *(void *)(v5 + 968) = &unk_1EDFC93B0;
  *(void *)(v5 + 976) = v9;
  *(void *)(v5 + 1032) = 0;
  *(_OWORD *)(v5 + 1016) = 0u;
  *(_OWORD *)(v5 + 1000) = 0u;
  *(_OWORD *)(v5 + 984) = 0u;
  *(void *)(v5 + 1040) = &unk_1EDFC8FA8;
  *(void *)(v5 + 1048) = v9;
  *(void *)(v5 + 1056) = &unk_1EDFC93B0;
  *(void *)(v5 + 1064) = v9;
  *(void *)(v5 + 1120) = 0;
  *(_OWORD *)(v5 + 1088) = 0u;
  *(_OWORD *)(v5 + 1072) = 0u;
  *(_OWORD *)(v5 + 1104) = 0u;
  *(void *)(v5 + 1128) = &unk_1EDFC93B0;
  *(void *)(v5 + 1136) = v9;
  *(void *)(v5 + 1192) = 0;
  *(_OWORD *)(v5 + 1176) = 0u;
  *(_OWORD *)(v5 + 1160) = 0u;
  *(_OWORD *)(v5 + 1144) = 0u;
  *(void *)(v5 + 1200) = &unk_1EDFC93B0;
  *(void *)(v5 + 1208) = v9;
  *(void *)(v5 + 1264) = 0;
  *(_OWORD *)(v5 + 1248) = 0u;
  *(_OWORD *)(v5 + 1232) = 0u;
  *(_OWORD *)(v5 + 1216) = 0u;
  *(void *)(v5 + 1272) = &unk_1EDFC7D60;
  *(void *)(v5 + 1280) = 0;
  *(_DWORD *)(v5 + 1288) = 0;
  *(void *)(v5 + 1296) = &unk_1EDFC7D60;
  *(void *)(v5 + 1304) = 0;
  *(_DWORD *)(v5 + 1312) = 0;
  *(void *)(v5 + 1320) = &unk_1EDFC7D60;
  *(void *)(v5 + 1328) = 0;
  *(_DWORD *)(v5 + 1336) = 0;
  *(void *)(v5 + 1408) = 0;
  *(_OWORD *)(v5 + 1392) = 0u;
  *(_OWORD *)(v5 + 1376) = 0u;
  *(_OWORD *)(v5 + 1344) = 0u;
  *(_OWORD *)(v5 + 1360) = 0u;
  *(void *)(v5 + 1416) = 0xBFF0000000000000;
  unint64_t v10 = vcvtad_u64_f64(v7 * 0.5);
  *(void *)(v5 + 1424) = &unk_1EDFC93B0;
  *(void *)(v5 + 1432) = v10;
  *(void *)(v5 + 1488) = 0;
  *(_OWORD *)(v5 + 1472) = 0u;
  *(_OWORD *)(v5 + 1456) = 0u;
  *(_OWORD *)(v5 + 1440) = 0u;
  *(void *)(v5 + 1496) = &unk_1EDFC93B0;
  *(void *)(v5 + 1504) = v10;
  *(void *)(v5 + 1560) = 0;
  *(_OWORD *)(v5 + 1544) = 0u;
  *(_OWORD *)(v5 + 1528) = 0u;
  *(_OWORD *)(v5 + 1512) = 0u;
  *(void *)(v5 + 1568) = &unk_1EDFC93B0;
  *(void *)(v5 + 1576) = vcvtas_u32_f32(v6);
  *(void *)(v5 + 1648) = 0;
  *(_OWORD *)(v5 + 1632) = 0u;
  *(_OWORD *)(v5 + 1616) = 0u;
  *(_OWORD *)(v5 + 1600) = 0u;
  *(_OWORD *)(v5 + 1584) = 0u;
  *(void *)(v5 + 1656) = &unk_1EDFC93B0;
  *(_OWORD *)(v5 + 1712) = 0u;
  *(_OWORD *)(v5 + 1696) = 0u;
  *(_OWORD *)(v5 + 1680) = 0u;
  *(_OWORD *)(v5 + 1664) = 0u;
  *(void *)(v5 + 1728) = &unk_1EDFC93B0;
  *(_OWORD *)(v5 + 1796) = 0u;
  *(_OWORD *)(v5 + 1784) = 0u;
  *(_OWORD *)(v5 + 1768) = 0u;
  *(_OWORD *)(v5 + 1752) = 0u;
  *(_OWORD *)(v5 + 1736) = 0u;
  *(void *)(v5 + 1816) = &unk_1EDFC93B0;
  *(unsigned char *)(v5 + 1888) = 0;
  *(_OWORD *)(v5 + 1856) = 0u;
  *(_OWORD *)(v5 + 1840) = 0u;
  *(_OWORD *)(v5 + 1824) = 0u;
  *(_OWORD *)(v5 + 1872) = 0u;
  *(void *)(v5 + 1896) = &unk_1EDFC93B0;
  *(_OWORD *)(v5 + 1968) = 0u;
  *(_OWORD *)(v5 + 1952) = 0u;
  *(_OWORD *)(v5 + 1936) = 0u;
  *(_OWORD *)(v5 + 1920) = 0u;
  *(_OWORD *)(v5 + 1904) = 0u;
  *(void *)(v5 + 1984) = &unk_1EDFC93B0;
  *(_OWORD *)(v5 + 2040) = 0u;
  *(_OWORD *)(v5 + 2024) = 0u;
  *(_OWORD *)(v5 + 2008) = 0u;
  *(_OWORD *)(v5 + 1992) = 0u;
  *(void *)(v5 + 2056) = &unk_1EDFC93B0;
  *(_OWORD *)(v5 + 2124) = 0u;
  *(_OWORD *)(v5 + 2096) = 0u;
  *(_OWORD *)(v5 + 2080) = 0u;
  *(_OWORD *)(v5 + 2064) = 0u;
  *(_OWORD *)(v5 + 2112) = 0u;
  *(void *)(v5 + 2144) = &unk_1EDFC93B0;
  *(unsigned char *)(v5 + 2216) = 0;
  *(_OWORD *)(v5 + 2200) = 0u;
  *(_OWORD *)(v5 + 2184) = 0u;
  *(_OWORD *)(v5 + 2168) = 0u;
  *(_OWORD *)(v5 + 2152) = 0u;
  *(void *)(v5 + 2224) = &unk_1EDFC93B0;
  *(unsigned char *)(v5 + 2296) = 0;
  *(_OWORD *)(v5 + 2280) = 0u;
  *(_OWORD *)(v5 + 2264) = 0u;
  *(_OWORD *)(v5 + 2248) = 0u;
  *(_OWORD *)(v5 + 2232) = 0u;
  *(void *)(v5 + 2304) = &unk_1EDFC93B0;
  *(void *)(v5 + 2312) = vcvtad_u64_f64(v7 * 0.2);
  *(void *)(v5 + 2368) = 0;
  *(_OWORD *)(v5 + 2352) = 0u;
  *(_OWORD *)(v5 + 2336) = 0u;
  *(_OWORD *)(v5 + 2320) = 0u;
  *(void *)(v5 + 2376) = 0x3F800000BF800000;
  if (*(unsigned char *)(v5 + 5)) {
    operator new();
  }
  operator new();
}

void sub_190533B80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,void *a25)
{
  v25[289] = a11;
  sub_1902D5B70(v25 + 292);
  sub_19052FDE4(a24);
  sub_19052FDE4(a25);
  v25[197] = a12;
  sub_1902D5B70(v25 + 200);
  v25[188] = a13;
  sub_1902D5B70(v25 + 191);
  v25[179] = a14;
  sub_1902D5B70(v25 + 182);
  sub_1902D5AB8(a15);
  sub_1902D5AB8(a16);
  sub_1905360CC(a22);
  sub_1902D5AB8(a17);
  sub_190530CB0(a18);
  _Unwind_Resume(a1);
}

void *sub_190533D08(void *a1)
{
  uint64_t v2 = a1[13];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    a1[13] = 0;
  }
  a1[289] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 292);
  sub_19052FDE4(a1 + 247);
  sub_19052FDE4(a1 + 206);
  a1[197] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 200);
  a1[188] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 191);
  a1[179] = &unk_1EDFC93B0;
  sub_1902D5B70(a1 + 182);
  sub_1902D5AB8(a1 + 131);
  sub_1902D5AB8(a1 + 102);
  sub_1905360CC((uint64_t)(a1 + 78));
  sub_1902D5AB8(a1 + 49);
  sub_190530CB0(a1 + 14);
  return a1;
}

BOOL sub_190533E34(float32x2_t *a1, uint64_t *a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  __int16 v51 = &unk_1EDFC7D60;
  uint64_t v52 = *a2;
  int v53 = *((_DWORD *)a2 + 2);
  __int32 v3 = a1[48].i32[0];
  if (v3)
  {
    a1[48].i32[0] = v3 - 1;
    if (v3 == 1) {
      a1[47].i32[0] = 0;
    }
    return v3 == 0;
  }
  sub_1902D9094((uint64_t)&a1[51], (float *)&v52);
  sub_1902D9094((uint64_t)&a1[60], (float *)&v52 + 1);
  sub_1902D9094((uint64_t)&a1[69], (float *)&v53);
  unint64_t v4 = (unint64_t)a1[59];
  float v5 = 0.0;
  float v6 = 0.0;
  if (v4) {
    float v6 = a1[53].f32[0] / (float)v4;
  }
  unint64_t v7 = (unint64_t)a1[68];
  if (v7) {
    float v5 = a1[62].f32[0] / (float)v7;
  }
  unint64_t v8 = (unint64_t)a1[77];
  if (v8) {
    float v9 = a1[71].f32[0] / (float)v8;
  }
  else {
    float v9 = 0.0;
  }
  a1[161].f32[0] = v6;
  a1[161].f32[1] = v5;
  a1[162].f32[0] = v9;
  a1[164].f32[0] = v6;
  a1[164].f32[1] = v5;
  a1[165].f32[0] = v9;
  a1[167].f32[0] = v6;
  a1[167].f32[1] = v5;
  a1[168].f32[0] = v9;
  if (a1[1].i8[5])
  {
    *(_DWORD *)long long buf = sqrtf((float)((float)(a1[7].f32[1] * a1[7].f32[1]) + (float)(a1[7].f32[0] * a1[7].f32[0]))+ (float)(a1[8].f32[0] * a1[8].f32[0]));
    sub_1902D9094((uint64_t)&a1[197], (float *)buf);
    v10.n128_f32[0] = sub_1902D9094((uint64_t)&a1[289], (float *)buf);
  }
  else
  {
    *(_DWORD *)long long buf = sqrtf((float)((float)(a1[10].f32[1] * a1[10].f32[1]) + (float)(a1[10].f32[0] * a1[10].f32[0]))+ (float)(a1[11].f32[0] * a1[11].f32[0]));
    sub_1902D9094((uint64_t)&a1[179], (float *)buf);
    unint64_t v11 = (unint64_t)a1[187];
    if (v11) {
      float v12 = a1[181].f32[0] / (float)v11;
    }
    else {
      float v12 = 0.0;
    }
    float v54 = (float)(*(float *)buf - v12) * (float)(*(float *)buf - v12);
    v10.n128_f32[0] = sub_1902D9094((uint64_t)&a1[188], &v54);
  }
  if (a1[1].i8[6])
  {
    float32x2_t v13 = a1[169];
    a1[161] = vsub_f32(a1[161], v13);
    float v14 = a1[170].f32[0];
    a1[162].f32[0] = a1[162].f32[0] - v14;
    a1[164] = vsub_f32(a1[164], v13);
    a1[165].f32[0] = a1[165].f32[0] - v14;
    return v3 == 0;
  }
  uint64_t v16 = a1 + 13;
  float32x2_t v15 = a1[13];
  *(void *)long long buf = 0xBFF0000000000000;
  (*(void (**)(float32x2_t, void **, float32x2_t *, unsigned char *, __n128))(**(void **)&v15 + 32))(v15, &v51, a1 + 2, buf, v10);
  ++a1[47].i32[0];
  (*(void (**)(float32x2_t, float32x2_t *, uint64_t))(**(void **)v16 + 48))(*v16, a1 + 169, (uint64_t)&a1[170] + 4);
  (*(void (**)(float32x2_t, float32x2_t *, float32x2_t *, float32x2_t *))(**(void **)v16 + 56))(*v16, a1 + 160, a1 + 163, a1 + 2);
  (*(void (**)(float32x2_t, float32x2_t *, float32x2_t *))(**(void **)v16 + 64))(*v16, a1 + 166, a1 + 2);
  if (!(*(unsigned int (**)(void))(**(void **)&a1[13] + 72))()) {
    goto LABEL_49;
  }
  if (a1[1].i8[5] && a1[170].i32[1] < 4)
  {
    float v17 = sqrtf((float)((float)(a1[161].f32[1] * a1[161].f32[1]) + (float)(a1[161].f32[0] * a1[161].f32[0]))+ (float)(a1[162].f32[0] * a1[162].f32[0]));
    if (v17 > 500.0)
    {
LABEL_40:
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD20C0);
      }
      float v26 = qword_1E929D790;
      if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_INFO))
      {
        double v27 = sqrtf((float)((float)(a1[161].f32[1] * a1[161].f32[1]) + (float)(a1[161].f32[0] * a1[161].f32[0]))+ (float)(a1[162].f32[0] * a1[162].f32[0]));
        *(_DWORD *)long long buf = 134217984;
        *(double *)&uint8_t buf[4] = v27;
        _os_log_impl(&dword_1902AF000, v26, OS_LOG_TYPE_INFO, "magnitude max threshold exceeded (%+.3f), resetting calibration", buf, 0xCu);
      }
      if (sub_1902D8400(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D798 != -1) {
          dispatch_once(&qword_1E929D798, &unk_1EDFD20C0);
        }
        double v37 = sqrtf((float)((float)(a1[161].f32[1] * a1[161].f32[1]) + (float)(a1[161].f32[0] * a1[161].f32[0]))+ (float)(a1[162].f32[0] * a1[162].f32[0]));
        float v54 = 3.852e-34;
        double v55 = v37;
        float v38 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 2, "void CLCompassCalculator::updateInterferenceChecks()", "CoreLocation: %s\n", v38);
        if (v38 != buf) {
          free(v38);
        }
      }
      (*(void (**)(void))(**(void **)&a1[13] + 24))(*(void *)&a1[13]);
      a1[48].i32[0] = a1[47].i32[1];
      int v25 = -1065353216;
LABEL_46:
      a1[14].i32[0] = v25;
      goto LABEL_49;
    }
LABEL_47:
    *(float *)long long buf = v17;
    sub_190530188((uint64_t)&a1[206], (float *)buf);
    if (sub_190535734((uint64_t)a1))
    {
      float v28 = sub_190529058((float *)&a1[160], (float *)&a1[9]) * -57.2957795 + 90.0;
      *(float *)long long buf = v28;
      sub_190530188((uint64_t)&a1[247], (float *)buf);
    }
    goto LABEL_49;
  }
  float v17 = sqrtf((float)((float)(a1[161].f32[1] * a1[161].f32[1]) + (float)(a1[161].f32[0] * a1[161].f32[0]))+ (float)(a1[162].f32[0] * a1[162].f32[0]));
  if (v17 >= 250.0 || v17 > 500.0) {
    goto LABEL_40;
  }
  if (a1[1].i8[5]) {
    goto LABEL_47;
  }
  *(float *)long long buf = v17;
  if (sub_190530188((uint64_t)&a1[206], (float *)buf))
  {
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD20C0);
    }
    float v19 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_INFO))
    {
      unint64_t v20 = (unint64_t)a1[225];
      double v21 = 0.0;
      double v22 = 0.0;
      if (v20) {
        double v22 = (float)(a1[219].f32[0] / (float)v20);
      }
      double v23 = a1[207].f32[1];
      unint64_t v24 = (unint64_t)a1[246];
      if (v24) {
        double v21 = (float)(a1[240].f32[0] / (float)v24);
      }
      *(_DWORD *)long long buf = 134218496;
      *(double *)&uint8_t buf[4] = v23;
      __int16 v61 = 2048;
      double v62 = v22;
      __int16 v63 = 2048;
      double v64 = v21;
      _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_INFO, "magnitude threshold exceeded (%f) with (%f) from base value (%f), resetting calibration", buf, 0x20u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD20C0);
      }
      double v39 = 0.0;
      double v40 = 0.0;
      unint64_t v41 = (unint64_t)a1[225];
      if (v41) {
        double v40 = (float)(a1[219].f32[0] / (float)v41);
      }
      double v42 = a1[207].f32[1];
      unint64_t v43 = (unint64_t)a1[246];
      if (v43) {
        double v39 = (float)(a1[240].f32[0] / (float)v43);
      }
      float v54 = 3.8522e-34;
      double v55 = v42;
      __int16 v56 = 2048;
      double v57 = v40;
      __int16 v58 = 2048;
      double v59 = v39;
      int v44 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLCompassCalculator::updateInterferenceChecks()", "CoreLocation: %s\n", v44);
      if (v44 != buf) {
        free(v44);
      }
    }
    (*(void (**)(void))(**(void **)&a1[13] + 24))(*(void *)&a1[13]);
    a1[48].i32[0] = a1[47].i32[1];
    int v25 = -1073741824;
    goto LABEL_46;
  }
  if (sub_190535734((uint64_t)a1))
  {
    float v30 = sub_190529058((float *)&a1[160], (float *)&a1[9]) * -57.2957795 + 90.0;
    *(float *)long long buf = v30;
    if (sub_190530188((uint64_t)&a1[247], (float *)buf))
    {
      if ((*(unsigned int (**)(void))(**(void **)&a1[13] + 80))(*(void *)&a1[13]))
      {
        if (qword_1E929D798 != -1) {
          dispatch_once(&qword_1E929D798, &unk_1EDFD20C0);
        }
        float v31 = qword_1E929D790;
        if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_INFO))
        {
          unint64_t v32 = (unint64_t)a1[266];
          double v33 = 0.0;
          double v34 = 0.0;
          if (v32) {
            double v34 = (float)(a1[260].f32[0] / (float)v32);
          }
          double v35 = a1[248].f32[1];
          unint64_t v36 = (unint64_t)a1[287];
          if (v36) {
            double v33 = (float)(a1[281].f32[0] / (float)v36);
          }
          *(_DWORD *)long long buf = 134218496;
          *(double *)&uint8_t buf[4] = v35;
          __int16 v61 = 2048;
          double v62 = v34;
          __int16 v63 = 2048;
          double v64 = v33;
          _os_log_impl(&dword_1902AF000, v31, OS_LOG_TYPE_INFO, "inclination threshold exceeded (%f) with (%f) from base value (%f), resetting calibration", buf, 0x20u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D798 != -1) {
            dispatch_once(&qword_1E929D798, &unk_1EDFD20C0);
          }
          double v45 = 0.0;
          double v46 = 0.0;
          unint64_t v47 = (unint64_t)a1[266];
          if (v47) {
            double v46 = (float)(a1[260].f32[0] / (float)v47);
          }
          double v48 = a1[248].f32[1];
          unint64_t v49 = (unint64_t)a1[287];
          if (v49) {
            double v45 = (float)(a1[281].f32[0] / (float)v49);
          }
          float v54 = 3.8522e-34;
          double v55 = v48;
          __int16 v56 = 2048;
          double v57 = v46;
          __int16 v58 = 2048;
          double v59 = v45;
          double v50 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CLCompassCalculator::updateInterferenceChecks()", "CoreLocation: %s\n", v50);
          if (v50 != buf) {
            free(v50);
          }
        }
        (*(void (**)(void))(**(void **)&a1[13] + 24))(*(void *)&a1[13]);
        a1[48].i32[0] = a1[47].i32[1];
        int v25 = -1069547520;
        goto LABEL_46;
      }
    }
  }
LABEL_49:
  if ((*(unsigned int (**)(void))(**(void **)&a1[13] + 88))(*(void *)&a1[13]))
  {
    sub_1905305B0((uint64_t)&a1[206], 0);
    sub_1905305B0((uint64_t)&a1[247], 0);
  }
  return v3 == 0;
}

float sub_190534938(uint64_t a1, double *a2)
{
  __int32 v3 = (_OWORD *)(a1 + 1368);
  if (a2[7] == -1.0)
  {
    *(void *)(a1 + 1416) = 0;
    *(_OWORD *)(a1 + 1384) = 0u;
    *(_OWORD *)(a1 + 1400) = 0u;
    _OWORD *v3 = 0u;
    *(void *)(a1 + 1424) = 0xBFF0000000000000;
    *(unsigned char *)(a1 + 116) = 0;
    sub_1902B5164((void *)(a1 + 136));
    return sub_1905310C4(a1 + 208);
  }
  else
  {
    long long v4 = *(_OWORD *)a2;
    long long v5 = *((_OWORD *)a2 + 1);
    long long v6 = *((_OWORD *)a2 + 3);
    *(_OWORD *)(a1 + 1400) = *((_OWORD *)a2 + 2);
    *(_OWORD *)(a1 + 1416) = v6;
    _OWORD *v3 = v4;
    *(_OWORD *)(a1 + 1384) = v5;
    uint64_t v7 = a1 + 112;
    *(unsigned char *)(a1 + 116) = 1;
    float v8 = a2[6];
    sub_190530D4C(v7, 10, 30, v8, 2.0);
  }
  return result;
}

BOOL sub_1905349F0(float *a1, float *a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16)
{
  v27[1] = *MEMORY[0x1E4F143B8];
  float v17 = a1[2];
  float v18 = a1[3];
  float v19 = a1[4];
  float v20 = a2[2];
  float v21 = a2[3];
  float v22 = a2[4];
  v27[0] = 0x3F8000003F800000;
  v25.i64[0] = 0;
  v25.i64[1] = 0x3F80000000000000;
  BOOL v23 = sub_1904CF974((float *)v27, &v25, (uint64_t)v26, v17, v18, v19, v20, v21, v22, a15, a16, a4, a5, a6, a7, a8, 0x3F800000uLL, 0.0);
  if (v23) {
    *a3 = sub_1904D0AD0(v25.f32);
  }
  return v23;
}

BOOL sub_190534A98(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v152 = *MEMORY[0x1E4F143B8];
  float v103 = 0.0;
  long long v100 = &unk_1EDFC7D60;
  double v18 = *(double *)(a1 + 1312);
  double v101 = v18;
  LODWORD(v18) = *(_DWORD *)(a1 + 1320);
  int v102 = LODWORD(v18);
  if (*(unsigned char *)(a1 + 13)) {
    BOOL v19 = a1 + 1328 == (void)&v100;
  }
  else {
    BOOL v19 = 1;
  }
  if (!v19)
  {
    double v18 = *(double *)(a1 + 1336);
    double v101 = v18;
    LODWORD(v18) = *(_DWORD *)(a1 + 1344);
    int v102 = LODWORD(v18);
  }
  BOOL v20 = sub_1905349F0((float *)&v100, (float *)(a1 + 72), &v103, a12, a13, a14, a15, a16, v18, a4, a5, a6, a7, a8, a9, a10);
  float v21 = v103;
  BOOL v22 = v103 < 360.0 && v20;
  BOOL v23 = v103 >= 0.0 && v22;
  if (v23)
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 1288);
    *(void *)&long long v24 = *(void *)(a1 + 1292);
    *((void *)&v24 + 1) = *(void *)(a1 + 1312);
    *(_OWORD *)(a2 + 4) = v24;
    LODWORD(v24) = *(_DWORD *)(a1 + 1320);
    *(float *)(a2 + 44) = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(*(float32x2_t *)(&v24 + 8), *(float32x2_t *)(&v24 + 8)).i32[1]), *((float *)&v24 + 2), *((float *)&v24 + 2))+ (float)(*(float *)&v24 * *(float *)&v24));
    *(_DWORD *)(a2 + 20) = v24;
    *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 1364);
    *(unsigned char *)(a2 + 40) = 0;
    float v25 = sub_190529058((float *)(a1 + 1304), (float *)(a1 + 72)) * -57.2957795 + 90.0;
    *(float *)(a2 + 48) = v25;
    float v26 = *(float *)(a2 + 44);
    float v27 = v25 * 0.0174532925;
    *(float *)(a2 + 52) = v26 * cosf(v27);
    *(void *)(a2 + 56) = *(void *)(a1 + 40);
    *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 16);
    double v40 = *(double *)(a1 + 32);
    *(double *)(a2 + 80) = v40;
    if (*(unsigned char *)(a1 + 13))
    {
      float v99 = v21;
      sub_1905349F0((float *)(a1 + 1280), (float *)(a1 + 72), &v99, v28, v29, v30, v31, v32, v40, v33, v34, v35, v36, v37, v38, v39);
      float v41 = v99;
      if (*(unsigned char *)(a1 + 2304))
      {
        float v42 = *(float *)(a1 + 2384);
      }
      else
      {
        *(unsigned char *)(a1 + 2304) = 1;
        float v42 = v41;
      }
      float v46 = v42 - v21;
      float v47 = v21;
      if (vabds_f32(v42, v21) > 270.0) {
        float v47 = dbl_19060BA10[v46 > 0.0] + v21;
      }
      float v48 = v41;
      if (vabds_f32(v42, v41) > 270.0) {
        float v48 = dbl_19060BA10[(float)(v42 - v41) > 0.0] + v41;
      }
      unint64_t v49 = *(void *)(a1 + 2376);
      float v50 = 0.0;
      float v51 = 0.0;
      if (v49 >= 2)
      {
        float v52 = (float)((float)v49 * *(float *)(a1 + 2332)) - (float)(*(float *)(a1 + 2328) * *(float *)(a1 + 2328));
        float v51 = v52 / (float)((v49 - 1) * v49);
        if (v52 < 0.0) {
          float v51 = 0.0;
        }
      }
      unint64_t v53 = *(void *)(a1 + 1640);
      if (v53) {
        float v50 = *(float *)(a1 + 1592) / (float)v53;
      }
      float v97 = v42 - v41;
      float v54 = (float)(v50 + -0.06) * 0.55 / 2.94000006 + 0.1;
      float v55 = fmaxf(fminf(v54, 0.65), 0.1);
      float v96 = v51;
      float v98 = v48;
      double v95 = v50;
      if (v51 >= 0.0015 || v50 >= 6.28318531)
      {
        float v56 = *(float *)(a1 + 2388) * 0.15 + 0.734964973;
        *(float *)(a1 + 2388) = v56;
      }
      else
      {
        float v94 = v47;
        float v56 = 1.0 - expf(v50 * -0.2);
        *(float *)(a1 + 2388) = v56;
        if (v50 <= 1.0)
        {
          float v46 = v42 - v21;
          float v48 = v98;
          float v47 = v94;
          if (v50 < 0.06)
          {
            *(_DWORD *)(a1 + 2388) = 1011052224;
            float v56 = 0.011928;
          }
        }
        else
        {
          float v56 = 1.0 - expf(v50 * (float)(v50 * -0.2));
          *(float *)(a1 + 2388) = v56;
          float v46 = v42 - v21;
          float v48 = v98;
          float v47 = v94;
        }
      }
      double v57 = v47;
      float v58 = (float)(v48 * v55) + (1.0 - v55) * v47;
      float v59 = (float)(v56 * v58) + (float)((float)(1.0 - v56) * v42);
      if (v59 >= 0.0)
      {
        for (; v59 >= 360.0; float v59 = v59 + -360.0)
          ;
      }
      else
      {
        for (; v59 < -360.0; float v59 = v59 + 360.0)
          ;
        float v59 = v59 + 360.0;
      }
      *(float *)(a1 + 2384) = v59;
      if (*(unsigned char *)(a1 + 12))
      {
        if (qword_1E929D798 != -1) {
          dispatch_once(&qword_1E929D798, &unk_1EDFD20C0);
        }
        float v60 = v59 - v42;
        __int16 v61 = qword_1E929D790;
        if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
        {
          float v62 = *(float *)(a1 + 2388);
          double v63 = *(float *)(a1 + 2384);
          *(_DWORD *)long long buf = 134220800;
          double v129 = v21;
          __int16 v130 = 2048;
          double v131 = v41;
          __int16 v132 = 2048;
          double v133 = v46;
          __int16 v134 = 2048;
          double v135 = v97;
          __int16 v136 = 2048;
          double v137 = v57;
          __int16 v138 = 2048;
          double v139 = v98;
          __int16 v140 = 2048;
          double v141 = v63;
          __int16 v142 = 2048;
          double v143 = v62;
          __int16 v144 = 2048;
          double v145 = v55;
          __int16 v146 = 2048;
          double v147 = v96;
          __int16 v148 = 2048;
          double v149 = v95;
          __int16 v150 = 2048;
          double v151 = v60;
          _os_log_impl(&dword_1902AF000, v61, OS_LOG_TYPE_DEBUG, "rawHeading, %.3f, gyroHeading, %.3f, deltaRaw, %.3f, deltaGyro, %.3f, rawHeadingU, %.3f, gyroHeadingU, %.3f, filteredHeading, %.3f, alpha, %.3f, gamma, %.3f, rotVar, %.5f, rotMag, %.3f, deltaFiltered, %.3f", buf, 0x7Au);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D798 != -1) {
            dispatch_once(&qword_1E929D798, &unk_1EDFD20C0);
          }
          double v89 = *(float *)(a1 + 2384);
          double v90 = *(float *)(a1 + 2388);
          float sinval = 3.8533e-34;
          double v105 = v21;
          __int16 v106 = 2048;
          double v107 = v41;
          __int16 v108 = 2048;
          double v109 = v46;
          __int16 v110 = 2048;
          double v111 = v97;
          __int16 v112 = 2048;
          double v113 = v57;
          __int16 v114 = 2048;
          double v115 = v98;
          __int16 v116 = 2048;
          double v117 = v89;
          __int16 v118 = 2048;
          double v119 = v90;
          __int16 v120 = 2048;
          double v121 = v55;
          __int16 v122 = 2048;
          double v123 = v96;
          __int16 v124 = 2048;
          double v125 = v95;
          __int16 v126 = 2048;
          double v127 = v60;
          long long v91 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "BOOL CLCompassCalculator::getCompassData(CLMotionTypeCompass &)", "CoreLocation: %s\n", v91);
          if (v91 != (char *)buf) {
            free(v91);
          }
        }
      }
      float v45 = *(float *)(a1 + 2384);
LABEL_76:
      if ((v45 >= 360.0 || v45 < 0.0) && *(unsigned char *)(a1 + 12))
      {
        if (qword_1E929D798 != -1) {
          dispatch_once(&qword_1E929D798, &unk_1EDFD20C0);
        }
        int v76 = qword_1E929D790;
        if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_INFO))
        {
          double v77 = *(float *)(a1 + 2384);
          *(_DWORD *)long long buf = 134217984;
          double v129 = v77;
          _os_log_impl(&dword_1902AF000, v76, OS_LOG_TYPE_INFO, "#Warning Heading  %.2f, is not in bound [0 360]", buf, 0xCu);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D798 != -1) {
            dispatch_once(&qword_1E929D798, &unk_1EDFD20C0);
          }
          double v92 = *(float *)(a1 + 2384);
          float sinval = 3.852e-34;
          double v105 = v92;
          long long v93 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "BOOL CLCompassCalculator::getCompassData(CLMotionTypeCompass &)", "CoreLocation: %s\n", v93);
          if (v93 != (char *)buf) {
            free(v93);
          }
        }
      }
      if (sub_190535734(a1)
        && (((*(uint64_t (**)(void))(**(void **)(a1 + 104) + 72))(*(void *)(a1 + 104)) & 1) != 0
         || *(unsigned char *)(a1 + 15)))
      {
        float v78 = sub_190529058((float *)(a1 + 1280), (float *)(a1 + 72)) * -57.2957795 + 90.0;
        float v79 = sqrtf((float)((float)(*(float *)(a1 + 1292) * *(float *)(a1 + 1292))+ (float)(*(float *)(a1 + 1288) * *(float *)(a1 + 1288)))+ (float)(*(float *)(a1 + 1296) * *(float *)(a1 + 1296)));
        float v80 = v78 * 3.14159265 / 180.0;
        float v81 = cosf(v80);
        sub_190530F80(a1 + 112, v78, v79 * v81);
      }
      float v82 = *(float *)(a1 + 2384);
      *(float *)(a2 + 24) = v82;
      if (*(double *)(a1 + 1424) == -1.0)
      {
        float v85 = -1.0;
LABEL_96:
        *(float *)(a2 + 28) = v85;
        int v86 = *(_DWORD *)(a1 + 1364);
        if (v86 || !*(unsigned char *)(a1 + 15))
        {
          float v87 = 20.0;
          if (*(unsigned char *)(a1 + 14))
          {
LABEL_102:
            *(float *)(a2 + 32) = v87;
            if (*(unsigned char *)(a1 + 13) && *(unsigned char *)(*(void *)(a1 + 104) + 184)) {
              *(float *)(a2 + 32) = v87 + 1.0;
            }
            return v23;
          }
        }
        else
        {
          int v86 = 1;
        }
        float v87 = sub_190531148(a1 + 112, v86);
        goto LABEL_102;
      }
      double v83 = *(double *)(a1 + 1408) + v82;
      double v84 = 360.0;
      if (v83 >= 360.0)
      {
        double v84 = -360.0;
      }
      else if (v83 >= 0.0)
      {
        goto LABEL_95;
      }
      double v83 = v83 + v84;
LABEL_95:
      float v85 = v83;
      goto LABEL_96;
    }
    float v43 = v21 * 0.0174532925;
    __float2 v44 = __sincosf_stret(v43);
    *(float *)long long buf = v44.__cosval;
    float sinval = v44.__sinval;
    sub_19053598C(a1 + 640, (float *)buf);
    sub_19053598C(a1 + 728, &sinval);
    sub_190536158(a1 + 640, (float *)buf);
    sub_190536158(a1 + 728, &sinval);
    float v45 = atan2f(sinval, *(float *)buf) * 57.2957795;
    if (v45 >= 0.0)
    {
      for (; v45 >= 360.0; float v45 = v45 + -360.0)
        ;
    }
    else
    {
      for (; v45 < -360.0; float v45 = v45 + 360.0)
        ;
      float v45 = v45 + 360.0;
    }
    *(float *)(a1 + 632) = v45;
    float v64 = *(float *)(a1 + 636);
    if (v64 == -1.0)
    {
LABEL_75:
      *(float *)(a1 + 636) = v45;
      *(float *)(a1 + 2384) = v45;
      goto LABEL_76;
    }
    double v65 = v64;
    double v66 = v45;
    double v67 = vabdd_f64(v45, v64);
    if (v67 > 180.0)
    {
      if (v45 >= 180.0) {
        double v66 = 360.0 - v66;
      }
      double v68 = 360.0 - v65;
      if (v64 < 180.0) {
        double v68 = v64;
      }
      double v67 = v66 + v68;
    }
    float v69 = v67;
    double v70 = v69;
    float v71 = (cos(v69 * 0.0174532925) + 1.0) * *(float *)(a1 + 628);
    float v72 = (1.2 - v71) * 0.75 * v70;
    float v73 = v45 - v64;
    if ((float)(v45 - v64) >= 0.0)
    {
      for (; v73 >= 360.0; float v73 = v73 + -360.0)
        ;
    }
    else
    {
      for (; v73 < -360.0; float v73 = v73 + 360.0)
        ;
      float v73 = v73 + 360.0;
    }
    if (v73 >= 180.0) {
      float v73 = v73 + -360.0;
    }
    if (v73 < 0.0) {
      float v72 = -v72;
    }
    double v74 = v65 + (float)(v72 + 0.0);
    double v75 = 360.0;
    if (v74 >= 360.0)
    {
      double v75 = -360.0;
    }
    else if (v74 >= 0.0)
    {
      goto LABEL_74;
    }
    double v74 = v74 + v75;
LABEL_74:
    float v45 = v74;
    *(float *)(a1 + 632) = v45;
    goto LABEL_75;
  }
  return v23;
}

BOOL sub_190535734(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 13);
  if (*(unsigned char *)(a1 + 13))
  {
    if (sqrtf((float)((float)(*(float *)(a1 + 60) * *(float *)(a1 + 60))+ (float)(*(float *)(a1 + 56) * *(float *)(a1 + 56)))+ (float)(*(float *)(a1 + 64) * *(float *)(a1 + 64))) > 4.71238911)return 0; {
    unint64_t v2 = *(void *)(a1 + 1640);
    }
    if (v2)
    {
      float v3 = *(float *)(a1 + 1592);
      if ((float)(v3 / (float)v2) > 3.1416) {
        return 0;
      }
      if (v2 >= 2)
      {
        float v6 = (float)((float)v2 * *(float *)(a1 + 1596)) - (float)(v3 * v3);
        if (v6 >= 0.0) {
          return (float)(v6 / (float)((v2 - 1) * v2)) <= 0.64;
        }
      }
    }
    return 1;
  }
  float v4 = sqrtf((float)((float)(*(float *)(a1 + 84) * *(float *)(a1 + 84)) + (float)(*(float *)(a1 + 80) * *(float *)(a1 + 80)))+ (float)(*(float *)(a1 + 88) * *(float *)(a1 + 88)));
  if (v4 < 1.2 && v4 > 0.8)
  {
    unint64_t v5 = *(void *)(a1 + 1568);
    if (v5) {
      return (float)(*(float *)(a1 + 1520) / (float)v5) < 0.09;
    }
    return 1;
  }
  return v1;
}

uint64_t sub_190535840(uint64_t a1)
{
  *(void *)a1 = &unk_1EDFC8268;
  sub_1904B9BBC(a1 + 64, *(void **)(a1 + 72));
  sub_190535FD4(a1 + 16);
  return a1;
}

void sub_190535890(uint64_t a1)
{
  *(void *)a1 = &unk_1EDFC8268;
  sub_1904B9BBC(a1 + 64, *(void **)(a1 + 72));
  sub_190535FD4(a1 + 16);

  JUMPOUT(0x192FCC980);
}

void sub_190535900(void *a1)
{
  unint64_t v2 = (void **)a1[3];
  uint64_t v3 = a1[4];
  a1[7] = 0;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = a1[4];
      unint64_t v2 = (void **)(a1[3] + 8);
      a1[3] = v2;
      unint64_t v4 = v5 - (void)v2;
    }
    while (v4 > 0x10);
  }
  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 256;
    goto LABEL_7;
  }
  if (v4 >> 3 == 2)
  {
    uint64_t v6 = 512;
LABEL_7:
    a1[6] = v6;
  }
  float v8 = (void *)a1[9];
  uint64_t v7 = a1 + 9;
  sub_1904B9BBC((uint64_t)(v7 - 1), v8);
  *(v7 - 1) = v7;
  *uint64_t v7 = 0;
  v7[1] = 0;
}

void sub_19053598C(uint64_t a1, float *a2)
{
  float v3 = *a2;
  unint64_t v4 = (float *)operator new(0x20uLL);
  uint64_t v5 = v4;
  v4[7] = v3;
  uint64_t v6 = (uint64_t **)(a1 + 72);
  uint64_t v7 = *(uint64_t ***)(a1 + 72);
  if (v7)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = v7;
        if (*((float *)v7 + 7) <= v3) {
          break;
        }
        uint64_t v7 = (uint64_t **)*v7;
        float v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      uint64_t v7 = (uint64_t **)v7[1];
    }
    while (v7);
    float v8 = v6 + 1;
  }
  else
  {
    float v8 = (uint64_t **)(a1 + 72);
  }
LABEL_8:
  *(void *)unint64_t v4 = 0;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = v6;
  *float v8 = (uint64_t *)v4;
  uint64_t v9 = **(void **)(a1 + 64);
  __n128 v10 = (uint64_t *)v4;
  if (v9)
  {
    *(void *)(a1 + 64) = v9;
    __n128 v10 = *v8;
  }
  sub_1902DD3B4(*(uint64_t **)(a1 + 72), v10);
  unint64_t v11 = *(char **)(a1 + 32);
  float v12 = *(char **)(a1 + 24);
  uint64_t v13 = v11 - v12;
  ++*(void *)(a1 + 80);
  if (v11 == v12) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = ((v11 - v12) << 6) - 1;
  }
  unint64_t v15 = *(void *)(a1 + 48);
  uint64_t v16 = *(void *)(a1 + 56);
  unint64_t v17 = v16 + v15;
  if (v14 == v16 + v15)
  {
    BOOL v18 = v15 >= 0x200;
    unint64_t v19 = v15 - 512;
    if (v18)
    {
      *(void *)(a1 + 48) = v19;
      uint64_t v22 = *(void *)v12;
      BOOL v20 = v12 + 8;
      uint64_t v21 = v22;
      *(void *)(a1 + 24) = v20;
      if (v11 == *(char **)(a1 + 40))
      {
        unint64_t v23 = *(void *)(a1 + 16);
        uint64_t v24 = (uint64_t)&v20[-v23];
        if ((unint64_t)v20 <= v23)
        {
          uint64_t v50 = (uint64_t)&v11[-v23];
          BOOL v49 = v50 == 0;
          uint64_t v51 = v50 >> 2;
          if (v49) {
            unint64_t v52 = 1;
          }
          else {
            unint64_t v52 = v51;
          }
          unint64_t v53 = (char *)sub_1902C0520(v52);
          float v55 = &v53[8 * (v52 >> 2)];
          float v56 = *(uint64_t **)(a1 + 24);
          unint64_t v11 = v55;
          uint64_t v57 = *(void *)(a1 + 32) - (void)v56;
          if (v57)
          {
            unint64_t v11 = &v55[v57 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v58 = 8 * (v57 >> 3);
            float v59 = &v53[8 * (v52 >> 2)];
            do
            {
              uint64_t v60 = *v56++;
              *(void *)float v59 = v60;
              v59 += 8;
              v58 -= 8;
            }
            while (v58);
          }
          __int16 v61 = *(void **)(a1 + 16);
          *(void *)(a1 + 16) = v53;
          *(void *)(a1 + 24) = v55;
          *(void *)(a1 + 32) = v11;
          *(void *)(a1 + 40) = &v53[8 * v54];
          if (v61)
          {
            operator delete(v61);
            unint64_t v11 = *(char **)(a1 + 32);
          }
        }
        else
        {
          uint64_t v25 = v24 >> 3;
          BOOL v26 = v24 >> 3 < -1;
          uint64_t v27 = (v24 >> 3) + 2;
          if (v26) {
            uint64_t v28 = v27;
          }
          else {
            uint64_t v28 = v25 + 1;
          }
          uint64_t v29 = -(v28 >> 1);
          uint64_t v30 = v28 >> 1;
          uint64_t v31 = &v20[-8 * v30];
          int64_t v32 = v11 - v20;
          if (v11 != v20)
          {
            memmove(&v20[-8 * v30], v20, v11 - v20);
            unint64_t v11 = *(char **)(a1 + 24);
          }
          double v33 = &v11[8 * v29];
          unint64_t v11 = &v31[v32];
          *(void *)(a1 + 24) = v33;
          *(void *)(a1 + 32) = &v31[v32];
        }
      }
      *(void *)unint64_t v11 = v21;
    }
    else
    {
      uint64_t v34 = v13 >> 3;
      double v35 = *(char **)(a1 + 40);
      double v36 = *(char **)(a1 + 16);
      if (v13 >> 3 >= (unint64_t)((v35 - v36) >> 3))
      {
        if (v35 == v36) {
          unint64_t v39 = 1;
        }
        else {
          unint64_t v39 = (v35 - v36) >> 2;
        }
        double v40 = (char *)sub_1902C0520(v39);
        uint64_t v42 = v41;
        float v43 = operator new(0x1000uLL);
        __float2 v44 = &v40[8 * v34];
        float v45 = &v40[8 * v42];
        if (v34 == v42)
        {
          uint64_t v46 = 8 * v34;
          if (v13 < 1)
          {
            float v94 = v43;
            uint64_t v95 = v46 >> 2;
            if (v11 == v12) {
              unint64_t v96 = 1;
            }
            else {
              unint64_t v96 = v95;
            }
            float v97 = (char *)sub_1902C0520(v96);
            __float2 v44 = &v97[8 * (v96 >> 2)];
            float v45 = &v97[8 * v98];
            if (v40) {
              operator delete(v40);
            }
            double v40 = v97;
            float v43 = v94;
          }
          else
          {
            uint64_t v47 = v46 >> 3;
            if (v47 >= -1) {
              unint64_t v48 = v47 + 1;
            }
            else {
              unint64_t v48 = v47 + 2;
            }
            v44 -= 8 * (v48 >> 1);
          }
        }
        *(void *)__float2 v44 = v43;
        float v99 = v44 + 8;
        for (uint64_t i = *(void *)(a1 + 32); i != *(void *)(a1 + 24); i -= 8)
        {
          if (v44 == v40)
          {
            if (v99 >= v45)
            {
              if (v45 == v40) {
                unint64_t v105 = 1;
              }
              else {
                unint64_t v105 = (v45 - v40) >> 2;
              }
              __int16 v106 = (char *)sub_1902C0520(v105);
              __int16 v108 = v106;
              __float2 v44 = &v106[(2 * v105 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v109 = v99 - v40;
              BOOL v49 = v99 == v40;
              float v99 = v44;
              if (!v49)
              {
                float v99 = &v44[v109 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v110 = 8 * (v109 >> 3);
                double v111 = v44;
                __int16 v112 = (uint64_t *)v40;
                do
                {
                  uint64_t v113 = *v112++;
                  *(void *)double v111 = v113;
                  v111 += 8;
                  v110 -= 8;
                }
                while (v110);
              }
              float v45 = &v106[8 * v107];
              if (v40) {
                operator delete(v40);
              }
              double v40 = v108;
            }
            else
            {
              uint64_t v101 = (v45 - v99) >> 3;
              if (v101 >= -1) {
                uint64_t v102 = v101 + 1;
              }
              else {
                uint64_t v102 = v101 + 2;
              }
              uint64_t v103 = v102 >> 1;
              __float2 v44 = &v40[8 * (v102 >> 1)];
              double v104 = v40;
              if (v99 != v40)
              {
                memmove(v44, v40, v99 - v40);
                double v104 = v99;
              }
              float v99 = &v104[8 * v103];
            }
          }
          uint64_t v114 = *(void *)(i - 8);
          *((void *)v44 - 1) = v114;
          v44 -= 8;
        }
        double v115 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v40;
        *(void *)(a1 + 24) = v44;
        *(void *)(a1 + 32) = v99;
        *(void *)(a1 + 40) = v45;
        if (v115) {
          operator delete(v115);
        }
        goto LABEL_46;
      }
      double v37 = operator new(0x1000uLL);
      double v38 = v37;
      if (v35 == v11)
      {
        if (v12 == v36)
        {
          if (v11 == v12) {
            unint64_t v71 = 1;
          }
          else {
            unint64_t v71 = (v35 - v12) >> 2;
          }
          uint64_t v72 = 2 * v71;
          float v73 = (char *)sub_1902C0520(v71);
          float v12 = &v73[(v72 + 6) & 0xFFFFFFFFFFFFFFF8];
          double v75 = *(uint64_t **)(a1 + 24);
          int v76 = v12;
          uint64_t v77 = *(void *)(a1 + 32) - (void)v75;
          if (v77)
          {
            int v76 = &v12[v77 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v78 = 8 * (v77 >> 3);
            float v79 = &v73[(v72 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v80 = *v75++;
              *(void *)float v79 = v80;
              v79 += 8;
              v78 -= 8;
            }
            while (v78);
          }
          float v81 = *(void **)(a1 + 16);
          *(void *)(a1 + 16) = v73;
          *(void *)(a1 + 24) = v12;
          *(void *)(a1 + 32) = v76;
          *(void *)(a1 + 40) = &v73[8 * v74];
          if (v81)
          {
            operator delete(v81);
            float v12 = *(char **)(a1 + 24);
          }
        }
        *((void *)v12 - 1) = v38;
        float v82 = *(char **)(a1 + 24);
        double v83 = *(char **)(a1 + 32);
        *(void *)(a1 + 24) = v82 - 8;
        uint64_t v84 = *((void *)v82 - 1);
        *(void *)(a1 + 24) = v82;
        if (v83 == *(char **)(a1 + 40))
        {
          unint64_t v85 = *(void *)(a1 + 16);
          uint64_t v86 = (uint64_t)&v82[-v85];
          if ((unint64_t)v82 <= v85)
          {
            uint64_t v116 = (uint64_t)&v83[-v85];
            BOOL v49 = v116 == 0;
            uint64_t v117 = v116 >> 2;
            if (v49) {
              unint64_t v118 = 1;
            }
            else {
              unint64_t v118 = v117;
            }
            double v119 = (char *)sub_1902C0520(v118);
            double v121 = &v119[8 * (v118 >> 2)];
            __int16 v122 = *(uint64_t **)(a1 + 24);
            double v83 = v121;
            uint64_t v123 = *(void *)(a1 + 32) - (void)v122;
            if (v123)
            {
              double v83 = &v121[v123 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v124 = 8 * (v123 >> 3);
              double v125 = &v119[8 * (v118 >> 2)];
              do
              {
                uint64_t v126 = *v122++;
                *(void *)double v125 = v126;
                v125 += 8;
                v124 -= 8;
              }
              while (v124);
            }
            double v127 = *(void **)(a1 + 16);
            *(void *)(a1 + 16) = v119;
            *(void *)(a1 + 24) = v121;
            *(void *)(a1 + 32) = v83;
            *(void *)(a1 + 40) = &v119[8 * v120];
            if (v127)
            {
              operator delete(v127);
              double v83 = *(char **)(a1 + 32);
            }
          }
          else
          {
            uint64_t v87 = v86 >> 3;
            BOOL v26 = v86 >> 3 < -1;
            uint64_t v88 = (v86 >> 3) + 2;
            if (v26) {
              uint64_t v89 = v88;
            }
            else {
              uint64_t v89 = v87 + 1;
            }
            uint64_t v90 = -(v89 >> 1);
            uint64_t v91 = v89 >> 1;
            double v92 = &v82[-8 * v91];
            int64_t v93 = v83 - v82;
            if (v83 != v82)
            {
              memmove(&v82[-8 * v91], v82, v83 - v82);
              float v82 = *(char **)(a1 + 24);
            }
            double v83 = &v92[v93];
            *(void *)(a1 + 24) = &v82[8 * v90];
            *(void *)(a1 + 32) = &v92[v93];
          }
        }
        *(void *)double v83 = v84;
      }
      else
      {
        *(void *)unint64_t v11 = v37;
      }
    }
    *(void *)(a1 + 32) += 8;
LABEL_46:
    float v12 = *(char **)(a1 + 24);
    unint64_t v15 = *(void *)(a1 + 48);
    uint64_t v16 = *(void *)(a1 + 56);
    unint64_t v17 = v15 + v16;
  }
  *(void *)(*(void *)&v12[(v17 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v17 & 0x1FF)) = v5;
  unint64_t v62 = v16 + 1;
  *(void *)(a1 + 56) = v62;
  if (v62 > *(unsigned int *)(a1 + 8))
  {
    uint64_t v63 = (v15 >> 6) & 0x3FFFFFFFFFFFFF8;
    unint64_t v64 = v15 & 0x1FF;
    double v65 = *(uint64_t **)(*(void *)(*(void *)(a1 + 24) + v63) + 8 * v64);
    double v66 = (void *)v65[1];
    if (v66)
    {
      do
      {
        double v67 = v66;
        double v66 = (void *)*v66;
      }
      while (v66);
    }
    else
    {
      double v68 = *(void **)(*(void *)(*(void *)(a1 + 24) + v63) + 8 * v64);
      do
      {
        double v67 = (void *)v68[2];
        BOOL v49 = *v67 == (void)v68;
        double v68 = v67;
      }
      while (!v49);
    }
    if (*(uint64_t **)(a1 + 64) == v65) {
      *(void *)(a1 + 64) = v67;
    }
    float v69 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    sub_1902CE250(v69, v65);
    operator delete(v65);
    int64x2_t v70 = vaddq_s64(*(int64x2_t *)(a1 + 48), (int64x2_t)xmmword_19060B3A0);
    *(int64x2_t *)(a1 + 48) = v70;
    if (v70.i64[0] >= 0x400uLL)
    {
      operator delete(**(void ***)(a1 + 24));
      *(void *)(a1 + 24) += 8;
      *(void *)(a1 + 48) -= 512;
    }
  }
}

void sub_190535FA8(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_190535FD4(uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  float v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      float v3 = *(void ***)(a1 + 16);
      unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 512;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

os_log_t sub_19053609C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Compass");
  qword_1E929D790 = (uint64_t)result;
  return result;
}

uint64_t sub_1905360CC(uint64_t a1)
{
  *(void *)(a1 + 104) = &unk_1EDFC8268;
  sub_1904B9BBC(a1 + 168, *(void **)(a1 + 176));
  sub_190535FD4(a1 + 120);
  *(void *)(a1 + 16) = &unk_1EDFC8268;
  sub_1904B9BBC(a1 + 80, *(void **)(a1 + 88));
  sub_190535FD4(a1 + 32);
  return a1;
}

float sub_190536158(uint64_t a1, float *a2)
{
  unint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    float v3 = (double)v2 * 0.5;
    int v4 = vcvtms_s32_f32(v3);
    unint64_t v5 = *(float **)(a1 + 64);
    if (v4 < 1)
    {
      uint64_t v8 = *(float **)(a1 + 64);
    }
    else
    {
      for (int i = 0; i != v4; ++i)
      {
        uint64_t v7 = (float *)*((void *)v5 + 1);
        if (v7)
        {
          do
          {
            uint64_t v8 = v7;
            uint64_t v7 = *(float **)v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v8 = (float *)*((void *)v5 + 2);
            BOOL v9 = *(void *)v8 == (void)v5;
            unint64_t v5 = v8;
          }
          while (!v9);
        }
        unint64_t v5 = v8;
      }
    }
    float result = v8[7];
    *a2 = result;
  }
  return result;
}

void sub_1905361D4(_DWORD *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (*a1)
  {
    if ((int)a1[78] >= 1)
    {
      if (qword_1E929D998 != -1) {
        dispatch_once(&qword_1E929D998, &unk_1EDFD20E0);
      }
      unint64_t v2 = qword_1E929D9A0;
      if (os_log_type_enabled((os_log_t)qword_1E929D9A0, OS_LOG_TYPE_ERROR))
      {
        int v3 = a1[78];
        *(_DWORD *)long long buf = 67240192;
        int v8 = v3;
        _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_ERROR, "[CMMotionContextSessionAnalyticsTracker] We've already sent analytics for this instance, was this intended? sent: %{public}d", buf, 8u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D998 != -1) {
          dispatch_once(&qword_1E929D998, &unk_1EDFD20E0);
        }
        unint64_t v5 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "void CMMotionContextSessionAnalyticsTracker::send()", "CoreLocation: %s\n", v5);
        if (v5 != (char *)buf) {
          free(v5);
        }
      }
    }
    AnalyticsSendEventLazy();
    ++a1[78];
  }
  else
  {
    if (qword_1E929D998 != -1) {
      dispatch_once(&qword_1E929D998, &unk_1EDFD20E0);
    }
    int v4 = qword_1E929D9A0;
    if (os_log_type_enabled((os_log_t)qword_1E929D9A0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_ERROR, "[CMMotionContextSessionAnalyticsTracker] Trying to send analytics but there are no recorded DistractedViewing events, not sending.", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D998 != -1) {
        dispatch_once(&qword_1E929D998, &unk_1EDFD20E0);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CMMotionContextSessionAnalyticsTracker::send()", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
}

void *sub_190536534(uint64_t a1, const char *a2, uint64_t a3)
{
  v175[6] = *MEMORY[0x1E4F143B8];
  int v3 = *(double **)(a1 + 32);
  int v4 = objc_msgSend_dictionary(MEMORY[0x1E4F1CA60], a2, a3);
  v174[0] = @"trackingClientMode";
  v175[0] = objc_msgSend_numberWithInt_(NSNumber, v5, *((unsigned int *)v3 + 79));
  v174[1] = @"distractedViewingCount";
  v175[1] = objc_msgSend_numberWithInt_(NSNumber, v6, *(unsigned int *)v3);
  v174[2] = @"pdrTnbTrackingDisabledViaWalkingCount";
  v175[2] = objc_msgSend_numberWithInt_(NSNumber, v7, *((unsigned int *)v3 + 1));
  v174[3] = @"pdrTnbTrackingDisabledViaSitToStandWithWalkingCount";
  v175[3] = objc_msgSend_numberWithInt_(NSNumber, v8, *((unsigned int *)v3 + 2));
  v174[4] = @"pdrTnbTrackingReEnabledViaTouchCount";
  v175[4] = objc_msgSend_numberWithInt_(NSNumber, v9, *((unsigned int *)v3 + 3));
  v174[5] = @"pdrTnbTrackingReEnabledViaPickUpCount";
  v175[5] = objc_msgSend_numberWithInt_(NSNumber, v10, *((unsigned int *)v3 + 4));
  uint64_t v12 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v11, (uint64_t)v175, v174, 6);
  objc_msgSend_setDictionary_(v4, v13, v12);
  double v16 = v3[3];
  if (v16 != 1.79769313e308)
  {
    *(float *)&double v16 = v16;
    uint64_t v17 = objc_msgSend_numberWithFloat_(NSNumber, v14, v15, v16);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v18, v17, @"minPdrTnbDisplacementMeters");
    int v21 = *((_DWORD *)v3 + 12);
    if (v21 < 1) {
      double v22 = 0.0;
    }
    else {
      double v22 = v3[5] / (double)v21;
    }
    *(float *)&double v22 = v22;
    uint64_t v23 = objc_msgSend_numberWithFloat_(NSNumber, v19, v20, v22);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v24, v23, @"avgPdrTnbDisplacementMeters");
    double v25 = v3[4];
    *(float *)&double v25 = v25;
    uint64_t v28 = objc_msgSend_numberWithFloat_(NSNumber, v26, v27, v25);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v29, v28, @"maxPdrTnbDisplacementMeters");
  }
  double v30 = v3[7];
  if (v30 != 1.79769313e308)
  {
    *(float *)&double v30 = v30;
    uint64_t v31 = objc_msgSend_numberWithFloat_(NSNumber, v14, v15, v30);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v32, v31, @"minPdrDistanceTravelledMeters");
    int v35 = *((_DWORD *)v3 + 20);
    if (v35 < 1) {
      double v36 = 0.0;
    }
    else {
      double v36 = v3[9] / (double)v35;
    }
    *(float *)&double v36 = v36;
    uint64_t v37 = objc_msgSend_numberWithFloat_(NSNumber, v33, v34, v36);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v38, v37, @"avgPdrDistanceTravelledMeters");
    double v39 = v3[8];
    *(float *)&double v39 = v39;
    uint64_t v42 = objc_msgSend_numberWithFloat_(NSNumber, v40, v41, v39);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v43, v42, @"maxPdrDistanceTravelledMeters");
  }
  double v44 = v3[11];
  if (v44 != 1.79769313e308)
  {
    *(float *)&double v44 = v44;
    uint64_t v45 = objc_msgSend_numberWithFloat_(NSNumber, v14, v15, v44);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v46, v45, @"minPdrTnbLoopClosure");
    int v49 = *((_DWORD *)v3 + 28);
    if (v49 < 1) {
      double v50 = 0.0;
    }
    else {
      double v50 = v3[13] / (double)v49;
    }
    *(float *)&double v50 = v50;
    uint64_t v51 = objc_msgSend_numberWithFloat_(NSNumber, v47, v48, v50);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v52, v51, @"avgPdrTnbLoopClosure");
    double v53 = v3[12];
    *(float *)&double v53 = v53;
    uint64_t v56 = objc_msgSend_numberWithFloat_(NSNumber, v54, v55, v53);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v57, v56, @"maxPdrTnbLoopClosure");
  }
  double v58 = v3[15];
  if (v58 != 1.79769313e308)
  {
    *(float *)&double v58 = v58;
    uint64_t v59 = objc_msgSend_numberWithFloat_(NSNumber, v14, v15, v58);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v60, v59, @"minPdrTnbHeadingDiffDegs");
    int v63 = *((_DWORD *)v3 + 36);
    if (v63 < 1) {
      double v64 = 0.0;
    }
    else {
      double v64 = v3[17] / (double)v63;
    }
    *(float *)&double v64 = v64;
    uint64_t v65 = objc_msgSend_numberWithFloat_(NSNumber, v61, v62, v64);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v66, v65, @"avgPdrTnbHeadingDiffDegs");
    double v67 = v3[16];
    *(float *)&double v67 = v67;
    uint64_t v70 = objc_msgSend_numberWithFloat_(NSNumber, v68, v69, v67);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v71, v70, @"maxPdrTnbHeadingDiffDegs");
  }
  double v72 = v3[19];
  if (v72 != 1.79769313e308)
  {
    *(float *)&double v72 = v72;
    uint64_t v73 = objc_msgSend_numberWithFloat_(NSNumber, v14, v15, v72);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v74, v73, @"minPdrTnbNumSteps");
    int v77 = *((_DWORD *)v3 + 44);
    if (v77 < 1) {
      double v78 = 0.0;
    }
    else {
      double v78 = v3[21] / (double)v77;
    }
    *(float *)&double v78 = v78;
    uint64_t v79 = objc_msgSend_numberWithFloat_(NSNumber, v75, v76, v78);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v80, v79, @"avgPdrTnbNumSteps");
    double v81 = v3[20];
    *(float *)&double v81 = v81;
    uint64_t v84 = objc_msgSend_numberWithFloat_(NSNumber, v82, v83, v81);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v85, v84, @"maxPdrTnbNumSteps");
  }
  double v86 = v3[23];
  if (v86 != 1.79769313e308)
  {
    *(float *)&double v86 = v86;
    uint64_t v87 = objc_msgSend_numberWithFloat_(NSNumber, v14, v15, v86);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v88, v87, @"minPdrTnbStepCadence");
    int v91 = *((_DWORD *)v3 + 52);
    if (v91 < 1)
    {
      uint64_t v93 = objc_msgSend_numberWithFloat_(NSNumber, v89, v90, 0.0);
    }
    else
    {
      double v92 = v3[25] / (double)v91;
      *(float *)&double v92 = v92;
      uint64_t v93 = objc_msgSend_numberWithFloat_(NSNumber, v89, v90, v92);
    }
    objc_msgSend_setObject_forKeyedSubscript_(v4, v94, v93, @"avgPdrTnbStepCadence");
    double v95 = v3[24];
    *(float *)&double v95 = v95;
    uint64_t v98 = objc_msgSend_numberWithFloat_(NSNumber, v96, v97, v95);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v99, v98, @"maxPdrTnbStepCadence");
  }
  double v100 = v3[27];
  if (v100 != 1.79769313e308)
  {
    *(float *)&double v100 = v100;
    uint64_t v101 = objc_msgSend_numberWithFloat_(NSNumber, v14, v15, v100);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v102, v101, @"minPdrTnbSpeedMetersPerSecond");
    int v105 = *((_DWORD *)v3 + 60);
    if (v105 < 1)
    {
      uint64_t v107 = objc_msgSend_numberWithFloat_(NSNumber, v103, v104, 0.0);
    }
    else
    {
      double v106 = v3[29] / (double)v105;
      *(float *)&double v106 = v106;
      uint64_t v107 = objc_msgSend_numberWithFloat_(NSNumber, v103, v104, v106);
    }
    objc_msgSend_setObject_forKeyedSubscript_(v4, v108, v107, @"avgPdrTnbSpeedMetersPerSecond");
    double v109 = v3[28];
    *(float *)&double v109 = v109;
    uint64_t v112 = objc_msgSend_numberWithFloat_(NSNumber, v110, v111, v109);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v113, v112, @"maxPdrTnbSpeedMetersPerSecond");
  }
  double v114 = v3[31];
  if (v114 != 1.79769313e308)
  {
    *(float *)&double v114 = v114;
    uint64_t v115 = objc_msgSend_numberWithFloat_(NSNumber, v14, v15, v114);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v116, v115, @"minDistractedViewingDurationSeconds");
    int v119 = *((_DWORD *)v3 + 68);
    if (v119 < 1)
    {
      uint64_t v121 = objc_msgSend_numberWithFloat_(NSNumber, v117, v118, 0.0);
    }
    else
    {
      double v120 = v3[33] / (double)v119;
      *(float *)&double v120 = v120;
      uint64_t v121 = objc_msgSend_numberWithFloat_(NSNumber, v117, v118, v120);
    }
    objc_msgSend_setObject_forKeyedSubscript_(v4, v122, v121, @"avgDistractedViewingDurationSeconds");
    double v123 = v3[32];
    *(float *)&double v123 = v123;
    uint64_t v126 = objc_msgSend_numberWithFloat_(NSNumber, v124, v125, v123);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v127, v126, @"maxDistractedViewingDurationSeconds");
  }
  double v128 = v3[35];
  if (v128 != 1.79769313e308)
  {
    *(float *)&double v128 = v128;
    uint64_t v129 = objc_msgSend_numberWithFloat_(NSNumber, v14, v15, v128);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v130, v129, @"minDistractedViewingAuxSampleIntervalSeconds");
    int v133 = *((_DWORD *)v3 + 76);
    if (v133 < 1)
    {
      uint64_t v135 = objc_msgSend_numberWithFloat_(NSNumber, v131, v132, 0.0);
    }
    else
    {
      double v134 = v3[37] / (double)v133;
      *(float *)&double v134 = v134;
      uint64_t v135 = objc_msgSend_numberWithFloat_(NSNumber, v131, v132, v134);
    }
    objc_msgSend_setObject_forKeyedSubscript_(v4, v136, v135, @"avgDistractedViewingAuxSampleIntervalSeconds");
    double v137 = v3[36];
    *(float *)&double v137 = v137;
    uint64_t v140 = objc_msgSend_numberWithFloat_(NSNumber, v138, v139, v137);
    objc_msgSend_setObject_forKeyedSubscript_(v4, v141, v140, @"maxDistractedViewingAuxSampleIntervalSeconds");
  }
  long long v163 = 0u;
  long long v164 = 0u;
  long long v161 = 0u;
  long long v162 = 0u;
  __int16 v142 = v4;
  double v143 = objc_msgSend_allKeys(v4, v14, v15);
  uint64_t v145 = objc_msgSend_countByEnumeratingWithState_objects_count_(v143, v144, (uint64_t)&v161, v173, 16);
  if (v145)
  {
    uint64_t v146 = v145;
    uint64_t v147 = *(void *)v162;
    do
    {
      uint64_t v148 = 0;
      do
      {
        if (*(void *)v162 != v147) {
          objc_enumerationMutation(v143);
        }
        uint64_t v149 = *(void *)(*((void *)&v161 + 1) + 8 * v148);
        if (qword_1E929D998 != -1) {
          dispatch_once(&qword_1E929D998, &unk_1EDFD20E0);
        }
        __int16 v150 = qword_1E929D9A0;
        if (os_log_type_enabled((os_log_t)qword_1E929D9A0, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v152 = objc_msgSend_objectForKey_(v142, v151, v149);
          *(_DWORD *)long long buf = 138478083;
          uint64_t v170 = v149;
          __int16 v171 = 2113;
          uint64_t v172 = v152;
          _os_log_impl(&dword_1902AF000, v150, OS_LOG_TYPE_DEFAULT, "[CMMotionContextSessionAnalyticsTracker] %{private}@ -> %{private}@", buf, 0x16u);
        }
        if (sub_1902D8400(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929D998 != -1) {
            dispatch_once(&qword_1E929D998, &unk_1EDFD20E0);
          }
          uint64_t v155 = objc_msgSend_objectForKey_(v142, v154, v149);
          int v165 = 138478083;
          uint64_t v166 = v149;
          __int16 v167 = 2113;
          uint64_t v168 = v155;
          __int16 v156 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 2, "void CMMotionContextSessionAnalyticsTracker::send()_block_invoke", "CoreLocation: %s\n", v156);
          if (v156 != (char *)buf) {
            free(v156);
          }
        }
        ++v148;
      }
      while (v146 != v148);
      uint64_t v157 = objc_msgSend_countByEnumeratingWithState_objects_count_(v143, v153, (uint64_t)&v161, v173, 16);
      uint64_t v146 = v157;
    }
    while (v157);
  }
  if (qword_1E929D998 != -1) {
    dispatch_once(&qword_1E929D998, &unk_1EDFD20E0);
  }
  __int16 v158 = qword_1E929D9A0;
  if (os_log_type_enabled((os_log_t)qword_1E929D9A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1902AF000, v158, OS_LOG_TYPE_DEFAULT, "[CMMotionContextSessionAnalyticsTracker] sent payload.", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D998 != -1) {
      dispatch_once(&qword_1E929D998, &unk_1EDFD20E0);
    }
    LOWORD(v165) = 0;
    __int16 v160 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMMotionContextSessionAnalyticsTracker::send()_block_invoke", "CoreLocation: %s\n", v160);
    if (v160 != (char *)buf) {
      free(v160);
    }
  }
  return v142;
}

os_log_t sub_190536F1C()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "MotionContext");
  qword_1E929D9A0 = (uint64_t)result;
  return result;
}

void sub_19053701C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v17, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_190537058(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*a2
    && (CFDictionaryRef Dictionary = (void *)CLConnectionMessage::getDictionary(*a2)) != 0
    && (int v4 = objc_msgSend_objectForKeyedSubscript_(Dictionary, v3, @"CMErrorMessage")) != 0)
  {
    int v7 = objc_msgSend_intValue(v4, v5, v6);
  }
  else
  {
    int v7 = 103;
  }
  if (qword_1E929DA58 != -1) {
    dispatch_once(&qword_1E929DA58, &unk_1EDFD43C0);
  }
  int v8 = qword_1E929DA60;
  if (os_log_type_enabled((os_log_t)qword_1E929DA60, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 67240192;
    int v11 = v7;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_FAULT, "Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929DA58 != -1) {
      dispatch_once(&qword_1E929DA58, &unk_1EDFD43C0);
    }
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "-[CMSensorMonitorSimulatorProxy initWithSensorMonitorTests]_block_invoke", "CoreLocation: %s\n", v9);
    if (v9 != (char *)buf) {
      free(v9);
    }
  }
}

void sub_1905373DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15) {
    sub_1902D8B58(a15);
  }
  if (a17) {
    sub_1902D8B58(a17);
  }
  _Unwind_Resume(exception_object);
}

CLConnectionMessage *sub_190537408(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  os_log_t result = *a2;
  if (*a2)
  {
    os_log_t result = (CLConnectionMessage *)CLConnectionMessage::getDictionary(result);
    if (result)
    {
      uint64_t v5 = objc_msgSend_objectForKeyedSubscript_(result, v4, @"CMErrorMessage");
      if (v5)
      {
        uint64_t v6 = (void *)v5;
        if (qword_1E929DA58 != -1) {
          dispatch_once(&qword_1E929DA58, &unk_1EDFD43C0);
        }
        int v7 = qword_1E929DA60;
        if (os_log_type_enabled((os_log_t)qword_1E929DA60, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          double v16 = v6;
          _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_ERROR, "Error in simulateMotionSensorData: %@", buf, 0xCu);
        }
        if (sub_1902D8400(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1E929DA58 != -1) {
            dispatch_once(&qword_1E929DA58, &unk_1EDFD43C0);
          }
          uint64_t v14 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "-[CMSensorMonitorSimulatorProxy _simulateMotionSensorDataForType:payload:withHandler:]_block_invoke", "CoreLocation: %s\n", v14);
          if (v14 != (char *)buf) {
            free(v14);
          }
        }
        __n128 v10 = (void *)MEMORY[0x1E4F28C58];
        int v11 = objc_msgSend_intValue(v6, v8, v9);
        objc_msgSend_errorWithDomain_code_userInfo_(v10, v12, @"CMErrorDomain", v11, 0);
        return (CLConnectionMessage *)(*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
      }
      else
      {
        uint64_t v13 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
        return (CLConnectionMessage *)v13();
      }
    }
  }
  return result;
}

uint64_t sub_190537858(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_sensorMonitorSimulatorProxy(*(void **)(a1 + 32), a2, a3);
  uint64_t v5 = *(void *)(a1 + 56);

  return MEMORY[0x1F4181798](v4, sel__simulateMotionSensorDataForType_payload_withHandler_, v5);
}

os_log_t sub_1905378A0()
{
  os_log_t result = os_log_create("com.apple.locationd.Core", "SensorKit");
  qword_1E929DA60 = (uint64_t)result;
  return result;
}

float sub_1905378D0(uint64_t a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 2)
  {
    if (qword_1EB3BE888 != -1) {
      dispatch_once(&qword_1EB3BE888, &unk_1EDFD3000);
    }
    uint64_t v5 = off_1EB3BE880;
    if (os_log_type_enabled((os_log_t)off_1EB3BE880, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 2;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 271,invalid index %zu >= %zu.", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE888 != -1) {
        dispatch_once(&qword_1EB3BE888, &unk_1EDFD3000);
      }
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "T CMVector<float, 2>::operator[](const size_t) const [T = float, N = 2]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf) {
        free(v6);
      }
    }
  }
  return *(float *)(a1 + 4 * a2);
}

void sub_190537AAC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0x3F80000000000000;
  *(unsigned char *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 2143289344;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  sub_19058E778(a1 + 72);
  *(void *)(a1 + 256) = 0x7FF8000000000000;
  *(unsigned char *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 268) = 1;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0x600000000;
  *(unsigned char *)(a1 + 328) = 1;
  *(void *)(a1 + 348) = 0;
  *(void *)(a1 + 340) = 0;
  *(void *)(a1 + 356) = 0x600000000;
  *(unsigned char *)(a1 + 388) = 1;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 416) = 0x600000000;
  *(void *)(a1 + 448) = 0;
  *(unsigned char *)(a1 + 456) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  *(void *)(a1 + 476) = 0;
  *(_DWORD *)(a1 + 484) = 0;
  *(void *)(a1 + 460) = 0;
  *(void *)(a1 + 468) = 0;
  sub_19058F130();
}

void sub_190537CEC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = 0;
  uint64_t v4 = v1 + 480;
  while (1)
  {
    uint64_t v5 = *(void *)(v4 + v3);
    *(void *)(v4 + v3) = 0;
    if (v5) {
      MEMORY[0x192FCC980](v5, 0x1000C40FF89C88ELL);
    }
    v3 -= 8;
    if (v3 == -16)
    {
      uint64_t v6 = *(void *)(v1 + 464);
      *(void *)(v1 + 464) = 0;
      if (v6) {
        MEMORY[0x192FCC980](v6, 0x1000C40FF89C88ELL);
      }
      uint64_t v7 = 0;
      uint64_t v8 = v1 + 248;
      while (1)
      {
        uint64_t v9 = *(void *)(v8 + v7);
        *(void *)(v8 + v7) = 0;
        if (v9) {
          MEMORY[0x192FCC980](v9, 0x1000C40FF89C88ELL);
        }
        v7 -= 8;
        if (v7 == -16) {
          _Unwind_Resume(exception_object);
        }
      }
    }
  }
}

os_log_t sub_190537D90()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "MotionContext");
  qword_1E929D9A0 = (uint64_t)result;
  return result;
}

void sub_190537DC4()
{
}

void sub_190537DD8(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = *a2;
  float v3 = 1.0 / *(double *)a2;
  *(float *)(a1 + 16) = v3;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 23) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  bzero((void *)(a1 + 56), 0x2D8uLL);
  *(_WORD *)(a1 + 822) = 0;
  *(_DWORD *)(a1 + 818) = 0;
}

void sub_190537E40(uint64_t a1, float *a2)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  sub_1902E40B4((int)(a2[2] / 0.3 * 5.0), (int)(a2[3] / 0.3 * 5.0), (int)(a2[4] / 0.3 * 5.0), a1 + 62, (_WORD *)(a1 + 254));
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_WORD *)(a1 + 816) = 0;
  if ((int)sub_1902E545C(0, 0, 0, (uint64_t *)(a1 + 264), a1 + 62, *(_WORD *)(a1 + 254), 0, 1, a1 + 56, (_DWORD *)(a1 + 776), a1 + 784) >= 1)
  {
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD2140);
    }
    float v3 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *(__int16 *)(a1 + 660);
      int v5 = *(__int16 *)(a1 + 798);
      int v6 = *(__int16 *)(a1 + 796);
      int v7 = *(__int16 *)(a1 + 800);
      int v8 = *(__int16 *)(a1 + 802);
      int v9 = *(__int16 *)(a1 + 786);
      int v10 = *(__int16 *)(a1 + 804);
      int v11 = *(__int16 *)(a1 + 806);
      int v12 = *(__int16 *)(a1 + 808);
      int v13 = *(__int16 *)(a1 + 792);
      int v14 = *(__int16 *)(a1 + 784);
      int v15 = *(__int16 *)(a1 + 810);
      int v16 = *(__int16 *)(a1 + 812);
      int v17 = *(__int16 *)(a1 + 814);
      int v18 = *(__int16 *)(a1 + 790);
      int v19 = *(__int16 *)(a1 + 788);
      int v20 = *(__int16 *)(a1 + 794);
      int v21 = *(__int16 *)(a1 + 816);
      *(_DWORD *)long long buf = 136319746;
      uint64_t v24 = "Compass-DOE";
      __int16 v25 = 1024;
      int v26 = v4;
      __int16 v27 = 1024;
      int v28 = v5;
      __int16 v29 = 1024;
      int v30 = v6;
      __int16 v31 = 1024;
      int v32 = v7;
      __int16 v33 = 1024;
      int v34 = v8;
      __int16 v35 = 1024;
      int v36 = v9;
      __int16 v37 = 1024;
      int v38 = v10;
      __int16 v39 = 1024;
      int v40 = v11;
      __int16 v41 = 1024;
      int v42 = v12;
      __int16 v43 = 1024;
      int v44 = v13;
      __int16 v45 = 1024;
      int v46 = v14;
      __int16 v47 = 1024;
      int v48 = v15;
      __int16 v49 = 1024;
      int v50 = v16;
      __int16 v51 = 1024;
      int v52 = v17;
      __int16 v53 = 1024;
      int v54 = v18;
      __int16 v55 = 1024;
      int v56 = v19;
      __int16 v57 = 1024;
      int v58 = v20;
      __int16 v59 = 1024;
      int v60 = v21;
      _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEBUG, "Type,%s,radius,%d,hrmin,%d,hrmax,%d,hrvar,%d,rvar,%d,m,%d,ovar,%d,%d,%d,hovar,%d,n,%d,vvar,%d,%d,%d,hvarA,%d,hvar,%d,hdistpl,%d,dvar,%d,", buf, 0x78u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD2140);
      }
      double v22 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLCompassCalibratorAKM::addSample(const CLVector3d<float> &, const CLClientQuaternion *, const CFTimeInterval &)", "CoreLocation: %s\n", v22);
      if (v22 != (char *)buf) {
        free(v22);
      }
    }
  }
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 776);
}

void sub_19053826C(uint64_t a1, float *a2, int *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v5 = *a3;
  *(_WORD *)(a1 + 56) = (int)(a2[2] / 0.3 * 5.0);
  uint64_t v6 = a1 + 56;
  *(_DWORD *)(a1 + 776) = v5;
  *(_DWORD *)(a1 + 20) = v5;
  *(_WORD *)(a1 + 58) = (int)(a2[3] / 0.3 * 5.0);
  *(_WORD *)(a1 + 60) = (int)(a2[4] / 0.3 * 5.0);
  sub_1902E05D4(a1 + 62);
  sub_1902E50F0(v6 + 208, 0, 0, 0, v6, *(_DWORD *)(v6 + 720));
  *(_DWORD *)(v6 - 28) = *(_DWORD *)(v6 + 720);
  *(_DWORD *)(v6 + 762) = *(_DWORD *)v6;
  *(_WORD *)(v6 + 766) = *(_WORD *)(v6 + 4);
  *(unsigned char *)(v6 - 32) = 1;
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD2140);
  }
  int v7 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
  {
    double v8 = a2[2];
    double v9 = a2[3];
    double v10 = a2[4];
    int v11 = *a3;
    *(_DWORD *)long long buf = 134218752;
    double v14 = v8;
    __int16 v15 = 2048;
    double v16 = v9;
    __int16 v17 = 2048;
    double v18 = v10;
    __int16 v19 = 1024;
    int v20 = v11;
    _os_log_impl(&dword_1902AF000, v7, OS_LOG_TYPE_DEBUG, "compass calibrator has been set with offsets (%+.3f/%+.3f/%+.3f) and calibration level (%d)", buf, 0x26u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD2140);
    }
    int v12 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual void CLCompassCalibratorAKM::setBias(const CLVector3d<float> &, const CLMotionTypeCompassCalibrationLevel &, const CLVector3d<float> &, const CLClientQuaternion *)", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf) {
      free(v12);
    }
  }
}

uint64_t sub_190538538(uint64_t result, float *a2, _DWORD *a3)
{
  int v3 = *(_DWORD *)(result + 776);
  *a3 = v3;
  int v4 = *(__int16 *)(result + 56);
  *(_DWORD *)(result + 20) = v3;
  float v5 = (float)((float)v4 / 5.0) * 0.3;
  *a2 = v5;
  float v6 = (float)((float)*(__int16 *)(result + 58) / 5.0) * 0.3;
  a2[1] = v6;
  float v7 = (float)((float)*(__int16 *)(result + 60) / 5.0) * 0.3;
  a2[2] = v7;
  int v8 = *(_DWORD *)(result + 28);
  if (v8 == v3
    && *(unsigned __int16 *)(result + 818) == *(unsigned __int16 *)(result + 56)
    && *(unsigned __int16 *)(result + 820) == *(unsigned __int16 *)(result + 58)
    && *(unsigned __int16 *)(result + 822) == *(unsigned __int16 *)(result + 60))
  {
    *(_WORD *)(result + 25) = 0;
  }
  else
  {
    *(unsigned char *)(result + 26) = v8 <= v3;
    *(_WORD *)(result + 24) = 256;
    *(_DWORD *)(result + 28) = v3;
    *(_DWORD *)(result + 818) = *(_DWORD *)(result + 56);
    *(_WORD *)(result + 822) = *(_WORD *)(result + 60);
  }
  return result;
}

float32_t sub_19053861C(__int16 *a1, float32x2_t *a2, float32x2_t *a3)
{
  float v3 = (float)((float)a1[30] / 5.0) * 0.3;
  float32_t v4 = a2[2].f32[0] - v3;
  v5.i32[0] = a1[28];
  v5.i32[1] = a1[29];
  __asm { FMOV            V3.2S, #5.0 }
  float32x2_t v11 = vcvt_f32_f64(vmulq_f64(vcvtq_f64_f32(vdiv_f32(vcvt_f32_s32(v5), _D3)), (float64x2_t)vdupq_n_s64(0x3FD3333333333333uLL)));
  a2[1] = vsub_f32(a2[1], v11);
  a2[2].f32[0] = v4;
  float32_t result = a3[2].f32[0] - v3;
  a3[1] = vsub_f32(a3[1], v11);
  a3[2].f32[0] = result;
  return result;
}

BOOL sub_1905386A8(uint64_t a1)
{
  return !*(_DWORD *)(a1 + 776)
      && *(unsigned char *)(a1 + 25)
      && !*(_WORD *)(a1 + 56)
      && !*(_WORD *)(a1 + 58)
      && *(_WORD *)(a1 + 60) == 0;
}

uint64_t sub_1905386E4()
{
  return 3;
}

uint64_t sub_1905386EC()
{
  return 0;
}

os_log_t sub_1905386F4()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Compass");
  qword_1E929D790 = (uint64_t)result;
  return result;
}

uint64_t sub_190538724(uint64_t a1, uint64_t a2)
{
  if (!sub_1902C4784(a2, "kCLMotionTypeGeomagneticModelDataXKey", (void *)a1)
    || !sub_1902C4784(a2, "kCLMotionTypeGeomagneticModelDataYKey", (void *)(a1 + 8))
    || !sub_1902C4784(a2, "kCLMotionTypeGeomagneticModelDataZKey", (void *)(a1 + 16))
    || !sub_1902C4784(a2, "kCLMotionTypeGeomagneticModelDataMagnitudeKey", (void *)(a1 + 24))
    || !sub_1902C4784(a2, "kCLMotionTypeGeomagneticModelDataHorizontalKey", (void *)(a1 + 32))
    || !sub_1902C4784(a2, "kCLMotionTypeGeomagneticModelDataDeclinationKey", (void *)(a1 + 40))
    || !sub_1902C4784(a2, "kCLMotionTypeGeomagneticModelDataInclinationKey", (void *)(a1 + 48)))
  {
    return 0;
  }

  return sub_1902C4784(a2, "kCLMotionTypeGeomagneticModelDataTimestampKey", (void *)(a1 + 56));
}

uint64_t sub_190538840(float *a1, float *a2, BOOL *a3, uint64_t a4)
{
  if (!sub_19045F394(a4, "kCLBiasXKey", a1)
    || !sub_19045F394(a4, "kCLBiasYKey", a1 + 1)
    || !sub_19045F394(a4, "kCLBiasZKey", a1 + 2)
    || !sub_19045F394(a4, "kCLVarianceXKey", a2)
    || !sub_19045F394(a4, "kCLVarianceYKey", a2 + 1)
    || !sub_19045F394(a4, "kCLVarianceZKey", a2 + 2))
  {
    return 0;
  }

  return sub_1902C47F8(a4, "KCLDoingBiasEstimationKey", a3);
}

BOOL sub_190538954(const void *a1, const void *a2, const void *a3, uint64_t a4)
{
  sub_190462484(a4, "kCMActivityAlarmId", a1);
  sub_190462484(a4, "kCMActivityAlarmTrigger", a2);

  return sub_190462A6C(a4, "kCMActivityAlarmDuration", a3);
}

uint64_t sub_1905389CC(_DWORD *a1, _DWORD *a2, void *a3, uint64_t a4)
{
  if (!sub_1902B44C0(a4, "kCMActivityAlarmId", a1)
    || !sub_1902B44C0(a4, "kCMActivityAlarmTrigger", a2))
  {
    return 0;
  }

  return sub_1902C4784(a4, "kCMActivityAlarmDuration", a3);
}

uint64_t sub_190538A6C(UInt8 *a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  if (sub_19045E038(a2, "kCMPressureBiasId", &cf)) {
    BOOL v3 = cf == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFDataGetTypeID()) {
    return 0;
  }
  CFDataRef v5 = (const __CFData *)cf;
  if ((unint64_t)CFDataGetLength((CFDataRef)cf) < 0x1D) {
    return 0;
  }
  v8.locatiouint64_t n = 0;
  v8.length = 29;
  CFDataGetBytes(v5, v8, a1);
  return 1;
}

uint64_t sub_190538B10()
{
  uint64_t result = sub_1902CD6B0();
  if ((result & 0x100) != 0) {
    operator new();
  }
  return result;
}

void sub_190538B78(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0xA1C4030951706);
  _Unwind_Resume(a1);
}

BOOL sub_190538B9C(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  sub_1902D6BD0();
  sub_1904DFAD8();
  if (qword_1E929D708 != -1) {
    dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
  }
  unint64_t v2 = off_1E929D6F8;
  if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEFAULT, "[CLSPUEclipseClient] Notifying latest suppression.", buf, 2u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D708 != -1) {
      dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
    }
    __int16 v9 = 0;
    float v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "BOOL CLSPUEclipseClient::notifyLatestSuppression()", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  char v8 = 4;
  BOOL v3 = sub_190595B88(a1, (uint64_t)&v8, (char *)1);
  if (!v3)
  {
    if (qword_1E929D708 != -1) {
      dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
    }
    CFTypeID v4 = off_1E929D6F8;
    if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_DEFAULT, "[CLSPUEclipseClient] Notify failed", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D708 != -1) {
        dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
      }
      __int16 v9 = 0;
      float v7 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "BOOL CLSPUEclipseClient::notifyLatestSuppression()", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
  return v3;
}

uint64_t sub_190538E84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2020000000;
  char v13 = 0;
  uint64_t v6 = sub_1902D6BD0();
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  void v9[2] = sub_1902B70F8;
  v9[3] = &unk_1E568F3B8;
  v9[6] = a3;
  void v9[7] = a2;
  double v9[4] = &v10;
  void v9[5] = a1;
  sub_1902CDE98(v6, (uint64_t)v9);
  uint64_t v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_190538F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_190538F5C(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  __int16 v9 = &v8;
  uint64_t v10 = 0x2020000000;
  char v11 = 0;
  uint64_t v4 = sub_1902D6BD0();
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = sub_190539030;
  void v7[3] = &unk_1E568DAA0;
  void v7[5] = a1;
  v7[6] = a2;
  void v7[4] = &v8;
  sub_1902CDE98(v4, (uint64_t)v7);
  uint64_t v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_190539018(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_190539030(void *a1)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[5];
  if ((sub_1902CD6B0() & 0x100) == 0)
  {
    if (qword_1E929D708 != -1) {
      dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
    }
    double v14 = off_1E929D6F8;
    uint64_t v5 = (int *)"assert";
    if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 68289539;
      *(_DWORD *)int v26 = 0;
      *(_WORD *)&v26[4] = 2082;
      *(void *)&void v26[6] = "";
      __int16 v27 = 2082;
      int v28 = "assert";
      __int16 v29 = 2081;
      int v30 = "isAvailable()";
      _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLSPUEclipseInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1E929D708 != -1) {
        dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
      }
    }
    __int16 v15 = off_1E929D6F8;
    if (os_signpost_enabled((os_log_t)off_1E929D6F8))
    {
      *(_DWORD *)long long buf = 68289539;
      *(_DWORD *)int v26 = 0;
      *(_WORD *)&v26[4] = 2082;
      *(void *)&void v26[6] = "";
      __int16 v27 = 2082;
      int v28 = "assert";
      __int16 v29 = 2081;
      int v30 = "isAvailable()";
      _os_signpost_emit_with_name_impl(&dword_1902AF000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLSPUEclipseInterface] Service required", "{\"msg%{public}.0s\":\"[CLSPUEclipseInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1E929D708 != -1) {
        dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
      }
    }
    uint64_t v4 = off_1E929D6F8;
    if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 68289539;
      *(_DWORD *)int v26 = 0;
      *(_WORD *)&v26[4] = 2082;
      *(void *)&void v26[6] = "";
      __int16 v27 = 2082;
      int v28 = "assert";
      __int16 v29 = 2081;
      int v30 = "isAvailable()";
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLSPUEclipseInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
LABEL_30:
    dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
LABEL_4:
    uint64_t v6 = off_1E929D6F8;
    if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = mach_error_string((mach_error_t)v4);
      *(_DWORD *)long long buf = 136446466;
      *(void *)int v26 = v7;
      *(_WORD *)&v26[8] = 1026;
      *(_DWORD *)&v26[10] = v4;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_ERROR, "[CLSPUEclipseClient] QueryStaticPose failed: %{public}s (0x%{public}x)", buf, 0x12u);
    }
    if (!sub_1902D8400(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (*((void *)v5 + 225) != -1) {
      dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
    }
    uint64_t v8 = mach_error_string((mach_error_t)v4);
    int v21 = 136446466;
    uint64_t v22 = (uint64_t)v8;
    __int16 v23 = 1026;
    int v24 = (int)v4;
    __int16 v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "BOOL CLSPUEclipseClient::queryStaticPoseBlocking(CMEclipseReport::QueryStaticPoseReply &)_block_invoke", "CoreLocation: %s\n", v9);
    if (v9 == (char *)buf) {
      return;
    }
LABEL_34:
    free(v9);
    return;
  }
  char v20 = 8;
  __int16 v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  uint64_t v16 = 34;
  int v3 = sub_1905145B0(*(void *)(v2 + 24), (uint64_t)&v20, (char *)1, (uint64_t)&v17, (uint64_t)&v16);
  if (v3)
  {
    LODWORD(v4) = v3;
    uint64_t v5 = &OBJC_IVAR___CMHeadphoneActivityManagerInternal_fLogger;
    if (qword_1E929D708 == -1) {
      goto LABEL_4;
    }
    goto LABEL_30;
  }
  if (v16 == 34)
  {
    uint64_t v10 = a1[6];
    long long v11 = v17;
    long long v12 = v18;
    *(_WORD *)(v10 + 32) = v19;
    *(_OWORD *)uint64_t v10 = v11;
    *(_OWORD *)(v10 + 16) = v12;
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
    return;
  }
  if (qword_1E929D708 != -1) {
    dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
  }
  char v13 = off_1E929D6F8;
  if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 134349056;
    *(void *)int v26 = v16;
    _os_log_impl(&dword_1902AF000, v13, OS_LOG_TYPE_ERROR, "[CLSPUEclipseClient] Unexpected response size: %{public}zu", buf, 0xCu);
  }
  if (sub_1902D8400(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D708 != -1) {
      dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
    }
    int v21 = 134349056;
    uint64_t v22 = v16;
    __int16 v9 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "BOOL CLSPUEclipseClient::queryStaticPoseBlocking(CMEclipseReport::QueryStaticPoseReply &)_block_invoke", "CoreLocation: %s\n", v9);
    if (v9 != (char *)buf) {
      goto LABEL_34;
    }
  }
}

void sub_1905395C8(uint64_t a1, int a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  sub_1902D6BD0();
  sub_1904DFAD8();
  v8[0] = 6;
  v8[1] = a2;
  if (qword_1E929D708 != -1) {
    dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
  }
  uint64_t v4 = off_1E929D6F8;
  if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67240192;
    int v12 = a2;
    _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "[CLSPUEclipseClient] Sending SignificantUserInteraction to AOP,simulated,%{public}u", buf, 8u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D708 != -1) {
      dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
    }
    int v9 = 67240192;
    int v10 = a2;
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CLSPUEclipseClient::informSignificantUserInteraction(BOOL)", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
  if (!sub_190595B88(a1, (uint64_t)v8, (char *)2))
  {
    if (qword_1E929D708 != -1) {
      dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
    }
    uint64_t v5 = off_1E929D6F8;
    if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_DEFAULT, "[CLSPUEclipseClient] Informing AOP about SignificantUserInteraction failed", buf, 2u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D708 != -1) {
        dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
      }
      LOWORD(v9) = 0;
      uint64_t v7 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "void CLSPUEclipseClient::informSignificantUserInteraction(BOOL)", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf) {
        free(v7);
      }
    }
  }
}

void sub_1905398C8(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1902D6BD0();
  sub_1904DFAD8();
  char v4 = 7;
  if (!sub_190595B88(a1, (uint64_t)&v4, (char *)1))
  {
    if (qword_1E929D708 != -1) {
      dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
    }
    uint64_t v2 = off_1E929D6F8;
    if (os_log_type_enabled((os_log_t)off_1E929D6F8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_ERROR, "[CLSPUEclipseClient] Failed to release AP force wake assertion", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D708 != -1) {
        dispatch_once(&qword_1E929D708, &unk_1EDFD3280);
      }
      int v3 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "void CLSPUEclipseClient::releaseAPForceWakeAssertion()", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf) {
        free(v3);
      }
    }
  }
}

void sub_190539A7C(uint64_t a1)
{
  sub_190595AF8(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_190539AB4()
{
  return 0;
}

os_log_t sub_190539ABC()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Eclipse");
  off_1E929D6F8 = result;
  return result;
}

void sub_190539AEC()
{
}

void sub_190539B54(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10A1C40A8081CBALL);
  _Unwind_Resume(a1);
}

void sub_190539B7C(uint64_t a1)
{
  sub_1905D3F44(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_190539BB4(uint64_t result)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v1 = (void *)result;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      && objc_msgSend_objectForKeyedSubscript_(v1, v2, @"CMOnBodyStatusManagerClassifierTheta0")
      && objc_msgSend_objectForKeyedSubscript_(v1, v3, @"CMOnBodyStatusManagerClassifierTheta1")
      && objc_msgSend_objectForKeyedSubscript_(v1, v4, @"CMOnBodyStatusManagerClassifierTheta2")
      && objc_msgSend_objectForKeyedSubscript_(v1, v5, @"CMOnBodyStatusManagerClassifierTheta3")
      && objc_msgSend_objectForKeyedSubscript_(v1, v6, @"CMOnBodyStatusManagerClassifierTheta4")
      && objc_msgSend_objectForKeyedSubscript_(v1, v7, @"CMOnBodyStatusManagerClassifierTheta5")
      && objc_msgSend_objectForKeyedSubscript_(v1, v8, @"CMOnBodyStatusManagerClassifierMinLowPower")
      && objc_msgSend_objectForKeyedSubscript_(v1, v9, @"CMOnBodyStatusManagerClassifierMaxLowPower")
      && objc_msgSend_objectForKeyedSubscript_(v1, v10, @"CMOnBodyStatusManagerClassifierMaxHighPower")
      && objc_msgSend_objectForKeyedSubscript_(v1, v11, @"CMOnBodyStatusManagerLowBandStart")
      && objc_msgSend_objectForKeyedSubscript_(v1, v12, @"CMOnBodyStatusManagerLowBandStop")
      && objc_msgSend_objectForKeyedSubscript_(v1, v13, @"CMOnBodyStatusManagerHighBandStart")
      && objc_msgSend_objectForKeyedSubscript_(v1, v14, @"CMOnBodyStatusManagerHighBandStop")
      && objc_msgSend_objectForKeyedSubscript_(v1, v15, @"CMOnBodyStatusManagerWakeThreshold")
      && objc_msgSend_objectForKeyedSubscript_(v1, v16, @"CMOnBodyStatusManagerOddsThreshold")
      && objc_msgSend_objectForKeyedSubscript_(v1, v17, @"CMOnBodyStatusManagerMedianFilterSize")
      && objc_msgSend_objectForKeyedSubscript_(v1, v18, @"CMOnBodyStatusManagerConfidenceThreshold")
      && objc_msgSend_objectForKeyedSubscript_(v1, v19, @"CMOnBodyStatusManagerUseHysteresis")
      && objc_msgSend_objectForKeyedSubscript_(v1, v20, @"CMOnBodyStatusManagerUseAngleOverride")
      && objc_msgSend_objectForKeyedSubscript_(v1, v21, @"CMOnBodyStatusManagerAngleMetricThreshold"))
    {
      return 1;
    }
    else
    {
      if (qword_1E929D988 != -1) {
        dispatch_once(&qword_1E929D988, &unk_1EDFD2DC0);
      }
      uint64_t v22 = qword_1E929D990;
      if (os_log_type_enabled((os_log_t)qword_1E929D990, OS_LOG_TYPE_FAULT))
      {
        __int16 v25 = objc_msgSend_description(v1, v23, v24);
        *(_DWORD *)long long buf = 136446210;
        uint64_t v36 = objc_msgSend_UTF8String(v25, v26, v27);
        _os_log_impl(&dword_1902AF000, v22, OS_LOG_TYPE_FAULT, "Invalid parameters received:\n%{public}s", buf, 0xCu);
      }
      int v28 = sub_1902D8400(115, 0);
      os_log_t result = 0;
      if (v28)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D988 != -1) {
          dispatch_once(&qword_1E929D988, &unk_1EDFD2DC0);
        }
        uint64_t v31 = objc_msgSend_description(v1, v29, v30);
        objc_msgSend_UTF8String(v31, v32, v33);
        int v34 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "static BOOL CLOnBodyNotifier_Type::Params::isValid(NSDictionary *)", "CoreLocation: %s\n", v34);
        if (v34 != (char *)buf) {
          free(v34);
        }
        return 0;
      }
    }
  }
  return result;
}

os_log_t sub_190539F90()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "OnBody");
  qword_1E929D990 = (uint64_t)result;
  return result;
}

void sub_190539FC4(uint64_t a1, const char *a2, uint64_t a3)
{
  sub_1905418CC(a1, a2, a3);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_190539FFC(uint64_t a1, _DWORD *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (*a2) {
    return 1;
  }
  if (!*(void *)(a1 + 112))
  {
    *(void *)(a1 + 120) = dispatch_queue_create("com.apple.CoreMotion.CLGeomagneticModelProviderClientPrivateQueue", 0);
    operator new();
  }
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD3020);
  }
  int v3 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_FAULT, "fLocationdConnection is not NULL", buf, 2u);
  }
  uint64_t result = sub_1902D8400(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD3020);
    }
    char v4 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLGeomagneticModelProviderClient::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf) {
      free(v4);
    }
    return 0;
  }
  return result;
}

void sub_19053A374(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a12) {
    sub_1902D8B58(a12);
  }
  sub_1902D8B58(v33);
  _Unwind_Resume(a1);
}

void *sub_19053A414(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  CFDictionaryRef Dictionary = (const __CFDictionary *)CLConnectionMessage::getDictionary(*a2);
  sub_19045CAD8(v16, Dictionary);
  if ((*(int (**)(void *))(v16[0] + 856))(v16) >= 1
    && (sub_190538724((uint64_t)v15, (uint64_t)v16) & 1) != 0)
  {
    uint64_t v5 = *(void **)(v2 + 40);
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    long long v10 = v15[0];
    long long v11 = v15[1];
    void v9[2] = sub_19053A698;
    v9[3] = &unk_1E568F3D8;
    double v9[4] = v2;
    long long v12 = v15[2];
    long long v13 = v15[3];
    objc_msgSend_async_(v5, v4, (uint64_t)v9);
  }
  else
  {
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD3020);
    }
    uint64_t v6 = qword_1E929D790;
    if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "Could not get geomagnetic model data for message!", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D798 != -1) {
        dispatch_once(&qword_1E929D798, &unk_1EDFD3020);
      }
      __int16 v14 = 0;
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLGeomagneticModelProviderClient::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)_block_invoke", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  return sub_19045CCC8(v16);
}

void sub_19053A678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
}

uint64_t sub_19053A698(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  long long v2 = *(_OWORD *)(a1 + 56);
  v6[0] = *(_OWORD *)(a1 + 40);
  v6[1] = v2;
  long long v3 = *(_OWORD *)(a1 + 88);
  void v6[2] = *(_OWORD *)(a1 + 72);
  v6[3] = v3;
  int v5 = 0;
  return (*(uint64_t (**)(uint64_t, int *, _OWORD *, uint64_t, uint64_t, void))(*(void *)v1 + 152))(v1, &v5, v6, 1, 0xFFFFFFFFLL, 0);
}

void sub_19053A710(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD3020);
  }
  long long v3 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = CLConnectionMessage::name(*a2);
    if (*(char *)(v4 + 23) >= 0) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = *(void *)v4;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v8 = v5;
    _os_log_impl(&dword_1902AF000, v3, OS_LOG_TYPE_DEBUG, "Default handler received message %s", buf, 0xCu);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD3020);
    }
    CLConnectionMessage::name(*a2);
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "virtual BOOL CLGeomagneticModelProviderClient::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf) {
      free(v6);
    }
  }
}

uint64_t sub_19053A8F0(uint64_t a1, _DWORD *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (*a2) {
    return 1;
  }
  if (*(void *)(a1 + 112))
  {
    uint64_t v3 = MEMORY[0x192FCC3F0]();
    MEMORY[0x192FCC980](v3, 0xB0C40BC2CC919);
    *(void *)(a1 + 112) = 0;
    dispatch_release(*(dispatch_object_t *)(a1 + 120));
    *(void *)(a1 + 120) = 0;
    return 1;
  }
  if (qword_1E929D798 != -1) {
    dispatch_once(&qword_1E929D798, &unk_1EDFD3020);
  }
  uint64_t v5 = qword_1E929D790;
  if (os_log_type_enabled((os_log_t)qword_1E929D790, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_FAULT, "fLocationdConnection is NULL", buf, 2u);
  }
  int v6 = sub_1902D8400(115, 0);
  uint64_t result = 0;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D798 != -1) {
      dispatch_once(&qword_1E929D798, &unk_1EDFD3020);
    }
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLGeomagneticModelProviderClient::unregisterForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf) {
      free(v7);
    }
    return 0;
  }
  return result;
}

uint64_t sub_19053AB08()
{
  uint64_t result = sub_1902BB1DC();
  if (result) {
    byte_1EB3BF540 = 1;
  }
  return result;
}

uint64_t sub_19053AB30(uint64_t a1)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_19053ABC0;
  block[3] = &unk_1E568D118;
  void block[4] = a1;
  if (qword_1E929E550 != -1) {
    dispatch_once(&qword_1E929E550, block);
  }
  return qword_1E929E9D8;
}

void sub_19053ABC0()
{
}

void sub_19053AC34(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10B3C40469E7843);
  _Unwind_Resume(a1);
}

uint64_t sub_19053AC58(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(a1 + 108)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = (int *)v8;
  v8[0] = 0;
  v8[1] = 0;
  uint64_t v9 = a2;
  uint64_t v3 = (unsigned int *)(a1 + 104);
  ++*(_DWORD *)(a1 + 104);
  long long v10 = (_DWORD *)(a1 + 104);
  uint64_t v4 = sub_1904B9814((uint64_t **)(a1 + 80), (int *)(a1 + 104), (uint64_t)&unk_1906099C2, &v10);
  if (v4 + 5 != (uint64_t **)&v7) {
    sub_1904B993C(v4 + 5, v7, (int *)v8);
  }
  uint64_t v5 = (void *)v8[0];
  v4[8] = v9;
  uint64_t v2 = *v3;
  sub_1904B9BBC((uint64_t)&v7, v5);
  return v2;
}

void sub_19053AD0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_19053AD24(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  v14[0] = a2;
  if (!*(unsigned char *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      if (v7 >= (int)a2) {
        uint64_t v9 = (uint64_t *)v4;
      }
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)long long buf = *(_DWORD *)(*(void *)(v6 + 40) + 28);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112))(a1, a2, buf);
      }
      sub_1904B9CD0(v5, v14);
    }
    else
    {
LABEL_12:
      if (qword_1E929D728 != -1) {
        dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
      }
      long long v10 = qword_1E929D720;
      if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_FAULT))
      {
        long long v11 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          long long v11 = (void *)*v11;
        }
        *(_DWORD *)long long buf = 136446466;
        __int16 v19 = v11;
        __int16 v20 = 1026;
        int v21 = a2;
        _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1E929D728 != -1) {
          dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
        }
        long long v12 = (void *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0) {
          long long v12 = (void *)*v12;
        }
        v14[1] = 136446466;
        __int16 v15 = v12;
        __int16 v16 = 1026;
        int v17 = a2;
        long long v13 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::removeClient(int) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v13);
        if (v13 != (char *)buf) {
          free(v13);
        }
      }
    }
  }
}

uint64_t sub_19053AFB4(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v7 = sub_1904B9DEC(a4);
  if (v7)
  {
    int v10 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t))(*(void *)a1 + 96))(a1, a2, &v10, v7);
  }
  else
  {
    int v9 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 88))(a1, a2, &v9);
  }
}

uint64_t sub_19053B068(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 104))(a1, a2, &v4);
}

uint64_t sub_19053B0B0(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 112))(a1, a2, &v4);
}

uint64_t sub_19053B0F8(uint64_t a1, int a2)
{
  int v3 = a2;
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 120))(a1, &v3);
}

uint64_t sub_19053B140(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  if (!result)
  {
    int v3 = objc_alloc_init(CLNotifierServiceAdapter);
    *(void *)(a1 + 48) = v3;
    objc_msgSend_setValid_(v3, v4, 1);
    objc_msgSend_setAdaptedNotifier_(*(void **)(a1 + 48), v5, a1);
    return *(void *)(a1 + 48);
  }
  return result;
}

uint64_t sub_19053B190(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96))(a1, a2, a3, &unk_1E929E0D8);
}

uint64_t sub_19053B1BC(uint64_t a1, int a2, int *a3, char *a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  int v41 = a2;
  if (*(unsigned char *)(a1 + 108)) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        long long v13 = (uint64_t *)v7;
      }
      else {
        long long v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }
    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)int v42 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          uint64_t v24 = (uint64_t *)v18;
        }
        else {
          uint64_t v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }
      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          __int16 v29 = (uint64_t *)v25;
        }
        else {
          __int16 v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }
      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v40 = v26;
        uint64_t v35 = *(void *)(v26 + 56);
        char v36 = *a4;
        *(void *)long long buf = &v41;
        *((unsigned char *)sub_1904BAC2C((uint64_t **)(v26 + 40), &v41, (uint64_t)&unk_1906099C2, (_DWORD **)buf) + 32) = v36;
        long long v46 = 0u;
        long long v47 = 0u;
        memset(buf, 0, sizeof(buf));
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, uint8_t *))(*(void *)a1 + 128))(a1, a3, buf))
        {
          sub_19053DBF0();
        }
        if (v35) {
          goto LABEL_46;
        }
      }
      else
      {
LABEL_42:
        uint64_t v40 = a1 + 64;
        char v30 = byte_1E929E0D9;
        int v39 = v17;
        *(void *)long long buf = &v39;
        *((unsigned char *)sub_1904BAA54((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_1906099C2, (_DWORD **)buf) + 80) = v30;
        int v39 = *a3;
        *(void *)long long buf = &v39;
        uint64_t v31 = sub_1904BAA54((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_1906099C2, (_DWORD **)buf);
        int v32 = (std::__shared_weak_count *)v31[9];
        v31[8] = 0;
        v31[9] = 0;
        if (v32) {
          sub_1902D8B58(v32);
        }
        char v33 = *a4;
        int v39 = *a3;
        *(void *)long long buf = &v39;
        int v34 = sub_1904BAA54((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_1906099C2, (_DWORD **)buf);
        *(void *)long long buf = &v41;
        *((unsigned char *)sub_1904BAC2C(v34 + 5, &v41, (uint64_t)&unk_1906099C2, (_DWORD **)buf) + 32) = v33;
      }
      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168))(a1, a3);
LABEL_46:
      if (v21 == v19)
      {
        *(_DWORD *)long long buf = *a3;
        sub_1904BB77C((uint64_t **)(*(void *)v42 + 40), (int *)buf, buf);
      }
      return 1;
    }
  }
  if (qword_1E929D728 != -1) {
    dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
  }
  __int16 v14 = qword_1E929D720;
  if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_FAULT))
  {
    __int16 v15 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      __int16 v15 = (void *)*v15;
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl(&dword_1902AF000, v14, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist", buf, 0x12u);
  }
  int v16 = sub_1902D8400(115, 0);
  uint64_t result = 0;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D728 != -1) {
      dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
    }
    uint64_t v37 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      uint64_t v37 = (void *)*v37;
    }
    *(_DWORD *)int v42 = 136446466;
    *(void *)&v42[4] = v37;
    __int16 v43 = 1026;
    int v44 = a2;
    int v38 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v38);
    if (v38 != (char *)buf) {
      free(v38);
    }
    return 0;
  }
  return result;
}

BOOL sub_19053B664(uint64_t a1, int a2, int *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v5;
    }
    else {
      int v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }
    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }
  else
  {
LABEL_11:
    if (qword_1E929D728 != -1) {
      dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
    }
    uint64_t v10 = qword_1E929D720;
    if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        int v11 = (void *)*v11;
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v24 = v11;
      __int16 v25 = 1026;
      int v26 = a2;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist", buf, 0x12u);
    }
    int v12 = sub_1902D8400(115, 0);
    BOOL result = 0;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D728 != -1) {
        dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
      }
      int v22 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v22);
      if (v22 != (char *)buf) {
        free(v22);
      }
      return 0;
    }
  }
  return result;
}

BOOL sub_19053B8E8(char *a1, int a2, int *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  int v32 = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        int v12 = v8 + 48;
        long long v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            long long v13 = *v19;
          }
          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1904BB838((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            int v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                __int16 v25 = (uint64_t *)v20;
              }
              else {
                __int16 v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                int v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }
            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1904BB838((uint64_t)(v22 + 40), &v32);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176))(a1, a3);
              }
            }
            else
            {
LABEL_33:
              if (qword_1E929D728 != -1) {
                dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
              }
              int v26 = qword_1E929D720;
              if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_FAULT))
              {
                uint64_t v27 = a1 + 8;
                if (a1[31] < 0) {
                  uint64_t v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160))(__p, a1, a3);
                if (v42 >= 0) {
                  BOOL v28 = __p;
                }
                else {
                  BOOL v28 = (void **)__p[0];
                }
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v34 = 2082;
                uint64_t v35 = v28;
                _os_log_impl(&dword_1902AF000, v26, OS_LOG_TYPE_FAULT, "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v42 < 0) {
                  operator delete(__p[0]);
                }
              }
              if (sub_1902D8400(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1E929D728 != -1) {
                  dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
                }
                __int16 v29 = a1 + 8;
                if (a1[31] < 0) {
                  __int16 v29 = (void *)*v29;
                }
                (*(void (**)(unsigned char *__return_ptr, char *, int *))(*(void *)a1 + 160))(buf, a1, a3);
                if (v36 >= 0) {
                  char v30 = buf;
                }
                else {
                  char v30 = *(unsigned char **)buf;
                }
                int v37 = 136446466;
                int v38 = v29;
                __int16 v39 = 2082;
                uint64_t v40 = v30;
                uint64_t v31 = (char *)_os_log_send_and_compose_impl();
                if (v36 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_1902D398C("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v31);
                if (v31 != (char *)__p) {
                  free(v31);
                }
              }
            }
          }
        }
      }
    }
  }
  return v3 == 0;
}

void sub_19053BCBC(uint64_t a1, int *a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v2 = a1 + 64;
  uint64_t v3 = v4;
  if (v4)
  {
    int v5 = *a2;
    uint64_t v6 = v2;
    do
    {
      int v7 = *(_DWORD *)(v3 + 32);
      BOOL v8 = v7 < v5;
      if (v7 >= v5) {
        int v9 = (uint64_t *)v3;
      }
      else {
        int v9 = (uint64_t *)(v3 + 8);
      }
      if (!v8) {
        uint64_t v6 = v3;
      }
      uint64_t v3 = *v9;
    }
    while (*v9);
    if (v6 != v2 && v5 >= *(_DWORD *)(v6 + 32))
    {
      BOOL v10 = *(std::__shared_weak_count **)(v6 + 72);
      *(void *)(v6 + 64) = 0;
      *(void *)(v6 + 72) = 0;
      if (v10) {
        sub_1902D8B58(v10);
      }
    }
  }
}

uint64_t sub_19053BD10(uint64_t a1, int *a2, _OWORD *a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }
  while (*v10);
  if (v7 == v3) {
    return 0;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0;
  }
  int v11 = *(long long **)(v7 + 64);
  if (!v11) {
    return 0;
  }
  long long v12 = *v11;
  long long v13 = v11[1];
  long long v14 = v11[3];
  a3[2] = v11[2];
  a3[3] = v14;
  *a3 = v12;
  a3[1] = v13;
  return 1;
}

uint64_t sub_19053BD78(uint64_t a1, int *a2, _OWORD *a3)
{
  int v6 = (char *)operator new(0x58uLL);
  long long v7 = a3[1];
  *(_OWORD *)(v6 + 24) = *a3;
  *(_OWORD *)(v6 + 40) = v7;
  long long v8 = a3[3];
  *(_OWORD *)(v6 + 56) = a3[2];
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)int v6 = &unk_1EDFD0E48;
  *(_OWORD *)(v6 + 72) = v8;
  int v12 = *a2;
  long long v13 = &v12;
  BOOL v9 = sub_1904BAA54((uint64_t **)(a1 + 56), &v12, (uint64_t)&unk_1906099C2, &v13);
  BOOL v10 = (std::__shared_weak_count *)v9[9];
  void v9[8] = (uint64_t *)(v6 + 24);
  v9[9] = (uint64_t *)v6;
  if (v10) {
    sub_1902D8B58(v10);
  }
  return 1;
}

void sub_19053BE3C(_Unwind_Exception *a1)
{
  sub_1902D8B58(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19053BE50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  memset(v5, 0, sizeof(v5));
  return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 152))(a1, a2, v5, a3, a4, 0);
}

void sub_19053BEAC(uint64_t a1, unsigned int *a2, _OWORD *a3, int a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 108)) {
    return;
  }
  long long v8 = _os_activity_create(&dword_1902AF000, "CL: notifyClientsWithData (Fallback)", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
  os_activity_scope_enter(v8, &state);

  if (qword_1E929D728 != -1) {
    dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
  }
  BOOL v9 = qword_1E929D720;
  if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_DEBUG))
  {
    BOOL v10 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      BOOL v10 = (void *)*v10;
    }
    int v11 = (std::__shared_weak_count *)*a2;
    *(_DWORD *)long long buf = 68289794;
    int v24 = 0;
    __int16 v25 = 2082;
    *(void *)int v26 = "";
    *(_WORD *)&v26[8] = 2082;
    *(void *)&v26[10] = "activity";
    __int16 v27 = 2082;
    BOOL v28 = v10;
    __int16 v29 = 2050;
    char v30 = v11;
    _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"notifyClientsWithData\", \"event\":%{public, location:escape_only}s, \"name\":%{public, location:escape_only}s, \"notification\":%{public}lld}", buf, 0x30u);
  }
  uint64_t v12 = *(void *)(a1 + 64);
  if (!v12) {
    goto LABEL_18;
  }
  int v13 = *a2;
  long long v14 = (uint64_t **)(a1 + 64);
  do
  {
    int v15 = *(_DWORD *)(v12 + 32);
    BOOL v16 = v15 < v13;
    if (v15 >= v13) {
      int v17 = (uint64_t *)v12;
    }
    else {
      int v17 = (uint64_t *)(v12 + 8);
    }
    if (!v16) {
      long long v14 = (uint64_t **)v12;
    }
    uint64_t v12 = *v17;
  }
  while (*v17);
  if (v14 == (uint64_t **)(a1 + 64) || v13 < *((_DWORD *)v14 + 8))
  {
LABEL_18:
    uint64_t v31 = v32;
    memset(v32, 0, sizeof(v32));
    char v33 = 0;
    sub_1904BBF48((uint64_t)buf, a2, (uint64_t)&v31);
    long long v14 = sub_1904BBE10((uint64_t **)(a1 + 56), (__n128 *)buf);
    if (v30) {
      sub_1902D8B58(v30);
    }
    sub_1904B9BBC((uint64_t)&v25, *(void **)&v26[6]);
    if (v33) {
      sub_1902D8B58(v33);
    }
    sub_1904B9BBC((uint64_t)&v31, v32[0]);
  }
  if (a4)
  {
    BOOL v18 = (char *)operator new(0x58uLL);
    long long v19 = a3[1];
    *(_OWORD *)(v18 + 24) = *a3;
    *(_OWORD *)(v18 + 40) = v19;
    long long v20 = a3[3];
    *(_OWORD *)(v18 + 56) = a3[2];
    *((void *)v18 + 1) = 0;
    *((void *)v18 + 2) = 0;
    *(void *)BOOL v18 = &unk_1EDFD0E48;
    *(_OWORD *)(v18 + 72) = v20;
    int v21 = (std::__shared_weak_count *)v14[9];
    v14[8] = (uint64_t *)(v18 + 24);
    v14[9] = (uint64_t *)v18;
    if (!v21) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  int v21 = (std::__shared_weak_count *)v14[9];
  v14[8] = 0;
  v14[9] = 0;
  if (v21) {
LABEL_27:
  }
    sub_1902D8B58(v21);
LABEL_28:
  if (v14[7]) {
    sub_19053CAEC();
  }
  os_activity_scope_leave(&state);
}

void sub_19053C4A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

uint64_t sub_19053C4F0()
{
  return 1;
}

void sub_19053C4F8(uint64_t a1)
{
  *(void *)((char *)&v24[202] + 2) = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 108))
  {
    if (qword_1E929D728 != -1) {
      dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
    }
    uint64_t v2 = qword_1E929D720;
    if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        uint64_t v3 = (void *)*v3;
      }
      *(_DWORD *)long long buf = 136315138;
      int v22 = v3;
      _os_log_impl(&dword_1902AF000, v2, OS_LOG_TYPE_DEBUG, "%s; already shutdown; not listing clients", buf, 0xCu);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D728 != -1) {
        dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
      }
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::listClients() [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf) {
        free(v4);
      }
    }
  }
  else
  {
    if (qword_1E929D728 != -1) {
      dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
    }
    uint64_t v5 = qword_1E929D720;
    if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_DEBUG))
    {
      int v6 = (void *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        int v6 = (void *)*v6;
      }
      uint64_t v7 = *(void *)(a1 + 96);
      *(_DWORD *)long long buf = 136315394;
      int v22 = v6;
      __int16 v23 = 2048;
      v24[0] = v7;
      _os_log_impl(&dword_1902AF000, v5, OS_LOG_TYPE_DEBUG, "%s; listing clients, num clients: %zu", buf, 0x16u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1E929D728 != -1) {
        dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
      }
      long long v20 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::listClients() [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v20);
      if (v20 != (char *)buf) {
        free(v20);
      }
    }
    long long v8 = *(void **)(a1 + 80);
    if (v8 != (void *)(a1 + 88))
    {
      do
      {
        BOOL v9 = (void *)v8[5];
        if (v9 != v8 + 6)
        {
          do
          {
            if (qword_1E929D728 != -1) {
              dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
            }
            BOOL v10 = qword_1E929D720;
            if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_DEBUG))
            {
              int v11 = (void *)(a1 + 8);
              if (*(char *)(a1 + 31) < 0) {
                int v11 = *(void **)(a1 + 8);
              }
              int v12 = *((_DWORD *)v8 + 8);
              int v13 = *((_DWORD *)v9 + 7);
              *(_DWORD *)long long buf = 136315650;
              int v22 = v11;
              __int16 v23 = 1024;
              LODWORD(v24[0]) = v12;
              WORD2(v24[0]) = 1024;
              *(_DWORD *)((char *)v24 + 6) = v13;
              _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_DEBUG, "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }
            if (sub_1902D8400(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1E929D728 != -1) {
                dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
              }
              int v17 = (char *)_os_log_send_and_compose_impl();
              sub_1902D398C("Generic", 1, 0, 2, "virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::listClients() [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v17);
              if (v17 != (char *)buf) {
                free(v17);
              }
            }
            long long v14 = (void *)v9[1];
            if (v14)
            {
              do
              {
                int v15 = v14;
                long long v14 = (void *)*v14;
              }
              while (v14);
            }
            else
            {
              do
              {
                int v15 = (void *)v9[2];
                BOOL v16 = *v15 == (void)v9;
                BOOL v9 = v15;
              }
              while (!v16);
            }
            BOOL v9 = v15;
          }
          while (v15 != v8 + 6);
        }
        BOOL v18 = (void *)v8[1];
        if (v18)
        {
          do
          {
            long long v19 = v18;
            BOOL v18 = (void *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            long long v19 = (void *)v8[2];
            BOOL v16 = *v19 == (void)v8;
            long long v8 = v19;
          }
          while (!v16);
        }
        long long v8 = v19;
      }
      while (v19 != (void *)(a1 + 88));
    }
  }
}

double sub_19053CAA4@<D0>(uint64_t a1@<X8>)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0xBFF0000000000000;
  return result;
}

os_log_t sub_19053CABC()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Compass");
  qword_1E929D790 = (uint64_t)result;
  return result;
}

void sub_19053CAEC()
{
}

void sub_19053CBA0(uint64_t a1, int *a2, void *a3)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 108))
  {
    uint64_t v5 = a1 + 64;
    uint64_t v4 = *(void *)(a1 + 64);
    if (v4)
    {
      int v8 = *a2;
      uint64_t v9 = a1 + 64;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          int v12 = (uint64_t *)v4;
        }
        else {
          int v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          uint64_t v9 = v4;
        }
        uint64_t v4 = *v12;
      }
      while (*v12);
      if (v9 != v5 && v8 >= *(_DWORD *)(v9 + 32))
      {
        uint64_t v49 = v9;
        uint64_t v13 = sub_19053D154(a3);
        (*(void (**)(uint64_t, int *, uint64_t, uint64_t))(*(void *)a1 + 184))(a1, a2, v13, v9 + 80);
        long long v14 = *(void **)(v9 + 40);
        if (v14 != (void *)(v9 + 48))
        {
          int v15 = (uint64_t *)(a1 + 88);
          BOOL v16 = (uint64_t *)(a1 + 8);
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            uint64_t v19 = a1 + 88;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                uint64_t v19 = v17;
              }
              uint64_t v17 = *v22;
            }
            while (*v22);
            if ((uint64_t *)v19 != v15 && (int v23 = *(_DWORD *)(v19 + 32), v18 >= v23))
            {
              uint64_t v48 = v19;
              sub_19053CF90(a1, (uint64_t)&v48, (uint64_t)&v49, a3);
              uint64_t v27 = *(void *)(a1 + 64);
              if (!v27) {
                return;
              }
              int v28 = *a2;
              uint64_t v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  int v32 = (uint64_t *)v27;
                }
                else {
                  int v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  uint64_t v29 = v27;
                }
                uint64_t v27 = *v32;
              }
              while (*v32);
              if (v29 == v5 || v28 < *(_DWORD *)(v29 + 32)) {
                return;
              }
              uint64_t v49 = v29;
              uint64_t v34 = *(void *)(v29 + 48);
              long long v14 = (void *)(v29 + 48);
              uint64_t v33 = v34;
              if (v34)
              {
                uint64_t v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    __int16 v39 = (uint64_t *)v36;
                  }
                  else {
                    __int16 v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    uint64_t v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }
                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      char v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      char v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      long long v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }
                  while (*v42);
                }
                else
                {
                  uint64_t v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      long long v14 = v43;
                      uint64_t v43 = (void *)*v43;
                    }
                    while (v43);
                  }
                  else
                  {
                    do
                    {
                      long long v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      uint64_t v35 = v14;
                    }
                    while (!v44);
                  }
                }
              }
            }
            else
            {
LABEL_25:
              uint64_t v48 = a1 + 88;
              if (qword_1E929D728 != -1) {
                dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
              }
              int v24 = qword_1E929D720;
              if (os_log_type_enabled((os_log_t)qword_1E929D720, OS_LOG_TYPE_FAULT))
              {
                uint64_t v25 = a1 + 8;
                if (*(char *)(a1 + 31) < 0) {
                  uint64_t v25 = *v16;
                }
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)long long buf = 136446466;
                uint64_t v55 = v25;
                __int16 v56 = 1026;
                int v57 = v26;
                _os_log_impl(&dword_1902AF000, v24, OS_LOG_TYPE_FAULT, "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }
              if (sub_1902D8400(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1E929D728 != -1) {
                  dispatch_once(&qword_1E929D728, &unk_1EDFD3720);
                }
                uint64_t v45 = a1 + 8;
                if (*(char *)(a1 + 31) < 0) {
                  uint64_t v45 = *v16;
                }
                int v46 = *((_DWORD *)v14 + 7);
                int v50 = 136446466;
                uint64_t v51 = v45;
                __int16 v52 = 1026;
                int v53 = v46;
                long long v47 = (char *)_os_log_send_and_compose_impl();
                sub_1902D398C("Generic", 1, 0, 0, "void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v47);
                if (v47 != (char *)buf) {
                  free(v47);
                }
              }
            }
          }
          while (v14 != (void *)(v49 + 48));
        }
      }
    }
  }
}

uint64_t sub_19053CF90(uint64_t result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!*(unsigned char *)(result + 108))
  {
    uint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32);
    LODWORD(v14) = *(_DWORD *)(*(void *)a3 + 32);
    uint64_t v9 = sub_19053D154(a4);
    uint64_t v10 = *(void *)a3 + 80;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40);
    int v15 = (int *)(*(void *)a2 + 32);
    int v12 = sub_1904BAC2C(v11, v15, (uint64_t)&unk_1906099C2, &v15);
    os_log_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t **))(*(void *)v7 + 192))(v7, v8, &v14, v9, v10, v12 + 4);
    if (result) {
      return objc_msgSend_onNotification_withData_(*(void **)(*(void *)a2 + 64), v13, *(unsigned int *)(*(void *)a3 + 32), a4, v14);
    }
  }
  return result;
}

os_log_t sub_19053D088()
{
  os_log_t result = os_log_create("com.apple.locationd.Core", "Notifier");
  qword_1E929D720 = (uint64_t)result;
  return result;
}

void sub_19053D0B8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0E48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_19053D0D8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFD0E48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_19053D134(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    JUMPOUT(0x192FCC980);
  }
  return result;
}

uint64_t sub_19053D154(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    return sub_19053D1F0(a1, v2, v3);
  }
  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      return sub_19053D55C(a1, v5, v6);
    }
    else
    {
      return 0;
    }
  }
}

uint64_t sub_19053D1F0(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend_binaryVersion(a1, a2, a3);
  objc_msgSend_sizeOfType(a1, v5, v6);
  if (!v4) {
    return sub_19053D8FC((uint64_t)&v12, a1, v7);
  }
  if (!getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_1E929D8A8 != -1) {
      dispatch_once(&qword_1E929D8A8, &unk_1EDFC37C8);
    }
    uint64_t v10 = qword_1E929D8B0;
    if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 134218498;
      uint64_t v20 = v4;
      __int16 v21 = 2048;
      uint64_t v22 = 0;
      __int16 v23 = 2080;
      unint64_t v24 = (unint64_t)"N31CLGeomagneticModelProvider_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl(&dword_1902AF000, v10, OS_LOG_TYPE_FAULT, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
    }
    if (!sub_1902D8400(115, 0)) {
      return 0;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8A8 == -1) {
      goto LABEL_18;
    }
    goto LABEL_20;
  }
  if (qword_1E929D8A8 != -1) {
    dispatch_once(&qword_1E929D8A8, &unk_1EDFC37C8);
  }
  uint64_t v8 = qword_1E929D8B0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 134218498;
    uint64_t v20 = v4;
    __int16 v21 = 2048;
    uint64_t v22 = 0;
    __int16 v23 = 2080;
    unint64_t v24 = (unint64_t)"N31CLGeomagneticModelProvider_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_ERROR, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
  }
  if (!sub_1902D8400(115, 0)) {
    return 0;
  }
  bzero(buf, 0x65CuLL);
  if (qword_1E929D8A8 != -1) {
LABEL_20:
  }
    dispatch_once(&qword_1E929D8A8, &unk_1EDFC37C8);
LABEL_18:
  int v13 = 134218498;
  uint64_t v14 = v4;
  __int16 v15 = 2048;
  uint64_t v16 = 0;
  __int16 v17 = 2080;
  unint64_t v18 = (unint64_t)"N31CLGeomagneticModelProvider_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
  BOOL v11 = (char *)_os_log_send_and_compose_impl();
  sub_1902D398C("Generic", 1, 0, 0, "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLGeomagneticModelProvider_Type::NotificationData, Callbacuint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Shared/Intersilo/CLCppContainer.h:241:46)]", "CoreLocation: %s\n", v11);
  if (v11 != (char *)buf) {
    free(v11);
  }
  return 0;
}

uint64_t sub_19053D55C(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend_binaryVersion(a1, a2, a3);
  objc_msgSend_sizeOfType(a1, v5, v6);
  if (v4)
  {
    if (getenv("_INTERSILO_UNIT_TEST"))
    {
      if (qword_1E929D8A8 != -1) {
        dispatch_once(&qword_1E929D8A8, &unk_1EDFC37C8);
      }
      uint64_t v9 = qword_1E929D8B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 134218498;
        uint64_t v14 = v4;
        __int16 v15 = 2048;
        uint64_t v16 = 0;
        __int16 v17 = 2080;
        unint64_t v18 = (unint64_t)"N31CLGeomagneticModelProvider_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
        _os_log_impl(&dword_1902AF000, v9, OS_LOG_TYPE_ERROR, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
      }
      if (!sub_1902D8400(115, 0)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8A8 == -1)
      {
LABEL_20:
        char v12 = (char *)_os_log_send_and_compose_impl();
        sub_1902D398C("Generic", 1, 0, 0, "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLGeomagneticModelProvider_Type::NotificationData, Callbacuint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Shared/Intersilo/CLCppContainer.h:250:46)]", "CoreLocation: %s\n", v12);
        if (v12 != (char *)buf) {
          free(v12);
        }
        return 0;
      }
    }
    else
    {
      if (qword_1E929D8A8 != -1) {
        dispatch_once(&qword_1E929D8A8, &unk_1EDFC37C8);
      }
      BOOL v11 = qword_1E929D8B0;
      if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 134218498;
        uint64_t v14 = v4;
        __int16 v15 = 2048;
        uint64_t v16 = 0;
        __int16 v17 = 2080;
        unint64_t v18 = (unint64_t)"N31CLGeomagneticModelProvider_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
        _os_log_impl(&dword_1902AF000, v11, OS_LOG_TYPE_FAULT, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
      }
      if (!sub_1902D8400(115, 0)) {
        return 0;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1E929D8A8 == -1) {
        goto LABEL_20;
      }
    }
    dispatch_once(&qword_1E929D8A8, &unk_1EDFC37C8);
    goto LABEL_20;
  }

  return objc_msgSend_cppObjectPtr(a1, v7, v8);
}

uint64_t sub_19053D8FC(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!objc_msgSend_cppObjectPtr(a2, (const char *)a2, a3))
  {
    uint64_t v6 = objc_msgSend_compatibilityInfo(a2, v4, v5);
    if (objc_msgSend_isEqual_(v6, v7, (uint64_t)&unk_1EE001DC8))
    {
      uint64_t v8 = objc_msgSend_serialized(a2, v4, v5);
      if (objc_msgSend_length(v8, v9, v10) != 64)
      {
        if (qword_1E929D8A8 != -1) {
          dispatch_once(&qword_1E929D8A8, &unk_1EDFC37C8);
        }
        uint64_t v19 = qword_1E929D8B0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)long long buf = 68289539;
          int v23 = 0;
          __int16 v24 = 2082;
          uint64_t v25 = "";
          __int16 v26 = 2082;
          uint64_t v27 = "assert";
          __int16 v28 = 2081;
          uint64_t v29 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_log_impl(&dword_1902AF000, v19, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
          if (qword_1E929D8A8 != -1) {
            dispatch_once(&qword_1E929D8A8, &unk_1EDFC37C8);
          }
        }
        uint64_t v20 = qword_1E929D8B0;
        if (os_signpost_enabled((os_log_t)qword_1E929D8B0))
        {
          *(_DWORD *)long long buf = 68289539;
          int v23 = 0;
          __int16 v24 = 2082;
          uint64_t v25 = "";
          __int16 v26 = 2082;
          uint64_t v27 = "assert";
          __int16 v28 = 2081;
          uint64_t v29 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_signpost_emit_with_name_impl(&dword_1902AF000, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "The total size of the POD types on the 2 architectures is expected to be the same.", "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
          if (qword_1E929D8A8 != -1) {
            dispatch_once(&qword_1E929D8A8, &unk_1EDFC37C8);
          }
        }
        __int16 v21 = qword_1E929D8B0;
        if (os_log_type_enabled((os_log_t)qword_1E929D8B0, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 68289539;
          int v23 = 0;
          __int16 v24 = 2082;
          uint64_t v25 = "";
          __int16 v26 = 2082;
          uint64_t v27 = "assert";
          __int16 v28 = 2081;
          uint64_t v29 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_log_impl(&dword_1902AF000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        }
        abort_report_np();
      }
      int v13 = objc_msgSend_serialized(a2, v11, v12);
      uint64_t v16 = objc_msgSend_bytes(v13, v14, v15);
      objc_msgSend_setCppObjectPtr_(a2, v17, v16);
    }
  }

  return objc_msgSend_cppObjectPtr(a2, v4, v5);
}

os_log_t sub_19053DBC0()
{
  os_log_t result = os_log_create("com.apple.locationd.Support", "Support");
  qword_1E929D8B0 = (uint64_t)result;
  return result;
}

void sub_19053DBF0()
{
}

uint64_t sub_19053DCA4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    JUMPOUT(0x192FCC980);
  }
  return result;
}

void sub_19053DFB8(uint64_t a1, mach_error_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD21C0);
    }
    uint64_t v4 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_INFO))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 134218242;
      uint64_t v10 = v5;
      __int16 v11 = 2080;
      uint64_t v12 = mach_error_string(a2);
      _os_log_impl(&dword_1902AF000, v4, OS_LOG_TYPE_INFO, "[CLHidManager] setReport: id=0x%lx, failed=%s", buf, 0x16u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD21C0);
      }
      mach_error_string(a2);
LABEL_18:
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 2, "-[CLHidDevice setReport:payload:length:]_block_invoke", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf) {
        free(v8);
      }
    }
  }
  else
  {
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD21C0);
    }
    uint64_t v6 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 134218240;
      uint64_t v10 = v7;
      __int16 v11 = 1024;
      LODWORD(v12) = 1;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_INFO, "[CLHidManager] setReport: id=0x%lx, success=%d", buf, 0x12u);
    }
    if (sub_1902D8400(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD21C0);
      }
      goto LABEL_18;
    }
  }
}

uint64_t sub_19053E570(uint64_t result, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 32);
  if (v3)
  {
    uint64_t v5 = objc_msgSend_clientDevices(*(void **)(result + 32), a2, a3);
    uint64_t result = objc_msgSend_count(v5, v6, v7);
    if (result)
    {
      return MEMORY[0x1F4181798](v3, sel_updateClientDeviceWithHidDevice_added_, a2);
    }
  }
  return result;
}

uint64_t sub_19053E6DC(uint64_t result, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(result + 32);
  if (v3)
  {
    uint64_t v4 = result;
    objc_msgSend_delegate(*(void **)(result + 32), a2, a3);
    uint64_t result = objc_opt_respondsToSelector();
    if (result)
    {
      uint64_t v7 = objc_msgSend_delegate(v3, v5, v6);
      uint64_t v8 = *(void *)(v4 + 40);
      return MEMORY[0x1F4181798](v7, sel_monitorUpdateForDevice_added_, v8);
    }
  }
  return result;
}

void sub_19053E948(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6)
  {
    if (objc_msgSend_hidDevice(*(void **)(a1 + 40), a2, a3))
    {
      objc_msgSend_delegate(*(void **)(a1 + 48), v9, v10);
      if (objc_opt_respondsToSelector())
      {
        if (objc_msgSend_delegateQueue(*(void **)(a1 + 48), v11, v12))
        {
          uint64_t v15 = objc_msgSend_delegateQueue(*(void **)(a1 + 48), v13, v14);
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 3221225472;
          block[2] = sub_19053EA14;
          block[3] = &unk_1E568F490;
          void block[4] = a6;
          void block[5] = v6;
          void block[6] = *(void *)(a1 + 40);
          dispatch_async(v15, block);
        }
      }
    }
  }
}

void sub_19053EA14(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  memset(v28, 0, sizeof(v28));
  if ((unint64_t)objc_msgSend_length(*(void **)(a1 + 32), a2, a3) < 0x81)
  {
    uint64_t v13 = *(void **)(a1 + 32);
    uint64_t v14 = objc_msgSend_length(v13, v4, v5);
    objc_msgSend_getBytes_length_(v13, v15, (uint64_t)v28, v14);
    unint64_t v18 = objc_msgSend_delegate(*(void **)(a1 + 40), v16, v17);
    uint64_t v19 = *(void *)(a1 + 48);
    uint64_t v22 = objc_msgSend_length(*(void **)(a1 + 32), v20, v21);
    objc_msgSend_inputReportForDevice_report_length_(v18, v23, v19, v28, v22);
  }
  else
  {
    if (qword_1EB3BE898 != -1) {
      dispatch_once(&qword_1EB3BE898, &unk_1EDFD21C0);
    }
    uint64_t v6 = off_1EB3BE890;
    if (os_log_type_enabled((os_log_t)off_1EB3BE890, OS_LOG_TYPE_FAULT))
    {
      uint64_t v9 = objc_msgSend_length(*(void **)(a1 + 32), v7, v8);
      *(_DWORD *)long long buf = 134218240;
      uint64_t v25 = v9;
      __int16 v26 = 2048;
      uint64_t v27 = 128;
      _os_log_impl(&dword_1902AF000, v6, OS_LOG_TYPE_FAULT, "[CLHidManager], HID report length %lu exceeds %zu byte maximum", buf, 0x16u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE898 != -1) {
        dispatch_once(&qword_1EB3BE898, &unk_1EDFD21C0);
      }
      objc_msgSend_length(*(void **)(a1 + 32), v10, v11);
      uint64_t v12 = (char *)_os_log_send_and_compose_impl();
      sub_1902D398C("Generic", 1, 0, 0, "-[CLHidManager activateClientDevice:]_block_invoke", "CoreLocation: %s\n", v12);
      if (v12 != (char *)buf) {
        free(v12);
      }
    }
  }
}

void sub_19053F0E8(uint64_t a1)
{
  sub_1905D3F44(a1);

  JUMPOUT(0x192FCC980);
}

void sub_190540068(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

void sub_190540154(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_190540334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19054052C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

os_log_t sub_1905407A0()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "Health");
  qword_1E929D930 = (uint64_t)result;
  return result;
}

void ***sub_1905407D0(void ***result, void **a2)
{
  uint64_t v2 = *result;
  *os_log_t result = a2;
  if (v2)
  {
    uint64_t v3 = v2;
    sub_1904F1028(&v3);
    return (void ***)MEMORY[0x192FCC980](v2, 0x20C40960023A9);
  }
  return result;
}

uint64_t sub_190541314()
{
  id v0 = objc_alloc(MEMORY[0x1E4F73038]);
  uint64_t result = objc_msgSend_initWithIdentifier_(v0, v1, @"CLGeomagneticModelProviderSilo");
  qword_1EB3BF550 = result;
  return result;
}

uint64_t sub_190541808(uint64_t result)
{
  *(unsigned char *)(result + 108) = 1;
  return result;
}

uint64_t sub_190541814(uint64_t result)
{
  *(unsigned char *)(result + 108) = 1;
  return result;
}

uint64_t sub_190541820(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = &unk_1EDFC7858;
  sub_1902C3F54((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = objc_msgSend_silo(a3, v5, v6);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 108) = 0;
  return a1;
}

void sub_1905418B0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1905418CC(uint64_t a1, const char *a2, uint64_t a3)
{
  *(void *)a1 = &unk_1EDFC7858;
  objc_msgSend_invalidate(*(void **)(a1 + 48), a2, a3);

  sub_190541C6C(a1 + 80, *(void **)(a1 + 88));
  sub_190541CCC(a1 + 56, *(void **)(a1 + 64));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void *sub_190541950@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x20uLL, "%d", *a1);
  return sub_1902C3F54(a2, __str);
}

void sub_1905419CC()
{
}

void sub_190541A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  MEMORY[0x192FCC980](v15, 0x1081C407D05813FLL);
  _Unwind_Resume(a1);
}

uint64_t sub_190541AC4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = &unk_1EDFC8E90;
  uint64_t v12 = [CLNotifierClientAdapter alloc];
  *(void *)(a1 + 8) = objc_msgSend_initWithClient_(v12, v13, a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  if (*(char *)(a3 + 23) >= 0) {
    uint64_t v15 = objc_msgSend_stringWithUTF8String_(NSString, v14, a3);
  }
  else {
    uint64_t v15 = objc_msgSend_stringWithUTF8String_(NSString, v14, *(void *)a3);
  }
  uint64_t v18 = v15;
  uint64_t v19 = objc_msgSend_vendor(a4, v16, v17);
  uint64_t v21 = objc_msgSend_proxyForService_(v19, v20, v18);
  *(void *)(a1 + 16) = v21;
  id v22 = v21;
  if (a2) {
    objc_msgSend_setDelegateEntityName_(*(void **)(a1 + 16), v23, a2);
  }
  uint64_t v26 = *(void *)(a1 + 8);
  uint64_t v25 = *(void **)(a1 + 16);
  uint64_t v27 = objc_msgSend_silo(a4, v23, v24);
  objc_msgSend_registerDelegate_inSilo_(v25, v28, v26, v27);
  return a1;
}

void sub_190541BAC(uint64_t a1, const char *a2)
{
  sub_190541D64(a1, a2);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_190541BE4(uint64_t a1, int a2, void *a3)
{
  uint64_t result = sub_19053D154(a3);
  if (result)
  {
    int v6 = a2;
    return (*(uint64_t (**)(void, int *, uint64_t, void))(a1 + 24))(0, &v6, result, *(void *)(a1 + 32));
  }
  return result;
}

os_log_t sub_190541C34()
{
  os_log_t result = os_log_create("com.apple.locationd.Core", "Notifier");
  qword_1E929D720 = (uint64_t)result;
  return result;
}

void sub_190541C6C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_190541C6C(a1, *a2);
    sub_190541C6C(a1, a2[1]);
    sub_1904B9BBC((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }
}

void sub_190541CCC(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_190541CCC(a1, *a2);
    sub_190541CCC(a1, a2[1]);
    sub_1904BABAC((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_190541D2C(uint64_t a1, const char *a2)
{
  sub_190541D64(a1, a2);

  JUMPOUT(0x192FCC980);
}

uint64_t sub_190541D64(uint64_t a1, const char *a2)
{
  *(void *)a1 = &unk_1EDFC8E90;
  uint64_t v3 = (void **)(a1 + 8);
  objc_msgSend_forget_(*(void **)(a1 + 16), a2, *(void *)(a1 + 8));

  objc_msgSend_invalidate(*v3, v4, v5);
  void *v3 = 0;
  *(void *)(a1 + 16) = 0;
  return a1;
}

unsigned char *sub_190541DD4(unsigned char *__dst, unsigned __int8 *a2, size_t a3)
{
  if (a3 && ((unsigned int v4 = *a2 - 1, v4 > 8) ? (v5 = 0) : (v5 = qword_19060BD50[(char)v4]), v5 == a3)) {
    memcpy(__dst, a2, a3);
  }
  else {
    *long long __dst = -1;
  }
  return __dst;
}

unsigned char *sub_190541E40(unsigned char *result, uint64_t a2)
{
  switch(*result)
  {
    case 1:
      os_log_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a2 + 16))(a2, result);
      break;
    case 2:
      os_log_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a2 + 24))(a2, result);
      break;
    case 3:
      os_log_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a2 + 32))(a2, result);
      break;
    case 4:
      os_log_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a2 + 40))(a2, result);
      break;
    case 5:
      os_log_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a2 + 48))(a2, result);
      break;
    case 6:
      os_log_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a2 + 56))(a2, result);
      break;
    case 7:
      os_log_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a2 + 64))(a2, result);
      break;
    case 8:
      os_log_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a2 + 72))(a2, result);
      break;
    case 9:
      os_log_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a2 + 80))(a2, result);
      break;
    default:
      return result;
  }
  return result;
}

BOOL sub_190542028()
{
  id v0 = (void *)MEMORY[0x192FCD2F0]();
  sub_190542070();
  BOOL v1 = qword_1E929EA98 != 0;
  objc_msgSend_showCalibrationAlert((void *)qword_1E929EA98, v2, v3);
  return v1;
}

void sub_190542070()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (qword_1E929E928) {
    return;
  }
  qword_1E929E928 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/CompassUI.framework/CompassUI", 1);
  if (qword_1E929E928)
  {
    qword_1E929EA98 = (uint64_t)NSClassFromString(&cfstr_Cuicalibration.isa);
    if (!qword_1E929EA98)
    {
      if (qword_1EB3BE858 != -1) {
        dispatch_once(&qword_1EB3BE858, &unk_1EDFD2220);
      }
      id v0 = qword_1EB3BE850;
      if (os_log_type_enabled((os_log_t)qword_1EB3BE850, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1902AF000, v0, OS_LOG_TYPE_FAULT, "Could not load CUICalibrationClass from CompassUI framework", buf, 2u);
      }
      if (sub_1902D8400(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EB3BE858 == -1)
        {
LABEL_18:
          uint64_t v2 = (char *)_os_log_send_and_compose_impl();
          sub_1902D398C("Generic", 1, 0, 0, "void CLClientLoadCompassUIIfNecessary(void)", "CoreLocation: %s\n", v2);
          if (v2 != (char *)buf) {
            free(v2);
          }
          return;
        }
LABEL_20:
        dispatch_once(&qword_1EB3BE858, &unk_1EDFD2220);
        goto LABEL_18;
      }
    }
  }
  else
  {
    if (qword_1EB3BE858 != -1) {
      dispatch_once(&qword_1EB3BE858, &unk_1EDFD2220);
    }
    BOOL v1 = qword_1EB3BE850;
    if (os_log_type_enabled((os_log_t)qword_1EB3BE850, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1902AF000, v1, OS_LOG_TYPE_FAULT, "Unable to load CompassUI framework", buf, 2u);
    }
    if (sub_1902D8400(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EB3BE858 == -1) {
        goto LABEL_18;
      }
      goto LABEL_20;
    }
  }
}

void sub_190542308()
{
  id v0 = (void *)MEMORY[0x192FCD2F0]();
  sub_190542070();
  objc_msgSend_dismissCalibrationAlert((void *)qword_1E929EA98, v1, v2);
}

os_log_t sub_190542350()
{
  os_log_t result = os_log_create("com.apple.locationd.Core", "Client");
  qword_1EB3BE850 = (uint64_t)result;
  return result;
}

BOOL sub_1905426E8(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t v5 = 0;
  if (a1 && a2 - a3 >= a5)
  {
    if (*(unsigned char *)(a1 + a3) == 64
      && (uint64_t v6 = a3 + a1, *(unsigned __int8 *)(v6 + 1) <= 0x30u)
      && *(unsigned __int8 *)(v6 + 2) == a5)
    {
      return *(unsigned __int8 *)(a3 + a1 + 3) == a4;
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

BOOL sub_190542748(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a3 >= 35)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    *(_DWORD *)a2 = 19083328;
    *(unsigned char *)(a2 + 4) = 0;
    *(void *)(a2 + 5) = *(void *)(a1 + 8);
    *(void *)(a2 + 13) = *(void *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 40);
    do
    {
      unsigned int v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      unsigned int v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 33);
    *(_WORD *)(a2 + 33) = v6 | ((_WORD)v5 << 8);
    *a4 = 35;
  }
  return a3 > 34;
}

BOOL sub_1905427F0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_1905426E8(a2, a3, a4, 1, 35);
  if (result)
  {
    uint64_t v8 = (unsigned __int8 *)(a2 + a4);
    *(void *)(a1 + 8) = *(void *)(v8 + 5);
    *(void *)(a1 + 24) = *(void *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    uint64_t v9 = a4 + 33;
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 29);
    if (a4 < -32)
    {
      int v14 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      uint64_t v12 = v9;
      do
      {
        int v13 = *v8++;
        unsigned int v11 = (v11 + v13) % 0xFF;
        unsigned int v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      int v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    int v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_1905428E4(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a3 >= 41)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    char v7 = *(unsigned char *)(a1 + 49);
    if (*(unsigned char *)(a1 + 50)) {
      v7 |= 2u;
    }
    *(_DWORD *)a2 = 36253760;
    *(unsigned char *)(a2 + 4) = 0;
    *(void *)(a2 + 5) = *(void *)(a1 + 8);
    *(void *)(a2 + 13) = *(void *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a2 + 33) = *(_DWORD *)(a1 + 44);
    *(unsigned char *)(a2 + 37) = *(unsigned char *)(a1 + 48);
    *(unsigned char *)(a2 + 38) = v7;
    do
    {
      unsigned int v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      unsigned int v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 39);
    *(_WORD *)(a2 + 39) = v6 | ((_WORD)v5 << 8);
    *a4 = 41;
  }
  return a3 > 40;
}

BOOL sub_1905429B4(uint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_1905426E8(a2, a3, a4, 2, 41);
  if (result)
  {
    uint64_t v8 = (unsigned __int8 *)(a2 + a4);
    *(void *)(a1 + 8) = *(void *)(v8 + 5);
    *(void *)(a1 + 24) = *(void *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 29);
    *(_DWORD *)(a1 + 44) = *(_DWORD *)(v8 + 33);
    *(unsigned char *)(a1 + 48) = v8[37];
    unsigned __int8 v9 = v8[38];
    uint64_t v10 = a4 + 39;
    *(unsigned char *)(a1 + 49) = v9 & 1;
    *(unsigned char *)(a1 + 50) = (v9 & 2) != 0;
    if (a4 < -38)
    {
      int v15 = 0;
    }
    else
    {
      unsigned int v11 = 0;
      unsigned int v12 = 0;
      uint64_t v13 = v10;
      do
      {
        int v14 = *v8++;
        unsigned int v12 = (v12 + v14) % 0xFF;
        unsigned int v11 = (v12 + v11) % 0xFF;
        --v13;
      }
      while (v13);
      int v15 = (unsigned __int16)v12 | ((unsigned __int16)v11 << 8);
    }
    int v16 = *(unsigned __int16 *)(v10 + a2);
    *(_WORD *)(a1 + 16) = v16;
    return v16 == v15;
  }
  return result;
}

BOOL sub_190542ACC(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a3 >= 19)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    *(_DWORD *)a2 = 101920832;
    *(unsigned char *)(a2 + 4) = 0;
    *(void *)(a2 + 5) = *(void *)(a1 + 8);
    *(_DWORD *)(a2 + 13) = *(_DWORD *)(a1 + 20);
    do
    {
      unsigned int v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      unsigned int v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 17);
    *(_WORD *)(a2 + 17) = v6 | ((_WORD)v5 << 8);
    *a4 = 19;
  }
  return a3 > 18;
}

BOOL sub_190542B5C(uint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_1905426E8(a2, a3, a4, 6, 19);
  if (result)
  {
    uint64_t v8 = (unsigned __int8 *)(a2 + a4);
    *(void *)(a1 + 8) = *(void *)(v8 + 5);
    uint64_t v9 = a4 + 17;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(v8 + 13);
    if (a4 < -16)
    {
      int v14 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      uint64_t v12 = v9;
      do
      {
        int v13 = *v8++;
        unsigned int v11 = (v11 + v13) % 0xFF;
        unsigned int v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      int v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    int v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_190542C38(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a3 >= 40)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    *(_DWORD *)a2 = 203960384;
    *(unsigned char *)(a2 + 4) = 0;
    *(void *)(a2 + 5) = *(void *)(a1 + 8);
    *(_DWORD *)(a2 + 13) = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a2 + 17) = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 33) = *(_DWORD *)(a1 + 40);
    *(unsigned char *)(a2 + 37) = *(unsigned char *)(a1 + 44);
    do
    {
      unsigned int v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      unsigned int v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 38);
    *(_WORD *)(a2 + 38) = v6 | ((_WORD)v5 << 8);
    *a4 = 40;
  }
  return a3 > 39;
}

BOOL sub_190542CF8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_1905426E8(a2, a3, a4, 12, 40);
  if (result)
  {
    uint64_t v8 = (unsigned __int8 *)(a2 + a4);
    *(void *)(a1 + 8) = *(void *)(v8 + 5);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(v8 + 13);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(v8 + 17);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 25);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 29);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 33);
    *(unsigned char *)(a1 + 44) = v8[37];
    uint64_t v9 = a4 + 38;
    if (a4 < -37)
    {
      int v14 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      uint64_t v12 = v9;
      do
      {
        int v13 = *v8++;
        unsigned int v11 = (v11 + v13) % 0xFF;
        unsigned int v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      int v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    int v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_190542E04(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a3 >= 20)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    *(_DWORD *)a2 = 303312960;
    *(unsigned char *)(a2 + 4) = 0;
    *(void *)(a2 + 5) = *(void *)(a1 + 8);
    *(_DWORD *)(a2 + 13) = *(_DWORD *)(a1 + 20);
    do
    {
      unsigned int v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      unsigned int v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 18);
    *(_WORD *)(a2 + 18) = v6 | ((_WORD)v5 << 8);
    *a4 = 20;
  }
  return a3 > 19;
}

BOOL sub_190542E94(uint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_1905426E8(a2, a3, a4, 18, 20);
  if (result)
  {
    uint64_t v8 = (unsigned __int8 *)(a2 + a4);
    *(void *)(a1 + 8) = *(void *)(v8 + 5);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(v8 + 13);
    uint64_t v9 = a4 + 18;
    if (a4 < -17)
    {
      int v14 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      uint64_t v12 = v9;
      do
      {
        int v13 = *v8++;
        unsigned int v11 = (v11 + v13) % 0xFF;
        unsigned int v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      int v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    int v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_190542F70(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a3 >= 35)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    *(_DWORD *)a2 = 52637760;
    *(unsigned char *)(a2 + 4) = 0;
    *(void *)(a2 + 5) = *(void *)(a1 + 8);
    *(void *)(a2 + 13) = *(void *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 40);
    do
    {
      unsigned int v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      unsigned int v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 33);
    *(_WORD *)(a2 + 33) = v6 | ((_WORD)v5 << 8);
    *a4 = 35;
  }
  return a3 > 34;
}

BOOL sub_190543018(uint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_1905426E8(a2, a3, a4, 3, 35);
  if (result)
  {
    uint64_t v8 = (unsigned __int8 *)(a2 + a4);
    *(void *)(a1 + 8) = *(void *)(v8 + 5);
    *(void *)(a1 + 24) = *(void *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    uint64_t v9 = a4 + 33;
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 29);
    if (a4 < -32)
    {
      int v14 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      uint64_t v12 = v9;
      do
      {
        int v13 = *v8++;
        unsigned int v11 = (v11 + v13) % 0xFF;
        unsigned int v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      int v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    int v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_19054310C(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a3 >= 72)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    *(_DWORD *)a2 = 71839808;
    *(unsigned char *)(a2 + 4) = 0;
    *(void *)(a2 + 5) = *(void *)(a1 + 8);
    *(void *)(a2 + 13) = *(void *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a2 + 33) = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a2 + 37) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(a2 + 41) = *(_DWORD *)(a1 + 52);
    *(_DWORD *)(a2 + 45) = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a2 + 49) = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a2 + 53) = *(_DWORD *)(a1 + 64);
    *(unsigned char *)(a2 + 57) = *(unsigned char *)(a1 + 68);
    *(_DWORD *)(a2 + 58) = *(_DWORD *)(a1 + 72);
    *(_DWORD *)(a2 + 62) = *(_DWORD *)(a1 + 76);
    *(_DWORD *)(a2 + 66) = *(_DWORD *)(a1 + 80);
    do
    {
      unsigned int v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      unsigned int v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 70);
    *(_WORD *)(a2 + 70) = v6 | ((_WORD)v5 << 8);
    *a4 = 72;
  }
  return a3 > 71;
}

BOOL sub_190543204(uint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_1905426E8(a2, a3, a4, 4, 72);
  if (result)
  {
    uint64_t v8 = (unsigned __int8 *)(a2 + a4);
    *(void *)(a1 + 8) = *(void *)(v8 + 5);
    *(void *)(a1 + 24) = *(void *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 29);
    *(_DWORD *)(a1 + 44) = *(_DWORD *)(v8 + 33);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(v8 + 37);
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(v8 + 41);
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(v8 + 45);
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(v8 + 49);
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(v8 + 53);
    *(unsigned char *)(a1 + 68) = v8[57];
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(v8 + 58);
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(v8 + 62);
    uint64_t v9 = a4 + 70;
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(v8 + 66);
    if (a4 < -69)
    {
      int v14 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      uint64_t v12 = v9;
      do
      {
        int v13 = *v8++;
        unsigned int v11 = (v11 + v13) % 0xFF;
        unsigned int v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      int v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    int v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_190543348(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a3 >= 24)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    *(_DWORD *)a2 = 186134592;
    *(unsigned char *)(a2 + 4) = 0;
    *(void *)(a2 + 5) = *(void *)(a1 + 8);
    *(void *)(a2 + 13) = *(void *)(a1 + 24);
    *(unsigned char *)(a2 + 21) = *(unsigned char *)(a1 + 32);
    do
    {
      unsigned int v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      unsigned int v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 22);
    *(_WORD *)(a2 + 22) = v6 | ((_WORD)v5 << 8);
    *a4 = 24;
  }
  return a3 > 23;
}

BOOL sub_1905433E0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_1905426E8(a2, a3, a4, 11, 24);
  if (result)
  {
    uint64_t v8 = (unsigned __int8 *)(a2 + a4);
    *(void *)(a1 + 8) = *(void *)(v8 + 5);
    *(void *)(a1 + 24) = *(void *)(v8 + 13);
    *(unsigned char *)(a1 + 32) = v8[21];
    uint64_t v9 = a4 + 22;
    if (a4 < -21)
    {
      int v14 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      uint64_t v12 = v9;
      do
      {
        int v13 = *v8++;
        unsigned int v11 = (v11 + v13) % 0xFF;
        unsigned int v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      int v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    int v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_1905434C4(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a3 >= 102)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    *(_DWORD *)a2 = 90583104;
    *(unsigned char *)(a2 + 4) = 0;
    *(void *)(a2 + 5) = *(void *)(a1 + 8);
    *(void *)(a2 + 13) = *(void *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a2 + 33) = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a2 + 37) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(a2 + 41) = *(_DWORD *)(a1 + 52);
    *(_DWORD *)(a2 + 45) = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a2 + 49) = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a2 + 53) = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a2 + 57) = *(_DWORD *)(a1 + 68);
    *(_DWORD *)(a2 + 61) = *(_DWORD *)(a1 + 72);
    *(_DWORD *)(a2 + 65) = *(_DWORD *)(a1 + 76);
    *(_DWORD *)(a2 + 69) = *(_DWORD *)(a1 + 80);
    *(unsigned char *)(a2 + 73) = *(unsigned char *)(a1 + 84);
    *(_DWORD *)(a2 + 74) = *(_DWORD *)(a1 + 88);
    *(_DWORD *)(a2 + 78) = *(_DWORD *)(a1 + 92);
    *(_DWORD *)(a2 + 82) = *(_DWORD *)(a1 + 96);
    *(_DWORD *)(a2 + 86) = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a2 + 90) = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a2 + 94) = *(_DWORD *)(a1 + 108);
    *(_WORD *)(a2 + 98) = *(_WORD *)(a1 + 112);
    do
    {
      unsigned int v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      unsigned int v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 100);
    *(_WORD *)(a2 + 100) = v6 | ((_WORD)v5 << 8);
    *a4 = 102;
  }
  return a3 > 101;
}

BOOL sub_1905435FC(uint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_1905426E8(a2, a3, a4, 5, 102);
  if (result)
  {
    uint64_t v8 = (unsigned __int8 *)(a2 + a4);
    *(void *)(a1 + 8) = *(void *)(v8 + 5);
    *(void *)(a1 + 24) = *(void *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 29);
    *(_DWORD *)(a1 + 44) = *(_DWORD *)(v8 + 33);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(v8 + 37);
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(v8 + 41);
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(v8 + 45);
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(v8 + 49);
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(v8 + 53);
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(v8 + 57);
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(v8 + 61);
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(v8 + 65);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(v8 + 69);
    *(unsigned char *)(a1 + 84) = v8[73];
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(v8 + 74);
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(v8 + 78);
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(v8 + 82);
    *(_DWORD *)(a1 + 100) = *(_DWORD *)(v8 + 86);
    *(_DWORD *)(a1 + 104) = *(_DWORD *)(v8 + 90);
    *(_DWORD *)(a1 + 108) = *(_DWORD *)(v8 + 94);
    *(_WORD *)(a1 + 112) = *((_WORD *)v8 + 49);
    uint64_t v9 = a4 + 100;
    if (a4 < -99)
    {
      int v14 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      uint64_t v12 = v9;
      do
      {
        int v13 = *v8++;
        unsigned int v11 = (v11 + v13) % 0xFF;
        unsigned int v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      int v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    int v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_190543780(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a3 >= 31)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    *(_DWORD *)a2 = 270479424;
    *(unsigned char *)(a2 + 4) = 0;
    *(void *)(a2 + 5) = *(void *)(a1 + 8);
    *(void *)(a2 + 13) = *(void *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    do
    {
      unsigned int v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      unsigned int v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 29);
    *(_WORD *)(a2 + 29) = v6 | ((_WORD)v5 << 8);
    *a4 = 31;
  }
  return a3 > 30;
}

BOOL sub_190543820(uint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_1905426E8(a2, a3, a4, 16, 31);
  if (result)
  {
    uint64_t v8 = (unsigned __int8 *)(a2 + a4);
    *(void *)(a1 + 8) = *(void *)(v8 + 5);
    *(void *)(a1 + 24) = *(void *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    uint64_t v9 = a4 + 29;
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    if (a4 < -28)
    {
      int v14 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      uint64_t v12 = v9;
      do
      {
        int v13 = *v8++;
        unsigned int v11 = (v11 + v13) % 0xFF;
        unsigned int v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      int v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    int v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

uint64_t sub_19054390C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,Accelerometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(double *)(a1 + 24));
  return MEMORY[0x192FCC770](a2, __str);
}

uint64_t sub_1905439A8(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,Gyro,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,subType,%d,sampleNum%%3,%d,triggerEnabled,%d,triggerOn,%d", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(double *)(a1 + 24), *(_DWORD *)(a1 + 44), *(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49), *(unsigned __int8 *)(a1 + 50));
  return MEMORY[0x192FCC770](a2, __str);
}

uint64_t sub_190543A5C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,GyroTemperature,temperature,%f", *(double *)(a1 + 8), *(float *)(a1 + 20));
  return MEMORY[0x192FCC770](a2, __str);
}

uint64_t sub_190543AE0(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,GyroBias,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,variance.x,%20.20f,variance.y,%20.20f,variance.z,%20.20f,doingBiasEstimation,%d", *(double *)(a1 + 8), *(float *)(a1 + 20), *(float *)(a1 + 24), *(float *)(a1 + 28), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(char *)(a1 + 44));
  return MEMORY[0x192FCC770](a2, __str);
}

uint64_t sub_190543B94(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,GyroDt,dt,%20.20f", *(double *)(a1 + 8), *(float *)(a1 + 20));
  return MEMORY[0x192FCC770](a2, __str);
}

uint64_t sub_190543C18(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,Magnetometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(double *)(a1 + 24));
  return MEMORY[0x192FCC770](a2, __str);
}

uint64_t sub_190543CB4(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,Compass,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(float *)(a1 + 44), *(float *)(a1 + 48), *(float *)(a1 + 52), *(float *)(a1 + 56), *(float *)(a1 + 60), *(float *)(a1 + 64), *(char *)(a1 + 68), *(float *)(a1 + 72), *(float *)(a1 + 76), *(float *)(a1 + 80),
    *(double *)(a1 + 24));
  return MEMORY[0x192FCC770](a2, __str);
}

uint64_t sub_190543DA0(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,CompassAlignment,compassJustAlignedToStableField,%d,timestamp,%20.20f", *(double *)(a1 + 8), *(char *)(a1 + 32), *(double *)(a1 + 24));
  return MEMORY[0x192FCC770](a2, __str);
}

uint64_t sub_190543E2C(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = *(unsigned __int16 *)(a1 + 112);
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,DeviceMotion,q.x,%20.20f,q.y,%20.20f,q.z,%20.20f,q.w,%20.20f,userAccel.x,%20.20f,userAccel.y,%20.20f,userAccel.z,%20.20f,rotationRate.x,%20.20f,rotationRate.y,%20.20f,rotationRate.z,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,magneticFieldCalibrationLevel,%d,heading,%.3f,trueheading,%.3f,accuracy,%.3f,variant,%d,mode,%d,clientID,%#02x,biasEstimation,%d,yawCorrection,%d,gravityCorrection,%d,courseCorrection,%d,visualLocalizationCorrection,%d,initialized,%d,accelSaturated,%d,gyroSaturated,%d,compassCalibration,%d,gyroCalibration,%d,course,%d,gmm,%d,north,%d,visualLocalization,%d,timestamp,%20.20f", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(float *)(a1 + 44), *(float *)(a1 + 48), *(float *)(a1 + 52), *(float *)(a1 + 56), *(float *)(a1 + 60), *(float *)(a1 + 64), *(float *)(a1 + 68),
    *(float *)(a1 + 72),
    *(float *)(a1 + 76),
    *(float *)(a1 + 80),
    *(char *)(a1 + 84),
    *(float *)(a1 + 88),
    *(float *)(a1 + 92),
    *(float *)(a1 + 96),
    *(_DWORD *)(a1 + 100),
    *(_DWORD *)(a1 + 104),
    *(_DWORD *)(a1 + 108),
    (v3 >> 4) & 1,
    (v3 >> 3) & 1,
    (v3 >> 2) & 1,
    (v3 >> 5) & 1,
    (v3 >> 6) & 1,
    (v3 >> 8) & 1,
    (v3 >> 1) & 1,
    v3 & 1,
    (v3 >> 10) & 1,
    (v3 >> 9) & 1,
    (v3 >> 11) & 1,
    (v3 >> 12) & 1,
    (v3 >> 13) & 1,
    (v3 >> 14) & 1,
    *(double *)(a1 + 24));
  return MEMORY[0x192FCC770](a2, __str);
}

uint64_t sub_190543FA4(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,PressureFiltered,pressure,%20.20f,temperature,%20.20f,timestamp,%20.20lf", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(double *)(a1 + 24));
  return MEMORY[0x192FCC770](a2, __str);
}

void sub_190544038()
{
}

uint64_t sub_19054404C()
{
  return 35;
}

void sub_190544058()
{
}

uint64_t sub_19054406C()
{
  return 41;
}

void sub_190544078()
{
}

uint64_t sub_19054408C()
{
  return 19;
}

void sub_190544098()
{
}

uint64_t sub_1905440AC()
{
  return 20;
}

void sub_1905440B8()
{
}

uint64_t sub_1905440CC()
{
  return 35;
}

void sub_1905440D8()
{
}

uint64_t sub_1905440EC()
{
  return 72;
}

uint64_t sub_1905440F4()
{
  return 31;
}

void sub_190544100()
{
}

uint64_t sub_190544114()
{
  return 102;
}

void sub_190544120()
{
}

uint64_t sub_190544134()
{
  return 40;
}

void sub_190544140()
{
}

uint64_t sub_190544154()
{
  return 24;
}

void sub_190544160()
{
}

void sub_190544174(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  sub_1904F6C48(a1, a2, a3);
}

void sub_19054426C(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = 0;
  if (v6)
  {
    *(_OWORD *)(v6 + 5928) = 0u;
    MEMORY[0x192FCC980]();
  }
  uint64_t v7 = *v4;
  *uint64_t v4 = 0;
  if (v7)
  {
    *(_OWORD *)(v7 + 7576) = 0u;
    MEMORY[0x192FCC980]();
  }
  sub_190544F98((uint64_t *)(v1 + 37496), 0);
  uint64_t v8 = *v2;
  uint64_t *v2 = 0;
  if (v8)
  {
    uint64_t v9 = *(void *)(v8 + 96);
    if (v9) {
      *(_OWORD *)(v9 + 10912) = 0u;
    }
    MEMORY[0x192FCC980]();
  }
  sub_19050212C((void **)(v1 + 27552));
  sub_1905021A8((void *)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_190544344(uint64_t a1, unsigned int a2)
{
  sub_1904F71FC((unsigned int *)a1, a2);
  if (!*(void *)(a1 + 37488) || !*(unsigned char *)(a1 + 5))
  {
    sub_190544518(a1);
  }
}

uint64_t sub_1905443A0(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(a1 + 37488);
  uint64_t v3 = *(void *)(a1 + 37488);
  uint64_t *v2 = 0;
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 96);
    if (v4) {
      *(_OWORD *)(v4 + 10912) = 0u;
    }
    MEMORY[0x192FCC980]();
  }
  uint64_t v5 = v2[3];
  v2[3] = 0;
  if (v5)
  {
    *(_OWORD *)(v5 + 7576) = 0u;
    MEMORY[0x192FCC980]();
  }
  uint64_t v6 = v2[4];
  v2[4] = 0;
  if (v6)
  {
    *(_OWORD *)(v6 + 5928) = 0u;
    MEMORY[0x192FCC980]();
  }
  sub_190544F98((uint64_t *)(a1 + 37496), 0);
  uint64_t v7 = v2[4];
  v2[4] = 0;
  if (v7)
  {
    *(_OWORD *)(v7 + 5928) = 0u;
    MEMORY[0x192FCC980]();
  }
  uint64_t v8 = v2[3];
  v2[3] = 0;
  if (v8)
  {
    *(_OWORD *)(v8 + 7576) = 0u;
    MEMORY[0x192FCC980]();
  }
  sub_190544F98((uint64_t *)(a1 + 37496), 0);
  uint64_t v9 = *v2;
  uint64_t *v2 = 0;
  if (v9)
  {
    uint64_t v10 = *(void *)(v9 + 96);
    if (v10) {
      *(_OWORD *)(v10 + 10912) = 0u;
    }
    MEMORY[0x192FCC980]();
  }
  sub_19050212C((void **)(a1 + 27552));
  sub_1905021A8((void *)(a1 + 8));
  return a1;
}

void sub_190544518(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 37480);
  uint64_t v3 = *(void *)(a1 + 37488);
  v2[1] = 0;
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 96);
    if (v4) {
      *(_OWORD *)(v4 + 10912) = 0u;
    }
    MEMORY[0x192FCC980]();
  }
  if (*(unsigned char *)(a1 + 4) == 1)
  {
    uint64_t v5 = v2[4];
    v2[4] = 0;
    if (v5)
    {
      *(_OWORD *)(v5 + 7576) = 0u;
      MEMORY[0x192FCC980]();
    }
    sub_190544F98((uint64_t *)(a1 + 37496), 0);
    operator new();
  }
  uint64_t v6 = v2[5];
  v2[5] = 0;
  if (v6)
  {
    *(_OWORD *)(v6 + 5928) = 0u;
    MEMORY[0x192FCC980]();
  }
  operator new();
}

void sub_190544B34(_Unwind_Exception *a1)
{
  MEMORY[0x192FCC980](v1, 0x10A0C40B2A28986);
  _Unwind_Resume(a1);
}

void sub_190544B98(int a1, unint64_t a2, uint64_t a3)
{
}

void sub_190544BB8(int a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 + 37488;
  if (*(void *)(a3 + 37512))
  {
    char v5 = a1;
    sub_190560E24(*(void *)v3, *(unsigned __int8 *)(a3 + 37504), *(unsigned __int8 *)(a3 + 37505), a1, a2);
    if (*(unsigned char *)(v3 + 16))
    {
      uint64_t v6 = *(void *)(v3 + 8);
      sub_1904C832C(v6, v5, a2);
    }
  }
}

void sub_190544C40(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = a1 + 37488;
  uint64_t v7 = (unsigned char *)(a1 + 16058);
  if (sub_1904F9288(a1, a3)) {
    sub_19055FF48(*(void *)v6, a3);
  }
  if (*v7)
  {
    if (*(_DWORD *)(*(void *)v6 + 112) == 2) {
      uint64_t v8 = 2500000;
    }
    else {
      uint64_t v8 = 5000000;
    }
  }
  else
  {
    uint64_t v8 = 7500000;
  }
  if (sub_1904F959C(a1, a2, a3, v8))
  {
    if (*v7)
    {
      sub_190560130(*(void *)v6, a3);
    }
    else if (*(unsigned char *)(v6 + 16))
    {
      uint64_t v9 = *(void *)(v6 + 8);
      if (v9) {
        sub_1904C8528(v9, a3);
      }
    }
  }
  if (v7[4] && *v7)
  {
    uint64_t v10 = *(void *)v6;
    sub_190560310(v10, a3);
  }
}

void sub_190544D54(uint64_t a1, unsigned int a2, unsigned int a3, unint64_t a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (qword_1E929D8D8 != -1) {
    dispatch_once(&qword_1E929D8D8, &unk_1EDFD2240);
  }
  uint64_t v8 = qword_1E929D8E0;
  if (os_log_type_enabled((os_log_t)qword_1E929D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67240704;
    unsigned int v12 = a2;
    __int16 v13 = 1026;
    unsigned int v14 = a3;
    __int16 v15 = 2050;
    unint64_t v16 = a4;
    _os_log_impl(&dword_1902AF000, v8, OS_LOG_TYPE_DEFAULT, "[HeadTrackingService] JBLMs, %{public}d, limitMs, %{public}d, timestampUs, %{public}llu", buf, 0x18u);
  }
  if (sub_1902D8400(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1E929D8D8 != -1) {
      dispatch_once(&qword_1E929D8D8, &unk_1EDFD2240);
    }
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    sub_1902D398C("Generic", 1, 0, 2, "void CMHeadTrackingService::feedJBLChangedEventAndThreshold(uint16_t, uint16_t, uint64_t)", "CoreLocation: %s\n", v10);
    if (v10 != (char *)buf) {
      free(v10);
    }
  }
  if (*(unsigned char *)(a1 + 4))
  {
    uint64_t v9 = *(void *)(a1 + 37488);
    if (v9) {
      sub_1905604F0(v9, a2 > a3, a4);
    }
  }
}

os_log_t sub_190544F68()
{
  os_log_t result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1E929D8E0 = (uint64_t)result;
  return result;
}

uint64_t *sub_190544F98(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *os_log_t result = a2;
  if (v2)
  {
    uint64_t v3 = 0;
    *(_OWORD *)(v2 + 10912) = 0u;
    while (1)
    {
      uint64_t v4 = *(void *)(v2 + v3 + 10904);
      *(void *)(v2 + v3 + 10904) = 0;
      if (v4) {
        MEMORY[0x192FCC980](v4, 0x1000C40FF89C88ELL);
      }
      v3 -= 8;
      if (v3 == -24)
      {
        JUMPOUT(0x192FCC980);
      }
    }
  }
  return result;
}

void sub_190545030()
{
}

void *sub_190545044(uint64_t a1)
{
  os_log_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *os_log_t result = &unk_1EDFD09B8;
  result[1] = v3;
  return result;
}