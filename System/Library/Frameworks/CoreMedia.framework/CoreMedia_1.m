CFNumberRef FigCFNumberCreateUInt64(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t *v2;
  CFNumberType v3;
  void valuePtr[2];
  uint64_t v6;

  v6 = a2;
  if (a2 < 0)
  {
    valuePtr[0] = 0;
    valuePtr[1] = a2;
    v2 = valuePtr;
    v3 = kCFNumberMaxType|kCFNumberSInt8Type;
  }
  else
  {
    v2 = &v6;
    v3 = kCFNumberSInt64Type;
  }
  return CFNumberCreate(a1, v3, v2);
}

uint64_t FigCFDictionaryGetInt64IfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberSInt64Type, a3);
}

uint64_t FigCFDictionarySetInt64(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberSInt64Type, &v4);
}

uint64_t FigCFArrayGetInt64AtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberSInt64Type, a3);
}

uint64_t FigCFArrayAppendInt64(void *a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberSInt64Type, &v3);
}

uint64_t FigCFDictionaryGetCFIndexIfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberCFIndexType, a3);
}

uint64_t FigCFDictionarySetCFIndex(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberCFIndexType, &v4);
}

uint64_t FigCFArrayGetCFIndexAtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberCFIndexType, a3);
}

uint64_t FigCFArrayAppendCFIndex(void *a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberCFIndexType, &v3);
}

CFDataRef FigCFDictionarySetBase64Data(void *a1, const void *a2, const __CFData *Base64EncodedStringFromBytes)
{
  value = 0;
  if (!a1) {
    return 0;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != CFDictionaryGetTypeID() || !a2)
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (Base64EncodedStringFromBytes)
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    BytePtr = CFDataGetBytePtr(Base64EncodedStringFromBytes);
    CFIndex Length = CFDataGetLength(Base64EncodedStringFromBytes);
    Base64EncodedStringFromBytes = (const __CFData *)FigCreateBase64EncodedStringFromBytes(v7, (uint64_t)BytePtr, Length, 0, (CFStringRef *)&value);
    v10 = value;
    if (!Base64EncodedStringFromBytes)
    {
      CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, value);
      v10 = value;
    }
    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
  return Base64EncodedStringFromBytes;
}

uint64_t FigCFDictionaryFindAnyKeyForValue(const __CFDictionary *a1, const void *a2, void *a3)
{
  uint64_t v3 = 0;
  uint64_t v8 = 0;
  if (!a1 || !a2) {
    return v3;
  }
  if (a3)
  {
    context[0] = &v8;
    context[1] = a2;
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)findAnyKeyForValueApplier, context);
    uint64_t v5 = v8;
    *a3 = v8;
    return v5 != 0;
  }

  return CFDictionaryContainsValue(a1, a2);
}

uint64_t findAnyKeyForValueApplier(uint64_t a1, CFTypeRef cf1, uint64_t a3)
{
  uint64_t result = CFEqual(cf1, *(CFTypeRef *)(a3 + 8));
  if (result) {
    **(void **)a3 = a1;
  }
  return result;
}

uint64_t FigCFDictionarySetValueFromKeyInDict(__CFDictionary *a1, const void *a2, CFDictionaryRef theDict, void *key)
{
  uint64_t result = 0;
  if (a1 && a2 && theDict && key)
  {
    uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, key);
    if (result)
    {
      CFDictionarySetValue(a1, a2, (const void *)result);
      return 1;
    }
  }
  return result;
}

void setKeyInDictionaryApply(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

void FigCFDictionarySetBoolean(__CFDictionary *a1, const void *a2, int a3)
{
  if (a1 && a2)
  {
    uint64_t v3 = (const void **)MEMORY[0x1E4F1CFD0];
    if (!a3) {
      uint64_t v3 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    CFDictionarySetValue(a1, a2, *v3);
  }
}

uint64_t FigCFDictionaryGetBooleanIfPresent(uint64_t result, const void *a2, Boolean *a3)
{
  value = 0;
  if (result)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)result;
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFDictionaryGetTypeID() && a2 && a3)
    {
      uint64_t result = CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value);
      if (!result) {
        return result;
      }
      CFTypeID TypeID = CFBooleanGetTypeID();
      if (TypeID == CFGetTypeID(value))
      {
        *a3 = CFBooleanGetValue((CFBooleanRef)value);
        return 1;
      }
    }
    else
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  return result;
}

CFDictionaryRef FigCFRangeCopyAsDictionary(uint64_t a1, uint64_t a2, CFAllocatorRef allocator)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *(void *)&long long valuePtr = a1;
  CFNumberRef v5 = CFNumberCreate(allocator, kCFNumberSInt64Type, &valuePtr);
  *(void *)&long long valuePtr = a2;
  CFNumberRef v6 = CFNumberCreate(allocator, kCFNumberSInt64Type, &valuePtr);
  long long valuePtr = xmmword_1E56793A0;
  v9[0] = v5;
  v9[1] = v6;
  CFDictionaryRef v7 = CFDictionaryCreate(allocator, (const void **)&valuePtr, v9, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v5) {
    CFRelease(v5);
  }
  if (v6) {
    CFRelease(v6);
  }
  return v7;
}

uint64_t FigCFRangeMakeFromDictionary(uint64_t a1, void *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (a1 && a2)
  {
    if (figCFDictionaryGetNumberIfPresent(a1, @"Location", kCFNumberSInt64Type, &v7)
      && figCFDictionaryGetNumberIfPresent(a1, @"Length", kCFNumberSInt64Type, &v6))
    {
      uint64_t result = 0;
      uint64_t v5 = v6;
      *a2 = v7;
      a2[1] = v5;
    }
    else
    {
      return FigSignalErrorAt(4294954302, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigCFDictionarySetRange(__CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a1 && a2)
  {
    CFDictionaryRef v6 = FigCFRangeCopyAsDictionary(a3, a4, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    if (v6)
    {
      CFDictionaryRef v7 = v6;
      CFDictionarySetValue(a1, a2, v6);
      CFRelease(v7);
    }
    else
    {
      FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCFDictionaryGetRangeIfPresent(CFDictionaryRef theDict, const void *a2, _OWORD *a3)
{
  if (!a3)
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t result = 0;
  if (theDict)
  {
    if (a2)
    {
      value = 0;
      uint64_t result = CFDictionaryGetValueIfPresent(theDict, a2, (const void **)&value);
      if (result)
      {
        long long v6 = 0uLL;
        if (!FigCFRangeMakeFromDictionary((uint64_t)value, &v6))
        {
          *a3 = v6;
          return 1;
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t FigCFDictionaryGetCMTimeIfPresent(uint64_t result, const void *a2, CMTime *a3)
{
  value = 0;
  if (result)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)result;
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFDictionaryGetTypeID() && a2 && a3)
    {
      uint64_t result = CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value);
      if (!result) {
        return result;
      }
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(value))
      {
        CMTimeMakeFromDictionary(&v8, (CFDictionaryRef)value);
        *a3 = v8;
        return 1;
      }
    }
    else
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  return result;
}

uint64_t FigCFDictionarySetCMTime(void *a1, const void *a2, CMTime *a3)
{
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 != CFDictionaryGetTypeID())
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    if (a2)
    {
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CMTime v11 = *a3;
      CFDictionaryRef v8 = CMTimeCopyAsDictionary(&v11, v7);
      if (!v8) {
        return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
      }
      CFDictionaryRef v9 = v8;
      CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, v8);
      CFRelease(v9);
      return 0;
    }
  }

  return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFDictionarySetCMTimeRange(void *a1, const void *a2, _OWORD *a3)
{
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 != CFDictionaryGetTypeID())
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    if (a2)
    {
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      long long v8 = a3[1];
      *(_OWORD *)&v12.start.value = *a3;
      *(_OWORD *)&v12.start.epoch = v8;
      *(_OWORD *)&v12.duration.timescale = a3[2];
      CFDictionaryRef v9 = CMTimeRangeCopyAsDictionary(&v12, v7);
      if (!v9) {
        return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
      }
      CFDictionaryRef v10 = v9;
      CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, v9);
      CFRelease(v10);
      return 0;
    }
  }

  return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFDictionaryGetCMTimeRangeIfPresent(uint64_t result, const void *a2, _OWORD *a3)
{
  value = 0;
  if (result)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)result;
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFDictionaryGetTypeID() && a2 && a3)
    {
      uint64_t result = CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value);
      if (!result) {
        return result;
      }
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(value))
      {
        CMTimeRangeMakeFromDictionary(&v9, (CFDictionaryRef)value);
        long long v8 = *(_OWORD *)&v9.start.epoch;
        *a3 = *(_OWORD *)&v9.start.value;
        a3[1] = v8;
        a3[2] = *(_OWORD *)&v9.duration.timescale;
        return 1;
      }
    }
    else
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  return result;
}

uint64_t FigCFArrayAppendCMTime(void *a1, CMTime *a2)
{
  if (a1)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 == CFArrayGetTypeID())
    {
      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CMTime v10 = *a2;
      CFDictionaryRef v7 = CMTimeCopyAsDictionary(&v10, v6);
      if (!v7) {
        return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
      }
      CFDictionaryRef v8 = v7;
      CFArrayAppendValue((CFMutableArrayRef)a1, v7);
      CFRelease(v8);
    }
    else
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCFArrayGetCMTimeAtIndex(const void *a1, CFIndex a2, CMTime *a3)
{
  if (a1
    && (CFTypeID v6 = CFGetTypeID(a1), v6 == CFArrayGetTypeID())
    && a3
    && (a2 & 0x8000000000000000) == 0
    && CFArrayGetCount((CFArrayRef)a1) > a2
    && (CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, a2)) != 0
    && (CFDictionaryRef v8 = ValueAtIndex, v9 = CFGetTypeID(ValueAtIndex), v9 == CFDictionaryGetTypeID()))
  {
    CMTimeMakeFromDictionary(&v11, v8);
    *a3 = v11;
    return 1;
  }
  else
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

__CFString *FigCFCopyCompactDescription(const __CFSet *a1)
{
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  figCFAppendCompactDescription(Mutable, a1);
  return Mutable;
}

void figCFAppendCompactDescription(CFMutableStringRef theString, const __CFSet *a2)
{
  if (!a2)
  {
    CFStringRef v6 = @"NULL";
    goto LABEL_8;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a2))
  {
    CFTypeID v7 = CFArrayGetTypeID();
    if (v7 != CFGetTypeID(a2))
    {
      CFTypeID v8 = CFSetGetTypeID();
      if (v8 == CFGetTypeID(a2))
      {
        v11.value = 0;
        FigCFSetCopyValuesAsCFArray(a2, (CFArrayRef *)&v11);
        CFStringAppend(theString, @"{");
        figCFAppendArrayToCompactDescription(theString, (CFArrayRef)v11.value);
        CFStringAppend(theString, @"}");
        if (v11.value) {
          CFRelease((CFTypeRef)v11.value);
        }
      }
      else
      {
        CFStringAppendFormat(theString, 0, @"%@", a2);
      }
      return;
    }
    CFStringAppend(theString, @"[");
    figCFAppendArrayToCompactDescription(theString, a2);
    CFStringRef v6 = @"]";
LABEL_8:
    CFStringAppend(theString, v6);
    return;
  }
  memset(&v11, 0, sizeof(v11));
  CMTimeMakeFromDictionary(&v11, a2);
  if (v11.flags)
  {
    if ((v11.flags & 4) != 0)
    {
      CFStringRef v5 = @"+inf";
    }
    else if ((v11.flags & 8) != 0)
    {
      CFStringRef v5 = @"-inf";
    }
    else
    {
      if ((v11.flags & 0x10) == 0)
      {
        CMTime context = v11;
        Float64 Seconds = CMTimeGetSeconds(&context);
        CFStringAppendFormat(theString, 0, @"%1.3f", *(void *)&Seconds);
        return;
      }
      CFStringRef v5 = @"indef";
    }
  }
  else
  {
    *(_OWORD *)&context.value = (unint64_t)theString;
    CFStringAppend(theString, @"[");
    CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)figCFAppendCompactDictionaryDescription, &context);
    CFStringRef v5 = @"]";
  }
  CFStringAppend(theString, v5);
}

CFArrayRef FigCreateCFArrayFromColorValues(const __CFAllocator *a1, double a2, double a3, double a4, double a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  double v17 = a3;
  double valuePtr = a2;
  double v15 = a5;
  double v16 = a4;
  CFTypeRef v21 = 0;
  CFTypeRef cf = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCGFloatType, &valuePtr);
  values = v7;
  if (!v7) {
    return 0;
  }
  CFTypeID v8 = v7;
  CFNumberRef v9 = CFNumberCreate(v6, kCFNumberCGFloatType, &v17);
  CFNumberRef v20 = v9;
  if (v9)
  {
    CFNumberRef v10 = v9;
    CFNumberRef v11 = CFNumberCreate(v6, kCFNumberCGFloatType, &v16);
    CFTypeRef v21 = v11;
    if (v11)
    {
      CFTypeRef v12 = v11;
      CFTypeRef cf = CFNumberCreate(v6, kCFNumberCGFloatType, &v15);
      if (cf)
      {
        CFArrayRef v13 = CFArrayCreate(a1, (const void **)&values, 4, MEMORY[0x1E4F1D510]);
        CFRelease(cf);
        CFTypeRef v12 = v21;
      }
      else
      {
        CFArrayRef v13 = 0;
      }
      CFRelease(v12);
      CFNumberRef v10 = v20;
    }
    else
    {
      CFArrayRef v13 = 0;
    }
    CFRelease(v10);
    CFTypeID v8 = values;
  }
  else
  {
    CFArrayRef v13 = 0;
  }
  CFRelease(v8);
  return v13;
}

char *FigCFGetLocalTimeString(char *a1, size_t a2)
{
  int v10 = 0;
  uint64_t v8 = 0;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  unsigned int v5 = llround(modf(Current, &__y) * 1000.0);
  if (v5 == 1000) {
    unsigned int v6 = 0;
  }
  else {
    unsigned int v6 = v5;
  }
  if (v5 == 1000) {
    CFAbsoluteTime Current = Current + 1.0;
  }
  FigThreadRunOnce(&sCFCalendarStuffOnce, (void (*)(void))figCreateCalendarStuffOnce);
  FigSimpleMutexLock((pthread_mutex_t *)sCFCalendarMutex);
  CFCalendarDecomposeAbsoluteTime((CFCalendarRef)sCFGregorianCalendar, Current, "Hms", (char *)&v8 + 4, &v8, &v10);
  FigSimpleMutexUnlock((pthread_mutex_t *)sCFCalendarMutex);
  snprintf(a1, a2, "%02d:%02d:%02d.%03d", HIDWORD(v8), v8, v10, v6);
  return a1;
}

CFTimeZoneRef figCreateCalendarStuffOnce()
{
  sCFGregorianCalendar = (uint64_t)CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFCalendarIdentifier)*MEMORY[0x1E4F1D198]);
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  sCFCalendarMutex = (uint64_t)FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  CFAllocatorRef v1 = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  CFTimeZoneRef result = CFTimeZoneCreateWithTimeIntervalFromGMT(v1, 0.0);
  sCFTimeZoneGMT = (uint64_t)result;
  return result;
}

uint64_t FigCFIOKitObjectGetTypeID()
{
  if (FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectInitOnce != -1) {
    dispatch_once(&FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectInitOnce, &__block_literal_global_18);
  }
  return FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectTypeID;
}

uint64_t __FigCFIOKitObjectGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectCFTypeID TypeID = result;
  return result;
}

uint64_t FigCFIOKitObjectCreate(uint64_t *a1, io_object_t a2)
{
  if (FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectInitOnce != -1) {
    dispatch_once(&FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectInitOnce, &__block_literal_global_18);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294954305;
  }
  uint64_t v5 = Instance;
  IOObjectRetain(a2);
  uint64_t result = 0;
  *(_DWORD *)(v5 + 16) = a2;
  *a1 = v5;
  return result;
}

uint64_t FigCFIOKitObjectGetIOKitObject(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

CFIndex FigCreateCFDataFromCFPropertyList(CFPropertyListRef propertyList, CFAllocatorRef allocator, CFDataRef *a3)
{
  if (propertyList)
  {
    CFErrorRef error = 0;
    CFDataRef v4 = CFPropertyListCreateData(allocator, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, &error);
    *a3 = v4;
    if (v4)
    {
      return 0;
    }
    else if (error)
    {
      CFIndex Code = CFErrorGetCode(error);
      CFStringRef v6 = CFErrorCopyFailureReason(error);
      if (v6) {
        CFRelease(v6);
      }
      CFRelease(error);
    }
    else
    {
      return 4294954302;
    }
  }
  else
  {
    CFIndex Code = 0;
    *a3 = CFDataCreate(allocator, 0, 0);
  }
  return Code;
}

CFIndex FigCreateCFPropertyListFromData(UInt8 *bytes, CFIndex length, CFAllocatorRef allocator, CFPropertyListRef *a4)
{
  if (length)
  {
    CFErrorRef error = 0;
    CFDataRef v6 = CFDataCreateWithBytesNoCopy(allocator, bytes, length, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (v6)
    {
      CFDataRef v7 = v6;
      *a4 = CFPropertyListCreateWithData(allocator, v6, 0, 0, &error);
      CFRelease(v7);
      if (*a4)
      {
        return 0;
      }
      else if (error)
      {
        CFIndex Code = CFErrorGetCode(error);
        CFStringRef v9 = CFErrorCopyFailureReason(error);
        if (v9) {
          CFRelease(v9);
        }
        CFRelease(error);
      }
      else
      {
        return 4294954302;
      }
    }
    else
    {
      return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    CFIndex Code = 0;
    *a4 = 0;
  }
  return Code;
}

uint64_t FigCFTypeIsPListSerializable(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    uint64_t v21 = 4294954305;
    goto LABEL_26;
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  CFTypeID TypeID = CFBooleanGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  CFTypeID TypeID = CFDataGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  CFTypeID TypeID = CFDateGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  CFTypeID TypeID = CFNumberGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  CFTypeID TypeID = CFStringGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  if (!a1)
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    uint64_t v8 = 0;
    CFStringRef v9 = 0;
    goto LABEL_20;
  }
  CFTypeID v3 = CFGetTypeID((CFTypeRef)a1);
  if (!FigCFArrayContainsInt64(Mutable, v3))
  {
LABEL_25:
    uint64_t v21 = 4294954306;
LABEL_26:
    FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
    uint64_t v8 = 0;
    goto LABEL_27;
  }
  CFTypeID v4 = CFGetTypeID((CFTypeRef)a1);
  if (v4 == CFDictionaryGetTypeID())
  {
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a1);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      size_t v7 = 8 * Count;
      uint64_t v8 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
      if (v8)
      {
        CFStringRef v9 = (const void **)malloc_type_malloc(v7, 0xC0040B8AA526DuLL);
        if (v9)
        {
          CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v8, v9);
          uint64_t v10 = 0;
          while (1)
          {
            CFNumberRef v11 = v8[v10];
            Value = CFDictionaryGetValue((CFDictionaryRef)a1, v11);
            CFTypeID v13 = CFGetTypeID(v11);
            if (v13 != CFStringGetTypeID() || !FigCFTypeIsPListSerializable(Value)) {
              break;
            }
            if (v6 == ++v10) {
              goto LABEL_19;
            }
          }
          uint64_t v20 = 4294954306;
        }
        else
        {
          uint64_t v20 = 4294954305;
        }
        FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
        goto LABEL_28;
      }
      FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
LABEL_27:
      CFStringRef v9 = 0;
LABEL_28:
      a1 = 0;
      goto LABEL_20;
    }
    goto LABEL_18;
  }
  CFTypeID v14 = CFGetTypeID((CFTypeRef)a1);
  if (v14 == CFArrayGetTypeID())
  {
    CFIndex v15 = CFArrayGetCount((CFArrayRef)a1);
    if (v15 >= 1)
    {
      CFIndex v16 = v15;
      CFIndex v17 = 0;
      do
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v17);
        if (!FigCFTypeIsPListSerializable(ValueAtIndex)) {
          goto LABEL_25;
        }
      }
      while (v16 != ++v17);
    }
  }
LABEL_18:
  uint64_t v8 = 0;
  CFStringRef v9 = 0;
LABEL_19:
  a1 = 1;
LABEL_20:
  free(v8);
  free(v9);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return a1;
}

double FigGetCFPreferenceSizeWithDefault(const __CFString *a1, const __CFString *a2, double a3)
{
  CFStringRef v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  if (v4)
  {
    CFStringRef v5 = v4;
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(v5)) {
      goto LABEL_12;
    }
    range.location = 0;
    range.length = 0;
    CFIndex v7 = CFStringGetLength(v5) - 1;
    v16.location = 0;
    v16.length = v7;
    if (!CFStringFindWithOptions(v5, @"x", v16, 1uLL, &range)) {
      goto LABEL_12;
    }
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    v17.length = range.location;
    v17.location = 0;
    CFStringRef v9 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, v17);
    v18.location = range.location + 1;
    v18.length = v7 - range.location;
    CFStringRef v10 = CFStringCreateWithSubstring(v8, v5, v18);
    CFStringRef v11 = v10;
    if (v9) {
      BOOL v12 = v10 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
      if (!v9)
      {
        if (!v10)
        {
LABEL_12:
          CFRelease(v5);
          return a3;
        }
LABEL_11:
        CFRelease(v11);
        goto LABEL_12;
      }
    }
    else
    {
      FigGetDoubleFromCFTypeWithDefault(v9);
      a3 = v14;
      FigGetDoubleFromCFTypeWithDefault(v11);
    }
    CFRelease(v9);
    if (!v11) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  return a3;
}

void FigGetDoubleFromCFTypeWithDefault(const __CFString *a1)
{
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID(a1);
    if (v2 == CFStringGetTypeID())
    {
      if (CFStringGetDoubleValue(a1) == 0.0)
      {
        if (CFStringCompare(a1, @"0", 1uLL)) {
          CFStringCompare(a1, @"0.0", 1uLL);
        }
      }
    }
    else
    {
      CFTypeID v3 = CFGetTypeID(a1);
      if (v3 == CFNumberGetTypeID())
      {
        uint64_t valuePtr = 0;
        CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &valuePtr);
      }
    }
  }
}

uint64_t FigCFDictionaryGetCGRectIfPresent(uint64_t result, const void *a2, CGRect *a3)
{
  value = 0;
  if (result)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)result;
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFDictionaryGetTypeID() && a2 && a3)
    {
      uint64_t result = CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value);
      if (!result) {
        return result;
      }
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(value)) {
        return 0;
      }
      if (CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)value, a3)) {
        return 1;
      }
    }
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

uint64_t FigCFDictionarySetCGRect(void *a1, const void *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  if (!a1) {
    goto LABEL_7;
  }
  CFTypeID v12 = CFGetTypeID(a1);
  if (v12 != CFDictionaryGetTypeID())
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (a2)
  {
    v18.origin.x = a3;
    v18.origin.y = a4;
    v18.size.width = a5;
    v18.size.height = a6;
    CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v18);
    if (DictionaryRepresentation)
    {
      CFDictionaryRef v14 = DictionaryRepresentation;
      CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, DictionaryRepresentation);
      CFRelease(v14);
      return 0;
    }
    uint64_t v16 = 4294954305;
  }
  else
  {
LABEL_7:
    uint64_t v16 = 4294954306;
  }

  return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFArrayAppendCGRect(void *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  if (a1)
  {
    CFTypeID v10 = CFGetTypeID(a1);
    if (v10 != CFArrayGetTypeID())
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    v16.origin.x = a2;
    v16.origin.y = a3;
    v16.size.width = a4;
    v16.size.height = a5;
    CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v16);
    if (DictionaryRepresentation)
    {
      CFDictionaryRef v12 = DictionaryRepresentation;
      CFArrayAppendValue((CFMutableArrayRef)a1, DictionaryRepresentation);
      CFRelease(v12);
      return 0;
    }
    uint64_t v14 = 4294954305;
  }
  else
  {
    uint64_t v14 = 4294954306;
  }

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFArrayGetCGRectAtIndex(const void *a1, CFIndex a2, CGRect *a3)
{
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 == CFArrayGetTypeID())
    {
      if (a3)
      {
        if ((a2 & 0x8000000000000000) == 0 && CFArrayGetCount((CFArrayRef)a1) > a2)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, a2);
          if (ValueAtIndex)
          {
            CFDictionaryRef v8 = ValueAtIndex;
            CFTypeID v9 = CFGetTypeID(ValueAtIndex);
            if (v9 == CFDictionaryGetTypeID() && CGRectMakeWithDictionaryRepresentation(v8, a3)) {
              return 1;
            }
          }
        }
      }
    }
  }
  FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigCFDictionaryGetCGSizeIfPresent(uint64_t result, const void *a2, CGSize *a3)
{
  value = 0;
  if (result)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)result;
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFDictionaryGetTypeID() && a2 && a3)
    {
      uint64_t result = CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value);
      if (!result) {
        return result;
      }
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(value)) {
        return 0;
      }
      if (CGSizeMakeWithDictionaryRepresentation((CFDictionaryRef)value, a3)) {
        return 1;
      }
    }
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

uint64_t FigCFDictionarySetCGSize(void *a1, const void *a2, CGFloat a3, CGFloat a4)
{
  if (!a1) {
    goto LABEL_7;
  }
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 != CFDictionaryGetTypeID())
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (a2)
  {
    v14.width = a3;
    v14.height = a4;
    CFDictionaryRef DictionaryRepresentation = CGSizeCreateDictionaryRepresentation(v14);
    if (DictionaryRepresentation)
    {
      CFDictionaryRef v10 = DictionaryRepresentation;
      CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, DictionaryRepresentation);
      CFRelease(v10);
      return 0;
    }
    uint64_t v12 = 4294954305;
  }
  else
  {
LABEL_7:
    uint64_t v12 = 4294954306;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFArrayAppendCGSize(void *a1, CGFloat a2, CGFloat a3)
{
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 != CFArrayGetTypeID())
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    v12.width = a2;
    v12.height = a3;
    CFDictionaryRef DictionaryRepresentation = CGSizeCreateDictionaryRepresentation(v12);
    if (DictionaryRepresentation)
    {
      CFDictionaryRef v8 = DictionaryRepresentation;
      CFArrayAppendValue((CFMutableArrayRef)a1, DictionaryRepresentation);
      CFRelease(v8);
      return 0;
    }
    uint64_t v10 = 4294954305;
  }
  else
  {
    uint64_t v10 = 4294954306;
  }

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFArrayGetCGSizeAtIndex(const void *a1, CFIndex a2, CGSize *a3)
{
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 == CFArrayGetTypeID())
    {
      if (a3)
      {
        if ((a2 & 0x8000000000000000) == 0 && CFArrayGetCount((CFArrayRef)a1) > a2)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, a2);
          if (ValueAtIndex)
          {
            CFDictionaryRef v8 = ValueAtIndex;
            CFTypeID v9 = CFGetTypeID(ValueAtIndex);
            if (v9 == CFDictionaryGetTypeID() && CGSizeMakeWithDictionaryRepresentation(v8, a3)) {
              return 1;
            }
          }
        }
      }
    }
  }
  FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  return 0;
}

CFTypeRef FigCFTypeCollectionRetain(int a1, CFTypeRef cf)
{
  return CFRetain(cf);
}

void FigCFTypeCollectionRelease(int a1, CFTypeRef cf)
{
}

uint64_t FigASCIICFStringCaseInsensitiveEqualCallback(const __CFString *cf, const __CFString *cf2)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    CFTypeID TypeID = CFStringGetTypeID();
    if (cf2)
    {
      if (v4 == TypeID)
      {
        CFTypeID v6 = CFGetTypeID(cf2);
        if (v6 == CFStringGetTypeID()) {
          return CFStringCompare(cf, cf2, 1uLL) == kCFCompareEqualTo;
        }
      }
    }
  }

  return CFEqual(cf, cf2);
}

CFHashCode FigASCIICFStringCaseInsensitiveHashCallback(const __CFString *cf)
{
  if (cf
    && (CFTypeID v2 = CFGetTypeID(cf), v2 == CFStringGetTypeID())
    && (CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter),
        v10.length = CFStringGetLength(cf),
        v10.location = 0,
        CFStringFindCharacterFromSet(cf, Predefined, v10, 0, 0))
    && (CFAllocatorRef v4 = CFGetAllocator(cf), (MutableCopy = CFStringCreateMutableCopy(v4, 0, cf)) != 0))
  {
    CFTypeID v6 = MutableCopy;
    CFStringLowercase(MutableCopy, 0);
    CFHashCode v7 = CFHash(v6);
    CFRelease(v6);
    return v7;
  }
  else
  {
    return CFHash(cf);
  }
}

CFPropertyListRef FigCreatePropertyListFromBundleIdentifier(const __CFAllocator *a1, CFStringRef bundleID, const __CFString *a3, const __CFString *a4)
{
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(bundleID);
  if (!BundleWithIdentifier)
  {
    FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  CFURLRef v8 = CFBundleCopyResourceURL(BundleWithIdentifier, a3, 0, a4);
  if (!v8) {
    return 0;
  }
  CFURLRef v9 = v8;
  CFRange v10 = CFReadStreamCreateWithFile((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8);
  if (!v10)
  {
    FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
    CFRelease(v9);
    return 0;
  }
  CFStringRef v11 = v10;
  CFPropertyListFormat format = 0;
  if (CFReadStreamOpen(v10))
  {
    CFPropertyListRef v12 = CFPropertyListCreateWithStream(a1, v11, 0, 0, &format, 0);
    if (!v12) {
      FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
    CFPropertyListRef v12 = 0;
  }
  CFRelease(v9);
  CFRelease(v11);
  return v12;
}

CFPropertyListRef FigCFCreatePropertyListFromBundleIdentifierOnPlatform(CFStringRef bundleID, const __CFString *a2)
{
  return FigCreateModelSpecificPropertyListFromBundleIdentifier((const __CFAllocator *)*MEMORY[0x1E4F1CF80], bundleID, a2);
}

BOOL FigCFBundleIDResourceSubdirExists(const __CFString *a1, const __CFString *a2)
{
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(a1);
  if (BundleWithIdentifier && (CFURLRef v4 = CFBundleCopyResourcesDirectoryURL(BundleWithIdentifier)) != 0)
  {
    CFURLRef v5 = v4;
    CFURLRef v6 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, a2, 1u);
    if (v6)
    {
      CFURLRef v7 = v6;
      BOOL DoesFileExist = FigFileDoesFileExist(v6);
      CFRelease(v5);
      CFRelease(v7);
      return DoesFileExist;
    }
    FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
    CFRelease(v5);
  }
  else
  {
    FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

UInt8 *FigCreateBytesFromCFString(const __CFAllocator *a1, CFStringRef theString, CFStringEncoding a3, int a4, void *a5)
{
  CFIndex maxBufLen = 0;
  if (a4)
  {
    HIDWORD(v11) = a3 - 256;
    LODWORD(v11) = a3 - 256;
    unsigned int v10 = v11 >> 26;
    if (v10 > 7) {
      unint64_t v12 = 1;
    }
    else {
      unint64_t v12 = qword_18FE95D18[v10];
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  v18.length = CFStringGetLength(theString);
  v18.location = 0;
  CFStringGetBytes(theString, v18, a3, 0, 0, 0, 0, &maxBufLen);
  CFTypeID v13 = (UInt8 *)CFAllocatorAllocate(a1, maxBufLen + v12, 0);
  v19.length = CFStringGetLength(theString);
  v19.location = 0;
  CFStringGetBytes(theString, v19, a3, 0, 0, v13, maxBufLen, 0);
  if (a4)
  {
    if (v12 <= 1) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = v12;
    }
    CFIndex v15 = v13;
    do
    {
      v15[maxBufLen] = 0;
      ++v15;
      --v14;
    }
    while (v14);
  }
  if (a5) {
    *a5 = maxBufLen + v12;
  }
  return v13;
}

UInt8 *FigCreateBytesFromCFStringAndMovieLangCode(const __CFAllocator *a1, const __CFString *a2, unsigned int a3, int a4, void *a5)
{
  if (a3 > 0x97)
  {
    if (a3 != 0x7FFF && a3 >= 0x400) {
      CFStringEncoding v5 = 134217984;
    }
    else {
      CFStringEncoding v5 = 0;
    }
  }
  else
  {
    CFStringEncoding v5 = langCodeToStringEncoding[a3];
  }
  return FigCreateBytesFromCFString(a1, a2, v5, a4, a5);
}

uint64_t FigCFStringCreateWithBytesAndMovieLangCode(const __CFAllocator *a1, const UInt8 *a2, unint64_t a3, unsigned int a4, CFStringEncoding *a5, CFStringRef *a6)
{
  if (!a2)
  {
    uint64_t v12 = 4294954306;
    goto LABEL_19;
  }
  if (!a6)
  {
    uint64_t v12 = 4294954306;
    goto LABEL_19;
  }
  if (a4 <= 0x97)
  {
    Boolean v7 = 0;
    CFStringEncoding v8 = langCodeToStringEncoding[a4];
    if (!a5) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if (a4 == 0x7FFF)
  {
    CFStringEncoding v8 = 0;
    Boolean v7 = 0;
    if (!a5) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if (a4 < 0x400)
  {
    uint64_t v12 = 4294954303;
    goto LABEL_19;
  }
  if (a3 >= 2)
  {
    int v9 = *a2;
    if (v9 == 255)
    {
      if (a2[1] != 254) {
        goto LABEL_14;
      }
    }
    else if (v9 != 254 || a2[1] != 255)
    {
      goto LABEL_14;
    }
    Boolean v7 = 1;
    CFStringEncoding v8 = 256;
    if (!a5) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_14:
  Boolean v7 = 0;
  CFStringEncoding v8 = 134217984;
  if (a5) {
LABEL_15:
  }
    *a5 = v8;
LABEL_16:
  CFStringRef v10 = CFStringCreateWithBytes(a1, a2, a3, v8, v7);
  if (v10)
  {
    *a6 = v10;
    return 0;
  }
  uint64_t v12 = 4294954302;
LABEL_19:

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

CFStringRef FigCFStringFind(const __CFString *result, const __CFString *a2, CFStringCompareFlags a3)
{
  if (result)
  {
    CFStringRef v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    CFTypeID TypeID = CFStringGetTypeID();
    uint64_t result = 0;
    if (a2)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a2);
        if (v8 == CFStringGetTypeID()) {
          return (const __CFString *)(CFStringFind(v5, a2, a3).location != -1);
        }
        else {
          return 0;
        }
      }
    }
  }
  return result;
}

CFStringRef FigCFStringGetIntAfterString(CFStringRef result, const __CFString *a2, SInt32 *a3)
{
  if (result)
  {
    CFStringRef v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    CFTypeID TypeID = CFStringGetTypeID();
    uint64_t result = 0;
    if (a2)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a2);
        if (v8 != CFStringGetTypeID()) {
          return 0;
        }
        CFRange v9 = CFStringFind(v5, a2, 0);
        if (v9.location == -1) {
          return 0;
        }
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        v13.length = CFStringGetLength(v5) - v9.length;
        v13.location = v9.length;
        uint64_t result = CFStringCreateWithSubstring(v10, v5, v13);
        if (!result) {
          return result;
        }
        CFStringRef v11 = result;
        SInt32 IntValue = CFStringGetIntValue(result);
        if (!IntValue && CFStringCompare(v11, @"0", 1uLL))
        {
          CFRelease(v11);
          return 0;
        }
        CFRelease(v11);
        if (a3) {
          *a3 = IntValue;
        }
        return (CFStringRef)1;
      }
    }
  }
  return result;
}

CFStringRef FigCFStringCreateLoggingIdentifierOfLength(const __CFAllocator *a1, uint64_t a2)
{
  CFURLRef v4 = (char *)malloc_type_malloc(a2 + 1, 0xAE81E663uLL);
  CFStringRef v5 = v4;
  if (v4)
  {
    if (a2)
    {
      CFTypeID v6 = v4;
      uint64_t v7 = a2;
      do
      {
        *v6++ = FigCFStringCreateLoggingIdentifierOfLength_charSet[arc4random_uniform(0x1Au)];
        --v7;
      }
      while (v7);
    }
    v5[a2] = 0;
    CFStringRef v8 = CFStringCreateWithCString(a1, v5, 0x600u);
  }
  else
  {
    CFStringRef v8 = 0;
  }
  free(v5);
  return v8;
}

CFLocaleRef FigCFLocaleCreateWithMovieLangCode(CFAllocatorRef alloc, unsigned int a2)
{
  if (a2 == 0x7FFF) {
    return 0;
  }
  if (a2 > 0x3FF)
  {
    *(_DWORD *)bytes = (a2 >> 10) | 0x60;
    *(_WORD *)&bytes[1] = (a2 >> 5) & 0x1F | 0x60;
    bytes[2] = a2 & 0x1F | 0x60;
    CFStringRef CanonicalLocaleIdentifierFromScriptManagerCodes = CFStringCreateWithBytes(alloc, bytes, 4, 0x600u, 0);
  }
  else
  {
    CFStringRef CanonicalLocaleIdentifierFromScriptManagerCodes = CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(alloc, a2, -1);
  }
  CFStringRef v4 = CanonicalLocaleIdentifierFromScriptManagerCodes;
  if (!CanonicalLocaleIdentifierFromScriptManagerCodes) {
    return 0;
  }
  CFLocaleRef v5 = CFLocaleCreate(alloc, CanonicalLocaleIdentifierFromScriptManagerCodes);
  CFRelease(v4);
  return v5;
}

__CFArray *FigCopyRankedLanguagesAccordingToPreferredLanguages2(const __CFArray *a1, const __CFArray *a2, int a3)
{
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef MutableCopy = FigCFArrayCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2);
  uint64_t v7 = FigCFArrayCreateMutableCopy(v5, a1);
  if (v7) {
    BOOL v8 = MutableCopy == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    CFMutableArrayRef Mutable = 0;
    if (!MutableCopy) {
      goto LABEL_38;
    }
LABEL_37:
    CFRelease(MutableCopy);
    goto LABEL_38;
  }
  v26.length = CFArrayGetCount(MutableCopy);
  v26.location = 0;
  CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(MutableCopy, v26, @"zh-Hant-HK");
  v27.length = CFArrayGetCount(MutableCopy);
  v27.location = 0;
  CFIndex v10 = CFArrayGetFirstIndexOfValue(MutableCopy, v27, @"zh-HK");
  CFIndex v11 = v10;
  if ((FirstIndexOfValue & 0x8000000000000000) == 0 || (v10 & 0x8000000000000000) == 0)
  {
    v28.length = CFArrayGetCount(MutableCopy);
    v28.location = 0;
    if (!CFArrayContainsValue(MutableCopy, v28, @"yue-Hant"))
    {
      if (FirstIndexOfValue >= v11) {
        CFIndex v12 = v11;
      }
      else {
        CFIndex v12 = FirstIndexOfValue;
      }
      if (FirstIndexOfValue <= v11) {
        CFIndex v13 = v11;
      }
      else {
        CFIndex v13 = FirstIndexOfValue;
      }
      if ((FirstIndexOfValue | v11) < 0) {
        CFIndex v14 = v13;
      }
      else {
        CFIndex v14 = v12;
      }
      CFArrayInsertValueAtIndex(MutableCopy, v14, @"yue-Hant");
    }
  }
  CFArrayInsertValueAtIndex(v7, 0, @"ULTIMATUM");
  CFArrayAppendValue(MutableCopy, @"ULTIMATUM");
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E4F1D510]);
  if (CFArrayGetCount(v7) < 1) {
    goto LABEL_37;
  }
  do
  {
    CFArrayRef v16 = CFBundleCopyLocalizationsForPreferences(v7, MutableCopy);
    if (!v16) {
      continue;
    }
    CFArrayRef v17 = v16;
    CFIndex Count = CFArrayGetCount(v16);
    if (Count < 1) {
      goto LABEL_34;
    }
    CFIndex v19 = Count;
    CFIndex v20 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v17, v20);
      v29.length = CFArrayGetCount(v7);
      v29.location = 0;
      CFIndex v22 = CFArrayGetFirstIndexOfValue(v7, v29, ValueAtIndex);
      if (ValueAtIndex != @"ULTIMATUM")
      {
        CFIndex v23 = v22;
        if (!ValueAtIndex || !CFEqual(ValueAtIndex, @"ULTIMATUM"))
        {
          if ((v23 & 0x8000000000000000) == 0)
          {
            CFArrayRemoveValueAtIndex(v7, v23);
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
          goto LABEL_31;
        }
      }
      if (a3 || Mutable && CFArrayGetCount(Mutable)) {
        break;
      }
      CFArrayRemoveValueAtIndex(v7, 0);
      CFIndex v24 = CFArrayGetCount(MutableCopy);
      CFArrayRemoveValueAtIndex(MutableCopy, v24 - 1);
LABEL_31:
      if (v19 == ++v20) {
        goto LABEL_34;
      }
    }
    CFArrayRemoveAllValues(v7);
LABEL_34:
    CFRelease(v17);
  }
  while (CFArrayGetCount(v7) > 0);
  if (MutableCopy) {
    goto LABEL_37;
  }
LABEL_38:
  if (v7) {
    CFRelease(v7);
  }
  return Mutable;
}

__CFArray *FigCopyRankedLanguagesAccordingToPreferredLanguages(const __CFArray *a1, const __CFArray *a2)
{
  return FigCopyRankedLanguagesAccordingToPreferredLanguages2(a1, a2, 1);
}

CFStringRef FigCFDateCreateFromString(const __CFAllocator *a1, const __CFString *cf, const void *a3)
{
  CFStringRef v3 = cf;
  if (!cf) {
    return v3;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFStringGetTypeID()) {
    return 0;
  }
  if (a3) {
    CFLocaleRef v7 = (const __CFLocale *)CFRetain(a3);
  }
  else {
    CFLocaleRef v7 = CFLocaleCopyCurrent();
  }
  CFLocaleRef v8 = v7;
  CFAbsoluteTime atp = 0.0;
  BytesFromCFString = FigCreateBytesFromCFString(a1, v3, 0, 1, 0);
  if (!BytesFromCFString)
  {
    CFStringRef v3 = 0;
    if (!v8) {
      return v3;
    }
    goto LABEL_33;
  }
  CFIndex v10 = BytesFromCFString;
  if (!FigCFParseISO8601Date((const char *)BytesFromCFString, &atp)) {
    goto LABEL_30;
  }
  v25 = v10;
  CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F1D088];
  CFIndex v12 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFDateFormatterStyle v13 = kCFDateFormatterFullStyle;
  while (1)
  {
    CFDateFormatterStyle v14 = v13;
    if (v13 == kCFDateFormatterNoStyle) {
      break;
    }
    CFIndex v15 = CFDateFormatterCreate(0, v8, v13, kCFDateFormatterNoStyle);
    if (v15)
    {
      CFArrayRef v16 = v15;
      CFDateFormatterSetProperty(v15, v11, v12);
      int AbsoluteTimeFromString = CFDateFormatterGetAbsoluteTimeFromString(v16, v3, 0, &atp);
      CFRelease(v16);
    }
    else
    {
      int AbsoluteTimeFromString = 0;
    }
    CFDateFormatterStyle v13 = v14 - 1;
    if (AbsoluteTimeFromString) {
      goto LABEL_19;
    }
  }
  int AbsoluteTimeFromString = 0;
LABEL_19:
  CFDateFormatterStyle v18 = kCFDateFormatterFullStyle;
  while (v18)
  {
    CFIndex v19 = CFDateFormatterCreate(0, v8, v14, v18);
    if (v19)
    {
      CFIndex v20 = v19;
      CFDateFormatterSetProperty(v19, v11, v12);
      int v21 = CFDateFormatterGetAbsoluteTimeFromString(v20, v3, 0, &atp);
      CFRelease(v20);
    }
    else
    {
      int v21 = 0;
    }
    --v18;
    if (v21) {
      goto LABEL_27;
    }
  }
  int v21 = 0;
LABEL_27:
  if (v21 | AbsoluteTimeFromString)
  {
    CFIndex v10 = v25;
    if (v14 == kCFDateFormatterNoStyle)
    {
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      uint64_t v26 = 0;
      FigSimpleMutexLock((pthread_mutex_t *)sCFCalendarMutex);
      CFCalendarDecomposeAbsoluteTime((CFCalendarRef)sCFGregorianCalendar, atp, "Hms", (char *)&v28 + 4, &v28, (char *)&v27 + 4);
      CFIndex v22 = (__CFCalendar *)sCFGregorianCalendar;
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      CFCalendarDecomposeAbsoluteTime(v22, Current, "Mdy", &v27, (char *)&v26 + 4, &v26);
      CFCalendarComposeAbsoluteTime((CFCalendarRef)sCFGregorianCalendar, &atp, "HmsMdy", HIDWORD(v28), v28, HIDWORD(v27), v27, HIDWORD(v26), v26);
      FigSimpleMutexUnlock((pthread_mutex_t *)sCFCalendarMutex);
    }
LABEL_30:
    CFStringRef v3 = (const __CFString *)CFDateCreate(a1, atp);
    goto LABEL_32;
  }
  CFStringRef v3 = 0;
  CFIndex v10 = v25;
LABEL_32:
  CFAllocatorDeallocate(a1, v10);
  if (v8) {
LABEL_33:
  }
    CFRelease(v8);
  return v3;
}

uint64_t FigCFParseISO8601Date(const char *a1, CFAbsoluteTime *a2)
{
  memset(&v22, 0, sizeof(v22));
  FigThreadRunOnce(&sCFCalendarStuffOnce, (void (*)(void))figCreateCalendarStuffOnce);
  CFStringRef v4 = strptime(a1, "%FT%T", &v22);
  if (v4 || (CFStringRef v4 = strptime(a1, "%Y%m%dT%H%M%S", &v22)) != 0)
  {
    *(int32x2_t *)&v22.tm_mon = vadd_s32(*(int32x2_t *)&v22.tm_mon, (int32x2_t)0x76C00000001);
  }
  else
  {
    CFStringRef v4 = strptime(a1, "%T", &v22);
    if (!v4)
    {
      CFStringRef v4 = strptime(a1, "%H%M%S", &v22);
      if (!v4) {
        goto LABEL_20;
      }
    }
    v20.tm_sec = 0;
    uint64_t v21 = 0;
    FigSimpleMutexLock((pthread_mutex_t *)sCFCalendarMutex);
    CFDateFormatterStyle v18 = (__CFCalendar *)sCFGregorianCalendar;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFCalendarDecomposeAbsoluteTime(v18, Current, "Mdy", &v20, (char *)&v21 + 4, &v21);
    FigSimpleMutexUnlock((pthread_mutex_t *)sCFCalendarMutex);
    v22.tm_mday = HIDWORD(v21);
    v22.tm_mon = v20.tm_sec;
    v22.tm_year = v21;
  }
  FigSimpleMutexLock((pthread_mutex_t *)sCFCalendarMutex);
  CFTimeZoneRef v5 = CFCalendarCopyTimeZone((CFCalendarRef)sCFGregorianCalendar);
  CFCalendarSetTimeZone((CFCalendarRef)sCFGregorianCalendar, (CFTimeZoneRef)sCFTimeZoneGMT);
  CFCalendarComposeAbsoluteTime((CFCalendarRef)sCFGregorianCalendar, a2, "HmsMdy", v22.tm_hour, v22.tm_min, v22.tm_sec, v22.tm_mon, v22.tm_mday, v22.tm_year);
  CFCalendarSetTimeZone((CFCalendarRef)sCFGregorianCalendar, v5);
  FigSimpleMutexUnlock((pthread_mutex_t *)sCFCalendarMutex);
  CFRelease(v5);
  int v6 = *v4;
  if ((v6 | 2) == 0x2E)
  {
    int v7 = *++v4;
    unsigned int v8 = v7 - 48;
    double v9 = 0.0;
    if ((v7 - 48) <= 9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 1;
      do
      {
        uint64_t v10 = 10 * v10 + v8;
        v11 *= 10;
        int v12 = *++v4;
        unsigned int v8 = v12 - 48;
      }
      while ((v12 - 48) < 0xA);
      double v9 = (double)v10 / (double)v11;
    }
    *a2 = v9 + *a2;
    int v6 = *v4;
  }
  if (v6 == 45 || v6 == 43)
  {
    memset(&v20, 0, sizeof(v20));
    int v14 = *v4;
    CFDateFormatterStyle v13 = v4 + 1;
    if (v14 == 45) {
      double v15 = 1.0;
    }
    else {
      double v15 = -1.0;
    }
    CFArrayRef v16 = strptime(v13, "%H%M", &v20);
    if (v16 || (CFArrayRef v16 = strptime(v13, "%H:%M", &v20)) != 0 || (CFArrayRef v16 = strptime(v13, "%H", &v20)) != 0) {
      *a2 = *a2 + v15 * (double)(3600 * v20.tm_hour + 60 * v20.tm_min);
    }
    CFStringRef v4 = v16;
  }
LABEL_20:
  if (v4) {
    return 0;
  }
  else {
    return 4294954302;
  }
}

uint64_t FigCFURLIsLocalResource(const __CFURL *a1)
{
  if (!a1) {
    return 0;
  }
  CFStringRef v2 = CFURLCopyScheme(a1);
  if (v2)
  {
    CFStringRef v3 = v2;
    uint64_t IsPersistentURL = 1;
    if (CFStringCompare(@"file", v2, 1uLL)) {
      uint64_t IsPersistentURL = FigIsPersistentURL(a1);
    }
    CFRelease(v3);
    return IsPersistentURL;
  }

  return FigIsPersistentURL(a1);
}

CFURLRef FigCFURLCreateCacheKey(const __CFURL *result, char a2)
{
  if (!result) {
    return result;
  }
  CFURLRef v3 = result;
  CFStringRef v4 = CFURLGetString(result);
  if (!v4)
  {
LABEL_13:
    uint64_t v7 = 4294954305;
    goto LABEL_14;
  }
  if (a2)
  {
    uint64_t result = (const __CFURL *)CFURLCopyPath(v3);
    if (result) {
      return result;
    }
    goto LABEL_13;
  }
  CFStringRef v5 = v4;
  if ((a2 & 2) == 0 || (CFIndex location = CFStringFind(v4, @"?", 0).location, location == -1))
  {
    return (const __CFURL *)CFRetain(v5);
  }
  else
  {
    v9.length = location;
    v9.CFIndex location = 0;
    uint64_t result = (const __CFURL *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, v9);
    if (!result)
    {
      uint64_t v7 = 4294967188;
LABEL_14:
      FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
      return 0;
    }
  }
  return result;
}

CFURLRef FigCFStringCreateCacheKeyFromURLString(CFStringRef URLString, char a2)
{
  if (URLString)
  {
    CFURLRef v3 = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], URLString, 0);
    if (v3)
    {
      CFURLRef v4 = v3;
      CFURLRef v5 = FigCFURLCreateCacheKey(v3, a2);
      CFRelease(v4);
      return v5;
    }
    uint64_t v7 = 4294954305;
  }
  else
  {
    uint64_t v7 = 4294954306;
  }
  FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigCFStringInsertIndent(__CFString *a1, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  CFAllocatorRef v8 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v8, 0);
  uint64_t v10 = CFStringCreateMutable(v8, 0);
  if (a4 >= 1)
  {
    do
    {
      CFStringAppend(Mutable, a2);
      CFStringAppend(v10, a3);
      --a4;
    }
    while (a4);
  }
  CFStringRef v11 = CFStringCreateWithFormat(v8, 0, @"\n%@", v10);
  if (v11)
  {
    CFStringInsert(a1, 0, Mutable);
    v13.length = CFStringGetLength(a1);
    v13.CFIndex location = 0;
    CFStringFindAndReplace(a1, @"\n", v11, v13, 0);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v11) {
    CFRelease(v11);
  }
  return 0;
}

__CFString *FigCFStringCopyWithIndent(const __CFString *a1, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  CFAllocatorRef v8 = CFGetAllocator(a1);
  uint64_t result = CFStringCreateMutableCopy(v8, 0, a1);
  if (result)
  {
    CFStringRef v10 = result;
    FigCFStringInsertIndent(result, a2, a3, a4);
    CFStringRef Copy = CFStringCreateCopy(v8, v10);
    CFRelease(v10);
    return (__CFString *)Copy;
  }
  return result;
}

BOOL FigCFURLDoesDirectoryExist(const __CFURL *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v3 = 4294954306;
LABEL_11:
    FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    uint64_t v3 = 4294967246;
    goto LABEL_11;
  }
  memset(&v4, 0, sizeof(v4));
  return stat((const char *)buffer, &v4) != -1 && (v4.st_mode & 0xF000) == 0x4000;
}

uint64_t FigCFURLCreateDirectory(const __CFURL *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (FigCFURLDoesDirectoryExist(a1)) {
    return 0;
  }
  if (a1)
  {
    if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    {
      uint64_t result = mkdir((const char *)buffer, 0x1C0u);
      if (!result) {
        return result;
      }
      uint64_t v3 = 4294954301;
    }
    else
    {
      uint64_t v3 = 4294967246;
    }
  }
  else
  {
    uint64_t v3 = 4294954306;
  }
  return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFURLCreateRelativeURLWithURLAndBaseURL(const __CFAllocator *a1, const __CFURL *a2, const __CFURL *a3, CFURLRef *a4)
{
  if ((!a1 || (CFTypeID TypeID = CFAllocatorGetTypeID(), TypeID == CFGetTypeID(a1)))
    && a2
    && (CFTypeID v9 = CFURLGetTypeID(), v9 == CFGetTypeID(a2))
    && CFURLCanBeDecomposed(a2)
    && a3
    && (CFTypeID v10 = CFURLGetTypeID(), v10 == CFGetTypeID(a3))
    && CFURLCanBeDecomposed(a3)
    && a4)
  {
    CFURLRef v11 = CFURLCopyAbsoluteURL(a2);
    if (v11)
    {
      CFURLRef v12 = v11;
      CFStringRef v13 = CFURLCopyScheme(v11);
      if (!v13 || (CFRelease(v13), (CFURLRef v14 = CFURLCopyAbsoluteURL(a3)) == 0))
      {
        uint64_t v27 = FigSignalErrorAt(4294954300, 0, 0, 0, 0, 0, 0);
        CFRelease(v12);
        return v27;
      }
      CFURLRef v15 = v14;
      CFStringRef v16 = CFURLCopyScheme(v14);
      if (v16)
      {
        CFRelease(v16);
        if (CFURLHasDirectoryPath(v15))
        {
          CFURLRef PathComponent = (const __CFURL *)CFRetain(v15);
          goto LABEL_17;
        }
        CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(a1, v15);
        if (PathComponent)
        {
LABEL_17:
          CFStringRef v18 = CFURLGetString(v12);
          if (v18)
          {
            CFStringRef v19 = CFURLGetString(PathComponent);
            if (v19)
            {
              CFStringRef v20 = v19;
              if (CFStringHasPrefix(v18, v19))
              {
                CFIndex Length = CFStringGetLength(v20);
                v31.length = CFStringGetLength(v18) - Length;
                v31.CFIndex location = Length;
                CFStringRef v18 = CFStringCreateWithSubstring(a1, v18, v31);
                if (v18)
                {
                  CFURLRef v22 = CFURLCreateWithString(a1, v18, PathComponent);
                  if (v22)
                  {
                    uint64_t v23 = 0;
                    *a4 = v22;
                    if (!PathComponent) {
                      goto LABEL_27;
                    }
                    goto LABEL_26;
                  }
                }
                uint64_t v28 = 4294954305;
                goto LABEL_39;
              }
              uint64_t v24 = 4294954300;
            }
            else
            {
              uint64_t v24 = 4294954306;
            }
            uint64_t v23 = FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
            CFStringRef v18 = 0;
            if (!PathComponent)
            {
LABEL_27:
              CFRelease(v15);
              CFRelease(v12);
              if (v18) {
                CFRelease(v18);
              }
              return v23;
            }
LABEL_26:
            CFRelease(PathComponent);
            goto LABEL_27;
          }
          uint64_t v28 = 4294954306;
LABEL_39:
          uint64_t v23 = FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
          if (!PathComponent) {
            goto LABEL_27;
          }
          goto LABEL_26;
        }
        uint64_t v29 = 4294954305;
      }
      else
      {
        uint64_t v29 = 4294954300;
      }
      uint64_t v23 = FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
      CFStringRef v18 = 0;
      goto LABEL_27;
    }
    uint64_t v26 = 4294954305;
  }
  else
  {
    uint64_t v26 = 4294954306;
  }

  return FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFURLCreateWithSuffixedExtension(const __CFAllocator *a1, CFURLRef url, const __CFString *a3, void *a4)
{
  CFStringRef v8 = CFURLCopyPathExtension(url);
  CFStringRef v9 = v8;
  if (v8 == a3 || a3 && v8 && CFEqual(a3, v8)) {
    CFTypeID v10 = (void *)CFRetain(url);
  }
  else {
    CFTypeID v10 = CFURLCreateCopyAppendingPathExtension(a1, url, a3);
  }
  CFURLRef v11 = v10;
  if (v10 || (uint64_t v12 = FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0), !v12))
  {
    uint64_t v12 = 0;
    *a4 = v11;
  }
  if (v9) {
    CFRelease(v9);
  }
  return v12;
}

uint64_t FigCFURLCopyCanonicalPath(const __CFURL *a1, void *a2)
{
  CFTypeRef propertyValueTypeRefPtr = 0;
  if (a1 && _CFURLIsFileURL() && a2)
  {
    CFURLCopyResourcePropertyForKey(a1, (CFStringRef)*MEMORY[0x1E4F1D588], &propertyValueTypeRefPtr, 0);
    if (propertyValueTypeRefPtr)
    {
      uint64_t v4 = 0;
      *a2 = propertyValueTypeRefPtr;
    }
    else
    {
      uint64_t v4 = FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      if (propertyValueTypeRefPtr) {
        CFRelease(propertyValueTypeRefPtr);
      }
    }
    return v4;
  }
  else
  {
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCFURLGetFileStats(const __CFURL *a1, off_t *a2, void *a3, timespec *a4, BOOL *a5)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  memset(&v10, 0, sizeof(v10));
  if (a1 && (a2 || a3 || a4 || a5))
  {
    if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    {
      if (stat((const char *)buffer, &v10) == -1)
      {
        return *__error();
      }
      else
      {
        if (a2) {
          *a2 = v10.st_size;
        }
        if (a3) {
          *a3 = v10.st_blocks << 9;
        }
        if (a4) {
          *a4 = v10.st_mtimespec;
        }
        uint64_t result = 0;
        if (a5) {
          *a5 = (v10.st_mode & 0x4000) != 0;
        }
      }
    }
    else
    {
      return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigCFURLIdentifiesSameFileResourceAsCFURL(const __CFURL *a1, const __CFURL *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  bzero(buffer, 0x400uLL);
  bzero(v8, 0x400uLL);
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      memset(&v7, 0, sizeof(v7));
      memset(&v6, 0, sizeof(v6));
      uint64_t result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024);
      if (result)
      {
        uint64_t result = CFURLGetFileSystemRepresentation(a2, 1u, v8, 1024);
        if (result) {
          return stat((const char *)buffer, &v7) != -1
        }
              && stat((const char *)v8, &v6) != -1
              && v7.st_ino == v6.st_ino
              && v7.st_dev == v6.st_dev
              && v7.st_size == v6.st_size
              && v7.st_mtimespec.tv_sec == v6.st_mtimespec.tv_sec
              && v7.st_mtimespec.tv_nsec == v6.st_mtimespec.tv_nsec;
      }
    }
  }
  return result;
}

char *FigCFStringGetCStringPtrAndBufferToFree(CFStringRef theString, CFStringEncoding encoding, char **a3)
{
  if (a3) {
    *a3 = 0;
  }
  if (!theString) {
    return 0;
  }
  CStringPtr = CFStringGetCStringPtr(theString, encoding);
  stat v7 = (char *)CStringPtr;
  if (a3 && !CStringPtr)
  {
    CFIndex Length = CFStringGetLength(theString);
    size_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length + 1, encoding);
    if (MaximumSizeForEncoding == -1) {
      return 0;
    }
    CFIndex v10 = MaximumSizeForEncoding;
    stat v7 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0x44BA675EuLL);
    if (v7)
    {
      if (CFStringGetCString(theString, v7, v10, encoding))
      {
        *a3 = v7;
        return v7;
      }
      free(v7);
      return 0;
    }
  }
  return v7;
}

const char *FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer(const char *result, char *a2, CFIndex a3, CFStringEncoding encoding)
{
  if (result)
  {
    CFStringRef v7 = (const __CFString *)result;
    uint64_t result = CFStringGetCStringPtr((CFStringRef)result, encoding);
    if (!result && a2 && a3)
    {
      if (CFStringGetCString(v7, a2, a3, encoding)) {
        return a2;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t FigCFStringGetOSTypeValue(CFStringRef theString, int *a2)
{
  uint64_t result = 0;
  char v6 = 0;
  *(_DWORD *)buffer = 0;
  if (theString && a2)
  {
    if (CFStringGetLength(theString) == 4)
    {
      uint64_t result = CFStringGetCString(theString, buffer, 5, 0);
      if (result)
      {
        *a2 = (buffer[1] << 16) | (buffer[0] << 24) | (buffer[2] << 8) | buffer[3];
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

__CFString *FigGetCFStringForOSTypeValue(unsigned int a1)
{
  *(_DWORD *)bytes = a1;
  if (a1 == 1936684398) {
    return @"soun";
  }
  if (a1 == 1986618469) {
    return @"vide";
  }
  FigThreadRunOnce(&sLoadFourCharCodeStringOnce, (void (*)(void))figCreateFourCharCodeStuffOnce);
  FigSimpleMutexLock((pthread_mutex_t *)sFourCharCodeStringMutex);
  Value = CFDictionaryGetValue((CFDictionaryRef)sCFStringsForFourCharCodes, (const void *)a1);
  if (!Value)
  {
    *(_DWORD *)bytes = bswap32(a1);
    Value = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 4, 0x600u, 0);
    if (Value)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)sCFStringsForFourCharCodes, (const void *)a1, Value);
      CFRelease(Value);
    }
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)sFourCharCodeStringMutex);
  return (__CFString *)Value;
}

pthread_mutex_t *figCreateFourCharCodeStuffOnce()
{
  sCFStringsForFourCharCodes = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  uint64_t result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  sFourCharCodeStringMutex = (uint64_t)result;
  return result;
}

const void *FigGetCFStringFor3CCValue(unsigned int a1)
{
  unsigned int v4 = a1;
  FigThreadRunOnce(&sLoadThreeCharCodeStringOnce, (void (*)(void))figCreateThreeCharCodeStuffOnce);
  FigSimpleMutexLock((pthread_mutex_t *)sThreeCharCodeStringMutex);
  Value = CFDictionaryGetValue((CFDictionaryRef)sCFStringsForThreeCharCodes, (const void *)a1);
  if (!Value)
  {
    unsigned int v4 = bswap32(a1);
    Value = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)&v4 + 1, 3, 0x600u, 0);
    if (Value)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)sCFStringsForThreeCharCodes, (const void *)a1, Value);
      CFRelease(Value);
    }
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)sThreeCharCodeStringMutex);
  return Value;
}

pthread_mutex_t *figCreateThreeCharCodeStuffOnce()
{
  sCFStringsForThreeCharCodes = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  uint64_t result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  sThreeCharCodeStringMutex = (uint64_t)result;
  return result;
}

CFPropertyListRef FigCFPropertyListCreateFromFigFileFork(const __CFAllocator *a1, int *a2, CFOptionFlags a3, CFPropertyListFormat *a4, CFErrorRef *a5)
{
  size_t size = 0;
  if (!a2)
  {
    CFIndex v10 = 0;
    goto LABEL_11;
  }
  CFIndex v10 = 0;
  if (FigFileForkGetLengthAtOffset(a2, 0, &size))
  {
    CFPropertyListRef v11 = 0;
    goto LABEL_8;
  }
  CFPropertyListRef v11 = 0;
  if ((uint64_t)size >= 1)
  {
    CFIndex v10 = (UInt8 *)malloc_type_malloc(size, 0x9A6C5734uLL);
    if (!FigFileForkRead(a2, v10, size, 0, 0))
    {
      CFDataRef v12 = CFDataCreate(a1, v10, size);
      if (v12)
      {
        CFDataRef v13 = v12;
        CFPropertyListRef v11 = CFPropertyListCreateWithData(a1, v12, a3, a4, a5);
        CFRelease(v13);
        goto LABEL_8;
      }
      FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
    }
LABEL_11:
    CFPropertyListRef v11 = 0;
  }
LABEL_8:
  free(v10);
  return v11;
}

CFDataRef FigCFPropertyListWriteToFigFileFork(CFPropertyListRef propertyList, int *a2, CFPropertyListFormat a3, CFOptionFlags a4, CFErrorRef *a5)
{
  uint64_t v11 = 0;
  CFDataRef result = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], propertyList, a3, a4, a5);
  if (result)
  {
    CFDataRef v7 = result;
    if (!FigFileForkTruncate(a2, 0))
    {
      CFIndex Length = CFDataGetLength(v7);
      if (Length >= 1)
      {
        size_t v9 = Length;
        BytePtr = (UInt8 *)CFDataGetBytePtr(v7);
        if (BytePtr) {
          FigFileForkWrite(a2, BytePtr, v9, 0, &v11);
        }
      }
    }
    CFRelease(v7);
    return (CFDataRef)v11;
  }
  return result;
}

uint64_t FigGetNumberFromCFTypeWithDefault(const __CFString *a1, uint64_t a2)
{
  if (!a1) {
    return a2;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    uint64_t IntValue = CFStringGetIntValue(a1);
    if (!IntValue)
    {
      uint64_t IntValue = 1;
      if (CFStringCompare(a1, @"true", 1uLL))
      {
        uint64_t IntValue = 1;
        if (CFStringCompare(a1, @"yes", 1uLL))
        {
          if (CFStringCompare(a1, @"false", 1uLL) == kCFCompareEqualTo) {
            return 0;
          }
          if (CFStringCompare(a1, @"no", 1uLL) == kCFCompareEqualTo) {
            return 0;
          }
          uint64_t IntValue = a2;
          if (CFStringCompare(a1, @"0", 1uLL) == kCFCompareEqualTo) {
            return 0;
          }
        }
      }
    }
  }
  else
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 == CFNumberGetTypeID())
    {
      unsigned int valuePtr = 0;
      if (CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &valuePtr)) {
        return valuePtr;
      }
      else {
        return a2;
      }
    }
    else
    {
      CFTypeID v7 = CFGetTypeID(a1);
      uint64_t IntValue = a2;
      if (v7 == CFBooleanGetTypeID()) {
        return CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
      }
    }
  }
  return IntValue;
}

unint64_t FigGetLongNumberFromCFTypeWithDefault(const __CFString *a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  if (!a1) {
    return valuePtr;
  }
  CFTypeID v3 = CFGetTypeID(a1);
  if (v3 != CFStringGetTypeID())
  {
    CFTypeID v7 = CFGetTypeID(a1);
    if (v7 == CFNumberGetTypeID()) {
      return (unint64_t)FigCFNumberGetSInt64((const __CFNumber *)a1);
    }
    CFTypeID v9 = CFGetTypeID(a1);
    if (v9 != CFBooleanGetTypeID()) {
      return valuePtr;
    }
    return CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
  }
  if (CFStringCompare(a1, @"true", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"yes", 1uLL) == kCFCompareEqualTo)
  {
    return 1;
  }
  if (CFStringCompare(a1, @"false", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"no", 1uLL) == kCFCompareEqualTo)
  {
    return 0;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFLocaleRef v5 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"en_US_POSIX");
  CFTypeID v6 = CFNumberFormatterCreate(v4, v5, kCFNumberFormatterNoStyle);
  CFNumberFormatterGetValueFromString(v6, a1, 0, kCFNumberLongLongType, &valuePtr);
  if (v5) {
    CFRelease(v5);
  }
  if (v6) {
    CFRelease(v6);
  }
  return valuePtr;
}

CFNumberRef FigCFNumberGetSInt64(const __CFNumber *result)
{
  uint64_t valuePtr = 0;
  if (result)
  {
    CFNumberRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v1, kCFNumberSInt64Type, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t FigGetCFPreferenceNumberWithDefault(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  CFStringRef v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  uint64_t NumberFromCFTypeWithDefault = FigGetNumberFromCFTypeWithDefault(v4, a3);
  if (v4) {
    CFRelease(v4);
  }
  return NumberFromCFTypeWithDefault;
}

unint64_t FigGetCFPreferenceLongNumberWithDefault(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  CFStringRef v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  Longuint64_t NumberFromCFTypeWithDefault = FigGetLongNumberFromCFTypeWithDefault(v4, a3);
  if (v4) {
    CFRelease(v4);
  }
  return LongNumberFromCFTypeWithDefault;
}

double FigGetCFPreferenceDoubleWithDefault(const __CFString *a1, const __CFString *a2)
{
  CFStringRef v2 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  FigGetDoubleFromCFTypeWithDefault(v2);
  double v4 = v3;
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

uint64_t FigGetBooleanFromCFTypeWithDefault(const __CFString *a1, uint64_t a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFBooleanGetTypeID())
    {
      return *MEMORY[0x1E4F1CFD0] == (void)a1;
    }
    else
    {
      CFTypeID v5 = CFGetTypeID(a1);
      if (v5 == CFNumberGetTypeID())
      {
        int valuePtr = 0;
        CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &valuePtr);
        return valuePtr != 0;
      }
      else
      {
        CFTypeID v6 = CFGetTypeID(a1);
        if (v6 == CFStringGetTypeID())
        {
          if (CFStringCompare(a1, @"true", 1uLL)
            && CFStringCompare(a1, @"yes", 1uLL)
            && CFStringCompare(a1, @"1", 1uLL))
          {
            if (CFStringCompare(a1, @"false", 1uLL) == kCFCompareEqualTo
              || CFStringCompare(a1, @"no", 1uLL) == kCFCompareEqualTo
              || CFStringCompare(a1, @"0", 1uLL) == kCFCompareEqualTo)
            {
              return 0;
            }
          }
          else
          {
            return 1;
          }
        }
      }
    }
  }
  return a2;
}

uint64_t FigGetCFPreferenceBooleanWithDefault(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  CFStringRef v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  uint64_t BooleanFromCFTypeWithDefault = FigGetBooleanFromCFTypeWithDefault(v4, a3);
  if (v4) {
    CFRelease(v4);
  }
  return BooleanFromCFTypeWithDefault;
}

uint64_t FigReplaceURLWithString(__CFDictionary *a1, const void *a2, const void *a3, CFURLRef relativeURL)
{
  CFURLRef v7 = CFURLCopyAbsoluteURL(relativeURL);
  if (v7)
  {
    CFURLRef v8 = v7;
    CFStringRef v9 = CFURLGetString(v7);
    CFDictionaryRemoveValue(a1, a2);
    CFDictionarySetValue(a1, a3, v9);
    CFRelease(v8);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigReplaceStringWithURL(__CFDictionary *a1, const void *a2, const void *a3, CFStringRef URLString)
{
  CFURLRef v7 = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], URLString, 0);
  if (v7)
  {
    CFURLRef v8 = v7;
    CFDictionaryRemoveValue(a1, a2);
    CFDictionarySetValue(a1, a3, v8);
    CFRelease(v8);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  }
}

CFURLRef FigCFURLCreateFromSystemTemporaryDirectory(const __CFAllocator *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  bzero(buffer, 0x400uLL);
  CFIndex v2 = confstr(65537, (char *)buffer, 0x400uLL) - 1;
  if (v2 < 1 || (CFURLRef result = CFURLCreateFromFileSystemRepresentation(a1, buffer, v2, 1u)) == 0)
  {
    FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

CFURLRef FigCFURLCreateFromTemporaryFileWithDirectoryAndSuffix(const __CFAllocator *a1, const __CFURL *a2, const char *a3, const char *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  bzero(buffer, 0x400uLL);
  bzero(__str, 0x400uLL);
  if (a2)
  {
    if (!FigCFURLDoesDirectoryExist(a2) || !CFURLGetFileSystemRepresentation(a2, 1u, buffer, 1024)) {
      goto LABEL_11;
    }
  }
  else if ((uint64_t)(confstr(65537, (char *)buffer, 0x400uLL) - 1) <= 0)
  {
    goto LABEL_11;
  }
  if (a4)
  {
    snprintf(__str, 0x400uLL, "%s/%sXXXXXX%s", (const char *)buffer, a3, a4);
    int v8 = strlen(a4);
    mkstemps(__str, v8);
  }
  else
  {
    snprintf(__str, 0x400uLL, "%s/%sXXXXXX", (const char *)buffer, a3);
    mkstemp(__str);
  }
  int64_t v9 = strlen(__str);
  if (v9 > 0) {
    return CFURLCreateFromFileSystemRepresentation(a1, (const UInt8 *)__str, v9, 0);
  }
LABEL_11:
  FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  return 0;
}

CFURLRef FigCFURLCreateFromTemporaryFileWithDirectory(const __CFAllocator *a1, const __CFURL *a2, const char *a3)
{
  return FigCFURLCreateFromTemporaryFileWithDirectoryAndSuffix(a1, a2, a3, 0);
}

uint64_t FigCFAttributedStringSetDouble(__CFAttributedString *a1, CFIndex a2, CFIndex a3, const __CFString *a4, double a5)
{
  double valuePtr = a5;
  if (a1 && a4)
  {
    CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &valuePtr);
    if (v9)
    {
      CFNumberRef v10 = v9;
      v14.CFIndex location = a2;
      v14.length = a3;
      CFAttributedStringSetAttribute(a1, v14, a4, v9);
      CFRelease(v10);
      return 0;
    }
    else
    {
      return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
}

BOOL FigCFRangeEqual(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

uint64_t FigCFRangeGetLimit(uint64_t a1, uint64_t a2)
{
  return a1 + a2;
}

uint64_t FigCFIntersectionRange(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 > result || result >= a3 + a4)
  {
    if (a3 < result + a2) {
      uint64_t v4 = a3;
    }
    else {
      uint64_t v4 = 0;
    }
    if (result <= a3) {
      return v4;
    }
    else {
      return 0;
    }
  }
  return result;
}

BOOL FigCFIntersectsRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 < a3 + a4 && a3 < a1 + a2;
}

CFTypeRef FigCopyCFPreferenceAppValueOrOptionCFTypeWithDefault(const __CFDictionary *a1, CFStringRef key, CFStringRef applicationID, const void *a4)
{
  CFTypeRef result = CFPreferencesCopyAppValue(key, applicationID);
  if (!a1 || result)
  {
LABEL_5:
    if (result) {
      return result;
    }
    goto LABEL_6;
  }
  Value = CFDictionaryGetValue(a1, key);
  if (Value)
  {
    CFTypeRef result = CFRetain(Value);
    goto LABEL_5;
  }
LABEL_6:
  if (!a4) {
    return 0;
  }

  return CFRetain(a4);
}

uint64_t FigGetCFPreferenceOrOptionNumberWithDefault(const __CFDictionary *a1, const __CFString *key, const __CFString *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  unsigned int valuePtr = a4;
  if (a1)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, key);
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      uint64_t v4 = valuePtr;
    }
  }
  return FigGetCFPreferenceNumberWithDefault(key, a3, v4);
}

void FigGetCFPreferenceOrOptionDoubleWithDefault(const __CFDictionary *a1, const __CFString *key, const __CFString *a3, double a4)
{
  double valuePtr = a4;
  if (a1)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, key);
    if (Value) {
      CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
    }
  }
  FigGetCFPreferenceDoubleWithDefault(key, a3);
}

uint64_t FigGetGlobalCFAllocatorFigMalloc()
{
  if (FigGetGlobalCFAllocatorFigMalloc_sOnceToken != -1) {
    dispatch_once_f(&FigGetGlobalCFAllocatorFigMalloc_sOnceToken, &FigGetGlobalCFAllocatorFigMalloc_sFigCFAllocatorFigMalloc, (dispatch_function_t)figCreateFigCFAllocatorFigMallocOnceFunc);
  }
  return FigGetGlobalCFAllocatorFigMalloc_sFigCFAllocatorFigMalloc;
}

CFAllocatorRef figCreateFigCFAllocatorFigMallocOnceFunc(CFAllocatorRef *a1)
{
  CFAllocatorRef result = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &sFigCFAllocatorFigMallocContext);
  *a1 = result;
  return result;
}

uint64_t FigCreateCFAllocatorFigMallocWithDeallocCallback(void (__cdecl *a1)(void *, void *), CFTypeRef *a2)
{
  memset(&v7, 0, sizeof(v7));
  if (FigGetGlobalCFAllocatorFigMalloc_sOnceToken != -1) {
    dispatch_once_f(&FigGetGlobalCFAllocatorFigMalloc_sOnceToken, &FigGetGlobalCFAllocatorFigMalloc_sFigCFAllocatorFigMalloc, (dispatch_function_t)figCreateFigCFAllocatorFigMallocOnceFunc);
  }
  CFAllocatorGetContext((CFAllocatorRef)FigGetGlobalCFAllocatorFigMalloc_sFigCFAllocatorFigMalloc, &v7);
  v7.deallocate = a1;
  CFAllocatorRef v4 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &v7);
  if (!v4) {
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  CFAllocatorRef v5 = v4;
  *a2 = CFRetain(v4);
  CFRelease(v5);
  return 0;
}

dispatch_object_t figDispatchCFCollectionRetainCallBack(int a1, dispatch_object_t object)
{
  return object;
}

void figDispatchCFCollectionReleaseCallBack(int a1, dispatch_object_t object)
{
}

CFStringRef figDispatchQueueCFCollectionCopyDescriptionCallBack(NSObject *a1)
{
  label = dispatch_queue_get_label(a1);
  size_t v2 = strlen(label);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];

  return CFStringCreateWithBytes(v3, (const UInt8 *)label, v2, 0x8000100u, 0);
}

void *figBlockCFCollectionRetainCallBack(int a1, void *aBlock)
{
  return _Block_copy(aBlock);
}

void figBlockCFCollectionReleaseCallBack(int a1, void *aBlock)
{
}

CFNumberRef FigCFNumberCreateUInt8(const __CFAllocator *a1, __int16 a2)
{
  char v6 = a2;
  if ((a2 & 0x80) != 0)
  {
    __int16 valuePtr = a2;
    p___int16 valuePtr = &valuePtr;
    CFNumberType v3 = kCFNumberSInt16Type;
  }
  else
  {
    p___int16 valuePtr = (__int16 *)&v6;
    CFNumberType v3 = kCFNumberSInt8Type;
  }
  return CFNumberCreate(a1, v3, p_valuePtr);
}

CFNumberRef FigCFNumberCreateUInt16(const __CFAllocator *a1, int a2)
{
  __int16 v6 = a2;
  if ((a2 & 0x8000) != 0)
  {
    int valuePtr = a2;
    p_int valuePtr = (__int16 *)&valuePtr;
    CFNumberType v3 = kCFNumberSInt32Type;
  }
  else
  {
    p_int valuePtr = &v6;
    CFNumberType v3 = kCFNumberSInt16Type;
  }
  return CFNumberCreate(a1, v3, p_valuePtr);
}

CFNumberRef FigCFNumberCreateUInt32(const __CFAllocator *a1, unsigned int a2)
{
  unsigned int v6 = a2;
  if ((a2 & 0x80000000) != 0)
  {
    uint64_t v5 = a2;
    size_t v2 = &v5;
    CFNumberType v3 = kCFNumberSInt64Type;
  }
  else
  {
    size_t v2 = (uint64_t *)&v6;
    CFNumberType v3 = kCFNumberSInt32Type;
  }
  return CFNumberCreate(a1, v3, v2);
}

uint64_t FigCFNumberGetUInt8(const __CFNumber *a1)
{
  __int16 valuePtr = 0;
  if (a1 && (CFTypeID v2 = CFGetTypeID(a1), v2 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(a1, kCFNumberSInt16Type, &valuePtr);
    return valuePtr;
  }
  else
  {
    return 0;
  }
}

uint64_t FigCFNumberGetUInt16(const __CFNumber *a1)
{
  int valuePtr = 0;
  if (a1 && (CFTypeID v2 = CFGetTypeID(a1), v2 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(a1, kCFNumberSInt32Type, &valuePtr);
    return (unsigned __int16)valuePtr;
  }
  else
  {
    return 0;
  }
}

CFNumberRef FigCFNumberGetUInt32(const __CFNumber *result)
{
  uint64_t valuePtr = 0;
  if (result)
  {
    CFNumberRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v1, kCFNumberSInt64Type, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFNumberRef FigCFNumberGetUInt64(const __CFNumber *result)
{
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  if (result)
  {
    CFNumberGetValue(result, kCFNumberMaxType|kCFNumberSInt8Type, &v1);
    return (const __CFNumber *)v2;
  }
  return result;
}

CFNumberRef FigCFNumberCreateSInt8(const __CFAllocator *a1, char a2)
{
  char valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberSInt8Type, &valuePtr);
}

uint64_t FigCFNumberGetSInt8(const __CFNumber *a1)
{
  char valuePtr = 0;
  if (a1 && (CFTypeID v2 = CFGetTypeID(a1), v2 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(a1, kCFNumberSInt8Type, &valuePtr);
    return valuePtr;
  }
  else
  {
    return 0;
  }
}

uint64_t FigCFNumberGetSInt16(const __CFNumber *a1)
{
  __int16 valuePtr = 0;
  if (a1 && (CFTypeID v2 = CFGetTypeID(a1), v2 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(a1, kCFNumberSInt16Type, &valuePtr);
    return valuePtr;
  }
  else
  {
    return 0;
  }
}

CFNumberRef FigCFNumberGetSInt32(const __CFNumber *result)
{
  unsigned int valuePtr = 0;
  if (result)
  {
    CFNumberRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFNumberRef FigCFNumberCreateFloat32(const __CFAllocator *a1, float a2)
{
  float valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberFloat32Type, &valuePtr);
}

CFNumberRef FigCFNumberCreateFloat64(const __CFAllocator *a1, double a2)
{
  double valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberFloat64Type, &valuePtr);
}

float FigCFNumberGetFloat32(const void *a1)
{
  float valuePtr = 0.0;
  float v1 = 0.0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(a1);
    if (v3 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)a1, kCFNumberFloat32Type, &valuePtr);
      return valuePtr;
    }
  }
  return v1;
}

double FigCFNumberGetFloat64(const void *a1)
{
  double valuePtr = 0.0;
  double v1 = 0.0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(a1);
    if (v3 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)a1, kCFNumberFloat64Type, &valuePtr);
      return valuePtr;
    }
  }
  return v1;
}

__CFDictionary *FigCFCopyCFErrorAsPropertyList(__CFError *a1)
{
  CFTypeRef cf = 0;
  if (!a1) {
    return 0;
  }
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFIndex valuePtr = CFErrorGetCode(a1);
    CFNumberRef v4 = CFNumberCreate(v2, kCFNumberCFIndexType, &valuePtr);
    if (v4)
    {
      CFNumberRef v5 = v4;
      CFDictionarySetValue(Mutable, @"CFError_Code", v4);
      CFRelease(v5);
    }
    Domain = (__CFString *)CFErrorGetDomain(a1);
    value = Domain;
    if (Domain) {
      CFDictionarySetValue(Mutable, @"CFError_Domain", Domain);
    }
    CFDictionaryRef v7 = CFErrorCopyUserInfo(a1);
    if (v7)
    {
      CFDictionaryRef v8 = v7;
      if (CFDictionaryGetValueIfPresent(v7, (const void *)*MEMORY[0x1E4F1D170], (const void **)&value)) {
        CFDictionarySetValue(Mutable, @"CFError_LocalizedDescription", value);
      }
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E4F1D178], (const void **)&value)) {
        CFDictionarySetValue(Mutable, @"CFError_LocalizedFailureReason", value);
      }
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E4F1D180], (const void **)&value)) {
        CFDictionarySetValue(Mutable, @"CFError_LocalizedRecoverySuggestion", value);
      }
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E4F1D140], (const void **)&value)) {
        CFDictionarySetValue(Mutable, @"CFError_Description", value);
      }
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E4F1D188], (const void **)&value))
      {
        CFStringRef v9 = CFURLGetString((CFURLRef)value);
        CFDictionarySetValue(Mutable, @"CFError_URL", v9);
      }
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E4F1D168], (const void **)&value)) {
        CFDictionarySetValue(Mutable, @"CFError_FilePath", value);
      }
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E4F1D190], (const void **)&value))
      {
        CFNumberRef v10 = (const void *)FigCFCopyCFErrorAsPropertyList(value);
        if (v10)
        {
          uint64_t v11 = v10;
          CFDictionarySetValue(Mutable, @"CFError_UnderlyingError", v10);
          CFRelease(v11);
        }
      }
      if (!FigCreateSerializedDictionaryFromNSErrorUserInfo(v8, (__CFDictionary **)&cf)) {
        FigCFDictionaryAddEntriesToDictionaryWithRecursion(cf, Mutable, 1);
      }
      if (cf) {
        CFRelease(cf);
      }
      CFRelease(v8);
    }
  }
  return Mutable;
}

CFDictionaryRef FigCFErrorCreateFromPropertyList(const __CFDictionary *a1)
{
  CFDictionaryRef v1 = a1;
  value = 0;
  CFIndex valuePtr = 0;
  CFDictionaryRef theDict = 0;
  CFTypeRef cf = 0;
  if (a1)
  {
    if (CFDictionaryGetValueIfPresent(a1, @"CFError_Code", (const void **)&theDict)
      && (CFNumberGetValue(theDict, kCFNumberCFIndexType, &valuePtr),
          CFDictionaryGetValueIfPresent(v1, @"CFError_Domain", (const void **)&value))
      && (CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
          (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) != 0))
    {
      CFNumberRef v4 = Mutable;
      if (CFDictionaryGetValueIfPresent(v1, @"CFError_LocalizedDescription", (const void **)&theDict)) {
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F1D170], theDict);
      }
      if (CFDictionaryGetValueIfPresent(v1, @"CFError_LocalizedFailureReason", (const void **)&theDict)) {
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F1D178], theDict);
      }
      if (CFDictionaryGetValueIfPresent(v1, @"CFError_LocalizedRecoverySuggestion", (const void **)&theDict)) {
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F1D180], theDict);
      }
      if (CFDictionaryGetValueIfPresent(v1, @"CFError_Description", (const void **)&theDict)) {
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F1D140], theDict);
      }
      if (CFDictionaryGetValueIfPresent(v1, @"CFError_URL", (const void **)&theDict))
      {
        CFURLRef v5 = CFURLCreateWithString(v2, (CFStringRef)theDict, 0);
        if (v5)
        {
          CFURLRef v6 = v5;
          CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F1D188], v5);
          CFRelease(v6);
        }
      }
      if (CFDictionaryGetValueIfPresent(v1, @"CFError_FilePath", (const void **)&theDict)) {
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F1D168], theDict);
      }
      if (CFDictionaryGetValueIfPresent(v1, @"CFError_UnderlyingError", (const void **)&theDict))
      {
        CFDictionaryRef v7 = (const void *)FigCFErrorCreateFromPropertyList(theDict);
        if (v7)
        {
          CFDictionaryRef v8 = v7;
          CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F1D190], v7);
          CFRelease(v8);
        }
      }
      if (!FigCreateNSErrorUserInfoFromSerializedDictionary(v1, (__CFDictionary **)&cf)) {
        FigCFDictionaryAddEntriesToDictionaryWithRecursion(cf, v4, 1);
      }
      if (cf) {
        CFRelease(cf);
      }
      CFDictionaryRef v1 = CFErrorCreate(v2, (CFErrorDomain)value, valuePtr, v4);
      CFRelease(v4);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t FigCFCopyPropertyAsTime(uint64_t a1, uint64_t a2, uint64_t a3, CMTime *a4)
{
  CFDictionaryRef dictionaryRepresentation = 0;
  memset(&v14, 0, sizeof(v14));
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(a1) + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  CFNumberRef v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFDictionaryRef *))(v9 + 48);
  if (v10)
  {
    uint64_t v11 = v10(a1, a2, a3, &dictionaryRepresentation);
    CFDictionaryRef v12 = dictionaryRepresentation;
    if (!v11 && dictionaryRepresentation)
    {
      CMTimeMakeFromDictionary(&v14, dictionaryRepresentation);
      CFDictionaryRef v12 = dictionaryRepresentation;
    }
    if (v12) {
      CFRelease(v12);
    }
  }
  else
  {
    uint64_t v11 = 4294954514;
  }
  *a4 = v14;
  return v11;
}

uint64_t FigCFSetPropertyToTime(uint64_t a1, uint64_t a2, CMTime *a3)
{
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CMTime v12 = *a3;
  CFDictionaryRef v6 = CMTimeCopyAsDictionary(&v12, v5);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable(a1) + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, CFDictionaryRef))(v8 + 56);
  if (v9)
  {
    uint64_t v10 = v9(a1, a2, v6);
    if (!v6) {
      return v10;
    }
    goto LABEL_8;
  }
  uint64_t v10 = 4294954514;
  if (v6) {
LABEL_8:
  }
    CFRelease(v6);
  return v10;
}

uint64_t FigCFSetCopyValuesAsCFArray(const __CFSet *a1, CFArrayRef *a2)
{
  size_t Count = CFSetGetCount(a1);
  if (!a1)
  {
    uint64_t v8 = 0;
LABEL_10:
    CFDictionaryRef v6 = 0;
    goto LABEL_6;
  }
  if (!a2)
  {
    uint64_t v8 = FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  CFIndex v5 = Count;
  CFDictionaryRef v6 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
  if (v6
    && (CFSetGetValues(a1, v6),
        (CFArrayRef v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, v5, MEMORY[0x1E4F1D510])) != 0))
  {
    uint64_t v8 = 0;
    *a2 = v7;
  }
  else
  {
    uint64_t v8 = FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  }
LABEL_6:
  free(v6);
  return v8;
}

uint64_t FigCFArrayCopyValuesAsCFSet(const __CFArray *a1, CFSetRef *a2)
{
  if (a1)
  {
    size_t Count = CFArrayGetCount(a1);
    if (a2)
    {
      CFIndex v5 = Count;
      CFDictionaryRef v6 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
      if (v6
        && (v10.CFIndex location = 0,
            v10.length = v5,
            CFArrayGetValues(a1, v10, v6),
            (CFSetRef v7 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, v5, MEMORY[0x1E4F1D548])) != 0))
      {
        uint64_t v8 = 0;
        *a2 = v7;
      }
      else
      {
        uint64_t v8 = FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      uint64_t v8 = FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      CFDictionaryRef v6 = 0;
    }
  }
  else
  {
    CFDictionaryRef v6 = 0;
    uint64_t v8 = 0;
  }
  free(v6);
  return v8;
}

__CFSet *FigCFSetCreateFromArray(const __CFAllocator *a1, CFArrayRef theArray)
{
  if (theArray) {
    CFIndex Count = CFArrayGetCount(theArray);
  }
  else {
    CFIndex Count = 0;
  }
  CFMutableDictionaryRef Mutable = CFSetCreateMutable(a1, Count, MEMORY[0x1E4F1D548]);
  if (Mutable) {
    BOOL v6 = Count < 1;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    CFIndex v7 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v7);
      CFSetAddValue(Mutable, ValueAtIndex);
      ++v7;
    }
    while (Count != v7);
  }
  return Mutable;
}

BOOL FigCFSetContainsValue(CFSetRef theSet, const void *a2)
{
  BOOL result = 0;
  if (theSet)
  {
    if (a2) {
      return CFSetContainsValue(theSet, a2) != 0;
    }
  }
  return result;
}

CGColorRef FigCreateCGColorSRGB(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  components[4] = *(CGFloat *)MEMORY[0x1E4F143B8];
  components[0] = a1;
  components[1] = a2;
  components[2] = a3;
  components[3] = a4;
  CFNumberRef v4 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
  CFIndex v5 = v4;
  if (v4) {
    CGColorRef v6 = CGColorCreate(v4, components);
  }
  else {
    CGColorRef v6 = 0;
  }
  CGColorSpaceRelease(v5);
  return v6;
}

CFMutableArrayRef FigCopyCGColorSRGBAsArray(void *a1)
{
  if (!a1 || (CFTypeID v2 = CFGetTypeID(a1), v2 != CGColorGetTypeID()))
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (CGColorGetNumberOfComponents((CGColorRef)a1) != 4) {
    return 0;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    Components = CGColorGetComponents((CGColorRef)a1);
    if (Components)
    {
      CFIndex v5 = Components;
      uint64_t v6 = 0;
      do
      {
        float v7 = v5[v6];
        float v10 = v7;
        if (figCFArrayAppendNumber(Mutable, kCFNumberFloatType, &v10)) {
          break;
        }
      }
      while (v6++ != 3);
    }
  }
  return Mutable;
}

CGColorRef FigCreateCGColorSRGBFromArray(const void *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (a1 && (CFTypeID v2 = CFGetTypeID(a1), v2 == CFArrayGetTypeID()) && CFArrayGetCount((CFArrayRef)a1) == 4)
  {
    CFIndex v3 = 0;
    for (i = &v6; figCFArrayGetNumberAtIndex(a1, v3, kCFNumberFloatType, i); i = (uint64_t *)((char *)i + 4))
    {
      if (++v3 == 4) {
        return FigCreateCGColorSRGB(*(float *)&v6, *((float *)&v6 + 1), *(float *)&v7, *((float *)&v7 + 1));
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigStorageCreate(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (a3)
  {
    FigGetAllocatorForMedia();
    FigThreadRunOnce(&FigStorageGetTypeID_sFigStorageRegisterOnce, (void (*)(void))FigStorage_initOnce);
    uint64_t Instance = _CFRuntimeCreateInstance();
    *(void *)(Instance + 16) = a2;
    *a3 = Instance;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigStorageRefGetBytePtr(uint64_t a1)
{
  return a1 + 24;
}

uint64_t FigGetMedianValueOfCArray(uint64_t a1, uint64_t a2, uint64_t (*a3)(void, uint64_t, void), uint64_t (*a4)(const void *, uint64_t), size_t a5)
{
  CFIndex v5 = 0;
  if (!a1) {
    return (uint64_t)v5;
  }
  uint64_t v6 = a2 - 1;
  if (a2 < 1) {
    return (uint64_t)v5;
  }
  unint64_t v10 = a2 & 0x8000000000000001;
  unint64_t v11 = (unint64_t)a2 >> 1;
  CMTime v12 = *(const void **)(a1 + 8 * figGetIndexOfNthSmallestValue(a1, 0, v6, a3, (unint64_t)a2 >> 1));
  if (v10 == 1)
  {
    uint64_t v13 = malloc_type_malloc(a5, 0x5B635DDuLL);
    CFIndex v5 = v13;
    if (v13) {
      memcpy(v13, v12, a5);
    }
    return (uint64_t)v5;
  }
  uint64_t v15 = *(void *)(a1 + 8 * figGetIndexOfNthSmallestValue(a1, 0, v6, a3, v11 - 1));

  return a4(v12, v15);
}

uint64_t figGetIndexOfNthSmallestValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, uint64_t, void), uint64_t a5)
{
  if (a2 != a3)
  {
    uint64_t v6 = a3;
    uint64_t v8 = a2;
    while (1)
    {
      uint64_t v28 = a2;
      if (v6 - v8 < 5)
      {
        uint64_t SubMedian = figFindSubMedian(a1, v8, v6, a4);
      }
      else
      {
        if (v6 >= v8)
        {
          uint64_t v9 = 0;
          do
          {
            uint64_t v10 = v9 / 5 + v8;
            if (v8 + v9 + 4 >= v6) {
              uint64_t v11 = v6;
            }
            else {
              uint64_t v11 = v8 + v9 + 4;
            }
            uint64_t v12 = figFindSubMedian(a1, v8 + v9, v11, a4);
            uint64_t v13 = *(void *)(a1 + 8 * v12);
            *(void *)(a1 + 8 * v12) = *(void *)(a1 + 8 * v10);
            *(void *)(a1 + 8 * v10) = v13;
            v9 += 5;
          }
          while (v8 + v9 <= v6);
        }
        uint64_t SubMedian = figGetIndexOfNthSmallestValue(a1, v8, (v6 - v8) / 5 + v8, a4, v8 + (v6 - v8) / 10 + 1);
      }
      uint64_t v15 = *(void *)(a1 + 8 * SubMedian);
      *(void *)(a1 + 8 * SubMedian) = *(void *)(a1 + 8 * v6);
      *(void *)(a1 + 8 * v6) = v15;
      uint64_t v16 = v8;
      uint64_t v17 = v6 - v8;
      if (v6 > v8)
      {
        CFStringRef v18 = (void *)(a1 + 8 * v8);
        uint64_t v16 = v8;
        do
        {
          if (a4(*v18, v15, 0) == -1)
          {
            uint64_t v19 = *(void *)(a1 + 8 * v16);
            *(void *)(a1 + 8 * v16) = *v18;
            *CFStringRef v18 = v19;
            ++v16;
          }
          ++v18;
          --v17;
        }
        while (v17);
      }
      uint64_t v20 = v16;
      uint64_t v21 = v6 - v16;
      if (v6 > v16)
      {
        CFURLRef v22 = (void *)(a1 + 8 * v16);
        uint64_t v20 = v16;
        do
        {
          if (!a4(*v22, v15, 0))
          {
            uint64_t v23 = *(void *)(a1 + 8 * v20);
            *(void *)(a1 + 8 * v20) = *v22;
            *CFURLRef v22 = v23;
            ++v20;
          }
          ++v22;
          --v21;
        }
        while (v21);
      }
      uint64_t v24 = *(void *)(a1 + 8 * v6);
      *(void *)(a1 + 8 * v6) = *(void *)(a1 + 8 * v20);
      *(void *)(a1 + 8 * v20) = v24;
      if (v20 >= a5) {
        uint64_t v25 = a5;
      }
      else {
        uint64_t v25 = v20;
      }
      if (v16 > a5) {
        uint64_t v25 = v16;
      }
      if (v25 == a5) {
        break;
      }
      if (v16 <= a5) {
        uint64_t v8 = v25 + 1;
      }
      else {
        uint64_t v6 = v16 - 1;
      }
      a2 = v28;
      if (v16 <= a5) {
        a2 = v25 + 1;
      }
      if (v8 == v6) {
        return a2;
      }
    }
    return a5;
  }
  return a2;
}

CFStringRef FigCreateBase32EncodedSHA1HashFromCFString(const __CFString *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFStringRef v10 = 0;
  *(void *)md = 0;
  uint64_t v12 = 0;
  int v13 = 0;
  *(void *)len = 0;
  CFTypeID v2 = FigDigestSHA1Create();
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  BytesFromCFString = FigCreateBytesFromCFString(AllocatorForMedia, a1, 0x8000100u, 0, len);
  if (BytesFromCFString)
  {
    CFIndex v5 = BytesFromCFString;
    FigDigestSHA1AppendData(v2, BytesFromCFString, len[0]);
    FigDigestSHA1GetDigest(v2, md);
    CFAllocatorRef v6 = (const __CFAllocator *)FigGetAllocatorForMedia();
    FigCreateBase32EncodedStringFromBytes(v6, (uint64_t)md, 20, 0, &v10);
    CFAllocatorRef v7 = (const __CFAllocator *)FigGetAllocatorForMedia();
    CFAllocatorDeallocate(v7, v5);
  }
  FigDigestSHA1Destroy(v2);
  return v10;
}

uint64_t figCFAppendCompactDictionaryDescription(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 8)) {
    CFStringAppend(*(CFMutableStringRef *)a3, @", ");
  }
  figCFAppendCompactDescription(*(CFMutableStringRef *)a3);
  CFStringAppend(*(CFMutableStringRef *)a3, @" = ");
  uint64_t result = figCFAppendCompactDescription(*(CFMutableStringRef *)a3);
  *(unsigned char *)(a3 + 8) = 1;
  return result;
}

CFIndex figCFAppendArrayToCompactDescription(__CFString *a1, CFArrayRef theArray)
{
  CFIndex result = CFArrayGetCount(theArray);
  if (result >= 1)
  {
    CFIndex v5 = result;
    for (CFIndex i = 0; i != v5; ++i)
    {
      CFArrayGetValueAtIndex(theArray, i);
      if (i) {
        CFStringAppend(a1, @", ");
      }
      CFIndex result = figCFAppendCompactDescription(a1);
    }
  }
  return result;
}

uint64_t _FigCFIOKitObjectInit(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t _FigCFIOKitObjectFinalize(uint64_t a1)
{
  uint64_t result = IOObjectRelease(*(_DWORD *)(a1 + 16));
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

void *figCFAllocatorAllocate(size_t a1)
{
  return malloc_type_malloc(a1, 0x69261C97uLL);
}

void *figCFAllocatorReallocate(void *a1, size_t a2)
{
  return malloc_type_realloc(a1, a2, 0x8AD6C2F7uLL);
}

uint64_t FigStorage_initOnce()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigStorageID = result;
  return result;
}

uint64_t figStorage_finalize(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 16))(a1 + 24);
}

uint64_t figFindSubMedian(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, uint64_t, void))
{
  if (a2 < a3)
  {
    uint64_t v8 = a2;
    do
    {
      uint64_t v9 = v8++;
      if (v9 >= a2)
      {
        uint64_t v10 = *(void *)(a1 + 8 * v8);
        do
        {
          if (a4(*(void *)(a1 + 8 * v9), v10, 0) != 1) {
            break;
          }
          uint64_t v11 = (uint64_t *)(a1 + 8 * v9);
          uint64_t v12 = *v11;
          uint64_t v10 = v11[1];
          *uint64_t v11 = v10;
          v11[1] = v12;
        }
        while (v9-- > a2);
      }
    }
    while (v8 != a3);
  }
  uint64_t v14 = a3 + a2;
  if (a3 + a2 < 0 != __OFADD__(a3, a2)) {
    ++v14;
  }
  return v14 >> 1;
}

uint64_t FigHALAudioDeviceGetClassID()
{
  if (FigHALAudioDeviceGetClassID_sRegisterFigHALAudioDeviceClassOnce != -1) {
    dispatch_once(&FigHALAudioDeviceGetClassID_sRegisterFigHALAudioDeviceClassOnce, &__block_literal_global_19);
  }
  return FigHALAudioDeviceGetClassID_sFigHALAudioDeviceClassID;
}

uint64_t __FigHALAudioDeviceGetClassID_block_invoke()
{
  ClassID = (void *)FigHALAudioObjectGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&FigHALAudioDeviceGetClassID_sFigHALAudioDeviceClassDesc, ClassID, 0, &FigHALAudioDeviceGetClassID_sFigHALAudioDeviceClassID);
}

uint64_t FigAudioFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigAudioFormatDescriptionRegisterOnce, (void (*)(void))FigAudioFormatDescriptionRegisterOnce);
}

OSStatus CMAudioFormatDescriptionCreate(CFAllocatorRef allocator, const AudioStreamBasicDescription *asbd, size_t layoutSize, const AudioChannelLayout *layout, size_t magicCookieSize, const void *magicCookie, CFDictionaryRef extensions, CMAudioFormatDescriptionRef *formatDescriptionOut)
{
  CFTypeRef cf = 0;
  if (!asbd || !formatDescriptionOut || asbd->mSampleRate == 0.0)
  {
    uint64_t v10 = 4294954586;
LABEL_5:
    OSStatus v11 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
LABEL_6:
    if (v11 && cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
    if (formatDescriptionOut) {
      goto LABEL_10;
    }
    return v11;
  }
  FigThreadRunOnce(&sFigAudioFormatDescriptionRegisterOnce, (void (*)(void))FigAudioFormatDescriptionRegisterOnce);
  OSStatus v11 = FigDerivedFormatDescriptionCreate(allocator, (void *)0x736F756E, asbd->mFormatID, extensions, (uint64_t *)&cf);
  if (v11) {
    goto LABEL_6;
  }
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf);
  uint64_t v20 = *(void *)&asbd->mBitsPerChannel;
  long long v21 = *(_OWORD *)&asbd->mBytesPerPacket;
  *(_OWORD *)uint64_t DerivedStorage = *(_OWORD *)&asbd->mSampleRate;
  *(_OWORD *)(DerivedStorage + 16) = v21;
  *(void *)(DerivedStorage + 32) = v20;
  if (layoutSize && layout)
  {
    CFURLRef v22 = CFAllocatorAllocate(allocator, layoutSize, 0);
    *(void *)(DerivedStorage + 64) = v22;
    if (!v22) {
      goto LABEL_27;
    }
    memcpy(v22, layout, layoutSize);
    *(void *)(DerivedStorage + 56) = layoutSize;
  }
  if (magicCookieSize && magicCookie)
  {
    uint64_t v23 = CFAllocatorAllocate(allocator, magicCookieSize, 0);
    *(void *)(DerivedStorage + 48) = v23;
    if (v23)
    {
      memcpy(v23, magicCookie, magicCookieSize);
      *(void *)(DerivedStorage + 40) = magicCookieSize;
      goto LABEL_21;
    }
LABEL_27:
    uint64_t v10 = 4294954585;
    goto LABEL_5;
  }
LABEL_21:
  CFTypeRef v24 = cf;
  uint64_t v25 = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf);
  uint64_t v62 = 0;
  *(_DWORD *)size_t size = 0;
  CFAllocatorRef v26 = CFGetAllocator(v24);
  uint64_t v27 = *(void *)(v25 + 32);
  long long v28 = *(_OWORD *)(v25 + 16);
  *(_OWORD *)&size[4] = *(_OWORD *)v25;
  long long v59 = v28;
  uint64_t v29 = *(void *)(v25 + 48);
  uint64_t v60 = v27;
  uint64_t v61 = v29;
  LODWORD(v62) = *(void *)(v25 + 40);
  if (!AudioToolbox_AudioFormatGetPropertyInfo(1718383476, 56, (uint64_t)&size[4], (uint64_t)size)
    && *(_DWORD *)size >= 0x30u)
  {
    v30 = CFAllocatorAllocate(v26, *(unsigned int *)size, 0);
    if (!v30)
    {
      FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      goto LABEL_48;
    }
    CFRange v31 = v30;
    if (!AudioToolbox_AudioFormatGetProperty(1718383476, 56, (uint64_t)&size[4], (uint64_t)size, (uint64_t)v30))
    {
      unsigned int v32 = *(_DWORD *)size;
      if (*(_DWORD *)size > 0x2Fu) {
        goto LABEL_26;
      }
    }
    CFAllocatorDeallocate(v26, v31);
    *(_DWORD *)size_t size = 0;
  }
  if (v24)
  {
    uint64_t v33 = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)v24);
    *(_DWORD *)size_t size = 48;
    v34 = CFAllocatorAllocate(v26, 48, 0);
    if (v34)
    {
      v35 = v34;
      long long v36 = *(_OWORD *)v33;
      long long v37 = *(_OWORD *)(v33 + 16);
      v34[4] = *(void *)(v33 + 32);
      *(_OWORD *)v34 = v36;
      *((_OWORD *)v34 + 1) = v37;
      int v38 = *(_DWORD *)(v33 + 28);
      if (v38 == 1) {
        int v39 = 6553601;
      }
      else {
        int v39 = -65536;
      }
      if (v38 == 2) {
        int v40 = 6619138;
      }
      else {
        int v40 = v39;
      }
      *((_DWORD *)v34 + 10) = v40;
      v41 = *(_DWORD **)(v33 + 64);
      if (v41)
      {
        unsigned int ChannelLayoutTagFromLayout = getChannelLayoutTagFromLayout(v41, *(void *)(v33 + 56));
        unsigned int v43 = *((_DWORD *)v35 + 10);
        if (v43 > 0xFFFEFFFF) {
          int v44 = 2;
        }
        else {
          int v44 = 3;
        }
        BOOL v45 = ChannelLayoutTagFromLayout != v43 || ChannelLayoutTagFromLayout >= 0xFFFF0000;
        *((_DWORD *)v35 + 10) = ChannelLayoutTagFromLayout;
        if (!v45) {
          int v44 = 1;
        }
        *(void *)(v25 + 80) = *(unsigned int *)size;
        *(void *)(v25 + 88) = v35;
        *(_DWORD *)(v25 + 72) = v44;
      }
      else
      {
        *(void *)(v25 + 80) = *(unsigned int *)size;
        *(void *)(v25 + 88) = v35;
      }
      goto LABEL_48;
    }
    uint64_t v54 = 4294954585;
  }
  else
  {
    uint64_t v54 = 4294954586;
  }
  if (!FigSignalErrorAt(v54, 0, 0, 0, 0, 0, 0))
  {
    CFRange v31 = 0;
    unsigned int v32 = *(_DWORD *)size;
LABEL_26:
    *(void *)(v25 + 80) = v32;
    *(void *)(v25 + 88) = v31;
  }
LABEL_48:
  figAudioFormatDescriptionEnsureRichestDecodableLayout((const opaqueCMFormatDescription *)cf);
  figAudioFormatDescriptionEnsureMostCompatibleLayout((const opaqueCMFormatDescription *)cf);
  v46 = *(_DWORD **)(DerivedStorage + 64);
  if (!v46 || (unint64_t v47 = *(void *)(DerivedStorage + 56)) == 0)
  {
    OSStatus v11 = 0;
LABEL_10:
    *formatDescriptionOut = (CMAudioFormatDescriptionRef)cf;
    return v11;
  }
  *(void *)size_t size = 0xFFFF000000000000;
  __int16 v56 = 0;
  int v55 = 0;
  evaluateLayoutAgainstFormatList(*(void *)(DerivedStorage + 88), *(void *)(DerivedStorage + 80), v46, v47, size, (int *)&size[4], (unsigned char *)&v56 + 1, &v56, &v55);
  int v48 = *(_DWORD *)(DerivedStorage + 72);
  if ((v48 & 0xFFFFFFFE) != 2)
  {
    int v48 = v55;
    *(_DWORD *)(DerivedStorage + 72) = v55;
    if (!v48)
    {
      v49 = *(void **)(DerivedStorage + 64);
      if (v49)
      {
        CFAllocatorDeallocate(allocator, v49);
        *(void *)(DerivedStorage + 64) = 0;
        int v48 = *(_DWORD *)(DerivedStorage + 72);
      }
      else
      {
        int v48 = 0;
      }
      *(void *)(DerivedStorage + 56) = 0;
    }
  }
  if ((v48 & 0xFFFFFFFE) == 2)
  {
    uint64_t v50 = *(void *)(DerivedStorage + 88);
    if (v50)
    {
      unint64_t v51 = *(void *)(DerivedStorage + 80);
      if (v51 >= 0x30)
      {
        unint64_t v52 = v51 / 0x30;
        v53 = (_DWORD *)(v50 + 40);
        do
        {
          if (*(_DWORD *)size == *(v53 - 3)) {
            _DWORD *v53 = *(_DWORD *)&size[4];
          }
          v53 += 12;
          --v52;
        }
        while (v52);
      }
    }
  }
  if (!*(void *)(DerivedStorage + 64))
  {
    figAudioFormatDescriptionEnsureRichestDecodableLayout((const opaqueCMFormatDescription *)cf);
    figAudioFormatDescriptionEnsureMostCompatibleLayout((const opaqueCMFormatDescription *)cf);
  }
  OSStatus v11 = 0;
  if (formatDescriptionOut) {
    goto LABEL_10;
  }
  return v11;
}

uint64_t figAudioFormatDescriptionEnsureRichestDecodableLayout(const opaqueCMFormatDescription *a1)
{
  if (a1 && CMFormatDescriptionGetMediaType(a1) == 1936684398)
  {
    uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
    uint64_t v3 = (void *)(DerivedStorage + 104);
    if (*(void *)(DerivedStorage + 104)) {
      return 0;
    }
    CFNumberRef v4 = (void *)DerivedStorage;
    RichestDecodableFormat = CMAudioFormatDescriptionGetRichestDecodableFormat(a1);
    if (RichestDecodableFormat)
    {
      CFAllocatorRef v6 = RichestDecodableFormat;
      uint64_t v7 = v4[8];
      if (v7)
      {
        uint64_t v8 = v4[7];
        if (v8)
        {
          UInt32 mChannelsPerFrame = v6->mASBD.mChannelsPerFrame;
          if (mChannelsPerFrame == FigGetAudioChannelCountFromLayout(v7, v8)) {
            return 0;
          }
        }
      }
      CFAllocatorRef v11 = CFGetAllocator(a1);
      uint64_t v12 = allocAudioChannelLayoutForAudioChannelLayoutTag(v11, v6->mChannelLayoutTag, v4 + 12, v3);
      if (v12) {
        return v12;
      }
      uint64_t v13 = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
      if (!*(void *)(v13 + 136))
      {
        uint64_t v14 = v13;
        size_t sizeOut = 0;
        FormatList = CMAudioFormatDescriptionGetFormatList(a1, &sizeOut);
        uint64_t v10 = 0;
        if (!FormatList || sizeOut < 0x90) {
          return v10;
        }
        uint64_t v16 = FormatList;
        size_t v17 = sizeOut;
        size_t v18 = sizeOut / 0x30;
        int64_t v19 = sizeOut / 0x30 - 2;
        CFAllocatorRef v20 = CFGetAllocator(a1);
        long long v21 = (char *)CFAllocatorAllocate(v20, 16 * v19, 0);
        if (v21)
        {
          CFURLRef v22 = v21;
          bzero(v21, 16 * v19);
          uint64_t v23 = 0;
          p_mChannelLayoutTag = &v16[1].mChannelLayoutTag;
          do
          {
            if (16 * v18 - 16 == v23 + 16)
            {
              uint64_t v10 = 0;
              *(void *)(v14 + 128) = v19;
              *(void *)(v14 + 136) = v22;
              return v10;
            }
            CFAllocatorRef v25 = CFGetAllocator(a1);
            uint64_t v26 = allocAudioChannelLayoutForAudioChannelLayoutTag(v25, *p_mChannelLayoutTag, (uint64_t *)&v22[v23], &v22[v23 + 8]);
            p_mChannelLayoutTag += 12;
            v23 += 16;
          }
          while (!v26);
          uint64_t v10 = v26;
          uint64_t v27 = 0;
          if (v19 <= 1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = v17 / 0x30 - 2;
          }
          uint64_t v29 = 16 * v28;
          do
          {
            if (*(void *)&v22[v27 + 8])
            {
              CFAllocatorRef v30 = CFGetAllocator(a1);
              CFAllocatorDeallocate(v30, *(void **)&v22[v27 + 8]);
            }
            v27 += 16;
          }
          while (v29 != v27);
          CFAllocatorRef v31 = CFGetAllocator(a1);
          CFAllocatorDeallocate(v31, v22);
          return v10;
        }
        return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      }
      return 0;
    }
    uint64_t v33 = 4294954578;
  }
  else
  {
    uint64_t v33 = 4294954586;
  }

  return FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
}

uint64_t figAudioFormatDescriptionEnsureMostCompatibleLayout(const opaqueCMFormatDescription *a1)
{
  if (!a1 || CMFormatDescriptionGetMediaType(a1) != 1936684398)
  {
    uint64_t v13 = 4294954586;
LABEL_14:
    return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
  }
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  uint64_t v3 = (void *)(DerivedStorage + 120);
  if (*(void *)(DerivedStorage + 120)) {
    return 0;
  }
  CFNumberRef v4 = (void *)DerivedStorage;
  MostCompatibleFormat = CMAudioFormatDescriptionGetMostCompatibleFormat(a1);
  if (!MostCompatibleFormat)
  {
    uint64_t v13 = 4294954578;
    goto LABEL_14;
  }
  CFAllocatorRef v6 = MostCompatibleFormat;
  uint64_t v7 = v4[8];
  if (v7)
  {
    uint64_t v8 = v4[7];
    if (v8)
    {
      UInt32 mChannelsPerFrame = v6->mASBD.mChannelsPerFrame;
      if (mChannelsPerFrame == FigGetAudioChannelCountFromLayout(v7, v8)) {
        return 0;
      }
    }
  }
  CFAllocatorRef v11 = CFGetAllocator(a1);
  unsigned int mChannelLayoutTag = v6->mChannelLayoutTag;

  return allocAudioChannelLayoutForAudioChannelLayoutTag(v11, mChannelLayoutTag, v4 + 14, v3);
}

uint64_t evaluateLayoutAgainstFormatList(uint64_t result, unint64_t a2, _DWORD *a3, unint64_t a4, _DWORD *a5, int *a6, unsigned char *a7, unsigned char *a8, int *a9)
{
  int v12 = 0;
  int ChannelLayoutTagFromLayout = -65536;
  unint64_t v14 = a2 - 48;
  if (a2 < 0x30 || (uint64_t v15 = result) == 0 || !a3)
  {
    LOBYTE(v18) = 0;
    LOBYTE(v19) = 0;
    int v20 = 0;
    goto LABEL_34;
  }
  LOBYTE(v18) = 0;
  LOBYTE(v19) = 0;
  int v20 = 0;
  if (a4 < 0xC) {
    goto LABEL_34;
  }
  CFAllocatorRef v31 = a6;
  int ChannelLayoutTagFromLayout = getChannelLayoutTagFromLayout(a3, a4);
  uint64_t result = FigGetAudioChannelCountFromLayout((uint64_t)a3, a4);
  int v12 = result;
  if (!result) {
    goto LABEL_32;
  }
  if (v14 > 0x2F)
  {
    unint64_t v27 = a2 / 0x30 - 1;
    if (HIDWORD(v27))
    {
      uint64_t result = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      goto LABEL_32;
    }
    unsigned int v32 = 0;
    uint64_t result = FigAudioFormatGetRichestDecodableFormatIndex(v15, a2, &v32);
    unsigned int v28 = v32;
    if (result) {
      unsigned int v28 = 0;
    }
    if (v12 == *(_DWORD *)(v15 + 48 * v28 + 28))
    {
      unsigned int v29 = *(_DWORD *)(v15 + 48 * v28 + 40);
      BOOL v23 = ChannelLayoutTagFromLayout == v29;
      BOOL v24 = v29 > 0xFFFEFFFF;
      int v18 = 1;
    }
    else
    {
      int v18 = 0;
      BOOL v23 = 0;
      BOOL v24 = 0;
    }
    if (v12 == *(_DWORD *)(v15 + 48 * v27 + 28))
    {
      unsigned int v30 = *(_DWORD *)(v15 + 48 * v27 + 40);
      BOOL v25 = ChannelLayoutTagFromLayout == v30;
      BOOL v26 = v30 > 0xFFFEFFFF;
      int v19 = 1;
      goto LABEL_20;
    }
    int v19 = 0;
    BOOL v25 = 0;
  }
  else
  {
    if (result == *(_DWORD *)(v15 + 28))
    {
      unsigned int v22 = *(_DWORD *)(v15 + 40);
      BOOL v23 = ChannelLayoutTagFromLayout == v22;
      BOOL v24 = v22 > 0xFFFEFFFF;
      int v18 = 1;
      int v19 = 1;
      BOOL v25 = v23;
      BOOL v26 = v24;
      goto LABEL_20;
    }
    int v18 = 0;
    int v19 = 0;
    BOOL v23 = 0;
    BOOL v25 = 0;
    BOOL v24 = 0;
  }
  BOOL v26 = 0;
LABEL_20:
  if (v19 | v18)
  {
    if (v19 && v26)
    {
      int v20 = 2;
      LOBYTE(v19) = 1;
    }
    else if (v18 && v24)
    {
      int v20 = 2;
      LOBYTE(v18) = 1;
    }
    else if (v25 || v23)
    {
      int v20 = 1;
    }
    else
    {
      int v20 = 3;
    }
    goto LABEL_33;
  }
LABEL_32:
  LOBYTE(v18) = 0;
  LOBYTE(v19) = 0;
  int v20 = 0;
LABEL_33:
  a6 = v31;
LABEL_34:
  if (a7) {
    *a7 = v18;
  }
  if (a8) {
    *a8 = v19;
  }
  if (a5) {
    *a5 = v12;
  }
  if (a6) {
    *a6 = ChannelLayoutTagFromLayout;
  }
  if (a9) {
    *a9 = v20;
  }
  return result;
}

const AudioStreamBasicDescription *__cdecl CMAudioFormatDescriptionGetStreamBasicDescription(CMAudioFormatDescriptionRef desc)
{
  if (desc && CMFormatDescriptionGetMediaType(desc) == 1936684398)
  {
    return (const AudioStreamBasicDescription *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

const void *__cdecl CMAudioFormatDescriptionGetMagicCookie(CMAudioFormatDescriptionRef desc, size_t *sizeOut)
{
  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    size_t v6 = 0;
    uint64_t result = 0;
    if (!sizeOut) {
      return result;
    }
    goto LABEL_6;
  }
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
  uint64_t result = *(const void **)(DerivedStorage + 48);
  size_t v6 = *(void *)(DerivedStorage + 40);
  if (sizeOut) {
LABEL_6:
  }
    *size_t sizeOut = v6;
  return result;
}

const AudioChannelLayout *__cdecl CMAudioFormatDescriptionGetChannelLayout(CMAudioFormatDescriptionRef desc, size_t *sizeOut)
{
  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    uint64_t result = 0;
LABEL_7:
    size_t v6 = 0;
    if (!sizeOut) {
      return result;
    }
    goto LABEL_8;
  }
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
  uint64_t result = *(const AudioChannelLayout **)(DerivedStorage + 64);
  if (!result) {
    goto LABEL_7;
  }
  size_t v6 = *(void *)(DerivedStorage + 56);
  if (sizeOut) {
LABEL_8:
  }
    *size_t sizeOut = v6;
  return result;
}

const AudioStreamBasicDescription *CMAudioFormatDescriptionGetChannelCount(const opaqueCMFormatDescription *a1)
{
  uint64_t result = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
  if (result) {
    return (const AudioStreamBasicDescription *)result->mChannelsPerFrame;
  }
  return result;
}

uint64_t FigAudioFormatDescriptionGetCodecOutputChannelCount(const opaqueCMFormatDescription *a1)
{
  RichestDecodableFormat = CMAudioFormatDescriptionGetRichestDecodableFormat(a1);
  if (!RichestDecodableFormat)
  {
    RichestDecodableFormat = (const AudioFormatListItem *)CMAudioFormatDescriptionGetStreamBasicDescription(a1);
    if (!RichestDecodableFormat) {
      goto LABEL_26;
    }
  }
  AudioFormatID mFormatID = RichestDecodableFormat->mASBD.mFormatID;
  unsigned int size = 0;
  AudioFormatID size_4 = mFormatID;
  size_t sizeOut = 0;
  if (mFormatID != 1819304813)
  {
    if (!AudioToolbox_AudioFormatGetPropertyInfo(1635148901, 4, (uint64_t)&size_4, (uint64_t)&size)
      && size)
    {
      CFNumberRef v4 = (char *)malloc_type_malloc(size, 0xFD690280uLL);
      if (v4)
      {
        if (!AudioToolbox_AudioFormatGetProperty(1635148901, 4, (uint64_t)&size_4, (uint64_t)&size, (uint64_t)v4))
        {
          unsigned int v7 = size;
          MagicCookie = CMAudioFormatDescriptionGetMagicCookie(a1, &sizeOut);
          if (v7 >= 0xC)
          {
            uint64_t v9 = MagicCookie;
            uint64_t v10 = 0;
            CFIndex v5 = 0;
            uint64_t mChannelsPerFrame = 0;
            while (1)
            {
              CFAllocatorRef v11 = &v4[12 * v10];
              if (*((_DWORD *)v11 + 1) == size_4 && *(_DWORD *)v11 != 1935959395)
              {
                long long v12 = *(_OWORD *)&RichestDecodableFormat->mASBD.mBytesPerPacket;
                uint64_t v13 = *(void *)&RichestDecodableFormat->mASBD.mBitsPerChannel;
                v20[0] = *(_OWORD *)&RichestDecodableFormat->mASBD.mSampleRate;
                v20[1] = v12;
                uint64_t v21 = v13;
                unsigned int v22 = v9;
                int v23 = sizeOut;
                uint64_t v14 = *(void *)v11;
                int v25 = *((_DWORD *)v11 + 2);
                uint64_t v24 = v14;
                if (AudioToolbox_AudioFormatGetPropertyInfo(1868983411, 64, (uint64_t)v20, (uint64_t)&size))goto LABEL_28; {
                if (!size)
                }
                  goto LABEL_28;
                CFIndex v5 = (unsigned int *)malloc_type_malloc(size, 0xCA77FD73uLL);
                if (!v5
                  || AudioToolbox_AudioFormatGetProperty(1868983411, 64, (uint64_t)v20, (uint64_t)&size, (uint64_t)v5))
                {
                  goto LABEL_28;
                }
                if (size >= 0x30)
                {
                  unint64_t v15 = size / 0x30uLL;
                  uint64_t v16 = v5 + 7;
                  do
                  {
                    unsigned int v18 = *v16;
                    v16 += 12;
                    unsigned int v17 = v18;
                    if (mChannelsPerFrame <= v18) {
                      uint64_t mChannelsPerFrame = v17;
                    }
                    else {
                      uint64_t mChannelsPerFrame = mChannelsPerFrame;
                    }
                    --v15;
                  }
                  while (v15);
                }
              }
              if (++v10 == v7 / 0xCuLL) {
                goto LABEL_28;
              }
            }
          }
        }
      }
      uint64_t mChannelsPerFrame = 0;
      goto LABEL_27;
    }
LABEL_26:
    uint64_t mChannelsPerFrame = 0;
    CFNumberRef v4 = 0;
LABEL_27:
    CFIndex v5 = 0;
    goto LABEL_28;
  }
  CFNumberRef v4 = 0;
  CFIndex v5 = 0;
  uint64_t mChannelsPerFrame = RichestDecodableFormat->mASBD.mChannelsPerFrame;
LABEL_28:
  free(v5);
  free(v4);
  return mChannelsPerFrame;
}

const AudioFormatListItem *__cdecl CMAudioFormatDescriptionGetRichestDecodableFormat(CMAudioFormatDescriptionRef desc)
{
  size_t sizeOut = 0;
  FormatList = CMAudioFormatDescriptionGetFormatList(desc, &sizeOut);
  uint64_t result = 0;
  int v3 = 0;
  if (FormatList && sizeOut >= 0x30)
  {
    if (FigAudioFormatGetRichestDecodableFormatIndex((uint64_t)FormatList, sizeOut, &v3)) {
      return 0;
    }
    else {
      return &FormatList[v3];
    }
  }
  return result;
}

const AudioFormatListItem *__cdecl CMAudioFormatDescriptionGetFormatList(CMAudioFormatDescriptionRef desc, size_t *sizeOut)
{
  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    uint64_t result = 0;
LABEL_7:
    size_t v6 = 0;
    if (!sizeOut) {
      return result;
    }
    goto LABEL_8;
  }
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
  uint64_t result = *(const AudioFormatListItem **)(DerivedStorage + 88);
  if (!result) {
    goto LABEL_7;
  }
  size_t v6 = *(void *)(DerivedStorage + 80);
  if (sizeOut) {
LABEL_8:
  }
    *size_t sizeOut = v6;
  return result;
}

uint64_t FigAudioFormatGetRichestDecodableFormatIndex(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  int v6 = 0;
  if (a1 && a2 > 0x2F && !HIDWORD(a2) && a3)
  {
    int v5 = 4;
    uint64_t result = AudioToolbox_AudioFormatGetProperty(1718642284, a2, a1, (uint64_t)&v5, (uint64_t)&v6);
    if (!result) {
      *a3 = v6;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

const AudioFormatListItem *__cdecl CMAudioFormatDescriptionGetMostCompatibleFormat(CMAudioFormatDescriptionRef desc)
{
  size_t sizeOut = 0;
  FormatList = CMAudioFormatDescriptionGetFormatList(desc, &sizeOut);
  uint64_t result = 0;
  if (FormatList)
  {
    if (sizeOut >= 0x30) {
      return &FormatList[sizeOut / 0x30 - 1];
    }
  }
  return result;
}

uint64_t FigGetAudioChannelCountFromLayout(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  unsigned int v5 = 0;
  if (a1 && (unint64_t)(a2 - 0x100000000) >= 0xFFFFFFFF0000000CLL)
  {
    int v4 = 4;
    if (AudioToolbox_AudioFormatGetProperty(1852008557, a2, a1, (uint64_t)&v4, (uint64_t)&v5)) {
      return 0;
    }
    else {
      return v5;
    }
  }
  return result;
}

OSStatus CMAudioFormatDescriptionCreateSummary(CFAllocatorRef allocator, CFArrayRef formatDescriptionArray, uint32_t flags, CMAudioFormatDescriptionRef *formatDescriptionOut)
{
  memset(&v42.mFormatID, 0, 32);
  if (formatDescriptionOut)
  {
    *formatDescriptionOut = 0;
    if (formatDescriptionArray && (CFIndex Count = CFArrayGetCount(formatDescriptionArray)) != 0)
    {
      uint64_t v8 = Count;
      v42.double mSampleRate = 0.0;
      CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      if (Mutable)
      {
        uint64_t v10 = Mutable;
        size_t sizeOut = 0;
        CFDataIncreaseLength(Mutable, 12);
        if (v8 < 1)
        {
          UInt32 mChannelsPerFrame = 0;
          double mSampleRate = 0.0;
        }
        else
        {
          UInt32 mChannelsPerFrame = 0;
          CFIndex v12 = 0;
          double mSampleRate = 0.0;
          do
          {
            CFDictionaryRef ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(formatDescriptionArray, v12);
            if (ValueAtIndex)
            {
              unint64_t v15 = ValueAtIndex;
              if (CMFormatDescriptionGetMediaType(ValueAtIndex) == 1936684398)
              {
                StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(v15);
                if (StreamBasicDescription)
                {
                  if (mSampleRate < StreamBasicDescription->mSampleRate) {
                    double mSampleRate = StreamBasicDescription->mSampleRate;
                  }
                  if (mChannelsPerFrame <= StreamBasicDescription->mChannelsPerFrame) {
                    UInt32 mChannelsPerFrame = StreamBasicDescription->mChannelsPerFrame;
                  }
                  ChannelLayout = (AudioChannelLayout *)CMAudioFormatDescriptionGetChannelLayout(v15, &sizeOut);
                  if (ChannelLayout && sizeOut) {
                    appendToSummaryChannelLayout(v10, ChannelLayout);
                  }
                }
              }
            }
            ++v12;
          }
          while (v8 != v12);
        }
        cleanUpSummaryAndGetChannelLayoutSize(v10);
        MutableBytePtr = CFDataGetMutableBytePtr(v10);
        if (!*(_DWORD *)MutableBytePtr)
        {
          int v23 = MutableBytePtr;
          uint64_t v24 = *((unsigned int *)MutableBytePtr + 2);
          if (v24)
          {
            uint64_t v25 = 0;
            unsigned int v26 = 0;
            int v27 = 0;
            int v28 = 0;
            unsigned int v29 = (int *)(MutableBytePtr + 12);
            do
            {
              int v31 = *v29;
              v29 += 5;
              int v30 = v31;
              if ((v31 & 0xFFFF0000) == 0x10000) {
                int v32 = v27;
              }
              else {
                int v32 = 1;
              }
              if (v30 == 42) {
                int v33 = 1;
              }
              else {
                int v33 = v28;
              }
              if (v30 == 42)
              {
                int v32 = v27;
                unsigned int v34 = v25;
              }
              else
              {
                unsigned int v34 = v26;
              }
              if (v30 != 100)
              {
                int v28 = v33;
                int v27 = v32;
                unsigned int v26 = v34;
              }
              ++v25;
            }
            while (v24 != v25);
            if (v28 && (_BYTE)v27)
            {
              uint64_t v46 = 0;
              uint64_t v45 = 0;
              int v48 = 0;
              uint64_t v47 = 0;
              v49.CFIndex location = 20 * v26 + 12;
              v49.length = 20;
              CFDataDeleteBytes(v10, v49);
              --*((_DWORD *)v23 + 2);
              int v44 = 6619138;
              appendToSummaryChannelLayout(v10, &v44);
            }
          }
        }
        unsigned int v22 = CFDataGetMutableBytePtr(v10);
        if (*(_DWORD *)v22)
        {
          if (*(_DWORD *)v22 != 0x10000 || *((_DWORD *)v22 + 1) || mChannelsPerFrame - 1 >= 2) {
            goto LABEL_54;
          }
        }
        else if (*((_DWORD *)v22 + 2) || mChannelsPerFrame - 1 > 1)
        {
          goto LABEL_54;
        }
        uint64_t v46 = 0;
        uint64_t v45 = 0;
        int v48 = 0;
        uint64_t v47 = 0;
        if (mChannelsPerFrame == 1) {
          int v35 = 6553601;
        }
        else {
          int v35 = 6619138;
        }
        int v44 = v35;
        appendToSummaryChannelLayout(v10, &v44);
LABEL_54:
        size_t ChannelLayoutSize = cleanUpSummaryAndGetChannelLayoutSize(v10);
        if (ChannelLayoutSize < 0xC)
        {
          int v39 = 0;
          size_t v37 = 0;
        }
        else
        {
          size_t v37 = ChannelLayoutSize;
          int v38 = (AudioChannelLayout *)malloc_type_malloc(ChannelLayoutSize, 0x678D86DEuLL);
          if (!v38)
          {
            OSStatus v18 = -12711;
            FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_65:
            CFRelease(v10);
            return v18;
          }
          int v39 = v38;
          int v40 = CFDataGetMutableBytePtr(v10);
          memcpy(v39, v40, v37);
        }
        v42.AudioFormatID mFormatID = 1819304813;
        v42.double mSampleRate = mSampleRate;
        UInt32 AudioChannelCountFromLayout = FigGetAudioChannelCountFromLayout((uint64_t)v39, v37);
        v42.UInt32 mChannelsPerFrame = AudioChannelCountFromLayout;
        if (AudioChannelCountFromLayout)
        {
          UInt32 mChannelsPerFrame = AudioChannelCountFromLayout;
        }
        else
        {
          v42.UInt32 mChannelsPerFrame = mChannelsPerFrame;
          if (v39)
          {
            free(v39);
            int v39 = 0;
            size_t v37 = 0;
          }
        }
        v42.mBitsPerChannel = 32;
        v42.mFramesPerPacket = 1;
        v42.mBytesPerFrame = 4 * mChannelsPerFrame;
        v42.mFormatFlags = 9;
        v42.mBytesPerPacket = 4 * mChannelsPerFrame;
        OSStatus v18 = CMAudioFormatDescriptionCreate(allocator, &v42, v37, v39, 0, 0, 0, formatDescriptionOut);
        if (v39) {
          free(v39);
        }
        goto LABEL_65;
      }
      OSStatus v18 = -12711;
      uint64_t v19 = 4294954585;
    }
    else
    {
      OSStatus v18 = -12710;
      uint64_t v19 = 4294954586;
    }
  }
  else
  {
    OSStatus v18 = -12710;
    uint64_t v19 = 4294954586;
  }
  FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
  return v18;
}

void appendToSummaryChannelLayout(CFMutableDataRef theData, _DWORD *a2)
{
  CFTypeID v2 = a2;
  int v4 = *a2;
  if (*a2 && !a2[2])
  {
    LODWORD(size) = 0;
    if (v4 == 0x10000)
    {
      uint64_t v20 = (uint64_t)(a2 + 1);
      uint64_t v21 = 1668116578;
    }
    else
    {
      uint64_t v21 = 1668116588;
      uint64_t v20 = (uint64_t)a2;
    }
    if (AudioToolbox_AudioFormatGetPropertyInfo(v21, 4, v20, (uint64_t)&size)) {
      return;
    }
    if (!size) {
      return;
    }
    unsigned int v22 = malloc_type_calloc(1uLL, size, 0x6FA21849uLL);
    if (!v22) {
      return;
    }
    unsigned int v5 = v22;
    if (*v2 == 0x10000)
    {
      uint64_t v23 = (uint64_t)(v2 + 1);
      uint64_t v24 = 1668116578;
    }
    else
    {
      uint64_t v24 = 1668116588;
      uint64_t v23 = (uint64_t)v2;
    }
    if (AudioToolbox_AudioFormatGetProperty(v24, 4, v23, (uint64_t)&size, (uint64_t)v5))
    {
LABEL_23:
      free(v5);
      return;
    }
  }
  else
  {
    unsigned int v5 = 0;
  }
  if (v5) {
    CFTypeID v2 = v5;
  }
  uint64_t v6 = v2[2];
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    MutableBytePtr = 0;
    do
    {
      if (!MutableBytePtr)
      {
        MutableBytePtr = CFDataGetMutableBytePtr(theData);
        uint64_t v8 = *((unsigned int *)MutableBytePtr + 2);
      }
      uint64_t v10 = &v2[5 * v7];
      int v13 = v10[3];
      CFAllocatorRef v11 = (const UInt8 *)(v10 + 3);
      int v12 = v13;
      if (v13)
      {
        if (v8)
        {
          uint64_t v14 = 0;
          unint64_t v15 = &v2[5 * v7];
          uint64_t v16 = v15 + 4;
          unsigned int v17 = (float *)(v15 + 5);
          OSStatus v18 = (float *)(v15 + 6);
          uint64_t v19 = (float *)(v15 + 7);
          while (v12 != *(_DWORD *)&MutableBytePtr[v14 + 12]
               || v12 == 100
               && (*v16 != *(_DWORD *)&MutableBytePtr[v14 + 16]
                || *v17 != *(float *)&MutableBytePtr[v14 + 20]
                || *v18 != *(float *)&MutableBytePtr[v14 + 24]
                || *v19 != *(float *)&MutableBytePtr[v14 + 28]))
          {
            v14 += 20;
            if (20 * v8 == v14) {
              goto LABEL_20;
            }
          }
        }
        else
        {
LABEL_20:
          *(_DWORD *)MutableBytePtr = 0;
          ++*((_DWORD *)MutableBytePtr + 2);
          CFDataAppendBytes(theData, v11, 20);
          MutableBytePtr = 0;
        }
      }
      ++v7;
    }
    while (v7 != v6);
  }
  if (v5) {
    goto LABEL_23;
  }
}

uint64_t cleanUpSummaryAndGetChannelLayoutSize(__CFData *a1)
{
  int v20 = 0;
  MutableBytePtr = CFDataGetMutableBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  if (*(_DWORD *)MutableBytePtr) {
    goto LABEL_2;
  }
  unint64_t v5 = *((unsigned int *)MutableBytePtr + 2);
  if (!v5) {
    goto LABEL_2;
  }
  if (*((_DWORD *)MutableBytePtr + 3) == 42) {
    goto LABEL_11;
  }
  uint64_t v6 = (int *)(MutableBytePtr + 32);
  uint64_t v7 = 1;
  do
  {
    unint64_t v8 = v7;
    if (v5 == v7) {
      break;
    }
    int v9 = *v6;
    v6 += 5;
    ++v7;
  }
  while (v9 != 42);
  if (v8 < v5)
  {
LABEL_11:
    if (v5 == 1) {
      goto LABEL_14;
    }
LABEL_2:
    if (v20) {
      *(_DWORD *)MutableBytePtr = v20;
    }
    return Length;
  }
  if (v5 < 2) {
    goto LABEL_2;
  }
LABEL_14:
  int v21 = 4;
  if (!AudioToolbox_AudioFormatGetProperty(1668116596, Length, (uint64_t)MutableBytePtr, (uint64_t)&v21, (uint64_t)&v20))goto LABEL_2; {
  int v10 = *((_DWORD *)MutableBytePtr + 2);
  }
  if (v10)
  {
    uint64_t v11 = (v10 - 1);
    if (v11)
    {
      for (unint64_t i = 0; i != v11; ++i)
      {
        int v13 = &MutableBytePtr[20 * i + 12];
        uint64_t v14 = (uint64_t)&MutableBytePtr[20 * v11 + 12];
        uint64_t v15 = v11 - 1;
        do
        {
          if (*(_DWORD *)v14 < *(_DWORD *)v13)
          {
            long long v22 = *(_OWORD *)v13;
            long long v16 = v22;
            int v23 = *(_DWORD *)&MutableBytePtr[20 * i + 28];
            int v17 = v23;
            int v18 = *(_DWORD *)(v14 + 16);
            *(_OWORD *)int v13 = *(_OWORD *)v14;
            *(_DWORD *)&MutableBytePtr[20 * i + 28] = v18;
            *(_OWORD *)uint64_t v14 = v16;
            *(_DWORD *)(v14 + 16) = v17;
          }
          BOOL v19 = i >= v15--;
          v14 -= 20;
        }
        while (!v19);
      }
    }
  }
  if (!AudioToolbox_AudioFormatGetProperty(1668116596, Length, (uint64_t)MutableBytePtr, (uint64_t)&v21, (uint64_t)&v20))goto LABEL_2; {
  return Length;
  }
}

Boolean CMAudioFormatDescriptionEqual(CMAudioFormatDescriptionRef formatDescription, CMAudioFormatDescriptionRef otherFormatDescription, CMAudioFormatDescriptionMask equalityMask, CMAudioFormatDescriptionMask *equalityMaskOut)
{
  v45[2] = *MEMORY[0x1E4F143B8];
  memset(v40, 0, sizeof(v40));
  memset(v39, 0, sizeof(v39));
  if (formatDescription
    && otherFormatDescription
    && (char v6 = equalityMask, CMFormatDescriptionGetMediaType(formatDescription) == 1936684398)
    && CMFormatDescriptionGetMediaType(otherFormatDescription) == 1936684398)
  {
    CMAudioFormatDescriptionMask v8 = v6 & 0xF;
    if (formatDescription != otherFormatDescription)
    {
      size_t v41 = 0;
      size_t sizeOut = 0;
      uint64_t DerivedStorage = (const AudioFormatListItem *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)formatDescription);
      int v10 = (const AudioFormatListItem *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)otherFormatDescription);
      if ((v6 & 5) != 0)
      {
        FormatList = CMAudioFormatDescriptionGetFormatList(formatDescription, &sizeOut);
        int v12 = CMAudioFormatDescriptionGetFormatList(otherFormatDescription, &v41);
        int v13 = v12;
        if (FormatList && sizeOut >= 0x30)
        {
          if ((unsigned __int16)FormatList->mChannelLayoutTag)
          {
            LODWORD(v40[0]) = FormatList->mChannelLayoutTag;
            unint64_t v14 = (unint64_t)v40;
            unint64_t v15 = 12;
          }
          else
          {
            unint64_t v15 = *(void *)&DerivedStorage[1].mASBD.mFormatID;
            unint64_t v14 = *(void *)&DerivedStorage[1].mASBD.mBytesPerPacket;
          }
        }
        else
        {
          unint64_t v15 = *(void *)&DerivedStorage[1].mASBD.mFormatID;
          unint64_t v14 = *(void *)&DerivedStorage[1].mASBD.mBytesPerPacket;
          FormatList = DerivedStorage;
        }
        if (v12 && v41 >= 0x30)
        {
          if ((unsigned __int16)v12->mChannelLayoutTag)
          {
            LODWORD(v39[0]) = v12->mChannelLayoutTag;
            unint64_t v19 = (unint64_t)v39;
            size_t v18 = 12;
            if (v6)
            {
LABEL_47:
              size_t v28 = v18;
              unint64_t v37 = v15;
              int v38 = (_OWORD *)v19;
              unsigned int v29 = (_DWORD *)v14;
              if (!memcmp(FormatList, v13, 0x24uLL))
              {
                Boolean v16 = 1;
                unint64_t v14 = (unint64_t)v29;
                unint64_t v15 = v37;
                unint64_t v19 = (unint64_t)v38;
                size_t v18 = v28;
              }
              else
              {
                if (!equalityMaskOut) {
                  return 0;
                }
                unint64_t v14 = (unint64_t)v29;
                size_t v18 = v28;
                Boolean v16 = 0;
                CMAudioFormatDescriptionMask v8 = v6 & 0xE;
                unint64_t v15 = v37;
                unint64_t v19 = (unint64_t)v38;
              }
LABEL_26:
              if ((v6 & 2) == 0) {
                goto LABEL_36;
              }
              size_t v20 = *(void *)&DerivedStorage->mChannelLayoutTag;
              if (v20 == *(void *)&v10->mChannelLayoutTag
                && (Float64 mSampleRate = DerivedStorage[1].mASBD.mSampleRate,
                    Float64 v22 = v10[1].mASBD.mSampleRate,
                    (*(void *)&mSampleRate != 0) ^ (*(void *)&v22 == 0)))
              {
                if (!v20 || mSampleRate == 0.0)
                {
LABEL_36:
                  if ((v6 & 4) == 0) {
                    goto LABEL_42;
                  }
                  goto LABEL_37;
                }
                int v23 = (_OWORD *)v19;
                size_t v24 = v18;
                uint64_t v25 = (_DWORD *)v14;
                if (!memcmp(*(const void **)&mSampleRate, *(const void **)&v22, v20))
                {
                  unint64_t v14 = (unint64_t)v25;
                  size_t v18 = v24;
                  unint64_t v19 = (unint64_t)v23;
                  if ((v6 & 4) == 0) {
                    goto LABEL_42;
                  }
LABEL_37:
                  int v43 = 4;
                  int v44 = 0;
                  if ((v18 == 0) != (v15 == 0)) {
                    goto LABEL_40;
                  }
                  if (v15 | v18)
                  {
                    if ((v19 == 0) != (v14 == 0)) {
                      goto LABEL_40;
                    }
                    if (v19 | v14)
                    {
                      if (v15 != v18
                        || !v19
                        || !v14
                        || (int v30 = (_DWORD *)v14,
                            size_t v31 = v18,
                            int v32 = (_OWORD *)v19,
                            int v33 = memcmp((const void *)v14, (const void *)v19, v18),
                            unint64_t v19 = (unint64_t)v32,
                            size_t v18 = v31,
                            unint64_t v14 = (unint64_t)v30,
                            v33))
                      {
                        unsigned int v34 = (_DWORD *)v19;
                        unint64_t v35 = v18;
                        unint64_t v36 = v14;
                        if (!isValidAudioChannelLayoutAndSize((_DWORD *)v14, v15)
                          || !isValidAudioChannelLayoutAndSize(v34, v35))
                        {
                          FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
                          goto LABEL_40;
                        }
                        v45[0] = v36;
                        v45[1] = v34;
                        if (AudioToolbox_AudioFormatGetProperty(1667786097, 16, (uint64_t)v45, (uint64_t)&v43, (uint64_t)&v44)|| !(_BYTE)v44)
                        {
LABEL_40:
                          if (equalityMaskOut)
                          {
                            Boolean v16 = 0;
                            v8 &= ~4u;
                            goto LABEL_42;
                          }
                          return 0;
                        }
                      }
                    }
                  }
LABEL_42:
                  if ((v6 & 8) != 0)
                  {
                    CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(formatDescription);
                    CFDictionaryRef v27 = CMFormatDescriptionGetExtensions(otherFormatDescription);
                    if (!FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(Extensions, v27, 0, 0))
                    {
                      Boolean v16 = 0;
                      if (equalityMaskOut) {
                        v8 &= ~8u;
                      }
                    }
                  }
                  goto LABEL_12;
                }
                if (!equalityMaskOut) {
                  return 0;
                }
                unint64_t v14 = (unint64_t)v25;
                size_t v18 = v24;
                unint64_t v19 = (unint64_t)v23;
              }
              else if (!equalityMaskOut)
              {
                return 0;
              }
              Boolean v16 = 0;
              v8 &= ~2u;
              goto LABEL_36;
            }
          }
          else
          {
            size_t v18 = *(void *)&v10[1].mASBD.mFormatID;
            unint64_t v19 = *(void *)&v10[1].mASBD.mBytesPerPacket;
            if (v6) {
              goto LABEL_47;
            }
          }
        }
        else
        {
          size_t v18 = *(void *)&v10[1].mASBD.mFormatID;
          unint64_t v19 = *(void *)&v10[1].mASBD.mBytesPerPacket;
          int v13 = v10;
          if (v6) {
            goto LABEL_47;
          }
        }
      }
      else
      {
        size_t v18 = 0;
        unint64_t v15 = 0;
        unint64_t v19 = 0;
        unint64_t v14 = 0;
      }
      Boolean v16 = 1;
      goto LABEL_26;
    }
    Boolean v16 = 1;
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    Boolean v16 = 0;
    CMAudioFormatDescriptionMask v8 = 0;
  }
LABEL_12:
  if (equalityMaskOut) {
    *equalityMaskOut = v8;
  }
  return v16;
}

uint64_t CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(const opaqueCMFormatDescription *a1, const AudioFormatListItem **a2, void *a3, void *a4)
{
  if (a1 && CMFormatDescriptionGetMediaType(a1) == 1936684398)
  {
    if (a2 || (uint64_t v8 = 4294954586, a3) && a4)
    {
      RichestDecodableFormat = CMAudioFormatDescriptionGetRichestDecodableFormat(a1);
      if (RichestDecodableFormat)
      {
        int v10 = RichestDecodableFormat;
        if (a4)
        {
          uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
          int v13 = (uint64_t *)(DerivedStorage + 64);
          uint64_t v12 = *(void *)(DerivedStorage + 64);
          if (!v12
            || (unint64_t v15 = (uint64_t *)(DerivedStorage + 56), (v14 = *(void *)(DerivedStorage + 56)) == 0)
            || (UInt32 mChannelsPerFrame = v10->mASBD.mChannelsPerFrame,
                mChannelsPerFrame != FigGetAudioChannelCountFromLayout(v12, v14)))
          {
            uint64_t result = figAudioFormatDescriptionEnsureRichestDecodableLayout(a1);
            if (result) {
              return result;
            }
            int v13 = (uint64_t *)(DerivedStorage + 104);
            unint64_t v15 = (uint64_t *)(DerivedStorage + 96);
          }
          uint64_t v18 = *v13;
          uint64_t v19 = *v15;
        }
        else
        {
          uint64_t v18 = 0;
          uint64_t v19 = 0;
        }
        if (!v18) {
          uint64_t v19 = 0;
        }
        if (!a4) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }
      uint64_t v8 = 4294954578;
    }
  }
  else
  {
    uint64_t v8 = 4294954586;
  }
  uint64_t result = FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  if (result) {
    return result;
  }
  uint64_t v19 = 0;
  uint64_t v18 = 0;
  int v10 = 0;
  if (a4) {
LABEL_22:
  }
    *a4 = v18;
LABEL_23:
  if (a3) {
    *a3 = v19;
  }
  uint64_t result = 0;
  if (a2) {
    *a2 = v10;
  }
  return result;
}

uint64_t CMAudioFormatDescriptionGetMostCompatibleFormatAndChannelLayout(const opaqueCMFormatDescription *a1, const AudioFormatListItem **a2, void *a3, void *a4)
{
  if (a1 && CMFormatDescriptionGetMediaType(a1) == 1936684398)
  {
    if (a2 || (uint64_t v8 = 4294954586, a3) && a4)
    {
      MostCompatibleFormat = CMAudioFormatDescriptionGetMostCompatibleFormat(a1);
      if (MostCompatibleFormat)
      {
        int v10 = MostCompatibleFormat;
        if (!a4)
        {
          uint64_t v13 = 0;
          uint64_t v19 = 0;
          goto LABEL_22;
        }
        uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
        uint64_t v12 = (void *)DerivedStorage;
        uint64_t v13 = *(void *)(DerivedStorage + 120);
        if (!v13)
        {
          uint64_t v14 = *(void *)(DerivedStorage + 64);
          if (v14)
          {
            Boolean v16 = v12 + 7;
            uint64_t v15 = v12[7];
            if (v15)
            {
              UInt32 mChannelsPerFrame = v10->mASBD.mChannelsPerFrame;
              if (mChannelsPerFrame == FigGetAudioChannelCountFromLayout(v14, v15))
              {
                uint64_t v13 = v12[8];
LABEL_21:
                uint64_t v19 = *v16;
LABEL_22:
                if (!v13) {
                  uint64_t v19 = 0;
                }
                if (!a4) {
                  goto LABEL_26;
                }
                goto LABEL_25;
              }
            }
          }
          uint64_t result = figAudioFormatDescriptionEnsureMostCompatibleLayout(a1);
          if (result) {
            return result;
          }
          uint64_t v13 = v12[15];
        }
        Boolean v16 = v12 + 14;
        goto LABEL_21;
      }
      uint64_t v8 = 4294954578;
    }
  }
  else
  {
    uint64_t v8 = 4294954586;
  }
  uint64_t result = FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  if (result) {
    return result;
  }
  uint64_t v19 = 0;
  uint64_t v13 = 0;
  int v10 = 0;
  if (!a4) {
    goto LABEL_26;
  }
LABEL_25:
  *a4 = v13;
LABEL_26:
  if (a3) {
    *a3 = v19;
  }
  uint64_t result = 0;
  if (a2) {
    *a2 = v10;
  }
  return result;
}

const AudioFormatListItem *FigAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(const opaqueCMFormatDescription *a1, void *a2, void *a3)
{
  char v6 = 0;
  if (!CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(a1, &v6, a2, a3)) {
    return v6;
  }
  if (a2) {
    *a2 = 0;
  }
  uint64_t result = 0;
  if (a3) {
    *a3 = 0;
  }
  return result;
}

const AudioFormatListItem *FigAudioFormatDescriptionGetMostCompatibleFormatAndChannelLayout(const opaqueCMFormatDescription *a1, void *a2, void *a3)
{
  char v6 = 0;
  if (!CMAudioFormatDescriptionGetMostCompatibleFormatAndChannelLayout(a1, &v6, a2, a3)) {
    return v6;
  }
  if (a2) {
    *a2 = 0;
  }
  uint64_t result = 0;
  if (a3) {
    *a3 = 0;
  }
  return result;
}

uint64_t FigAudioFormatDescriptionGetBestDecodableFormatAndChannelLayoutForRenderingPreferences(const opaqueCMFormatDescription *a1, uint64_t a2, uint64_t *a3, void *a4, void *a5)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    goto LABEL_89;
  }
  uint64_t v8 = a2;
  if (!a2)
  {
    uint64_t result = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    goto LABEL_57;
  }
  if (CMFormatDescriptionGetMediaType(a1) != 1936684398)
  {
LABEL_89:
    uint64_t v40 = 4294954586;
    goto LABEL_55;
  }
  if (a3 || a4 && a5)
  {
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    size_t sizeOut = 0;
    unsigned int v53 = 0;
    FormatList = CMAudioFormatDescriptionGetFormatList(a1, &sizeOut);
    if (FormatList)
    {
      size_t v11 = sizeOut;
      if (sizeOut > 0x2F)
      {
        uint64_t v12 = FormatList;
        uint64_t result = FigAudioFormatGetRichestDecodableFormatIndex((uint64_t)FormatList, sizeOut, &v53);
        if (!result)
        {
          int v48 = a1;
          CFRange v49 = a3;
          uint64_t MaximumChannelCountAndPreferredChannelLayout = FigAudioRenderingPreferencesGetMaximumChannelCountAndPreferredChannelLayout(v8, &v56, &v55);
          int64_t v15 = MaximumChannelCountAndPreferredChannelLayout;
          unint64_t v50 = v11 / 0x30;
          if (!v55) {
            goto LABEL_19;
          }
          uint64_t v16 = v53;
          if (MaximumChannelCountAndPreferredChannelLayout > v12[v53].mASBD.mChannelsPerFrame
            || v53 >= (v11 / 0x30))
          {
            goto LABEL_19;
          }
          p_UInt32 mChannelsPerFrame = (uint64_t)&v12[v53].mASBD.mChannelsPerFrame;
          uint64_t v19 = (int *)p_mChannelsPerFrame;
          while (1)
          {
            int v20 = *v19;
            v19 += 12;
            if (v15 == v20)
            {
              *(void *)&v57[4] = 0;
              uint64_t v58 = 0;
              *(_DWORD *)v57 = 0;
              int v51 = 4;
              memset(v52, 0, sizeof(v52));
              LODWORD(v52[0]) = *(_DWORD *)(p_mChannelsPerFrame + 12);
              *(void *)&v57[4] = v52;
              uint64_t v58 = v55;
              AudioToolbox_AudioFormatGetProperty(1667786097, 16, (uint64_t)&v57[4], (uint64_t)&v51, (uint64_t)v57);
              if (*(_DWORD *)v57 == 1) {
                break;
              }
            }
            ++v16;
            p_UInt32 mChannelsPerFrame = (uint64_t)v19;
            if ((v11 / 0x30) == v16) {
              goto LABEL_19;
            }
          }
          if (v16 == -1)
          {
LABEL_19:
            int v21 = malloc_type_calloc(v15, 4uLL, 0x100004052888210uLL);
            if (v21)
            {
              Float64 v22 = v21;
              uint64_t v16 = v53;
              if (v53 >= v50)
              {
LABEL_33:
                free(v22);
              }
              else
              {
                while (1)
                {
                  int v23 = &v12[v16];
                  UInt32 mChannelsPerFrame = v23->mASBD.mChannelsPerFrame;
                  size_t v24 = &v23->mASBD.mChannelsPerFrame;
                  if (v15 >= mChannelsPerFrame)
                  {
                    *(_DWORD *)&v57[8] = 0;
                    uint64_t v58 = 0;
                    *(void *)v57 = (4 * v15);
                    memset(v52, 0, sizeof(v52));
                    LODWORD(v52[0]) = v12[v16].mChannelLayoutTag;
                    *(void *)&v57[4] = v52;
                    uint64_t v58 = v55;
                    if (!AudioToolbox_AudioFormatGetProperty(1667788144, 16, (uint64_t)&v57[4], (uint64_t)v57, (uint64_t)v22)&& ((4 * v15) & 0x3FFFFFFFCLL) == *(unsigned int *)v57)
                    {
                      if (v15 < 1)
                      {
                        int v27 = 0;
                      }
                      else
                      {
                        uint64_t v26 = 0;
                        int v27 = 0;
                        do
                        {
                          if (*((_DWORD *)v22 + v26) != -1) {
                            ++v27;
                          }
                          ++v26;
                        }
                        while (v15 > v26);
                      }
                      if (*v24 == v27) {
                        break;
                      }
                    }
                  }
                  if (++v16 == v50) {
                    goto LABEL_33;
                  }
                }
                free(v22);
                if (v16 != -1) {
                  goto LABEL_62;
                }
              }
            }
            unsigned int v28 = v53;
            unsigned int v29 = v50;
            if (v12[v53].mASBD.mFormatID == 1700997939)
            {
              LODWORD(v52[0]) = 0;
              *(_DWORD *)&v57[4] = 4;
              int Property = AudioToolbox_AudioFormatGetProperty(1936745324, v56, v55, (uint64_t)&v57[4], (uint64_t)v52);
              BOOL v31 = (v52[0] & 0x20) != 0 && Property == 0;
              unsigned int v28 = v53;
              if (!v31)
              {
                int v32 = v50 - v53;
                if (v50 > v53)
                {
                  p_unsigned int mChannelLayoutTag = &v12[v53].mChannelLayoutTag;
                  do
                  {
                    memset((char *)v52 + 4, 0, 28);
                    AudioChannelLayoutTag v34 = *p_mChannelLayoutTag;
                    p_mChannelLayoutTag += 12;
                    LODWORD(v52[0]) = v34;
                    *(void *)v57 = 4;
                    if (!AudioToolbox_AudioFormatGetProperty(1936745324, 32, (uint64_t)v52, (uint64_t)v57, (uint64_t)&v57[4])&& (v57[4] & 0x20) != 0&& v53 < (int)v50 - 1)
                    {
                      ++v53;
                    }
                    --v32;
                  }
                  while (v32);
                  unsigned int v28 = v53;
                  unsigned int v29 = v50;
                }
              }
            }
            if (v28 >= v29) {
              goto LABEL_70;
            }
            uint64_t v35 = v28;
            unint64_t v36 = &v12[v28].mASBD.mChannelsPerFrame;
            unsigned int v37 = -1;
            LODWORD(v16) = -1;
            while (1)
            {
              unsigned int v39 = *v36;
              v36 += 12;
              unsigned int v38 = v39;
              if (v15 >= v39) {
                break;
              }
              if (v38 < v37)
              {
                LODWORD(v16) = v35;
                unsigned int v37 = v38;
              }
              if (v29 == ++v35) {
                goto LABEL_62;
              }
            }
            LODWORD(v16) = v35;
          }
LABEL_62:
          if (v16 >= v53 && v16 < v50)
          {
            uint64_t v8 = (uint64_t)&v12[v16];
            uint64_t DerivedStorage = (void *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)v48);
            if (DerivedStorage[10] / 0x30uLL - 1 == v16)
            {
              uint64_t result = figAudioFormatDescriptionEnsureMostCompatibleLayout(v48);
              if (!result)
              {
                uint64_t v42 = DerivedStorage[15];
                a3 = v49;
                uint64_t result = 0;
                if (v42)
                {
                  uint64_t v41 = DerivedStorage[14];
                }
                else
                {
                  uint64_t v41 = DerivedStorage[7];
                  uint64_t v42 = DerivedStorage[8];
                }
LABEL_82:
                if (a3) {
                  *a3 = v8;
                }
                if (a4) {
                  goto LABEL_85;
                }
                goto LABEL_86;
              }
            }
            else
            {
              uint64_t result = figAudioFormatDescriptionEnsureRichestDecodableLayout(v48);
              if (!result)
              {
                if (v16 == v53)
                {
                  uint64_t v42 = DerivedStorage[13];
                  uint64_t result = 0;
                  if (v42)
                  {
                    uint64_t v41 = DerivedStorage[12];
                  }
                  else
                  {
                    uint64_t v41 = DerivedStorage[7];
                    uint64_t v42 = DerivedStorage[8];
                  }
                  goto LABEL_81;
                }
                uint64_t v45 = DerivedStorage[17];
                if (v45)
                {
                  uint64_t v46 = (v16 - 1);
                  if (DerivedStorage[16] > v46)
                  {
                    uint64_t result = 0;
                    uint64_t v47 = (uint64_t *)(v45 + 16 * v46);
                    uint64_t v41 = *v47;
                    uint64_t v42 = v47[1];
                    goto LABEL_81;
                  }
                }
                uint64_t result = FigSignalErrorAt(4294954578, 0, 0, 0, 0, 0, 0);
              }
            }
LABEL_71:
            uint64_t v41 = 0;
            uint64_t v42 = 0;
LABEL_81:
            a3 = v49;
            goto LABEL_82;
          }
LABEL_70:
          uint64_t result = FigSignalErrorAt(4294954578, 0, 0, 0, 0, 0, 0);
          uint64_t v8 = 0;
          goto LABEL_71;
        }
        goto LABEL_56;
      }
    }
    uint64_t v40 = 4294954578;
LABEL_55:
    uint64_t result = FigSignalErrorAt(v40, 0, 0, 0, 0, 0, 0);
LABEL_56:
    uint64_t v8 = 0;
LABEL_57:
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    goto LABEL_82;
  }
  uint64_t result = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  uint64_t v42 = 0;
  uint64_t v41 = 0;
  if (a4) {
LABEL_85:
  }
    *a4 = v41;
LABEL_86:
  if (a5) {
    *a5 = v42;
  }
  return result;
}

uint64_t CMAudioFormatDescriptionCreateCopyWithNewChannelLayout(const opaqueCMFormatDescription *a1, unint64_t a2, AudioChannelLayout *a3, CMAudioFormatDescriptionRef *a4)
{
  CMAudioFormatDescriptionRef formatDescriptionOut = 0;
  if (a1)
  {
    if (CMFormatDescriptionGetMediaType(a1) != 1936684398 || !a3 || a2 <= 0xB || !a4)
    {
      uint64_t v18 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_21:
      if (formatDescriptionOut) {
        CFRelease(formatDescriptionOut);
      }
      return v18;
    }
    uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
    CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
    int v10 = Extensions;
    if (Extensions
      && ((CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms"),
           (CFDictionaryRef v12 = Value) == 0)
        ? (BOOL v13 = 1)
        : (BOOL v13 = CFDictionaryGetValue(Value, @"chnl") == 0),
          CFAllocatorRef v14 = CFGetAllocator(a1),
          int v10 = CFDictionaryCreateMutableCopy(v14, 0, v10),
          CFDictionaryRemoveValue(v10, @"VerbatimISOSampleEntry"),
          CFDictionaryRemoveValue(v10, @"VerbatimSampleDescription"),
          !v13))
    {
      CFAllocatorRef v16 = CFGetAllocator(v12);
      CFMutableArrayRef MutableCopy = CFDictionaryCreateMutableCopy(v16, 0, v12);
      CFDictionaryRemoveValue(v10, @"SampleDescriptionExtensionAtoms");
      CFDictionaryRemoveValue(MutableCopy, @"chnl");
      if ((uint64_t)FigCFDictionaryGetCount(MutableCopy) >= 1) {
        CFDictionarySetValue(v10, @"SampleDescriptionExtensionAtoms", MutableCopy);
      }
    }
    else
    {
      CFMutableArrayRef MutableCopy = 0;
    }
    __int16 v20 = 0;
    evaluateLayoutAgainstFormatList(*(void *)(DerivedStorage + 88), *(void *)(DerivedStorage + 80), a3, a2, 0, 0, (unsigned char *)&v20 + 1, &v20, 0);
    if (v20 | HIBYTE(v20))
    {
      CFAllocatorRef v17 = CFGetAllocator(a1);
      uint64_t v18 = CMAudioFormatDescriptionCreate(v17, (const AudioStreamBasicDescription *)DerivedStorage, a2, a3, *(void *)(DerivedStorage + 40), *(const void **)(DerivedStorage + 48), v10, &formatDescriptionOut);
      if (!v18)
      {
        *a4 = formatDescriptionOut;
        CMAudioFormatDescriptionRef formatDescriptionOut = 0;
      }
      if (!MutableCopy) {
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v18 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      if (!MutableCopy)
      {
LABEL_19:
        if (v10) {
          CFRelease(v10);
        }
        goto LABEL_21;
      }
    }
    CFRelease(MutableCopy);
    goto LABEL_19;
  }

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAudioFormatDescriptionGetCreationChannelLayoutSignificance(uint64_t result)
{
  if (result)
  {
    uint64_t result = FigDerivedFormatDescriptionGetDerivedStorage(result);
    if (result) {
      return *(unsigned int *)(result + 72);
    }
  }
  return result;
}

uint64_t FigAudioFormatDescriptionEmploysDependentPackets(uint64_t result)
{
  if (!result) {
    return result;
  }
  CFDictionaryRef v1 = (const opaqueCMFormatDescription *)result;
  if (CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)result) != 1936684398) {
    return 0;
  }
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(v1);
  uint64_t result = 1;
  if (MediaSubType <= 1886745440)
  {
    if (MediaSubType > 1667330146)
    {
      if (MediaSubType == 1667330147) {
        return result;
      }
      int v3 = 1668641633;
    }
    else
    {
      if (MediaSubType == 1633889588) {
        return result;
      }
      int v3 = 1634754915;
    }
LABEL_15:
    if (MediaSubType == v3) {
      return result;
    }
    return 0;
  }
  if (MediaSubType <= 1903522656)
  {
    if (MediaSubType == 1886745441) {
      return result;
    }
    int v3 = 1902211171;
    goto LABEL_15;
  }
  if (MediaSubType != 1903522657 && MediaSubType != 1970495843)
  {
    int v3 = 2054517601;
    goto LABEL_15;
  }
  return result;
}

const opaqueCMFormatDescription *FigAudioFormatDescriptionUsesAudibleDRM(const opaqueCMFormatDescription *result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    if (CMFormatDescriptionGetMediaType(result) == 1936684398) {
      return (const opaqueCMFormatDescription *)(CMFormatDescriptionGetMediaSubType(v1) == 1633771875);
    }
    else {
      return 0;
    }
  }
  return result;
}

_OWORD *FigAudioFormatDescriptionAudibleContentIsAuthorized(const opaqueCMFormatDescription *a1, int a2)
{
  uint64_t result = FigAudioFormatDescriptionUsesAudibleDRM(a1);
  if (result)
  {
    int v15 = 0;
    size_t sizeOut = 0;
    uint64_t result = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
    if (result)
    {
      long long v5 = *result;
      long long v6 = result[1];
      uint64_t v11 = *((void *)result + 4);
      v10[0] = v5;
      v10[1] = v6;
      MagicCookie = CMAudioFormatDescriptionGetMagicCookie(a1, &sizeOut);
      if (HIDWORD(sizeOut))
      {
        return 0;
      }
      else
      {
        int v13 = sizeOut;
        int v14 = a2;
        int v8 = 4;
        if (AudioToolbox_AudioFormatGetProperty(1633776744, 56, (uint64_t)v10, (uint64_t)&v8, (uint64_t)&v15))BOOL v7 = 1; {
        else
        }
          BOOL v7 = v15 == 0;
        return (_OWORD *)!v7;
      }
    }
  }
  return result;
}

__CFString *CMAudioFormatDescriptionCopyRichestDecodableFormatCompactDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  uint64_t v9 = 0;
  int v10 = 0;
  uint64_t v8 = 0;
  if (CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout((const opaqueCMFormatDescription *)a1, &v10, &v9, &v8))
  {
    CFTypeRef v4 = CFRetain(@"(null)");
    CFTypeRef v5 = CFRetain(@"(null)");
  }
  else
  {
    CFDictionaryRef v12 = 0;
    int v11 = 8;
    AudioToolbox_AudioFormatGetProperty(1718509933, 40, (uint64_t)v10, (uint64_t)&v11, (uint64_t)&v12);
    CFTypeRef v4 = v12;
    if (!v12) {
      CFTypeRef v4 = CFRetain(@"(null)");
    }
    CFTypeRef v5 = aclCopyDebugDesc(v8, v9);
  }
  long long v6 = v5;
  CFStringAppendFormat(Mutable, 0, @"%@, %@", v4, v5);
  if (v6) {
    CFRelease(v6);
  }
  if (v4) {
    CFRelease(v4);
  }
  return Mutable;
}

CFTypeRef aclCopyDebugDesc(uint64_t a1, uint64_t a2)
{
  long long v6 = 0;
  int v5 = 8;
  AudioToolbox_AudioFormatGetProperty(1819242093, a2, a1, (uint64_t)&v5, (uint64_t)&v6);
  CFTypeRef result = v6;
  if (!v6)
  {
    if (a1 && a2) {
      return 0;
    }
    else {
      return CFRetain(@"(null)");
    }
  }
  return result;
}

uint64_t FigCreateAudioCodecStringFromFormatDescription(const opaqueCMFormatDescription *a1, int a2, __CFString **a3)
{
  size_t v24 = 0;
  int v23 = 8;
  CMBlockBufferRef blockBufferOut = 0;
  size_t sizeOut = 0;
  if (!a3)
  {
    uint64_t Property = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  BOOL v6 = a2 == 1751937824;
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
  if (StreamBasicDescription)
  {
    uint64_t v8 = StreamBasicDescription;
    if (a2 == 1751937824) {
      int v9 = 1836069990;
    }
    else {
      int v9 = a2;
    }
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    long long v10 = *(_OWORD *)&StreamBasicDescription->mSampleRate;
    long long v11 = *(_OWORD *)&StreamBasicDescription->mBytesPerPacket;
    uint64_t v17 = *(void *)&StreamBasicDescription->mBitsPerChannel;
    v16[0] = v10;
    v16[1] = v11;
    MagicCookie = CMAudioFormatDescriptionGetMagicCookie(a1, &sizeOut);
    LODWORD(v19) = sizeOut;
    LODWORD(v20) = v9;
    uint64_t Property = AudioToolbox_AudioFormatGetProperty(1668309350, 64, (uint64_t)v16, (uint64_t)&v23, (uint64_t)&v24);
    int v13 = v24;
    if (v9 != 1836069990 || v24)
    {
LABEL_11:
      *a3 = v13;
      size_t v24 = 0;
      goto LABEL_12;
    }
    uint64_t v14 = CMAudioFormatDescriptionCopyAsBigEndianSoundDescriptionBlockBuffer((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, @"ISOFamily", &blockBufferOut);
    if (!v14)
    {
      uint64_t Property = FigMP4BridgeCreateRFC6381CodecString(blockBufferOut, 1936684398, v8->mFormatID, v6, &v24);
      if (Property) {
        goto LABEL_12;
      }
      int v13 = v24;
      goto LABEL_11;
    }
    uint64_t Property = v14;
  }
  else
  {
    uint64_t Property = 0;
  }
LABEL_12:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
LABEL_14:
  if (v24) {
    CFRelease(v24);
  }
  return Property;
}

uint64_t FigAudioFormatDescriptionCopySceneInformation(const opaqueCMFormatDescription *a1, uint64_t a2, void *a3)
{
  uint64_t v16 = 0;
  if (a1 && a3)
  {
    StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
    if (StreamBasicDescription)
    {
      uint64_t v15 = 0;
      size_t sizeOut = 0;
      int v10 = 8;
      uint64_t v6 = *(void *)&StreamBasicDescription->mBitsPerChannel;
      long long v7 = *(_OWORD *)&StreamBasicDescription->mBytesPerPacket;
      v12[0] = *(_OWORD *)&StreamBasicDescription->mSampleRate;
      v12[1] = v7;
      uint64_t v13 = v6;
      MagicCookie = CMAudioFormatDescriptionGetMagicCookie(a1, &sizeOut);
      LODWORD(v15) = sizeOut;
      AudioToolbox_AudioFormatGetProperty(1936286825, 56, (uint64_t)v12, (uint64_t)&v10, (uint64_t)&v16);
      uint64_t v8 = v16;
    }
    else
    {
      uint64_t v8 = 0;
    }
    *a3 = v8;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigAudioFormatDescriptionCopyCompatibleCompositionPresets(const opaqueCMFormatDescription *a1, const __CFAllocator *a2, CFMutableArrayRef *a3)
{
  CFTypeRef cf = 0;
  uint64_t v5 = FigAudioFormatDescriptionCopySceneInformation(a1, (uint64_t)a2, &cf);
  if (v5)
  {
LABEL_23:
    uint64_t v20 = v5;
  }
  else
  {
    Float64 v22 = a3;
    if (cf)
    {
      ArrayCFDictionaryRef Value = (const __CFArray *)FigCFDictionaryGetArrayValue(cf, @"SceneCompositions");
      CFDictionaryRef ValueAtIndex = FigCFArrayGetValueAtIndex(ArrayValue, 0);
      CFArrayRef v8 = (const __CFArray *)FigCFDictionaryGetArrayValue(ValueAtIndex, @"PresetDescriptions");
      if (v8)
      {
        CFArrayRef v9 = v8;
        CFIndex Count = CFArrayGetCount(v8);
        if (Count >= 1)
        {
          CFIndex v11 = Count;
          CFIndex v12 = 0;
          CFMutableArrayRef Mutable = 0;
          while (1)
          {
            uint64_t v14 = FigCFArrayGetValueAtIndex(v9, v12);
            DictionaryCFDictionaryRef Value = FigCFDictionaryGetDictionaryValue(v14, @"PresetDescription");
            CFArrayRef v16 = (const __CFArray *)FigCFDictionaryGetArrayValue(DictionaryValue, @"AudioCharacteristics");
            if (FigCFArrayContainsValue(v16, @"CompatibleSelection"))
            {
              if (!Mutable)
              {
                CFMutableArrayRef Mutable = CFArrayCreateMutable(a2, 0, MEMORY[0x1E4F1D510]);
                if (!Mutable)
                {
                  uint64_t v5 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
                  goto LABEL_23;
                }
              }
              CFMutableDictionaryRef v17 = CFDictionaryCreateMutable(a2, 2, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
              if (!v17)
              {
                uint64_t v20 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_21:
                CFRelease(Mutable);
                goto LABEL_16;
              }
              CFMutableDictionaryRef v18 = v17;
              FigCFDictionarySetValue(v17, @"CompatibleCompositionPresetKey_Description", DictionaryValue);
              uint64_t v19 = FigCFDictionarySetCFIndex(v18, @"CompatibleCompositionPresetKey_Index", v12);
              if (v19)
              {
                uint64_t v20 = v19;
                CFRelease(v18);
                goto LABEL_21;
              }
              CFArrayAppendValue(Mutable, v18);
              CFRelease(v18);
            }
            if (v11 == ++v12) {
              goto LABEL_15;
            }
          }
        }
      }
    }
    CFMutableArrayRef Mutable = 0;
LABEL_15:
    uint64_t v20 = 0;
    *Float64 v22 = Mutable;
  }
LABEL_16:
  if (cf) {
    CFRelease(cf);
  }
  return v20;
}

uint64_t CMAudioFormatDescriptionGetPlaintextMediaSubTypeAndEncryptionScheme(const opaqueCMFormatDescription *a1, int *a2, int *a3)
{
  if (a1)
  {
    int v7 = 1852796517;
    signed int MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
    int v9 = MediaSubType;
    if (MediaSubType <= 1902207794)
    {
      if (MediaSubType <= 1685220712)
      {
        if (MediaSubType <= 1667524656)
        {
          if (MediaSubType <= 1667326823)
          {
            if (MediaSubType == 1633771875 || MediaSubType == 1667312947) {
              goto LABEL_83;
            }
            unsigned __int16 v11 = 24931;
          }
          else if (MediaSubType > 1667330146)
          {
            if (MediaSubType == 1667330147) {
              goto LABEL_83;
            }
            unsigned __int16 v11 = 30307;
          }
          else
          {
            if (MediaSubType == 1667326824) {
              goto LABEL_83;
            }
            unsigned __int16 v11 = 25456;
          }
          int v13 = v11 | 0x63610000;
          goto LABEL_82;
        }
        if (MediaSubType <= 1667656802)
        {
          if (MediaSubType != 1667524657 && MediaSubType != 1667574579)
          {
            int v13 = 1667575091;
            goto LABEL_82;
          }
          goto LABEL_83;
        }
        if (MediaSubType <= 1668047202)
        {
          if (MediaSubType != 1667656803)
          {
            int v13 = 1667790435;
            goto LABEL_82;
          }
          goto LABEL_83;
        }
        if (MediaSubType == 1668047203) {
          goto LABEL_83;
        }
        int v13 = 1668641633;
        goto LABEL_82;
      }
      if (MediaSubType <= 1885430578)
      {
        if (MediaSubType <= 1701733237)
        {
          if (MediaSubType != 1685220713 && MediaSubType != 1700886115)
          {
            int v13 = 1701733217;
            goto LABEL_82;
          }
        }
        else if (MediaSubType > 1882599479)
        {
          if (MediaSubType != 1882599480)
          {
            int v13 = 1885430115;
            goto LABEL_82;
          }
        }
        else if (MediaSubType != 1701733238)
        {
          int v13 = 1869117027;
          goto LABEL_82;
        }
        goto LABEL_83;
      }
      if (MediaSubType <= 1885547314)
      {
        if ((MediaSubType - 1885430579) > 0x3D
          || ((1 << (MediaSubType - 51)) & 0x2020000000000001) == 0)
        {
          goto LABEL_92;
        }
        goto LABEL_83;
      }
      if (MediaSubType <= 1886745440)
      {
        if (MediaSubType != 1885547315)
        {
          int v13 = 1885692723;
          goto LABEL_82;
        }
        goto LABEL_83;
      }
      if (MediaSubType == 1886745441) {
        goto LABEL_83;
      }
      unsigned __int16 v12 = 24931;
    }
    else
    {
      if (MediaSubType > 1902667125)
      {
        if (MediaSubType <= 2053202738)
        {
          if (MediaSubType <= 1902998903)
          {
            if (MediaSubType != 1902667126 && MediaSubType != 1902671459)
            {
              int v13 = 1902928227;
              goto LABEL_82;
            }
          }
          else if (MediaSubType > 1903587384)
          {
            if (MediaSubType != 1903587385)
            {
              unsigned __int16 v10 = 24931;
              goto LABEL_72;
            }
          }
          else if (MediaSubType != 1902998904)
          {
            int v13 = 1903522657;
            goto LABEL_82;
          }
LABEL_83:
          for (uint64_t i = 0; i != 30; i += 3)
          {
            if (MediaSubType == conciseCodecTypeLookupTable[i + 2])
            {
              int v7 = 1667591779;
              int v9 = conciseCodecTypeLookupTable[i];
              goto LABEL_92;
            }
          }
          StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
          if (!StreamBasicDescription) {
            goto LABEL_92;
          }
          AudioFormatID mFormatID = StreamBasicDescription->mFormatID;
          uint64_t v20 = 0;
          int v19 = 8;
          if (AudioToolbox_AudioFormatGetProperty(1718183273, 4, (uint64_t)&mFormatID, (uint64_t)&v19, (uint64_t)&v20))return FigSignalErrorAt(4294954578, 0, 0, 0, 0, 0, 0); {
          int v9 = v20;
          }
          int v7 = HIDWORD(v20);
          if (SHIDWORD(v20) <= 1885695586)
          {
            if (HIDWORD(v20) == 1667392371)
            {
              int v7 = 1667392371;
              goto LABEL_92;
            }
            int v17 = 1667591779;
LABEL_99:
            if (HIDWORD(v20) == v17)
            {
              int v7 = 1667591779;
              goto LABEL_92;
            }
            return FigSignalErrorAt(4294954578, 0, 0, 0, 0, 0, 0);
          }
          if (HIDWORD(v20) != 1885695587)
          {
            int v17 = 2053467747;
            goto LABEL_99;
          }
LABEL_92:
          if (a2) {
            *a2 = v9;
          }
          uint64_t result = 0;
          if (a3) {
            *a3 = v7;
          }
          return result;
        }
        if (MediaSubType <= 2053319474)
        {
          if ((MediaSubType - 2053202739) > 0x3D
            || ((1 << (MediaSubType - 51)) & 0x2020000000000001) == 0)
          {
            unsigned __int16 v10 = 30307;
LABEL_72:
            int v13 = v10 | 0x7A610000;
            goto LABEL_82;
          }
          goto LABEL_83;
        }
        if (MediaSubType <= 2053923170)
        {
          if (MediaSubType != 2053319475)
          {
            int v13 = 2053464883;
            goto LABEL_82;
          }
          goto LABEL_83;
        }
        if (MediaSubType == 2054517601) {
          goto LABEL_83;
        }
        int v13 = 2053923171;
LABEL_82:
        if (MediaSubType != v13) {
          goto LABEL_92;
        }
        goto LABEL_83;
      }
      if (MediaSubType > 1902324530)
      {
        if (MediaSubType <= 1902405732)
        {
          if (MediaSubType == 1902324531 || MediaSubType == 1902403958) {
            goto LABEL_83;
          }
          unsigned __int16 v14 = 26673;
        }
        else
        {
          if (MediaSubType > 1902469938)
          {
            if (MediaSubType == 1902469939) {
              goto LABEL_83;
            }
            int v13 = 1902537827;
            goto LABEL_82;
          }
          if (MediaSubType == 1902405733) {
            goto LABEL_83;
          }
          unsigned __int16 v14 = 28024;
        }
        int v13 = v14 | 0x71640000;
        goto LABEL_82;
      }
      if ((MediaSubType - 1902207795) <= 0x3D
        && ((1 << (MediaSubType - 51)) & 0x2020000000000001) != 0
        || (MediaSubType - 1902212657) <= 0x34
        && ((1 << (MediaSubType - 49)) & 0x14000000000001) != 0)
      {
        goto LABEL_83;
      }
      unsigned __int16 v12 = 28771;
    }
    int v13 = v12 | 0x71610000;
    goto LABEL_82;
  }
  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAudioFormatDescriptionGetCinematicAudioEffectEligibility(const opaqueCMFormatDescription *a1)
{
  if (!a1 || CMFormatDescriptionGetMediaType(a1) != 1936684398)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions) {
    return 0;
  }
  CFDictionaryRef theDict = 0;
  if (!FigCFDictionaryGetValueIfPresent(Extensions, @"SampleDescriptionExtensionAtoms", (const void **)&theDict))return 0; {
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"ngst");
  }
  if (!Value) {
    return 0;
  }
  CFArrayRef v4 = Value;
  CFTypeID v5 = CFGetTypeID(Value);
  if (v5 == CFArrayGetTypeID())
  {
    int8x8_t v10 = 0;
    FigCFArrayApplyFunction(v4, (void (__cdecl *)(const void *, void *))fafd_checkNgstExtensionDataApplier, &v10);
    if (v10.i32[1]) {
      return 0;
    }
    else {
      return v10.u8[0];
    }
  }
  CFTypeID v7 = CFGetTypeID(v4);
  if (v7 != CFDataGetTypeID()) {
    return 0;
  }
  unsigned int v11 = 0;
  int8x8_t v10 = 0;
  int v8 = fafd_IngestSignalingInfoFromExtensionData(v4, &v10);
  unsigned __int8 v6 = 0;
  if (!v8 && v10.i32[0] == 1667853921)
  {
    unsigned __int8 v6 = 0;
    if (v10.i32[1] != 0x10000 && (v10.i32[1] & 0xFFFF0000) == 0x10000)
    {
      unsigned __int8 v6 = v11;
      if (v11 > 1) {
        return 0;
      }
    }
  }
  return v6;
}

CFDataRef fafd_checkNgstExtensionDataApplier(const __CFData *cf, uint64_t a2)
{
  unsigned int v7 = 0;
  int8x8_t v6 = 0;
  if (!*(_DWORD *)(a2 + 4) && !*(unsigned char *)a2)
  {
    CFDataRef v3 = cf;
    if (cf && (CFTypeID v4 = CFGetTypeID(cf), v4 == CFDataGetTypeID()))
    {
      CFTypeRef cf = (const __CFData *)fafd_IngestSignalingInfoFromExtensionData(v3, &v6);
      if (!cf)
      {
        if (v6.i32[0] == 1667853921)
        {
          char v5 = 0;
          if (v6.i32[1] != 0x10000 && (v6.i32[1] & 0xFFFF0000) == 0x10000)
          {
            char v5 = v7;
            if (v7 > 1) {
              char v5 = 0;
            }
          }
        }
        else
        {
          char v5 = 0;
        }
        *(unsigned char *)a2 = v5;
      }
    }
    else
    {
      return (const __CFData *)FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
  }
  return cf;
}

uint64_t fafd_IngestSignalingInfoFromExtensionData(const __CFData *a1, int8x8_t *a2)
{
  unsigned int v7 = 0;
  int8x8_t v6 = 0;
  if (a1 && (CFTypeID v4 = CFGetTypeID(a1), v4 == CFDataGetTypeID()) && CFDataGetLength(a1) == 12)
  {
    v9.CFIndex location = 0;
    v9.length = 12;
    CFDataGetBytes(a1, v9, (UInt8 *)&v6);
    int8x8_t v6 = vrev32_s8(v6);
    a2[1].i32[0] = bswap32(v7);
    *a2 = v6;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigAudioFormatDescriptionGetEligibleCinematicAudioEffectVersion(const opaqueCMFormatDescription *a1, __int32 *a2)
{
  if (!a1 || CMFormatDescriptionGetMediaType(a1) != 1936684398)
  {
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions) {
    return 4294954578;
  }
  CFDictionaryRef theDict = 0;
  if (!FigCFDictionaryGetValueIfPresent(Extensions, @"SampleDescriptionExtensionAtoms", (const void **)&theDict))return 4294954578; {
  CFArrayRef Value = CFDictionaryGetValue(theDict, @"ngst");
  }
  if (!Value) {
    return 4294954578;
  }
  int8x8_t v6 = Value;
  CFTypeID v7 = CFGetTypeID(Value);
  if (v7 != CFArrayGetTypeID())
  {
    CFTypeID v17 = CFGetTypeID(v6);
    if (v17 == CFDataGetTypeID())
    {
      int v19 = 0;
      int8x8_t v18 = 0;
      uint64_t result = fafd_IngestSignalingInfoFromExtensionData((const __CFData *)v6, &v18);
      if (result) {
        return result;
      }
      if (v18.i32[0] == 1667853921
        && (__int32 v8 = v18.i32[1], v18.i32[1] != 0x10000)
        && (v18.i32[1] & 0xFFFF0000) == 0x10000
        && v19 == 1)
      {
        int v14 = 1;
      }
      else
      {
        __int32 v8 = 0;
        int v14 = 0;
      }
LABEL_30:
      if (v14)
      {
        uint64_t result = 0;
        if (a2) {
          *a2 = v8;
        }
        return result;
      }
    }
    return 4294954578;
  }
  if (CFArrayGetCount((CFArrayRef)v6) <= 0) {
    return 4294954578;
  }
  __int32 v8 = 0;
  uint64_t v9 = 1;
  while (1)
  {
    int v19 = 0;
    int8x8_t v18 = 0;
    CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)v6, v9 - 1);
    uint64_t result = fafd_IngestSignalingInfoFromExtensionData(ValueAtIndex, &v18);
    if (result) {
      return result;
    }
    if (v18.i32[0] == 1667853921
      && v18.i32[1] != 0x10000
      && ((v18.i32[1] & 0xFFFF0000) == 0x10000 ? (BOOL v12 = v19 == 1) : (BOOL v12 = 0), v12))
    {
      int v13 = 0;
      int v14 = 1;
      __int32 v8 = v18.i32[1];
    }
    else
    {
      int v14 = 0;
      int v13 = 1;
    }
    CFIndex Count = CFArrayGetCount((CFArrayRef)v6);
    if (v13)
    {
      if (v9++ < Count) {
        continue;
      }
    }
    goto LABEL_30;
  }
}

__CFString *figAudioFormatDescriptionCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = (void *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v3, 0);
  char v5 = asbdCopyDebugDesc(a1, (uint64_t)DerivedStorage);
  CFStringRef v6 = 0;
  CFIndex v8 = DerivedStorage[5];
  CFTypeID v7 = (const UInt8 *)DerivedStorage[6];
  if (v7) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    CFAllocatorRef v10 = CFGetAllocator(a1);
    CFDataRef v11 = CFDataCreate(v10, v7, v8);
    if (v11)
    {
      CFDataRef v12 = v11;
      CFStringRef v6 = CFCopyDescription(v11);
      CFRelease(v12);
    }
    else
    {
      CFStringRef v6 = 0;
    }
  }
  CFTypeRef v13 = aclCopyDebugDesc(DerivedStorage[8], DerivedStorage[7]);
  uint64_t v14 = DerivedStorage[11];
  if (v14 && (unint64_t v15 = DerivedStorage[10], v15 >= 0x30))
  {
    Float64 v22 = Mutable;
    CFAllocatorRef v16 = CFGetAllocator(a1);
    CFTypeID v17 = CFStringCreateMutable(v16, 0);
    uint64_t v18 = 0;
    unint64_t v19 = v15 / 0x30;
    do
    {
      uint64_t v20 = asbdCopyDebugDesc(a1, v14);
      if (v18) {
        CFStringAppend(v17, @"\n");
      }
      CFStringAppendFormat(v17, 0, @"\n\t\t\tIndex: %d \n\t\t\tChannelLayoutTag: 0x%x \n\t\t\tASBD: {%@\t}", v18, *(unsigned int *)(v14 + 40), v20);
      if (v20) {
        CFRelease(v20);
      }
      ++v18;
      v14 += 48;
    }
    while (v19 != v18);
    CFMutableArrayRef Mutable = v22;
  }
  else
  {
    CFTypeID v17 = (__CFString *)CFRetain(@"(null)");
  }
  CFStringAppendFormat(Mutable, 0, @"\t\tASBD: {%@\t} \n\t\tcookie: {%@} \n\t\tACL: {%@}\n\t\tFormatList Array: {%@}", v5, v6, v13, v17);
  if (v5) {
    CFRelease(v5);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v17) {
    CFRelease(v17);
  }
  return Mutable;
}

uint64_t figAudioFormatDescriptionEqual(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2, unint64_t a3, unint64_t a4)
{
  uint64_t result = CMAudioFormatDescriptionEqual(a1, a2, 7u, 0);
  if (result)
  {
    CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
    CFDictionaryRef v10 = CMFormatDescriptionGetExtensions(a2);
    return FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(Extensions, v10, a3, a4);
  }
  return result;
}

__CFString *asbdCopyDebugDesc(const void *a1, uint64_t a2)
{
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v3, 0);
  CFStringAppendFormat(Mutable, 0, @"\n\t\t\tmSampleRate: %f \n\t\t\tmFormatID: '%c%c%c%c' \n\t\t\tmFormatFlags: 0x%x \n\t\t\tmBytesPerPacket: %u \n\t\t\tmFramesPerPacket: %u \n\t\t\tmBytesPerFrame: %u \n\t\t\tmChannelsPerFrame: %u \n\t\t\tmBitsPerChannel: %u ", *(void *)a2, HIBYTE(*(_DWORD *)(a2 + 8)), BYTE2(*(_DWORD *)(a2 + 8)), BYTE1(*(_DWORD *)(a2 + 8)), *(_DWORD *)(a2 + 8), *(unsigned int *)(a2 + 12), *(unsigned int *)(a2 + 16), *(unsigned int *)(a2 + 20), *(unsigned int *)(a2 + 24), *(unsigned int *)(a2 + 28), *(unsigned int *)(a2 + 32));
  return Mutable;
}

uint64_t getChannelLayoutTagFromLayout(_DWORD *a1, unint64_t a2)
{
  int v5 = 4;
  unsigned int v6 = -65536;
  if (HIDWORD(a2))
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 4294901760;
  }
  else
  {
    int Property = AudioToolbox_AudioFormatGetProperty(1668116596, a2, (uint64_t)a1, (uint64_t)&v5, (uint64_t)&v6);
    uint64_t result = v6;
    if (!Property && v6 == 6553601)
    {
      if (*a1)
      {
        return 6553601;
      }
      else
      {
        uint64_t result = 6553601;
        if (a1[2] == 1)
        {
          if (a1[3] == 3) {
            return 4294901760;
          }
          else {
            return 6553601;
          }
        }
      }
    }
  }
  return result;
}

BOOL isValidAudioChannelLayoutAndSize(_DWORD *a1, unint64_t a2)
{
  if (!a1 || a2 < 4) {
    return 0;
  }
  if (!*a1) {
    return a2 >= 0xC && 20 * (unint64_t)a1[2] + 12 <= a2;
  }
  return *a1 != 0x10000 || a2 >= 8;
}

uint64_t allocAudioChannelLayoutForAudioChannelLayoutTag(const __CFAllocator *a1, unsigned int a2, uint64_t *a3, void *a4)
{
  if (a2 > 0xFFFEFFFF)
  {
    uint64_t v6 = 0;
    CFTypeID v7 = 0;
LABEL_5:
    *a3 = v6;
    *a4 = v7;
    return 0;
  }
  CFTypeID v7 = CFAllocatorAllocate(a1, 12, 0);
  if (v7)
  {
    *(void *)CFTypeID v7 = 0;
    v7[2] = 0;
    uint64_t v6 = 12;
    *CFTypeID v7 = a2;
    goto LABEL_5;
  }

  return FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAudioDeviceClock_RemoteCreateCommon(uint64_t a1, const void *a2, unsigned int a3, void *a4)
{
  uint64_t v11 = 0;
  if (gAudioDeviceClockRemoteClientSetupOnce != -1) {
    dispatch_once(&gAudioDeviceClockRemoteClientSetupOnce, &__block_literal_global_20);
  }
  uint64_t v7 = remoteDeviceClock_OneTimeInitialization_err;
  if (remoteDeviceClock_OneTimeInitialization_err) {
    return v7;
  }
  if (a4)
  {
    uint64_t BasicRemoteAudioDeviceClock = CreateBasicRemoteAudioDeviceClock((CFTypeRef *)&v11);
    CFTypeRef v9 = (CFTypeRef)v11;
    if (BasicRemoteAudioDeviceClock)
    {
      uint64_t v7 = BasicRemoteAudioDeviceClock;
    }
    else
    {
      uint64_t v7 = AcquireServerClockObject(v11, a2, a3);
      if (!v7)
      {
        FigDerivedClockGetDerivedStorage((uint64_t)v9);
        *a4 = v9;
        return v7;
      }
    }
    if (v9) {
      CFRelease(v9);
    }
    return v7;
  }

  return FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
}

uint64_t CreateBasicRemoteAudioDeviceClock(CFTypeRef *a1)
{
  CFTypeRef cf = 0;
  uint64_t v2 = *MEMORY[0x1E4F1CF80];
  CMClockRef HostTimeClock = CMClockGetHostTimeClock();
  CMTimeMake(&v9, 1, 10);
  uint64_t TimeCallback = FigDerivedClockCreateWithGetTimeCallback(v2, gFigAudioDeviceRemoteClockCallbacks, HostTimeClock, (long long *)&v9.value, 1, (uint64_t *)&cf);
  if (TimeCallback)
  {
    uint64_t v7 = TimeCallback;
  }
  else
  {
    uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)cf);
    dispatch_queue_t v6 = dispatch_queue_create("com.apple.coremedia.audioclock.reconnect", 0);
    *(void *)(DerivedStorage + 16) = v6;
    if (v6)
    {
      uint64_t v7 = 0;
      *a1 = cf;
      return v7;
    }
    uint64_t v7 = 4294954549;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

uint64_t AcquireServerClockObject(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t DerivedStorage = (void *)FigDerivedClockGetDerivedStorage(a1);
  xpc_object_t v11 = 0;
  xpc_object_t xdict = 0;
  uint64_t v7 = FigXPCCreateBasicMessage(0x63726538u, 0, &xdict);
  if (v7
    || (xpc_dictionary_set_int64(xdict, "DeviceID", a3),
        uint64_t v7 = FigXPCMessageSetCFString(xdict, "DeviceUID", a2),
        v7)
    || (uint64_t v7 = FigXPCRemoteClientSendSyncMessageCreatingReply(gAudioDeviceClockRemoteClient, (uint64_t)xdict, &v11),
        v7))
  {
    uint64_t v9 = v7;
  }
  else
  {
    uint64 = (const void *)xpc_dictionary_get_uint64(v11, ".objectID");
    uint64_t v9 = FigXPCRemoteClientAssociateObject(gAudioDeviceClockRemoteClient, a1, uint64);
    if (!v9) {
      *uint64_t DerivedStorage = uint64;
    }
  }
  FigXPCRelease(xdict);
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(gAudioDeviceClockRemoteClient, v9, "AcquireServerClockObject", 0);
  return v9;
}

uint64_t FigAudioDeviceClockXPCRemotePing()
{
  CFTypeID v4 = 0;
  if (gAudioDeviceClockRemoteClientSetupOnce != -1) {
    dispatch_once(&gAudioDeviceClockRemoteClientSetupOnce, &__block_literal_global_20);
  }
  uint64_t v0 = remoteDeviceClock_OneTimeInitialization_err;
  if (remoteDeviceClock_OneTimeInitialization_err)
  {
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v1 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &v4);
    uint64_t v2 = v4;
    if (v1)
    {
      uint64_t v0 = v1;
    }
    else
    {
      uint64_t v0 = FigXPCRemoteClientSendSyncMessage(gAudioDeviceClockRemoteClient, (uint64_t)v4);
      uint64_t v2 = v4;
    }
  }
  FigXPCRelease(v2);
  return v0;
}

uint64_t FigAudioDeviceClockXPCRemoteRetainCopiedClock(const void *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  if (a1 && a2)
  {
    if (gAudioDeviceClockRemoteClientSetupOnce != -1) {
      dispatch_once(&gAudioDeviceClockRemoteClientSetupOnce, &__block_literal_global_20);
    }
    uint64_t v4 = remoteDeviceClock_OneTimeInitialization_err;
    if (remoteDeviceClock_OneTimeInitialization_err) {
      return v4;
    }
    uint64_t v4 = FigXPCRemoteClientRetainCopiedObject(gAudioDeviceClockRemoteClient, (uint64_t)a1, &cf);
    CFTypeRef v5 = cf;
    if (!v4)
    {
      if (cf)
      {
        FigAudioDeviceClockXPCRemoteGetObjectID((OpaqueCMClock *)cf, &v8);
LABEL_10:
        uint64_t v4 = 0;
        *a2 = cf;
        return v4;
      }
      uint64_t v6 = FigAudioDeviceClockXPCRemoteCreateWithObjectID(a1, &cf);
      if (!v6) {
        goto LABEL_10;
      }
      uint64_t v4 = v6;
      CFTypeRef v5 = cf;
    }
    if (v5) {
      CFRelease(v5);
    }
    return v4;
  }

  return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAudioDeviceClockXPCRemoteCreateWithObjectID(const void *a1, void *a2)
{
  uint64_t v8 = 0;
  if (a1 && a2)
  {
    if (gAudioDeviceClockRemoteClientSetupOnce != -1) {
      dispatch_once(&gAudioDeviceClockRemoteClientSetupOnce, &__block_literal_global_20);
    }
    uint64_t v4 = remoteDeviceClock_OneTimeInitialization_err;
    if (remoteDeviceClock_OneTimeInitialization_err) {
      return v4;
    }
    uint64_t BasicRemoteAudioDeviceClock = CreateBasicRemoteAudioDeviceClock((CFTypeRef *)&v8);
    CFTypeRef v6 = (CFTypeRef)v8;
    if (BasicRemoteAudioDeviceClock)
    {
      uint64_t v4 = BasicRemoteAudioDeviceClock;
    }
    else
    {
      uint64_t v4 = FigXPCRemoteClientAssociateObject(gAudioDeviceClockRemoteClient, v8, a1);
      if (!v4)
      {
        *(void *)FigDerivedClockGetDerivedStorage((uint64_t)v6) = a1;
        *a2 = v6;
        return v4;
      }
    }
    if (v6) {
      CFRelease(v6);
    }
    return v4;
  }

  return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAudioDeviceClockXPCRemoteGetObjectID(OpaqueCMClock *a1, void *a2)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)a1);
  if (a1
    && (CFTypeRef v5 = (void *)DerivedStorage, CMClockGetHostTimeClock() != a1)
    && FigDerivedClockVerifyCallbacksMatch((BOOL)a1, (uint64_t)gFigAudioDeviceRemoteClockCallbacks))
  {
    *a2 = *v5;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigAudioDeviceClockRemoteCreateForServerObject(uint64_t a1, uint64_t a2, void *a3)
{
  int v7 = 0;
  uint64_t v5 = 0;
  CFTypeRef v6 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void, int *, const void **, uint64_t *))(a2 + 16))(a2, 0, 0, &v7, &v6, &v5);
  if (!result) {
    return FigAudioDeviceClockXPCRemoteCreateWithObjectID(v6, a3);
  }
  return result;
}

uint64_t FigAudioDeviceClock_GetServerClockToken(OpaqueCMClock *a1, void *a2)
{
  uint64_t DerivedStorage = (void *)FigDerivedClockGetDerivedStorage((uint64_t)a1);
  if (CMClockGetHostTimeClock() == a1
    || !FigDerivedClockVerifyCallbacksMatch((BOOL)a1, (uint64_t)gFigAudioDeviceRemoteClockCallbacks))
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    *a2 = *DerivedStorage;
    return 0;
  }
}

uint64_t remoteDeviceClock_DeadConnectionCallback(uint64_t a1)
{
  uint64_t result = FigDerivedClockGetDerivedStorage(a1);
  *(unsigned char *)(result + 8) = 1;
  return result;
}

CFStringRef remoteDeviceClock_CopyDebugDesc(const void *a1)
{
  uint64_t v8 = 0;
  unsigned int v7 = 0;
  uint64_t DerivedStorage = (void *)FigDerivedClockGetDerivedStorage((uint64_t)a1);
  BOOL v6 = 0;
  remoteDeviceClock_GetAudioDevice((uint64_t)a1, &v8, &v7, &v6);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  uint64_t v4 = "true";
  if (!v6) {
    uint64_t v4 = "false";
  }
  return CFStringCreateWithFormat(v3, 0, @"RemoteAudioDeviceClockXPC(objectID=%lld deviceUID='%@', deviceID=%d, trackDefaultDevice=%s)", *DerivedStorage, v8, v7, v4);
}

void remoteDeviceClock_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  BOOL v6 = 0;
  uint64_t v2 = *(NSObject **)(DerivedStorage + 16);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(DerivedStorage + 16) = 0;
  }
  CFAllocatorRef v3 = *(void **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    FigXPCRemoteClientDisassociateObject(gAudioDeviceClockRemoteClient, v3);
    if (*(unsigned char *)(DerivedStorage + 8))
    {
      CFAllocatorRef v3 = 0;
    }
    else
    {
      int v4 = FigXPCCreateBasicMessage(0x646F6F6Du, *(void *)DerivedStorage, &v6);
      CFAllocatorRef v3 = v6;
      if (!v4)
      {
        uint64_t v5 = FigXPCRemoteClientSendSyncMessage(gAudioDeviceClockRemoteClient, (uint64_t)v6);
        FigXPCRemoteClientKillServerOnTimeout(gAudioDeviceClockRemoteClient, v5, "remoteDeviceClock_Finalize", 0);
        CFAllocatorRef v3 = v6;
      }
    }
  }
  FigXPCRelease(v3);
}

BOOL remoteDeviceClock_MightDrift(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  __int16 v7 = 0;
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  uint64_t v5 = FigDerivedClockGetDerivedStorage(a2);
  BOOL result = 1;
  if (DerivedStorage && v5) {
    return remoteDeviceClock_GetAudioDevice(a1, 0, (_DWORD *)&v8 + 1, (BOOL *)&v7 + 1)
  }
        || remoteDeviceClock_GetAudioDevice(a2, 0, &v8, (BOOL *)&v7)
        || HIDWORD(v8) != v8
        || HIBYTE(v7) != v7;
  return result;
}

double remoteDeviceClock_GetRate(const void *a1)
{
  uint64_t DerivedStorage = (uint64_t *)FigDerivedClockGetDerivedStorage((uint64_t)a1);
  xpc_object_t xdict = 0;
  xpc_object_t v9 = 0;
  double v3 = 0.0;
  if (DerivedStorage)
  {
    int v4 = DerivedStorage;
    if (!FigXPCCreateBasicMessage(0x67726174u, *DerivedStorage, &v9))
    {
      uint64_t v5 = FigXPCRemoteClientSendSyncMessageCreatingReply(gAudioDeviceClockRemoteClient, (uint64_t)v9, &xdict);
      int v6 = v5;
      FigXPCRemoteClientKillServerOnTimeout(gAudioDeviceClockRemoteClient, v5, "remoteDeviceClock_GetRate", 0);
      if (v6 == -16152) {
        goto LABEL_8;
      }
      if (!v6)
      {
        double v3 = xpc_dictionary_get_double(xdict, "Rate");
        goto LABEL_9;
      }
      if (v6 == -16155 || *((unsigned char *)v4 + 8))
      {
LABEL_8:
        MaybeReacquireServerClockObject(a1);
        double v3 = 1.0;
      }
    }
  }
LABEL_9:
  FigXPCRelease(v9);
  FigXPCRelease(xdict);
  return v3;
}

uint64_t remoteDeviceClock_GetAnchorTime(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = (uint64_t *)FigDerivedClockGetDerivedStorage((uint64_t)a1);
  xpc_object_t xdict = 0;
  xpc_object_t v13 = 0;
  if (!DerivedStorage) {
    goto LABEL_14;
  }
  __int16 v7 = DerivedStorage;
  uint64_t CMTime = FigXPCCreateBasicMessage(0x67616E6Bu, *DerivedStorage, &v13);
  if (CMTime)
  {
LABEL_16:
    uint64_t int64 = CMTime;
    goto LABEL_15;
  }
  uint64_t int64 = FigXPCRemoteClientSendSyncMessageCreatingReply(gAudioDeviceClockRemoteClient, (uint64_t)v13, &xdict);
  FigXPCRemoteClientKillServerOnTimeout(gAudioDeviceClockRemoteClient, int64, "remoteDeviceClock_GetAnchorTime", 0);
  if (int64 == -16152)
  {
LABEL_13:
    MaybeReacquireServerClockObject(a1);
LABEL_14:
    uint64_t int64 = 4294954550;
    goto LABEL_15;
  }
  if (int64)
  {
    if (int64 != -16155 && !*((unsigned char *)v7 + 8)) {
      goto LABEL_15;
    }
    goto LABEL_13;
  }
  uint64_t int64 = xpc_dictionary_get_int64(xdict, "LoadStatus");
  if (a2)
  {
    uint64_t CMTime = FigXPCMessageGetCMTime(xdict, "ClockTime", a2);
    if (CMTime) {
      goto LABEL_16;
    }
  }
  if (a3)
  {
    unsigned int v10 = FigXPCMessageGetCMTime(xdict, "RefClockTime", a3);
    if (v10) {
      uint64_t int64 = v10;
    }
    else {
      uint64_t int64 = int64;
    }
  }
LABEL_15:
  FigXPCRelease(v13);
  FigXPCRelease(xdict);
  return int64;
}

uint64_t remoteDeviceClock_GetAudioDevice(uint64_t a1, void *a2, _DWORD *a3, BOOL *a4)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  xpc_object_t xdict = 0;
  xpc_object_t v14 = 0;
  if (!DerivedStorage)
  {
    uint64_t v11 = 4294954550;
    goto LABEL_14;
  }
  xpc_object_t v9 = (uint64_t *)DerivedStorage;
  if (FigDerivedClockVerifyCallbacksMatch(a1, (uint64_t)gFigAudioDeviceRemoteClockCallbacks))
  {
    uint64_t v10 = FigXPCCreateBasicMessage(0x67646576u, *v9, &v14);
    if (v10)
    {
LABEL_16:
      uint64_t v11 = v10;
      goto LABEL_14;
    }
    uint64_t v11 = FigXPCRemoteClientSendSyncMessageCreatingReply(gAudioDeviceClockRemoteClient, (uint64_t)v14, &xdict);
    FigXPCRemoteClientKillServerOnTimeout(gAudioDeviceClockRemoteClient, v11, "remoteDeviceClock_GetAudioDevice", 0);
    if (!v11)
    {
      if (!a2 || (uint64_t v10 = FigXPCMessageCopyCFString(xdict, "DeviceUID", a2), !v10))
      {
        if (a3) {
          *a3 = xpc_dictionary_get_int64(xdict, "DeviceID");
        }
        uint64_t v11 = 0;
        if (a4) {
          *a4 = xpc_dictionary_get_BOOL(xdict, "TrackDefaultDevice");
        }
        goto LABEL_14;
      }
      goto LABEL_16;
    }
LABEL_14:
    FigXPCRelease(v14);
    FigXPCRelease(xdict);
    return v11;
  }

  return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
}

void MaybeReacquireServerClockObject(const void *a1)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)a1);
  if (FigAtomicCompareAndSwap32(0, 1u, (atomic_uint *)(DerivedStorage + 12)))
  {
    uint64_t v3 = FigDerivedClockGetDerivedStorage((uint64_t)a1);
    if (*(void *)v3)
    {
      FigXPCRemoteClientDisassociateObject(gAudioDeviceClockRemoteClient, *(const void **)v3);
      *(void *)uint64_t v3 = 0;
    }
    CFRetain(a1);
    int v4 = *(NSObject **)(v3 + 16);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = __ReacquireServerClockObject_block_invoke;
    v5[3] = &__block_descriptor_tmp_7_4;
    v5[4] = v3;
    v5[5] = a1;
    dispatch_async(v4, v5);
  }
}

void __ReacquireServerClockObject_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 12) && !*(void *)v2)
  {
    int v3 = AcquireServerClockObject(*(void *)(a1 + 40), 0, 0);
    uint64_t v4 = *(void *)(a1 + 32);
    if (*(void *)v4) {
      BOOL v5 = v3 == 0;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5) {
      *(unsigned char *)(v4 + 8) = 0;
    }
    *(_DWORD *)(v4 + 12) = 0;
  }
  int v6 = *(const void **)(a1 + 40);

  CFRelease(v6);
}

uint64_t FigCustomURLRequestInfoMakeNSSecureCodingTypesSerializable(const __CFDictionary *a1)
{
  return figCustomURLMessageMakeNSSecureCodingTypesSerializable(a1, (const void ***)&sRequestInfoKeysRequiringNSSecureCodingSerialization, (const void ***)&sRequestInfoKeysToSerializeTo);
}

uint64_t figCustomURLMessageMakeNSSecureCodingTypesSerializable(const __CFDictionary *a1, const void ***a2, const void ***a3)
{
  int v6 = (void *)MEMORY[0x192FC5D30]();
  if (!a1) {
    goto LABEL_9;
  }
  __int16 v7 = **a2;
  uint64_t v8 = **a3;
  CFArrayRef Value = CFDictionaryGetValue(a1, v7);
  if (Value)
  {
    uint64_t v10 = Value;
    if (CFDictionaryContainsKey(a1, v8))
    {
LABEL_7:
      CFDictionaryRemoveValue(a1, v7);
      goto LABEL_8;
    }
    if ([(id)objc_opt_class() conformsToProtocol:&unk_1EDF8B318])
    {
      uint64_t v11 = (void *)[objc_alloc(MEMORY[0x1E4F28DB0]) initRequiringSecureCoding:1];
      [v11 encodeObject:v10 forKey:*MEMORY[0x1E4F284E8]];
      CFDataRef v12 = (const void *)[v11 encodedData];

      if (v12)
      {
        CFDictionarySetValue(a1, v8, v12);
        goto LABEL_7;
      }
    }
LABEL_9:
    uint64_t v13 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
LABEL_8:
  uint64_t v13 = 0;
LABEL_10:
  return v13;
}

uint64_t FigCustomURLRequestInfoDeserializeNSSecureCodingTypes(const __CFDictionary *a1)
{
  return figCustomURLMessageDeserializeNSSecureCodingTypes(a1, (const void ***)&sRequestInfoKeysToSerializeTo, (const void ***)&sRequestInfoKeysRequiringNSSecureCodingSerialization, (NSString **)sRequestInfoClassesForDeserializion);
}

uint64_t figCustomURLMessageDeserializeNSSecureCodingTypes(const __CFDictionary *a1, const void ***a2, const void ***a3, NSString **a4)
{
  uint64_t v8 = (void *)MEMORY[0x192FC5D30]();
  if (!a1) {
    goto LABEL_8;
  }
  xpc_object_t v9 = **a2;
  uint64_t v10 = **a3;
  Class v11 = NSClassFromString(*a4);
  CFArrayRef Value = CFDictionaryGetValue(a1, v9);
  if (!Value) {
    goto LABEL_7;
  }
  uint64_t v13 = Value;
  if (CFDictionaryContainsKey(a1, v10)) {
    goto LABEL_7;
  }
  if (![(objc_class *)v11 conformsToProtocol:&unk_1EDF8B318]
    || (xpc_object_t v14 = (void *)[objc_alloc(MEMORY[0x1E4F28DC0]) initForReadingFromData:v13 error:0],
        unint64_t v15 = (const void *)[v14 decodeObjectOfClass:v11 forKey:*MEMORY[0x1E4F284E8]],
        v14,
        !v15))
  {
LABEL_8:
    uint64_t v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  CFDictionarySetValue(a1, v10, v15);
LABEL_7:
  uint64_t v16 = 0;
LABEL_9:
  return v16;
}

uint64_t FigCustomURLResponseInfoMakeNSSecureCodingTypesSerializable(void *a1)
{
  uint64_t v2 = (void *)MEMORY[0x192FC5D30]();
  CFTypeRef cf = 0;
  CFDictionaryRef theDict = 0;
  CFAllocatorRef v3 = CFGetAllocator(a1);
  if (a1)
  {
    CFAllocatorRef v4 = v3;
    uint64_t NSSecureCodingTypesSerializable = FigCustomURLResponseInfoCopyRequestInfo((const __CFDictionary *)a1, (const void **)&theDict);
    if (!NSSecureCodingTypesSerializable)
    {
      if (!CFDictionaryContainsKey(theDict, *sRequestInfoKeysRequiringNSSecureCodingSerialization)
        || (uint64_t NSSecureCodingTypesSerializable = FigCustomURLRequestInfoCreateMutableCopy(v4, theDict, &cf),
            !NSSecureCodingTypesSerializable)
        && (uint64_t NSSecureCodingTypesSerializable = figCustomURLMessageMakeNSSecureCodingTypesSerializable((const __CFDictionary *)cf, (const void ***)&sRequestInfoKeysRequiringNSSecureCodingSerialization, (const void ***)&sRequestInfoKeysToSerializeTo), !NSSecureCodingTypesSerializable)&& (uint64_t NSSecureCodingTypesSerializable = FigCustomURLResponseInfoSetRequestInfo((__CFDictionary *)a1, (void *)cf), !NSSecureCodingTypesSerializable))
      {
        uint64_t NSSecureCodingTypesSerializable = figCustomURLMessageMakeNSSecureCodingTypesSerializable((const __CFDictionary *)a1, (const void ***)&sResponseInfoKeysRequiringNSSecureCodingSerialization, (const void ***)&sResponseInfoKeysToSerializeTo);
      }
    }
  }
  else
  {
    uint64_t NSSecureCodingTypesSerializable = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v6 = NSSecureCodingTypesSerializable;
  if (theDict) {
    CFRelease(theDict);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t FigCustomURLResponseInfoDeserializeNSSecureCodingTypes(void *a1)
{
  uint64_t v2 = (void *)MEMORY[0x192FC5D30]();
  CFTypeRef cf = 0;
  CFDictionaryRef theDict = 0;
  CFAllocatorRef v3 = CFGetAllocator(a1);
  if (a1)
  {
    CFAllocatorRef v4 = v3;
    uint64_t v5 = FigCustomURLResponseInfoCopyRequestInfo((const __CFDictionary *)a1, (const void **)&theDict);
    if (!v5)
    {
      if (!CFDictionaryContainsKey(theDict, *sRequestInfoKeysToSerializeTo)
        || (uint64_t v5 = FigCustomURLRequestInfoCreateMutableCopy(v4, theDict, &cf), !v5)
        && (uint64_t v5 = figCustomURLMessageDeserializeNSSecureCodingTypes((const __CFDictionary *)cf, (const void ***)&sRequestInfoKeysToSerializeTo, (const void ***)&sRequestInfoKeysRequiringNSSecureCodingSerialization, (NSString **)sRequestInfoClassesForDeserializion), !v5)&& (uint64_t v5 = FigCustomURLResponseInfoSetRequestInfo((__CFDictionary *)a1, (void *)cf), !v5))
      {
        uint64_t v5 = figCustomURLMessageDeserializeNSSecureCodingTypes((const __CFDictionary *)a1, (const void ***)&sResponseInfoKeysToSerializeTo, (const void ***)&sResponseInfoKeysRequiringNSSecureCodingSerialization, (NSString **)sResponseInfoClassesForDeserializion);
      }
    }
  }
  else
  {
    uint64_t v5 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v6 = v5;
  if (theDict) {
    CFRelease(theDict);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t FigCustomURLRequestInfoSetNSURLAuthenticationChallenge(__CFDictionary *a1, void *value)
{
  if (a1)
  {
    if (value) {
      CFDictionarySetValue(a1, @"RequestInfoNSURLAuthenticationChallenge", value);
    }
    else {
      CFDictionaryRemoveValue(a1, @"RequestInfoNSURLAuthenticationChallenge");
    }
    CFDictionaryRemoveValue(a1, @"RequestInfoSerializedNSURLAuthenticationChallenge");
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCustomURLRequestInfoCopyNSURLAuthenticationChallenge(const __CFDictionary *a1, const void **value)
{
  if (a1 && value)
  {
    if (CFDictionaryGetValueIfPresent(a1, @"RequestInfoNSURLAuthenticationChallenge", value)) {
      uint64_t v3 = 0;
    }
    else {
      uint64_t v3 = 4294949936;
    }
    if (*value) {
      CFRetain(*value);
    }
    return v3;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCustomURLResponseInfoSetNSURLCredential(__CFDictionary *a1, void *value)
{
  if (a1)
  {
    if (value) {
      CFDictionarySetValue(a1, @"ResponseInfoNSURLCredential", value);
    }
    else {
      CFDictionaryRemoveValue(a1, @"ResponseInfoNSURLCredential");
    }
    CFDictionaryRemoveValue(a1, @"ResponseInfoSerializedNSURLCredential");
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCustomURLResponseInfoCopyNSURLCredential(const __CFDictionary *a1, const void **value)
{
  if (a1 && value)
  {
    if (CFDictionaryGetValueIfPresent(a1, @"ResponseInfoNSURLCredential", value)) {
      uint64_t v3 = 0;
    }
    else {
      uint64_t v3 = 4294949936;
    }
    if (*value) {
      CFRetain(*value);
    }
    return v3;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCustomURLResponseInfoSetNSURLSessionAuthChallengeDisposition(void *a1, uint64_t a2)
{
  if (a1)
  {
    FigCFDictionarySetCFIndex(a1, @"ResponseInfoNSURLSessionAuthChallengeDispositionKey", a2);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCustomURLResponseInfoGetNSURLSessionAuthChallengeDisposition(uint64_t a1, void *a2)
{
  uint64_t v4 = 0;
  if (a1 && a2)
  {
    if (FigCFDictionaryGetCFIndexIfPresent(a1, @"ResponseInfoNSURLSessionAuthChallengeDispositionKey", &v4))
    {
      uint64_t result = 0;
      *a2 = v4;
    }
    else
    {
      return 4294949936;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigHALAudioConfigChangeCreateRecord(int a1, uint64_t *a2, void *a3)
{
  uint64_t v6 = (char *)malloc_type_calloc(1uLL, 0x38uLL, 0x100004021716A34uLL);
  if (v6)
  {
    *(_DWORD *)uint64_t v6 = a1;
    if (a2)
    {
      uint64_t v7 = *a2;
      *((_DWORD *)v6 + 3) = *((_DWORD *)a2 + 2);
      *(void *)(v6 + 4) = v7;
    }
    *a3 = v6;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigHALAudioConfigChangeCloneRecord(int a1, uint64_t a2, uint64_t *a3)
{
  FigHALAudioConfigChangeCreateRecord(a1, 0, a3);
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a2 + 48);
  long long v8 = *(_OWORD *)(a2 + 16);
  long long v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
  *(_OWORD *)(v5 + 16) = v8;
  *(_OWORD *)(v5 + 32) = v7;
  *(void *)(v5 + 48) = v6;
  return 0;
}

void FigHALAudioConfigChangeSendRequest(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (GetHostCallbackQueue_sInitCallbackQueueOnce != -1) {
    dispatch_once(&GetHostCallbackQueue_sInitCallbackQueueOnce, &__block_literal_global_21);
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  v8[2] = __FigHALAudioConfigChangeSendRequest_block_invoke;
  v8[3] = &__block_descriptor_tmp_24;
  int v9 = a2;
  v8[4] = a1;
  v8[5] = a3;
  v8[6] = a4;
  dispatch_async((dispatch_queue_t)GetHostCallbackQueue_sCallbackQueue, v8);
}

uint64_t __FigHALAudioConfigChangeSendRequest_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 32) + 32))(*(void *)(a1 + 32), *(unsigned int *)(a1 + 56), *(void *)(a1 + 40), *(void *)(a1 + 48));
}

void FigHALAudioConfigChangeSendRequestWithCustomChangeRecord(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (GetHostCallbackQueue_sInitCallbackQueueOnce != -1) {
    dispatch_once(&GetHostCallbackQueue_sInitCallbackQueueOnce, &__block_literal_global_21);
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  v8[2] = __FigHALAudioConfigChangeSendRequestWithCustomChangeRecord_block_invoke;
  v8[3] = &__block_descriptor_tmp_1_1;
  int v9 = a2;
  v8[4] = a1;
  v8[5] = a3;
  v8[6] = a4;
  dispatch_async((dispatch_queue_t)GetHostCallbackQueue_sCallbackQueue, v8);
}

uint64_t __FigHALAudioConfigChangeSendRequestWithCustomChangeRecord_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 32) + 32))(*(void *)(a1 + 32), *(unsigned int *)(a1 + 56), *(void *)(a1 + 40), *(void *)(a1 + 48));
}

void FigHALAudioPropertySendOneChange(uint64_t (**a1)(void, uint64_t, uint64_t, _DWORD *), uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  v57[0] = a3;
  v57[1] = a4;
  v57[2] = a5;
  int v56 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v56, &type);
  int v11 = v56;
  BOOL v12 = os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type);
  unsigned int v14 = v11 & 0xFFFFFFFE;
  if (v12) {
    unsigned int v14 = v11;
  }
  if (v14)
  {
    uint64_t v15 = MEMORY[0x1E4F14390];
    if ((a3 & 0x80000000) != 0) {
      int v16 = __maskrune(HIBYTE(a3), 0x40000uLL);
    }
    else {
      int v16 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * HIBYTE(a3) + 60) & 0x40000;
    }
    if (v16) {
      int v18 = HIBYTE(a3);
    }
    else {
      int v18 = 46;
    }
    int v53 = v18;
    if (BYTE2(a3) > 0x7Fu) {
      int v19 = __maskrune(BYTE2(a3), 0x40000uLL);
    }
    else {
      int v19 = *(_DWORD *)(v15 + 4 * BYTE2(a3) + 60) & 0x40000;
    }
    if (v19) {
      int v20 = BYTE2(a3);
    }
    else {
      int v20 = 46;
    }
    int v52 = v20;
    if (BYTE1(a3) > 0x7Fu) {
      int v21 = __maskrune(BYTE1(a3), 0x40000uLL);
    }
    else {
      int v21 = *(_DWORD *)(v15 + 4 * BYTE1(a3) + 60) & 0x40000;
    }
    if (v21) {
      int v22 = BYTE1(a3);
    }
    else {
      int v22 = 46;
    }
    int v51 = v22;
    if (a3 > 0x7Fu) {
      int v23 = __maskrune(a3, 0x40000uLL);
    }
    else {
      int v23 = *(_DWORD *)(v15 + 4 * a3 + 60) & 0x40000;
    }
    if (v23) {
      int v24 = a3;
    }
    else {
      int v24 = 46;
    }
    int v50 = v24;
    if ((a4 & 0x80000000) != 0) {
      int v25 = __maskrune(HIBYTE(a4), 0x40000uLL);
    }
    else {
      int v25 = *(_DWORD *)(v15 + 4 * HIBYTE(a4) + 60) & 0x40000;
    }
    if (v25) {
      int v26 = HIBYTE(a4);
    }
    else {
      int v26 = 46;
    }
    int v49 = v26;
    if (BYTE2(a4) > 0x7Fu) {
      int v27 = __maskrune(BYTE2(a4), 0x40000uLL);
    }
    else {
      int v27 = *(_DWORD *)(v15 + 4 * BYTE2(a4) + 60) & 0x40000;
    }
    if (v27) {
      int v28 = BYTE2(a4);
    }
    else {
      int v28 = 46;
    }
    int v48 = v28;
    if (BYTE1(a4) > 0x7Fu) {
      int v29 = __maskrune(BYTE1(a4), 0x40000uLL);
    }
    else {
      int v29 = *(_DWORD *)(v15 + 4 * BYTE1(a4) + 60) & 0x40000;
    }
    if (v29) {
      int v30 = BYTE1(a4);
    }
    else {
      int v30 = 46;
    }
    int v47 = v30;
    uint64_t v54 = a1;
    if (a4 > 0x7Fu) {
      int v31 = __maskrune(a4, 0x40000uLL);
    }
    else {
      int v31 = *(_DWORD *)(v15 + 4 * a4 + 60) & 0x40000;
    }
    if (v31) {
      int v32 = a4;
    }
    else {
      int v32 = 46;
    }
    if ((a5 & 0x80000000) != 0) {
      int v33 = __maskrune(HIBYTE(a5), 0x40000uLL);
    }
    else {
      int v33 = *(_DWORD *)(v15 + 4 * HIBYTE(a5) + 60) & 0x40000;
    }
    if (v33) {
      int v34 = HIBYTE(a5);
    }
    else {
      int v34 = 46;
    }
    if (BYTE2(a5) > 0x7Fu) {
      int v35 = __maskrune(BYTE2(a5), 0x40000uLL);
    }
    else {
      int v35 = *(_DWORD *)(v15 + 4 * BYTE2(a5) + 60) & 0x40000;
    }
    if (v35) {
      int v36 = BYTE2(a5);
    }
    else {
      int v36 = 46;
    }
    if (BYTE1(a5) > 0x7Fu) {
      int v37 = __maskrune(BYTE1(a5), 0x40000uLL);
    }
    else {
      int v37 = *(_DWORD *)(v15 + 4 * BYTE1(a5) + 60) & 0x40000;
    }
    if (v37) {
      int v38 = BYTE1(a5);
    }
    else {
      int v38 = 46;
    }
    if (a5 > 0x7Fu) {
      int v39 = __maskrune(a5, 0x40000uLL);
    }
    else {
      int v39 = *(_DWORD *)(v15 + 4 * a5 + 60) & 0x40000;
    }
    int v58 = 136318210;
    if (v39) {
      int v40 = a5;
    }
    else {
      int v40 = 46;
    }
    uint64_t v59 = "FigHALAudioPropertySendOneChange";
    __int16 v60 = 1024;
    int v61 = v53;
    __int16 v62 = 1024;
    int v63 = v52;
    __int16 v64 = 1024;
    int v65 = v51;
    __int16 v66 = 1024;
    int v67 = v50;
    __int16 v68 = 1024;
    int v69 = v49;
    __int16 v70 = 1024;
    int v71 = v48;
    __int16 v72 = 1024;
    int v73 = v47;
    __int16 v74 = 1024;
    int v75 = v32;
    __int16 v76 = 1024;
    int v77 = v34;
    __int16 v78 = 1024;
    int v79 = v36;
    __int16 v80 = 1024;
    int v81 = v38;
    __int16 v82 = 1024;
    int v83 = v40;
    CFTypeID v17 = (unsigned char *)_os_log_send_and_compose_impl();
    LOBYTE(v11) = v56;
    a2 = a2;
    a1 = v54;
  }
  else
  {
    CFTypeID v17 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v17, v17 != v84, v11, 0, v13);
  int v41 = (*a1)(a1, a2, 1, v57);
  int v56 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  uint64_t v42 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v56, &type);
  int v43 = v56;
  if (os_log_type_enabled(v42, type)) {
    unsigned int v45 = v43;
  }
  else {
    unsigned int v45 = v43 & 0xFFFFFFFE;
  }
  if (v45)
  {
    int v58 = 136316162;
    uint64_t v59 = "FigHALAudioPropertySendOneChange";
    __int16 v60 = 1024;
    int v61 = v41;
    __int16 v62 = 1024;
    int v63 = a3;
    __int16 v64 = 1024;
    int v65 = a4;
    __int16 v66 = 1024;
    int v67 = a5;
    uint64_t v46 = (unsigned char *)_os_log_send_and_compose_impl();
    LOBYTE(v43) = v56;
  }
  else
  {
    uint64_t v46 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v46, v46 != v84, v43, 0, v44);
}

void FigHALAudioPropertySendChanges(uint64_t (**a1)(void, uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v20 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v20, &type);
  int v9 = v20;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = v9 & 0xFFFFFFFE;
  }
  if (v11)
  {
    int v21 = 136315650;
    int v22 = "FigHALAudioPropertySendChanges";
    __int16 v23 = 1024;
    int v24 = a2;
    __int16 v25 = 1024;
    int v26 = a3;
    BOOL v12 = (unsigned char *)_os_log_send_and_compose_impl();
    LOBYTE(v9) = v20;
  }
  else
  {
    BOOL v12 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v12, v12 != v29, v9, 0, v10);
  int v13 = (*a1)(a1, a2, a3, a4);
  int v20 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  unsigned int v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v20, &type);
  int v15 = v20;
  if (os_log_type_enabled(v14, type)) {
    unsigned int v17 = v15;
  }
  else {
    unsigned int v17 = v15 & 0xFFFFFFFE;
  }
  if (v17)
  {
    int v21 = 136315906;
    int v22 = "FigHALAudioPropertySendChanges";
    __int16 v23 = 1024;
    int v24 = v13;
    __int16 v25 = 1024;
    int v26 = a2;
    __int16 v27 = 1024;
    int v28 = a3;
    int v18 = (unsigned char *)_os_log_send_and_compose_impl();
    LOBYTE(v15) = v20;
  }
  else
  {
    int v18 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v18, v18 != v29, v15, 0, v16);
}

void FigHALAudioPropertySendOneChangeAsync(uint64_t a1, int a2, int a3, int a4, int a5)
{
  if (GetHostCallbackQueue_sInitCallbackQueueOnce != -1) {
    dispatch_once(&GetHostCallbackQueue_sInitCallbackQueueOnce, &__block_literal_global_21);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigHALAudioPropertySendOneChangeAsync_block_invoke;
  block[3] = &__block_descriptor_tmp_2_0;
  block[4] = a1;
  int v11 = a2;
  int v12 = a3;
  int v13 = a4;
  int v14 = a5;
  dispatch_async((dispatch_queue_t)GetHostCallbackQueue_sCallbackQueue, block);
}

void __FigHALAudioPropertySendOneChangeAsync_block_invoke(uint64_t a1)
{
}

dispatch_queue_t __GetHostCallbackQueue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("FigHALAudioHostCallbackQueue", 0);
  GetHostCallbackQueue_sCallbackQueue = (uint64_t)result;
  return result;
}

void ids_didReceivePackage(const void *a1, const void *a2)
{
  if (a1 && a2)
  {
    uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
    if (!*DerivedStorage)
    {
      uint64_t v5 = DerivedStorage;
      CFRetain(a2);
      CFRetain(a1);
      uint64_t v6 = *((void *)v5 + 6);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __ids_didReceivePackage_block_invoke;
      block[3] = &__block_descriptor_56_e5_v8__0l;
      block[4] = v5;
      void block[5] = a2;
      block[6] = a1;
      dispatch_async(v6, block);
    }
  }
}

uint64_t FigTransportConnectionIDSCreate(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (a2)
  {
    if (FigTransportConnectionIDSCreate_onceToken != -1) {
      dispatch_once(&FigTransportConnectionIDSCreate_onceToken, &__block_literal_global_22);
    }
    uint64_t v4 = 0;
    if (!ids_IDSOpenSocketOptionTransportKey) {
      goto LABEL_13;
    }
    if (!ids_IDSOpenSocketOptionPriorityKey) {
      goto LABEL_13;
    }
    if (!ids_IDSOpenSocketOptionScopeKey) {
      goto LABEL_13;
    }
    if (!ids_IDSLinkPreferenceOptionPacketsPerSecondKey) {
      goto LABEL_13;
    }
    if (!ids_IDSLinkPreferenceOptionInputBytesPerSecondKey) {
      goto LABEL_13;
    }
    if (!ids_IDSLinkPreferenceOptionOutputBytesPerSecondKey) {
      goto LABEL_13;
    }
    if (!ids_IDSDeviceConnectionClass) {
      goto LABEL_13;
    }
    if (!ids_IDSServiceClass) {
      goto LABEL_13;
    }
    ClassID = (void *)NeroTransportConnectionGetClassID();
    uint64_t v4 = CMDerivedObjectCreate(a1, (uint64_t)&kFigTransportConnectionUSBVTable, ClassID, &cf);
    if (v4) {
      goto LABEL_13;
    }
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
    long long v7 = (void *)[objc_alloc((Class)ids_IDSServiceClass) initWithService:@"com.apple.private.alloy.fignero"];
    long long v8 = (void *)[v7 devices];
    if ([v8 count])
    {
      unint64_t v9 = 0;
      do
      {
        if (objc_msgSend((id)objc_msgSend(v8, "objectAtIndexedSubscript:", v9), "isDefaultPairedDevice")) {
          *(void *)(DerivedStorage + 160) = [v8 objectAtIndexedSubscript:v9];
        }
        ++v9;
      }
      while ([v8 count] > v9);
    }
    uint64_t v10 = [*(id *)(DerivedStorage + 160) deviceType];
    int v11 = *(void **)(DerivedStorage + 160);
    if (v10 == 6)
    {
      if (v11)
      {
        [v11 operatingSystemVersion];
        if (v39 > 10) {
          goto LABEL_28;
        }
        int v11 = *(void **)(DerivedStorage + 160);
      }
      else
      {
        uint64_t v39 = 0;
        uint64_t v40 = 0;
        uint64_t v41 = 0;
      }
    }
    if ([v11 deviceType] != 2) {
      goto LABEL_36;
    }
    int v12 = *(void **)(DerivedStorage + 160);
    if (!v12)
    {
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      goto LABEL_36;
    }
    [v12 operatingSystemVersion];
    if (v36 < 18)
    {
LABEL_36:
      int v35 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v35, &type);
      int v19 = v35;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v21 = v19;
      }
      else {
        unsigned int v21 = v19 & 0xFFFFFFFE;
      }
      if (v21)
      {
        int v43 = 136315138;
        uint64_t v44 = "FigTransportConnectionIDSCreate";
        int v22 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v19) = v35;
      }
      else
      {
        int v22 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v22, v22 != v45, v19, 0, v20);
      __int16 v23 = NeroMessageCenterSocket;
LABEL_45:
      id v24 = [v23 alloc];
      uint64_t v25 = [v24 initWithIDSSerivce:v7 connection:cf];
      *(void *)(DerivedStorage + 72) = v25;
      if (v25)
      {
        dispatch_queue_t v26 = FigDispatchQueueCreateWithPriority("FigTransportConnectionIDS", 0, 0x1Cu);
        *(void *)(DerivedStorage + 8) = v26;
        if (v26)
        {
          dispatch_queue_t v27 = FigDispatchQueueCreateWithPriority("FigTransportConnectionIDS.data", 0, 0x1Cu);
          *(void *)(DerivedStorage + 16) = v27;
          if (v27)
          {
            dispatch_semaphore_t v28 = dispatch_semaphore_create(0);
            *(void *)(DerivedStorage + 144) = v28;
            if (v28)
            {
              dispatch_semaphore_t v29 = dispatch_semaphore_create(0);
              *(void *)(DerivedStorage + 152) = v29;
              if (v29)
              {
                CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                CFDictionarySetValue(Mutable, @"FigMemoryPool_LoggingName", @"TransportConnectionIDS");
                int v31 = CMMemoryPoolCreate(Mutable);
                *(void *)(DerivedStorage + 56) = v31;
                if (Mutable)
                {
                  CFRelease(Mutable);
                  int v31 = *(OpaqueCMMemoryPool **)(DerivedStorage + 56);
                }
                if (v31)
                {
                  CFAllocatorRef Allocator = CMMemoryPoolGetAllocator(v31);
                  *(void *)(DerivedStorage + 64) = Allocator;
                  if (Allocator) {
                    CFRetain(Allocator);
                  }
                  uint64_t v4 = 0;
                  *a2 = cf;
                  return v4;
                }
              }
            }
          }
        }
      }
      uint64_t v4 = 4294955245;
LABEL_13:
      if (cf) {
        CFRelease(cf);
      }
      return v4;
    }
LABEL_28:
    if (FigGetCFPreferenceBooleanWithDefault(@"EnableNeroIDSService", @"com.apple.coremedia", 0)|| _os_feature_enabled_impl())
    {
      int v35 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      int v13 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v35, &type);
      int v14 = v35;
      if (os_log_type_enabled(v13, type)) {
        unsigned int v16 = v14;
      }
      else {
        unsigned int v16 = v14 & 0xFFFFFFFE;
      }
      if (v16)
      {
        int v43 = 136315138;
        uint64_t v44 = "FigTransportConnectionIDSCreate";
        unsigned int v17 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v14) = v35;
      }
      else
      {
        unsigned int v17 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v17, v17 != v45, v14, 0, v15);
      __int16 v23 = NeroMessageCenterService;
      goto LABEL_45;
    }
    goto LABEL_36;
  }

  return FigSignalErrorAt(4294955246, 0, 0, 0, 0, 0, 0);
}

void *__FigTransportConnectionIDSCreate_block_invoke()
{
  uint64_t v0 = dlopen("/System/Library/PrivateFrameworks/IDSFoundation.framework/IDSFoundation", 1);
  if (v0)
  {
    uint64_t v1 = v0;
    ids_IDSOpenSocketOptionTransportKey = (uint64_t)dlsym(v0, "IDSOpenSocketOptionTransportKey");
    ids_IDSOpenSocketOptionPriorityKey = (uint64_t)dlsym(v1, "IDSOpenSocketOptionPriorityKey");
    ids_IDSOpenSocketOptionScopeKey = (uint64_t)dlsym(v1, "IDSOpenSocketOptionScopeKey");
  }
  dispatch_queue_t result = dlopen("/System/Library/PrivateFrameworks/IDS.framework/IDS", 1);
  if (result)
  {
    uint64_t v3 = result;
    ids_IDSDeviceConnectionClass = (uint64_t)objc_getClass("IDSDeviceConnection");
    ids_IDSServiceClass = (uint64_t)objc_getClass("IDSService");
    ids_IDSLinkPreferenceOptionPacketsPerSecondKey = (uint64_t)dlsym(v3, "IDSLinkPreferenceOptionPacketsPerSecondKey");
    ids_IDSLinkPreferenceOptionInputBytesPerSecondKey = (uint64_t)dlsym(v3, "IDSLinkPreferenceOptionInputBytesPerSecondKey");
    dispatch_queue_t result = dlsym(v3, "IDSLinkPreferenceOptionOutputBytesPerSecondKey");
    ids_IDSLinkPreferenceOptionOutputBytesPerSecondKey = (uint64_t)result;
  }
  return result;
}

void __ids_didReceivePackage_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)v2)
  {
    uint64_t v3 = *(void *)(v2 + 40);
    if (v3) {
      (*(void (**)(uint64_t, void, void))(v3 + 16))(v3, 0, *(void *)(a1 + 40));
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 48));
  uint64_t v4 = *(const void **)(a1 + 40);

  CFRelease(v4);
}

uint64_t ids_Invalidate(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  *(unsigned char *)uint64_t DerivedStorage = 1;
  uint64_t v2 = *(const void **)(DerivedStorage + 72);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(DerivedStorage + 72) = 0;
  }
  return 0;
}

void ids_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  ids_Invalidate(a1);
  uint64_t v3 = DerivedStorage[1];
  if (v3)
  {
    dispatch_release(v3);
    DerivedStorage[1] = 0;
  }
  uint64_t v4 = DerivedStorage[2];
  if (v4)
  {
    dispatch_release(v4);
    DerivedStorage[2] = 0;
  }
  uint64_t v5 = (const void *)DerivedStorage[5];
  if (v5)
  {
    _Block_release(v5);
    DerivedStorage[5] = 0;
  }
  uint64_t v6 = DerivedStorage[18];
  if (v6)
  {
    dispatch_release(v6);
    DerivedStorage[18] = 0;
  }
  long long v7 = DerivedStorage[19];
  if (v7)
  {
    dispatch_release(v7);
    DerivedStorage[19] = 0;
  }
  long long v8 = (const void *)DerivedStorage[7];
  if (v8)
  {
    CFRelease(v8);
    DerivedStorage[7] = 0;
  }
  unint64_t v9 = (const void *)DerivedStorage[8];
  if (v9)
  {
    CFRelease(v9);
    DerivedStorage[8] = 0;
  }
  uint64_t v10 = DerivedStorage[6];
  if (v10)
  {
    dispatch_release(v10);
    DerivedStorage[6] = 0;
  }
}

__CFString *ids_CopyDebugDescription(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigTransportConnectionIDS %p>", a1);
  return Mutable;
}

uint64_t ids_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage) {
    return 4294955241;
  }
  long long v7 = DerivedStorage;
  if (!CFEqual(a2, @"ConnectionMode"))
  {
    if (CFEqual(a2, @"Version"))
    {
      CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      p_int valuePtr = (int *)(v7 + 32);
    }
    else
    {
      if (!CFEqual(a2, @"ReplyTimeout")) {
        return 4294954512;
      }
      int valuePtr = 6;
      CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      p_int valuePtr = &valuePtr;
    }
    unint64_t v9 = CFNumberCreate(v10, kCFNumberSInt32Type, p_valuePtr);
    goto LABEL_11;
  }
  long long v8 = (const void *)*((void *)v7 + 3);
  if (v8)
  {
    unint64_t v9 = (void *)CFRetain(v8);
LABEL_11:
    int v12 = v9;
    goto LABEL_12;
  }
  int v12 = 0;
LABEL_12:
  uint64_t result = 0;
  *a4 = v12;
  return result;
}

uint64_t ids_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage) {
    return 4294955241;
  }
  uint64_t v6 = DerivedStorage;
  if (CFEqual(a2, @"ConnectionMode"))
  {
    uint64_t v7 = *((void *)v6 + 3);
    *((void *)v6 + 3) = a3;
    if (a3) {
      CFRetain(a3);
    }
    if (v7)
    {
      CFRelease((CFTypeRef)v7);
      return 0;
    }
  }
  else if (CFEqual(a2, @"Version"))
  {
    if (a3)
    {
      CFTypeID v8 = CFGetTypeID(a3);
      uint64_t v7 = 4294954516;
      if (v8 == CFNumberGetTypeID())
      {
        if (CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, v6 + 32)) {
          return 0;
        }
        else {
          return 4294954516;
        }
      }
    }
    else
    {
      return 4294954516;
    }
  }
  else
  {
    return 4294954512;
  }
  return v7;
}

uint64_t ids_SetEventHandler(uint64_t a1, NSObject *a2, unint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage) {
    return 4294955241;
  }
  uint64_t v6 = DerivedStorage;
  uint64_t v7 = *(NSObject **)(DerivedStorage + 48);
  if ((unint64_t)a2 | a3)
  {
    if (v7)
    {
      dispatch_release(v7);
      *(void *)(v6 + 48) = 0;
    }
    if (a2)
    {
      *(void *)(v6 + 48) = a2;
      dispatch_retain(a2);
    }
    else
    {
      *(void *)(v6 + 48) = FigDispatchQueueCreateWithPriority("FigTransportConnectionEvent", 0, 0x1Cu);
    }
    CFTypeID v8 = *(const void **)(v6 + 40);
    if (v8)
    {
      _Block_release(v8);
      *(void *)(v6 + 40) = 0;
    }
    if (a3)
    {
      unint64_t v9 = _Block_copy((const void *)a3);
      uint64_t result = 0;
      *(void *)(v6 + 40) = v9;
      return result;
    }
  }
  else
  {
    if (!v7) {
      return 4294955240;
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __ids_SetEventHandler_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = v6;
    dispatch_sync(v7, block);
  }
  return 0;
}

uint64_t ids_Start(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage) {
    return 4294955241;
  }
  uint64_t v3 = DerivedStorage;
  [*(id *)(DerivedStorage + 72) activateConnection];
  int v4 = *(_DWORD *)(v3 + 36);
  if (!v4)
  {
    if (*(void *)(v3 + 80)) {
      return 4294955243;
    }
    *(unsigned char *)(v3 + 88) = 0;
    values = @"FigTransportConnectionIDS.mainThread";
    CFDictionaryRef v5 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&kFigThreadCreateKey_Identifier, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    FigThreadCreate((uint64_t)ids_threadMain, a1, 0x1Cu, 1, v5, (pthread_t *)(v3 + 80));
    if (v5) {
      CFRelease(v5);
    }
    int v4 = *(_DWORD *)(v3 + 36);
  }
  uint64_t result = 0;
  *(_DWORD *)(v3 + 36) = v4 + 1;
  return result;
}

uint64_t ids_Stop(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage) {
    return 4294955241;
  }
  uint64_t v2 = DerivedStorage;
  uint64_t v3 = *(NSObject **)(DerivedStorage + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __ids_Stop_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = v2;
  dispatch_sync(v3, block);
  [*(id *)(v2 + 72) deactivateConnection];
  return 0;
}

uint64_t ids_EnqueuePackageWithPriority(const void *a1, unsigned int *a2, OpaqueCMBlockBuffer *a3, int a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v9 = *a2;
  DataCFIndex Length = CMBlockBufferGetDataLength(a3);
  if (*(unsigned char *)DerivedStorage) {
    return 4294955241;
  }
  if (a2[1] == 1885957735) {
    goto LABEL_17;
  }
  if (!*(unsigned char *)(DerivedStorage + 89))
  {
    uint64_t v21 = 4294955244;
    goto LABEL_20;
  }
  if ((a4 - 3) <= 0xFFFFFFFD || (size_t v11 = v9 - DataLength, v9 - DataLength <= 7))
  {
LABEL_17:
    uint64_t v21 = 4294955246;
LABEL_20:
    return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
  }
  int v22 = a4;
  size_t v12 = CMBlockBufferGetDataLength(a3);
  size_t v13 = v12 + v11;
  int v14 = (char *)malloc_type_malloc(v12 + v11, 0x729B95DDuLL);
  size_t lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  memcpy(v14, a2, v11);
  if (v12)
  {
    size_t v15 = 0;
    while (1)
    {
      size_t lengthAtOffsetOut = -1;
      dataPointerOut = 0;
      if (CMBlockBufferGetDataPointer(a3, v15, &lengthAtOffsetOut, 0, &dataPointerOut)) {
        break;
      }
      size_t v16 = lengthAtOffsetOut;
      if (v13 < lengthAtOffsetOut + v15 + v11) {
        break;
      }
      memcpy(&v14[v15 + v11], dataPointerOut, lengthAtOffsetOut);
      v15 += v16;
      if (v15 >= v12) {
        goto LABEL_11;
      }
    }
  }
  else
  {
LABEL_11:
    unsigned int v17 = malloc_type_calloc(1uLL, 0x18uLL, 0x10A00404E934A1DuLL);
    if (v17)
    {
      int v18 = v17;
      v17[1] = v14;
      v17[2] = v13;
      CFRetain(a1);
      int v19 = *(NSObject **)(DerivedStorage + 16);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __ids_EnqueuePackageWithPriority_block_invoke;
      block[3] = &__block_descriptor_60_e5_v8__0l;
      block[4] = v18;
      void block[5] = DerivedStorage;
      int v24 = v22;
      block[6] = a1;
      dispatch_async(v19, block);
      return 0;
    }
  }
  if (v14) {
    CFRelease(v14);
  }
  return 4294955245;
}

uint64_t ids_FlushPendingPackagesWithPriority(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage) {
    return 4294955241;
  }
  CFDictionaryRef v5 = DerivedStorage;
  while (!v5[88])
  {
    uint64_t v6 = *((void *)v5 + 19);
    dispatch_time_t v7 = dispatch_time(0, 15000000);
    if (dispatch_semaphore_wait(v6, v7)) {
      break;
    }
    ids_sendData(a1, a2);
  }
  return 0;
}

uint64_t ids_threadMain(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!*(unsigned char *)(DerivedStorage + 88))
  {
    uint64_t v3 = DerivedStorage;
    do
    {
      if (![*(id *)(v3 + 72) isActive]) {
        break;
      }
      int v4 = (void *)MEMORY[0x192FC5D30]();
      uint64_t v5 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      CFRetain(a1);
      uint64_t v6 = *(NSObject **)(v5 + 16);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __ids_sendPackagesMain_block_invoke;
      block[3] = &__block_descriptor_48_e5_v8__0l;
      block[4] = v5;
      void block[5] = a1;
      dispatch_async(v6, block);
      while (!*(unsigned char *)(v5 + 88) && [*(id *)(v5 + 72) isActive])
      {
        dispatch_time_t v7 = (void *)MEMORY[0x192FC5D30]();
        CFTypeID v8 = *(NSObject **)(v5 + 152);
        dispatch_time_t v9 = dispatch_time(0, 300000000);
        if (!dispatch_semaphore_wait(v8, v9)) {
          ids_sendData((uint64_t)a1, 0);
        }
      }
      CFRetain(a1);
      CFAllocatorRef v10 = *(NSObject **)(v5 + 16);
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      v14[2] = __ids_sendPackagesMain_block_invoke_3;
      v14[3] = &__block_descriptor_48_e5_v8__0l;
      v14[4] = v5;
      v14[5] = a1;
      dispatch_async(v10, v14);
      size_t v11 = *(NSObject **)(v3 + 144);
      dispatch_time_t v12 = dispatch_time(0, 5000000000);
      dispatch_semaphore_wait(v11, v12);
    }
    while (!*(unsigned char *)(v3 + 88));
  }
  return 0;
}

void __ids_sendPackagesMain_block_invoke(uint64_t a1)
{
  for (uint64_t i = 0; i != 32; i += 16)
  {
    *(void *)(*(void *)(a1 + 32) + i + 112) = 0;
    *(void *)(*(void *)(a1 + 32) + i + 120) = *(void *)(a1 + 32) + i + 112;
  }
  uint64_t v3 = *(unsigned char **)(a1 + 32);
  v3[89] = 1;
  if (!*v3)
  {
    CFRetain(*(CFTypeRef *)(a1 + 40));
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    v4[2] = __ids_sendPackagesMain_block_invoke_2;
    v4[3] = &__block_descriptor_48_e5_v8__0l;
    long long v5 = *(_OWORD *)(a1 + 32);
    dispatch_async(*(dispatch_queue_t *)(v5 + 48), v4);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void __ids_sendPackagesMain_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)v2)
  {
    uint64_t v3 = *(void *)(v2 + 40);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t, void))(v3 + 16))(v3, 1, 0);
    }
  }
  int v4 = *(const void **)(a1 + 40);

  CFRelease(v4);
}

void ids_sendData(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  int v4 = *(NSObject **)(DerivedStorage + 16);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __ids_sendData_block_invoke;
  v5[3] = &__block_descriptor_44_e5_v8__0l;
  int v6 = a2;
  v5[4] = DerivedStorage;
  dispatch_sync(v4, v5);
}

void __ids_sendPackagesMain_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)(a1 + 32);
  v2[89] = 0;
  if (!*v2)
  {
    CFRetain(*(CFTypeRef *)(a1 + 40));
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = __ids_sendPackagesMain_block_invoke_4;
    v9[3] = &__block_descriptor_48_e5_v8__0l;
    long long v10 = *(_OWORD *)(a1 + 32);
    dispatch_async(*(dispatch_queue_t *)(v10 + 48), v9);
    uint64_t v2 = *(unsigned char **)(a1 + 32);
  }
  for (uint64_t i = 1; i != 3; ++i)
  {
    while (1)
    {
      int v4 = &v2[16 * i];
      dispatch_time_t v7 = (void **)*((void *)v4 + 12);
      long long v5 = (void **)(v4 + 96);
      int v6 = v7;
      if (!v7) {
        break;
      }
      CFTypeID v8 = *v6;
      *long long v5 = *v6;
      if (!v8) {
        *(void *)(*(void *)(a1 + 32) + 16 * i + 104) = *(void *)(a1 + 32) + 16 * i + 96;
      }
      free(v6[1]);
      free(v6);
      uint64_t v2 = *(unsigned char **)(a1 + 32);
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void __ids_sendPackagesMain_block_invoke_4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)v2)
  {
    uint64_t v3 = *(void *)(v2 + 40);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t, void))(v3 + 16))(v3, 2, 0);
    }
  }
  int v4 = *(const void **)(a1 + 40);

  CFRelease(v4);
}

void __ids_sendData_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(int *)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = *(void **)(v3 + 16 * v2 + 96);
    if (v4 && [*(id *)(v3 + 72) sendMemoryBlock:v4[1] withLength:v4[2]])
    {
      uint64_t v5 = *(int *)(a1 + 40);
      uint64_t v6 = *(void *)(a1 + 32) + 16 * v5;
      uint64_t v7 = **(void **)(v6 + 96);
      *(void *)(v6 + 96) = v7;
      if (!v7) {
        *(void *)(*(void *)(a1 + 32) + 16 * v5 + 104) = *(void *)(a1 + 32) + 16 * v5 + 96;
      }
      free(v4);
    }
  }
  else
  {
    for (uint64_t i = 112; i != 144; i += 16)
    {
      uint64_t v9 = *(void *)(a1 + 32);
      long long v10 = *(void **)(v9 + i);
      if (v10 && [*(id *)(v9 + 72) sendMemoryBlock:v10[1] withLength:v10[2]])
      {
        uint64_t v11 = *(void *)(a1 + 32);
        uint64_t v12 = **(void **)(v11 + i);
        *(void *)(v11 + i) = v12;
        if (!v12) {
          *(void *)(*(void *)(a1 + 32) + i + 8) = *(void *)(a1 + 32) + i;
        }
        free(v10);
      }
    }
  }
}

uint64_t FigIsHDRAllowedOnDevice()
{
  if (FigIsHDRAllowedOnDevice_onceTokenIsHDRAllowedOnDevice != -1) {
    dispatch_once(&FigIsHDRAllowedOnDevice_onceTokenIsHDRAllowedOnDevice, &__block_literal_global_23);
  }
  return FigIsHDRAllowedOnDevice_sIsHDRAllowedOnDevice;
}

uint64_t __FigIsHDRAllowedOnDevice_block_invoke()
{
  char v0 = MGGetBoolAnswer();
  char v1 = 0;
  uint64_t result = MGGetProductType();
  if (result <= 2614323574)
  {
    if (result <= 896202453)
    {
      if (result == 42878382 || result == 228444038) {
        goto LABEL_24;
      }
      uint64_t v3 = 337183581;
    }
    else if (result > 1878257789)
    {
      if (result == 1878257790) {
        goto LABEL_24;
      }
      uint64_t v3 = 2385671069;
    }
    else
    {
      if (result == 896202454) {
        goto LABEL_24;
      }
      uint64_t v3 = 1380747801;
    }
  }
  else if (result > 3397214290)
  {
    if (result > 3645319984)
    {
      if (result == 3645319985) {
        goto LABEL_24;
      }
      uint64_t v3 = 4242862982;
    }
    else
    {
      if (result == 3397214291) {
        goto LABEL_24;
      }
      uint64_t v3 = 3402870384;
    }
  }
  else if (result > 3196805750)
  {
    if (result == 3196805751) {
      goto LABEL_24;
    }
    uint64_t v3 = 3215673114;
  }
  else
  {
    if (result == 2614323575) {
      goto LABEL_24;
    }
    uint64_t v3 = 2781508713;
  }
  if (result != v3) {
    char v1 = v0;
  }
LABEL_24:
  FigIsHDRAllowedOnDevice_sIsHDRAllowedOnDevice = v1;
  return result;
}

BOOL FigIsDeviceCapableOfGeneratingStatisticsForHDR()
{
  if (FigIsDeviceCapableOfGeneratingStatisticsForHDR_onceTokenDeviceCapableOfGeneratingStatisticsForHDR != -1) {
    dispatch_once(&FigIsDeviceCapableOfGeneratingStatisticsForHDR_onceTokenDeviceCapableOfGeneratingStatisticsForHDR, &__block_literal_global_4);
  }
  return (FigIsDeviceCapableOfGeneratingStatisticsForHDR_sDeviceCapableOfGeneratingStatisticsForHDR & 1) == 0;
}

void __FigIsDeviceCapableOfGeneratingStatisticsForHDR_block_invoke()
{
  if (FigIsHDRAllowedOnDevice_onceTokenIsHDRAllowedOnDevice != -1) {
    dispatch_once(&FigIsHDRAllowedOnDevice_onceTokenIsHDRAllowedOnDevice, &__block_literal_global_23);
  }
  if (!FigIsHDRAllowedOnDevice_sIsHDRAllowedOnDevice) {
    FigIsDeviceCapableOfGeneratingStatisticsForHDR_sDeviceCapableOfGeneratingStatisticsForHDR = 1;
  }
}

OSStatus CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionData(CFAllocatorRef allocator, const uint8_t *soundDescriptionData, size_t size, CMSoundDescriptionFlavor flavor, CMAudioFormatDescriptionRef *formatDescriptionOut)
{
  CFTypeRef cf = 0;
  OSStatus BlockBufferCopyingMemoryBlock = FigCreateBlockBufferCopyingMemoryBlock(allocator, soundDescriptionData, size, (CMBlockBufferRef *)&cf);
  if (!BlockBufferCopyingMemoryBlock) {
    OSStatus BlockBufferCopyingMemoryBlock = FigAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBufferWithReporter(allocator, (CMBlockBufferRef)cf, flavor, formatDescriptionOut, 0);
  }
  OSStatus v9 = BlockBufferCopyingMemoryBlock;
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

OSStatus CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef soundDescriptionBlockBuffer, CMSoundDescriptionFlavor flavor, CMAudioFormatDescriptionRef *formatDescriptionOut)
{
  return FigAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBufferWithReporter(allocator, soundDescriptionBlockBuffer, flavor, formatDescriptionOut, 0);
}

uint64_t FigAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBufferWithReporter(const __CFAllocator *a1, CMBlockBufferRef theSourceBuffer, CFTypeRef cf1, CMAudioFormatDescriptionRef *a4, uint64_t a5)
{
  CFTypeRef v7 = cf1;
  uint64_t v228 = *MEMORY[0x1E4F143B8];
  long long v10 = 0uLL;
  long long v208 = 0u;
  memset(v209, 0, 112);
  long long v206 = 0u;
  long long v207 = 0u;
  long long v204 = 0u;
  long long v205 = 0u;
  long long v202 = 0u;
  long long v203 = 0u;
  long long v200 = 0u;
  long long v201 = 0u;
  long long v198 = 0u;
  long long v199 = 0u;
  long long v196 = 0u;
  long long v197 = 0u;
  long long v194 = 0u;
  long long v195 = 0u;
  long long v193 = 0u;
  memset(v192, 0, sizeof(v192));
  unsigned int v191 = 0;
  uint64_t v190 = 0;
  long long v189 = 0u;
  memset(v188, 0, sizeof(v188));
  memset(&layout, 0, sizeof(layout));
  long long v186 = 0uLL;
  v182 = 0;
  CMAudioFormatDescriptionRef formatDescriptionOut = 0;
  unsigned int v181 = 0;
  if (cf1)
  {
    if (CFEqual(cf1, @"ISOFamily"))
    {
      LODWORD(v7) = 1;
LABEL_8:
      long long v10 = 0uLL;
      LODWORD(v192[0]) = v7;
      goto LABEL_9;
    }
    if (CFEqual(v7, @"QuickTimeMovieV2"))
    {
      LODWORD(v7) = 4;
      goto LABEL_8;
    }
    if (CFEqual(v7, @"3GPFamily"))
    {
      LODWORD(v7) = 3;
      goto LABEL_8;
    }
    LOBYTE(v7) = 0;
    long long v10 = 0uLL;
  }
LABEL_9:
  *(void *)&asbd.mBitsPerChannel = 0;
  *(_OWORD *)&asbd.Float64 mSampleRate = v10;
  *(_OWORD *)&asbd.mBytesPerPacket = v10;
  int v184 = 0;
  LOWORD(destination[0]) = -1;
  uint64_t v11 = CMBlockBufferCopyDataBytes(theSourceBuffer, 0x10uLL, 2uLL, destination);
  if (v11)
  {
LABEL_739:
    uint64_t Empty = v11;
    goto LABEL_504;
  }
  int v12 = bswap32(LOWORD(destination[0]));
  int v13 = v12 >> 16;
  LOWORD(destination[0]) = HIWORD(v12);
  if ((v7 & 1) != 0 && v13 > 1)
  {
    int v14 = "Version >= 2 in ISO sound description";
    goto LABEL_13;
  }
  switch(v13)
  {
    case 0:
      int v18 = 1;
      size_t v15 = 36;
      goto LABEL_32;
    case 2:
      int v18 = 4;
      size_t v15 = 72;
      goto LABEL_32;
    case 1:
      IsBlockBufferISOchar v1 = figSoundBridge_IsBlockBufferISOv1(theSourceBuffer, 1);
      if ((v7 & 1) == 0 && IsBlockBufferISOv1)
      {
        int v14 = "ISO V1 in movie file";
        goto LABEL_13;
      }
      if (IsBlockBufferISOv1) {
        size_t v15 = 36;
      }
      else {
        size_t v15 = 52;
      }
      if (IsBlockBufferISOv1) {
        int v18 = 2;
      }
      else {
        int v18 = 3;
      }
      LOWORD(v13) = destination[0];
LABEL_32:
      LOWORD(v192[1]) = v13;
      HIDWORD(v192[1]) = v18;
      v192[2] = v15;
      goto LABEL_33;
  }
  int v14 = "Version >= 3 in sound description";
LABEL_13:
  figSoundBridge_ReportParsingFailureMessage(a5, (uint64_t)v14);
  uint64_t v11 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  if (v11) {
    goto LABEL_739;
  }
  size_t v15 = v192[2];
  if (v192[2] >= 0x49)
  {
    size_t v16 = "Offset to extension atoms is out of bounds";
    goto LABEL_39;
  }
LABEL_33:
  uint64_t v11 = CMBlockBufferCopyDataBytes(theSourceBuffer, 0, v15, &v192[3]);
  if (v11) {
    goto LABEL_739;
  }
  if (SLOWORD(v192[1]) >= 2)
  {
    signed int v19 = bswap32(HIDWORD(v193));
    if ((uint64_t)v192[2] >= v19)
    {
      if ((uint64_t)v192[2] > v19)
      {
        size_t v16 = "Sound description V2 size is less than expected";
        goto LABEL_39;
      }
    }
    else
    {
      v192[2] = v19;
    }
  }
  HIDWORD(v192[0]) = bswap32(HIDWORD(v192[3]));
  *(void *)&long long v208 = a5;
  if (LODWORD(v192[3])) {
    goto LABEL_44;
  }
  DataCFIndex Length = CMBlockBufferGetDataLength(theSourceBuffer);
  if (!HIDWORD(DataLength))
  {
    LODWORD(v192[3]) = bswap32(DataLength);
    goto LABEL_44;
  }
  size_t v16 = "Sound description V0 size is out of bounds";
LABEL_39:
  figSoundBridge_ReportParsingFailureMessage(v208, (uint64_t)v16);
  uint64_t v11 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  if (v11) {
    goto LABEL_739;
  }
LABEL_44:
  v172 = a4;
  int CFPreferenceNumberWithDefault = figSoundBridge_AllowZeroSizeTerminatorAtom_value;
  if (figSoundBridge_AllowZeroSizeTerminatorAtom_value == -1)
  {
    int CFPreferenceNumberWithDefault = FigGetCFPreferenceNumberWithDefault(@"zero_size_terminator_atom", @"com.apple.coremedia", 1);
    figSoundBridge_AllowZeroSizeTerminatorAtom_value = CFPreferenceNumberWithDefault;
  }
  char v22 = CFPreferenceNumberWithDefault != 0;
  if (!(LOWORD(v192[1]) | v192[0] & 1)) {
    goto LABEL_276;
  }
  int64_t v23 = CMBlockBufferGetDataLength(theSourceBuffer);
  if (v23 < (uint64_t)v192[2])
  {
    v161 = "Offset to extension atoms is greater than length of sound description";
    uint64_t v162 = a5;
LABEL_738:
    figSoundBridge_ReportParsingFailureMessage(v162, (uint64_t)v161);
    uint64_t v11 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_739;
  }
  if (v23 == v192[2]) {
    goto LABEL_276;
  }
  uint64_t v11 = FigAtomStreamInitWithBBuf(theSourceBuffer, v192[2], v22, (uint64_t)v209);
  if (v11) {
    goto LABEL_739;
  }
  theBuffer = theSourceBuffer;
  CFAllocatorRef v170 = a1;
  uint64_t v167 = a5;
  if (LOWORD(v192[1]))
  {
    if ((v192[0] & 1) == 0)
    {
      BOOL v174 = (HIDWORD(v192[1]) - 1) < 2;
      LOBYTE(v165) = 1;
LABEL_56:
      CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      LODWORD(lengthAtOffsetOut) = 0;
      size_t size = 0;
      int v210 = 0;
      CurrentAtomTypeAndDataCFIndex Length = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v209, &lengthAtOffsetOut, &size);
      if (CurrentAtomTypeAndDataLength)
      {
        uint64_t Empty = CurrentAtomTypeAndDataLength;
        unsigned int v25 = 0;
        CFTypeRef cf = 0;
        dispatch_queue_t v26 = 0;
        goto LABEL_218;
      }
      dispatch_queue_t v26 = 0;
      unsigned int v176 = 0;
      unsigned int v25 = 0;
      char v28 = v165;
      while (1)
      {
        size_t v29 = size;
        if ((size & 0x8000000000000000) != 0)
        {
          figSoundBridge_ReportParsingFailureMessage(v208, (uint64_t)"Sound description extension data has incorrect length");
          uint64_t ESDSAtomAndData = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_717:
          uint64_t Empty = ESDSAtomAndData;
          goto LABEL_217;
        }
        int v30 = lengthAtOffsetOut;
        if (lengthAtOffsetOut) {
          break;
        }
LABEL_172:
        int Atom = FigAtomStreamAdvanceToNextAtom(v209);
        if (Atom)
        {
          if (Atom != -12890) {
            figSoundBridge_ReportParsingFailureMessage(v208, (uint64_t)"Sound description has extra bytes that can't be parsed as an extension");
          }
          uint64_t Empty = 0;
LABEL_217:
          CFTypeRef cf = 0;
          goto LABEL_218;
        }
        LODWORD(lengthAtOffsetOut) = 0;
        size_t size = 0;
        int v210 = 0;
        uint64_t ESDSAtomAndData = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v209, &lengthAtOffsetOut, &size);
        if (ESDSAtomAndData) {
          goto LABEL_717;
        }
      }
      if (lengthAtOffsetOut == 1936289382)
      {
        if ((void)v202)
        {
LABEL_62:
          if (v25 == v176)
          {
            int v31 = (CFTypeRef *)malloc_type_realloc(v26, 24 * (int)(v176 + 16), 0x1060040D0FAAE32uLL);
            if (!v31)
            {
              uint64_t Empty = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              CFTypeRef cf = 0;
              dispatch_queue_t v26 = 0;
              unsigned int v25 = v176;
              goto LABEL_218;
            }
            v176 += 16;
            dispatch_queue_t v26 = v31;
          }
          CFMutableArrayRef Mutable = CFDataCreateMutable(allocator, 0);
          CFDataRef v33 = Mutable;
          CFTypeRef cf = Mutable;
          if (lengthAtOffsetOut == 1970628964)
          {
            CFDataSetLength(Mutable, v29 + 16);
            BytePtr = (UInt8 *)CFDataGetBytePtr(v33);
            uint64_t CurrentAtomUUIDType = FigAtomStreamGetCurrentAtomUUIDType((uint64_t)v209, BytePtr);
            if (CurrentAtomUUIDType)
            {
              uint64_t Empty = CurrentAtomUUIDType;
              goto LABEL_218;
            }
            uint64_t v36 = BytePtr + 16;
          }
          else
          {
            CFDataSetLength(Mutable, v29);
            uint64_t v36 = CFDataGetBytePtr(v33);
          }
          uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData((uint64_t)v209, 0, v29, (uint64_t)v36);
          if (CurrentAtomData)
          {
            uint64_t Empty = CurrentAtomData;
            goto LABEL_218;
          }
          if (cf)
          {
            uint64_t v42 = &v26[3 * (int)v25];
            *(_DWORD *)uint64_t v42 = lengthAtOffsetOut;
            v42[1] = cf;
            *((_DWORD *)v42 + 4) = 0;
            ++v25;
          }
          goto LABEL_172;
        }
        uint64_t v39 = (CMBlockBufferRef *)&v202;
        goto LABEL_80;
      }
      if (v28)
      {
        if (v174)
        {
          int v37 = 1;
LABEL_83:
          if (v30 > 1684425824)
          {
            if (v30 <= 1885564226)
            {
              if (v30 == 1684425825 || v30 == 1702061171) {
                goto LABEL_172;
              }
              int v40 = 1718773093;
            }
            else if (v30 > 1936875891)
            {
              if (v30 == 1936875892) {
                goto LABEL_172;
              }
              int v40 = 2002876005;
            }
            else
            {
              if (v30 == 1885564227) {
                goto LABEL_172;
              }
              int v40 = 1935764850;
            }
          }
          else if (v30 <= 1667785069)
          {
            if (!v30 || v30 == 1633972845) {
              goto LABEL_172;
            }
            int v40 = 1634492771;
          }
          else if (v30 > 1684106609)
          {
            if (v30 == 1684106610) {
              goto LABEL_172;
            }
            int v40 = 1684366131;
          }
          else
          {
            if (v30 == 1667785070) {
              goto LABEL_172;
            }
            int v40 = 1684103987;
          }
          if (v30 == v40 || !v37) {
            goto LABEL_172;
          }
          goto LABEL_62;
        }
        if (lengthAtOffsetOut != 1667785070)
        {
          if (lengthAtOffsetOut != 2002876005)
          {
            if (figSoundBridge_GetDecodeFormatIDForUnknownExtensionType(lengthAtOffsetOut, (uint64_t)v192, &v210))
            {
              int v52 = v26;
              int v53 = v210;
              LODWORD(v204) = v210;
              if (!*((void *)&v203 + 1))
              {
                uint64_t BBuf = FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)v209, (CMBlockBufferRef *)&v203 + 1);
                if (BBuf) {
                  goto LABEL_760;
                }
              }
              uint64_t BBuf = figSoundBridge_TransformToCanonicalMagicCookieBBuf(v170, v53, (uint64_t)v192, (CMBlockBufferRef *)&v203 + 1);
              if (BBuf) {
                goto LABEL_760;
              }
              int v37 = 0;
              dispatch_queue_t v26 = v52;
              char v28 = v165;
              goto LABEL_82;
            }
            goto LABEL_81;
          }
          int v43 = (OpaqueCMBlockBuffer *)*((void *)&v201 + 1);
          if (*((void *)&v201 + 1)) {
            goto LABEL_108;
          }
          uint64_t v44 = FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)v209, 0, 0, (CMBlockBufferRef *)&v201 + 1);
          if (v44)
          {
            uint64_t Empty = v44;
            if (v44 != -12891) {
              goto LABEL_217;
            }
          }
          int v43 = (OpaqueCMBlockBuffer *)*((void *)&v201 + 1);
          if (*((void *)&v201 + 1))
          {
LABEL_108:
            unsigned int v45 = v26;
            long long v222 = 0u;
            long long v223 = 0u;
            long long v220 = 0u;
            long long v221 = 0u;
            long long v219 = 0u;
            memset(destination, 0, sizeof(destination));
            int v46 = figSoundBridge_AllowZeroSizeTerminatorAtom_value;
            if (figSoundBridge_AllowZeroSizeTerminatorAtom_value == -1)
            {
              int v46 = FigGetCFPreferenceNumberWithDefault(@"zero_size_terminator_atom", @"com.apple.coremedia", 1);
              figSoundBridge_AllowZeroSizeTerminatorAtom_value = v46;
              int v43 = (OpaqueCMBlockBuffer *)*((void *)&v201 + 1);
            }
            if (FigAtomStreamInitWithBBuf(v43, 0, v46 != 0, (uint64_t)destination))
            {
LABEL_160:
              int v37 = 1;
              dispatch_queue_t v26 = v45;
              goto LABEL_82;
            }
            while (1)
            {
              LODWORD(blockBufferOut) = 0;
              dataPointerOut[0] = 0;
              unsigned __int16 v211 = 0;
              if (FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)destination, &blockBufferOut, dataPointerOut))goto LABEL_160; {
              if ((int)blockBufferOut <= 1684425824)
              }
              {
                if ((int)blockBufferOut > 1684103986)
                {
                  if (blockBufferOut == 1684103987)
                  {
                    if (!*((void *)&v197 + 1))
                    {
                      int v50 = (CMBlockBufferRef *)&v197 + 1;
                      goto LABEL_151;
                    }
                  }
                  else if (blockBufferOut == 1684366131 && !(void)v198)
                  {
                    int v50 = (CMBlockBufferRef *)&v198;
                    goto LABEL_151;
                  }
                }
                else
                {
                  switch(blockBufferOut)
                  {
                    case 0x6164726D:
                      if (!(void)v200)
                      {
                        int v50 = (CMBlockBufferRef *)&v200;
LABEL_151:
                        if (FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)destination, v50)) {
                          goto LABEL_160;
                        }
                      }
                      break;
                    case 0x616C6163:
                      if (!*((void *)&v198 + 1))
                      {
                        int v50 = (CMBlockBufferRef *)&v198 + 1;
                        goto LABEL_151;
                      }
                      break;
                    case 0:
                      goto LABEL_160;
                    default:
                      break;
                  }
                }
              }
              else
              {
                if ((int)blockBufferOut > 1702061170)
                {
                  if (blockBufferOut == 1702061171)
                  {
                    if (ReadESDSAtomAndData((uint64_t)destination, (CMBlockBufferRef *)&v196 + 1, (CMBlockBufferRef *)&v197))goto LABEL_160; {
                    goto LABEL_159;
                    }
                  }
                  if (blockBufferOut == 1935764850)
                  {
                    if (!*((void *)&v199 + 1)
                      && FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)destination, 0, 0, (CMBlockBufferRef *)&v199 + 1))
                    {
                      goto LABEL_160;
                    }
                    goto LABEL_159;
                  }
                  if (blockBufferOut != 1718775137) {
                    goto LABEL_159;
                  }
                  v212[0] = 0;
                  if (FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)destination, 0, 0, (CMBlockBufferRef *)v212))goto LABEL_160; {
                  if (!v212[0])
                  }
                    goto LABEL_159;
                  size_t v47 = CMBlockBufferGetDataLength((CMBlockBufferRef)v212[0]);
                  LODWORD(v215) = 0;
                  int v48 = "'wave' atom has 'frma' atom that is too short to contain a format type";
                  if (v47 < 4) {
                    goto LABEL_153;
                  }
                  int v49 = 0;
                  if (HIDWORD(v192[0]) != 1633777252
                    && HIDWORD(v192[0]) != 1685220723
                    && HIDWORD(v192[0]) != 1701733217)
                  {
                    CMBlockBufferCopyDataBytes((CMBlockBufferRef)v212[0], 0, 4uLL, &v215);
                    LODWORD(v215) = bswap32(v215);
                    int v48 = "'wave' atom has wrong 'frma' format type";
                    if (v215 == HIDWORD(v192[0]))
                    {
                      int v49 = 0;
                      goto LABEL_154;
                    }
LABEL_153:
                    figSoundBridge_ReportParsingFailureMessage(v208, (uint64_t)v48);
                    int v49 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
                  }
LABEL_154:
                  if (v212[0]) {
                    CFRelease(v212[0]);
                  }
                  if (v49) {
                    goto LABEL_160;
                  }
                  goto LABEL_159;
                }
                if (blockBufferOut == 1684425825)
                {
                  if (!(void)v199)
                  {
                    int v50 = (CMBlockBufferRef *)&v199;
                    goto LABEL_151;
                  }
                }
                else if (blockBufferOut == 1701733473)
                {
                  if (!*((void *)&v202 + 1)
                    && FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)destination, (CMBlockBufferRef *)&v202 + 1)|| FigAtomStreamReadCurrentAtomData((uint64_t)destination, 0, 2, (uint64_t)&v211))
                  {
                    goto LABEL_160;
                  }
                  unsigned __int16 v211 = bswap32(v211) >> 16;
                  LOBYTE(v205) = (_BYTE)v211 != 0;
                }
              }
LABEL_159:
              if (FigAtomStreamAdvanceToNextAtom(destination)) {
                goto LABEL_160;
              }
            }
          }
LABEL_81:
          int v37 = 1;
LABEL_82:
          int v30 = lengthAtOffsetOut;
          goto LABEL_83;
        }
        if (*((void *)&v200 + 1)) {
          goto LABEL_81;
        }
        uint64_t v39 = (CMBlockBufferRef *)&v200 + 1;
LABEL_80:
        uint64_t ESDSAtomAndData = FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)v209, v39);
        if (ESDSAtomAndData) {
          goto LABEL_717;
        }
        goto LABEL_81;
      }
      if ((int)lengthAtOffsetOut > 1684366130)
      {
        if ((int)lengthAtOffsetOut <= 1702061170)
        {
          if (lengthAtOffsetOut == 1684366131)
          {
            if ((void)v198) {
              goto LABEL_81;
            }
            uint64_t v39 = (CMBlockBufferRef *)&v198;
            goto LABEL_80;
          }
          if (lengthAtOffsetOut == 1684425825)
          {
            if ((void)v199) {
              goto LABEL_81;
            }
            uint64_t v39 = (CMBlockBufferRef *)&v199;
            goto LABEL_80;
          }
        }
        else
        {
          switch(lengthAtOffsetOut)
          {
            case 0x65736473:
              uint64_t ESDSAtomAndData = ReadESDSAtomAndData((uint64_t)v209, (CMBlockBufferRef *)&v196 + 1, (CMBlockBufferRef *)&v197);
              if (ESDSAtomAndData) {
                goto LABEL_717;
              }
              goto LABEL_81;
            case 0x73726174:
              if (HIDWORD(v192[1]) == 2)
              {
                LODWORD(destination[0]) = 0;
                if (!(void)v203)
                {
                  uint64_t ESDSAtomAndData = FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)v209, (CMBlockBufferRef *)&v203);
                  if (ESDSAtomAndData) {
                    goto LABEL_717;
                  }
                }
                if (FigAtomStreamReadCurrentAtomData((uint64_t)v209, 4, 4, (uint64_t)destination))
                {
                  if ((void)v203)
                  {
                    CFRelease((CFTypeRef)v203);
                    *(void *)&long long v203 = 0;
                  }
                }
                else
                {
                  *((double *)&v205 + 1) = (double)bswap32(destination[0]);
                }
              }
              goto LABEL_81;
            case 0x70636D43:
              if ((void)v196) {
                goto LABEL_81;
              }
              uint64_t v39 = (CMBlockBufferRef *)&v196;
              goto LABEL_80;
          }
        }
      }
      else if ((int)lengthAtOffsetOut <= 1667788395)
      {
        if (lengthAtOffsetOut == 1633972845)
        {
          if ((void)v200) {
            goto LABEL_81;
          }
          uint64_t v39 = (CMBlockBufferRef *)&v200;
          goto LABEL_80;
        }
        if (lengthAtOffsetOut == 1634492771)
        {
          if (*((void *)&v198 + 1)) {
            goto LABEL_81;
          }
          uint64_t v39 = (CMBlockBufferRef *)&v198 + 1;
          goto LABEL_80;
        }
      }
      else
      {
        switch(lengthAtOffsetOut)
        {
          case 0x63686E6C:
            if ((void)v201) {
              goto LABEL_81;
            }
            uint64_t v39 = (CMBlockBufferRef *)&v201;
            goto LABEL_80;
          case 0x64616333:
            if (*((void *)&v197 + 1)) {
              goto LABEL_81;
            }
            uint64_t v39 = (CMBlockBufferRef *)&v197 + 1;
            goto LABEL_80;
          case 0x64616D72:
            if (!*((void *)&v199 + 1))
            {
              uint64_t ESDSAtomAndData = FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)v209, 0, 0, (CMBlockBufferRef *)&v199 + 1);
              if (ESDSAtomAndData) {
                goto LABEL_717;
              }
            }
            goto LABEL_81;
        }
      }
      if (figSoundBridge_GetDecodeFormatIDForUnknownExtensionType(lengthAtOffsetOut, (uint64_t)v192, &v210))
      {
        int v52 = v26;
        int v55 = v210;
        LODWORD(v204) = v210;
        if (!*((void *)&v203 + 1)
          && (uint64_t BBuf = FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)v209, (CMBlockBufferRef *)&v203 + 1),
              BBuf)
          || (uint64_t BBuf = figSoundBridge_TransformToCanonicalMagicCookieBBuf(v170, v55, (uint64_t)v192, (CMBlockBufferRef *)&v203 + 1), BBuf))
        {
LABEL_760:
          uint64_t Empty = BBuf;
          CFTypeRef cf = 0;
          dispatch_queue_t v26 = v52;
          goto LABEL_218;
        }
        int v37 = 0;
        dispatch_queue_t v26 = v52;
        goto LABEL_82;
      }
      goto LABEL_81;
    }
LABEL_55:
    unsigned int v165 = (HIDWORD(v192[1]) > 3) | (9u >> (BYTE4(v192[1]) & 0xF));
    BOOL v174 = HIDWORD(v192[1]) != 3;
    goto LABEL_56;
  }
  if (v192[0]) {
    goto LABEL_55;
  }
  uint64_t Empty = 0;
  unsigned int v25 = 0;
  dispatch_queue_t v26 = 0;
  CFTypeRef cf = 0;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
LABEL_218:
  size_t v56 = (int)v25;
  v164 = (char *)(v26 + 2);
  v166 = (char *)(v26 + 3);
  uint64_t v57 = v25;
  v173 = v26;
  while (!Empty || Empty == -12890)
  {
    if (!v26)
    {
      uint64_t Empty = 0;
      *((void *)&v204 + 1) = 0;
      a1 = v170;
      a5 = v167;
      goto LABEL_273;
    }
    int v58 = (CFTypeRef *)malloc_type_calloc(v56, 8uLL, 0x6004044C4A2DFuLL);
    v177 = (const void **)malloc_type_calloc(v56, 8uLL, 0x6004044C4A2DFuLL);
    uint64_t v59 = (const void **)malloc_type_calloc(v56, 8uLL, 0x6004044C4A2DFuLL);
    __int16 v60 = v59;
    v175 = v58;
    if (v58 && v177 && v59)
    {
      CFIndex v61 = 0;
      if (v56)
      {
        size_t v62 = 0;
        size_t v63 = v56;
        int v65 = v164;
        __int16 v64 = (int *)v166;
        while (LODWORD(v26[3 * v62 + 2]))
        {
LABEL_243:
          ++v62;
          v64 += 6;
          v65 += 6;
          --v63;
          if (v62 == v56) {
            goto LABEL_244;
          }
        }
        int v66 = (int)v26[3 * v62];
        LOBYTE(destination[0]) = 4;
        BYTE1(destination[0]) = HIBYTE(v66);
        BYTE2(destination[0]) = BYTE2(v66);
        BYTE3(destination[0]) = BYTE1(v66);
        BYTE4(destination[0]) = v66;
        CFStringRef v67 = CFStringCreateWithPascalString(allocator, (ConstStr255Param)destination, 0);
        v175[v61] = v67;
        if (!v67)
        {
          uint64_t v68 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          if (v68)
          {
            uint64_t Empty = v68;
            CFDictionaryRef v77 = 0;
LABEL_248:
            if ((int)v57 >= 1)
            {
              __int16 v78 = v175;
              uint64_t v79 = v57;
              do
              {
                if (*v78) {
                  CFRelease(*v78);
                }
                ++v78;
                --v79;
              }
              while (v79);
            }
            free(v175);
            dispatch_queue_t v26 = v173;
            goto LABEL_254;
          }
        }
        int v69 = v64;
        size_t v70 = v62;
        do
        {
          if (++v70 >= v56)
          {
            dispatch_queue_t v26 = v173;
            v177[v61] = CFRetain(v173[3 * v62 + 1]);
LABEL_242:
            ++v61;
            goto LABEL_243;
          }
          int v71 = *v69;
          v69 += 6;
        }
        while (v66 != v71);
        if (v62 >= v56)
        {
          CFIndex v72 = 0;
        }
        else
        {
          CFIndex v72 = 0;
          size_t v73 = v63;
          __int16 v74 = v65;
          do
          {
            if (v66 == *(v74 - 4))
            {
              v60[v72++] = (const void *)*((void *)v74 - 1);
              *__int16 v74 = 1;
            }
            v74 += 6;
            --v73;
          }
          while (v73);
        }
        CFArrayRef v75 = CFArrayCreate(allocator, v60, v72, MEMORY[0x1E4F1D510]);
        v177[v61] = v75;
        dispatch_queue_t v26 = v173;
        if (v75) {
          goto LABEL_242;
        }
      }
      else
      {
LABEL_244:
        CFDictionaryRef v76 = CFDictionaryCreate(allocator, v175, v177, v61, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (v76)
        {
          CFDictionaryRef v77 = v76;
          uint64_t Empty = 0;
          goto LABEL_247;
        }
      }
    }
    uint64_t Empty = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    CFDictionaryRef v77 = 0;
LABEL_247:
    if (v175) {
      goto LABEL_248;
    }
LABEL_254:
    if (v177)
    {
      if ((int)v56 >= 1)
      {
        __int16 v80 = v177;
        uint64_t v81 = v57;
        do
        {
          if (*v80) {
            CFRelease(*v80);
          }
          ++v80;
          --v81;
        }
        while (v81);
      }
      free(v177);
      dispatch_queue_t v26 = v173;
    }
    if (v60) {
      free(v60);
    }
    *((void *)&v204 + 1) = v77;
    if (!Empty) {
      break;
    }
  }
  a1 = v170;
  a5 = v167;
  if (v26)
  {
    if ((int)v57 >= 1)
    {
      __int16 v82 = v26 + 1;
      do
      {
        if (*v82) {
          CFRelease(*v82);
        }
        v82 += 3;
        --v57;
      }
      while (v57);
    }
    free(v26);
  }
LABEL_273:
  theSourceBuffer = theBuffer;
  if (cf) {
    CFRelease(cf);
  }
  if (Empty) {
    goto LABEL_504;
  }
LABEL_276:
  dataPointerOut[0] = 0;
  int v83 = HIDWORD(v192[0]);
  if (SHIDWORD(v192[0]) <= 1718367025)
  {
    if (HIDWORD(v192[0]) != 1633777252 && HIDWORD(v192[0]) != 1685220723 && HIDWORD(v192[0]) != 1701733217) {
      goto LABEL_328;
    }
    *(void *)&destination[0] = 0;
    uint64_t Empty = CMBlockBufferCreateEmpty(a1, 4u, 0, (CMBlockBufferRef *)destination);
    if (Empty)
    {
LABEL_302:
      if (*(void *)&destination[0]) {
        CFRelease(*(CFTypeRef *)&destination[0]);
      }
      goto LABEL_304;
    }
    if (*((void *)&v196 + 1)) {
      CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], *((CMBlockBufferRef *)&v196 + 1), 0, 0, 0);
    }
    if (HIDWORD(v192[0]) == 1633777252)
    {
      uint64_t v85 = (OpaqueCMBlockBuffer *)v200;
      if (!(void)v200) {
        goto LABEL_299;
      }
    }
    else
    {
      if (HIDWORD(v192[0]) != 1701733217 && HIDWORD(v192[0]) != 1685220723) {
        goto LABEL_299;
      }
      if (*((void *)&v197 + 1)) {
        CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], *((CMBlockBufferRef *)&v197 + 1), 0, 0, 0);
      }
      if ((void)v198) {
        CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], (CMBlockBufferRef)v198, 0, 0, 0);
      }
      if ((void)v199) {
        CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], (CMBlockBufferRef)v199, 0, 0, 0);
      }
      if (*((void *)&v198 + 1)) {
        CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], *((CMBlockBufferRef *)&v198 + 1), 0, 0, 0);
      }
      uint64_t v85 = (OpaqueCMBlockBuffer *)*((void *)&v203 + 1);
      if (!*((void *)&v203 + 1)) {
        goto LABEL_299;
      }
    }
    CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], v85, 0, 0, 0);
LABEL_299:
    v86 = *(char **)&destination[0];
    if (*(void *)&destination[0]) {
      v86 = (char *)CFRetain(*(CFTypeRef *)&destination[0]);
    }
    dataPointerOut[0] = v86;
    goto LABEL_302;
  }
  if (SHIDWORD(v192[0]) <= 1768829491)
  {
    if (HIDWORD(v192[0]) != 1718367026)
    {
      int v84 = 1718367796;
      goto LABEL_312;
    }
    goto LABEL_313;
  }
  if (HIDWORD(v192[0]) != 1768829492)
  {
    int v84 = 1768829746;
LABEL_312:
    if (HIDWORD(v192[0]) != v84)
    {
LABEL_328:
      if ((v192[0] & 1) == 0)
      {
        if (HIDWORD(v192[0]) == 1832149349
          || HIDWORD(v192[0]) == 1836069985
          || figSoundBridge_isAACUsingESDSinMOV(HIDWORD(v192[0])))
        {
LABEL_332:
          v95 = (const void *)v197;
          if ((void)v197)
          {
LABEL_333:
            v87 = (char *)CFRetain(v95);
LABEL_665:
            uint64_t Empty = 0;
            dataPointerOut[0] = v87;
            goto LABEL_305;
          }
LABEL_664:
          v87 = 0;
          goto LABEL_665;
        }
        v105 = (const void *)*((void *)&v203 + 1);
        if (!*((void *)&v203 + 1))
        {
          v105 = (const void *)*((void *)&v201 + 1);
          if (!*((void *)&v201 + 1)) {
            goto LABEL_434;
          }
        }
LABEL_669:
        v87 = (char *)CFRetain(v105);
        uint64_t Empty = 0;
        dataPointerOut[0] = v87;
        goto LABEL_305;
      }
      if (SHIDWORD(v192[0]) > 1718641516)
      {
        if (SHIDWORD(v192[0]) > 1935764849)
        {
          if (HIDWORD(v192[0]) == 1935764850 || HIDWORD(v192[0]) == 1935767394)
          {
            if (!*((void *)&v199 + 1))
            {
              uint64_t v106 = v208;
              v107 = "Required 'damr' extension missing";
              goto LABEL_754;
            }
            MagicCookieBBufFromAMRuint64_t BBuf = figSoundBridge_CreateMagicCookieBBufFromAMRBBuf(a1, HIDWORD(v192[0]), *((OpaqueCMBlockBuffer **)&v199 + 1), dataPointerOut);
            goto LABEL_474;
          }
        }
        else if (HIDWORD(v192[0]) == 1718641517 || HIDWORD(v192[0]) == 1768973165)
        {
          if (!(void)v196)
          {
            uint64_t v106 = v208;
            v107 = "Required 'pcmC' extension missing";
            goto LABEL_754;
          }
LABEL_434:
          uint64_t Empty = 0;
LABEL_304:
          v87 = (char *)dataPointerOut[0];
LABEL_305:
          if (!v87) {
            goto LABEL_341;
          }
          size_t v88 = CMBlockBufferGetDataLength((CMBlockBufferRef)v87);
          if (!HIDWORD(v88))
          {
            int v89 = v88;
            if (CMBlockBufferIsRangeContiguous((CMBlockBufferRef)v87, 0, v88))
            {
              v90 = (OpaqueCMBlockBuffer *)CFRetain(v87);
              *((void *)&v206 + 1) = v90;
              if (!v90)
              {
LABEL_341:
                if (dataPointerOut[0]) {
                  CFRelease(dataPointerOut[0]);
                }
                if (!Empty)
                {
                  int v83 = HIDWORD(v192[0]);
                  goto LABEL_313;
                }
                goto LABEL_504;
              }
            }
            else
            {
              CMBlockBufferCreateContiguous(a1, (CMBlockBufferRef)v87, a1, 0, 0, 0, 0, (CMBlockBufferRef *)&v206 + 1);
              v90 = (OpaqueCMBlockBuffer *)*((void *)&v206 + 1);
              if (!*((void *)&v206 + 1)) {
                goto LABEL_341;
              }
            }
            CMBlockBufferGetDataPointer(v90, 0, 0, 0, (char **)&v207);
            DWORD2(v207) = v89;
            goto LABEL_341;
          }
          uint64_t v106 = v208;
          v107 = "Magic cookie size is greater than UINT32_MAX";
LABEL_754:
          figSoundBridge_ReportParsingFailureMessage(v106, (uint64_t)v107);
          uint64_t Empty = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
          goto LABEL_341;
        }
      }
      else if (SHIDWORD(v192[0]) > 1700998450)
      {
        if (HIDWORD(v192[0]) == 1700998451)
        {
          v105 = (const void *)v198;
          if (!(void)v198)
          {
            uint64_t v106 = v208;
            v107 = "Required 'dec3' extension missing";
            goto LABEL_754;
          }
          goto LABEL_669;
        }
        if (HIDWORD(v192[0]) == 1716281667)
        {
          v105 = (const void *)v199;
          if (!(void)v199)
          {
            uint64_t v106 = v208;
            v107 = "Required 'dfLa' extension missing";
            goto LABEL_754;
          }
          goto LABEL_669;
        }
      }
      else
      {
        if (HIDWORD(v192[0]) == 1633889587)
        {
          v95 = (const void *)*((void *)&v197 + 1);
          if (*((void *)&v197 + 1)) {
            goto LABEL_333;
          }
          goto LABEL_664;
        }
        if (HIDWORD(v192[0]) == 1634492771)
        {
          if (!*((void *)&v198 + 1))
          {
            uint64_t v106 = v208;
            v107 = "Required 'alac' extension missing";
            goto LABEL_754;
          }
          MagicCookieBBufFromAMRuint64_t BBuf = figSoundBridge_CreateMagicCookieBBufFromALACBBuf(a1, *((OpaqueCMBlockBuffer **)&v198 + 1), dataPointerOut);
LABEL_474:
          uint64_t Empty = MagicCookieBBufFromAMRBBuf;
          goto LABEL_304;
        }
      }
      v105 = (const void *)*((void *)&v203 + 1);
      if (!*((void *)&v203 + 1)) {
        goto LABEL_332;
      }
      goto LABEL_669;
    }
  }
LABEL_313:
  uint64_t v213 = 0;
  memset(v212, 0, sizeof(v212));
  if (SLOWORD(v192[1]) > 1)
  {
    if (LOWORD(v192[1]) == 2)
    {
      v212[0] = (char *)bswap64(v194);
      unsigned int v92 = bswap32(DWORD2(v194));
      LODWORD(v212[1]) = v83;
      HIDWORD(v212[3]) = v92;
      LODWORD(v213) = bswap32(v195);
      unsigned int v93 = bswap32(DWORD1(v195));
      if (v83 == 1819304813)
      {
        if ((v93 & 8) != 0) {
          v93 &= ~0x10u;
        }
        if (v93) {
          v93 &= 0xFFFFFFBB;
        }
        v93 &= ~0x40u;
      }
      HIDWORD(v212[1]) = v93;
      v94 = (char *)vrev32_s8(*(int8x8_t *)((char *)&v195 + 8));
      v212[2] = v94;
      if (v83 != 1819304813) {
        goto LABEL_391;
      }
      uint64_t Empty = 0;
      LODWORD(v212[3]) = v94;
      goto LABEL_503;
    }
    uint64_t v96 = v208;
    v97 = "This sound description cannot be parsed";
    goto LABEL_461;
  }
  if (v83 > 1768829745)
  {
    if (v83 <= 1918990111)
    {
      if (v83 == 1768829746) {
        goto LABEL_358;
      }
      int v91 = 1819304813;
    }
    else
    {
      if (v83 == 1918990112 || v83 == 1953984371) {
        goto LABEL_358;
      }
      int v91 = 1936684916;
    }
LABEL_357:
    if (v83 == v91) {
      goto LABEL_358;
    }
    *(double *)v212 = (double)bswap32(DWORD2(v193)) * 0.0000152587891;
    unsigned int v92 = (int)bswap32((unsigned __int16)v193) >> 16;
    LODWORD(v212[1]) = v83;
    HIDWORD(v212[3]) = v92;
    if (HIDWORD(v192[1]) == 3)
    {
      unsigned int v93 = HIDWORD(v193);
      if (!HIDWORD(v193)) {
        goto LABEL_389;
      }
      HIDWORD(v212[2]) = bswap32(HIDWORD(v193));
      if (SWORD2(v193) != -257)
      {
        unsigned int v93 = 0;
        LODWORD(v212[2]) = bswap32(DWORD1(v194));
        goto LABEL_389;
      }
    }
    unsigned int v93 = 0;
    goto LABEL_389;
  }
  if (v83 <= 1718367025)
  {
    if (!v83) {
      goto LABEL_358;
    }
    int v91 = 1313820229;
    goto LABEL_357;
  }
  if (v83 != 1718367026 && v83 != 1718367796)
  {
    int v91 = 1768829492;
    goto LABEL_357;
  }
LABEL_358:
  v212[1] = (char *)0x86C70636DLL;
  if (v83 <= 1718367025)
  {
    if (v83)
    {
      int v99 = 1313820229;
LABEL_364:
      if (v83 != v99) {
        goto LABEL_367;
      }
    }
    if (WORD1(v193) != 2048)
    {
LABEL_367:
      unsigned int v93 = 12;
      goto LABEL_368;
    }
    unsigned int v93 = 8;
  }
  else
  {
    unsigned int v93 = 9;
    if (v83 != 1718367026 && v83 != 1718367796)
    {
      int v99 = 1918990112;
      goto LABEL_364;
    }
LABEL_368:
    HIDWORD(v212[1]) = v93;
  }
  if (v83 <= 1768829491)
  {
    if (v83 != 1718367026 && v83 != 1718367796) {
      goto LABEL_378;
    }
    goto LABEL_376;
  }
  if (v83 == 1768829492 || v83 == 1768829746)
  {
LABEL_376:
    if (!*((void *)&v202 + 1) || !(_BYTE)v205) {
      goto LABEL_378;
    }
    goto LABEL_379;
  }
  if (v83 == 1936684916)
  {
    unsigned int v100 = (int)bswap32(WORD1(v193)) >> 16;
    goto LABEL_387;
  }
LABEL_378:
  v93 |= 2u;
  HIDWORD(v212[1]) = v93;
LABEL_379:
  unsigned int v100 = (int)bswap32(WORD1(v193)) >> 16;
  LODWORD(v213) = v100;
  if (v83 > 1768829491)
  {
    if (v83 == 1768829492)
    {
      unsigned int v100 = 24;
      goto LABEL_387;
    }
    if (v83 != 1768829746) {
      goto LABEL_388;
    }
LABEL_385:
    unsigned int v100 = 32;
LABEL_387:
    LODWORD(v213) = v100;
    goto LABEL_388;
  }
  if (v83 == 1718367026) {
    goto LABEL_385;
  }
  if (v83 == 1718367796)
  {
    unsigned int v100 = 64;
    goto LABEL_387;
  }
LABEL_388:
  *(double *)v212 = (double)bswap32(DWORD2(v193)) * 0.0000152587891;
  unsigned int v92 = (int)bswap32((unsigned __int16)v193) >> 16;
  LODWORD(v212[2]) = (v100 >> 3) * v92;
  HIDWORD(v212[2]) = 1;
  v212[3] = (char *)__PAIR64__(v92, v212[2]);
  int v83 = 1819304813;
LABEL_389:
  if ((void)v203) {
    v212[0] = *((char **)&v205 + 1);
  }
LABEL_391:
  size_t size = 0;
  if (v83 > 1718378850)
  {
    if (v83 <= 1836069984)
    {
      if (v83 <= 1768829745)
      {
        if (v83 == 1718378851) {
          goto LABEL_464;
        }
        if (v83 != 1718641517)
        {
          int v101 = 1768829492;
          goto LABEL_459;
        }
        HIDWORD(v212[1]) = v93 | 1;
        goto LABEL_496;
      }
      if (v83 <= 1819304812)
      {
        if (v83 == 1768829746) {
          goto LABEL_460;
        }
        if (v83 != 1768973165) {
          goto LABEL_485;
        }
LABEL_496:
        LODWORD(v212[1]) = 1819304813;
        if (!(void)v196) {
          goto LABEL_502;
        }
        *(void *)&destination[0] = 0;
        dataPointerOut[0] = 0;
        LODWORD(blockBufferOut) = 40;
        uint64_t DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)v196, 0, (size_t *)destination, 0, (char **)dataPointerOut);
        if (DataPointer) {
          goto LABEL_463;
        }
        uint64_t Property = AudioToolbox_AudioFormatGetProperty(1885565796, LODWORD(destination[0]), (uint64_t)dataPointerOut[0], (uint64_t)&blockBufferOut, (uint64_t)v212);
        if (!Property) {
          goto LABEL_502;
        }
LABEL_462:
        uint64_t DataPointer = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
        goto LABEL_463;
      }
      if (v83 == 1819304813) {
        goto LABEL_502;
      }
      if (v83 != 1832149349) {
        goto LABEL_485;
      }
LABEL_453:
      if ((void)v197)
      {
        uint64_t DataPointer = figSoundBridge_GetMP4ASBDFromESDSDataBBuf((uint64_t)v192, (uint64_t)v212);
        goto LABEL_463;
      }
      uint64_t Empty = 0;
      LODWORD(v212[1]) = 1633772320;
      goto LABEL_658;
    }
    if (v83 <= 1935767393)
    {
      if (v83 == 1836069985) {
        goto LABEL_453;
      }
      if (v83 == 1918990112) {
        goto LABEL_460;
      }
      if (v83 != 1935764850) {
        goto LABEL_485;
      }
    }
    else
    {
      if (v83 > 1953984370)
      {
        if (v83 == 1986295393)
        {
          if (LOWORD(v192[1]) == 1 && (v192[0] & 1) == 0)
          {
            uint64_t Empty = 0;
            v212[2] = (char *)bswap32(DWORD1(v194));
            goto LABEL_503;
          }
          goto LABEL_502;
        }
        int v101 = 1953984371;
LABEL_459:
        if (v83 != v101) {
          goto LABEL_485;
        }
        goto LABEL_460;
      }
      if (v83 != 1935767394)
      {
        int v101 = 1936684916;
        goto LABEL_459;
      }
    }
    if (!*((void *)&v199 + 1))
    {
      uint64_t v96 = v208;
      v97 = "Expected to get a magic cookie for AMR";
      goto LABEL_461;
    }
    LODWORD(destination[0]) = 40;
    HIDWORD(v212[3]) = 1;
    v212[0] = *((char **)&unk_18FE95E40 + (v83 == 1935764850));
    uint64_t DataPointer = AudioToolbox_AudioFormatGetProperty(1718449257, DWORD2(v207), v207, (uint64_t)destination, (uint64_t)v212);
    goto LABEL_463;
  }
  if (v83 > 1634492770)
  {
    if (v83 > 1701733216)
    {
      if (v83 <= 1718367025)
      {
        if (v83 == 1701733217)
        {
LABEL_443:
          if ((void)v197)
          {
            uint64_t DataPointer = figSoundBridge_GetMP4ASBDFromESDSDataBBuf((uint64_t)v192, (uint64_t)v212);
            if (DataPointer) {
              goto LABEL_463;
            }
            if (v83 == 1633777252)
            {
              uint64_t Empty = 0;
              int v155 = 1633771875;
              goto LABEL_747;
            }
            if (v83 != 1701733217)
            {
              if (SLODWORD(v212[1]) <= 1633772399)
              {
                if (LODWORD(v212[1]) == 1633772320)
                {
                  uint64_t Empty = 0;
                  int v155 = 1885430115;
                  goto LABEL_747;
                }
                if (LODWORD(v212[1]) == 1633772392)
                {
                  uint64_t Empty = 0;
                  int v103 = 1885430115;
LABEL_688:
                  int v155 = v103 + 517;
LABEL_747:
                  LODWORD(v212[1]) = v155;
                  goto LABEL_503;
                }
                goto LABEL_728;
              }
              if (LODWORD(v212[1]) != 1633772400)
              {
                if (LODWORD(v212[1]) == 1970495843)
                {
                  uint64_t Empty = 0;
                  int v155 = 1886745441;
                  goto LABEL_747;
                }
LABEL_728:
                uint64_t v96 = v208;
                v97 = "Unrecognized audio codec type for 'drms'";
                goto LABEL_461;
              }
              uint64_t Empty = 0;
              int v160 = 1885430115;
LABEL_727:
              int v155 = v160 + 525;
              goto LABEL_747;
            }
            if (SLODWORD(v212[1]) > 1633772399)
            {
              if (LODWORD(v212[1]) == 1633772400)
              {
                uint64_t Empty = 0;
                int v160 = 1902207331;
                goto LABEL_727;
              }
              if (LODWORD(v212[1]) == 1970495843)
              {
                uint64_t Empty = 0;
                int v155 = 1903522657;
                goto LABEL_747;
              }
            }
            else
            {
              if (LODWORD(v212[1]) == 1633772320)
              {
                uint64_t Empty = 0;
                int v155 = 1902207331;
                goto LABEL_747;
              }
              if (LODWORD(v212[1]) == 1633772392)
              {
                uint64_t Empty = 0;
                int v103 = 1902207331;
                goto LABEL_688;
              }
            }
            uint64_t v96 = v208;
            v97 = "Unrecognized audio codec type for 'enca'";
LABEL_461:
            figSoundBridge_ReportParsingFailureMessage(v96, (uint64_t)v97);
            uint64_t Property = 4294954582;
            goto LABEL_462;
          }
          if (*((void *)&v197 + 1))
          {
            uint64_t DataPointer = figSoundBridge_GetASBDFromDAC3BBuf(*((OpaqueCMBlockBuffer **)&v197 + 1), (uint64_t)v212);
            if (DataPointer) {
              goto LABEL_463;
            }
            if (v83 != 1633777252)
            {
              uint64_t Empty = 0;
              if (v83 == 1701733217) {
                int v108 = 1902207331;
              }
              else {
                int v108 = 1885430115;
              }
              int v155 = v108 + 464;
              goto LABEL_747;
            }
            uint64_t v96 = v208;
            v97 = "Unrecognized audio codec type AC3 for 'aavd'";
            goto LABEL_461;
          }
          if ((void)v198)
          {
            uint64_t DataPointer = figSoundBridge_GetASBDFromDEC3BBuf((OpaqueCMBlockBuffer *)v198, (uint64_t)v212);
            if (DataPointer) {
              goto LABEL_463;
            }
            if (v83 != 1633777252)
            {
              uint64_t Empty = 0;
              if (v83 == 1701733217) {
                int v155 = 1902469939;
              }
              else {
                int v155 = 1885692723;
              }
              goto LABEL_747;
            }
            uint64_t v96 = v208;
            v97 = "Unrecognized audio codec type EnhancedAC3 for 'aavd'";
            goto LABEL_461;
          }
          if ((void)v199)
          {
            uint64_t DataPointer = figSoundBridge_GetASBDFromAudioFormatWithCodecSpecificAtomBBuf(1718378851, (CMBlockBufferRef)v199, (uint64_t)v212);
            if (DataPointer) {
              goto LABEL_463;
            }
            if (v83 == 1701733217)
            {
              uint64_t Empty = 0;
              int v155 = 1902537827;
              goto LABEL_747;
            }
            uint64_t v96 = v208;
            v97 = "Unrecognized audio protection type for FLAC";
            goto LABEL_461;
          }
          if (*((void *)&v198 + 1))
          {
            uint64_t DataPointer = figSoundBridge_GetASBDFromALACBBuf(*((OpaqueCMBlockBuffer **)&v198 + 1), (uint64_t)v212);
            if (DataPointer) {
              goto LABEL_463;
            }
            if (v83 == 1701733217)
            {
              uint64_t Empty = 0;
              int v155 = 1902928227;
              goto LABEL_747;
            }
            uint64_t v96 = v208;
            v97 = "Unrecognized audio protection type for Apple Lossless";
            goto LABEL_461;
          }
          if (*((void *)&v203 + 1))
          {
            uint64_t DataPointer = figSoundBridge_GetASBDFromAudioFormatWithCodecSpecificAtomBBuf(v204, *((CMBlockBufferRef *)&v203 + 1), (uint64_t)v212);
            if (DataPointer) {
              goto LABEL_463;
            }
            if (v83 == 1701733217
              && (LODWORD(v212[1]) == 1634754915 || LODWORD(v212[1]) == 1902211171 || LODWORD(v212[1]) == 1667330147))
            {
              uint64_t Empty = 0;
              int v155 = 1902211171;
              goto LABEL_747;
            }
            uint64_t v96 = v208;
            v97 = "Unrecognized audio protection type";
            goto LABEL_461;
          }
          if (v83 == 1633777252)
          {
            uint64_t Empty = 0;
            int v163 = 1633771875;
          }
          else
          {
            if (v83 != 1685220723)
            {
              uint64_t Empty = 0;
              goto LABEL_503;
            }
            uint64_t Empty = 0;
            int v163 = 1885430115;
          }
          LODWORD(v212[1]) = v163;
LABEL_658:
          v212[2] = (char *)0x40000000000;
          goto LABEL_503;
        }
        if (v83 != 1716281667) {
          goto LABEL_485;
        }
        LODWORD(v212[1]) = 1718378851;
LABEL_464:
        if ((void)v199)
        {
          uint64_t DataPointer = figSoundBridge_GetASBDFromAudioFormatWithCodecSpecificAtomBBuf(1718378851, (CMBlockBufferRef)v199, (uint64_t)v212);
          goto LABEL_463;
        }
        goto LABEL_502;
      }
      if (v83 != 1718367026)
      {
        int v101 = 1718367796;
        goto LABEL_459;
      }
LABEL_460:
      uint64_t v96 = v208;
      v97 = "Detected an old, unsupported PCM OSType";
      goto LABEL_461;
    }
    if (v83 == 1634492771)
    {
      if (*((void *)&v198 + 1))
      {
        uint64_t DataPointer = figSoundBridge_GetASBDFromALACBBuf(*((OpaqueCMBlockBuffer **)&v198 + 1), (uint64_t)v212);
        goto LABEL_463;
      }
      goto LABEL_502;
    }
    if (v83 == 1685220723) {
      goto LABEL_443;
    }
    if (v83 != 1700998451) {
      goto LABEL_485;
    }
    if (!(void)v198)
    {
      uint64_t v96 = v208;
      v97 = "Expected to get a magic cookie for ec-3";
      goto LABEL_461;
    }
    uint64_t DataPointer = figSoundBridge_GetASBDFromDEC3BBuf((OpaqueCMBlockBuffer *)v198, (uint64_t)v212);
LABEL_463:
    uint64_t Empty = DataPointer;
    goto LABEL_503;
  }
  if (v83 <= 1296122677)
  {
    if (v83)
    {
      if (v83 == 778924083)
      {
        if ((HIDWORD(v192[1]) - 3) < 2) {
          goto LABEL_502;
        }
      }
      else if (v83 == 1296122675)
      {
        uint64_t Empty = 0;
        LODWORD(v212[2]) = 2 * v92;
        HIDWORD(v212[2]) = 6;
        goto LABEL_503;
      }
      goto LABEL_485;
    }
    goto LABEL_460;
  }
  if (v83 <= 1633777251)
  {
    if (v83 != 1296122678)
    {
      int v101 = 1313820229;
      goto LABEL_459;
    }
    uint64_t Empty = 0;
    v212[2] = (char *)(v92 | 0x600000000);
    goto LABEL_503;
  }
  if (v83 == 1633777252) {
    goto LABEL_443;
  }
  if (v83 == 1633889587)
  {
    if (*((void *)&v197 + 1))
    {
      uint64_t DataPointer = figSoundBridge_GetASBDFromDAC3BBuf(*((OpaqueCMBlockBuffer **)&v197 + 1), (uint64_t)v212);
      goto LABEL_463;
    }
LABEL_502:
    uint64_t Empty = 0;
    goto LABEL_503;
  }
LABEL_485:
  if (!*((void *)&v203 + 1)
    || (LODWORD(destination[0]) = 0,
        figSoundBridge_GetDecodeFormatIDForCodingName(v83, (uint64_t)v192, destination)))
  {
LABEL_487:
    destination[0] = *(_OWORD *)v212;
    destination[1] = *(_OWORD *)&v212[2];
    *(void *)&long long v219 = v213;
    *(void *)&long long v226 = 32;
    dataPointerOut[0] = v212[0];
    dataPointerOut[1] = (CFTypeRef)0x96C70636DLL;
    LODWORD(v225) = 4 * HIDWORD(v212[3]);
    DWORD1(v225) = 1;
    DWORD2(v225) = 4 * HIDWORD(v212[3]);
    HIDWORD(v225) = HIDWORD(v212[3]);
    if (!AudioToolbox_AudioConverterNew((uint64_t)destination, (uint64_t)dataPointerOut, (uint64_t)&size)
      && (!(void)v207
       || !DWORD2(v207)
       || !AudioToolbox_AudioConverterSetProperty(size, 1684891491, DWORD2(v207), v207)))
    {
      LODWORD(blockBufferOut) = 40;
      if (!AudioToolbox_AudioConverterGetProperty(size, 1633904996, (uint64_t)&blockBufferOut, (uint64_t)destination))
      {
        *(_OWORD *)v212 = destination[0];
        *(_OWORD *)&v212[2] = destination[1];
        uint64_t v213 = v219;
      }
    }
    if (size) {
      AudioToolbox_AudioConverterDispose(size);
    }
    goto LABEL_502;
  }
  int v158 = destination[0];
  LODWORD(v212[1]) = destination[0];
  uint64_t Empty = figSoundBridge_GetASBDFromAudioFormatWithCodecSpecificAtomBBuf(destination[0], *((CMBlockBufferRef *)&v203 + 1), (uint64_t)v212);
  if (!Empty) {
    goto LABEL_503;
  }
  if (v158 > 1869641074)
  {
    if (v158 == 1869641075) {
      goto LABEL_503;
    }
    int v159 = 1902211171;
  }
  else
  {
    if (v158 == 1634754915) {
      goto LABEL_503;
    }
    int v159 = 1667330147;
  }
  if (v158 != v159)
  {
    figSoundBridge_ReportParsingFailureMessage(v208, (uint64_t)"AudioToolbox failed to parse the magic cookie; the resulting audio description may not be authoritative");
    goto LABEL_487;
  }
LABEL_503:
  if (Empty)
  {
LABEL_504:
    v109 = 0;
    goto LABEL_505;
  }
  uint64_t v113 = a5;
  theBuffera = theSourceBuffer;
  CFAllocatorRef v171 = a1;
  v114 = v212[0];
  long long v186 = *(_OWORD *)((char *)&v212[1] + 4);
  AudioFormatID v115 = (AudioFormatID)v212[1];
  UInt32 v116 = HIDWORD(v212[3]);
  uint64_t v117 = v213;
  if (!*((void *)&v200 + 1))
  {
    size_t v119 = 0;
    goto LABEL_560;
  }
  size_t v118 = CMBlockBufferGetDataLength(*((CMBlockBufferRef *)&v200 + 1));
  size_t v119 = v118;
  if (!v118) {
    goto LABEL_560;
  }
  unint64_t v120 = v118 - 12;
  if (v118 <= 0xC)
  {
    v161 = "Channel extension size is too short";
    uint64_t v162 = v113;
    goto LABEL_738;
  }
  v109 = (AudioChannelLayout *)malloc_type_malloc(v118 - 12, 0xE0C9B033uLL);
  uint64_t v121 = CMBlockBufferCopyDataBytes(*((CMBlockBufferRef *)&v200 + 1), 0xCuLL, v119 - 12, v109);
  if (v121) {
    goto LABEL_774;
  }
  if (!v109)
  {
    v119 -= 12;
LABEL_560:
    v109 = 0;
    if (!(void)v201)
    {
      unint64_t v120 = 0;
      goto LABEL_578;
    }
    unint64_t v120 = 0;
    if (v115 != 1819304813) {
      goto LABEL_578;
    }
    dataPointerOut[0] = 0;
    v212[0] = 0;
    LODWORD(size) = 0;
    *(void *)&long long v220 = 0;
    long long v219 = 0u;
    memset(destination, 0, sizeof(destination));
    if (CMBlockBufferGetDataPointer((CMBlockBufferRef)v201, 0, (size_t *)dataPointerOut, 0, v212))
    {
      v109 = 0;
    }
    else
    {
      *(void *)&destination[0] = v114;
      *(_OWORD *)((char *)destination + 12) = v186;
      DWORD2(destination[0]) = 1819304813;
      HIDWORD(destination[1]) = v116;
      *(void *)&long long v219 = v117;
      *((char **)&v219 + 1) = v212[0];
      LODWORD(v220) = dataPointerOut[0];
      uint64_t PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1684235116, 56, (uint64_t)destination, (uint64_t)&size);
      if (PropertyInfo)
      {
        v109 = 0;
      }
      else
      {
        v109 = (AudioChannelLayout *)malloc_type_malloc(size, 0x19220E06uLL);
        if (v109)
        {
          uint64_t PropertyInfo = AudioToolbox_AudioFormatGetProperty(1684235116, 56, (uint64_t)destination, (uint64_t)&size, (uint64_t)v109);
          if (!PropertyInfo)
          {
            size_t v119 = size;
LABEL_567:
            unint64_t v120 = v119;
            goto LABEL_578;
          }
        }
        else
        {
          uint64_t PropertyInfo = 4294954583;
        }
      }
      if (!FigSignalErrorAt(PropertyInfo, 0, 0, 0, 0, 0, 0))
      {
        v109 = 0;
        goto LABEL_567;
      }
    }
    free(v109);
    if (v116 >= 3)
    {
      figSoundBridge_ReportParsingFailureMessage(v113, (uint64_t)"Can't convert ISO channel layout for multichannel audio to an AudioChannelLayout");
      uint64_t Empty = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      v109 = 0;
      v110 = 0;
      CFDictionaryRef v111 = 0;
      goto LABEL_506;
    }
    v109 = 0;
    unint64_t v120 = 0;
    goto LABEL_578;
  }
  if (v120 <= 4)
  {
    figSoundBridge_ReportParsingFailureMessage(v113, (uint64_t)"Channel extension size is too short");
    uint64_t v121 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_774;
  }
  if (v120 < 0xC) {
    goto LABEL_556;
  }
  int8x8_t v123 = *(int8x8_t *)&v109->mChannelLayoutTag;
  unsigned int mNumberChannelDescriptions = v109->mNumberChannelDescriptions;
  uint64_t v125 = bswap32(mNumberChannelDescriptions);
  if (v125 <= ((int)v119 - 24) / 0x14u)
  {
    if (mNumberChannelDescriptions)
    {
      uint64_t v126 = 0;
      mCoordinates = (AudioChannelLayout *)v109->mChannelDescriptions[0].mCoordinates;
      do
      {
        uint64_t v128 = 0;
        *(int8x8_t *)&v109->mChannelDescriptions[v126].mChannelLabel = vrev32_s8(*(int8x8_t *)&v109->mChannelDescriptions[v126].mChannelLabel);
        do
        {
          *(AudioChannelLayoutTag *)((char *)&mCoordinates->mChannelLayoutTag + v128) = bswap32(*(AudioChannelLayoutTag *)((char *)&mCoordinates->mChannelLayoutTag + v128));
          v128 += 4;
        }
        while (v128 != 12);
        ++v126;
        mCoordinates = (AudioChannelLayout *)((char *)mCoordinates + 20);
      }
      while (v126 != v125);
    }
LABEL_577:
    *(int8x8_t *)&v109->unsigned int mChannelLayoutTag = vrev32_s8(v123);
    v109->unsigned int mNumberChannelDescriptions = v125;
    goto LABEL_578;
  }
  if (v123.i32[0])
  {
    LODWORD(v125) = 0;
    goto LABEL_577;
  }
LABEL_556:
  uint64_t v121 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (!v121)
  {
LABEL_578:
    *(void *)&v188[0] = v114;
    *(_OWORD *)((char *)v188 + 12) = v186;
    DWORD2(v188[0]) = v115;
    HIDWORD(v188[1]) = v116;
    *(void *)&long long v189 = v117;
    *((void *)&v189 + 1) = v207;
    LODWORD(v190) = DWORD2(v207);
    uint64_t v129 = AudioToolbox_AudioFormatGetPropertyInfo(1718383476, 56, (uint64_t)v188, (uint64_t)&v191);
    if (v129)
    {
      uint64_t Empty = v129;
      CFAllocatorRef allocatora = (CFAllocatorRef)v120;
      *(void *)&asbd.Float64 mSampleRate = v114;
      asbd.AudioFormatID mFormatID = v115;
      *(_OWORD *)&asbd.mFormatFlags = v186;
      asbd.UInt32 mChannelsPerFrame = v116;
      *(void *)&asbd.mBitsPerChannel = v117;
      CFAllocatorRef v130 = v171;
      if ((void)v197)
      {
        *(void *)&destination[0] = 0;
        dataPointerOut[0] = 0;
        if (!CMBlockBufferGetDataPointer((CMBlockBufferRef)v197, 0, (size_t *)destination, 0, (char **)dataPointerOut))
        {
          if (HIDWORD(*(void *)&destination[0]))
          {
            FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
          }
          else
          {
            LODWORD(v212[0]) = 32;
            AudioToolbox_AudioFormatGetProperty(1702060908, *(uint64_t *)&destination[0], (uint64_t)dataPointerOut[0], (uint64_t)v212, (uint64_t)&layout);
          }
        }
      }
      uint64_t v131 = v207;
      unsigned int v132 = DWORD2(v207);
      if (!v109 && v115 == 1633889587 && (void)v207 && DWORD2(v207))
      {
        *(void *)&long long v219 = 0;
        memset(destination, 0, sizeof(destination));
        LODWORD(dataPointerOut[0]) = 0;
        if (!ParseAC3MP4Cookie((unsigned __int8 *)v207, DWORD2(v207), (uint64_t)destination, (int *)dataPointerOut)&& DWORD2(destination[0]) == 1633889587)
        {
          layout.unsigned int mChannelLayoutTag = (AudioChannelLayoutTag)dataPointerOut[0];
        }
        AudioFormatID v115 = 1633889587;
      }
      v110 = 0;
      if (!v109 && DWORD2(v188[0]) == 1700998451 && v131 && v132)
      {
        *(void *)&long long v219 = 0;
        memset(destination, 0, sizeof(destination));
        dataPointerOut[0] = 0;
        LODWORD(v212[0]) = 0;
        if (!ParseEnhancedAC3MP4Cookie(v131, v132, (uint64_t)destination, dataPointerOut, (unsigned int *)v212)&& v115 == DWORD2(destination[0]))
        {
          layout.unsigned int mChannelLayoutTag = *(_DWORD *)dataPointerOut[0];
        }
        free((void *)dataPointerOut[0]);
        v110 = 0;
      }
      goto LABEL_611;
    }
    if (v191 > 0x2F)
    {
      v110 = malloc_type_calloc(1uLL, v191, 0x6D08AF81uLL);
      if (v110)
      {
        uint64_t Empty = AudioToolbox_AudioFormatGetProperty(1718383476, 56, (uint64_t)v188, (uint64_t)&v191, (uint64_t)v110);
        CFAllocatorRef allocatora = (CFAllocatorRef)v120;
        if (Empty || v191 <= 0x2F)
        {
          *(void *)&asbd.Float64 mSampleRate = v114;
          asbd.AudioFormatID mFormatID = v115;
          *(_OWORD *)&asbd.mFormatFlags = v186;
          asbd.UInt32 mChannelsPerFrame = v116;
          *(void *)&asbd.mBitsPerChannel = v117;
        }
        else
        {
          v133 = (char *)&v110[12 * (v191 / 0x30) - 12];
          long long v134 = *(_OWORD *)v133;
          long long v135 = *((_OWORD *)v133 + 1);
          *(void *)&asbd.mBitsPerChannel = *((void *)v133 + 4);
          *(_OWORD *)&asbd.Float64 mSampleRate = v134;
          *(_OWORD *)&asbd.mBytesPerPacket = v135;
          layout.unsigned int mChannelLayoutTag = *((_DWORD *)v133 + 10);
          if (!layout.mChannelLayoutTag)
          {
            long long v156 = *(_OWORD *)v133;
            long long v157 = *((_OWORD *)v133 + 1);
            *(void *)&long long v189 = *((void *)v133 + 4);
            v188[1] = v157;
            v188[0] = v156;
            CFAllocatorRef v130 = v171;
            uint64_t Empty = 0;
            if (!figSoundBridge_ChannelLayoutFromFormatInfo((uint64_t)v188, &v182, &v181)) {
              layout.unsigned int mNumberChannelDescriptions = *((_DWORD *)v182 + 2);
            }
LABEL_611:
            v212[0] = 0;
            long long v219 = 0u;
            long long v220 = 0u;
            memset(destination, 0, sizeof(destination));
            long long v226 = 0u;
            long long v227 = 0u;
            *(_OWORD *)dataPointerOut = 0u;
            long long v225 = 0u;
            CMBlockBufferRef blockBufferOut = 0;
            size_t size = 0;
            CFAllocatorRef v136 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            size_t v137 = CMBlockBufferGetDataLength(theBuffera);
            if (!CMBlockBufferCreateContiguous(v136, theBuffera, 0, 0, 0, v137, 0, &blockBufferOut))
            {
              v138 = blockBufferOut;
              size_t v139 = CMBlockBufferGetDataLength(blockBufferOut);
              if (!FigCreateCFDataWithBlockBufferNoCopy(v136, v138, 0, v139, (CFDataRef *)&size))
              {
                if (v192[0])
                {
                  if (BYTE8(v208)) {
                    v140 = kFigFormatDescriptionExtension_DeprecatedVerbatimISOSampleEntry;
                  }
                  else {
                    v140 = (__CFString **)&kCMFormatDescriptionExtension_VerbatimISOSampleEntry;
                  }
                }
                else if (BYTE8(v208))
                {
                  v140 = kFigFormatDescriptionExtension_DeprecatedVerbatimSampleDescription;
                }
                else
                {
                  v140 = (__CFString **)&kCMFormatDescriptionExtension_VerbatimSampleDescription;
                }
                v141 = *v140;
                dataPointerOut[0] = (CFTypeRef)size;
                size_t size = 0;
                *(void *)&destination[0] = v141;
                CFIndex v142 = 1;
                v212[0] = (char *)1;
                if (*((void *)&v204 + 1))
                {
                  *((void *)&destination[0] + 1) = @"SampleDescriptionExtensionAtoms";
                  dataPointerOut[1] = CFRetain(*((CFTypeRef *)&v204 + 1));
                  CFIndex v142 = 2;
                  v212[0] = (char *)2;
                }
                if (!(void)v202)
                {
LABEL_630:
                  CFDictionaryRef v111 = CFDictionaryCreate(v130, (const void **)destination, dataPointerOut, v142, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
                  if (!v111) {
                    FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                  }
LABEL_632:
                  if (v212[0])
                  {
                    v145 = 0;
                    do
                    {
                      CFRelease(*((CFTypeRef *)destination + (void)v145));
                      CFRelease(dataPointerOut[(void)v145++]);
                    }
                    while (v145 < v212[0]);
                  }
                  if (blockBufferOut) {
                    CFRelease(blockBufferOut);
                  }
                  size_t v146 = (size_t)allocatora;
                  if (!v111) {
                    goto LABEL_506;
                  }
                  int v184 = 40;
                  AudioToolbox_AudioFormatGetProperty(1718449257, DWORD2(v207), v207, (uint64_t)&v184, (uint64_t)&asbd);
                  if (layout.mChannelLayoutTag == 0x10000)
                  {
                    AudioChannelBitmap mChannelBitmap = layout.mChannelBitmap;
                    if (!layout.mChannelBitmap) {
                      goto LABEL_677;
                    }
                    UInt32 mChannelLayoutTag_low = 0;
                    do
                    {
                      mChannelLayoutTag_low += mChannelBitmap & 1;
                      BOOL v149 = mChannelBitmap >= 2;
                      mChannelBitmap >>= 1;
                    }
                    while (v149);
                  }
                  else if (layout.mChannelLayoutTag)
                  {
                    UInt32 mChannelLayoutTag_low = LOWORD(layout.mChannelLayoutTag);
                  }
                  else
                  {
                    UInt32 mChannelLayoutTag_low = layout.mNumberChannelDescriptions;
                  }
                  if (mChannelLayoutTag_low)
                  {
                    if (!v109) {
                      goto LABEL_679;
                    }
                    if (v109->mChannelLayoutTag == 0x10000)
                    {
                      unsigned int v151 = v109->mChannelBitmap;
                      if (v151)
                      {
                        int v150 = 0;
                        do
                        {
                          v150 += v151 & 1;
                          BOOL v149 = v151 >= 2;
                          v151 >>= 1;
                        }
                        while (v149);
                      }
                      else
                      {
                        int v150 = 0;
                      }
                    }
                    else
                    {
                      int v150 = v109->mChannelLayoutTag
                           ? (unsigned __int16)v109->mChannelLayoutTag
                           : v109->mNumberChannelDescriptions;
                    }
                    unsigned int v152 = v191;
                    LODWORD(destination[0]) = 0;
                    if (!v110 || v191 <= 0x2F) {
                      goto LABEL_679;
                    }
                    if (FigAudioFormatGetRichestDecodableFormatIndex((uint64_t)v110, v191, destination)) {
                      int v153 = 0;
                    }
                    else {
                      int v153 = destination[0];
                    }
                    if (v110[12 * v153 + 7] == v150) {
                      goto LABEL_677;
                    }
                    p_AudioChannelLayout layout = v109;
                    if (v110[12 * (v152 / 0x30) - 5] != v150)
                    {
LABEL_679:
                      p_AudioChannelLayout layout = (const AudioChannelLayout *)v182;
                      if (v182)
                      {
                        size_t v146 = v181;
                      }
                      else
                      {
                        p_AudioChannelLayout layout = &layout;
                        size_t v146 = 12;
                      }
                    }
LABEL_682:
                    uint64_t Empty = CMAudioFormatDescriptionCreate(v130, &asbd, v146, p_layout, DWORD2(v207), (const void *)v207, v111, &formatDescriptionOut);
                    if (!Empty)
                    {
                      CMAudioFormatDescriptionRef *v172 = formatDescriptionOut;
                      CMAudioFormatDescriptionRef formatDescriptionOut = 0;
                    }
                    goto LABEL_506;
                  }
LABEL_677:
                  p_AudioChannelLayout layout = v109;
                  goto LABEL_682;
                }
                size_t lengthAtOffsetOut = 0;
                v215 = 0;
                if (!CMBlockBufferGetDataPointer((CMBlockBufferRef)v202, 0, &lengthAtOffsetOut, 0, &v215))
                {
                  lengthAtOffsetOut -= 8;
                  v215 += 8;
                  LODWORD(v206) = FigBridgeGetCommonEncryptionScheme((uint64_t)v215, lengthAtOffsetOut);
                  if (v206)
                  {
                    *((void *)destination + v142) = @"CommonEncryptionProtected";
                    dataPointerOut[v142] = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
                    CFIndex v143 = v142 + 1;
                    v212[0] = (char *)(v142 + 1);
                    int OriginalFormatFromSinf = FigBridgeGetOriginalFormatFromSinf((uint64_t)v215, lengthAtOffsetOut);
                    if (OriginalFormatFromSinf)
                    {
                      *((void *)destination + v143) = @"CommonEncryptionOriginalFormat";
                      dataPointerOut[v143] = FigCFNumberCreateSInt32(v136, OriginalFormatFromSinf);
                      v212[0] = (char *)(v142 + 2);
                    }
                    CFAllocatorRef v130 = v171;
                    if (FigBridgeExtractCommonEncryptionTrackEncryptionExtension(v171, (uint64_t)destination, (uint64_t)dataPointerOut, v212, (uint64_t)v215, lengthAtOffsetOut))
                    {
                      CFDictionaryRef v111 = 0;
                      goto LABEL_632;
                    }
                    CFIndex v142 = (CFIndex)v212[0];
                  }
                  goto LABEL_630;
                }
              }
            }
            CFDictionaryRef v111 = 0;
            goto LABEL_632;
          }
          uint64_t Empty = 0;
        }
        CFAllocatorRef v130 = v171;
        goto LABEL_611;
      }
      FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      v110 = 0;
    }
    CFDictionaryRef v111 = 0;
    uint64_t Empty = 0;
    goto LABEL_506;
  }
LABEL_774:
  uint64_t Empty = v121;
LABEL_505:
  v110 = 0;
  CFDictionaryRef v111 = 0;
LABEL_506:
  free(v109);
  free(v110);
  free(v182);
  if (*((void *)&v206 + 1)) {
    CFRelease(*((CFTypeRef *)&v206 + 1));
  }
  *(void *)&long long v207 = 0;
  if ((void)v196) {
    CFRelease((CFTypeRef)v196);
  }
  if ((void)v197) {
    CFRelease((CFTypeRef)v197);
  }
  if (*((void *)&v196 + 1)) {
    CFRelease(*((CFTypeRef *)&v196 + 1));
  }
  if (*((void *)&v197 + 1)) {
    CFRelease(*((CFTypeRef *)&v197 + 1));
  }
  if ((void)v198) {
    CFRelease((CFTypeRef)v198);
  }
  if (*((void *)&v198 + 1)) {
    CFRelease(*((CFTypeRef *)&v198 + 1));
  }
  if ((void)v199) {
    CFRelease((CFTypeRef)v199);
  }
  if (*((void *)&v199 + 1)) {
    CFRelease(*((CFTypeRef *)&v199 + 1));
  }
  if (*((void *)&v200 + 1)) {
    CFRelease(*((CFTypeRef *)&v200 + 1));
  }
  if ((void)v201) {
    CFRelease((CFTypeRef)v201);
  }
  if ((void)v203) {
    CFRelease((CFTypeRef)v203);
  }
  if (*((void *)&v201 + 1)) {
    CFRelease(*((CFTypeRef *)&v201 + 1));
  }
  if ((void)v202) {
    CFRelease((CFTypeRef)v202);
  }
  if (*((void *)&v202 + 1)) {
    CFRelease(*((CFTypeRef *)&v202 + 1));
  }
  if ((void)v200) {
    CFRelease((CFTypeRef)v200);
  }
  if (*((void *)&v203 + 1)) {
    CFRelease(*((CFTypeRef *)&v203 + 1));
  }
  if (*((void *)&v204 + 1)) {
    CFRelease(*((CFTypeRef *)&v204 + 1));
  }
  if (v111) {
    CFRelease(v111);
  }
  if ((Empty + 12896) < 7 || Empty == -206) {
    return 4294954582;
  }
  return Empty;
}

void figSoundBridge_ReportParsingFailureMessage(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFMutableDictionaryRef v6 = Mutable;
      CFTypeRef v7 = CFStringCreateMutable(v4, 0);
      if (v7)
      {
        CFTypeID v8 = v7;
        CFStringAppendFormat(v7, 0, @" %s.", a2);
        FigCFDictionarySetInt64(v6, @"MessageType", 2);
        CFDictionarySetValue(v6, @"DiagnosticInformation", v8);
        FigCFDictionarySetInt32(v6, @"AnalysisType", 1836019574);
        FigAssetAnalysisReporterAddMessage(a1, v6);
        CFRelease(v8);
      }
      CFRelease(v6);
    }
  }
}

uint64_t figSoundBridge_ChannelLayoutFromFormatInfo(uint64_t a1, void *a2, _DWORD *a3)
{
  LODWORD(size) = 0;
  uint64_t PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1668048489, 56, a1, (uint64_t)&size);
  if (PropertyInfo) {
    goto LABEL_9;
  }
  if (size <= 0x1F)
  {
    uint64_t PropertyInfo = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
LABEL_9:
    uint64_t v9 = PropertyInfo;
    goto LABEL_6;
  }
  CFTypeRef v7 = malloc_type_malloc(size, 0x8A7ADFBFuLL);
  if (!v7)
  {
    uint64_t Property = 4294954583;
    goto LABEL_11;
  }
  uint64_t Property = AudioToolbox_AudioFormatGetProperty(1668048489, 56, a1, (uint64_t)&size, (uint64_t)v7);
  if (Property)
  {
LABEL_11:
    uint64_t v9 = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  uint64_t v9 = 0;
  *a2 = v7;
  *a3 = size;
LABEL_6:
  CFTypeRef v7 = 0;
LABEL_7:
  free(v7);
  return v9;
}

uint64_t ParseAC3MP4Cookie(unsigned __int8 *a1, unsigned int a2, uint64_t a3, int *a4)
{
  uint64_t v4 = 4294954582;
  if (a1 && a2 >= 0xB)
  {
    unint64_t v5 = (unint64_t)a1[8] >> 6;
    if (v5 == 3) {
      return 4294954582;
    }
    uint64_t v6 = ParseEnhancedAC3MP4Cookie_theSampleRateTable[v5];
    unint64_t v7 = a1[9];
    uint64_t v8 = (v7 >> 3) & 7;
    int v9 = ParseAC3MP4Cookie_theChannelTable[v8];
    unsigned int v10 = v7 & 4;
    if (a4)
    {
      switch((int)v8)
      {
        case 1:
          BOOL v11 = v10 == 0;
          int v12 = 9764866;
          int v13 = 6553601;
          break;
        case 3:
          int v12 = 9961476;
          BOOL v11 = v10 == 0;
          int v13 = 9830403;
          break;
        case 4:
          int v12 = 10027012;
          BOOL v11 = v10 == 0;
          int v13 = 8585219;
          break;
        case 5:
          BOOL v11 = v10 == 0;
          int v12 = 10092549;
          int v13 = 9895940;
          break;
        case 6:
          BOOL v11 = v10 == 0;
          int v12 = 9043973;
          int v13 = 8650756;
          break;
        case 7:
          BOOL v11 = v10 == 0;
          int v12 = 8060934;
          int v13 = 7798789;
          break;
        default:
          BOOL v11 = v10 == 0;
          int v12 = 8716291;
          int v13 = 6619138;
          break;
      }
      if (v11) {
        int v12 = v13;
      }
      *a4 = v12;
    }
    if (((a1[10] >> 5) & 0xFFFFFFE7 | (8 * (a1[9] & 3))) > 0x12)
    {
      return 4294954582;
    }
    else
    {
      uint64_t v4 = 0;
      if (a3)
      {
        *(void *)a3 = v6;
        *(void *)(a3 + 8) = 1633889587;
        *(void *)(a3 + 16) = 0x60000000000;
        *(_DWORD *)(a3 + 24) = 0;
        *(_DWORD *)(a3 + 28) = v9 + (v10 >> 2);
        *(void *)(a3 + 32) = 0;
      }
    }
  }
  return v4;
}

uint64_t ParseEnhancedAC3MP4Cookie(uint64_t a1, unsigned int a2, uint64_t a3, void *a4, unsigned int *a5)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  uint64_t result = 4294954582;
  if (!a1 || a2 < 0xD) {
    return result;
  }
  unsigned int v8 = 0;
  uint64_t v9 = a1 + 8;
  uint64_t v10 = a2 - 8;
  unsigned int v11 = *(unsigned char *)(a1 + 9) & 7;
  uint64_t v39 = 0;
  int v12 = (unsigned __int8 *)(a1 + 10);
  double v13 = 0.0;
  double v14 = 0.0;
  do
  {
    if ((uint64_t)&v12[-v9 + 3] > v10) {
      return 4294954582;
    }
    unint64_t v15 = (unint64_t)*v12 >> 6;
    uint64_t v67 = 0;
    long long v65 = 0uLL;
    long long v66 = 0uLL;
    long long v63 = 0uLL;
    long long v64 = 0uLL;
    long long v61 = 0uLL;
    long long v62 = 0uLL;
    long long v59 = 0uLL;
    long long v60 = 0uLL;
    long long v57 = 0uLL;
    long long v58 = 0uLL;
    long long v55 = 0uLL;
    long long v56 = 0uLL;
    long long v53 = 0uLL;
    long long v54 = 0uLL;
    long long v51 = 0uLL;
    long long v52 = 0uLL;
    long long v49 = 0uLL;
    long long v50 = 0uLL;
    long long v47 = 0uLL;
    long long v48 = 0uLL;
    long long v45 = 0uLL;
    long long v46 = 0uLL;
    long long v43 = 0uLL;
    long long v44 = 0uLL;
    long long v41 = 0uLL;
    long long v42 = 0uLL;
    long long __src = 0uLL;
    if (v15 == 3) {
      return 4294954582;
    }
    if (*(double *)&ParseEnhancedAC3MP4Cookie_theSampleRateTable[v15] > v14 || v8 == 0)
    {
      double v13 = *(double *)&ParseEnhancedAC3MP4Cookie_theSampleRateTable[v15];
      double v14 = v13;
    }
    unsigned int v17 = v12[1];
    int v18 = (v17 >> 1) & 7;
    switch(v18)
    {
      case 1:
        LODWORD(__src) = 3;
        unsigned int v19 = 1;
        if (v17) {
          goto LABEL_25;
        }
        break;
      case 3:
        unsigned int v19 = 3;
        LODWORD(__src) = 1;
        DWORD1(v41) = 3;
        DWORD2(v42) = 2;
        if (v17) {
          goto LABEL_25;
        }
        break;
      case 4:
        LODWORD(__src) = 1;
        DWORD1(v41) = 2;
        unsigned int v19 = 3;
        DWORD2(v42) = 9;
        if (v17) {
          goto LABEL_25;
        }
        break;
      case 5:
        LODWORD(__src) = 1;
        DWORD1(v41) = 3;
        unsigned int v19 = 4;
        DWORD2(v42) = 2;
        HIDWORD(v43) = 9;
        if (v17) {
          goto LABEL_25;
        }
        break;
      case 6:
        LODWORD(__src) = 1;
        DWORD1(v41) = 2;
        unsigned int v19 = 4;
        DWORD2(v42) = 5;
        HIDWORD(v43) = 6;
        if (v17) {
          goto LABEL_25;
        }
        break;
      case 7:
        LODWORD(__src) = 1;
        DWORD1(v41) = 3;
        unsigned int v19 = 5;
        DWORD2(v42) = 2;
        HIDWORD(v43) = 5;
        LODWORD(v45) = 6;
        if (v17) {
          goto LABEL_25;
        }
        break;
      default:
        unsigned int v19 = 2;
        LODWORD(__src) = 1;
        DWORD1(v41) = 2;
        if (v17)
        {
LABEL_25:
          uint64_t v20 = 20 * v19++;
          *(_DWORD *)((char *)&__src + v20) = 4;
        }
        break;
    }
    unsigned __int8 v21 = v12[2];
    if ((v21 & 0x1E) == 0)
    {
      v12 += 3;
      continue;
    }
    if ((uint64_t)&v12[-v9 + 4] > v10) {
      return 4294954582;
    }
    unsigned __int8 v22 = v12[3];
    if (v22)
    {
      unsigned int v23 = v19 + 1;
      *((_DWORD *)&__src + 5 * v19) = 7;
      v19 += 2;
      *((_DWORD *)&__src + 5 * v23) = 8;
      if ((v22 & 2) == 0)
      {
LABEL_30:
        if ((v22 & 4) == 0) {
          goto LABEL_37;
        }
        goto LABEL_35;
      }
    }
    else if ((v12[3] & 2) == 0)
    {
      goto LABEL_30;
    }
    unsigned int v24 = v19 + 1;
    *((_DWORD *)&__src + 5 * v19) = 33;
    v19 += 2;
    *((_DWORD *)&__src + 5 * v24) = 34;
    if ((v22 & 4) == 0) {
      goto LABEL_37;
    }
LABEL_35:
    if ((v18 - 6) <= 0xFFFFFFFD)
    {
      uint64_t v25 = 20 * v19++;
      *(_DWORD *)((char *)&__src + v25) = 9;
    }
LABEL_37:
    if ((v22 & 8) != 0)
    {
      uint64_t v28 = 20 * v19++;
      *(_DWORD *)((char *)&__src + v28) = 12;
      if ((v22 & 0x10) == 0)
      {
LABEL_39:
        if ((v22 & 0x20) == 0) {
          goto LABEL_40;
        }
        goto LABEL_49;
      }
    }
    else if ((v22 & 0x10) == 0)
    {
      goto LABEL_39;
    }
    unsigned int v29 = v19 + 1;
    *((_DWORD *)&__src + 5 * v19) = 10;
    v19 += 2;
    *((_DWORD *)&__src + 5 * v29) = 11;
    if ((v22 & 0x20) == 0)
    {
LABEL_40:
      if ((v22 & 0x40) != 0) {
        goto LABEL_50;
      }
      goto LABEL_41;
    }
LABEL_49:
    unsigned int v30 = v19 + 1;
    *((_DWORD *)&__src + 5 * v19) = 35;
    v19 += 2;
    *((_DWORD *)&__src + 5 * v30) = 36;
    if ((v22 & 0x40) != 0)
    {
LABEL_50:
      unsigned int v31 = v19 + 1;
      *((_DWORD *)&__src + 5 * v19) = 13;
      v19 += 2;
      *((_DWORD *)&__src + 5 * v31) = 15;
      if ((v22 & 0x80) == 0) {
        goto LABEL_42;
      }
      goto LABEL_51;
    }
LABEL_41:
    if ((v22 & 0x80) == 0) {
      goto LABEL_42;
    }
LABEL_51:
    uint64_t v32 = 20 * v19++;
    *(_DWORD *)((char *)&__src + v32) = 14;
LABEL_42:
    v12 += 4;
    if (v21)
    {
      uint64_t v26 = 20 * v19++;
      *(_DWORD *)((char *)&__src + v26) = 37;
    }
  }
  while (v8++ < v11);
  if (a4 && a5)
  {
    int v37 = 4;
    int v38 = 0;
    unsigned int v33 = 20 * v19 + 12;
    int v34 = malloc_type_calloc(1uLL, v33, 0xD3CA3F14uLL);
    _DWORD *v34 = 0;
    v34[2] = v19;
    memcpy(v34 + 3, &__src, 20 * v19);
    if (!AudioToolbox_AudioFormatGetProperty(1668116596, v33, (uint64_t)v34, (uint64_t)&v37, (uint64_t)&v38))
    {
      free(v34);
      unsigned int v33 = 32;
      int v34 = malloc_type_calloc(1uLL, 0x20uLL, 0x99CAEB3DuLL);
      _DWORD *v34 = v38;
      v34[2] = 0;
    }
    *a5 = v33;
    *a4 = v34;
  }
  uint64_t result = 0;
  if (a3)
  {
    *(double *)a3 = v13;
    *(void *)(a3 + 8) = 1700998451;
    *(void *)(a3 + 16) = 0x60000000000;
    *(_DWORD *)(a3 + 24) = 0;
    *(_DWORD *)(a3 + 28) = v19;
    *(void *)(a3 + 32) = v39;
  }
  return result;
}

_DWORD *figSoundBridge_GetAudioChannelCountFromLayout(_DWORD *result)
{
  if (result)
  {
    if (*result == 0x10000)
    {
      unsigned int v1 = result[1];
      if (v1)
      {
        LODWORD(result) = 0;
        do
        {
          uint64_t result = (_DWORD *)((v1 & 1) + result);
          BOOL v2 = v1 >= 2;
          v1 >>= 1;
        }
        while (v2);
      }
      else
      {
        return 0;
      }
    }
    else if (*result)
    {
      return (_DWORD *)(unsigned __int16)*result;
    }
    else
    {
      return (_DWORD *)result[2];
    }
  }
  return result;
}

OSStatus CMAudioFormatDescriptionCopyAsBigEndianSoundDescriptionBlockBuffer(CFAllocatorRef allocator, CMAudioFormatDescriptionRef audioFormatDescription, CMSoundDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  size_t sizeOut = 0;
  CMBlockBufferRef theBuffer = 0;
  if (audioFormatDescription)
  {
    CFTypeID TypeID = CMFormatDescriptionGetTypeID();
    if (TypeID == CFGetTypeID(audioFormatDescription)
      && CMFormatDescriptionGetMediaType(audioFormatDescription) == 1936684398
      && blockBufferOut)
    {
      if (!flavor)
      {
LABEL_19:
        int v9 = 1;
LABEL_20:
        size_t totalLengthOut = 0;
        signed int MediaSubType = CMFormatDescriptionGetMediaSubType(audioFormatDescription);
        if (MediaSubType <= 1902324530)
        {
          if (MediaSubType > 1700998450)
          {
            if (MediaSubType == 1700998451 || MediaSubType == 1885547315) {
              goto LABEL_48;
            }
            int v13 = 1885692723;
          }
          else
          {
            if (MediaSubType == 1667574579 || MediaSubType == 1667575091) {
              goto LABEL_48;
            }
            int v13 = 1700997939;
          }
          if (MediaSubType != v13) {
            goto LABEL_39;
          }
LABEL_48:
          if (CMAudioFormatDescriptionGetStreamBasicDescription(audioFormatDescription)->mFramesPerPacket == 1536)
          {
LABEL_39:
            unint64_t v15 = (CFStringRef *)&kCMFormatDescriptionExtension_VerbatimISOSampleEntry;
            if ((flavor & 1) == 0) {
              unint64_t v15 = (CFStringRef *)&kCMFormatDescriptionExtension_VerbatimSampleDescription;
            }
            CFDataRef Extension = (const __CFData *)CMFormatDescriptionGetExtension(audioFormatDescription, *v15);
            if (Extension)
            {
              CFDataRef v17 = Extension;
              CFTypeID v18 = CFDataGetTypeID();
              if (v18 == CFGetTypeID(v17))
              {
                size_t Length = CFDataGetLength(v17);
                BytePtr = CFDataGetBytePtr(v17);
                unsigned __int8 v21 = BytePtr;
                dataPointerOut = 0;
                if (((v9 | flavor) & 1) != 0 || *((_WORD *)BytePtr + 8) == 512)
                {
                  OSStatus DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, Length, allocator, 0, 0, Length, 1u, &theBuffer);
                  if (!DataPointer)
                  {
                    OSStatus DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
                    if (!DataPointer)
                    {
                      memcpy(dataPointerOut, v21, Length);
                      *CMBlockBufferRef blockBufferOut = theBuffer;
                      CMBlockBufferRef theBuffer = 0;
                    }
                  }
                  goto LABEL_57;
                }
              }
            }
            MostCompatibleFormatAndChannelLayout = FigAudioFormatDescriptionGetMostCompatibleFormatAndChannelLayout(audioFormatDescription, 0, 0);
            if (MostCompatibleFormatAndChannelLayout)
            {
              uint64_t v25 = (uint64_t)MostCompatibleFormatAndChannelLayout;
              MagicCookie = CMAudioFormatDescriptionGetMagicCookie(audioFormatDescription, &sizeOut);
              if (flavor)
              {
                OSStatus DataPointer = figSoundBridge_CreateNativeISOAudioSampleEntryFromASBD(v25, allocator, &theBuffer);
                if (DataPointer) {
                  goto LABEL_57;
                }
              }
              else
              {
                OSStatus DataPointer = figSoundBridge_CreateNativeMovieSoundDescriptionFromASBD(v25, allocator, (char)flavor, (CFTypeRef *)&theBuffer);
                if (DataPointer) {
                  goto LABEL_57;
                }
                if ((FigAudioFormatDescriptionGetCreationChannelLayoutSignificance((uint64_t)audioFormatDescription) & 0xFFFFFFFE) == 2)
                {
                  dataPointerOut = 0;
                  ChannelLayout = CMAudioFormatDescriptionGetChannelLayout(audioFormatDescription, (size_t *)&dataPointerOut);
                  if (ChannelLayout)
                  {
                    if (dataPointerOut)
                    {
                      if (!((unint64_t)dataPointerOut >> 32))
                      {
                        OSStatus Contiguous = figSoundBridge_AddChannelLayoutExtensionToNativeSoundDescriptionBBuf(theBuffer, allocator, ChannelLayout, dataPointerOut);
                        if (Contiguous) {
                          goto LABEL_56;
                        }
                      }
                    }
                  }
                }
              }
              OSStatus DataPointer = figSoundBridge_AddCookieExtensionToNativeSoundDescriptionBBuf(theBuffer, *(_DWORD *)(v25 + 8), allocator, (uint64_t)MagicCookie, sizeOut, (char)flavor);
              if (DataPointer) {
                goto LABEL_57;
              }
              if (flavor)
              {
                OSStatus DataPointer = figSoundBridge_AddSamplingRateBoxIfNecessaryToNativeISOAudioSampleEntry(theBuffer, allocator, v25);
                if (DataPointer) {
                  goto LABEL_57;
                }
                OSStatus DataPointer = figSoundBridge_AddISOChannelLayoutBoxToNativeISOAudioSampleEntryIfEligible(theBuffer, allocator, audioFormatDescription);
                if (DataPointer) {
                  goto LABEL_57;
                }
              }
              OSStatus DataPointer = figSoundBridge_AddMiscellaneousSampleDescriptionExtensionsToNativeSoundDescriptionBBuf(theBuffer, audioFormatDescription, allocator);
              if (DataPointer) {
                goto LABEL_57;
              }
              Datasize_t Length = CMBlockBufferGetDataLength(theBuffer);
              size_t totalLengthOut = DataLength;
              IsRangeOSStatus Contiguous = CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength);
              unsigned int v31 = theBuffer;
              if (IsRangeContiguous) {
                goto LABEL_72;
              }
              dataPointerOut = 0;
              OSStatus Contiguous = CMBlockBufferCreateContiguous(allocator, theBuffer, allocator, 0, 0, DataLength, 0, (CMBlockBufferRef *)&dataPointerOut);
              if (!Contiguous)
              {
                if (theBuffer) {
                  CFRelease(theBuffer);
                }
                unsigned int v31 = (OpaqueCMBlockBuffer *)dataPointerOut;
                CMBlockBufferRef theBuffer = (CMBlockBufferRef)dataPointerOut;
LABEL_72:
                dataPointerOut = 0;
                size_t totalLengthOut = 0;
                OSStatus DataPointer = CMBlockBufferGetDataPointer(v31, 0, 0, &totalLengthOut, &dataPointerOut);
                if (!DataPointer)
                {
                  OSStatus DataPointer = figSoundBridge_FlipSoundDescriptionData((uint64_t)dataPointerOut, totalLengthOut, 1);
                  if (!DataPointer)
                  {
                    *CMBlockBufferRef blockBufferOut = theBuffer;
                    return DataPointer;
                  }
                }
LABEL_57:
                if (theBuffer) {
                  CFRelease(theBuffer);
                }
                return DataPointer;
              }
LABEL_56:
              OSStatus DataPointer = Contiguous;
              goto LABEL_57;
            }
            uint64_t v23 = 4294954586;
LABEL_55:
            OSStatus Contiguous = FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
            goto LABEL_56;
          }
LABEL_49:
          uint64_t v23 = 4294954579;
          goto LABEL_55;
        }
        if (MediaSubType > 1935767393)
        {
          if (MediaSubType == 2053464883 || MediaSubType == 2053319475) {
            goto LABEL_48;
          }
          unsigned __int16 v14 = 30562;
        }
        else
        {
          if (MediaSubType == 1902324531 || MediaSubType == 1902469939) {
            goto LABEL_48;
          }
          unsigned __int16 v14 = 28018;
        }
        if (MediaSubType != (v14 | 0x73610000) || (flavor & 3) != 1) {
          goto LABEL_39;
        }
        goto LABEL_49;
      }
      if (CFEqual(flavor, @"ISOFamily"))
      {
        int v9 = 1;
        LODWORD(flavor) = 1;
        goto LABEL_20;
      }
      if (CFEqual(flavor, @"QuickTimeMovieV2"))
      {
        int v9 = 0;
        LODWORD(flavor) = 4;
        goto LABEL_20;
      }
      if (CFEqual(flavor, @"3GPFamily"))
      {
        LODWORD(flavor) = 3;
        goto LABEL_19;
      }
      if (CFEqual(flavor, @"QuickTimeMovie"))
      {
        LODWORD(flavor) = 0;
        goto LABEL_19;
      }
      uint64_t v10 = 4294954579;
    }
    else
    {
      uint64_t v10 = 4294954584;
    }
  }
  else
  {
    uint64_t v10 = 4294954584;
  }

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_CreateNativeISOAudioSampleEntryFromASBD(uint64_t a1, const __CFAllocator *a2, CMBlockBufferRef *a3)
{
  uint64_t v6 = 0;
  double v7 = *(double *)a1;
  unsigned int v8 = (*(double *)a1 * 65536.0 + 0.5);
  dataPointerOut = 0;
  CMBlockBufferRef theBuffer = 0;
  int v9 = *(_DWORD *)(a1 + 8);
  int v10 = *(_DWORD *)(a1 + 12);
  int v11 = *(_DWORD *)(a1 + 28);
  do
  {
    if (v9 == figSoundBridge_CreateNativeISOAudioSampleEntryFromASBD_isoDenylist[v6]) {
      goto LABEL_60;
    }
    ++v6;
  }
  while (v6 != 3);
  if (v9 == 1819304813)
  {
    size[0] = 0;
    uint64_t PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1935962211, 40, a1, (uint64_t)size);
    if (!PropertyInfo)
    {
      int v13 = CFAllocatorAllocate(a2, size[0], 0);
      if (v13)
      {
        unsigned __int16 v14 = v13;
        uint64_t Property = AudioToolbox_AudioFormatGetProperty(1935962211, 40, a1, (uint64_t)size, (uint64_t)v13);
        if (!Property)
        {
          unsigned int v16 = size[0];
          goto LABEL_9;
        }
        uint64_t v28 = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
        if (v28)
        {
          uint64_t DataPointer = v28;
LABEL_47:
          CFAllocatorDeallocate(a2, v14);
          goto LABEL_61;
        }
LABEL_57:
        unsigned __int16 v14 = 0;
        unsigned int v16 = 0;
LABEL_9:
        if (v10) {
          int v17 = 1718641517;
        }
        else {
          int v17 = 1768973165;
        }
LABEL_12:
        BOOL v18 = v7 < 65536.0;
        __int16 v19 = v7 >= 65536.0;
        goto LABEL_34;
      }
      uint64_t PropertyInfo = 4294954583;
    }
    uint64_t DataPointer = FigSignalErrorAt(PropertyInfo, 0, 0, 0, 0, 0, 0);
    if (DataPointer) {
      goto LABEL_61;
    }
    goto LABEL_57;
  }
  int v20 = translateMP4AFormatID(*(_DWORD *)(a1 + 8));
  if (v9 == 1718378851)
  {
    int v17 = 1716281667;
    goto LABEL_33;
  }
  int v17 = v20;
  if (v20 > 1718641516)
  {
    if (v20 > 1836069984)
    {
      if (v20 == 1836069985 || v20 == 1935764850) {
        goto LABEL_31;
      }
      int v21 = 1935767394;
    }
    else
    {
      if (v20 == 1718641517 || v20 == 1768973165) {
        goto LABEL_31;
      }
      int v21 = 1832149349;
    }
  }
  else if (v20 > 1700998450)
  {
    if (v20 == 1700998451 || v20 == 1701733217) {
      goto LABEL_31;
    }
    int v21 = 1716281667;
  }
  else
  {
    if (v20 == 1633889587 || v20 == 1634492771) {
      goto LABEL_31;
    }
    int v21 = 1685220723;
  }
  if (v20 != v21)
  {
    int v34 = 0;
    size[0] = v20;
    *(void *)&size[1] = 0x6D70346600000000;
    uint64_t v33 = 0;
    int v32 = 0;
    if (!AudioToolbox_AudioFormatGetPropertyInfo(1668180324, 12, (uint64_t)size, (uint64_t)&v32))
    {
      if (v32 == 12)
      {
        uint64_t v27 = AudioToolbox_AudioFormatGetProperty(1668180324, 12, (uint64_t)size, (uint64_t)&v32, (uint64_t)&v33);
        if (!v27)
        {
          int v17 = v34;
          goto LABEL_31;
        }
      }
      else
      {
        uint64_t v27 = 4294954584;
      }
      if (!FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0)) {
        goto LABEL_31;
      }
    }
LABEL_60:
    uint64_t DataPointer = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
    goto LABEL_61;
  }
LABEL_31:
  unsigned __int16 v14 = 0;
  unsigned int v16 = 0;
  if (v17 == 1768973165 || v17 == 1718641517) {
    goto LABEL_12;
  }
LABEL_33:
  BOOL v18 = v7 < 65536.0;
  unsigned int v16 = 0;
  unsigned __int16 v14 = 0;
  __int16 v19 = 0;
LABEL_34:
  if (v18) {
    int v22 = v8;
  }
  else {
    int v22 = 0x10000;
  }
  size_t v23 = v16;
  size_t v24 = v16 + 36;
  uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock(a2, 0, v24, a2, 0, 0, v24, 1u, &theBuffer);
  if (!DataPointer)
  {
    uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    if (!DataPointer)
    {
      uint64_t v26 = dataPointerOut;
      *(_DWORD *)dataPointerOut = v24;
      *((_DWORD *)v26 + 1) = v17;
      *((void *)v26 + 1) = 0xFFFF000000000000;
      *((_WORD *)v26 + 8) = v19;
      *((_WORD *)v26 + 9) = 0;
      *((_DWORD *)v26 + 5) = 0;
      if (v17 != 1768973165 && v17 != 1718641517) {
        LOWORD(v11) = 2;
      }
      *((_WORD *)v26 + 12) = v11;
      *(_DWORD *)(v26 + 26) = 16;
      *((_WORD *)v26 + 15) = 0;
      *((_DWORD *)v26 + 8) = v22;
      if (v23 && v14) {
        memcpy(v26 + 36, v14, v23);
      }
      uint64_t DataPointer = 0;
      *a3 = theBuffer;
      CMBlockBufferRef theBuffer = 0;
    }
  }
  if (v14) {
    goto LABEL_47;
  }
LABEL_61:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return DataPointer;
}

uint64_t figSoundBridge_CreateNativeMovieSoundDescriptionFromASBD(uint64_t a1, CFAllocatorRef structureAllocator, char a3, CFTypeRef *a4)
{
  CFTypeRef cf = 0;
  dataPointerOut = 0;
  if (a4)
  {
    double v6 = *(double *)a1;
    int v7 = *(_DWORD *)(a1 + 8);
    unsigned int v8 = *(_DWORD *)(a1 + 12);
    unsigned int v9 = *(_DWORD *)(a1 + 16);
    int v10 = *(_DWORD *)(a1 + 20);
    int v11 = *(_DWORD *)(a1 + 24);
    unsigned int v12 = *(_DWORD *)(a1 + 28);
    unsigned int v13 = *(_DWORD *)(a1 + 32);
    *a4 = 0;
    if (v7 <= 1768829491)
    {
      if (v7 > 1718367025)
      {
        if (v7 == 1718367026) {
          goto LABEL_18;
        }
        int v14 = 1718367796;
      }
      else
      {
        if (!v7) {
          goto LABEL_18;
        }
        int v14 = 1313820229;
      }
    }
    else if (v7 <= 1918990111)
    {
      if (v7 == 1768829492) {
        goto LABEL_18;
      }
      int v14 = 1768829746;
    }
    else
    {
      if (v7 == 1918990112 || v7 == 1953984371) {
        goto LABEL_18;
      }
      int v14 = 1936684916;
    }
    if (v7 != v14 && v12)
    {
      if (v7 != 1819304813) {
        goto LABEL_31;
      }
      if (v11 && v13 && v9 && v10 == 1)
      {
        if (!(v8 & 8 | v13 & 7) && v9 == (v13 >> 3) * v12) {
          v8 |= 8u;
        }
LABEL_31:
        if ((a3 & 5) != 4 && v6 < 65536.0 && v12 <= 2)
        {
          if (v7 == 1819304813)
          {
            if (v13 && (v13 & 7) == 0 && (v8 & 8) != 0 && v8 <= 0xF)
            {
              if (v8)
              {
                int v18 = 0;
                __int16 v19 = 1;
                size_t v20 = 52;
                if (v13 == 32)
                {
LABEL_63:
                  int v17 = 1;
                  goto LABEL_47;
                }
                int v17 = 1;
                if (v13 == 64)
                {
LABEL_47:
                  int v37 = v17;
                  __int16 v38 = v19;
                  int v39 = v18;
                  uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock(structureAllocator, 0, v20, structureAllocator, 0, 0, v20, 1u, (CMBlockBufferRef *)&cf);
                  if (DataPointer) {
                    goto LABEL_19;
                  }
                  uint64_t DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)cf, 0, 0, 0, &dataPointerOut);
                  if (DataPointer) {
                    goto LABEL_19;
                  }
                  bzero(dataPointerOut, v20);
                  int v21 = dataPointerOut;
                  *(_DWORD *)dataPointerOut = v20;
                  *((_WORD *)v21 + 8) = v38;
                  *((_WORD *)v21 + 7) = -1;
                  int v22 = translateMP4AFormatID(v7);
                  if (v39)
                  {
                    *((void *)v21 + 3) = 0xFFFE00100003;
                    *((_DWORD *)v21 + 1) = v22;
                    *((_DWORD *)v21 + 8) = 0x10000;
                    *((_DWORD *)v21 + 9) = v20;
                    *((double *)v21 + 5) = v6;
                    *((_DWORD *)v21 + 12) = v12;
                    *((_DWORD *)v21 + 13) = 2130706432;
                    *((_DWORD *)v21 + 14) = v13;
                    *((_DWORD *)v21 + 15) = v8;
                    *((_DWORD *)v21 + 16) = v9;
                    *((_DWORD *)v21 + 17) = v10;
LABEL_100:
                    uint64_t DataPointer = 0;
                    *a4 = cf;
                    return DataPointer;
                  }
                  if (!v37) {
                    goto LABEL_100;
                  }
                  if (v22 != 1819304813)
                  {
                    *((_DWORD *)v21 + 1) = v22;
                    goto LABEL_90;
                  }
                  if ((v8 & 1) == 0)
                  {
                    int v23 = 1768829492;
                    if (v13 != 24)
                    {
                      if (v13 != 32)
                      {
                        if ((v8 & 4) != 0)
                        {
                          if ((v8 & 2) != 0) {
                            int v27 = 1953984371;
                          }
                          else {
                            int v27 = 1936684916;
                          }
                        }
                        else
                        {
                          int v27 = 1918990112;
                        }
                        *((_DWORD *)v21 + 1) = v27;
                        goto LABEL_90;
                      }
                      int v23 = 1768829746;
                    }
                    goto LABEL_67;
                  }
                  int v23 = 1718367026;
                  if (v13 == 32)
                  {
LABEL_67:
                    *((_DWORD *)v21 + 1) = v23;
                    goto LABEL_68;
                  }
                  if (v13 == 64)
                  {
                    int v23 = 1718367796;
                    goto LABEL_67;
                  }
                  int v28 = *((_DWORD *)v21 + 1);
                  if (v28 > 1768829491)
                  {
                    if (v28 == 1768829746) {
                      goto LABEL_68;
                    }
                    int v29 = 1768829492;
                  }
                  else
                  {
                    if (v28 == 1718367026) {
                      goto LABEL_68;
                    }
                    int v29 = 1718367796;
                  }
                  if (v28 != v29) {
                    goto LABEL_90;
                  }
LABEL_68:
                  if ((v8 & 2) != 0) {
                    goto LABEL_90;
                  }
                  uint64_t v25 = v21;
                  int v40 = 0;
                  CMBlockBufferRef theBuffer = 0;
                  uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock(structureAllocator, 0, 0x26uLL, structureAllocator, 0, 0, 0x26uLL, 1u, &theBuffer);
                  if (!DataPointer)
                  {
                    uint64_t v26 = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &v40);
                    if (v26)
                    {
                      uint64_t DataPointer = v26;
                      if (theBuffer) {
                        CFRelease(theBuffer);
                      }
                      goto LABEL_19;
                    }
                    unsigned int v31 = v40;
                    unsigned int v30 = theBuffer;
                    *(_OWORD *)int v40 = xmmword_18FE95E50;
                    unsigned int v32 = bswap32(*((_DWORD *)v25 + 1));
                    *(void *)(v31 + 30) = 0x8000000;
                    v31 += 30;
                    *(_DWORD *)(v31 - 14) = v32;
                    *(void *)(v31 - 10) = 0x61646E650A000000;
                    *((_WORD *)v31 - 1) = 256;
                    int v40 = v31;
                    uint64_t DataPointer = CMBlockBufferAppendBufferReference((CMBlockBufferRef)cf, v30, 0, 0x26uLL, 0);
                    if (theBuffer) {
                      CFRelease(theBuffer);
                    }
                    if (DataPointer) {
                      goto LABEL_19;
                    }
                    int v21 = v25;
                    *(_DWORD *)v25 += 38;
LABEL_90:
                    *((_WORD *)v21 + 12) = v12;
                    if ((unsigned __int16)v13 == 8) {
                      int v33 = v13;
                    }
                    else {
                      int v33 = 16;
                    }
                    *((_WORD *)v21 + 13) = v33;
                    *((_DWORD *)v21 + 8) = (v6 * 65536.0 + 0.5);
                    *((_DWORD *)v21 + 9) = v10;
                    int v34 = (int)((v33 + (((__int16)v33 >> 28) & 7)) << 16) >> 19;
                    if (v9) {
                      __int16 v35 = -1;
                    }
                    else {
                      __int16 v35 = -2;
                    }
                    if (v9) {
                      unsigned int v36 = v9;
                    }
                    else {
                      unsigned int v36 = 2;
                    }
                    *((_WORD *)v21 + 14) = v35;
                    *((_DWORD *)v21 + 11) = v36;
                    *((_DWORD *)v21 + 12) = v34;
                    *((_DWORD *)v21 + 10) = v36 / v12;
                    goto LABEL_100;
                  }
LABEL_19:
                  if (cf) {
                    CFRelease(cf);
                  }
                  return DataPointer;
                }
              }
              else if ((v8 & 4) != 0)
              {
                HIDWORD(v24) = v13;
                LODWORD(v24) = v13 - 8;
                if ((v24 >> 3) < 4)
                {
LABEL_62:
                  int v18 = 0;
                  __int16 v19 = 1;
                  size_t v20 = 52;
                  goto LABEL_63;
                }
              }
              else if (v13 == 8)
              {
                goto LABEL_62;
              }
            }
          }
          else if (v7 != 1718378851 && v7 != 1634492771 || (v8 & 6) == 0)
          {
            goto LABEL_62;
          }
        }
        int v17 = 0;
        int v18 = 1;
        __int16 v19 = 2;
        size_t v20 = 72;
        goto LABEL_47;
      }
    }
LABEL_18:
    uint64_t DataPointer = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_AddChannelLayoutExtensionToNativeSoundDescriptionBBuf(OpaqueCMBlockBuffer *a1, const __CFAllocator *a2, const void *a3, unsigned int a4)
{
  int v14 = 0;
  CFTypeRef cf = 0;
  if (a1)
  {
    size_t lengthAtOffsetOut = 0;
    dataPointerOut = 0;
    uint64_t DataPointer = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (!DataPointer)
    {
      if (lengthAtOffsetOut < 4) {
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
      unsigned int v10 = a4 + 12;
      uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock(a2, 0, a4 + 12, a2, 0, 0, a4 + 12, 1u, (CMBlockBufferRef *)&cf);
      if (!DataPointer)
      {
        uint64_t DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)cf, 0, 0, 0, &v14);
        if (!DataPointer)
        {
          *(_DWORD *)int v14 = bswap32(v10);
          int v11 = v14;
          v14 += 4;
          *((_DWORD *)v11 + 1) = 1851877475;
          v14 += 4;
          *(_DWORD *)int v14 = 0;
          v14 += 4;
          memcpy(v14, a3, a4);
          uint64_t DataPointer = figSoundBridge_EndianAudioChannelLayout_NtoB((int8x8_t *)v14, a4);
          if (!DataPointer)
          {
            uint64_t DataPointer = CMBlockBufferAppendBufferReference(a1, (CMBlockBufferRef)cf, 0, a4 + 12, 0);
            if (!DataPointer) {
              *(_DWORD *)dataPointerOut += v10;
            }
          }
        }
      }
    }
    if (cf) {
      CFRelease(cf);
    }
    return DataPointer;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_AddCookieExtensionToNativeSoundDescriptionBBuf(CMBlockBufferRef theBuffer, int a2, const __CFAllocator *a3, uint64_t a4, unsigned int a5, char a6)
{
  *(void *)&__n[1] = a4;
  CFTypeRef cf = 0;
  __n[0] = a5;
  BOOL v6 = (a6 & 1) == 0;
  if (theBuffer && (a4 || !a5))
  {
    if (!a5)
    {
      uint64_t DataPointer = 0;
LABEL_13:
      if (cf) {
        CFRelease(cf);
      }
      return DataPointer;
    }
    dataPointerOut = 0;
    int v33 = 0;
    size_t lengthAtOffsetOut = 0;
    uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (DataPointer)
    {
LABEL_9:
      if (*(void *)&__n[1] && *(void *)&__n[1] != a4) {
        CFAllocatorDeallocate(a3, *(void **)&__n[1]);
      }
      goto LABEL_13;
    }
    if (lengthAtOffsetOut < 4) {
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    }
    int v14 = translateMP4AFormatID(a2);
    if (v14 == 1836069985 || v14 == 1832149349)
    {
      uint64_t v15 = *(void *)&__n[1];
      int v16 = __n[0];
      CFAllocatorRef v17 = a3;
      int v18 = a2;
      int v19 = 0;
LABEL_23:
      uint64_t v20 = figSoundBridge_ConvertMP4AESDSMagicCookieToSoundDescriptionExtension(v17, v18, v19, v15, v16, a6, (char **)&__n[1], __n);
      goto LABEL_24;
    }
    if (figSoundBridge_isProtectedMP4AFormatUsingESDS(a2))
    {
      uint64_t v15 = *(void *)&__n[1];
      int v16 = __n[0];
      CFAllocatorRef v17 = a3;
      int v18 = a2;
      int v19 = 1;
      goto LABEL_23;
    }
    if (a2 > 1902537826)
    {
      if (a2 > 1935764849)
      {
        if (a2 == 1935764850 || a2 == 1935767394)
        {
          uint64_t v20 = figSoundBridge_ConvertAMRMagicCookieToSoundDescriptionExtension(a3, a2, *(_DWORD **)&__n[1], __n[0], a6, &__n[1], __n);
LABEL_24:
          uint64_t DataPointer = v20;
          int v21 = v6;
          if (v20) {
            goto LABEL_9;
          }
          goto LABEL_25;
        }
        int v26 = 2053923171;
        goto LABEL_42;
      }
      if (a2 != 1902537827)
      {
        int v26 = 1902928227;
LABEL_42:
        if (a2 != v26)
        {
LABEL_53:
          if (FigAudioCodecTypeIsAC3(a2)) {
            goto LABEL_54;
          }
          if (a2 <= 1885692722)
          {
            if (a2 == 1667575091) {
              goto LABEL_54;
            }
            int v28 = 1700998451;
          }
          else
          {
            if (a2 == 1885692723 || a2 == 1902469939) {
              goto LABEL_54;
            }
            int v28 = 2053464883;
          }
          if (a2 != v28)
          {
            uint64_t v29 = figSoundBridge_EncapsulatedMagicCookieFromCanonicalMagicCookie(a3, a2, a6, *(uint64_t *)&__n[1], __n[0], &__n[1], __n);
            if (v29)
            {
              if (a6)
              {
                int v21 = 0;
                if (a2 != 1634754915 && a2 != 1667330147)
                {
                  uint64_t DataPointer = v29;
                  if (a2 != 1902211171) {
                    goto LABEL_9;
                  }
                }
              }
              else
              {
                int v21 = 1;
              }
LABEL_25:
              unsigned int v22 = __n[0] + 8;
              if (v21) {
                size_t v23 = __n[0] + 8;
              }
              else {
                size_t v23 = __n[0];
              }
              uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock(a3, 0, v23, a3, 0, 0, v23, 1u, (CMBlockBufferRef *)&cf);
              if (!DataPointer)
              {
                uint64_t DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)cf, 0, 0, 0, &v33);
                if (!DataPointer)
                {
                  if (v21)
                  {
                    *(_DWORD *)int v33 = bswap32(v22);
                    unint64_t v24 = v33;
                    v33 += 4;
                    *((_DWORD *)v24 + 1) = 1702257015;
                    uint64_t v25 = v33 + 4;
                    v33 += 4;
                  }
                  else
                  {
                    uint64_t v25 = v33;
                  }
                  memcpy(v25, *(const void **)&__n[1], __n[0]);
                  uint64_t DataPointer = CMBlockBufferAppendBufferReference(theBuffer, (CMBlockBufferRef)cf, 0, v23, 0);
                  if (!DataPointer) {
                    *(_DWORD *)dataPointerOut += v23;
                  }
                }
              }
              goto LABEL_9;
            }
            int v21 = 0;
            if (a2 == 1634754915 || a2 == 1667330147 || a2 == 1902211171) {
              goto LABEL_25;
            }
LABEL_56:
            int v21 = v6;
            goto LABEL_25;
          }
LABEL_54:
          unint64_t v30 = 0;
          figSoundBridge_AreAtomsWellFormed(*(uint64_t *)&__n[1], __n[0], v6, &v30);
          if (v30 < __n[0]) {
            __n[0] = v30;
          }
          goto LABEL_56;
        }
        goto LABEL_48;
      }
LABEL_47:
      uint64_t v20 = figSoundBridge_ConvertFLACMagicCookieToSoundDescriptionExtension(a3, *(unsigned int **)&__n[1], __n[0], (unsigned int **)&__n[1], __n);
      goto LABEL_24;
    }
    if (a2 > 1668047202)
    {
      if (a2 != 1668047203)
      {
        int v27 = 1718378851;
LABEL_46:
        if (a2 != v27) {
          goto LABEL_53;
        }
        goto LABEL_47;
      }
    }
    else if (a2 != 1634492771)
    {
      int v27 = 1667656803;
      goto LABEL_46;
    }
LABEL_48:
    uint64_t v20 = figSoundBridge_ConvertALACMagicCookieToSoundDescriptionExtension(a3, *(_DWORD **)&__n[1], __n[0], a6, &__n[1], __n);
    goto LABEL_24;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_AddSamplingRateBoxIfNecessaryToNativeISOAudioSampleEntry(OpaqueCMBlockBuffer *a1, const __CFAllocator *a2, uint64_t a3)
{
  unsigned int v12 = 0;
  CFTypeRef cf = 0;
  if (a1)
  {
    if (*(double *)a3 < 65536.0 || *(_DWORD *)(a3 + 8) != 1819304813) {
      return 0;
    }
    size_t lengthAtOffsetOut = 0;
    dataPointerOut = 0;
    uint64_t DataPointer = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (DataPointer)
    {
LABEL_5:
      if (cf) {
        CFRelease(cf);
      }
      return DataPointer;
    }
    if (lengthAtOffsetOut >= 4)
    {
      uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock(a2, 0, 0x10uLL, a2, 0, 0, 0x10uLL, 1u, (CMBlockBufferRef *)&cf);
      if (!DataPointer)
      {
        uint64_t DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)cf, 0, 0, 0, &v12);
        if (!DataPointer)
        {
          *(_DWORD *)unsigned int v12 = 0x10000000;
          unsigned int v8 = v12;
          v12 += 4;
          *((_DWORD *)v8 + 1) = 1952543347;
          v12 += 4;
          *(_DWORD *)unsigned int v12 = 0;
          unsigned int v9 = v12;
          v12 += 4;
          *((_DWORD *)v9 + 1) = bswap32(*(double *)a3);
          uint64_t DataPointer = CMBlockBufferAppendBufferReference(a1, (CMBlockBufferRef)cf, 0, 0x10uLL, 0);
          if (!DataPointer) {
            *(_DWORD *)dataPointerOut += 16;
          }
        }
      }
      goto LABEL_5;
    }
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_AddISOChannelLayoutBoxToNativeISOAudioSampleEntryIfEligible(OpaqueCMBlockBuffer *a1, const __CFAllocator *a2, CMFormatDescriptionRef desc)
{
  uint64_t v36 = 0;
  int v37 = 0;
  dataPointerOut = 0;
  __int16 v35 = 0;
  CFIndex size = 0;
  size_t lengthAtOffsetOut = 0;
  CFTypeRef cf = 0;
  CFPropertyListRef Extension = CMFormatDescriptionGetExtension(desc, @"SampleDescriptionExtensionAtoms");
  uint64_t appended = (uint64_t)Extension;
  if (Extension)
  {
    CFTypeID v8 = CFGetTypeID(Extension);
    if (v8 == CFDictionaryGetTypeID())
    {
      if (CFDictionaryGetValue((CFDictionaryRef)appended, @"chnl")) {
        goto LABEL_52;
      }
    }
  }
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(desc);
  if (StreamBasicDescription->mFormatID == 1819304813 && StreamBasicDescription->mChannelsPerFrame >= 2)
  {
    uint64_t RichestDecodableFormatAndChannelLayout = CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(desc, &v37, &v36, &v35);
    if (RichestDecodableFormatAndChannelLayout) {
      goto LABEL_64;
    }
    int v11 = 1;
  }
  else
  {
    if (!appended) {
      goto LABEL_53;
    }
    CFTypeID v12 = CFGetTypeID((CFTypeRef)appended);
    if (v12 != CFDictionaryGetTypeID()) {
      goto LABEL_52;
    }
    uint64_t v13 = 0;
    while (!CFDictionaryGetValue((CFDictionaryRef)appended, *(const void **)((char *)&off_1E5679668 + v13)))
    {
      v13 += 8;
      if (v13 == 48) {
        goto LABEL_52;
      }
    }
    int v11 = 0;
    if (CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(desc, &v37, &v36, &v35)) {
      goto LABEL_52;
    }
  }
  if (!a1) {
    goto LABEL_62;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if (DataPointer)
  {
LABEL_65:
    uint64_t appended = DataPointer;
    goto LABEL_53;
  }
  if (lengthAtOffsetOut <= 0x23)
  {
LABEL_62:
    uint64_t RichestDecodableFormatAndChannelLayout = 4294954584;
    goto LABEL_64;
  }
  uint64_t v15 = v35;
  if (v37->mASBD.mFormatID != 1819304813 || v35 == 0)
  {
    int CreationChannelLayoutSignificance = FigAudioFormatDescriptionGetCreationChannelLayoutSignificance((uint64_t)desc);
    uint64_t v15 = v35;
  }
  else
  {
    int CreationChannelLayoutSignificance = 2;
  }
  memset(v30, 0, sizeof(v30));
  unint64_t v18 = v36;
  if (v15 && v36) {
    goto LABEL_31;
  }
  UInt32 mChannelsPerFrame = v37->mASBD.mChannelsPerFrame;
  if (mChannelsPerFrame == 1)
  {
    int v20 = 6553601;
  }
  else
  {
    if (mChannelsPerFrame != 2) {
      goto LABEL_31;
    }
    int v20 = 6619138;
  }
  LODWORD(v30[0]) = v20;
  uint64_t v15 = v30;
  __int16 v35 = v30;
  unint64_t v18 = 32;
  uint64_t v36 = 32;
  int CreationChannelLayoutSignificance = 2;
LABEL_31:
  if (!v15 || v18 < 4 || HIDWORD(v18)) {
    goto LABEL_51;
  }
  if (*v15 == 0x10000)
  {
    unsigned int v22 = v15[1];
    if (v22)
    {
      int v21 = 0;
      do
      {
        v21 += v22 & 1;
        BOOL v23 = v22 >= 2;
        v22 >>= 1;
      }
      while (v23);
    }
    else
    {
      int v21 = 0;
    }
  }
  else
  {
    int v21 = *v15 ? (unsigned __int16)*v15 : v15[2];
  }
  BOOL v24 = v21 != v37->mASBD.mChannelsPerFrame || CreationChannelLayoutSignificance == 3;
  if (v24 || CreationChannelLayoutSignificance == 0)
  {
LABEL_51:
    if (!v11) {
      goto LABEL_52;
    }
    uint64_t RichestDecodableFormatAndChannelLayout = 4294954586;
LABEL_64:
    uint64_t DataPointer = FigSignalErrorAt(RichestDecodableFormatAndChannelLayout, 0, 0, 0, 0, 0, 0);
    goto LABEL_65;
  }
  uint64_t RichestDecodableFormatAndChannelLayout = AudioToolbox_AudioFormatGetPropertyInfo(1668047726, v18, (uint64_t)v15, (uint64_t)&size + 4);
  if (RichestDecodableFormatAndChannelLayout)
  {
    if (RichestDecodableFormatAndChannelLayout != 1886547824) {
      goto LABEL_64;
    }
LABEL_52:
    uint64_t appended = 0;
    goto LABEL_53;
  }
  int v27 = CFAllocatorAllocate(a2, HIDWORD(size), 0);
  if (!v27)
  {
    uint64_t RichestDecodableFormatAndChannelLayout = 4294954583;
    goto LABEL_64;
  }
  int v28 = v27;
  LODWORD(size) = HIDWORD(size);
  uint64_t Property = AudioToolbox_AudioFormatGetProperty(1668047726, v36, (uint64_t)v35, (uint64_t)&size, (uint64_t)v27);
  if (Property
    || (uint64_t Property = CMBlockBufferCreateWithMemoryBlock(a2, v28, HIDWORD(size), a2, 0, 0, size, 0, (CMBlockBufferRef *)&cf), Property))
  {
    uint64_t appended = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
    CFAllocatorDeallocate(a2, v28);
  }
  else
  {
    uint64_t appended = CMBlockBufferAppendBufferReference(a1, (CMBlockBufferRef)cf, 0, size, 0);
    if (!appended) {
      *(_DWORD *)dataPointerOut += size;
    }
  }
LABEL_53:
  if (cf) {
    CFRelease(cf);
  }
  return appended;
}

uint64_t figSoundBridge_AddMiscellaneousSampleDescriptionExtensionsToNativeSoundDescriptionBBuf(OpaqueCMBlockBuffer *a1, const opaqueCMFormatDescription *a2, const __CFAllocator *a3)
{
  CFTypeRef cf = 0;
  size_t v14 = 0;
  uint64_t DataPointer = figBridge_ConvertMiscellaneousSampleDescriptionExtensionsToAtoms(a2, &v14, 0);
  if (!DataPointer)
  {
    size_t v7 = v14;
    if (v14)
    {
      size_t lengthAtOffsetOut = 0;
      dataPointerOut = 0;
      unsigned int v9 = 0;
      uint64_t DataPointer = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
      if (!DataPointer)
      {
        if (lengthAtOffsetOut < 4) {
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        }
        uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock(a3, 0, v7, a3, 0, 0, v7, 1u, (CMBlockBufferRef *)&cf);
        if (!DataPointer)
        {
          uint64_t DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)cf, 0, 0, 0, &v9);
          if (!DataPointer)
          {
            uint64_t DataPointer = figBridge_ConvertMiscellaneousSampleDescriptionExtensionsToAtoms(a2, &v10, (uint64_t)v9);
            if (!DataPointer)
            {
              uint64_t DataPointer = CMBlockBufferAppendBufferReference(a1, (CMBlockBufferRef)cf, 0, v7, 0);
              if (!DataPointer) {
                *(_DWORD *)dataPointerOut += v7;
              }
            }
          }
        }
      }
      if (cf) {
        CFRelease(cf);
      }
    }
  }
  return DataPointer;
}

OSStatus CMSwapHostEndianSoundDescriptionToBig(uint8_t *soundDescriptionData, size_t soundDescriptionSize)
{
  return figSoundBridge_FlipSoundDescriptionData((uint64_t)soundDescriptionData, soundDescriptionSize, 1);
}

Boolean CMDoesBigEndianSoundDescriptionRequireLegacyCBRSampleTableLayout(CMBlockBufferRef soundDescriptionBlockBuffer, CMSoundDescriptionFlavor flavor)
{
  int destination = 0;
  if (CMBlockBufferCopyDataBytes(soundDescriptionBlockBuffer, 0x10uLL, 2uLL, (char *)&destination + 2)) {
    return 0;
  }
  HIWORD(destination) = bswap32(HIWORD(destination)) >> 16;
  if (flavor)
  {
    if (!CFEqual(@"QuickTimeMovie", flavor)
      && !CFEqual(@"QuickTimeMovieV2", flavor)
      && (HIWORD(destination) != 1 || figSoundBridge_IsBlockBufferISOv1(soundDescriptionBlockBuffer, 1)))
    {
      return 0;
    }
  }
  if (CMBlockBufferCopyDataBytes(soundDescriptionBlockBuffer, 0x1CuLL, 2uLL, &destination)) {
    return 1;
  }
  if (SHIWORD(destination) > 1) {
    return 0;
  }
  return (__int16)destination != -257;
}

OSStatus CMSwapBigEndianSoundDescriptionToHost(uint8_t *soundDescriptionData, size_t soundDescriptionSize)
{
  return figSoundBridge_FlipSoundDescriptionData((uint64_t)soundDescriptionData, soundDescriptionSize, 0);
}

uint64_t figSoundBridge_FlipSoundDescriptionData(uint64_t a1, unint64_t a2, int a3)
{
  if (!a1)
  {
    uint64_t v9 = 4294954584;
    goto LABEL_18;
  }
  if (a2 <= 0x11) {
    goto LABEL_16;
  }
  unsigned int v5 = *(unsigned __int16 *)(a1 + 16);
  unsigned int v6 = bswap32(*(_DWORD *)a1);
  unsigned int v7 = bswap32(v5) >> 16;
  if (a3)
  {
    unsigned int v8 = *(_DWORD *)a1;
  }
  else
  {
    LOWORD(v5) = v7;
    unsigned int v8 = v6;
  }
  if ((unsigned __int16)v5 >= 3u) {
    goto LABEL_16;
  }
  if ((unsigned __int16)v5 == 1) {
    LOWORD(v5) = figSoundBridge_IsDataISOv1(a1, a2, a3 == 0) == 0;
  }
  if ((int)v8 > a2
    || !(_WORD)v5 && v8 < 0x24
    || (unsigned __int16)v5 == 1 && v8 < 0x34
    || (unsigned __int16)v5 == 2 && v8 <= 0x47)
  {
LABEL_16:
    uint64_t v9 = 4294954582;
LABEL_18:
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  int8x16_t v11 = 0uLL;
  if ((unsigned __int16)v5 == 1) {
    int8x16_t v11 = *(int8x16_t *)(a1 + 36);
  }
  int8x8_t v12 = vrev32_s8(*(int8x8_t *)a1);
  unsigned int v13 = bswap32(*(_DWORD *)(a1 + 8));
  int8x8_t v14 = vrev16_s8(*(int8x8_t *)(a1 + 12));
  unsigned int v15 = bswap32(*(_DWORD *)(a1 + 20));
  int8x8_t v16 = vrev16_s8(*(int8x8_t *)(a1 + 24));
  unsigned int v17 = bswap32(*(_DWORD *)(a1 + 32));
  if ((unsigned __int16)v5 == 1)
  {
    *(int8x8_t *)a1 = v12;
    *(_DWORD *)(a1 + 8) = v13;
    *(int8x8_t *)(a1 + 12) = v14;
    *(_DWORD *)(a1 + 20) = v15;
    *(int8x8_t *)(a1 + 24) = v16;
    *(_DWORD *)(a1 + 32) = v17;
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(v11);
  }
  else
  {
    *(int8x8_t *)a1 = v12;
    *(_DWORD *)(a1 + 8) = v13;
    *(int8x8_t *)(a1 + 12) = v14;
    *(_DWORD *)(a1 + 20) = v15;
    *(int8x8_t *)(a1 + 24) = v16;
    *(_DWORD *)(a1 + 32) = v17;
    if ((unsigned __int16)v5 == 2)
    {
      unint64_t v18 = bswap64(*(void *)(a1 + 40));
      int8x16_t v19 = vrev32q_s8(*(int8x16_t *)(a1 + 48));
      int8x8_t v20 = vrev32_s8(*(int8x8_t *)(a1 + 64));
      *(_DWORD *)(a1 + 36) = bswap32(*(_DWORD *)(a1 + 36));
      *(void *)(a1 + 40) = v18;
      *(int8x16_t *)(a1 + 48) = v19;
      *(int8x8_t *)(a1 + 64) = v20;
    }
  }
  return 0;
}

uint64_t figSoundBridge_IsDataISOv1(uint64_t a1, unint64_t a2, int a3)
{
  BOOL v3 = 0;
  if (a1 && a2 >= 0x24)
  {
    signed int v6 = *(_DWORD *)a1;
    unsigned int v7 = *(unsigned __int16 *)(a1 + 16);
    unsigned int v8 = bswap32(*(_DWORD *)a1);
    unsigned int v9 = bswap32(v7) >> 16;
    if (a3)
    {
      signed int v6 = v8;
      LOWORD(v7) = v9;
    }
    uint64_t v10 = v6;
    if (v6 < 0x24 || v6 > a2 || (unsigned __int16)v7 != 1) {
      return 0;
    }
    if (v6 == 36) {
      return 1;
    }
    BOOL v14 = 1;
    BOOL v15 = figSoundBridge_AreAtomsWellFormed(a1 + 36, v6 - 36, 1, 0);
    if (v10 >= 0x35)
    {
      BOOL v3 = 1;
      BOOL v16 = figSoundBridge_AreAtomsWellFormed(a1 + 52, v10 - 52, 1, 0);
      BOOL v14 = !v16;
      if (v15 && !v16) {
        return v3;
      }
      if (!v15 && v16) {
        return 0;
      }
    }
    unsigned int v17 = *(_DWORD *)(a1 + 4);
    unsigned int v18 = bswap32(v17);
    if (a3) {
      unsigned int v17 = v18;
    }
    BOOL v3 = 1;
    if (v17 != 1716281667 && v17 != 1718641517 && v17 != 1768973165)
    {
      unsigned int v19 = *(unsigned __int16 *)(a1 + 28);
      unsigned int v20 = bswap32(v19) >> 16;
      if (a3) {
        LOWORD(v19) = v20;
      }
      if ((unsigned __int16)v19 > 0xFFFDu) {
        return 0;
      }
      if (!v15)
      {
        if (v14) {
          return 0;
        }
LABEL_36:
        figSoundBridge_IsKnownAtomFoundInExtension(a1 + 52, v10 - 52, 1);
        return 0;
      }
      IsKnownAtomFoundInCFPropertyListRef Extension = figSoundBridge_IsKnownAtomFoundInExtension(a1 + 36, v10 - 36, 0);
      BOOL v3 = IsKnownAtomFoundInExtension != 0;
      if (IsKnownAtomFoundInExtension) {
        char v22 = 1;
      }
      else {
        char v22 = v14;
      }
      if ((v22 & 1) == 0) {
        goto LABEL_36;
      }
    }
  }
  return v3;
}

uint64_t figSoundBridge_IsBlockBufferISOv1(OpaqueCMBlockBuffer *a1, int a2)
{
  CMBlockBufferRef theBuffer = 0;
  dataPointerOut = 0;
  Datasize_t Length = CMBlockBufferGetDataLength(a1);
  if (CMBlockBufferIsRangeContiguous(a1, 0, 0))
  {
    unsigned int v5 = a1;
  }
  else
  {
    if (CMBlockBufferCreateContiguous(0, a1, 0, 0, 0, 0, 0, &theBuffer)) {
      goto LABEL_10;
    }
    unsigned int v5 = theBuffer;
  }
  if (!CMBlockBufferGetDataPointer(v5, 0, 0, 0, &dataPointerOut))
  {
    IsDataISOunsigned int v1 = figSoundBridge_IsDataISOv1((uint64_t)dataPointerOut, DataLength, a2);
    goto LABEL_7;
  }
LABEL_10:
  IsDataISOunsigned int v1 = 0;
LABEL_7:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return IsDataISOv1;
}

uint64_t FigAudioCodecTypeIsDecodable(int a1)
{
  LODWORD(size) = 0;
  uint64_t PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1633904998, 0, 0, (uint64_t)&size);
  if (PropertyInfo)
  {
    BOOL v3 = 0;
    goto LABEL_15;
  }
  if (size < 5)
  {
    BOOL v3 = 0;
    uint64_t PropertyInfo = 0xFFFFFFFFLL;
    goto LABEL_15;
  }
  BOOL v3 = (char *)malloc_type_calloc(1uLL, size, 0x2EB930uLL);
  if (!v3)
  {
    uint64_t PropertyInfo = 4294954585;
    goto LABEL_15;
  }
  uint64_t PropertyInfo = AudioToolbox_AudioFormatGetProperty(1633904998, 0, 0, (uint64_t)&size, (uint64_t)v3);
  if (PropertyInfo)
  {
LABEL_15:
    FigSignalErrorAt(PropertyInfo, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  if (size < 4)
  {
LABEL_9:
    uint64_t v5 = 0;
    goto LABEL_11;
  }
  uint64_t v4 = 0;
  while (*(_DWORD *)&v3[v4] != a1)
  {
    v4 += 4;
    if ((size & 0xFFFFFFFC) == v4) {
      goto LABEL_9;
    }
  }
  uint64_t v5 = 1;
LABEL_11:
  free(v3);
  return v5;
}

uint64_t ReadESDSAtomAndData(uint64_t a1, CMBlockBufferRef *a2, CMBlockBufferRef *a3)
{
  CMBlockBufferRef theBuffer = 0;
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v5 = FigAtomStreamReadCurrentAtomDataAndCreateBBuf(a1, 4, 0, &theBuffer);
  if (v5)
  {
    uint64_t v12 = v5;
    uint64_t v10 = 0;
  }
  else
  {
    Datasize_t Length = CMBlockBufferGetDataLength(theBuffer);
    size_t v7 = DataLength + 8;
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
    unsigned int v9 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF90], DataLength + 8, 0);
    uint64_t v10 = v9;
    if (v9)
    {
      *unsigned int v9 = bswap32(v7);
      v9[1] = 1935962981;
      uint64_t v11 = CMBlockBufferCopyDataBytes(theBuffer, 0, DataLength, v9 + 2);
      if (v11)
      {
        uint64_t v12 = v11;
      }
      else
      {
        uint64_t v12 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v10, v7, v8, 0, 0, v7, 0, &blockBufferOut);
        if (!v12)
        {
          uint64_t v10 = 0;
          *a2 = blockBufferOut;
          *a3 = theBuffer;
          CMBlockBufferRef theBuffer = 0;
          CMBlockBufferRef blockBufferOut = 0;
          goto LABEL_6;
        }
        if (blockBufferOut) {
          CFRelease(blockBufferOut);
        }
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
  }
  if (theBuffer) {
    CFRelease(theBuffer);
  }
LABEL_6:
  free(v10);
  return v12;
}

uint64_t figSoundBridge_GetDecodeFormatIDForUnknownExtensionType(int a1, uint64_t a2, _DWORD *a3)
{
  int v6 = *(_DWORD *)(a2 + 4);
  if ((*(unsigned char *)a2 & 1) != 0 && (unsigned int v7 = *(_DWORD *)(a2 + 12) - 1, v7 <= 2)) {
    int v8 = dword_18FE95ED4[v7];
  }
  else {
    int v8 = 1299148630;
  }
  int v18 = v8;
  int v19 = 4;
  int v20 = v6;
  int v16 = 0;
  uint64_t v15 = 0;
  int v17 = 0;
  if (!AudioToolbox_AudioFormatGetPropertyInfo(1701733230, 12, (uint64_t)&v18, (uint64_t)&v17))
  {
    if (v17 == 12)
    {
      uint64_t Property = AudioToolbox_AudioFormatGetProperty(1701733230, 12, (uint64_t)&v18, (uint64_t)&v17, (uint64_t)&v15);
      if (!Property)
      {
        int v10 = v16;
        return v10 == a1 && !figSoundBridge_GetDecodeFormatIDForCodingName(v6, a2, a3);
      }
    }
    else
    {
      uint64_t Property = 4294954584;
    }
    if (!FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0))
    {
      int v10 = 0;
      return v10 == a1 && !figSoundBridge_GetDecodeFormatIDForCodingName(v6, a2, a3);
    }
  }
  if ((*(unsigned char *)a2 & 1) != 0 && (unsigned int v12 = *(_DWORD *)(a2 + 12) - 1, v12 <= 2)) {
    int v13 = dword_18FE95ED4[v12];
  }
  else {
    int v13 = 1299148630;
  }
  int v18 = v13;
  int v19 = 4;
  int v20 = a1;
  LODWORD(v15) = 0;
  int v17 = 0;
  if (AudioToolbox_AudioFormatGetPropertyInfo(1768187246, 12, (uint64_t)&v18, (uint64_t)&v17)) {
    return 0;
  }
  if (v17 == 4)
  {
    uint64_t v14 = AudioToolbox_AudioFormatGetProperty(1768187246, 12, (uint64_t)&v18, (uint64_t)&v17, (uint64_t)&v15);
    if (!v14)
    {
      *a3 = v15;
      return 1;
    }
  }
  else
  {
    uint64_t v14 = 4294954584;
  }
  return !FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_TransformToCanonicalMagicCookieBBuf(const __CFAllocator *a1, int a2, uint64_t a3, CMBlockBufferRef *a4)
{
  dataPointerOut = 0;
  CMBlockBufferRef blockBufferOut = 0;
  size_t lengthAtOffsetOut = 0;
  uint64_t DataPointer = CMBlockBufferGetDataPointer(*a4, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if (DataPointer) {
    return DataPointer;
  }
  if ((*(unsigned char *)a3 & 1) != 0 && (unsigned int v9 = *(_DWORD *)(a3 + 12) - 1, v9 <= 2)) {
    int v10 = dword_18FE95ED4[v9];
  }
  else {
    int v10 = 1299148630;
  }
  LODWORD(size_4) = a2;
  HIDWORD(size_4) = v10;
  BOOL v24 = dataPointerOut;
  uint64_t v25 = lengthAtOffsetOut;
  unsigned int size = 0;
  uint64_t DataPointer = AudioToolbox_AudioFormatGetPropertyInfo(1835230563, 24, (uint64_t)&size_4, (uint64_t)&size);
  if (DataPointer) {
    return DataPointer;
  }
  if (!size)
  {
    uint64_t v18 = 4294954584;
LABEL_19:
    uint64_t v16 = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
LABEL_21:
    if (v16) {
      return v16;
    }
    unsigned int v12 = 0;
    size_t v14 = 0;
    goto LABEL_11;
  }
  uint64_t v11 = CFAllocatorAllocate(a1, size, 0);
  if (!v11)
  {
    uint64_t v18 = 4294954583;
    goto LABEL_19;
  }
  unsigned int v12 = v11;
  uint64_t Property = AudioToolbox_AudioFormatGetProperty(1835230563, 24, (uint64_t)&size_4, (uint64_t)&size, (uint64_t)v11);
  if (Property)
  {
    uint64_t v16 = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
    CFAllocatorDeallocate(a1, v12);
    goto LABEL_21;
  }
  size_t v14 = size;
LABEL_11:
  uint64_t v15 = CMBlockBufferCreateWithMemoryBlock(a1, v12, v14, a1, 0, 0, v14, 1u, &blockBufferOut);
  if (v15)
  {
    uint64_t v16 = v15;
    if (blockBufferOut) {
      CFRelease(blockBufferOut);
    }
    if (v12) {
      CFAllocatorDeallocate(a1, v12);
    }
  }
  else
  {
    if (*a4) {
      CFRelease(*a4);
    }
    uint64_t v16 = 0;
    *a4 = blockBufferOut;
  }
  return v16;
}

uint64_t figSoundBridge_GetDecodeFormatIDForCodingName(int a1, uint64_t a2, _DWORD *a3)
{
  if ((*(unsigned char *)a2 & 1) != 0 && (int v4 = *(_DWORD *)(a2 + 12) - 1, v4 <= 2)) {
    int v5 = dword_18FE95ED4[v4];
  }
  else {
    int v5 = 1299148630;
  }
  v9[0] = v5;
  v9[1] = 4;
  v9[2] = a1;
  int v7 = 0;
  int v8 = 0;
  uint64_t result = AudioToolbox_AudioFormatGetPropertyInfo(1768186734, 12, (uint64_t)v9, (uint64_t)&v7);
  if (!result)
  {
    if (v7 == 4)
    {
      uint64_t result = AudioToolbox_AudioFormatGetProperty(1768186734, 12, (uint64_t)v9, (uint64_t)&v7, (uint64_t)&v8);
      if (!result)
      {
        *a3 = v8;
        return result;
      }
    }
    else
    {
      uint64_t result = 4294954584;
    }
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t figSoundBridge_CreateMagicCookieBBufFromALACBBuf(const __CFAllocator *a1, OpaqueCMBlockBuffer *a2, void *a3)
{
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v12 = 0;
  memset(v11, 0, sizeof(v11));
  int v10 = 1667329121;
  uint64_t v5 = CMBlockBufferCreateEmpty(a1, 4u, 0, &blockBufferOut);
  if (v5 || (uint64_t v5 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)v11), v5))
  {
    uint64_t v8 = v5;
  }
  else
  {
    FigAtomWriterBeginAtom((uint64_t)v11, 0x66726D61u, 0);
    FigAtomWriterAppendData((uint64_t)v11, (uint64_t)&v10, 4);
    FigAtomWriterEndAtom((uint64_t)v11);
    FigAtomWriterBeginAtom((uint64_t)v11, 0x616C6163u, 0);
    Datasize_t Length = CMBlockBufferGetDataLength(a2);
    FigAtomWriterAppendBlockBufferData((uint64_t)v11, a2, 8uLL, DataLength - 8);
    FigAtomWriterEndAtom((uint64_t)v11);
    FigAtomWriterBeginAtom((uint64_t)v11, 0, 0);
    FigAtomWriterEndAtom((uint64_t)v11);
    int v7 = blockBufferOut;
    if (blockBufferOut) {
      int v7 = (void *)CFRetain(blockBufferOut);
    }
    uint64_t v8 = 0;
    *a3 = v7;
  }
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v8;
}

uint64_t figSoundBridge_CreateMagicCookieBBufFromAMRBBuf(const __CFAllocator *a1, unsigned int a2, OpaqueCMBlockBuffer *a3, void *a4)
{
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  unsigned int v13 = 0;
  __int16 v12 = 0;
  uint64_t v7 = CMBlockBufferCreateEmpty(a1, 4u, 0, &blockBufferOut);
  if (v7 || (uint64_t v7 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)v14), v7))
  {
    uint64_t v10 = v7;
  }
  else
  {
    FigAtomWriterBeginAtom((uint64_t)v14, 0x66726D61u, 0);
    unsigned int v13 = bswap32(a2);
    FigAtomWriterAppendData((uint64_t)v14, (uint64_t)&v13, 4);
    FigAtomWriterEndAtom((uint64_t)v14);
    FigAtomWriterBeginAtom((uint64_t)v14, 0x656E6461u, 0);
    FigAtomWriterAppendData((uint64_t)v14, (uint64_t)&v12, 2);
    FigAtomWriterEndAtom((uint64_t)v14);
    FigAtomWriterBeginAtom((uint64_t)v14, 0x73616D72u, 0);
    Datasize_t Length = CMBlockBufferGetDataLength(a3);
    FigAtomWriterAppendBlockBufferData((uint64_t)v14, a3, 0, DataLength);
    FigAtomWriterEndAtom((uint64_t)v14);
    FigAtomWriterBeginAtom((uint64_t)v14, 0, 0);
    FigAtomWriterEndAtom((uint64_t)v14);
    unsigned int v9 = blockBufferOut;
    if (blockBufferOut) {
      unsigned int v9 = (void *)CFRetain(blockBufferOut);
    }
    uint64_t v10 = 0;
    *a4 = v9;
  }
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v10;
}

BOOL figSoundBridge_isAACUsingESDSinMOV(unsigned int a1)
{
  if (a1 - 1633772389 > 0xE) {
    goto LABEL_6;
  }
  int v1 = 1 << (a1 - 101);
  if ((v1 & 0x4888) != 0) {
    return 1;
  }
  if ((v1 & 7) != 0) {
    return 0;
  }
LABEL_6:
  if (a1 == 1633772320) {
    return 1;
  }
  return a1 >> 8 == 6381923;
}

uint64_t figSoundBridge_GetMP4ASBDFromESDSDataBBuf(uint64_t a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  CFIndex size = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v28 = 0u;
  CMBlockBufferRef blockBufferOut = 0;
  int v26 = 0;
  dataPointerOut = 0;
  size_t lengthAtOffsetOut = 0;
  uint64_t DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(a1 + 112), 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if (DataPointer) {
    goto LABEL_62;
  }
  if (HIDWORD(lengthAtOffsetOut))
  {
    uint64_t DataPointer = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_62;
  }
  *((void *)&v30 + 1) = dataPointerOut;
  LODWORD(size) = lengthAtOffsetOut;
  int v26 = 56;
  if (AudioToolbox_AudioFormatGetProperty(1702061673, lengthAtOffsetOut, (uint64_t)dataPointerOut, (uint64_t)&v26, (uint64_t)&v28))
  {
    int v26 = 40;
    uint64_t Property = AudioToolbox_AudioFormatGetProperty(1702064996, lengthAtOffsetOut, (uint64_t)dataPointerOut, (uint64_t)&v26, a2);
    if (Property) {
      goto LABEL_48;
    }
    goto LABEL_29;
  }
  long long v6 = v29;
  *(_OWORD *)a2 = v28;
  *(_OWORD *)(a2 + 16) = v6;
  *(void *)(a2 + 32) = v30;
  if (size && *((void *)&v30 + 1))
  {
    if (lengthAtOffsetOut > size
      && *((void *)&v30 + 1) >= (unint64_t)dataPointerOut
      && (unint64_t)&dataPointerOut[lengthAtOffsetOut - *((void *)&v30 + 1)] >= size)
    {
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
      uint64_t v8 = (char *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF90], size, 0);
      if (!v8)
      {
LABEL_35:
        uint64_t Property = 0;
        goto LABEL_54;
      }
      uint64_t v9 = CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 112), *((void *)&v30 + 1) - (void)dataPointerOut, size, v8);
      if (v9) {
        goto LABEL_60;
      }
      uint64_t v9 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8, size, v7, 0, 0, size, 0, &blockBufferOut);
      if (v9) {
        goto LABEL_60;
      }
    }
    goto LABEL_20;
  }
  uint64_t v10 = *(void **)(a1 + 104);
  if (v10) {
    uint64_t v10 = (void *)CFRetain(v10);
  }
  CMBlockBufferRef blockBufferOut = (CMBlockBufferRef)v10;
  CFAllocatorRef v11 = CFGetAllocator(v10);
  uint64_t DataPointer = figSoundBridge_TransformToCanonicalMagicCookieBBuf(v11, SDWORD2(v28), a1, &blockBufferOut);
  if (DataPointer)
  {
LABEL_62:
    uint64_t Property = DataPointer;
    goto LABEL_53;
  }
  if (*(_DWORD *)(a2 + 8) == 1633772320) {
    *(unsigned char *)(a1 + 296) = 1;
  }
LABEL_20:
  CMBlockBufferRef v12 = blockBufferOut;
  if (blockBufferOut)
  {
    unsigned int v13 = *(const void **)(a1 + 264);
    *(void *)(a1 + 264) = blockBufferOut;
    CFRetain(v12);
    if (v13) {
      CFRelease(v13);
    }
    if (blockBufferOut)
    {
      CFRelease(blockBufferOut);
      CMBlockBufferRef blockBufferOut = 0;
    }
    size_t v14 = *(OpaqueCMBlockBuffer **)(a1 + 264);
    if (v14)
    {
      *(void *)&long long totalLengthOut = 0;
      CMBlockBufferGetDataPointer(v14, 0, 0, (size_t *)&totalLengthOut, (char **)(a1 + 272));
      *(_DWORD *)(a1 + 280) = totalLengthOut;
    }
    if (DWORD2(v28) == 1987015266)
    {
      uint64_t Property = 1718449215;
      goto LABEL_48;
    }
  }
LABEL_29:
  if (*(_DWORD *)(a2 + 8) != 1633772320)
  {
    uint64_t v8 = 0;
    goto LABEL_35;
  }
  uint64_t Property = 0;
  uint64_t v8 = 0;
  int v15 = *(_DWORD *)(a2 + 12);
  if (v15 > 28)
  {
    if (v15 == 29)
    {
      int v16 = 1633772400;
    }
    else
    {
      if (v15 != 30) {
        goto LABEL_54;
      }
      int v16 = 1633772403;
    }
  }
  else if (v15 == 5)
  {
    int v16 = 1633772392;
  }
  else
  {
    if (v15 != 23) {
      goto LABEL_54;
    }
    int v16 = 1633772396;
  }
  v32[0] = 0;
  long long v34 = 0u;
  uint64_t v35 = 0;
  long long totalLengthOut = 0u;
  uint64_t v36 = dataPointerOut;
  int v38 = 0;
  DWORD2(totalLengthOut) = v16;
  int v37 = lengthAtOffsetOut;
  uint64_t Property = AudioToolbox_AudioFormatGetPropertyInfo(1718383476, 56, (uint64_t)&totalLengthOut, (uint64_t)v32);
  if (Property || !v32[0])
  {
LABEL_47:
    if (Property)
    {
LABEL_48:
      unsigned __int8 v23 = 0;
      unsigned __int16 v22 = 0;
      FigMP4Bridge_GetESDSObjectTypeAndCopyDecoderSpecificInfo((unint64_t)dataPointerOut, lengthAtOffsetOut, (char *)&v23, &v22, 0);
      int v20 = v23;
      if (v23)
      {
        if (v22)
        {
          snprintf((char *)v32, 0x20uLL, ", audio object type %u", v22);
          int v20 = v23;
        }
        else
        {
          LOBYTE(v32[0]) = 0;
        }
        snprintf((char *)&totalLengthOut, 0x80uLL, "Found stream descriptor for unsupported MPEG-4 object type 0x%X%s", v20, (const char *)v32);
        figSoundBridge_ReportParsingFailureMessage(*(void *)(a1 + 288), (uint64_t)&totalLengthOut);
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
    }
LABEL_53:
    uint64_t v8 = 0;
    goto LABEL_54;
  }
  uint64_t v8 = (char *)malloc_type_malloc(v32[0], 0x413501D0uLL);
  if (v8)
  {
    uint64_t Property = AudioToolbox_AudioFormatGetProperty(1718383476, 56, (uint64_t)&totalLengthOut, (uint64_t)v32, (uint64_t)v8);
    if (!Property)
    {
      int v17 = &v8[48 * (v32[0] / 0x30) - 48];
      uint64_t v18 = *((void *)v17 + 4);
      long long v19 = *((_OWORD *)v17 + 1);
      *(_OWORD *)a2 = *(_OWORD *)v17;
      *(_OWORD *)(a2 + 16) = v19;
      *(void *)(a2 + 32) = v18;
    }
    free(v8);
    goto LABEL_47;
  }
  uint64_t v9 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_60:
  uint64_t Property = v9;
LABEL_54:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  if (v8) {
    CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E4F1CF90], v8);
  }
  return Property;
}

uint64_t figSoundBridge_GetASBDFromDAC3BBuf(OpaqueCMBlockBuffer *a1, uint64_t a2)
{
  size_t v4 = 0;
  dataPointerOut = 0;
  uint64_t result = CMBlockBufferGetDataPointer(a1, 0, &v4, 0, &dataPointerOut);
  if (!result) {
    return ParseAC3MP4Cookie((unsigned __int8 *)dataPointerOut, v4, a2, 0);
  }
  return result;
}

uint64_t figSoundBridge_GetASBDFromDEC3BBuf(OpaqueCMBlockBuffer *a1, uint64_t a2)
{
  size_t v4 = 0;
  dataPointerOut = 0;
  uint64_t result = CMBlockBufferGetDataPointer(a1, 0, &v4, 0, &dataPointerOut);
  if (!result) {
    return ParseEnhancedAC3MP4Cookie((uint64_t)dataPointerOut, v4, a2, 0, 0);
  }
  return result;
}

uint64_t figSoundBridge_GetASBDFromAudioFormatWithCodecSpecificAtomBBuf(int a1, CMBlockBufferRef theBuffer, uint64_t a3)
{
  dataPointerOut = 0;
  size_t lengthAtOffsetOut = 0;
  int v6 = 40;
  uint64_t result = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if (!result)
  {
    *(_DWORD *)(a3 + 8) = a1;
    return AudioToolbox_AudioFormatGetProperty(1718449257, lengthAtOffsetOut, (uint64_t)dataPointerOut, (uint64_t)&v6, a3);
  }
  return result;
}

uint64_t figSoundBridge_GetASBDFromALACBBuf(OpaqueCMBlockBuffer *a1, uint64_t a2)
{
  uint64_t v9 = 0;
  size_t lengthAtOffsetOut = 0;
  uint64_t result = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &v9);
  if (!result)
  {
    if (lengthAtOffsetOut < 0x24)
    {
      return 4294954582;
    }
    else
    {
      size_t v4 = v9;
      *(_DWORD *)(a2 + 8) = 1634492771;
      *(double *)a2 = (double)(int)bswap32(*((_DWORD *)v4 + 8));
      HIDWORD(v6) = v4[17];
      LODWORD(v6) = (HIDWORD(v6) << 24) - 0x10000000;
      unsigned __int8 v5 = v6 >> 26;
      if (v5 > 4u) {
        int v7 = 0;
      }
      else {
        int v7 = dword_18FE95EE0[(char)v5];
      }
      uint64_t result = 0;
      *(_DWORD *)(a2 + 12) = v7;
      *(_DWORD *)(a2 + 28) = v4[21];
      unsigned int v8 = bswap32(*((_DWORD *)v4 + 3));
      *(_DWORD *)(a2 + 16) = 0;
      *(void *)(a2 + 20) = v8;
      *(void *)(a2 + 32) = 0;
    }
  }
  return result;
}

uint64_t translateMP4AFormatID(int a1)
{
  uint64_t result = 1836069985;
  if (a1 <= 1752594530)
  {
    if (a1 <= 1667312946)
    {
      if ((a1 - 1633772389) <= 0xE && ((1 << (a1 - 101)) & 0x488F) != 0) {
        return result;
      }
      if (a1 == 1633771875) {
        return 1633777252;
      }
      int v5 = 1633772320;
    }
    else
    {
      if (a1 <= 1667575090)
      {
        if (a1 <= 1667326823)
        {
          if (a1 == 1667312947) {
            return 1701733217;
          }
          unsigned __int16 v4 = 24931;
        }
        else
        {
          if (a1 == 1667326824 || a1 == 1667326832) {
            return 1701733217;
          }
          unsigned __int16 v4 = 28771;
        }
        int v3 = v4 | 0x63610000;
        goto LABEL_50;
      }
      if (a1 > 1667656802)
      {
        if (a1 == 1667656803 || a1 == 1668047203) {
          return 1701733217;
        }
        int v3 = 1668641633;
        goto LABEL_50;
      }
      if (a1 == 1667575091) {
        return 1701733217;
      }
      int v5 = 1667591280;
    }
LABEL_46:
    if (a1 == v5) {
      return result;
    }
    goto LABEL_53;
  }
  if (a1 <= 1902211170)
  {
    if (a1 <= 1885692722)
    {
      if ((a1 - 1885430579) > 0x3D || ((1 << (a1 - 51)) & 0x2020000000000001) == 0)
      {
        if (a1 == 1752594531) {
          return result;
        }
        if (a1 != 1885430115) {
          goto LABEL_53;
        }
      }
      return 1685220723;
    }
    if (a1 <= 1902207794)
    {
      if (a1 != 1885692723 && a1 != 1886745441)
      {
        int v3 = 1902207331;
        goto LABEL_50;
      }
      return 1685220723;
    }
    if ((a1 - 1902207795) <= 0x3D && ((1 << (a1 - 51)) & 0x2020000000000001) != 0) {
      return 1701733217;
    }
LABEL_53:
    if (a1 >> 8 == 6381923) {
      return 1836069985;
    }
    else {
      return a1;
    }
  }
  if (a1 <= 1903522656)
  {
    if (a1 > 1902537826)
    {
      if (a1 == 1902537827) {
        return 1701733217;
      }
      int v3 = 1902928227;
    }
    else
    {
      if (a1 == 1902211171) {
        return 1701733217;
      }
      int v3 = 1902469939;
    }
LABEL_50:
    if (a1 == v3) {
      return 1701733217;
    }
    goto LABEL_53;
  }
  if (a1 <= 1936487277)
  {
    if (a1 != 1903522657)
    {
      if (a1 == 1936487267) {
        return 1832149349;
      }
      goto LABEL_53;
    }
    return 1701733217;
  }
  if (a1 != 1936487278 && a1 != 1953986161)
  {
    int v5 = 1970495843;
    goto LABEL_46;
  }
  return result;
}

uint64_t figSoundBridge_EndianAudioChannelLayout_NtoB(int8x8_t *a1, unsigned int a2)
{
  if (a1 && a2 >= 0xC)
  {
    unint64_t v3 = a2;
    unsigned int AudioChannelCountFromLayout = figSoundBridge_GetAudioChannelCountFromLayout(a1);
    uint64_t v5 = a1[1].u32[0];
    if (v5)
    {
      if (AudioChannelCountFromLayout != v5 || 20 * (unint64_t)AudioChannelCountFromLayout + 12 > v3) {
        goto LABEL_11;
      }
    }
    else if (!AudioChannelCountFromLayout)
    {
      goto LABEL_11;
    }
    int8x8_t v6 = *a1;
    if (20 * (unint64_t)v5 + 12 <= v3)
    {
      unsigned int v7 = bswap32(v5);
      if (v5)
      {
        uint64_t v9 = 0;
        uint64_t v10 = (_DWORD *)&a1[2] + 1;
        do
        {
          uint64_t v11 = 0;
          *(int8x8_t *)((char *)a1 + 20 * v9 + 12) = vrev32_s8(*(int8x8_t *)((char *)a1 + 20 * v9 + 12));
          do
          {
            v10[v11] = bswap32(v10[v11]);
            ++v11;
          }
          while (v11 != 3);
          ++v9;
          v10 += 5;
        }
        while (v9 != v5);
      }
    }
    else
    {
      if (!v6.i32[0]) {
        goto LABEL_11;
      }
      unsigned int v7 = 0;
    }
    *a1 = vrev32_s8(v6);
    a1[1].i32[0] = v7;
    return 0;
  }
LABEL_11:

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_ConvertMP4AESDSMagicCookieToSoundDescriptionExtension(const __CFAllocator *a1, int a2, int a3, uint64_t a4, int a5, char a6, char **a7, _DWORD *a8)
{
  LODWORD(v11) = a5;
  if (a3) {
    uint64_t v15 = 4;
  }
  else {
    uint64_t v15 = 12;
  }
  if (a3) {
    unsigned int v16 = translateMP4AFormatID(a2);
  }
  else {
    unsigned int v16 = 1836069985;
  }
  uint64_t v17 = v15 + v11;
  if (a6) {
    unint64_t v18 = v17;
  }
  else {
    unint64_t v18 = v17 + 32;
  }
  if (HIDWORD(v18))
  {
    uint64_t v27 = 4294954586;
LABEL_27:
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  if (!a7 || !a8)
  {
    uint64_t v27 = 4294954584;
    goto LABEL_27;
  }
  CFAllocatorRef allocator = a1;
  long long v19 = (char *)CFAllocatorAllocate(a1, v18, 0);
  if (!v19)
  {
    uint64_t v27 = 4294954583;
    goto LABEL_27;
  }
  int v20 = v19;
  int v21 = v19;
  if ((a6 & 1) == 0)
  {
    *(void *)long long v19 = 0x616D72660C000000;
    unsigned int v22 = bswap32(v16);
    *((_DWORD *)v19 + 2) = v22;
    *((_DWORD *)v19 + 3) = 201326592;
    *((_DWORD *)v19 + 4) = v22;
    *((_DWORD *)v19 + 5) = 0;
    int v21 = v19 + 24;
  }
  *(_DWORD *)int v21 = bswap32(v17);
  *(void *)(v21 + 4) = 1935962981;
  unsigned __int8 v23 = v21 + 12;
  if (a3)
  {
    BOOL v24 = v11 >= 8;
    size_t v11 = (v11 - 8);
    if (!v24)
    {
      uint64_t v28 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      CFAllocatorDeallocate(allocator, v20);
      return v28;
    }
    uint64_t v25 = (const void *)(a4 + 8);
    int v26 = v21 + 12;
  }
  else
  {
    size_t v11 = v11;
    int v26 = v21 + 12;
    uint64_t v25 = (const void *)a4;
  }
  memcpy(v26, v25, v11);
  if ((a6 & 1) == 0) {
    *(void *)&v23[v11] = 0x8000000;
  }
  *a7 = v20;
  *a8 = v18;
  return 0;
}

uint64_t figSoundBridge_isProtectedMP4AFormatUsingESDS(int a1)
{
  uint64_t result = 1;
  if (a1 <= 1885430631)
  {
    if (a1 > 1667326831)
    {
      if (a1 != 1667326832 && a1 != 1668641633)
      {
        int v3 = 1885430115;
LABEL_18:
        if (a1 != v3) {
          return 0;
        }
      }
    }
    else if (a1 != 1633771875 && a1 != 1667326307)
    {
      int v3 = 1667326824;
      goto LABEL_18;
    }
  }
  else
  {
    if (a1 > 1902207330)
    {
      if (a1 > 1902207855)
      {
        if (a1 == 1902207856) {
          return result;
        }
        int v3 = 1903522657;
      }
      else
      {
        if (a1 == 1902207331) {
          return result;
        }
        int v3 = 1902207848;
      }
      goto LABEL_18;
    }
    if (a1 != 1885430632 && a1 != 1885430640)
    {
      int v3 = 1886745441;
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t figSoundBridge_ConvertALACMagicCookieToSoundDescriptionExtension(const __CFAllocator *a1, _DWORD *a2, unsigned int a3, char a4, void *a5, _DWORD *a6)
{
  if (a5 && a6)
  {
    if (a3 > 0x2F)
    {
      if (a2[1] == 1634562662)
      {
        if (*a2 == 201326592 && a2[2] == 1667329121 && a2[4] == 1667329121)
        {
          uint64_t v13 = bswap32(a2[3]);
          if (v13 + 12 <= (unint64_t)a3)
          {
            if (a4) {
              size_t v11 = v13;
            }
            else {
              size_t v11 = a3;
            }
            size_t v14 = (char *)CFAllocatorAllocate(a1, v11, 0);
            if (v14)
            {
              uint64_t v10 = v14;
              if (a4) {
                uint64_t v15 = a2 + 3;
              }
              else {
                uint64_t v15 = a2;
              }
              memcpy(v14, v15, v11);
              goto LABEL_32;
            }
LABEL_33:
            uint64_t v12 = 4294954583;
            goto LABEL_27;
          }
        }
      }
      else if (a2[7] == 1851877475 && a3 - 24 == bswap32(a2[6]))
      {
LABEL_23:
        if (a4)
        {
          long long v19 = (char *)CFAllocatorAllocate(a1, 36, 0);
          if (v19)
          {
            uint64_t v10 = v19;
            *(void *)long long v19 = 0x63616C6124000000;
            *((_DWORD *)v19 + 2) = 0;
            long long v20 = *(_OWORD *)a2;
            *(void *)(v19 + 28) = *((void *)a2 + 2);
            *(_OWORD *)(v19 + 12) = v20;
            LODWORD(v11) = 36;
            goto LABEL_32;
          }
        }
        else
        {
          unsigned int v16 = (char *)CFAllocatorAllocate(a1, 56, 0);
          if (v16)
          {
            uint64_t v10 = v16;
            *(_OWORD *)unsigned int v16 = xmmword_18FE95E60;
            *((void *)v16 + 2) = 1667329121;
            long long v17 = *(_OWORD *)a2;
            *((void *)v16 + 5) = *((void *)a2 + 2);
            *(_OWORD *)(v16 + 24) = v17;
            *((void *)v16 + 6) = 0x8000000;
            LODWORD(v11) = 56;
            goto LABEL_32;
          }
        }
        goto LABEL_33;
      }
    }
    else if (a3 == 24)
    {
      if (!a2)
      {
        uint64_t v10 = 0;
        LODWORD(v11) = 0;
LABEL_32:
        *a5 = v10;
        *a6 = v11;
        return 0;
      }
      goto LABEL_23;
    }
    uint64_t v12 = 4294954580;
  }
  else
  {
    uint64_t v12 = 4294954584;
  }
LABEL_27:

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_ConvertFLACMagicCookieToSoundDescriptionExtension(const __CFAllocator *a1, unsigned int *a2, uint64_t a3, unsigned int **a4, unsigned int *a5)
{
  if (a3 < 9 || a2[1] != 1632396900)
  {
    unsigned int v17 = 0;
    uint64_t PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1835230310, a3, (uint64_t)a2, (uint64_t)&v17);
    if (!PropertyInfo)
    {
      uint64_t v13 = CFAllocatorAllocate(a1, a3, 0);
      if (v13)
      {
        size_t v14 = v13;
        uint64_t Property = AudioToolbox_AudioFormatGetProperty(1835230310, a3, (uint64_t)a2, (uint64_t)&v17, (uint64_t)v13);
        if (Property)
        {
          uint64_t v11 = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
          if (v11) {
            CFAllocatorDeallocate(a1, v14);
          }
          return v11;
        }
        uint64_t v11 = 0;
        *a4 = (unsigned int *)v14;
        unsigned int v10 = v17;
        goto LABEL_9;
      }
      uint64_t PropertyInfo = 4294954583;
    }
    return FigSignalErrorAt(PropertyInfo, 0, 0, 0, 0, 0, 0);
  }
  unsigned int v10 = bswap32(*a2);
  if (v10 <= a3)
  {
    uint64_t v11 = 0;
    *a4 = a2;
LABEL_9:
    *a5 = v10;
    return v11;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_ConvertAMRMagicCookieToSoundDescriptionExtension(const __CFAllocator *a1, int a2, _DWORD *a3, int a4, char a5, void *a6, _DWORD *a7)
{
  if (a6 && a7)
  {
    if (a4 == 47
      && *a3 == 201326592
      && a3[1] == 1634562662
      && bswap32(a3[2]) == a2
      && ((unsigned int v11 = bswap32(*(_DWORD *)((char *)a3 + 26)), v11 == 1684106610) || v11 == 1935764850)
      && *(_DWORD *)((char *)a3 + 22) == 285212672)
    {
      if (a5) {
        size_t v12 = 17;
      }
      else {
        size_t v12 = 47;
      }
      uint64_t v13 = CFAllocatorAllocate(a1, v12, 0);
      if (v13)
      {
        size_t v14 = v13;
        if (a5) {
          uint64_t v15 = (char *)a3 + 22;
        }
        else {
          uint64_t v15 = a3;
        }
        memcpy(v13, v15, v12);
        if (a5) {
          v14[1] = 1919770980;
        }
        else {
          *(_DWORD *)((char *)v14 + 26) = 1919770995;
        }
        *a6 = v14;
        *a7 = v12;
        return 0;
      }
      uint64_t v16 = 4294954583;
    }
    else
    {
      uint64_t v16 = 4294954580;
    }
  }
  else
  {
    uint64_t v16 = 4294954584;
  }

  return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAudioCodecTypeIsAC3(int a1)
{
  uint64_t result = 1;
  if (a1 > 1885430578)
  {
    if (a1 != 1885430579 && a1 != 1902207795)
    {
      int v3 = 2053202739;
LABEL_8:
      if (a1 != v3) {
        return 0;
      }
    }
  }
  else if (a1 != 1633889587 && a1 != 1667312947)
  {
    int v3 = 1667326771;
    goto LABEL_8;
  }
  return result;
}

uint64_t figSoundBridge_EncapsulatedMagicCookieFromCanonicalMagicCookie(const __CFAllocator *a1, int a2, char a3, uint64_t a4, unsigned int a5, void *a6, unsigned int *a7)
{
  if (a3) {
    int v10 = 1836069990;
  }
  else {
    int v10 = 1299148630;
  }
  LODWORD(size_4) = a2;
  HIDWORD(size_4) = v10;
  uint64_t v20 = a4;
  uint64_t v21 = a5;
  unsigned int size = 0;
  uint64_t PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1701014883, 24, (uint64_t)&size_4, (uint64_t)&size);
  if (PropertyInfo) {
    return PropertyInfo;
  }
  if (!size)
  {
    uint64_t v17 = 4294954584;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  size_t v12 = CFAllocatorAllocate(a1, size, 0);
  if (!v12)
  {
    uint64_t v17 = 4294954583;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v13 = v12;
  uint64_t Property = AudioToolbox_AudioFormatGetProperty(1701014883, 24, (uint64_t)&size_4, (uint64_t)&size, (uint64_t)v12);
  if (Property)
  {
    uint64_t v15 = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
    CFAllocatorDeallocate(a1, v13);
  }
  else
  {
    uint64_t v15 = 0;
    *a7 = size;
    *a6 = v13;
  }
  return v15;
}

BOOL figSoundBridge_AreAtomsWellFormed(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  memset(v17, 0, sizeof(v17));
  int CFPreferenceNumberWithDefault = figSoundBridge_AllowZeroSizeTerminatorAtom_value;
  if (figSoundBridge_AllowZeroSizeTerminatorAtom_value == -1)
  {
    int CFPreferenceNumberWithDefault = FigGetCFPreferenceNumberWithDefault(@"zero_size_terminator_atom", @"com.apple.coremedia", 1);
    figSoundBridge_AllowZeroSizeTerminatorAtom_value = CFPreferenceNumberWithDefault;
  }
  int v9 = FigAtomStreamInitWithMemoryBlock(a1, a2, 0, CFPreferenceNumberWithDefault != 0, (uint64_t)v17);
  uint64_t v10 = 0;
  if (!v9)
  {
    while (1)
    {
      int v16 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      if (FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v17, &v16, &v15)
        || FigAtomStreamGetCurrentAtomGlobalOffset(v17, 0, &v14))
      {
        break;
      }
      if (!v16)
      {
        uint64_t v13 = v14;
        if (!a3) {
          uint64_t v13 = 0;
        }
        v10 += v13;
        BOOL result = 1;
        if (!a4) {
          return result;
        }
        goto LABEL_13;
      }
      v10 += v14;
      int Atom = FigAtomStreamAdvanceToNextAtom(v17);
      if (Atom)
      {
        BOOL result = Atom == -12890;
        if (a4) {
          goto LABEL_13;
        }
        return result;
      }
    }
  }
  BOOL result = 0;
  if (a4) {
LABEL_13:
  }
    *a4 = v10;
  return result;
}

uint64_t figBridge_ConvertMiscellaneousSampleDescriptionExtensionsToAtoms(const opaqueCMFormatDescription *a1, void *a2, uint64_t a3)
{
  *a2 = 0;
  CFPropertyListRef Extension = CMFormatDescriptionGetExtension(a1, @"SampleDescriptionExtensionAtoms");
  if (!Extension) {
    return 0;
  }
  uint64_t v5 = Extension;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v5)) {
    return 0;
  }
  size_t Count = CFDictionaryGetCount((CFDictionaryRef)v5);
  if (!Count) {
    return 0;
  }
  size_t v8 = Count;
  int v9 = (const void **)malloc_type_calloc(Count, 8uLL, 0x6004044C4A2DFuLL);
  long long v42 = v9;
  if (v9)
  {
    uint64_t v10 = v9;
    int v38 = a2;
    CFDictionaryGetKeysAndValues((CFDictionaryRef)v5, v9, 0);
    qsort(v10, v8, 8uLL, (int (__cdecl *)(const void *, const void *))SampleDescriptionExtensionComparator);
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = a3;
    size_t v41 = v8;
    do
    {
      CFStringRef v14 = (const __CFString *)v10[v12];
      uint64_t v15 = v5;
      CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)v5, v14);
      CFTypeID v17 = CFStringGetTypeID();
      if (v17 == CFGetTypeID(v14))
      {
        unsigned int v18 = figBridge_ConvertStringToAtomType(v14);
        if (v18)
        {
          unsigned int v19 = v18;
          CFTypeID v20 = CFGetTypeID(Value);
          if (CFDataGetTypeID() == v20)
          {
            size_t Length = CFDataGetLength((CFDataRef)Value);
            uint64_t v22 = v13;
            unsigned int v23 = Length + 8;
            if (v22)
            {
              BOOL v24 = (_DWORD *)(v22 + v11);
              *BOOL v24 = bswap32(v23);
              v24[1] = bswap32(v19);
              BytePtr = CFDataGetBytePtr((CFDataRef)Value);
              memcpy((void *)(v22 + v11 + 8), BytePtr, Length);
            }
            v11 += v23;
            uint64_t v13 = v22;
            uint64_t v10 = v42;
          }
          else if (CFArrayGetTypeID() == v20)
          {
            CFIndex v26 = CFArrayGetCount((CFArrayRef)Value);
            if (v26)
            {
              CFIndex v27 = v26;
              CFIndex v28 = 0;
              unsigned int v39 = bswap32(v19);
              do
              {
                CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)Value, v28);
                CFTypeID v30 = CFDataGetTypeID();
                if (v30 == CFGetTypeID(ValueAtIndex))
                {
                  size_t v31 = CFDataGetLength(ValueAtIndex);
                  unsigned int v32 = v31 + 8;
                  if (v13)
                  {
                    int v33 = (_DWORD *)(v13 + v11);
                    *int v33 = bswap32(v32);
                    v33[1] = v39;
                    long long v34 = CFDataGetBytePtr(ValueAtIndex);
                    uint64_t v35 = (void *)(v13 + v11 + 8);
                    uint64_t v13 = a3;
                    memcpy(v35, v34, v31);
                  }
                  v11 += v32;
                  uint64_t v10 = v42;
                }
                ++v28;
              }
              while (v27 != v28);
            }
          }
        }
      }
      ++v12;
      uint64_t v5 = v15;
    }
    while (v12 != v41);
    uint64_t v36 = 0;
    *int v38 = v11;
  }
  else
  {
    uint64_t v36 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
  free(v42);
  return v36;
}

uint64_t SampleDescriptionExtensionComparator(const __CFString **a1, const __CFString **a2)
{
  int v3 = figBridge_ConvertStringToAtomType(*a1);
  int v4 = v3;
  uint64_t v5 = 0;
  while (SampleDescriptionExtensionISOAtomPriority_isoAtomOrdering[v5] != v3)
  {
    if (++v5 == 8)
    {
      LODWORD(v5) = 0;
      break;
    }
  }
  int v6 = v5;
  int v7 = figBridge_ConvertStringToAtomType(*a2);
  uint64_t v8 = 0;
  while (SampleDescriptionExtensionISOAtomPriority_isoAtomOrdering[v8] != v7)
  {
    if (++v8 == 8)
    {
      if (v6) {
        return 0xFFFFFFFFLL;
      }
      else {
        return (v4 - v7);
      }
    }
  }
  if (v6 && v8) {
    return (v6 - v8);
  }
  if (v8) {
    unsigned int v10 = 1;
  }
  else {
    unsigned int v10 = v4 - v7;
  }
  if (v6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v10;
  }
}

uint64_t figBridge_ConvertStringToAtomType(const __CFString *a1)
{
  int PascalString = CFStringGetPascalString(a1, &buffer, 5, 0);
  uint64_t result = 0;
  if (PascalString)
  {
    if (buffer == 4) {
      return bswap32(v4);
    }
  }
  return result;
}

uint64_t figSoundBridge_IsKnownAtomFoundInExtension(uint64_t a1, uint64_t a2, int a3)
{
  memset(v11, 0, sizeof(v11));
  int CFPreferenceNumberWithDefault = figSoundBridge_AllowZeroSizeTerminatorAtom_value;
  if (figSoundBridge_AllowZeroSizeTerminatorAtom_value == -1)
  {
    int CFPreferenceNumberWithDefault = FigGetCFPreferenceNumberWithDefault(@"zero_size_terminator_atom", @"com.apple.coremedia", 1);
    figSoundBridge_AllowZeroSizeTerminatorAtom_value = CFPreferenceNumberWithDefault;
  }
  if (!FigAtomStreamInitWithMemoryBlock(a1, a2, 0, CFPreferenceNumberWithDefault != 0, (uint64_t)v11))
  {
    while (1)
    {
      int v10 = 0;
      uint64_t v9 = 0;
      if (FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v11, &v10, &v9)) {
        return 0;
      }
      if (v10 <= 1969513847) {
        break;
      }
      if ((v10 - 1969514801) < 2) {
        goto LABEL_19;
      }
      if (v10 != 2002876005)
      {
        if (v10 != 1969513848) {
          goto LABEL_20;
        }
LABEL_19:
        if (!a3) {
          return 1;
        }
        goto LABEL_20;
      }
      if (a3 == 1) {
        return 1;
      }
LABEL_20:
      if (FigAtomStreamAdvanceToNextAtom(v11)) {
        return 0;
      }
    }
    if (v10 <= 1936875891)
    {
      if (v10 != 1667788396 && v10 != 1684892024)
      {
        if (!v10) {
          return 0;
        }
        goto LABEL_20;
      }
    }
    else if ((v10 - 1969513265) >= 2 && v10 != 1936875892)
    {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  return 0;
}

OSStatus CMSwapBigEndianClosedCaptionDescriptionToHost(uint8_t *closedCaptionDescriptionData, size_t closedCaptionDescriptionSize)
{
  if (closedCaptionDescriptionSize > 0xF)
  {
    flipClosedCaptionDescriptionData((int8x8_t *)closedCaptionDescriptionData);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
}

int8x8_t flipClosedCaptionDescriptionData(int8x8_t *a1)
{
  int8x8_t result = vrev32_s8(*a1);
  unsigned int v2 = bswap32(a1[1].u32[0]);
  unsigned int v3 = bswap32(a1[1].u16[2]) >> 16;
  unsigned int v4 = bswap32(a1[1].u16[3]) >> 16;
  *a1 = result;
  a1[1].i32[0] = v2;
  a1[1].i16[2] = v3;
  a1[1].i16[3] = v4;
  return result;
}

OSStatus CMSwapHostEndianClosedCaptionDescriptionToBig(uint8_t *closedCaptionDescriptionData, size_t closedCaptionDescriptionSize)
{
  if (closedCaptionDescriptionSize > 0xF)
  {
    flipClosedCaptionDescriptionData((int8x8_t *)closedCaptionDescriptionData);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionData(CFAllocatorRef allocator, const uint8_t *closedCaptionDescriptionData, size_t size, CMClosedCaptionDescriptionFlavor flavor, CMClosedCaptionFormatDescriptionRef *formatDescriptionOut)
{
  v45[1] = *MEMORY[0x1E4F143B8];
  if (!closedCaptionDescriptionData || size <= 0xF || !formatDescriptionOut)
  {
    uint64_t v9 = 4294954584;
    goto LABEL_11;
  }
  signed int v6 = bswap32(*(_DWORD *)closedCaptionDescriptionData);
  uint64_t v7 = v6;
  if (v6 < 0x10 || v6 > size)
  {
    uint64_t v9 = 4294954582;
LABEL_11:
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  signed int v12 = *((_DWORD *)closedCaptionDescriptionData + 1);
  FourCharCode v13 = bswap32(v12);
  memset(values, 0, sizeof(values));
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  *(_OWORD *)keys = 0u;
  long long v37 = 0u;
  if (v12 > 942684002)
  {
    if (v12 != 1667462241)
    {
      unsigned __int16 v14 = 14179;
      goto LABEL_19;
    }
LABEL_20:
    FourCharCode mediaSubType = v13;
    unint64_t v15 = v7 - 16;
    if ((unint64_t)(v7 - 16) < 9)
    {
LABEL_43:
      CFMutableDictionaryRef Mutable = 0;
LABEL_44:
      CFDictionaryRef v29 = 0;
      char v30 = 1;
    }
    else
    {
      CFMutableDictionaryRef Mutable = 0;
      CFTypeID v17 = closedCaptionDescriptionData + 16;
      CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        unsigned int v19 = *((_DWORD *)v17 + 1);
        signed int v20 = bswap32(*(_DWORD *)v17);
        *(_DWORD *)bytes = bswap32(v19);
        uint64_t v21 = v20;
        unint64_t v22 = v20 - 8;
        BOOL v23 = v15 - 8 >= v22;
        v15 -= v20;
        if (!v23) {
          break;
        }
        if (v19 != 1701147238)
        {
          CFDataRef v24 = CFDataCreate(v18, v17 + 8, v22);
          if (!v24) {
            break;
          }
          CFDataRef v25 = v24;
          *(_DWORD *)bytes = bswap32(*(unsigned int *)bytes);
          CFStringRef v26 = CFStringCreateWithBytes(v18, bytes, 4, 0, 0);
          if (!v26)
          {
            CFRelease(v25);
            break;
          }
          CFStringRef v27 = v26;
          if (!Mutable)
          {
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v18, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (!Mutable)
            {
              CFRelease(v25);
              CFRelease(v27);
              goto LABEL_43;
            }
          }
          CFDictionaryAddValue(Mutable, v27, v25);
          CFRelease(v27);
          CFRelease(v25);
        }
        v17 += v21;
      }
      while (v15 > 8);
      if (!Mutable) {
        goto LABEL_44;
      }
      *(void *)&values[0] = CFRetain(Mutable);
      keys[0] = @"SampleDescriptionExtensionAtoms";
      CFDictionaryRef v29 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (*(void *)&values[0]) {
        CFRelease(*(CFTypeRef *)&values[0]);
      }
      char v30 = 0;
      *(void *)&values[0] = 0;
      if (!v29)
      {
        OSStatus v31 = -12713;
        char v32 = 0;
        goto LABEL_46;
      }
    }
    OSStatus v31 = 0;
    char v32 = v30;
    char v30 = 1;
LABEL_46:
    int v33 = (CFTypeRef *)values;
    do
    {
      if (*v33) {
        CFRelease(*v33);
      }
      ++v33;
    }
    while (v33 < v45);
    if ((v32 & 1) == 0) {
      CFRelease(Mutable);
    }
    if (v30)
    {
      OSStatus v31 = CMFormatDescriptionCreate(allocator, 0x636C6370u, mediaSubType, v29, formatDescriptionOut);
      if (v29) {
        CFRelease(v29);
      }
    }
    return v31;
  }
  if (v12 == 942683747) {
    goto LABEL_20;
  }
  unsigned __int16 v14 = 13936;
LABEL_19:
  if (v12 == (v14 | 0x38300000)) {
    goto LABEL_20;
  }
  OSStatus v28 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (v28) {
    return v28;
  }

  return CMFormatDescriptionCreate(allocator, 0x636C6370u, v13, 0, formatDescriptionOut);
}

OSStatus CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef closedCaptionDescriptionBlockBuffer, CMClosedCaptionDescriptionFlavor flavor, CMClosedCaptionFormatDescriptionRef *formatDescriptionOut)
{
  CFTypeRef cf = 0;
  if (closedCaptionDescriptionBlockBuffer)
  {
    dataPointerOut = 0;
    Datasize_t Length = CMBlockBufferGetDataLength(closedCaptionDescriptionBlockBuffer);
    if (CMBlockBufferIsRangeContiguous(closedCaptionDescriptionBlockBuffer, 0, 0))
    {
      uint64_t v8 = (void *)CFRetain(closedCaptionDescriptionBlockBuffer);
      CFTypeRef cf = v8;
    }
    else
    {
      OSStatus Contiguous = CMBlockBufferCreateContiguous(allocator, closedCaptionDescriptionBlockBuffer, allocator, 0, 0, DataLength, 0, (CMBlockBufferRef *)&cf);
      if (Contiguous) {
        goto LABEL_9;
      }
      uint64_t v8 = (void *)cf;
    }
    CMBlockBufferGetDataPointer((CMBlockBufferRef)v8, 0, 0, 0, &dataPointerOut);
    OSStatus Contiguous = CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionData(allocator, (const uint8_t *)dataPointerOut, DataLength, v9, formatDescriptionOut);
LABEL_9:
    if (cf) {
      CFRelease(cf);
    }
    return Contiguous;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

OSStatus CMClosedCaptionFormatDescriptionCopyAsBigEndianClosedCaptionDescriptionBlockBuffer(CFAllocatorRef allocator, CMClosedCaptionFormatDescriptionRef closedCaptionFormatDescription, CMClosedCaptionDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  long long v39 = 0;
  CMBlockBufferRef v40 = 0;
  if (closedCaptionFormatDescription)
  {
    CFTypeID TypeID = CMFormatDescriptionGetTypeID();
    if (TypeID == CFGetTypeID(closedCaptionFormatDescription)
      && CMFormatDescriptionGetMediaType(closedCaptionFormatDescription) == 1668047728
      && blockBufferOut)
    {
      CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(closedCaptionFormatDescription);
      if (!Extensions)
      {
        int64_t v12 = 0;
        size_t v24 = 16;
        goto LABEL_33;
      }
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms");
      if (Value)
      {
        CFDictionaryRef v10 = Value;
        dataPointerOut = 0;
        CMBlockBufferRef theBuffer = 0;
        size_t Count = CFDictionaryGetCount(Value);
        int64_t v12 = Count;
        if (Count)
        {
          FourCharCode v13 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
          unsigned __int16 v14 = (const void **)malloc_type_calloc(v12, 8uLL, 0xC0040B8AA526DuLL);
          CFDictionaryGetKeysAndValues(v10, v13, v14);
          long long v38 = v13;
          size_t v15 = 0;
          if (v12 >= 1)
          {
            int v16 = v14;
            int64_t v17 = v12;
            do
            {
              if (*v16)
              {
                CFTypeID v18 = CFGetTypeID(*v16);
                if (v18 == CFDataGetTypeID())
                {
                  if (*v13)
                  {
                    CFTypeID v19 = CFGetTypeID(*v13);
                    if (v19 == CFStringGetTypeID()) {
                      v15 += CFDataGetLength((CFDataRef)*v16) + 8;
                    }
                  }
                }
              }
              ++v13;
              ++v16;
              --v17;
            }
            while (v17);
          }
          OSStatus DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, v15, allocator, 0, 0, v15, 1u, &theBuffer);
          if (DataPointer
            || (OSStatus DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut)) != 0)
          {
            OSStatus v21 = DataPointer;
            int64_t v12 = 0;
            unint64_t v22 = v38;
            if (!v38) {
              goto LABEL_20;
            }
          }
          else
          {
            unint64_t v22 = v38;
            if (v12 >= 1)
            {
              CFDictionaryRef v29 = v14;
              char v30 = v38;
              do
              {
                if (*v29)
                {
                  CFTypeID v31 = CFGetTypeID(*v29);
                  if (v31 == CFDataGetTypeID())
                  {
                    if (*v30)
                    {
                      CFTypeID v32 = CFGetTypeID(*v30);
                      if (v32 == CFStringGetTypeID())
                      {
                        int Length = CFDataGetLength((CFDataRef)*v29);
                        *(_DWORD *)dataPointerOut = bswap32(Length + 8);
                        dataPointerOut += 4;
                        v44.CFIndex location = 0;
                        v44.length = 4;
                        CFStringGetBytes((CFStringRef)*v30, v44, 0, 0, 0, (UInt8 *)dataPointerOut, 4, 0);
                        dataPointerOut += 4;
                        long long v34 = dataPointerOut;
                        BytePtr = CFDataGetBytePtr((CFDataRef)*v29);
                        size_t v36 = CFDataGetLength((CFDataRef)*v29);
                        memcpy(v34, BytePtr, v36);
                        CFIndex v37 = CFDataGetLength((CFDataRef)*v29);
                        dataPointerOut += v37;
                      }
                    }
                  }
                }
                ++v30;
                ++v29;
                --v12;
              }
              while (v12);
            }
            OSStatus v21 = 0;
            int64_t v12 = (int64_t)theBuffer;
            CMBlockBufferRef theBuffer = 0;
            if (!v38)
            {
LABEL_20:
              if (v14) {
                free(v14);
              }
              if (theBuffer) {
                CFRelease(theBuffer);
              }
              if (v21)
              {
                if (v12)
                {
                  CFRelease((CFTypeRef)v12);
                  int64_t v12 = 0;
                }
                goto LABEL_36;
              }
              goto LABEL_32;
            }
          }
          free(v22);
          goto LABEL_20;
        }
      }
      else
      {
        int64_t v12 = 0;
      }
LABEL_32:
      size_t v24 = CMBlockBufferGetDataLength((CMBlockBufferRef)v12) + 16;
LABEL_33:
      OSStatus v25 = CMBlockBufferCreateWithMemoryBlock(allocator, 0, v24, allocator, 0, 0, v24, 1u, &v40);
      if (!v25)
      {
        OSStatus v25 = CMBlockBufferGetDataPointer(v40, 0, 0, 0, &v39);
        if (!v25)
        {
          *(_DWORD *)long long v39 = v24;
          FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(closedCaptionFormatDescription);
          CFStringRef v27 = (int8x8_t *)v39;
          *((_DWORD *)v39 + 1) = MediaSubType;
          v27[1] = (int8x8_t)0xFFFF000000000000;
          flipClosedCaptionDescriptionData(v27);
          if (!v12
            || (Dataint Length = CMBlockBufferGetDataLength((CMBlockBufferRef)v12),
                (OSStatus v25 = CMBlockBufferCopyDataBytes((CMBlockBufferRef)v12, 0, DataLength, v39 + 16)) == 0))
          {
            OSStatus v21 = 0;
            *CMBlockBufferRef blockBufferOut = v40;
            CMBlockBufferRef v40 = 0;
            if (!v12) {
              return v21;
            }
            goto LABEL_39;
          }
        }
      }
      OSStatus v21 = v25;
LABEL_36:
      if (v40) {
        CFRelease(v40);
      }
      if (!v12) {
        return v21;
      }
LABEL_39:
      CFRelease((CFTypeRef)v12);
      return v21;
    }
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

OSStatus CMSwapBigEndianTextDescriptionToHost(uint8_t *textDescriptionData, size_t textDescriptionSize)
{
  return 0;
}

int8x8_t flipTextDescriptionData(int a1, unsigned __int16 *__dst)
{
  memset(__src, 0, 46);
  if (a1 > 2004251763)
  {
    if (a1 == 2021028980)
    {
LABEL_7:
      __src[0] = *(_OWORD *)__dst;
      *(int8x8_t *)&__src[0] = vrev32_s8(*(int8x8_t *)&__src[0]);
      DWORD2(__src[0]) = bswap32(DWORD2(__src[0]));
      WORD6(__src[0]) = bswap32(WORD6(__src[0])) >> 16;
      HIWORD(__src[0]) = bswap32(HIWORD(__src[0])) >> 16;
      size_t v5 = 16;
      goto LABEL_9;
    }
    int v4 = 2004251764;
  }
  else
  {
    if (a1 == 1937010800)
    {
      __src[0] = *(_OWORD *)__dst;
      *(int8x8_t *)&__src[0] = vrev32_s8(*(int8x8_t *)&__src[0]);
      DWORD2(__src[0]) = bswap32(DWORD2(__src[0]));
      WORD6(__src[0]) = bswap32(WORD6(__src[0])) >> 16;
      HIWORD(__src[0]) = bswap32(HIWORD(__src[0])) >> 16;
      int8x8_t result = *(int8x8_t *)&__src[0];
      *(_OWORD *)__dst = __src[0];
      return result;
    }
    int v4 = 1937142900;
  }
  if (a1 == v4) {
    goto LABEL_7;
  }
  __src[0] = *(_OWORD *)__dst;
  unsigned int v6 = *((_DWORD *)__dst + 4);
  *(int8x8_t *)&__src[0] = vrev32_s8(*(int8x8_t *)&__src[0]);
  DWORD2(__src[0]) = bswap32(DWORD2(__src[0]));
  WORD6(__src[0]) = bswap32(WORD6(__src[0])) >> 16;
  HIWORD(__src[0]) = bswap32(HIWORD(__src[0])) >> 16;
  LODWORD(__src[1]) = bswap32(v6);
  size_t v5 = 20;
LABEL_9:
  memcpy(__dst, __src, v5);
  if (a1 == 1952807028)
  {
    *((_DWORD *)__dst + 5) = bswap32(*((_DWORD *)__dst + 5));
    unsigned int v11 = bswap32(__dst[13]);
    unsigned int v12 = bswap32(__dst[14]);
    __dst[12] = bswap32(__dst[12]) >> 16;
    __dst[13] = HIWORD(v11);
    __dst[14] = HIWORD(v12);
    unint64_t v13 = *(void *)(__dst + 15);
    unint64_t v14 = HIDWORD(v13);
    unint64_t v15 = HIWORD(v13);
    LODWORD(v13) = bswap32(v13);
    *(void *)(__dst + 15) = ((unint64_t)(bswap32(v14) >> 16) << 32) | ((unint64_t)__rev16(v15) << 48) | ((unint64_t)(unsigned __int16)v13 << 16) | WORD1(v13);
    LODWORD(v14) = bswap32(__dst[21]);
    LODWORD(v15) = bswap32(__dst[22]);
    unsigned int v16 = bswap32(__dst[23]);
    int8x8_t result = vrev16_s8(*(int8x8_t *)(__dst + 25));
    *(_DWORD *)(__dst + 19) = bswap32(*(_DWORD *)(__dst + 19));
    __dst[21] = WORD1(v14);
    __dst[22] = WORD1(v15);
    __dst[23] = HIWORD(v16);
    *(int8x8_t *)(__dst + 25) = result;
  }
  else if (a1 == 1954034535)
  {
    unint64_t v8 = *(void *)(__dst + 13);
    unint64_t v9 = HIDWORD(v8);
    unint64_t v10 = HIWORD(v8);
    LODWORD(v8) = bswap32(v8);
    *(void *)(__dst + 13) = ((unint64_t)(bswap32(v9) >> 16) << 32) | ((unint64_t)__rev16(v10) << 48) | ((unint64_t)(unsigned __int16)v8 << 16) | WORD1(v8);
    LODWORD(v9) = bswap32(__dst[18]) >> 16;
    LODWORD(v10) = bswap32(__dst[19]);
    __dst[17] = bswap32(__dst[17]) >> 16;
    __dst[18] = v9;
    __dst[19] = WORD1(v10);
  }
  return result;
}

OSStatus CMSwapHostEndianTextDescriptionToBig(uint8_t *textDescriptionData, size_t textDescriptionSize)
{
  return 0;
}

OSStatus CMTextFormatDescriptionCreateFromBigEndianTextDescriptionData(CFAllocatorRef allocator, const uint8_t *textDescriptionData, size_t size, CMTextDescriptionFlavor flavor, CMMediaType mediaType, CMTextFormatDescriptionRef *formatDescriptionOut)
{
  unsigned int v6 = formatDescriptionOut;
  v141[0] = *MEMORY[0x1E4F143B8];
  if (size <= 7) {
    goto LABEL_2;
  }
  int v15 = bswap32(*((_DWORD *)textDescriptionData + 1));
  if (v15 <= 1952807027)
  {
    if (v15 == 1685220724) {
      goto LABEL_26;
    }
    if (v15 != 1937010800)
    {
      if (v15 != 1937142900)
      {
LABEL_17:
        uint64_t v10 = 4294954579;
        goto LABEL_3;
      }
      goto LABEL_23;
    }
    CFTypeRef v113 = 0;
    long long v139 = 0u;
    long long v140 = 0u;
    long long v137 = 0u;
    long long v138 = 0u;
    long long v135 = 0u;
    long long v136 = 0u;
    long long v133 = 0u;
    long long v134 = 0u;
    long long v131 = 0u;
    long long v132 = 0u;
    long long v129 = 0u;
    long long v130 = 0u;
    long long v127 = 0u;
    long long v128 = 0u;
    long long v125 = 0u;
    long long v126 = 0u;
    long long v123 = 0u;
    long long v124 = 0u;
    long long v121 = 0u;
    long long v122 = 0u;
    CFTypeRef v98 = 0;
    LOBYTE(v96) = 0;
    LOBYTE(v95) = 0;
    LOBYTE(v94) = 0;
    LOBYTE(cf) = 0;
    if (size <= 0x10) {
      goto LABEL_2;
    }
    v105[0] = 0;
    v105[1] = 0;
    v99[0] = 0;
    v99[1] = 0;
    v102[0] = 0;
    v102[1] = 0;
    CFTypeRef v117 = 0;
    size_t v118 = 0;
    if (locateXMLSubtitleSampleFields((uint64_t)textDescriptionData, size, (char *)&v96, (uint64_t *)v105, (char *)&v95, (size_t *)v99, (char *)&v94, (size_t *)v102, (char *)&cf, &v117)|| !(_BYTE)v96|| (_BYTE)cf && (!(_BYTE)v95 || !(_BYTE)v94)|| (char *)v105[1] + 16 > (CFTypeRef)size|| (char *)v105[0] + (unint64_t)v105[1] > (CFTypeRef)size)
    {
      goto LABEL_161;
    }
    if ((_BYTE)v95)
    {
      long long v66 = (char *)v99[1] + (unint64_t)v105[1] + 16;
      if ((unint64_t)v66 > size
        || (char *)v99[0] + (unint64_t)v99[1] > (CFTypeRef)size
        || (_BYTE)v94
        && ((unint64_t)v102[1] + (unint64_t)v66 > size
         || (char *)v102[0] + (unint64_t)v102[1] > (CFTypeRef)size))
      {
        goto LABEL_161;
      }
    }
    else if ((_BYTE)v94)
    {
      goto LABEL_161;
    }
    if ((uint64_t)v105[1] > 1)
    {
      CFAllocatorRef v78 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef v75 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &textDescriptionData[(unint64_t)v105[0]], (CFIndex)v105[1] - 1, 0x8000100u, 1u);
      if (v75)
      {
        CFStringRef v76 = 0;
        if (!(_BYTE)v95
          || (uint64_t)v99[1] < 2
          || (CFStringRef v76 = CFStringCreateWithBytes(v78, &textDescriptionData[(unint64_t)v99[0]], (CFIndex)v99[1] - 1, 0x8000100u, 1u)) != 0)
        {
          CFStringRef v77 = 0;
          if ((_BYTE)v94
            && (uint64_t)v102[1] >= 2
            && (CFStringRef v77 = CFStringCreateWithBytes(v78, &textDescriptionData[(unint64_t)v102[0]], (CFIndex)v102[1] - 1, 0x8000100u, 1u)) == 0)
          {
            OSStatus Dict = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            CFTypeRef v12 = 0;
          }
          else
          {
            int v79 = ParseExtensionAtomsInDescription((uint64_t)textDescriptionData, size, 0, 0, 0, (__CFDictionary **)&v98);
            CFIndex v80 = 0;
            if (!v79)
            {
              CFStringRef v89 = v75;
              uint64_t v81 = (CFTypeRef *)&v131;
              if (v98)
              {
                uint64_t v81 = (CFTypeRef *)&v131 + 1;
                *(void *)&long long v131 = CFRetain(v98);
                *(void *)&long long v121 = @"SampleDescriptionExtensionAtoms";
                uint64_t v82 = 1;
              }
              else
              {
                uint64_t v82 = 0;
              }
              *uint64_t v81 = CFRetain(v89);
              int v83 = v81 + 1;
              CFIndex v80 = v82 + 1;
              *(void *)((unint64_t)&v121 | (8 * v82)) = @"XMLNamespaces";
              if (v76)
              {
                int v83 = v81 + 2;
                v81[1] = CFRetain(v76);
                *((void *)&v121 + v80) = @"XMLSchemas";
                CFIndex v80 = v82 | 2;
              }
              CFStringRef v75 = v89;
              if (v77)
              {
                *int v83 = CFRetain(v77);
                *((void *)&v121 + v80++) = @"AuxiliaryMIMETypes";
              }
            }
            OSStatus Dict = createDict(allocator, (const void **)&v121, (const void **)&v131, v80, (CFDictionaryRef *)&v113);
            CFTypeRef v12 = v113;
          }
LABEL_181:
          CFStringRef v84 = v77;
          CFStringRef v85 = v76;
          if (Dict && v12)
          {
            CFStringRef v86 = v75;
            CFRelease(v12);
            CFTypeRef v12 = 0;
          }
          else
          {
            CFStringRef v86 = v75;
          }
          v87 = (CFTypeRef *)&v131;
          do
          {
            if (*v87) {
              CFRelease(*v87);
            }
            ++v87;
          }
          while (v87 < v141);
          if (v86) {
            CFRelease(v86);
          }
          if (v85) {
            CFRelease(v85);
          }
          if (v84) {
            CFRelease(v84);
          }
          CFTypeRef v69 = v98;
          unsigned int v6 = formatDescriptionOut;
          if (v98) {
            goto LABEL_196;
          }
          goto LABEL_4;
        }
        OSStatus Dict = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        CFTypeRef v12 = 0;
LABEL_163:
        CFStringRef v77 = 0;
        goto LABEL_181;
      }
      OSStatus Dict = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
      CFTypeRef v12 = 0;
LABEL_162:
      CFStringRef v76 = 0;
      goto LABEL_163;
    }
LABEL_161:
    OSStatus Dict = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    CFTypeRef v12 = 0;
    CFStringRef v75 = 0;
    goto LABEL_162;
  }
  if (v15 <= 2004251763)
  {
    if (v15 != 1952807028)
    {
      if (v15 != 1954034535) {
        goto LABEL_17;
      }
LABEL_26:
      CFTypeRef v98 = 0;
      CFTypeRef v95 = 0;
      CFTypeRef v96 = 0;
      CFTypeRef cf = 0;
      CFTypeRef v94 = 0;
      CFTypeRef v117 = @"Red";
      size_t v118 = @"Green";
      size_t v119 = @"Blue";
      unint64_t v120 = @"Alpha";
      CFTypeRef v113 = @"Top";
      v114 = @"Left";
      AudioFormatID v115 = @"Bottom";
      UInt32 v116 = @"Right";
      v99[0] = @"StartChar";
      v99[1] = @"EndChar";
      *(void *)&long long v100 = @"Font";
      *((void *)&v100 + 1) = @"FontFace";
      *(void *)int v101 = @"FontSize";
      *(void *)&v101[8] = @"ForegroundColor";
      long long v111 = 0u;
      long long v112 = 0u;
      long long v109 = 0u;
      long long v110 = 0u;
      long long v107 = 0u;
      long long v108 = 0u;
      *(_OWORD *)v105 = 0u;
      long long v106 = 0u;
      long long v139 = 0u;
      long long v140 = 0u;
      long long v137 = 0u;
      long long v138 = 0u;
      long long v135 = 0u;
      long long v136 = 0u;
      long long v133 = 0u;
      long long v134 = 0u;
      long long v131 = 0u;
      long long v132 = 0u;
      long long v129 = 0u;
      long long v130 = 0u;
      long long v127 = 0u;
      long long v128 = 0u;
      long long v125 = 0u;
      long long v126 = 0u;
      long long v123 = 0u;
      long long v124 = 0u;
      long long v121 = 0u;
      long long v122 = 0u;
      CFTypeRef v91 = 0;
      CFTypeRef v92 = 0;
      if (size > 0x2D)
      {
        long long v18 = *((_OWORD *)textDescriptionData + 1);
        *(_OWORD *)v102 = *(_OWORD *)textDescriptionData;
        *(_OWORD *)int v103 = v18;
        *(_OWORD *)&v103[14] = *(_OWORD *)(textDescriptionData + 30);
        CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFNumberRef v20 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt8Type, &v103[6]);
        if (!v20) {
          goto LABEL_94;
        }
        v105[0] = v20;
        CFNumberRef v21 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[7]);
        if (!v21) {
          goto LABEL_94;
        }
        v105[1] = v21;
        CFNumberRef v22 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[8]);
        if (!v22) {
          goto LABEL_94;
        }
        *(void *)&long long v106 = v22;
        CFNumberRef v23 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[9]);
        if (!v23) {
          goto LABEL_94;
        }
        *((void *)&v106 + 1) = v23;
        OSStatus v24 = createDict(allocator, &v117, v105, 4, (CFDictionaryRef *)&v96);
        if (!v24)
        {
          LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[10]) >> 16;
          CFNumberRef v25 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
          if (!v25) {
            goto LABEL_94;
          }
          v105[0] = v25;
          LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[12]) >> 16;
          CFNumberRef v26 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
          if (!v26) {
            goto LABEL_94;
          }
          v105[1] = v26;
          LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[14]) >> 16;
          CFNumberRef v27 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
          if (!v27) {
            goto LABEL_94;
          }
          *(void *)&long long v106 = v27;
          LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[16]) >> 16;
          CFNumberRef v28 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
          if (!v28) {
            goto LABEL_94;
          }
          *((void *)&v106 + 1) = v28;
          OSStatus v24 = createDict(allocator, &v113, v105, 4, (CFDictionaryRef *)&v95);
          if (!v24)
          {
            CFNumberRef v29 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[26]);
            if (!v29) {
              goto LABEL_94;
            }
            v105[0] = v29;
            CFNumberRef v30 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[27]);
            if (!v30) {
              goto LABEL_94;
            }
            v105[1] = v30;
            CFNumberRef v31 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[28]);
            if (!v31) {
              goto LABEL_94;
            }
            *(void *)&long long v106 = v31;
            CFNumberRef v32 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[29]);
            if (!v32) {
              goto LABEL_94;
            }
            *((void *)&v106 + 1) = v32;
            OSStatus v24 = createDict(allocator, &v117, v105, 4, (CFDictionaryRef *)&cf);
            if (!v24)
            {
              LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[18]) >> 16;
              CFNumberRef v33 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
              if (!v33) {
                goto LABEL_94;
              }
              v105[0] = v33;
              LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[20]) >> 16;
              CFNumberRef v34 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
              if (!v34) {
                goto LABEL_94;
              }
              v105[1] = v34;
              LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[22]) >> 16;
              CFNumberRef v35 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
              if (!v35) {
                goto LABEL_94;
              }
              *(void *)&long long v106 = v35;
              CFNumberRef v36 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[24]);
              if (!v36) {
                goto LABEL_94;
              }
              *((void *)&v106 + 1) = v36;
              CFNumberRef v37 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[25]);
              if (!v37) {
                goto LABEL_94;
              }
              *(void *)&long long v107 = v37;
              *((void *)&v107 + 1) = CFRetain(cf);
              OSStatus v24 = createDict(allocator, v99, v105, 6, (CFDictionaryRef *)&v94);
              if (!v24)
              {
                unsigned int valuePtr = bswap32(*(unsigned int *)v103);
                CFNumberRef v38 = CFNumberCreate(v19, kCFNumberSInt32Type, &valuePtr);
                if (v38)
                {
                  *(void *)&long long v131 = v38;
                  *(void *)&long long v121 = @"DisplayFlags";
                  CFNumberRef v39 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[4]);
                  if (v39)
                  {
                    *((void *)&v131 + 1) = v39;
                    *((void *)&v121 + 1) = @"HorizontalJustification";
                    CFNumberRef v40 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[5]);
                    if (v40)
                    {
                      *(void *)&long long v132 = v40;
                      *(void *)&long long v122 = @"VerticalJustification";
                      *((void *)&v132 + 1) = CFRetain(v96);
                      *((void *)&v122 + 1) = @"BackgroundColor";
                      *(void *)&long long v133 = CFRetain(v95);
                      *(void *)&long long v123 = @"DefaultTextBox";
                      *((void *)&v133 + 1) = CFRetain(v94);
                      *((void *)&v123 + 1) = @"DefaultStyle";
                      if (ParseExtensionAtomsInDescription((uint64_t)textDescriptionData, size, (__CFDictionary **)&v92, 0, 0, (__CFDictionary **)&v91))
                      {
                        CFIndex v41 = 6;
                      }
                      else
                      {
                        if (v92)
                        {
                          size_t v88 = (CFTypeRef *)&v134 + 1;
                          *(void *)&long long v134 = CFRetain(v92);
                          *(void *)&long long v124 = @"FontTable";
                          CFIndex v41 = 7;
                        }
                        else
                        {
                          size_t v88 = (CFTypeRef *)&v134;
                          CFIndex v41 = 6;
                        }
                        if (v91)
                        {
                          *size_t v88 = CFRetain(v91);
                          *((void *)&v121 + v41++) = @"SampleDescriptionExtensionAtoms";
                        }
                      }
                      OSStatus Dict = createDict(allocator, (const void **)&v121, (const void **)&v131, v41, (CFDictionaryRef *)&v98);
                      CFTypeRef v12 = v98;
                      if (Dict && v98)
                      {
                        CFRelease(v98);
                        goto LABEL_220;
                      }
LABEL_95:
                      uint64_t v67 = v105;
                      do
                      {
                        if (*v67) {
                          CFRelease(*v67);
                        }
                        ++v67;
                      }
                      while (v67 < &v113);
                      uint64_t v68 = (CFTypeRef *)&v131;
                      do
                      {
                        if (*v68) {
                          CFRelease(*v68);
                        }
                        ++v68;
                      }
                      while (v68 < v141);
                      if (v92) {
                        CFRelease(v92);
                      }
                      if (v91) {
                        CFRelease(v91);
                      }
                      if (v96) {
                        CFRelease(v96);
                      }
                      if (v95) {
                        CFRelease(v95);
                      }
                      if (v94) {
                        CFRelease(v94);
                      }
                      CFTypeRef v69 = cf;
                      if (!cf) {
                        goto LABEL_4;
                      }
LABEL_196:
                      CFRelease(v69);
                      goto LABEL_4;
                    }
                  }
                }
LABEL_94:
                CFTypeRef v12 = 0;
                OSStatus Dict = -12713;
                goto LABEL_95;
              }
            }
          }
        }
        OSStatus Dict = v24;
LABEL_220:
        CFTypeRef v12 = 0;
        goto LABEL_95;
      }
LABEL_2:
      uint64_t v10 = 4294954582;
LABEL_3:
      OSStatus Dict = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
      CFTypeRef v12 = 0;
      goto LABEL_4;
    }
    CFTypeRef v98 = 0;
    CFTypeRef v95 = 0;
    CFTypeRef v96 = 0;
    CFTypeRef cf = 0;
    CFTypeRef v94 = 0;
    CFTypeRef v113 = @"Red";
    v114 = @"Green";
    AudioFormatID v115 = @"Blue";
    CFTypeRef v117 = @"Top";
    size_t v118 = @"Left";
    size_t v119 = @"Bottom";
    unint64_t v120 = @"Right";
    v102[0] = @"StartChar";
    v102[1] = @"Height";
    *(void *)int v103 = @"Ascent";
    *(void *)&v103[8] = @"Font";
    *(void *)&v103[16] = @"FontFace";
    *(void *)&v103[24] = @"FontSize";
    v104 = @"ForegroundColor";
    long long v111 = 0u;
    long long v112 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    *(_OWORD *)v105 = 0u;
    long long v106 = 0u;
    long long v139 = 0u;
    long long v140 = 0u;
    long long v137 = 0u;
    long long v138 = 0u;
    long long v135 = 0u;
    long long v136 = 0u;
    long long v133 = 0u;
    long long v134 = 0u;
    long long v131 = 0u;
    long long v132 = 0u;
    long long v129 = 0u;
    long long v130 = 0u;
    long long v127 = 0u;
    long long v128 = 0u;
    long long v125 = 0u;
    long long v126 = 0u;
    long long v123 = 0u;
    long long v124 = 0u;
    long long v121 = 0u;
    long long v122 = 0u;
    CFTypeRef v91 = 0;
    CFTypeRef v92 = 0;
    if (size <= 0x3A || (unint64_t)textDescriptionData[58] + 59 > size) {
      goto LABEL_2;
    }
    long long v42 = *((_OWORD *)textDescriptionData + 1);
    *(_OWORD *)int v99 = *(_OWORD *)textDescriptionData;
    long long v100 = v42;
    *(_OWORD *)int v101 = *((_OWORD *)textDescriptionData + 2);
    *(_OWORD *)&v101[11] = *(_OWORD *)(textDescriptionData + 43);
    LOWORD(valuePtr) = bswap32(WORD4(v42)) >> 16;
    CFAllocatorRef v43 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v44 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt16Type, &valuePtr);
    if (v44)
    {
      v105[0] = v44;
      LOWORD(valuePtr) = bswap32(WORD5(v100)) >> 16;
      CFNumberRef v45 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
      if (v45)
      {
        v105[1] = v45;
        LOWORD(valuePtr) = bswap32(WORD6(v100)) >> 16;
        CFNumberRef v46 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
        if (v46)
        {
          *(void *)&long long v106 = v46;
          OSStatus v47 = createDict(allocator, &v113, v105, 3, (CFDictionaryRef *)&v96);
          if (v47) {
            goto LABEL_202;
          }
          LOWORD(valuePtr) = bswap32(HIWORD(v100)) >> 16;
          CFNumberRef v48 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
          if (v48)
          {
            v105[0] = v48;
            LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)v101) >> 16;
            CFNumberRef v49 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
            if (v49)
            {
              v105[1] = v49;
              LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[2]) >> 16;
              CFNumberRef v50 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
              if (v50)
              {
                *(void *)&long long v106 = v50;
                LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[4]) >> 16;
                CFNumberRef v51 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                if (v51)
                {
                  *((void *)&v106 + 1) = v51;
                  OSStatus v47 = createDict(allocator, &v117, v105, 4, (CFDictionaryRef *)&v95);
                  if (v47) {
                    goto LABEL_202;
                  }
                  LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[20]) >> 16;
                  CFNumberRef v52 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                  if (v52)
                  {
                    v105[0] = v52;
                    LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[22]) >> 16;
                    CFNumberRef v53 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                    if (v53)
                    {
                      v105[1] = v53;
                      LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[24]) >> 16;
                      CFNumberRef v54 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                      if (v54)
                      {
                        *(void *)&long long v106 = v54;
                        OSStatus v47 = createDict(allocator, &v113, v105, 3, (CFDictionaryRef *)&cf);
                        if (v47) {
                          goto LABEL_202;
                        }
                        unsigned int valuePtr = bswap32(*(unsigned int *)&v101[6]);
                        CFNumberRef v55 = CFNumberCreate(v43, kCFNumberSInt32Type, &valuePtr);
                        if (v55)
                        {
                          v105[0] = v55;
                          LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[10]) >> 16;
                          CFNumberRef v56 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                          if (v56)
                          {
                            v105[1] = v56;
                            LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[12]) >> 16;
                            CFNumberRef v57 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                            if (v57)
                            {
                              *(void *)&long long v106 = v57;
                              LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[14]) >> 16;
                              CFNumberRef v58 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                              if (v58)
                              {
                                *((void *)&v106 + 1) = v58;
                                CFNumberRef v59 = CFNumberCreate(v43, kCFNumberSInt8Type, &v101[16]);
                                if (v59)
                                {
                                  *(void *)&long long v107 = v59;
                                  LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[18]) >> 16;
                                  CFNumberRef v60 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                                  if (v60)
                                  {
                                    *((void *)&v107 + 1) = v60;
                                    *(void *)&long long v108 = CFRetain(cf);
                                    OSStatus v47 = createDict(allocator, v102, v105, 7, (CFDictionaryRef *)&v94);
                                    if (!v47)
                                    {
                                      CFStringRef v61 = CFStringCreateWithPascalString(allocator, textDescriptionData + 58, 0);
                                      unsigned int valuePtr = bswap32(v100);
                                      CFNumberRef v62 = CFNumberCreate(v43, kCFNumberSInt32Type, &valuePtr);
                                      if (v62)
                                      {
                                        *(void *)&long long v131 = v62;
                                        *(void *)&long long v121 = @"DisplayFlags";
                                        unsigned int valuePtr = bswap32(DWORD1(v100));
                                        CFNumberRef v63 = CFNumberCreate(v43, kCFNumberSInt32Type, &valuePtr);
                                        if (v63)
                                        {
                                          *((void *)&v131 + 1) = v63;
                                          *((void *)&v121 + 1) = @"TextJustification";
                                          *(void *)&long long v132 = CFRetain(v96);
                                          *(void *)&long long v122 = @"BackgroundColor";
                                          *((void *)&v132 + 1) = CFRetain(v95);
                                          *((void *)&v122 + 1) = @"DefaultTextBox";
                                          *(void *)&long long v133 = CFRetain(v94);
                                          *(void *)&long long v123 = @"DefaultStyle";
                                          if (v61)
                                          {
                                            long long v64 = (CFTypeRef *)&v134;
                                            *((void *)&v133 + 1) = CFRetain(v61);
                                            *((void *)&v123 + 1) = @"DefaultFontName";
                                            CFIndex v65 = 6;
                                          }
                                          else
                                          {
                                            long long v64 = (CFTypeRef *)&v133 + 1;
                                            CFIndex v65 = 5;
                                          }
                                          if (!ParseExtensionAtomsInDescription((uint64_t)textDescriptionData, size, (__CFDictionary **)&v92, 0, 0, (__CFDictionary **)&v91))
                                          {
                                            if (v92)
                                            {
                                              *v64++ = CFRetain(v92);
                                              *((void *)&v121 + v65++) = @"FontTable";
                                            }
                                            if (v91)
                                            {
                                              *long long v64 = CFRetain(v91);
                                              *((void *)&v121 + v65++) = @"SampleDescriptionExtensionAtoms";
                                            }
                                          }
                                          OSStatus Dict = createDict(allocator, (const void **)&v121, (const void **)&v131, v65, (CFDictionaryRef *)&v98);
                                          CFTypeRef v12 = v98;
                                          if (Dict && v98)
                                          {
                                            CFRelease(v98);
                                            CFTypeRef v12 = 0;
                                          }
LABEL_119:
                                          int v71 = v105;
                                          do
                                          {
                                            if (*v71) {
                                              CFRelease(*v71);
                                            }
                                            ++v71;
                                          }
                                          while (v71 < &v113);
                                          CFIndex v72 = (CFTypeRef *)&v131;
                                          do
                                          {
                                            if (*v72) {
                                              CFRelease(*v72);
                                            }
                                            ++v72;
                                          }
                                          while (v72 < v141);
                                          if (v92) {
                                            CFRelease(v92);
                                          }
                                          if (v91) {
                                            CFRelease(v91);
                                          }
                                          if (v96) {
                                            CFRelease(v96);
                                          }
                                          if (v95) {
                                            CFRelease(v95);
                                          }
                                          if (v94) {
                                            CFRelease(v94);
                                          }
                                          if (cf) {
                                            CFRelease(cf);
                                          }
                                          if (v61)
                                          {
                                            CFTypeRef v69 = v61;
                                            goto LABEL_196;
                                          }
                                          goto LABEL_4;
                                        }
                                      }
                                      CFTypeRef v12 = 0;
LABEL_118:
                                      OSStatus Dict = -12713;
                                      goto LABEL_119;
                                    }
LABEL_202:
                                    OSStatus Dict = v47;
                                    CFTypeRef v12 = 0;
                                    CFStringRef v61 = 0;
                                    goto LABEL_119;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    CFTypeRef v12 = 0;
    CFStringRef v61 = 0;
    goto LABEL_118;
  }
  if (v15 != 2004251764 && v15 != 2021028980) {
    goto LABEL_17;
  }
LABEL_23:
  v105[0] = 0;
  long long v139 = 0u;
  long long v140 = 0u;
  long long v137 = 0u;
  long long v138 = 0u;
  long long v135 = 0u;
  long long v136 = 0u;
  long long v133 = 0u;
  long long v134 = 0u;
  long long v131 = 0u;
  long long v132 = 0u;
  long long v129 = 0u;
  long long v130 = 0u;
  long long v127 = 0u;
  long long v128 = 0u;
  long long v125 = 0u;
  long long v126 = 0u;
  long long v123 = 0u;
  long long v124 = 0u;
  long long v121 = 0u;
  long long v122 = 0u;
  v99[0] = 0;
  v102[0] = 0;
  CFTypeRef v117 = 0;
  CFTypeRef v113 = 0;
  if (size <= 0xF) {
    goto LABEL_2;
  }
  if (ParseExtensionAtomsInDescription((uint64_t)textDescriptionData, size, (__CFDictionary **)v99, (__CFDictionary **)v102, (__CFDictionary **)&v117, (__CFDictionary **)&v113))
  {
    CFIndex v17 = 0;
  }
  else
  {
    size_t v70 = (CFTypeRef *)&v131;
    if (v113)
    {
      size_t v70 = (CFTypeRef *)&v131 + 1;
      *(void *)&long long v131 = CFRetain(v113);
      *(void *)&long long v121 = @"SampleDescriptionExtensionAtoms";
      CFIndex v17 = 1;
    }
    else
    {
      CFIndex v17 = 0;
    }
    if (v102[0])
    {
      *v70++ = CFRetain(v102[0]);
      size_t v73 = (void *)((unint64_t)&v121 | (8 * v17++));
      *size_t v73 = @"rqdf";
    }
    if (v117)
    {
      *size_t v70 = CFRetain(v117);
      *((void *)&v121 + v17++) = @"InlineResources";
    }
  }
  __int16 v74 = (CFTypeRef *)&v131;
  OSStatus Dict = createDict(allocator, (const void **)&v121, (const void **)&v131, v17, (CFDictionaryRef *)v105);
  CFTypeRef v12 = v105[0];
  if (Dict && v105[0])
  {
    CFRelease(v105[0]);
    CFTypeRef v12 = 0;
  }
  do
  {
    if (*v74) {
      CFRelease(*v74);
    }
    ++v74;
  }
  while (v74 < v141);
  if (v99[0]) {
    CFRelease(v99[0]);
  }
  if (v102[0]) {
    CFRelease(v102[0]);
  }
  if (v117) {
    CFRelease(v117);
  }
  CFTypeRef v69 = v113;
  if (v113) {
    goto LABEL_196;
  }
LABEL_4:
  if (!Dict) {
    OSStatus Dict = CMFormatDescriptionCreate(allocator, mediaType, bswap32(*((_DWORD *)textDescriptionData + 1)), (CFDictionaryRef)v12, v6);
  }
  if (v12) {
    CFRelease(v12);
  }
  return Dict;
}

OSStatus CMTextFormatDescriptionCreateFromBigEndianTextDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef textDescriptionBlockBuffer, CMTextDescriptionFlavor flavor, CMMediaType mediaType, CMTextFormatDescriptionRef *formatDescriptionOut)
{
  CFTypeRef cf = 0;
  if (textDescriptionBlockBuffer)
  {
    dataPointerOut = 0;
    Dataint Length = CMBlockBufferGetDataLength(textDescriptionBlockBuffer);
    if (DataLength)
    {
      size_t v10 = DataLength;
      if (CMBlockBufferIsRangeContiguous(textDescriptionBlockBuffer, 0, 0))
      {
        unsigned int v11 = (void *)CFRetain(textDescriptionBlockBuffer);
        CFTypeRef cf = v11;
      }
      else
      {
        OSStatus Contiguous = CMBlockBufferCreateContiguous(allocator, textDescriptionBlockBuffer, allocator, 0, 0, v10, 0, (CMBlockBufferRef *)&cf);
        if (Contiguous) {
          goto LABEL_12;
        }
        unsigned int v11 = (void *)cf;
      }
      OSStatus DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)v11, 0, 0, 0, &dataPointerOut);
      if (!DataPointer) {
        OSStatus DataPointer = CMTextFormatDescriptionCreateFromBigEndianTextDescriptionData(allocator, (const uint8_t *)dataPointerOut, v10, v13, mediaType, formatDescriptionOut);
      }
    }
    else
    {
      OSStatus DataPointer = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    }
    OSStatus Contiguous = DataPointer;
LABEL_12:
    if (cf) {
      CFRelease(cf);
    }
    return Contiguous;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTextFormatDescriptionCopyAsBigEndianTextDescriptionBlockBuffer(CFAllocatorRef allocator, CMTextFormatDescriptionRef textFormatDescription, CMTextDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  CMBlockBufferRef v69 = 0;
  dataPointerOut = 0;
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(textFormatDescription);
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(textFormatDescription);
  CFDictionaryRef v9 = Extensions;
  int v10 = 0;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  long long v66 = 0;
  value = 0;
  CFIndex v65 = 0;
  CFDictionaryRef v62 = 0;
  CFDictionaryRef theDict = 0;
  CFNumberRef v60 = 0;
  CFDictionaryRef v61 = 0;
  uint64_t context = 0;
  uint64_t v59 = 0;
  size_t v57 = 0;
  CFNumberRef v52 = blockBufferOut;
  if (MediaSubType <= 2004251763)
  {
    if (MediaSubType != 1937010800)
    {
      int v11 = 1937142900;
      goto LABEL_6;
    }
    CFStringRef v55 = 0;
    CFStringRef theString = 0;
    CFStringRef v54 = 0;
    if (!Extensions
      || (int ValueIfPresent = CFDictionaryGetValueIfPresent(Extensions, @"XMLNamespaces", (const void **)&theString),
          CFDictionaryGetValueIfPresent(v9, @"XMLSchemas", (const void **)&v55),
          int v17 = CFDictionaryGetValueIfPresent(v9, @"AuxiliaryMIMETypes", (const void **)&v54),
          !ValueIfPresent))
    {
      uint64_t v19 = 4294954581;
      goto LABEL_170;
    }
    int v18 = v17;
    if (theString)
    {
      uint64_t v19 = emitUTF8StringFromCFString(0, 0, theString, &v57);
      if (v19) {
        goto LABEL_170;
      }
      size_t v14 = v57;
    }
    else
    {
      size_t v14 = 0;
    }
    if (v55)
    {
      uint64_t v19 = emitUTF8StringFromCFString(0, 0, v55, &v57);
      if (v19) {
        goto LABEL_170;
      }
      size_t v13 = v57;
    }
    else
    {
      size_t v13 = 0;
    }
    LODWORD(v50) = v18;
    if (!v54)
    {
      size_t v12 = 0;
      goto LABEL_36;
    }
    uint64_t v19 = emitUTF8StringFromCFString(0, 0, v54, &v57);
    if (!v19)
    {
      size_t v12 = v57;
LABEL_36:
      uint64_t v51 = 0;
      HIDWORD(v50) = 0;
      int v15 = 0;
      goto LABEL_37;
    }
LABEL_170:
    OSStatus v47 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    goto LABEL_161;
  }
  if (MediaSubType == 2004251764) {
    goto LABEL_8;
  }
  int v11 = 2021028980;
LABEL_6:
  if (MediaSubType != v11) {
    int v10 = 1;
  }
LABEL_8:
  if (MediaSubType != 1937142900 && MediaSubType != 2004251764 && MediaSubType != 2021028980 && !Extensions)
  {
    uint64_t v19 = 4294954584;
    goto LABEL_170;
  }
  if (!Extensions) {
    int v10 = 0;
  }
  if (v10 == 1)
  {
    if (CFDictionaryGetValueIfPresent(Extensions, @"FontTable", (const void **)&value) == 1)
    {
      uint64_t context = 0;
      uint64_t v59 = 0;
      CFNumberRef v60 = 0;
      CFDictionaryApplyFunction((CFDictionaryRef)value, (CFDictionaryApplierFunction)FontTableEmittingApplierFunction, &context);
      size_t v12 = 0;
      size_t v13 = 0;
      size_t v14 = 0;
      LODWORD(v50) = 0;
      HIDWORD(v50) = (unsigned __int16)context;
      uint64_t v51 = v59 + 10;
    }
    else
    {
      uint64_t v50 = 0;
      uint64_t v51 = 0;
      size_t v12 = 0;
      size_t v13 = 0;
      size_t v14 = 0;
    }
    int v15 = 1;
  }
  else
  {
    HIDWORD(v50) = 0;
    if (!Extensions)
    {
      uint64_t v20 = 0;
      long long __src = 0;
      uint64_t v51 = 0;
      size_t v12 = 0;
      size_t v13 = 0;
      size_t v14 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      LODWORD(v50) = 0;
      goto LABEL_59;
    }
    uint64_t v51 = 0;
    size_t v12 = 0;
    size_t v13 = 0;
    size_t v14 = 0;
    LODWORD(v50) = 0;
    int v15 = 0;
  }
LABEL_37:
  if (CFDictionaryGetValueIfPresent(v9, @"SampleDescriptionExtensionAtoms", (const void **)&theDict) == 1)
  {
    uint64_t context = 0;
    uint64_t v59 = 0;
    CFNumberRef v60 = 0;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)MiscExtensionEmittingApplierFunction, &context);
    uint64_t v21 = v59;
    if ((v15 & 1) == 0) {
      goto LABEL_48;
    }
  }
  else
  {
    uint64_t v21 = 0;
    long long __src = 0;
    uint64_t v20 = 0;
    if (!v15) {
      goto LABEL_49;
    }
  }
  if (CFDictionaryGetValueIfPresent(v9, @"DefaultFontName", (const void **)&v68) != 1 || v68 == 0) {
    goto LABEL_48;
  }
  CFNumberRef v25 = (char *)malloc_type_malloc(0x100uLL, 0x3B333B4uLL);
  if (!CFStringGetPascalString((CFStringRef)v68, (StringPtr)v25, 256, 0))
  {
    free(v25);
LABEL_48:
    long long __src = 0;
    uint64_t v20 = 0;
    goto LABEL_49;
  }
  long long __src = v25;
  uint64_t v20 = *v25;
LABEL_49:
  if (MediaSubType == 1937142900 || MediaSubType == 2021028980 || MediaSubType == 2004251764)
  {
    if (CFDictionaryGetValueIfPresent(v9, @"rqdf", (const void **)&v62) == 1)
    {
      uint64_t context = 0;
      uint64_t v59 = 0;
      CFNumberRef v60 = 0;
      CFDictionaryApplyFunction(v62, (CFDictionaryApplierFunction)RequiredFeaturesEmittingApplierFunction, &context);
      uint64_t v22 = v59;
    }
    else
    {
      uint64_t v22 = 0;
    }
    if (CFDictionaryGetValueIfPresent(v9, @"InlineResources", (const void **)&v61) == 1)
    {
      uint64_t context = 0;
      uint64_t v59 = 0;
      CFNumberRef v60 = 0;
      CFDictionaryApplyFunction(v61, (CFDictionaryApplierFunction)InlineResourcesEmittingApplierFunction, &context);
      uint64_t v23 = v59;
      goto LABEL_59;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  uint64_t v23 = 0;
LABEL_59:
  if (MediaSubType <= 1952807027)
  {
    if (MediaSubType == 1937010800)
    {
      BOOL v30 = (v21 | v12) != 0;
      if (v13) {
        BOOL v30 = v13;
      }
      if (v21) {
        BOOL v31 = v12 == 0;
      }
      else {
        BOOL v31 = 0;
      }
      if (v31) {
        uint64_t v32 = 1;
      }
      else {
        uint64_t v32 = v12;
      }
      uint64_t v28 = v14 + v32 + v30 + 16;
      uint64_t v27 = 16;
      uint64_t v29 = v28;
      goto LABEL_78;
    }
    int v26 = 1937142900;
  }
  else
  {
    if (MediaSubType == 1952807028)
    {
      uint64_t v27 = 0;
      uint64_t v29 = v20 + 59;
      uint64_t v28 = v20 + 59 + v51;
      goto LABEL_78;
    }
    if (MediaSubType == 2021028980)
    {
LABEL_66:
      uint64_t v27 = 0;
      uint64_t v28 = v22 + v23 + 16;
      uint64_t v29 = 16;
      goto LABEL_78;
    }
    int v26 = 2004251764;
  }
  if (MediaSubType == v26) {
    goto LABEL_66;
  }
  uint64_t v27 = 0;
  uint64_t v28 = v51 + 46;
  uint64_t v29 = 46;
LABEL_78:
  size_t v33 = v28 + v21;
  OSStatus DictionaryNumberWithNtoBFlip = CMBlockBufferCreateWithMemoryBlock(allocator, 0, v28 + v21, allocator, 0, 0, v28 + v21, 1u, &v69);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  CMBlockBufferGetDataPointer(v69, 0, 0, 0, &dataPointerOut);
  bzero(dataPointerOut, v33);
  if (MediaSubType <= 1952807027)
  {
    if (MediaSubType != 1937010800)
    {
      int v35 = 1937142900;
LABEL_85:
      if (MediaSubType == v35) {
        goto LABEL_86;
      }
      CFNumberRef v44 = dataPointerOut;
      *(_DWORD *)dataPointerOut = bswap32(v33);
      *((_DWORD *)v44 + 1) = bswap32(CMFormatDescriptionGetMediaSubType(textFormatDescription));
      *((_WORD *)v44 + 7) = -1;
      OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip(v9, @"DisplayFlags", 3, (_DWORD *)v44 + 4);
      if (DictionaryNumberWithNtoBFlip) {
        goto LABEL_167;
      }
      OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip(v9, @"HorizontalJustification", 1, (_DWORD *)v44 + 5);
      if (DictionaryNumberWithNtoBFlip) {
        goto LABEL_167;
      }
      OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip(v9, @"VerticalJustification", 1, v44 + 21);
      if (DictionaryNumberWithNtoBFlip) {
        goto LABEL_167;
      }
      if (CFDictionaryGetValueIfPresent(v9, @"BackgroundColor", (const void **)&v67) == 1)
      {
        OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Red", 1, v44 + 22);
        if (DictionaryNumberWithNtoBFlip) {
          goto LABEL_167;
        }
        OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Green", 1, v44 + 23);
        if (DictionaryNumberWithNtoBFlip) {
          goto LABEL_167;
        }
        OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Blue", 1, (_DWORD *)v44 + 6);
        if (DictionaryNumberWithNtoBFlip) {
          goto LABEL_167;
        }
        OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Alpha", 1, v44 + 25);
        if (DictionaryNumberWithNtoBFlip) {
          goto LABEL_167;
        }
        if (CFDictionaryGetValueIfPresent(v9, @"DefaultTextBox", (const void **)&v67) == 1)
        {
          OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Top", 2, v44 + 26);
          if (DictionaryNumberWithNtoBFlip) {
            goto LABEL_167;
          }
          OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Left", 2, (_DWORD *)v44 + 7);
          if (DictionaryNumberWithNtoBFlip) {
            goto LABEL_167;
          }
          OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Right", 2, (_DWORD *)v44 + 8);
          if (DictionaryNumberWithNtoBFlip) {
            goto LABEL_167;
          }
          OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Bottom", 2, v44 + 30);
          if (DictionaryNumberWithNtoBFlip) {
            goto LABEL_167;
          }
          if (CFDictionaryGetValueIfPresent(v9, @"DefaultStyle", (const void **)&v67) == 1)
          {
            OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"StartChar", 2, v44 + 34);
            if (DictionaryNumberWithNtoBFlip) {
              goto LABEL_167;
            }
            OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"EndChar", 2, (_DWORD *)v44 + 9);
            if (DictionaryNumberWithNtoBFlip) {
              goto LABEL_167;
            }
            OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Font", 2, v44 + 38);
            if (DictionaryNumberWithNtoBFlip) {
              goto LABEL_167;
            }
            OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"FontFace", 1, (_DWORD *)v44 + 10);
            if (DictionaryNumberWithNtoBFlip) {
              goto LABEL_167;
            }
            OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"FontSize", 1, v44 + 41);
            if (DictionaryNumberWithNtoBFlip) {
              goto LABEL_167;
            }
            if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v67, @"ForegroundColor", (const void **)&v65) == 1)
            {
              OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, @"Red", 1, v44 + 42);
              if (!DictionaryNumberWithNtoBFlip)
              {
                OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, @"Green", 1, v44 + 43);
                if (!DictionaryNumberWithNtoBFlip)
                {
                  OSStatus v39 = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, @"Blue", 1, (_DWORD *)v44 + 11);
                  CFNumberRef v37 = __src;
                  if (!v39)
                  {
                    OSStatus v39 = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, @"Alpha", 1, v44 + 45);
                    if (!v39) {
                      goto LABEL_150;
                    }
                  }
                  goto LABEL_172;
                }
              }
LABEL_167:
              OSStatus v47 = DictionaryNumberWithNtoBFlip;
              CMBlockBufferRef blockBufferOut = v52;
              CFNumberRef v37 = __src;
              goto LABEL_159;
            }
          }
        }
      }
      goto LABEL_165;
    }
    CFNumberRef v40 = dataPointerOut;
    *(_DWORD *)dataPointerOut = bswap32(v33);
    *((_DWORD *)v40 + 1) = bswap32(CMFormatDescriptionGetMediaSubType(textFormatDescription));
    *((_WORD *)v40 + 7) = -1;
    if (CFDictionaryGetValueIfPresent(v9, @"XMLNamespaces", (const void **)&v66) != 1)
    {
LABEL_165:
      uint64_t v41 = 4294954581;
      goto LABEL_166;
    }
    uint64_t v41 = emitUTF8StringFromCFString(v40 + 16, v33 - v27, (CFStringRef)v66, &v57);
    if (!v41)
    {
      long long v42 = &v40[v57 + 16];
      size_t v43 = v29 - v27 - v57;
      if (CFDictionaryGetValueIfPresent(v9, @"XMLSchemas", (const void **)&v66))
      {
        uint64_t v41 = emitUTF8StringFromCFString(v42, v43, (CFStringRef)v66, &v57);
        if (v41) {
          goto LABEL_166;
        }
        v42 += v57;
        v43 -= v57;
      }
      else if (v21 || v50)
      {
        *v42++ = 0;
        --v43;
      }
      if (!CFDictionaryGetValueIfPresent(v9, @"AuxiliaryMIMETypes", (const void **)&v66))
      {
        if (v21)
        {
          *long long v42 = 0;
          --v43;
        }
        goto LABEL_149;
      }
      uint64_t v41 = emitUTF8StringFromCFString(v42, v43, (CFStringRef)v66, &v57);
      if (!v41)
      {
        v43 -= v57;
LABEL_149:
        CFNumberRef v37 = __src;
        if (!v43) {
          goto LABEL_150;
        }
        OSStatus v39 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        goto LABEL_172;
      }
    }
LABEL_166:
    OSStatus DictionaryNumberWithNtoBFlip = FigSignalErrorAt(v41, 0, 0, 0, 0, 0, 0);
    goto LABEL_167;
  }
  if (MediaSubType != 1952807028)
  {
    if (MediaSubType == 2021028980)
    {
LABEL_86:
      CFNumberRef v36 = dataPointerOut;
      *(_DWORD *)dataPointerOut = bswap32(v33);
      *((_DWORD *)v36 + 1) = bswap32(CMFormatDescriptionGetMediaSubType(textFormatDescription));
      *((_WORD *)v36 + 7) = -1;
      CFNumberRef v37 = __src;
LABEL_150:
      CFNumberRef v60 = &dataPointerOut[v29];
      if (value)
      {
        *(_DWORD *)&dataPointerOut[v29] = bswap32(v51);
        CFNumberRef v45 = v60;
        v60 += 4;
        *((_DWORD *)v45 + 1) = 1650553958;
        CFNumberRef v46 = v60;
        v60 += 4;
        *((_WORD *)v46 + 2) = bswap32(HIDWORD(v50)) >> 16;
        v60 += 2;
        CFDictionaryApplyFunction((CFDictionaryRef)value, (CFDictionaryApplierFunction)FontTableEmittingApplierFunction, &context);
      }
      if (theDict) {
        CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)MiscExtensionEmittingApplierFunction, &context);
      }
      CMBlockBufferRef blockBufferOut = v52;
      if (v62) {
        CFDictionaryApplyFunction(v62, (CFDictionaryApplierFunction)RequiredFeaturesEmittingApplierFunction, &context);
      }
      if (v61) {
        CFDictionaryApplyFunction(v61, (CFDictionaryApplierFunction)InlineResourcesEmittingApplierFunction, &context);
      }
      OSStatus v47 = 0;
      goto LABEL_159;
    }
    int v35 = 2004251764;
    goto LABEL_85;
  }
  CFNumberRef v38 = dataPointerOut;
  *(_DWORD *)dataPointerOut = bswap32(v33);
  *((_DWORD *)v38 + 1) = bswap32(CMFormatDescriptionGetMediaSubType(textFormatDescription));
  *((_WORD *)v38 + 7) = -1;
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip(v9, @"DisplayFlags", 3, (_DWORD *)v38 + 4);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip(v9, @"TextJustification", 3, (_DWORD *)v38 + 5);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  if (CFDictionaryGetValueIfPresent(v9, @"BackgroundColor", (const void **)&v67) != 1) {
    goto LABEL_165;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Red", 2, (_DWORD *)v38 + 6);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Green", 2, v38 + 26);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Blue", 2, (_DWORD *)v38 + 7);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  if (CFDictionaryGetValueIfPresent(v9, @"DefaultTextBox", (const void **)&v67) != 1) {
    goto LABEL_165;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Top", 2, v38 + 30);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Left", 2, (_DWORD *)v38 + 8);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Right", 2, (_DWORD *)v38 + 9);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Bottom", 2, v38 + 34);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  if (CFDictionaryGetValueIfPresent(v9, @"DefaultStyle", (const void **)&v67) != 1) {
    goto LABEL_165;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"StartChar", 3, v38 + 38);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Height", 2, v38 + 42);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Ascent", 2, (_DWORD *)v38 + 11);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"Font", 2, v38 + 46);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"FontFace", 1, (_DWORD *)v38 + 12);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, @"FontSize", 2, v38 + 50);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v67, @"ForegroundColor", (const void **)&v65) != 1) {
    goto LABEL_165;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, @"Red", 2, (_DWORD *)v38 + 13);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, @"Green", 2, v38 + 54);
  if (DictionaryNumberWithNtoBFlip) {
    goto LABEL_167;
  }
  OSStatus v39 = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, @"Blue", 2, (_DWORD *)v38 + 14);
  CFNumberRef v37 = __src;
  if (!v39)
  {
    if (__src) {
      memcpy(v38 + 58, __src, v20 + 1);
    }
    goto LABEL_150;
  }
LABEL_172:
  OSStatus v47 = v39;
  CMBlockBufferRef blockBufferOut = v52;
LABEL_159:
  if (v37) {
    free(v37);
  }
LABEL_161:
  CFNumberRef v48 = v69;
  if (v47 && v69)
  {
    CFRelease(v69);
    CFNumberRef v48 = 0;
  }
  *CMBlockBufferRef blockBufferOut = v48;
  return v47;
}

uint64_t emitUTF8StringFromCFString(void *a1, size_t a2, CFStringRef theString, size_t *a4)
{
  size_t __n = 0;
  if (theString && (a1 != 0) == (a2 != 0))
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    unint64_t v8 = FigCreateBytesFromCFString((const __CFAllocator *)*MEMORY[0x1E4F1CF80], theString, 0x8000100u, 1, &__n);
    if (v8)
    {
      CFDictionaryRef v9 = v8;
      size_t v10 = __n;
      if (!a1) {
        goto LABEL_7;
      }
      if (__n <= a2)
      {
        memcpy(a1, v8, __n);
LABEL_7:
        CFAllocatorDeallocate(v7, v9);
        uint64_t result = 0;
        if (a4) {
          *a4 = v10;
        }
        return result;
      }
      uint64_t v12 = 4294954582;
    }
    else
    {
      uint64_t v12 = 4294954583;
    }
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

CFIndex FontTableEmittingApplierFunction(const __CFString *a1, CFStringRef theString, uint64_t a3)
{
  CFIndex Length = CFStringGetLength(theString);
  CFTypeID v7 = CFGetTypeID(a1);
  if (v7 == CFStringGetTypeID() && (CFTypeID v8 = CFGetTypeID(theString), v8 == CFStringGetTypeID()))
  {
    CFIndex maxBufLen = 0;
    v15.CFIndex location = 0;
    v15.length = Length;
    CFIndex result = CFStringGetBytes(theString, v15, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
    if (maxBufLen)
    {
      CFIndex v10 = maxBufLen + *(void *)(a3 + 8) + 3;
      ++*(void *)a3;
      *(void *)(a3 + 8) = v10;
      if (*(void *)(a3 + 16))
      {
        **(_WORD **)(a3 + 16) = bswap32(CFStringGetIntValue(a1)) >> 16;
        uint64_t v11 = *(void *)(a3 + 16);
        *(void *)(a3 + 16) = v11 + 2;
        *(unsigned char *)(v11 + 2) = maxBufLen;
        uint64_t v12 = (UInt8 *)(*(void *)(a3 + 16) + 1);
        *(void *)(a3 + 16) = v12;
        v16.CFIndex location = 0;
        v16.length = Length;
        CFIndex result = CFStringGetBytes(theString, v16, 0x8000100u, 0, 0, v12, maxBufLen, &maxBufLen);
        *(void *)(a3 + 16) += maxBufLen;
      }
    }
    else
    {
      return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

void MiscExtensionEmittingApplierFunction(const __CFString *a1, const __CFData *a2, void *a3)
{
  CFIndex Length = CFStringGetLength(a1);
  CFTypeID v7 = CFGetTypeID(a1);
  if (v7 == CFStringGetTypeID()
    && a2
    && (CFTypeID v8 = CFGetTypeID(a2), v8 == CFDataGetTypeID())
    && (CFIndex v9 = CFDataGetLength(a2), v9 > 0))
  {
    CFIndex v10 = v9;
    uint64_t v11 = a3[1] + v9 + 8;
    ++*a3;
    a3[1] = v11;
    uint64_t v12 = (_DWORD *)a3[2];
    if (v12)
    {
      CFIndex usedBufLen = 0;
      *(_DWORD *)unsigned __int8 buffer = 0;
      *uint64_t v12 = bswap32(v9 + 8);
      a3[2] += 4;
      v17.CFIndex location = 0;
      v17.length = Length;
      CFStringGetBytes(a1, v17, 0, 0, 0, buffer, 4, &usedBufLen);
      if (usedBufLen == 4)
      {
        *(_DWORD *)a3[2] = *(_DWORD *)buffer;
        size_t v13 = (UInt8 *)(a3[2] + 4);
        a3[2] = v13;
        v18.CFIndex location = 0;
        v18.length = v10;
        CFDataGetBytes(a2, v18, v13);
        a3[2] += v10;
      }
      else
      {
        FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t RequiredFeaturesEmittingApplierFunction(const void *a1, const void *a2, void *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    uint64_t result = CFEqual(a1, @"feat");
    if (!result) {
      return result;
    }
    CFIndex maxBufLen = 0;
    CFTypeID v8 = CFGetTypeID(a2);
    if (v8 != CFArrayGetTypeID()) {
      return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    }
    uint64_t result = CFArrayGetCount((CFArrayRef)a2);
    uint64_t v9 = result;
    uint64_t v11 = a3[1];
    CFIndex v10 = (_DWORD *)a3[2];
    a3[1] = v11 + 8;
    if (v10)
    {
      _DWORD *v10 = 0x8000000;
      uint64_t v12 = a3[2];
      a3[2] = v12 + 4;
      *(_DWORD *)(v12 + 4) = 1717858674;
      uint64_t v13 = a3[2] + 4;
      a3[2] = v13;
    }
    else
    {
      uint64_t v13 = 0;
    }
    if (result >= 1)
    {
      CFIndex v14 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a2, v14);
        CFTypeID v16 = CFGetTypeID(ValueAtIndex);
        if (v16 != CFStringGetTypeID()) {
          break;
        }
        CFIndex Length = CFStringGetLength(ValueAtIndex);
        v26.CFIndex location = 0;
        v26.length = Length;
        uint64_t result = CFStringGetBytes(ValueAtIndex, v26, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
        if (!maxBufLen) {
          break;
        }
        unsigned int v18 = maxBufLen + 8;
        CFIndex v19 = a3[1] + maxBufLen + 8;
        ++*a3;
        a3[1] = v19;
        uint64_t v20 = (_DWORD *)a3[2];
        if (v20)
        {
          *uint64_t v20 = bswap32(v18);
          uint64_t v21 = (_DWORD *)(a3[2] + 4);
          a3[2] = v21;
          *uint64_t v21 = 1952540006;
          uint64_t v22 = (UInt8 *)(a3[2] + 4);
          a3[2] = v22;
          v27.CFIndex location = 0;
          v27.length = Length;
          uint64_t result = CFStringGetBytes(ValueAtIndex, v27, 0x8000100u, 0, 0, v22, maxBufLen, &maxBufLen);
          uint64_t v13 = a3[2] + maxBufLen;
          a3[2] = v13;
        }
        else
        {
          uint64_t v13 = 0;
        }
        if (v9 == ++v14) {
          goto LABEL_15;
        }
      }
      return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    }
LABEL_15:
    if (v13)
    {
      unint64_t v23 = a3[1] - v11;
      if (!HIDWORD(v23))
      {
        _DWORD *v10 = bswap32(v23);
        return result;
      }
      return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

void InlineResourcesEmittingApplierFunction(const void *a1, const __CFArray *a2, uint64_t a3)
{
  uint64_t v15 = 0;
  CFTypeID v16 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    if (*(void *)(a3 + 16)) {
      CFTypeID v7 = @"Skipping inline resources [atom writing pass]";
    }
    else {
      CFTypeID v7 = @"Skipping inline resources [data sizing pass]";
    }
    CFShow(v7);
    if (CFEqual(a1, @"InlineResourcesArray"))
    {
      uint64_t v13 = 0;
      memset(v12, 0, sizeof(v12));
      if (a2 && (CFTypeID v8 = CFGetTypeID(a2), v8 == CFArrayGetTypeID()))
      {
        if (!CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 8u, 0, &blockBufferOut)
          && !FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)v12)
          && !FigAtomWriterBeginAtom((uint64_t)v12, 0x76747452u, 0))
        {
          uint64_t v15 = a3;
          CFTypeID v16 = v12;
          FigCFArrayApplyFunction(a2, (void (__cdecl *)(const void *, void *))InlineResourcesPayloadWritingApplierFunc, &v15);
          if (!FigAtomWriterEndAtom((uint64_t)v12))
          {
            DataCFIndex Length = CMBlockBufferGetDataLength(blockBufferOut);
            CFIndex v10 = *(void **)(a3 + 16);
            *(void *)(a3 + 8) += DataLength;
            if (v10)
            {
              size_t v11 = DataLength;
              if (!CMBlockBufferCopyDataBytes(blockBufferOut, 0, DataLength, v10)) {
                *(void *)(a3 + 16) += v11;
              }
            }
          }
        }
      }
      else
      {
        FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
      }
      if (blockBufferOut) {
        CFRelease(blockBufferOut);
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FetchDictionaryNumberWithNtoBFlip(const __CFDictionary *a1, const void *a2, uint64_t a3, _DWORD *a4)
{
  value = 0;
  unsigned int valuePtr = 0;
  unsigned __int16 v8 = 0;
  if (CFDictionaryGetValueIfPresent(a1, a2, (const void **)&value) != 1) {
    return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  }
  CFTypeID v6 = CFGetTypeID(value);
  if (v6 != CFNumberGetTypeID()) {
    return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  }
  if (a3 == 3)
  {
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
    uint64_t result = 0;
    *a4 = bswap32(valuePtr);
  }
  else if (a3 == 2)
  {
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt16Type, &v8);
    uint64_t result = 0;
    *(_WORD *)a4 = bswap32(v8) >> 16;
  }
  else
  {
    if (a3 == 1) {
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt8Type, a4);
    }
    return 0;
  }
  return result;
}

uint64_t createDict(const __CFAllocator *a1, const void **a2, const void **a3, CFIndex a4, CFDictionaryRef *a5)
{
  uint64_t v6 = a4;
  CFTypeID v7 = a3;
  CFDictionaryRef v8 = CFDictionaryCreate(a1, a2, a3, a4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *a5 = v8;
  if (v6 >= 1)
  {
    do
    {
      if (*v7)
      {
        CFRelease(*v7);
        *CFTypeID v7 = 0;
      }
      ++v7;
      --v6;
    }
    while (v6);
    CFDictionaryRef v8 = *a5;
  }
  if (v8) {
    return 0;
  }
  else {
    return 4294954583;
  }
}

uint64_t ParseExtensionAtomsInDescription(uint64_t a1, unint64_t a2, __CFDictionary **a3, __CFDictionary **a4, __CFDictionary **a5, __CFDictionary **a6)
{
  uint64_t v139 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)bytes = 0;
  unsigned int v12 = *(_DWORD *)(a1 + 4);
  int v13 = bswap32(v12);
  BOOL v15 = v12 == 1953789560 || (v13 & 0xFBFFFFFF) == 1937142900;
  if (v13 <= 1952807027)
  {
    if (v13 != 1937010800)
    {
      if (v13 != 1937142900) {
        goto LABEL_17;
      }
      goto LABEL_14;
    }
    LOBYTE(dataPointerOut) = 0;
    LOBYTE(v122) = 0;
    LOBYTE(v120) = 0;
    LOBYTE(v112) = 0;
    long long v113 = 0uLL;
    v111[0] = 0uLL;
    size_t v132 = 0;
    long long v133 = 0;
    size_t lengthAtOffsetOut = 0;
    CFStringRef v126 = 0;
    if (a2 <= 0x10
      || locateXMLSubtitleSampleFields(a1, a2, (char *)&dataPointerOut, (uint64_t *)&v113, (char *)&v122, (size_t *)v111, (char *)&v120, &v132, (char *)&v112, &lengthAtOffsetOut)|| !(_BYTE)dataPointerOut|| (_BYTE)v112 && (!(_BYTE)v122 || !(_BYTE)v120))
    {
      goto LABEL_36;
    }
    unint64_t v20 = *((void *)&v113 + 1) + 16;
    if (*((void *)&v113 + 1) + 16 > a2) {
      goto LABEL_36;
    }
    if ((_BYTE)v122)
    {
      v20 += *((void *)&v111[0] + 1);
      if (v20 > a2) {
        goto LABEL_36;
      }
      if ((_BYTE)v120)
      {
        v20 += (unint64_t)v133;
        if (v20 > a2) {
          goto LABEL_36;
        }
      }
    }
    else if ((_BYTE)v120)
    {
      goto LABEL_36;
    }
    unint64_t v18 = a2 - v20;
    if (a2 >= v20)
    {
      int v99 = 0;
      uint64_t v17 = a1 + v20;
      goto LABEL_48;
    }
LABEL_36:
    uint64_t v21 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    uint64_t v22 = 0;
    unint64_t v23 = 0;
    OSStatus v24 = 0;
    CFDataRef v25 = 0;
    CFStringRef v26 = 0;
    CFRange v27 = 0;
    goto LABEL_37;
  }
  if (v13 == 1952807028)
  {
    if (a2 > 0x3A)
    {
      unint64_t v19 = *(unsigned __int8 *)(a1 + 58) + 59;
      unint64_t v18 = a2 - v19;
      if (a2 >= v19)
      {
        uint64_t v17 = a1 + v19;
        goto LABEL_22;
      }
    }
    goto LABEL_36;
  }
  if (v13 != 2021028980 && v13 != 2004251764)
  {
LABEL_17:
    if (a2 > 0x2D)
    {
      uint64_t v17 = a1 + 46;
      unint64_t v18 = a2 - 46;
LABEL_22:
      int v99 = 1;
      goto LABEL_48;
    }
    goto LABEL_36;
  }
LABEL_14:
  int v99 = 0;
  uint64_t v17 = a1 + 16;
  unint64_t v18 = a2 - 16;
LABEL_48:
  if (v18 < 9)
  {
    CFStringRef v26 = 0;
    CFDataRef v25 = 0;
    uint64_t v21 = 0;
    goto LABEL_225;
  }
  BOOL v97 = v15;
  v90 = a3;
  CFTypeRef v91 = a4;
  CFTypeRef v92 = a5;
  unsigned int v93 = a6;
  CFTypeRef v95 = 0;
  CFTypeRef v96 = 0;
  CFTypeRef v94 = 0;
  CFTypeRef v98 = 0;
  CFAllocatorRef v29 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v30 = v17;
  do
  {
    unsigned int v31 = *(_DWORD *)(v30 + 4);
    signed int v32 = bswap32(*(_DWORD *)v30);
    *(_DWORD *)bytes = bswap32(v31);
    if (v32 <= 7)
    {
      uint64_t v21 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      CFDataRef v25 = 0;
      goto LABEL_247;
    }
    uint64_t v33 = v32;
    unint64_t v106 = v18 - 8;
    if (v32 - 9 >= v18 - 8) {
      break;
    }
    unint64_t v34 = v32 - 8;
    int v35 = v99;
    if (v31 != 1650553958) {
      int v35 = 0;
    }
    unint64_t length = v33 - 8;
    if (v35 == 1)
    {
      if (v34 > 1)
      {
        unsigned int v36 = bswap32(*(unsigned __int16 *)(v30 + 8)) >> 16;
        unint64_t v37 = v33 - 10;
        if (3 * (__int16)v36 <= (unint64_t)(v33 - 10))
        {
          uint64_t v104 = v33;
          CFIndex v38 = (__int16)v36;
          if ((__int16)v36 < 1)
          {
            CFTypeRef v98 = 0;
LABEL_109:
            uint64_t v33 = v104;
          }
          else
          {
            CFMutableDictionaryRef Mutable = 0;
            uint64_t v101 = v30;
            CFNumberRef v40 = (const UInt8 *)(v30 + 10);
            uint64_t v41 = (__int16)v36;
            while (v37 >= 3)
            {
              CFIndex v42 = v40[2];
              if (v40[2])
              {
                uint64_t v43 = v42 + 3;
                if (v37 < v42 + 3) {
                  break;
                }
                CFStringRef v44 = CFStringCreateWithFormat(v29, 0, @"%d", bswap32(*(unsigned __int16 *)v40) >> 16);
                if (!v44) {
                  break;
                }
                CFStringRef v45 = v44;
                CFStringRef v46 = CFStringCreateWithBytes(v29, v40 + 3, v42, 0x8000100u, 0);
                if (v46)
                {
                  CFStringRef v47 = v46;
                  if (!Mutable) {
                    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v29, v38, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  }
                  CFDictionaryAddValue(Mutable, v45, v47);
                  CFRelease(v47);
                }
                CFRelease(v45);
              }
              else
              {
                uint64_t v43 = 3;
              }
              v40 += v43;
              v37 -= v43;
              if (!--v41)
              {
                CFTypeRef v98 = Mutable;
                uint64_t v30 = v101;
                goto LABEL_109;
              }
            }
            FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            uint64_t v33 = v104;
            if (Mutable) {
              CFRelease(Mutable);
            }
            uint64_t v30 = v101;
          }
          goto LABEL_122;
        }
      }
LABEL_107:
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_122;
    }
    if (v31 != 1717858674 || !v97)
    {
      if (v31 == 1383363702 && v97)
      {
        if (length <= 7) {
          goto LABEL_107;
        }
        memset(v111, 0, sizeof(v111));
        unsigned int v110 = 0;
        uint64_t v109 = 0;
        if (FigAtomStreamInitWithMemoryBlock(v30 + 8, length, 0, 0, (uint64_t)v111)) {
          goto LABEL_122;
        }
        CFMutableArrayRef v59 = 0;
        uint64_t v102 = v30;
        value = 0;
        uint64_t v105 = v33;
        while (1)
        {
          if (FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v111, &v110, &v109)) {
            goto LABEL_207;
          }
          unsigned int v60 = v110;
          if (v110 == 1718773093) {
            goto LABEL_172;
          }
          if (v110 == 1920168547) {
            break;
          }
          uint64_t v82 = value;
          if (!value)
          {
            uint64_t v82 = CFArrayCreateMutable(v29, 0, MEMORY[0x1E4F1D510]);
            unsigned int v60 = v110;
          }
          UInt32 = FigCFNumberCreateUInt32(v29, v60);
          value = v82;
          CFArrayAppendValue(v82, UInt32);
          if (UInt32) {
            goto LABEL_171;
          }
LABEL_172:
          if (FigAtomStreamAdvanceToNextAtom(v111))
          {
            if (!v59)
            {
              CFTypeRef v95 = 0;
              goto LABEL_207;
            }
            CFStringRef v85 = CFDictionaryCreateMutable(v29, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CFDictionaryAddValue(v85, @"InlineResourcesArray", v59);
            CFTypeRef v95 = v85;
            if (value)
            {
              CFDictionaryAddValue(v85, @"UnrecognizedAtoms", value);
              CFStringRef v86 = value;
              goto LABEL_208;
            }
LABEL_210:
            CFMutableArrayRef v58 = v59;
            goto LABEL_121;
          }
        }
        if (!v59) {
          CFMutableArrayRef v59 = CFArrayCreateMutable(v29, 0, MEMORY[0x1E4F1D510]);
        }
        int v121 = 0;
        uint64_t v120 = 0;
        long long v119 = 0u;
        long long v118 = 0u;
        long long v117 = 0u;
        long long v116 = 0u;
        long long v115 = 0u;
        long long v114 = 0u;
        long long v113 = 0u;
        CMBlockBufferRef v112 = 0;
        CurrentAtomTypeAndDataCFIndex Length = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v111, &v121, &v120);
        if (CurrentAtomTypeAndDataLength
          || (CurrentAtomTypeAndDataCFIndex Length = FigAtomStreamInitWithParent((uint64_t)v111, 0, (uint64_t)&v113)) != 0)
        {
          int v69 = CurrentAtomTypeAndDataLength;
          UInt32 = 0;
          goto LABEL_194;
        }
        long long v100 = v59;
        CFNumberRef v62 = 0;
        CFStringRef v63 = 0;
        UInt32 = 0;
        int v65 = 0;
        int v66 = 0;
        CFDataRef v67 = 0;
        while (2)
        {
          while (2)
          {
            while (2)
            {
              int v68 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v113, &v121, &v120);
              if (v68) {
                goto LABEL_184;
              }
              if (v121 == 1684108385)
              {
                size_t v132 = 0;
                size_t lengthAtOffsetOut = 0;
                dataPointerOut = 0;
                if (v66)
                {
                  int v66 = 1;
                  continue;
                }
                int v68 = FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)&v113, 0, 0, &v112);
                if (v68) {
                  goto LABEL_184;
                }
                DataCFIndex Length = CMBlockBufferGetDataLength(v112);
                int DataPointer = CMBlockBufferGetDataPointer(v112, 0, &v132, &lengthAtOffsetOut, &dataPointerOut);
                if (DataPointer) {
                  goto LABEL_200;
                }
                CFDataRef v67 = CFDataCreate(v29, (const UInt8 *)dataPointerOut, DataLength);
                if (!v67)
                {
                  int DataPointer = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_200:
                  int v69 = DataPointer;
                  if (!v62) {
                    goto LABEL_187;
                  }
LABEL_186:
                  CFRelease(v62);
                  goto LABEL_187;
                }
                int v66 = 1;
                goto LABEL_163;
              }
              break;
            }
            if (v121 == 1954115685)
            {
              if (v65)
              {
                int v65 = 1;
                continue;
              }
              int v124 = 0;
              size_t v132 = 0;
              size_t lengthAtOffsetOut = 0;
              int v69 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v113, &v124, &v132);
              CFNumberRef v62 = 0;
              if (v69)
              {
                CFStringRef v63 = 0;
                UInt32 = 0;
                goto LABEL_161;
              }
              CFStringRef v63 = 0;
              UInt32 = 0;
              if (v132 < 0xA) {
                goto LABEL_161;
              }
              long long v122 = 0;
              dataPointerOut = 0;
              int BBuf = FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)&v113, 0, 0, (CMBlockBufferRef *)&lengthAtOffsetOut);
              if (BBuf)
              {
                int v69 = BBuf;
              }
              else
              {
                int v69 = CMBlockBufferGetDataPointer((CMBlockBufferRef)lengthAtOffsetOut, 0, (size_t *)&dataPointerOut, 0, &v122);
                if (!v69)
                {
                  int v71 = v122;
                  CFNumberRef v62 = FigCFNumberCreateUInt32(v29, bswap32(*((_DWORD *)v122 + 1)));
                  CFIndex v72 = v71 + 8;
                  size_t v73 = dataPointerOut - 8;
                  size_t v74 = strnlen(v72, (size_t)(dataPointerOut - 8));
                  CFStringRef v63 = 0;
                  if (v74 && (size_t v75 = v74, v74 < (unint64_t)v73))
                  {
                    CFStringRef v63 = CFStringCreateWithBytes(v29, (const UInt8 *)v72, v74, 0, 1u);
                    CFStringRef v76 = &dataPointerOut[-v75 - 9];
                    if ((unint64_t)dataPointerOut <= v75 + 9)
                    {
                      UInt32 = 0;
LABEL_158:
                      int v69 = 0;
                    }
                    else
                    {
                      CFStringRef v77 = &v72[v75 + 1];
                      size_t v78 = strnlen(v77, (size_t)v76);
                      int v69 = 0;
                      UInt32 = 0;
                      if (v78 && v78 < (unint64_t)v76)
                      {
                        UInt32 = CFStringCreateWithBytes(v29, (const UInt8 *)v77, v78, 0, 1u);
                        goto LABEL_158;
                      }
                    }
                  }
                  else
                  {
                    UInt32 = 0;
                  }
LABEL_159:
                  if (lengthAtOffsetOut) {
                    CFRelease((CFTypeRef)lengthAtOffsetOut);
                  }
LABEL_161:
                  if (v69) {
                    goto LABEL_185;
                  }
                  int v65 = 1;
                  break;
                }
              }
              CFNumberRef v62 = 0;
              CFStringRef v63 = 0;
              UInt32 = 0;
              goto LABEL_159;
            }
            break;
          }
LABEL_163:
          int v81 = FigAtomStreamAdvanceToNextAtom(&v113);
          if (v81 == -12890)
          {
            int v69 = 0;
LABEL_175:
            if (!v65 || !v66) {
              goto LABEL_183;
            }
            long long v137 = 0u;
            long long v138 = 0u;
            long long v136 = 0u;
            long long v130 = 0u;
            long long v131 = 0u;
            long long v129 = 0u;
            size_t v132 = (size_t)@"resource_role";
            long long v133 = @"resource_mimetype";
            size_t lengthAtOffsetOut = (size_t)v62;
            CFStringRef v126 = v63;
            long long v134 = @"resource_mimetype_URI";
            long long v135 = @"resource_payload";
            long long v127 = UInt32;
            CFDataRef v128 = v67;
            UInt32 = CFDictionaryCreate(v29, (const void **)&v132, (const void **)&lengthAtOffsetOut, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            uint64_t v83 = 0;
            CFMutableArrayRef v59 = v100;
            uint64_t v30 = v102;
            do
            {
              CFStringRef v84 = *(const void **)((char *)&lengthAtOffsetOut + v83);
              if (v84) {
                CFRelease(v84);
              }
              v83 += 8;
            }
            while (v83 != 32);
            if (!UInt32)
            {
              CFDataRef v67 = 0;
              CFStringRef v63 = 0;
              CFNumberRef v62 = 0;
LABEL_183:
              int v68 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
LABEL_184:
              int v69 = v68;
LABEL_185:
              if (v62) {
                goto LABEL_186;
              }
LABEL_187:
              if (v63) {
                CFRelease(v63);
              }
              if (UInt32) {
                CFRelease(UInt32);
              }
              uint64_t v30 = v102;
              if (v67) {
                CFRelease(v67);
              }
              UInt32 = 0;
              CFMutableArrayRef v59 = v100;
            }
LABEL_194:
            if (v112) {
              CFRelease(v112);
            }
            if (!v69)
            {
              CFArrayAppendValue(v59, UInt32);
              uint64_t v33 = v105;
              if (!UInt32) {
                goto LABEL_172;
              }
LABEL_171:
              CFRelease(UInt32);
              goto LABEL_172;
            }
            if (UInt32) {
              CFRelease(UInt32);
            }
            uint64_t v33 = v105;
LABEL_207:
            CFStringRef v86 = value;
            if (value) {
LABEL_208:
            }
              CFRelease(v86);
            if (!v59) {
              goto LABEL_122;
            }
            goto LABEL_210;
          }
          int v69 = v81;
          if (v81) {
            goto LABEL_175;
          }
          continue;
        }
      }
      CFDataRef v25 = CFDataCreate(v29, (const UInt8 *)(v30 + 8), length);
      if (v25)
      {
        *(_DWORD *)bytes = bswap32(*(unsigned int *)bytes);
        CFStringRef v26 = CFStringCreateWithBytes(v29, bytes, 4, 0, 0);
        if (v26)
        {
          size_t v57 = v96;
          if (v96 || (size_t v57 = CFDictionaryCreateMutable(v29, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) != 0)
          {
            CFTypeRef v96 = v57;
            CFDictionaryAddValue(v57, v26, v25);
            CFRelease(v26);
            goto LABEL_120;
          }
          uint64_t v21 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
          CFRange v27 = 0;
          a5 = v92;
          a6 = v93;
          a3 = v90;
          a4 = v91;
          unint64_t v23 = v94;
          OSStatus v24 = v95;
          uint64_t v22 = v98;
LABEL_37:
          if (!v21) {
            goto LABEL_229;
          }
          uint64_t v28 = v27;
          if (v22)
          {
            CFRelease(v22);
            CFRange v27 = v28;
          }
          if (v23)
          {
            CFRelease(v23);
            CFRange v27 = v28;
          }
          if (v24)
          {
            CFRelease(v24);
            CFRange v27 = v28;
          }
          if (!v27)
          {
            uint64_t v22 = 0;
            unint64_t v23 = 0;
            OSStatus v24 = 0;
            if (a3) {
              goto LABEL_230;
            }
            goto LABEL_226;
          }
          CFRelease(v27);
LABEL_225:
          uint64_t v22 = 0;
          unint64_t v23 = 0;
          OSStatus v24 = 0;
          CFRange v27 = 0;
          if (a3) {
            goto LABEL_230;
          }
          goto LABEL_226;
        }
        uint64_t v21 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_248:
        a5 = v92;
        a6 = v93;
        a3 = v90;
        a4 = v91;
        unint64_t v23 = v94;
        OSStatus v24 = v95;
        uint64_t v22 = v98;
        CFRange v27 = v96;
        goto LABEL_37;
      }
      uint64_t v21 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_247:
      CFStringRef v26 = 0;
      goto LABEL_248;
    }
    if (length <= 7) {
      goto LABEL_107;
    }
    long long v119 = 0u;
    long long v118 = 0u;
    long long v117 = 0u;
    long long v116 = 0u;
    long long v115 = 0u;
    long long v114 = 0u;
    long long v113 = 0u;
    LODWORD(v112) = 0;
    long long v122 = 0;
    if (FigAtomStreamInitWithMemoryBlock(v30 + 8, length, 0, 0, (uint64_t)&v113)) {
      goto LABEL_122;
    }
    uint64_t v49 = v33;
    CFDataRef v25 = 0;
    uint64_t v50 = 0;
    while (!FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v113, &v112, &v122))
    {
      unsigned int v51 = v112;
      if (v112 != 1718773093)
      {
        if (v112 == 1717920116)
        {
          if (!v25) {
            CFDataRef v25 = CFArrayCreateMutable(v29, 0, MEMORY[0x1E4F1D510]);
          }
          LODWORD(v120) = 0;
          *(void *)&v111[0] = 0;
          size_t v132 = 0;
          int v52 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v113, &v120, v111);
          if (v52 || *(uint64_t *)&v111[0] < 1)
          {
            if (v52) {
              break;
            }
LABEL_116:
            FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            break;
          }
          size_t lengthAtOffsetOut = 0;
          dataPointerOut = 0;
          OSStatus v53 = FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)&v113, 0, 0, (CMBlockBufferRef *)&v132);
          if (v53)
          {
            OSStatus v54 = v53;
LABEL_87:
            CFStringRef v55 = 0;
          }
          else
          {
            OSStatus v54 = CMBlockBufferGetDataPointer((CMBlockBufferRef)v132, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
            if (v54) {
              goto LABEL_87;
            }
            CFStringRef v55 = CFStringCreateWithBytes(v29, (const UInt8 *)dataPointerOut, lengthAtOffsetOut, 0, 1u);
          }
          if (v132) {
            CFRelease((CFTypeRef)v132);
          }
          if (v54)
          {
            if (v55) {
              CFRelease(v55);
            }
            break;
          }
          if (!v55) {
            goto LABEL_116;
          }
          CFArrayAppendValue(v25, v55);
        }
        else
        {
          if (!v50)
          {
            uint64_t v50 = CFArrayCreateMutable(v29, 0, MEMORY[0x1E4F1D510]);
            unsigned int v51 = v112;
          }
          CFStringRef v55 = FigCFNumberCreateUInt32(v29, v51);
          CFArrayAppendValue(v50, v55);
          if (!v55) {
            goto LABEL_99;
          }
        }
        CFRelease(v55);
      }
LABEL_99:
      if (FigAtomStreamAdvanceToNextAtom(&v113))
      {
        if (v25)
        {
          v87 = CFDictionaryCreateMutable(v29, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionaryAddValue(v87, @"feat", v25);
          CFTypeRef v94 = v87;
          if (!v50)
          {
            uint64_t v33 = v49;
            goto LABEL_120;
          }
          CFDictionaryAddValue(v87, @"UnrecognizedAtoms", v50);
          goto LABEL_118;
        }
        CFTypeRef v94 = 0;
        break;
      }
    }
    if (!v50) {
      goto LABEL_119;
    }
LABEL_118:
    CFRelease(v50);
LABEL_119:
    uint64_t v33 = v49;
    if (!v25) {
      goto LABEL_122;
    }
LABEL_120:
    CFMutableArrayRef v58 = v25;
LABEL_121:
    CFRelease(v58);
LABEL_122:
    unint64_t v18 = v106 - length;
    v30 += v33;
  }
  while (v106 - length > 8);
  CFStringRef v26 = 0;
  CFDataRef v25 = 0;
  uint64_t v21 = 0;
  a5 = v92;
  a6 = v93;
  a3 = v90;
  a4 = v91;
  unint64_t v23 = v94;
  OSStatus v24 = v95;
  uint64_t v22 = v98;
  CFRange v27 = v96;
LABEL_229:
  if (a3)
  {
LABEL_230:
    *a3 = v22;
    goto LABEL_231;
  }
LABEL_226:
  if (v22)
  {
    size_t v88 = v27;
    CFRelease(v22);
    CFRange v27 = v88;
  }
LABEL_231:
  if (a4)
  {
    *a4 = v23;
    unint64_t v23 = 0;
  }
  if (a5)
  {
    *a5 = v24;
    OSStatus v24 = 0;
  }
  *a6 = v27;
  if (v23) {
    CFRelease(v23);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v25) {
    CFRelease(v25);
  }
  return v21;
}

uint64_t locateXMLSubtitleSampleFields(uint64_t a1, unint64_t a2, char *a3, uint64_t *a4, char *a5, size_t *a6, char *a7, size_t *a8, char *a9, void *a10)
{
  unint64_t v13 = a2 - 16;
  if (a2 <= 0x10 || (size_t v16 = strnlen((const char *)(a1 + 16), a2 - 16), v17 = v16 + 1, v16 + 1 > v13))
  {
    uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    char v29 = 0;
    char v21 = 0;
    char v22 = 0;
    uint64_t v30 = 0;
    size_t v17 = 0;
    size_t v18 = 0;
    size_t v23 = 0;
    size_t v24 = 0;
    size_t v25 = 0;
    char v26 = 0;
    size_t v27 = 0;
    unint64_t v28 = 0;
  }
  else
  {
    size_t v18 = v16 + 17;
    size_t v19 = a2 - (v16 + 17);
    if (a2 == v16 + 17)
    {
      uint64_t result = 0;
LABEL_5:
      char v21 = 0;
      char v22 = 0;
      size_t v18 = 0;
      size_t v23 = 0;
      size_t v24 = 0;
      size_t v25 = 0;
      char v26 = 0;
      size_t v27 = 0;
      unint64_t v28 = 0;
      char v29 = 1;
      uint64_t v30 = 16;
      goto LABEL_14;
    }
    size_t v23 = strnlen((const char *)(a1 + v18), v19) + 1;
    if (v23 > v19)
    {
      uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_5;
    }
    size_t v24 = v23 + v18;
    if (a2 == v23 + v18)
    {
      uint64_t result = 0;
LABEL_9:
      char v22 = 0;
      size_t v24 = 0;
      size_t v25 = 0;
      char v26 = 0;
      size_t v27 = 0;
      unint64_t v28 = 0;
      char v29 = 1;
      uint64_t v30 = 16;
      char v21 = 1;
      goto LABEL_14;
    }
    size_t v25 = strnlen((const char *)(a1 + v24), a2 - (v23 + v18)) + 1;
    if (v25 > a2 - (v23 + v18))
    {
      uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_9;
    }
    size_t v27 = v25 + v24;
    uint64_t result = 0;
    unint64_t v28 = a2 - (v25 + v24);
    if (a2 == v25 + v24)
    {
      char v26 = 0;
      size_t v27 = 0;
      char v29 = 1;
      uint64_t v30 = 16;
      char v21 = 1;
      char v22 = 1;
    }
    else
    {
      char v29 = 1;
      uint64_t v30 = 16;
      char v21 = 1;
      char v22 = 1;
      char v26 = 1;
    }
  }
LABEL_14:
  if (a3) {
    *a3 = v29;
  }
  if (a5) {
    *a5 = v21;
  }
  if (a7) {
    *a7 = v22;
  }
  if (a9) {
    *a9 = v26;
  }
  if (a4)
  {
    *a4 = v30;
    a4[1] = v17;
  }
  if (a6)
  {
    *a6 = v18;
    a6[1] = v23;
  }
  if (a8)
  {
    *a8 = v24;
    a8[1] = v25;
  }
  if (a10)
  {
    *a10 = v27;
    a10[1] = v28;
  }
  return result;
}

void InlineResourcesPayloadWritingApplierFunc(const __CFDictionary *a1, uint64_t a2)
{
  size_t v18 = 0;
  value = 0;
  size_t v16 = 0;
  size_t v17 = 0;
  unsigned int valuePtr = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  uint64_t v12 = 0;
  memset(v11, 0, sizeof(v11));
  if (CFDictionaryGetValueIfPresent(a1, @"resource_role", (const void **)&value)) {
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
  }
  CFDictionaryGetValueIfPresent(a1, @"resource_mimetype", (const void **)&v18);
  CFDictionaryGetValueIfPresent(a1, @"resource_mimetype_URI", (const void **)&v17);
  CFDictionaryGetValueIfPresent(a1, @"resource_payload", (const void **)&v16);
  size_t v5 = 0;
  if (!value || !v18 || !v16) {
    goto LABEL_26;
  }
  if (FigAtomWriterInitWithParent(v4, (uint64_t)v13)) {
    goto LABEL_28;
  }
  if (FigAtomWriterBeginAtom((uint64_t)v13, 0x72737263u, 0)) {
    goto LABEL_28;
  }
  if (FigAtomWriterInitWithParent((uint64_t)v13, (uint64_t)v11)) {
    goto LABEL_28;
  }
  if (FigAtomWriterBeginAtom((uint64_t)v11, 0x74797065u, 0)) {
    goto LABEL_28;
  }
  if (FigAtomWriterAppendVersionAndFlags((uint64_t)v11, 0, 0)) {
    goto LABEL_28;
  }
  unsigned int valuePtr = bswap32(valuePtr);
  if (FigAtomWriterAppendData((uint64_t)v11, (uint64_t)&valuePtr, 4)) {
    goto LABEL_28;
  }
  if (v18)
  {
    CFIndex Length = CFStringGetLength((CFStringRef)v18);
    CFIndex maxBufLen = 0;
    v20.CFIndex location = 0;
    v20.unint64_t length = Length;
    CFStringGetBytes((CFStringRef)v18, v20, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
    if (!maxBufLen) {
      goto LABEL_27;
    }
    size_t v5 = (UInt8 *)malloc_type_malloc(maxBufLen + 1, 0xCCD4FD58uLL);
    v21.CFIndex location = 0;
    v21.unint64_t length = Length;
    CFStringGetBytes((CFStringRef)v18, v21, 0x8000100u, 0, 0, v5, maxBufLen, &maxBufLen);
    v5[maxBufLen] = 0;
    if (FigAtomWriterAppendData((uint64_t)v11, (uint64_t)v5, maxBufLen + 1)) {
      goto LABEL_26;
    }
    free(v5);
  }
  if (!v17)
  {
LABEL_20:
    if (!FigAtomWriterEndAtom((uint64_t)v11)
      && !FigAtomWriterBeginAtom((uint64_t)v11, 0x64617461u, 0))
    {
      BytePtr = CFDataGetBytePtr((CFDataRef)v16);
      CFIndex v9 = CFDataGetLength((CFDataRef)v16);
      if (!FigAtomWriterAppendData((uint64_t)v11, (uint64_t)BytePtr, v9)
        && !FigAtomWriterEndAtom((uint64_t)v11)
        && !FigAtomWriterEndAtom((uint64_t)v13))
      {
        size_t v5 = 0;
        ++**(void **)a2;
        goto LABEL_26;
      }
    }
LABEL_28:
    size_t v5 = 0;
    goto LABEL_26;
  }
  CFIndex v7 = CFStringGetLength((CFStringRef)v17);
  CFIndex maxBufLen = 0;
  v22.CFIndex location = 0;
  v22.unint64_t length = v7;
  CFStringGetBytes((CFStringRef)v17, v22, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
  if (!maxBufLen)
  {
LABEL_27:
    FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  size_t v5 = (UInt8 *)malloc_type_malloc(maxBufLen + 1, 0x1D7B6DF8uLL);
  v23.CFIndex location = 0;
  v23.unint64_t length = v7;
  CFStringGetBytes((CFStringRef)v17, v23, 0x8000100u, 0, 0, v5, maxBufLen, &maxBufLen);
  v5[maxBufLen] = 0;
  if (!FigAtomWriterAppendData((uint64_t)v11, (uint64_t)v5, maxBufLen + 1))
  {
    free(v5);
    goto LABEL_20;
  }
LABEL_26:
  free(v5);
}

uint64_t FigHALAudioObjectMapperCreate(uint64_t **a1)
{
  uint64_t v2 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0x10200403A5D3213uLL);
  if (v2)
  {
    uint64_t v3 = FigCFWeakReferenceTableCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 3, v2);
    if (!v3)
    {
      *((_DWORD *)v2 + 2) = 1;
      *a1 = v2;
      uint64_t v2 = 0;
    }
  }
  else
  {
    uint64_t v3 = FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
  }
  FigHALAudioObjectMapperDispose((const void **)v2);
  return v3;
}

void FigHALAudioObjectMapperDispose(const void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

id FigHALAudioObjectMapperCopyObjectForID(uint64_t *a1, unsigned int a2)
{
  return FigCFWeakReferenceTableCopyValue(*a1, (void *)a2);
}

uint64_t FigHALAudioObjectMapperAddPluginObjectMapping(uint64_t *a1, uint64_t a2)
{
  return FigCFWeakReferenceTableAddValueAssociatedWithKey(*a1, a2, 1);
}

uint64_t FigHALAudioObjectMapperAddMapping(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unsigned int v6 = FigAtomicIncrement32((atomic_uint *)(a1 + 8));
  uint64_t result = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(void *)a1, a2, v6);
  *a3 = v6;
  return result;
}

uint64_t FigHALAudioObjectMapperRemoveMapping(uint64_t *a1, unsigned int a2)
{
  return FigCFWeakReferenceTableRemoveValue(*a1, a2);
}

uint64_t FigVideoFormatDescriptionCreateFromBigEndianImageDescriptionDataWithReporter(const __CFAllocator *a1, long long *a2, unint64_t a3, CFStringEncoding a4, CFTypeRef cf1, CMVideoFormatDescriptionRef *a6, const void *a7)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  CMVideoFormatDescriptionRef formatDescriptionOut = 0;
  unsigned int v96 = 0;
  __int16 v95 = 0;
  CFTypeRef v93 = 0;
  CFTypeRef cf = 0;
  uint64_t v91 = 0;
  size_t count = 0;
  size_t v90 = 0;
  unsigned int v88 = 0;
  int valuePtr = 0;
  unsigned int v87 = 0;
  if (a2 && a3 > 0x55 && a6)
  {
    if (cf1) {
      BOOL v13 = CFEqual(cf1, @"ISOFamily") == 0;
    }
    else {
      BOOL v13 = 1;
    }
    signed int v15 = bswap32(*(_DWORD *)a2);
    long long v99 = 0u;
    long long v100 = 0u;
    long long v101 = 0u;
    memset(v102, 0, sizeof(v102));
    if (v15 < 0x56 || v15 > a3)
    {
      strcpy((char *)context, "Image description size is incorrect");
      uint64_t v21 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      figSoundBridge_ReportParsingFailureMessage((uint64_t)a7, (uint64_t)context);
      return v21;
    }
    *(void *)&v102[30] = *(void *)((char *)a2 + 78);
    long long v16 = a2[3];
    long long v101 = a2[2];
    *(_OWORD *)uint64_t v102 = v16;
    *(_OWORD *)&v102[16] = a2[4];
    long long v17 = a2[1];
    long long v99 = *a2;
    long long v100 = v17;
    int v18 = bswap32(DWORD1(v99));
    unsigned int v96 = v18;
    unsigned int v19 = WORD1(v101);
    int v20 = bswap32(*(unsigned __int16 *)&v102[34]);
    __int16 v95 = HIWORD(v20);
    if (DWORD1(v99) == 544694642)
    {
      unsigned int v96 = v20 >> 16;
      __int16 v95 = 0;
      int v18 = v20 >> 16;
    }
    else if (v20 >> 16 < 0)
    {
      strcpy((char *)context, "Image description has negative depth");
      goto LABEL_81;
    }
    if ((_WORD)v101)
    {
      if (WORD1(v101))
      {
        if ((v18 & 0xFFFFFFFE) == 0x64766870 && (unsigned __int16)v101 == 5 && WORD1(v101) == 53250)
        {
          unsigned int v22 = 960;
        }
        else
        {
          unsigned int v22 = __rev16((unsigned __int16)v101);
          switch(v18)
          {
            case 1685481522:
            case 1685481525:
              goto LABEL_24;
            case 1685481523:
            case 1685481526:
              if ((unsigned __int16)v101 == 32775 && WORD1(v101) == 14340)
              {
                unsigned int v22 = 1280;
              }
              else if (v18 == 1685481525)
              {
LABEL_24:
                if ((unsigned __int16)v101 == 32775 && WORD1(v101) == 14340) {
                  unsigned int v22 = 1440;
                }
              }
              break;
            default:
              break;
          }
        }
        if (*(_WORD *)&v102[36])
        {
          unint64_t v25 = 86;
          goto LABEL_36;
        }
        if (v15 <= 0x65)
        {
          strcpy((char *)context, "Image description is too small to have a color table");
          goto LABEL_81;
        }
        int v33 = (int)bswap32(*((unsigned __int16 *)a2 + 46)) >> 16;
        if (v33 < 0)
        {
          strcpy((char *)context, "Image description has negative color table size");
          goto LABEL_81;
        }
        unint64_t v25 = 8 * (unsigned __int16)v33 + 102;
        if (v25 <= v15)
        {
LABEL_36:
          BOOL v85 = v13;
          int32_t v86 = v22;
          uint64_t v26 = (uint64_t)a2 + v25;
          unint64_t v27 = v15 - v25;
          uint64_t v28 = figBridge_WalkAndConvertImageDescriptionExtensions(a1, (uint64_t)a2 + v25, v27, (uint64_t)&count, 0, 0, &v90, 0, a7);
          if (v28)
          {
            uint64_t v21 = v28;
LABEL_82:
            CMVideoFormatDescriptionRef v72 = 0;
            OSStatus v39 = 0;
            CFNumberRef v40 = 0;
LABEL_83:
            CFStringRef v36 = 0;
LABEL_84:
            FigFormatDescriptionRelease(v72);
            if (v93) {
              CFRelease(v93);
            }
            if (v36) {
              CFRelease(v36);
            }
            if (cf) {
              CFRelease(cf);
            }
            if (v39)
            {
              size_t v73 = count;
              if (count)
              {
                size_t v74 = 0;
                do
                {
                  size_t v75 = (const void *)v39[v74];
                  if (v75)
                  {
                    CFRelease(v75);
                    size_t v73 = count;
                  }
                  ++v74;
                }
                while (v74 < v73);
              }
              free(v39);
            }
            if (v40)
            {
              size_t v76 = count;
              if (count)
              {
                size_t v77 = 0;
                do
                {
                  size_t v78 = (const void *)v40[v77];
                  if (v78)
                  {
                    CFRelease(v78);
                    size_t v76 = count;
                  }
                  ++v77;
                }
                while (v77 < v76);
              }
              free(v40);
            }
            return v21;
          }
          uint64_t v84 = v26;
          uint64_t v29 = 0;
          unsigned int v30 = __rev16(v19);
          unint64_t v31 = v27;
          while (figBridge_ConvertMPEG2ProfileCodecTypesToProfileExtensions_mpeg2ConformingVideoCodecTypes[v29] != v96)
          {
            if (++v29 == 39)
            {
              size_t v32 = count;
              goto LABEL_48;
            }
          }
          size_t v32 = count + 1;
LABEL_48:
          size_t count = v32 + 1;
          if (v102[2] - 1 > 0x1E)
          {
            unsigned int v35 = bswap32(DWORD1(v99));
            CFStringRef v34 = CFStringCreateWithFormat(a1, 0, @"'%c%c%c%c'", HIBYTE(v35), BYTE2(v35), BYTE1(v35), v35);
          }
          else
          {
            CFStringRef v34 = CFStringCreateWithPascalString(a1, &v102[2], a4);
          }
          CFStringRef v36 = v34;
          size_t v37 = count;
          if (v34) {
            size_t v37 = count + 1;
          }
          size_t v38 = v37 + 4;
          size_t count = v37 + 4;
          if (DWORD1(v100))
          {
            size_t v38 = v37 + 5;
            size_t count = v37 + 5;
          }
          if (v95) {
            size_t count = ++v38;
          }
          if (v38)
          {
            OSStatus v39 = malloc_type_calloc(v38, 8uLL, 0x6004044C4A2DFuLL);
            if (!v39)
            {
              uint64_t v21 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              CMVideoFormatDescriptionRef v72 = 0;
              CFNumberRef v40 = 0;
              goto LABEL_84;
            }
            CFNumberRef v40 = malloc_type_calloc(count, 8uLL, 0xC0040B8AA526DuLL);
            if (!v40)
            {
              uint64_t MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              goto LABEL_108;
            }
            uint64_t MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo = figBridge_WalkAndConvertImageDescriptionExtensions(a1, v84, v31, (uint64_t)&v91, (uint64_t)v39, (uint64_t)v40, 0, v90, a7);
            if (MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo)
            {
LABEL_108:
              uint64_t v21 = MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo;
              goto LABEL_133;
            }
            figBridge_ConvertMPEG2ProfileCodecTypesToProfileExtensions((void *)v96, &v96, &v91, (uint64_t)v39, (uint64_t)v40);
            CFIndex v42 = (CFTypeRef *)&kCMFormatDescriptionExtension_VerbatimSampleDescription;
            if (!v85) {
              CFIndex v42 = (CFTypeRef *)&kCMFormatDescriptionExtension_VerbatimISOSampleEntry;
            }
            CFTypeRef v43 = CFRetain(*v42);
            v39[v91] = v43;
            CFDataRef v44 = CFDataCreate(a1, (const UInt8 *)a2, a3);
            uint64_t v45 = v91;
            v40[v91] = v44;
            uint64_t v91 = v45 + 1;
            if (v36)
            {
              CFTypeRef v46 = CFRetain(@"FormatName");
              uint64_t v47 = v91;
              v39[v91] = v46;
              v40[v47] = v36;
              uint64_t v91 = v47 + 1;
            }
            HIWORD(valuePtr) = bswap32((unsigned __int16)v100) >> 16;
            CFTypeRef v48 = CFRetain(@"Version");
            v39[v91] = v48;
            CFAllocatorRef v49 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFNumberRef v50 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt16Type, (char *)&valuePtr + 2);
            uint64_t v51 = v91;
            v40[v91] = v50;
            uint64_t v91 = v51 + 1;
            LOWORD(valuePtr) = bswap32(WORD1(v100)) >> 16;
            CFTypeRef v52 = CFRetain(@"RevisionLevel");
            v39[v91] = v52;
            CFNumberRef v53 = CFNumberCreate(v49, kCFNumberSInt16Type, &valuePtr);
            uint64_t v54 = v91;
            v40[v91] = v53;
            uint64_t v91 = v54 + 1;
            unsigned int v88 = bswap32(DWORD2(v100));
            CFTypeRef v55 = CFRetain(@"TemporalQuality");
            v39[v91] = v55;
            CFNumberRef v56 = CFNumberCreate(v49, kCFNumberSInt32Type, &v88);
            uint64_t v57 = v91;
            v40[v91] = v56;
            uint64_t v91 = v57 + 1;
            unsigned int v87 = bswap32(HIDWORD(v100));
            CFTypeRef v58 = CFRetain(@"SpatialQuality");
            v39[v91] = v58;
            CFNumberRef v59 = CFNumberCreate(v49, kCFNumberSInt32Type, &v87);
            uint64_t v60 = v91;
            v40[v91] = v59;
            CFIndex v61 = v60 + 1;
            uint64_t v91 = v60 + 1;
            if (DWORD1(v100))
            {
              CFTypeRef v62 = CFRetain(@"Vendor");
              v39[v91] = v62;
              CFStringRef v63 = CFStringCreateWithBytes(a1, (const UInt8 *)&v100 + 4, 4, 0, 0);
              uint64_t v64 = v91;
              v40[v91] = v63;
              CFIndex v61 = v64 + 1;
              uint64_t v91 = v64 + 1;
            }
            if (v95)
            {
              CFTypeRef v65 = CFRetain(@"Depth");
              v39[v91] = v65;
              CFNumberRef v66 = CFNumberCreate(v49, kCFNumberSInt16Type, &v95);
              uint64_t v67 = v91;
              v40[v91] = v66;
              CFIndex v61 = v67 + 1;
              uint64_t v91 = v67 + 1;
            }
            if (count == v61)
            {
              CFTypeRef cf = CFDictionaryCreate(a1, (const void **)v39, (const void **)v40, v61, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              if (cf)
              {
                CFStringRef v36 = 0;
LABEL_73:
                int32_t v68 = v30;
                int v69 = v96;
                if (v96 != 1836070006)
                {
                  int32_t v70 = v86;
                  goto LABEL_111;
                }
                uint64_t MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo = (uint64_t)figBridge_GetMPEG4VideoCodecTypeAndCopyDecoderSpecificInfo((const __CFDictionary *)cf, (int *)&v96, (__CFDictionary **)&v93);
                if (!MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo)
                {
                  if ((uint64_t)FigCFDictionaryGetCount((CFDictionaryRef)v93) < 1)
                  {
                    int32_t v70 = v86;
                  }
                  else
                  {
                    context[0] = (unint64_t)cf;
                    *(void *)&context[1] = __PAIR64__(v30, v86);
                    CFDictionaryApplyFunction((CFDictionaryRef)v93, (CFDictionaryApplierFunction)figbridge_ConsumeMP4BridgeDecoderSpecificInfo, context);
                    int32_t v70 = context[1];
                    int32_t v68 = DWORD1(context[1]);
                    int v71 = (const void *)*((void *)&context[0] + 1);
                    if (*((void *)&context[0] + 1))
                    {
                      if (cf)
                      {
                        CFRelease(cf);
                        int v71 = (const void *)*((void *)&context[0] + 1);
                      }
                      CFTypeRef cf = v71;
                    }
                  }
                  int v69 = v96;
LABEL_111:
                  if (v69 == 1701733238)
                  {
                    unsigned int ConciseProtectedCodecType = figBridge_GetConciseProtectedCodecType((const __CFDictionary *)cf);
                    if (ConciseProtectedCodecType)
                    {
                      int v69 = ConciseProtectedCodecType;
                      unsigned int v96 = ConciseProtectedCodecType;
                    }
                    else
                    {
                      int v69 = v96;
                    }
                  }
                  if (FigVideoCodecTypeIsH264Flavor(v69)
                    || FigVideoCodecTypeIsHEVCFlavorOrDolbyVisionHEVCFlavor(v69))
                  {
                    goto LABEL_117;
                  }
                  if (v69 > 1902212656)
                  {
                    if (v69 != 1902403958)
                    {
                      int v83 = 1902212657;
LABEL_140:
                      if (v69 != v83) {
                        goto LABEL_120;
                      }
                    }
                  }
                  else if (v69 != 1635135537)
                  {
                    int v83 = 1684108849;
                    goto LABEL_140;
                  }
LABEL_117:
                  FigBridge_MakeFallbackExtensionsFromVUI(a1, v69, (uint64_t)a7, (const __CFDictionary **)&cf);
                  if (FigVideoCodecTypeIsHEVCFlavorOrDolbyVisionHEVCFlavor(v96))
                  {
                    CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"AlternativeTransferCharacteristics");
                    if (Value) {
                      figBridge_OverrideTransferFunctionFromAlternativeTransferCharacteristics(a1, Value, (CFDictionaryRef *)&cf);
                    }
                  }
LABEL_120:
                  CMVideoCodecType v81 = v96;
                  if (FigVideoCodecTypeIsProRes(v96))
                  {
                    figBridge_GetBitsPerComponentForProRes(a1, v81, (uint64_t *)&cf);
                    figBridge_GetAlphaChannelExtensionForProRes(a1, (uint64_t *)&cf);
                    CMVideoCodecType v81 = v96;
                  }
                  if (v81 == 1932670515)
                  {
                    if (figBridge_Is3GP263ExtensionPresent((const __CFDictionary *)cf))
                    {
                      CMVideoCodecType v81 = 1748121139;
                      goto LABEL_130;
                    }
                    CMVideoCodecType v81 = v96;
                  }
                  char v82 = v85;
                  if (v81 != 1835692135) {
                    char v82 = 1;
                  }
                  if (v82) {
                    goto LABEL_131;
                  }
                  CMVideoCodecType v81 = 1785750887;
LABEL_130:
                  unsigned int v96 = v81;
LABEL_131:
                  uint64_t v21 = CMVideoFormatDescriptionCreate(a1, v81, v70, v68, (CFDictionaryRef)cf, &formatDescriptionOut);
                  CMVideoFormatDescriptionRef v72 = formatDescriptionOut;
                  if (v21) {
                    goto LABEL_84;
                  }
                  *a6 = formatDescriptionOut;
                  CMVideoFormatDescriptionRef formatDescriptionOut = 0;
LABEL_133:
                  CMVideoFormatDescriptionRef v72 = 0;
                  goto LABEL_84;
                }
                goto LABEL_108;
              }
              uint64_t v21 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            }
            else
            {
              strcpy((char *)context, "Image description data could have changed");
              uint64_t v21 = 4294954582;
              FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
              figSoundBridge_ReportParsingFailureMessage((uint64_t)a7, (uint64_t)context);
            }
            CMVideoFormatDescriptionRef v72 = 0;
            goto LABEL_83;
          }
          OSStatus v39 = 0;
          CFNumberRef v40 = 0;
          goto LABEL_73;
        }
        CFRange v23 = "Image description color table size is too big";
      }
      else
      {
        CFRange v23 = "Image description has negative or zero height";
      }
      long long v24 = *((_OWORD *)v23 + 1);
      context[0] = *(_OWORD *)v23;
      context[1] = v24;
      *(_OWORD *)((char *)&context[1] + 14) = *(_OWORD *)(v23 + 30);
    }
    else
    {
      strcpy((char *)context, "Image description has negative or zero width");
    }
LABEL_81:
    uint64_t v21 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage((uint64_t)a7, (uint64_t)context);
    goto LABEL_82;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

CFDictionaryRef figBridge_GetMPEG4VideoCodecTypeAndCopyDecoderSpecificInfo(const __CFDictionary *result, int *a2, __CFDictionary **a3)
{
  if (result)
  {
    unsigned __int8 v15 = 0;
    CFDictionaryRef Value = CFDictionaryGetValue(result, @"SampleDescriptionExtensionAtoms");
    if (!Value) {
      return 0;
    }
    unsigned int v6 = Value;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (TypeID != CFGetTypeID(v6)) {
      return 0;
    }
    CFArrayRef v8 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v6, @"esds");
    if (!v8) {
      return 0;
    }
    CFArrayRef ValueAtIndex = v8;
    CFTypeID v10 = CFArrayGetTypeID();
    if (v10 == CFGetTypeID(ValueAtIndex))
    {
      CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
      if (!ValueAtIndex) {
        return 0;
      }
    }
    CFTypeID v11 = CFDataGetTypeID();
    if (v11 != CFGetTypeID(ValueAtIndex)) {
      return 0;
    }
    BytePtr = CFDataGetBytePtr(ValueAtIndex);
    CFIndex Length = CFDataGetLength(ValueAtIndex);
    if (FigMP4Bridge_GetESDSObjectTypeAndCopyDecoderSpecificInfo((unint64_t)BytePtr, Length, (char *)&v15, 0, a3))return 0; {
    int v14 = 1836069238;
    }
    if (v15 > 0x64u)
    {
      if (v15 != 101)
      {
        if (v15 == 106) {
          goto LABEL_18;
        }
        if (v15 == 108)
        {
          int v14 = 1785750887;
          goto LABEL_18;
        }
        return (const __CFDictionary *)FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
      }
    }
    else if (v15 - 96 >= 2)
    {
      if (v15 == 32)
      {
        int v14 = 1836070006;
LABEL_18:
        *a2 = v14;
        return 0;
      }
      return (const __CFDictionary *)FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    }
    int v14 = 1836069494;
    goto LABEL_18;
  }
  return result;
}

void figbridge_ConsumeMP4BridgeDecoderSpecificInfo(const void *a1, const __CFNumber *a2, uint64_t a3)
{
  if (CFEqual(a1, @"VideoWidth"))
  {
    int SInt32 = FigCFNumberGetSInt32(a2);
    if (SInt32 >= 1) {
      *(_DWORD *)(a3 + 16) = SInt32;
    }
  }
  else if (CFEqual(a1, @"VideoHeight"))
  {
    int v7 = FigCFNumberGetSInt32(a2);
    if (v7 >= 1) {
      *(_DWORD *)(a3 + 20) = v7;
    }
  }
  else if (!CFDictionaryContainsKey(*(CFDictionaryRef *)a3, a1))
  {
    CFMutableArrayRef MutableCopy = *(__CFDictionary **)(a3 + 8);
    if (MutableCopy
      || (CFMutableArrayRef MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(CFDictionaryRef *)a3), (*(void *)(a3 + 8) = MutableCopy) != 0))
    {
      CFDictionaryAddValue(MutableCopy, a1, a2);
    }
  }
}

CFDictionaryRef figBridge_GetConciseProtectedCodecType(const __CFDictionary *result)
{
  if (!result) {
    return result;
  }
  uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"SampleDescriptionExtensionAtoms");
  if (!result) {
    return result;
  }
  uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"sinf");
  if (!result) {
    return result;
  }
  CFDictionaryRef v1 = result;
  CFTypeID v2 = CFGetTypeID(result);
  if (v2 != CFArrayGetTypeID())
  {
    CFTypeID v8 = CFGetTypeID(v1);
    if (v8 == CFDataGetTypeID())
    {
      BytePtr = CFDataGetBytePtr(v1);
      CFIndex Length = CFDataGetLength(v1);
      return (const __CFDictionary *)figBridge_GetConciseProtectedCodecTypeFromSinfData((uint64_t)BytePtr, Length);
    }
    return 0;
  }
  if (CFArrayGetCount(v1) < 1) {
    return 0;
  }
  CFIndex v3 = 0;
  while (1)
  {
    CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex(v1, v3);
    CFTypeID v5 = CFGetTypeID(ValueAtIndex);
    if (v5 == CFDataGetTypeID())
    {
      unsigned int v6 = CFDataGetBytePtr((CFDataRef)ValueAtIndex);
      CFIndex v7 = CFDataGetLength((CFDataRef)ValueAtIndex);
      uint64_t result = (const __CFDictionary *)figBridge_GetConciseProtectedCodecTypeFromSinfData((uint64_t)v6, v7);
      if (result) {
        break;
      }
    }
    if (CFArrayGetCount(v1) <= ++v3) {
      return 0;
    }
  }
  return result;
}

uint64_t FigVideoCodecTypeIsH264Flavor(int a1)
{
  uint64_t result = 1;
  if (a1 > 1700886114)
  {
    if (a1 > 1902212708)
    {
      if (a1 == 1902212709) {
        return result;
      }
      int v3 = 2053207651;
    }
    else
    {
      if (a1 == 1700886115) {
        return result;
      }
      int v3 = 1902212707;
    }
  }
  else if (a1 > 1667331682)
  {
    if (a1 == 1667331683) {
      return result;
    }
    int v3 = 1685220713;
  }
  else
  {
    if (a1 == 1635148593) {
      return result;
    }
    int v3 = 1635148595;
  }
  if (a1 != v3) {
    return 0;
  }
  return result;
}

uint64_t FigVideoCodecTypeIsHEVCFlavorOrDolbyVisionHEVCFlavor(int a1)
{
  uint64_t result = 1;
  if (a1 > 1836415072)
  {
    if (a1 > 1902407031)
    {
      if (a1 > 1902671458)
      {
        if (a1 == 1902671459) {
          return result;
        }
        int v3 = 1902998904;
      }
      else
      {
        if (a1 == 1902407032) {
          return result;
        }
        int v3 = 1902667126;
      }
    }
    else if (a1 > 1902405680)
    {
      if (a1 == 1902405681) {
        return result;
      }
      int v3 = 1902405733;
    }
    else
    {
      if (a1 == 1836415073) {
        return result;
      }
      int v3 = 1869117027;
    }
  }
  else if (a1 > 1685481572)
  {
    if (a1 > 1751479856)
    {
      if (a1 == 1751479857) {
        return result;
      }
      int v3 = 1752589105;
    }
    else
    {
      if (a1 == 1685481573) {
        return result;
      }
      int v3 = 1718908520;
    }
  }
  else if (a1 > 1684895095)
  {
    if (a1 == 1684895096) {
      return result;
    }
    int v3 = 1685481521;
  }
  else
  {
    if (a1 == 1667524657) {
      return result;
    }
    int v3 = 1667790435;
  }
  if (a1 != v3) {
    return 0;
  }
  return result;
}

uint64_t FigBridge_MakeFallbackExtensionsFromVUI(const __CFAllocator *a1, int a2, uint64_t a3, const __CFDictionary **a4)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a4;
  CFDictionaryRef v110 = 0;
  memset(v112, 0, sizeof(v112));
  memset(v111, 0, sizeof(v111));
  if (!v4) {
    return 0;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(v4, @"SampleDescriptionExtensionAtoms");
  if (!Value) {
    return 0;
  }
  CFTypeID v10 = Value;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v10)) {
    return 0;
  }
  uint64_t v12 = @"avcC";
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 == 1902405681 || a2 == 1902405733) {
          goto LABEL_48;
        }
        int v13 = 1902407032;
      }
      else
      {
        if (a2 <= 1902998903)
        {
          if (a2 != 1902667126)
          {
            int v13 = 1902671459;
            goto LABEL_47;
          }
          goto LABEL_48;
        }
        if (a2 == 2053207651) {
          goto LABEL_49;
        }
        int v13 = 1902998904;
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709) {
            goto LABEL_49;
          }
          int v15 = 1902403958;
LABEL_41:
          if (a2 != v15) {
            goto LABEL_72;
          }
LABEL_42:
          uint64_t v12 = @"av1C";
          goto LABEL_49;
        }
        if (a2 == 1902212657) {
          goto LABEL_42;
        }
        int v14 = 1902212707;
        goto LABEL_26;
      }
      if (a2 == 1752589105 || a2 == 1836415073) {
        goto LABEL_48;
      }
      int v13 = 1869117027;
    }
LABEL_47:
    if (a2 == v13) {
      goto LABEL_48;
    }
LABEL_72:
    snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
    FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
    return 0;
  }
  if (a2 > 1684895095)
  {
    if (a2 > 1685481572)
    {
      if (a2 > 1718908519)
      {
        if (a2 != 1718908520)
        {
          int v13 = 1751479857;
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      if (a2 == 1685481573) {
        goto LABEL_48;
      }
      int v14 = 1700886115;
LABEL_26:
      if (a2 == v14) {
        goto LABEL_49;
      }
      goto LABEL_72;
    }
    if (a2 == 1684895096) {
      goto LABEL_48;
    }
    if (a2 == 1685220713) {
      goto LABEL_49;
    }
    int v13 = 1685481521;
    goto LABEL_47;
  }
  if (a2 <= 1667331682)
  {
    if (a2 == 1635135537) {
      goto LABEL_42;
    }
    if (a2 == 1635148593) {
      goto LABEL_49;
    }
    int v14 = 1635148595;
    goto LABEL_26;
  }
  if (a2 <= 1667790434)
  {
    if (a2 == 1667331683) {
      goto LABEL_49;
    }
    int v13 = 1667524657;
    goto LABEL_47;
  }
  if (a2 != 1667790435)
  {
    int v15 = 1684108849;
    goto LABEL_41;
  }
LABEL_48:
  uint64_t v12 = @"hvcC";
LABEL_49:
  CFArrayRef v16 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v10, v12);
  if (!v16) {
    return 0;
  }
  CFArrayRef ValueAtIndex = v16;
  CFTypeID v18 = CFArrayGetTypeID();
  if (v18 == CFGetTypeID(ValueAtIndex))
  {
    CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    if (!ValueAtIndex) {
      return 0;
    }
  }
  CFTypeID v19 = CFDataGetTypeID();
  if (v19 != CFGetTypeID(ValueAtIndex)) {
    return 0;
  }
  unint64_t v108 = 0;
  uint64_t v109 = 0;
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 != 1902405681 && a2 != 1902405733)
        {
          int v20 = 1902407032;
          goto LABEL_94;
        }
      }
      else
      {
        if (a2 <= 1902998903)
        {
          if (a2 == 1902667126) {
            goto LABEL_95;
          }
          int v20 = 1902671459;
          goto LABEL_94;
        }
        if (a2 != 1902998904)
        {
          int v21 = 2053207651;
          goto LABEL_99;
        }
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709) {
            goto LABEL_100;
          }
          int v22 = 1902403958;
          goto LABEL_89;
        }
        if (a2 == 1902212657) {
          goto LABEL_90;
        }
        int v21 = 1902212707;
LABEL_99:
        if (a2 != v21) {
          goto LABEL_102;
        }
        goto LABEL_100;
      }
      if (a2 != 1752589105 && a2 != 1836415073)
      {
        int v20 = 1869117027;
        goto LABEL_94;
      }
    }
LABEL_95:
    if (!FigHEVCBridge_GetHEVCParameterSetAtIndex(ValueAtIndex, 33, 0, (unint64_t)&v109, (unint64_t)&v108, 0, 0))goto LABEL_103; {
    return 0;
    }
  }
  if (a2 > 1684895095)
  {
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096) {
        goto LABEL_95;
      }
      if (a2 == 1685220713) {
        goto LABEL_100;
      }
      int v20 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573) {
          goto LABEL_95;
        }
        int v21 = 1700886115;
        goto LABEL_99;
      }
      if (a2 == 1718908520) {
        goto LABEL_95;
      }
      int v20 = 1751479857;
    }
LABEL_94:
    if (a2 == v20) {
      goto LABEL_95;
    }
LABEL_102:
    snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
    FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
    goto LABEL_103;
  }
  if (a2 <= 1667331682)
  {
    if (a2 == 1635135537) {
      goto LABEL_90;
    }
    if (a2 == 1635148593) {
      goto LABEL_100;
    }
    int v21 = 1635148595;
    goto LABEL_99;
  }
  if (a2 > 1667790434)
  {
    if (a2 == 1667790435) {
      goto LABEL_95;
    }
    int v22 = 1684108849;
LABEL_89:
    if (a2 != v22) {
      goto LABEL_102;
    }
LABEL_90:
    if (!FigAV1Bridge_Getav1CStartAndLength(ValueAtIndex, (const UInt8 **)&v109, &v108)) {
      goto LABEL_103;
    }
    return 0;
  }
  if (a2 != 1667331683)
  {
    int v20 = 1667524657;
    goto LABEL_94;
  }
LABEL_100:
  BytePtr = CFDataGetBytePtr(ValueAtIndex);
  CFIndex Length = CFDataGetLength(ValueAtIndex);
  if (FigH264Bridge_GetSPSFromAVCC((uint64_t)BytePtr, Length, 0, &v109, &v108)) {
    return 0;
  }
LABEL_103:
  uint64_t v25 = *MEMORY[0x1E4F24A10];
  if (CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E4F24A10]))
  {
    uint64_t v26 = 0;
    goto LABEL_186;
  }
  *(void *)colorPrimariesCodePoint = 0;
  if (a2 <= 1752589104)
  {
    if (a2 <= 1684895095)
    {
      if (a2 > 1667331682)
      {
        if (a2 <= 1667790434)
        {
          if (a2 != 1667331683)
          {
            int v27 = 1667524657;
            goto LABEL_152;
          }
          goto LABEL_158;
        }
        if (a2 == 1667790435) {
          goto LABEL_153;
        }
        int v29 = 1684108849;
        goto LABEL_140;
      }
      if (a2 == 1635135537) {
        goto LABEL_141;
      }
      if (a2 != 1635148593)
      {
        int v28 = 1635148595;
        goto LABEL_157;
      }
LABEL_158:
      int SPS_VUI_ChromaLocation = FigH264Bridge_GetSPS_VUI_ChromaLocation(v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint);
LABEL_159:
      if (!SPS_VUI_ChromaLocation) {
        goto LABEL_161;
      }
      goto LABEL_160;
    }
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096) {
        goto LABEL_153;
      }
      if (a2 == 1685220713) {
        goto LABEL_158;
      }
      int v27 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573) {
          goto LABEL_153;
        }
        int v28 = 1700886115;
LABEL_157:
        if (a2 != v28) {
          goto LABEL_512;
        }
        goto LABEL_158;
      }
      if (a2 == 1718908520) {
        goto LABEL_153;
      }
      int v27 = 1751479857;
    }
LABEL_152:
    if (a2 == v27) {
      goto LABEL_153;
    }
LABEL_512:
    snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
    FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
    goto LABEL_161;
  }
  if (a2 > 1902405680)
  {
    if (a2 <= 1902667125)
    {
      if (a2 != 1902405681 && a2 != 1902405733)
      {
        int v27 = 1902407032;
        goto LABEL_152;
      }
    }
    else
    {
      if (a2 <= 1902998903)
      {
        if (a2 == 1902667126) {
          goto LABEL_153;
        }
        int v27 = 1902671459;
        goto LABEL_152;
      }
      if (a2 != 1902998904)
      {
        int v28 = 2053207651;
        goto LABEL_157;
      }
    }
LABEL_153:
    if (!FigHEVCBridge_GetSPS_VUI_ChromaLocation((uint64_t)v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint))goto LABEL_161; {
LABEL_160:
    }
    *(void *)colorPrimariesCodePoint = 0;
    goto LABEL_161;
  }
  if (a2 <= 1902212656)
  {
    if (a2 != 1752589105 && a2 != 1836415073)
    {
      int v27 = 1869117027;
      goto LABEL_152;
    }
    goto LABEL_153;
  }
  if (a2 <= 1902212708)
  {
    if (a2 == 1902212657) {
      goto LABEL_141;
    }
    int v28 = 1902212707;
    goto LABEL_157;
  }
  if (a2 == 1902212709) {
    goto LABEL_158;
  }
  int v29 = 1902403958;
LABEL_140:
  if (a2 != v29) {
    goto LABEL_512;
  }
LABEL_141:
  __str[0] = 0;
  LOBYTE(yCbCrMatrixCodePoint) = 0;
  int SPS_VUI_ChromaLocation = FigAV1Bridge_GetChromaFormatAndBitDepthsFromAV1CodecConfigurationRecord((char *)v109, v108, (char *)&yCbCrMatrixCodePoint, __str, 0);
  if (SPS_VUI_ChromaLocation) {
    goto LABEL_159;
  }
  if (__str[0] == 2)
  {
    int v32 = 3;
  }
  else if (__str[0])
  {
    int v32 = 0;
  }
  else
  {
    if (yCbCrMatrixCodePoint == 100) {
      int v31 = 3;
    }
    else {
      int v31 = 0;
    }
    if ((_BYTE)yCbCrMatrixCodePoint) {
      int v32 = v31;
    }
    else {
      int v32 = 1;
    }
  }
  colorPrimariesCodePoint[0] = v32;
  colorPrimariesCodePoint[1] = v32;
LABEL_161:
  if (a2 > 1700886114)
  {
    if (a2 > 1902212708)
    {
      if (a2 == 1902212709) {
        goto LABEL_173;
      }
      int v33 = 2053207651;
    }
    else
    {
      if (a2 == 1700886115) {
        goto LABEL_173;
      }
      int v33 = 1902212707;
    }
  }
  else if (a2 > 1667331682)
  {
    if (a2 == 1667331683) {
      goto LABEL_173;
    }
    int v33 = 1685220713;
  }
  else
  {
    if (a2 == 1635148593) {
      goto LABEL_173;
    }
    int v33 = 1635148595;
  }
  if (a2 != v33)
  {
    unsigned __int8 v34 = colorPrimariesCodePoint[1];
    goto LABEL_176;
  }
LABEL_173:
  unsigned __int8 v34 = colorPrimariesCodePoint[1];
  if (colorPrimariesCodePoint[1] == 2 && colorPrimariesCodePoint[0] == 2)
  {
    unsigned __int8 v34 = 1;
    colorPrimariesCodePoint[0] = 1;
    colorPrimariesCodePoint[1] = 1;
  }
LABEL_176:
  unsigned int v35 = (const void *)figConvertChromaLocationIndexToString(v34);
  if (v35)
  {
    *(void *)&v111[0] = CFRetain(v35);
    if (*(void *)&v111[0])
    {
      v112[0] = v25;
      uint64_t v26 = 1;
    }
    else
    {
      uint64_t v26 = 0;
    }
  }
  else
  {
    uint64_t v26 = 0;
    *(void *)&v111[0] = 0;
  }
  CFStringRef v36 = (const void *)figConvertChromaLocationIndexToString(LOBYTE(colorPrimariesCodePoint[0]));
  size_t v37 = v111;
  if (v36)
  {
    CFTypeRef v38 = CFRetain(v36);
    *(void *)((unint64_t)v111 | (8 * v26)) = v38;
    if (!v38) {
      goto LABEL_186;
    }
    uint64_t v39 = *MEMORY[0x1E4F24A08];
    uint64_t v40 = v26 + 1;
    size_t v37 = v112;
  }
  else
  {
    uint64_t v39 = 0;
    uint64_t v40 = v26;
  }
  v37[v26] = v39;
  uint64_t v26 = v40;
LABEL_186:
  uint64_t v41 = *MEMORY[0x1E4F24A90];
  if (CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E4F24A90])) {
    goto LABEL_249;
  }
  *(void *)colorPrimariesCodePoint = 0;
  int yCbCrMatrixCodePoint = 0;
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 == 1902405681 || a2 == 1902405733) {
          goto LABEL_228;
        }
        int v42 = 1902407032;
      }
      else
      {
        if (a2 > 1902998903)
        {
          if (a2 == 1902998904) {
            goto LABEL_228;
          }
          int v43 = 2053207651;
          goto LABEL_231;
        }
        if (a2 == 1902667126) {
          goto LABEL_228;
        }
        int v42 = 1902671459;
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709) {
            goto LABEL_232;
          }
          int v44 = 1902403958;
          goto LABEL_223;
        }
        if (a2 == 1902212657) {
          goto LABEL_224;
        }
        int v43 = 1902212707;
        goto LABEL_231;
      }
      if (a2 == 1752589105 || a2 == 1836415073) {
        goto LABEL_228;
      }
      int v42 = 1869117027;
    }
LABEL_227:
    if (a2 == v42) {
      goto LABEL_228;
    }
LABEL_513:
    snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
    FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
    goto LABEL_234;
  }
  if (a2 > 1684895095)
  {
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096) {
        goto LABEL_228;
      }
      if (a2 == 1685220713) {
        goto LABEL_232;
      }
      int v42 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573) {
          goto LABEL_228;
        }
        int v43 = 1700886115;
LABEL_231:
        if (a2 != v43) {
          goto LABEL_513;
        }
        goto LABEL_232;
      }
      if (a2 == 1718908520) {
        goto LABEL_228;
      }
      int v42 = 1751479857;
    }
    goto LABEL_227;
  }
  if (a2 <= 1667331682)
  {
    if (a2 == 1635135537) {
      goto LABEL_224;
    }
    if (a2 == 1635148593) {
      goto LABEL_232;
    }
    int v43 = 1635148595;
    goto LABEL_231;
  }
  if (a2 > 1667790434)
  {
    if (a2 != 1667790435)
    {
      int v44 = 1684108849;
LABEL_223:
      if (a2 != v44) {
        goto LABEL_513;
      }
LABEL_224:
      int SeqOBU_VUI_NCLC = FigAV1Bridge_GetSeqOBU_VUI_NCLC((char *)v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint, &yCbCrMatrixCodePoint);
      goto LABEL_233;
    }
LABEL_228:
    int SeqOBU_VUI_NCLC = FigHEVCBridge_GetSPS_VUI_NCLC((uint64_t)v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint, &yCbCrMatrixCodePoint);
    goto LABEL_233;
  }
  if (a2 != 1667331683)
  {
    int v42 = 1667524657;
    goto LABEL_227;
  }
LABEL_232:
  int SeqOBU_VUI_NCLC = FigH264Bridge_GetSPS_VUI_NCLC(v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint, &yCbCrMatrixCodePoint);
LABEL_233:
  if (SeqOBU_VUI_NCLC) {
    goto LABEL_249;
  }
LABEL_234:
  CFStringRef StringForIntegerCodePoint = CVColorPrimariesGetStringForIntegerCodePoint(colorPrimariesCodePoint[1]);
  uint64_t v47 = v111;
  if (StringForIntegerCodePoint)
  {
    CFTypeRef v48 = CFRetain(StringForIntegerCodePoint);
    *((void *)v111 + v26) = v48;
    if (!v48) {
      goto LABEL_239;
    }
    uint64_t v49 = v26 + 1;
    uint64_t v47 = v112;
  }
  else
  {
    uint64_t v41 = 0;
    uint64_t v49 = v26;
  }
  v47[v26] = v41;
  uint64_t v26 = v49;
LABEL_239:
  CFStringRef v50 = CVTransferFunctionGetStringForIntegerCodePoint(colorPrimariesCodePoint[0]);
  uint64_t v51 = v111;
  if (v50)
  {
    CFTypeRef v52 = CFRetain(v50);
    *((void *)v111 + v26) = v52;
    if (!v52) {
      goto LABEL_244;
    }
    uint64_t v53 = *MEMORY[0x1E4F24BC8];
    uint64_t v54 = v26 + 1;
    uint64_t v51 = v112;
  }
  else
  {
    uint64_t v53 = 0;
    uint64_t v54 = v26;
  }
  v51[v26] = v53;
  uint64_t v26 = v54;
LABEL_244:
  CFStringRef v55 = CVYCbCrMatrixGetStringForIntegerCodePoint(yCbCrMatrixCodePoint);
  CFNumberRef v56 = v111;
  if (v55)
  {
    CFTypeRef v57 = CFRetain(v55);
    *((void *)v111 + v26) = v57;
    if (!v57) {
      goto LABEL_249;
    }
    uint64_t v58 = *MEMORY[0x1E4F24C18];
    uint64_t v59 = v26 + 1;
    CFNumberRef v56 = v112;
  }
  else
  {
    uint64_t v58 = 0;
    uint64_t v59 = v26;
  }
  v56[v26] = v58;
  uint64_t v26 = v59;
LABEL_249:
  if (CFDictionaryContainsKey(v4, @"FullRangeVideo")) {
    goto LABEL_301;
  }
  LOBYTE(colorPrimariesCodePoint[1]) = 0;
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 == 1902405681 || a2 == 1902405733) {
          goto LABEL_290;
        }
        int v60 = 1902407032;
      }
      else
      {
        if (a2 > 1902998903)
        {
          if (a2 == 1902998904) {
            goto LABEL_290;
          }
          int v61 = 2053207651;
          goto LABEL_293;
        }
        if (a2 == 1902667126) {
          goto LABEL_290;
        }
        int v60 = 1902671459;
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709) {
            goto LABEL_294;
          }
          int v62 = 1902403958;
          goto LABEL_285;
        }
        if (a2 == 1902212657) {
          goto LABEL_286;
        }
        int v61 = 1902212707;
        goto LABEL_293;
      }
      if (a2 == 1752589105 || a2 == 1836415073) {
        goto LABEL_290;
      }
      int v60 = 1869117027;
    }
  }
  else
  {
    if (a2 <= 1684895095)
    {
      if (a2 > 1667331682)
      {
        if (a2 <= 1667790434)
        {
          if (a2 != 1667331683)
          {
            int v60 = 1667524657;
            goto LABEL_289;
          }
LABEL_294:
          int SPS_VUI_FullRangeVideo = FigH264Bridge_GetSPS_VUI_FullRangeVideo(v109, v108, &colorPrimariesCodePoint[1]);
LABEL_295:
          if (SPS_VUI_FullRangeVideo) {
            goto LABEL_301;
          }
          goto LABEL_296;
        }
        if (a2 != 1667790435)
        {
          int v62 = 1684108849;
LABEL_285:
          if (a2 != v62) {
            goto LABEL_514;
          }
LABEL_286:
          int SPS_VUI_FullRangeVideo = FigAV1Bridge_GetColorRangeFromAV1CodecConfigurationRecord((char *)v109, v108, (BOOL *)&colorPrimariesCodePoint[1]);
          goto LABEL_295;
        }
LABEL_290:
        int SPS_VUI_FullRangeVideo = FigHEVCBridge_GetSPS_VUI_FullRangeVideo((uint64_t)v109, v108, &colorPrimariesCodePoint[1]);
        goto LABEL_295;
      }
      if (a2 == 1635135537) {
        goto LABEL_286;
      }
      if (a2 == 1635148593) {
        goto LABEL_294;
      }
      int v61 = 1635148595;
LABEL_293:
      if (a2 != v61) {
        goto LABEL_514;
      }
      goto LABEL_294;
    }
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096) {
        goto LABEL_290;
      }
      if (a2 == 1685220713) {
        goto LABEL_294;
      }
      int v60 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573) {
          goto LABEL_290;
        }
        int v61 = 1700886115;
        goto LABEL_293;
      }
      if (a2 == 1718908520) {
        goto LABEL_290;
      }
      int v60 = 1751479857;
    }
  }
LABEL_289:
  if (a2 == v60) {
    goto LABEL_290;
  }
LABEL_514:
  snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
  FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
  figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
LABEL_296:
  uint64_t v64 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
  if (!LOBYTE(colorPrimariesCodePoint[1])) {
    uint64_t v64 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
  }
  CFTypeRef v65 = *v64;
  if (*v64) {
    CFTypeRef v65 = CFRetain(v65);
  }
  *((void *)v111 + v26) = v65;
  v112[v26++] = @"FullRangeVideo";
LABEL_301:
  uint64_t v66 = *MEMORY[0x1E4F24B98];
  if (CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E4F24B98])) {
    goto LABEL_302;
  }
  *(void *)colorPrimariesCodePoint = 0;
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 != 1902405681 && a2 != 1902405733)
        {
          int v69 = 1902407032;
          goto LABEL_476;
        }
      }
      else
      {
        if (a2 <= 1902998903)
        {
          if (a2 == 1902667126) {
            goto LABEL_477;
          }
          int v69 = 1902671459;
          goto LABEL_476;
        }
        if (a2 != 1902998904)
        {
          int v72 = 2053207651;
          goto LABEL_481;
        }
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709) {
            goto LABEL_482;
          }
          int v93 = 1902403958;
          goto LABEL_471;
        }
        if (a2 == 1902212657) {
          goto LABEL_472;
        }
        int v72 = 1902212707;
LABEL_481:
        if (a2 == v72) {
          goto LABEL_482;
        }
        goto LABEL_515;
      }
      if (a2 != 1752589105 && a2 != 1836415073)
      {
        int v69 = 1869117027;
        goto LABEL_476;
      }
    }
LABEL_477:
    if (FigHEVCBridge_GetSPS_VUI_AspectRatio((uint64_t)v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint))goto LABEL_302; {
    goto LABEL_483;
    }
  }
  if (a2 > 1684895095)
  {
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096) {
        goto LABEL_477;
      }
      if (a2 == 1685220713) {
        goto LABEL_482;
      }
      int v69 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573) {
          goto LABEL_477;
        }
        int v72 = 1700886115;
        goto LABEL_481;
      }
      if (a2 == 1718908520) {
        goto LABEL_477;
      }
      int v69 = 1751479857;
    }
LABEL_476:
    if (a2 == v69) {
      goto LABEL_477;
    }
    goto LABEL_515;
  }
  if (a2 <= 1667331682)
  {
    if (a2 == 1635135537) {
      goto LABEL_472;
    }
    if (a2 == 1635148593) {
      goto LABEL_482;
    }
    int v72 = 1635148595;
    goto LABEL_481;
  }
  if (a2 <= 1667790434)
  {
    if (a2 != 1667331683)
    {
      int v69 = 1667524657;
      goto LABEL_476;
    }
LABEL_482:
    if (FigH264Bridge_GetSPS_VUI_AspectRatio(v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint))goto LABEL_302; {
    goto LABEL_483;
    }
  }
  if (a2 == 1667790435) {
    goto LABEL_477;
  }
  int v93 = 1684108849;
LABEL_471:
  if (a2 == v93)
  {
LABEL_472:
    if (FigAV1Bridge_GetSeqOBU_VUI_AspectRatio((char *)v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint))goto LABEL_302; {
    goto LABEL_483;
    }
  }
LABEL_515:
  snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
  FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
  figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
LABEL_483:
  uint64_t v100 = colorPrimariesCodePoint[1];
  if (colorPrimariesCodePoint[1] && colorPrimariesCodePoint[0])
  {
    v112[v26] = v66;
    CFDictionaryRef v101 = figBridge_CFDictionaryCreateWithNumbers(a1, v94, (void *)*MEMORY[0x1E4F24B90], v95, v96, v97, v98, v99, v100);
    *((void *)v111 + v26) = v101;
    if (!v101) {
      goto LABEL_506;
    }
    ++v26;
  }
LABEL_302:
  uint64_t v67 = *MEMORY[0x1E4F24AF8];
  if (CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E4F24AF8])) {
    goto LABEL_303;
  }
  int v70 = 0;
  LOBYTE(colorPrimariesCodePoint[1]) = 0;
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 == 1902405681 || a2 == 1902405733) {
          goto LABEL_496;
        }
        int v71 = 1902407032;
      }
      else
      {
        if (a2 > 1902998903)
        {
          if (a2 == 1902998904) {
            goto LABEL_496;
          }
          int v73 = 2053207651;
          goto LABEL_499;
        }
        if (a2 == 1902667126) {
          goto LABEL_496;
        }
        int v71 = 1902671459;
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709) {
            goto LABEL_500;
          }
          int v102 = 1902403958;
LABEL_491:
          if (a2 == v102) {
            goto LABEL_502;
          }
          goto LABEL_516;
        }
        if (a2 == 1902212657) {
          goto LABEL_502;
        }
        int v73 = 1902212707;
        goto LABEL_499;
      }
      if (a2 == 1752589105 || a2 == 1836415073) {
        goto LABEL_496;
      }
      int v71 = 1869117027;
    }
LABEL_495:
    if (a2 == v71) {
      goto LABEL_496;
    }
LABEL_516:
    snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
    FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
    goto LABEL_503;
  }
  if (a2 > 1684895095)
  {
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096) {
        goto LABEL_496;
      }
      if (a2 == 1685220713) {
        goto LABEL_500;
      }
      int v71 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573) {
          goto LABEL_496;
        }
        int v73 = 1700886115;
LABEL_499:
        if (a2 != v73) {
          goto LABEL_516;
        }
        goto LABEL_500;
      }
      if (a2 == 1718908520) {
        goto LABEL_496;
      }
      int v71 = 1751479857;
    }
    goto LABEL_495;
  }
  if (a2 <= 1667331682)
  {
    if (a2 == 1635135537) {
      goto LABEL_502;
    }
    if (a2 == 1635148593) {
      goto LABEL_500;
    }
    int v73 = 1635148595;
    goto LABEL_499;
  }
  if (a2 <= 1667790434)
  {
    if (a2 != 1667331683)
    {
      int v71 = 1667524657;
      goto LABEL_495;
    }
LABEL_500:
    int SPSIsInterlaced = FigH264Bridge_GetSPSIsInterlaced(v109, v108, (BOOL *)&colorPrimariesCodePoint[1]);
    goto LABEL_501;
  }
  if (a2 != 1667790435)
  {
    int v102 = 1684108849;
    goto LABEL_491;
  }
LABEL_496:
  int SPSIsInterlaced = FigHEVCBridge_GetSPSIsInterlaced((uint64_t)v109, v108, (char *)&colorPrimariesCodePoint[1]);
LABEL_501:
  int v70 = SPSIsInterlaced;
LABEL_502:
  if (v70) {
    goto LABEL_303;
  }
LABEL_503:
  if (LOBYTE(colorPrimariesCodePoint[1])) {
    goto LABEL_303;
  }
  *(_DWORD *)__str = 1;
  v112[v26] = v67;
  CFNumberRef v104 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, __str);
  *((void *)v111 + v26) = v104;
  if (!v104)
  {
LABEL_506:
    uint64_t v91 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    if (!v26) {
      return v91;
    }
    goto LABEL_507;
  }
  ++v26;
LABEL_303:
  if (CFDictionaryContainsKey(v4, @"MasteringDisplayColorVolume")) {
    goto LABEL_358;
  }
  *(void *)__str = 0;
  int IsHEVCFlavor = FigVideoCodecTypeIsHEVCFlavor(a2);
  if (!IsHEVCFlavor)
  {
    if (a2 > 1902212656)
    {
      if (a2 == 1902403958) {
        goto LABEL_350;
      }
      int v74 = 1902212657;
    }
    else
    {
      if (a2 == 1635135537) {
        goto LABEL_350;
      }
      int v74 = 1684108849;
    }
    if (a2 != v74) {
      goto LABEL_351;
    }
LABEL_350:
    int IsHEVCFlavor = FigAV1Bridge_CopyMDCVDataFromAV1ConfigurationRecordConfigOBU(ValueAtIndex, (CFDataRef *)__str);
    goto LABEL_351;
  }
  int IsHEVCFlavor = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 137, (CFTypeRef *)__str);
LABEL_351:
  size_t v75 = *(const void **)__str;
  if (!IsHEVCFlavor && *(void *)__str)
  {
    if (CFDataGetLength(*(CFDataRef *)__str) == 24)
    {
      v112[v26] = @"MasteringDisplayColorVolume";
      *((void *)v111 + v26++) = *(void *)__str;
      goto LABEL_358;
    }
    size_t v75 = *(const void **)__str;
  }
  if (v75) {
    CFRelease(v75);
  }
LABEL_358:
  if (CFDictionaryContainsKey(v4, @"ContentLightLevelInfo")) {
    goto LABEL_375;
  }
  *(void *)__str = 0;
  int v76 = FigVideoCodecTypeIsHEVCFlavor(a2);
  if (v76)
  {
    int v76 = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 144, (CFTypeRef *)__str);
    goto LABEL_368;
  }
  if (a2 > 1902212656)
  {
    if (a2 != 1902403958)
    {
      int v77 = 1902212657;
LABEL_366:
      if (a2 != v77) {
        goto LABEL_368;
      }
    }
  }
  else if (a2 != 1635135537)
  {
    int v77 = 1684108849;
    goto LABEL_366;
  }
  int v76 = FigAV1Bridge_CopyCLLIDataFromAV1ConfigurationRecordConfigOBU(ValueAtIndex, (CFDataRef *)__str);
LABEL_368:
  size_t v78 = *(const void **)__str;
  if (!v76 && *(void *)__str)
  {
    if (CFDataGetLength(*(CFDataRef *)__str) == 4)
    {
      v112[v26] = @"ContentLightLevelInfo";
      *((void *)v111 + v26++) = *(void *)__str;
      goto LABEL_375;
    }
    size_t v78 = *(const void **)__str;
  }
  if (v78) {
    CFRelease(v78);
  }
LABEL_375:
  if (!CFDictionaryContainsKey(v4, @"AmbientViewingEnvironment")
    && FigVideoCodecTypeIsHEVCFlavor(a2))
  {
    *(void *)__str = 0;
    int v81 = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 148, (CFTypeRef *)__str);
    char v82 = *(const void **)__str;
    if (!v81 && *(void *)__str)
    {
      if (CFDataGetLength(*(CFDataRef *)__str) == 8)
      {
        v112[v26] = @"AmbientViewingEnvironment";
        *((void *)v111 + v26++) = *(void *)__str;
        goto LABEL_376;
      }
      char v82 = *(const void **)__str;
    }
    if (v82) {
      CFRelease(v82);
    }
  }
LABEL_376:
  if (!CFDictionaryContainsKey(v4, @"ContentColorVolume") && FigVideoCodecTypeIsHEVCFlavor(a2))
  {
    *(void *)__str = 0;
    int v83 = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 149, (CFTypeRef *)__str);
    uint64_t v84 = *(void *)__str;
    if (v83 || !*(void *)__str)
    {
      if (*(void *)__str) {
        CFRelease(*(CFTypeRef *)__str);
      }
    }
    else
    {
      v112[v26] = @"ContentColorVolume";
      *((void *)v111 + v26++) = v84;
    }
  }
  if (!CFDictionaryContainsKey(v4, @"AlternativeTransferCharacteristics"))
  {
    if (FigVideoCodecTypeIsHEVCFlavor(a2))
    {
      __str[0] = 0;
      if (!FigHEVCBridge_GetATCSEI(ValueAtIndex, (UInt8 *)__str))
      {
        v112[v26] = @"AlternativeTransferCharacteristics";
        BOOL v85 = CVTransferFunctionGetStringForIntegerCodePoint(__str[0]);
        if (v85) {
          BOOL v85 = CFRetain(v85);
        }
        *((void *)v111 + v26++) = v85;
      }
    }
  }
  if (!CFDictionaryContainsKey(v4, @"AlphaChannelMode"))
  {
    if (FigVideoCodecTypeIsHEVCFlavor(a2))
    {
      *(void *)__str = 0;
      if (!FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 165, (CFTypeRef *)__str))
      {
        if (*(void *)__str)
        {
          LOBYTE(colorPrimariesCodePoint[1]) = 0;
          int32_t v86 = CFDataGetBytePtr(*(CFDataRef *)__str);
          CFIndex v87 = CFDataGetLength(*(CFDataRef *)__str);
          if (!FigHEVCBridge_GetSEIAlphaChannelInfo((uint64_t)v86, v87, &colorPrimariesCodePoint[1]))
          {
            if (LOBYTE(colorPrimariesCodePoint[1])) {
              unsigned int v88 = &kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha;
            }
            else {
              unsigned int v88 = &kCMFormatDescriptionAlphaChannelMode_StraightAlpha;
            }
            *((CFStringRef *)v111 + v26) = *v88;
            v112[v26++] = @"AlphaChannelMode";
          }
          if (*(void *)__str) {
            CFRelease(*(CFTypeRef *)__str);
          }
        }
      }
    }
  }
  if (CFDictionaryContainsKey(v4, @"ContainsAlphaChannel"))
  {
    int v79 = (const void *)*MEMORY[0x1E4F1CFD0];
    BOOL v80 = v79 == CFDictionaryGetValue(v4, @"ContainsAlphaChannel");
  }
  else if (FigVideoCodecTypeIsHEVCFlavor(a2) && figBridge_AlphaLayerIsPresent(v4))
  {
    *((void *)v111 + v26) = *MEMORY[0x1E4F1CFD0];
    v112[v26++] = @"ContainsAlphaChannel";
    BOOL v80 = 1;
  }
  else
  {
    BOOL v80 = 0;
  }
  if (a2 <= 1836415072)
  {
    if (a2 > 1751479856)
    {
      if (a2 == 1751479857) {
        goto LABEL_422;
      }
      int v89 = 1752589105;
    }
    else
    {
      if (a2 == 1667790435) {
        goto LABEL_422;
      }
      int v89 = 1718908520;
    }
LABEL_421:
    if (a2 != v89) {
      goto LABEL_434;
    }
    goto LABEL_422;
  }
  if (a2 <= 1902667125)
  {
    if (a2 == 1836415073) {
      goto LABEL_422;
    }
    int v89 = 1869117027;
    goto LABEL_421;
  }
  if (a2 != 1902667126 && a2 != 1902998904)
  {
    int v89 = 1902671459;
    goto LABEL_421;
  }
LABEL_422:
  if (v80)
  {
    colorPrimariesCodePoint[1] = 0;
    if (!FigHEVCBridge_CheckVPSPrimaryAlphaLayerCompatibility(ValueAtIndex, &colorPrimariesCodePoint[1]))
    {
      if (colorPrimariesCodePoint[1] == 2)
      {
        strcpy(__str, "Image description - PrimaryAlphaLayerCompatibility. Apple decoders will not be able to decode this HEVC with Alpha stream. To fix this in the encoder, for the primary alpha layer, NumDirectRefLayers must be 0 and poc_lsb_not_present_flag must be 1");
        uint64_t v90 = 4294954579;
        goto LABEL_433;
      }
      if (colorPrimariesCodePoint[1] == 1)
      {
        strcpy(__str, "Image description - PrimaryAlphaLayerCompatibility. Apple decoders can still decode this HEVC with Alpha stream, but the stream is not compliant with the standard (ISO/IEC 23008-2) and may have compatibility issues with other decoders");
        uint64_t v90 = 4294954580;
LABEL_433:
        FigSignalErrorAt(v90, 0, 0, 0, 0, 0, 0);
        figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
      }
    }
  }
LABEL_434:
  if (!CFDictionaryContainsKey(v4, @"BitsPerComponent"))
  {
    __str[0] = 0;
    if (!figBridge_getSPS_VUI_ComponentBitDepth(a2, (char *)v109, v108, __str))
    {
      *((void *)v111 + v26) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt8Type, __str);
      v112[v26++] = @"BitsPerComponent";
    }
  }
  if (!v26) {
    return 0;
  }
  uint64_t v91 = FigCFCreateExtendedDictionary(a1, v4, v112, v111, v26, &v110);
  if (!v91 && v110)
  {
    *a4 = v110;
    CFRelease(v4);
  }
LABEL_507:
  uint64_t v105 = (CFTypeRef *)v111;
  do
  {
    if (*v105) {
      CFRelease(*v105);
    }
    ++v105;
    --v26;
  }
  while (v26);
  return v91;
}

void figBridge_OverrideTransferFunctionFromAlternativeTransferCharacteristics(const __CFAllocator *a1, const void *a2, CFDictionaryRef *a3)
{
  if (a3)
  {
    CFIndex v7 = (const void *)*MEMORY[0x1E4F24BC8];
    CFDictionaryRef Value = CFDictionaryGetValue(*a3, (const void *)*MEMORY[0x1E4F24BC8]);
    if (!Value || !FigCFEqual(Value, a2))
    {
      CFMutableArrayRef MutableCopy = FigCFDictionaryCreateMutableCopy(a1, *a3);
      CFDictionarySetValue(MutableCopy, v7, a2);
      if (*a3) {
        CFRelease(*a3);
      }
      *a3 = MutableCopy;
    }
  }
  else
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigVideoCodecTypeIsProRes(int a1)
{
  uint64_t result = 1;
  if (a1 <= 1634743415)
  {
    if (a1 != 1634742376 && a1 != 1634742888)
    {
      unsigned __int16 v3 = 13416;
LABEL_9:
      if (a1 != (v3 | 0x61700000)) {
        return 0;
      }
    }
  }
  else if (((a1 - 1634755432) > 0xB || ((1 << (a1 - 104)) & 0x8C1) == 0) {
         && ((a1 - 1634759272) > 6 || ((1 << (a1 - 104)) & 0x51) == 0))
  }
  {
    unsigned __int16 v3 = 13432;
    goto LABEL_9;
  }
  return result;
}

void figBridge_GetBitsPerComponentForProRes(const __CFAllocator *a1, int a2, uint64_t *a3)
{
  int v8 = 0;
  if (a3)
  {
    FigCFDictionaryGetIntIfPresent(*a3, @"BitsPerComponent", &v8);
    if (v8) {
      return;
    }
    CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy(a1, (CFDictionaryRef)*a3);
    __int16 v7 = 0;
    int v8 = 12;
    FigCFDictionaryGetInt16IfPresent(*a3, @"Depth", &v7);
    if (a2 > 1634759271)
    {
      if (a2 != 1634759272 && a2 != 1634759278)
      {
LABEL_14:
        FigCFDictionarySetInt32(MutableCopy, @"BitsPerComponent", v8);
        if (*a3) {
          CFRelease((CFTypeRef)*a3);
        }
        *a3 = (uint64_t)MutableCopy;
        return;
      }
    }
    else if (a2 != 1634743400 && a2 != 1634743416 || v7 != 32)
    {
      goto LABEL_14;
    }
    int v8 = 16;
    goto LABEL_14;
  }

  FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

void figBridge_GetAlphaChannelExtensionForProRes(const __CFAllocator *a1, uint64_t *a2)
{
  __int16 v10 = 0;
  if (a2 && *a2)
  {
    FigCFDictionaryGetInt16IfPresent(*a2, @"Depth", &v10);
    if (v10 == 32)
    {
      int v4 = CFDictionaryContainsKey((CFDictionaryRef)*a2, @"ContainsAlphaChannel");
      int v5 = CFDictionaryContainsKey((CFDictionaryRef)*a2, @"AlphaChannelMode");
      if (!v4 || v5 == 0)
      {
        int v7 = v5;
        CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy(a1, (CFDictionaryRef)*a2);
        if (MutableCopy)
        {
          CFIndex v9 = MutableCopy;
          if (!v4) {
            CFDictionarySetValue(MutableCopy, @"ContainsAlphaChannel", (const void *)*MEMORY[0x1E4F1CFD0]);
          }
          if (!v7) {
            CFDictionarySetValue(v9, @"AlphaChannelMode", @"StraightAlpha");
          }
          if (*a2) {
            CFRelease((CFTypeRef)*a2);
          }
          *a2 = (uint64_t)v9;
        }
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
}

CFDictionaryRef figBridge_Is3GP263ExtensionPresent(const __CFDictionary *a1)
{
  CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(a1, @"SampleDescriptionExtensionAtoms");
  if (result)
  {
    CFDictionaryRef v2 = result;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    CFDictionaryRef result = 0;
    if (TypeID == CFGetTypeID(v2))
    {
      CFDictionaryRef Value = CFDictionaryGetValue(v2, @"d263");
      if (Value)
      {
        int v5 = Value;
        CFTypeID v6 = CFDataGetTypeID();
        if (v6 == CFGetTypeID(v5)) {
          return (const __CFDictionary *)1;
        }
      }
    }
  }
  return result;
}

OSStatus CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionData(CFAllocatorRef allocator, const uint8_t *imageDescriptionData, size_t size, CFStringEncoding stringEncoding, CMImageDescriptionFlavor flavor, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  return FigVideoFormatDescriptionCreateFromBigEndianImageDescriptionDataWithReporter(allocator, (long long *)imageDescriptionData, size, stringEncoding, flavor, formatDescriptionOut, 0);
}

uint64_t FigBridge_GetPlaintextMediaSubTypeAndEncryptionSchemeFromProtectedCodecType(int a1, int *a2, int *a3)
{
  uint64_t v3 = 0;
  while (1)
  {
    int v4 = &lookUpConciseCodecType[v3];
    if (lookUpConciseCodecType[v3 + 2] == a1) {
      break;
    }
    v3 += 3;
    if (v3 == 63) {
      return 4294954578;
    }
  }
  if (!*v4) {
    return 4294954578;
  }
  int v6 = v4[1];
  if (a2) {
    *a2 = *v4;
  }
  uint64_t result = 0;
  if (a3) {
    *a3 = v6;
  }
  return result;
}

uint64_t figConvertChromaLocationIndexToString(int a1)
{
  switch(a1)
  {
    case 0:
      uint64_t v1 = MEMORY[0x1E4F24A38];
      return *(void *)v1;
    case 1:
      uint64_t v1 = MEMORY[0x1E4F24A28];
      return *(void *)v1;
    case 2:
      uint64_t v1 = MEMORY[0x1E4F24A48];
      return *(void *)v1;
    case 3:
      uint64_t v1 = MEMORY[0x1E4F24A40];
      return *(void *)v1;
    case 4:
      uint64_t v1 = MEMORY[0x1E4F24A20];
      return *(void *)v1;
    case 5:
      uint64_t v1 = MEMORY[0x1E4F24A18];
      return *(void *)v1;
    default:
      if (a1 == 255)
      {
        uint64_t v1 = MEMORY[0x1E4F24A30];
        return *(void *)v1;
      }
      else
      {
        FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
        return 0;
      }
  }
}

CFDictionaryRef figBridge_CFDictionaryCreateWithNumbers(const __CFAllocator *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  *(_OWORD *)keys = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)values = 0u;
  long long v22 = 0u;
  int v20 = (void **)&a9;
  if (a3)
  {
    __int16 v10 = a3;
    int v11 = 0;
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (v11 < 10)
    {
      int v13 = v20++;
      int valuePtr = *(_DWORD *)v13;
      CFNumberRef v14 = CFNumberCreate(v12, kCFNumberSInt32Type, &valuePtr);
      values[v11] = v14;
      if (v14) {
        keys[v11++] = v10;
      }
      int v15 = v20++;
      __int16 v10 = *v15;
      if (!*v15) {
        goto LABEL_10;
      }
    }
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    int v11 = 0;
  }
LABEL_10:
  CFDictionaryRef v16 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, v11, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v11 >= 1)
  {
    unint64_t v17 = v11 + 1;
    do
      CFRelease(values[(v17-- - 2)]);
    while (v17 > 1);
  }
  return v16;
}

uint64_t figBridge_AlphaLayerIsPresent(const __CFDictionary *a1)
{
  unsigned __int8 v14 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  CFDictionaryRef Value = CFDictionaryGetValue(a1, @"SampleDescriptionExtensionAtoms");
  if (!Value) {
    return 0;
  }
  CFDictionaryRef v2 = Value;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v2)) {
    return 0;
  }
  CFArrayRef v4 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v2, @"hvcC");
  if (!v4) {
    return 0;
  }
  CFArrayRef ValueAtIndex = v4;
  CFTypeID v6 = CFArrayGetTypeID();
  if (v6 == CFGetTypeID(ValueAtIndex))
  {
    CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    if (!ValueAtIndex) {
      return 0;
    }
  }
  CFTypeID v7 = CFDataGetTypeID();
  if (v7 == CFGetTypeID(ValueAtIndex)
    && (int v13 = 0,
        !FigHEVCBridge_GetHEVCParameterSetAtIndex(ValueAtIndex, 32, 0, (unint64_t)&v12, (unint64_t)&v11, 0, 0)))
  {
    int VPSAlphaChannelNuhLayerId = FigHEVCBridge_GetVPSAlphaChannelNuhLayerId(v12, v11, &v14, &v13);
    unsigned __int8 v9 = v14;
    if (VPSAlphaChannelNuhLayerId) {
      return 0;
    }
  }
  else
  {
    return 0;
  }
  return v9;
}

uint64_t figBridge_getSPS_VUI_ComponentBitDepth(int a1, char *a2, unint64_t a3, unsigned char *a4)
{
  __int16 v10 = 0;
  uint64_t result = 4294954579;
  if (a1 > 1836415072)
  {
    if (a1 > 1902405732)
    {
      if (a1 > 1902667125)
      {
        if (a1 == 1902667126 || a1 == 1902998904) {
          goto LABEL_31;
        }
        int v7 = 1902671459;
        goto LABEL_30;
      }
      if (a1 == 1902405733) {
        goto LABEL_31;
      }
      unsigned __int16 v8 = 28024;
    }
    else
    {
      if (a1 <= 1902212656)
      {
        if (a1 == 1836415073) {
          goto LABEL_31;
        }
        int v7 = 1869117027;
LABEL_30:
        if (a1 != v7) {
          return result;
        }
        goto LABEL_31;
      }
      if (a1 == 1902212657 || a1 == 1902403958) {
        goto LABEL_22;
      }
      unsigned __int16 v8 = 26673;
    }
    int v7 = v8 | 0x71640000;
    goto LABEL_30;
  }
  if (a1 > 1685481520)
  {
    if (a1 <= 1718908519)
    {
      if (a1 == 1685481521) {
        goto LABEL_31;
      }
      int v7 = 1685481573;
    }
    else
    {
      if (a1 == 1718908520 || a1 == 1751479857) {
        goto LABEL_31;
      }
      int v7 = 1752589105;
    }
    goto LABEL_30;
  }
  if (a1 <= 1667790434)
  {
    if (a1 == 1635135537) {
      goto LABEL_22;
    }
    int v7 = 1667524657;
    goto LABEL_30;
  }
  if (a1 != 1667790435)
  {
    if (a1 != 1684108849)
    {
      int v7 = 1684895096;
      goto LABEL_30;
    }
LABEL_22:
    uint64_t result = FigAV1Bridge_GetChromaFormatAndBitDepthsFromAV1CodecConfigurationRecord(a2, a3, 0, 0, &v10);
    char v9 = v10;
    goto LABEL_34;
  }
LABEL_31:
  uint64_t result = FigHEVCBridge_GetSPSBitDepths((uint64_t)a2, a3, (unsigned char *)&v10 + 1, &v10);
  if (result) {
    return result;
  }
  char v9 = HIBYTE(v10);
  if (HIBYTE(v10) <= v10) {
    char v9 = v10;
  }
LABEL_34:
  *a4 = v9;
  return result;
}

OSStatus CMVideoFormatDescriptionCopyTagCollectionArray(CMVideoFormatDescriptionRef formatDescription, CFArrayRef *tagCollectionsOut)
{
  uint64_t v27 = 0;
  CFDataRef theData = 0;
  uint64_t v26 = 0;
  unsigned __int8 v25 = -1;
  unsigned __int8 v24 = -1;
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(formatDescription);
  signed int v5 = MediaSubType;
  OSStatus v6 = -12710;
  if (MediaSubType <= 1768972831)
  {
    if (MediaSubType > 1685481572)
    {
      if (MediaSubType > 1751479856)
      {
        if (MediaSubType == 1751479857) {
          goto LABEL_29;
        }
        int v7 = 1752589105;
      }
      else
      {
        if (MediaSubType == 1685481573) {
          goto LABEL_29;
        }
        int v7 = 1718908520;
      }
    }
    else
    {
      if (MediaSubType <= 1684895095)
      {
        if (MediaSubType != 1667524657)
        {
          int v7 = 1667790435;
          goto LABEL_28;
        }
LABEL_29:
        CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(formatDescription);
        if (!Extensions) {
          goto LABEL_47;
        }
        CFDictionaryRef v8 = Extensions;
        if (v5 == 1768972832) {
          goto LABEL_31;
        }
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms");
        if (Value)
        {
          CFArrayRef v13 = (const __CFArray *)CFDictionaryGetValue(Value, @"hvcC");
          if (v13)
          {
            CFArrayRef ValueAtIndex = v13;
            CFTypeID v15 = CFGetTypeID(v13);
            if (v15 == CFArrayGetTypeID()
              && (CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0)) == 0
              || (CFTypeID v16 = CFGetTypeID(ValueAtIndex), v16 != CFDataGetTypeID()))
            {
LABEL_50:
              OSStatus HEVCParameterSetAtIndex = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_51:
              OSStatus v6 = HEVCParameterSetAtIndex;
              goto LABEL_47;
            }
            OSStatus HEVCParameterSetAtIndex = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 176, (CFTypeRef *)&theData);
            if (HEVCParameterSetAtIndex) {
              goto LABEL_51;
            }
            if (!theData) {
              return -12710;
            }
            OSStatus HEVCParameterSetAtIndex = FigHEVCBridge_GetHEVCParameterSetAtIndex(ValueAtIndex, 32, 0, (unint64_t)&v27, (unint64_t)&v26, 0, 0);
            if (HEVCParameterSetAtIndex) {
              goto LABEL_51;
            }
            uint64_t v19 = v26;
            uint64_t v18 = v27;
            BytePtr = CFDataGetBytePtr(theData);
            CFIndex Length = CFDataGetLength(theData);
            FigHEVCBridge_Get3DLayerIDs(v18, v19, (uint64_t)BytePtr, Length, (char *)&v25, (char *)&v24);
            if (HEVCParameterSetAtIndex) {
              goto LABEL_51;
            }
LABEL_44:
            if (v25 != 255 && v24 != 255)
            {
              OSStatus v6 = 0;
              *tagCollectionsOut = figBridge_createFigTagCollectionArrayForLeftEyeVideoLayerIDsAndRightEyeVideoLayerIDs(&v25, &v24, 1);
              goto LABEL_47;
            }
            goto LABEL_50;
          }
        }
        goto LABEL_52;
      }
      if (MediaSubType == 1684895096) {
        goto LABEL_29;
      }
      int v7 = 1685481521;
    }
LABEL_28:
    if (MediaSubType != v7) {
      goto LABEL_47;
    }
    goto LABEL_29;
  }
  if (MediaSubType > 1902407031)
  {
    if (MediaSubType > 1902671458)
    {
      if (MediaSubType == 1902998904) {
        goto LABEL_29;
      }
      unsigned __int16 v9 = 30307;
    }
    else
    {
      if (MediaSubType == 1902407032) {
        goto LABEL_29;
      }
      unsigned __int16 v9 = 25974;
    }
    int v7 = v9 | 0x71680000;
    goto LABEL_28;
  }
  if (MediaSubType > 1902405680)
  {
    if (MediaSubType == 1902405681) {
      goto LABEL_29;
    }
    int v7 = 1902405733;
    goto LABEL_28;
  }
  if (MediaSubType == 1836415073 || MediaSubType == 1869117027) {
    goto LABEL_29;
  }
  if (MediaSubType != 1768972832) {
    goto LABEL_47;
  }
  CFDictionaryRef v8 = CMFormatDescriptionGetExtensions(formatDescription);
  if (v8)
  {
LABEL_31:
    __int16 v23 = 0;
    FigCFDictionaryGetBooleanIfPresent((uint64_t)v8, @"HasLeftStereoEyeView", (Boolean *)&v23 + 1);
    FigCFDictionaryGetBooleanIfPresent((uint64_t)v8, @"HasRightStereoEyeView", (Boolean *)&v23);
    StringCFDictionaryRef Value = FigCFDictionaryGetStringValue(v8, @"ViewPackingKind");
    if (HIBYTE(v23) && (_BYTE)v23 && !StringValue)
    {
      unsigned __int8 v25 = 0;
      unsigned __int8 v24 = 1;
    }
    goto LABEL_44;
  }
LABEL_52:
  OSStatus v6 = -12710;
LABEL_47:
  if (theData) {
    CFRelease(theData);
  }
  return v6;
}

__CFArray *figBridge_createFigTagCollectionArrayForLeftEyeVideoLayerIDsAndRightEyeVideoLayerIDs(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  CFMutableDictionaryRef Mutable = 0;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CMTagCollectionRef newCollectionOut = 0;
  if (a1)
  {
    CFArrayRef v4 = a2;
    if (a2)
    {
      uint64_t v5 = a3;
      if (a3 >= 1)
      {
        OSStatus v6 = a1;
        CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        if (Mutable)
        {
          while (1)
          {
            CMTag tags = kCMTagStereoLeftEye;
            unsigned int v8 = *v6++;
            CMTag v14 = CMTagMakeWithSInt64Value(kCMTagCategory_VideoLayerID, v8);
            v12[0] = kCMTagStereoRightEye;
            unsigned int v9 = *v4++;
            v12[1] = CMTagMakeWithSInt64Value(kCMTagCategory_VideoLayerID, v9);
            if (CMTagCollectionCreate(v7, &tags, 2, &newCollectionOut)) {
              break;
            }
            CFArrayAppendValue(Mutable, newCollectionOut);
            if (newCollectionOut)
            {
              CFRelease(newCollectionOut);
              CMTagCollectionRef newCollectionOut = 0;
            }
            if (FigTagCollectionCreate((uint64_t)v7, (uint64_t)v12, 2, (uint64_t *)&newCollectionOut)) {
              break;
            }
            CFArrayAppendValue(Mutable, newCollectionOut);
            if (newCollectionOut)
            {
              CFRelease(newCollectionOut);
              CMTagCollectionRef newCollectionOut = 0;
            }
            if (!--v5) {
              return Mutable;
            }
          }
          if (newCollectionOut) {
            CFRelease(newCollectionOut);
          }
        }
      }
    }
  }
  return Mutable;
}

uint64_t FigVideoFormatDescriptionCopyFigTagCollectionArrayWithExtraChannels(const opaqueCMFormatDescription *a1, __CFArray **a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = 0;
  CFDataRef theData = 0;
  uint64_t v25 = 0;
  memset(v29, 0, sizeof(v29));
  memset(v28, 0, sizeof(v28));
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  uint64_t v5 = 4294954586;
  if (MediaSubType > 1836415072)
  {
    if (MediaSubType > 1902407031)
    {
      if (MediaSubType > 1902671458)
      {
        if (MediaSubType == 1902998904) {
          goto LABEL_26;
        }
        unsigned __int16 v7 = 30307;
      }
      else
      {
        if (MediaSubType == 1902407032) {
          goto LABEL_26;
        }
        unsigned __int16 v7 = 25974;
      }
      int v6 = v7 | 0x71680000;
    }
    else if (MediaSubType > 1902405680)
    {
      if (MediaSubType == 1902405681) {
        goto LABEL_26;
      }
      int v6 = 1902405733;
    }
    else
    {
      if (MediaSubType == 1836415073) {
        goto LABEL_26;
      }
      int v6 = 1869117027;
    }
  }
  else if (MediaSubType > 1685481572)
  {
    if (MediaSubType > 1751479856)
    {
      if (MediaSubType == 1751479857) {
        goto LABEL_26;
      }
      int v6 = 1752589105;
    }
    else
    {
      if (MediaSubType == 1685481573) {
        goto LABEL_26;
      }
      int v6 = 1718908520;
    }
  }
  else if (MediaSubType > 1684895095)
  {
    if (MediaSubType == 1684895096) {
      goto LABEL_26;
    }
    int v6 = 1685481521;
  }
  else
  {
    if (MediaSubType == 1667524657) {
      goto LABEL_26;
    }
    int v6 = 1667790435;
  }
  if (MediaSubType != v6) {
    goto LABEL_48;
  }
LABEL_26:
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
  if (Extensions)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms");
    if (Value)
    {
      __int16 v10 = CFDictionaryGetValue(Value, @"hvcC");
      if (v10)
      {
        CFArrayRef ValueAtIndex = v10;
        CFTypeID v12 = CFGetTypeID(v10);
        if (v12 != CFArrayGetTypeID() || (CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0)) != 0)
        {
          CFTypeID v13 = CFGetTypeID(ValueAtIndex);
          if (v13 == CFDataGetTypeID())
          {
            uint64_t HEVCParameterSetAtIndex = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 176, (CFTypeRef *)&theData);
            if (HEVCParameterSetAtIndex) {
              goto LABEL_52;
            }
            if (!theData) {
              return 4294954586;
            }
            uint64_t HEVCParameterSetAtIndex = FigHEVCBridge_GetHEVCParameterSetAtIndex(ValueAtIndex, 32, 0, (unint64_t)&v26, (unint64_t)&v25, 0, 0);
            if (HEVCParameterSetAtIndex) {
              goto LABEL_52;
            }
            uint64_t v16 = v25;
            uint64_t v15 = v26;
            BytePtr = CFDataGetBytePtr(theData);
            CFIndex Length = CFDataGetLength(theData);
            FigHEVCBridge_Get3DLayerIDSets(v15, v16, (uint64_t)BytePtr, Length, v29, v28);
            if (HEVCParameterSetAtIndex) {
              goto LABEL_52;
            }
            uint64_t v19 = 0;
            uint64_t v20 = -1;
            uint64_t v21 = -1;
            do
            {
              int v22 = *((unsigned __int8 *)v29 + v19);
              int v23 = *((unsigned __int8 *)v28 + v19);
              if (v22 == 255 && v23 == 255) {
                break;
              }
              if (v23 != 255) {
                uint64_t v20 = v19;
              }
              if (v22 != 255) {
                uint64_t v21 = v19;
              }
              ++v19;
            }
            while (v19 != 64);
            if ((v21 & 0x8000000000000000) == 0 && (v20 & 0x8000000000000000) == 0 && v21 == v20)
            {
              uint64_t v5 = 0;
              *a2 = figBridge_createFigTagCollectionArrayForLeftEyeVideoLayerIDsAndRightEyeVideoLayerIDs((unsigned __int8 *)v29, (unsigned __int8 *)v28, v21 + 1);
              goto LABEL_48;
            }
          }
        }
        uint64_t HEVCParameterSetAtIndex = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_52:
        uint64_t v5 = HEVCParameterSetAtIndex;
      }
    }
  }
LABEL_48:
  if (theData) {
    CFRelease(theData);
  }
  return v5;
}

uint64_t FigVideoFormatDescriptionDetermineCompatibilityWithCoreMediaRequirementsForHEVCWithAlpha(const opaqueCMFormatDescription *a1, _DWORD *a2)
{
  int v11 = 0;
  FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  if ((MediaSubType == 1752589105 || MediaSubType == 1902671459) && FigVideoFormatDescriptionContainsAlphaChannel(a1))
  {
    CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
    if (Extensions
      && (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms")) != 0
      && (unsigned __int16 v7 = CFDictionaryGetValue(Value, @"hvcC")) != 0
      && (unsigned int v8 = v7, v9 = CFGetTypeID(v7), v9 == CFDataGetTypeID()))
    {
      uint64_t result = FigHEVCBridge_CheckVPSPrimaryAlphaLayerCompatibility(v8, &v11);
      if (!result)
      {
        if (v11 == 2 || v11 == 1)
        {
          uint64_t result = 0;
          *a2 = v11;
        }
        else if (v11)
        {
          return 4294954578;
        }
        else
        {
          uint64_t result = 0;
          *a2 = 0;
        }
      }
    }
    else
    {
      return 4294954586;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

OSStatus CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef imageDescriptionBlockBuffer, CFStringEncoding stringEncoding, CMImageDescriptionFlavor flavor, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  return FigVideoFormatDescriptionCreateFromBigEndianImageDescriptionBlockBufferWithReporter(allocator, imageDescriptionBlockBuffer, stringEncoding, flavor, formatDescriptionOut, 0);
}

uint64_t FigVideoFormatDescriptionCreateFromBigEndianImageDescriptionBlockBufferWithReporter(const __CFAllocator *a1, CMBlockBufferRef theBuffer, CFStringEncoding a3, const void *a4, CMVideoFormatDescriptionRef *a5, const void *a6)
{
  CFTypeRef cf = 0;
  if (theBuffer)
  {
    dataPointerOut = 0;
    DataCFIndex Length = CMBlockBufferGetDataLength(theBuffer);
    if (CMBlockBufferIsRangeContiguous(theBuffer, 0, 0))
    {
      CFTypeID v13 = (void *)CFRetain(theBuffer);
      CFTypeRef cf = v13;
    }
    else
    {
      uint64_t Contiguous = CMBlockBufferCreateContiguous(a1, theBuffer, a1, 0, 0, DataLength, 0, (CMBlockBufferRef *)&cf);
      if (Contiguous) {
        goto LABEL_9;
      }
      CFTypeID v13 = (void *)cf;
    }
    CMBlockBufferGetDataPointer((CMBlockBufferRef)v13, 0, 0, 0, &dataPointerOut);
    uint64_t Contiguous = FigVideoFormatDescriptionCreateFromBigEndianImageDescriptionDataWithReporter(a1, (long long *)dataPointerOut, DataLength, a3, a4, a5, a6);
LABEL_9:
    if (cf) {
      CFRelease(cf);
    }
    return Contiguous;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

OSStatus CMVideoFormatDescriptionCopyAsBigEndianImageDescriptionBlockBuffer(CFAllocatorRef allocator, CMVideoFormatDescriptionRef videoFormatDescription, CFStringEncoding stringEncoding, CMImageDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  uint64_t v65 = 0;
  CMBlockBufferRef theBuffer = 0;
  uint64_t v64 = 0;
  if (videoFormatDescription)
  {
    CFTypeID TypeID = CMFormatDescriptionGetTypeID();
    if (TypeID == CFGetTypeID(videoFormatDescription)
      && CMFormatDescriptionGetMediaType(videoFormatDescription) == 1986618469
      && blockBufferOut)
    {
      if (flavor)
      {
        if (CFEqual(flavor, @"ISOFamily"))
        {
          int v11 = 0;
          LOBYTE(flavor) = 1;
        }
        else if (CFEqual(flavor, @"3GPFamily"))
        {
          int v11 = 0;
          LOBYTE(flavor) = 3;
        }
        else if (CFEqual(flavor, @"FMP4InStreamParameterSets"))
        {
          int v11 = 0;
          LOBYTE(flavor) = 5;
        }
        else if (CFEqual(flavor, @"ISOFamilyWithAppleExtensions"))
        {
          LOBYTE(flavor) = 9;
          int v11 = 1;
        }
        else
        {
          if (!CFEqual(flavor, @"QuickTimeMovie")) {
            goto LABEL_81;
          }
          int v11 = 0;
          LOBYTE(flavor) = 0;
        }
      }
      else
      {
        int v11 = 0;
      }
      FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(videoFormatDescription);
      if (MediaSubType == 1785750887) {
        int v15 = v11;
      }
      else {
        int v15 = 1;
      }
      if ((flavor & 1) == 0) {
        int v15 = 1;
      }
      if (v15) {
        int v16 = MediaSubType;
      }
      else {
        int v16 = 1835692135;
      }
      unsigned int v62 = v16;
      if (v16 <= 1902403957)
      {
        if (v16 > 1902212656)
        {
          if ((v16 - 1902212657) > 0x34
            || ((1 << (v16 - 49)) & 0x14000000000001) == 0)
          {
LABEL_50:
            if ((flavor & 7) != 1) {
              goto LABEL_69;
            }
            if (v16 <= 1701733237)
            {
              if (v16 > 1684890160)
              {
                if (v16 == 1684890161 || v16 == 1685220713) {
                  goto LABEL_69;
                }
                int v19 = 1685481521;
              }
              else
              {
                if (v16 == 1635135537 || v16 == 1635148593) {
                  goto LABEL_69;
                }
                int v19 = 1684108849;
              }
            }
            else if (v16 <= 1785750886)
            {
              if (v16 == 1701733238 || v16 == 1748121139) {
                goto LABEL_69;
              }
              int v19 = 1752589105;
            }
            else if (v16 > 1836070005)
            {
              if (v16 == 1836070006) {
                goto LABEL_69;
              }
              int v19 = 1987063865;
            }
            else
            {
              if (v16 == 1785750887) {
                goto LABEL_69;
              }
              int v19 = 1835692135;
            }
            if (v16 != v19) {
              goto LABEL_81;
            }
LABEL_69:
            if ((flavor & 2) != 0)
            {
              if (v16 <= 1748121138)
              {
                if (v16 != 1635148593)
                {
                  int v20 = 1701733238;
LABEL_76:
                  if (v16 == v20) {
                    goto LABEL_77;
                  }
LABEL_81:
                  uint64_t v12 = 4294954579;
                  goto LABEL_10;
                }
              }
              else if (v16 != 1748121139 && v16 != 1752589105)
              {
                int v20 = 1836070006;
                goto LABEL_76;
              }
            }
LABEL_77:
            if ((flavor & 4) != 0 && v16 != 1751479857 && v16 != 1685481573 && v16 != 1635148595) {
              goto LABEL_81;
            }
            uint64_t v21 = (CFStringRef *)&kCMFormatDescriptionExtension_VerbatimSampleDescription;
            if (flavor) {
              uint64_t v21 = (CFStringRef *)&kCMFormatDescriptionExtension_VerbatimISOSampleEntry;
            }
            CFDataRef Extension = (const __CFData *)CMFormatDescriptionGetExtension(videoFormatDescription, *v21);
            CFStringRef v63 = 0;
            if (Extension)
            {
              CFDataRef v23 = Extension;
              CFTypeID v24 = CFDataGetTypeID();
              if (v24 == CFGetTypeID(v23))
              {
                size_t Length = CFDataGetLength(v23);
                BytePtr = CFDataGetBytePtr(v23);
                dataPointerOut = 0;
                OSStatus DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, Length, allocator, 0, 0, Length, 1u, &theBuffer);
                if (!DataPointer)
                {
                  OSStatus DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
                  if (!DataPointer)
                  {
                    memcpy(dataPointerOut, BytePtr, Length);
                    *CMBlockBufferRef blockBufferOut = theBuffer;
                    CMBlockBufferRef theBuffer = 0;
                  }
                }
                goto LABEL_102;
              }
            }
            CFArrayRef v28 = (const __CFArray *)CMFormatDescriptionGetExtension(videoFormatDescription, @"RequiredButUnrecognizedFormatAtoms");
            if (v28)
            {
              CFArrayRef v29 = v28;
              CFTypeID v30 = CFGetTypeID(v28);
              if (v30 != CFArrayGetTypeID() || CFArrayGetCount(v29))
              {
                OSStatus v37 = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
LABEL_101:
                OSStatus DataPointer = v37;
                goto LABEL_102;
              }
            }
            figBridge_WalkAndConvertVideoFormatDescriptionExtensions(videoFormatDescription, (char)flavor, &v65, 0);
            unsigned int v31 = v65 + 86;
            OSStatus DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, v65 + 86, allocator, 0, 0, v65 + 86, 1u, &theBuffer);
            if (!DataPointer)
            {
              OSStatus DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &v63);
              if (!DataPointer)
              {
                CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(videoFormatDescription);
                if ((flavor & 1) == 0)
                {
                  CFNumberRef v33 = (const __CFNumber *)CMFormatDescriptionGetExtension(videoFormatDescription, @"Depth");
                  if (v33)
                  {
                    CFNumberRef v34 = v33;
                    CFTypeID v35 = CFNumberGetTypeID();
                    unsigned int v36 = 24;
                    if (v35 == CFGetTypeID(v34))
                    {
                      LOWORD(dataPointerOut) = 0;
                      if (CFNumberGetValue(v34, kCFNumberSInt16Type, &dataPointerOut)) {
                        unsigned int v36 = (unsigned __int16)dataPointerOut;
                      }
                      else {
                        unsigned int v36 = 24;
                      }
                    }
                  }
                  else
                  {
                    unsigned int v36 = 24;
                  }
                  unsigned int v39 = v62;
                  if (v62 <= 0x28 && ((1 << v62) & 0x11701010116) != 0)
                  {
                    unsigned int v62 = 1918990112;
                    unsigned int v36 = v39;
                  }
                  else if (v62 == 1836069494)
                  {
                    figBridge_ConvertMPEG2ProfileExtensionToCodecType(videoFormatDescription, &v62);
                  }
                  uint64_t v40 = v63;
                  *(_DWORD *)CFStringRef v63 = bswap32(v31);
                  *((_DWORD *)v40 + 1) = bswap32(v62);
                  *((void *)v40 + 1) = 0xFFFF000000000000;
                  *((void *)v40 + 2) = 0;
                  *((void *)v40 + 3) = 0x2000000020000;
                  *((_WORD *)v40 + 16) = bswap32(Dimensions.width) >> 16;
                  *((_WORD *)v40 + 17) = bswap32(Dimensions.height) >> 16;
                  *(void *)(v40 + 36) = 0x480000004800;
                  *((_DWORD *)v40 + 11) = 0;
                  *((_WORD *)v40 + 24) = 256;
                  *((_WORD *)v40 + 41) = bswap32(v36) >> 16;
                  *((_WORD *)v40 + 42) = -1;
                  *(_OWORD *)(v40 + 50) = 0u;
                  *(_OWORD *)(v40 + 66) = 0u;
                  CFStringRef v41 = (const __CFString *)CMFormatDescriptionGetExtension(videoFormatDescription, @"FormatName");
                  if (!v41
                    || (v42 = v41, CFTypeID v43 = CFStringGetTypeID(), v43 != CFGetTypeID(v42))
                    || !CFStringGetPascalString(v42, (StringPtr)v63 + 50, 32, stringEncoding))
                  {
                    int v44 = v63;
                    if (*((_DWORD *)v63 + 1) == 1752589105)
                    {
                      *(_DWORD *)(v63 + 50) = 1447380996;
                      v44[54] = 67;
                    }
                    else
                    {
                      *((_WORD *)v63 + 25) = 9990;
                      unsigned int v45 = v62;
                      v44[52] = HIBYTE(v62);
                      v44[53] = BYTE2(v45);
                      v44[54] = BYTE1(v45);
                      v44[55] = v45;
                      v44[56] = 39;
                    }
                  }
                  CFNumberRef v46 = (const __CFNumber *)CMFormatDescriptionGetExtension(videoFormatDescription, @"TemporalQuality");
                  if (v46)
                  {
                    CFNumberRef v47 = v46;
                    CFTypeID v48 = CFNumberGetTypeID();
                    if (v48 == CFGetTypeID(v47))
                    {
                      LODWORD(dataPointerOut) = 0;
                      CFNumberGetValue(v47, kCFNumberSInt32Type, &dataPointerOut);
                      *((_DWORD *)v63 + 6) = bswap32(dataPointerOut);
                    }
                  }
                  CFNumberRef v49 = (const __CFNumber *)CMFormatDescriptionGetExtension(videoFormatDescription, @"SpatialQuality");
                  if (v49)
                  {
                    CFNumberRef v50 = v49;
                    CFTypeID v51 = CFNumberGetTypeID();
                    if (v51 == CFGetTypeID(v50))
                    {
                      LODWORD(dataPointerOut) = 0;
                      CFNumberGetValue(v50, kCFNumberSInt32Type, &dataPointerOut);
                      *((_DWORD *)v63 + 7) = bswap32(dataPointerOut);
                    }
                  }
                  CFNumberRef v52 = (const __CFNumber *)CMFormatDescriptionGetExtension(videoFormatDescription, @"Version");
                  if (v52)
                  {
                    CFNumberRef v53 = v52;
                    CFTypeID v54 = CFNumberGetTypeID();
                    if (v54 == CFGetTypeID(v53))
                    {
                      LOWORD(dataPointerOut) = 0;
                      CFNumberGetValue(v53, kCFNumberSInt16Type, &dataPointerOut);
                      *((_WORD *)v63 + 8) = bswap32((unsigned __int16)dataPointerOut) >> 16;
                    }
                  }
                  CFNumberRef v55 = (const __CFNumber *)CMFormatDescriptionGetExtension(videoFormatDescription, @"RevisionLevel");
                  if (v55)
                  {
                    CFNumberRef v56 = v55;
                    CFTypeID v57 = CFNumberGetTypeID();
                    if (v57 == CFGetTypeID(v56))
                    {
                      LOWORD(dataPointerOut) = 0;
                      CFNumberGetValue(v56, kCFNumberSInt16Type, &dataPointerOut);
                      *((_WORD *)v63 + 9) = bswap32((unsigned __int16)dataPointerOut) >> 16;
                    }
                  }
                  CFStringRef v58 = (const __CFString *)CMFormatDescriptionGetExtension(videoFormatDescription, @"Vendor");
                  if (v58)
                  {
                    CFStringRef v59 = v58;
                    CFTypeID v60 = CFStringGetTypeID();
                    if (v60 == CFGetTypeID(v59))
                    {
                      v68.CFIndex location = 0;
                      v68.unint64_t length = 4;
                      if (CFStringGetBytes(v59, v68, 0, 0, 0, (UInt8 *)v63 + 20, 4, 0) != 4) {
                        *((_DWORD *)v63 + 5) = 0;
                      }
                    }
                  }
                  goto LABEL_135;
                }
                CFTypeRef v38 = v63;
                if ((flavor & 2) == 0
                  || v62 != 1748121139
                  || (OSStatus DataPointer = figBridge_ConvertH263SampleDescriptionExtensionToCodecType(videoFormatDescription, &v62)) == 0)
                {
                  *(_DWORD *)CFTypeRef v38 = bswap32(v31);
                  *((_DWORD *)v38 + 1) = bswap32(v62);
                  *((void *)v38 + 2) = 0;
                  *((void *)v38 + 3) = 0;
                  *((void *)v38 + 1) = 0xFFFF000000000000;
                  *((_WORD *)v38 + 16) = bswap32(Dimensions.width) >> 16;
                  *((_WORD *)v38 + 17) = bswap32(Dimensions.height) >> 16;
                  *(void *)(v38 + 36) = 0x480000004800;
                  *((_DWORD *)v38 + 11) = 0;
                  *((_WORD *)v38 + 24) = 256;
                  *(_DWORD *)(v38 + 82) = -59392;
                  *(_OWORD *)(v38 + 50) = 0u;
                  *(_OWORD *)(v38 + 66) = 0u;
LABEL_135:
                  if (!v65)
                  {
LABEL_138:
                    OSStatus DataPointer = 0;
                    *CMBlockBufferRef blockBufferOut = theBuffer;
                    return DataPointer;
                  }
                  dataPointerOut = 0;
                  OSStatus v37 = CMBlockBufferGetDataPointer(theBuffer, 0x56uLL, 0, 0, &dataPointerOut);
                  if (!v37)
                  {
                    figBridge_WalkAndConvertVideoFormatDescriptionExtensions(videoFormatDescription, (char)flavor, &v64, (uint64_t)dataPointerOut);
                    goto LABEL_138;
                  }
                  goto LABEL_101;
                }
              }
            }
LABEL_102:
            if (theBuffer) {
              CFRelease(theBuffer);
            }
            return DataPointer;
          }
        }
        else if (v16 != 1667331683 && v16 != 1667524657)
        {
          int v18 = 1667790435;
          goto LABEL_48;
        }
      }
      else if (v16 <= 1902407031)
      {
        if (v16 != 1902403958 && v16 != 1902405681)
        {
          int v18 = 1902405733;
          goto LABEL_48;
        }
      }
      else if (v16 > 1902671458)
      {
        if (v16 != 1902998904)
        {
          unsigned __int16 v17 = 30307;
          goto LABEL_47;
        }
      }
      else if (v16 != 1902407032)
      {
        unsigned __int16 v17 = 25974;
LABEL_47:
        int v18 = v17 | 0x71680000;
LABEL_48:
        if (v16 != v18) {
          goto LABEL_50;
        }
      }
      int v16 = 1701733238;
      unsigned int v62 = 1701733238;
      goto LABEL_50;
    }
    uint64_t v12 = 4294954584;
  }
  else
  {
    uint64_t v12 = 4294954584;
  }
LABEL_10:

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

CFTypeID figBridge_WalkAndConvertVideoFormatDescriptionExtensions(const opaqueCMFormatDescription *a1, char a2, void *a3, uint64_t a4)
{
  int v6 = a1;
  size_t v181 = 0;
  CFPropertyListRef Extension = CMFormatDescriptionGetExtension(a1, @"SampleDescriptionExtensionAtoms");
  v180 = v6;
  if (!Extension) {
    goto LABEL_35;
  }
  unsigned int v8 = Extension;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v8)) {
    goto LABEL_35;
  }
  size_t Count = CFDictionaryGetCount((CFDictionaryRef)v8);
  if (!Count) {
    goto LABEL_35;
  }
  size_t v11 = Count;
  uint64_t v12 = (const void **)malloc_type_calloc(Count, 8uLL, 0x6004044C4A2DFuLL);
  CFTypeID v13 = (const void **)malloc_type_calloc(v11, 8uLL, 0x6004044C4A2DFuLL);
  CMTag v14 = v13;
  if (v12) {
    BOOL v15 = v13 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  if (!v15)
  {
    uint64_t v176 = a4;
    v173 = a3;
    CFDictionaryGetKeysAndValues((CFDictionaryRef)v8, v12, v13);
    size_t v16 = 0;
    for (uint64_t i = 0; i != v11; ++i)
    {
      CFStringRef v18 = (const __CFString *)v12[i];
      int v19 = v14[i];
      CFTypeID v20 = CFStringGetTypeID();
      if (v20 == CFGetTypeID(v18) && CFStringGetPascalString(v18, buffer, 5, 0) && buffer[0] == 4)
      {
        uint64_t v177 = bswap32(*(unsigned int *)&buffer[1]);
        if (v177)
        {
          CFTypeID v22 = CFGetTypeID(v19);
          if (CFDataGetTypeID() == v22)
          {
            size_t Length = CFDataGetLength((CFDataRef)v19);
            size_t v24 = v16;
            uint64_t v25 = (Length + 8);
            if (v176)
            {
              *(void *)(v176 + v24) = bswap64(v177 | (v25 << 32));
              BytePtr = CFDataGetBytePtr((CFDataRef)v19);
              memcpy((void *)(v176 + v24 + 8), BytePtr, Length);
            }
            size_t v16 = v24 + v25;
          }
          else if (CFArrayGetTypeID() == v22)
          {
            CFIndex v27 = CFArrayGetCount((CFArrayRef)v19);
            if (v27)
            {
              CFIndex v28 = v27;
              CFIndex v29 = 0;
              BOOL v174 = v19;
              CFIndex v175 = v27;
              do
              {
                CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)v19, v29);
                CFTypeID v31 = CFDataGetTypeID();
                if (v31 == CFGetTypeID(ValueAtIndex))
                {
                  size_t v32 = v11;
                  CFNumberRef v33 = v14;
                  CFNumberRef v34 = v12;
                  size_t v35 = CFDataGetLength(ValueAtIndex);
                  uint64_t v36 = (v35 + 8);
                  if (v176)
                  {
                    size_t v37 = v16;
                    CFTypeRef v38 = (void *)(v176 + v16);
                    *CFTypeRef v38 = bswap64(v177 | (v36 << 32));
                    unsigned int v39 = CFDataGetBytePtr(ValueAtIndex);
                    uint64_t v40 = v38 + 1;
                    size_t v16 = v37;
                    int v19 = v174;
                    memcpy(v40, v39, v35);
                  }
                  v16 += v36;
                  uint64_t v12 = v34;
                  CMTag v14 = v33;
                  size_t v11 = v32;
                  CFIndex v28 = v175;
                }
                ++v29;
              }
              while (v28 != v29);
            }
          }
        }
      }
      int v6 = v180;
    }
    size_t v181 = v16;
    a3 = v173;
    a4 = v176;
    if (!v12) {
      goto LABEL_33;
    }
    goto LABEL_32;
  }
  FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  if (v12) {
LABEL_32:
  }
    free(v12);
LABEL_33:
  if (v14) {
    free(v14);
  }
LABEL_35:
  size_t v41 = v181;
  if (a4) {
    size_t v42 = a4 + v181;
  }
  else {
    size_t v42 = 0;
  }
  if ((a2 & 2) == 0)
  {
    CFStringRef v43 = (const __CFString *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E4F24A90]);
    if (v43)
    {
      CFStringRef v44 = v43;
      CFTypeID v45 = CFGetTypeID(v43);
      if (v45 == CFStringGetTypeID()) {
        CFStringRef v46 = v44;
      }
      else {
        CFStringRef v46 = 0;
      }
    }
    else
    {
      CFStringRef v46 = 0;
    }
    CFNumberRef v47 = a3;
    CFStringRef v48 = (const __CFString *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E4F24BC8]);
    if (v48)
    {
      CFStringRef v49 = v48;
      CFTypeID v50 = CFGetTypeID(v48);
      if (v50 == CFStringGetTypeID()) {
        CFStringRef v51 = v49;
      }
      else {
        CFStringRef v51 = 0;
      }
    }
    else
    {
      CFStringRef v51 = 0;
    }
    CFStringRef v52 = (const __CFString *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E4F24C18]);
    if (v52)
    {
      CFStringRef v53 = v52;
      CFTypeID v54 = CFGetTypeID(v52);
      if (v54 == CFStringGetTypeID()) {
        CFStringRef v55 = v53;
      }
      else {
        CFStringRef v55 = 0;
      }
    }
    else
    {
      CFStringRef v55 = 0;
    }
    CFPropertyListRef v56 = CMFormatDescriptionGetExtension(v6, @"FullRangeVideo");
    signed int MediaSubType = CMFormatDescriptionGetMediaSubType(v6);
    unsigned int IntegerCodePointForString = CVColorPrimariesGetIntegerCodePointForString(v46);
    unsigned int v59 = CVTransferFunctionGetIntegerCodePointForString(v51);
    unsigned int v60 = CVYCbCrMatrixGetIntegerCodePointForString(v55);
    if (MediaSubType <= 1836415072)
    {
      if (MediaSubType > 1751479856)
      {
        if (MediaSubType == 1751479857) {
          goto LABEL_67;
        }
        int v61 = 1752589105;
      }
      else
      {
        if (MediaSubType == 1667790435) {
          goto LABEL_67;
        }
        int v61 = 1718908520;
      }
    }
    else
    {
      if (MediaSubType > 1902667125)
      {
        if (MediaSubType != 1902667126 && MediaSubType != 1902998904)
        {
          int v61 = 1902671459;
          goto LABEL_66;
        }
LABEL_67:
        if ((unsigned __int16)v59 == 18)
        {
          if (a2)
          {
            CFDictionaryRef v62 = (const __CFDictionary *)CMFormatDescriptionGetExtension(v6, @"SampleDescriptionExtensionAtoms");
            if (v62)
            {
              CFDictionaryRef v63 = v62;
              CFPropertyListRef v178 = v56;
              CFTypeID v64 = CFGetTypeID(v62);
              BOOL v15 = v64 == CFDictionaryGetTypeID();
              CFPropertyListRef v56 = v178;
              if (v15)
              {
                CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v63, @"hvcC");
                if (Value)
                {
                  CFTypeID v66 = CFArrayGetTypeID();
                  if (v66 == CFGetTypeID(Value)) {
                    CFArrayRef Value = (const __CFArray *)CFArrayGetValueAtIndex(Value, 0);
                  }
                  CFPropertyListRef v56 = v178;
                }
                buffer[0] = 0;
                if (!FigHEVCBridge_GetATCSEI(Value, buffer)) {
                  goto LABEL_70;
                }
              }
            }
          }
          else if (CMFormatDescriptionGetExtension(v6, @"AlternativeTransferCharacteristics"))
          {
LABEL_70:
            unsigned int v59 = 14;
          }
        }
LABEL_79:
        if ((unsigned __int16)IntegerCodePointForString == 2
          && (unsigned __int16)v59 == 2
          && (unsigned __int16)v60 == 2)
        {
          CFDataRef v67 = (const __CFData *)CMFormatDescriptionGetExtension(v6, @"CVImageBufferICCProfile");
          if (v67)
          {
            CFDataRef v68 = v67;
            CFTypeID v69 = CFDataGetTypeID();
            a3 = v47;
            if (v69 == CFGetTypeID(v68))
            {
              size_t v70 = CFDataGetLength(v68);
              unsigned int v71 = v70 + 12;
              if (v42)
              {
                *(void *)size_t v42 = bswap32(v71) | 0x726C6F6300000000;
                *(_DWORD *)(v42 + 8) = 1718579824;
                int v72 = CFDataGetBytePtr(v68);
                memcpy((void *)(v42 + 12), v72, v70);
              }
            }
            else
            {
              unsigned int v71 = 0;
            }
            goto LABEL_94;
          }
          unsigned int v71 = 0;
        }
        else
        {
          unsigned int v71 = a2 & 1 | 0x12;
          if (v42)
          {
            *(void *)size_t v42 = (v71 << 24) | 0x726C6F6300000000;
            int v73 = (a2 & 1) != 0 ? 2020369262 : 1668047726;
            *(_DWORD *)(v42 + 8) = v73;
            *(_WORD *)(v42 + 12) = bswap32(IntegerCodePointForString) >> 16;
            *(_WORD *)(v42 + 14) = bswap32(v59) >> 16;
            *(_WORD *)(v42 + 16) = bswap32(v60) >> 16;
            if (a2) {
              *(unsigned char *)(v42 + 18) = (*MEMORY[0x1E4F1CFD0] == (void)v56) << 7;
            }
          }
        }
        a3 = v47;
LABEL_94:
        size_t v181 = v71;
        if (v42) {
          v42 += v71;
        }
        else {
          size_t v42 = 0;
        }
        v41 += v71;
        int v6 = v180;
        goto LABEL_98;
      }
      if (MediaSubType == 1836415073) {
        goto LABEL_67;
      }
      int v61 = 1869117027;
    }
LABEL_66:
    if (MediaSubType != v61) {
      goto LABEL_79;
    }
    goto LABEL_67;
  }
LABEL_98:
  *(void *)unsigned __int8 buffer = 0;
  CFPropertyListRef v74 = CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E4F24B28]);
  if (v74
    && (size_t v75 = v74, v76 = CFNumberGetTypeID(), v76 == CFGetTypeID(v75))
    && CFNumberGetValue((CFNumberRef)v75, kCFNumberDoubleType, buffer)
    && (unsigned int v77 = vcvtd_n_s64_f64(*(double *)buffer, 0x10uLL)) != 0)
  {
    if (v42)
    {
      *(void *)size_t v42 = 0x616D61670C000000;
      *(_DWORD *)(v42 + 8) = bswap32(v77);
    }
    size_t v78 = 12;
  }
  else
  {
    size_t v78 = 0;
  }
  size_t v181 = v78;
  if (v42) {
    size_t v79 = v42 + v78;
  }
  else {
    size_t v79 = 0;
  }
  buffer[0] = 0;
  CFNumberRef v80 = (const __CFNumber *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E4F24AF8]);
  CFPropertyListRef v81 = CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E4F24B00]);
  if (v80)
  {
    CFTypeID v82 = CFNumberGetTypeID();
    if (v82 == CFGetTypeID(v80)) {
      CFNumberGetValue(v80, kCFNumberSInt8Type, buffer);
    }
  }
  if (v81 && (CFTypeID v83 = CFStringGetTypeID(), v83 == CFGetTypeID(v81)))
  {
    if (CFEqual(v81, (CFTypeRef)*MEMORY[0x1E4F24B20]))
    {
      char v84 = 1;
    }
    else if (CFEqual(v81, (CFTypeRef)*MEMORY[0x1E4F24B18]))
    {
      char v84 = 6;
    }
    else if (CFEqual(v81, (CFTypeRef)*MEMORY[0x1E4F24B08]))
    {
      char v84 = 9;
    }
    else if (CFEqual(v81, (CFTypeRef)*MEMORY[0x1E4F24B10]))
    {
      char v84 = 14;
    }
    else
    {
      char v84 = 0;
    }
  }
  else
  {
    char v84 = 0;
  }
  unsigned __int8 v85 = buffer[0];
  if (buffer[0])
  {
    char v86 = a2;
    if (v79)
    {
      *(void *)size_t v79 = 0x6C6569660A000000;
      *(unsigned char *)(v79 + 8) = v85;
      *(unsigned char *)(v79 + 9) = v84;
    }
    size_t v87 = 10;
  }
  else
  {
    size_t v87 = 0;
    char v86 = a2;
  }
  size_t v181 = v87;
  if (v79) {
    size_t v88 = v79 + v87;
  }
  else {
    size_t v88 = 0;
  }
  size_t v89 = v78 + v41 + v87;
  *(_DWORD *)unsigned __int8 buffer = 0;
  CFPropertyListRef v90 = CMFormatDescriptionGetExtension(v6, @"CVBytesPerRow");
  if (v90
    && (uint64_t v91 = v90, v92 = CFNumberGetTypeID(), v92 == CFGetTypeID(v91))
    && CFNumberGetValue((CFNumberRef)v91, kCFNumberSInt32Type, buffer))
  {
    if (v88)
    {
      *(void *)size_t v88 = 0x62776F720C000000;
      *(_DWORD *)(v88 + 8) = bswap32(*(unsigned int *)buffer);
    }
    size_t v93 = 12;
  }
  else
  {
    size_t v93 = 0;
  }
  size_t v181 = v93;
  if (v88) {
    size_t v94 = v88 + v93;
  }
  else {
    size_t v94 = 0;
  }
  size_t v95 = v89 + v93;
  buffer[0] = 0;
  valuePtr[4] = 0;
  CFPropertyListRef v96 = CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E4F24A10]);
  CFPropertyListRef v97 = CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E4F24A08]);
  if (v96
    && (v98 = v97, CFTypeID v99 = CFStringGetTypeID(), v99 == CFGetTypeID(v96))
    && figBridge_ConvertChromaLocationStringToUInt8(v96, (char *)buffer))
  {
    if (!v98
      || (CFTypeID v100 = CFStringGetTypeID(), v100 != CFGetTypeID(v98))
      || !figBridge_ConvertChromaLocationStringToUInt8(v98, &valuePtr[4]))
    {
      valuePtr[4] = buffer[0];
    }
    if (v94)
    {
      *(void *)size_t v94 = 0x6D7268630A000000;
      *(unsigned char *)(v94 + 8) = buffer[0];
      *(unsigned char *)(v94 + 9) = valuePtr[4];
    }
    size_t v101 = 10;
  }
  else
  {
    size_t v101 = 0;
  }
  size_t v181 = v101;
  if (v94) {
    int v102 = (void *)(v94 + v101);
  }
  else {
    int v102 = 0;
  }
  size_t v103 = v95 + v101;
  *(_DWORD *)unsigned __int8 buffer = 0;
  *(_DWORD *)&valuePtr[4] = 0;
  CFDictionaryRef v104 = (const __CFDictionary *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E4F24B98]);
  if (!v104) {
    goto LABEL_161;
  }
  CFDictionaryRef v105 = v104;
  CFTypeID v106 = CFGetTypeID(v104);
  if (v106 != CFDictionaryGetTypeID()) {
    goto LABEL_161;
  }
  CFNumberRef v107 = (const __CFNumber *)CFDictionaryGetValue(v105, (const void *)*MEMORY[0x1E4F24B90]);
  CFNumberRef v108 = (const __CFNumber *)CFDictionaryGetValue(v105, (const void *)*MEMORY[0x1E4F24BA0]);
  if (v107)
  {
    CFTypeID v109 = CFNumberGetTypeID();
    if (v109 == CFGetTypeID(v107)) {
      CFNumberGetValue(v107, kCFNumberSInt32Type, buffer);
    }
  }
  if (v108 && (CFTypeID v110 = CFNumberGetTypeID(), v110 == CFGetTypeID(v108)))
  {
    CFNumberGetValue(v108, kCFNumberSInt32Type, &valuePtr[4]);
    size_t v111 = 0;
    if (*(int *)buffer >= 1 && *(int *)&valuePtr[4] >= 1)
    {
      if (v102)
      {
        unint64_t v112 = bswap64(*(unsigned int *)&valuePtr[4] | ((unint64_t)*(unsigned int *)buffer << 32));
        *int v102 = 0x7073617010000000;
        v102[1] = v112;
      }
      size_t v111 = 2;
    }
  }
  else
  {
LABEL_161:
    size_t v111 = 0;
  }
  size_t v181 = v111 * 8;
  if (v102) {
    long long v113 = &v102[v111];
  }
  else {
    long long v113 = 0;
  }
  VEXUBridge_ConvertVideoExtendedUsageExtensionToAtom(v6, &v181, v113);
  if (v113) {
    size_t v114 = (size_t)v113 + v181;
  }
  else {
    size_t v114 = 0;
  }
  size_t v115 = v103 + v111 * 8 + v181;
  *(_DWORD *)unsigned __int8 buffer = 0;
  *(void *)int valuePtr = 0;
  unsigned int v184 = 0;
  uint64_t v182 = 0;
  uint64_t v183 = 0;
  CFDictionaryRef v116 = (const __CFDictionary *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E4F24A78]);
  if (v116 && (CFDictionaryRef v117 = v116, v118 = CFGetTypeID(v116), v118 == CFDictionaryGetTypeID()))
  {
    figBridge_ReadRationalOrIntegerFromDictionary(v117, @"WidthAsRational", (const void *)*MEMORY[0x1E4F24A88], buffer, &valuePtr[4]);
    figBridge_ReadRationalOrIntegerFromDictionary(v117, @"HeightAsRational", (const void *)*MEMORY[0x1E4F24A68], valuePtr, &v184);
    figBridge_ReadRationalOrIntegerFromDictionary(v117, @"HorizontalOffsetAsRational", (const void *)*MEMORY[0x1E4F24A70], (char *)&v183 + 4, &v183);
    figBridge_ReadRationalOrIntegerFromDictionary(v117, @"VerticalOffsetAsRational", (const void *)*MEMORY[0x1E4F24A80], (char *)&v182 + 4, &v182);
    size_t v119 = 0;
    unsigned int v120 = *(_DWORD *)buffer;
    if (*(_DWORD *)buffer)
    {
      unsigned int v121 = *(_DWORD *)valuePtr;
      if (*(_DWORD *)valuePtr)
      {
        unsigned int v122 = *(_DWORD *)&valuePtr[4];
        if (*(_DWORD *)&valuePtr[4])
        {
          unsigned int v123 = v184;
          if (v184)
          {
            unsigned int v124 = v183;
            if (v183)
            {
              unsigned int v125 = v182;
              if (v182)
              {
                if (v114)
                {
                  *(void *)size_t v114 = 0x70616C6328000000;
                  unsigned int v126 = bswap32(v120);
                  unsigned int v127 = bswap32(v122);
                  unsigned int v128 = bswap32(v123);
                  unsigned int v129 = bswap32(HIDWORD(v183));
                  unsigned int v130 = bswap32(HIDWORD(v182));
                  *(_DWORD *)(v114 + 8) = v126;
                  *(_DWORD *)(v114 + 12) = v127;
                  *(_DWORD *)(v114 + 16) = bswap32(v121);
                  *(_DWORD *)(v114 + 20) = v128;
                  *(_DWORD *)(v114 + 24) = v129;
                  *(_DWORD *)(v114 + 28) = bswap32(v124);
                  *(_DWORD *)(v114 + 32) = v130;
                  *(_DWORD *)(v114 + 36) = bswap32(v125);
                }
                size_t v119 = 40;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    size_t v119 = 0;
  }
  size_t v181 = v119;
  if (v114) {
    size_t v131 = v114 + v119;
  }
  else {
    size_t v131 = 0;
  }
  size_t v132 = v115 + v119;
  if ((v86 & 2) == 0)
  {
    figBridge_ConvertCFDataExtensionToAtom(v6, &v181, (_DWORD *)v131, @"MasteringDisplayColorVolume", 0x6D646376u);
    size_t v133 = v181;
    if (v131) {
      long long v134 = (_DWORD *)(v131 + v181);
    }
    else {
      long long v134 = 0;
    }
    figBridge_ConvertCFDataExtensionToAtom(v6, &v181, v134, @"ContentLightLevelInfo", 0x636C6C69u);
    if (v134) {
      long long v135 = (_DWORD *)((char *)v134 + v181);
    }
    else {
      long long v135 = 0;
    }
    size_t v136 = v133 + v181;
    figBridge_ConvertCFDataExtensionToAtom(v6, &v181, v135, @"AmbientViewingEnvironment", 0x616D7665u);
    if (v135) {
      long long v137 = (_DWORD *)((char *)v135 + v181);
    }
    else {
      long long v137 = 0;
    }
    size_t v138 = v136 + v181;
    figBridge_ConvertCFDataExtensionToAtom(v6, &v181, v137, @"ContentColorVolume", 0x63636C76u);
    if (v137) {
      size_t v131 = (size_t)v137 + v181;
    }
    else {
      size_t v131 = 0;
    }
    v132 += v138 + v181;
  }
  if ((v86 & 1) == 0)
  {
    signed int v139 = CMFormatDescriptionGetMediaSubType(v6);
    CFStringRef v140 = (const __CFString *)CMFormatDescriptionGetExtension(v6, @"AlternativeTransferCharacteristics");
    if (!v140 || (v141 = v140, CFTypeID v142 = CFGetTypeID(v140), v142 != CFStringGetTypeID()))
    {
      size_t v143 = 0;
      goto LABEL_222;
    }
    size_t v143 = 0;
    if (v139 <= 1836415072)
    {
      if (v139 > 1751479856)
      {
        if (v139 != 1751479857)
        {
          int v144 = 1752589105;
          goto LABEL_218;
        }
      }
      else if (v139 != 1667790435)
      {
        int v144 = 1718908520;
        goto LABEL_218;
      }
    }
    else
    {
      if (v139 > 1902667125)
      {
        if (v139 == 1902667126 || v139 == 1902998904) {
          goto LABEL_219;
        }
        int v144 = 1902671459;
LABEL_218:
        if (v139 == v144) {
          goto LABEL_219;
        }
LABEL_222:
        size_t v181 = v143;
        if (v131) {
          v131 += v143;
        }
        else {
          size_t v131 = 0;
        }
        v132 += v143;
        goto LABEL_226;
      }
      if (v139 != 1836415073)
      {
        int v144 = 1869117027;
        goto LABEL_218;
      }
    }
LABEL_219:
    char v145 = CVTransferFunctionGetIntegerCodePointForString(v141);
    if (v131)
    {
      *(void *)size_t v131 = 0x6863746109000000;
      *(unsigned char *)(v131 + 8) = v145;
    }
    size_t v143 = 9;
    goto LABEL_222;
  }
LABEL_226:
  CFPropertyListRef v146 = CMFormatDescriptionGetExtension(v6, @"AlphaChannelMode");
  if (FigCFEqual(v146, @"StraightAlpha"))
  {
    int v147 = 0x10000;
    if (!v131)
    {
LABEL_229:
      size_t v148 = 12;
      goto LABEL_230;
    }
LABEL_228:
    *(void *)size_t v131 = 0x6F6D6C610C000000;
    *(_DWORD *)(v131 + 8) = v147;
    goto LABEL_229;
  }
  if (FigCFEqual(v146, @"PremultipliedAlpha"))
  {
    int v147 = 33619968;
    if (!v131) {
      goto LABEL_229;
    }
    goto LABEL_228;
  }
  size_t v148 = 0;
LABEL_230:
  size_t v181 = v148;
  if (v131) {
    BOOL v149 = (uint64_t *)(v131 + v148);
  }
  else {
    BOOL v149 = 0;
  }
  size_t v150 = v148 + v132;
  CFStringRef v151 = (const __CFString *)CMFormatDescriptionGetExtension(v6, @"AuxiliaryTypeInfo");
  if (!v151 || (CFStringRef v152 = v151, v153 = CFStringGetTypeID(), v153 != CFGetTypeID(v152)))
  {
    int v155 = 0;
LABEL_242:
    size_t v156 = 0;
    goto LABEL_243;
  }
  CFIndex v154 = CFStringGetLength(v152);
  *(void *)unsigned __int8 buffer = 0;
  v187.CFIndex location = 0;
  v187.unint64_t length = v154;
  int v155 = 0;
  if (CFStringGetBytes(v152, v187, 0x8000100u, 0, 0, 0, 0, (CFIndex *)buffer) != v154)
  {
    size_t v156 = 0;
    goto LABEL_243;
  }
  size_t v156 = 0;
  if (*(uint64_t *)buffer >= 1)
  {
    int v155 = malloc_type_malloc(*(void *)buffer + 1, 0x8A7507E9uLL);
    *(void *)&valuePtr[4] = 0;
    v188.CFIndex location = 0;
    v188.unint64_t length = v154;
    size_t v156 = 0;
    if (CFStringGetBytes(v152, v188, 0x8000100u, 0, 0, v155, *(CFIndex *)buffer, (CFIndex *)&valuePtr[4]) == v154)
    {
      if (*(void *)buffer == *(void *)&valuePtr[4])
      {
        v155[*(void *)buffer] = 0;
        int v157 = *(_DWORD *)buffer;
        size_t v158 = ++*(void *)buffer;
        size_t v156 = (v157 + 9);
        if (v149)
        {
          *BOOL v149 = bswap32(v156) | 0x6978756100000000;
          memcpy(v149 + 1, v155, v158);
        }
        goto LABEL_243;
      }
      goto LABEL_242;
    }
  }
LABEL_243:
  size_t v181 = v156;
  free(v155);
  if (v149) {
    size_t v159 = (size_t)v149 + v181;
  }
  else {
    size_t v159 = 0;
  }
  size_t v160 = v150 + v181;
  *(_DWORD *)unsigned __int8 buffer = 0;
  CFTypeID result = (CFTypeID)CMFormatDescriptionGetExtension(v6, @"HorizontalFieldOfView");
  if (result
    && (v162 = (const void *)result, v163 = CFNumberGetTypeID(), CFTypeID result = CFGetTypeID(v162), v163 == result)
    && (CFTypeID result = CFNumberGetValue((CFNumberRef)v162, kCFNumberSInt32Type, buffer), result))
  {
    if (v159)
    {
      *(void *)size_t v159 = 0x766F66680C000000;
      *(_DWORD *)(v159 + 8) = bswap32(*(unsigned int *)buffer);
    }
    size_t v164 = 12;
  }
  else
  {
    size_t v164 = 0;
  }
  size_t v181 = v164;
  if (v159) {
    size_t v165 = v159 + v164;
  }
  else {
    size_t v165 = 0;
  }
  size_t v166 = v160 + v164;
  if (v86)
  {
LABEL_271:
    if (!a3) {
      return result;
    }
    goto LABEL_272;
  }
  CFTypeID result = (CFTypeID)CMFormatDescriptionGetExtension(v6, @"LogTransferFunction");
  if (!result) {
    goto LABEL_263;
  }
  CFStringRef v167 = (const __CFString *)result;
  CFTypeID v168 = CFGetTypeID((CFTypeRef)result);
  CFTypeID result = CFStringGetTypeID();
  if (v168 != result) {
    goto LABEL_263;
  }
  CFIndex v169 = CFStringGetLength(v167);
  *(void *)unsigned __int8 buffer = 0;
  v189.CFIndex location = 0;
  v189.unint64_t length = v169;
  CFTypeID result = CFStringGetBytes(v167, v189, 0x600u, 0, 0, 0, 0, (CFIndex *)buffer);
  uint64_t v170 = 0;
  if (result != v169) {
    goto LABEL_264;
  }
  double v171 = *(double *)buffer;
  if ((unint64_t)(*(void *)buffer - 1) <= 0xFFFFFFF6)
  {
    uint64_t v170 = (*(_DWORD *)buffer + 8);
    if (v165)
    {
      *(void *)&valuePtr[4] = 0;
      *(void *)size_t v165 = bswap32(v170) | 0x73676F6C00000000;
      v190.CFIndex location = 0;
      v190.unint64_t length = v169;
      CFTypeID result = CFStringGetBytes(v167, v190, 0x600u, 0, 0, (UInt8 *)(v165 + 8), *(CFIndex *)&v171, (CFIndex *)&valuePtr[4]);
    }
  }
  else
  {
LABEL_263:
    uint64_t v170 = 0;
  }
LABEL_264:
  if (v165) {
    v172 = (_DWORD *)(v165 + v170);
  }
  else {
    v172 = 0;
  }
  if (v170 + v166)
  {
    if (v172) {
      _DWORD *v172 = 0;
    }
    v166 += v170 + 4;
    goto LABEL_271;
  }
  size_t v166 = 0;
  if (a3) {
LABEL_272:
  }
    *a3 = v166;
  return result;
}

uint64_t figBridge_ConvertH263SampleDescriptionExtensionToCodecType(const opaqueCMFormatDescription *a1, _DWORD *a2)
{
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
  if (Extensions && figBridge_Is3GP263ExtensionPresent(Extensions))
  {
    *a2 = 1932670515;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
  }
}

CFTypeID figBridge_ConvertMPEG2ProfileExtensionToCodecType(const opaqueCMFormatDescription *a1, void *a2)
{
  CFTypeID result = (CFTypeID)CMFormatDescriptionGetExtension(a1, @"ConformsToMPEG2VideoProfile");
  if (result)
  {
    CFArrayRef v4 = (const void *)result;
    CFTypeID TypeID = CFNumberGetTypeID();
    CFTypeID result = CFGetTypeID(v4);
    if (TypeID == result)
    {
      return CFNumberGetValue((CFNumberRef)v4, kCFNumberSInt32Type, a2);
    }
  }
  return result;
}

OSStatus CMSwapBigEndianImageDescriptionToHost(uint8_t *imageDescriptionData, size_t imageDescriptionSize)
{
  return figBridge_FlipImageDescriptionData((uint64_t)imageDescriptionData, imageDescriptionSize, 0);
}

uint64_t figBridge_FlipImageDescriptionData(uint64_t a1, unint64_t a2, int a3)
{
  if (a1)
  {
    int v3 = *(_DWORD *)a1;
    unsigned int v4 = bswap32(*(_DWORD *)a1);
    if (!a3) {
      int v3 = v4;
    }
    if (v3 >= 0x56 && v3 <= a2)
    {
      int v6 = *(unsigned __int16 *)(a1 + 84);
      if (*(_WORD *)(a1 + 84))
      {
        uint64_t v7 = 0;
LABEL_16:
        long long v28 = *(_OWORD *)(a1 + 50);
        long long v29 = *(_OWORD *)(a1 + 66);
        unsigned int v10 = bswap32(*(_DWORD *)(a1 + 8));
        int8x8_t v11 = vrev16_s8(*(int8x8_t *)(a1 + 12));
        int8x8_t v12 = vrev32_s8(*(int8x8_t *)(a1 + 20));
        unsigned int v13 = bswap32(*(_DWORD *)(a1 + 28));
        unsigned int v14 = bswap32(*(unsigned __int16 *)(a1 + 32)) >> 16;
        unsigned int v15 = bswap32(*(unsigned __int16 *)(a1 + 34)) >> 16;
        int8x8_t v16 = vrev32_s8(*(int8x8_t *)(a1 + 36));
        unsigned int v17 = bswap32(*(_DWORD *)(a1 + 44));
        unsigned int v18 = bswap32(*(unsigned __int16 *)(a1 + 48)) >> 16;
        unsigned int v19 = bswap32(*(unsigned __int16 *)(a1 + 82)) >> 16;
        unsigned int v20 = bswap32(*(unsigned __int16 *)(a1 + 84)) >> 16;
        *(int8x8_t *)a1 = vrev32_s8(*(int8x8_t *)a1);
        *(_DWORD *)(a1 + 8) = v10;
        *(int8x8_t *)(a1 + 12) = v11;
        *(int8x8_t *)(a1 + 20) = v12;
        *(_DWORD *)(a1 + 28) = v13;
        *(_WORD *)(a1 + 32) = v14;
        *(_WORD *)(a1 + 34) = v15;
        *(int8x8_t *)(a1 + 36) = v16;
        *(_DWORD *)(a1 + 44) = v17;
        *(_WORD *)(a1 + 48) = v18;
        *(_OWORD *)(a1 + 66) = v29;
        *(_OWORD *)(a1 + 50) = v28;
        *(_WORD *)(a1 + 82) = v19;
        *(_WORD *)(a1 + 84) = v20;
        if (!v6)
        {
          unsigned int v21 = *(unsigned __int16 *)(v7 + 6);
          unsigned int v22 = bswap32(v21) >> 16;
          if (!a3) {
            LOWORD(v21) = v22;
          }
          unsigned int v21 = (__int16)v21;
          *(void *)uint64_t v7 = bswap32(*(void *)v7) | ((unint64_t)(bswap32(HIDWORD(*(void *)v7)) >> 16) << 32) | ((unint64_t)__rev16(HIWORD(*(void *)v7)) << 48);
          if ((__int16)v21 >= 1)
          {
            CFDataRef v23 = (unint64_t *)(a1 + 94);
            do
            {
              unsigned int v24 = bswap32(*v23);
              *CFDataRef v23 = HIWORD(v24) | ((unint64_t)(unsigned __int16)v24 << 16) | ((unint64_t)(bswap32(HIDWORD(*v23)) >> 16) << 32) | ((unint64_t)__rev16(HIWORD(*v23)) << 48);
              ++v23;
              int v25 = (__int16)v21--;
            }
            while (v25 > 1);
          }
        }
        return 0;
      }
      if (v3 >= 0x66)
      {
        unsigned int v8 = *(unsigned __int16 *)(a1 + 92);
        unsigned int v9 = bswap32(v8) >> 16;
        if (!a3) {
          LOWORD(v8) = v9;
        }
        if ((v8 & 0x8000) == 0 && 8 * (unsigned __int16)v8 + 102 <= v3)
        {
          uint64_t v7 = a1 + 86;
          goto LABEL_16;
        }
      }
    }
    uint64_t v27 = 4294954582;
  }
  else
  {
    uint64_t v27 = 4294954584;
  }

  return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
}

OSStatus CMSwapHostEndianImageDescriptionToBig(uint8_t *imageDescriptionData, size_t imageDescriptionSize)
{
  return figBridge_FlipImageDescriptionData((uint64_t)imageDescriptionData, imageDescriptionSize, 1);
}

uint64_t figBridge_WrapPayloadAsCFData(CFAllocatorRef allocator, uint64_t a2, uint64_t a3, void *a4, UInt8 *bytes, CFIndex length, CFTypeRef cf)
{
  if (a2) {
    *(void *)(a2 + 8 * *a4) = CFRetain(cf);
  }
  if (a3 && (CFDataRef v12 = CFDataCreate(allocator, bytes, length), (*(void *)(a3 + 8 * *a4) = v12) == 0)) {
    uint64_t result = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
  else {
    uint64_t result = 0;
  }
  ++*a4;
  return result;
}

CFArrayRef figBridge_CFArrayCreateWithTwoIntegers(const __CFAllocator *a1, int a2, int a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v10 = a3;
  int valuePtr = a2;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  values = v5;
  CFNumberRef v6 = CFNumberCreate(v4, kCFNumberIntType, &v10);
  CFTypeRef cf = v6;
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    CFArrayRef v8 = CFArrayCreate(a1, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
    uint64_t v5 = values;
    if (!values) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  CFArrayRef v8 = 0;
  if (v5) {
LABEL_9:
  }
    CFRelease(v5);
LABEL_10:
  if (cf) {
    CFRelease(cf);
  }
  return v8;
}

uint64_t figBridge_GetConciseProtectedCodecTypeFromSinfData(uint64_t a1, uint64_t a2)
{
  int OriginalFormatFromSinf = FigBridgeGetOriginalFormatFromSinf(a1, a2);
  int CommonEncryptionScheme = FigBridgeGetCommonEncryptionScheme(a1, a2);
  uint64_t v6 = 0;
  while (OriginalFormatFromSinf != lookUpConciseCodecType[v6]
       || CommonEncryptionScheme != lookUpConciseCodecType[v6 + 1])
  {
    v6 += 3;
    if (v6 == 63) {
      return 0;
    }
  }
  return lookUpConciseCodecType[v6 + 2];
}

unint64_t figBridge_ConvertCFDataExtensionToAtom(const opaqueCMFormatDescription *a1, void *a2, _DWORD *a3, CFStringRef extensionKey, unsigned int a5)
{
  unint64_t result = (unint64_t)CMFormatDescriptionGetExtension(a1, extensionKey);
  if (result
    && (v9 = (const __CFData *)result, TypeID = CFDataGetTypeID(), unint64_t result = CFGetTypeID(v9), TypeID == result)
    && (unint64_t result = CFDataGetLength(v9), result <= 0xFFFFFFF7))
  {
    size_t v11 = result;
    uint64_t v12 = (result + 8);
    if (a3)
    {
      *a3 = bswap32(v12);
      a3[1] = bswap32(a5);
      BytePtr = CFDataGetBytePtr(v9);
      unint64_t result = (unint64_t)memcpy(a3 + 2, BytePtr, v11);
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  *a2 = v12;
  return result;
}

uint64_t figBridge_ConvertChromaLocationStringToUInt8(const void *a1, char *a2)
{
  if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24A38]))
  {
    char v4 = 0;
  }
  else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24A28]))
  {
    char v4 = 1;
  }
  else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24A48]))
  {
    char v4 = 2;
  }
  else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24A40]))
  {
    char v4 = 3;
  }
  else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24A20]))
  {
    char v4 = 4;
  }
  else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24A18]))
  {
    char v4 = 5;
  }
  else
  {
    uint64_t result = CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24A30]);
    if (!result) {
      return result;
    }
    char v4 = -1;
  }
  *a2 = v4;
  return 1;
}

CFTypeID figBridge_ReadRationalOrIntegerFromDictionary(const __CFDictionary *a1, const void *a2, const void *a3, void *a4, _DWORD *a5)
{
  CFArrayRef Value = CFDictionaryGetValue(a1, a2);
  if (Value
    && (v10 = Value, CFTypeID v11 = CFArrayGetTypeID(), v11 == CFGetTypeID(v10))
    && CFArrayGetCount((CFArrayRef)v10) == 2
    && (CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v10, 0),
        CFNumberRef v13 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v10, 1),
        ValueAtIndex)
    && (v14 = v13, CFTypeID v15 = CFNumberGetTypeID(), v15 == CFGetTypeID(ValueAtIndex))
    && v14
    && (CFTypeID v16 = CFNumberGetTypeID(), v16 == CFGetTypeID(v14)))
  {
    CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, a4);
    return CFNumberGetValue(v14, kCFNumberSInt32Type, a5);
  }
  else
  {
    CFTypeID result = (CFTypeID)CFDictionaryGetValue(a1, a3);
    if (result)
    {
      unsigned int v18 = (const void *)result;
      CFTypeID TypeID = CFNumberGetTypeID();
      CFTypeID result = CFGetTypeID(v18);
      if (TypeID == result)
      {
        CFTypeID result = CFNumberGetValue((CFNumberRef)v18, kCFNumberSInt32Type, a4);
        *a5 = 1;
      }
    }
  }
  return result;
}

uint64_t FigMP4Bridge_GetESDSObjectTypeAndCopyDecoderSpecificInfo(unint64_t a1, unint64_t a2, char *a3, unsigned __int16 *a4, __CFDictionary **a5)
{
  uint64_t result = 4294954582;
  if (!a1) {
    return result;
  }
  unint64_t v7 = a2;
  if (!a2) {
    return result;
  }
  unint64_t v72 = a1;
  uint64_t v73 = a2;
  uint64_t v76 = 0;
  unint64_t v74 = a1;
  long long v75 = a1 + a2;
  uint64_t result = CopyNextWord((uint64_t)&v72);
  if (result) {
    return result;
  }
  unint64_t v11 = v74;
  uint64_t v12 = v75;
  if (v74 >= (unint64_t)v75)
  {
    unsigned __int8 Bits = 0;
LABEL_17:
    int v16 = Bits;
  }
  else
  {
    unsigned __int8 Bits = 0;
    while (1)
    {
      unint64_t v14 = v12 - v11;
      BOOL v15 = HIDWORD(v75) || v14 > 4;
      int v16 = Bits;
      if (!v15 || Bits == 3) {
        break;
      }
      unsigned __int8 Bits = GetBits((uint64_t)&v72, 8u);
      unint64_t v11 = v74;
      uint64_t v12 = v75;
      if (v74 >= (unint64_t)v75) {
        goto LABEL_17;
      }
    }
  }
  if (v16 != 3) {
    goto LABEL_54;
  }
  int64_t v71 = 0;
  if (!GetBERInteger((uint64_t)&v72, (unint64_t *)&v71)
    || v71 < 1
    || v74 >= (unint64_t)v75
    || (void)v75 - (v76 + v74) + ((unint64_t)HIDWORD(v75) >> 3) < v71
    || (unint64_t)v75 - v74 <= 4 && !HIDWORD(v75))
  {
    goto LABEL_54;
  }
  SkipBits((uint64_t)&v72, 0x10u);
  char v18 = GetBits((uint64_t)&v72, 8u);
  char v19 = v18;
  if (v18 < 0)
  {
    SkipBits((uint64_t)&v72, 0x10u);
    if ((v19 & 0x40) == 0)
    {
LABEL_27:
      if ((v19 & 0x20) == 0) {
        goto LABEL_29;
      }
      goto LABEL_28;
    }
  }
  else if ((v18 & 0x40) == 0)
  {
    goto LABEL_27;
  }
  unsigned __int8 v24 = GetBits((uint64_t)&v72, 8u);
  SkipBits((uint64_t)&v72, 8 * v24 + 8);
  if ((v19 & 0x20) != 0) {
LABEL_28:
  }
    SkipBits((uint64_t)&v72, 0x10u);
LABEL_29:
  if (v74 >= (unint64_t)v75 || (unint64_t)v75 - v74 <= 4 && !HIDWORD(v75)) {
    goto LABEL_54;
  }
  if (GetBits((uint64_t)&v72, 8u) != 4) {
    goto LABEL_54;
  }
  unint64_t v70 = 0;
  if (!GetBERInteger((uint64_t)&v72, &v70)) {
    goto LABEL_54;
  }
  if (v74 >= (unint64_t)v75) {
    goto LABEL_54;
  }
  unint64_t v20 = v75 - (v76 + v74) + ((unint64_t)HIDWORD(v75) >> 3);
  uint64_t v21 = v70 - v20;
  if (v70 > v20 || (unint64_t)v75 - v74 <= 4 && !HIDWORD(v75)) {
    goto LABEL_54;
  }
  char v22 = GetBits((uint64_t)&v72, 8u);
  if ((GetBits((uint64_t)&v72, 8u) & 0x3F8) != 0x10) {
    goto LABEL_54;
  }
  SkipBits((uint64_t)&v72, 0x58u);
  if (v74 >= (unint64_t)v75)
  {
    unint64_t v25 = 0;
    unint64_t v23 = 0;
  }
  else
  {
    unint64_t v23 = v75 - (v76 + v74) + ((unint64_t)HIDWORD(v75) >> 3);
    unint64_t v69 = 0;
    if (((unint64_t)v75 - v74 > 4 || HIDWORD(v75)) && GetBits((uint64_t)&v72, 8u) == 5)
    {
      if (GetBERInteger((uint64_t)&v72, &v69))
      {
        unint64_t v23 = v74 >= (unint64_t)v75 ? 0 : v75 - (v76 + v74) + ((unint64_t)HIDWORD(v75) >> 3);
        unint64_t v25 = v69;
        if (v23 >= v69 && v21 + v23 >= v69) {
          goto LABEL_53;
        }
      }
LABEL_54:
      uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      if (result) {
        return result;
      }
      unint64_t v26 = 0;
      char v22 = 32;
      goto LABEL_56;
    }
    unint64_t v25 = 0;
  }
LABEL_53:
  unint64_t v26 = v73 - v23;
  unint64_t v7 = v25;
LABEL_56:
  if (a3) {
    *a3 = v22;
  }
  switch(v22)
  {
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
      if (!v7) {
        return 0;
      }
      unint64_t v27 = a1 + v26;
      unint64_t v28 = v7;
      int v29 = 1;
      return MP4Bridge_ParseMPEGVideoSequenceHeader(v27, v28, v29, a5);
    case 'f':
    case 'g':
    case 'h':
      unint64_t v36 = a1 + v26;
      LODWORD(v71) = 0;
      LODWORD(v70) = 0;
      unint64_t v72 = v36;
      uint64_t v73 = v7;
      uint64_t v76 = 0;
      unint64_t v74 = v36;
      long long v75 = v36 + v7;
      uint64_t result = CopyNextWord((uint64_t)&v72);
      if (result) {
        return result;
      }
      if (GetBits((uint64_t)&v72, 0x20u) != 1094994246)
      {
        unint64_t v46 = v36;
        return MP4Bridge_ParseMPEG4AudioSpecificConfig(v46, v7, a4, a5);
      }
      if (GetBits((uint64_t)&v72, 1u) == 1)
      {
        int v37 = 9;
        do
        {
          SkipBits((uint64_t)&v72, 8u);
          --v37;
        }
        while (v37);
      }
      SkipBits((uint64_t)&v72, 1u);
      SkipBits((uint64_t)&v72, 1u);
      int v38 = GetBits((uint64_t)&v72, 1u);
      SkipBits((uint64_t)&v72, 0x17u);
      if ((GetBits((uint64_t)&v72, 4u) + 1) != 1)
      {
        uint64_t v59 = 4294954582;
        return FigSignalErrorAt(v59, 0, 0, 0, 0, 0, 0);
      }
      if (!v38) {
        SkipBits((uint64_t)&v72, 0x14u);
      }
      uint64_t result = MP4Bridge_ParseProgramConfigElement((uint64_t)&v72, &v71, &v70);
      if (!a5 || result) {
        return result;
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (!Mutable) {
        goto LABEL_191;
      }
      CFMutableDictionaryRef v40 = Mutable;
      FigCFDictionarySetInt32(Mutable, @"AudioSampleRate", v71);
      FigCFDictionarySetInt32(v40, @"AudioChannelCount", v70);
      FigCFDictionarySetInt32(v40, @"AudioFramesPerPacket", 1024);
      goto LABEL_149;
    case 'i':
    case 'k':
      if (!v7) {
        return 0;
      }
      if (v7 <= 5) {
        goto LABEL_160;
      }
      unint64_t v72 = a1 + v26;
      uint64_t v73 = v7;
      unint64_t v74 = a1 + v26;
      uint64_t v76 = 0;
      long long v75 = a1 + v26 + v7;
      if (CopyNextWord((uint64_t)&v72)) {
        return 0;
      }
      SkipBits((uint64_t)&v72, 0xBu);
      __int16 v41 = GetBits((uint64_t)&v72, 2u);
      if (v41 == 1) {
        goto LABEL_160;
      }
      __int16 v42 = v41;
      unsigned __int16 v43 = 4 - GetBits((uint64_t)&v72, 2u);
      if (v43 >= 4u) {
        goto LABEL_160;
      }
      if (!a5) {
        goto LABEL_157;
      }
      SkipBits((uint64_t)&v72, 5u);
      unsigned __int8 v44 = GetBits((uint64_t)&v72, 2u);
      if (v44 == 3)
      {
LABEL_160:
        uint64_t v56 = 4294954582;
      }
      else
      {
        if (v44 > 2u) {
          unsigned int v45 = 0;
        }
        else {
          unsigned int v45 = dword_18FE96208[(char)v44];
        }
        if (v42)
        {
          if (v42 == 2) {
            v45 >>= 1;
          }
        }
        else
        {
          v45 >>= 2;
        }
        SkipBits((uint64_t)&v72, 2u);
        if (GetBits((uint64_t)&v72, 2u) == 3) {
          int v52 = 1;
        }
        else {
          int v52 = 2;
        }
        switch(v43)
        {
          case 3u:
            if (v45 <= 0x5DC0) {
              int v53 = 576;
            }
            else {
              int v53 = 1152;
            }
            break;
          case 2u:
            int v53 = 1152;
            break;
          case 1u:
            int v53 = 384;
            break;
          default:
            int v53 = 0;
            break;
        }
        CFMutableDictionaryRef v54 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (v54)
        {
          CFMutableDictionaryRef v55 = v54;
          FigCFDictionarySetInt32(v54, @"AudioSampleRate", v45);
          FigCFDictionarySetInt32(v55, @"AudioChannelCount", v52);
          FigCFDictionarySetInt32(v55, @"AudioFramesPerPacket", v53);
          *a5 = v55;
LABEL_157:
          if (a4) {
            *a4 = v43;
          }
          return 0;
        }
        uint64_t v56 = 4294954510;
      }
      FigSignalErrorAt(v56, 0, 0, 0, 0, 0, 0);
      return 0;
    case 'j':
      if (!v7) {
        return 0;
      }
      unint64_t v27 = a1 + v26;
      unint64_t v28 = v7;
      int v29 = 0;
      return MP4Bridge_ParseMPEGVideoSequenceHeader(v27, v28, v29, a5);
    case 'l':
      if (v7 < 7) {
        return 0;
      }
      unint64_t v72 = a1 + v26;
      uint64_t v73 = v7;
      unint64_t v74 = a1 + v26;
      uint64_t v76 = 0;
      long long v75 = a1 + v26 + v7;
      uint64_t result = CopyNextWord((uint64_t)&v72);
      if (result) {
        return result;
      }
      SkipBits((uint64_t)&v72, 0x10u);
      __int16 v47 = GetBits((uint64_t)&v72, 0x10u);
      __int16 v48 = GetBits((uint64_t)&v72, 0x10u);
      SkipBits((uint64_t)&v72, 8u);
      CFAllocatorRef v49 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef v40 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v40)
      {
        CFMutableDictionaryRef PixelAspectRatioDictionary = createPixelAspectRatioDictionary(v49, v47, v48);
        FigCFDictionarySetValue(v40, (const void *)*MEMORY[0x1E4F24B98], PixelAspectRatioDictionary);
        if (PixelAspectRatioDictionary) {
          CFRelease(PixelAspectRatioDictionary);
        }
        if (!a5)
        {
          CFMutableDictionaryRef v51 = v40;
          goto LABEL_133;
        }
      }
      else if (!a5)
      {
        return 0;
      }
LABEL_149:
      uint64_t result = 0;
      *a5 = v40;
      return result;
    default:
      if (v22 == 64)
      {
        unint64_t v46 = a1 + v26;
        return MP4Bridge_ParseMPEG4AudioSpecificConfig(v46, v7, a4, a5);
      }
      if (v22 != 32) {
        return 0;
      }
      if (!v7)
      {
        uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        if (result) {
          return result;
        }
        return 4294954582;
      }
      unint64_t v72 = a1 + v26;
      uint64_t v73 = v7;
      unint64_t v74 = a1 + v26;
      uint64_t v76 = 0;
      long long v75 = a1 + v26 + v7;
      uint64_t result = CopyNextWord((uint64_t)&v72);
      if (result) {
        return result;
      }
      unint64_t v30 = v74;
      unint64_t v31 = v75;
      while (1)
      {
        if (v30 >= v31 || v31 - v30 <= 4 && !HIDWORD(v75)) {
          return 4294954582;
        }
        while (PeekBits((uint64_t)&v72, 0x18u) != 1)
        {
          GetBits((uint64_t)&v72, 8u);
          if (v74 < (unint64_t)v75 && ((unint64_t)v75 - v74 > 4 || HIDWORD(v75) != 0)) {
            continue;
          }
          return 4294954582;
        }
        GetBits((uint64_t)&v72, 0x18u);
        unsigned int v33 = GetBits((uint64_t)&v72, 8u);
        if (v33 != 181) {
          break;
        }
        if (GetBits((uint64_t)&v72, 1u) == 1)
        {
          GetBits((uint64_t)&v72, 4u);
          GetBits((uint64_t)&v72, 3u);
        }
        int v35 = GetBits((uint64_t)&v72, 4u);
        if ((v35 - 1) <= 1 && GetBits((uint64_t)&v72, 1u) == 1)
        {
          GetBits((uint64_t)&v72, 3u);
          GetBits((uint64_t)&v72, 1u);
          if (GetBits((uint64_t)&v72, 1u))
          {
            GetBits((uint64_t)&v72, 8u);
            GetBits((uint64_t)&v72, 8u);
            GetBits((uint64_t)&v72, 8u);
          }
        }
        GetBits((uint64_t)&v72, 1u);
        GetBits((uint64_t)&v72, BYTE12(v75) & 7);
        if (PeekBits((uint64_t)&v72, 0x20u) == 434)
        {
LABEL_90:
          uint64_t result = EatUserData((uint64_t)&v72);
          if (result) {
            return result;
          }
          goto LABEL_98;
        }
        if (v35 != 1) {
          return 4294954579;
        }
        GetBits((uint64_t)&v72, 0x18u);
        GetBits((uint64_t)&v72, 8u);
        if (PeekBits((uint64_t)&v72, 0x16u) == 32) {
          return 4294954579;
        }
LABEL_98:
        unint64_t v30 = v74;
        unint64_t v31 = v75;
        if (v74 >= (unint64_t)v75 || (unint64_t)v75 - v74 <= 4 && !HIDWORD(v75)) {
          return 4294954582;
        }
      }
      if (v33 == 176)
      {
        unsigned int v34 = 8;
LABEL_81:
        GetBits((uint64_t)&v72, v34);
        if (PeekBits((uint64_t)&v72, 0x20u) == 434) {
          goto LABEL_90;
        }
        goto LABEL_98;
      }
      if (v33 < 0x20) {
        goto LABEL_98;
      }
      if ((v33 & 0xFFFFFFF0) != 0x20)
      {
        if (v33 != 179) {
          goto LABEL_98;
        }
        GetBits((uint64_t)&v72, 0x14u);
        GetBits((uint64_t)&v72, 1u);
        unsigned int v34 = BYTE12(v75) & 7;
        goto LABEL_81;
      }
      GetBits((uint64_t)&v72, 1u);
      if (GetBits((uint64_t)&v72, 8u) == 18) {
        return 4294954579;
      }
      int v57 = 1;
      if (GetBits((uint64_t)&v72, 1u))
      {
        int v57 = GetBits((uint64_t)&v72, 4u);
        GetBits((uint64_t)&v72, 3u);
      }
      if (GetBits((uint64_t)&v72, 4u) == 15)
      {
        GetBits((uint64_t)&v72, 8u);
        GetBits((uint64_t)&v72, 8u);
      }
      if (GetBits((uint64_t)&v72, 1u) == 1)
      {
        GetBits((uint64_t)&v72, 2u);
        GetBits((uint64_t)&v72, 1u);
        if (GetBits((uint64_t)&v72, 1u) == 1)
        {
          GetBits((uint64_t)&v72, 0x1Bu);
          GetBits((uint64_t)&v72, 0x1Bu);
          GetBits((uint64_t)&v72, 0x19u);
        }
      }
      int v58 = GetBits((uint64_t)&v72, 2u);
      if (v58 == 3 && v57 != 1) {
        return 4294954579;
      }
      if (!GetBits((uint64_t)&v72, 1u)) {
        return 4294954582;
      }
      unsigned int v60 = GetBits((uint64_t)&v72, 0x10u);
      if (!GetBits((uint64_t)&v72, 1u)) {
        return 4294954582;
      }
      unsigned int v61 = 1;
      int v62 = GetBits((uint64_t)&v72, 1u);
      if (v60 >= 2)
      {
        do
        {
          ++v61;
          BOOL v15 = v60 > 3;
          v60 >>= 1;
        }
        while (v15);
      }
      if (v62) {
        GetBits((uint64_t)&v72, v61);
      }
      if (v58 == 2) {
        return 4294954579;
      }
      if (v58)
      {
        CFDictionaryRef v66 = 0;
LABEL_194:
        if (GetBits((uint64_t)&v72, 1u) || !GetBits((uint64_t)&v72, 1u)) {
          return 4294954579;
        }
        unsigned int v67 = v57 == 1 ? 1 : 2;
        if (GetBits((uint64_t)&v72, v67) || v57 != 1 && v58 && !GetBits((uint64_t)&v72, 1u)) {
          return 4294954579;
        }
        int v68 = GetBits((uint64_t)&v72, 1u);
        uint64_t result = 4294954579;
        if (v58 == 3 || v68 == 1) {
          return result;
        }
        if (GetBits((uint64_t)&v72, 1u) == 1 || v57 != 1 && GetBits((uint64_t)&v72, 1u)) {
          return 4294954579;
        }
        if (!GetBits((uint64_t)&v72, 1u)) {
          DefineVOPComplexityEstimationHeader((uint64_t)&v72);
        }
        GetBits((uint64_t)&v72, 1u);
        if (GetBits((uint64_t)&v72, 1u)) {
          GetBits((uint64_t)&v72, 1u);
        }
        if (v57 != 1 && (GetBits((uint64_t)&v72, 1u) || GetBits((uint64_t)&v72, 1u))
          || GetBits((uint64_t)&v72, 1u))
        {
          return 4294954579;
        }
        if (a5 && (uint64_t)FigCFDictionaryGetCount(v66) >= 1)
        {
          uint64_t result = 0;
          *a5 = v66;
          return result;
        }
        if (v66)
        {
          CFMutableDictionaryRef v51 = v66;
LABEL_133:
          CFRelease(v51);
        }
        return 0;
      }
      if (!GetBits((uint64_t)&v72, 1u)) {
        return 4294954582;
      }
      int v63 = GetBits((uint64_t)&v72, 0xDu);
      if (!GetBits((uint64_t)&v72, 1u)) {
        return 4294954582;
      }
      int v64 = GetBits((uint64_t)&v72, 0xDu);
      if (!GetBits((uint64_t)&v72, 1u)) {
        return 4294954582;
      }
      CFMutableDictionaryRef v65 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v65)
      {
        CFDictionaryRef v66 = v65;
        FigCFDictionarySetInt32(v65, @"VideoWidth", v63);
        FigCFDictionarySetInt32(v66, @"VideoHeight", v64);
        goto LABEL_194;
      }
LABEL_191:
      uint64_t v59 = 4294954510;
      return FigSignalErrorAt(v59, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t MP4Bridge_ParseMPEG4AudioSpecificConfig(unint64_t a1, unint64_t a2, _WORD *a3, CFMutableDictionaryRef *a4)
{
  if (a2 > 1)
  {
    uint64_t v39 = v4;
    uint64_t v40 = v5;
    v34[0] = a1;
    v34[1] = a2;
    uint64_t v37 = 0;
    unint64_t v35 = a1;
    long long v36 = a1 + a2;
    uint64_t result = CopyNextWord((uint64_t)v34);
    if (result) {
      return result;
    }
    unsigned int Bits = GetBits((uint64_t)v34, 5u);
    if (Bits == 31) {
      unsigned int Bits = GetBits((uint64_t)v34, 6u) + 32;
    }
    unsigned int v10 = GetBits((uint64_t)v34, 4u);
    if (v10 == 15)
    {
      int v11 = GetBits((uint64_t)v34, 0x18u);
    }
    else
    {
      if (v10 >= 0xD)
      {
LABEL_119:
        uint64_t v31 = 4294954582;
        return FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
      }
      int v11 = sSamplingFrequencies[v10];
    }
    unsigned int v12 = GetBits((uint64_t)v34, 4u);
    if (!v12)
    {
      int v13 = 0;
      goto LABEL_14;
    }
    if (v12 < 0x10 && ((0x8701uLL >> v12) & 1) == 0)
    {
      int v13 = MP4Bridge_ParseMPEG4AudioSpecificConfig_sChannelCounts[v12];
LABEL_14:
      BOOL v14 = Bits == 29;
      if (Bits == 29 || Bits == 5)
      {
        if (GetBits((uint64_t)v34, 4u) == 15) {
          SkipBits((uint64_t)v34, 0x18u);
        }
        unsigned int v15 = GetBits((uint64_t)v34, 5u);
        if (v15 == 31) {
          unsigned int v15 = GetBits((uint64_t)v34, 6u) + 32;
        }
        if (v15 == 22) {
          SkipBits((uint64_t)v34, 4u);
        }
        BOOL v16 = 1;
        if (!a4) {
          goto LABEL_63;
        }
      }
      else
      {
        BOOL v16 = 0;
        BOOL v14 = 0;
        unsigned int v15 = Bits;
        if (!a4)
        {
LABEL_63:
          uint64_t result = 0;
          if (a3) {
            *a3 = v15;
          }
          return result;
        }
      }
      uint64_t result = 4294954514;
      BOOL v33 = v14;
      size_t v32 = a3;
      int v17 = 160;
      int v18 = 8000;
      int v19 = 1;
      switch(v15)
      {
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        case 6u:
        case 7u:
        case 0x11u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
          int v38 = 0;
          if ((unsigned __int16)v15 == 23) {
            int v17 = 512;
          }
          else {
            int v17 = 1024;
          }
          if (GetBits((uint64_t)v34, 1u) != 1) {
            goto LABEL_37;
          }
          if ((unsigned __int16)v15 == 23)
          {
            int v17 = 480;
          }
          else if ((unsigned __int16)v15 == 3)
          {
            uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            if (result) {
              return result;
            }
          }
          else
          {
            int v17 = 960;
          }
LABEL_37:
          if (GetBits((uint64_t)v34, 1u) == 1) {
            SkipBits((uint64_t)v34, 0xEu);
          }
          int v20 = GetBits((uint64_t)v34, 1u);
          if (v12) {
            goto LABEL_42;
          }
          if ((unsigned __int16)v15 - 5 < 0xFFFFFFFC)
          {
            uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            if (result) {
              return result;
            }
            int v17 = 0;
            if (!v13) {
              goto LABEL_119;
            }
LABEL_54:
            if ((v15 > 0x17 || ((1 << v15) & 0xA00080) == 0)
              && v35 < (unint64_t)v36
              && (BYTE12(v36) & 7 | (8 * ((void)v36 - (v37 + v35) + ((unint64_t)HIDWORD(v36) >> 3)))) >= 0xB
              && (unsigned __int16)GetBits((uint64_t)v34, 0xBu) == 695
              && Bits != 5
              && Bits != 29
              && v35 < (unint64_t)v36
              && (BYTE12(v36) & 7 | (8 * ((void)v36 - (v37 + v35) + ((unint64_t)HIDWORD(v36) >> 3)))) >= 5)
            {
              __int16 v24 = GetBits((uint64_t)v34, 5u);
              if (v24 == 31
                && v35 < (unint64_t)v36
                && (BYTE12(v36) & 6 | (8 * ((void)v36 - (v37 + v35) + ((unint64_t)HIDWORD(v36) >> 3)))) >= 6)
              {
                __int16 v24 = GetBits((uint64_t)v34, 6u) + 32;
              }
              if (v24 == 22 || v24 == 5)
              {
                int v25 = GetBits((uint64_t)v34, 1u);
                BOOL v16 = v25 == 1;
                if (v25 == 1 && GetBits((uint64_t)v34, 4u) == 15) {
                  SkipBits((uint64_t)v34, 0x18u);
                }
                if (v24 == 22)
                {
                  if (v15 != 22) {
                    goto LABEL_119;
                  }
                  SkipBits((uint64_t)v34, 4u);
                }
                else if (v24 == 5 {
                       && v35 < (unint64_t)v36
                }
                       && (BYTE12(v36) & 4 | (8 * ((void)v36 - (v37 + v35) + ((unint64_t)HIDWORD(v36) >> 3)))) >= 0xC
                       && (unsigned __int16)GetBits((uint64_t)v34, 0xBu) == 1352)
                {
                  BOOL v33 = GetBits((uint64_t)v34, 1u) == 1;
                }
              }
            }
            goto LABEL_56;
          }
          uint64_t result = MP4Bridge_ParseProgramConfigElement((uint64_t)v34, 0, &v38);
          if (result) {
            return result;
          }
LABEL_42:
          if ((unsigned __int16)v15 == 20 || (unsigned __int16)v15 == 6) {
            SkipBits((uint64_t)v34, 3u);
          }
          if (v20 != 1) {
            goto LABEL_51;
          }
          if ((unsigned __int16)v15 > 0x17u) {
            goto LABEL_50;
          }
          if (((1 << v15) & 0x9A0000) != 0)
          {
            unsigned int v21 = 3;
          }
          else
          {
            if ((unsigned __int16)v15 != 22) {
              goto LABEL_50;
            }
            SkipBits((uint64_t)v34, 5u);
            unsigned int v21 = 11;
          }
          SkipBits((uint64_t)v34, v21);
LABEL_50:
          SkipBits((uint64_t)v34, 1u);
LABEL_51:
          if (!v12) {
            int v13 = v38;
          }
          if (!v13) {
            goto LABEL_119;
          }
          goto LABEL_54;
        case 9u:
        case 0x19u:
          goto LABEL_57;
        case 0x20u:
        case 0x21u:
        case 0x22u:
          SkipBits((uint64_t)v34, 1u);
          int v17 = 0;
          goto LABEL_56;
        case 0x27u:
          if (GetBits((uint64_t)v34, 1u) == 1) {
            int v17 = 480;
          }
          else {
            int v17 = 512;
          }
          SkipBits((uint64_t)v34, 3u);
          char v26 = GetBits((uint64_t)v34, 1u);
          if (v26)
          {
            BOOL v16 = v26;
            GetBits((uint64_t)v34, 1u);
          }
          else
          {
            BOOL v16 = 0;
          }
LABEL_56:
          int v19 = v13;
          int v18 = v11;
          goto LABEL_57;
        case 0x2Au:
          unsigned int v27 = GetBits((uint64_t)v34, 5u);
          if (v27 == 31)
          {
            int v18 = GetBits((uint64_t)v34, 0x18u);
          }
          else
          {
            if (v27 > 0x1B || v27 - 13 < 2) {
              goto LABEL_109;
            }
            int v18 = MP4Bridge_ParseUSACConfig_sUSACSamplingFrequencies[v27];
          }
          unsigned int v28 = GetBits((uint64_t)v34, 3u);
          if (v28 > 4) {
            goto LABEL_109;
          }
          int v17 = MP4Bridge_ParseUSACConfig_sUSACFramesPerPacket[v28];
          unsigned int v29 = GetBits((uint64_t)v34, 5u);
          if (v29)
          {
            if (v29 > 0xF) {
              goto LABEL_109;
            }
            int v19 = MP4Bridge_ParseUSACConfig_sUSACChannelCounts[v29];
          }
          else
          {
            int v19 = GetBits((uint64_t)v34, 5u);
            if (v19 == 31)
            {
              int v30 = GetBits((uint64_t)v34, 0x12u);
              int v19 = GetBits((uint64_t)v34, 0x12u) + 31;
              if (v30 == 0x3FFFF) {
                v19 += GetBits((uint64_t)v34, 0xDu);
              }
            }
          }
          if (v19) {
            goto LABEL_57;
          }
LABEL_109:
          uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
          int v17 = 0;
          int v19 = v13;
          int v18 = v11;
          if (result) {
            return result;
          }
LABEL_57:
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (!Mutable)
          {
            uint64_t v31 = 4294954510;
            return FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
          }
          CFMutableDictionaryRef v23 = Mutable;
          FigCFDictionarySetInt32(Mutable, @"AudioSampleRate", v18);
          FigCFDictionarySetInt32(v23, @"AudioChannelCount", v19);
          FigCFDictionarySetInt32(v23, @"AudioFramesPerPacket", v17);
          if (v16) {
            FigCFDictionarySetBoolean(v23, @"SBRIsPresent", v16);
          }
          a3 = v32;
          if (v33) {
            FigCFDictionarySetBoolean(v23, @"PSIsPresent", 1);
          }
          *a4 = v23;
          goto LABEL_63;
        default:
          return result;
      }
    }
    goto LABEL_119;
  }
  return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
}

uint64_t MP4Bridge_ParseMPEGVideoSequenceHeader(unint64_t a1, unint64_t a2, int a3, __CFDictionary **a4)
{
  if (a3)
  {
    if (a2 > 0x15) {
      goto LABEL_3;
    }
  }
  else if (a2 > 0xB)
  {
LABEL_3:
    v45[0] = a1;
    v45[1] = a2;
    uint64_t v48 = 0;
    unint64_t v46 = a1;
    long long v47 = a1 + a2;
    uint64_t Word = CopyNextWord((uint64_t)v45);
    if (!Word)
    {
      if (GetBits((uint64_t)v45, 0x20u) == 435
        && (int v7 = GetBits((uint64_t)v45, 0xCu),
            int v8 = GetBits((uint64_t)v45, 0xCu),
            unsigned __int8 v9 = GetBits((uint64_t)v45, 4u),
            int v10 = GetBits((uint64_t)v45, 4u),
            GetBits((uint64_t)v45, 0x12u),
            GetBits((uint64_t)v45, 1u) == 1))
      {
        SkipBits((uint64_t)v45, 0xAu);
        GetBits((uint64_t)v45, 1u);
        if (GetBits((uint64_t)v45, 1u)) {
          SkipBits((uint64_t)v45, 0x200u);
        }
        if (GetBits((uint64_t)v45, 1u)) {
          SkipBits((uint64_t)v45, 0x200u);
        }
        CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (Mutable)
        {
          int v13 = Mutable;
          if (a3)
          {
            AdvanceToNextStartCode((uint64_t)v45);
            if (v46 >= (unint64_t)v47) {
              goto LABEL_97;
            }
            if ((void)v47 - (v48 + v46) + ((unint64_t)HIDWORD(v47) >> 3) < 0xA) {
              goto LABEL_97;
            }
            if (GetBits((uint64_t)v45, 0x20u) != 437) {
              goto LABEL_97;
            }
            if (GetBits((uint64_t)v45, 4u) != 1) {
              goto LABEL_97;
            }
            GetBits((uint64_t)v45, 8u);
            GetBits((uint64_t)v45, 1u);
            GetBits((uint64_t)v45, 2u);
            int Bits = GetBits((uint64_t)v45, 2u);
            int v15 = GetBits((uint64_t)v45, 2u);
            GetBits((uint64_t)v45, 0xCu);
            if (GetBits((uint64_t)v45, 1u) != 1) {
              goto LABEL_97;
            }
            v7 |= Bits << 12;
            v8 |= v15 << 12;
            SkipBits((uint64_t)v45, 8u);
            GetBits((uint64_t)v45, 1u);
            GetBits((uint64_t)v45, 2u);
            GetBits((uint64_t)v45, 5u);
            AdvanceToNextStartCode((uint64_t)v45);
            __int16 v16 = v8;
            __int16 v17 = v7;
            if (v46 >= (unint64_t)v47
              || (__int16 v16 = v8, v17 = v7, (void)v47 - (v48 + v46) + ((unint64_t)HIDWORD(v47) >> 3) < 9)
              || (__int16 v16 = v8, v17 = v7, GetBits((uint64_t)v45, 0x20u) != 437)
              || (__int16 v16 = v8, v17 = v7, GetBits((uint64_t)v45, 4u) != 2))
            {
LABEL_88:
              if (v17 != (__int16)v7 || v7 << 16 != 47185920 || (__int16)v8 != v16) {
                goto LABEL_101;
              }
              int v37 = v8 << 16;
              if (v8 << 16 != 31457280)
              {
                if (v37 == 37748736)
                {
                  if (v9 == 2)
                  {
                    int v24 = 54;
                    int v25 = 59;
                    goto LABEL_105;
                  }
                  if (v9 == 3)
                  {
                    int v24 = 81;
                    int v25 = 118;
                    goto LABEL_105;
                  }
                  goto LABEL_101;
                }
                if (v37 != 31850496) {
                  goto LABEL_101;
                }
              }
              if (v9 == 2)
              {
                int v24 = 11;
                int v25 = 10;
                goto LABEL_105;
              }
              if (v9 == 3)
              {
                int v24 = 33;
                int v25 = 40;
                goto LABEL_105;
              }
LABEL_101:
              char v39 = v9 - 2;
              if ((v9 - 2) > 2u)
              {
                int v41 = 0;
                int v42 = 0;
              }
              else
              {
                uint64_t v40 = v39;
                int v41 = dword_18FE96214[v39];
                int v42 = dword_18FE96220[v40];
              }
              int v25 = v42 * v16;
              int v24 = v41 * v17;
              goto LABEL_105;
            }
            GetBits((uint64_t)v45, 3u);
            if (!GetBits((uint64_t)v45, 1u)) {
              goto LABEL_76;
            }
            int v18 = GetBits((uint64_t)v45, 8u);
            if (v18 == 6)
            {
              int v19 = (const void *)*MEMORY[0x1E4F24A90];
              int v20 = (const void **)MEMORY[0x1E4F24AC8];
            }
            else
            {
              if (v18 != 1)
              {
                FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_62:
                int v30 = GetBits((uint64_t)v45, 8u);
                if (v30 == 7)
                {
                  uint64_t v31 = (const void *)*MEMORY[0x1E4F24BC8];
                  size_t v32 = (const void **)MEMORY[0x1E4F24BF0];
                }
                else
                {
                  if (v30 != 1)
                  {
                    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
                    goto LABEL_68;
                  }
                  uint64_t v31 = (const void *)*MEMORY[0x1E4F24BC8];
                  size_t v32 = (const void **)MEMORY[0x1E4F24BE0];
                }
                CFDictionarySetValue(v13, v31, *v32);
LABEL_68:
                int v33 = GetBits((uint64_t)v45, 8u);
                switch(v33)
                {
                  case 7:
                    unsigned int v34 = (const void *)*MEMORY[0x1E4F24C18];
                    unint64_t v35 = (const void **)MEMORY[0x1E4F24C60];
                    goto LABEL_74;
                  case 6:
                    unsigned int v34 = (const void *)*MEMORY[0x1E4F24C18];
                    unint64_t v35 = (const void **)MEMORY[0x1E4F24C40];
                    goto LABEL_74;
                  case 1:
                    unsigned int v34 = (const void *)*MEMORY[0x1E4F24C18];
                    unint64_t v35 = (const void **)MEMORY[0x1E4F24C48];
LABEL_74:
                    CFDictionarySetValue(v13, v34, *v35);
                    goto LABEL_76;
                }
                FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_76:
                __int16 v16 = v8;
                __int16 v17 = v7;
                if (v46 >= (unint64_t)v47
                  || (__int16 v16 = v8, v17 = v7, (void)v47 - (v48 + v46) + ((unint64_t)HIDWORD(v47) >> 3) < 4))
                {
LABEL_87:
                  GetBits((uint64_t)v45, BYTE12(v47) & 7);
                  AdvanceToNextStartCode((uint64_t)v45);
                  goto LABEL_88;
                }
                __int16 v17 = v7;
                if (GetBits((uint64_t)v45, 0xEu) < (__int16)v7) {
                  __int16 v17 = GetBits((uint64_t)v45, 0xEu);
                }
                if (GetBits((uint64_t)v45, 1u) == 1)
                {
                  __int16 v16 = v8;
                  if (GetBits((uint64_t)v45, 0xEu) < (__int16)v8) {
                    __int16 v16 = GetBits((uint64_t)v45, 0xEu);
                  }
                  if (v17 < (__int16)v7 || v16 < (__int16)v8)
                  {
                    CFMutableDictionaryRef v36 = CFDictionaryCreateMutable(v11, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                    FigCFDictionarySetInt32(v36, (const void *)*MEMORY[0x1E4F24A88], v17);
                    FigCFDictionarySetInt32(v36, (const void *)*MEMORY[0x1E4F24A68], v16);
                    FigCFDictionarySetInt32(v36, (const void *)*MEMORY[0x1E4F24A70], 0);
                    FigCFDictionarySetInt32(v36, (const void *)*MEMORY[0x1E4F24A80], 0);
                    FigCFDictionarySetValue(v13, (const void *)*MEMORY[0x1E4F24A78], v36);
                    if (v36) {
                      CFRelease(v36);
                    }
                  }
                  goto LABEL_87;
                }
LABEL_97:
                uint64_t v38 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
                goto LABEL_111;
              }
              int v19 = (const void *)*MEMORY[0x1E4F24A90];
              int v20 = (const void **)MEMORY[0x1E4F24AB0];
            }
            CFDictionarySetValue(v13, v19, *v20);
            goto LABEL_62;
          }
          int v22 = v10 << 16;
          if (v10 << 16 != 0x40000)
          {
            if (v22 == 196608)
            {
              CFMutableDictionaryRef v23 = (const void *)*MEMORY[0x1E4F24AA0];
              int v26 = v8 << 16;
              int v27 = v7 << 16;
              if (v8 << 16 == 18874368 && v27 == 23068672)
              {
                int v24 = 54;
                int v25 = 59;
                if (!v23) {
                  goto LABEL_105;
                }
                goto LABEL_54;
              }
              if (v26 == 17825792 && v27 == 24117248)
              {
                int v24 = 69;
                int v25 = 68;
                if (!v23) {
                  goto LABEL_105;
                }
              }
              else
              {
                if (v26 != 13631488 || v27 != 24117248)
                {
LABEL_43:
                  unsigned int v28 = v9 - 1;
                  if (v28 > 0xD)
                  {
                    int v25 = 0;
                    int v24 = 0;
                    if (!v23) {
                      goto LABEL_105;
                    }
                  }
                  else
                  {
                    unsigned int v29 = (__int16 *)((char *)&pixelAspectRatios + 4 * v28);
                    int v25 = *v29;
                    int v24 = v29[1];
                    if (!v23) {
                      goto LABEL_105;
                    }
                  }
                  goto LABEL_54;
                }
                int v24 = 69;
                int v25 = 65;
                if (!v23) {
                  goto LABEL_105;
                }
              }
LABEL_54:
              CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24A90], v23);
              CFDictionarySetValue(v13, (const void *)*MEMORY[0x1E4F24BC8], (const void *)*MEMORY[0x1E4F24BE0]);
              CFDictionarySetValue(v13, (const void *)*MEMORY[0x1E4F24C18], (const void *)*MEMORY[0x1E4F24C40]);
              goto LABEL_105;
            }
            if (v22 != 0x10000)
            {
              CFMutableDictionaryRef v23 = 0;
              goto LABEL_43;
            }
          }
          CFMutableDictionaryRef v23 = (const void *)*MEMORY[0x1E4F24AC8];
          if ((unsigned __int16)v8 != 240) {
            goto LABEL_43;
          }
          if (v7 << 16 == 23068672)
          {
            int v24 = 11;
            int v25 = 10;
          }
          else
          {
            if (v7 << 16 != 25165824) {
              goto LABEL_43;
            }
            int v24 = 6;
            int v25 = 5;
            if (v9 != 1 && v9 != 14) {
              goto LABEL_43;
            }
          }
          if (!v23)
          {
LABEL_105:
            FigCFDictionarySetInt16(v13, @"VideoWidth", v7);
            FigCFDictionarySetInt16(v13, @"VideoHeight", v8);
            if (v25 >= 1 && v24 >= 1)
            {
              CFMutableDictionaryRef PixelAspectRatioDictionary = createPixelAspectRatioDictionary(v11, v25, v24);
              FigCFDictionarySetValue(v13, (const void *)*MEMORY[0x1E4F24B98], PixelAspectRatioDictionary);
              if (PixelAspectRatioDictionary) {
                CFRelease(PixelAspectRatioDictionary);
              }
            }
            uint64_t v38 = 0;
            if (a4)
            {
              *a4 = v13;
              return v38;
            }
LABEL_111:
            CFRelease(v13);
            return v38;
          }
          goto LABEL_54;
        }
        uint64_t v44 = 4294954510;
      }
      else
      {
        uint64_t v44 = 4294954582;
      }
      return FigSignalErrorAt(v44, 0, 0, 0, 0, 0, 0);
    }
    return Word;
  }

  return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
}

uint64_t FigMP4BridgeCreateRFC6381CodecString(OpaqueCMBlockBuffer *a1, int a2, int a3, uint64_t a4, __CFString **a5)
{
  memset(v64, 0, 112);
  int v63 = 0;
  unint64_t v62 = 0;
  memset(v61, 0, sizeof(v61));
  int v60 = 0;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  dataPointerOut = 0;
  int64_t v57 = 0;
  *a5 = 0;
  CurrentAtomTypeAndDatasize_t Length = FigAtomStreamInitWithBBuf(a1, 0, 1, (uint64_t)v64);
  if (CurrentAtomTypeAndDataLength) {
    return CurrentAtomTypeAndDataLength;
  }
  CurrentAtomTypeAndDatasize_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v64, &v63, &v62);
  if (CurrentAtomTypeAndDataLength) {
    return CurrentAtomTypeAndDataLength;
  }
  unsigned int v10 = v63;
  if (v63 == 1633777252 || v63 == 1701733217 || v63 == 1685220723)
  {
    if (a3 > 1885692722)
    {
      if (a3 > 1903522656)
      {
        if (a3 > 2053202791)
        {
          if (a3 > 2053464882)
          {
            if (a3 == 2053464883) {
              goto LABEL_81;
            }
            int v12 = 2054517601;
          }
          else
          {
            if (a3 == 2053202792) {
              goto LABEL_60;
            }
            int v12 = 2053202800;
          }
          goto LABEL_59;
        }
        if (a3 <= 2053202274)
        {
          if (a3 == 1903522657) {
            goto LABEL_60;
          }
          int v12 = 1970495843;
          goto LABEL_59;
        }
        if (a3 == 2053202275) {
          goto LABEL_60;
        }
        int v11 = 2053202739;
      }
      else
      {
        if (a3 > 1902207847)
        {
          if (a3 <= 1902211170)
          {
            if (a3 == 1902207848) {
              goto LABEL_60;
            }
            int v12 = 1902207856;
            goto LABEL_59;
          }
          if (a3 == 1902211171) {
            goto LABEL_54;
          }
          int v13 = 1902469939;
LABEL_52:
          if (a3 == v13) {
            goto LABEL_81;
          }
          goto LABEL_61;
        }
        if (a3 <= 1902207330)
        {
          if (a3 == 1885692723) {
            goto LABEL_81;
          }
          int v12 = 1886745441;
          goto LABEL_59;
        }
        if (a3 == 1902207331) {
          goto LABEL_60;
        }
        int v11 = 1902207795;
      }
    }
    else
    {
      if (a3 <= 1667330146)
      {
        if (a3 <= 1667326306)
        {
          if (a3 <= 1634754914)
          {
            if (a3 != 1633771875)
            {
              int v11 = 1633889587;
              goto LABEL_46;
            }
LABEL_60:
            unsigned int v10 = 1836069985;
            goto LABEL_82;
          }
          if (a3 != 1634754915)
          {
            unsigned __int16 v14 = 11571;
LABEL_39:
            int v11 = v14 | 0x63610000;
            goto LABEL_46;
          }
LABEL_54:
          unsigned int v10 = 1634754915;
          goto LABEL_82;
        }
        if (a3 <= 1667326823)
        {
          if (a3 == 1667326307) {
            goto LABEL_60;
          }
          unsigned __int16 v14 = 25395;
          goto LABEL_39;
        }
        if (a3 == 1667326824) {
          goto LABEL_60;
        }
        int v12 = 1667326832;
LABEL_59:
        if (a3 != v12)
        {
LABEL_61:
          if (a3 <= 1718378850)
          {
            if (a3 > 1667656802)
            {
              if (a3 == 1667656803) {
                goto LABEL_77;
              }
              if (a3 == 1668047203) {
                goto LABEL_192;
              }
              int v15 = 1700997939;
            }
            else
            {
              if (a3 == 1633889588)
              {
                unsigned int v10 = 1633889588;
                goto LABEL_82;
              }
              if (a3 == 1634492771) {
                goto LABEL_192;
              }
              int v15 = 1667574579;
            }
            goto LABEL_80;
          }
          if (a3 > 1902537826)
          {
            if (a3 <= 2053319474)
            {
              if (a3 != 1902537827)
              {
                if (a3 != 1902928227) {
                  goto LABEL_83;
                }
LABEL_192:
                unsigned int v10 = 1634492771;
                goto LABEL_82;
              }
LABEL_77:
              unsigned int v10 = 1716281667;
              goto LABEL_82;
            }
            if (a3 == 2053923171) {
              goto LABEL_192;
            }
            int v15 = 2053319475;
            goto LABEL_80;
          }
          if (a3 == 1718378851) {
            goto LABEL_77;
          }
          if (a3 != 1885547315)
          {
            int v15 = 1902324531;
LABEL_80:
            if (a3 != v15) {
              goto LABEL_83;
            }
          }
LABEL_81:
          unsigned int v10 = 1700998451;
          goto LABEL_82;
        }
        goto LABEL_60;
      }
      if (a3 <= 1885430114)
      {
        if (a3 > 1668641632)
        {
          if (a3 == 1668641633) {
            goto LABEL_60;
          }
          int v13 = 1700998451;
        }
        else
        {
          if (a3 == 1667330147) {
            goto LABEL_54;
          }
          int v13 = 1667575091;
        }
        goto LABEL_52;
      }
      if (a3 > 1885430631)
      {
        if (a3 == 1885430632) {
          goto LABEL_60;
        }
        int v12 = 1885430640;
        goto LABEL_59;
      }
      if (a3 == 1885430115) {
        goto LABEL_60;
      }
      int v11 = 1885430579;
    }
LABEL_46:
    if (a3 == v11)
    {
      unsigned int v10 = 1633889587;
LABEL_82:
      int v63 = v10;
      goto LABEL_83;
    }
    goto LABEL_61;
  }
LABEL_83:
  CFStringForOSTypeCFArrayRef Value = FigGetCFStringForOSTypeValue(v10);
  if (v63 <= 1835560240)
  {
    if ((v63 - 1835557169) >= 2)
    {
      if (v63 != 1633889588) {
        goto LABEL_180;
      }
      int v17 = 1684103988;
LABEL_92:
      if (a2 == 1936684398)
      {
        uint64_t v18 = 28;
      }
      else
      {
        if (a2 != 1986618469) {
          return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        }
        uint64_t v18 = 78;
      }
      if (v62 <= v18 + 8) {
        return 4294954580;
      }
      CurrentAtomTypeAndDatasize_t Length = FigAtomStreamInitWithParent((uint64_t)v64, v18, (uint64_t)v61);
      if (CurrentAtomTypeAndDataLength) {
        return CurrentAtomTypeAndDataLength;
      }
      while (v60 != v17)
      {
        CurrentAtomTypeAndDatasize_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v61, &v60, &v59);
        if (CurrentAtomTypeAndDataLength) {
          return CurrentAtomTypeAndDataLength;
        }
      }
      CurrentAtomTypeAndDatasize_t Length = FigAtomStreamGetCurrentAtomGlobalOffset(v61, &v58, &v57);
      if (CurrentAtomTypeAndDataLength) {
        return CurrentAtomTypeAndDataLength;
      }
      if (v57 < v59) {
        return 4294954580;
      }
      size_t v19 = v58 + v57;
      if (v19 > CMBlockBufferGetDataLength(a1)) {
        return 4294954580;
      }
      CurrentAtomTypeAndDatasize_t Length = CMBlockBufferGetDataPointer(a1, 0, 0, 0, &dataPointerOut);
      if (!CurrentAtomTypeAndDataLength)
      {
        unint64_t v20 = v59;
        uint64_t v21 = v57 - v59 + v58;
        if (v17 != 1684103988)
        {
          if (v17 != 1835557187)
          {
            unsigned int v67 = 0;
            unsigned __int8 v66 = 0;
            unsigned __int16 v65 = 0;
            int v22 = (__CFDictionary **)&v67;
            if (a3 != 1633772320 && a3 != 1633772392 && a3 != 1633772400) {
              int v22 = 0;
            }
            if (FigMP4Bridge_GetESDSObjectTypeAndCopyDecoderSpecificInfo((unint64_t)&dataPointerOut[v21], v59, (char *)&v66, &v65, v22))
            {
              CFStringRef v23 = 0;
LABEL_196:
              uint64_t v24 = 0;
LABEL_197:
              if (v67) {
                CFRelease(v67);
              }
              if (!v24)
              {
LABEL_200:
                if (!v23) {
                  goto LABEL_180;
                }
LABEL_201:
                CFMutableDictionaryRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, CFStringForOSTypeValue);
                if (MutableCopy)
                {
                  CFMutableDictionaryRef v54 = MutableCopy;
                  CFStringAppendFormat(MutableCopy, 0, @".%@", v23);
                  uint64_t v24 = 0;
                  *a5 = v54;
                }
                else
                {
                  uint64_t v24 = 4294954583;
                }
LABEL_203:
                CFRelease(v23);
                return v24;
              }
LABEL_129:
              if (!v23) {
                return v24;
              }
              goto LABEL_203;
            }
            uint64_t v37 = v65;
            if (v66 != 64)
            {
              if ((v66 & 0xFD) == 0x69 && v65) {
                CFStringRef v52 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%X.%u", v66, v65);
              }
              else {
                CFStringRef v52 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%X", v66);
              }
              goto LABEL_195;
            }
            if (v65 > 4u)
            {
              if (v65 != 5 && v65 != 29)
              {
LABEL_194:
                CFStringRef v52 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"40.%u", v37);
LABEL_195:
                CFStringRef v23 = v52;
                goto LABEL_196;
              }
            }
            else if (v65)
            {
              if (v65 == 2)
              {
                if (FigCFDictionaryGetBooleanValue(v67, @"SBRIsPresent")) {
                  unsigned __int16 v65 = 5;
                }
                if (FigCFDictionaryGetBooleanValue(v67, @"PSIsPresent"))
                {
                  uint64_t v37 = 29;
                  unsigned __int16 v65 = 29;
                }
                else
                {
                  uint64_t v37 = v65;
                }
              }
              goto LABEL_194;
            }
            uint64_t v24 = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
            CFStringRef v23 = 0;
            if (v24) {
              goto LABEL_197;
            }
            goto LABEL_196;
          }
          if ((unint64_t)v59 > 4)
          {
            int v69 = 0;
            long long v71 = 0u;
            uint64_t v72 = 0;
            unsigned int v67 = &dataPointerOut[v21];
            int v68 = v59;
            unint64_t v70 = &dataPointerOut[v21];
            *(void *)&long long v71 = &dataPointerOut[v21 + v59];
            uint64_t Word = CopyNextWord((uint64_t)&v67);
            if (Word) {
              goto LABEL_210;
            }
            if (GetBits((uint64_t)&v67, 8u) == 1)
            {
              unsigned __int8 Bits = GetBits((uint64_t)&v67, 8u);
              SkipBits((uint64_t)&v67, 8u);
              if (v20 >= (unsigned __int16)GetBits((uint64_t)&v67, 0x10u) + 5)
              {
                CFStringRef v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%02X", Bits);
                goto LABEL_200;
              }
            }
          }
          uint64_t Word = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
LABEL_210:
          uint64_t v24 = Word;
          CFStringRef v23 = 0;
          if (!Word) {
            goto LABEL_200;
          }
          goto LABEL_129;
        }
        int v69 = 0;
        long long v71 = 0u;
        uint64_t v72 = 0;
        unsigned int v67 = &dataPointerOut[v21];
        int v68 = v59;
        unint64_t v70 = &dataPointerOut[v21];
        *(void *)&long long v71 = &dataPointerOut[v21 + v59];
        if (CopyNextWord((uint64_t)&v67)) {
          goto LABEL_180;
        }
        char v25 = GetBits((uint64_t)&v67, 3u);
        if ((v25 & 0xFE) != 0) {
          goto LABEL_207;
        }
        char v26 = v25;
        unsigned __int8 v27 = GetBits((uint64_t)&v67, 7u);
        SkipBits((uint64_t)&v67, 5u);
        unsigned __int16 v28 = GetBits((uint64_t)&v67, 9u);
        unsigned __int16 v29 = v28;
        if (v26 == 1)
        {
          if ((v27 & 0xFE) != 0 && GetBits((uint64_t)&v67, 1u) == 1)
          {
            SkipBits((uint64_t)&v67, 0x10u);
            if (GetBits((uint64_t)&v67, 1u) == 1)
            {
              unsigned int v38 = 0;
              do
                SkipBits((uint64_t)&v67, 8u);
              while (v38++ < 0xF);
            }
          }
          SkipBits((uint64_t)&v67, 2u);
          SkipBits((uint64_t)&v67, 0x20u);
          SkipBits((uint64_t)&v67, 0x20u);
          GetBits((uint64_t)&v67, BYTE12(v71) & 7);
          int v40 = v29;
          if (v29)
          {
            int v41 = 0;
            while (1)
            {
              unsigned __int8 v42 = GetBits((uint64_t)&v67, 8u);
              if (v42 >= 3u) {
                goto LABEL_207;
              }
              unsigned __int8 v33 = v42;
              int v43 = GetBits((uint64_t)&v67, 8u);
              if (v43 == 255) {
                int v43 = GetBits((uint64_t)&v67, 0x10u) + 255;
              }
              if (GetBits((uint64_t)&v67, 5u) != 6) {
                goto LABEL_123;
              }
              for (int i = GetBits((uint64_t)&v67, 7u); i; --i)
                SkipBits((uint64_t)&v67, 0xFu);
              if (v33)
              {
                if (v33 == 1)
                {
                  if ((unint64_t)v70 >= (unint64_t)v71) {
                    unint64_t v45 = 0;
                  }
                  else {
                    unint64_t v45 = BYTE12(v71) & 7 | (8 * (v71 - (void)&v70[v72] + ((unint64_t)HIDWORD(v71) >> 3)));
                  }
                  if (GetBits((uint64_t)&v67, 1u) == 1)
                  {
                    SkipBits((uint64_t)&v67, 2u);
                    SkipBits((uint64_t)&v67, 0x20u);
                    SkipBits((uint64_t)&v67, 0x20u);
                  }
                  if (GetBits((uint64_t)&v67, 1u) == 1)
                  {
                    GetBits((uint64_t)&v67, BYTE12(v71) & 7);
                    __int16 v46 = GetBits((uint64_t)&v67, 0x10u);
                    if (v46)
                    {
                      LOWORD(v47) = v46;
                      do
                      {
                        SkipBits((uint64_t)&v67, 8u);
                        int v47 = (unsigned __int16)v47 + 1;
                      }
                      while ((v47 & 0x10000) == 0);
                    }
                    for (int j = GetBits((uint64_t)&v67, 5u); j; --j)
                      SkipBits((uint64_t)&v67, 0xBu);
                  }
                  GetBits((uint64_t)&v67, BYTE12(v71) & 7);
                  if ((unint64_t)v70 >= (unint64_t)v71) {
                    unint64_t v49 = 0;
                  }
                  else {
                    unint64_t v49 = BYTE12(v71) & 7 | (8 * (v71 - (void)&v70[v72] + ((unint64_t)HIDWORD(v71) >> 3)));
                  }
                  if (v45 - v49 <= (8 * v43 - 8))
                  {
                    SkipBits((uint64_t)&v67, 6u);
                    if (GetBits((uint64_t)&v67, 1u) == 1) {
                      unsigned int v50 = 9;
                    }
                    else {
                      unsigned int v50 = 1;
                    }
                    SkipBits((uint64_t)&v67, v50);
                  }
                }
              }
              else
              {
                GetBits((uint64_t)&v67, BYTE12(v71) & 7);
              }
              if (++v41 == v40) {
                goto LABEL_178;
              }
            }
          }
        }
        else if (!v26 && v28)
        {
          int v30 = GetBits((uint64_t)&v67, 1u);
          char v31 = GetBits((uint64_t)&v67, 5u);
          unsigned __int8 v32 = GetBits((uint64_t)&v67, 5u);
          if (v32 < 3u)
          {
            unsigned __int8 v33 = v32;
            if (v30 == 1 || v31 != 6)
            {
LABEL_123:
              uint64_t v34 = GetBits((uint64_t)&v67, 3u);
              goto LABEL_179;
            }
          }
LABEL_207:
          FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
          goto LABEL_180;
        }
        unsigned __int8 v33 = 0;
LABEL_178:
        uint64_t v34 = 0;
LABEL_179:
        CFStringRef v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%02X.%02X.%02X", v27, v33, v34);
        if (!v23) {
          goto LABEL_180;
        }
        goto LABEL_201;
      }
      return CurrentAtomTypeAndDataLength;
    }
LABEL_89:
    int v17 = 1835557187;
    goto LABEL_92;
  }
  if ((v63 - 1835560241) < 2) {
    goto LABEL_89;
  }
  int v17 = 1702061171;
  if (v63 == 1836069985 || v63 == 1836070006) {
    goto LABEL_92;
  }
LABEL_180:
  if (CFStringForOSTypeValue) {
    CFMutableDictionaryRef v51 = (__CFString *)CFRetain(CFStringForOSTypeValue);
  }
  else {
    CFMutableDictionaryRef v51 = 0;
  }
  uint64_t v24 = 0;
  *a5 = v51;
  return v24;
}

uint64_t GetBERInteger(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = *(void *)(a1 + 24);
  if (v3 >= v4)
  {
    unint64_t v6 = 0;
  }
  else
  {
    unint64_t v6 = 0;
    char Bits = 0x80;
    uint64_t v8 = 5;
    while ((v4 - v3 > 4 || *(_DWORD *)(a1 + 36)) && Bits < 0)
    {
      if (!--v8)
      {
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        return 0;
      }
      char Bits = GetBits(a1, 8u);
      unint64_t v6 = Bits & 0x7F | (v6 << 7);
      unint64_t v3 = *(void *)(a1 + 16);
      unint64_t v4 = *(void *)(a1 + 24);
      if (v3 >= v4) {
        break;
      }
    }
  }
  *a2 = v6;
  return 1;
}

uint64_t SkipBits(uint64_t result, unsigned int a2)
{
  unint64_t v2 = *(void *)(result + 16);
  unint64_t v3 = *(void *)(result + 24);
  if (v2 < v3)
  {
    uint64_t v5 = result;
    do
    {
      if (v3 - v2 <= 4 && !*(_DWORD *)(v5 + 36)) {
        break;
      }
      if (!a2) {
        break;
      }
      unsigned int v6 = a2 >= 4 ? 4 : a2;
      uint64_t result = GetBits(v5, v6);
      a2 -= v6;
      unint64_t v2 = *(void *)(v5 + 16);
      unint64_t v3 = *(void *)(v5 + 24);
    }
    while (v2 < v3);
  }
  return result;
}

uint64_t CopyNextWord(uint64_t a1)
{
  unint64_t v2 = *(unsigned char **)(a1 + 16);
  unint64_t v3 = *(unsigned char **)(a1 + 24);
  size_t v4 = v3 - v2;
  if (v3 <= v2 || v3 == v2)
  {
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    return 4294954584;
  }
  else
  {
    if (v4 > 3) {
      size_t v4 = 4;
    }
    else {
      *(_DWORD *)(a1 + 32) = 0;
    }
    memcpy((void *)(a1 + 32), v2, v4);
    unsigned int v7 = bswap32(*(_DWORD *)(a1 + 32));
    *(_DWORD *)(a1 + 32) = v7;
    *(_DWORD *)(a1 + 36) = 8 * v4;
    if (v4 <= 3) {
      *(_DWORD *)(a1 + 32) = v7 >> (-8 * v4);
    }
    uint64_t result = 0;
    *(void *)(a1 + 40) = v4;
  }
  return result;
}

uint64_t EatUserData(uint64_t a1)
{
  uint64_t v2 = 4294954582;
  if (GetBits(a1, 0x20u) == 434)
  {
    if (AdvanceToNextStartCode(a1) == 1) {
      return 0;
    }
    else {
      return 4294954582;
    }
  }
  return v2;
}

uint64_t AdvanceToNextStartCode(uint64_t a1)
{
  for (uint64_t i = a1; ; a1 = i)
  {
    uint64_t result = PeekBits(a1, 0x18u);
    if (result == 1) {
      break;
    }
    unint64_t v3 = *(void *)(i + 16);
    unint64_t v4 = *(void *)(i + 24);
    if (v3 >= v4 || v4 - v3 <= 4 && !*(_DWORD *)(i + 36)) {
      break;
    }
    GetBits(i, 8u);
  }
  return result;
}

uint64_t DefineVOPComplexityEstimationHeader(uint64_t a1)
{
  uint64_t result = GetBits(a1, 2u);
  if (result <= 1)
  {
    int v3 = result;
    if (!GetBits(a1, 1u)) {
      GetBits(a1, 6u);
    }
    if (!GetBits(a1, 1u)) {
      GetBits(a1, 4u);
    }
    GetBits(a1, 1u);
    if (!GetBits(a1, 1u)) {
      GetBits(a1, 4u);
    }
    if (!GetBits(a1, 1u)) {
      GetBits(a1, 6u);
    }
    uint64_t result = GetBits(a1, 1u);
    if (v3 == 1)
    {
      uint64_t result = GetBits(a1, 1u);
      if (!result)
      {
        return GetBits(a1, 2u);
      }
    }
  }
  return result;
}

CFMutableDictionaryRef createPixelAspectRatioDictionary(const __CFAllocator *a1, int a2, int a3)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32(Mutable, (const void *)*MEMORY[0x1E4F24B90], a2);
  FigCFDictionarySetInt32(Mutable, (const void *)*MEMORY[0x1E4F24BA0], a3);
  return Mutable;
}

uint64_t MP4Bridge_ParseProgramConfigElement(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  SkipBits(a1, 4u);
  SkipBits(a1, 2u);
  unsigned int Bits = GetBits(a1, 4u);
  if (Bits >= 0xD)
  {
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    char v25 = a2;
    int v24 = sSamplingFrequencies[Bits];
    unsigned __int8 v7 = GetBits(a1, 4u);
    LOBYTE(v8) = GetBits(a1, 4u);
    LOBYTE(v9) = GetBits(a1, 4u);
    LOBYTE(v10) = GetBits(a1, 2u);
    unsigned __int8 v11 = GetBits(a1, 3u);
    unsigned __int8 v12 = GetBits(a1, 4u);
    if (GetBits(a1, 1u) == 1) {
      SkipBits(a1, 4u);
    }
    if (GetBits(a1, 1u) == 1) {
      SkipBits(a1, 4u);
    }
    if (GetBits(a1, 1u) == 1)
    {
      SkipBits(a1, 2u);
      SkipBits(a1, 1u);
    }
    int v13 = a3;
    int v14 = v7;
    if (v7)
    {
      int v15 = 0;
      do
      {
        if (GetBits(a1, 1u) == 1) {
          int v16 = 2;
        }
        else {
          int v16 = 1;
        }
        v15 += v16;
        SkipBits(a1, 4u);
        --v14;
      }
      while (v14);
    }
    else
    {
      int v15 = 0;
    }
    int v8 = v8;
    if ((_BYTE)v8)
    {
      do
      {
        if (GetBits(a1, 1u) == 1) {
          int v17 = 2;
        }
        else {
          int v17 = 1;
        }
        v15 += v17;
        SkipBits(a1, 4u);
        --v8;
      }
      while (v8);
    }
    int v9 = v9;
    if ((_BYTE)v9)
    {
      do
      {
        if (GetBits(a1, 1u) == 1) {
          int v18 = 2;
        }
        else {
          int v18 = 1;
        }
        v15 += v18;
        SkipBits(a1, 4u);
        --v9;
      }
      while (v9);
    }
    int v19 = v10;
    if ((_BYTE)v10)
    {
      int v10 = v10;
      do
      {
        SkipBits(a1, 4u);
        --v10;
      }
      while (v10);
      v15 += v19;
    }
    int v20 = v11;
    if (v11)
    {
      do
      {
        SkipBits(a1, 4u);
        --v20;
      }
      while (v20);
    }
    int v21 = v12;
    if (v12)
    {
      do
      {
        SkipBits(a1, 1u);
        SkipBits(a1, 4u);
        --v21;
      }
      while (v21);
    }
    GetBits(a1, *(_DWORD *)(a1 + 36) & 7);
    for (int i = GetBits(a1, 8u); i; --i)
      SkipBits(a1, 8u);
    if (v25) {
      _DWORD *v25 = v24;
    }
    if (v13) {
      *int v13 = v15;
    }
    return 0;
  }
}

uint64_t FigTransportConnectionXPCClientCreate(uint64_t a1, void *a2)
{
  if (ntcxpc_getConnectionShared_once != -1) {
    dispatch_once(&ntcxpc_getConnectionShared_once, &__block_literal_global_24);
  }
  if (ntcxpc_getConnectionShared_transportConnection)
  {
    CFTypeRef v3 = CFRetain((CFTypeRef)ntcxpc_getConnectionShared_transportConnection);
    *a2 = v3;
    if (v3) {
      return 0;
    }
  }
  else
  {
    *a2 = 0;
  }
  return 4294955245;
}

void __ntcxpc_getConnectionShared_block_invoke()
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  v9[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v9, &type);
  int v1 = v9[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v3 = v1;
  }
  else {
    unsigned int v3 = v1 & 0xFFFFFFFE;
  }
  if (v3)
  {
    v9[1] = 136315138;
    int v10 = "ntcxpc_getConnectionShared_block_invoke";
    unint64_t v4 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v9[0];
  }
  else
  {
    unint64_t v4 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v4, v4 != &v11, v1, 0, v2);
  uint64_t v5 = *MEMORY[0x1E4F1CF80];
  ClassID = (void *)NeroTransportConnectionGetClassID();
  if (!CMDerivedObjectCreate(v5, (uint64_t)&kFigTransportConnectionXPCVTable, ClassID, &ntcxpc_getConnectionShared_transportConnection))
  {
    uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(ntcxpc_getConnectionShared_transportConnection);
    if (ntcxpc_getClient_once != -1) {
      dispatch_once(&ntcxpc_getClient_once, &__block_literal_global_8);
    }
    *uint64_t DerivedStorage = ntcxpc_getClient_client;
    ntcxpc_initTransportConnection(ntcxpc_getConnectionShared_transportConnection);
  }
}

void ntcxpc_initTransportConnection(uint64_t a1)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  xpc_object_t v4 = 0;
  xpc_object_t v5 = 0;
  int v2 = FigXPCCreateBasicMessage(0x696E6974u, 0, &v5);
  xpc_object_t v3 = 0;
  if (!v2)
  {
    FigXPCRemoteClientSendSyncMessageCreatingReply(*DerivedStorage, (uint64_t)v5, &v4);
    xpc_object_t v3 = v4;
  }
  FigXPCRelease(v3);
  FigXPCRelease(v5);
}

uint64_t ntcxpc_Invalidate()
{
  return 4294954514;
}

void ntcxpc_Finalize()
{
  int v7 = 0;
  os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v7, &v6);
  int v1 = v7;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, v6)) {
    unsigned int v3 = v1;
  }
  else {
    unsigned int v3 = v1 & 0xFFFFFFFE;
  }
  if (v3)
  {
    xpc_object_t v4 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v7;
  }
  else
  {
    xpc_object_t v4 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v4, v4 != &v5, v1, 0, v2);
  __break(1u);
}

__CFString *ntcxpc_CopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigTransportConnectionXPC %p>", a1);
  return Mutable;
}

uint64_t ntcxpc_CopyProperty()
{
  return 4294954514;
}

uint64_t ntcxpc_SetProperty()
{
  return 0;
}

uint64_t ntcxpc_SetEventHandler(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!*(unsigned char *)(DerivedStorage + 16))
  {
    uint64_t v5 = DerivedStorage;
    if (a3) {
      a3 = _Block_copy(a3);
    }
    os_log_type_t v6 = *(const void **)(v5 + 8);
    if (v6) {
      _Block_release(v6);
    }
    *(void *)(v5 + 8) = a3;
  }
  return 0;
}

uint64_t ntcxpc_Start()
{
  return 0;
}

uint64_t ntcxpc_Stop()
{
  return 0;
}

uint64_t ntcxpc_EnqueuePackageWithPriority(uint64_t a1, unsigned int *a2, CMBlockBufferRef theBuffer, int a4)
{
  xpc_object_t xdict = 0;
  if (theBuffer) {
    Datasize_t Length = CMBlockBufferGetDataLength(theBuffer);
  }
  else {
    Datasize_t Length = 0;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)(DerivedStorage + 16))
  {
    xpc_object_t v12 = 0;
    uint64_t v11 = 0;
  }
  else if (DataLength >= *a2)
  {
    xpc_object_t v12 = 0;
    uint64_t v11 = 4294954516;
  }
  else
  {
    int v10 = (uint64_t *)DerivedStorage;
    uint64_t v11 = FigXPCCreateBasicMessage(0x656E7175u, 0, &xdict);
    xpc_object_t v12 = xdict;
    if (!v11)
    {
      xpc_dictionary_set_data(xdict, "enqueuePkgHeader", a2, *a2 - DataLength);
      uint64_t v11 = FigXPCMessageSetBlockBuffer(xdict, "enqueuePackage", theBuffer);
      xpc_object_t v12 = xdict;
      if (!v11)
      {
        xpc_dictionary_set_int64(xdict, "enqueuePriority", a4);
        uint64_t v11 = FigXPCRemoteClientSendSyncMessage(*v10, (uint64_t)xdict);
        xpc_object_t v12 = xdict;
      }
    }
  }
  FigXPCRelease(v12);
  return v11;
}

uint64_t ntcxpc_FlushPendingPackagesWithPriority(uint64_t a1, int a2)
{
  xpc_object_t xdict = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)(DerivedStorage + 16))
  {
    xpc_object_t v6 = 0;
    uint64_t v5 = 0;
  }
  else
  {
    xpc_object_t v4 = (uint64_t *)DerivedStorage;
    uint64_t v5 = FigXPCCreateBasicMessage(0x666C7368u, 0, &xdict);
    xpc_object_t v6 = xdict;
    if (!v5)
    {
      xpc_dictionary_set_int64(xdict, "flushPendingPackage", a2);
      uint64_t v5 = FigXPCRemoteClientSendSyncMessage(*v4, (uint64_t)xdict);
      xpc_object_t v6 = xdict;
    }
  }
  FigXPCRelease(v6);
  return v5;
}

void __ntcxpc_getClient_block_invoke()
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v13 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v13, &type);
  int v2 = v13;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v4 = v2;
  }
  else {
    unsigned int v4 = v2 & 0xFFFFFFFE;
  }
  if (v4)
  {
    int v14 = 136315394;
    int v15 = "ntcxpc_getClient_block_invoke";
    __int16 v16 = 2080;
    int v17 = "com.apple.coremedia.nerotransportconnectionxpc";
    uint64_t v5 = (unsigned char *)_os_log_send_and_compose_impl();
    LOBYTE(v2) = v13;
  }
  else
  {
    uint64_t v5 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v5, v5 != v18, v2, 0, v3);
  CFDictionarySetValue(Mutable, @"xpcRemoteClientOption_DeathNoticeName", @"FigTransportNTCXPCServerDied");
  FigCFDictionarySetInt32(Mutable, @"xpcRemoteClientOption_QueuePriority", 28);
  int v6 = FigXPCRemoteClientCreate((uint64_t)"com.apple.coremedia.nerotransportconnectionxpc", kFigTransportConnectionXPC_FigTransportConnectionClass_block_invoke_clientCallbacks, Mutable, &ntcxpc_getClient_client);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v6)
  {
    int v13 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    int v7 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, &v13, &type);
    int v8 = v13;
    if (os_log_type_enabled(v7, type)) {
      unsigned int v10 = v8;
    }
    else {
      unsigned int v10 = v8 & 0xFFFFFFFE;
    }
    if (v10)
    {
      int v14 = 136315394;
      int v15 = "ntcxpc_getClient_block_invoke";
      __int16 v16 = 1024;
      LODWORD(v17) = v6;
      uint64_t v11 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v8) = v13;
    }
    else
    {
      uint64_t v11 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v11, v11 != v18, v8, 0, v9);
  }
}

void ntcxpc_handleServerDeath()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  v6[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v6, &type);
  int v1 = v6[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v3 = v1;
  }
  else {
    unsigned int v3 = v1 & 0xFFFFFFFE;
  }
  if (v3)
  {
    v6[1] = 136315138;
    int v7 = "ntcxpc_handleServerDeath";
    unsigned int v4 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v6[0];
  }
  else
  {
    unsigned int v4 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v4, v4 != &v8, v1, 0, v2);
  if (ntcxpc_getConnectionShared_once != -1) {
    dispatch_once(&ntcxpc_getConnectionShared_once, &__block_literal_global_24);
  }
  ntcxpc_initTransportConnection(ntcxpc_getConnectionShared_transportConnection);
}

uint64_t ntcxpc_handleServerMessage(void *a1)
{
  if (ntcxpc_getConnectionShared_once != -1) {
    dispatch_once(&ntcxpc_getConnectionShared_once, &__block_literal_global_24);
  }
  uint64_t v2 = ntcxpc_getConnectionShared_transportConnection;
  int v8 = 0;
  uint64_t result = FigXPCMessageGetOpCode(a1, &v8);
  if (!result)
  {
    if (v8 == 1701671783)
    {
      CFTypeRef cf = 0;
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(v2);
      if (!*(unsigned char *)(DerivedStorage + 16))
      {
        uint64_t v5 = DerivedStorage;
        int64_t int64 = xpc_dictionary_get_int64(a1, (const char *)kNeroTransportConnectionEventHandler_Type);
        if (!FigXPCMessageCreateBlockBufferData((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1, (char *)kNeroTransportConnectionEventHandler_BBuf, (CMBlockBufferRef *)&cf))
        {
          uint64_t v7 = *(void *)(v5 + 8);
          if (v7) {
            (*(void (**)(uint64_t, int64_t, CFTypeRef))(v7 + 16))(v7, int64, cf);
          }
        }
        if (cf) {
          CFRelease(cf);
        }
      }
      return 0;
    }
    else
    {
      return 4294954516;
    }
  }
  return result;
}

void FigEnableCustomAllocatorsOnDaemonStartup()
{
}

void figCustomAllocatorsInit(char a1)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __figCustomAllocatorsInit_block_invoke;
  block[3] = &__block_descriptor_tmp_27;
  char v2 = a1;
  if (figCustomAllocatorsInit_onceToken != -1) {
    dispatch_once(&figCustomAllocatorsInit_onceToken, block);
  }
}

uint64_t FigGetAllocatorForMedia()
{
  return qword_1EB28B9B0;
}

uint64_t FigGetMallocZoneForMedia()
{
  return qword_1EB28B9A8;
}

uint64_t FigGetAllocatorForPermanentAllocations()
{
  return qword_1EB28B9C8;
}

uint64_t FigGetMallocZoneForPermanentAllocations()
{
  return qword_1EB28B9C0;
}

void *__figCustomAllocatorsInit_block_invoke(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 32);
  figCustomAllocatorsInit_allocators = (uint64_t)"CMMediaAllocator";
  qword_1EB28B9B8 = (uint64_t)"CMPermanentAllocator";
  if (v1)
  {
    qword_1EB28B9A8 = (uint64_t)malloc_create_zone(0, 0);
    malloc_set_zone_name((malloc_zone_t *)qword_1EB28B9A8, "CMMediaZone");
    context.version = 0;
    context.info = &figCustomAllocatorsInit_allocators;
    context.retain = 0;
    context.release = 0;
    context.copyDescription = (CFAllocatorCopyDescriptionCallBack)darwinMemory_copyDebugDescForCustomAllocator;
    context.allocate = (CFAllocatorAllocateCallBack)darwinMemory_allocForCustomAllocator;
    context.reallocate = (CFAllocatorReallocateCallBack)darwinMemory_reallocForCustomAllocator;
    context.deallocate = (CFAllocatorDeallocateCallBack)darwinMemory_deallocForCustomAllocator;
    context.preferredSize = 0;
    qword_1EB28B9B0 = (uint64_t)CFAllocatorCreate(0, &context);
    qword_1EB28B9C0 = (uint64_t)malloc_create_zone(0, 0);
    malloc_set_zone_name((malloc_zone_t *)qword_1EB28B9C0, "CMPermanentZone");
    context.version = 0;
    context.info = &qword_1EB28B9B8;
    context.retain = 0;
    context.release = 0;
    context.copyDescription = (CFAllocatorCopyDescriptionCallBack)darwinMemory_copyDebugDescForCustomAllocator;
    context.allocate = (CFAllocatorAllocateCallBack)darwinMemory_allocForCustomAllocator;
    context.reallocate = (CFAllocatorReallocateCallBack)darwinMemory_reallocForCustomAllocator;
    context.deallocate = (CFAllocatorDeallocateCallBack)darwinMemory_deallocForCustomAllocator;
    context.preferredSize = 0;
    uint64_t result = CFAllocatorCreate(0, &context);
    qword_1EB28B9C8 = (uint64_t)result;
  }
  else
  {
    qword_1EB28B9B0 = *MEMORY[0x1E4F1CF80];
    uint64_t v3 = qword_1EB28B9B0;
    qword_1EB28B9A8 = (uint64_t)malloc_default_zone();
    qword_1EB28B9C8 = v3;
    uint64_t result = malloc_default_zone();
    qword_1EB28B9C0 = (uint64_t)result;
  }
  return result;
}

CFStringRef darwinMemory_copyDebugDescForCustomAllocator(uint64_t *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v3 = *a1;
  zone_name = malloc_get_zone_name((malloc_zone_t *)a1[1]);
  return CFStringCreateWithFormat(v2, 0, @"<%s with zone: %s(%p)>", v3, zone_name, a1[1]);
}

void *darwinMemory_allocForCustomAllocator(size_t size, uint64_t a2, uint64_t a3)
{
  return malloc_type_zone_calloc(*(malloc_zone_t **)(a3 + 8), 1uLL, size, 0xF2F21DC9uLL);
}

void *darwinMemory_reallocForCustomAllocator(void *ptr, size_t size, uint64_t a3, uint64_t a4)
{
  return malloc_type_zone_realloc(*(malloc_zone_t **)(a4 + 8), ptr, size, 0x58E682ADuLL);
}

void darwinMemory_deallocForCustomAllocator(void *ptr, uint64_t a2)
{
}

uint64_t FigMetricEventTimelineCreateRemote(uint64_t a1, int64_t a2, uint64_t *a3, uint64_t a4, CFTypeRef *a5)
{
  xpc_object_t v20 = 0;
  xpc_object_t xdict = 0;
  if (!a5)
  {
    uint64_t v8 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
LABEL_15:
    uint64_t v17 = v8;
    xpc_object_t v9 = 0;
    goto LABEL_13;
  }
  uint64_t v8 = metremote_ensureClientEstablished();
  if (v8) {
    goto LABEL_15;
  }
  uint64_t v8 = FigXPCCreateBasicMessage(0x63726574u, 0, &xdict);
  if (v8) {
    goto LABEL_15;
  }
  xpc_dictionary_set_int64(xdict, "MaxNoOfClasses", a2);
  xpc_object_t v9 = xpc_array_create(0, 0);
  if (v9)
  {
    if (a2 >= 1)
    {
      unsigned int v10 = a3;
      int64_t v11 = a2;
      do
      {
        int64_t v12 = *v10++;
        xpc_array_set_int64(v9, 0xFFFFFFFFFFFFFFFFLL, v12);
        --v11;
      }
      while (v11);
    }
    xpc_dictionary_set_value(xdict, "EventCountByClassXPCArray", v9);
    uint64_t v13 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigMetricEventTimelineRemoteClient, (uint64_t)xdict, &v20);
    if (v13) {
      goto LABEL_12;
    }
    uint64_t int64 = xpc_dictionary_get_uint64(v20, ".objectID");
    if (uint64)
    {
      int v15 = (const void *)uint64;
      uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
      uint64_t v13 = metremote_create(AllocatorForMedia, (uint64_t)v15, a2, a3, a5);
      if (!v13) {
        uint64_t v13 = FigXPCRemoteClientAssociateObject(gFigMetricEventTimelineRemoteClient, (uint64_t)*a5, v15);
      }
      goto LABEL_12;
    }
    uint64_t v19 = 4294947844;
  }
  else
  {
    uint64_t v19 = 4294947845;
  }
  uint64_t v13 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
LABEL_12:
  uint64_t v17 = v13;
LABEL_13:
  FigXPCRelease(v9);
  FigXPCRelease(xdict);
  FigXPCRelease(v20);
  return v17;
}

uint64_t metremote_ensureClientEstablished()
{
  uint64_t v3 = 0;
  unsigned int v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __metremote_ensureClientEstablished_block_invoke;
  block[3] = &unk_1E5679780;
  void block[4] = &v3;
  if (metremote_ensureClientEstablished_sFigMetricEventTimelineRemoteClientSetupOnce != -1) {
    dispatch_once(&metremote_ensureClientEstablished_sFigMetricEventTimelineRemoteClientSetupOnce, block);
  }
  FigXPCRemoteClientKillServerOnTimeout(gFigMetricEventTimelineRemoteClient, *((unsigned int *)v4 + 6), "metremote_ensureClientEstablished", 0);
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t metremote_create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, CFTypeRef *a5)
{
  CFTypeRef cf = 0;
  if (a5)
  {
    ClassID = (void *)FigMetricEventTimelineGetClassID();
    uint64_t v11 = CMDerivedObjectCreate(a1, (uint64_t)&kMetricEventTimeline_VTable, ClassID, &cf);
    CFTypeRef v12 = cf;
    if (v11
      || (uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf),
          *uint64_t DerivedStorage = a2,
          int v14 = (CFTypeRef *)(DerivedStorage + 2),
          uint64_t AllocatorForMedia = FigGetAllocatorForMedia(),
          uint64_t v11 = FigMetricEventTimelineCreate(AllocatorForMedia, a3, a4, 0, 0, v14),
          CFTypeRef v12 = cf,
          v11))
    {
      if (v12) {
        CFRelease(v12);
      }
    }
    else
    {
      *a5 = cf;
    }
    return v11;
  }
  else
  {
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigMetricEventTimelineCreateRemoteWithObjectID(uint64_t a1, const void *a2, uint64_t a3, uint64_t *a4, void *a5)
{
  CFTypeRef cf = 0;
  if (a5)
  {
    uint64_t v9 = metremote_ensureClientEstablished();
    if (v9) {
      return v9;
    }
    uint64_t v10 = FigXPCRemoteClientRetainCopiedObject(gFigMetricEventTimelineRemoteClient, (uint64_t)a2, &cf);
    CFTypeRef v11 = cf;
    if (v10
      || !cf
      && ((uint64_t AllocatorForMedia = FigGetAllocatorForMedia(),
           uint64_t v10 = metremote_create(AllocatorForMedia, (uint64_t)a2, a3, a4, &cf),
           CFTypeRef v11 = cf,
           v10)
       || (uint64_t v10 = FigXPCRemoteClientAssociateObject(gFigMetricEventTimelineRemoteClient, (uint64_t)cf, a2),
           CFTypeRef v11 = cf,
           v10)))
    {
      uint64_t v13 = v10;
      if (v11) {
        CFRelease(v11);
      }
    }
    else
    {
      uint64_t v13 = 0;
      *a5 = v11;
    }
    return v13;
  }
  else
  {
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t __metremote_ensureClientEstablished_block_invoke(uint64_t a1)
{
  v3[0] = 1;
  v3[1] = (unint64_t)metremote_deadConnectionCallback;
  v3[2] = 0;
  v3[3] = (unint64_t)metremote_handleServerMessage;
  long long v4 = 0u;
  long long v5 = 0u;
  uint64_t result = FigXPCRemoteClientCreate((uint64_t)"com.apple.coremedia.mediaplaybackd.figmetriceventtimeline.xpc", v3, 0, &gFigMetricEventTimelineRemoteClient);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t metremote_deadConnectionCallback(uint64_t a1)
{
  uint64_t result = CMBaseObjectGetDerivedStorage(a1);
  *(unsigned char *)(result + 8) = 1;
  return result;
}

uint64_t metremote_handleServerMessage(uint64_t a1, void *a2)
{
  int v14 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v14);
  if (OpCode) {
    return OpCode;
  }
  if (v14 != 1702260340) {
    return 4294951138;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  CFTypeRef cf = 0;
  uint64_t v6 = FigMetricEventTimelineClientServerXPC_DeserializeAndCopyEvent(a2, &cf);
  if (v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void *)(DerivedStorage + 16);
  CFTypeRef v8 = cf;
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable(v7) + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  CFTypeRef v12 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef))(v10 + 40);
  if (v12)
  {
    uint64_t v6 = v12(v7, a1, v8);
LABEL_10:
    uint64_t v11 = v6;
    goto LABEL_12;
  }
  uint64_t v11 = 4294954514;
LABEL_12:
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t metremote_finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigXPCRemoteClientDisassociateObject(gFigMetricEventTimelineRemoteClient, *(const void **)DerivedStorage);
  CFAllocatorRef v2 = 0;
  uint64_t v6 = 0;
  if (!*(unsigned char *)(DerivedStorage + 8))
  {
    int v3 = FigXPCCreateBasicMessage(0x64697370u, *(void *)DerivedStorage, &v6);
    CFAllocatorRef v2 = v6;
    if (!v3)
    {
      FigXPCRemoteClientSendAsyncMessage(gFigMetricEventTimelineRemoteClient, v6);
      CFAllocatorRef v2 = v6;
    }
  }
  FigXPCRelease(v2);
  long long v4 = *(const void **)(DerivedStorage + 16);
  if (v4) {
    CFRelease(v4);
  }
  return FigXPCRemoteClientKillServerOnTimeout(gFigMetricEventTimelineRemoteClient, 0, "metremote_finalize", 0);
}

CFStringRef metremote_copyDebugDesc(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, @"[FigMetricEventTimelineRemote %p %lld]", a1, *DerivedStorage);
}

uint64_t metremote_registerSubscriber(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  int v18 = 0;
  if (!a2)
  {
    uint64_t v13 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  CFTypeRef v8 = (uint64_t *)DerivedStorage;
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    int v15 = 0;
    uint64_t v16 = 0;
    goto LABEL_11;
  }
  *(unsigned char *)(DerivedStorage + 24) = 1;
  uint64_t v9 = *(void *)(DerivedStorage + 16);
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable(v9) + 16);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  CFTypeRef v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 8);
  if (!v12)
  {
    int v15 = 0;
    uint64_t v16 = 4294954514;
    goto LABEL_11;
  }
  uint64_t v13 = v12(v9, a2, a3, a4);
  if (v13)
  {
LABEL_13:
    uint64_t v16 = v13;
    int v15 = 0;
    goto LABEL_11;
  }
  uint64_t v14 = FigXPCCreateBasicMessage(0x72656773u, *v8, &v18);
  int v15 = v18;
  if (v14)
  {
    uint64_t v16 = v14;
  }
  else
  {
    uint64_t v16 = FigXPCRemoteClientSendSyncMessage(gFigMetricEventTimelineRemoteClient, (uint64_t)v18);
    int v15 = v18;
  }
LABEL_11:
  FigXPCRelease(v15);
  return v16;
}

uint64_t metremote_subscribeByEventID(uint64_t a1, uint64_t a2, int64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  xpc_object_t xdict = 0;
  if (!a2)
  {
    uint64_t v11 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  uint64_t v6 = (uint64_t *)DerivedStorage;
  uint64_t v7 = *(void *)(DerivedStorage + 16);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(v7) + 16);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, int64_t))(v9 + 16);
  if (!v10)
  {
    xpc_object_t v13 = 0;
    uint64_t v12 = 4294954514;
    goto LABEL_10;
  }
  uint64_t v11 = v10(v7, a2, a3);
  if (v11)
  {
LABEL_12:
    uint64_t v12 = v11;
    xpc_object_t v13 = 0;
    goto LABEL_10;
  }
  uint64_t v12 = FigXPCCreateBasicMessage(0x73657669u, *v6, &xdict);
  xpc_object_t v13 = xdict;
  if (!v12)
  {
    xpc_dictionary_set_int64(xdict, "EventID", a3);
    uint64_t v12 = FigXPCRemoteClientSendSyncMessage(gFigMetricEventTimelineRemoteClient, (uint64_t)xdict);
    xpc_object_t v13 = xdict;
  }
LABEL_10:
  FigXPCRelease(v13);
  return v12;
}

uint64_t metremote_subscribeByClassID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  xpc_object_t xdict = 0;
  if (!a2)
  {
    uint64_t v11 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  uint64_t v6 = (uint64_t *)DerivedStorage;
  uint64_t v7 = *(void *)(DerivedStorage + 16);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(v7) + 16);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9 + 24);
  if (!v10)
  {
    xpc_object_t v13 = 0;
    uint64_t v12 = 4294954514;
    goto LABEL_10;
  }
  uint64_t v11 = v10(v7, a2, a3);
  if (v11)
  {
LABEL_12:
    uint64_t v12 = v11;
    xpc_object_t v13 = 0;
    goto LABEL_10;
  }
  uint64_t v12 = FigXPCCreateBasicMessage(0x636C7369u, *v6, &xdict);
  xpc_object_t v13 = xdict;
  if (!v12)
  {
    xpc_dictionary_set_int64(xdict, "ClassID", (int)a3);
    uint64_t v12 = FigXPCRemoteClientSendSyncMessage(gFigMetricEventTimelineRemoteClient, (uint64_t)xdict);
    xpc_object_t v13 = xdict;
  }
LABEL_10:
  FigXPCRelease(v13);
  return v12;
}

uint64_t metremote_subscribeToAllEvents(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v14 = 0;
  if (!a2)
  {
    uint64_t v9 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  long long v4 = (uint64_t *)DerivedStorage;
  uint64_t v5 = *(void *)(DerivedStorage + 16);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable(v5) + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 32);
  if (!v8)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 4294954514;
    goto LABEL_10;
  }
  uint64_t v9 = v8(v5, a2);
  if (v9)
  {
LABEL_12:
    uint64_t v12 = v9;
    uint64_t v11 = 0;
    goto LABEL_10;
  }
  uint64_t v10 = FigXPCCreateBasicMessage(0x73746165u, *v4, &v14);
  uint64_t v11 = v14;
  if (v10)
  {
    uint64_t v12 = v10;
  }
  else
  {
    uint64_t v12 = FigXPCRemoteClientSendSyncMessage(gFigMetricEventTimelineRemoteClient, (uint64_t)v14);
    uint64_t v11 = v14;
  }
LABEL_10:
  FigXPCRelease(v11);
  return v12;
}

uint64_t met_publishEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v17 = 0;
  if (!a2 || !a3)
  {
    uint64_t v12 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  uint64_t v7 = (uint64_t *)DerivedStorage;
  uint64_t v8 = *(void *)(DerivedStorage + 16);
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable(v8) + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 40);
  if (!v11)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 4294954514;
    goto LABEL_12;
  }
  uint64_t v12 = v11(v8, a2, a3);
  if (v12)
  {
LABEL_14:
    uint64_t v15 = v12;
    uint64_t v14 = 0;
    goto LABEL_12;
  }
  uint64_t v13 = FigXPCCreateBasicMessage(0x70756273u, *v7, &v17);
  uint64_t v14 = v17;
  if (v13 || (uint64_t v13 = FigMetricEventTimelineClientServerXPC_SerializeEvent(v17, a1, a3), v14 = v17, v13))
  {
    uint64_t v15 = v13;
  }
  else
  {
    uint64_t v15 = FigXPCRemoteClientSendSyncMessage(gFigMetricEventTimelineRemoteClient, (uint64_t)v17);
    uint64_t v14 = v17;
  }
LABEL_12:
  FigXPCRelease(v14);
  return v15;
}

uint64_t FigVirtualCaptureCardServerStart()
{
  v3[0] = 2;
  v3[1] = FigVirtualCaptureCardServerReplyingMessageHandler;
  v3[2] = FigVirtualCaptureCardServerNoReplyMessageHandler;
  memset(&v3[3], 0, 24);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, @"xpcServerOption_SiloObjectIDs", (const void *)*MEMORY[0x1E4F1CFD0]);
  uint64_t v1 = FigXPCServerStart((uint64_t)"com.apple.coremedia.figvirtualcapturecard.xpc", v3, (uint64_t)Mutable, &gFigVirtualCaptureCardServer);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v1;
}

uint64_t FigVirtualCaptureCardServerReplyingMessageHandler(_xpc_connection_s *a1, void *a2, void *a3)
{
  int v24 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v24);
  if (OpCode) {
    return OpCode;
  }
  if (v24 != 1668441400)
  {
    uint64_t int64 = xpc_dictionary_get_uint64(a2, ".objectID");
    uint64_t value = 0;
    uint64_t v11 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &value, 0);
    if (v11)
    {
      uint64_t v9 = v11;
    }
    else
    {
      if (!value) {
        return 4294954513;
      }
      CFTypeID v12 = CFGetTypeID((CFTypeRef)value);
      if (v12 == FigVirtualCaptureCardGetTypeID())
      {
        uint64_t v13 = value;
        uint64_t v9 = 4294951138;
        if (v24 <= 1919251317)
        {
          if (v24 == 778268793)
          {
            uint64_t v15 = FigXPCHandleStdCopyPropertyMessage(value, a2, a3);
LABEL_31:
            uint64_t v9 = v15;
            if (!v13) {
              return v9;
            }
            goto LABEL_37;
          }
          if (v24 == 779314548)
          {
            uint64_t v15 = FigXPCHandleStdSetPropertyMessage(value, a2);
            goto LABEL_31;
          }
        }
        else
        {
          switch(v24)
          {
            case 1919251318:
              string = xpc_dictionary_get_string(a2, "FileURL");
              CFStringRef v17 = CFStringCreateWithCString(0, string, 0x8000100u);
              if (!v17)
              {
                uint64_t v9 = 4294954510;
                if (!v13) {
                  return v9;
                }
LABEL_37:
                int v22 = (const void *)v13;
LABEL_38:
                CFRelease(v22);
                return v9;
              }
              CFStringRef v18 = v17;
              CFURLRef v19 = CFURLCreateWithString(0, v17, 0);
              if (v19)
              {
                CFURLRef v20 = v19;
                int v21 = *(uint64_t (**)(uint64_t, CFURLRef))(*(void *)(CMBaseObjectGetVTable(v13) + 16) + 16);
                if (v21) {
                  uint64_t v9 = v21(v13, v20);
                }
                else {
                  uint64_t v9 = 4294954514;
                }
                CFRelease(v18);
              }
              else
              {
                uint64_t v9 = 4294954510;
                CFURLRef v20 = (CFURLRef)v18;
              }
              CFRelease(v20);
              break;
            case 1935767141:
              uint64_t v14 = *(uint64_t (**)(uint64_t))(*(void *)(CMBaseObjectGetVTable(value) + 16) + 24);
              if (!v14)
              {
LABEL_19:
                uint64_t v9 = 4294954514;
                if (!v13) {
                  return v9;
                }
                goto LABEL_37;
              }
              goto LABEL_29;
            case 1936224119:
              uint64_t v14 = *(uint64_t (**)(uint64_t))(*(void *)(CMBaseObjectGetVTable(value) + 16) + 8);
              if (!v14) {
                goto LABEL_19;
              }
LABEL_29:
              uint64_t v15 = v14(v13);
              goto LABEL_31;
          }
        }
        if (!v13) {
          return v9;
        }
        goto LABEL_37;
      }
      uint64_t v9 = 4294954516;
    }
    int v22 = (const void *)value;
    if (!value) {
      return v9;
    }
    goto LABEL_38;
  }
  if (HandleFigVirtualCaptureCardCreationMessage_onceToken != -1) {
    dispatch_once(&HandleFigVirtualCaptureCardCreationMessage_onceToken, &__block_literal_global_25);
  }
  uint64_t value = 0;
  FigSimpleMutexLock((pthread_mutex_t *)HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCardCreationLock);
  uint64_t v7 = (const void *)HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCard;
  if (HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCard) {
    goto LABEL_8;
  }
  uint64_t v8 = FigVirtualCaptureCardCreate(*MEMORY[0x1E4F1CF80], 0, &HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCard);
  if (!v8)
  {
    uint64_t v7 = (const void *)HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCard;
LABEL_8:
    uint64_t v9 = FigXPCServerAssociateObjectWithConnection(a1, v7, 0, 0, 0, &value);
    if (!v9) {
      xpc_dictionary_set_uint64(a3, ".objectID", value);
    }
    goto LABEL_10;
  }
  uint64_t v9 = v8;
LABEL_10:
  FigSimpleMutexUnlock((pthread_mutex_t *)HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCardCreationLock);
  return v9;
}

uint64_t FigVirtualCaptureCardServerNoReplyMessageHandler(_xpc_connection_s *a1, void *a2)
{
  int v9 = 0;
  CFTypeRef cf = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v9);
  if (OpCode) {
    goto LABEL_5;
  }
  uint64_t int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  OpCFIndex Code = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, 0);
  if (OpCode) {
    goto LABEL_5;
  }
  if (v9 == 1684632432)
  {
    OpCFIndex Code = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_5:
    uint64_t v6 = OpCode;
    goto LABEL_7;
  }
  uint64_t v6 = 4294951138;
LABEL_7:
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

pthread_mutex_t *__HandleFigVirtualCaptureCardCreationMessage_block_invoke()
{
  uint64_t result = FigSimpleMutexCreate();
  HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCardCreationLock = (uint64_t)result;
  return result;
}

uint64_t AudioToolbox_AudioConverterGetProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioConverterGetProperty;
  if (pAudioConverterGetProperty
    || ((FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce), !gAudioToolboxBundleStatus)? (result = 0): (result = 4294965266), (uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioConverterGetProperty) != 0))
  {
    return v8(a1, a2, a3, a4);
  }
  return result;
}

uint64_t AudioToolbox_AudioConverterSetProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioConverterSetProperty;
  if (pAudioConverterSetProperty
    || ((FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce), !gAudioToolboxBundleStatus)? (result = 0): (result = 4294965266), (uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioConverterSetProperty) != 0))
  {
    return v8(a1, a2, a3, a4);
  }
  return result;
}

uint64_t AudioToolbox_AudioConverterDispose(uint64_t a1)
{
  CFAllocatorRef v2 = (uint64_t (*)(uint64_t))pAudioConverterDispose;
  if (pAudioConverterDispose
    || ((FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce), !gAudioToolboxBundleStatus)? (uint64_t result = 0): (uint64_t result = 4294965266), (v2 = (uint64_t (*)(uint64_t))pAudioConverterDispose) != 0))
  {
    return v2(a1);
  }
  return result;
}

uint64_t AudioToolbox_AudioConverterNew(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))pAudioConverterNew;
  if (pAudioConverterNew
    || ((FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce), !gAudioToolboxBundleStatus)? (result = 0): (result = 4294965266), (uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))pAudioConverterNew) != 0))
  {
    return v6(a1, a2, a3);
  }
  return result;
}

uint64_t FigHALAudioObjectGetClassID()
{
  if (FigHALAudioObjectGetClassID_sRegisterFigHALAudioDeviceOnce != -1) {
    dispatch_once(&FigHALAudioObjectGetClassID_sRegisterFigHALAudioDeviceOnce, &__block_literal_global_26);
  }
  return FigHALAudioObjectGetClassID_sFigHALAudioObjectClassID;
}

uint64_t __FigHALAudioObjectGetClassID_block_invoke()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&FigHALAudioObjectGetClassID_sFigHALAudioObjectClassDesc, ClassID, 1, &FigHALAudioObjectGetClassID_sFigHALAudioObjectClassID);
}

uint64_t CelestialIsAppleTV()
{
  if (getDeviceClass_onceToken != -1) {
    dispatch_once(&getDeviceClass_onceToken, &__block_literal_global_97);
  }
  if (getDeviceClass_deviceClass != 4) {
    return CelestialIsAppleTV_sIsAppleTV;
  }
  uint64_t result = 1;
  CelestialIsAppleTV_sIsAppleTV = 1;
  return result;
}

uint64_t CelestialIsiPad()
{
  if (getDeviceClass_onceToken != -1) {
    dispatch_once(&getDeviceClass_onceToken, &__block_literal_global_97);
  }
  if (getDeviceClass_deviceClass != 3) {
    return CelestialIsiPad_sIsiPad;
  }
  uint64_t result = 1;
  CelestialIsiPad_sIsiPad = 1;
  return result;
}

uint64_t CelestialIsiPhone()
{
  if (getDeviceClass_onceToken != -1) {
    dispatch_once(&getDeviceClass_onceToken, &__block_literal_global_97);
  }
  if (getDeviceClass_deviceClass != 1) {
    return CelestialIsiPhone_sIsiPhone;
  }
  uint64_t result = 1;
  CelestialIsiPhone_sIsiPhone = 1;
  return result;
}

void CelestialGetSupportedAVCProfileAndLevel(unsigned char *a1, unsigned char *a2)
{
  if (CelestialGetSupportedAVCProfileAndLevel_onceToken == -1)
  {
    if (!a1) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  dispatch_once(&CelestialGetSupportedAVCProfileAndLevel_onceToken, &__block_literal_global_27);
  if (a1) {
LABEL_3:
  }
    *a1 = 100;
LABEL_4:
  if (a2) {
    *a2 = CelestialGetSupportedAVCProfileAndLevel_sLevel;
  }
}

void __CelestialGetSupportedAVCProfileAndLevel_block_invoke()
{
  CFNumberRef v0 = (const __CFNumber *)MGCopyAnswer();
  unsigned int SInt8 = FigCFNumberGetSInt8(v0);
  if (v0) {
    CFRelease(v0);
  }
  if (SInt8 <= 0x33)
  {
    if (SInt8 == 51)
    {
      char v2 = 51;
    }
    else if (SInt8 <= 0x31)
    {
      if (SInt8 < 0x2A) {
        return;
      }
      char v2 = 42;
    }
    else
    {
      char v2 = 50;
    }
  }
  else
  {
    char v2 = 52;
  }
  CelestialGetSupportedAVCProfileAndLevel_sLevel = v2;
}

uint64_t CelestialGetModelSpecificResolutionCap(double *a1, double *a2, long long *a3)
{
  long long v12 = xmmword_18FE96240;
  double v10 = 0.0;
  double v11 = 0.0;
  CelestialGetMainScreenSize(&v11, &v10, 2048.0);
  uint64_t result = 0;
  double v8 = v10;
  double v7 = v11;
  if (v11 > 0.0 && v10 > 0.0 && v10 > 7.0)
  {
    long long v12 = kResolutionCap3K;
    uint64_t result = 1;
  }
  *a3 = v12;
  *a1 = v7;
  *a2 = v8;
  return result;
}

double CelestialGetMainScreenSize(double *a1, double *a2, double result)
{
  if (a1)
  {
    if (a2)
    {
      *a1 = 0.0;
      *a2 = 0.0;
      int v5 = MGGetSInt32Answer();
      int v6 = MGGetSInt32Answer();
      int v7 = MGGetSInt32Answer();
      if (v5 >= 1 && v6 >= 1)
      {
        double v8 = (double)v7;
        double v9 = (double)v6;
        if ((double)v5 <= (double)v6) {
          double v10 = (double)v6;
        }
        else {
          double v10 = (double)v5;
        }
        if ((double)v5 <= (double)v6) {
          double v9 = (double)v5;
        }
        *a1 = v10 / v8;
        uint64_t result = v9 / v8;
        *a2 = result;
      }
    }
  }
  return result;
}

uint64_t CelestialIsAudioAccessory()
{
  if (CelestialIsAudioAccessory_onceToken != -1) {
    dispatch_once(&CelestialIsAudioAccessory_onceToken, &__block_literal_global_4_0);
  }
  return CelestialIsAudioAccessory_sIsAudioAccessory;
}

uint64_t __CelestialIsAudioAccessory_block_invoke()
{
  uint64_t result = MGGetSInt32Answer();
  if (result == 7) {
    CelestialIsAudioAccessory_sIsAudioAccessory = 1;
  }
  return result;
}

BOOL CelestialIs1GBAudioAccessory()
{
  if (CelestialIsAudioAccessory_onceToken != -1) {
    dispatch_once(&CelestialIsAudioAccessory_onceToken, &__block_literal_global_4_0);
  }
  if (CelestialIsAudioAccessory_sIsAudioAccessory != 1) {
    return 0;
  }
  FigThreadRunOnce(&sGetSystemMemorySizeOnce, (void (*)(void))celestialGetSystemMemorySizeOnce);
  return (unint64_t)sMemorySize < 0x40000001;
}

uint64_t CelestialGetSystemMemorySize()
{
  return sMemorySize;
}

void __CelestialGetModelSpecificName_block_invoke()
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)cStr = 0u;
  long long v9 = 0u;
  size_t v7 = 64;
  sysctlbyname("hw.model", cStr, &v7, 0, 0);
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (Mutable)
  {
    CFStringRef v2 = Mutable;
    CFStringAppendCString(Mutable, cStr, 0);
    CFIndex Length = CFStringGetLength(v2);
    if (CFStringHasSuffix(v2, @"AP")) {
      CFIndex v4 = Length - 2;
    }
    else {
      CFIndex v4 = 0;
    }
    if (CFStringHasSuffix(v2, @"DEV")) {
      v5.unint64_t length = Length - 3;
    }
    else {
      v5.unint64_t length = v4;
    }
    if (v5.length < 1)
    {
      int v6 = (void *)CFRetain(v2);
    }
    else
    {
      v5.CFIndex location = 0;
      int v6 = (void *)CFStringCreateWithSubstring(v0, v2, v5);
    }
    CelestialGetModelSpecificName_sModelNameStr = (uint64_t)v6;
    CFRelease(v2);
  }
  if (!CelestialGetModelSpecificName_sModelNameStr) {
    CelestialGetModelSpecificName_sModelNameStr = @"D421";
  }
}

uint64_t celestialGetSystemMemorySizeOnce()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  *(void *)CFStringRef v2 = 0x1800000006;
  size_t v1 = 8;
  uint64_t result = sysctl(v2, 2u, &sMemorySize, &v1, 0, 0);
  if ((result & 0x80000000) != 0) {
    sMemorySize = 0;
  }
  return result;
}

CFPropertyListRef CelestialCFCreatePropertyListForModelAndBundleIdentifier(CFStringRef bundleID, const __CFString *a2, __CFString *cf)
{
  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier((const __CFAllocator *)*MEMORY[0x1E4F1CF80], bundleID, a2, cf);
}

CFPropertyListRef FigCreateModelSpecificPropertyListForModelAndBundleIdentifier(const __CFAllocator *a1, CFStringRef bundleID, const __CFString *a3, __CFString *cf)
{
  CFIndex v4 = cf;
  if (cf)
  {
    CFRetain(cf);
    if (!FigCFBundleIDResourceSubdirExists(bundleID, v4))
    {
      CFRelease(v4);
      CFIndex v4 = @"Default";
    }
  }
  CFPropertyListRef PropertyListFromBundleIdentifier = FigCreatePropertyListFromBundleIdentifier(a1, bundleID, a3, v4);
  CFPropertyListRef v9 = PropertyListFromBundleIdentifier;
  if (v4 && !PropertyListFromBundleIdentifier)
  {
    CFPropertyListRef v9 = FigCreatePropertyListFromBundleIdentifier(a1, bundleID, a3, 0);
LABEL_8:
    CFRelease(v4);
    return v9;
  }
  if (v4) {
    goto LABEL_8;
  }
  return v9;
}

CFPropertyListRef CelestialCFCreatePropertyListForModel(const __CFString *a1, __CFString *cf)
{
  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier((const __CFAllocator *)*MEMORY[0x1E4F1CF80], @"com.apple.MediaToolbox", a1, cf);
}

CFPropertyListRef FigCreateModelSpecificPropertyListForModel(const __CFAllocator *a1, const __CFString *a2, __CFString *cf)
{
  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier(a1, @"com.apple.MediaToolbox", a2, cf);
}

CFPropertyListRef FigCreateModelSpecificPropertyList(const __CFAllocator *a1, const __CFString *a2)
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1) {
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_10);
  }
  CFIndex v4 = (__CFString *)CelestialGetModelSpecificName_sModelNameStr;

  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier(a1, @"com.apple.MediaToolbox", a2, v4);
}

CFPropertyListRef CelestialCFCreatePropertyListFromBundleIdentifier(CFStringRef bundleID, const __CFString *a2)
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1) {
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_10);
  }
  CFIndex v4 = (__CFString *)CelestialGetModelSpecificName_sModelNameStr;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];

  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier(v5, bundleID, a2, v4);
}

CFPropertyListRef FigCreateModelSpecificPropertyListFromBundleIdentifier(const __CFAllocator *a1, CFStringRef bundleID, const __CFString *a3)
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1) {
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_10);
  }
  int v6 = (__CFString *)CelestialGetModelSpecificName_sModelNameStr;

  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier(a1, bundleID, a3, v6);
}

uint64_t CelestialCustomizePlaybackImageQueueLevels(uint64_t a1, CMTime *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = CelestialIsAppleTV();
  if (result)
  {
    memset(&v13, 0, sizeof(v13));
    CMTime v12 = *a2;
    CMTimeConvertScale(&v13, &v12, 60, kCMTimeRoundingMethod_RoundTowardPositiveInfinity);
    int CFPreferenceNumberWithDefault = FigGetCFPreferenceNumberWithDefault(@"decode_depth", @"com.apple.coremedia", LODWORD(v13.value));
    CMTimeMake(&v12, CFPreferenceNumberWithDefault, 60);
    *(_OWORD *)&a2->uint64_t value = *(_OWORD *)&v12.value;
    CMTimeEpoch epoch = v12.epoch;
    a2->CMTimeEpoch epoch = v12.epoch;
    long long v10 = *(_OWORD *)&a2->value;
    *(void *)(a3 + 16) = epoch;
    *(_OWORD *)a3 = v10;
    long long v11 = *(_OWORD *)&a2->value;
    *(void *)(a4 + 16) = a2->epoch;
    *(_OWORD *)a4 = v11;
    return 1;
  }
  return result;
}

double CelestialGetStreamingBackBufferDuration(double a1)
{
  if ((unint64_t)sMemorySize <= 0x20000000 && !CelestialIsAppleTV()) {
    return 1.0;
  }
  return a1;
}

uint64_t CelestialShouldLimitConcurrent4K60HEVCDecoding()
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1) {
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_10);
  }
  CFAllocatorRef v0 = (const void *)CelestialGetModelSpecificName_sModelNameStr;

  return FigCFEqual(v0, @"J105a");
}

uint64_t CelestialShouldLimitHDRConcurrentPlayback(_DWORD *a1)
{
  uint64_t result = CelestialIsAppleTV();
  if (result)
  {
    uint64_t result = 1;
    if (a1) {
      *a1 = 1;
    }
  }
  return result;
}

uint64_t CelestialShouldLimitMVHEVCEncoding()
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1) {
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_10);
  }
  CFAllocatorRef v0 = (const void *)CelestialGetModelSpecificName_sModelNameStr;

  return FigCFEqual(v0, @"J105a");
}

BOOL CelestialShouldLimitMVHEVCDecoding()
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1) {
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_10);
  }
  CFAllocatorRef v0 = (const void *)CelestialGetModelSpecificName_sModelNameStr;
  return FigCFEqual((CFTypeRef)CelestialGetModelSpecificName_sModelNameStr, @"J71b")
      || FigCFEqual(v0, @"J72b")
      || FigCFEqual(v0, @"J120")
      || FigCFEqual(v0, @"J121")
      || FigCFEqual(v0, @"J171")
      || FigCFEqual(v0, @"J172")
      || FigCFEqual(v0, @"J207")
      || FigCFEqual(v0, @"J208") != 0;
}

uint64_t CelestialShouldLimit4kConcurrentPlayback(_DWORD *a1)
{
  uint64_t result = CelestialIsAppleTV();
  if (result)
  {
    uint64_t result = 1;
    if (a1) {
      *a1 = 1;
    }
  }
  return result;
}

uint64_t CelestialShouldLimit4kStereoConcurrentPlayback()
{
  return 0;
}

uint64_t CelestialShouldLimitHDRFrameRateForPlayback(void *a1, double a2, double a3)
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1) {
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_10);
  }
  int v6 = FigCFEqual((CFTypeRef)CelestialGetModelSpecificName_sModelNameStr, @"J105a");
  uint64_t result = 0;
  if (v6) {
    BOOL v8 = a3 <= 1920.0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8 && a2 > 1080.0)
  {
    if (a1) {
      *a1 = 0x403E000000000000;
    }
    return 1;
  }
  return result;
}

BOOL CelestialShouldSupportHDR10Plus()
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1) {
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_10);
  }
  CFAllocatorRef v0 = (const void *)CelestialGetModelSpecificName_sModelNameStr;
  return !FigCFEqual((CFTypeRef)CelestialGetModelSpecificName_sModelNameStr, @"J42d")
      && !FigCFEqual(v0, @"J105a")
      && !FigCFEqual(v0, @"J305");
}

uint64_t CelestialShouldManageEDRDeadline()
{
  return MGGetBoolAnswer();
}

uint64_t CelestialShouldAllowHTPCIOSurfacesForHDRPlaybackToCA()
{
  if (CelestialShouldAllowHTPCIOSurfacesForHDRPlaybackToCA_once != -1) {
    dispatch_once(&CelestialShouldAllowHTPCIOSurfacesForHDRPlaybackToCA_once, &__block_literal_global_80);
  }
  return CelestialShouldAllowHTPCIOSurfacesForHDRPlaybackToCA_result;
}

void __CelestialShouldAllowHTPCIOSurfacesForHDRPlaybackToCA_block_invoke()
{
  CFDictionaryRef v0 = (const __CFDictionary *)MGCopyAnswer();
  if (v0)
  {
    CFDictionaryRef v1 = v0;
    CFStringRef v2 = (const void *)*MEMORY[0x1E4F1CFD0];
    if (v2 == CFDictionaryGetValue(v0, @"buffer-compression")
      && v2 == CFDictionaryGetValue(v1, @"media-compression"))
    {
      CelestialShouldAllowHTPCIOSurfacesForHDRPlaybackToCA_uint64_t result = 1;
    }
    CFRelease(v1);
  }
}

uint64_t FigIsAirplaydEnabled()
{
  if (FigIsAirplaydEnabled_once != -1) {
    dispatch_once(&FigIsAirplaydEnabled_once, &__block_literal_global_92);
  }
  return FigIsAirplaydEnabled_result;
}

uint64_t __FigIsAirplaydEnabled_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  FigIsAirplaydEnabled_uint64_t result = result;
  return result;
}

uint64_t __getDeviceClass_block_invoke()
{
  uint64_t result = MGGetSInt32Answer();
  getDeviceClass_deviceClass = result;
  return result;
}

uint64_t FigOSTransactionCreateWithProcessName(const char *a1, const char *a2, uint64_t a3, const __CFURL *a4, uint64_t a5)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = 0;
  CFTypeRef cf = 0;
  memset(v79, 0, 128);
  unint64_t v35 = 0;
  CFMutableDictionaryRef v36 = 0;
  long long v77 = 0u;
  memset(v78, 0, sizeof(v78));
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v64 = 0u;
  long long v63 = 0u;
  long long v62 = 0u;
  long long v61 = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  long long v58 = 0u;
  long long v57 = 0u;
  long long v56 = 0u;
  long long v55 = 0u;
  long long v54 = 0u;
  long long v53 = 0u;
  long long v52 = 0u;
  long long v51 = 0u;
  long long v50 = 0u;
  long long v49 = 0u;
  long long v48 = 0u;
  qmemcpy(v47, "n/a", sizeof(v47));
  time_t v10 = time(0);
  unsigned int v34 = 0;
  CFStringRef theString = 0;
  memset(buffer, 0, sizeof(buffer));
  if (!a1)
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    uint64_t v18 = 0;
    goto LABEL_42;
  }
  time_t v30 = v10;
  unsigned int v11 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigOSTransactionUtilities[1], @"figostransactionutilities_trace", @"com.apple.coremedia", (uint64_t)"playback-memory", (uint64_t)"com.apple.coremedia", v11, 0, gFigOSTransactionUtilities);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1E9272F18, @"figostransactionutilities_trace", @"com.apple.coremedia", (uint64_t)"playback-memory", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1E9272F10);
  if ((int)a3 < 1 || a5)
  {
    CMTime v12 = a2;
    CMTime v13 = a1;
    if ((int)a3 < 1) {
      goto LABEL_9;
    }
  }
  else
  {
    FigServer_CopyProcessName(a3, (CFStringRef *)&cf);
    FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer((const char *)cf, v79, 128, 0x600u);
    CMTime v12 = a2;
    CMTime v13 = a1;
  }
  FigApplicationStateMonitorGetHostPIDIfAvailable(a3, (int *)&v34);
  if ((int)v34 >= 1)
  {
    FigServer_CopyProcessName(v34, &theString);
    if (theString) {
      CFStringGetCString(theString, (char *)buffer, 128, 0x600u);
    }
  }
LABEL_9:
  if (a4)
  {
    if (FigIsItOKToLogURLs())
    {
      CFStringRef v14 = CFURLGetString(a4);
      if (v14) {
        CFStringGetCString(v14, v47, 512, 0x8000100u);
      }
    }
    else
    {
      CFStringRef v15 = CFURLCopyScheme(a4);
      if (v15)
      {
        CFStringRef v16 = v15;
        CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@://<redacted>", v15);
        CFStringGetCString(v17, v47, 512, 0x8000100u);
        if (v17) {
          CFRelease(v17);
        }
        CFRelease(v16);
      }
    }
  }
  if (!v34 || v34 == a3) {
    asprintf(&v37, "%ld %s %s %d:%s ");
  }
  else {
    asprintf(&v37, "%ld %s %s %d->%d:%s->%s ", v30);
  }
  asprintf(&v36, "%s %s", v37, v47);
  uint64_t v18 = os_transaction_create();
  if (!v18)
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_42;
  }
  if (sFigOSTransactions != -1) {
    dispatch_once(&sFigOSTransactions, &__block_literal_global_28);
  }
  CFTypeRef v19 = FigCFWeakReferenceHolderCreateWithReferencedObject(v18);
  FigSimpleMutexLock((pthread_mutex_t *)qword_1EB28BA40);
  figPruneOSTransactionArrayWhilePerformingOperation(0);
  CFArrayAppendValue((CFMutableArrayRef)qword_1EB28BA38, v19);
  if (!a4)
  {
    if (!dword_1E9272F18) {
      goto LABEL_40;
    }
    int v32 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F10, 1, &v32, &type);
    int v23 = v32;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v27 = v23;
    }
    else {
      unsigned int v27 = v23 & 0xFFFFFFFE;
    }
    if (v27)
    {
      int v39 = 136315650;
      int v40 = "FigOSTransactionCreateWithProcessName";
      __int16 v41 = 2048;
      CFTypeRef v42 = v19;
      __int16 v43 = 2080;
      uint64_t v44 = v37;
      goto LABEL_37;
    }
LABEL_38:
    unsigned __int16 v28 = 0;
    goto LABEL_39;
  }
  CFURLRef v20 = v37;
  CFHashCode v21 = CFHash(a4);
  asprintf(&v35, "%s %lu", v20, v21);
  if (!dword_1E9272F18) {
    goto LABEL_40;
  }
  int v32 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  int v22 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F10, 1, &v32, &type);
  int v23 = v32;
  if (os_log_type_enabled(v22, type)) {
    unsigned int v25 = v23;
  }
  else {
    unsigned int v25 = v23 & 0xFFFFFFFE;
  }
  if (!v25) {
    goto LABEL_38;
  }
  int v39 = 136315650;
  int v40 = "FigOSTransactionCreateWithProcessName";
  __int16 v41 = 2048;
  CFTypeRef v42 = v19;
  __int16 v43 = 2080;
  uint64_t v44 = v35;
LABEL_37:
  unsigned __int16 v28 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v23) = v32;
LABEL_39:
  fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F10, 1u, 1, v28, v28 != &v45, v23, 0, v24);
LABEL_40:
  FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EB28BA40);
  FigPerformanceMonitorUpdateOSTransactionData(v19, v13, v12, a3);
  if (v19) {
    CFRelease(v19);
  }
LABEL_42:
  free(v36);
  free(v37);
  free(v35);
  if (cf) {
    CFRelease(cf);
  }
  if (theString) {
    CFRelease(theString);
  }
  return v18;
}

void figPruneOSTransactionArrayWhilePerformingOperation(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFArrayGetCount((CFArrayRef)qword_1EB28BA38);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    CFIndex v4 = 0;
    do
    {
      CFNumberRef ValueAtIndex = (id *)CFArrayGetValueAtIndex((CFArrayRef)qword_1EB28BA38, v4);
      int v6 = FigCFWeakReferenceHolderCopyReferencedObject(ValueAtIndex);
      if (v6)
      {
        size_t v7 = v6;
        if (a1) {
          (*(void (**)(uint64_t, id *))(a1 + 16))(a1, v6);
        }
        ++v4;
        os_release(v7);
      }
      else
      {
        if (dword_1E9272F18)
        {
          v14[0] = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F10, 1, v14, &type);
          int v9 = v14[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v11 = v9;
          }
          else {
            unsigned int v11 = v9 & 0xFFFFFFFE;
          }
          if (v11)
          {
            v14[1] = 136315394;
            CFStringRef v15 = "figPruneOSTransactionArrayWhilePerformingOperation";
            __int16 v16 = 2048;
            CFStringRef v17 = ValueAtIndex;
            CMTime v12 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v9) = v14[0];
          }
          else
          {
            CMTime v12 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F10, 1u, 1, v12, v12 != &v18, v9, 0, v10);
        }
        CFArrayRemoveValueAtIndex((CFMutableArrayRef)qword_1EB28BA38, v4);
        --v3;
      }
    }
    while (v4 < v3);
  }
}

uint64_t FigOSTransactionCreate(const char *a1, const char *a2, uint64_t a3, const __CFURL *a4)
{
  return FigOSTransactionCreateWithProcessName(a1, a2, a3, a4, 0);
}

CFMutableArrayRef FigOSTransactionCopyDescriptions(const __CFAllocator *a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  if (sFigOSTransactions != -1) {
    dispatch_once(&sFigOSTransactions, &__block_literal_global_28);
  }
  FigSimpleMutexLock((pthread_mutex_t *)qword_1EB28BA40);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = __FigOSTransactionCopyDescriptions_block_invoke;
  v4[3] = &__block_descriptor_tmp_32;
  void v4[4] = a1;
  v4[5] = Mutable;
  figPruneOSTransactionArrayWhilePerformingOperation((uint64_t)v4);
  FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EB28BA40);
  return Mutable;
}

void __FigOSTransactionCopyDescriptions_block_invoke(uint64_t a1)
{
  CFStringRef v2 = (char *)os_transaction_copy_description();
  CFStringRef v3 = CFStringCreateWithCString(*(CFAllocatorRef *)(a1 + 32), v2, 0x8000100u);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v3);
  if (v3) {
    CFRelease(v3);
  }

  free(v2);
}

pthread_mutex_t *figOSTransactionsInitializer_block_invoke()
{
  qword_1EB28BA38 = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  uint64_t result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  qword_1EB28BA40 = (uint64_t)result;
  return result;
}

uint64_t FigCustomURLHandlerRemoteClientCreateWithXPCEndpoint(uint64_t a1, uint64_t a2)
{
  uint64_t result = FigXPCRemoteClientCreateWithXPCEndpoint((uint64_t)"customURLHandler", a1, (uint64_t)&FigCustomURLHandlerRemoteClientCreateWithXPCEndpoint_sFigCustomURLHandlerRemoteClientCallbacks, 0, a2);
  if (result)
  {
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t figCustomURLHandlerRemote_DeadConnectionCallback(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  uint64_t result = FigCustomURLHandlerGetTypeID();
  if (v2 == result)
  {
    uint64_t result = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    *(unsigned char *)(result + 40) = 1;
  }
  return result;
}

uint64_t figCustomURLHandlerRemote_MessageHandler(uint64_t a1, void *a2)
{
  int v15 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v15);
  if (!OpCode && v15 == 1667777603)
  {
    if (dataCallbackMessageRec_getCFAllocator_sOnceToken != -1) {
      dispatch_once_f(&dataCallbackMessageRec_getCFAllocator_sOnceToken, &dataCallbackMessageRec_getCFAllocator_sAllocator, (dispatch_function_t)dataCallbackMessageRec_initializeCFAllocatorOnce);
    }
    CFAllocatorRef v5 = (const __CFAllocator *)dataCallbackMessageRec_getCFAllocator_sAllocator;
    if (dataCallbackMessageRec_getCFAllocator_sAllocator
      || (OpCFIndex Code = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0), !OpCode))
    {
      int v6 = (const UInt8 *)malloc_type_calloc(1uLL, 8uLL, 0x80040B8603338uLL);
      if (v6)
      {
        size_t v7 = v6;
        CFDataRef v8 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, 8, v5);
        if (v8)
        {
          CFDataRef v9 = v8;
          *size_t v7 = FigXPCRetain(a2);
          uint64_t int64 = xpc_dictionary_get_uint64(a2, "CustomURLHandler_RequestID");
          uint64_t v11 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
          if (v11) {
            uint64_t v12 = v11;
          }
          else {
            uint64_t v12 = 0;
          }
          CMTime v13 = *(uint64_t (**)(uint64_t, uint64_t, void (*)(uint64_t, uint64_t, const __CFData *, int, const void *, const void *, const void *, NSObject *, uint64_t, CFTypeRef), CFDataRef))(v12 + 56);
          if (v13) {
            OpCFIndex Code = v13(a1, uint64, figCustomURLHandler_handleDataCallbackMessageWithRegisteredRequestInfo, v9);
          }
          else {
            OpCFIndex Code = 4294954514;
          }
          CFRelease(v9);
          return OpCode;
        }
        free(v7);
      }
      return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
  }
  return OpCode;
}

uint64_t FigCustomURLHandlerRemoteClientCopyExistingOrCreateIfNeccessaryWithXPCEndpoint(int a1, uint64_t a2, void *a3)
{
  if (FigCustomURLHandlerRemoteClientCopyExistingOrCreateIfNeccessaryWithXPCEndpoint_sFigCustomURLRemoteXPCRemoteClientByPIDMutexRegisterOnce != -1) {
    dispatch_once(&FigCustomURLHandlerRemoteClientCopyExistingOrCreateIfNeccessaryWithXPCEndpoint_sFigCustomURLRemoteXPCRemoteClientByPIDMutexRegisterOnce, &__block_literal_global_29);
  }
  if (gFigCustomURLRemoteXPCRemoteClientByPIDTable)
  {
    FigSimpleMutexLock((pthread_mutex_t *)gFigCustomURLRemoteXPCRemoteClientByPIDMutex);
    id v10 = FigCFWeakReferenceTableCopyValue(gFigCustomURLRemoteXPCRemoteClientByPIDTable, (void *)a1);
    if (v10)
    {
      uint64_t v6 = 0;
LABEL_10:
      FigSimpleMutexUnlock((pthread_mutex_t *)gFigCustomURLRemoteXPCRemoteClientByPIDMutex);
      *a3 = v10;
      return v6;
    }
    if (a2)
    {
      if (!FigXPCRemoteClientCreateWithXPCEndpoint((uint64_t)"customURLHandler", a2, (uint64_t)&FigCustomURLHandlerRemoteClientCopyExistingOrCreateIfNeccessaryWithXPCEndpoint_sFigCustomURLHandlerRemoteClientCallbacks, 0, (uint64_t)&v10))
      {
        FigCFWeakReferenceTableRemoveValue(gFigCustomURLRemoteXPCRemoteClientByPIDTable, a1);
        uint64_t v7 = FigCFWeakReferenceTableAddValueAssociatedWithKey(gFigCustomURLRemoteXPCRemoteClientByPIDTable, (uint64_t)v10, a1);
LABEL_9:
        uint64_t v6 = v7;
        goto LABEL_10;
      }
      uint64_t v9 = 4294954510;
    }
    else
    {
      uint64_t v9 = 4294954516;
    }
    uint64_t v7 = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }

  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t __FigCustomURLHandlerRemoteClientCopyExistingOrCreateIfNeccessaryWithXPCEndpoint_block_invoke()
{
  gFigCustomURLRemoteXPCRemoteClientByPIDMutex = (uint64_t)FigSimpleMutexCreate();
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];

  return FigCFWeakReferenceTableCreate(v0, 1, &gFigCustomURLRemoteXPCRemoteClientByPIDTable);
}

uint64_t FigCustomURLHandlerRemoteCreateWithID(const void *a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  CFTypeRef cf = 0;
  int v14 = 0;
  if (!a2) {
    return 4294954516;
  }
  CFDataRef v8 = (const void *)*MEMORY[0x1E4F1CF80];
  ClassID = (void *)FigCustomURLHandlerGetClassID();
  uint64_t ServerPID = CMDerivedObjectCreate((uint64_t)v8, (uint64_t)&kFigCustomURLHandlerRemote_VTable, ClassID, &cf);
  if (ServerPID
    || (uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf),
        *(void *)(DerivedStorage + 24) = dispatch_queue_create("com.apple.coremedia.customurlhandler.remotehandler", 0), uint64_t ServerPID = FigXPCRemoteClientGetServerPID((uint64_t)a2, &v14), ServerPID))
  {
    uint64_t v12 = ServerPID;
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    *(_DWORD *)(DerivedStorage + 8) = v14;
    *(void *)(DerivedStorage + 32) = a1;
    *(void *)uint64_t DerivedStorage = CFRetain(a2);
    FigXPCRemoteClientAssociateObject((uint64_t)a2, (uint64_t)cf, a1);
    uint64_t v12 = FigCustomURLHandlerCreate(v8, "FigCustomURLHandlerRemoteShim", (uint64_t)cf, *(NSObject **)(DerivedStorage + 24), (uint64_t)&FigCustomURLHandlerRemoteCreateWithID_sFigCustomURLHandlerRemoteCallbacks, a3, (CFTypeRef *)(DerivedStorage + 16));
    *a4 = cf;
  }
  return v12;
}

void figCustomURLHandlerRemote_shimHandleRequestCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4, void (*a5)(uint64_t, void, uint64_t), uint64_t a6)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  *(void *)int v23 = 0;
  if (*(unsigned char *)(DerivedStorage + 40))
  {
    CFTypeRef v19 = 0;
    uint64_t v16 = 4294949923;
    goto LABEL_21;
  }
  uint64_t v11 = DerivedStorage;
  uint64_t v12 = FigXPCCreateBasicMessage(0x63684852u, *(void *)(DerivedStorage + 32), v23);
  if (v12)
  {
    uint64_t v16 = v12;
LABEL_34:
    CFTypeRef v19 = 0;
    goto LABEL_21;
  }
  CFTypeRef cf = 0;
  if (*(unsigned char *)(v11 + 40))
  {
    uint64_t v16 = 4294949923;
    goto LABEL_34;
  }
  uint64_t NSSecureCodingTypesSerializable = FigCustomURLRequestInfoCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a3, &cf);
  if (NSSecureCodingTypesSerializable) {
    goto LABEL_25;
  }
  int v14 = (__CFDictionary *)cf;
  uint64_t value = 0;
  uint64_t v25 = 0;
  uint64_t v15 = FigCustomURLRequestInfoCopyCryptor((const __CFDictionary *)cf, (const void **)&value);
  if (v15 == -17360)
  {
    uint64_t v16 = 0;
    goto LABEL_11;
  }
  uint64_t v16 = v15;
  if (!v15)
  {
    uint64_t IDForCryptorByAssociatingWithClientPID = FigCPECryptorServerGetIDForCryptorByAssociatingWithClientPID(value, *(_DWORD *)(v11 + 8), &v25);
    if (IDForCryptorByAssociatingWithClientPID
      || (uint64_t IDForCryptorByAssociatingWithClientPID = FigCustomURLRequestInfoSetCryptorID(v14, v25),
          IDForCryptorByAssociatingWithClientPID))
    {
      uint64_t v16 = IDForCryptorByAssociatingWithClientPID;
    }
    else
    {
      uint64_t v16 = FigCustomURLRequestInfoSetCryptor(v14, 0);
      if (!v16) {
        goto LABEL_11;
      }
    }
    FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
LABEL_11:
  if (value) {
    CFRelease(value);
  }
  if (v16) {
    goto LABEL_32;
  }
  uint64_t v18 = FigCustomURLRequestInfoSetNetworkHistory((__CFDictionary *)cf, 0);
  if (v18)
  {
    uint64_t v16 = v18;
    FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
LABEL_32:
    if (cf) {
      CFRelease(cf);
    }
    goto LABEL_34;
  }
  uint64_t NSSecureCodingTypesSerializable = FigCustomURLRequestInfoMakeNSSecureCodingTypesSerializable((const __CFDictionary *)cf);
  if (NSSecureCodingTypesSerializable)
  {
LABEL_25:
    uint64_t v16 = NSSecureCodingTypesSerializable;
    goto LABEL_32;
  }
  CFTypeRef v19 = cf;
  xpc_dictionary_set_uint64(*(xpc_object_t *)v23, "CustomURLHandler_RequestID", a4);
  FigXPCMessageSetCFDictionary(*(void **)v23, "CustomURLHandler_RequestInfo", v19);
  uint64_t v20 = *(void *)v11;
  v22[0] = MEMORY[0x1E4F143A8];
  v22[1] = 0x40000000;
  v22[2] = __figCustomURLHandlerRemote_shimHandleRequestCallback_block_invoke;
  v22[3] = &__block_descriptor_tmp_7_5;
  v22[4] = a5;
  v22[5] = a6;
  uint64_t v21 = FigXPCRemoteClientSendAsyncMessageWithNoTimeoutWithReplyHandler(v20, *(void **)v23, (uint64_t)v22);
  if (!v21) {
    goto LABEL_22;
  }
  uint64_t v16 = v21;
  if (v19)
  {
    uint64_t value = 0;
    if (!*(unsigned char *)(v11 + 40) && !FigCustomURLRequestInfoGetCryptorID((uint64_t)v19, &value)) {
      FigCPECryptorServerDisassociateCryptorWithClientPID((uint64_t)value, *(_DWORD *)(v11 + 8));
    }
  }
LABEL_21:
  a5(a6, 0, v16);
LABEL_22:
  FigXPCRelease(*(xpc_object_t *)v23);
  if (v19) {
    CFRelease(v19);
  }
}

void figCustomURLHandlerRemote_shimCancelRequestCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  xpc_object_t xdict = 0;
  CFTypeRef cf = 0;
  if (!*(unsigned char *)(DerivedStorage + 40))
  {
    uint64_t v7 = DerivedStorage;
    if (!FigCustomURLRequestInfoCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a3, &cf))
    {
      uint64_t v8 = FigCustomURLRequestInfoSetNetworkHistory((__CFDictionary *)cf, 0);
      if (v8)
      {
        FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
      }
      else if (!FigCustomURLRequestInfoMakeNSSecureCodingTypesSerializable((const __CFDictionary *)cf) {
             && !FigXPCCreateBasicMessage(0x63684352u, *(void *)(v7 + 32), &xdict))
      }
      {
        xpc_dictionary_set_uint64(xdict, "CustomURLHandler_RequestID", a4);
        FigXPCMessageSetCFDictionary(xdict, "CustomURLHandler_RequestInfo", cf);
        FigXPCRemoteClientSendAsyncMessage(*(void *)v7, xdict);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  FigXPCRelease(xdict);
}

void figCustomURLHandler_handleDataCallbackMessageWithRegisteredRequestInfo(uint64_t a1, uint64_t a2, const __CFData *a3, int a4, const void *a5, const void *a6, const void *a7, NSObject *a8, uint64_t a9, CFTypeRef a10)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  CFTypeRef v43 = 0;
  CFTypeRef v44 = 0;
  CFTypeRef v41 = 0;
  CFTypeRef v42 = 0;
  CFTypeRef cf = 0;
  BytePtr = (void **)CFDataGetBytePtr(a3);
  if (a4) {
    goto LABEL_35;
  }
  CFTypeRef v19 = *BytePtr;
  CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (!FigXPCMessageCreateBlockBufferData((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *BytePtr, "CustomURLHandler_BlockBuffer", (CMBlockBufferRef *)&v42))
  {
    uint64_t int64 = xpc_dictionary_get_uint64(v19, "CustomURLHandler_CallbackFlags");
    if (!FigXPCMessageCopyCFError(v19, "CustomURLHandler_Error", (const __CFDictionary **)&v41))
    {
      char v22 = uint64;
      if ((uint64 & 1) == 0 || !FigXPCMessageCopyCFDictionary(v19, "CustomURLHandler_FinalReport", &cf))
      {
        if (a6
          || !FigXPCMessageCopyCFDictionary(v19, "CustomURLHandler_ResponseInfo", &v44)
          && (!v44
           || !FigCustomURLResponseInfoCreateMutableCopy(v20, (CFDictionaryRef)v44, (CFMutableDictionaryRef *)&v43)&& !FigCustomURLResponseInfoDeserializeNSSecureCodingTypes((void *)v43)&& ((uint64_t v28 = *(void *)(DerivedStorage + 16), v29 = v43, (v30 = *(void *)(CMBaseObjectGetVTable(v28) + 16)) == 0)? (v31 = 0): (v31 = v30), (v39 = *(unsigned int (**)(uint64_t, uint64_t, CFTypeRef))(v31 + 8)) != 0&& !v39(v28, a2, v29))))
        {
          CFTypeRef v23 = v42;
          if (v42 || (uint64 & 0xFFFFFFFE) != 0 || (CFTypeRef v24 = v41) != 0 && (v22 & 1) == 0)
          {
            uint64_t v25 = *(void *)(DerivedStorage + 16);
            uint64_t v26 = *(void *)(CMBaseObjectGetVTable(v25) + 16);
            if (v26) {
              uint64_t v27 = v26;
            }
            else {
              uint64_t v27 = 0;
            }
            int v32 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef))(v27 + 16);
            if (!v32) {
              goto LABEL_33;
            }
            int v33 = v32(v25, a2, v23);
            if ((v22 & 1) == 0 || v33) {
              goto LABEL_33;
            }
            CFTypeRef v24 = v41;
          }
          else if ((v22 & 1) == 0)
          {
            goto LABEL_33;
          }
          uint64_t v34 = *(void *)(DerivedStorage + 16);
          CFTypeRef v35 = cf;
          uint64_t v36 = *(void *)(CMBaseObjectGetVTable(v34) + 16);
          if (v36) {
            uint64_t v37 = v36;
          }
          else {
            uint64_t v37 = 0;
          }
          unsigned int v38 = *(void (**)(uint64_t, uint64_t, CFTypeRef, CFTypeRef))(v37 + 24);
          if (v38) {
            v38(v34, a2, v24, v35);
          }
        }
      }
    }
  }
LABEL_33:
  if (cf) {
    CFRelease(cf);
  }
LABEL_35:
  if (v41) {
    CFRelease(v41);
  }
  if (v42) {
    CFRelease(v42);
  }
  if (v44) {
    CFRelease(v44);
  }
  if (v43) {
    CFRelease(v43);
  }
  if (a5) {
    CFRelease(a5);
  }
  if (a6) {
    CFRelease(a6);
  }
  if (a7) {
    CFRelease(a7);
  }
  if (a8) {
    dispatch_release(a8);
  }
  if (a10) {
    CFRelease(a10);
  }
}

uint64_t dataCallbackMessageRec_initializeCFAllocatorOnce(void *a1)
{
  CFTypeRef v3 = 0;
  uint64_t result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))dataCallbackMessageRec_dealloc, &v3);
  if (!result) {
    *a1 = v3;
  }
  return result;
}

void dataCallbackMessageRec_dealloc(xpc_object_t *a1)
{
  FigXPCRelease(*a1);

  free(a1);
}

uint64_t figCustomURLHandlerRemote_Invalidate(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = *(void *)(DerivedStorage + 16);
  if (!v2) {
    return 4294954516;
  }
  uint64_t v3 = *(void *)(CMBaseObjectGetVTable(*(void *)(DerivedStorage + 16)) + 8);
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t))(v4 + 24);
  if (!v6) {
    return 4294954514;
  }

  return v6(v2);
}

void figCustomURLHandlerRemote_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v3 = *(const void **)(DerivedStorage + 32);
  uint64_t v6 = 0;
  figCustomURLHandlerRemote_Invalidate(a1);
  if (!*(unsigned char *)(DerivedStorage + 40))
  {
    if (!*(void *)DerivedStorage) {
      goto LABEL_7;
    }
    FigXPCRemoteClientDisassociateObject(*(void *)DerivedStorage, v3);
    if (!FigXPCCreateBasicMessage(0x63684469u, (uint64_t)v3, &v6)) {
      FigXPCRemoteClientSendAsyncMessage(*(void *)DerivedStorage, v6);
    }
  }
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
LABEL_7:
  uint64_t v4 = *(const void **)(DerivedStorage + 16);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(DerivedStorage + 16) = 0;
  }
  CFAllocatorRef v5 = *(NSObject **)(DerivedStorage + 24);
  if (v5)
  {
    dispatch_release(v5);
    *(void *)(DerivedStorage + 24) = 0;
  }
  FigXPCRelease(v6);
}

uint64_t figCustomURLHandlerRemote_HandleRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = *(void *)(CMBaseObjectGetDerivedStorage(a1) + 16);
  uint64_t v16 = *(void *)(CMBaseObjectGetVTable(v15) + 16);
  if (v16) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v17 + 32);
  if (!v18) {
    return 4294954514;
  }

  return v18(v15, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t figCustomURLHandlerRemote_CancelRequest(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage(a1) + 16);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(v3) + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 40);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t figCustomURLHandlerRemote_RequestSetDormant(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage(a1) + 16);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable(v5) + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48);
  if (!v8) {
    return 4294954514;
  }

  return v8(v5, a2, a3);
}

uint64_t figCustomURLHandlerRemote_lookupAndRetainRegisteredInfoForRequestID(const void *a1, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (remoteHandlerLookupAndRetainRec_getCFAllocator_sOnceToken != -1) {
    dispatch_once_f(&remoteHandlerLookupAndRetainRec_getCFAllocator_sOnceToken, &remoteHandlerLookupAndRetainRec_getCFAllocator_sAllocator, (dispatch_function_t)remoteHandlerLookupAndRetainRec_initializeCFAllocatorOnce);
  }
  CFAllocatorRef v9 = (const __CFAllocator *)remoteHandlerLookupAndRetainRec_getCFAllocator_sAllocator;
  if (!remoteHandlerLookupAndRetainRec_getCFAllocator_sAllocator)
  {
    uint64_t v20 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if (v20) {
      return v20;
    }
  }
  id v10 = (const UInt8 *)malloc_type_calloc(1uLL, 0x18uLL, 0xE0040C2B16B6AuLL);
  if (v10)
  {
    uint64_t v11 = (UInt8 *)v10;
    CFDataRef v12 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v10, 24, v9);
    if (v12)
    {
      CFDataRef v13 = v12;
      if (a1) {
        CFTypeRef v14 = CFRetain(a1);
      }
      else {
        CFTypeRef v14 = 0;
      }
      *(void *)uint64_t v11 = v14;
      *((void *)v11 + 1) = a3;
      if (a4) {
        CFTypeRef v15 = CFRetain(a4);
      }
      else {
        CFTypeRef v15 = 0;
      }
      *((void *)v11 + 2) = v15;
      uint64_t v16 = *(void *)(DerivedStorage + 16);
      uint64_t v17 = *(void *)(CMBaseObjectGetVTable(v16) + 16);
      if (v17) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = 0;
      }
      CFTypeRef v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t, CFDataRef, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), CFDataRef))(v18 + 56);
      if (v19) {
        uint64_t v20 = v19(v16, a2, figCustomURLHandlerRemote_shimLookupAndRetainRegisteredInfoCallback, v13);
      }
      else {
        uint64_t v20 = 4294954514;
      }
      CFRelease(v13);
      return v20;
    }
    free(v11);
  }

  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t figCustomURLHandlerRemote_shimLookupAndRetainRegisteredInfoCallback(int a1, uint64_t a2, CFDataRef theData, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  BytePtr = CFDataGetBytePtr(theData);
  uint64_t v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))*((void *)BytePtr + 1);
  uint64_t v19 = *((void *)BytePtr + 2);
  uint64_t v20 = *(void *)BytePtr;

  return v18(v20, a2, v19, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t remoteHandlerLookupAndRetainRec_initializeCFAllocatorOnce(void *a1)
{
  CFTypeRef v3 = 0;
  uint64_t result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))remoteHandlerLookupAndRetainRec_dealloc, &v3);
  if (!result) {
    *a1 = v3;
  }
  return result;
}

void remoteHandlerLookupAndRetainRec_dealloc(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = a1[2];
  if (v3) {
    CFRelease(v3);
  }

  free(a1);
}

uint64_t __figCustomURLHandlerRemote_shimHandleRequestCallback_block_invoke(uint64_t a1, uint64_t a2, xpc_object_t xdict)
{
  if (a2) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = xpc_dictionary_get_BOOL(xdict, "CustomURLHandler_CanHandleResult");
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, BOOL, uint64_t))(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);

  return v7(v6, v5, a2);
}

void *NeroValeriaListenerCreate(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!in_audio_mx_server_process() || !FigIsAirplaydEnabled()) {
    return 0;
  }
  if (a1)
  {
    uint64_t v2 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 0x40000000;
    _OWORD v20[2] = __NeroValeriaListenerCreate_block_invoke;
    v20[3] = &unk_1E5679988;
    v20[4] = a1;
    v20[5] = v2;
    *((void *)v2 + 1) = dispatch_queue_create("com.apple.coremedia.NeroValeriaListener", 0);
    uint64_t v3 = *MEMORY[0x1E4F1CF80];
    int started = FigTransportConnectionUSBCreate(*MEMORY[0x1E4F1CF80], &cf);
    if (started)
    {
LABEL_5:
      int v5 = started;
      goto LABEL_15;
    }
    uint64_t CMBaseObject = NeroTransportConnectionGetCMBaseObject(cf);
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    CFAllocatorRef v9 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(v8 + 56);
    if (v9)
    {
      int started = v9(CMBaseObject, @"USBInterfaceName", @"Valeria");
      if (!started)
      {
        int started = NeroTransportCreate(v3, cf, (uint64_t *)v2);
        if (!started)
        {
          uint64_t v10 = *(void *)v2;
          LocalRootObject = (const void *)FigTransportGetLocalRootObject();
          int started = NeroTransportRegisterObject(v10, LocalRootObject, *((NSObject **)v2 + 1), v20, 0);
          if (!started) {
            int started = NeroTransportStartAcceptingConnections(*(void *)v2);
          }
        }
      }
      goto LABEL_5;
    }
    int v5 = -12782;
  }
  else
  {
    uint64_t v2 = 0;
    int v5 = -12780;
  }
LABEL_15:
  if (cf) {
    CFRelease(cf);
  }
  if (v5)
  {
    int v19 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, &v19, &type);
    int v13 = v19;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v15 = v13;
    }
    else {
      unsigned int v15 = v13 & 0xFFFFFFFE;
    }
    if (v15)
    {
      int v22 = 136315394;
      CFTypeRef v23 = "NeroValeriaListenerCreate";
      __int16 v24 = 1024;
      int v25 = v5;
      uint64_t v16 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v13) = v19;
    }
    else
    {
      uint64_t v16 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v16, v16 != &v26, v13, 0, v14);
    NeroValeriaListenerDestroy((CFTypeRef *)v2);
    return 0;
  }
  return v2;
}

void __NeroValeriaListenerCreate_block_invoke(uint64_t a1, int a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2 == 1684628836)
  {
    v10[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v10, &type);
    int v5 = v10[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v7 = v5;
    }
    else {
      unsigned int v7 = v5 & 0xFFFFFFFE;
    }
    if (v7)
    {
      v10[1] = 136315138;
      uint64_t v11 = "NeroValeriaListenerCreate_block_invoke";
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v10[0];
    }
    else
    {
      uint64_t v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v8, v8 != &v12, v5, 0, v6);
  }
  else if (a2 == 1651470958)
  {
    NeroTransportStopAcceptingConnections(**(void **)(a1 + 40));
    uint64_t v3 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    v3();
  }
}

void NeroValeriaListenerDestroy(CFTypeRef *a1)
{
  if (a1)
  {
    CFTypeRef v2 = *a1;
    if (v2)
    {
      NeroTransportInvalidate((uint64_t)v2);
      if (*a1)
      {
        CFRelease(*a1);
        *a1 = 0;
      }
    }
    uint64_t v3 = a1[1];
    if (v3) {
      dispatch_release(v3);
    }
    free(a1);
  }
}

void NeroValeriaListenerSetActiveStatus(uint64_t a1, char a2)
{
  if (a1)
  {
    CFTypeRef v2 = *(NSObject **)(a1 + 8);
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 0x40000000;
    v3[2] = __NeroValeriaListenerSetActiveStatus_block_invoke;
    v3[3] = &__block_descriptor_tmp_3_1;
    char v4 = a2;
    unint64_t v3[4] = a1;
    dispatch_async(v2, v3);
  }
}

uint64_t __NeroValeriaListenerSetActiveStatus_block_invoke(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v2 = **(void **)(a1 + 32);
  if (v1) {
    return NeroTransportStartAcceptingConnections(v2);
  }
  else {
    return NeroTransportStopAcceptingConnections(v2);
  }
}

uint64_t FigTransportSessionGetClassID()
{
  if (FigTransportSessionGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigTransportSessionGetClassID_sRegisterOnce, &FigTransportSessionGetClassID_sClassID, (dispatch_function_t)session_getClassID);
  }
  return FigTransportSessionGetClassID_sClassID;
}

uint64_t session_getClassID(void *a1)
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&session_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigTransportSessionGetTypeID()
{
  if (FigTransportSessionGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigTransportSessionGetClassID_sRegisterOnce, &FigTransportSessionGetClassID_sClassID, (dispatch_function_t)session_getClassID);
  }
  CFAllocatorRef v0 = (void *)FigTransportSessionGetClassID_sClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFStringRef session_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigTransportSession %p]", a1);
}

uint64_t FigEndpointStreamAirPlayGetClassID()
{
  if (FigEndpointStreamAirPlayGetClassID_sRegisterFigEndpointStreamAirPlayBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointStreamAirPlayGetClassID_sRegisterFigEndpointStreamAirPlayBaseTypeOnce, &FigEndpointStreamAirPlayGetClassID_sFigEndpointStreamAirPlayClassID, (dispatch_function_t)FigEndpointStreamAirPlayGetClassIDCallback);
  }
  return FigEndpointStreamAirPlayGetClassID_sFigEndpointStreamAirPlayClassID;
}

uint64_t FigEndpointStreamAirPlayGetClassIDCallback(void *a1)
{
  ClassID = (void *)FigEndpointStreamGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&FigEndpointStreamAirPlayGetClassIDCallback_sFigEndpointStreamAirPlayClassDesc, ClassID, 0, a1);
}

CFStringRef FigEndpointStreamAirPlayBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpointStreamAirPlay %p]", a1);
}

uint64_t FigAudioDeviceClockServerStart()
{
  v2[0] = 1;
  v2[1] = HandleAudioDeviceClockMessage;
  long long v3 = 0u;
  long long v4 = 0u;
  if (FigServer_IsMediaparserd()) {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  if (FigServer_IsMediaplaybackd()) {
    int v1 = "com.apple.coremedia.mediaplaybackd.audiodeviceclock.xpc";
  }
  else {
    int v1 = "com.apple.coremedia.audiodeviceclock.xpc";
  }
  return FigXPCServerStart((uint64_t)v1, v2, 0, &gAudioDeviceClockServer);
}

uint64_t HandleAudioDeviceClockMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  CFTypeRef cf = 0;
  int v19 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v19);
  if (OpCode) {
    goto LABEL_33;
  }
  if (v19 == 1668441400)
  {
    clockTimeOut.CMTime value = 0;
    clockOut.CMTime value = 0;
    value.CMTime value = 0;
    AudioDeviceID int64 = xpc_dictionary_get_int64(a2, "DeviceID");
    uint64_t v8 = FigXPCMessageCopyCFString(a2, "DeviceUID", &clockTimeOut);
    if (v8)
    {
      uint64_t AnchorTime = v8;
    }
    else
    {
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (int64) {
        uint64_t v10 = CMAudioDeviceClockCreateFromAudioDeviceID(v9, int64, (CMClockRef *)&clockOut);
      }
      else {
        uint64_t v10 = CMAudioDeviceClockCreate(v9, (CFStringRef)clockTimeOut.value, (CMClockRef *)&clockOut);
      }
      uint64_t AnchorTime = v10;
      if (!v10)
      {
        uint64_t AnchorTime = FigXPCServerAssociateObjectWithConnection(a1, (const void *)clockOut.value, 0, 0, 0, (unint64_t *)&value);
        if (!AnchorTime) {
          xpc_dictionary_set_uint64(a3, ".objectID", value.value);
        }
      }
    }
    if (clockTimeOut.value) {
      CFRelease((CFTypeRef)clockTimeOut.value);
    }
    if (clockOut.value) {
      CFRelease((CFTypeRef)clockOut.value);
    }
    goto LABEL_29;
  }
  uAudioDeviceID int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  OpCFIndex Code = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, 0);
  if (OpCode) {
    goto LABEL_33;
  }
  if (!cf || (CFTypeID v12 = CFGetTypeID(cf), v12 != CMClockGetTypeID()))
  {
    OpCFIndex Code = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    goto LABEL_33;
  }
  uint64_t AnchorTime = 4294951138;
  if (v19 > 1734632821)
  {
    if (v19 != 1734632822)
    {
      if (v19 != 1735549300) {
        goto LABEL_29;
      }
      CFTypeRef v14 = cf;
      CMClockRef HostTimeClock = CMClockGetHostTimeClock();
      double RelativeRate = CMSyncGetRelativeRate(v14, HostTimeClock);
      xpc_dictionary_set_double(a3, "Rate", RelativeRate);
      goto LABEL_26;
    }
    clockTimeOut.CMTime value = 0;
    LODWORD(clockOut.CFDictionarySetValue(theDict, key, value) = 0;
    LOBYTE(value.CFDictionarySetValue(theDict, key, value) = 0;
    uint64_t AudioDevice = CMAudioDeviceClockGetAudioDevice((CMClockRef)cf, (CFStringRef *)&clockTimeOut, (AudioDeviceID *)&clockOut, (Boolean *)&value);
    OpCFIndex Code = FigXPCMessageSetCFString(a3, "DeviceUID", (CFTypeRef)clockTimeOut.value);
    if (!OpCode)
    {
      xpc_dictionary_set_int64(a3, "DeviceID", LODWORD(clockOut.value));
      xpc_dictionary_set_BOOL(a3, "TrackDefaultDevice", LOBYTE(value.value) != 0);
      xpc_dictionary_set_int64(a3, "LoadStatus", (int)AudioDevice);
      uint64_t AnchorTime = AudioDevice;
      goto LABEL_29;
    }
LABEL_33:
    uint64_t AnchorTime = OpCode;
    goto LABEL_29;
  }
  if (v19 == 1685024621)
  {
    FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_26:
    uint64_t AnchorTime = 0;
    goto LABEL_29;
  }
  if (v19 == 1734438507)
  {
    memset(&clockTimeOut, 0, sizeof(clockTimeOut));
    memset(&clockOut, 0, sizeof(clockOut));
    uint64_t AnchorTime = CMClockGetAnchorTime((CMClockRef)cf, &clockTimeOut, &clockOut);
    if (!AnchorTime)
    {
      CMTime value = clockTimeOut;
      FigXPCMessageSetCMTime(a3, "ClockTime", &value);
      CMTime value = clockOut;
      FigXPCMessageSetCMTime(a3, "RefClockTime", &value);
      xpc_dictionary_set_int64(a3, "LoadStatus", 0);
    }
  }
LABEL_29:
  if (cf) {
    CFRelease(cf);
  }
  return AnchorTime;
}

uint64_t FigXPCAudioDeviceClockServerAssociateCopiedNeighborClock(xpc_connection_t connection, const void *a2, void *a3)
{
  return FigXPCServerAssociateCopiedObjectWithNeighborProcess(gAudioDeviceClockServer, connection, a2, 0, 0, 0, a3);
}

uint64_t FigXPCAudioDeviceClockServerAssociateNeighborClock(xpc_connection_t connection, const void *a2, void *a3)
{
  return FigXPCServerAssociateObjectWithNeighborProcess(gAudioDeviceClockServer, connection, a2, 0, 0, 0, a3);
}

uint64_t FigXPCAudioDeviceClockServerCopyClockForID(void *a1, void *a2)
{
  return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gAudioDeviceClockServer, a1, a2);
}

uint64_t FigAudioDeviceClockServer_MakeWrapperForClock(const void *a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, void *a6)
{
  *a5 = 0;
  return FigXPCServerAssociateObjectWithNeighborProcessByPID(gAudioDeviceClockServer, a4, a1, 0, 0, 0, a6);
}

uint64_t FigAudioDeviceClockServer_MakeWrapperForClockWithManualCommandPortSendRightInsertion(const void *a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, void *a6)
{
  *a5 = 0;
  return FigXPCServerAssociateObjectWithNeighborProcessByPID(gAudioDeviceClockServer, a4, a1, 0, 0, 0, a6);
}

uint64_t FigAudioDeviceClockServer_LookupAndRetainSubClock(void *a1, void *a2)
{
  return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gAudioDeviceClockServer, a1, a2);
}

uint64_t CMGetDMVersionLevelFromRPU()
{
  CFDataRef v0 = (const __CFData *)MEMORY[0x1F4188790]();
  bzero(v4, 0x73B0uLL);
  if (!v0) {
    return 0;
  }
  size_t Length = CFDataGetLength(v0);
  BytePtr = CFDataGetBytePtr(v0);
  if (FigHEVCBridge_GetRPUMetadata(BytePtr, Length, (uint64_t)v4) || !v4[29130]) {
    return 0;
  }
  if (v5 <= 2u) {
    return v5 + 2;
  }
  return 0;
}

BOOL FigTagHasSInt64Value(uint64_t a1)
{
  return (a1 & 0xBFFFFFFF00000000) == 0x200000000;
}

Boolean CMTagHasSInt64Value(CMTag tag)
{
  return (*(void *)&tag.category & 0xBFFFFFFF00000000) == 0x200000000;
}

CMTagDataType CMTagGetValueDataType(CMTag tag)
{
  return tag.dataType & 0xBFFFFFFF;
}

uint64_t FigTagGetSInt64Value(uint64_t a1, uint64_t a2)
{
  return a2;
}

int64_t CMTagGetSInt64Value(CMTag tag)
{
  return tag.value;
}

BOOL FigTagHasFloat64Value(uint64_t a1)
{
  return (a1 & 0xBFFFFFFF00000000) == 0x300000000;
}

Boolean CMTagHasFloat64Value(CMTag tag)
{
  return (*(void *)&tag.category & 0xBFFFFFFF00000000) == 0x300000000;
}

double FigTagGetFloat64Value(uint64_t a1, uint64_t a2)
{
  return *(double *)&a2;
}

Float64 CMTagGetFloat64Value(CMTag tag)
{
  return *(double *)&tag.value;
}

BOOL FigTagHasOSTypeValue(uint64_t a1)
{
  return (a1 & 0xBFFFFFFF00000000) == 0x500000000;
}

Boolean CMTagHasOSTypeValue(CMTag tag)
{
  return (*(void *)&tag.category & 0xBFFFFFFF00000000) == 0x500000000;
}

uint64_t FigTagGetOSTypeValue(uint64_t a1, uint64_t a2)
{
  return a2;
}

OSType CMTagGetOSTypeValue(CMTag tag)
{
  return tag.value;
}

BOOL FigTagHasFlagsValue(uint64_t a1)
{
  return (a1 & 0xBFFFFFFF00000000) == 0x700000000;
}

Boolean CMTagHasFlagsValue(CMTag tag)
{
  return (*(void *)&tag.category & 0xBFFFFFFF00000000) == 0x700000000;
}

uint64_t FigTagGetFlagsValue(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t CMTagGetFlagsValue(CMTag tag)
{
  return tag.value;
}

uint64_t FigTagMakeWithSInt64Value(unsigned int a1)
{
  return a1 | 0x200000000;
}

CMTag CMTagMakeWithSInt64Value(CMTagCategory category, int64_t value)
{
  uint64_t v2 = category | 0x200000000;
  result.CMTime value = value;
  result.category = v2;
  result.dataType = HIDWORD(v2);
  return result;
}

uint64_t FigTagMakeWithFloat64Value(unsigned int a1)
{
  return a1 | 0x300000000;
}

CMTag CMTagMakeWithFloat64Value(CMTagCategory category, Float64 value)
{
  uint64_t v3 = category | 0x300000000;
  *(Float64 *)&result.CMTime value = value;
  result.category = v3;
  result.dataType = HIDWORD(v3);
  return result;
}

uint64_t FigTagMakeWithOSTypeValue(unsigned int a1)
{
  return a1 | 0x500000000;
}

CMTag CMTagMakeWithOSTypeValue(CMTagCategory category, OSType value)
{
  uint64_t v2 = value;
  uint64_t v3 = category | 0x500000000;
  result.category = v3;
  result.dataType = HIDWORD(v3);
  LODWORD(result.CFDictionarySetValue(theDict, key, value) = value;
  return result;
}

uint64_t FigTagMakeWithFlagsValue(unsigned int a1)
{
  return a1 | 0x700000000;
}

CMTag CMTagMakeWithFlagsValue(CMTagCategory category, uint64_t flagsForTag)
{
  uint64_t v2 = category | 0x700000000;
  result.CMTime value = flagsForTag;
  result.category = v2;
  result.dataType = HIDWORD(v2);
  return result;
}

CFHashCode CMTagHash(CMTag tag)
{
  CMTag v5 = tag;
  unsigned __int32 v4 = tag.dataType & 0xBFFFFFFF;
  if ((tag.dataType & 0xBFFFFFFF) != 0) {
    unint64_t v1 = _CMTagCFHashBytes((uint64_t)&v5.value, 8);
  }
  else {
    unint64_t v1 = 0x1000000;
  }
  unint64_t v2 = (_CMTagCFHashBytes((uint64_t)&v4, 4) + (v1 << 6) + (v1 >> 2) + 2654435769u) ^ v1;
  return (_CMTagCFHashBytes((uint64_t)&v5, 4) + (v2 << 6) + (v2 >> 2) + 2654435769u) ^ v2;
}

uint64_t _CMTagCFHashBytes(uint64_t a1, uint64_t a2)
{
  if ((int)a2 < 4)
  {
    unsigned int v2 = 0;
    unsigned int v9 = a2;
  }
  else
  {
    unsigned int v2 = 0;
    uint64_t v3 = (unsigned __int8 *)((a2 & 0xFFFFFFFF00000000) + a1 + 1);
    unsigned int v4 = a2;
    do
    {
      unsigned int v5 = *(v3 - 1) + 16 * v2;
      unsigned int v6 = *v3 + 16 * (v5 ^ (16 * (v5 >> 28)));
      unsigned int v7 = v3[1] + 16 * (v6 ^ (16 * (v6 >> 28)));
      int v8 = v3[2] + 16 * (v7 ^ (16 * (v7 >> 28)));
      unsigned int v2 = (v8 ^ ((v8 & 0xF0000000) >> 24)) & ~(v8 & 0xF0000000);
      unsigned int v9 = v4 - 4;
      v3 += 4;
      BOOL v10 = v4 > 7;
      v4 -= 4;
    }
    while (v10);
  }
  switch(v9)
  {
    case 1u:
      goto LABEL_11;
    case 2u:
LABEL_10:
      int v12 = *(unsigned __int8 *)(a2 + a1 - 2) + 16 * v2;
      unsigned int v2 = (v12 ^ ((v12 & 0xF0000000) >> 24)) & ~(v12 & 0xF0000000);
LABEL_11:
      int v13 = *(unsigned __int8 *)(a2 + a1 - 1) + 16 * v2;
      return (v13 ^ ((v13 & 0xF0000000) >> 24)) & ~(v13 & 0xF0000000);
    case 3u:
      int v11 = *(unsigned __int8 *)(a2 + a1 - 3) + 16 * v2;
      unsigned int v2 = (v11 ^ ((v11 & 0xF0000000) >> 24)) & ~(v11 & 0xF0000000);
      goto LABEL_10;
  }
  return v2;
}

BOOL FigTagEqualToTag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v5 = ((a3 ^ a1) & 0xBFFFFFFF00000000) == 0 && a2 == a4;
  return a1 == a3 && v5;
}

Boolean CMTagEqualToTag(CMTag tag1, CMTag tag2)
{
  Boolean v3 = ((*(void *)&tag2.category ^ *(void *)&tag1.category) & 0xBFFFFFFF00000000) == 0 && tag1.value == tag2.value;
  if (tag1.category == tag2.category) {
    return v3;
  }
  else {
    return 0;
  }
}

CFComparisonResult CMTagCompare(CMTag tag1, CMTag tag2)
{
  if ((int)tag1.category < (int)tag2.category) {
    return -1;
  }
  if (tag1.category != tag2.category) {
    return 1;
  }
  unsigned __int32 v3 = tag1.dataType & 0xBFFFFFFF;
  if ((int)(tag1.dataType & 0xBFFFFFFF) < (int)(tag2.dataType & 0xBFFFFFFF)) {
    return -1;
  }
  if (v3 != (tag2.dataType & 0xBFFFFFFF)) {
    return 1;
  }
  CFComparisonResult v4 = (unint64_t)(tag1.value > tag2.value);
  if (tag1.value < tag2.value) {
    CFComparisonResult v4 = kCFCompareLessThan;
  }
  CFComparisonResult v5 = (unint64_t)(*(double *)&tag1.value > *(double *)&tag2.value);
  if (*(double *)&tag1.value < *(double *)&tag2.value) {
    CFComparisonResult v5 = kCFCompareLessThan;
  }
  if (v3 == 3) {
    return v5;
  }
  else {
    return v4;
  }
}

CFStringRef CMTagCopyDescription(CFAllocatorRef allocator, CMTag tag)
{
  CMTagValue value = tag.value;
  unint64_t v3 = *(void *)&tag.category;
  CFMutableArrayRef Mutable = CFStringCreateMutable(allocator, 0);
  CFComparisonResult v5 = Mutable;
  if (Mutable)
  {
    unsigned int v9 = bswap32(v3);
    CFStringAppendFormat(Mutable, 0, @"{");
    CFStringAppendFormat(v5, 0, @"category:'%.4s'", &v9);
    unint64_t v6 = HIDWORD(v3);
    if (v6)
    {
      CFStringAppendFormat(v5, 0, @" value:");
      switch(v6 & 0xBFFFFFFF)
      {
        case 0uLL:
          CFStringAppendFormat(v5, 0, @"<invalid>", v8);
          break;
        case 2uLL:
          CFStringAppendFormat(v5, 0, @"%lld <int64>", value);
          break;
        case 3uLL:
          CFStringAppendFormat(v5, 0, @"%0.2f <Flt64>", value);
          break;
        case 5uLL:
          unsigned int v10 = bswap32(value);
          CFStringAppendFormat(v5, 0, @"'%.4s' <OSType>", &v10);
          break;
        case 7uLL:
          CFStringAppendFormat(v5, 0, @"0x%llx <flags>", value);
          break;
        default:
          CFStringAppendFormat(v5, 0, @"<raw:0x%0llu type:%d>", value, v6 & 0xBFFFFFFF);
          break;
      }
      CFStringAppendFormat(v5, 0, @"}");
    }
    else
    {
      CFStringAppendFormat(v5, 0, @"{INVALID}");
    }
  }
  return v5;
}

CFDictionaryRef CMTagCopyAsDictionary(CMTag tag, CFAllocatorRef allocator)
{
  CMTagValue value = tag.value;
  CMTagDataType dataType = tag.dataType;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)keys = xmmword_1E5679A88;
  CFTypeRef v14 = @"value";
  CFNumberRef SInt32 = 0;
  CFNumberRef SInt64 = 0;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], tag.category);
  if (values
    && (CFNumberRef SInt32 = FigCFNumberCreateSInt32(v5, dataType & 0xBFFFFFFF)) != 0
    && (CFNumberRef SInt64 = FigCFNumberCreateSInt64(v5, value)) != 0)
  {
    CFDictionaryRef v6 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)&values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!v6) {
      FigSignalErrorAt(4294951565, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    FigSignalErrorAt(4294951565, 0, 0, 0, 0, 0, 0);
    CFDictionaryRef v6 = 0;
  }
  for (uint64_t i = 0; i != 24; i += 8)
  {
    uint64_t v8 = *(void **)((char *)&values + i);
    if (v8) {
      CFRelease(v8);
    }
  }
  return v6;
}

CMTag CMTagMakeFromDictionary(CFDictionaryRef dict)
{
  if (dict)
  {
    CFTypeID v2 = CFGetTypeID(dict);
    if (v2 == CFDictionaryGetTypeID()
      && (CMTagValue v7 = 0,
          uint64_t v8 = 0,
          FigCFDictionaryGetInt32IfPresent((uint64_t)dict, @"category", (char *)&v8 + 4))
      && FigCFDictionaryGetInt32IfPresent((uint64_t)dict, @"flags", &v8)
      && FigCFDictionaryGetInt64IfPresent((uint64_t)dict, @"value", &v7))
    {
      CMTagValue v3 = v7;
      uint64_t v4 = HIDWORD(v8);
      unint64_t v5 = (unint64_t)v8 << 32;
    }
    else
    {
      unint64_t v5 = 0;
      CMTagValue v3 = 0;
      uint64_t v4 = 0;
    }
  }
  else
  {
    unint64_t v5 = 0;
    CMTagValue v3 = 0;
    uint64_t v4 = 0;
  }
  unint64_t v6 = v4 | v5;
  result.CMTagValue value = v3;
  result.category = v6;
  result.CMTagDataType dataType = HIDWORD(v6);
  return result;
}

void *FigTagCopyAsXPCDictionary(unint64_t a1, uint64_t a2)
{
  xpc_object_t empty = xpc_dictionary_create_empty();
  unint64_t v5 = empty;
  if (empty)
  {
    xpc_dictionary_set_uint64(empty, "CMTagCategory", a1);
    xpc_dictionary_set_uint64(v5, "CMTagDataType", HIDWORD(a1) & 0xFFFFFFFFBFFFFFFFLL);
    xpc_dictionary_set_uint64(v5, "CMTagValue", a2);
  }
  else
  {
    FigSignalErrorAt(4294951565, 0, 0, 0, 0, 0, 0);
  }
  return v5;
}

uint64_t FigTagMakeFromXPCDictionary(void *a1)
{
  if (a1)
  {
    uAudioDeviceID int64 = xpc_dictionary_get_uint64(a1, "CMTagCategory");
    uint64_t v3 = xpc_dictionary_get_uint64(a1, "CMTagDataType");
    xpc_dictionary_get_uint64(a1, "CMTagValue");
    uint64_t v4 = HIDWORD(uint64);
    if (HIDWORD(v3)) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = v3 << 32;
    }
    if (HIDWORD(v3)) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = uint64;
    }
    BOOL v7 = v4 == 0;
    if (v4) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = v5;
    }
    if (v7) {
      uint64_t v9 = v6;
    }
    else {
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  return v9 | v8;
}

uint64_t FigNote_CopyRingBufferBacking()
{
  return 4294950613;
}

uint64_t FigNote_AllowInternalDefaultLogs()
{
  if (FigNote_AllowInternalDefaultLogs_onceToken != -1) {
    dispatch_once_f(&FigNote_AllowInternalDefaultLogs_onceToken, 0, (dispatch_function_t)fig_note_initialize_allow_internal_default_logs);
  }
  return gAllowInternalDefaultLogs;
}

uint64_t fig_note_initialize_allow_internal_default_logs()
{
  uint64_t result = FigDebugIsInternalBuild();
  gAllowInternalDefaultLogs = result;
  return result;
}

char *fig_get_timestamp(uint64_t a1, char *__str, size_t __size)
{
  if (a1 == 2)
  {
    fig_get_offsetTimeStamp(__str, __size);
  }
  else if (a1 == 1)
  {
    FigCFGetLocalTimeString(__str, __size);
  }
  else
  {
    snprintf(__str, __size, " ");
  }
  return __str;
}

char *fig_get_offsetTimeStamp(char *a1, size_t a2)
{
  v11.tv_sec = 0;
  *(void *)&v11.__darwin_suseconds_t tv_usec = 0;
  gettimeofday(&v11, 0);
  int v4 = v11.tv_usec - dword_1EB28BA60;
  if (v11.tv_usec - dword_1EB28BA60 < 0)
  {
    if (v4 <= -1000000) {
      int v4 = -1000000;
    }
    int v6 = dword_1EB28BA60 + v4;
    if (v6 == v11.tv_usec) {
      __darwin_suseconds_t tv_usec = v11.tv_usec;
    }
    else {
      __darwin_suseconds_t tv_usec = v11.tv_usec + 1;
    }
    BOOL v8 = v6 == v11.tv_usec;
    LODWORD(v9) = (v6 - tv_usec) / 0xF4240u;
    if (v8) {
      uint64_t v9 = v9;
    }
    else {
      uint64_t v9 = (v9 + 1);
    }
    __darwin_time_t v5 = v11.tv_sec + ~sStartTime - v9;
    int v4 = v11.tv_usec + 1000000 * v9 + 1000000 - dword_1EB28BA60;
  }
  else
  {
    __darwin_time_t v5 = v11.tv_sec - sStartTime;
  }
  snprintf(a1, a2, "%02d:%02d.%06d", v5 / 60, v5 % 60, v4);
  return a1;
}

uint64_t fig_log_emitter_get_os_log(uint64_t *a1, BOOL *a2, BOOL *a3)
{
  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  if (!a1 || (uint64_t result = *a1) == 0) {
    uint64_t result = *fig_log_get_emitter("com.apple.coremedia", "");
  }
  if (a2) {
    *a2 = (gFigLogControl & 0xFFFFFFFE) == 8;
  }
  if (a3)
  {
    BOOL v8 = gFigLogControl != 8 || byte_1E9270E61 != 0;
    *a3 = v8;
  }
  return result;
}

void *fig_log_get_emitter(const char *a1, const char *a2)
{
  if (fig_log_get_emitter_onceToken != -1) {
    dispatch_once(&fig_log_get_emitter_onceToken, &__block_literal_global_9_0);
  }
  if (!a1) {
    a1 = "com.apple.coremedia";
  }
  if (a2) {
    int v4 = a2;
  }
  else {
    int v4 = "";
  }
  CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s-%s", a1, v4);
  os_unfair_lock_lock((os_unfair_lock_t)&fig_log_get_emitter_lock);
  CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)fig_log_get_emitter_emitterTable, v5);
  if (!Value)
  {
    CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
    CFStringRef Copy = CFStringCreateCopy(AllocatorForPermanentAllocations, v5);
    MallocZoneForPermanentAllocations = (malloc_zone_t *)FigGetMallocZoneForPermanentAllocations();
    CFArrayRef Value = malloc_type_zone_calloc(MallocZoneForPermanentAllocations, 1uLL, 8uLL, 0x2004093837F09uLL);
    void *Value = os_log_create(a1, v4);
    CFDictionarySetValue((CFMutableDictionaryRef)fig_log_get_emitter_emitterTable, Copy, Value);
    CFRelease(Copy);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&fig_log_get_emitter_lock);
  if (v5) {
    CFRelease(v5);
  }
  return Value;
}

uint64_t fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(uint64_t *a1, int a2, int *a3, unsigned char *a4)
{
  uint64_t os_log_and_send_and_compose_flags = fig_log_emitter_get_os_log_and_send_and_compose_flags(a1, a3);
  if (a4) {
    *a4 = fig_log_get_os_log_type(a2);
  }
  return os_log_and_send_and_compose_flags;
}

uint64_t fig_log_emitter_get_os_log_and_send_and_compose_flags(uint64_t *a1, int *a2)
{
  __int16 v5 = 0;
  uint64_t result = fig_log_emitter_get_os_log(a1, (BOOL *)&v5 + 1, (BOOL *)&v5);
  if (a2)
  {
    int v4 = 2 * ((_BYTE)v5 != 0);
    *a2 = v4;
    if (HIBYTE(v5)) {
      *a2 = v4 | 1;
    }
  }
  return result;
}

uint64_t fig_log_get_os_log_type(int a1)
{
  if (a1)
  {
    if (a1 == 2) {
      return 16;
    }
    else {
      return 0;
    }
  }
  else
  {
    if (FigNote_AllowInternalDefaultLogs_onceToken != -1) {
      dispatch_once_f(&FigNote_AllowInternalDefaultLogs_onceToken, 0, (dispatch_function_t)fig_note_initialize_allow_internal_default_logs);
    }
    if (gAllowInternalDefaultLogs) {
      return 16;
    }
    else {
      return 16 * FigServer_ShouldLogFigErrorsAsErrorsInThisProcess();
    }
  }
}

void fig_log_call_emit_and_clean_up_after_send_and_compose(uint64_t *a1, unsigned __int16 a2, char a3, void *a4, uint64_t a5, char a6, uint64_t a7, uint64_t a8)
{
  if ((a6 & 2) != 0)
  {
    int v8 = a5;
    fig_log_emit(a1, a2, a3 | 8, 0, a5, "%s", a7, a8, (uint64_t)a4);
    if (v8)
    {
      free(a4);
    }
  }
}

void fig_log_emit(uint64_t *a1, unsigned __int16 a2, char a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (gFigLogControl) {
    BOOL v9 = (a4 | (unint64_t)a6) == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    if (!a4) {
      a3 |= 4u;
    }
    fig_log_internal(a1, a2, a3, a4, a6, (CFIndex)&a9);
  }
}

void fig_log_internal(uint64_t *a1, unsigned __int16 a2, char a3, uint64_t a4, const char *a5, CFIndex a6)
{
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  int v6 = gFigLogControl;
  size_t v87 = 0;
  if (!gFigLogControl) {
    goto LABEL_144;
  }
  int v13 = byte_1E9270E61;
  int v14 = a2;
  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  fig_log_get_os_log_type(v14);
  fig_log_emitter_get_os_log(a1, 0, 0);
  unsigned __int16 v79 = a2;
  char range = a3;
  if (v13) {
    goto LABEL_3;
  }
  if (v6 == 7)
  {
    if (a4 || (a3 & 4) != 0)
    {
      if (!a4)
      {
        os_log_with_args();
        goto LABEL_144;
      }
      char v26 = 0;
      BOOL v23 = 0;
      __int16 v24 = 0;
LABEL_79:
      os_log_pack_send();
      goto LABEL_87;
    }
  }
  else
  {
    if (v6 != 8)
    {
LABEL_3:
      if (a4)
      {
        if ((a3 & 3) != 0)
        {
          memset(blockBufferOut, 0, sizeof(blockBufferOut));
          fig_get_timestamp(a3 & 3, (char *)blockBufferOut, 0x20uLL);
          size_t v22 = safe_snprintf_0(__src, v15, v16, v17, v18, v19, v20, v21, &vars0 + 96);
        }
        else
        {
          size_t v22 = 0;
        }
        uint64_t v27 = (char *)os_log_pack_compose();
        if (v27 == &__src[v22]
          || (uint64_t v28 = v27, v29 = strlen(v27), (v30 = (char *)malloc_type_malloc(v22 + v29 + 1, 0x599D277DuLL)) == 0))
        {
          __int16 v24 = __src;
        }
        else
        {
          __int16 v24 = v30;
          if (v22) {
            memcpy(v30, __src, v22);
          }
          size_t v31 = strlen(v28);
          memcpy(&v24[v22], v28, v31 + 1);
          free(v28);
        }
        char v26 = 0;
        BOOL v23 = v24 != __src;
        goto LABEL_65;
      }
      goto LABEL_21;
    }
    BOOL v23 = 0;
    __int16 v24 = 0;
    char v25 = 1;
    char v26 = 0;
    if (a4 || (a3 & 0xC) != 0)
    {
LABEL_70:
      if ((range & 8) != 0) {
        goto LABEL_87;
      }
      if (!a4)
      {
        if (v25) {
          os_log_with_args();
        }
        else {
LABEL_83:
        }
          fig_os_log_with_args();
        goto LABEL_87;
      }
      goto LABEL_79;
    }
  }
LABEL_21:
  if (!a5) {
    goto LABEL_144;
  }
  CFIndex usedBufLen = a6;
  memset(blockBufferOut, 0, sizeof(blockBufferOut));
  int v77 = a3 & 3;
  if ((a3 & 3) != 0)
  {
    long long v76 = blockBufferOut;
    fig_get_timestamp(a3 & 3, (char *)blockBufferOut, 0x20uLL);
  }
  else
  {
    long long v76 = 0;
  }
  int v78 = v13;
  char v84 = a1;
  int64_t v32 = strlen(a5);
  if (v32 < 1)
  {
    uint64_t v37 = __src;
    goto LABEL_49;
  }
  int v33 = 0;
  size_t v34 = 0;
  int v35 = 0;
  uint64_t v36 = &a5[v32];
  uint64_t v37 = __src;
  unsigned int v38 = a5;
  while (1)
  {
    int v39 = *(unsigned __int8 *)v38;
    if (!v35)
    {
      if (v39 != 123 || v33 != 37)
      {
        ++v34;
        *uint64_t v37 = v39;
        if (v34 == 511) {
          break;
        }
LABEL_42:
        int v35 = 0;
        goto LABEL_43;
      }
LABEL_40:
      int v35 = 1;
      goto LABEL_43;
    }
    if (v39 != 125) {
      goto LABEL_40;
    }
    if ((unint64_t)(v36 - v38) >= 4) {
      size_t v40 = 4;
    }
    else {
      size_t v40 = v36 - v38;
    }
    if (strncmp("}*.P", v38, v40)) {
      goto LABEL_42;
    }
    size_t v41 = v34 - 1;
    CFTypeRef v42 = &__src[v34 - 1];
    size_t v43 = 512 - v34 >= 8 ? 8 : 512 - v34;
    strncpy(v42, "(%zu) %p", v43);
    size_t v34 = v43 + v41;
    if (v34 == 511) {
      break;
    }
    int v35 = 0;
    v38 += 3;
LABEL_43:
    int v44 = *(unsigned __int8 *)v38++;
    int v33 = v44;
    uint64_t v37 = &__src[v34];
    if (v38 >= v36) {
      goto LABEL_49;
    }
  }
  uint64_t v37 = &v93;
LABEL_49:
  *uint64_t v37 = 0;
  va_list arguments = (va_list)usedBufLen;
  CFStringRef v45 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __src, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  CFMutableArrayRef Mutable = CFStringCreateMutable(0, 0);
  char v26 = Mutable;
  if (v45) {
    BOOL v47 = Mutable == 0;
  }
  else {
    BOOL v47 = 1;
  }
  if (v47)
  {
    a1 = v84;
    int v13 = v78;
    if (v45) {
      goto LABEL_61;
    }
  }
  else
  {
    a1 = v84;
    int v13 = v78;
    if (v77) {
      CFStringAppendFormat(Mutable, 0, @"[%s] ", v76);
    }
    if (FigCFEqual(v45, @"%s"))
    {
      long long v48 = (const char **)arguments;
      arguments += 8;
      CFStringAppendCString(v26, *v48, 0x8000100u);
    }
    else
    {
      CFStringAppendFormatAndArguments(v26, 0, v45, arguments);
    }
LABEL_61:
    CFRelease(v45);
  }
  CStringPtrMaybeUsingPreallocatedBuffer = (char *)FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer((const char *)v26, __src, 1536, 0x8000100u);
  if (!CStringPtrMaybeUsingPreallocatedBuffer) {
    CStringPtrMaybeUsingPreallocatedBuffer = FigCFStringGetCStringPtrAndBufferToFree(v26, 0x8000100u, (char **)&v87);
  }
  __int16 v24 = CStringPtrMaybeUsingPreallocatedBuffer;
  BOOL v23 = 0;
LABEL_65:
  char v25 = 0;
  switch(v6)
  {
    case 1:
      if ((v79 & 0xFFFD) != 0) {
        int v50 = 5;
      }
      else {
        int v50 = 3;
      }
      syslog(v50, "%s", v24);
      break;
    case 2:
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s\n", v24);
      break;
    case 3:
      puts(v24);
      break;
    case 4:
      goto LABEL_86;
    case 5:
      blockBufferOut[0] = 0;
      size_t v51 = strlen(v24);
      if (!CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v51 + 2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, v51 + 2, 1u, blockBufferOut))
      {
        CMBlockBufferReplaceDataBytes(v24, blockBufferOut[0], 0, v51);
        CMBlockBufferReplaceDataBytes("\n", blockBufferOut[0], v51, 2uLL);
        dispatch_async_f((dispatch_queue_t)sNoteBBufQueue, blockBufferOut[0], (dispatch_function_t)append_and_release_noteBBuf);
      }
      break;
    case 7:
      if (a4) {
        goto LABEL_79;
      }
      goto LABEL_83;
    case 8:
      goto LABEL_70;
    case 9:
      if ((range & 8) == 0)
      {
        if (a4) {
          os_log_pack_send();
        }
        else {
          os_log_with_args();
        }
      }
LABEL_86:
      fig_note_write_to_external_log_file(v24);
      break;
    default:
      break;
  }
LABEL_87:
  if (v13 && v26)
  {
    CFIndex Length = CFStringGetLength(v26);
    CFIndex usedBufLen = 0;
    unsigned int destination = 0;
    size_t lengthAtOffsetOut = 0;
    va_list arguments = 0;
    if (pthread_self() == (pthread_t)qword_1E9270E58)
    {
      os_log = fig_log_emitter_get_os_log(a1, 0, 0);
      if (os_log_type_enabled(os_log, OS_LOG_TYPE_ERROR)) {
        fig_log_internal_cold_1(os_log);
      }
    }
    else
    {
      FigReadWriteLockLockForRead(sFigNoteRingBufferState);
      if (qword_1E9270E68)
      {
        v104.CFIndex location = 0;
        v104.unint64_t length = Length;
        CFStringGetBytes(v26, v104, 0x8000100u, 0, 0, 0, 0, &usedBufLen);
        usedBufLen += 4;
        if (usedBufLen <= (unint64_t)qword_1E9270E78)
        {
          CFIndex rangea = Length;
          CFTypeID v83 = v24;
          unsigned __int8 v85 = a1;
          CFStringRef theString = v26;
          unint64_t v55 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v56 = 0x7FFFFFFFFFFFFFFFLL;
          do
          {
LABEL_97:
            unint64_t v57 = v56;
            unint64_t v56 = qword_1E9270E70;
            uint64_t v58 = (v57 >> 42) & 0x1FFFFF;
            unint64_t v59 = ((unint64_t)qword_1E9270E70 >> 42) & 0x1FFFFF;
            unint64_t v60 = qword_1E9270E70;
            if (v58 == v59)
            {
              uint64_t v61 = (v57 >> 21) & 0x1FFFFF;
              int v62 = v57 & 0x1FFFFF;
              if (v61 == (((unint64_t)qword_1E9270E70 >> 21) & 0x1FFFFF)
                && v62 == (qword_1E9270E70 & 0x1FFFFF))
              {
                long long v64 = fig_log_emitter_get_os_log(v85, 0, 0);
                if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
                {
                  LODWORD(blockBufferOut[0]) = 134219776;
                  *(CMBlockBufferRef *)((char *)blockBufferOut + 4) = (CMBlockBufferRef)qword_1E9270E78;
                  WORD2(blockBufferOut[1]) = 1024;
                  *(_DWORD *)((char *)&blockBufferOut[1] + 6) = v62;
                  WORD1(blockBufferOut[2]) = 1024;
                  HIDWORD(blockBufferOut[2]) = v61;
                  LOWORD(blockBufferOut[3]) = 1024;
                  *(_DWORD *)((char *)&blockBufferOut[3] + 2) = v58;
                  HIWORD(blockBufferOut[3]) = 1024;
                  int v95 = v55 & 0x1FFFFF;
                  __int16 v96 = 1024;
                  int v97 = (v55 >> 21) & 0x1FFFFF;
                  __int16 v98 = 1024;
                  int v99 = (v55 >> 42) & 0x1FFFFF;
                  __int16 v100 = 1024;
                  unsigned int v101 = destination;
                  _os_log_error_impl(&dword_18FD29000, v64, OS_LOG_TYPE_ERROR, "Ring buffer (size %zu) contained unrecoverable garbage when going from (oldest:%d loop:%d latest:%d) to (oldest:%d loop:%d latest:%d). Last log size read from buffer was %u", (uint8_t *)blockBufferOut, 0x36u);
                }
                LODWORD(v59) = 0x1FFFFF;
                unint64_t v60 = v55 & 0x8000000000000000 | 0x7FFFFC00001FFFFFLL;
              }
              else
              {
                unint64_t v59 = (v57 >> 42) & 0x1FFFFF;
                unint64_t v60 = qword_1E9270E70;
              }
            }
            unint64_t v65 = v60 & 0xFFFFFFFFFFE00000;
            if (v59 == 0x1FFFFF) {
              uint64_t v66 = 0;
            }
            else {
              uint64_t v66 = v59;
            }
            if (v59 != 0x1FFFFF) {
              unint64_t v65 = v60;
            }
            unint64_t v67 = (v66 + usedBufLen) & 0x1FFFFF;
            unint64_t v68 = v65 & 0x8000000000000000;
            unint64_t v69 = v65 & 0x800003FFFFFFFFFFLL | ((((int)v66 + (int)usedBufLen) & 0x1FFFFFLL) << 42);
            if (qword_1E9270E78 < v67) {
              size_t v70 = 0;
            }
            else {
              size_t v70 = v66;
            }
            if (qword_1E9270E78 < v67) {
              unint64_t v69 = (v68 | (v66 << 21)) & 0x800003FFFFFFFFFFLL | ((usedBufLen & 0x1FFFFF) << 42);
            }
            if (((v69 >> 42) & 0x1FFFFF) <= ((v69 >> 21) & 0x1FFFFF)) {
              unint64_t v55 = v69;
            }
            else {
              unint64_t v55 = v69 & 0xFFFFFC00001FFFFFLL | (((v69 >> 42) & 0x1FFFFF) << 21);
            }
            if (v59 != 0x1FFFFF)
            {
              unsigned int v71 = v55 & 0x1FFFFF;
              if (v70 <= (v55 & 0x1FFFFF))
              {
                while (v71 < ((v55 >> 42) & 0x1FFFFF))
                {
                  CMBlockBufferCopyDataBytes((CMBlockBufferRef)qword_1E9270E68, v55 & 0x1FFFFF, 4uLL, &destination);
                  if (destination < 4) {
                    goto LABEL_97;
                  }
                  if (qword_1E9270E78 < (unint64_t)destination
                    || (v55 & 0x1FFFFF) > qword_1E9270E78 - (unint64_t)destination)
                  {
                    goto LABEL_97;
                  }
                  uint64_t v74 = (destination + v55) & 0x1FFFFF;
                  if (v74 >= ((v56 >> 21) & 0x1FFFFF)) {
                    unint64_t v55 = (v55 >> 21) & 0x3FFFFE00000 | v55 & 0xFFFFFC0000000000;
                  }
                  else {
                    unint64_t v55 = v55 & 0xFFFFFFFFFFE00000 | v74;
                  }
                  unsigned int v71 = v55 & 0x1FFFFF;
                  if ((int)v70 > (int)(v55 & 0x1FFFFF)) {
                    break;
                  }
                }
              }
            }
            unint64_t v72 = v56;
            atomic_compare_exchange_strong_explicit(&qword_1E9270E70, &v72, v55, memory_order_relaxed, memory_order_relaxed);
          }
          while (v72 != v56);
          CMBlockBufferReplaceDataBytes(&usedBufLen, (CMBlockBufferRef)qword_1E9270E68, v70, 4uLL);
          CMBlockBufferGetDataPointer((CMBlockBufferRef)qword_1E9270E68, v70 + 4, &lengthAtOffsetOut, 0, &arguments);
          if (lengthAtOffsetOut >= usedBufLen) {
            CFIndex v75 = usedBufLen;
          }
          else {
            CFIndex v75 = lengthAtOffsetOut;
          }
          char v26 = (__CFString *)theString;
          v105.CFIndex location = 0;
          v105.unint64_t length = rangea;
          CFStringGetBytes(theString, v105, 0x8000100u, 0, 0, (UInt8 *)arguments, v75, 0);
          __int16 v24 = v83;
        }
        else
        {
          long long v53 = fig_log_emitter_get_os_log(a1, 0, 0);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
            fig_log_internal_cold_2(&usedBufLen, v53);
          }
        }
      }
      FigReadWriteLockUnlockForRead(sFigNoteRingBufferState);
    }
  }
  if (v23) {
    free(v24);
  }
  if (v26) {
    CFRelease(v26);
  }
LABEL_144:
  free(v87);
}

void fig_log(unsigned __int16 a1, char a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a5)
  {
    if (gFigLogControl) {
      fig_log_internal(0, a1, a2 | 4, 0, a5, (CFIndex)&a9);
    }
  }
}

void fig_log_with_return_address(uint64_t *a1, unsigned __int16 a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, const char *a7, uint64_t a8, uint64_t a9)
{
  if (a7)
  {
    if (gFigLogControl) {
      fig_log_internal(a1, a2, a3 | 4, 0, a7, (CFIndex)&a9);
    }
  }
}

void fig_log_CF1(unsigned __int16 a1, char a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a5)
  {
    if (gFigLogControl) {
      fig_log_internal(0, a1, a2, 0, a5, (CFIndex)&a9);
    }
  }
}

void fig_post_a_symptom_guts(uint64_t a1)
{
  if (fig_post_a_symptom_guts_onceToken != -1) {
    dispatch_once(&fig_post_a_symptom_guts_onceToken, &__block_literal_global_30);
  }
  CFTypeID v2 = fig_post_a_symptom_guts_sFigLogOSLogSymptom;
  if (os_log_type_enabled((os_log_t)fig_post_a_symptom_guts_sFigLogOSLogSymptom, OS_LOG_TYPE_ERROR)) {
    fig_post_a_symptom_guts_cold_1(a1, v2);
  }
}

uint64_t __fig_post_a_symptom_guts_block_invoke()
{
  fig_post_a_symptom_guts_sFigLogOSLogSymptom = (uint64_t)os_log_create("com.apple.coremedia", "Symptoms");

  return FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
}

void *fig_log_handle()
{
  uint64_t result = fig_log_get_emitter("com.apple.coremedia", "");
  if (result) {
    return (void *)*result;
  }
  return result;
}

CFMutableDictionaryRef __fig_log_get_emitter_block_invoke()
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], 0);
  fig_log_get_emitter_emitterTable = (uint64_t)result;
  return result;
}

void *fig_log_get_excessive_emitter_for_subsystem(const char *a1)
{
  return fig_log_get_emitter(a1, "excessive");
}

void fig_note_initialize_category_with_default_work_cf(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, void *a8)
{
  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  FigThreadRunOnce(&sFigNoteInit, (void (*)(void))fig_note_init_timestamps_once);
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  v22[0] = a3;
  v22[1] = a2;
  v22[2] = a5;
  v22[3] = a4;
  v22[4] = a1;
  v22[5] = a6;
  if (initialize_fignote_variable_registry_sInitRegistryOnce != -1) {
    dispatch_once_f(&initialize_fignote_variable_registry_sInitRegistryOnce, 0, (dispatch_function_t)initialize_fignote_variable_registry_once);
  }
  dispatch_sync_f((dispatch_queue_t)gFigNoteVariableRegistry_0, v22, (dispatch_function_t)perform_fignote_variable_registration);
  uint64_t v15 = v23;
  if ((_BYTE)v24 && v23)
  {
    CFStringRef v16 = (const __CFString *)CFPreferencesCopyAppValue(a2, a3);
    CFStringRef v17 = v16;
    int v18 = gAllowAutomaticFigNotes;
    if (gAllowAutomaticFigNotes) {
      int v18 = *(_DWORD *)(v15 + 16);
    }
    **(_DWORD **)(v15 + 8) = v18;
    if (v16)
    {
      CFTypeID v19 = CFGetTypeID(v16);
      if (v19 == CFStringGetTypeID())
      {
        LODWORD(v22[0]) = 0;
        if (!fig_note_get_value_for_string_preference(v17, (int *)v22)) {
          goto LABEL_16;
        }
      }
      else
      {
        CFTypeID v20 = CFGetTypeID(v17);
        if (v20 != CFNumberGetTypeID())
        {
          CFTypeID v21 = CFGetTypeID(v17);
          if (v21 == CFBooleanGetTypeID()) {
            **(_DWORD **)(v15 + 8) = CFEqual(v17, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
          }
          goto LABEL_16;
        }
        LODWORD(v22[0]) = 0;
        if (!CFNumberGetValue((CFNumberRef)v17, kCFNumberIntType, v22))
        {
LABEL_16:
          CFRelease(v17);
          goto LABEL_17;
        }
      }
      **(_DWORD **)(v15 + 8) = v22[0];
      goto LABEL_16;
    }
  }
LABEL_17:
  if (a8)
  {
    if (v15) {
      *a8 = *(void *)v15;
    }
  }
}

void fig_note_initialize_category_with_default_work(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, void *a8)
{
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v15 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  CFStringRef v16 = CFStringCreateWithCString(v14, a3, 0x8000100u);
  fig_note_initialize_category_with_default_work_cf(a1, v15, v16, a4, a5, a6, v17, a8);
  if (v15) {
    CFRelease(v15);
  }
  if (v16)
  {
    CFRelease(v16);
  }
}

void fig_note_initialize_with_default_work(uint64_t a1, const char *a2, const char *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
}

uint64_t FigNote_OneTimeInitializationForMediaServerd()
{
  if (initialize_fignote_variable_registry_sInitRegistryOnce != -1) {
    dispatch_once_f(&initialize_fignote_variable_registry_sInitRegistryOnce, 0, (dispatch_function_t)initialize_fignote_variable_registry_once);
  }
  sRunningInMediaserverd = 1;
  Boolean keyExistsAndHasValidFormat = 0;
  AppIntegerCFArrayRef Value = CFPreferencesGetAppIntegerValue(@"rpc_timeout", @"com.apple.coremedia", &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    uint64_t v1 = 1000000 * AppIntegerValue;
  }
  else {
    uint64_t v1 = 9000000000;
  }
  FigRPCServer_SetTimeoutNanoseconds(v1);
  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  return fig_note_read_control_preferences();
}

uint64_t fig_note_read_control_preferences()
{
  FigReentrantMutexLock((pthread_mutex_t *)gFigLogControlMutex);
  CFStringRef v0 = (const __CFString *)CFPreferencesCopyAppValue(@"fig_notes", @"com.apple.coremedia");
  if (v0)
  {
    CFStringRef v1 = v0;
    CFTypeID v2 = CFGetTypeID(v0);
    if (v2 == CFStringGetTypeID())
    {
      fig_note_close_external_log_file();
      if (CFStringCompare(v1, @"true", 1uLL)
        && CFStringCompare(v1, @"yes", 1uLL)
        && CFStringCompare(v1, @"on", 1uLL)
        && CFStringCompare(v1, @"oslog", 1uLL))
      {
        if (CFStringCompare(v1, @"syslog", 1uLL) == kCFCompareEqualTo)
        {
          gFigLogControl = 1;
          goto LABEL_28;
        }
        if (CFStringCompare(v1, @"stderr", 1uLL))
        {
          if (CFStringCompare(v1, @"stdout", 1uLL))
          {
            if (CFStringCompare(v1, @"external", 1uLL) == kCFCompareEqualTo
              || CFStringCompare(v1, @"external_no_echo_oslog", 1uLL) == kCFCompareEqualTo
              || CFStringCompare(v1, @"public", 1uLL) == kCFCompareEqualTo && sRunningInMediaserverd)
            {
              fig_note_configure_external_log_file(v1);
LABEL_28:
              CFRelease(v1);
              goto LABEL_29;
            }
            if (CFStringCompare(v1, @"bbuf", 1uLL))
            {
              if (CFStringCompare(v1, @"ring", 1uLL))
              {
                SInt32 IntValue = CFStringGetIntValue(v1);
                goto LABEL_23;
              }
              unint64_t v5 = 0x1E9270000;
              int v6 = 6;
            }
            else
            {
              if (!sNoteBBufQueue)
              {
                sNoteBBufQueue = (uint64_t)dispatch_queue_create("com.apple.coremedia.fignote", 0);
                CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0x100u, 0, (CMBlockBufferRef *)&sNoteBBuf);
              }
              unint64_t v5 = 0x1E9270000;
              int v6 = 5;
            }
          }
          else
          {
            unint64_t v5 = 0x1E9270000;
            int v6 = 3;
          }
        }
        else
        {
          unint64_t v5 = 0x1E9270000;
          int v6 = 2;
        }
      }
      else
      {
        unint64_t v5 = 0x1E9270000uLL;
        int v6 = 8;
      }
      *(_DWORD *)(v5 + 3656) = v6;
      goto LABEL_28;
    }
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == CFNumberGetTypeID())
    {
      int valuePtr = 0;
      CFNumberGetValue((CFNumberRef)v1, kCFNumberIntType, &valuePtr);
      BOOL v4 = valuePtr == 0;
LABEL_24:
      int v9 = !v4;
      gFigLogControl = 8 * v9;
      goto LABEL_28;
    }
    CFTypeID v7 = CFGetTypeID(v1);
    if (v7 != CFBooleanGetTypeID()) {
      goto LABEL_28;
    }
    SInt32 IntValue = CFEqual(v1, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
LABEL_23:
    BOOL v4 = IntValue == 0;
    goto LABEL_24;
  }
  fig_note_close_external_log_file();
  if (gFigLogControl != 8) {
    gFigLogControl = 8;
  }
LABEL_29:
  CFStringRef v10 = (const __CFString *)CFPreferencesCopyAppValue(@"automatic_fig_notes", @"com.apple.coremedia");
  gAllowAutomaticFigNotes = 1;
  if (v10)
  {
    CFStringRef v11 = v10;
    CFTypeID v12 = CFGetTypeID(v10);
    if (v12 == CFStringGetTypeID())
    {
      int v18 = 0;
      if (!fig_note_get_value_for_string_preference(v11, &v18))
      {
LABEL_36:
        CFRelease(v11);
        return FigReentrantMutexUnlock((pthread_mutex_t *)gFigLogControlMutex);
      }
      char v13 = v18;
    }
    else
    {
      CFTypeID v14 = CFGetTypeID(v11);
      if (v14 != CFNumberGetTypeID())
      {
        CFTypeID v16 = CFGetTypeID(v11);
        if (v16 == CFBooleanGetTypeID()) {
          gAllowAutomaticFigNotes = CFEqual(v11, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
        }
        goto LABEL_36;
      }
      int v17 = 0;
      CFNumberGetValue((CFNumberRef)v11, kCFNumberIntType, &v17);
      char v13 = v17 != 0;
    }
    gAllowAutomaticFigNotes = v13;
    goto LABEL_36;
  }
  return FigReentrantMutexUnlock((pthread_mutex_t *)gFigLogControlMutex);
}

uint64_t FigNote_RefreshControlPreferences()
{
  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);

  return fig_note_read_control_preferences();
}

uint64_t FigNote_CopyAndClearNoteBBuf()
{
  return 0;
}

uint64_t FigNote_ChangeValue(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = 4294950614;
  unsigned int v8 = -16682;
  if (gFigNoteVariableRegistry_0) {
    BOOL v4 = gFigNoteVariableRegistry_1 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    int v6[2] = __FigNote_ChangeValue_block_invoke;
    v6[3] = &__block_descriptor_tmp_12_0;
    v6[4] = a1;
    v6[5] = a2;
    int v7 = a3;
    v6[6] = &v8;
    dispatch_sync((dispatch_queue_t)gFigNoteVariableRegistry_0, v6);
    return v8;
  }
  return v3;
}

uint64_t FigNote_GetValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 4294950614;
  unsigned int v7 = -16682;
  if (gFigNoteVariableRegistry_0) {
    BOOL v4 = gFigNoteVariableRegistry_1 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FigNote_GetValue_block_invoke;
    block[3] = &__block_descriptor_tmp_13_2;
    void block[4] = a1;
    void block[5] = a2;
    void block[6] = a3;
    void block[7] = &v7;
    dispatch_sync((dispatch_queue_t)gFigNoteVariableRegistry_0, block);
    return v7;
  }
  return v3;
}

uint64_t FigNote_ConfigureRingBuffer(uint64_t a1)
{
  uint64_t v2 = fignote_initialize_ringlog();
  if (v2) {
    return v2;
  }
  if (a1 && !*(void *)a1)
  {
    FigReadWriteLockLockForWrite(sFigNoteRingBufferState);
    qword_1E9270E58 = (uint64_t)pthread_self();
    uint64_t v3 = *(unsigned int *)(a1 + 8);
    if (v3)
    {
      if (v3 >= 0x200000)
      {
        uint64_t v4 = FigSignalErrorAt(4294950616, 0, 0, 0, 0, 0, 0);
LABEL_11:
        qword_1E9270E58 = 0;
        FigReadWriteLockUnlockForWrite(sFigNoteRingBufferState);
        return v4;
      }
    }
    else
    {
      uint64_t v3 = 0x100000;
    }
    qword_1E9270E78 = v3;
    if (byte_1E9270E61)
    {
      fig_note_dropRingBufferDataStructuresInternal();
      fig_note_makeRingBufferDataStructuresInternal();
    }
    uint64_t v4 = 0;
    goto LABEL_11;
  }

  return FigSignalErrorAt(4294950616, 0, 0, 0, 0, 0, 0);
}

uint64_t fignote_initialize_ringlog()
{
  if (fignote_initialize_ringlog_initializeLogRingBuffer != -1) {
    dispatch_once_f(&fignote_initialize_ringlog_initializeLogRingBuffer, 0, (dispatch_function_t)initialize_logRingBuffer);
  }
  if (byte_1E9270E60) {
    return 0;
  }
  else {
    return 4294950613;
  }
}

void fig_note_dropRingBufferDataStructuresInternal()
{
  if (qword_1E9270E68)
  {
    CFRelease((CFTypeRef)qword_1E9270E68);
    qword_1E9270E68 = 0;
  }
  else
  {
    FigSignalErrorAt(4294950616, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t fig_note_makeRingBufferDataStructuresInternal()
{
  if (qword_1E9270E68)
  {
    return FigSignalErrorAt(4294950616, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t result = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, qword_1E9270E78, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, qword_1E9270E78, 1u, (CMBlockBufferRef *)&qword_1E9270E68);
    if (!result) {
      atomic_store(0x7FFFFC00001FFFFFuLL, (unint64_t *)&qword_1E9270E70);
    }
  }
  return result;
}

uint64_t FigNote_EnableRingBuffer(int a1)
{
  uint64_t v2 = fignote_initialize_ringlog();
  if (!v2)
  {
    FigReadWriteLockLockForWrite(sFigNoteRingBufferState);
    qword_1E9270E58 = (uint64_t)pthread_self();
    if (!a1 || byte_1E9270E61)
    {
      if (!a1 && byte_1E9270E61) {
        fig_note_dropRingBufferDataStructuresInternal();
      }
    }
    else
    {
      fig_note_makeRingBufferDataStructuresInternal();
    }
    byte_1E9270E61 = a1;
    qword_1E9270E58 = 0;
    FigReadWriteLockUnlockForWrite(sFigNoteRingBufferState);
  }
  return v2;
}

uint64_t FigNote_CopyRingBufferLogArrayAndResetRing(__CFArray **a1, int a2)
{
  uint64_t result = fignote_initialize_ringlog();
  if (!result)
  {
    FigReadWriteLockLockForWrite(sFigNoteRingBufferState);
    qword_1E9270E58 = (uint64_t)pthread_self();
    unint64_t v5 = atomic_load((unint64_t *)&qword_1E9270E70);
    if (qword_1E9270E68 && (int v6 = (__CFString *)CFRetain((CFTypeRef)qword_1E9270E68)) != 0)
    {
      unsigned int v7 = v6;
      if (!a2 || (v5 & 0x1FFFFF) != 0x1FFFFF)
      {
        fig_note_dropRingBufferDataStructuresInternal();
        if (a2) {
          fig_note_makeRingBufferDataStructuresInternal();
        }
        else {
          byte_1E9270E61 = 0;
        }
      }
      qword_1E9270E58 = 0;
      FigReadWriteLockUnlockForWrite(sFigNoteRingBufferState);
      int v8 = v5 & 0x1FFFFF;
      if ((v5 & 0x1FFFFF) != 0x1FFFFF)
      {
        size_t v22 = a1;
        context.version = 0;
        memset(&context.retain, 0, 40);
        context.info = v7;
        context.deallocate = (CFAllocatorDeallocateCallBack)fig_log_ring_backing_deallocator;
        context.preferredSize = 0;
        CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFAllocatorRef v10 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &context);
        BOOL v11 = v8 == 0;
        BOOL v12 = v8 != 0;
        theArray = CFArrayCreateMutable(v9, 0, MEMORY[0x1E4F1D510]);
        char v13 = 0;
        uint64_t v14 = (v5 >> 42) & 0x1FFFFF;
        uint64_t v15 = (v5 >> 21) & 0x1FFFFF;
        do
        {
          int destination = 0;
          dataPointerOut = 0;
          size_t lengthAtOffsetOut = 0;
          CMBlockBufferCopyDataBytes((CMBlockBufferRef)v7, v8, 4uLL, &destination);
          int v16 = destination;
          if (destination < 5) {
            break;
          }
          destination -= 4;
          CMBlockBufferGetDataPointer((CMBlockBufferRef)v7, v8 + 4, &lengthAtOffsetOut, 0, &dataPointerOut);
          if (lengthAtOffsetOut < destination) {
            break;
          }
          CFRetain(v7);
          CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
          CFStringRef v18 = CFStringCreateWithBytesNoCopy(AllocatorForMedia, (const UInt8 *)dataPointerOut, destination, 0x8000100u, 0, v10);
          CFStringRef v19 = v7;
          if (v18)
          {
            CFArrayAppendValue(theArray, v18);
            CFStringRef v19 = v18;
          }
          int v20 = v16 + v8;
          CFRelease(v19);
          if (!v12 && v20 >= (int)v14) {
            char v13 = 1;
          }
          if (v20 < (int)v15)
          {
            int v8 = v20;
          }
          else
          {
            BOOL v11 = 1;
            int v8 = 0;
          }
          BOOL v12 = !v11;
        }
        while (!v13 || !v11);
        *size_t v22 = theArray;
        if (v10) {
          CFRelease(v10);
        }
      }
      CFRelease(v7);
      return 0;
    }
    else
    {
      qword_1E9270E58 = 0;
      FigReadWriteLockUnlockForWrite(sFigNoteRingBufferState);
      return 4294950613;
    }
  }
  return result;
}

void fig_log_ring_backing_deallocator(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    if (cf) {
      CFRelease(cf);
    }
  }
}

uint64_t FigNote_CopyKeys(uint64_t a1, void *a2)
{
  uint64_t v8 = 0;
  CFAllocatorRef v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  if (gFigNoteVariableRegistry_0) {
    BOOL v2 = gFigNoteVariableRegistry_1 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    goto LABEL_7;
  }
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  v7[2] = __FigNote_CopyKeys_block_invoke;
  v7[3] = &unk_1E5679B40;
  v7[4] = &v8;
  v7[5] = a1;
  dispatch_sync((dispatch_queue_t)gFigNoteVariableRegistry_0, v7);
  uint64_t v4 = (__CFArray *)v9[3];
  if (!v4)
  {
LABEL_7:
    uint64_t v5 = 4294950614;
  }
  else
  {
    v12.unint64_t length = CFArrayGetCount((CFArrayRef)v9[3]);
    v12.CFIndex location = 0;
    CFArraySortValues(v4, v12, MEMORY[0x1E4F1C2A8], 0);
    uint64_t v5 = 0;
    *a2 = v9[3];
  }
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t fig_os_log_with_args()
{
  return os_log_with_args();
}

uint64_t fig_note_write_to_external_log_file(const char *a1)
{
  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  FigReentrantMutexLock((pthread_mutex_t *)gFigLogControlMutex);
  if (sExternalLogfile)
  {
    int v2 = fprintf((FILE *)sExternalLogfile, "%s\n", a1);
    fflush((FILE *)sExternalLogfile);
    if (v2 >= 1 && sExternalLogfileSizeLimit != 0)
    {
      sExternalLogfileNumBytesWritten += v2;
      if (sExternalLogfileNumBytesWritten > sExternalLogfileSizeLimit)
      {
        fig_note_close_external_log_file();
        unlink(sExternalLogfilePath);
        fig_note_open_external_log_file();
      }
    }
  }
  uint64_t v4 = (pthread_mutex_t *)gFigLogControlMutex;

  return FigReentrantMutexUnlock(v4);
}

void append_and_release_noteBBuf(CMBlockBufferRef targetBBuf)
{
  CMBlockBufferAppendBufferReference((CMBlockBufferRef)sNoteBBuf, targetBBuf, 0, 0, 0);

  CFRelease(targetBBuf);
}

uint64_t safe_snprintf_0(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  LODWORD(result) = vsnprintf(a1, 0x600uLL, "[%s] ", &a9);
  if (result >= 0x5FF) {
    return 1535;
  }
  else {
    return result;
  }
}

uint64_t fig_note_close_external_log_file()
{
  FigReentrantMutexLock((pthread_mutex_t *)gFigLogControlMutex);
  if (sExternalLogfile)
  {
    if (sFigNoteExternalLogDeleteWatchSource)
    {
      dispatch_source_cancel((dispatch_source_t)sFigNoteExternalLogDeleteWatchSource);
      dispatch_release((dispatch_object_t)sFigNoteExternalLogDeleteWatchSource);
      sFigNoteExternalLogDeleteWatchSource = 0;
    }
    else
    {
      fclose((FILE *)sExternalLogfile);
    }
    sExternalLogfile = 0;
  }
  CFStringRef v0 = (pthread_mutex_t *)gFigLogControlMutex;

  return FigReentrantMutexUnlock(v0);
}

uint64_t fig_note_open_external_log_file()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  FigReentrantMutexLock((pthread_mutex_t *)gFigLogControlMutex);
  time_t v8 = 0;
  time(&v8);
  if (sPublicLogFileInUse == 1)
  {
    qmemcpy(handler, "/private/var/mobile/Library/Logs/CrashReporter/mediaserverd_log_", sizeof(handler));
    CFStringRef v0 = localtime(&v8);
    strftime(v10, 0x3C0uLL, "%Y-%m-%d-%H%M%S.txt", v0);
    __strlcpy_chk();
  }
  sExternalLogfileNumBytesWritten = 0;
  CFStringRef v1 = fopen(sExternalLogfilePath, "ab");
  sExternalLogfile = (uint64_t)v1;
  if (v1)
  {
    setvbuf(v1, 0, 2, 0);
    int v2 = (FILE *)sExternalLogfile;
    uint64_t v3 = ctime(&v8);
    fprintf(v2, "\n\n\n=== New Log Starting At %.24s =============================================================\n", v3);
    gFigLogControl = 4;
    if (sExternalEchoToOSLog) {
      fwrite("**** WARNING: Using external_no_echo_oslog causes standard Fig logging to be omitted from the log captured by sysdiagnose, which will mean that engineering is not able to analyze radars created while it's set\n\n", 0xD2uLL, 1uLL, (FILE *)sExternalLogfile);
    }
    else {
      gFigLogControl = 9;
    }
    sExternalLogfileNumBytesWritten = MEMORY[0x192FC58F0](sExternalLogfile);
    uint64_t v4 = sExternalLogfile;
    if (sExternalLogfile)
    {
      int v5 = fileno((FILE *)sExternalLogfile);
      global_queue = dispatch_get_global_queue(0, 0);
      sFigNoteExternalLogDeleteWatchSource = (uint64_t)dispatch_source_create(MEMORY[0x1E4F144A8], v5, 1uLL, global_queue);
      dispatch_source_set_event_handler((dispatch_source_t)sFigNoteExternalLogDeleteWatchSource, &__block_literal_global_30_0);
      *(void *)&handler[0] = MEMORY[0x1E4F143A8];
      *((void *)&handler[0] + 1) = 0x40000000;
      *(void *)&handler[1] = __fig_note_setup_log_delete_watch_block_invoke_2;
      *((void *)&handler[1] + 1) = &__block_descriptor_tmp_31;
      *(void *)&handler[2] = v4;
      dispatch_source_set_cancel_handler((dispatch_source_t)sFigNoteExternalLogDeleteWatchSource, handler);
      dispatch_resume((dispatch_object_t)sFigNoteExternalLogDeleteWatchSource);
    }
  }
  else
  {
    gFigLogControl = 8;
  }
  return FigReentrantMutexUnlock((pthread_mutex_t *)gFigLogControlMutex);
}

uint64_t __fig_note_setup_log_delete_watch_block_invoke()
{
  FigReentrantMutexLock((pthread_mutex_t *)gFigLogControlMutex);
  if (sExternalLogfile)
  {
    fig_note_close_external_log_file();
    fig_note_open_external_log_file();
  }
  CFStringRef v0 = (pthread_mutex_t *)gFigLogControlMutex;

  return FigReentrantMutexUnlock(v0);
}

uint64_t __fig_note_setup_log_delete_watch_block_invoke_2(uint64_t a1)
{
  return fclose(*(FILE **)(a1 + 32));
}

void perform_fignote_variable_registration(uint64_t a1)
{
  CMTagValue value = 0;
  CFMutableArrayRef Mutable = (void *)CFDictionaryGetValue((CFDictionaryRef)gFigNoteVariableRegistry_1, *(const void **)a1);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue((CFMutableDictionaryRef)gFigNoteVariableRegistry_1, *(const void **)a1, Mutable);
    CFRelease(Mutable);
  }
  if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)Mutable, *(const void **)(a1 + 8), (const void **)&value))
  {
    CMTagValue value = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    CFDictionarySetValue((CFMutableDictionaryRef)Mutable, *(const void **)(a1 + 8), value);
    CFRelease(value);
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)value);
  if (Count < 1)
  {
LABEL_9:
    unsigned int v7 = malloc_type_calloc(1uLL, 0x18uLL, 0x10300409B68AA8EuLL);
    time_t v8 = v7;
    if (v7)
    {
      v7[1] = *(void *)(a1 + 32);
      *((_DWORD *)v7 + 4) = *(_DWORD *)(a1 + 40);
      *unsigned int v7 = fig_log_get_emitter(*(const char **)(a1 + 16), *(const char **)(a1 + 24));
      CFArrayAppendValue((CFMutableArrayRef)value, v8);
      *(unsigned char *)(a1 + 56) = 1;
    }
  }
  else
  {
    CFIndex v4 = Count;
    CFIndex v5 = 0;
    while (1)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)value, v5);
      if (ValueAtIndex[1] == *(void *)(a1 + 32)) {
        break;
      }
      if (v4 == ++v5) {
        goto LABEL_9;
      }
    }
    time_t v8 = ValueAtIndex;
  }
  *(void *)(a1 + 48) = v8;
}

BOOL fig_note_get_value_for_string_preference(const __CFString *a1, int *a2)
{
  BOOL v4 = 1;
  if (CFStringCompare(a1, @"true", 1uLL))
  {
    int v5 = 1;
    if (CFStringCompare(a1, @"yes", 1uLL))
    {
      int v5 = 1;
      if (CFStringCompare(a1, @"on", 1uLL))
      {
        BOOL v4 = 1;
        if (CFStringCompare(a1, @"false", 1uLL)
          && (BOOL v4 = 1, CFStringCompare(a1, @"no", 1uLL))
          && (BOOL v4 = 1, CFStringCompare(a1, @"off", 1uLL)))
        {
          if (CFEqual(a1, @"0"))
          {
            int v5 = 0;
            BOOL v4 = 1;
          }
          else
          {
            SInt32 IntValue = CFStringGetIntValue(a1);
            BOOL v4 = IntValue != 0;
            int v5 = IntValue & ~(IntValue >> 31);
          }
        }
        else
        {
          int v5 = 0;
        }
      }
      else
      {
        BOOL v4 = 1;
      }
    }
    else
    {
      BOOL v4 = 1;
    }
  }
  else
  {
    int v5 = 1;
  }
  *a2 = v5;
  return v4;
}

void initialize_fignote_variable_registry_once()
{
  gFigNoteVariableRegistry_0 = (uint64_t)dispatch_queue_create("fignote_variable_registry_queue", 0);
  gFigNoteVariableRegistry_1 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);

  FigInstallSysdiagnoseBlock(@"FigNoteVariableRegistry", (uint64_t)&__block_literal_global_59);
}

void __initialize_fignote_variable_registry_once_block_invoke()
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  v6[0] = 0;
  uint64_t os_log_and_send_and_compose_flags = fig_log_emitter_get_os_log_and_send_and_compose_flags(0, v6);
  int v1 = v6[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags, OS_LOG_TYPE_DEFAULT)) {
    unsigned int v4 = v1;
  }
  else {
    unsigned int v4 = v1 & 0xFFFFFFFE;
  }
  if (v4)
  {
    v6[1] = 136315138;
    unsigned int v7 = "";
    int v5 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v6[0];
  }
  else
  {
    int v5 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 0, v5, v5 != block, v1, v2, v3);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __DumpVariableRegistry_block_invoke;
  block[3] = &__block_descriptor_tmp_60;
  char v9 = 1;
  dispatch_sync((dispatch_queue_t)gFigNoteVariableRegistry_0, block);
}

void __DumpVariableRegistry_block_invoke(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 32)) {
    int v1 = DumpNonDefaultRegisteredVariablesDictionaryApplierFunction;
  }
  else {
    int v1 = DumpAllRegisteredVariablesDictionaryApplierFunction;
  }
  CFDictionaryApplyFunction((CFDictionaryRef)gFigNoteVariableRegistry_1, (CFDictionaryApplierFunction)DumpVariableAppIDDictionaryApplierFunction, v1);
}

void DumpNonDefaultRegisteredVariablesDictionaryApplierFunction(uint64_t a1, CFArrayRef theArray, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    for (CFIndex i = 0; i != v7; ++i)
    {
      CFNumberRef ValueAtIndex = (_DWORD **)CFArrayGetValueAtIndex(theArray, i);
      if (*ValueAtIndex[1] != *((_DWORD *)ValueAtIndex + 4))
      {
        uint64_t v10 = ValueAtIndex;
        v19[0] = 0;
        uint64_t os_log_and_send_and_compose_flags = fig_log_emitter_get_os_log_and_send_and_compose_flags(0, v19);
        int v12 = v19[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags, OS_LOG_TYPE_DEFAULT)) {
          unsigned int v15 = v12;
        }
        else {
          unsigned int v15 = v12 & 0xFFFFFFFE;
        }
        if (v15)
        {
          int v16 = *v10[1];
          int v17 = *((_DWORD *)v10 + 4);
          v19[1] = 136316162;
          int v20 = "";
          __int16 v21 = 2112;
          uint64_t v22 = a3;
          __int16 v23 = 2112;
          uint64_t v24 = a1;
          __int16 v25 = 1024;
          int v26 = v16;
          __int16 v27 = 1024;
          int v28 = v17;
          CFStringRef v18 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v12) = v19[0];
        }
        else
        {
          CFStringRef v18 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 0, v18, v18 != &v29, v12, v13, v14);
      }
    }
  }
}

void DumpAllRegisteredVariablesDictionaryApplierFunction(uint64_t a1, CFArrayRef theArray, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    for (CFIndex i = 0; i != v7; ++i)
    {
      CFNumberRef ValueAtIndex = (_DWORD **)CFArrayGetValueAtIndex(theArray, i);
      v18[0] = 0;
      uint64_t os_log_and_send_and_compose_flags = fig_log_emitter_get_os_log_and_send_and_compose_flags(0, v18);
      int v11 = v18[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v14 = v11;
      }
      else {
        unsigned int v14 = v11 & 0xFFFFFFFE;
      }
      if (v14)
      {
        int v15 = *ValueAtIndex[1];
        int v16 = *((_DWORD *)ValueAtIndex + 4);
        v18[1] = 136316162;
        CFStringRef v19 = "";
        __int16 v20 = 2112;
        uint64_t v21 = a3;
        __int16 v22 = 2112;
        uint64_t v23 = a1;
        __int16 v24 = 1024;
        int v25 = v15;
        __int16 v26 = 1024;
        int v27 = v16;
        int v17 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v11) = v18[0];
      }
      else
      {
        int v17 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 0, v17, v17 != &v28, v11, v12, v13);
    }
  }
}

void DumpVariableAppIDDictionaryApplierFunction(void *context, CFDictionaryRef theDict, CFDictionaryApplierFunction applier)
{
}

uint64_t fig_note_configure_external_log_file(const __CFString *a1)
{
  sExternalEchoToOSLog = CFStringCompare(a1, @"external_no_echo_oslog", 1uLL) == kCFCompareEqualTo;
  if (CFStringCompare(a1, @"public", 1uLL))
  {
    sPublicLogFileInUse = 0;
    CFStringRef v2 = (const __CFString *)CFPreferencesCopyAppValue(@"fig_notes_log", @"com.apple.coremedia");
    if (v2)
    {
      CFStringRef v3 = v2;
      CFTypeID v4 = CFGetTypeID(v2);
      if (v4 == CFStringGetTypeID()) {
        CFStringGetCString(v3, sExternalLogfilePath, 1024, 0x8000100u);
      }
      CFRelease(v3);
    }
  }
  else
  {
    sPublicLogFileInUse = 1;
  }
  CFStringRef v5 = (const __CFString *)CFPreferencesCopyAppValue(@"fig_notes_log_limit", @"com.apple.coremedia");
  if (v5)
  {
    CFStringRef v6 = v5;
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 == CFStringGetTypeID())
    {
      sExternalLogfileSizeLimit = CFStringGetIntValue(v6);
    }
    else
    {
      CFTypeID v8 = CFGetTypeID(v6);
      if (v8 == CFNumberGetTypeID()) {
        CFNumberGetValue((CFNumberRef)v6, kCFNumberSInt64Type, &sExternalLogfileSizeLimit);
      }
    }
    if (sExternalLogfileSizeLimit && sExternalLogfileSizeLimit < 0x10000) {
      sExternalLogfileSizeLimit = 0x10000;
    }
    CFRelease(v6);
  }

  return fig_note_open_external_log_file();
}

uint64_t initialize_logRingBuffer()
{
  uint64_t result = FigDebugIsInternalBuild();
  if (result)
  {
    byte_1E9270E60 = 1;
    uint64_t result = (uint64_t)FigReadWriteLockCreate(1);
    sFigNoteRingBufferState = result;
  }
  else
  {
    byte_1E9270E60 = 0;
  }
  return result;
}

uint64_t FigTimeCodeFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigTimeCodeFormatDescriptionRegisterOnce, (void (*)(void))FigTimeCodeFormatDescriptionRegisterOnce);
}

uint64_t FigTimeCodeFormatDescriptionRegisterOnce()
{
  int v1 = 0;
  CFStringRef v5 = figTimeCodeFormatDescriptionFinalize;
  CFTypeID v4 = figTimeCodeFormatDescriptionCopyDebugDesc;
  uint64_t v2 = 32;
  CFStringRef v3 = figTimeCodeFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x746D6364u, (long long *)&v1);
}

OSStatus CMTimeCodeFormatDescriptionCreate(CFAllocatorRef allocator, CMTimeCodeFormatType timeCodeFormatType, CMTime *frameDuration, uint32_t frameQuanta, uint32_t flags, CFDictionaryRef extensions, CMTimeCodeFormatDescriptionRef *formatDescriptionOut)
{
  CFTypeRef cf = 0;
  if (!formatDescriptionOut) {
    goto LABEL_14;
  }
  if ((int)timeCodeFormatType > 1952658995)
  {
    if (timeCodeFormatType != 1952658996)
    {
      int v14 = 1953325924;
LABEL_8:
      if (timeCodeFormatType != v14) {
        goto LABEL_14;
      }
    }
  }
  else if (timeCodeFormatType != 1668166450)
  {
    int v14 = 1668167220;
    goto LABEL_8;
  }
  if ((frameDuration->flags & 1) != 0 && frameQuanta)
  {
    FigThreadRunOnce(&sFigTimeCodeFormatDescriptionRegisterOnce, (void (*)(void))FigTimeCodeFormatDescriptionRegisterOnce);
    OSStatus v15 = FigDerivedFormatDescriptionCreate(allocator, (void *)0x746D6364, timeCodeFormatType, extensions, (uint64_t *)&cf);
    if (v15)
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf);
      CMTimeEpoch epoch = frameDuration->epoch;
      *(_OWORD *)uint64_t DerivedStorage = *(_OWORD *)&frameDuration->value;
      *(void *)(DerivedStorage + 16) = epoch;
      *(_DWORD *)(DerivedStorage + 24) = frameQuanta;
      *(_DWORD *)(DerivedStorage + 28) = flags;
      *CMVideoFormatDescriptionRef formatDescriptionOut = (CMTimeCodeFormatDescriptionRef)cf;
    }
    return v15;
  }
LABEL_14:

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

CMTime *__cdecl CMTimeCodeFormatDescriptionGetFrameDuration(CMTime *__return_ptr retstr, CMTimeCodeFormatDescriptionRef timeCodeFormatDescription)
{
  *(_OWORD *)&retstr->CMTagValue value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (timeCodeFormatDescription)
  {
    uint64_t result = (CMTime *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)timeCodeFormatDescription);
    *(_OWORD *)&retstr->CMTagValue value = *(_OWORD *)&result->value;
    retstr->CMTimeEpoch epoch = result->epoch;
  }
  else
  {
    return (CMTime *)FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint32_t CMTimeCodeFormatDescriptionGetFrameQuanta(CMTimeCodeFormatDescriptionRef timeCodeFormatDescription)
{
  if (timeCodeFormatDescription) {
    return *(_DWORD *)(FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)timeCodeFormatDescription) + 24);
  }
  FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint32_t CMTimeCodeFormatDescriptionGetTimeCodeFlags(CMTimeCodeFormatDescriptionRef desc)
{
  if (desc) {
    return *(_DWORD *)(FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc) + 28);
  }
  FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  return 0;
}

__CFString *figTimeCodeFormatDescriptionCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v3, 0);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  long long v6 = *(_OWORD *)DerivedStorage;
  time.CMTimeEpoch epoch = *(void *)(DerivedStorage + 16);
  *(_OWORD *)&time.CMTagValue value = v6;
  CFStringRef v7 = CMTimeCopyDescription(v5, &time);
  CFStringAppendFormat(Mutable, 0, @"\t\tframeDuration: %@", v7);
  CFRelease(v7);
  CFStringAppendFormat(Mutable, 0, @"\t\tframes/sec: %d", *(unsigned int *)(DerivedStorage + 24));
  CFStringAppendFormat(Mutable, 0, @"\t\ttcFlags: %d", *(unsigned int *)(DerivedStorage + 28));
  return Mutable;
}

BOOL figTimeCodeFormatDescriptionEqual(uint64_t a1, const opaqueCMFormatDescription *a2, unint64_t a3, unint64_t a4)
{
  CFStringRef v7 = (const opaqueCMFormatDescription *)a1;
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage(a1);
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(v7);
  uint64_t v10 = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a2);
  CFDictionaryRef v11 = CMFormatDescriptionGetExtensions(a2);
  LODWORD(v7) = CMFormatDescriptionGetMediaSubType(v7);
  if (v7 == CMFormatDescriptionGetMediaSubType(a2)
    && (long long v12 = *(_OWORD *)DerivedStorage,
        time1.CMTimeEpoch epoch = *(void *)(DerivedStorage + 16),
        *(_OWORD *)&time1.CMTagValue value = v12,
        long long v13 = *(_OWORD *)v10,
        v15.CMTimeEpoch epoch = *(void *)(v10 + 16),
        *(_OWORD *)&v15.CMTagValue value = v13,
        !CMTimeCompare(&time1, &v15))
    && *(_DWORD *)(DerivedStorage + 24) == *(_DWORD *)(v10 + 24)
    && *(_DWORD *)(DerivedStorage + 28) == *(_DWORD *)(v10 + 28))
  {
    return FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(Extensions, v11, a3, a4) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t FigSandboxRegistrationAssociateWithURL(FigSandboxRegistrationObjCWrapper *a1, void *a2)
{
  uint64_t v2 = a1;
  if (a1)
  {
    if (a2)
    {
      id v4 = objc_alloc_init(MEMORY[0x1E4F28B28]);
      uint64_t v2 = [[FigSandboxRegistrationObjCWrapper alloc] initWithRegistration:v2];
      if (v2)
      {
        objc_setAssociatedObject(a2, &urlSBRegKey, v2, (void *)0x301);
        uint64_t v5 = 0;
      }
      else
      {
        uint64_t v5 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      uint64_t v5 = FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
      id v4 = 0;
      uint64_t v2 = 0;
    }
  }
  else
  {
    uint64_t v5 = FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
    id v4 = 0;
  }

  [v4 drain];
  return v5;
}

uint64_t FigGetSandboxRegistrationAssociatedWithURL(void *a1, void *a2)
{
  if (a1 && a2)
  {
    id v4 = (void *)MEMORY[0x192FC5D30]();
    id AssociatedObject = objc_getAssociatedObject(a1, &urlSBRegKey);
    if (AssociatedObject) {
      id AssociatedObject = (id)[AssociatedObject _sandboxRegistration];
    }
    *a2 = AssociatedObject;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCreateBase32EncodedStringFromBytes(const __CFAllocator *a1, uint64_t a2, uint64_t a3, int a4, CFStringRef *a5)
{
  if (a2 && a3 && a5) {
    return figNumericsCreateEncodedStringFromBytes(a1, 5uLL, "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", a2, a3, a4, a5);
  }
  else {
    return FigSignalErrorAt(4294949846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figNumericsCreateEncodedStringFromBytes(const __CFAllocator *a1, unint64_t a2, char *__s, uint64_t a4, uint64_t a5, int a6, CFStringRef *a7)
{
  if (strlen(__s) >> a2)
  {
    if (a6) {
      CFIndex v14 = (a2 + 8 * a5 - 1) / a2 + 8;
    }
    else {
      CFIndex v14 = (a2 + 8 * a5 - 1) / a2;
    }
    CMTime v15 = (const UInt8 *)CFAllocatorAllocate(a1, v14, 0);
    int v16 = (UInt8 *)v15;
    if (!v15)
    {
LABEL_24:
      uint64_t v29 = 4294949845;
      goto LABEL_26;
    }
    if (a5)
    {
      uint64_t v17 = 0;
      int v18 = 0;
      unint64_t v19 = 0;
      unsigned int v20 = 0;
      do
      {
        unsigned int v20 = *(unsigned __int8 *)(a4 + v17) | (v20 << 8);
        if (v19 + 8 >= a2)
        {
          uint64_t v21 = (UInt8 *)&v15[v18];
          int v22 = 8 - a2 + v19;
          v19 += 8;
          do
          {
            *v21++ = __s[(unint64_t)v20 >> v22];
            v19 -= a2;
            v20 &= ~(-1 << v22);
            ++v18;
            v22 -= a2;
          }
          while (v19 >= a2);
        }
        else
        {
          v19 += 8;
        }
        ++v17;
      }
      while (v17 != a5);
      if (v19) {
        v15[v18++] = __s[v20 << (a2 - v19)];
      }
      if (!a6)
      {
LABEL_22:
        CFStringRef v26 = CFStringCreateWithBytesNoCopy(a1, v15, v18, 0x8000100u, 0, a1);
        uint64_t v27 = 0;
        *a7 = v26;
        if (v26) {
          return v27;
        }
        goto LABEL_24;
      }
    }
    else
    {
      int v18 = 0;
      if (!a6) {
        goto LABEL_22;
      }
    }
    if ((((_BYTE)v18 * (_BYTE)a2) & 7) != 0)
    {
      unint64_t v23 = a2 + a2 * v18;
      __int16 v24 = (UInt8 *)&v15[v18];
      do
      {
        *v24++ = 61;
        ++v18;
        BOOL v25 = (v23 & 7) == 0;
        v23 += a2;
      }
      while (!v25);
    }
    goto LABEL_22;
  }
  int v16 = 0;
  uint64_t v29 = 4294949846;
LABEL_26:
  uint64_t v27 = FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
  if (v27) {
    CFAllocatorDeallocate(a1, v16);
  }
  return v27;
}

uint64_t FigCreateBase64EncodedStringFromBytes(const __CFAllocator *a1, uint64_t a2, uint64_t a3, int a4, CFStringRef *a5)
{
  if (a2 && a3 && a5) {
    return figNumericsCreateEncodedStringFromBytes(a1, 6uLL, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a2, a3, a4, a5);
  }
  else {
    return FigSignalErrorAt(4294949846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCreateBase64EncodedStringFromCFData(const __CFAllocator *a1, CFDataRef theData, int a3, CFStringRef *a4)
{
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    return FigCreateBase64EncodedStringFromBytes(a1, (uint64_t)BytePtr, Length, a3, a4);
  }
  else
  {
    return FigSignalErrorAt(4294949846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCreateHexStringFromCFData(const __CFAllocator *a1, const __CFData *a2, int a3, CFStringRef *a4)
{
  if (a4)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(a1, 0);
    if (Mutable)
    {
      char v9 = Mutable;
      if (a2)
      {
        BytePtr = CFDataGetBytePtr(a2);
        CFStringAppendFormat(v9, 0, @"0x");
        CFIndex Length = CFDataGetLength(a2);
        unint64_t v12 = Length;
        if (a3)
        {
          if (Length >= 1)
          {
            CFIndex v13 = 0;
            do
              CFStringAppendFormat(v9, 0, @"%02x", BytePtr[v13++]);
            while (v13 < CFDataGetLength(a2));
          }
        }
        else if (Length >= 1)
        {
          CFIndex v14 = BytePtr - 1;
          do
            CFStringAppendFormat(v9, 0, @"%02x", v14[v12]);
          while (v12-- > 1);
        }
        CFStringRef Copy = CFStringCreateCopy(a1, v9);
        *a4 = Copy;
        if (Copy)
        {
          uint64_t v17 = 0;
LABEL_14:
          CFRelease(v9);
          return v17;
        }
        uint64_t v20 = 4294949845;
      }
      else
      {
        uint64_t v20 = 4294949846;
      }
      uint64_t v17 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
      goto LABEL_14;
    }
    uint64_t v19 = 4294949845;
  }
  else
  {
    uint64_t v19 = 4294949846;
  }

  return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionData(CFAllocatorRef allocator, const uint8_t *timeCodeDescriptionData, size_t size, CMTimeCodeDescriptionFlavor flavor, CMTimeCodeFormatDescriptionRef *formatDescriptionOut)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  memset(&v55, 0, sizeof(v55));
  CMTimeCodeFormatDescriptionRef formatDescriptionOuta = 0;
  if (timeCodeDescriptionData)
  {
    if (size < 0x22 || !formatDescriptionOut)
    {
      OSStatus v25 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      CFDictionaryRef v29 = 0;
LABEL_72:
      if (formatDescriptionOuta) {
        CFRelease(formatDescriptionOuta);
      }
      goto LABEL_74;
    }
    unsigned int v9 = *((_DWORD *)timeCodeDescriptionData + 1);
    unsigned int v51 = *((_DWORD *)timeCodeDescriptionData + 7);
    unsigned int v52 = *((_DWORD *)timeCodeDescriptionData + 6);
    size_t v10 = 34;
    uint32_t v11 = timeCodeDescriptionData[32];
    unsigned int v53 = *((_DWORD *)timeCodeDescriptionData + 5);
    do
    {
      if (v10 + 8 > size) {
        goto LABEL_10;
      }
      unint64_t v12 = &timeCodeDescriptionData[v10];
      unsigned int v13 = bswap32(*(_DWORD *)&timeCodeDescriptionData[v10]);
      unsigned int v14 = v13 - 8;
      if (v13 < 8) {
        goto LABEL_10;
      }
      v10 += v13;
      if (v10 > size) {
        goto LABEL_25;
      }
    }
    while (*((_DWORD *)v12 + 1) != 1701667182);
    if (v14 >= 4)
    {
      unsigned int v32 = *((unsigned __int16 *)v12 + 4);
      CMTime v15 = v12 + 8;
      uint64_t v16 = bswap32(v32) >> 16;
      if (v16 + 4 > (unint64_t)v14)
      {
LABEL_25:
        uint64_t v30 = 4294954582;
        goto LABEL_26;
      }
      unsigned int v17 = 2;
    }
    else
    {
LABEL_10:
      CMTime v15 = 0;
      LODWORD(v16) = 0;
      unsigned int v17 = 1;
    }
    size_t v18 = v17;
    uint64_t v19 = (__CFString **)malloc_type_calloc(v17, 8uLL, 0x6004044C4A2DFuLL);
    if (v19)
    {
      uint64_t v20 = v19;
      uint32_t v50 = v11;
      uint64_t v21 = (const void **)malloc_type_calloc(v18, 8uLL, 0xC0040B8AA526DuLL);
      if (v21)
      {
        int v22 = @"VerbatimSampleDescription";
        if (@"VerbatimSampleDescription") {
          int v22 = (__CFString *)CFRetain(@"VerbatimSampleDescription");
        }
        *uint64_t v20 = v22;
        *uint64_t v21 = CFDataCreate(allocator, timeCodeDescriptionData, size);
        if (v15)
        {
          unsigned int v23 = bswap32(*((unsigned __int16 *)v15 + 1));
          __int16 valuePtr = HIWORD(v23);
          keys.CMTagValue value = 0;
          *(void *)&keys.timescale = 0;
          values = 0;
          CFNumberRef v60 = 0;
          CFTypeRef cf = 0;
          OSStatus v24 = FigCFStringCreateWithBytesAndMovieLangCode(allocator, v15 + 4, v16, HIWORD(v23), 0, (CFStringRef *)&cf);
          if (v24)
          {
            OSStatus v25 = v24;
            CFDictionaryRef v26 = 0;
            CFNumberRef v27 = 0;
          }
          else
          {
            keys.CMTagValue value = (CMTimeValue)@"TimeCode_SourceReferenceName_Value";
            values = (void *)cf;
            CFNumberRef v34 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt16Type, &valuePtr);
            CFNumberRef v27 = v34;
            if (v34
              && (*(void *)&keys.timescale = @"TimeCode_SourceReferenceName_LangCode",
                  CFNumberRef v60 = v34,
                  (CFDictionaryRef v35 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 2, 0, MEMORY[0x1E4F1D540])) != 0))
            {
              CFDictionaryRef v26 = v35;
              OSStatus v25 = 0;
            }
            else
            {
              OSStatus v25 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              CFDictionaryRef v26 = 0;
            }
          }
          if (cf) {
            CFRelease(cf);
          }
          if (v27) {
            CFRelease(v27);
          }
          if (v25) {
            goto LABEL_48;
          }
          uint64_t v36 = @"TimeCode_SourceReferenceName";
          if (@"TimeCode_SourceReferenceName") {
            uint64_t v36 = (__CFString *)CFRetain(@"TimeCode_SourceReferenceName");
          }
          v20[1] = v36;
          v21[1] = v26;
          int v33 = 2;
        }
        else
        {
          int v33 = 1;
        }
        if (v18 == v33)
        {
          CFDictionaryRef v29 = CFDictionaryCreate(allocator, (const void **)v20, v21, v18, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (v29) {
            OSStatus v25 = 0;
          }
          else {
            OSStatus v25 = -12711;
          }
          goto LABEL_49;
        }
        uint64_t v31 = 4294954584;
      }
      else
      {
        uint64_t v31 = 4294954583;
      }
      OSStatus v25 = FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
LABEL_48:
      CFDictionaryRef v29 = 0;
LABEL_49:
      unint64_t v37 = 0;
      uint64_t v38 = 8 * v18;
      do
      {
        int v39 = v20[v37 / 8];
        if (v39) {
          CFRelease(v39);
        }
        v37 += 8;
      }
      while (v38 != v37);
      free(v20);
      if (v21)
      {
        unint64_t v40 = 0;
        do
        {
          size_t v41 = v21[v40 / 8];
          if (v41) {
            CFRelease(v41);
          }
          v40 += 8;
        }
        while (v38 != v40);
        free(v21);
      }
      uint32_t v11 = v50;
      if (v25) {
        goto LABEL_72;
      }
LABEL_60:
      CMTimeMake(&v55, (int)bswap32(v51), bswap32(v52));
      unsigned int v42 = bswap32(v9);
      unsigned int v43 = bswap32(v53);
      int v44 = 1952658996;
      if (v42 == 1952658996)
      {
        int v46 = 1668167220;
        BOOL v45 = (v43 & 8) == 0;
      }
      else
      {
        int v44 = 1953325924;
        if (v42 != 1953325924)
        {
          OSStatus v49 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
          if (v49)
          {
            OSStatus v25 = v49;
            goto LABEL_72;
          }
          uint32_t v48 = 0;
          CMTimeCodeFormatType v47 = 0;
          goto LABEL_68;
        }
        BOOL v45 = (v43 & 8) == 0;
        int v46 = 1668166450;
      }
      if (v45) {
        CMTimeCodeFormatType v47 = v44;
      }
      else {
        CMTimeCodeFormatType v47 = v46;
      }
      uint32_t v48 = v43 & 0xFFFFFFF7;
LABEL_68:
      CMTime keys = v55;
      OSStatus v25 = CMTimeCodeFormatDescriptionCreate(allocator, v47, &keys, v11, v48, v29, &formatDescriptionOuta);
      if (v25) {
        goto LABEL_72;
      }
      *CMVideoFormatDescriptionRef formatDescriptionOut = formatDescriptionOuta;
      CMTimeCodeFormatDescriptionRef formatDescriptionOuta = 0;
LABEL_74:
      if (v29) {
        CFRelease(v29);
      }
      return v25;
    }
    uint64_t v30 = 4294954583;
LABEL_26:
    OSStatus v25 = FigSignalErrorAt(v30, 0, 0, 0, 0, 0, 0);
    CFDictionaryRef v29 = 0;
    if (v25) {
      goto LABEL_72;
    }
    goto LABEL_60;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef timeCodeDescriptionBlockBuffer, CMTimeCodeDescriptionFlavor flavor, CMTimeCodeFormatDescriptionRef *formatDescriptionOut)
{
  CMBlockBufferRef theBuffer = 0;
  if (timeCodeDescriptionBlockBuffer && formatDescriptionOut)
  {
    dataPointerOut = 0;
    DataCFIndex Length = CMBlockBufferGetDataLength(timeCodeDescriptionBlockBuffer);
    if (CMBlockBufferIsRangeContiguous(timeCodeDescriptionBlockBuffer, 0, 0))
    {
      CFTypeID v8 = (OpaqueCMBlockBuffer *)CFRetain(timeCodeDescriptionBlockBuffer);
      CMBlockBufferRef theBuffer = v8;
    }
    else
    {
      OSStatus v10 = CMBlockBufferCreateContiguous(allocator, timeCodeDescriptionBlockBuffer, allocator, 0, 0, DataLength, 0, &theBuffer);
      CFTypeID v8 = theBuffer;
      if (v10)
      {
LABEL_10:
        if (v8) {
          CFRelease(v8);
        }
        return v10;
      }
    }
    CMBlockBufferGetDataPointer(v8, 0, 0, 0, &dataPointerOut);
    OSStatus v10 = CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionData(allocator, (const uint8_t *)dataPointerOut, DataLength, v11, formatDescriptionOut);
    CFTypeID v8 = theBuffer;
    goto LABEL_10;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTimeCodeFormatDescriptionCopyAsBigEndianTimeCodeDescriptionBlockBuffer(CFAllocatorRef allocator, CMTimeCodeFormatDescriptionRef timeCodeFormatDescription, CMTimeCodeDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  unsigned __int16 v37 = 0;
  size_t v35 = 0;
  ptr = 0;
  dataPointerOut = 0;
  CMBlockBufferRef theBuffer = 0;
  if (!timeCodeFormatDescription) {
    goto LABEL_19;
  }
  CFTypeID TypeID = CMFormatDescriptionGetTypeID();
  if (TypeID != CFGetTypeID(timeCodeFormatDescription)
    || CMFormatDescriptionGetMediaType(timeCodeFormatDescription) != 1953325924)
  {
    goto LABEL_19;
  }
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(timeCodeFormatDescription);
  signed int v9 = MediaSubType;
  if (MediaSubType > 1952658995)
  {
    if (MediaSubType == 1952658996) {
      goto LABEL_11;
    }
    int v10 = 1953325924;
  }
  else
  {
    if (MediaSubType == 1668166450) {
      goto LABEL_11;
    }
    int v10 = 1668167220;
  }
  if (MediaSubType != v10)
  {
LABEL_19:
    OSStatus v22 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
LABEL_11:
  if (!blockBufferOut) {
    goto LABEL_19;
  }
  CMTimeCodeFormatDescriptionGetFrameDuration(&v32, timeCodeFormatDescription);
  if ((v32.flags & 1) == 0) {
    goto LABEL_19;
  }
  unsigned int value = v32.value;
  CMTimeScale timescale = v32.timescale;
  uint32_t FrameQuanta = CMTimeCodeFormatDescriptionGetFrameQuanta(timeCodeFormatDescription);
  if (!FrameQuanta) {
    goto LABEL_19;
  }
  char v14 = FrameQuanta;
  uint32_t TimeCodeFlags = CMTimeCodeFormatDescriptionGetTimeCodeFlags(timeCodeFormatDescription);
  CFDataRef Extension = (const __CFData *)CMFormatDescriptionGetExtension(timeCodeFormatDescription, @"VerbatimSampleDescription");
  if (!Extension || (CFDataRef v17 = Extension, v18 = CFGetTypeID(Extension), v18 != CFDataGetTypeID()))
  {
    CFDictionaryRef v24 = (const __CFDictionary *)CMFormatDescriptionGetExtension(timeCodeFormatDescription, @"TimeCode_SourceReferenceName");
    if (v24
      && (v25 = v24, CFTypeID v26 = CFGetTypeID(v24), v26 == CFDictionaryGetTypeID())
      && !createaSourceReferenceNameStringFromDictionary(allocator, v25, &v37, (UInt8 **)&ptr, &v35))
    {
      unsigned int v27 = v35 + 12;
    }
    else
    {
      unsigned int v27 = 0;
    }
    OSStatus DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, v27 + 34, allocator, 0, 0, v27 + 34, 1u, &theBuffer);
    if (DataPointer) {
      goto LABEL_21;
    }
    OSStatus DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    if (DataPointer) {
      goto LABEL_21;
    }
    if (v9 > 1952658995)
    {
      if (v9 == 1953325924) {
        goto LABEL_42;
      }
      if (v9 == 1952658996)
      {
        signed int v9 = 1952658996;
        goto LABEL_42;
      }
    }
    else
    {
      if (v9 == 1668166450)
      {
        TimeCodeFlags |= 8u;
        signed int v9 = 1953325924;
        goto LABEL_42;
      }
      if (v9 == 1668167220)
      {
        signed int v9 = 1952658996;
        TimeCodeFlags |= 8u;
LABEL_42:
        char v28 = dataPointerOut;
        *(_DWORD *)dataPointerOut = bswap32(v27 + 34);
        *((_DWORD *)v28 + 1) = bswap32(v9);
        *((void *)v28 + 1) = 0xFFFF000000000000;
        *((_DWORD *)v28 + 4) = 0;
        *((_DWORD *)v28 + 5) = bswap32(TimeCodeFlags);
        *((_DWORD *)v28 + 6) = bswap32(timescale);
        *((_DWORD *)v28 + 7) = bswap32(value);
        v28[32] = v14;
        v28[33] = 0;
        if (!v27)
        {
LABEL_45:
          OSStatus DataPointer = 0;
          goto LABEL_46;
        }
        v32.unsigned int value = 0;
        OSStatus v22 = CMBlockBufferGetDataPointer(theBuffer, 0x22uLL, 0, 0, (char **)&v32);
        if (!v22)
        {
          *(_DWORD *)v32.unsigned int value = bswap32(v27);
          *(_DWORD *)(v32.value + 4) = 1701667182;
          CMTimeValue v29 = v32.value;
          size_t v31 = v35;
          uint64_t v30 = ptr;
          *(_WORD *)(v32.value + 8) = bswap32(v35) >> 16;
          *(_WORD *)(v29 + 10) = bswap32(v37) >> 16;
          memmove((void *)(v29 + 12), v30, v31);
          goto LABEL_45;
        }
LABEL_20:
        OSStatus DataPointer = v22;
        goto LABEL_21;
      }
    }
    signed int v9 = 0;
    goto LABEL_42;
  }
  size_t Length = CFDataGetLength(v17);
  BytePtr = CFDataGetBytePtr(v17);
  v32.unsigned int value = 0;
  OSStatus DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, Length, allocator, 0, 0, Length, 1u, &theBuffer);
  if (!DataPointer)
  {
    OSStatus DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, (char **)&v32);
    if (!DataPointer)
    {
      memcpy((void *)v32.value, BytePtr, Length);
LABEL_46:
      *CMBlockBufferRef blockBufferOut = theBuffer;
      CMBlockBufferRef theBuffer = 0;
    }
  }
LABEL_21:
  if (ptr) {
    CFAllocatorDeallocate(allocator, ptr);
  }
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return DataPointer;
}

uint64_t createaSourceReferenceNameStringFromDictionary(const __CFAllocator *a1, CFDictionaryRef theDict, unsigned __int16 *a3, UInt8 **a4, void *a5)
{
  unsigned __int16 valuePtr = 0;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"TimeCode_SourceReferenceName_Value");
  CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"TimeCode_SourceReferenceName_LangCode");
  if (Value) {
    BOOL v12 = v11 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12) {
    return 4294954584;
  }
  uint64_t v15 = 0;
  CFNumberGetValue(v11, kCFNumberSInt16Type, &valuePtr);
  unsigned int v13 = FigCreateBytesFromCFStringAndMovieLangCode(a1, Value, valuePtr, 0, &v15);
  uint64_t result = 0;
  *a3 = valuePtr;
  *a4 = v13;
  *a5 = v15;
  return result;
}

OSStatus CMSwapBigEndianTimeCodeDescriptionToHost(uint8_t *timeCodeDescriptionData, size_t timeCodeDescriptionSize)
{
  return 0;
}

int8x8_t figBridge_FlipTimeCodeDescriptionData(uint64_t a1, unint64_t a2)
{
  if (a1 && a2 > 0x21)
  {
    int8x8_t result = vrev32_s8(*(int8x8_t *)a1);
    unsigned int v3 = bswap32(*(_DWORD *)(a1 + 8));
    unsigned int v4 = bswap32(*(unsigned __int16 *)(a1 + 12)) >> 16;
    unsigned int v5 = bswap32(*(unsigned __int16 *)(a1 + 14)) >> 16;
    int8x16_t v6 = vrev32q_s8(*(int8x16_t *)(a1 + 16));
    *(int8x8_t *)a1 = result;
    *(_DWORD *)(a1 + 8) = v3;
    *(_WORD *)(a1 + 12) = v4;
    *(_WORD *)(a1 + 14) = v5;
    *(int8x16_t *)(a1 + 16) = v6;
  }
  else
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

OSStatus CMSwapHostEndianTimeCodeDescriptionToBig(uint8_t *timeCodeDescriptionData, size_t timeCodeDescriptionSize)
{
  return 0;
}

size_t FigBlockBufferHexDumpWithEmitter(OpaqueCMBlockBuffer *a1, size_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6, uint64_t (*a7)(uint64_t a1, const char *a2), uint64_t a8)
{
  char *returnedPointerOut;
  char __str[1024];
  long long v79;
  long long v80;
  long long v81;
  long long v82;
  long long v83;
  long long v84;
  long long v85;
  long long v86;
  char temporaryBlock[128];
  uint64_t v88;

  char v9 = a6;
  size_t v88 = *MEMORY[0x1E4F143B8];
  char v86 = 0u;
  unsigned __int8 v85 = 0u;
  char v84 = 0u;
  CFTypeID v83 = 0u;
  CFTypeID v82 = 0u;
  CFPropertyListRef v81 = 0u;
  uint64_t v80 = 0u;
  unsigned __int16 v79 = 0u;
  char v14 = "%#6zx: ";
  if ((a6 & 2) == 0) {
    char v14 = "%5zd: ";
  }
  uint64_t v15 = "/* %#6zx: */ ";
  if ((a6 & 2) == 0) {
    uint64_t v15 = "/* %5zd: */ ";
  }
  if ((a6 & 0x10) != 0) {
    char v14 = v15;
  }
  unint64_t v67 = (char *)v14;
  if ((a6 & 0x10) != 0) {
    int v16 = 0;
  }
  else {
    int v16 = a6 & 1;
  }
  int v70 = v16;
  if ((a6 & 0x10) != 0) {
    int v17 = 0;
  }
  else {
    int v17 = (a6 >> 2) & 1;
  }
  int v69 = v17;
  if ((a6 & 0x10) != 0) {
    int v18 = 0;
  }
  else {
    int v18 = (((a6 >> 2) & 1) == 0) & (a6 >> 3);
  }
  size_t result = CMBlockBufferGetDataLength(a1);
  size_t offset = a2;
  size_t v66 = result;
  unint64_t v20 = result - a2;
  if (result > a2)
  {
    returnedPointerOut = 0;
    if (a7) {
      uint64_t v21 = a7;
    }
    else {
      uint64_t v21 = DefaultBBufHexDumpEmitter;
    }
    unsigned int v71 = v21;
    uint64_t v22 = 128;
    if (a5 < 0x80) {
      uint64_t v22 = a5;
    }
    if (a5) {
      unint64_t v23 = v22;
    }
    else {
      unint64_t v23 = 16;
    }
    if (v20 >= a3) {
      unint64_t v24 = a3;
    }
    else {
      unint64_t v24 = result - a2;
    }
    if (a3) {
      unint64_t v20 = v24;
    }
    unint64_t v25 = v23 * a4;
    if (v20 < v23 * a4) {
      unint64_t v25 = v20;
    }
    if (a4 > 0) {
      unint64_t v20 = v25;
    }
    unint64_t v65 = v20;
    if (v20)
    {
      uint64_t v74 = 0;
      int v26 = 0;
      size_t v27 = v20;
      size_t v28 = a2;
      while (1)
      {
        if (v27 >= v23) {
          size_t v29 = v23;
        }
        else {
          size_t v29 = v27;
        }
        if (v69)
        {
          char v86 = 0u;
          unsigned __int8 v85 = 0u;
          char v84 = 0u;
          CFTypeID v83 = 0u;
          CFTypeID v82 = 0u;
          CFPropertyListRef v81 = 0u;
          uint64_t v80 = 0u;
          unsigned __int16 v79 = 0u;
          if (v29)
          {
            uint64_t v30 = 0;
            size_t v31 = v29;
            size_t v32 = v28;
            do
            {
              size_t lengthAtOffsetOut = 0;
              CMBlockBufferGetDataPointer(a1, v32, &lengthAtOffsetOut, 0, 0);
              BOOL v33 = v31 >= lengthAtOffsetOut;
              v31 -= lengthAtOffsetOut;
              if (!v33) {
                break;
              }
              v30 += lengthAtOffsetOut;
              v32 += lengthAtOffsetOut;
              *((unsigned char *)&v79 + v30 - 1) = 1;
            }
            while (v31);
          }
        }
        size_t v34 = v27 - v29;
        CMBlockBufferAccessDataBytes(a1, v28, v29, temporaryBlock, &returnedPointerOut);
        if (v70 && v34)
        {
          if (!v29)
          {
LABEL_51:
            ++v26;
            v74 += v29;
            goto LABEL_125;
          }
          size_t v35 = returnedPointerOut;
          size_t v36 = v29;
          while (!*v35++)
          {
            if (!--v36) {
              goto LABEL_51;
            }
          }
        }
        size_t v72 = v27 - v29;
        if (v26)
        {
          snprintf(__str, 0x400uLL, "    * %zd zeroes", v74);
          size_t result = v71(a8, __str);
          if (result) {
            return result;
          }
          uint64_t v74 = 0;
        }
        uint64_t v38 = fmtcheck(v67, "%zd");
        int v39 = snprintf(__str, 0x400uLL, v38, v28 - offset);
        int v40 = 1024 - v39;
        if (v39 >= 1024) {
          int v41 = 0;
        }
        else {
          int v41 = v39;
        }
        unsigned int v42 = &__str[v41];
        if (v39 >= 1024) {
          int v40 = 0;
        }
        if (v29)
        {
          uint64_t v43 = 0;
          do
          {
            int v44 = v40;
            if ((v9 & 0x10) != 0)
            {
              int v46 = snprintf(v42, v40, "0x%02X, ", returnedPointerOut[v43++]);
            }
            else
            {
              if (!v18 || (BOOL v45 = "", (((_BYTE)v43 + 1) & 3) == 0))
              {
                BOOL v45 = " ";
                if (*((unsigned char *)&v79 + v43)) {
                  BOOL v45 = "|";
                }
              }
              int v46 = snprintf(v42, v40, "%02X%s", returnedPointerOut[v43++], v45);
            }
            int v40 = v44 - v46;
            if (v44 <= v46) {
              int v47 = 0;
            }
            else {
              int v47 = v46;
            }
            v42 += v47;
            if (v44 <= v46) {
              int v40 = 0;
            }
          }
          while (v43 != v29);
        }
        int v48 = v40;
        size_t v49 = v29;
        if (v23 > v27)
        {
          do
          {
            if ((v9 & 0x10) != 0)
            {
              int v52 = snprintf(v42, v48, "      ");
              ++v49;
            }
            else
            {
              BOOL v50 = (++v49 & 3) == 0 || v18 == 0;
              unsigned int v51 = "";
              if (v50) {
                unsigned int v51 = " ";
              }
              int v52 = snprintf(v42, v48, "  %s", v51);
            }
            if (v48 <= v52) {
              int v53 = 0;
            }
            else {
              int v53 = v52;
            }
            v42 += v53;
            if (v48 <= v52) {
              int v48 = 0;
            }
            else {
              v48 -= v52;
            }
          }
          while (v49 != v23);
        }
        int v54 = snprintf(v42, v48, "  ");
        if (v48 <= v54) {
          int v55 = 0;
        }
        else {
          int v55 = v54;
        }
        unint64_t v56 = &v42[v55];
        if (v48 <= v54) {
          int v57 = 0;
        }
        else {
          int v57 = v48 - v54;
        }
        if ((v9 & 0x10) == 0)
        {
          if (v29) {
            break;
          }
          goto LABEL_121;
        }
        int v58 = snprintf(v56, v57, "/* ");
        if (v57 <= v58)
        {
          int v57 = 0;
        }
        else
        {
          v56 += v58;
          v57 -= v58;
        }
        if (v29) {
          break;
        }
LABEL_121:
        if ((v9 & 0x10) != 0) {
          snprintf(v56, v57, " */");
        }
        size_t result = v71(a8, __str);
        size_t v34 = v72;
        if (result) {
          return result;
        }
        int v26 = 0;
LABEL_125:
        v28 += v29;
        size_t v27 = v34;
        if (!v34) {
          goto LABEL_126;
        }
      }
      uint64_t v59 = 0;
      while (1)
      {
        unsigned int v60 = returnedPointerOut[v59];
        if (returnedPointerOut[v59] < 0)
        {
          if (!__maskrune(returnedPointerOut[v59], 0x40000uLL))
          {
LABEL_113:
            uint64_t v62 = 46;
            goto LABEL_114;
          }
          int v61 = __maskrune(v60, 0x200uLL);
        }
        else
        {
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * returnedPointerOut[v59] + 60) & 0x40000) == 0) {
            goto LABEL_113;
          }
          int v61 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * returnedPointerOut[v59] + 60) & 0x200;
        }
        if (v61) {
          uint64_t v62 = 46;
        }
        else {
          uint64_t v62 = v60;
        }
LABEL_114:
        int v63 = snprintf(v56, v57, "%c", v62);
        if (v57 <= v63) {
          int v64 = 0;
        }
        else {
          int v64 = v63;
        }
        v56 += v64;
        if (v57 <= v63) {
          int v57 = 0;
        }
        else {
          v57 -= v63;
        }
        if (v29 == ++v59) {
          goto LABEL_121;
        }
      }
    }
LABEL_126:
    if (v65 + offset < v66) {
      v71(a8, "  ...");
    }
    return v71(a8, 0);
  }
  return result;
}

uint64_t DefaultBBufHexDumpEmitter(uint64_t a1, const char *a2)
{
  if (a2) {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s\n", a2);
  }
  return 0;
}

size_t FigBlockBufferHexDump(OpaqueCMBlockBuffer *a1, size_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6)
{
  return FigBlockBufferHexDumpWithEmitter(a1, a2, a3, a4, a5, a6, DefaultBBufHexDumpEmitter, 0);
}

size_t FigBlockBufferAppendHexDumpToCFString(OpaqueCMBlockBuffer *a1, size_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6, uint64_t a7)
{
  return FigBlockBufferHexDumpWithEmitter(a1, a2, a3, a4, a5, a6, (uint64_t (*)(uint64_t, const char *))cfStringBBufHexDumpEmitter, a7);
}

uint64_t cfStringBBufHexDumpEmitter(__CFString *a1, uint64_t a2)
{
  if (a2) {
    CFStringAppendFormat(a1, 0, @"%s\n", a2);
  }
  return 0;
}

uint64_t FigBlockBufferCompare(OpaqueCMBlockBuffer *a1, OpaqueCMBlockBuffer *a2)
{
  Datasize_t Length = CMBlockBufferGetDataLength(a1);
  size_t v5 = CMBlockBufferGetDataLength(a2);
  if (DataLength == v5)
  {
    size_t v6 = 0;
    while (1)
    {
      size_t v12 = 0;
      size_t lengthAtOffsetOut = 0;
      int v10 = 0;
      dataPointerOut = 0;
      CMBlockBufferGetDataPointer(a1, v6, &lengthAtOffsetOut, 0, &dataPointerOut);
      CMBlockBufferGetDataPointer(a2, v6, &v12, 0, &v10);
      size_t v7 = lengthAtOffsetOut >= v12 ? v12 : lengthAtOffsetOut;
      if (!v7) {
        break;
      }
      uint64_t result = memcmp(dataPointerOut, v10, v7);
      v6 += v7;
      if (result) {
        BOOL v9 = 1;
      }
      else {
        BOOL v9 = v6 >= DataLength;
      }
      if (v9) {
        return result;
      }
    }
    if (lengthAtOffsetOut == v12) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else if (DataLength > v5)
  {
    return 1;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t FigCreateCFDataWithBlockBufferNoCopy(const __CFAllocator *a1, CMBlockBufferRef theBuffer, size_t offset, unint64_t a4, CFDataRef *a5)
{
  if (a5)
  {
    dataPointerOut = 0;
    size_t lengthAtOffsetOut = 0;
    uint64_t result = CMBlockBufferGetDataPointer(theBuffer, offset, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (result)
    {
LABEL_15:
      CFDataRef v14 = 0;
      goto LABEL_9;
    }
    if (a4)
    {
      if (lengthAtOffsetOut < a4)
      {
        uint64_t v11 = 4294954592;
LABEL_14:
        uint64_t result = FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
        goto LABEL_15;
      }
    }
    else
    {
      a4 = lengthAtOffsetOut;
    }
    context.version = 0;
    context.info = theBuffer;
    context.retain = (CFAllocatorRetainCallBack)MEMORY[0x1E4F1C280];
    context.release = (CFAllocatorReleaseCallBack)MEMORY[0x1E4F1C278];
    context.copyDescription = 0;
    context.deallocate = (CFAllocatorDeallocateCallBack)BBufUtilDummyDeallocate;
    context.preferredSize = 0;
    context.allocate = (CFAllocatorAllocateCallBack)BBufUtilDummyAllocate;
    context.reallocate = 0;
    CFAllocatorRef v12 = CFAllocatorCreate(a1, &context);
    if (v12)
    {
      CFAllocatorRef v13 = v12;
      CFDataRef v14 = CFDataCreateWithBytesNoCopy(a1, (const UInt8 *)dataPointerOut, a4, v12);
      CFRelease(v13);
      uint64_t result = 0;
LABEL_9:
      *a5 = v14;
      return result;
    }
    uint64_t v11 = 4294954596;
    goto LABEL_14;
  }
  return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
}

uint64_t BBufUtilDummyAllocate()
{
  return 0;
}

uint64_t FigCreateBlockBufferWithCFDataNoCopy(const __CFAllocator *a1, CFDataRef theData, unint64_t a3, size_t a4, CMBlockBufferRef *a5)
{
  CMBlockBufferRef blockBufferOut = 0;
  if (!theData)
  {
    uint64_t v13 = FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
    if (!a5) {
      return v13;
    }
    goto LABEL_12;
  }
  if (a5)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unint64_t Length = CFDataGetLength(theData);
    if (!BytePtr)
    {
      uint64_t v12 = 4294954591;
      goto LABEL_21;
    }
    if (Length > a3)
    {
      if (a4)
      {
        if (Length < a4)
        {
          uint64_t v12 = 4294954592;
          goto LABEL_21;
        }
        if (Length - a4 < a3) {
          goto LABEL_8;
        }
      }
      else
      {
        a4 = Length - a3;
      }
      customBlockSource.version = 0;
      customBlockSource.AllocateBlock = 0;
      customBlockSource.FreeBlock = (void (__cdecl *)(void *, void *, size_t))BBufUtilCFDataReleaser;
      customBlockSource.refCon = (void *)CFRetain(theData);
      uint64_t v13 = CMBlockBufferCreateWithMemoryBlock(a1, (void *)&BytePtr[a3], a4, 0, &customBlockSource, 0, a4, 0, &blockBufferOut);
      if (v13) {
        CFRelease(theData);
      }
      goto LABEL_12;
    }
LABEL_8:
    uint64_t v12 = 4294954593;
LABEL_21:
    uint64_t v13 = FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
LABEL_12:
    *a5 = blockBufferOut;
    return v13;
  }

  return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCreateBlockBufferWithCFString(const __CFAllocator *a1, CFStringRef theString, CMBlockBufferRef *a3)
{
  CFStringRef v4 = theString;
  CMBlockBufferRef blockBufferOut = 0;
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (!CStringPtr)
  {
    CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(a1, v4, 0x8000100u, 0x3Fu);
    if (!ExternalRepresentation)
    {
      uint64_t v11 = 4294954510;
      if (!a3) {
        return v11;
      }
      goto LABEL_11;
    }
    CFStringRef v4 = (const __CFString *)ExternalRepresentation;
    size_t Length = CFDataGetLength(ExternalRepresentation);
    uint64_t v11 = FigCreateBlockBufferWithCFDataNoCopy(a1, (CFDataRef)v4, 0, Length, &blockBufferOut);
    goto LABEL_9;
  }
  size_t v7 = (char *)CStringPtr;
  customBlockSource.version = 0;
  if (v4) {
    CFTypeID v8 = (void *)CFRetain(v4);
  }
  else {
    CFTypeID v8 = 0;
  }
  customBlockSource.AllocateBlock = 0;
  customBlockSource.FreeBlock = (void (__cdecl *)(void *, void *, size_t))BBufUtilCFStringReleaser;
  customBlockSource.refCon = v8;
  size_t v12 = strlen(v7);
  uint64_t v13 = CMBlockBufferCreateWithMemoryBlock(a1, v7, v12, 0, &customBlockSource, 0, v12, 0, &blockBufferOut);
  uint64_t v11 = v13;
  if (v4 && v13) {
LABEL_9:
  }
    CFRelease(v4);
  if (a3) {
LABEL_11:
  }
    *a3 = blockBufferOut;
  return v11;
}

uint64_t FigCreateBlockBufferCopyingMemoryBlock(CFAllocatorRef blockAllocator, const void *a2, size_t dataLength, CMBlockBufferRef *a4)
{
  CMBlockBufferRef destinationBuffer = 0;
  uint64_t v7 = CMBlockBufferCreateWithMemoryBlock(blockAllocator, 0, dataLength, blockAllocator, 0, 0, dataLength, 1u, &destinationBuffer);
  if (v7)
  {
    uint64_t v8 = v7;
  }
  else
  {
    uint64_t v8 = CMBlockBufferReplaceDataBytes(a2, destinationBuffer, 0, dataLength);
    if (!v8)
    {
      *a4 = destinationBuffer;
      return v8;
    }
  }
  if (destinationBuffer) {
    CFRelease(destinationBuffer);
  }
  return v8;
}

uint64_t FigMakeIOVecArrayWithBlockBuffer(CMBlockBufferRef theBuffer, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v6 = 0;
  size_t v7 = 0;
  size_t totalLengthOut = 0;
  uint64_t v8 = (size_t *)(a2 + 8);
  uint64_t v9 = a3 & ~(a3 >> 31);
  while (v9 != v6)
  {
    uint64_t result = CMBlockBufferGetDataPointer(theBuffer, v7, v8, &totalLengthOut, (char **)v8 - 1);
    if (result) {
      return result;
    }
    size_t v11 = *v8;
    v8 += 2;
    v7 += v11;
    ++v6;
    if (v7 >= totalLengthOut)
    {
      uint64_t result = 0;
      *a4 = v6;
      return result;
    }
  }
  return 4294954588;
}

void CMMemoryPoolInvalidate(CMMemoryPoolRef pool)
{
  uint64_t v1 = *((void *)pool + 2);
  if (v1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(v1 + 56));
    if (*(unsigned char *)(v1 + 16))
    {
      *(unsigned char *)(v1 + 16) = 0;
      poolBlockState_FreeBlocks(v1, 1);
    }
    uint64_t v2 = *(pthread_mutex_t **)(v1 + 56);
    FigSimpleMutexUnlock(v2);
  }
}

void poolBlockState_FreeBlocks(uint64_t a1, int a2)
{
  if (a2)
  {
    int64_t UpTimeNanoseconds = 0;
  }
  else
  {
    int64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    if (UpTimeNanoseconds < *(void *)(a1 + 48)) {
      return;
    }
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (Count < 1)
  {
    uint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    if (!a2) {
      goto LABEL_21;
    }
    return;
  }
  unint64_t v6 = Count + 1;
  uint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    CFNumberRef ValueAtIndex = (const void **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v6 - 2);
    uint64_t v9 = ValueAtIndex;
    if (*((_DWORD *)ValueAtIndex + 8))
    {
      int64_t v10 = (int64_t)ValueAtIndex[3];
LABEL_8:
      if (v7 >= v10) {
        uint64_t v7 = v10;
      }
      if (a2) {
        goto LABEL_17;
      }
      goto LABEL_15;
    }
    if (a2 != 1)
    {
      int64_t v10 = (int64_t)ValueAtIndex[3];
      if (v10 >= UpTimeNanoseconds) {
        goto LABEL_8;
      }
    }
    poolBlockState_DeallocateVMMemory((uint64_t)ValueAtIndex);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 72), v6 - 2);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 80), *v9);
    poolBlockState_postForgottenSerialNumber((const void *)a1, (uint64_t *)v9);
    free(v9);
    if (a2) {
      goto LABEL_17;
    }
LABEL_15:
    if ((((_BYTE)v6 - 2) & 0xF) == 0 && (uint64_t)(FigGetUpTimeNanoseconds() - UpTimeNanoseconds) >= 5000001) {
      return;
    }
LABEL_17:
    --v6;
  }
  while (v6 > 1);
  if (a2) {
    return;
  }
LABEL_21:
  uint64_t v11 = UpTimeNanoseconds + 5000000;
  if (v7 > UpTimeNanoseconds + 5000000) {
    uint64_t v11 = v7;
  }
  *(void *)(a1 + 48) = v11;
}

CFTypeID CMMemoryPoolGetTypeID(void)
{
  return sFigMemoryPoolID;
}

uint64_t RegisterFigMemoryPoolType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigMemoryPoolID = result;
  return result;
}

CMMemoryPoolRef CMMemoryPoolCreate(CFDictionaryRef options)
{
  uint64_t v1 = 500000000;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorContext context = *(CFAllocatorContext *)byte_1EDF6F610;
  if (options)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(options, @"FigMemoryPool_AgeOutPeriod");
    if (Value)
    {
      CFNumberRef v5 = Value;
      CFTypeID TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(v5))
      {
        double valuePtr = 0.0;
        CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
        if (valuePtr > 0.0) {
          uint64_t v1 = (uint64_t)(valuePtr * 1000.0 * 1000.0 * 1000.0);
        }
      }
    }
    uint64_t v7 = CFDictionaryGetValue(options, @"FigMemoryPool_LoggingName");
  }
  else
  {
    uint64_t v7 = 0;
  }
  FigThreadRunOnce(&sRegisterFigMemoryPoolTypeOnce, (void (*)(void))RegisterFigMemoryPoolType);
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v9 = Instance;
  if (Instance)
  {
    if (!poolBlockState_Create(v2, Instance, v1, 1, 0x40000, v7, (void *)(Instance + 16)))
    {
      context.info = (void *)CFRetain(*(CFTypeRef *)(v9 + 16));
      *(void *)(v9 + 24) = CFAllocatorCreate(0, &context);
    }
  }
  else
  {
    FigSignalErrorAt(4294951806, 0, 0, 0, 0, 0, 0);
  }
  return (CMMemoryPoolRef)v9;
}

CFTypeRef poolingAllocator_CopyDescription()
{
  return CFRetain(@"FigMemoryPoolAllocator");
}

vm_address_t poolingAllocator_Allocate(vm_address_t a1, uint64_t a2, uint64_t a3)
{
  return poolBlockState_AllocateInternal(a1, a3, 0, 0);
}

void *poolingAllocator_Reallocate(const void *a1, vm_address_t a2, uint64_t a3, uint64_t a4)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a4 + 56));
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 64), a1);
  if (Value)
  {
    vm_address_t v8 = Value[1];
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a4 + 56));
    Internal = (void *)poolBlockState_AllocateInternal(a2, a4, 0, 0);
    int64_t v10 = Internal;
    if (Internal)
    {
      if (v8 >= a2) {
        size_t v11 = a2;
      }
      else {
        size_t v11 = v8;
      }
      memcpy(Internal, a1, v11);
      poolingAllocator_Deallocate(a1, a4);
    }
  }
  else
  {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a4 + 56));
    return 0;
  }
  return v10;
}

uint64_t poolingAllocator_Deallocate(const void *a1, uint64_t a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a2 + 56));
  CFNumberRef Value = (const void **)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 64), a1);
  if (Value) {
    poolBlockState_DecrementUseCountInternal(a2, Value);
  }
  poolBlockState_FreeBlocks(a2, 0);
  CFNumberRef v5 = *(pthread_mutex_t **)(a2 + 56);

  return FigSimpleMutexUnlock(v5);
}

uint64_t poolBlockState_Create(const __CFAllocator *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, const void *a6, void *a7)
{
  memset(&valueCallBacks, 0, sizeof(valueCallBacks));
  memset(&v23, 0, sizeof(v23));
  if (poolBlockState_GetTypeID_sRegisterPoolBlockStateTypeOnce != -1) {
    dispatch_once_f(&poolBlockState_GetTypeID_sRegisterPoolBlockStateTypeOnce, &poolBlockState_GetTypeID_sPoolBlockStateID, (dispatch_function_t)poolBlockState_RegisterType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v15 = (void *)Instance;
    *(unsigned char *)(Instance + 16) = a4;
    *(void *)(Instance + 24) = a5;
    *(void *)(Instance + 32) = a3;
    if (a6) {
      CFTypeRef v16 = CFRetain(a6);
    }
    else {
      CFTypeRef v16 = 0;
    }
    v15[5] = v16;
    int v17 = FigSimpleMutexCreate();
    v15[7] = v17;
    if (a2)
    {
      v15[12] = FigCFWeakReferenceHolderCreateWithReferencedObject(a2);
      int v17 = (pthread_mutex_t *)v15[7];
    }
    if (!v17) {
      goto LABEL_15;
    }
    valueCallBacks.copyDescription = (CFDictionaryCopyDescriptionCallBack)poolBlockState_copyBlockInfoDescription;
    CFMutableDictionaryRef v18 = CFDictionaryCreateMutable(a1, 0, 0, &valueCallBacks);
    v15[8] = v18;
    if (!v18) {
      goto LABEL_15;
    }
    v23.copyDescription = (CFArrayCopyDescriptionCallBack)poolBlockState_copyBlockInfoDescription;
    CFMutableArrayRef v19 = CFArrayCreateMutable(a1, 0, &v23);
    v15[9] = v19;
    if (v19 && (CFMutableDictionaryRef v20 = CFDictionaryCreateMutable(a1, 0, 0, &valueCallBacks), (v15[10] = v20) != 0))
    {
      uint64_t v21 = 0;
      v15[11] = *MEMORY[0x1E4F14B00];
      *a7 = v15;
    }
    else
    {
LABEL_15:
      uint64_t v21 = FigSignalErrorAt(4294951806, 0, 0, 0, 0, 0, 0);
      CFRelease(v15);
    }
    return v21;
  }
  else
  {
    return FigSignalErrorAt(4294951806, 0, 0, 0, 0, 0, 0);
  }
}

CFAllocatorRef CMMemoryPoolGetAllocator(CMMemoryPoolRef pool)
{
  return (CFAllocatorRef)*((void *)pool + 3);
}

BOOL FigMemoryPoolIsPoolAllocator(const __CFAllocator *a1)
{
  memset(&v2, 0, sizeof(v2));
  BOOL result = 0;
  if (a1)
  {
    CFAllocatorGetContext(a1, &v2);
    if ((vm_address_t (*)(vm_address_t, uint64_t, uint64_t))v2.allocate == poolingAllocator_Allocate) {
      return 1;
    }
  }
  return result;
}

CFAllocatorRef FigMemoryPoolAllocatorCopyMemoryPool(const __CFAllocator *result, id **a2)
{
  if (result)
  {
    if (a2)
    {
      memset(&v6, 0, sizeof(v6));
      CFAllocatorGetContext(result, &v6);
      if ((vm_address_t (*)(vm_address_t, uint64_t, uint64_t))v6.allocate == poolingAllocator_Allocate)
      {
        unsigned int v3 = (id *)*((void *)v6.info + 12);
        if (v3 && (CFStringRef v4 = FigCFWeakReferenceHolderCopyReferencedObject(v3)) != 0)
        {
          CFNumberRef v5 = v4;
          BOOL result = 0;
          *a2 = v5;
        }
        else
        {
          return (const __CFAllocator *)FigSignalErrorAt(4294951801, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return (const __CFAllocator *)FigSignalErrorAt(4294951805, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

void CMMemoryPoolFlush(CMMemoryPoolRef pool)
{
  uint64_t v1 = *((void *)pool + 2);
  if (v1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(v1 + 56));
    if (*(unsigned char *)(v1 + 16)) {
      poolBlockState_FreeBlocks(v1, 1);
    }
    CFAllocatorContext v2 = *(pthread_mutex_t **)(v1 + 56);
    FigSimpleMutexUnlock(v2);
  }
}

uint64_t FigMemoryPoolCopyStats(uint64_t a1, CFMutableDictionaryRef *a2)
{
  if (a1 && a2)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    FigSimpleMutexLock(*(pthread_mutex_t **)(v3 + 56));
    int Count = CFDictionaryGetCount(*(CFDictionaryRef *)(v3 + 64));
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v3 + 56));
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    FigCFDictionarySetInt32(Mutable, @"FigMemoryPool_NumberOfBlocksInUse", Count);
    *a2 = Mutable;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951805, 0, 0, 0, 0, 0, 0);
  }
}

const void *FigMemoryPoolCreateBlockBufferWithOptions(uint64_t a1, vm_address_t a2, char a3, uint64_t a4, CMBlockBufferRef *a5)
{
  uint64_t valuePtr = 0;
  CMBlockBufferRef theBuffer = 0;
  blocksize_t Length = 0;
  if (!a1)
  {
    uint64_t v18 = 4294951805;
LABEL_15:
    uint64_t v13 = (const void *)FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  uint64_t v9 = (void *)poolBlockState_AllocateInternal(a2, *(void *)(a1 + 16), &valuePtr, &blockLength);
  if (!v9)
  {
    uint64_t v18 = 4294951806;
    goto LABEL_15;
  }
  int64_t v10 = v9;
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  size_t v12 = (const void *)CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9, blockLength, *(CFAllocatorRef *)(a1 + 24), 0, 0, a2, 0, &theBuffer);
  if (v12)
  {
    uint64_t v13 = v12;
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 24), v10);
LABEL_10:
    if (theBuffer) {
      CFRelease(theBuffer);
    }
    return v13;
  }
  uint64_t v13 = CFNumberCreate(v11, kCFNumberSInt64Type, &valuePtr);
  CMSetAttachment(theBuffer, @"MemoryPoolBlockSerialNumber", v13, 0);
  CMSetAttachment(theBuffer, @"OwningPoolBlockState", *(CFTypeRef *)(a1 + 16), 0);
  if (a3)
  {
    size_t v14 = (a2 + 0x3FFF) & 0xFFFFFFFFFFFFC000;
    int v15 = v14 - a2;
    if (v14 > a2 && v14 <= blockLength)
    {
      dataPointerOut = 0;
      CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
      int v20 = v15;
      bzero(&dataPointerOut[a2], v15);
      CFNumberRef v16 = CFNumberCreate(v11, kCFNumberSInt32Type, &v20);
      CMSetAttachment(theBuffer, @"NumTrailingPaddingBytes", v16, 0);
      CFRelease(v16);
    }
  }
  *a5 = theBuffer;
  CMBlockBufferRef theBuffer = 0;
  if (v13)
  {
    CFRelease(v13);
    uint64_t v13 = 0;
    goto LABEL_10;
  }
  return v13;
}

vm_address_t poolBlockState_AllocateInternal(vm_address_t result, uint64_t a2, void *a3, void *a4)
{
  vm_address_t address = 0;
  if (result)
  {
    unsigned int v7 = result;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a2 + 56));
    uint64_t v8 = 0;
    while (1)
    {
      int v9 = dword_18FE964B8[v8 + 1];
      if ((v9 & (v7 >> 4)) != 0) {
        break;
      }
      v8 += 2;
      if (v8 == 12) {
        goto LABEL_7;
      }
    }
    unsigned int v10 = (v7 + dword_18FE964B8[v8] - 1) & v9;
    if (v10) {
      goto LABEL_8;
    }
LABEL_7:
    unsigned int v10 = (v7 + 0x3FFF) & 0xFFFFC000;
LABEL_8:
    vm_size_t v11 = v10;
    vm_size_t v12 = *(void *)(a2 + 24);
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 72));
    if (Count < 1)
    {
      uint64_t v18 = 0;
LABEL_20:
      if (vm_allocate(*MEMORY[0x1E4F14960], &address, v11, 1577058305))
      {
        vm_address_t address = 0;
        if (!v18)
        {
LABEL_26:
          poolBlockState_FreeBlocks(a2, 0);
          FigSimpleMutexUnlock(*(pthread_mutex_t **)(a2 + 56));
          return address;
        }
        if (!a3)
        {
LABEL_24:
          if (a4) {
            *a4 = v18[1];
          }
          goto LABEL_26;
        }
LABEL_23:
        *a3 = *v18;
        goto LABEL_24;
      }
      uint64_t v18 = malloc_type_calloc(1uLL, 0x28uLL, 0x10800407C5467E8uLL);
      vm_address_t v24 = address;
      v18[1] = v11;
      int v18[2] = v24;
      v18[3] = 0;
      *((_DWORD *)v18 + 8) = 1;
      unint64_t v25 = (const void *)poolBlockState_newMemoryBlockSerialNumber();
      *uint64_t v18 = v25;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 80), v25, v18);
      uint64_t v22 = *(__CFDictionary **)(a2 + 64);
      CFArrayCallBacks v23 = (const void *)address;
    }
    else
    {
      vm_size_t v14 = v11 >> 1;
      if (v11 >> 1 >= v12) {
        vm_size_t v14 = v12;
      }
      vm_size_t v15 = v14 + v11;
      CFIndex v16 = Count + 1;
      while (1)
      {
        CFNumberRef ValueAtIndex = (vm_address_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 72), v16 - 2);
        uint64_t v18 = ValueAtIndex;
        vm_size_t v19 = ValueAtIndex[1];
        if (v19 >= v11 && v19 <= v15) {
          break;
        }
        if ((unint64_t)--v16 < 2) {
          goto LABEL_20;
        }
      }
      vm_address_t address = ValueAtIndex[2];
      vm_address_t v21 = address;
      ++*((_DWORD *)ValueAtIndex + 8);
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a2 + 72), v16 - 2);
      uint64_t v22 = *(__CFDictionary **)(a2 + 64);
      CFArrayCallBacks v23 = (const void *)v21;
    }
    CFDictionarySetValue(v22, v23, v18);
    if (!a3) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  return result;
}

const void *FigMemoryPoolCreateBlockBuffer(uint64_t a1, vm_address_t a2, CMBlockBufferRef *a3, uint64_t a4)
{
  return FigMemoryPoolCreateBlockBufferWithOptions(a1, a2, 0, a4, a3);
}

uint64_t FigMemoryPoolCreateContiguousBlockBuffer(uint64_t a1, CFAllocatorRef structureAllocator, CFAllocatorRef blockAllocator, CMBlockBufferCustomBlockSource *customBlockSource, CMBlockBufferRef theBuffer, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags, CMBlockBufferRef *a9)
{
  uint64_t v25 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  dataPointerOut = 0;
  if (FigMemoryPoolCreateContiguousBlockBuffer_onceToken != -1) {
    dispatch_once_f(&FigMemoryPoolCreateContiguousBlockBuffer_onceToken, &FigMemoryPoolCreateContiguousBlockBuffer_do_not_use_memory_pool, (dispatch_function_t)fmp_readContiguousBlockBufferDefaultOnce);
  }
  if (FigMemoryPoolCreateContiguousBlockBuffer_do_not_use_memory_pool)
  {
    uint64_t DataPointer = CMBlockBufferCreateContiguous(structureAllocator, theBuffer, blockAllocator, customBlockSource, offsetToData, dataLength, flags, &blockBufferOut);
    if (DataPointer) {
      goto LABEL_22;
    }
LABEL_19:
    uint64_t v20 = 0;
    *a9 = blockBufferOut;
    return v20;
  }
  size_t v18 = CMBlockBufferGetDataLength(theBuffer);
  if (v18 <= offsetToData || v18 - offsetToData < dataLength)
  {
    uint64_t DataPointer = FigSignalErrorAt(4294954593, 0, 0, 0, 0, 0, 0);
    goto LABEL_22;
  }
  if (!dataLength) {
    datasize_t Length = v18 - offsetToData;
  }
  if ((flags & 2) != 0
    || (unint64_t v22 = 0,
        size_t v23 = 0,
        FigBlockBufferGetDataPointerAndOrigin((uint64_t)theBuffer, offsetToData, &v23, 0, 0, &v25, &v22))|| v23 < dataLength|| !FigIsMemoryPoolBlockBuffer(theBuffer))
  {
    uint64_t DataPointer = (uint64_t)FigMemoryPoolCreateBlockBufferWithOptions(a1, dataLength, flags, v19, &blockBufferOut);
    if (!DataPointer)
    {
      uint64_t DataPointer = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &dataPointerOut);
      if (!DataPointer)
      {
        uint64_t DataPointer = CMBlockBufferCopyDataBytes(theBuffer, offsetToData, dataLength, dataPointerOut);
        if (!DataPointer) {
          goto LABEL_19;
        }
      }
    }
  }
  else
  {
    uint64_t DataPointer = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theBuffer, offsetToData, dataLength, flags, &blockBufferOut);
    if (!DataPointer) {
      goto LABEL_19;
    }
  }
LABEL_22:
  uint64_t v20 = DataPointer;
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v20;
}

uint64_t fmp_readContiguousBlockBufferDefaultOnce(unsigned char *a1)
{
  uint64_t result = FigGetCFPreferenceBooleanWithDefault(@"do_not_use_memory_pool_for_creating_contiguous_block_buffers", @"com.apple.coremedia", 0);
  *a1 = result;
  return result;
}

uint64_t FigIsMemoryPoolBlockBuffer(OpaqueCMBlockBuffer *a1)
{
  unint64_t v6 = 0;
  CMAttachmentBearerRef target = 0;
  Datasize_t Length = CMBlockBufferGetDataLength(a1);
  if (!CMBlockBufferIsRangeContiguous(a1, 0, DataLength))
  {
    unint64_t v4 = 0;
    unint64_t v5 = 0;
    while (!FigBlockBufferGetDataPointerAndOrigin((uint64_t)a1, v4, &v5, 0, 0, &target, &v6))
    {
      uint64_t result = (uint64_t)CMGetAttachment(target, @"OwningPoolBlockState", 0);
      if (!result) {
        return result;
      }
      uint64_t result = (uint64_t)CMGetAttachment(target, @"MemoryPoolBlockSerialNumber", 0);
      if (!result) {
        return result;
      }
      v4 += v5;
      if (v4 >= DataLength) {
        return 1;
      }
    }
    return 0;
  }
  if (FigBlockBufferGetDataPointerAndOrigin((uint64_t)a1, 0, 0, 0, 0, &target, &v6)) {
    return 0;
  }
  uint64_t result = (uint64_t)CMGetAttachment(target, @"OwningPoolBlockState", 0);
  if (result) {
    return CMGetAttachment(target, @"MemoryPoolBlockSerialNumber", 0) != 0;
  }
  return result;
}

uint64_t FigMemoryPoolBlockBufferGetPaddedWriteInfo(OpaqueCMBlockBuffer *a1, char **a2, void *a3, void *a4)
{
  size_t totalLengthOut = 0;
  size_t lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  int valuePtr = 0;
  uint64_t result = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
  if (!result)
  {
    if (lengthAtOffsetOut == totalLengthOut)
    {
      if (FigIsMemoryPoolBlockBuffer(a1)
        && (CFNumberRef v9 = (const __CFNumber *)CMGetAttachment(a1, @"NumTrailingPaddingBytes", 0)) != 0)
      {
        CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr);
        uint64_t v10 = valuePtr;
      }
      else
      {
        uint64_t v10 = 0;
      }
      uint64_t result = 0;
      *a2 = dataPointerOut;
      *a3 = totalLengthOut + v10;
      *a4 = v10;
    }
    else
    {
      return FigSignalErrorAt(4294951805, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

BOOL FigMemoryOriginIsBlockBufferSendable(uint64_t a1, CMBlockBufferRef theBuffer)
{
  unint64_t v15 = 0;
  CMAttachmentBearerRef target = 0;
  uint64_t valuePtr = 0;
  Datasize_t Length = CMBlockBufferGetDataLength(theBuffer);
  if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength))
  {
    int v6 = 0;
    unint64_t v7 = 0;
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    unint64_t v13 = 0;
    while (1)
    {
      if (FigBlockBufferGetDataPointerAndOrigin((uint64_t)theBuffer, v8, &v13, 0, 0, &target, &v15)) {
        return 0;
      }
      if (!CMGetAttachment(target, @"OwningPoolBlockState", 0)
        || !CMGetAttachment(target, @"MemoryPoolBlockSerialNumber", 0))
      {
        break;
      }
      CFNumberRef v10 = (const __CFNumber *)CMGetAttachment(target, @"ImportedBlockSerialNumber", 0);
      if (v10)
      {
        CFNumberGetValue(v10, kCFNumberSInt64Type, &valuePtr);
        unint64_t v7 = valuePtr & 0xFFFF800000000000;
        int v6 = 1;
        if (v9 && v9 != v7)
        {
          LODWORD(v5) = 0;
          return v7 == (unint64_t)*(unsigned int *)(a1 + 56) << 47 && v5;
        }
        unint64_t v9 = valuePtr & 0xFFFF800000000000;
      }
      v8 += v13;
      if (v8 >= DataLength)
      {
        BOOL v5 = 1;
        goto LABEL_19;
      }
    }
    BOOL v5 = 0;
LABEL_19:
    if (v6) {
      return v7 == (unint64_t)*(unsigned int *)(a1 + 56) << 47 && v5;
    }
    return v5;
  }
  if (FigBlockBufferGetDataPointerAndOrigin((uint64_t)theBuffer, 0, 0, 0, 0, &target, &v15)) {
    return 0;
  }
  if (CMGetAttachment(target, @"OwningPoolBlockState", 0)) {
    BOOL v5 = CMGetAttachment(target, @"MemoryPoolBlockSerialNumber", 0) != 0;
  }
  else {
    BOOL v5 = 0;
  }
  CFNumberRef v11 = (const __CFNumber *)CMGetAttachment(target, @"ImportedBlockSerialNumber", 0);
  if (v11)
  {
    CFNumberGetValue(v11, kCFNumberSInt64Type, &valuePtr);
    unint64_t v7 = valuePtr & 0xFFFF800000000000;
    return v7 == (unint64_t)*(unsigned int *)(a1 + 56) << 47 && v5;
  }
  return v5;
}

uint64_t FigMemoryOriginSetBlockBufferInIPCMessageData(uint64_t a1, CMBlockBufferRef theBuffer, uint64_t a3, unint64_t a4, unint64_t *a5)
{
  CMAttachmentBearerRef v25 = 0;
  int64_t v26 = 0;
  if (!theBuffer) {
    return 0;
  }
  if (a1)
  {
    Datasize_t Length = CMBlockBufferGetDataLength(theBuffer);
    unint64_t v10 = 0;
    int v11 = 0;
    uint64_t v23 = a3;
    int64_t v24 = 0;
    uint64_t v12 = 52;
    while (1)
    {
      unint64_t v13 = v12;
      uint64_t DataPointerAndOrigin = FigBlockBufferGetDataPointerAndOrigin((uint64_t)theBuffer, v10, (unint64_t *)&v24, 0, 0, &v25, (unint64_t *)&v26);
      if (DataPointerAndOrigin) {
        break;
      }
      int64_t v15 = v24;
      if (v13 <= a4)
      {
        uint64_t DataPointerAndOrigin = memoryOrigin_storeSubBlockDescription(a1, v25, v26, v24, 0, (int64_t *)(a3 + 40 * v11 + 12));
        if (DataPointerAndOrigin) {
          break;
        }
        ++v11;
      }
      else
      {
        a3 = 0;
      }
      v10 += v15;
      uint64_t v12 = v13 + 40;
      if (v10 >= DataLength)
      {
        if (a5) {
          *a5 = v13;
        }
        if (a3)
        {
          *(void *)a3 = *(void *)(a1 + 40);
          *(_DWORD *)(a3 + 8) = v11;
        }
        if (v13 <= a4 || v23 == 0) {
          uint64_t v17 = 0;
        }
        else {
          uint64_t v17 = 4294951775;
        }
        if (v17) {
          goto LABEL_25;
        }
        return v17;
      }
    }
  }
  else
  {
    uint64_t DataPointerAndOrigin = FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v17 = DataPointerAndOrigin;
  if (DataPointerAndOrigin)
  {
LABEL_25:
    if (a3 && *(_DWORD *)(a3 + 8))
    {
      unint64_t v18 = 0;
      uint64_t v19 = (const void **)(a3 + 28);
      do
      {
        uint64_t v20 = *v19;
        v19 += 5;
        memoryOrigin_unregisterUseOfBlock(a1, v20);
        ++v18;
      }
      while (v18 < *(unsigned int *)(a3 + 8));
    }
  }
  return v17;
}

uint64_t memoryOrigin_storeSubBlockDescription(uint64_t a1, CMAttachmentBearerRef target, int64_t a3, int64_t a4, unint64_t a5, int64_t *a6)
{
  uint64_t valuePtr = 0;
  CFTypeRef v12 = CMGetAttachment(target, @"OwningPoolBlockState", 0);
  CFNumberRef v13 = (const __CFNumber *)CMGetAttachment(target, @"MemoryPoolBlockSerialNumber", 0);
  if (!v12 || !v13 || !(a5 | (unint64_t)a6))
  {
    uint64_t v21 = FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
    goto LABEL_37;
  }
  CFNumberGetValue(v13, kCFNumberSInt64Type, &valuePtr);
  vm_size_t v14 = valuePtr;
  uint64_t v33 = 0;
  int64_t value = 0;
  poolBlockState_IncrementBlockUseCountAndAccessMemory((uint64_t)v12, valuePtr, &value, &v33);
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  int64_t v15 = (xpc_object_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), v14);
  if (!v15)
  {
    xpc_object_t v17 = xpc_shmem_create((void *)value, v33);
    if (v17)
    {
      unint64_t v18 = malloc_type_calloc(1uLL, 0x20uLL, 0x10A0040D63CFB62uLL);
      if (v18)
      {
        uint64_t v19 = v18;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v14, v18);
        if (!*(void *)(a1 + 72)) {
          *(void *)(a1 + 72) = FigOSTransactionCreateWithProcessName("FigMemoryOrigin", *(const char **)(a1 + 48), *(unsigned int *)(a1 + 56), 0, *(void *)(a1 + 64));
        }
        if (!MEMORY[0x192FC3C00](*(void *)(a1 + 32), v12))
        {
          DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
          FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)a1, (CFNotificationCallback)memoryOrigin_poolNotificationListener, 0, (unint64_t)v12, 2, 0);
        }
        CFBagAddValue(*(CFMutableBagRef *)(a1 + 32), v12);
        *(void *)uint64_t v19 = CFRetain(v12);
        v19[6] = 1;
        *((void *)v19 + 2) = v14;
        *((void *)v19 + 1) = xpc_retain(v17);
        goto LABEL_6;
      }
    }
    uint64_t v21 = FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    if (!v21) {
      goto LABEL_15;
    }
    poolBlockState_DecrementBlockUseCount((uint64_t)v12, v14);
    FigXPCRelease(v17);
LABEL_37:
    xpc_object_t v17 = 0;
    goto LABEL_34;
  }
  CFIndex v16 = v15;
  xpc_object_t v17 = xpc_retain(v15[1]);
  ++*((_DWORD *)v16 + 6);
LABEL_6:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
LABEL_15:
  if (!sFigMemoryOriginTransactionThreadKey) {
    goto LABEL_24;
  }
  unint64_t v22 = (__CFArray **)FigThreadGetValue(sFigMemoryOriginTransactionThreadKey);
  if (!v22) {
    goto LABEL_24;
  }
  uint64_t v23 = v22;
  if (!*(unsigned char *)v22) {
    goto LABEL_24;
  }
  CFMutableDictionaryRef Mutable = v22[1];
  if (!Mutable)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 10, MEMORY[0x1E4F1D510]);
    v23[1] = Mutable;
    if (!Mutable) {
      goto LABEL_38;
    }
  }
  if (!v23[2])
  {
    CFMutableArrayRef v25 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 10, MEMORY[0x1E4F1D510]);
    int v23[2] = v25;
    if (v25)
    {
      CFMutableDictionaryRef Mutable = v23[1];
      goto LABEL_23;
    }
LABEL_38:
    uint64_t v21 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    FigXPCRelease(0);
    if (v21) {
      goto LABEL_34;
    }
    goto LABEL_25;
  }
LABEL_23:
  CFArrayAppendValue(Mutable, (const void *)a1);
  FigCFArrayAppendInt64(v23[2], (uint64_t)v14);
LABEL_24:
  FigXPCRelease(0);
LABEL_25:
  if (a5)
  {
    xpc_dictionary_set_int64((xpc_object_t)a5, "OffsetInOrigin", a3);
    xpc_dictionary_set_int64((xpc_object_t)a5, "BlockBufferLength", a4);
    xpc_dictionary_set_int64((xpc_object_t)a5, "BlockSerialNumber", (int64_t)valuePtr);
    xpc_dictionary_set_value((xpc_object_t)a5, "OriginData", v17);
  }
  else
  {
    *a6 = a3;
    a6[1] = a4;
    int64_t v26 = (int64_t)valuePtr;
    a6[3] = 0;
    a6[4] = 0;
    a6[2] = v26;
  }
  CFNumberRef v27 = (const __CFNumber *)CMGetAttachment(target, @"ImportedBlockSerialNumber", 0);
  CFNumberRef v28 = (const __CFNumber *)CMGetAttachment(target, @"RecipientObjectID", 0);
  uint64_t v21 = 0;
  if (v27)
  {
    CFNumberRef v29 = v28;
    if (v28)
    {
      uint64_t v33 = 0;
      int64_t value = 0;
      CFNumberGetValue(v27, kCFNumberSInt64Type, &value);
      CFNumberGetValue(v29, kCFNumberSInt64Type, &v33);
      int64_t v30 = value;
      if (a5)
      {
        xpc_dictionary_set_int64((xpc_object_t)a5, "RoundTripBlockSerialNumber", value);
        xpc_dictionary_set_uint64((xpc_object_t)a5, "RoundTripOriginObjectID", v33);
      }
      else
      {
        a6[3] = v33;
        a6[4] = v30;
      }
      uint64_t v21 = 0;
    }
  }
LABEL_34:
  FigXPCRelease(v17);
  return v21;
}

uint64_t memoryOrigin_unregisterUseOfBlock(uint64_t a1, const void *a2)
{
  if (a2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    CFNumberRef Value = (CFTypeRef *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
    if (Value)
    {
      --*((_DWORD *)Value + 6);
      int v6 = CFRetain(*Value);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
      poolBlockState_DecrementBlockUseCount((uint64_t)v6, a2);
      if (v6)
      {
        CFRelease(v6);
        return 0;
      }
    }
    else
    {
      int v6 = (const void *)FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
      if (!v6) {
        poolBlockState_DecrementBlockUseCount(0, a2);
      }
    }
    return (uint64_t)v6;
  }
  else
  {
    return FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigMemoryOriginSetBlockBufferInXPCMessage(uint64_t a1, void *a2, const char *a3, OpaqueCMBlockBuffer *a4)
{
  int64_t v25 = 0;
  int64_t v26 = 0;
  CMAttachmentBearerRef v24 = 0;
  if (!a4)
  {
    xpc_object_t v11 = 0;
    xpc_object_t v14 = 0;
    xpc_object_t v8 = 0;
    goto LABEL_18;
  }
  if (!a1 || !a2 || !a3)
  {
    uint64_t v16 = FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
    xpc_object_t v11 = 0;
    xpc_object_t v14 = 0;
    xpc_object_t v8 = 0;
    goto LABEL_19;
  }
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  if (!v8)
  {
    uint64_t v10 = FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
    goto LABEL_32;
  }
  Datasize_t Length = CMBlockBufferGetDataLength(a4);
  if (!CMBlockBufferIsRangeContiguous(a4, 0, DataLength))
  {
    int64_t v23 = 0;
    xpc_object_t v11 = xpc_array_create(0, 0);
    unint64_t v12 = 0;
    do
    {
      uint64_t DataPointerAndOrigin = FigBlockBufferGetDataPointerAndOrigin((uint64_t)a4, v12, (unint64_t *)&v23, 0, 0, &v24, (unint64_t *)&v25);
      if (DataPointerAndOrigin)
      {
        uint64_t v16 = DataPointerAndOrigin;
        goto LABEL_26;
      }
      xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
      if (!v14)
      {
        uint64_t v15 = FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
LABEL_28:
        uint64_t v16 = v15;
        goto LABEL_19;
      }
      uint64_t v15 = memoryOrigin_storeSubBlockDescription(a1, v24, v25, v23, (unint64_t)v14, 0);
      if (v15) {
        goto LABEL_28;
      }
      xpc_array_set_value(v11, 0xFFFFFFFFFFFFFFFFLL, v14);
      xpc_release(v14);
      v12 += v23;
    }
    while (v12 < DataLength);
    xpc_dictionary_set_value(v8, "SubBlockArray", v11);
    if (v11) {
      xpc_release(v11);
    }
    goto LABEL_17;
  }
  uint64_t v10 = FigBlockBufferGetDataPointerAndOrigin((uint64_t)a4, 0, 0, &v26, 0, &v24, (unint64_t *)&v25);
  if (!v10)
  {
    uint64_t v10 = memoryOrigin_storeSubBlockDescription(a1, v24, v25, v26, (unint64_t)v8, 0);
    if (!v10)
    {
LABEL_17:
      xpc_dictionary_set_uint64(v8, ".objectID", *(void *)(a1 + 40));
      xpc_dictionary_set_value(a2, a3, v8);
      xpc_object_t v11 = 0;
      xpc_object_t v14 = 0;
LABEL_18:
      uint64_t v16 = 0;
      goto LABEL_19;
    }
  }
LABEL_32:
  uint64_t v16 = v10;
  xpc_object_t v11 = 0;
LABEL_26:
  xpc_object_t v14 = 0;
LABEL_19:
  FigXPCRelease(v8);
  FigXPCRelease(v14);
  if (v11)
  {
    size_t count = xpc_array_get_count(v11);
    if (count)
    {
      size_t v18 = count;
      for (size_t i = 0; i != v18; ++i)
      {
        xpc_object_t value = xpc_array_get_value(v11, i);
        AudioDeviceID int64 = (const void *)xpc_dictionary_get_int64(value, "BlockSerialNumber");
        memoryOrigin_unregisterUseOfBlock(a1, int64);
      }
    }
    FigXPCRelease(v11);
  }
  return v16;
}

uint64_t FigMemoryOriginUpdateRecipientStateFromXPCMessage(uint64_t a1, void *a2, const char *a3)
{
  CFTypeRef cf = 0;
  if (a1 && a2)
  {
    uint64_t v4 = FigXPCMessageCopyCFArray(a2, a3, &cf);
    CFTypeRef v5 = cf;
    if (v4)
    {
      uint64_t v6 = v4;
      if (!cf) {
        return v6;
      }
    }
    else
    {
      uint64_t v6 = memoryOrigin_unregisterUseOfMultipleBlocks(a1, (CFArrayRef)cf);
      CFTypeRef v5 = cf;
      if (!cf) {
        return v6;
      }
    }
    CFRelease(v5);
    return v6;
  }

  return FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
}

uint64_t memoryOrigin_unregisterUseOfMultipleBlocks(uint64_t a1, CFArrayRef theArray)
{
  if (!theArray) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1) {
    return 0;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  LODWORD(v7) = 0;
  do
  {
    uint64_t v10 = 0;
    FigCFArrayGetInt64AtIndex(theArray, v6, &v10);
    unsigned int v8 = memoryOrigin_unregisterUseOfBlock(a1, v10);
    if (v8) {
      uint64_t v7 = v8;
    }
    else {
      uint64_t v7 = v7;
    }
    ++v6;
  }
  while (v5 != v6);
  return v7;
}

uint64_t FigMemoryOriginUpdateRecipientStateFromIPCMessageData(uint64_t a1, unsigned int *a2, unint64_t a3)
{
  if (a1 && a2)
  {
    if (!a3) {
      return 0;
    }
    uint64_t v4 = *a2;
    if (((8 * v4) | 4uLL) <= a3)
    {
      if (v4)
      {
        unint64_t v6 = 0;
        LODWORD(v7) = 0;
        do
        {
          unsigned int v8 = memoryOrigin_unregisterUseOfBlock(a1, *(const void **)&a2[2 * v6 + 1]);
          if (v8) {
            uint64_t v7 = v8;
          }
          else {
            uint64_t v7 = v7;
          }
          ++v6;
        }
        while (v6 < *a2);
        return v7;
      }
      return 0;
    }
  }

  return FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
}

uint64_t FigMemoryOriginBeginEstablishingMemoryRecipientByFillingInXPCMessage1(void *a1)
{
  xpc_object_t value = 0;
  if (EnsureMemoryOriginServerStarted_sMemoryOriginServerStartOnce != -1) {
    dispatch_once(&EnsureMemoryOriginServerStarted_sMemoryOriginServerStartOnce, &__block_literal_global_85);
  }
  uint64_t v2 = EnsureMemoryOriginServerStarted_sMemoryOriginServerStartError;
  if (EnsureMemoryOriginServerStarted_sMemoryOriginServerStartError)
  {
    xpc_object_t v4 = 0;
  }
  else
  {
    uint64_t v3 = gMemoryOriginServerToken;
    uint64_t v2 = FigXPCServerCopyXPCEndpoint(gMemoryOriginServer, &value);
    xpc_object_t v4 = value;
    if (!v2)
    {
      xpc_dictionary_set_value(a1, "MemoryOriginEndpoint", value);
      xpc_dictionary_set_uint64(a1, "MemoryOriginServerToken", v3);
      xpc_object_t v4 = value;
    }
  }
  FigXPCRelease(v4);
  return v2;
}

uint64_t FigMemoryOriginCompleteEstablishingMemoryRecipientUsingXPCMessage2(void *a1, void *a2)
{
  uAudioDeviceID int64 = (void *)xpc_dictionary_get_uint64(a1, "OriginObjectID");
  xpc_object_t v4 = (uint64_t *)gMemoryOriginServer;

  return FigXPCServerRetainNeighborObjectFromID(v4, uint64, a2);
}

uint64_t FigMemoryOriginGetObjectID(uint64_t a1, void *a2)
{
  if (!a1 || !a2) {
    return FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
  }
  *a2 = *(void *)(a1 + 40);
  return 0;
}

uint64_t FigMemoryOriginServerCopyMemoryOriginForObjectID(void *a1, void *a2)
{
  uint64_t v5 = 0;
  if (a2)
  {
    *a2 = 0;
    if (a1)
    {
      if (gMemoryOriginServer)
      {
        uint64_t result = FigXPCServerRetainNeighborObjectFromID((uint64_t *)gMemoryOriginServer, a1, &v5);
        *a2 = v5;
        return result;
      }
      uint64_t v4 = 4294951774;
    }
    else
    {
      uint64_t v4 = 4294951776;
    }
  }
  else
  {
    uint64_t v4 = 4294951776;
  }

  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigMemoryRecipientCopyBlockBufferFromIPCMessageData(CFAllocatorRef structureAllocator, uint64_t a2, uint64_t a3, unint64_t a4, CMBlockBufferRef *a5)
{
  targetint BBuf = 0;
  CMBlockBufferRef blockBufferOut = 0;
  if (!a2 || !a3)
  {
    uint64_t v11 = FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  if (a5)
  {
    if (!a4) {
      goto LABEL_21;
    }
    if (a4 <= 0xB || (uint32_t v8 = *(_DWORD *)(a3 + 8), 40 * (unint64_t)v8 + 12 > a4))
    {
      uint64_t v10 = FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
      goto LABEL_9;
    }
    if (v8 == 1)
    {
      uint64_t v10 = CreateSubBlockBuffer(structureAllocator, a2, 0, (int64_t *)(a3 + 12), &blockBufferOut);
LABEL_9:
      uint64_t v11 = v10;
LABEL_22:
      *a5 = blockBufferOut;
      return v11;
    }
    uint64_t v10 = CMBlockBufferCreateEmpty(structureAllocator, v8, 0, &blockBufferOut);
    if (v10) {
      goto LABEL_9;
    }
    if (!*(_DWORD *)(a3 + 8))
    {
LABEL_21:
      uint64_t v11 = 0;
      goto LABEL_22;
    }
    unint64_t v12 = 0;
    CFNumberRef v13 = (int64_t *)(a3 + 12);
    while (1)
    {
      uint64_t appended = CreateSubBlockBuffer(structureAllocator, a2, 0, v13, &targetBBuf);
      CMBlockBufferRef v15 = targetBBuf;
      if (appended) {
        break;
      }
      uint64_t appended = CMBlockBufferAppendBufferReference(blockBufferOut, targetBBuf, 0, 0, 0);
      if (appended) {
        break;
      }
      if (v15)
      {
        CFRelease(v15);
        targetint BBuf = 0;
      }
      ++v12;
      v13 += 5;
      if (v12 >= *(unsigned int *)(a3 + 8))
      {
        uint64_t v11 = 0;
        goto LABEL_19;
      }
    }
    uint64_t v11 = appended;
    if (v15) {
      CFRelease(v15);
    }
LABEL_19:
    if (!a5) {
      return v11;
    }
    goto LABEL_22;
  }

  return FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
}

uint64_t CreateSubBlockBuffer(const __CFAllocator *a1, uint64_t a2, xpc_object_t xdict, int64_t *a4, OpaqueCMBlockBuffer **a5)
{
  xdicta[16] = *(xpc_object_t *)MEMORY[0x1E4F143B8];
  if (xdict)
  {
    xpc_object_t value = xpc_dictionary_get_value(xdict, "OriginData");
    int64_t int64 = xpc_dictionary_get_int64(xdict, "BlockSerialNumber");
    int64_t v63 = xpc_dictionary_get_int64(xdict, "OffsetInOrigin");
    datasize_t Length = xpc_dictionary_get_int64(xdict, "BlockBufferLength");
    uint64_t v10 = (const void *)xpc_dictionary_get_int64(xdict, "RoundTripBlockSerialNumber");
    uint64_t int64 = (void *)xpc_dictionary_get_uint64(xdict, "RoundTripOriginObjectID");
  }
  else
  {
    xpc_object_t value = 0;
    int64_t int64 = a4[2];
    datasize_t Length = a4[1];
    int64_t v63 = *a4;
    uint64_t int64 = (void *)a4[3];
    uint64_t v10 = (const void *)a4[4];
  }
  CMBlockBufferRef bufferReference = 0;
  int64_t v69 = int64;
  uint64_t v12 = *(void *)(a2 + 32);
  CFTypeRef cf = 0;
  uint64_t valuePtr = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)v12);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v12 + 8));
  if (Count < 1)
  {
LABEL_8:
    if (v10)
    {
      if (uint64)
      {
        FigMemoryOriginServerCopyMemoryOriginForObjectID(uint64, &cf);
        CFTypeRef v17 = cf;
        if (cf)
        {
          FigReentrantMutexLock(*((pthread_mutex_t **)cf + 2));
          size_t v18 = (CFTypeRef *)CFDictionaryGetValue(*((CFDictionaryRef *)v17 + 3), v10);
          if (v18)
          {
            CFTypeRef v19 = CFRetain(*v18);
            FigReentrantMutexUnlock(*((pthread_mutex_t **)v17 + 2));
            if (v19)
            {
              xdicta[0] = 0;
              *(void *)int v70 = 0;
              poolBlockState_IncrementBlockUseCountAndAccessMemory((uint64_t)v19, v10, xdicta, v70);
              receivedMemoryAllocator_tellOriginToDecrementUseCountOfBlock(v12, int64);
              uint64_t v20 = CFAllocatorAllocate(a1, 64, 0);
              if (v20)
              {
                uint64_t v21 = v20;
                *(_OWORD *)uint64_t v20 = 0u;
                *((_OWORD *)v20 + 1) = 0u;
                *((_OWORD *)v20 + 2) = 0u;
                *((_OWORD *)v20 + 3) = 0u;
                *uint64_t v20 = 0;
                v20[1] = v10;
                uint64_t v22 = *(void *)v70;
                _OWORD v20[2] = xdicta[0];
                v20[3] = v22;
                void v20[6] = CFRetain(v19);
                *((_WORD *)v21 + 20) = 256;
                if (a1) {
                  CFTypeRef v23 = CFRetain(a1);
                }
                else {
                  CFTypeRef v23 = 0;
                }
                size_t v26 = v63;
                v21[7] = v23;
                v21[4] = 0;
                CFArrayAppendValue(*(CFMutableArrayRef *)(v12 + 8), v21);
                xpc_object_t v24 = 0;
                int v25 = 0;
                uint64_t valuePtr = (const void *)v21[1];
                goto LABEL_32;
              }
              uint64_t v27 = FigSignalErrorAt(4294951765, 0, 0, 0, 0, 0, 0);
              xpc_object_t v24 = 0;
              goto LABEL_65;
            }
          }
          else
          {
            FigReentrantMutexUnlock(*((pthread_mutex_t **)v17 + 2));
          }
        }
      }
    }
    if (value)
    {
      xpc_object_t v24 = 0;
    }
    else
    {
      xdicta[0] = 0;
      *(void *)int v70 = 0;
      FigXPCCreateBasicMessage(0x66746368u, *(void *)(*(void *)(a2 + 32) + 24), xdicta);
      xpc_dictionary_set_int64(xdicta[0], "BlockSerialNumber", int64);
      uint64_t v27 = FigXPCRemoteClientSendSyncMessageCreatingReply(*(void *)(*(void *)(a2 + 32) + 16), (uint64_t)xdicta[0], (xpc_object_t *)v70);
      if (v27)
      {
        xpc_object_t v24 = 0;
      }
      else
      {
        xpc_object_t v28 = xpc_dictionary_get_value(*(xpc_object_t *)v70, "OriginData");
        xpc_object_t v24 = FigXPCRetain(v28);
      }
      FigXPCRelease(*(xpc_object_t *)v70);
      FigXPCRelease(xdicta[0]);
      if (v27) {
        goto LABEL_63;
      }
      xpc_object_t value = v24;
    }
    uint64_t v29 = *(void *)(v12 + 32);
    xdicta[0] = 0;
    size_t v30 = xpc_shmem_map(value, xdicta);
    if (v30 && xdicta[0])
    {
      size_t v31 = v30;
      uint64_t v32 = a2;
      xpc_object_t v33 = v24;
      size_t v34 = malloc_type_calloc(1uLL, 0x28uLL, 0x10800407C5467E8uLL);
      xpc_object_t v35 = xdicta[0];
      *((void *)v34 + 1) = v31;
      *((void *)v34 + 2) = v35;
      *((void *)v34 + 3) = 0;
      *((_DWORD *)v34 + 8) = 1;
      *(void *)size_t v34 = poolBlockState_newMemoryBlockSerialNumber();
      *((unsigned char *)v34 + 36) = 1;
      FigSimpleMutexLock(*(pthread_mutex_t **)(v29 + 56));
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v29 + 80), *(const void **)v34, v34);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v29 + 64), *((const void **)v34 + 2), v34);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v29 + 56));
      uint64_t v36 = *((void *)v34 + 1);
      uint64_t valuePtr = *(const void **)v34;
      uint64_t v37 = *((void *)v34 + 2);
LABEL_27:
      uint64_t v38 = CFAllocatorAllocate(a1, 64, 0);
      if (v38)
      {
        uint64_t v21 = v38;
        *(_OWORD *)uint64_t v38 = 0u;
        *((_OWORD *)v38 + 1) = 0u;
        *((_OWORD *)v38 + 2) = 0u;
        *((_OWORD *)v38 + 3) = 0u;
        v38[2] = v37;
        v38[3] = v36;
        *uint64_t v38 = v69;
        v38[1] = valuePtr;
        v38[6] = CFRetain(*(CFTypeRef *)(v12 + 32));
        *((unsigned char *)v21 + 40) = 0;
        xpc_object_t v24 = v33;
        if (a1) {
          CFTypeRef v39 = CFRetain(a1);
        }
        else {
          CFTypeRef v39 = 0;
        }
        a2 = v32;
        size_t v26 = v63;
        v21[7] = v39;
        v21[4] = 0;
        *((unsigned char *)v21 + 41) = 0;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v12 + 8), v21);
        CFTypeRef v19 = 0;
        int v25 = 1;
        goto LABEL_32;
      }
      uint64_t v27 = FigSignalErrorAt(4294951765, 0, 0, 0, 0, 0, 0);
      CFTypeRef v19 = 0;
      xpc_object_t v24 = v33;
      a2 = v32;
LABEL_65:
      unsigned int v42 = 0;
      int v25 = 0;
      BOOL v52 = v27 == 0;
      goto LABEL_66;
    }
    uint64_t v54 = FigSignalErrorAt(4294951764, 0, 0, 0, 0, 0, 0);
    if (!v54)
    {
      uint64_t v32 = a2;
      xpc_object_t v33 = v24;
      uint64_t v37 = 0;
      uint64_t v36 = 0;
      goto LABEL_27;
    }
    uint64_t v27 = v54;
LABEL_63:
    CFTypeRef v19 = 0;
    goto LABEL_65;
  }
  CFIndex v14 = Count;
  CFIndex v15 = 0;
  while (1)
  {
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v12 + 8), v15);
    if (*ValueAtIndex == int64) {
      break;
    }
    if (v14 == ++v15) {
      goto LABEL_8;
    }
  }
  uint64_t v21 = ValueAtIndex;
  CFTypeRef v19 = 0;
  xpc_object_t v24 = 0;
  int v25 = 0;
  uint64_t valuePtr = (const void *)ValueAtIndex[1];
  size_t v26 = v63;
LABEL_32:
  int v40 = *((unsigned __int8 *)v21 + 40);
  if (!*((unsigned char *)v21 + 40)) {
    *((unsigned char *)v21 + 40) = 1;
  }
  int v41 = (id *)v21[4];
  if (v41)
  {
    CMBlockBufferRef bufferReference = (CMBlockBufferRef)FigCFWeakReferenceHolderCopyReferencedObject(v41);
    if (bufferReference) {
      goto LABEL_36;
    }
LABEL_39:
    uint64_t v43 = CMBlockBufferCreateWithMemoryBlock(a1, (void *)v21[2], v21[3], *(CFAllocatorRef *)(a2 + 24), 0, 0, v21[3], 0, &bufferReference);
    if (v43) {
      goto LABEL_60;
    }
    uint64_t v44 = a2;
    xpc_object_t v45 = v24;
    CFAllocatorRef v46 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v47 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
    CMSetAttachment(bufferReference, @"MemoryPoolBlockSerialNumber", v47, 0);
    if (v47) {
      CFRelease(v47);
    }
    CMSetAttachment(bufferReference, @"OwningPoolBlockState", (CFTypeRef)v21[6], 0);
    if (*v21)
    {
      CFNumberRef v48 = CFNumberCreate(v46, kCFNumberSInt64Type, &v69);
      CMSetAttachment(bufferReference, @"ImportedBlockSerialNumber", v48, 0);
      CFRelease(v48);
      CFNumberRef v49 = CFNumberCreate(v46, kCFNumberSInt64Type, (const void *)(v44 + 16));
      CMSetAttachment(bufferReference, @"RecipientObjectID", v49, 0);
      CFRelease(v49);
    }
    BOOL v50 = (const void *)v21[4];
    if (v50) {
      CFRelease(v50);
    }
    v21[4] = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)bufferReference);
    xpc_object_t v24 = v45;
    a2 = v44;
    size_t v26 = v63;
    if (v63) {
      goto LABEL_37;
    }
LABEL_47:
    uint64_t v51 = v21[3];
    unsigned int v42 = bufferReference;
    if (v51 == dataLength)
    {
LABEL_50:
      uint64_t v27 = 0;
      CMBlockBufferRef bufferReference = 0;
      goto LABEL_51;
    }
    goto LABEL_48;
  }
  if (!bufferReference) {
    goto LABEL_39;
  }
LABEL_36:
  if (!v26) {
    goto LABEL_47;
  }
LABEL_37:
  unsigned int v42 = bufferReference;
LABEL_48:
  xdicta[0] = 0;
  uint64_t v43 = CMBlockBufferCreateWithBufferReference(a1, v42, v26, dataLength, 0, (CMBlockBufferRef *)xdicta);
  if (!v43)
  {
    CFRelease(bufferReference);
    unsigned int v42 = (OpaqueCMBlockBuffer *)xdicta[0];
    goto LABEL_50;
  }
LABEL_60:
  uint64_t v27 = v43;
  unsigned int v42 = 0;
LABEL_51:
  BOOL v52 = v27 == 0;
  if (bufferReference) {
    BOOL v53 = 1;
  }
  else {
    BOOL v53 = v27 == 0;
  }
  if (!v40 && v53)
  {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)v12);
    if (!v27) {
      goto LABEL_75;
    }
    goto LABEL_67;
  }
LABEL_66:
  receivedMemoryAllocator_tellOriginToDecrementUseCountOfBlock(*(void *)(a2 + 32), v69);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)v12);
  if (v52) {
    goto LABEL_75;
  }
LABEL_67:
  int v65 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, &v65, &type);
  int v56 = v65;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v58 = v56;
  }
  else {
    unsigned int v58 = v56 & 0xFFFFFFFE;
  }
  if (v58)
  {
    *(_DWORD *)int v70 = 136315394;
    *(void *)&v70[4] = "memoryRecipient_createRecipientBlockBuffer";
    __int16 v71 = 1024;
    int v72 = v27;
    uint64_t v59 = (xpc_object_t *)_os_log_send_and_compose_impl();
    LOBYTE(v56) = v65;
  }
  else
  {
    uint64_t v59 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v59, v59 != xdicta, v56, 0, v57);
  if (v25) {
    poolBlockState_DecrementBlockUseCount(*(void *)(v12 + 32), valuePtr);
  }
LABEL_75:
  if (cf) {
    CFRelease(cf);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (bufferReference) {
    CFRelease(bufferReference);
  }
  FigXPCRelease(v24);
  if (v27)
  {
    if (v42) {
      CFRelease(v42);
    }
  }
  else
  {
    *a5 = v42;
  }
  return v27;
}

uint64_t FigMemoryRecipientCopyBlockBufferFromXPCMessage(const __CFAllocator *a1, uint64_t a2, xpc_object_t xdict, char *key, CMBlockBufferRef *a5)
{
  targetint BBuf = 0;
  CMBlockBufferRef blockBufferOut = 0;
  if (!a2 || !xdict || !key)
  {
    uint64_t v18 = FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  if (a5)
  {
    xpc_object_t value = xpc_dictionary_get_value(xdict, key);
    if (value)
    {
      unint64_t v9 = value;
      xpc_object_t v10 = xpc_dictionary_get_value(value, "SubBlockArray");
      if (v10)
      {
        uint64_t v11 = v10;
        size_t count = xpc_array_get_count(v10);
        uint64_t v13 = CMBlockBufferCreateEmpty(a1, count, 0, &blockBufferOut);
        if (!v13)
        {
          if (count)
          {
            size_t v14 = 0;
            while (1)
            {
              xpc_object_t v15 = xpc_array_get_value(v11, v14);
              uint64_t appended = CreateSubBlockBuffer(a1, a2, v15, 0, &targetBBuf);
              CMBlockBufferRef v17 = targetBBuf;
              if (appended) {
                break;
              }
              uint64_t appended = CMBlockBufferAppendBufferReference(blockBufferOut, targetBBuf, 0, 0, 0);
              if (appended) {
                break;
              }
              if (v17)
              {
                CFRelease(v17);
                targetint BBuf = 0;
              }
              if (count == ++v14)
              {
                uint64_t v18 = 0;
                goto LABEL_16;
              }
            }
            uint64_t v18 = appended;
            if (v17) {
              CFRelease(v17);
            }
LABEL_16:
            if (!a5) {
              return v18;
            }
            goto LABEL_21;
          }
          goto LABEL_20;
        }
      }
      else
      {
        uint64_t v13 = CreateSubBlockBuffer(a1, a2, v9, 0, &blockBufferOut);
      }
      uint64_t v18 = v13;
LABEL_21:
      *a5 = blockBufferOut;
      return v18;
    }
LABEL_20:
    uint64_t v18 = 0;
    goto LABEL_21;
  }

  return FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
}

uint64_t FigMemoryRecipientAppendRecipientStateUpdateToXPCMessage(uint64_t a1, void *a2, const char *a3)
{
  if (a1 && a2)
  {
    FigSimpleMutexLock(**(pthread_mutex_t ***)(a1 + 32));
    if (CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 32) + 56)) < 1)
    {
      uint64_t v6 = 0;
    }
    else
    {
      dispatch_source_set_timer(*(dispatch_source_t *)(*(void *)(a1 + 32) + 48), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      uint64_t v6 = FigXPCMessageSetCFArray(a2, a3, *(CFTypeRef *)(*(void *)(a1 + 32) + 56));
      if (!v6) {
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(*(void *)(a1 + 32) + 56));
      }
    }
    FigSimpleMutexUnlock(**(pthread_mutex_t ***)(a1 + 32));
    return v6;
  }
  else
  {
    return FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigMemoryRecipientAppendRecipientStateUpdateToIPCMessageData(uint64_t a1, _DWORD *a2, unint64_t a3, unint64_t *a4)
{
  if (!a1)
  {
    uint64_t result = FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
    unint64_t v7 = 0;
    if (!a4) {
      return result;
    }
    goto LABEL_15;
  }
  unint64_t v7 = 0;
  uint64_t result = 0;
  if (a2 && a3 >= 0xC)
  {
    uint64_t v19 = 0;
    FigSimpleMutexLock(**(pthread_mutex_t ***)(a1 + 32));
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 32) + 56));
    CFIndex v11 = Count - 1;
    if (Count < 1)
    {
      unint64_t v7 = 0;
    }
    else
    {
      CFIndex v12 = Count;
      uint64_t v13 = 0;
      unint64_t v14 = a3 - 8;
      unint64_t v15 = 12;
      do
      {
        uint64_t v16 = v13;
        FigCFArrayGetInt64AtIndex(*(const void **)(*(void *)(a1 + 32) + 56), 0, &v19);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(void *)(a1 + 32) + 56), 0);
        *(void *)&a2[2 * v13++ + 1] = v19;
        unint64_t v17 = v15 + 8;
        if (v11 == v16) {
          break;
        }
        BOOL v18 = v15 > v14;
        v15 += 8;
      }
      while (!v18);
      unint64_t v7 = v17 - 8;
      if (v12 == v13) {
        dispatch_source_set_timer(*(dispatch_source_t *)(*(void *)(a1 + 32) + 48), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      }
      *a2 = v13;
    }
    FigSimpleMutexUnlock(**(pthread_mutex_t ***)(a1 + 32));
    uint64_t result = 0;
  }
  if (a4) {
LABEL_15:
  }
    *a4 = v7;
  return result;
}

uint64_t FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2(xpc_object_t xdict, void *a2, const char *a3, uint64_t **a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2_sRecipientRemoteClients != -1) {
    dispatch_once(&FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2_sRecipientRemoteClients, &__block_literal_global_31);
  }
  xpc_object_t value = xpc_dictionary_get_value(xdict, "MemoryOriginEndpoint");
  if (value)
  {
    uint64_t v9 = (uint64_t)value;
    if (MEMORY[0x192FC6B30]() == MEMORY[0x1E4F145A0])
    {
      uint64_t int64 = xpc_dictionary_get_uint64(xdict, "MemoryOriginServerToken");
      if (uint64)
      {
        CFIndex v11 = (void *)uint64;
        FigSimpleMutexLock((pthread_mutex_t *)qword_1E92725C8);
        id v12 = FigCFWeakReferenceTableCopyValue(qword_1E92725D0, v11);
        uint64_t v13 = v12;
        if (v12)
        {
          uint64_t Instance = (uint64_t *)CFRetain(v12);
          version = 0;
          uint64_t v16 = 0;
          goto LABEL_38;
        }
        unsigned int v42 = a4;
        uint64_t v43 = a2;
        id v17 = FigCFWeakReferenceTableCopyValue(qword_1E92725D8, v11);
        uint64_t v16 = v17;
        if (v17)
        {
          version = CFRetain(v17);
          CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        }
        else
        {
          context.version = 0;
          CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionarySetValue(Mutable, @"xpcRemoteClientOption_DeathNoticeName", @"MemoryRecipient_ServerDied");
          CFDictionarySetValue(Mutable, @"xpcRemoteClientOption_DoNotMonitorConnection", (const void *)*MEMORY[0x1E4F1CFD0]);
          int v20 = FigXPCRemoteClientCreateWithXPCEndpoint((uint64_t)"FigMemoryRecipient", v9, (uint64_t)&MemoryRecipientCreateRemoteClientWithXPCEndpoint_sMemoryRecipientRemoteClientCallbacks, (uint64_t)Mutable, (uint64_t)&context);
          if (Mutable) {
            CFRelease(Mutable);
          }
          if (v20)
          {
            uint64_t v39 = FigSignalErrorAt(4294951764, 0, 0, 0, 0, 0, 0);
            version = 0;
            uint64_t Instance = 0;
            if (v39) {
              goto LABEL_63;
            }
          }
          else
          {
            version = (const void *)context.version;
          }
          uint64_t v21 = FigCFWeakReferenceTableAddValueAssociatedWithKey(qword_1E92725D8, (uint64_t)version, (uint64_t)v11);
          if (v21)
          {
            uint64_t v39 = v21;
            uint64_t Instance = 0;
            goto LABEL_63;
          }
        }
        xpc_object_t v44 = 0;
        xpc_object_t xdicta = 0;
        if (memoryRecipient_GetTypeID_sRegisterMemoryRecipientTypeOnce != -1) {
          dispatch_once(&memoryRecipient_GetTypeID_sRegisterMemoryRecipientTypeOnce, &__block_literal_global_99);
        }
        uint64_t Instance = (uint64_t *)_CFRuntimeCreateInstance();
        if (!Instance)
        {
          uint64_t v39 = FigSignalErrorAt(4294951765, 0, 0, 0, 0, 0, 0);
          a4 = v42;
          goto LABEL_36;
        }
        uint64_t v22 = FigXPCCreateBasicMessage(0x63726538u, 0, &xdicta);
        if (v22
          || (xpc_dictionary_set_string(xdicta, ".DebugName", a3),
              memset(buffer, 0, 32),
              pid_t v23 = getpid(),
              proc_name(v23, buffer, 0x20u),
              xpc_dictionary_set_string(xdicta, ".ProcessName", buffer),
              uint64_t v22 = FigXPCRemoteClientSendSyncMessageCreatingReply((uint64_t)version, (uint64_t)xdicta, &v44),
              v22))
        {
          uint64_t v39 = v22;
          a4 = v42;
          goto LABEL_59;
        }
        xpc_object_t v24 = (pthread_mutex_t *)xpc_dictionary_get_uint64(v44, ".objectID");
        Instance[2] = (uint64_t)v24;
        memset(&context, 0, sizeof(context));
        int v25 = (pthread_mutex_t **)malloc_type_calloc(1uLL, 0x40uLL, 0x1020040D4733842uLL);
        if (!v25)
        {
          uint64_t v39 = FigSignalErrorAt(4294951765, 0, 0, 0, 0, 0, 0);
LABEL_58:
          a4 = v42;
          a2 = v43;
          if (!v39)
          {
LABEL_35:
            uint64_t v39 = FigXPCRemoteClientAssociateObject((uint64_t)version, (uint64_t)Instance, v24);
            if (!v39) {
              goto LABEL_36;
            }
          }
LABEL_59:
          CFRelease(Instance);
          uint64_t Instance = 0;
LABEL_36:
          FigXPCRelease(xdicta);
          FigXPCRelease(v44);
          if (!v39)
          {
            uint64_t v40 = FigCFWeakReferenceTableAddValueAssociatedWithKey(qword_1E92725D0, (uint64_t)Instance, (uint64_t)v11);
            if (!v40)
            {
LABEL_38:
              xpc_dictionary_set_uint64(a2, "OriginObjectID", Instance[2]);
              *a4 = Instance;
              FigSimpleMutexUnlock((pthread_mutex_t *)qword_1E92725C8);
              if (v13) {
                CFRelease(v13);
              }
              uint64_t Instance = 0;
              uint64_t v39 = 0;
              if (!version) {
                goto LABEL_42;
              }
LABEL_41:
              CFRelease(version);
LABEL_42:
              if (v16) {
                CFRelease(v16);
              }
              if (Instance) {
                CFRelease(Instance);
              }
              return v39;
            }
            uint64_t v39 = v40;
          }
LABEL_63:
          FigSimpleMutexUnlock((pthread_mutex_t *)qword_1E92725C8);
          if (!version) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
        size_t v26 = v25;
        uint64_t v27 = FigSimpleMutexCreate();
        *size_t v26 = v27;
        if (v27)
        {
          CFMutableArrayRef v28 = CFArrayCreateMutable(v18, 0, 0);
          v26[1] = (pthread_mutex_t *)v28;
          if (v28)
          {
            uint64_t v29 = poolBlockState_Create(v18, 0, 0, 0, 0, @"ReceivedMemoryAllocatorPBS", v26 + 4);
            if (v29)
            {
LABEL_53:
              uint64_t v39 = v29;
              receivedMemoryAllocator_ReleaseInfo((uint64_t)v26);
              goto LABEL_58;
            }
            v26[2] = (pthread_mutex_t *)CFRetain(version);
            v26[3] = v24;
            context.info = v26;
            context.release = (CFAllocatorReleaseCallBack)receivedMemoryAllocator_ReleaseInfo;
            context.deallocate = (CFAllocatorDeallocateCallBack)receivedMemoryAllocator_Deallocate;
            CFAllocatorRef v30 = CFAllocatorCreate(0, &context);
            if (v30)
            {
              CFAllocatorRef v31 = v30;
              label = 0;
              BOOL v50 = 0;
              CFTypeRef cf = 0;
              unsigned int v47 = 0;
              uint64_t ServerPID = FigXPCRemoteClientGetServerPID((uint64_t)version, &v47);
              if (!ServerPID)
              {
                FigServer_CopyProcessName(v47, (CFStringRef *)&cf);
                CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree((CFStringRef)cf, 0x8000100u, (char **)&v50);
                size_t v34 = "()";
                if (CStringPtrAndBufferToFree) {
                  size_t v34 = CStringPtrAndBufferToFree;
                }
                asprintf(&label, "com.apple.coremedia.memoryrecipient.use-count-batching.%s-%d", v34, v47);
                free(v50);
                if (cf) {
                  CFRelease(cf);
                }
                v26[5] = (pthread_mutex_t *)dispatch_queue_create(label, 0);
                free(label);
                if (v26[5])
                {
                  CFMutableArrayRef v35 = CFArrayCreateMutable(v18, 0, MEMORY[0x1E4F1D510]);
                  v26[7] = (pthread_mutex_t *)v35;
                  if (v35)
                  {
                    dispatch_source_t v36 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, (dispatch_queue_t)v26[5]);
                    v26[6] = (pthread_mutex_t *)v36;
                    if (v36)
                    {
                      uint64_t v37 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)v31);
                      dispatch_set_context((dispatch_object_t)v26[6], v37);
                      dispatch_set_finalizer_f((dispatch_object_t)v26[6], (dispatch_function_t)receivedMemoryAllocator_finalizeUseCountUpdateTimer);
                      uint64_t v38 = v26[6];
                      handler[0] = MEMORY[0x1E4F143A8];
                      handler[1] = 0x40000000;
                      handler[2] = __CreateReceivedMemoryAllocator_block_invoke;
                      handler[3] = &__block_descriptor_tmp_108;
                      _OWORD handler[4] = v37;
                      dispatch_source_set_event_handler(v38, handler);
                      dispatch_source_set_timer((dispatch_source_t)v26[6], 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
                      dispatch_resume((dispatch_object_t)v26[6]);
                      if (v37)
                      {
                        Instance[3] = (uint64_t)v31;
                        Instance[4] = (uint64_t)v26;
                        a4 = v42;
                        a2 = v43;
                        goto LABEL_35;
                      }
                    }
                  }
                }
                uint64_t ServerPID = FigSignalErrorAt(4294951765, 0, 0, 0, 0, 0, 0);
              }
              uint64_t v39 = ServerPID;
              CFRelease(v31);
              goto LABEL_58;
            }
          }
        }
        uint64_t v29 = FigSignalErrorAt(4294951765, 0, 0, 0, 0, 0, 0);
        goto LABEL_53;
      }
    }
  }

  return FigSignalErrorAt(4294951764, 0, 0, 0, 0, 0, 0);
}

uint64_t __FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2_block_invoke()
{
  qword_1E92725C8 = (uint64_t)FigSimpleMutexCreate();
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  FigCFWeakReferenceTableCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 1, &qword_1E92725D0);

  return FigCFWeakReferenceTableCreate(v0, 1, &qword_1E92725D8);
}

uint64_t FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt()
{
  if (FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt_onceToken != -1) {
    dispatch_once(&FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt_onceToken, &__block_literal_global_30_1);
  }
  uint64_t result = sFigMemoryOriginTransactionThreadKey;
  if (sFigMemoryOriginTransactionThreadKey)
  {
    CFNumberRef Value = FigThreadGetValue(sFigMemoryOriginTransactionThreadKey);
    if (Value)
    {
LABEL_5:
      uint64_t result = 0;
      unsigned char *Value = 1;
      return result;
    }
    uint64_t v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x1020040984C81BBuLL);
    if (v2)
    {
      CFNumberRef Value = v2;
      uint64_t result = FigThreadSetValue(sFigMemoryOriginTransactionThreadKey, v2);
      if (!result) {
        goto LABEL_5;
      }
    }
    else
    {
      return FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t __FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt_block_invoke()
{
  return pthread_key_create((pthread_key_t *)&sFigMemoryOriginTransactionThreadKey, (void (__cdecl *)(void *))transactionThreadDestructor);
}

void transactionThreadDestructor(void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(unsigned char *)a1)
    {
      v10[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
      int v3 = v10[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v5 = v3;
      }
      else {
        unsigned int v5 = v3 & 0xFFFFFFFE;
      }
      if (v5)
      {
        v10[1] = 136315394;
        CFIndex v11 = "transactionThreadDestructor";
        __int16 v12 = 2048;
        uint64_t v13 = a1;
        uint64_t v6 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v3) = v10[0];
      }
      else
      {
        uint64_t v6 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v6, v6 != &v14, v3, 0, v4);
    }
    unint64_t v7 = (const void *)a1[1];
    if (v7) {
      CFRelease(v7);
    }
    uint32_t v8 = (const void *)a1[2];
    if (v8) {
      CFRelease(v8);
    }
    free(a1);
  }
}

uint64_t FigMemoryOriginCompleteTransaction(int a1)
{
  CFNumberRef Value = (const __CFArray **)FigThreadGetValue(sFigMemoryOriginTransactionThreadKey);
  if (Value)
  {
    int v3 = Value;
    if (*(unsigned char *)Value)
    {
      CFArrayRef v4 = Value[1];
      if (v4)
      {
        CFIndex Count = CFArrayGetCount(v4);
        if (Count >= 1)
        {
          CFIndex v6 = Count;
          CFArrayRef v7 = v3[2];
          if (v7)
          {
            CFIndex v8 = CFArrayGetCount(v7);
            uint64_t v9 = 0;
            if (a1 != 1 || v6 != v8) {
              goto LABEL_11;
            }
            for (CFIndex i = 0; i != v6; ++i)
            {
              CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v3[1], i);
              CFNumberRef v12 = (const __CFNumber *)CFArrayGetValueAtIndex(v3[2], i);
              CFNumberRef SInt64 = FigCFNumberGetSInt64(v12);
              memoryOrigin_unregisterUseOfBlock((uint64_t)ValueAtIndex, SInt64);
            }
          }
        }
      }
      uint64_t v9 = 0;
    }
    else
    {
      uint64_t v9 = FigSignalErrorAt(4294951773, 0, 0, 0, 0, 0, 0);
    }
LABEL_11:
    FigCFArrayRemoveAllValues(v3[1]);
    FigCFArrayRemoveAllValues(v3[2]);
    *(unsigned char *)int v3 = 0;
    return v9;
  }

  return FigSignalErrorAt(4294951773, 0, 0, 0, 0, 0, 0);
}

uint64_t poolBlockState_DeallocateVMMemory(uint64_t result)
{
  if (!*(unsigned char *)(result + 36)) {
    JUMPOUT(0x192FC66D0);
  }
  if (*(void *)(result + 16)) {
    return munmap(*(void **)(result + 16), *(void *)(result + 8));
  }
  return result;
}

void poolBlockState_postForgottenSerialNumber(const void *a1, uint64_t *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt64(Mutable, @"pool_BlockSerialNumber", *a2);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, @"pool_ForgetBlock", a1, Mutable);

  CFRelease(Mutable);
}

uint64_t figMemoryPoolInit(uint64_t result)
{
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

void figMemoryPoolFinalize(OpaqueCMMemoryPool *a1)
{
  CMMemoryPoolInvalidate(a1);
  uint64_t v2 = (const void *)*((void *)a1 + 3);
  if (v2)
  {
    CFRelease(v2);
    *((void *)a1 + 3) = 0;
  }
  int v3 = (const void *)*((void *)a1 + 2);
  if (v3)
  {
    CFRelease(v3);
    *((void *)a1 + 2) = 0;
  }
}

CFStringRef figMemoryPoolCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigMemoryPool %p]", a1);
}

__CFString *figMemoryPoolCopyDebugDesc(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  CFStringRef v5 = CFCopyDescription(v2);
  CFIndex v6 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, @"FigMemoryPool %p RC: %d poolingAllocator: %p %@", a1, v6, a1[3], v5);
  if (v5) {
    CFRelease(v5);
  }
  return Mutable;
}

void poolBlockState_DecrementUseCountInternal(uint64_t a1, const void **a2)
{
  int v2 = *((_DWORD *)a2 + 8) - 1;
  *((_DWORD *)a2 + 8) = v2;
  if (!v2)
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 64), a2[2]);
    if (*(unsigned char *)(a1 + 16))
    {
      a2[3] = (const void *)(*(void *)(a1 + 32) + FigGetUpTimeNanoseconds());
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 72), a2);
      CFStringRef v5 = a2[3];
      if (*(void *)(a1 + 48) > (uint64_t)v5) {
        *(void *)(a1 + 48) = v5;
      }
    }
    else
    {
      poolBlockState_DeallocateVMMemory((uint64_t)a2);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 80), *a2);
      poolBlockState_postForgottenSerialNumber((const void *)a1, (uint64_t *)a2);
      free(a2);
    }
  }
}

__CFString *poolBlockState_copyBlockInfoDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, @"info %p ptr %p size %zd, expiryNanos %lld BlockSN %016llx useCount %d", a1, *(void *)(a1 + 16), *(void *)(a1 + 8), *(void *)(a1 + 24), *(void *)a1, *(unsigned int *)(a1 + 32));
  return Mutable;
}

uint64_t poolBlockState_RegisterType(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

double poolBlockState_Init(uint64_t a1)
{
  *(void *)(a1 + 96) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

CFAllocatorRef poolBlockState_Finalize(void *a1)
{
  int v2 = (const void *)a1[8];
  if (v2)
  {
    CFRelease(v2);
    a1[8] = 0;
  }
  CFAllocatorRef v3 = (const void *)a1[9];
  if (v3)
  {
    CFRelease(v3);
    a1[9] = 0;
  }
  CFArrayRef v4 = (const void *)a1[10];
  if (v4)
  {
    CFRelease(v4);
    a1[10] = 0;
  }
  CFStringRef v5 = (const void *)a1[5];
  if (v5)
  {
    CFRelease(v5);
    a1[5] = 0;
  }
  CFIndex v6 = (const void *)a1[12];
  if (v6)
  {
    CFRelease(v6);
    a1[12] = 0;
  }
  CFAllocatorRef result = (const __CFAllocator *)a1[7];
  if (result)
  {
    CFAllocatorRef result = FigSimpleMutexDestroy((uint64_t)result);
    a1[7] = 0;
  }
  return result;
}

__CFString *poolBlockState_CopyFormattingDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 56));
  CFIndex v4 = CFGetRetainCount((CFTypeRef)a1);
  CFStringRef v5 = *(__CFString **)(a1 + 40);
  CFDictionaryRef Count = FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 64));
  CFArrayRef v7 = *(const __CFArray **)(a1 + 72);
  if (v7) {
    CFArrayRef v7 = (const __CFArray *)CFArrayGetCount(v7);
  }
  CFIndex v8 = &stru_1EDF73CD0;
  if (v5) {
    CFIndex v8 = v5;
  }
  CFStringAppendFormat(Mutable, 0, @"<PoolBlockState %p RC: %d \"%@\" blocksInUse: %ld blocksForReuse: %ld>", a1, v4, v8, Count, v7);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 56));
  return Mutable;
}

__CFString *poolBlockState_CopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 56));
  CFIndex v4 = CFGetRetainCount((CFTypeRef)a1);
  CFStringRef v5 = &stru_1EDF73CD0;
  if (*(void *)(a1 + 40)) {
    CFStringRef v5 = *(__CFString **)(a1 + 40);
  }
  if (*(unsigned char *)(a1 + 16)) {
    CFIndex v6 = "recyclingEnabled";
  }
  else {
    CFIndex v6 = "recyclingDisabled";
  }
  CFStringAppendFormat(Mutable, 0, @"PoolBlockState %p RC: %d %@ %s blocksInUse: %p %@ blocksForReuse: %p %@", a1, v4, v5, v6, *(void *)(a1 + 64), *(void *)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 72));
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 56));
  return Mutable;
}

unint64_t poolBlockState_newMemoryBlockSerialNumber()
{
  if (poolBlockState_newMemoryBlockSerialNumber_sInitMemoryBlockSerialNumberOnce != -1) {
    dispatch_once_f(&poolBlockState_newMemoryBlockSerialNumber_sInitMemoryBlockSerialNumberOnce, &poolBlockState_newMemoryBlockSerialNumber_sNextMemoryBlockSerialNumber, (dispatch_function_t)poolBlockState_InitBlockSerialNumber);
  }

  return FigAtomicIncrement64(&poolBlockState_newMemoryBlockSerialNumber_sNextMemoryBlockSerialNumber);
}

uint64_t poolBlockState_InitBlockSerialNumber(void *a1)
{
  uint64_t result = getpid();
  *a1 = result << 47;
  return result;
}

uint64_t poolBlockState_IncrementBlockUseCountAndAccessMemory(uint64_t a1, const void *a2, void *a3, void *a4)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 56));
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  ++Value[8];
  uint64_t v9 = *((void *)Value + 1);
  *a3 = *((void *)Value + 2);
  *a4 = v9;
  xpc_object_t v10 = *(pthread_mutex_t **)(a1 + 56);

  return FigSimpleMutexUnlock(v10);
}

uint64_t memoryOrigin_poolNotificationListener(int a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5)
{
  uint64_t result = CFEqual(cf1, @"pool_ForgetBlock");
  if (result)
  {
    key = 0;
    FigCFDictionaryGetInt64IfPresent(a5, @"pool_BlockSerialNumber", &key);
    FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 16));
    CFNumberRef Value = (const void **)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 24), key);
    if (Value)
    {
      uint64_t v9 = Value;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      FigCFDictionarySetInt64(Mutable, @"BlockSerialNumber", (uint64_t)key);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 24), key);
      if (*(void *)(a2 + 72))
      {
        if (!CFDictionaryGetCount(*(CFDictionaryRef *)(a2 + 24)))
        {
          CFIndex v11 = *(void **)(a2 + 72);
          if (v11)
          {
            os_release(v11);
            *(void *)(a2 + 72) = 0;
          }
        }
      }
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification(DefaultLocalCenter, @"ForgetBlock", (const void *)a2, Mutable);
      if (Mutable) {
        CFRelease(Mutable);
      }
      CFBagRemoveValue(*(CFMutableBagRef *)(a2 + 32), *v9);
      if (!MEMORY[0x192FC3C00](*(void *)(a2 + 32), *v9))
      {
        uint64_t v13 = CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterRemoveWeakListener(v13, (const void *)a2, (uint64_t)memoryOrigin_poolNotificationListener, 0, *v9);
      }
      memoryOrigin_disposeOriginEntry(v9);
    }
    return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 16));
  }
  return result;
}

uint64_t poolBlockState_DecrementBlockUseCount(uint64_t a1, const void *a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 56));
  CFNumberRef Value = (const void **)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  poolBlockState_DecrementUseCountInternal(a1, Value);
  CFStringRef v5 = *(pthread_mutex_t **)(a1 + 56);

  return FigSimpleMutexUnlock(v5);
}

void memoryOrigin_disposeOriginEntry(const void **a1)
{
  if (a1)
  {
    CFAllocatorRef v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    CFAllocatorRef v3 = (void *)a1[1];
    if (v3)
    {
      a1[1] = 0;
      xpc_release(v3);
    }
    free(a1);
  }
}

uint64_t __EnsureMemoryOriginServerStarted_block_invoke()
{
  uint64_t v0 = getpid();
  gMemoryOriginServerToken = FigGetUpTimeNanoseconds() & 0x1FFFFFFFFFFLL | (v0 << 47);
  uint64_t result = FigXPCServerStartWithNewXPCEndpoint((uint64_t)"MemoryOriginServer", MemoryOriginServerStart_callbacks, 0, &gMemoryOriginServer);
  EnsureMemoryOriginServerStarted_sMemoryOriginServerStartError = result;
  return result;
}

uint64_t memoryOriginServer_handleRemoteMessageWithReply(_xpc_connection_s *a1, void *a2, void *a3)
{
  int v25 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v25);
  if (OpCode) {
    return OpCode;
  }
  if (v25 != 1718903656)
  {
    if (v25 != 1668441400) {
      return FigSignalErrorAt(4294951138, 0, 0, 0, 0, 0, 0);
    }
    uint64_t value = 0;
    string = xpc_dictionary_get_string(a2, ".DebugName");
    CFIndex v8 = xpc_dictionary_get_string(a2, ".ProcessName");
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (memoryOrigin_GetTypeID_sRegisterMemoryOriginTypeOnce != -1) {
      dispatch_once(&memoryOrigin_GetTypeID_sRegisterMemoryOriginTypeOnce, &__block_literal_global_91);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v11 = Instance;
      CFNumberRef v12 = FigReentrantMutexCreate();
      *(void *)(v11 + 16) = v12;
      if (v12)
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v9, 0, 0, 0);
        *(void *)(v11 + 24) = Mutable;
        if (Mutable)
        {
          CFMutableBagRef v14 = CFBagCreateMutable(v9, 0, MEMORY[0x1E4F1D520]);
          *(void *)(v11 + 32) = v14;
          if (v14)
          {
            if (string) {
              uint64_t v15 = strndup(string, 0x64uLL);
            }
            else {
              uint64_t v15 = strdup("unnamed");
            }
            *(void *)(v11 + 48) = v15;
            if (v8) {
              uint64_t v22 = strndup(v8, 0x64uLL);
            }
            else {
              uint64_t v22 = strdup("unknown");
            }
            *(void *)(v11 + 64) = v22;
            *(_DWORD *)(v11 + 56) = xpc_connection_get_pid(a1);
            uint64_t v23 = FigXPCServerAssociateObjectWithConnection(a1, (const void *)v11, 0, 0, 0, &value);
            if (v23)
            {
              uint64_t v20 = v23;
              goto LABEL_26;
            }
LABEL_25:
            xpc_dictionary_set_uint64(a3, ".objectID", value);
            uint64_t v20 = 0;
            *(void *)(v11 + 40) = value;
LABEL_26:
            uint64_t v21 = (const void *)v11;
LABEL_27:
            CFRelease(v21);
            return v20;
          }
        }
      }
      uint64_t v20 = FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
      CFRelease((CFTypeRef)v11);
    }
    else
    {
      uint64_t v20 = FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
    }
    if (v20) {
      return v20;
    }
    OpCFIndex Code = FigXPCServerAssociateObjectWithConnection(a1, 0, 0, 0, 0, &value);
    uint64_t v11 = 0;
    if (!OpCode) {
      goto LABEL_25;
    }
    return OpCode;
  }
  uint64_t value = 0;
  uint64_t int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  int64_t int64 = (const void *)xpc_dictionary_get_int64(a2, "BlockSerialNumber");
  uint64_t v18 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &value, 0);
  if (v18)
  {
    uint64_t v20 = v18;
  }
  else
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(value + 16));
    uint64_t v19 = (xpc_object_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(value + 24), int64);
    if (v19)
    {
      xpc_dictionary_set_value(a3, "OriginData", v19[1]);
      uint64_t v20 = 0;
    }
    else
    {
      uint64_t v20 = FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(value + 16));
  }
  uint64_t v21 = (const void *)value;
  if (value) {
    goto LABEL_27;
  }
  return v20;
}

uint64_t memoryOriginServer_handleRemoteMessageNoReply(_xpc_connection_s *a1, void *a2)
{
  int v12 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v12);
  if (OpCode) {
    return OpCode;
  }
  if (v12 != 1970482529)
  {
    if (v12 == 1970496813)
    {
      CFTypeRef v14 = 0;
      uint64_t int64 = xpc_dictionary_get_uint64(a2, ".objectID");
      int64_t int64 = (const void *)xpc_dictionary_get_int64(a2, "BlockSerialNumber");
      uint64_t v7 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &v14, 0);
      if (!v7) {
        uint64_t v7 = memoryOrigin_unregisterUseOfBlock((uint64_t)v14, int64);
      }
      goto LABEL_6;
    }
    return FigSignalErrorAt(4294951138, 0, 0, 0, 0, 0, 0);
  }
  CFTypeRef cf = 0;
  CFTypeRef v14 = 0;
  uint64_t v9 = xpc_dictionary_get_uint64(a2, ".objectID");
  uint64_t v7 = FigXPCMessageCopyCFArray(a2, "BlockSerialNumberArray", &v14);
  if (!v7)
  {
    uint64_t v8 = FigXPCServerLookupAndRetainAssociatedObject(a1, v9, &cf, 0);
    CFTypeRef v10 = cf;
    if (!v8)
    {
      uint64_t v8 = memoryOrigin_unregisterUseOfMultipleBlocks((uint64_t)cf, (CFArrayRef)v14);
      CFTypeRef v10 = cf;
    }
    if (v10) {
      CFRelease(v10);
    }
    goto LABEL_12;
  }
LABEL_6:
  uint64_t v8 = v7;
LABEL_12:
  if (v14) {
    CFRelease(v14);
  }
  return v8;
}

double memoryOrigin_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

uint64_t memoryOrigin_Finalize(uint64_t a1)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(a1 + 24);
  if (v2)
  {
    CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)memoryOrigin_disposeEachOriginEntry, 0);
    CFAllocatorRef v3 = *(const void **)(a1 + 24);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 24) = 0;
    }
  }
  CFIndex v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 32) = 0;
  }
  free(*(void **)(a1 + 48));
  *(void *)(a1 + 48) = 0;
  free(*(void **)(a1 + 64));
  *(void *)(a1 + 64) = 0;
  CFStringRef v5 = *(void **)(a1 + 72);
  if (v5)
  {
    os_release(v5);
    *(void *)(a1 + 72) = 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);

  return FigReentrantMutexDestroy(v6);
}

__CFString *memoryOrigin_CopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFMutableArrayRef v3 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  if (v3)
  {
    CFMutableArrayRef v4 = v3;
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    uint64_t v5 = *(void *)(a1 + 40);
    CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
    CFStringAppendFormat(Mutable, 0, @"FigMemoryOrigin %p ObjectID %016llx %ld originBlocks", a1, v5, Count);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    CFRelease(v4);
  }
  return Mutable;
}

void memoryOrigin_disposeEachOriginEntry(int a1, void *a2)
{
  if (*((int *)a2 + 6) >= 1)
  {
    int v3 = 0;
    do
    {
      poolBlockState_DecrementBlockUseCount(*(void *)a2, *((const void **)a2 + 2));
      ++v3;
    }
    while (v3 < *((_DWORD *)a2 + 6));
  }

  memoryOrigin_disposeOriginEntry((const void **)a2);
}

void receivedMemoryAllocator_tellOriginToDecrementUseCountOfBlock(uint64_t a1, uint64_t a2)
{
  if (!FigCFArrayAppendInt64(*(void **)(a1 + 56), a2) && CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) == 1)
  {
    int v3 = *(NSObject **)(a1 + 48);
    dispatch_time_t v4 = dispatch_time(0, 200000000);
    dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
}

uint64_t memoryRecipient_NotificationFilter(uint64_t a1, CFTypeRef cf1, uint64_t a3, uint64_t a4)
{
  if (CFEqual(cf1, @"ForgetBlock"))
  {
    uint64_t v12 = 0;
    uint64_t v6 = *(void *)(a1 + 32);
    FigCFDictionaryGetInt64IfPresent(a4, @"BlockSerialNumber", &v12);
    FigSimpleMutexLock(*(pthread_mutex_t **)v6);
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v6 + 8));
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      CFIndex v9 = 0;
      while (1)
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v6 + 8), v9);
        if (*(void *)ValueAtIndex == v12) {
          break;
        }
        if (v8 == ++v9) {
          goto LABEL_9;
        }
      }
      ValueAtIndex[41] = 1;
      if (!ValueAtIndex[40])
      {
        receivedMemoryAllocator_disposeReceivedMemoryEntry((uint64_t)ValueAtIndex);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v6 + 8), v9);
      }
    }
LABEL_9:
    FigSimpleMutexUnlock(*(pthread_mutex_t **)v6);
  }
  return 1;
}

void receivedMemoryAllocator_disposeReceivedMemoryEntry(uint64_t a1)
{
  if (a1)
  {
    poolBlockState_DecrementBlockUseCount(*(void *)(a1 + 48), *(const void **)(a1 + 8));
    CFDictionaryRef v2 = *(const void **)(a1 + 48);
    if (v2) {
      CFRelease(v2);
    }
    int v3 = *(const void **)(a1 + 32);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 32) = 0;
    }
    CFAllocatorRef v4 = *(const __CFAllocator **)(a1 + 56);
    CFAllocatorDeallocate(v4, (void *)a1);
    if (v4)
    {
      CFRelease(v4);
    }
  }
}

void *memoryRecipient_Init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void memoryRecipient_Finalize(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    FigSimpleMutexLock(**(pthread_mutex_t ***)(a1 + 32));
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 32) + 8));
    if (Count >= 1)
    {
      CFIndex v3 = Count;
      CFIndex v4 = 0;
      do
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 32) + 8), v4);
        ValueAtIndex[41] = 1;
        if (ValueAtIndex[40])
        {
          ++v4;
        }
        else
        {
          receivedMemoryAllocator_disposeReceivedMemoryEntry((uint64_t)ValueAtIndex);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(void *)(a1 + 32) + 8), v4);
          --v3;
        }
      }
      while (v4 < v3);
    }
    FigSimpleMutexUnlock(**(pthread_mutex_t ***)(a1 + 32));
    uint64_t v6 = *(const void **)(a1 + 24);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(a1 + 24) = 0;
    }
  }
}

__CFString *memoryRecipient_CopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  FigSimpleMutexLock(**(pthread_mutex_t ***)(a1 + 32));
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 32) + 8));
  CFStringAppendFormat(Mutable, 0, @"FigMemoryRecipient %p ObjectID %016llx receivedMemoryAllocator %p %ld memory blocks", a1, *(void *)(a1 + 16), *(void *)(a1 + 24), Count);
  FigSimpleMutexUnlock(**(pthread_mutex_t ***)(a1 + 32));
  return Mutable;
}

void receivedMemoryAllocator_ReleaseInfo(uint64_t a1)
{
  if (a1)
  {
    CFDictionaryRef v2 = *(NSObject **)(a1 + 48);
    if (v2)
    {
      dispatch_source_cancel(v2);
      CFIndex v3 = *(NSObject **)(a1 + 48);
      if (v3)
      {
        dispatch_release(v3);
        *(void *)(a1 + 48) = 0;
      }
      receivedMemoryAllocator_sendPendingBatchOfBlockSNtoDecrementUseCount((pthread_mutex_t **)a1);
    }
    CFIndex v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_release(v4);
      *(void *)(a1 + 40) = 0;
    }
    uint64_t v5 = *(const void **)(a1 + 56);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a1 + 56) = 0;
    }
    CFArrayRef v6 = *(const __CFArray **)(a1 + 8);
    if (v6)
    {
      CFIndex Count = CFArrayGetCount(v6);
      if (Count >= 1)
      {
        CFIndex v8 = Count;
        for (CFIndex i = 0; i != v8; ++i)
        {
          CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), i);
          receivedMemoryAllocator_disposeReceivedMemoryEntry((uint64_t)ValueAtIndex);
        }
      }
    }
    uint64_t v11 = *(const void **)(a1 + 32);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(a1 + 32) = 0;
    }
    uint64_t v12 = *(const void **)(a1 + 8);
    if (v12)
    {
      CFRelease(v12);
      *(void *)(a1 + 8) = 0;
    }
    uint64_t v13 = *(const void **)(a1 + 16);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(a1 + 16) = 0;
    }
    FigSimpleMutexDestroy(*(void *)a1);
    free((void *)a1);
  }
}

void receivedMemoryAllocator_Deallocate(id *a1, uint64_t a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)a2);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 8));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    CFMutableDictionaryRef Mutable = 0;
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex v9 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    while (1)
    {
      CFNumberRef ValueAtIndex = (id **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 8), v6);
      if (ValueAtIndex[2] == a1)
      {
        uint64_t v11 = (uint64_t)ValueAtIndex;
        uint64_t v12 = FigCFWeakReferenceHolderCopyReferencedObject(ValueAtIndex[4]);
        if (!v12)
        {
          if (*(unsigned char *)(v11 + 40))
          {
            *(unsigned char *)(v11 + 40) = 0;
            if (*(unsigned char *)(v11 + 41))
            {
              receivedMemoryAllocator_disposeReceivedMemoryEntry(v11);
              CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a2 + 8), v6);
            }
            else
            {
              receivedMemoryAllocator_tellOriginToDecrementUseCountOfBlock(a2, *(void *)v11);
            }
          }
          goto LABEL_12;
        }
        uint64_t v13 = v12;
        if (*(void *)v11)
        {
          FigSimpleMutexUnlock(*(pthread_mutex_t **)a2);
          CFRelease(v13);
          if (Mutable) {
            goto LABEL_13;
          }
          return;
        }
        if (!Mutable) {
          CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v8, 0, v9);
        }
        CFArrayAppendValue(Mutable, v13);
        CFRelease(v13);
      }
      if (v5 == ++v6) {
        goto LABEL_12;
      }
    }
  }
  CFMutableDictionaryRef Mutable = 0;
LABEL_12:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)a2);
  if (Mutable)
  {
LABEL_13:
    CFRelease(Mutable);
  }
}

void receivedMemoryAllocator_finalizeUseCountUpdateTimer(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void __CreateReceivedMemoryAllocator_block_invoke(uint64_t a1)
{
  uint64_t v1 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 32));
  if (v1)
  {
    CFDictionaryRef v2 = v1;
    memset(&v3, 0, sizeof(v3));
    CFAllocatorGetContext((CFAllocatorRef)v1, &v3);
    if (v3.info) {
      receivedMemoryAllocator_sendPendingBatchOfBlockSNtoDecrementUseCount((pthread_mutex_t **)v3.info);
    }
    CFRelease(v2);
  }
}

void receivedMemoryAllocator_sendPendingBatchOfBlockSNtoDecrementUseCount(pthread_mutex_t **a1)
{
  xpc_object_t xdict = 0;
  if (a1)
  {
    uint64_t v1 = a1;
    FigSimpleMutexLock(*a1);
    if (CFArrayGetCount((CFArrayRef)v1[7]) >= 1 && !FigXPCCreateBasicMessage(0x75732D61u, 0, &xdict))
    {
      FigXPCMessageSetCFObject(xdict, "BlockSerialNumberArray", v1[7]);
      CFArrayRemoveAllValues((CFMutableArrayRef)v1[7]);
      xpc_dictionary_set_uint64(xdict, ".objectID", (uint64_t)v1[3]);
      FigXPCRemoteClientSendAsyncMessage((uint64_t)v1[2], xdict);
    }
    FigSimpleMutexUnlock(*v1);
    a1 = (pthread_mutex_t **)xdict;
  }
  FigXPCRelease(a1);
}

uint64_t FigTransportStreamGetClassID()
{
  if (FigTransportStreamGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigTransportStreamGetClassID_sRegisterOnce, &FigTransportStreamGetClassID_sClassID, (dispatch_function_t)stream_getClassID);
  }
  return FigTransportStreamGetClassID_sClassID;
}

uint64_t stream_getClassID(void *a1)
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&stream_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigTransportStreamGetTypeID()
{
  if (FigTransportStreamGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigTransportStreamGetClassID_sRegisterOnce, &FigTransportStreamGetClassID_sClassID, (dispatch_function_t)stream_getClassID);
  }
  uint64_t v0 = (void *)FigTransportStreamGetClassID_sClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigTransportStreamSendBatchSlow(uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  uint64_t result = 4294950686;
  if (a1 && theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      CFIndex v8 = Count;
      CFIndex v9 = 0;
      while (1)
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v9);
        if (!ValueAtIndex) {
          break;
        }
        uint64_t v11 = ValueAtIndex;
        CFTypeID v12 = CFGetTypeID(ValueAtIndex);
        if (v12 != CMBlockBufferGetTypeID()) {
          break;
        }
        uint64_t v13 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
        if (v13) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, const void *))(v14 + 48);
        if (!v15) {
          return 4294954514;
        }
        uint64_t result = v15(a1, a2, v11);
        if (result) {
          return result;
        }
        if (v8 == ++v9) {
          return 0;
        }
      }
      return 4294950686;
    }
  }
  return result;
}

CFStringRef stream_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigTransportStream %p]", a1);
}

uint64_t FigEndpointPlaybackSessionStartServer()
{
  v3[0] = 1;
  v3[1] = HandleEndpointPlaybackSessionRemoteMessage;
  long long v4 = 0u;
  long long v5 = 0u;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32(Mutable, @"xpcServerOption_SelfTerminationTimeout", 30);
  uint64_t v1 = FigXPCServerStart((uint64_t)"com.apple.coremedia.endpointplaybacksession.xpc", v3, (uint64_t)Mutable, &gEndpointPlaybackSessionServer);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v1;
}

uint64_t HandleEndpointPlaybackSessionRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  int v87 = 0;
  uint64_t v86 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v87);
  if (OpCode) {
    return OpCode;
  }
  uint64_t int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  cf[0] = 0;
  uint64_t v8 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, cf, &v86);
  if (!v8)
  {
    if (cf[0])
    {
      CFTypeID v9 = CFGetTypeID(cf[0]);
      if (v9 == FigEndpointPlaybackSessionGetTypeID())
      {
        CFTypeRef v10 = cf[0];
        goto LABEL_6;
      }
    }
    uint64_t v8 = FigSignalErrorAt(4294950556, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v11 = v8;
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  if (v11) {
    return v11;
  }
  CFTypeRef v10 = 0;
LABEL_6:
  uint64_t v11 = 4294950556;
  if (v87 <= 1886151032)
  {
    if (v87 <= 1685024620)
    {
      if (v87 <= 1635018856)
      {
        if (v87 == 778268793)
        {
          uint64_t v24 = FigXPCHandleStdCopyPropertyMessage((uint64_t)v10, a2, a3);
        }
        else
        {
          if (v87 != 779314548) {
            goto LABEL_195;
          }
          uint64_t v24 = FigXPCHandleStdSetPropertyMessage((uint64_t)v10, a2);
        }
        goto LABEL_194;
      }
      if (v87 != 1635018857)
      {
        if (v87 == 1667593832)
        {
          uint64_t v33 = v86;
          uint64_t v34 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
          uint64_t v35 = v34 ? v34 : 0;
          CFIndex v75 = *(uint64_t (**)(CFTypeRef, void, void, void))(v35 + 120);
          uint64_t v11 = v75 ? v75(v10, 0, 0, 0) : 4294954514;
          *(void *)(v33 + 8) = 0;
          long long v76 = *(void **)(v33 + 16);
          if (v76)
          {
            *(void *)(v33 + 16) = 0;
            xpc_release(v76);
            if (!v10) {
              return v11;
            }
            goto LABEL_196;
          }
        }
        goto LABEL_195;
      }
      cf[0] = 0;
      v91[0] = 0;
      uint64_t v13 = FigXPCMessageCopyCFData(a2, "PicRequest", cf);
      if (v13) {
        goto LABEL_173;
      }
      uint64_t v13 = FigXPCMessageCopyCFString(a2, "ItemUUID", v91);
      if (v13) {
        goto LABEL_173;
      }
      CompletionCallbackParametersFromMessageAndConnection_0 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
      CFTypeRef v15 = cf[0];
      CFTypeRef v16 = v91[0];
      if (CompletionCallbackParametersFromMessageAndConnection_0) {
        id v17 = AuthorizeItemCompletionCallback;
      }
      else {
        id v17 = 0;
      }
      uint64_t v69 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
      if (v69) {
        uint64_t v70 = v69;
      }
      else {
        uint64_t v70 = 0;
      }
      uint64_t v80 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, void *, void *))(v70 + 16);
      if (!v80) {
        goto LABEL_174;
      }
      goto LABEL_172;
    }
    if (v87 > 1735422065)
    {
      if (v87 != 1735422066)
      {
        if (v87 != 1768846956)
        {
          if (v87 != 1768976745) {
            goto LABEL_195;
          }
          uint64_t v12 = v86;
          cf[0] = 0;
          v91[0] = 0;
          uint64_t v13 = FigXPCMessageCopyCFDictionary(a2, "Item", cf);
          if (v13) {
            goto LABEL_173;
          }
          uint64_t v13 = FigXPCMessageCopyCFDictionary(a2, "AfterItem", v91);
          if (v13) {
            goto LABEL_173;
          }
          uint64_t v13 = checkRequestAgainstSandboxRules(a1, v12, a2, (CFDictionaryRef)cf[0]);
          if (v13) {
            goto LABEL_173;
          }
          CompletionCallbackParametersFromMessageAndConnection_0 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
          CFTypeRef v15 = cf[0];
          CFTypeRef v16 = v91[0];
          if (CompletionCallbackParametersFromMessageAndConnection_0) {
            id v17 = StandardCompletionCallback;
          }
          else {
            id v17 = 0;
          }
          uint64_t v18 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
          if (v18) {
            uint64_t v19 = v18;
          }
          else {
            uint64_t v19 = 0;
          }
          uint64_t v80 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, void *, void *))(v19 + 32);
          if (v80) {
            goto LABEL_172;
          }
LABEL_174:
          uint64_t v11 = 4294954514;
LABEL_175:
          if (cf[0]) {
            CFRelease(cf[0]);
          }
          CFTypeRef v81 = v91[0];
          if (v91[0]) {
            goto LABEL_178;
          }
          goto LABEL_195;
        }
        uint64_t CMBaseObject = FigEndpointPlaybackSessionGetCMBaseObject(v10);
        if (!CMBaseObject)
        {
          uint64_t v11 = 4294954516;
          if (!v10) {
            return v11;
          }
          goto LABEL_196;
        }
        uint64_t v41 = CMBaseObject;
        uint64_t v42 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
        if (v42) {
          uint64_t v43 = v42;
        }
        else {
          uint64_t v43 = 0;
        }
        char v84 = *(uint64_t (**)(uint64_t))(v43 + 24);
        if (v84)
        {
          uint64_t v24 = v84(v41);
          goto LABEL_194;
        }
LABEL_198:
        uint64_t v11 = 4294954514;
        if (!v10) {
          return v11;
        }
        goto LABEL_196;
      }
      cf[0] = 0;
      v91[0] = 0;
      uint64_t v13 = FigXPCMessageCopyCFString(a2, "PropertyKey", cf);
      if (v13) {
        goto LABEL_173;
      }
      if (!cf[0])
      {
        uint64_t v13 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
        goto LABEL_173;
      }
      uint64_t v13 = FigXPCMessageCopyCFDictionary(a2, "Params", v91);
      if (v13)
      {
LABEL_173:
        uint64_t v11 = v13;
        goto LABEL_175;
      }
      CompletionCallbackParametersFromMessageAndConnection_0 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
      CFTypeRef v15 = cf[0];
      CFTypeRef v16 = v91[0];
      if (CompletionCallbackParametersFromMessageAndConnection_0) {
        id v17 = GetProxiedPropertyCompletionCallback;
      }
      else {
        id v17 = 0;
      }
      uint64_t v38 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
      if (v38) {
        uint64_t v39 = v38;
      }
      else {
        uint64_t v39 = 0;
      }
      uint64_t v80 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, void *, void *))(v39 + 88);
      if (!v80) {
        goto LABEL_174;
      }
LABEL_172:
      uint64_t v13 = v80(v10, v15, v16, v17, CompletionCallbackParametersFromMessageAndConnection_0);
      goto LABEL_173;
    }
    if (v87 != 1685024621)
    {
      if (v87 != 1735421033) {
        goto LABEL_195;
      }
      uint64_t v20 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
      if (v20) {
        uint64_t v21 = GetPlaybackInfoCompletionCallback;
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v27 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
      if (v27) {
        uint64_t v28 = v27;
      }
      else {
        uint64_t v28 = 0;
      }
      long long v73 = *(uint64_t (**)(CFTypeRef, void *, void *))(v28 + 56);
      if (!v73) {
        goto LABEL_198;
      }
      goto LABEL_122;
    }
    uint64_t v24 = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_194:
    uint64_t v11 = v24;
    goto LABEL_195;
  }
  if (v87 <= 1936028776)
  {
    if (v87 > 1919971688)
    {
      if (v87 != 1919971689)
      {
        if (v87 != 1936024673) {
          goto LABEL_195;
        }
        cf[0] = 0;
        v91[0] = 0;
        uint64_t v13 = FigXPCMessageCopyCFDate(a2, "Date", (CFDateRef *)cf);
        if (v13) {
          goto LABEL_173;
        }
        uint64_t v13 = FigXPCMessageCopyCFDictionary(a2, "Options", v91);
        if (v13) {
          goto LABEL_173;
        }
        CompletionCallbackParametersFromMessageAndConnection_0 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
        CFTypeRef v15 = cf[0];
        CFTypeRef v16 = v91[0];
        if (CompletionCallbackParametersFromMessageAndConnection_0) {
          id v17 = SeekCompletionCallback;
        }
        else {
          id v17 = 0;
        }
        uint64_t v36 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
        if (v36) {
          uint64_t v37 = v36;
        }
        else {
          uint64_t v37 = 0;
        }
        uint64_t v80 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, void *, void *))(v37 + 72);
        if (!v80) {
          goto LABEL_174;
        }
        goto LABEL_172;
      }
      cf[0] = 0;
      uint64_t v51 = FigXPCMessageCopyCFDictionary(a2, "Item", cf);
      if (v51) {
        goto LABEL_153;
      }
      unsigned int v58 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
      CFTypeRef v59 = cf[0];
      if (v58) {
        unsigned int v60 = StandardCompletionCallback;
      }
      else {
        unsigned int v60 = 0;
      }
      uint64_t v71 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
      if (v71) {
        uint64_t v72 = v71;
      }
      else {
        uint64_t v72 = 0;
      }
      unsigned __int16 v79 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void (*)(int, uint64_t), void *))(v72 + 40);
      if (!v79) {
        goto LABEL_154;
      }
    }
    else
    {
      if (v87 != 1886151033)
      {
        if (v87 != 1886545249) {
          goto LABEL_195;
        }
        cf[0] = 0;
        v91[0] = 0;
        uint64_t v13 = FigXPCMessageCopyCFString(a2, "Type", cf);
        if (v13) {
          goto LABEL_173;
        }
        uint64_t v13 = FigXPCMessageCopyCFObject(a2, "Params", (__CFDictionary **)v91);
        if (v13) {
          goto LABEL_173;
        }
        CompletionCallbackParametersFromMessageAndConnection_0 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
        CFTypeRef v15 = cf[0];
        CFTypeRef v16 = v91[0];
        if (CompletionCallbackParametersFromMessageAndConnection_0) {
          id v17 = RemoteActionCompletionCallback;
        }
        else {
          id v17 = 0;
        }
        uint64_t v25 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
        if (v25) {
          uint64_t v26 = v25;
        }
        else {
          uint64_t v26 = 0;
        }
        uint64_t v80 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, void *, void *))(v26 + 112);
        if (!v80) {
          goto LABEL_174;
        }
        goto LABEL_172;
      }
      uint64_t v57 = v86;
      cf[0] = 0;
      uint64_t v51 = FigXPCMessageCopyCFDictionary(a2, "Params", cf);
      if (v51) {
        goto LABEL_153;
      }
      uint64_t v51 = checkRequestAgainstSandboxRules(a1, v57, a2, (CFDictionaryRef)cf[0]);
      if (v51) {
        goto LABEL_153;
      }
      unsigned int v58 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
      CFTypeRef v59 = cf[0];
      if (v58) {
        unsigned int v60 = StandardCompletionCallback;
      }
      else {
        unsigned int v60 = 0;
      }
      uint64_t v61 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
      if (v61) {
        uint64_t v62 = v61;
      }
      else {
        uint64_t v62 = 0;
      }
      unsigned __int16 v79 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void (*)(int, uint64_t), void *))(v62 + 24);
      if (!v79) {
        goto LABEL_154;
      }
    }
    uint64_t v51 = v79(v10, v59, v60, v58);
    goto LABEL_153;
  }
  if (v87 <= 1936748657)
  {
    if (v87 != 1936028777)
    {
      if (v87 != 1936029288) {
        goto LABEL_195;
      }
      uint64_t v29 = v86;
      *(void *)(v29 + 8) = xpc_dictionary_get_uint64(a2, ".objectID");
      CFAllocatorRef v30 = *(void **)(v29 + 16);
      *(void *)(v29 + 16) = FigXPCRetain(a1);
      FigXPCRelease(v30);
      uint64_t v31 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
      if (v31) {
        uint64_t v32 = v31;
      }
      else {
        uint64_t v32 = 0;
      }
      uint64_t v74 = *(uint64_t (**)(CFTypeRef, void (*)(uint64_t, const void *, uint64_t), uint64_t, void))(v32 + 120);
      if (!v74) {
        goto LABEL_198;
      }
      uint64_t v24 = v74(v10, HandleEventCallback, v29, 0);
      goto LABEL_194;
    }
    v91[0] = 0;
    v91[1] = 0;
    uint64_t v92 = 0;
    CFPropertyListRef v90 = 0;
    uint64_t CMTime = FigXPCMessageGetCMTime(a2, "Time", (uint64_t)v91);
    if (!CMTime)
    {
      uint64_t CMTime = FigXPCMessageCopyCFDictionary(a2, "Options", &v90);
      if (!CMTime)
      {
        int v64 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
        int v65 = v90;
        if (v64) {
          size_t v66 = SeekCompletionCallback;
        }
        else {
          size_t v66 = 0;
        }
        long long v88 = *(_OWORD *)v91;
        uint64_t v89 = v92;
        uint64_t v67 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
        if (v67) {
          uint64_t v68 = v67;
        }
        else {
          uint64_t v68 = 0;
        }
        CFTypeID v82 = *(uint64_t (**)(CFTypeRef, CFTypeRef *, const void *, void (*)(const void *, int, uint64_t), void *))(v68 + 64);
        if (!v82)
        {
          uint64_t v11 = 4294954514;
LABEL_162:
          CFTypeRef v81 = v90;
          if (v90) {
            goto LABEL_178;
          }
          goto LABEL_195;
        }
        *(_OWORD *)CFTypeRef cf = v88;
        uint64_t v94 = v89;
        uint64_t CMTime = v82(v10, cf, v65, v66, v64);
      }
    }
    uint64_t v11 = CMTime;
    goto LABEL_162;
  }
  if (v87 != 1936748658)
  {
    if (v87 != 1936875892)
    {
      if (v87 != 1937010544) {
        goto LABEL_195;
      }
      uint64_t v20 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
      if (v20) {
        uint64_t v21 = StandardCompletionCallback;
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v22 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
      if (v22) {
        uint64_t v23 = v22;
      }
      else {
        uint64_t v23 = 0;
      }
      long long v73 = *(uint64_t (**)(CFTypeRef, void *, void *))(v23 + 48);
      if (!v73) {
        goto LABEL_198;
      }
LABEL_122:
      uint64_t v24 = v73(v10, v21, v20);
      goto LABEL_194;
    }
    cf[0] = 0;
    double v50 = xpc_dictionary_get_double(a2, "Rate");
    uint64_t v51 = FigXPCMessageCopyCFDictionary(a2, "Params", cf);
    if (v51) {
      goto LABEL_153;
    }
    BOOL v52 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
    CFTypeRef v53 = cf[0];
    if (v52) {
      uint64_t v54 = StandardCompletionCallback;
    }
    else {
      uint64_t v54 = 0;
    }
    uint64_t v55 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
    if (v55) {
      uint64_t v56 = v55;
    }
    else {
      uint64_t v56 = 0;
    }
    int v77 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void (*)(int, uint64_t), void *, float))(v56 + 80);
    if (v77)
    {
      float v78 = v50;
      uint64_t v51 = v77(v10, v53, v54, v52, v78);
LABEL_153:
      uint64_t v11 = v51;
      goto LABEL_155;
    }
LABEL_154:
    uint64_t v11 = 4294954514;
LABEL_155:
    CFTypeRef v81 = cf[0];
    if (cf[0]) {
      goto LABEL_178;
    }
    goto LABEL_195;
  }
  cf[0] = 0;
  v91[0] = 0;
  *(void *)&long long v88 = 0;
  uint64_t v44 = FigXPCMessageCopyCFString(a2, "PropertyKey", cf);
  if (v44) {
    goto LABEL_183;
  }
  if (!cf[0])
  {
    uint64_t v44 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
    goto LABEL_183;
  }
  uint64_t v44 = FigXPCMessageCopyCFDictionary(a2, "Params", v91);
  if (v44) {
    goto LABEL_183;
  }
  uint64_t v44 = FigXPCMessageCopyCFObject(a2, "PropertyValue", (__CFDictionary **)&v88);
  if (v44) {
    goto LABEL_183;
  }
  CFTypeRef v45 = cf[0];
  CFTypeRef v46 = v91[0];
  uint64_t v47 = v88;
  uint64_t v48 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
  if (v48) {
    uint64_t v49 = v48;
  }
  else {
    uint64_t v49 = 0;
  }
  CFTypeID v83 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, uint64_t))(v49 + 96);
  if (v83)
  {
    uint64_t v44 = v83(v10, v45, v46, v47);
LABEL_183:
    uint64_t v11 = v44;
    goto LABEL_185;
  }
  uint64_t v11 = 4294954514;
LABEL_185:
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  if (v91[0]) {
    CFRelease(v91[0]);
  }
  CFTypeRef v81 = (CFTypeRef)v88;
  if ((void)v88)
  {
LABEL_178:
    CFRelease(v81);
    if (!v10) {
      return v11;
    }
    goto LABEL_196;
  }
LABEL_195:
  if (v10) {
LABEL_196:
  }
    CFRelease(v10);
  return v11;
}

uint64_t FigXPCEndpointPlaybackSessionServerAssociateCopiedNeighborFigEndpointPlaybackSession(_xpc_connection_s *a1, const void *a2, void *a3)
{
  CFIndex v6 = malloc_type_calloc(1uLL, 0x20uLL, 0x10200404161829EuLL);
  uint64_t v7 = v6;
  if (v6)
  {
    *CFIndex v6 = a2;
    if (a2) {
      CFRetain(a2);
    }
    v7[3] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  }
  else
  {
    uint64_t v8 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if (v8) {
      goto LABEL_6;
    }
  }
  uint64_t v8 = FigXPCServerAssociateCopiedObjectWithNeighborProcess(gEndpointPlaybackSessionServer, a1, a2, (uint64_t)v7, (uint64_t)DisposeSessionEventHandlerState, 0, a3);
  if (v8) {
LABEL_6:
  }
    DisposeSessionEventHandlerState(v7);
  return v8;
}

void DisposeSessionEventHandlerState(void *a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)a1;
    if (*(void *)a1)
    {
      uint64_t v3 = *(void *)(CMBaseObjectGetVTable(*(void *)a1) + 16);
      uint64_t v4 = v3 ? v3 : 0;
      long long v5 = *(void (**)(uint64_t, void, void, void))(v4 + 120);
      if (v5) {
        v5(v2, 0, 0, 0);
      }
    }
    CFArrayRef v6 = (const __CFArray *)*((void *)a1 + 3);
    if (v6)
    {
      CFIndex Count = CFArrayGetCount(v6);
      if (Count >= 1)
      {
        CFIndex v8 = Count;
        for (CFIndex i = 0; i != v8; ++i)
        {
          uint64_t v12 = 0;
          FigCFArrayGetInt64AtIndex(*((const void **)a1 + 3), i, &v12);
          sandbox_extension_release();
        }
      }
      CFTypeRef v10 = (const void *)*((void *)a1 + 3);
      if (v10)
      {
        CFRelease(v10);
        *((void *)a1 + 3) = 0;
      }
    }
    uint64_t v11 = (void *)*((void *)a1 + 2);
    if (v11)
    {
      *((void *)a1 + 2) = 0;
      xpc_release(v11);
    }
    if (*(void *)a1) {
      CFRelease(*(CFTypeRef *)a1);
    }
    free(a1);
  }
}

void *CreateCompletionCallbackParametersFromMessageAndConnection_0(void *a1, void *a2)
{
  uint64_t int64 = xpc_dictionary_get_uint64(a1, "CompletionID");
  if (!uint64) {
    return 0;
  }
  uint64_t v5 = uint64;
  CFArrayRef v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    *CFArrayRef v6 = v5;
    v6[1] = xpc_dictionary_get_uint64(a1, ".objectID");
    v7[2] = FigXPCRetain(a2);
  }
  else
  {
    FigSignalErrorAt(4294950555, 0, 0, 0, 0, 0, 0);
  }
  return v7;
}

void AuthorizeItemCompletionCallback(const void *a1, const void *a2, int a3, uint64_t a4)
{
  xpc_object_t xdict = 0;
  if (a4 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a4 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a4);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a3);
    FigXPCMessageSetCFData(xdict, "PicData", a1);
    FigXPCMessageSetCFString(xdict, "PlayerGUID", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a4 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a4);
  FigXPCRelease(xdict);
}

uint64_t checkRequestAgainstSandboxRules(_xpc_connection_s *a1, uint64_t a2, void *a3, CFDictionaryRef theDict)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!CFDictionaryGetValue(theDict, @"path"))
  {
    xpc_connection_get_pid(a1);
    bzero(v11, 0x400uLL);
    if (!sandbox_container_path_for_pid())
    {
      uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, @"Content-Location");
      if (!result) {
        return result;
      }
      if (!FigXPCConnectionHasEntitlement((uint64_t)a1, (uint64_t)"com.apple.security.network.client")) {
        return FigSignalErrorAt(4294950550, 0, 0, 0, 0, 0, 0);
      }
    }
    return 0;
  }
  if (xpc_dictionary_get_string(a3, "SExtToken"))
  {
    uint64_t v8 = sandbox_extension_consume();
    if (v8 != -1)
    {
      CFNumberRef SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v8);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), SInt64);
      if (SInt64) {
        CFRelease(SInt64);
      }
      return 0;
    }
    return 4294950551;
  }
  else
  {
    return FigSignalErrorAt(4294950552, 0, 0, 0, 0, 0, 0);
  }
}

void StandardCompletionCallback(int a1, uint64_t a2)
{
  xpc_object_t xdict = 0;
  if (a2 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a2 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a2);
    FigXPCMessageSetOSStatus(xdict, "CompletionStatus", a1);
    xpc_connection_send_message(*(xpc_connection_t *)(a2 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a2);
  FigXPCRelease(xdict);
}

void GetPlaybackInfoCompletionCallback(const void *a1, int a2, uint64_t a3)
{
  xpc_object_t xdict = 0;
  if (a3 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a3 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a3);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a2);
    FigXPCMessageSetCFDictionary(xdict, "PlaybackInfo", a1);
    xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a3);
  FigXPCRelease(xdict);
}

void SeekCompletionCallback(const void *a1, int a2, uint64_t a3)
{
  xpc_object_t xdict = 0;
  if (a3 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a3 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a3);
    FigXPCMessageSetOSStatus(xdict, "CompletionStatus", a2);
    FigXPCMessageSetCFDictionary(xdict, "SeekResponseInfo", a1);
    xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a3);
  FigXPCRelease(xdict);
}

void GetProxiedPropertyCompletionCallback(const void *a1, const void *a2, int a3, uint64_t a4)
{
  xpc_object_t xdict = 0;
  if (a4 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a4 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a4);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a3);
    FigXPCMessageSetCFString(xdict, "PropertyKey", a1);
    FigXPCMessageSetCFObject(xdict, "PropertyValue", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a4 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a4);
  FigXPCRelease(xdict);
}

void RemoteActionCompletionCallback(int a1, const void *a2, uint64_t a3)
{
  xpc_object_t xdict = 0;
  if (a3 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a3 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a3);
    FigXPCMessageSetOSStatus(xdict, "ResponseStatus", a1);
    FigXPCMessageSetCFObject(xdict, "ResponseParams", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a3);
  FigXPCRelease(xdict);
}

void HandleEventCallback(uint64_t a1, const void *a2, uint64_t a3)
{
  xpc_object_t message = 0;
  if (a3)
  {
    int v5 = FigXPCCreateBasicMessage(0x65686362u, *(void *)(a3 + 8), &message);
    xpc_object_t v6 = message;
    if (!v5)
    {
      FigXPCMessageSetCFDictionary(message, "EventInfo", a2);
      xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), message);
      xpc_object_t v6 = message;
    }
  }
  else
  {
    xpc_object_t v6 = 0;
  }
  FigXPCRelease(v6);
}

uint64_t FigH264Bridge_GetNALUnitHeaderLengthFromAVCC(uint64_t a1, unint64_t a2, void *a3)
{
  if (a2 < 7) {
    return 4294954582;
  }
  uint64_t result = 0;
  *a3 = (*(unsigned char *)(a1 + 4) & 3) + 1;
  return result;
}

uint64_t FigH264Bridge_GetPPSFromAVCC(uint64_t a1, unint64_t a2, int a3, void *a4, void *a5)
{
  if (a2 >= 7)
  {
    int v5 = *(unsigned char *)(a1 + 5) & 0x1F;
    if ((*(unsigned char *)(a1 + 5) & 0x1F) != 0)
    {
      LODWORD(v6) = 6;
      while (1)
      {
        unint64_t v7 = (v6 + 2);
        if (v7 > a2) {
          break;
        }
        unsigned int v8 = *(unsigned __int16 *)(a1 + v6);
        unsigned int v9 = __rev16(v8);
        unint64_t v6 = v7 + (bswap32(v8) >> 16);
        if (v9 < 2 || v6 > a2) {
          break;
        }
        if (!--v5) {
          goto LABEL_12;
        }
      }
    }
    else
    {
      LODWORD(v6) = 6;
LABEL_12:
      unint64_t v11 = (v6 + 1);
      if (v11 <= a2)
      {
        int v12 = *(unsigned __int8 *)(a1 + v6);
        if (!v12) {
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        }
        while ((int)v11 + 2 <= a2)
        {
          uint64_t v13 = *(unsigned __int8 *)(a1 + (int)v11 + 1) | (*(unsigned __int8 *)(a1 + v11) << 8);
          if (v13 < 2 || (int)v13 + (int)v11 + 2 > a2) {
            break;
          }
          if (!a3)
          {
            uint64_t v16 = 0;
            *a4 = a1 + v11 + 2;
            *a5 = v13;
            return v16;
          }
          --a3;
          LODWORD(v11) = v13 + v11 + 2;
          if (!--v12) {
            return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
          }
        }
      }
    }
  }
  return 4294954582;
}

uint64_t FigH264Bridge_GetSPSSequenceID(const UInt8 *a1, unint64_t a2, _DWORD *a3)
{
  long long v28 = 0u;
  long long v29 = 0u;
  CFDataRef theData = 0;
  uint64_t v3 = 4294954584;
  if (!a1) {
    return v3;
  }
  int Length = a2;
  if (a2 < 6) {
    return v3;
  }
  BytePtr = a1;
  if ((*a1 & 0x1F) != 7) {
    return v3;
  }
  uint64_t v7 = RemoveEmulation3Byte(a1, a2, &theData);
  CFDataRef v8 = theData;
  if (v7)
  {
LABEL_32:
    uint64_t v3 = v7;
    if (!v8) {
      return v3;
    }
    goto LABEL_29;
  }
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    int Length = CFDataGetLength(v8);
  }
  unsigned int v9 = (unsigned int *)(BytePtr + 4);
  *(void *)&long long v28 = BytePtr + 4;
  DWORD2(v28) = Length - 4;
  *(void *)&long long v29 = BytePtr + 4;
  if ((Length - 4) < 4)
  {
    if (Length == 4)
    {
      unsigned int v10 = 0;
    }
    else
    {
      DWORD2(v29) = 0;
      __memcpy_chk();
      unsigned int v10 = DWORD2(v29);
    }
  }
  else
  {
    unsigned int v10 = *v9;
  }
  unsigned int v11 = bswap32(v10);
  DWORD2(v29) = v11;
  BYTE12(v29) = 0;
  if (!(v11 >> 19)) {
    goto LABEL_31;
  }
  unsigned int v12 = __clz(v11);
  unsigned int v13 = v12 + 1;
  unsigned int v14 = v11 << (v12 + 1) >> -(char)v12;
  if (!v12) {
    unsigned int v14 = 0;
  }
  char v15 = v13 + v12;
  uint64_t v16 = (char *)v9 + ((v13 + v12) >> 3);
  int v17 = BytePtr + Length - v16;
  if (v17 <= 3)
  {
    int v18 = v15 & 7;
    if (v17 <= 0) {
      uint64_t v19 = v16;
    }
    else {
      uint64_t v19 = v16 + 1;
    }
    int v20 = v17 - (v17 > 0);
    if (v20 > 0) {
      ++v19;
    }
    int v21 = v20 - (v20 > 0);
    BOOL v22 = v21 <= 0;
    int v23 = v21 & (v21 >> 31);
    uint64_t v24 = v22 ? v19 : v19 + 1;
    if (v23 | v18 && v24 == v16)
    {
LABEL_31:
      uint64_t v7 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_32;
    }
  }
  uint64_t v3 = 0;
  *a3 = v14 + ~(-1 << v12);
  if (v8) {
LABEL_29:
  }
    CFRelease(v8);
  return v3;
}

uint64_t FigH264Bridge_GetSPSWidthAndHeight(const UInt8 *a1, unint64_t a2, void *a3, void *a4)
{
  unsigned int Length = a2;
  BytePtr = a1;
  memset(v18, 0, 512);
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  CFDataRef theData = 0;
  uint64_t v8 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v8) {
    return v8;
  }
  CFDataRef v9 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unsigned int Length = CFDataGetLength(v9);
  }
  unsigned int v14 = BytePtr;
  LODWORD(v15) = Length;
  uint64_t v16 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v17) = 0;
      __memcpy_chk();
      unsigned int v10 = v17;
    }
    else
    {
      unsigned int v10 = 0;
    }
  }
  else
  {
    unsigned int v10 = *(_DWORD *)BytePtr;
  }
  LODWORD(v17) = bswap32(v10);
  BYTE4(v17) = 0;
  uint64_t v11 = PullParamSetSPS((uint64_t)&v14, (char *)v18);
  if (v9) {
    CFRelease(v9);
  }
  if (!v11) {
    FigH264Bridge_GetWidthAndHeightFromParsedSPS((uint64_t)v18, a3, a4);
  }
  return v11;
}

uint64_t FigH264Bridge_GetWidthAndHeightFromParsedSPS(uint64_t result, void *a2, void *a3)
{
  *a2 = 16 * *(_DWORD *)(result + 324) + 16;
  uint64_t v3 = 2 - *(int *)(result + 332);
  *a3 = 16 * ((int)v3 + (int)v3 * *(_DWORD *)(result + 328));
  if (*(_DWORD *)(result + 344))
  {
    unint64_t v4 = *(char *)(result + 40);
    if (v4 > 3)
    {
      uint64_t v5 = -2;
      uint64_t v6 = -2;
    }
    else
    {
      uint64_t v5 = qword_18FE96538[v4];
      uint64_t v6 = qword_18FE96558[v4];
    }
    uint64_t v7 = *(int *)(result + 360) + (uint64_t)*(int *)(result + 356);
    *a2 += v5 * (*(int *)(result + 352) + (uint64_t)*(int *)(result + 348));
    *a3 += v6 * v3 * v7;
  }
  return result;
}

uint64_t FigH264Bridge_GetSPSIsInterlaced(const UInt8 *a1, unint64_t a2, BOOL *a3)
{
  unsigned int Length = a2;
  BytePtr = a1;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  memset(v16, 0, sizeof(v16));
  uint64_t v13 = 0;
  unsigned int v14 = 0;
  uint64_t v15 = 0;
  CFDataRef theData = 0;
  uint64_t v6 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v6) {
    return v6;
  }
  CFDataRef v7 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unsigned int Length = CFDataGetLength(v7);
  }
  unsigned int v12 = BytePtr;
  LODWORD(v13) = Length;
  unsigned int v14 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v15) = 0;
      __memcpy_chk();
      unsigned int v8 = v15;
    }
    else
    {
      unsigned int v8 = 0;
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)BytePtr;
  }
  LODWORD(v15) = bswap32(v8);
  BYTE4(v15) = 0;
  uint64_t v9 = PullParamSetSPS((uint64_t)&v12, (char *)v16);
  if (v7) {
    CFRelease(v7);
  }
  if (!v9) {
    *a3 = HIDWORD(v17) == 0;
  }
  return v9;
}

uint64_t FigH264Bridge_GetSPSChromaFormatAndBitDepths(const UInt8 *a1, unint64_t a2, unsigned char *a3, unsigned char *a4, unsigned char *a5)
{
  unsigned int Length = a2;
  BytePtr = a1;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  memset(v20, 0, sizeof(v20));
  uint64_t v17 = 0;
  long long v18 = 0;
  uint64_t v19 = 0;
  CFDataRef theData = 0;
  uint64_t v10 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v10) {
    return v10;
  }
  CFDataRef v11 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unsigned int Length = CFDataGetLength(v11);
  }
  uint64_t v16 = BytePtr;
  LODWORD(v17) = Length;
  long long v18 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v19) = 0;
      __memcpy_chk();
      unsigned int v12 = v19;
    }
    else
    {
      unsigned int v12 = 0;
    }
  }
  else
  {
    unsigned int v12 = *(_DWORD *)BytePtr;
  }
  LODWORD(v19) = bswap32(v12);
  BYTE4(v19) = 0;
  uint64_t v13 = PullParamSetSPS((uint64_t)&v16, (char *)v20);
  if (v11) {
    CFRelease(v11);
  }
  if (!v13)
  {
    if (a3) {
      *a3 = BYTE8(v21);
    }
    if (a4) {
      *a4 = BYTE10(v21) + 8;
    }
    uint64_t v13 = 0;
    if (a5) {
      *a5 = BYTE11(v21) + 8;
    }
  }
  return v13;
}

uint64_t FigH264Bridge_GetSPS_VUI_Framerate(const UInt8 *a1, unint64_t a2, float *a3, BOOL *a4, unsigned char *a5, BOOL *a6, _DWORD *a7)
{
  unsigned int Length = a2;
  BytePtr = a1;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  memset(v26, 0, sizeof(v26));
  uint64_t v23 = 0;
  long long v24 = 0;
  uint64_t v25 = 0;
  CFDataRef theData = 0;
  uint64_t v14 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v14) {
    return v14;
  }
  CFDataRef v15 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unsigned int Length = CFDataGetLength(v15);
  }
  long long v22 = BytePtr;
  LODWORD(v23) = Length;
  long long v24 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v25) = 0;
      __memcpy_chk();
      unsigned int v16 = v25;
    }
    else
    {
      unsigned int v16 = 0;
    }
  }
  else
  {
    unsigned int v16 = *(_DWORD *)BytePtr;
  }
  LODWORD(v25) = bswap32(v16);
  BYTE4(v25) = 0;
  uint64_t v17 = PullParamSetSPS((uint64_t)&v22, (char *)v26);
  if (v15) {
    CFRelease(v15);
  }
  if (!v17)
  {
    if (v36)
    {
      float v18 = (float)SDWORD2(v36) / (float)SDWORD1(v36);
      if (DWORD1(v27) != 2 || HIDWORD(v29) != 0) {
        float v18 = v18 * 0.5;
      }
      *a3 = v18;
      *a4 = HIDWORD(v36) != 0;
      *a5 = BYTE12(v37);
      *a6 = (void)v37 != 0;
      *a7 = 0;
      uint64_t v17 = 0;
      if (*a6) {
        *a7 = v41 + v42 + 2;
      }
    }
    else
    {
      return 4294954584;
    }
  }
  return v17;
}

uint64_t FigH264Bridge_GetSPSAndPPSCountFromAVCC(const void *a1, void *a2, void *a3)
{
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 == CFDataGetTypeID())
    {
      CFIndex Length = CFDataGetLength((CFDataRef)a1);
      BytePtr = CFDataGetBytePtr((CFDataRef)a1);
      if (Length > 5 && *BytePtr == 1)
      {
        char v9 = 0;
        char v10 = 1;
        uint64_t v11 = 5;
        while (Length > v11)
        {
          char v12 = v10;
          uint64_t v13 = v11 + 1;
          unsigned int v14 = BytePtr[v11];
          if (v10) {
            uint64_t v15 = v14 & 0x1F;
          }
          else {
            uint64_t v15 = v14;
          }
          if (v15)
          {
            int v16 = v15;
            uint64_t v11 = v13;
            while (Length > v11 + 1)
            {
              v11 += (BytePtr[v11 + 1] | ((unint64_t)BytePtr[v11] << 8)) + 2;
              if (Length < v11) {
                break;
              }
              if (!--v16) {
                goto LABEL_17;
              }
            }
            break;
          }
          uint64_t v11 = v13;
LABEL_17:
          if (a2 == 0 || (v12 & 1) == 0)
          {
            if (a3 != 0 && (v9 & 1) != 0)
            {
              *a3 = v15;
              return 0;
            }
          }
          else
          {
            *a2 = v15;
          }
          char v10 = 0;
          char v9 = 1;
          if ((v12 & 1) == 0) {
            return 0;
          }
        }
      }
    }
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t FigH264Bridge_GetH264ParameterSetAtIndex(const void *a1, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t a5, _DWORD *a6)
{
  return FigH264Bridge_GetAndVisitH264ParameterSetAtIndex(a1, a2, a3, a4, a5, a6, 0, 0);
}

uint64_t FigH264Bridge_GetAndVisitH264ParameterSetAtIndex(CFTypeRef cf, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t a5, _DWORD *a6, unint64_t a7, uint64_t a8)
{
  if (a3) {
    *(void *)a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *(void *)a5 = 0;
  }
  if (a6) {
    *a6 = 0;
  }
  if (cf)
  {
    CFTypeID v14 = CFGetTypeID(cf);
    if (v14 == CFDataGetTypeID())
    {
      CFIndex Length = CFDataGetLength((CFDataRef)cf);
      BytePtr = CFDataGetBytePtr((CFDataRef)cf);
      if (Length >= 6)
      {
        uint64_t v17 = BytePtr;
        if (*BytePtr == 1)
        {
          int v18 = BytePtr[1];
          if (a6)
          {
            *a6 = (BytePtr[4] & 3) + 1;
            if (!a5 && !a3 && !a4 && !a7) {
              return 0;
            }
          }
          int v19 = 0;
          unint64_t v20 = 0;
          LODWORD(v21) = 0;
          uint64_t v22 = 5;
          unsigned int v31 = v18 - 100;
          uint64_t v30 = (1 << (v18 - 100)) & 0x100000400401;
          do
          {
            unint64_t v33 = v20;
            if (v19 == 2)
            {
              if (v31 > 0x2C) {
                break;
              }
              if (!v30 || Length == v22) {
                break;
              }
              v22 += 3;
            }
            if (Length <= v22) {
              goto LABEL_49;
            }
            CFIndex v24 = v22 + 1;
            LODWORD(v22) = v17[v22];
            if (v19) {
              uint64_t v22 = v22;
            }
            else {
              v22 &= 0x1Fu;
            }
            if (v22)
            {
              uint64_t v21 = (int)v21;
              uint64_t v32 = v22;
              int v25 = v22;
              while (Length > v24 + 1)
              {
                unint64_t v26 = v17[v24 + 1] | ((unint64_t)v17[v24] << 8);
                CFIndex v27 = v24 + 2;
                v24 += v26 + 2;
                if (Length < v24) {
                  break;
                }
                if (a2 == v21)
                {
                  if (a3) {
                    *(void *)a3 = &v17[v27];
                  }
                  if (a4) {
                    *a4 = v26;
                  }
                  if (!(a5 | a7)) {
                    return 0;
                  }
                }
                if (a7) {
                  ((void (*)(uint64_t, uint64_t, const UInt8 *))a7)(a8, v21, &v17[v27]);
                }
                ++v21;
                if (!--v25)
                {
                  uint64_t v22 = v32;
                  goto LABEL_44;
                }
              }
              goto LABEL_49;
            }
LABEL_44:
            unint64_t v20 = v33 + v22;
            ++v19;
            uint64_t v22 = v24;
          }
          while (v19 != 3);
          if (a5) {
            *(void *)a5 = v20;
          }
          if (!(a3 | (unint64_t)a4) || v20 > a2) {
            return 0;
          }
        }
      }
    }
  }
LABEL_49:

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t FigH264Bridge_VisitAllH264ParameterSets(const void *a1, unint64_t a2, _DWORD *a3, unint64_t a4, uint64_t a5)
{
  return FigH264Bridge_GetAndVisitH264ParameterSetAtIndex(a1, 0, 0, 0, a2, a3, a4, a5);
}

uint64_t FigH264Bridge_CreateAVCCFromH264ParameterSets(int a1, size_t count, uint64_t a3, uint64_t a4, unsigned int a5, void *a6, void *a7, __CFData **a8)
{
  char v11 = a5;
  uint64_t v12 = a4;
  uint64_t v185 = *MEMORY[0x1E4F143B8];
  long long v151 = 0u;
  long long v152 = 0u;
  CFDataRef theData = 0;
  if (a6) {
    *a6 = 0;
  }
  if (a7) {
    *a7 = 0;
  }
  if (!a3 || !a4 || count <= 1 || a5 > 4 || ((1 << a5) & 0x16) == 0 || !a8)
  {
    uint64_t v127 = 4294954584;
LABEL_195:
    uint64_t v125 = FigSignalErrorAt(v127, 0, 0, 0, 0, 0, 0);
    unsigned int v120 = 0;
    goto LABEL_199;
  }
  *a8 = 0;
  uint64_t v13 = malloc_type_calloc(count, 0x10uLL, 0x1000040451B5BE8uLL);
  if (!v13)
  {
    uint64_t v127 = 4294954583;
    goto LABEL_195;
  }
  unsigned int v130 = a6;
  size_t v132 = a8;
  size_t v133 = a7;
  char v131 = v11;
  uint64_t v14 = 0;
  unint64_t v142 = 0;
  unint64_t v143 = 0;
  unint64_t v144 = 0;
  unint64_t v145 = 0;
  uint64_t v139 = 0;
  uint64_t v140 = 0;
  __base = v13;
  uint64_t v15 = v13 + 2;
  UInt8 v141 = -1;
  CFIndex v16 = 7;
  int v137 = -1;
  int v138 = -1;
  int v135 = 1;
  int v136 = -1;
  size_t v17 = count;
  do
  {
    unint64_t v18 = *(void *)(v12 + 8 * v14);
    if (v18 >= 0x10000) {
      goto LABEL_193;
    }
    if (!v18) {
      goto LABEL_193;
    }
    int v19 = *(char **)(a3 + 8 * v14);
    if (!v19) {
      goto LABEL_193;
    }
    int v20 = *v19;
    if (v20 < 0 || (v20 & 0x60) == 0) {
      goto LABEL_193;
    }
    unsigned int v21 = v20 & 0x1F;
    int v22 = (1 << (v20 & 0x1F)) & 0x2180;
    if (v21 > 0xD || v22 == 0) {
      goto LABEL_193;
    }
    *((void *)v15 - 1) = v14;
    v15[1] = v21;
    *(void *)&long long v151 = v19;
    unint64_t v24 = *(void *)(v12 + 8 * v14);
    DWORD2(v151) = v24;
    if (v21 == 7)
    {
      *(void *)&long long v152 = v19 + 4;
      if (v24 < 8uLL)
      {
        if (v24 >= 5uLL)
        {
          DWORD2(v152) = 0;
          __memcpy_chk();
          size_t v17 = count;
        }
      }
      else
      {
        DWORD2(v152) = *((_DWORD *)v19 + 1);
      }
      uint64_t v25 = 4;
    }
    else
    {
      *(void *)&long long v152 = v19 + 1;
      if (v24 < 5uLL)
      {
        if (v24 >= 2uLL)
        {
          DWORD2(v152) = 0;
          __memcpy_chk();
          size_t v17 = count;
        }
      }
      else
      {
        DWORD2(v152) = *(_DWORD *)(v19 + 1);
      }
      uint64_t v25 = 1;
    }
    unsigned int v26 = bswap32(DWORD2(v152));
    DWORD2(v152) = v26;
    BYTE12(v152) = 0;
    if (!(v26 >> 19)) {
      goto LABEL_196;
    }
    CFIndex v27 = &v19[v25];
    unsigned int v28 = __clz(v26);
    unsigned int v29 = v28 + 1;
    unsigned int v30 = v26 << (v28 + 1) >> -(char)v28;
    if (!v28) {
      unsigned int v30 = 0;
    }
    *uint64_t v15 = v30 + ~(-1 << v28);
    char v31 = v29 + v28;
    uint64_t v32 = &v27[(v29 + v28) >> 3];
    int v33 = v19 + v24 - v32;
    if (v33 <= 3)
    {
      int v34 = v31 & 7;
      if (v33 <= 0) {
        long long v35 = v32;
      }
      else {
        long long v35 = v32 + 1;
      }
      int v36 = v33 - (v33 > 0);
      if (v36 > 0) {
        ++v35;
      }
      int v37 = v36 - (v36 > 0);
      BOOL v38 = v37 <= 0;
      int v39 = v37 & (v37 >> 31);
      long long v40 = v38 ? v35 : v35 + 1;
      if (v39 | v34 && v40 == v32) {
        goto LABEL_196;
      }
    }
    if (v21 == 13)
    {
      ++v145;
      goto LABEL_166;
    }
    if (v21 == 8)
    {
      ++v144;
      goto LABEL_166;
    }
    if (v21 != 7) {
      goto LABEL_166;
    }
    uint64_t v148 = 0;
    uint64_t v149 = 0;
    long long v183 = 0u;
    long long v184 = 0u;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    long long v177 = 0u;
    long long v178 = 0u;
    long long v175 = 0u;
    long long v176 = 0u;
    long long v173 = 0u;
    long long v174 = 0u;
    long long v171 = 0u;
    long long v172 = 0u;
    long long v169 = 0u;
    long long v170 = 0u;
    long long v167 = 0u;
    long long v168 = 0u;
    long long v165 = 0u;
    long long v166 = 0u;
    long long v163 = 0u;
    long long v164 = 0u;
    long long v161 = 0u;
    long long v162 = 0u;
    long long v159 = 0u;
    long long v160 = 0u;
    long long v158 = 0u;
    long long v156 = 0u;
    long long v157 = 0u;
    long long v154 = 0u;
    long long v155 = 0u;
    *(_OWORD *)bytes = 0u;
    uint64_t v42 = RemoveEmulation3Byte((const UInt8 *)v19, v24, &theData);
    if (v42) {
      goto LABEL_198;
    }
    CFDataRef v43 = theData;
    if (theData)
    {
      *(void *)&long long v151 = CFDataGetBytePtr(theData);
      unsigned int Length = CFDataGetLength(v43);
      long long v45 = (_DWORD *)v151;
    }
    else
    {
      long long v45 = *(_DWORD **)(a3 + 8 * v14);
      *(void *)&long long v151 = v45;
      unsigned int Length = *(_DWORD *)(v12 + 8 * v14);
    }
    DWORD2(v151) = Length;
    *(void *)&long long v152 = v45;
    if (Length < 4uLL)
    {
      if (Length)
      {
        DWORD2(v152) = 0;
        __memcpy_chk();
      }
    }
    else
    {
      DWORD2(v152) = *v45;
    }
    DWORD2(v152) = bswap32(DWORD2(v152));
    BYTE12(v152) = 0;
    if (PullParamSetSPS((uint64_t)&v151, (char *)bytes))
    {
      uint64_t v46 = 0;
      uint64_t v47 = 0;
      uint64_t v148 = 0;
      uint64_t v149 = 0;
    }
    else
    {
      FigH264Bridge_GetWidthAndHeightFromParsedSPS((uint64_t)bytes, &v149, &v148);
      uint64_t v46 = v148;
      uint64_t v47 = v149;
    }
    if (v139 && v139 != v47 || v140 && v140 != v46) {
      int v135 = 0;
    }
    long long v48 = (unsigned __int8 *)v151;
    *(void *)&long long v152 = v151;
    int v49 = DWORD2(v151);
    if (DWORD2(v151) < 4)
    {
      if (DWORD2(v151))
      {
        DWORD2(v152) = 0;
        uint64_t v50 = v47;
        uint64_t v51 = v12;
        CFDataRef v52 = v43;
        uint64_t v53 = v46;
        __memcpy_chk();
        uint64_t v46 = v53;
        CFDataRef v43 = v52;
        uint64_t v12 = v51;
        uint64_t v47 = v50;
      }
    }
    else
    {
      DWORD2(v152) = *(_DWORD *)v151;
    }
    DWORD2(v152) = bswap32(DWORD2(v152));
    BYTE12(v152) = 0;
    if (v49 - 1 < 4) {
      goto LABEL_196;
    }
    uint64_t v54 = (unsigned int *)(v48 + 4);
    if ((v49 - 6) > 0xFFFFFFFB)
    {
      unsigned __int8 v55 = v48[2];
      int v56 = v48[3];
      unsigned int v58 = v48[4] << 24;
      goto LABEL_83;
    }
    unsigned __int8 v55 = v48[2];
    if ((v49 - 7) > 0xFFFFFFFB)
    {
      int v56 = v48[3];
      int v57 = (v48[4] << 16) | (v48[5] << 8);
      goto LABEL_81;
    }
    int v56 = v48[3];
    if ((v49 & 0xFFFFFFFC) == 4)
    {
      int v57 = (v48[4] << 16) | (v48[5] << 8) | v48[6];
LABEL_81:
      unsigned int v58 = v57 << 8;
      goto LABEL_83;
    }
    unsigned int v58 = bswap32(*v54);
LABEL_83:
    if (v58 < 0x80000) {
      goto LABEL_196;
    }
    int v59 = v48 + v49;
    int v60 = v48[1];
    unsigned int v61 = __clz(v58);
    uint64_t v62 = (unsigned __int8 *)v54 + (v61 >> 2);
    int v63 = v48 + v49 - v62;
    if (v63 < 4)
    {
      if (v63 < 1) {
        goto LABEL_196;
      }
      int v65 = *v62;
      if (v63 == 1)
      {
        unsigned int v64 = v65 << 24;
      }
      else
      {
        int v66 = (v65 << 16) | (v62[1] << 8);
        if (v63 != 2) {
          v66 |= v62[2];
        }
        unsigned int v64 = v66 << 8;
      }
    }
    else
    {
      unsigned int v64 = bswap32(*(_DWORD *)v62);
    }
    if (v60 <= SHIDWORD(v143)) {
      unsigned int v67 = HIDWORD(v143);
    }
    else {
      unsigned int v67 = v48[1];
    }
    unsigned int v68 = v143;
    if (v56 > (int)v143) {
      unsigned int v68 = v56;
    }
    unint64_t v143 = __PAIR64__(v67, v68);
    if ((v60 - 100) <= 0x2C && ((1 << (v60 - 100)) & 0x100000400401) != 0)
    {
      int v69 = (2 * (v61 & 3)) | 1;
      unsigned int v70 = v64 << ((2 * (v61 & 3)) | 1);
      if (v70 < 0x80000) {
        goto LABEL_196;
      }
      unsigned int v71 = __clz(v70);
      unsigned int v72 = v70 << (v71 + 1) >> -(char)v71;
      if (v71) {
        unsigned int v73 = v72;
      }
      else {
        unsigned int v73 = 0;
      }
      unsigned int v74 = v71 + v69 + v71 + 1;
      uint64_t v75 = v74 >> 3;
      int v76 = v74 & 7;
      int v77 = &v62[v75];
      int v78 = v59 - v77;
      if (v59 - (int)v77 < 4)
      {
        if (v78 < 1)
        {
          int v79 = v76 | v78;
          if (v79) {
            goto LABEL_196;
          }
        }
        else
        {
          int v80 = *v77;
          if (v78 == 1)
          {
            int v79 = v80 << 24;
          }
          else
          {
            int v81 = (v80 << 16) | (v77[1] << 8);
            if (v78 != 2) {
              v81 |= v77[2];
            }
            int v79 = v81 << 8;
          }
        }
      }
      else
      {
        int v79 = bswap32(*(_DWORD *)v77);
      }
      int v82 = v73 + ~(-1 << v71);
      if (v82 == 3)
      {
        unsigned int v83 = v76 + 1;
        uint64_t v84 = v83 >> 3;
        int v76 = v83 & 7;
        v77 += v84;
        int v85 = v59 - v77;
        if (v59 - (int)v77 < 4)
        {
          if (v85 < 1)
          {
            int v86 = v76 | v85;
            if (v86) {
              goto LABEL_196;
            }
          }
          else
          {
            int v88 = *v77;
            if (v85 == 1)
            {
              int v86 = v88 << 24;
            }
            else
            {
              int v89 = (v88 << 16) | (v77[1] << 8);
              if (v85 != 2) {
                v89 |= v77[2];
              }
              int v86 = v89 << 8;
            }
          }
        }
        else
        {
          int v86 = bswap32(*(_DWORD *)v77);
        }
        unsigned int v87 = v86 << v76;
      }
      else
      {
        unsigned int v87 = v79 << v76;
      }
      if (v87 < 0x80000) {
        goto LABEL_196;
      }
      unsigned int v90 = __clz(v87);
      unsigned int v91 = v87 << (v90 + 1) >> -(char)v90;
      if (!v90) {
        unsigned int v91 = 0;
      }
      unsigned int v92 = v90 + v76 + v90 + 1;
      uint64_t v93 = v92 >> 3;
      int v94 = v92 & 7;
      int v95 = &v77[v93];
      int v96 = v59 - v95;
      if (v59 - (int)v95 < 4)
      {
        if (v96 < 1)
        {
          int v97 = v94 | v96;
          if (v97) {
            goto LABEL_196;
          }
        }
        else
        {
          int v98 = *v95;
          if (v96 == 1)
          {
            int v97 = v98 << 24;
          }
          else
          {
            int v99 = (v98 << 16) | (v95[1] << 8);
            if (v96 != 2) {
              v99 |= v95[2];
            }
            int v97 = v99 << 8;
          }
        }
      }
      else
      {
        int v97 = bswap32(*(_DWORD *)v95);
      }
      unsigned int v100 = v97 << v94;
      if ((v97 << v94) < 0x80000) {
        goto LABEL_196;
      }
      unsigned int v101 = __clz(v100);
      unsigned int v102 = v100 << (v101 + 1) >> -(char)v101;
      if (!v101) {
        unsigned int v102 = 0;
      }
      unsigned int v103 = v101 + v94 + v101 + 1;
      CFRange v104 = &v95[v103 >> 3];
      int v105 = v59 - v104;
      if (v105 <= 3)
      {
        int v106 = v103 & 7;
        if (v105 <= 0) {
          CFNumberRef v107 = v104;
        }
        else {
          CFNumberRef v107 = v104 + 1;
        }
        int v108 = v105 - (v105 > 0);
        if (v108 > 0) {
          ++v107;
        }
        int v109 = v108 - (v108 > 0);
        int v110 = v109 & (v109 >> 31);
        size_t v111 = v109 <= 0 ? v107 : v107 + 1;
        if (v110 | v106 && v111 == v104)
        {
LABEL_196:
          uint64_t v126 = 4294954582;
          goto LABEL_197;
        }
      }
      int v112 = v138;
      if (v138 == -1)
      {
        int v112 = v82;
      }
      else if (v138 != v82)
      {
        goto LABEL_193;
      }
      int v138 = v112;
      int v113 = v137;
      if (v137 == -1)
      {
        int v113 = v91 + ~(-1 << v90);
        int v114 = v136;
      }
      else
      {
        int v114 = v136;
        if (v137 != v91 + ~(-1 << v90)) {
          goto LABEL_193;
        }
      }
      int v137 = v113;
      if (v114 == -1)
      {
        int v136 = v102 + ~(-1 << v101);
        if (!v43) {
          goto LABEL_165;
        }
LABEL_164:
        CFDataRef v115 = v43;
        uint64_t v116 = v47;
        uint64_t v117 = v46;
        CFRelease(v115);
        uint64_t v46 = v117;
        uint64_t v47 = v116;
        CFDataRef theData = 0;
        goto LABEL_165;
      }
      if (v114 != v102 + ~(-1 << v101)) {
        goto LABEL_193;
      }
    }
    if (v43) {
      goto LABEL_164;
    }
LABEL_165:
    ++v142;
    v141 &= v55;
    uint64_t v139 = v47;
    uint64_t v140 = v46;
    size_t v17 = count;
LABEL_166:
    v16 += v18 + 2;
    ++v14;
    v15 += 4;
  }
  while (v17 != v14);
  unint64_t v118 = v145;
  unint64_t v119 = v142;
  if (v135)
  {
    if (v130) {
      *unsigned int v130 = v139;
    }
    if (v133) {
      void *v133 = v140;
    }
  }
  if (!v142)
  {
LABEL_193:
    uint64_t v126 = 4294954584;
LABEL_197:
    uint64_t v42 = FigSignalErrorAt(v126, 0, 0, 0, 0, 0, 0);
LABEL_198:
    uint64_t v125 = v42;
    unsigned int v120 = __base;
    goto LABEL_199;
  }
  unsigned int v120 = __base;
  if (!v144) {
    goto LABEL_203;
  }
  unsigned int v121 = HIDWORD(v143) - 100;
  if ((HIDWORD(v143) - 100) > 0x2C || ((1 << v121) & 0x100000400401) == 0)
  {
    unint64_t v119 = v142 + v145;
    unint64_t v118 = 0;
  }
  if (v119 >= 0x20 || v144 >= 0x100 || v118 >= 0x100)
  {
LABEL_203:
    uint64_t v129 = 4294954584;
LABEL_204:
    uint64_t v125 = FigSignalErrorAt(v129, 0, 0, 0, 0, 0, 0);
    goto LABEL_199;
  }
  qsort(__base, v17, 0x10uLL, (int (__cdecl *)(const void *, const void *))FigH264Bridge_sortParameterSets);
  if (v121 <= 0x2C && ((1 << v121) & 0x100000400401) != 0) {
    v16 += 4;
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v16);
  if (!Mutable)
  {
    uint64_t v129 = 4294954583;
    goto LABEL_204;
  }
  unsigned int v123 = Mutable;
  bytes[0] = 1;
  bytes[1] = BYTE4(v143);
  bytes[2] = v141;
  bytes[3] = v143;
  UInt8 bytes[4] = (v131 - 1) | 0xFC;
  bytes[5] = v119 | 0xE0;
  CFDataAppendBytes(Mutable, bytes, 6);
  if (v118) {
    int v124 = 0;
  }
  else {
    int v124 = 13;
  }
  FigH264Bridge_addSortedParameterSetsToData(v123, count, (uint64_t *)__base, a3, v12, 7, v124);
  bytes[0] = v144;
  CFDataAppendBytes(v123, bytes, 1);
  FigH264Bridge_addSortedParameterSetsToData(v123, count, (uint64_t *)__base, a3, v12, 8, 0);
  if (v121 <= 0x2C && ((1 << v121) & 0x100000400401) != 0)
  {
    bytes[0] = v138 | 0xFC;
    bytes[1] = v137 | 0xF8;
    bytes[2] = v136 | 0xF8;
    bytes[3] = v118;
    CFDataAppendBytes(v123, bytes, 4);
    FigH264Bridge_addSortedParameterSetsToData(v123, count, (uint64_t *)__base, a3, v12, 13, 0);
  }
  uint64_t v125 = 0;
  *size_t v132 = v123;
LABEL_199:
  if (theData) {
    CFRelease(theData);
  }
  free(v120);
  return v125;
}

uint64_t FigH264Bridge_sortParameterSets(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 12);
  unsigned int v6 = *(_DWORD *)(a2 + 12);
  BOOL v7 = v5 >= v6;
  BOOL v8 = v5 > v6;
  if (v7) {
    return v8;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void FigH264Bridge_addSortedParameterSetsToData(CFMutableDataRef theData, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  if (a2)
  {
    uint64_t v12 = a2;
    do
    {
      int v14 = *((_DWORD *)a3 + 3);
      if (v14 == a6 || v14 == a7)
      {
        uint64_t v16 = *a3;
        *(_WORD *)bytes = bswap32(*(unsigned __int16 *)(a5 + 8 * *a3)) >> 16;
        CFDataAppendBytes(theData, bytes, 2);
        CFDataAppendBytes(theData, *(const UInt8 **)(a4 + 8 * v16), *(void *)(a5 + 8 * v16));
      }
      a3 += 2;
      --v12;
    }
    while (v12);
  }
}

uint64_t FigH264Bridge_CreateAVCCFromSPSAndPPS(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, __CFData **a7)
{
  int v9[2] = *MEMORY[0x1E4F143B8];
  v9[0] = a2;
  v9[1] = a4;
  v8[0] = a3;
  v8[1] = a5;
  return FigH264Bridge_CreateAVCCFromH264ParameterSets(a1, 2uLL, (uint64_t)v9, (uint64_t)v8, a6, 0, 0, a7);
}

uint64_t FigH264Bridge_GetSPS_VUI_FullRangeVideo(const UInt8 *a1, unint64_t a2, unsigned char *a3)
{
  unsigned int Length = a2;
  BytePtr = a1;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  memset(v16, 0, sizeof(v16));
  uint64_t v13 = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  CFDataRef theData = 0;
  uint64_t v6 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v6) {
    return v6;
  }
  CFDataRef v7 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unsigned int Length = CFDataGetLength(v7);
  }
  uint64_t v12 = BytePtr;
  LODWORD(v13) = Length;
  int v14 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v15) = 0;
      __memcpy_chk();
      unsigned int v8 = v15;
    }
    else
    {
      unsigned int v8 = 0;
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)BytePtr;
  }
  LODWORD(v15) = bswap32(v8);
  BYTE4(v15) = 0;
  uint64_t v9 = PullParamSetSPS((uint64_t)&v12, (char *)v16);
  if (v7) {
    CFRelease(v7);
  }
  if (!v9)
  {
    if (HIDWORD(v17))
    {
      uint64_t v9 = 0;
      *a3 = v20;
    }
    else
    {
      return 4294954584;
    }
  }
  return v9;
}

uint64_t FigH264Bridge_GetPPSSequenceID(const UInt8 *a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  long long v40 = 0u;
  long long v41 = 0u;
  CFDataRef theData = 0;
  if (!a1) {
    return 4294954584;
  }
  BytePtr = a1;
  if ((*a1 & 0x1F) != 8) {
    return 4294954584;
  }
  int Length = a2;
  uint64_t v8 = RemoveEmulation3Byte(a1, a2, &theData);
  CFDataRef v9 = theData;
  if (v8) {
    goto LABEL_44;
  }
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    int Length = CFDataGetLength(v9);
  }
  char v10 = (unsigned int *)(BytePtr + 1);
  *(void *)&long long v40 = BytePtr + 1;
  DWORD2(v40) = Length - 1;
  *(void *)&long long v41 = BytePtr + 1;
  if ((Length - 1) < 4)
  {
    if (Length == 1)
    {
      unsigned int v11 = 0;
    }
    else
    {
      DWORD2(v41) = 0;
      __memcpy_chk();
      unsigned int v11 = DWORD2(v41);
    }
  }
  else
  {
    unsigned int v11 = *v10;
  }
  unsigned int v12 = bswap32(v11);
  DWORD2(v41) = v12;
  BYTE12(v41) = 0;
  if (!(v12 >> 19)) {
    goto LABEL_43;
  }
  int v13 = BytePtr + Length;
  unsigned int v14 = __clz(v12);
  unsigned int v15 = v12 << (v14 + 1) >> -(char)v14;
  if (!v14) {
    unsigned int v15 = 0;
  }
  unsigned int v16 = v14 + 1 + v14;
  int v17 = v16 & 7;
  long long v18 = (unsigned __int8 *)v10 + (v16 >> 3);
  int v19 = v13 - v18;
  if (v13 - (int)v18 >= 4)
  {
    int v20 = bswap32(*(_DWORD *)v18);
    goto LABEL_24;
  }
  if (v19 < 1)
  {
    int v20 = v17 | v19;
    if (!v20) {
      goto LABEL_24;
    }
LABEL_43:
    uint64_t v8 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_44:
    uint64_t v37 = v8;
    if (!v9) {
      return v37;
    }
    goto LABEL_41;
  }
  int v21 = *v18;
  if (v19 == 1)
  {
    int v20 = v21 << 24;
  }
  else
  {
    int v22 = (v21 << 16) | (v18[1] << 8);
    if (v19 != 2) {
      v22 |= v18[2];
    }
    int v20 = v22 << 8;
  }
LABEL_24:
  unsigned int v23 = v20 << v17;
  if (!((v20 << v17) >> 19)) {
    goto LABEL_43;
  }
  unsigned int v24 = __clz(v23);
  unsigned int v25 = v23 << (v24 + 1) >> -(char)v24;
  if (!v24) {
    unsigned int v25 = 0;
  }
  unsigned int v26 = v24 + v17 + v24 + 1;
  CFIndex v27 = &v18[v26 >> 3];
  int v28 = v13 - v27;
  if (v28 <= 3)
  {
    int v29 = v26 & 7;
    if (v28 <= 0) {
      unsigned int v30 = v27;
    }
    else {
      unsigned int v30 = v27 + 1;
    }
    int v31 = v28 - (v28 > 0);
    if (v31 > 0) {
      ++v30;
    }
    int v32 = v31 - (v31 > 0);
    BOOL v33 = v32 <= 0;
    int v34 = v32 & (v32 >> 31);
    long long v35 = v33 ? v30 : v30 + 1;
    if (v34 | v29 && v35 == v27) {
      goto LABEL_43;
    }
  }
  uint64_t v37 = 0;
  *a3 = v25 + ~(-1 << v24);
  *a4 = v15 + ~(-1 << v14);
  if (v9) {
LABEL_41:
  }
    CFRelease(v9);
  return v37;
}

uint64_t FigH264Bridge_CopyStandaloneSPSData(const UInt8 *a1, unint64_t a2, CFDataRef *a3)
{
  unsigned int Length = a2;
  BytePtr = a1;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  memset(v18, 0, sizeof(v18));
  uint64_t v15 = 0;
  unsigned int v16 = 0;
  uint64_t v17 = 0;
  CFDataRef theData = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  uint64_t v6 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v6) {
    return v6;
  }
  CFDataRef v7 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unsigned int Length = CFDataGetLength(v7);
  }
  unsigned int v14 = BytePtr;
  LODWORD(v15) = Length;
  unsigned int v16 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v17) = 0;
      __memcpy_chk();
      unsigned int v8 = v17;
    }
    else
    {
      unsigned int v8 = 0;
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)BytePtr;
  }
  LODWORD(v17) = bswap32(v8);
  BYTE4(v17) = 0;
  uint64_t v9 = PullParamSetSPS((uint64_t)&v14, (char *)v18);
  if (v7) {
    CFRelease(v7);
  }
  if (!v9)
  {
    long long v11 = v19;
    LODWORD(v12) = DWORD2(v20);
    *(void *)((char *)&v12 + 4) = *(void *)((char *)&v21 + 4);
    HIDWORD(v12) = HIDWORD(v21);
    *a3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)&v11, 32);
  }
  return v9;
}

uint64_t FigH264Bridge_CopyStandalonePPSData(const UInt8 *BytePtr, unint64_t a2, CFDataRef *a3)
{
  long long v28 = 0u;
  memset(v29, 0, 24);
  memset(v27, 0, sizeof(v27));
  uint64_t v24 = 0;
  long long v25 = 0;
  uint64_t v26 = 0;
  long long v22 = 0;
  bzero(&v11, 0x414uLL);
  uint64_t v6 = RemoveEmulation3Byte(BytePtr, a2, &v22);
  if (v6) {
    return v6;
  }
  CFDataRef v7 = v22;
  if (v22)
  {
    BytePtr = CFDataGetBytePtr(v22);
    LODWORD(a2) = CFDataGetLength(v7);
  }
  long long v23 = BytePtr;
  LODWORD(v24) = a2;
  long long v25 = BytePtr;
  if (a2 < 4)
  {
    if (a2)
    {
      LODWORD(v26) = 0;
      __memcpy_chk();
      unsigned int v8 = v26;
    }
    else
    {
      unsigned int v8 = 0;
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)BytePtr;
  }
  LODWORD(v26) = bswap32(v8);
  BYTE4(v26) = 0;
  uint64_t v9 = PullParamSetPPS((uint64_t *)&v23, (uint64_t)v27);
  if (v7) {
    CFRelease(v7);
  }
  if (!v9)
  {
    int32x2_t v11 = vrev64_s32(*(int32x2_t *)&v27[0]);
    int v12 = BYTE8(v27[0]);
    int v13 = BYTE9(v27[0]);
    uint64_t v14 = *(void *)((char *)v27 + 12);
    uint64_t v15 = *((void *)&v28 + 1);
    int v16 = LOBYTE(v29[0]);
    long long v17 = *(_OWORD *)((char *)v29 + 4);
    int v18 = BYTE4(v29[1]);
    int v19 = BYTE5(v29[1]);
    int v20 = BYTE6(v29[1]);
    char v21 = 1;
    *a3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)&v11, 1044);
  }
  return v9;
}

uint64_t PullParamSetPPS(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  int v5 = *((_DWORD *)a1 + 6);
  uint64_t v6 = *((unsigned __int8 *)a1 + 28);
  int v7 = *((_DWORD *)a1 + 2);
  uint64_t v8 = *a1;
  *(void *)(a2 + 80) = 0;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  unint64_t v9 = v6 + 1;
  int v10 = (v6 + 1) & 7;
  int32x2_t v11 = (unsigned __int8 *)(v4 + (v9 >> 3));
  int v12 = v8 + v7;
  int v13 = v8 + v7 - v11;
  if (v13 < 4)
  {
    if (v13 < 1)
    {
      unsigned int v16 = 0;
      if (v10 | v13)
      {
        LOBYTE(v21) = v10;
        goto LABEL_242;
      }
      unsigned int v14 = 0;
    }
    else
    {
      int v15 = *v11;
      if (v13 == 1)
      {
        unsigned int v14 = v15 << 24;
      }
      else
      {
        int v17 = (v15 << 16) | (v11[1] << 8);
        if (v13 != 2) {
          v17 |= v11[2];
        }
        unsigned int v14 = v17 << 8;
      }
    }
  }
  else
  {
    unsigned int v14 = bswap32(*(_DWORD *)v11);
  }
  int v18 = (v10 + 2) & 7;
  v11 += (v10 + 2) >> 3;
  int v19 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v19 < 1)
    {
      unsigned int v16 = 0;
      if (v18 | v19)
      {
        LOBYTE(v21) = (v10 + 2) & 7;
        goto LABEL_242;
      }
    }
    else
    {
      int v20 = *v11;
      if (v19 == 1)
      {
        unsigned int v16 = v20 << 24;
      }
      else
      {
        int v22 = (v20 << 16) | (v11[1] << 8);
        if (v19 != 2) {
          v22 |= v11[2];
        }
        unsigned int v16 = v22 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  int v21 = (v18 + 5) & 7;
  v11 += (v18 + 5) >> 3;
  int v23 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v23 < 1)
    {
      unsigned int v24 = 0;
      if (v21 | v23)
      {
        unsigned int v16 = 0;
        goto LABEL_242;
      }
      if (v5 < 0) {
        goto LABEL_385;
      }
    }
    else
    {
      int v25 = *v11;
      if (v23 == 1)
      {
        unsigned int v24 = v25 << 24;
        if (v5 < 0) {
          goto LABEL_385;
        }
      }
      else
      {
        int v32 = (v25 << 16) | (v11[1] << 8);
        if (v23 != 2) {
          v32 |= v11[2];
        }
        unsigned int v24 = v32 << 8;
        if (v5 < 0) {
          goto LABEL_385;
        }
      }
    }
  }
  else
  {
    unsigned int v24 = bswap32(*(_DWORD *)v11);
    if (v5 < 0) {
      goto LABEL_385;
    }
  }
  if (!(v14 << v10 >> 30) || v16 << v18 >> 27 != 8) {
    goto LABEL_385;
  }
  unsigned int v16 = v24 << v21;
  if (v24 << v21 < 0x80000) {
    goto LABEL_242;
  }
  unsigned int v26 = __clz(v16);
  unsigned int v27 = v16 << (v26 + 1) >> -(char)v26;
  if (!v26) {
    unsigned int v27 = 0;
  }
  unsigned int v28 = v27 + ~(-1 << v26);
  *(_DWORD *)a2 = v28;
  unsigned int v29 = v26 + v21 + v26 + 1;
  int v21 = v29 & 7;
  v11 += v29 >> 3;
  int v30 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v30 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v30) {
        goto LABEL_242;
      }
    }
    else
    {
      int v31 = *v11;
      if (v30 == 1)
      {
        unsigned int v16 = v31 << 24;
      }
      else
      {
        int v33 = (v31 << 16) | (v11[1] << 8);
        if (v30 != 2) {
          v33 |= v11[2];
        }
        unsigned int v16 = v33 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  if (v28 >= 0x100) {
    goto LABEL_385;
  }
  v16 <<= v21;
  if (v16 < 0x80000) {
    goto LABEL_242;
  }
  unsigned int v34 = __clz(v16);
  unsigned int v35 = v16 << (v34 + 1) >> -(char)v34;
  if (!v34) {
    unsigned int v35 = 0;
  }
  unsigned int v36 = v35 + ~(-1 << v34);
  *(_DWORD *)(a2 + 4) = v36;
  unsigned int v37 = v34 + v21 + v34 + 1;
  int v21 = v37 & 7;
  v11 += v37 >> 3;
  int v38 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v38 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v38) {
        goto LABEL_242;
      }
    }
    else
    {
      int v39 = *v11;
      if (v38 == 1)
      {
        unsigned int v16 = v39 << 24;
      }
      else
      {
        int v40 = (v39 << 16) | (v11[1] << 8);
        if (v38 != 2) {
          v40 |= v11[2];
        }
        unsigned int v16 = v40 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  if (v36 >= 0x20)
  {
LABEL_385:
    uint64_t v123 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    return v123;
  }
  *(unsigned char *)(a2 + 8) = ((v16 << v21) & 0x80000000) != 0;
  uint64_t v41 = (v21 + 1) >> 3;
  int v21 = (v21 + 1) & 7;
  v11 += v41;
  int v42 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v42 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v42) {
        goto LABEL_242;
      }
    }
    else
    {
      int v43 = *v11;
      if (v42 == 1)
      {
        unsigned int v16 = v43 << 24;
      }
      else
      {
        int v44 = (v43 << 16) | (v11[1] << 8);
        if (v42 != 2) {
          v44 |= v11[2];
        }
        unsigned int v16 = v44 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  *(unsigned char *)(a2 + 9) = ((v16 << v21) & 0x80000000) != 0;
  uint64_t v45 = (v21 + 1) >> 3;
  int v21 = (v21 + 1) & 7;
  v11 += v45;
  int v46 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v46 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v46) {
        goto LABEL_242;
      }
    }
    else
    {
      int v47 = *v11;
      if (v46 == 1)
      {
        unsigned int v16 = v47 << 24;
      }
      else
      {
        int v48 = (v47 << 16) | (v11[1] << 8);
        if (v46 != 2) {
          v48 |= v11[2];
        }
        unsigned int v16 = v48 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  unsigned int v49 = v16 << v21;
  if (v16 << v21 >= 0x80000)
  {
    unsigned int v50 = __clz(v49);
    unsigned int v51 = v49 << (v50 + 1) >> -(char)v50;
    if (!v50) {
      unsigned int v51 = 0;
    }
    unsigned int v52 = v51 + ~(-1 << v50);
    *(_DWORD *)(a2 + 12) = v52;
    unsigned int v53 = v50 + v21 + v50 + 1;
    int v21 = v53 & 7;
    v11 += v53 >> 3;
    int v54 = v12 - v11;
    if (v12 - (int)v11 < 4)
    {
      if (v54 < 1)
      {
        unsigned int v16 = 0;
        if (v21 | v54) {
          goto LABEL_242;
        }
      }
      else
      {
        int v57 = *v11;
        if (v54 == 1)
        {
          unsigned int v16 = v57 << 24;
        }
        else
        {
          int v59 = (v57 << 16) | (v11[1] << 8);
          if (v54 != 2) {
            v59 |= v11[2];
          }
          unsigned int v16 = v59 << 8;
        }
      }
    }
    else
    {
      unsigned int v16 = bswap32(*(_DWORD *)v11);
    }
    v16 <<= v21;
    if (!v52) {
      goto LABEL_261;
    }
LABEL_157:
    if (v16 < 0x80000) {
      goto LABEL_242;
    }
    unsigned int v87 = __clz(v16);
    unsigned int v88 = v16 << (v87 + 1) >> -(char)v87;
    if (!v87) {
      unsigned int v88 = 0;
    }
    unsigned int v89 = v88 + ~(-1 << v87);
    *(_DWORD *)(a2 + 16) = v89;
    unsigned int v90 = v87 + v21 + v87 + 1;
    int v21 = v90 & 7;
    v11 += v90 >> 3;
    int v91 = v12 - v11;
    if (v12 - (int)v11 < 4)
    {
      if (v91 < 1)
      {
        unsigned int v16 = 0;
        if (v21 | v91) {
          goto LABEL_242;
        }
      }
      else
      {
        int v92 = *v11;
        if (v91 == 1)
        {
          unsigned int v16 = v92 << 24;
        }
        else
        {
          int v93 = (v92 << 16) | (v11[1] << 8);
          if (v91 != 2) {
            v93 |= v11[2];
          }
          unsigned int v16 = v93 << 8;
        }
      }
    }
    else
    {
      unsigned int v16 = bswap32(*(_DWORD *)v11);
    }
    v16 <<= v21;
    switch(v89)
    {
      case 0u:
        while (v16 >= 0x80000)
        {
          unsigned int v96 = v21 + 2 * __clz(v16) + 1;
          int v21 = v96 & 7;
          v11 += v96 >> 3;
          int v97 = v12 - v11;
          if (v12 - (int)v11 < 4)
          {
            if (v97 < 1)
            {
              unsigned int v16 = 0;
              if (v21 | v97) {
                goto LABEL_242;
              }
            }
            else
            {
              int v98 = *v11;
              if (v97 == 1)
              {
                unsigned int v16 = v98 << 24;
              }
              else
              {
                int v99 = (v98 << 16) | (v11[1] << 8);
                if (v97 != 2) {
                  v99 |= v11[2];
                }
                unsigned int v16 = v99 << 8;
              }
            }
          }
          else
          {
            unsigned int v16 = bswap32(*(_DWORD *)v11);
          }
          v16 <<= v21;
          if (++v89 > v52) {
            goto LABEL_261;
          }
        }
        goto LABEL_242;
      case 2u:
        int v101 = 0;
        while (v16 >= 0x80000)
        {
          unsigned int v102 = v21 + 2 * __clz(v16) + 1;
          int v21 = v102 & 7;
          v11 += v102 >> 3;
          int v103 = v12 - v11;
          if (v12 - (int)v11 < 4)
          {
            if (v103 < 1)
            {
              unsigned int v16 = 0;
              if (v21 | v103) {
                goto LABEL_242;
              }
            }
            else
            {
              int v104 = *v11;
              if (v103 == 1)
              {
                unsigned int v16 = v104 << 24;
              }
              else
              {
                int v105 = (v104 << 16) | (v11[1] << 8);
                if (v103 != 2) {
                  v105 |= v11[2];
                }
                unsigned int v16 = v105 << 8;
              }
            }
          }
          else
          {
            unsigned int v16 = bswap32(*(_DWORD *)v11);
          }
          v16 <<= v21;
          if (v16 < 0x80000) {
            break;
          }
          unsigned int v106 = v21 + 2 * __clz(v16) + 1;
          int v21 = v106 & 7;
          v11 += v106 >> 3;
          int v107 = v12 - v11;
          if (v12 - (int)v11 < 4)
          {
            if (v107 < 1)
            {
              unsigned int v16 = 0;
              if (v21 | v107) {
                goto LABEL_242;
              }
            }
            else
            {
              int v108 = *v11;
              if (v107 == 1)
              {
                unsigned int v16 = v108 << 24;
              }
              else
              {
                int v109 = (v108 << 16) | (v11[1] << 8);
                if (v107 != 2) {
                  v109 |= v11[2];
                }
                unsigned int v16 = v109 << 8;
              }
            }
          }
          else
          {
            unsigned int v16 = bswap32(*(_DWORD *)v11);
          }
          v16 <<= v21;
          if (++v101 > v52) {
            goto LABEL_261;
          }
        }
        goto LABEL_242;
      case 3u:
      case 4u:
      case 5u:
        uint64_t v94 = (v21 + 1) >> 3;
        int v21 = (v21 + 1) & 7;
        v11 += v94;
        int v95 = v12 - v11;
        if (v12 - (int)v11 < 4)
        {
          if (v95 < 1)
          {
            unsigned int v16 = 0;
            if (v21 | v95) {
              goto LABEL_242;
            }
          }
          else
          {
            int v100 = *v11;
            if (v95 == 1)
            {
              unsigned int v16 = v100 << 24;
            }
            else
            {
              int v118 = (v100 << 16) | (v11[1] << 8);
              if (v95 != 2) {
                v118 |= v11[2];
              }
              unsigned int v16 = v118 << 8;
            }
          }
        }
        else
        {
          unsigned int v16 = bswap32(*(_DWORD *)v11);
        }
        v16 <<= v21;
        if (v16 < 0x80000) {
          goto LABEL_242;
        }
        unsigned int v119 = v21 + 2 * __clz(v16) + 1;
        int v21 = v119 & 7;
        v11 += v119 >> 3;
        int v120 = v12 - v11;
        if (v12 - (int)v11 < 4)
        {
          if (v120 < 1)
          {
            unsigned int v16 = 0;
            if (v21 | v120) {
              goto LABEL_242;
            }
          }
          else
          {
            int v121 = *v11;
            if (v120 == 1)
            {
              unsigned int v16 = v121 << 24;
            }
            else
            {
              int v122 = (v121 << 16) | (v11[1] << 8);
              if (v120 != 2) {
                v122 |= v11[2];
              }
              unsigned int v16 = v122 << 8;
            }
          }
        }
        else
        {
          unsigned int v16 = bswap32(*(_DWORD *)v11);
        }
        v16 <<= v21;
        goto LABEL_261;
      case 6u:
        double v110 = log2((double)(v52 + 1));
        if (v16 < 0x80000) {
          goto LABEL_242;
        }
        unsigned int v111 = __clz(v16);
        if (v111) {
          unsigned int v112 = v16 << (v111 + 1) >> -(char)v111;
        }
        else {
          unsigned int v112 = 0;
        }
        unsigned int v113 = v111 + v21 + v111 + 1;
        int v114 = v113 & 7;
        CFDataRef v115 = &v11[v113 >> 3];
        int v116 = v12 - v115;
        if (v12 - (int)v115 < 4)
        {
          if (v116 < 1)
          {
            unsigned int v16 = 0;
            if (v114 | v116)
            {
LABEL_241:
              LOBYTE(v21) = v114;
              int32x2_t v11 = v115;
              goto LABEL_242;
            }
          }
          else
          {
            int v117 = *v115;
            if (v116 == 1)
            {
              unsigned int v16 = v117 << 24;
            }
            else
            {
              int v124 = (v117 << 16) | (v115[1] << 8);
              if (v116 != 2) {
                v124 |= v115[2];
              }
              unsigned int v16 = v124 << 8;
            }
          }
        }
        else
        {
          unsigned int v16 = bswap32(*(_DWORD *)v115);
        }
        unsigned int v125 = 0;
        unsigned int v126 = vcvtpd_s64_f64(v110);
        unsigned int v127 = v112 + ~(-1 << v111);
        v16 <<= v114;
        int32x2_t v11 = v115;
        int v21 = v114;
        break;
      default:
        goto LABEL_261;
    }
    do
    {
      if (v126 - 26 < 0xFFFFFFE7) {
        goto LABEL_241;
      }
      unsigned int v128 = v21 + v126;
      int v21 = (v21 + v126) & 7;
      v11 += v128 >> 3;
      int v129 = v12 - v11;
      if (v12 - (int)v11 < 4)
      {
        if (v129 < 1)
        {
          unsigned int v130 = 0;
          if (v21 | v129)
          {
            unsigned int v16 = 0;
            goto LABEL_242;
          }
        }
        else
        {
          int v131 = *v11;
          if (v129 == 1)
          {
            unsigned int v130 = v131 << 24;
          }
          else
          {
            int v132 = (v131 << 16) | (v11[1] << 8);
            if (v129 != 2) {
              v132 |= v11[2];
            }
            unsigned int v130 = v132 << 8;
          }
        }
      }
      else
      {
        unsigned int v130 = bswap32(*(_DWORD *)v11);
      }
      ++v125;
    }
    while (v125 <= v127);
    unsigned int v16 = v130 << v21;
    goto LABEL_261;
  }
  uint64_t v55 = (v21 + 1) >> 3;
  int v21 = (v21 + 1) & 7;
  v11 += v55;
  int v56 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v56 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v56) {
        goto LABEL_242;
      }
    }
    else
    {
      int v58 = *v11;
      if (v56 == 1)
      {
        unsigned int v16 = v58 << 24;
      }
      else
      {
        int v60 = (v58 << 16) | (v11[1] << 8);
        if (v56 != 2) {
          v60 |= v11[2];
        }
        unsigned int v16 = v60 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  unsigned int v61 = 0;
  v16 <<= v21;
  do
  {
    char v62 = v21;
    unsigned int v63 = v16;
    uint64_t v64 = (v21 + 1) >> 3;
    int v21 = (v21 + 1) & 7;
    v11 += v64;
    int v65 = v12 - v11;
    if (v12 - (int)v11 < 4)
    {
      if (v65 < 1)
      {
        unsigned int v16 = 0;
        if (v21 | v65) {
          goto LABEL_242;
        }
      }
      else
      {
        int v66 = *v11;
        if (v65 == 1)
        {
          unsigned int v16 = v66 << 24;
        }
        else
        {
          int v67 = (v66 << 16) | (v11[1] << 8);
          if (v65 != 2) {
            v67 |= v11[2];
          }
          unsigned int v16 = v67 << 8;
        }
      }
    }
    else
    {
      unsigned int v16 = bswap32(*(_DWORD *)v11);
    }
    v16 <<= v21;
    --v61;
  }
  while ((v63 & 0x80000000) == 0);
  if (v61 < 0xFFFFFFE1) {
    goto LABEL_242;
  }
  int v68 = -v61;
  int v69 = (v62 + 1) & 7;
  unsigned int v70 = v69 - v61;
  if (-v61 <= 0x18)
  {
    uint64_t v71 = v70 >> 3;
    int v21 = v70 & 7;
    unsigned int v72 = &v11[v71];
    int v73 = v12 - (v11 + v71);
    if (v73 >= 4)
    {
      unsigned int v74 = bswap32(*(_DWORD *)v72);
      goto LABEL_140;
    }
    if (v73 >= 1)
    {
      int v77 = *v72;
      if (v73 == 1)
      {
        unsigned int v74 = v77 << 24;
      }
      else
      {
        int v79 = (v77 << 16) | (v72[1] << 8);
        if (v73 != 2) {
          v79 |= v72[2];
        }
        unsigned int v74 = v79 << 8;
      }
      goto LABEL_140;
    }
    unsigned int v74 = 0;
    if (!(v21 | v73))
    {
LABEL_140:
      int v80 = v16 >> v61;
      unsigned int v16 = v74 << v21;
      goto LABEL_156;
    }
    unsigned int v16 = 0;
LABEL_151:
    int32x2_t v11 = v72;
    goto LABEL_242;
  }
  int v21 = v70 & 7;
  v11 += (~v61 + v69 - 15) >> 3;
  int v75 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v75 < 1)
    {
      unsigned int v76 = 0;
      if (v21 | v75)
      {
        unsigned int v16 = 0;
        goto LABEL_242;
      }
    }
    else
    {
      int v78 = *v11;
      if (v75 == 1)
      {
        unsigned int v76 = v78 << 24;
      }
      else
      {
        int v81 = (v78 << 16) | (v11[1] << 8);
        if (v75 != 2) {
          v81 |= v11[2];
        }
        unsigned int v76 = v81 << 8;
      }
    }
  }
  else
  {
    unsigned int v76 = bswap32(*(_DWORD *)v11);
  }
  unsigned int v72 = v11 + 2;
  int v82 = v12 - (v11 + 2);
  if (v82 < 4)
  {
    if (v82 < 1)
    {
      unsigned int v83 = 0;
      if (v21 | v82)
      {
        unsigned int v16 = 0;
        goto LABEL_151;
      }
    }
    else
    {
      int v84 = *v72;
      if (v82 == 1)
      {
        unsigned int v83 = v84 << 24;
      }
      else
      {
        int v85 = (v84 << 16) | (v11[3] << 8);
        if (v82 != 2) {
          v85 |= v11[4];
        }
        unsigned int v83 = v85 << 8;
      }
    }
  }
  else
  {
    unsigned int v83 = bswap32(*(_DWORD *)v72);
  }
  unsigned int v86 = v16 >> (v61 + 48);
  unsigned int v16 = v83 << v21;
  int v80 = __PAIR64__(v86, v76 << v21) >> 16;
LABEL_156:
  unsigned int v52 = v80 + ~(-1 << v68);
  *(_DWORD *)(a2 + 12) = v52;
  int32x2_t v11 = v72;
  if (v52) {
    goto LABEL_157;
  }
LABEL_261:
  if (v16 < 0x80000) {
    goto LABEL_242;
  }
  unsigned int v133 = __clz(v16);
  unsigned int v134 = v16 << (v133 + 1) >> -(char)v133;
  if (!v133) {
    unsigned int v134 = 0;
  }
  unsigned int v135 = v134 + ~(-1 << v133);
  *(_DWORD *)(a2 + 56) = v135;
  unsigned int v136 = v133 + v21 + v133 + 1;
  int v21 = v136 & 7;
  v11 += v136 >> 3;
  int v137 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v137 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v137) {
        goto LABEL_242;
      }
    }
    else
    {
      int v138 = *v11;
      if (v137 == 1)
      {
        unsigned int v16 = v138 << 24;
      }
      else
      {
        int v139 = (v138 << 16) | (v11[1] << 8);
        if (v137 != 2) {
          v139 |= v11[2];
        }
        unsigned int v16 = v139 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  if (v135 >= 0x20) {
    goto LABEL_385;
  }
  v16 <<= v21;
  if (v16 < 0x80000) {
    goto LABEL_242;
  }
  unsigned int v140 = __clz(v16);
  unsigned int v141 = v16 << (v140 + 1) >> -(char)v140;
  if (!v140) {
    unsigned int v141 = 0;
  }
  unsigned int v142 = v141 + ~(-1 << v140);
  *(_DWORD *)(a2 + 60) = v142;
  unsigned int v143 = v140 + v21 + v140 + 1;
  int v21 = v143 & 7;
  v11 += v143 >> 3;
  int v144 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v144 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v144) {
        goto LABEL_242;
      }
    }
    else
    {
      int v145 = *v11;
      if (v144 == 1)
      {
        unsigned int v16 = v145 << 24;
      }
      else
      {
        int v146 = (v145 << 16) | (v11[1] << 8);
        if (v144 != 2) {
          v146 |= v11[2];
        }
        unsigned int v16 = v146 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  if (v142 >= 0x20) {
    goto LABEL_385;
  }
  *(unsigned char *)(a2 + 64) = ((v16 << v21) & 0x80000000) != 0;
  uint64_t v147 = (v21 + 1) >> 3;
  int v21 = (v21 + 1) & 7;
  v11 += v147;
  int v148 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v148 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v148) {
        goto LABEL_242;
      }
    }
    else
    {
      int v149 = *v11;
      if (v148 == 1)
      {
        unsigned int v16 = v149 << 24;
      }
      else
      {
        int v150 = (v149 << 16) | (v11[1] << 8);
        if (v148 != 2) {
          v150 |= v11[2];
        }
        unsigned int v16 = v150 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  unsigned int v151 = v16 << v21 >> 30;
  *(_DWORD *)(a2 + 68) = v151;
  uint64_t v152 = (v21 + 2) >> 3;
  int v21 = (v21 + 2) & 7;
  v11 += v152;
  int v153 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v153 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v153) {
        goto LABEL_242;
      }
    }
    else
    {
      int v154 = *v11;
      if (v153 == 1)
      {
        unsigned int v16 = v154 << 24;
      }
      else
      {
        int v155 = (v154 << 16) | (v11[1] << 8);
        if (v153 != 2) {
          v155 |= v11[2];
        }
        unsigned int v16 = v155 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  if (v151 == 3) {
    goto LABEL_385;
  }
  v16 <<= v21;
  if (v16 < 0x80000) {
    goto LABEL_242;
  }
  unsigned int v156 = __clz(v16);
  unsigned int v157 = v16 << (v156 + 1) >> -(char)v156;
  if (!v156) {
    unsigned int v157 = 0;
  }
  unsigned int v158 = v156 + v21 + v156 + 1;
  int v21 = v158 & 7;
  v11 += v158 >> 3;
  int v159 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v159 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v159) {
        goto LABEL_242;
      }
    }
    else
    {
      int v160 = *v11;
      if (v159 == 1)
      {
        unsigned int v16 = v160 << 24;
      }
      else
      {
        int v161 = (v160 << 16) | (v11[1] << 8);
        if (v159 != 2) {
          v161 |= v11[2];
        }
        unsigned int v16 = v161 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  unsigned int v162 = ((v157 + (1 << v156)) >> 1) - ((v157 + (1 << v156)) >> 1) * 2 * ((v157 + (1 << v156)) & 1);
  *(_DWORD *)(a2 + 72) = v162;
  if (v162 + 62 >= 0x58) {
    goto LABEL_385;
  }
  v16 <<= v21;
  if (v16 < 0x80000) {
    goto LABEL_242;
  }
  unsigned int v163 = __clz(v16);
  unsigned int v164 = v16 << (v163 + 1) >> -(char)v163;
  if (!v163) {
    unsigned int v164 = 0;
  }
  unsigned int v165 = v163 + v21 + v163 + 1;
  int v21 = v165 & 7;
  v11 += v165 >> 3;
  int v166 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v166 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v166) {
        goto LABEL_242;
      }
    }
    else
    {
      int v167 = *v11;
      if (v166 == 1)
      {
        unsigned int v16 = v167 << 24;
      }
      else
      {
        int v168 = (v167 << 16) | (v11[1] << 8);
        if (v166 != 2) {
          v168 |= v11[2];
        }
        unsigned int v16 = v168 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  unsigned int v169 = ((v164 + (1 << v163)) >> 1) - ((v164 + (1 << v163)) >> 1) * 2 * ((v164 + (1 << v163)) & 1);
  *(_DWORD *)(a2 + 76) = v169;
  if (v169 + 26 >= 0x34) {
    goto LABEL_385;
  }
  v16 <<= v21;
  if (v16 < 0x80000) {
    goto LABEL_242;
  }
  unsigned int v170 = __clz(v16);
  unsigned int v171 = v16 << (v170 + 1) >> -(char)v170;
  if (!v170) {
    unsigned int v171 = 0;
  }
  unsigned int v172 = v170 + v21 + v170 + 1;
  int v21 = v172 & 7;
  v11 += v172 >> 3;
  int v173 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v173 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v173) {
        goto LABEL_242;
      }
    }
    else
    {
      int v174 = *v11;
      if (v173 == 1)
      {
        unsigned int v16 = v174 << 24;
      }
      else
      {
        int v175 = (v174 << 16) | (v11[1] << 8);
        if (v173 != 2) {
          v175 |= v11[2];
        }
        unsigned int v16 = v175 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  unsigned int v176 = ((v171 + (1 << v170)) >> 1) - ((v171 + (1 << v170)) >> 1) * 2 * ((v171 + (1 << v170)) & 1);
  *(_DWORD *)(a2 + 80) = v176;
  if (v176 + 12 >= 0x19) {
    goto LABEL_385;
  }
  *(unsigned char *)(a2 + 84) = ((v16 << v21) & 0x80000000) != 0;
  uint64_t v177 = (v21 + 1) >> 3;
  int v21 = (v21 + 1) & 7;
  v11 += v177;
  int v178 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v178 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v178) {
        goto LABEL_242;
      }
    }
    else
    {
      int v179 = *v11;
      if (v178 == 1)
      {
        unsigned int v16 = v179 << 24;
      }
      else
      {
        int v180 = (v179 << 16) | (v11[1] << 8);
        if (v178 != 2) {
          v180 |= v11[2];
        }
        unsigned int v16 = v180 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  *(unsigned char *)(a2 + 85) = ((v16 << v21) & 0x80000000) != 0;
  uint64_t v181 = (v21 + 1) >> 3;
  int v21 = (v21 + 1) & 7;
  v11 += v181;
  int v182 = v12 - v11;
  if (v12 - (int)v11 < 4)
  {
    if (v182 < 1)
    {
      unsigned int v16 = 0;
      if (v21 | v182) {
        goto LABEL_242;
      }
    }
    else
    {
      int v183 = *v11;
      if (v182 == 1)
      {
        unsigned int v16 = v183 << 24;
      }
      else
      {
        int v184 = (v183 << 16) | (v11[1] << 8);
        if (v182 != 2) {
          v184 |= v11[2];
        }
        unsigned int v16 = v184 << 8;
      }
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
  }
  *(unsigned char *)(a2 + 86) = ((v16 << v21) & 0x80000000) != 0;
  uint64_t v185 = (v21 + 1) >> 3;
  int v21 = (v21 + 1) & 7;
  v11 += v185;
  int v186 = v12 - v11;
  if (v12 - (int)v11 >= 4)
  {
    unsigned int v16 = bswap32(*(_DWORD *)v11);
    goto LABEL_382;
  }
  if (v186 >= 1)
  {
    int v187 = *v11;
    if (v186 == 1)
    {
      unsigned int v16 = v187 << 24;
    }
    else
    {
      int v188 = (v187 << 16) | (v11[1] << 8);
      if (v186 != 2) {
        v188 |= v11[2];
      }
      unsigned int v16 = v188 << 8;
    }
    goto LABEL_382;
  }
  unsigned int v16 = 0;
  if (!(v21 | v186))
  {
LABEL_382:
    v16 <<= v21;
LABEL_383:
    uint64_t v123 = 0;
    a1[2] = (uint64_t)v11;
    *((_DWORD *)a1 + 6) = v16;
    *((unsigned char *)a1 + 28) = v21;
    return v123;
  }
LABEL_242:
  uint64_t v123 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  if (!v123) {
    goto LABEL_383;
  }
  return v123;
}

uint64_t FigH264Bridge_CopyDataWithEmulationPreventionBytesRemoved(const __CFData *a1, __CFData **a2)
{
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);

  return RemoveEmulation3Byte(BytePtr, Length, a2);
}

uint64_t FigH264Bridge_GetPPSSequenceIDFromSlice(const UInt8 *a1, unint64_t a2, int *a3, int *a4)
{
  long long v55 = 0u;
  long long v56 = 0u;
  CFDataRef theData = 0;
  uint64_t v4 = 4294954584;
  if (!a1) {
    return v4;
  }
  int Length = a2;
  if (a2 < 2) {
    return v4;
  }
  BytePtr = a1;
  if ((*a1 & 0x1B | 4) != 5) {
    return v4;
  }
  uint64_t v9 = RemoveEmulation3Byte(a1, a2, &theData);
  CFDataRef v10 = theData;
  if (v9) {
    goto LABEL_65;
  }
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    int Length = CFDataGetLength(v10);
  }
  int32x2_t v11 = BytePtr + 1;
  *(void *)&long long v55 = v11;
  int v12 = Length - 1;
  DWORD2(v55) = Length - 1;
  *(void *)&long long v56 = v11;
  if ((Length - 1) < 4)
  {
    if (Length != 1)
    {
      DWORD2(v56) = 0;
      __memcpy_chk();
    }
  }
  else
  {
    DWORD2(v56) = *v11;
  }
  unsigned int v13 = bswap32(DWORD2(v56));
  DWORD2(v56) = v13;
  BYTE12(v56) = 0;
  if (!(v13 >> 19)) {
    goto LABEL_64;
  }
  int v14 = v11 + v12;
  unsigned int v15 = __clz(v13);
  unsigned int v16 = v15 + 1;
  unsigned int v17 = v13 << (v15 + 1) >> -(char)v15;
  unsigned int v18 = v15 ? v17 : 0;
  uint64_t v19 = (v16 + v15) >> 3;
  int v20 = (v16 + v15) & 7;
  int v21 = (unsigned __int8 *)v11 + v19;
  int v22 = v12 - v19;
  if (v22 < 4)
  {
    if (v22 < 1)
    {
      int v23 = v20 | v22;
      if (v23) {
        goto LABEL_64;
      }
    }
    else
    {
      int v24 = *v21;
      if (v22 == 1)
      {
        int v23 = v24 << 24;
      }
      else
      {
        int v25 = (v24 << 16) | (v21[1] << 8);
        if (v22 != 2) {
          v25 |= v21[2];
        }
        int v23 = v25 << 8;
      }
    }
  }
  else
  {
    int v23 = bswap32(*(_DWORD *)v21);
  }
  if ((v18 + ~(-1 << v15)) >> 22) {
    goto LABEL_66;
  }
  unsigned int v26 = v23 << v20;
  if (!((v23 << v20) >> 19))
  {
LABEL_64:
    uint64_t v9 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_65:
    uint64_t v4 = v9;
    goto LABEL_61;
  }
  unsigned int v27 = __clz(v26);
  unsigned int v28 = v26 << (v27 + 1) >> -(char)v27;
  if (!v27) {
    unsigned int v28 = 0;
  }
  unsigned int v29 = v27 + v20 + v27 + 1;
  uint64_t v30 = v29 >> 3;
  int v31 = v29 & 7;
  int v32 = &v21[v30];
  int v33 = v14 - v32;
  if (v14 - (int)v32 >= 4)
  {
    int v34 = bswap32(*(_DWORD *)v32);
    goto LABEL_39;
  }
  if (v33 < 1)
  {
    int v34 = v31 | v33;
    if (!v34) {
      goto LABEL_39;
    }
    goto LABEL_64;
  }
  int v35 = *v32;
  if (v33 == 1)
  {
    int v34 = v35 << 24;
  }
  else
  {
    int v36 = (v35 << 16) | (v32[1] << 8);
    if (v33 != 2) {
      v36 |= v32[2];
    }
    int v34 = v36 << 8;
  }
LABEL_39:
  int v37 = v28 + ~(-1 << v27);
  if (v37 <= 9)
  {
    unsigned int v38 = v34 << v31;
    if (a3) {
      *a3 = v37;
    }
    if (v38 >> 19)
    {
      unsigned int v39 = __clz(v38);
      unsigned int v40 = v38 << (v39 + 1) >> -(char)v39;
      if (!v39) {
        unsigned int v40 = 0;
      }
      unsigned int v41 = v39 + v31 + v39 + 1;
      int v42 = &v32[v41 >> 3];
      int v43 = v14 - v42;
      if (v43 > 3) {
        goto LABEL_58;
      }
      int v44 = v41 & 7;
      if (v43 <= 0) {
        uint64_t v45 = v42;
      }
      else {
        uint64_t v45 = v42 + 1;
      }
      int v46 = v43 - (v43 > 0);
      if (v46 > 0) {
        ++v45;
      }
      int v47 = v46 - (v46 > 0);
      BOOL v48 = v47 <= 0;
      int v49 = v47 & (v47 >> 31);
      unsigned int v50 = v48 ? v45 : v45 + 1;
      if (!(v49 | v44) || v50 != v42)
      {
LABEL_58:
        int v52 = v40 + ~(-1 << v39);
        if (v52 <= 255)
        {
          uint64_t v4 = 0;
          if (a4) {
            *a4 = v52;
          }
          goto LABEL_61;
        }
        goto LABEL_66;
      }
    }
    goto LABEL_64;
  }
LABEL_66:
  uint64_t v4 = 4294954584;
LABEL_61:
  if (v10) {
    CFRelease(v10);
  }
  return v4;
}

uint64_t FigH264Bridge_GetInterlaceTypeFromSlice(const UInt8 *a1, unint64_t a2, unsigned char *a3, unint64_t a4, int *a5, unsigned int *a6, BOOL *a7)
{
  long long v84 = 0u;
  long long v85 = 0u;
  CFDataRef theData = 0;
  long long v82 = 0u;
  uint64_t v7 = 4294954584;
  if (!a1) {
    return v7;
  }
  unsigned int Length = a2;
  if (a2 < 3) {
    return v7;
  }
  BytePtr = a1;
  if (a5) {
    *a5 = 3;
  }
  long long v99 = 0uLL;
  long long v100 = 0uLL;
  long long v97 = 0uLL;
  long long v98 = 0uLL;
  long long v95 = 0uLL;
  long long v96 = 0uLL;
  long long v93 = 0uLL;
  long long v94 = 0uLL;
  long long v91 = 0uLL;
  long long v92 = 0uLL;
  long long v89 = 0uLL;
  long long v90 = 0uLL;
  long long v87 = 0uLL;
  long long v88 = 0uLL;
  memset(v86, 0, sizeof(v86));
  uint64_t v15 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v15) {
    return v15;
  }
  CFDataRef v16 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unsigned int Length = CFDataGetLength(v16);
  }
  *(void *)&long long v84 = BytePtr;
  DWORD2(v84) = Length;
  *(void *)&long long v85 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      DWORD2(v85) = 0;
      __memcpy_chk();
    }
  }
  else
  {
    DWORD2(v85) = *(_DWORD *)BytePtr;
  }
  DWORD2(v85) = bswap32(DWORD2(v85));
  BYTE12(v85) = 0;
  uint64_t v7 = PullParamSetSPS((uint64_t)&v84, (char *)v86);
  if (v16) {
    CFRelease(v16);
  }
  if (v7) {
    return v7;
  }
  int v17 = v87;
  uint64_t v7 = 4294954584;
  if ((int)v87 > 12 || !a3 || a4 < 3) {
    return v7;
  }
  if (a7) {
    *a7 = (*a3 & 0x60) != 0;
  }
  if ((*a3 & 0x1B | 4) != 5) {
    return 4294954577;
  }
  unsigned int v18 = a3 + 1;
  unsigned int v19 = a4 - 1;
  if (v19 < 4)
  {
    if (v19)
    {
      DWORD2(v82) = 0;
      __memcpy_chk();
    }
  }
  else
  {
    DWORD2(v82) = *v18;
  }
  unsigned int v20 = bswap32(DWORD2(v82));
  if (!(v20 >> 19)) {
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  unsigned int v21 = v18 + v19;
  unsigned int v22 = __clz(v20);
  unsigned int v23 = v22 + 1;
  unsigned int v24 = v20 << (v22 + 1) >> -(char)v22;
  if (v22) {
    unsigned int v25 = v24;
  }
  else {
    unsigned int v25 = 0;
  }
  uint64_t v26 = (v23 + v22) >> 3;
  int v27 = (v23 + v22) & 7;
  unsigned int v28 = (unsigned __int8 *)v18 + v26;
  int v29 = v19 - v26;
  if (v29 < 4)
  {
    if (v29 < 1)
    {
      int v30 = v27 | v29;
      if (v30) {
        return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      int v31 = *v28;
      if (v29 == 1)
      {
        int v30 = v31 << 24;
      }
      else
      {
        int v32 = (v31 << 16) | (v28[1] << 8);
        if (v29 != 2) {
          v32 |= v28[2];
        }
        int v30 = v32 << 8;
      }
    }
  }
  else
  {
    int v30 = bswap32(*(_DWORD *)v28);
  }
  if ((v25 + ~(-1 << v22)) >> 22) {
    return v7;
  }
  unsigned int v33 = v30 << v27;
  if (!((v30 << v27) >> 19)) {
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  unsigned int v34 = __clz(v33);
  unsigned int v35 = v33 << (v34 + 1) >> -(char)v34;
  if (v34) {
    unsigned int v36 = v35;
  }
  else {
    unsigned int v36 = 0;
  }
  unsigned int v37 = v34 + v27 + v34 + 1;
  uint64_t v38 = v37 >> 3;
  int v39 = v37 & 7;
  unsigned int v40 = &v28[v38];
  int v41 = v21 - (v28 + v38);
  if (v41 < 4)
  {
    if (v41 < 1)
    {
      int v42 = v39 | v41;
      if (v42) {
        return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      int v43 = *v40;
      if (v41 == 1)
      {
        int v42 = v43 << 24;
      }
      else
      {
        int v44 = (v43 << 16) | (v40[1] << 8);
        if (v41 != 2) {
          v44 |= v40[2];
        }
        int v42 = v44 << 8;
      }
    }
  }
  else
  {
    int v42 = bswap32(*(_DWORD *)v40);
  }
  if (v36 + ~(-1 << v34) > 9) {
    return v7;
  }
  unsigned int v45 = v42 << v39;
  if (!(v45 >> 19)) {
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  unsigned int v46 = __clz(v45);
  unsigned int v47 = v45 << (v46 + 1) >> -(char)v46;
  if (v46) {
    unsigned int v48 = v47;
  }
  else {
    unsigned int v48 = 0;
  }
  unsigned int v49 = v46 + v39 + v46 + 1;
  uint64_t v50 = v49 >> 3;
  int v51 = v49 & 7;
  int v52 = &v40[v50];
  int v53 = v21 - (v40 + v50);
  if (v53 < 4)
  {
    if (v53 < 1)
    {
      if (v51 | v53) {
        return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
      unsigned int v54 = 0;
    }
    else
    {
      int v55 = *v52;
      if (v53 == 1)
      {
        unsigned int v54 = v55 << 24;
      }
      else
      {
        int v56 = (v55 << 16) | (v52[1] << 8);
        if (v53 != 2) {
          v56 |= v52[2];
        }
        unsigned int v54 = v56 << 8;
      }
    }
  }
  else
  {
    unsigned int v54 = bswap32(*(_DWORD *)v52);
  }
  if (v48 + ~(-1 << v46) > 0xFF) {
    return v7;
  }
  if (v17 <= -4) {
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  unsigned int v57 = v51 + v17 + 4;
  uint64_t v58 = v57 >> 3;
  int v59 = v57 & 7;
  int v60 = &v52[v58];
  int v61 = v21 - v60;
  if ((int)(v21 - v60) >= 4)
  {
    int v62 = bswap32(*(_DWORD *)v60);
    if (!a6) {
      goto LABEL_82;
    }
LABEL_81:
    *a6 = v54 << v51 >> (28 - v17);
    goto LABEL_82;
  }
  if (v61 < 1)
  {
    int v62 = v59 | v61;
    if (v62) {
      return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    }
    if (a6) {
      goto LABEL_81;
    }
  }
  else
  {
    int v63 = *v60;
    if (v61 == 1)
    {
      int v62 = v63 << 24;
      if (a6) {
        goto LABEL_81;
      }
    }
    else
    {
      int v69 = (v63 << 16) | (v60[1] << 8);
      if (v61 != 2) {
        v69 |= v60[2];
      }
      int v62 = v69 << 8;
      if (a6) {
        goto LABEL_81;
      }
    }
  }
LABEL_82:
  if (HIDWORD(v89)) {
    goto LABEL_98;
  }
  int v64 = (v59 + 1) & 7;
  int v65 = &v60[(v59 + 1) >> 3];
  int v66 = v21 - v65;
  if ((int)(v21 - v65) >= 4)
  {
    int v67 = bswap32(*(_DWORD *)v65);
    goto LABEL_97;
  }
  if (v66 < 1)
  {
    int v67 = v64 | v66;
    if (!v67) {
      goto LABEL_97;
    }
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  int v68 = *v65;
  if (v66 == 1)
  {
    int v67 = v68 << 24;
  }
  else
  {
    int v70 = (v68 << 16) | (v65[1] << 8);
    if (v66 != 2) {
      v70 |= v65[2];
    }
    int v67 = v70 << 8;
  }
LABEL_97:
  if (((v62 << v59) & 0x80000000) == 0)
  {
LABEL_98:
    if (a5)
    {
      uint64_t v7 = 0;
      *a5 = 0;
      return v7;
    }
    return 0;
  }
  uint64_t v71 = &v65[(v64 + 1) >> 3];
  int v72 = v21 - v71;
  if (v72 <= 3)
  {
    if (v72 <= 0) {
      int v73 = &v65[(v64 + 1) >> 3];
    }
    else {
      int v73 = v71 + 1;
    }
    int v74 = v72 - (v72 > 0);
    if (v74 > 0) {
      ++v73;
    }
    int v75 = v74 - (v74 > 0);
    BOOL v76 = v75 <= 0;
    int v77 = v75 & (v75 >> 31);
    int v78 = v76 ? v73 : v73 + 1;
    if (v77 | ((_BYTE)v64 + 1) & 7 && v78 == v71) {
      return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    }
  }
  if (!a5) {
    return 0;
  }
  uint64_t v7 = 0;
  if (v67 << v64 >= 0) {
    int v80 = 1;
  }
  else {
    int v80 = 2;
  }
  *a5 = v80;
  return v7;
}

uint64_t FigH264Bridge_GetSliceInformationFromSampleBuffer(opaqueCMSampleBuffer *a1, int *a2, unsigned int *a3, BOOL *a4)
{
  char *returnedPointerOut;
  const UInt8 *v34;
  unsigned char temporaryBlock[32];
  uint64_t v36;

  unsigned int v36 = *MEMORY[0x1E4F143B8];
  unsigned int v34 = 0;
  unint64_t v32 = 0;
  FormatDescription = CMSampleBufferGetFormatDescription(a1);
  if (!FormatDescription) {
    return 4294954584;
  }
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(FormatDescription);
  if (!Extensions) {
    return 4294954584;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms");
  if (!Value) {
    return 4294954584;
  }
  CFDictionaryRef v10 = Value;
  CFTypeID v11 = CFGetTypeID(Value);
  if (v11 != CFDictionaryGetTypeID()) {
    return 4294954584;
  }
  CFArrayRef v12 = (const __CFArray *)CFDictionaryGetValue(v10, @"avcC");
  if (!v12) {
    return 4294954584;
  }
  CFArrayRef ValueAtIndex = v12;
  CFTypeID v14 = CFGetTypeID(v12);
  if (v14 == CFArrayGetTypeID())
  {
    CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    if (!ValueAtIndex) {
      return 4294954584;
    }
  }
  CFTypeID v15 = CFGetTypeID(ValueAtIndex);
  if (v15 != CFDataGetTypeID()) {
    return 4294954584;
  }
  returnedPointerOut = 0;
  BytePtr = CFDataGetBytePtr(ValueAtIndex);
  CFIndex Length = CFDataGetLength(ValueAtIndex);
  uint64_t result = FigH264Bridge_GetSPSFromAVCC((uint64_t)BytePtr, Length, 0, &v34, &v32);
  if (!result)
  {
    unsigned int v19 = CFDataGetBytePtr(ValueAtIndex);
    if ((unint64_t)CFDataGetLength(ValueAtIndex) >= 7)
    {
      uint64_t v20 = v19[4] & 3;
      size_t v21 = v20 + 1;
      if (v20 < 2 || v20 == 3)
      {
        CMBlockBufferRef DataBuffer = CMSampleBufferGetDataBuffer(a1);
        if (DataBuffer)
        {
          unsigned int v23 = DataBuffer;
          size_t v24 = 0;
          unsigned int v25 = v34;
          unint64_t v26 = v32;
          while (1)
          {
            unsigned int v31 = 0;
            uint64_t result = CMBlockBufferAccessDataBytes(v23, v24, v21, temporaryBlock, &returnedPointerOut);
            if (result) {
              return result;
            }
            if (v21 == 2)
            {
              unsigned int v27 = bswap32(*(unsigned __int16 *)returnedPointerOut) >> 16;
            }
            else
            {
              if (v21 != 4)
              {
                __memcpy_chk();
                unsigned int v27 = 0;
                goto LABEL_22;
              }
              unsigned int v27 = bswap32(*(_DWORD *)returnedPointerOut);
            }
            unsigned int v31 = v27;
LABEL_22:
            if (v27 >= 0x20) {
              size_t v28 = 32;
            }
            else {
              size_t v28 = v27;
            }
            size_t v29 = v24 + v21;
            uint64_t result = CMBlockBufferAccessDataBytes(v23, v29, v28, temporaryBlock, &returnedPointerOut);
            if (!result)
            {
              uint64_t result = FigH264Bridge_GetInterlaceTypeFromSlice(v25, v26, returnedPointerOut, v28, a2, a3, a4);
              size_t v24 = v29 + v31;
              if (result == -12719) {
                continue;
              }
            }
            return result;
          }
        }
      }
      return 4294954584;
    }
    return 4294954582;
  }
  return result;
}

uint64_t FigH264Bridge_CreateHLSfMP4ParsingInfoFromAVCCData(const void *a1, void *a2)
{
  int v70 = 0;
  uint64_t v71 = 0;
  unint64_t v68 = 0;
  unint64_t v69 = 0;
  unint64_t v66 = 0;
  unint64_t v67 = 0;
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFDataGetTypeID())
    {
      if (a2)
      {
        uint64_t SPSAndPPSCountFromAVCC = FigH264Bridge_GetSPSAndPPSCountFromAVCC(a1, &v67, &v66);
        if (SPSAndPPSCountFromAVCC) {
          return SPSAndPPSCountFromAVCC;
        }
        if (v67 && v66)
        {
          uint64_t v6 = (char *)malloc_type_malloc(0x3900uLL, 0x1000040677A246CuLL);
          uint64_t v7 = v6;
          if (v6)
          {
            bzero(v6, 0x3900uLL);
            if (v67)
            {
              uint64_t v8 = 0;
              while (1)
              {
                long long v64 = 0u;
                long long v65 = 0u;
                long long v62 = 0u;
                long long v63 = 0u;
                long long v60 = 0u;
                long long v61 = 0u;
                long long v58 = 0u;
                long long v59 = 0u;
                long long v56 = 0u;
                long long v57 = 0u;
                long long v54 = 0u;
                long long v55 = 0u;
                long long v52 = 0u;
                long long v53 = 0u;
                long long v50 = 0u;
                long long v51 = 0u;
                long long v48 = 0u;
                long long v49 = 0u;
                long long v46 = 0u;
                long long v47 = 0u;
                long long v44 = 0u;
                long long v45 = 0u;
                long long v42 = 0u;
                long long v43 = 0u;
                long long v40 = 0u;
                long long v41 = 0u;
                long long v38 = 0u;
                long long v39 = 0u;
                long long v36 = 0u;
                long long v37 = 0u;
                memset(v35, 0, sizeof(v35));
                long long v33 = 0u;
                long long v34 = 0u;
                CFDataRef theData = 0;
                BytePtr = CFDataGetBytePtr((CFDataRef)a1);
                CFIndex Length = CFDataGetLength((CFDataRef)a1);
                uint64_t SPSFromAVCC = FigH264Bridge_GetSPSFromAVCC((uint64_t)BytePtr, Length, v8, &v71, &v69);
                if (SPSFromAVCC) {
                  break;
                }
                CFArrayRef v12 = v71;
                unsigned int v13 = v69;
                uint64_t SPSFromAVCC = RemoveEmulation3Byte(v71, v69, &theData);
                if (SPSFromAVCC) {
                  break;
                }
                CFDataRef v14 = theData;
                if (theData)
                {
                  *(void *)&long long v33 = CFDataGetBytePtr(theData);
                  unsigned int v15 = CFDataGetLength(v14);
                  unint64_t v16 = v15;
                  DWORD2(v33) = v15;
                  CFArrayRef v12 = (const UInt8 *)v33;
                }
                else
                {
                  *(void *)&long long v33 = v12;
                  unint64_t v16 = v13;
                  DWORD2(v33) = v13;
                }
                *(void *)&long long v34 = v12;
                if (v16 < 4)
                {
                  if (v16)
                  {
                    DWORD2(v34) = 0;
                    __memcpy_chk();
                  }
                }
                else
                {
                  DWORD2(v34) = *(_DWORD *)v12;
                }
                DWORD2(v34) = bswap32(DWORD2(v34));
                BYTE12(v34) = 0;
                uint64_t v17 = PullParamSetSPS((uint64_t)&v33, (char *)v35);
                if (v14) {
                  CFRelease(v14);
                }
                if (v17) {
                  goto LABEL_44;
                }
                if (SDWORD1(v36) >= 32) {
                  goto LABEL_42;
                }
                unsigned int v18 = &v7[40 * SDWORD1(v36)];
                *unsigned int v18 = 1;
                int v19 = BYTE9(v36);
                *((_DWORD *)v18 + 1) = BYTE8(v36);
                *((_DWORD *)v18 + 2) = v19;
                *(_OWORD *)(v18 + 12) = v52;
                *(void *)(v18 + 28) = *(void *)((char *)&v54 + 4);
                *((_DWORD *)v18 + 9) = HIDWORD(v54);
                if (++v8 >= v67) {
                  goto LABEL_24;
                }
              }
            }
            else
            {
LABEL_24:
              if (!v66) {
                goto LABEL_40;
              }
              uint64_t v20 = 0;
              while (1)
              {
                *(void *)&long long v39 = 0;
                long long v37 = 0u;
                long long v38 = 0u;
                long long v36 = 0u;
                long long v34 = 0u;
                memset(v35, 0, sizeof(v35));
                long long v33 = 0u;
                CFDataRef theData = 0;
                size_t v21 = CFDataGetBytePtr((CFDataRef)a1);
                CFIndex v22 = CFDataGetLength((CFDataRef)a1);
                uint64_t SPSFromAVCC = FigH264Bridge_GetPPSFromAVCC((uint64_t)v21, v22, v20, &v70, &v68);
                if (SPSFromAVCC) {
                  break;
                }
                unsigned int v23 = v70;
                unsigned int v24 = v68;
                uint64_t SPSFromAVCC = RemoveEmulation3Byte(v70, v68, &theData);
                if (SPSFromAVCC) {
                  break;
                }
                CFDataRef v25 = theData;
                if (theData)
                {
                  *(void *)&long long v33 = CFDataGetBytePtr(theData);
                  unsigned int v26 = CFDataGetLength(v25);
                  unint64_t v27 = v26;
                  DWORD2(v33) = v26;
                  unsigned int v23 = (const UInt8 *)v33;
                }
                else
                {
                  *(void *)&long long v33 = v23;
                  unint64_t v27 = v24;
                  DWORD2(v33) = v24;
                }
                *(void *)&long long v34 = v23;
                if (v27 < 4)
                {
                  if (v27)
                  {
                    DWORD2(v34) = 0;
                    __memcpy_chk();
                  }
                }
                else
                {
                  DWORD2(v34) = *(_DWORD *)v23;
                }
                DWORD2(v34) = bswap32(DWORD2(v34));
                BYTE12(v34) = 0;
                uint64_t v17 = PullParamSetPPS((uint64_t *)&v33, (uint64_t)v35);
                if (v25) {
                  CFRelease(v25);
                }
                if (v17) {
                  goto LABEL_44;
                }
                if (LODWORD(v35[0]) >= 0x100) {
                  goto LABEL_42;
                }
                size_t v28 = &v7[52 * LODWORD(v35[0])];
                v28[1280] = 1;
                *((_DWORD *)v28 + 321) = DWORD1(v35[0]);
                *((_DWORD *)v28 + 322) = BYTE8(v35[0]);
                *((_DWORD *)v28 + 323) = BYTE9(v35[0]);
                *(void *)&long long v29 = *(void *)((char *)v35 + 12);
                *((void *)&v29 + 1) = __PAIR64__(DWORD2(v37), HIDWORD(v36));
                *((_OWORD *)v28 + 81) = v29;
                *((_DWORD *)v28 + 328) = HIDWORD(v37);
                *((_DWORD *)v28 + 329) = v38;
                *((_DWORD *)v28 + 330) = DWORD1(v38);
                *((_DWORD *)v28 + 331) = BYTE4(v39);
                *((_DWORD *)v28 + 332) = BYTE6(v39);
                if (++v20 >= v66) {
                  goto LABEL_40;
                }
              }
            }
          }
          else
          {
LABEL_42:
            uint64_t SPSFromAVCC = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          }
          uint64_t v17 = SPSFromAVCC;
LABEL_44:
          if (v17) {
            goto LABEL_45;
          }
LABEL_40:
          uint64_t v17 = 0;
          *a2 = v7;
          return v17;
        }
      }
    }
  }
  uint64_t v17 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  uint64_t v7 = 0;
  if (!v17) {
    goto LABEL_40;
  }
LABEL_45:
  if (v7) {
    free(v7);
  }
  return v17;
}

void FigH264Bridge_HLSfMP4ParsingInfoDestroy(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t FigH264Bridge_MeasureSliceHeader(const UInt8 *a1, unint64_t a2, uint64_t a3, int a4, const UInt8 **a5)
{
  uint64_t v471 = 0;
  long long v469 = 0u;
  long long v470 = 0u;
  long long v467 = 0u;
  long long v468 = 0u;
  long long v465 = 0u;
  long long v466 = 0u;
  long long v463 = 0u;
  long long v464 = 0u;
  long long v462 = 0u;
  long long v460 = 0u;
  long long v461 = 0u;
  long long v458 = 0u;
  long long v459 = 0u;
  long long v456 = 0u;
  long long v457 = 0u;
  long long v454 = 0u;
  long long v455 = 0u;
  CFDataRef theData = 0;
  uint64_t v10 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v10)
  {
    uint64_t v400 = v10;
    goto LABEL_1068;
  }
  CFDataRef v11 = theData;
  BytePtr = a1;
  int Length = a2;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    int Length = CFDataGetLength(v11);
  }
  *(void *)&long long v454 = BytePtr;
  DWORD2(v454) = Length;
  *(void *)&long long v455 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      DWORD2(v455) = 0;
      __memcpy_chk();
      unsigned int v14 = DWORD2(v455);
    }
    else
    {
      unsigned int v14 = 0;
    }
  }
  else
  {
    unsigned int v14 = *(_DWORD *)BytePtr;
  }
  unsigned int v15 = bswap32(v14);
  DWORD2(v455) = v15;
  BYTE12(v455) = 0;
  long long v456 = 0u;
  long long v457 = 0u;
  long long v458 = 0u;
  long long v459 = 0u;
  long long v460 = 0u;
  long long v461 = 0u;
  long long v462 = 0u;
  long long v463 = 0u;
  long long v464 = 0u;
  long long v465 = 0u;
  long long v466 = 0u;
  long long v467 = 0u;
  long long v468 = 0u;
  long long v469 = 0u;
  long long v470 = 0u;
  uint64_t v471 = 0;
  if (Length <= 3)
  {
    if (Length < 1)
    {
      uint64_t v22 = 4294954582;
      if (!a4)
      {
        v451 = a1;
        v452 = a5;
        unsigned int v23 = 0;
        LOBYTE(v24) = 1;
        goto LABEL_973;
      }
      goto LABEL_974;
    }
    LODWORD(v456) = (*BytePtr >> 5) & 3;
    unint64_t v16 = (unsigned __int8 *)(BytePtr + 1);
    unsigned int v17 = *BytePtr & 0x1F;
    DWORD1(v456) = v17;
    v451 = a1;
    v452 = a5;
    if (Length == 1)
    {
      int v20 = 0;
      int v18 = 0;
      unsigned int v19 = 0;
      goto LABEL_22;
    }
    int v25 = *v16;
    if (Length == 2)
    {
      int v20 = 0;
      unsigned int v19 = v25 << 24;
      int v18 = 1;
      goto LABEL_22;
    }
    int v21 = (v25 << 16) | (BytePtr[2] << 8);
    int v18 = 2;
  }
  else
  {
    v451 = a1;
    v452 = a5;
    LODWORD(v456) = (*(_DWORD *)BytePtr >> 5) & 3;
    unint64_t v16 = (unsigned __int8 *)(BytePtr + 1);
    unsigned int v17 = *(_DWORD *)BytePtr & 0x1F;
    DWORD1(v456) = v17;
    int v18 = Length - 1;
    if ((Length - 1) >= 4)
    {
      unsigned int v19 = bswap32(*(_DWORD *)v16);
      int v20 = 1;
      goto LABEL_22;
    }
    int v21 = (BytePtr[1] << 16) | (BytePtr[2] << 8) | BytePtr[3];
    int v18 = 3;
  }
  int v20 = 0;
  unsigned int v19 = v21 << 8;
LABEL_22:
  if (a4)
  {
    if ((v15 & 0x80000000) != 0) {
      goto LABEL_952;
    }
    LODWORD(v22) = -12714;
    if (v17 > 0x13 || ((1 << v17) & 0x80022) == 0) {
      goto LABEL_974;
    }
  }
  else if ((v15 & 0x80000000) != 0 || v17 > 0x13 || ((1 << v17) & 0x80022) == 0)
  {
    goto LABEL_853;
  }
  int v26 = BytePtr + Length;
  if (v19 >= 0x80000)
  {
    unsigned int v27 = __clz(v19);
    unsigned int v28 = v19 << (v27 + 1) >> -(char)v27;
    if (!v27) {
      unsigned int v28 = 0;
    }
    DWORD2(v456) = v28 + ~(-1 << v27);
    unsigned int v29 = v27 + 1 + v27;
    int v24 = v29 & 7;
    int v30 = &v16[v29 >> 3];
    int v31 = v26 - v30;
    if (v26 - (int)v30 >= 4)
    {
      unsigned int v23 = bswap32(*(_DWORD *)v30);
      goto LABEL_95;
    }
    if (v31 >= 1)
    {
      int v33 = *v30;
      if (v31 == 1)
      {
        unsigned int v23 = v33 << 24;
      }
      else
      {
        int v36 = (v33 << 16) | (v30[1] << 8);
        if (v31 != 2) {
          v36 |= v30[2];
        }
        unsigned int v23 = v36 << 8;
      }
      goto LABEL_95;
    }
    int v35 = v24 | v31;
    if (a4)
    {
      if (v35) {
        goto LABEL_952;
      }
      unsigned int v23 = 0;
      goto LABEL_95;
    }
    unsigned int v23 = 0;
    if (!v35)
    {
LABEL_95:
      v23 <<= v24;
      goto LABEL_121;
    }
    goto LABEL_1134;
  }
  if (v20)
  {
    unsigned int v32 = bswap32(*(_DWORD *)v16);
  }
  else
  {
    if (!v18)
    {
      uint64_t v22 = 4294954582;
      if (a4) {
        goto LABEL_974;
      }
      unsigned int v23 = 0;
      LOBYTE(v24) = 1;
      goto LABEL_48;
    }
    int v34 = *v16;
    if (v18 == 1)
    {
      unsigned int v32 = v34 << 24;
    }
    else
    {
      int v37 = (v34 << 16) | (BytePtr[2] << 8);
      if (v18 != 2) {
        v37 |= BytePtr[3];
      }
      unsigned int v32 = v37 << 8;
    }
  }
  int v38 = 0;
  int v39 = 2 * v32;
  for (int i = 1; ; int i = (i + 1) & 7)
  {
    int v24 = (i + 1) & 7;
    v16 += (i + 1) >> 3;
    int v41 = v26 - v16;
    if (v26 - (int)v16 >= 4)
    {
      unsigned int v42 = bswap32(*(_DWORD *)v16);
      goto LABEL_68;
    }
    if (v41 >= 1) {
      break;
    }
    int v44 = v24 | v41;
    if (a4)
    {
      if (v44) {
        goto LABEL_952;
      }
      unsigned int v23 = 0;
      if (v39 < 0) {
        goto LABEL_74;
      }
    }
    else
    {
      unsigned int v23 = 0;
      if (v44) {
        goto LABEL_1130;
      }
      if (v39 < 0) {
        goto LABEL_78;
      }
    }
LABEL_69:
    --v38;
    int v39 = v44;
  }
  int v43 = *v16;
  if (v41 == 1)
  {
    unsigned int v42 = v43 << 24;
  }
  else
  {
    int v45 = (v43 << 16) | (v16[1] << 8);
    if (v41 != 2) {
      v45 |= v16[2];
    }
    unsigned int v42 = v45 << 8;
  }
LABEL_68:
  int v44 = v42 << v24;
  if ((v39 & 0x80000000) == 0) {
    goto LABEL_69;
  }
  unsigned int v23 = v44;
  if (!a4)
  {
LABEL_78:
    if (-v38 > 0x1E)
    {
LABEL_1130:
      uint64_t v22 = 4294954582;
      goto LABEL_48;
    }
    if ((1 - v38) < 0x19) {
      goto LABEL_76;
    }
    goto LABEL_80;
  }
LABEL_74:
  if (-v38 > 0x1E) {
    goto LABEL_952;
  }
  if ((1 - v38) > 0x18)
  {
LABEL_80:
    int v50 = (((_BYTE)i + 1) & 7) - v38;
    int v24 = (v50 + 1) & 7;
    v16 += (v50 - 15) >> 3;
    int v51 = v26 - v16;
    if (v26 - (int)v16 >= 4)
    {
      unsigned int v52 = bswap32(*(_DWORD *)v16);
LABEL_102:
      unsigned int v57 = v52 << v24;
      goto LABEL_103;
    }
    if (v51 >= 1)
    {
      int v54 = *v16;
      if (v51 == 1)
      {
        unsigned int v52 = v54 << 24;
      }
      else
      {
        int v59 = (v54 << 16) | (v16[1] << 8);
        if (v51 != 2) {
          v59 |= v16[2];
        }
        unsigned int v52 = v59 << 8;
      }
      goto LABEL_102;
    }
    int v56 = v24 | v51;
    if (a4)
    {
      if (v56) {
        goto LABEL_952;
      }
      unsigned int v57 = 0;
LABEL_103:
      int v30 = v16 + 2;
      int v60 = v26 - (v16 + 2);
      if (v60 < 4)
      {
        if (v60 < 1)
        {
          int v63 = v24 | v60;
          if (a4)
          {
            if (v63) {
              goto LABEL_952;
            }
            unsigned int v61 = 0;
          }
          else
          {
            unsigned int v61 = 0;
            if (v63)
            {
LABEL_1139:
              uint64_t v22 = 4294954582;
              unsigned int v23 = 0;
              goto LABEL_1135;
            }
          }
        }
        else
        {
          int v62 = *v30;
          if (v60 == 1)
          {
            unsigned int v61 = v62 << 24;
          }
          else
          {
            int v64 = (v62 << 16) | (v16[3] << 8);
            if (v60 != 2) {
              v64 |= v16[4];
            }
            unsigned int v61 = v64 << 8;
          }
        }
      }
      else
      {
        unsigned int v61 = bswap32(*(_DWORD *)v30);
      }
      unsigned int v66 = v23 >> (v38 + 47);
      unsigned int v23 = v61 << v24;
      int v65 = __PAIR64__(v66, v57) >> 16;
      goto LABEL_120;
    }
    unsigned int v57 = 0;
    if (!v56) {
      goto LABEL_103;
    }
    uint64_t v22 = 4294954582;
    unsigned int v23 = 0;
LABEL_48:
    BytePtr = v16;
    goto LABEL_973;
  }
LABEL_76:
  unsigned int v46 = (((_BYTE)i + 1) & 7) - v38 + 1;
  uint64_t v47 = v46 >> 3;
  int v24 = v46 & 7;
  int v30 = &v16[v47];
  int v48 = v26 - (v16 + v47);
  if (v48 >= 4)
  {
    unsigned int v49 = bswap32(*(_DWORD *)v30);
    goto LABEL_115;
  }
  if (v48 >= 1)
  {
    int v53 = *v30;
    if (v48 == 1)
    {
      unsigned int v49 = v53 << 24;
    }
    else
    {
      int v58 = (v53 << 16) | (v30[1] << 8);
      if (v48 != 2) {
        v58 |= v30[2];
      }
      unsigned int v49 = v58 << 8;
    }
    goto LABEL_115;
  }
  int v55 = v24 | v48;
  if (!a4)
  {
    unsigned int v49 = 0;
    if (!v55) {
      goto LABEL_115;
    }
    goto LABEL_1139;
  }
  if (v55) {
    goto LABEL_952;
  }
  unsigned int v49 = 0;
LABEL_115:
  int v65 = v23 >> (v38 + 31);
  unsigned int v23 = v49 << v24;
LABEL_120:
  DWORD2(v456) = v65 + ~(-1 << (1 - v38));
LABEL_121:
  if (!a4)
  {
    if (v23 >= 0x80000) {
      goto LABEL_125;
    }
LABEL_1134:
    uint64_t v22 = 4294954582;
LABEL_1135:
    BytePtr = v30;
    goto LABEL_973;
  }
  if (v23 < 0x80000) {
    goto LABEL_952;
  }
LABEL_125:
  unsigned int v67 = __clz(v23);
  unsigned int v68 = v23 << (v67 + 1) >> -(char)v67;
  if (!v67) {
    unsigned int v68 = 0;
  }
  unsigned int v69 = v68 + ~(-1 << v67);
  LODWORD(v457) = v69;
  unsigned int v70 = v67 + v24 + v67 + 1;
  uint64_t v71 = v70 >> 3;
  int v24 = v70 & 7;
  int v72 = &v30[v71];
  int v73 = v26 - (v30 + v71);
  if (v73 >= 4)
  {
    unsigned int v74 = bswap32(*(_DWORD *)v72);
    goto LABEL_138;
  }
  if (v73 < 1)
  {
    int v76 = v24 | v73;
    if (a4)
    {
      if (v76) {
        goto LABEL_952;
      }
      unsigned int v23 = 0;
      goto LABEL_139;
    }
    unsigned int v23 = 0;
    if (v76) {
      goto LABEL_658;
    }
  }
  else
  {
    int v75 = *v72;
    if (v73 == 1)
    {
      unsigned int v74 = v75 << 24;
    }
    else
    {
      int v77 = (v75 << 16) | (v72[1] << 8);
      if (v73 != 2) {
        v77 |= v72[2];
      }
      unsigned int v74 = v77 << 8;
    }
LABEL_138:
    unsigned int v23 = v74 << v24;
    if (a4)
    {
LABEL_139:
      if (v69 > 9) {
        goto LABEL_952;
      }
      if (v17 == 5)
      {
        LODWORD(v22) = -12714;
        if (((1 << v69) & 0x294) == 0) {
          goto LABEL_974;
        }
      }
      if (v23 < 0x80000) {
        goto LABEL_952;
      }
      goto LABEL_149;
    }
  }
  if (v69 > 9 || v17 == 5 && ((1 << v69) & 0x294) == 0) {
    goto LABEL_853;
  }
  if (v23 < 0x80000) {
    goto LABEL_658;
  }
LABEL_149:
  unsigned int v78 = __clz(v23);
  unsigned int v79 = v23 << (v78 + 1) >> -(char)v78;
  if (!v78) {
    unsigned int v79 = 0;
  }
  unsigned int v80 = v79 + ~(-1 << v78);
  DWORD1(v457) = v80;
  unsigned int v81 = v78 + v24 + v78 + 1;
  int v24 = v81 & 7;
  v72 += v81 >> 3;
  int v82 = v26 - v72;
  if (v26 - (int)v72 >= 4)
  {
    unsigned int v83 = bswap32(*(_DWORD *)v72);
    goto LABEL_162;
  }
  if (v82 < 1)
  {
    int v85 = v24 | v82;
    if (a4)
    {
      if (v85) {
        goto LABEL_952;
      }
      unsigned int v23 = 0;
      goto LABEL_163;
    }
    unsigned int v23 = 0;
    if (v85) {
      goto LABEL_658;
    }
LABEL_170:
    if (v80 > 0xFF) {
      goto LABEL_1115;
    }
    if (!*(unsigned char *)(a3 + 52 * v80 + 1280)) {
      goto LABEL_1115;
    }
    int v87 = *(_DWORD *)(a3 + 52 * v80 + 1284);
    if (v87 > 31) {
      goto LABEL_1115;
    }
    long long v88 = (unsigned char *)(a3 + 40 * v87);
    if (!*v88) {
      goto LABEL_1115;
    }
    if (*(_DWORD *)(a3 + 40 * v87 + 8)) {
      goto LABEL_175;
    }
    goto LABEL_190;
  }
  int v84 = *v72;
  if (v82 == 1)
  {
    unsigned int v83 = v84 << 24;
  }
  else
  {
    int v86 = (v84 << 16) | (v72[1] << 8);
    if (v82 != 2) {
      v86 |= v72[2];
    }
    unsigned int v83 = v86 << 8;
  }
LABEL_162:
  unsigned int v23 = v83 << v24;
  if (!a4) {
    goto LABEL_170;
  }
LABEL_163:
  if (v80 > 0xFF) {
    goto LABEL_1007;
  }
  if (!*(unsigned char *)(a3 + 52 * v80 + 1280)) {
    goto LABEL_1007;
  }
  int v87 = *(_DWORD *)(a3 + 52 * v80 + 1284);
  if (v87 > 31) {
    goto LABEL_1007;
  }
  long long v88 = (unsigned char *)(a3 + 40 * v87);
  if (!*v88) {
    goto LABEL_1007;
  }
  if (!*(_DWORD *)(a3 + 40 * v87 + 8))
  {
LABEL_187:
    int v95 = *(_DWORD *)(a3 + 40 * v87 + 12);
    if ((v95 - 22) < 0xFFFFFFE7) {
      goto LABEL_952;
    }
    goto LABEL_191;
  }
LABEL_175:
  uint64_t v89 = (v24 + 2) >> 3;
  int v24 = (v24 + 2) & 7;
  v72 += v89;
  int v90 = v26 - v72;
  if (v26 - (int)v72 < 4)
  {
    if (v90 >= 1)
    {
      int v92 = *v72;
      if (v90 == 1)
      {
        unsigned int v91 = v92 << 24;
      }
      else
      {
        int v94 = (v92 << 16) | (v72[1] << 8);
        if (v90 != 2) {
          v94 |= v72[2];
        }
        unsigned int v91 = v94 << 8;
      }
      goto LABEL_186;
    }
    int v93 = v24 | v90;
    if (a4)
    {
      if (v93) {
        goto LABEL_952;
      }
      unsigned int v23 = 0;
      goto LABEL_187;
    }
    unsigned int v23 = 0;
    if (v93) {
      goto LABEL_658;
    }
  }
  else
  {
    unsigned int v91 = bswap32(*(_DWORD *)v72);
LABEL_186:
    unsigned int v23 = v91 << v24;
    if (a4) {
      goto LABEL_187;
    }
  }
LABEL_190:
  int v95 = *(_DWORD *)(a3 + 40 * v87 + 12);
  if ((v95 - 22) < 0xFFFFFFE7) {
    goto LABEL_658;
  }
LABEL_191:
  DWORD2(v457) = v23 >> (28 - v95);
  unsigned int v96 = v95 + v24 + 4;
  int v24 = v96 & 7;
  v72 += v96 >> 3;
  int v97 = v26 - v72;
  if (v26 - (int)v72 >= 4)
  {
    unsigned int v98 = bswap32(*(_DWORD *)v72);
    goto LABEL_202;
  }
  if (v97 < 1)
  {
    int v100 = v24 | v97;
    if (a4)
    {
      if (v100) {
        goto LABEL_952;
      }
    }
    else if (v100)
    {
      goto LABEL_1138;
    }
    int v102 = 0;
    unsigned int v23 = 0;
    WORD6(v457) = 0;
    if (!*(_DWORD *)(a3 + 40 * v87 + 36)) {
      goto LABEL_203;
    }
    goto LABEL_234;
  }
  int v99 = *v72;
  if (v97 == 1)
  {
    unsigned int v98 = v99 << 24;
  }
  else
  {
    int v101 = (v99 << 16) | (v72[1] << 8);
    if (v97 != 2) {
      v101 |= v72[2];
    }
    unsigned int v98 = v101 << 8;
  }
LABEL_202:
  int v100 = 0;
  int v102 = v98 << v24;
  WORD6(v457) = 0;
  unsigned int v23 = v98 << v24;
  if (*(_DWORD *)(a3 + 40 * v87 + 36)) {
    goto LABEL_234;
  }
LABEL_203:
  unsigned int v103 = v102 >> 31;
  BYTE12(v457) = v102 < 0;
  uint64_t v104 = (v24 + 1) >> 3;
  int v24 = (v24 + 1) & 7;
  v72 += v104;
  int v105 = v26 - v72;
  if (v26 - (int)v72 >= 4)
  {
    unsigned int v106 = bswap32(*(_DWORD *)v72);
    goto LABEL_217;
  }
  if (v105 < 1)
  {
    int v100 = v24 | v105;
    if (a4)
    {
      if (v100) {
        goto LABEL_952;
      }
LABEL_220:
      unsigned int v23 = 0;
      if (v102 < 0) {
        goto LABEL_221;
      }
      goto LABEL_234;
    }
    if (!v100) {
      goto LABEL_220;
    }
LABEL_1138:
    unsigned int v23 = 0;
    goto LABEL_658;
  }
  int v107 = *v72;
  if (v105 == 1)
  {
    unsigned int v106 = v107 << 24;
  }
  else
  {
    int v108 = (v107 << 16) | (v72[1] << 8);
    if (v105 != 2) {
      v108 |= v72[2];
    }
    unsigned int v106 = v108 << 8;
  }
LABEL_217:
  unsigned int v23 = v106 << v24;
  if ((v102 & 0x80000000) == 0)
  {
    int v100 = 0;
    goto LABEL_234;
  }
LABEL_221:
  BYTE13(v457) = (v23 & 0x80000000) != 0;
  uint64_t v109 = (v24 + 1) >> 3;
  int v24 = (v24 + 1) & 7;
  v72 += v109;
  int v110 = v26 - v72;
  if (v26 - (int)v72 < 4)
  {
    if (v110 < 1)
    {
      int v112 = v24 | v110;
      if (a4)
      {
        if (v112) {
          goto LABEL_952;
        }
        unsigned int v23 = 0;
      }
      else
      {
        unsigned int v23 = 0;
        if (v112) {
          goto LABEL_658;
        }
      }
    }
    else
    {
      int v111 = *v72;
      if (v110 == 1)
      {
        unsigned int v23 = v111 << 24;
      }
      else
      {
        int v113 = (v111 << 16) | (v72[1] << 8);
        if (v110 != 2) {
          v113 |= v72[2];
        }
        unsigned int v23 = v113 << 8;
      }
    }
  }
  else
  {
    unsigned int v23 = bswap32(*(_DWORD *)v72);
  }
  v23 <<= v24;
  int v100 = v103;
LABEL_234:
  if (v17 != 5) {
    goto LABEL_329;
  }
  if (v23 >= 0x80000)
  {
    unsigned int v114 = __clz(v23);
    unsigned int v115 = v23 << (v114 + 1) >> -(char)v114;
    if (!v114) {
      unsigned int v115 = 0;
    }
    LODWORD(v458) = v115 + ~(-1 << v114);
    unsigned int v116 = v114 + v24 + v114 + 1;
    int v24 = v116 & 7;
    v72 += v116 >> 3;
    int v117 = v26 - v72;
    if (v26 - (int)v72 < 4)
    {
      if (v117 < 1)
      {
        int v123 = v24 | v117;
        if (a4)
        {
          if (v123) {
            goto LABEL_952;
          }
          unsigned int v23 = 0;
        }
        else
        {
          unsigned int v23 = 0;
          if (v123) {
            goto LABEL_658;
          }
        }
      }
      else
      {
        int v121 = *v72;
        if (v117 == 1)
        {
          unsigned int v23 = v121 << 24;
        }
        else
        {
          int v125 = (v121 << 16) | (v72[1] << 8);
          if (v117 != 2) {
            v125 |= v72[2];
          }
          unsigned int v23 = v125 << 8;
        }
      }
    }
    else
    {
      unsigned int v23 = bswap32(*(_DWORD *)v72);
    }
    v23 <<= v24;
    goto LABEL_329;
  }
  uint64_t v118 = (v24 + 1) >> 3;
  int v24 = (v24 + 1) & 7;
  v72 += v118;
  int v119 = v26 - v72;
  if (v26 - (int)v72 >= 4)
  {
    unsigned int v120 = bswap32(*(_DWORD *)v72);
    goto LABEL_260;
  }
  if (v119 < 1)
  {
    int v124 = v24 | v119;
    if (a4)
    {
      if (v124) {
        goto LABEL_952;
      }
      unsigned int v23 = 0;
    }
    else
    {
      unsigned int v23 = 0;
      if (v124) {
        goto LABEL_658;
      }
    }
  }
  else
  {
    int v122 = *v72;
    if (v119 == 1)
    {
      unsigned int v120 = v122 << 24;
    }
    else
    {
      int v126 = (v122 << 16) | (v72[1] << 8);
      if (v119 != 2) {
        v126 |= v72[2];
      }
      unsigned int v120 = v126 << 8;
    }
LABEL_260:
    unsigned int v23 = v120 << v24;
  }
  int v127 = 0;
  unsigned int v128 = v23;
  while (2)
  {
    int v129 = (v24 + 1) & 7;
    v72 += (v24 + 1) >> 3;
    int v130 = v26 - v72;
    if (v26 - (int)v72 >= 4)
    {
      unsigned int v131 = bswap32(*(_DWORD *)v72);
      goto LABEL_274;
    }
    if (v130 < 1)
    {
      int v133 = v129 | v130;
      if (a4)
      {
        if (v133) {
          goto LABEL_952;
        }
        unsigned int v23 = 0;
        if ((v128 & 0x80000000) != 0) {
          goto LABEL_280;
        }
      }
      else
      {
        if (v133)
        {
LABEL_1131:
          unsigned int v23 = 0;
          goto LABEL_1132;
        }
        unsigned int v23 = 0;
        if ((v128 & 0x80000000) != 0) {
          goto LABEL_284;
        }
      }
      goto LABEL_275;
    }
    int v132 = *v72;
    if (v130 == 1)
    {
      unsigned int v131 = v132 << 24;
    }
    else
    {
      int v134 = (v132 << 16) | (v72[1] << 8);
      if (v130 != 2) {
        v134 |= v72[2];
      }
      unsigned int v131 = v134 << 8;
    }
LABEL_274:
    int v133 = v131 << v129;
    if ((v128 & 0x80000000) == 0)
    {
LABEL_275:
      --v127;
      unsigned int v128 = v133;
      int v24 = (v24 + 1) & 7;
      continue;
    }
    break;
  }
  unsigned int v23 = v133;
  if (!a4)
  {
LABEL_284:
    if (-v127 > 0x1E) {
      goto LABEL_1132;
    }
    if ((1 - v127) < 0x19) {
      goto LABEL_282;
    }
LABEL_286:
    int v138 = (((_BYTE)v24 + 1) & 7) - v127;
    int v24 = (v138 + 1) & 7;
    int v139 = &v72[(v138 - 15) >> 3];
    int v140 = v26 - v139;
    if (v26 - (int)v139 < 4)
    {
      if (v140 < 1)
      {
        int v145 = v24 | v140;
        if (a4)
        {
          if (v145) {
            goto LABEL_952;
          }
          unsigned int v146 = 0;
        }
        else
        {
          unsigned int v146 = 0;
          if (v145) {
            goto LABEL_438;
          }
        }
LABEL_307:
        int v72 = v139 + 2;
        int v149 = v26 - (v139 + 2);
        if (v149 < 4)
        {
          if (v149 < 1)
          {
            int v152 = v24 | v149;
            if (a4)
            {
              if (v152) {
                goto LABEL_952;
              }
              unsigned int v150 = 0;
            }
            else
            {
              unsigned int v150 = 0;
              if (v152) {
                goto LABEL_1140;
              }
            }
          }
          else
          {
            int v151 = *v72;
            if (v149 == 1)
            {
              unsigned int v150 = v151 << 24;
            }
            else
            {
              int v153 = (v151 << 16) | (v139[3] << 8);
              if (v149 != 2) {
                v153 |= v139[4];
              }
              unsigned int v150 = v153 << 8;
            }
          }
        }
        else
        {
          unsigned int v150 = bswap32(*(_DWORD *)v72);
        }
        unsigned int v155 = v23 >> (v127 + 47);
        unsigned int v23 = v150 << v24;
        int v154 = __PAIR64__(v155, v146) >> 16;
        goto LABEL_328;
      }
      int v143 = *v139;
      if (v140 == 1)
      {
        unsigned int v141 = v143 << 24;
      }
      else
      {
        int v148 = (v143 << 16) | (v139[1] << 8);
        if (v140 != 2) {
          v148 |= v139[2];
        }
        unsigned int v141 = v148 << 8;
      }
    }
    else
    {
      unsigned int v141 = bswap32(*(_DWORD *)v139);
    }
    unsigned int v146 = v141 << v24;
    goto LABEL_307;
  }
LABEL_280:
  if (-v127 > 0x1E) {
    goto LABEL_952;
  }
  if ((1 - v127) > 0x18) {
    goto LABEL_286;
  }
LABEL_282:
  unsigned int v135 = (((_BYTE)v24 + 1) & 7) - v127 + 1;
  int v24 = v135 & 7;
  v72 += v135 >> 3;
  int v136 = v26 - v72;
  if (v26 - (int)v72 >= 4)
  {
    unsigned int v137 = bswap32(*(_DWORD *)v72);
    goto LABEL_323;
  }
  if (v136 >= 1)
  {
    int v142 = *v72;
    if (v136 == 1)
    {
      unsigned int v137 = v142 << 24;
    }
    else
    {
      int v147 = (v142 << 16) | (v72[1] << 8);
      if (v136 != 2) {
        v147 |= v72[2];
      }
      unsigned int v137 = v147 << 8;
    }
    goto LABEL_323;
  }
  int v144 = v24 | v136;
  if (!a4)
  {
    unsigned int v137 = 0;
    if (!v144) {
      goto LABEL_323;
    }
LABEL_1140:
    uint64_t v22 = 4294954582;
    unsigned int v23 = 0;
    goto LABEL_659;
  }
  if (v144) {
    goto LABEL_952;
  }
  unsigned int v137 = 0;
LABEL_323:
  int v154 = v23 >> (v127 + 31);
  unsigned int v23 = v137 << v24;
LABEL_328:
  LODWORD(v458) = v154 + ~(-1 << (1 - v127));
LABEL_329:
  DWORD2(v458) = 0;
  int v156 = *(_DWORD *)(a3 + 40 * v87 + 16);
  if (v156) {
    goto LABEL_443;
  }
  int v157 = *(_DWORD *)(a3 + 40 * v87 + 20);
  unsigned int v158 = v157 - 22;
  if (a4)
  {
    if (v158 < 0xFFFFFFE7) {
      goto LABEL_952;
    }
  }
  else if (v158 < 0xFFFFFFE7)
  {
    goto LABEL_658;
  }
  DWORD1(v458) = v23 >> (28 - v157);
  unsigned int v159 = v24 + v157 + 4;
  int v24 = v159 & 7;
  v72 += v159 >> 3;
  int v160 = v26 - v72;
  if (v26 - (int)v72 < 4)
  {
    if (v160 < 1)
    {
      int v162 = v24 | v160;
      if (a4)
      {
        if (v162) {
          goto LABEL_952;
        }
        unsigned int v23 = 0;
      }
      else
      {
        unsigned int v23 = 0;
        if (v162) {
          goto LABEL_658;
        }
      }
    }
    else
    {
      int v161 = *v72;
      if (v160 == 1)
      {
        unsigned int v23 = v161 << 24;
      }
      else
      {
        int v163 = (v161 << 16) | (v72[1] << 8);
        if (v160 != 2) {
          v163 |= v72[2];
        }
        unsigned int v23 = v163 << 8;
      }
    }
  }
  else
  {
    unsigned int v23 = bswap32(*(_DWORD *)v72);
  }
  v23 <<= v24;
  if (!*(_DWORD *)(a3 + 52 * v80 + 1292) || v100) {
    goto LABEL_569;
  }
  if (v23 >= 0x80000)
  {
    unsigned int v164 = __clz(v23);
    unsigned int v165 = v23 << (v164 + 1) >> -(char)v164;
    if (!v164) {
      unsigned int v165 = 0;
    }
    unsigned int v166 = v164 + v24 + v164 + 1;
    int v24 = v166 & 7;
    v72 += v166 >> 3;
    int v167 = v26 - v72;
    if (v26 - (int)v72 < 4)
    {
      if (v167 < 1)
      {
        int v173 = v24 | v167;
        if (a4)
        {
          if (v173) {
            goto LABEL_952;
          }
          unsigned int v23 = 0;
        }
        else
        {
          unsigned int v23 = 0;
          if (v173) {
            goto LABEL_658;
          }
        }
      }
      else
      {
        int v171 = *v72;
        if (v167 == 1)
        {
          unsigned int v23 = v171 << 24;
        }
        else
        {
          int v175 = (v171 << 16) | (v72[1] << 8);
          if (v167 != 2) {
            v175 |= v72[2];
          }
          unsigned int v23 = v175 << 8;
        }
      }
    }
    else
    {
      unsigned int v23 = bswap32(*(_DWORD *)v72);
    }
    unsigned int v202 = v165 + ~(-1 << v164);
    v23 <<= v24;
    goto LABEL_442;
  }
  uint64_t v168 = (v24 + 1) >> 3;
  int v24 = (v24 + 1) & 7;
  v72 += v168;
  int v169 = v26 - v72;
  if (v26 - (int)v72 >= 4)
  {
    unsigned int v170 = bswap32(*(_DWORD *)v72);
    goto LABEL_373;
  }
  if (v169 < 1)
  {
    int v174 = v24 | v169;
    if (a4)
    {
      if (v174) {
        goto LABEL_952;
      }
      unsigned int v23 = 0;
    }
    else
    {
      unsigned int v23 = 0;
      if (v174) {
        goto LABEL_658;
      }
    }
  }
  else
  {
    int v172 = *v72;
    if (v169 == 1)
    {
      unsigned int v170 = v172 << 24;
    }
    else
    {
      int v176 = (v172 << 16) | (v72[1] << 8);
      if (v169 != 2) {
        v176 |= v72[2];
      }
      unsigned int v170 = v176 << 8;
    }
LABEL_373:
    unsigned int v23 = v170 << v24;
  }
  int v177 = 0;
  unsigned int v178 = v23;
  while (2)
  {
    int v129 = (v24 + 1) & 7;
    v72 += (v24 + 1) >> 3;
    int v179 = v26 - v72;
    if (v26 - (int)v72 >= 4)
    {
      unsigned int v180 = bswap32(*(_DWORD *)v72);
      goto LABEL_387;
    }
    if (v179 < 1)
    {
      int v182 = v129 | v179;
      if (a4)
      {
        if (v182) {
          goto LABEL_952;
        }
        unsigned int v23 = 0;
        if ((v178 & 0x80000000) != 0) {
          goto LABEL_393;
        }
      }
      else
      {
        if (v182) {
          goto LABEL_1131;
        }
        unsigned int v23 = 0;
        if ((v178 & 0x80000000) != 0) {
          goto LABEL_397;
        }
      }
      goto LABEL_388;
    }
    int v181 = *v72;
    if (v179 == 1)
    {
      unsigned int v180 = v181 << 24;
    }
    else
    {
      int v183 = (v181 << 16) | (v72[1] << 8);
      if (v179 != 2) {
        v183 |= v72[2];
      }
      unsigned int v180 = v183 << 8;
    }
LABEL_387:
    int v182 = v180 << v129;
    if ((v178 & 0x80000000) == 0)
    {
LABEL_388:
      --v177;
      unsigned int v178 = v182;
      int v24 = (v24 + 1) & 7;
      continue;
    }
    break;
  }
  unsigned int v23 = v182;
  if (!a4)
  {
LABEL_397:
    if (-v177 <= 0x1E)
    {
      if ((1 - v177) < 0x19) {
        goto LABEL_395;
      }
      goto LABEL_399;
    }
LABEL_1132:
    uint64_t v22 = 4294954582;
    LOBYTE(v24) = v129;
    goto LABEL_659;
  }
LABEL_393:
  if (-v177 > 0x1E) {
    goto LABEL_952;
  }
  if ((1 - v177) > 0x18)
  {
LABEL_399:
    int v187 = (((_BYTE)v24 + 1) & 7) - v177;
    int v24 = (v187 + 1) & 7;
    int v139 = &v72[(v187 - 15) >> 3];
    int v188 = v26 - v139;
    if (v26 - (int)v139 >= 4)
    {
      unsigned int v189 = bswap32(*(_DWORD *)v139);
LABEL_419:
      unsigned int v194 = v189 << v24;
      goto LABEL_420;
    }
    if (v188 >= 1)
    {
      int v191 = *v139;
      if (v188 == 1)
      {
        unsigned int v189 = v191 << 24;
      }
      else
      {
        int v196 = (v191 << 16) | (v139[1] << 8);
        if (v188 != 2) {
          v196 |= v139[2];
        }
        unsigned int v189 = v196 << 8;
      }
      goto LABEL_419;
    }
    int v193 = v24 | v188;
    if (a4)
    {
      if (v193) {
        goto LABEL_952;
      }
      unsigned int v194 = 0;
LABEL_420:
      int v72 = v139 + 2;
      int v197 = v26 - (v139 + 2);
      if (v197 < 4)
      {
        if (v197 < 1)
        {
          int v200 = v24 | v197;
          if (a4)
          {
            if (v200) {
              goto LABEL_952;
            }
            unsigned int v198 = 0;
          }
          else
          {
            unsigned int v198 = 0;
            if (v200) {
              goto LABEL_1140;
            }
          }
        }
        else
        {
          int v199 = *v72;
          if (v197 == 1)
          {
            unsigned int v198 = v199 << 24;
          }
          else
          {
            int v201 = (v199 << 16) | (v139[3] << 8);
            if (v197 != 2) {
              v201 |= v139[4];
            }
            unsigned int v198 = v201 << 8;
          }
        }
      }
      else
      {
        unsigned int v198 = bswap32(*(_DWORD *)v72);
      }
      unsigned int v204 = v23 >> (v177 + 47);
      unsigned int v23 = v198 << v24;
      int v203 = __PAIR64__(v204, v194) >> 16;
      goto LABEL_441;
    }
    unsigned int v194 = 0;
    if (!v193) {
      goto LABEL_420;
    }
LABEL_438:
    uint64_t v22 = 4294954582;
    unsigned int v23 = 0;
    BytePtr = v139;
    goto LABEL_973;
  }
LABEL_395:
  unsigned int v184 = (((_BYTE)v24 + 1) & 7) - v177 + 1;
  int v24 = v184 & 7;
  v72 += v184 >> 3;
  int v185 = v26 - v72;
  if (v26 - (int)v72 >= 4)
  {
    unsigned int v186 = bswap32(*(_DWORD *)v72);
    goto LABEL_436;
  }
  if (v185 >= 1)
  {
    int v190 = *v72;
    if (v185 == 1)
    {
      unsigned int v186 = v190 << 24;
    }
    else
    {
      int v195 = (v190 << 16) | (v72[1] << 8);
      if (v185 != 2) {
        v195 |= v72[2];
      }
      unsigned int v186 = v195 << 8;
    }
    goto LABEL_436;
  }
  int v192 = v24 | v185;
  if (!a4)
  {
    unsigned int v186 = 0;
    if (!v192) {
      goto LABEL_436;
    }
    goto LABEL_1140;
  }
  if (v192) {
    goto LABEL_952;
  }
  unsigned int v186 = 0;
LABEL_436:
  int v203 = v23 >> (v177 + 31);
  unsigned int v23 = v186 << v24;
LABEL_441:
  unsigned int v202 = v203 + ~(-1 << (1 - v177));
LABEL_442:
  DWORD2(v458) = ((v202 + 1) >> 1) - ((v202 + 1) >> 1) * 2 * ((v202 + 1) & 1);
LABEL_443:
  if (v156 != 1 || *(_DWORD *)(a3 + 40 * v87 + 24)) {
    goto LABEL_569;
  }
  if (v23 >= 0x80000)
  {
    unsigned int v205 = v24 + 2 * __clz(v23) + 1;
LABEL_486:
    int v24 = v205 & 7;
    v72 += v205 >> 3;
    int v224 = v26 - v72;
    if (v26 - (int)v72 >= 4) {
      goto LABEL_499;
    }
    if (v224 >= 1)
    {
      int v225 = *v72;
      if (v224 == 1)
      {
        unsigned int v23 = v225 << 24;
      }
      else
      {
        int v227 = (v225 << 16) | (v72[1] << 8);
        if (v224 != 2) {
          v227 |= v72[2];
        }
        unsigned int v23 = v227 << 8;
      }
      goto LABEL_500;
    }
    int v226 = v24 | v224;
    if (!a4) {
      goto LABEL_513;
    }
LABEL_491:
    if (v226) {
      goto LABEL_952;
    }
    unsigned int v23 = 0;
    goto LABEL_500;
  }
  uint64_t v206 = (v24 + 1) >> 3;
  int v24 = (v24 + 1) & 7;
  v72 += v206;
  int v207 = v26 - v72;
  if (v26 - (int)v72 >= 4)
  {
    unsigned int v208 = bswap32(*(_DWORD *)v72);
    goto LABEL_458;
  }
  if (v207 < 1)
  {
    int v210 = v24 | v207;
    if (a4)
    {
      if (v210) {
        goto LABEL_952;
      }
      unsigned int v23 = 0;
    }
    else
    {
      unsigned int v23 = 0;
      if (v210) {
        goto LABEL_658;
      }
    }
  }
  else
  {
    int v209 = *v72;
    if (v207 == 1)
    {
      unsigned int v208 = v209 << 24;
    }
    else
    {
      int v211 = (v209 << 16) | (v72[1] << 8);
      if (v207 != 2) {
        v211 |= v72[2];
      }
      unsigned int v208 = v211 << 8;
    }
LABEL_458:
    unsigned int v23 = v208 << v24;
  }
  unsigned int v212 = 1;
  unsigned int v213 = v23;
  while (2)
  {
    int v214 = (v24 + 1) & 7;
    v72 += (v24 + 1) >> 3;
    int v215 = v26 - v72;
    if (v26 - (int)v72 >= 4)
    {
      unsigned int v216 = bswap32(*(_DWORD *)v72);
      goto LABEL_472;
    }
    if (v215 < 1)
    {
      int v218 = v214 | v215;
      if (a4)
      {
        if (v218) {
          goto LABEL_952;
        }
        if ((v213 & 0x80000000) != 0) {
          goto LABEL_478;
        }
        int v218 = 0;
      }
      else
      {
        if (v218)
        {
LABEL_1136:
          unsigned int v23 = 0;
          goto LABEL_1137;
        }
        unsigned int v23 = 0;
        if ((v213 & 0x80000000) != 0) {
          goto LABEL_483;
        }
      }
      goto LABEL_473;
    }
    int v217 = *v72;
    if (v215 == 1)
    {
      unsigned int v216 = v217 << 24;
    }
    else
    {
      int v219 = (v217 << 16) | (v72[1] << 8);
      if (v215 != 2) {
        v219 |= v72[2];
      }
      unsigned int v216 = v219 << 8;
    }
LABEL_472:
    int v218 = v216 << v214;
    if ((v213 & 0x80000000) == 0)
    {
LABEL_473:
      ++v212;
      unsigned int v213 = v218;
      int v24 = (v24 + 1) & 7;
      continue;
    }
    break;
  }
  unsigned int v23 = v218;
  if (!a4)
  {
LABEL_483:
    if (v212 - 1 > 0x1E) {
      goto LABEL_1137;
    }
    if (v212 >= 0x19)
    {
      unsigned int v228 = (((_BYTE)v24 + 1) & 7) + v212;
      uint64_t v229 = (v228 - 16) >> 3;
      int v24 = v228 & 7;
      long long v222 = &v72[v229];
      int v230 = v26 - (v72 + v229);
      if (v230 > 0 || !(v24 | v230)) {
        goto LABEL_498;
      }
      goto LABEL_1141;
    }
LABEL_485:
    unsigned int v205 = (((_BYTE)v24 + 1) & 7) + v212;
    goto LABEL_486;
  }
LABEL_478:
  if (v212 - 1 > 0x1E) {
    goto LABEL_952;
  }
  if (v212 <= 0x18) {
    goto LABEL_485;
  }
  unsigned int v220 = (((_BYTE)v24 + 1) & 7) + v212;
  uint64_t v221 = (v220 - 16) >> 3;
  int v24 = v220 & 7;
  long long v222 = &v72[v221];
  int v223 = v26 - (v72 + v221);
  if (v223 <= 0 && v24 | v223)
  {
LABEL_952:
    LODWORD(v22) = -12714;
    goto LABEL_974;
  }
LABEL_498:
  int v72 = v222 + 2;
  int v231 = v26 - (v222 + 2);
  if (v231 >= 4)
  {
LABEL_499:
    unsigned int v23 = bswap32(*(_DWORD *)v72);
    goto LABEL_500;
  }
  if (v231 >= 1)
  {
    int v233 = *v72;
    if (v231 == 1)
    {
      unsigned int v23 = v233 << 24;
    }
    else
    {
      int v238 = (v233 << 16) | (v222[3] << 8);
      if (v231 != 2) {
        v238 |= v222[4];
      }
      unsigned int v23 = v238 << 8;
    }
    goto LABEL_500;
  }
  int v226 = v24 | v231;
  if (a4) {
    goto LABEL_491;
  }
LABEL_513:
  unsigned int v23 = 0;
  if (v226) {
    goto LABEL_658;
  }
LABEL_500:
  v23 <<= v24;
  if (*(_DWORD *)(a3 + 52 * v80 + 1292) != 1 || BYTE12(v457)) {
    goto LABEL_569;
  }
  if (v23 >= 0x80000)
  {
    unsigned int v232 = v24 + 2 * __clz(v23) + 1;
LABEL_554:
    int v24 = v232 & 7;
    v72 += v232 >> 3;
    int v251 = v26 - v72;
    if (v26 - (int)v72 >= 4) {
      goto LABEL_567;
    }
    if (v251 >= 1)
    {
      int v252 = *v72;
      if (v251 == 1)
      {
        unsigned int v23 = v252 << 24;
      }
      else
      {
        int v254 = (v252 << 16) | (v72[1] << 8);
        if (v251 != 2) {
          v254 |= v72[2];
        }
        unsigned int v23 = v254 << 8;
      }
      goto LABEL_568;
    }
    int v253 = v24 | v251;
    if (!a4) {
      goto LABEL_1122;
    }
LABEL_559:
    if (v253) {
      goto LABEL_952;
    }
    unsigned int v23 = 0;
LABEL_568:
    v23 <<= v24;
LABEL_569:
    HIDWORD(v458) = 0;
    if (*(_DWORD *)(a3 + 52 * v80 + 1328))
    {
      if (a4)
      {
        if (v23 < 0x80000) {
          goto LABEL_952;
        }
      }
      else if (v23 < 0x80000)
      {
        goto LABEL_658;
      }
      unsigned int v259 = __clz(v23);
      unsigned int v260 = v23 << (v259 + 1) >> -(char)v259;
      if (!v259) {
        unsigned int v260 = 0;
      }
      HIDWORD(v458) = v260 + ~(-1 << v259);
      unsigned int v261 = v259 + v24 + v259 + 1;
      int v24 = v261 & 7;
      v72 += v261 >> 3;
      int v262 = v26 - v72;
      if (v26 - (int)v72 < 4)
      {
        if (v262 < 1)
        {
          int v264 = v24 | v262;
          if (a4)
          {
            if (v264) {
              goto LABEL_952;
            }
            unsigned int v23 = 0;
          }
          else
          {
            unsigned int v23 = 0;
            if (v264) {
              goto LABEL_658;
            }
          }
        }
        else
        {
          int v263 = *v72;
          if (v262 == 1)
          {
            unsigned int v23 = v263 << 24;
          }
          else
          {
            int v265 = (v263 << 16) | (v72[1] << 8);
            if (v262 != 2) {
              v265 |= v72[2];
            }
            unsigned int v23 = v265 << 8;
          }
        }
      }
      else
      {
        unsigned int v23 = bswap32(*(_DWORD *)v72);
      }
      v23 <<= v24;
    }
    if (v69 == 6 || v69 == 1)
    {
      LOBYTE(v459) = (v23 & 0x80000000) != 0;
      uint64_t v266 = (v24 + 1) >> 3;
      int v24 = (v24 + 1) & 7;
      v72 += v266;
      int v267 = v26 - v72;
      if (v26 - (int)v72 < 4)
      {
        if (v267 < 1)
        {
          int v270 = v24 | v267;
          if (a4)
          {
            if (v270) {
              goto LABEL_952;
            }
            unsigned int v23 = 0;
          }
          else
          {
            unsigned int v23 = 0;
            if (v270) {
              goto LABEL_658;
            }
          }
        }
        else
        {
          int v269 = *v72;
          if (v267 == 1)
          {
            unsigned int v23 = v269 << 24;
          }
          else
          {
            int v271 = (v269 << 16) | (v72[1] << 8);
            if (v267 != 2) {
              v271 |= v72[2];
            }
            unsigned int v23 = v271 << 8;
          }
        }
      }
      else
      {
        unsigned int v23 = bswap32(*(_DWORD *)v72);
      }
      int v268 = v23 << v24;
    }
    else
    {
      int v268 = v23;
    }
    if (v69 > 8 || ((1 << v69) & 0x16B) == 0) {
      goto LABEL_627;
    }
    BYTE1(v459) = v268 < 0;
    uint64_t v272 = (v24 + 1) >> 3;
    int v24 = (v24 + 1) & 7;
    v72 += v272;
    int v273 = v26 - v72;
    if (v26 - (int)v72 >= 4)
    {
      unsigned int v274 = bswap32(*(_DWORD *)v72);
      goto LABEL_624;
    }
    if (v273 < 1)
    {
      if (v24 | v273) {
        BOOL v276 = 1;
      }
      else {
        BOOL v276 = v268 < 0;
      }
      char v277 = !v276;
      if (a4)
      {
        if ((v277 & 1) == 0) {
          goto LABEL_952;
        }
        unsigned int v23 = 0;
      }
      else
      {
        unsigned int v23 = 0;
        if ((v277 & 1) == 0) {
          goto LABEL_658;
        }
      }
      goto LABEL_625;
    }
    int v275 = *v72;
    if (v273 == 1)
    {
      unsigned int v274 = v275 << 24;
    }
    else
    {
      int v278 = (v275 << 16) | (v72[1] << 8);
      if (v273 != 2) {
        v278 |= v72[2];
      }
      unsigned int v274 = v278 << 8;
    }
LABEL_624:
    unsigned int v23 = v274 << v24;
    if ((v268 & 0x80000000) == 0)
    {
LABEL_625:
      *(void *)((char *)&v459 + 4) = *(void *)(a3 + 52 * v80 + 1308);
      goto LABEL_626;
    }
    if (a4)
    {
      if (v23 < 0x80000) {
        goto LABEL_952;
      }
    }
    else if (v23 < 0x80000)
    {
      goto LABEL_658;
    }
    unsigned int v285 = __clz(v23);
    unsigned int v286 = v23 << (v285 + 1) >> -(char)v285;
    if (!v285) {
      unsigned int v286 = 0;
    }
    unsigned int v287 = v286 + ~(-1 << v285);
    DWORD1(v459) = v287;
    unsigned int v288 = v285 + v24 + v285 + 1;
    int v24 = v288 & 7;
    v72 += v288 >> 3;
    int v289 = v26 - v72;
    if (v26 - (int)v72 >= 4)
    {
      unsigned int v290 = bswap32(*(_DWORD *)v72);
      goto LABEL_759;
    }
    if (v289 < 1)
    {
      int v294 = v24 | v289;
      if (a4)
      {
        if (v294) {
          goto LABEL_952;
        }
        unsigned int v23 = 0;
        goto LABEL_760;
      }
      unsigned int v23 = 0;
      if (v294) {
        goto LABEL_658;
      }
    }
    else
    {
      int v291 = *v72;
      if (v289 == 1)
      {
        unsigned int v290 = v291 << 24;
      }
      else
      {
        int v329 = (v291 << 16) | (v72[1] << 8);
        if (v289 != 2) {
          v329 |= v72[2];
        }
        unsigned int v290 = v329 << 8;
      }
LABEL_759:
      unsigned int v23 = v290 << v24;
      if (a4)
      {
LABEL_760:
        if (v287 > 0x1F) {
          goto LABEL_1007;
        }
LABEL_986:
        if (v69 != 6 && v69 != 1) {
          goto LABEL_626;
        }
        if (a4)
        {
          if (v23 < 0x80000) {
            goto LABEL_952;
          }
        }
        else if (v23 < 0x80000)
        {
          goto LABEL_658;
        }
        unsigned int v403 = __clz(v23);
        unsigned int v404 = v23 << (v403 + 1) >> -(char)v403;
        if (!v403) {
          unsigned int v404 = 0;
        }
        unsigned int v405 = v404 + ~(-1 << v403);
        DWORD2(v459) = v405;
        unsigned int v406 = v403 + v24 + v403 + 1;
        int v24 = v406 & 7;
        v72 += v406 >> 3;
        int v407 = v26 - v72;
        if (v26 - (int)v72 >= 4)
        {
          unsigned int v408 = bswap32(*(_DWORD *)v72);
          goto LABEL_1005;
        }
        if (v407 < 1)
        {
          int v410 = v24 | v407;
          if (a4)
          {
            if (v410) {
              goto LABEL_952;
            }
            unsigned int v23 = 0;
            goto LABEL_1006;
          }
          unsigned int v23 = 0;
          if (v410) {
            goto LABEL_658;
          }
        }
        else
        {
          int v409 = *v72;
          if (v407 == 1)
          {
            unsigned int v408 = v409 << 24;
          }
          else
          {
            int v411 = (v409 << 16) | (v72[1] << 8);
            if (v407 != 2) {
              v411 |= v72[2];
            }
            unsigned int v408 = v411 << 8;
          }
LABEL_1005:
          unsigned int v23 = v408 << v24;
          if (a4)
          {
LABEL_1006:
            int v268 = v23;
            if (v405 > 0x1F)
            {
LABEL_1007:
              LODWORD(v22) = -12719;
              goto LABEL_974;
            }
LABEL_627:
            if (((1 << v69) & 0x294) != 0)
            {
LABEL_628:
              if (v69 != 6 && v69 != 1) {
                goto LABEL_666;
              }
              BYTE13(v459) = v268 < 0;
              uint64_t v279 = (v24 + 1) >> 3;
              int v24 = (v24 + 1) & 7;
              v72 += v279;
              int v280 = v26 - v72;
              if (v26 - (int)v72 < 4)
              {
                if (v280 < 1)
                {
                  int v284 = v24 | v280;
                  if (a4)
                  {
                    if (v284) {
                      goto LABEL_952;
                    }
                    unsigned int v23 = 0;
                  }
                  else
                  {
                    unsigned int v23 = 0;
                    if (v284) {
                      goto LABEL_658;
                    }
                  }
                }
                else
                {
                  int v281 = *v72;
                  if (v280 == 1)
                  {
                    unsigned int v23 = v281 << 24;
                  }
                  else
                  {
                    int v292 = (v281 << 16) | (v72[1] << 8);
                    if (v280 != 2) {
                      v292 |= v72[2];
                    }
                    unsigned int v23 = v292 << 8;
                  }
                }
              }
              else
              {
                unsigned int v23 = bswap32(*(_DWORD *)v72);
              }
              v23 <<= v24;
              if ((v268 & 0x80000000) == 0)
              {
LABEL_665:
                int v268 = v23;
LABEL_666:
                uint64_t v295 = a3 + 52 * v80;
                int v450 = v87;
                if ((!*(_DWORD *)(v295 + 1316) || v69 > 8 || ((1 << v69) & 0x129) == 0)
                  && (*(_DWORD *)(a3 + 52 * v80 + 1320) != 1 || v69 != 6 && v69 != 1))
                {
                  int v298 = (int)BytePtr;
                  goto LABEL_719;
                }
                *(void *)&long long v455 = v72;
                DWORD2(v455) = v268;
                int v296 = v72 - BytePtr;
                BYTE12(v455) = v24;
                if (a4)
                {
                  if (Length < v296) {
                    goto LABEL_952;
                  }
                  int v297 = a4;
                  goto LABEL_717;
                }
                if (Length >= v296)
                {
                  int v297 = 0;
LABEL_717:
                  int v313 = PullSliceHeaderPredWeightTable((uint64_t *)&v454, &v456, (uint64_t)v88, v297);
                  if (v313)
                  {
                    LODWORD(v22) = v313;
                    goto LABEL_974;
                  }
                  int v72 = (unsigned __int8 *)v455;
                  int v268 = DWORD2(v455);
                  int v24 = BYTE12(v455);
                  int Length = DWORD2(v454);
                  int v298 = v454;
LABEL_719:
                  int v314 = v298 + Length;
                  if (!v456)
                  {
                    unsigned int v23 = v268;
                    BytePtr = v72;
                    goto LABEL_856;
                  }
                  uint64_t v315 = (v24 + 1) >> 3;
                  int v24 = (v24 + 1) & 7;
                  BytePtr = &v72[v315];
                  int v316 = v314 - (v72 + v315);
                  if (DWORD1(v456) == 5)
                  {
                    BYTE13(v468) = v268 < 0;
                    if (v316 >= 4)
                    {
                      unsigned int v317 = bswap32(*(_DWORD *)BytePtr);
                      goto LABEL_741;
                    }
                    if (v316 < 1)
                    {
                      int v320 = v24 | v316;
                      if (a4)
                      {
                        if (v320) {
                          goto LABEL_952;
                        }
                        unsigned int v23 = 0;
                        goto LABEL_742;
                      }
                      unsigned int v23 = 0;
                      if (!v320) {
                        goto LABEL_742;
                      }
                    }
                    else
                    {
                      int v318 = *BytePtr;
                      if (v316 == 1)
                      {
                        unsigned int v317 = v318 << 24;
                      }
                      else
                      {
                        int v322 = (v318 << 16) | (BytePtr[1] << 8);
                        if (v316 != 2) {
                          v322 |= BytePtr[2];
                        }
                        unsigned int v317 = v322 << 8;
                      }
LABEL_741:
                      unsigned int v23 = v317 << v24;
LABEL_742:
                      BYTE14(v468) = (v23 & 0x80000000) != 0;
                      uint64_t v323 = (v24 + 1) >> 3;
                      int v24 = (v24 + 1) & 7;
                      BytePtr += v323;
                      int v324 = v314 - BytePtr;
                      if (v314 - (int)BytePtr >= 4)
                      {
                        unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                        goto LABEL_855;
                      }
                      if (v324 >= 1)
                      {
                        int v325 = *BytePtr;
                        if (v324 == 1)
                        {
                          unsigned int v23 = v325 << 24;
                        }
                        else
                        {
                          int v328 = (v325 << 16) | (BytePtr[1] << 8);
                          if (v324 != 2) {
                            v328 |= BytePtr[2];
                          }
                          unsigned int v23 = v328 << 8;
                        }
                        goto LABEL_855;
                      }
                      int v326 = v24 | v324;
                      if (a4)
                      {
                        if (v326) {
                          goto LABEL_952;
                        }
                        unsigned int v23 = 0;
LABEL_855:
                        v23 <<= v24;
LABEL_856:
                        int v356 = *(_DWORD *)(a3 + 52 * v80 + 1288);
                        BYTE4(v471) = v356;
                        if (!*(_DWORD *)(v295 + 1316) || (LOBYTE(v357) = 1, v457) && v457 != 5)
                        {
                          int v357 = *(_DWORD *)(a3 + 52 * v80 + 1320);
                          if (v357) {
                            LOBYTE(v357) = v457 == 1 || v457 == 6;
                          }
                        }
                        BYTE5(v471) = v357;
                        if (!v356 || v457 <= 9 && ((1 << v457) & 0x294) != 0)
                        {
                          LOBYTE(v359) = 0;
                          goto LABEL_870;
                        }
                        if (a4)
                        {
                          if (v23 < 0x80000) {
                            goto LABEL_952;
                          }
LABEL_904:
                          unsigned int v372 = __clz(v23);
                          unsigned int v373 = v23 << (v372 + 1) >> -(char)v372;
                          if (!v372) {
                            unsigned int v373 = 0;
                          }
                          unsigned int v374 = v372 + v24 + v372 + 1;
                          int v24 = v374 & 7;
                          BytePtr += v374 >> 3;
                          int v375 = v298 + Length - BytePtr;
                          if (v375 >= 4)
                          {
                            unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                            goto LABEL_1117;
                          }
                          if (v375 >= 1)
                          {
                            int v376 = *BytePtr;
                            if (v375 == 1)
                            {
                              unsigned int v23 = v376 << 24;
                            }
                            else
                            {
                              int v412 = (v376 << 16) | (BytePtr[1] << 8);
                              if (v375 != 2) {
                                v412 |= BytePtr[2];
                              }
                              unsigned int v23 = v412 << 8;
                            }
                            goto LABEL_1117;
                          }
                          int v402 = v24 | v375;
                          if (a4)
                          {
                            if (v402) {
                              goto LABEL_952;
                            }
                            unsigned int v23 = 0;
                            goto LABEL_1117;
                          }
                          unsigned int v23 = 0;
                          if (!v402)
                          {
LABEL_1117:
                            unsigned int v359 = v373 + ~(-1 << v372);
                            v23 <<= v24;
LABEL_870:
                            BYTE4(v469) = v359;
                            if (a4)
                            {
                              if (v23 < 0x80000) {
                                goto LABEL_952;
                              }
LABEL_874:
                              unsigned int v360 = __clz(v23);
                              unsigned int v361 = v23 << (v360 + 1) >> -(char)v360;
                              if (!v360) {
                                unsigned int v361 = 0;
                              }
                              unsigned int v362 = v360 + v24 + v360 + 1;
                              int v24 = v362 & 7;
                              BytePtr += v362 >> 3;
                              int v363 = v314 - BytePtr;
                              if (v314 - (int)BytePtr >= 4)
                              {
                                unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                                goto LABEL_891;
                              }
                              if (v363 >= 1)
                              {
                                int v364 = *BytePtr;
                                if (v363 == 1)
                                {
                                  unsigned int v23 = v364 << 24;
                                }
                                else
                                {
                                  int v366 = (v364 << 16) | (BytePtr[1] << 8);
                                  if (v363 != 2) {
                                    v366 |= BytePtr[2];
                                  }
                                  unsigned int v23 = v366 << 8;
                                }
                                goto LABEL_891;
                              }
                              int v365 = v24 | v363;
                              if (a4)
                              {
                                if (v365) {
                                  goto LABEL_952;
                                }
                                unsigned int v23 = 0;
                                goto LABEL_891;
                              }
                              unsigned int v23 = 0;
                              if (!v365)
                              {
LABEL_891:
                                v23 <<= v24;
                                DWORD2(v469) = ((v361 + (1 << v360)) >> 1)
                                             - ((v361 + (1 << v360)) >> 1) * 2 * ((v361 + (1 << v360)) & 1);
                                switch((int)v457)
                                {
                                  case 3:
                                  case 8:
                                    BYTE12(v469) = (v23 & 0x80000000) != 0;
                                    uint64_t v367 = (v24 + 1) >> 3;
                                    int v24 = (v24 + 1) & 7;
                                    BytePtr += v367;
                                    int v368 = v314 - BytePtr;
                                    if (v314 - (int)BytePtr < 4)
                                    {
                                      if (v368 < 1)
                                      {
                                        int v370 = v24 | v368;
                                        if (a4)
                                        {
                                          if (v370) {
                                            goto LABEL_952;
                                          }
                                          unsigned int v23 = 0;
                                        }
                                        else
                                        {
                                          unsigned int v23 = 0;
                                          if (v370) {
                                            goto LABEL_972;
                                          }
                                        }
                                      }
                                      else
                                      {
                                        int v369 = *BytePtr;
                                        if (v368 == 1)
                                        {
                                          unsigned int v23 = v369 << 24;
                                        }
                                        else
                                        {
                                          int v371 = (v369 << 16) | (BytePtr[1] << 8);
                                          if (v368 != 2) {
                                            v371 |= BytePtr[2];
                                          }
                                          unsigned int v23 = v371 << 8;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                                    }
                                    v23 <<= v24;
                                    goto LABEL_913;
                                  case 4:
                                  case 9:
LABEL_913:
                                    if (a4)
                                    {
                                      if (v23 < 0x80000) {
                                        goto LABEL_952;
                                      }
                                    }
                                    else if (v23 < 0x80000)
                                    {
                                      goto LABEL_972;
                                    }
                                    unsigned int v377 = __clz(v23);
                                    unsigned int v378 = v23 << (v377 + 1) >> -(char)v377;
                                    if (!v377) {
                                      unsigned int v378 = 0;
                                    }
                                    unsigned int v379 = v377 + v24 + v377 + 1;
                                    int v24 = v379 & 7;
                                    BytePtr += v379 >> 3;
                                    int v380 = v314 - BytePtr;
                                    if (v314 - (int)BytePtr < 4)
                                    {
                                      if (v380 < 1)
                                      {
                                        int v382 = v24 | v380;
                                        if (a4)
                                        {
                                          if (v382) {
                                            goto LABEL_952;
                                          }
                                          unsigned int v23 = 0;
                                        }
                                        else
                                        {
                                          unsigned int v23 = 0;
                                          if (v382) {
                                            goto LABEL_972;
                                          }
                                        }
                                      }
                                      else
                                      {
                                        int v381 = *BytePtr;
                                        if (v380 == 1)
                                        {
                                          unsigned int v23 = v381 << 24;
                                        }
                                        else
                                        {
                                          int v383 = (v381 << 16) | (BytePtr[1] << 8);
                                          if (v380 != 2) {
                                            v383 |= BytePtr[2];
                                          }
                                          unsigned int v23 = v383 << 8;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                                    }
                                    v23 <<= v24;
                                    LODWORD(v470) = ((v378 + (1 << v377)) >> 1)
                                                  - ((v378 + (1 << v377)) >> 1) * 2 * ((v378 + (1 << v377)) & 1);
LABEL_932:
                                    *((void *)&v470 + 1) = 0;
                                    DWORD1(v470) = 0;
                                    if (!*(_DWORD *)(a3 + 52 * v80 + 1324)) {
                                      goto LABEL_1031;
                                    }
                                    if (a4)
                                    {
                                      if (v23 < 0x80000) {
                                        goto LABEL_952;
                                      }
                                    }
                                    else if (v23 < 0x80000)
                                    {
                                      goto LABEL_972;
                                    }
                                    unsigned int v384 = __clz(v23);
                                    unsigned int v385 = v23 << (v384 + 1) >> -(char)v384;
                                    if (!v384) {
                                      unsigned int v385 = 0;
                                    }
                                    unsigned int v386 = v385 + ~(-1 << v384);
                                    DWORD1(v470) = v386;
                                    unsigned int v387 = v384 + v24 + v384 + 1;
                                    int v24 = v387 & 7;
                                    BytePtr += v387 >> 3;
                                    int v388 = v314 - BytePtr;
                                    if (v314 - (int)BytePtr < 4)
                                    {
                                      if (v388 < 1)
                                      {
                                        if (v24 | v388) {
                                          BOOL v391 = 0;
                                        }
                                        else {
                                          BOOL v391 = v386 == 1;
                                        }
                                        char v392 = v391;
                                        if (a4)
                                        {
                                          if ((v392 & 1) == 0) {
                                            goto LABEL_952;
                                          }
                                          unsigned int v23 = 0;
                                        }
                                        else
                                        {
                                          unsigned int v23 = 0;
                                          if ((v392 & 1) == 0) {
                                            goto LABEL_972;
                                          }
                                        }
                                        goto LABEL_1031;
                                      }
                                      int v390 = *BytePtr;
                                      if (v388 == 1)
                                      {
                                        unsigned int v389 = v390 << 24;
                                      }
                                      else
                                      {
                                        int v393 = (v390 << 16) | (BytePtr[1] << 8);
                                        if (v388 != 2) {
                                          v393 |= BytePtr[2];
                                        }
                                        unsigned int v389 = v393 << 8;
                                      }
                                    }
                                    else
                                    {
                                      unsigned int v389 = bswap32(*(_DWORD *)BytePtr);
                                    }
                                    unsigned int v23 = v389 << v24;
                                    if (v386 != 1)
                                    {
                                      if (a4)
                                      {
                                        if (v23 < 0x80000) {
                                          goto LABEL_952;
                                        }
                                      }
                                      else if (v23 < 0x80000)
                                      {
                                        goto LABEL_972;
                                      }
                                      unsigned int v394 = __clz(v23);
                                      unsigned int v395 = v23 << (v394 + 1) >> -(char)v394;
                                      if (!v394) {
                                        unsigned int v395 = 0;
                                      }
                                      unsigned int v396 = v394 + v24 + v394 + 1;
                                      int v24 = v396 & 7;
                                      BytePtr += v396 >> 3;
                                      int v397 = v314 - BytePtr;
                                      if (v314 - (int)BytePtr < 4)
                                      {
                                        if (v397 < 1)
                                        {
                                          int v399 = v24 | v397;
                                          if (a4)
                                          {
                                            if (v399) {
                                              goto LABEL_952;
                                            }
                                            unsigned int v23 = 0;
                                          }
                                          else
                                          {
                                            unsigned int v23 = 0;
                                            if (v399) {
                                              goto LABEL_972;
                                            }
                                          }
                                        }
                                        else
                                        {
                                          int v398 = *BytePtr;
                                          if (v397 == 1)
                                          {
                                            unsigned int v23 = v398 << 24;
                                          }
                                          else
                                          {
                                            int v401 = (v398 << 16) | (BytePtr[1] << 8);
                                            if (v397 != 2) {
                                              v401 |= BytePtr[2];
                                            }
                                            unsigned int v23 = v401 << 8;
                                          }
                                        }
                                      }
                                      else
                                      {
                                        unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                                      }
                                      v23 <<= v24;
                                      DWORD2(v470) = ((v395 + (1 << v394)) >> 1)
                                                   - ((v395 + (1 << v394)) >> 1) * 2 * ((v395 + (1 << v394)) & 1);
                                      if (a4)
                                      {
                                        if (v23 < 0x80000) {
                                          goto LABEL_952;
                                        }
                                      }
                                      else if (v23 < 0x80000)
                                      {
                                        goto LABEL_972;
                                      }
                                      unsigned int v413 = __clz(v23);
                                      unsigned int v414 = v23 << (v413 + 1) >> -(char)v413;
                                      if (!v413) {
                                        unsigned int v414 = 0;
                                      }
                                      unsigned int v415 = v413 + v24 + v413 + 1;
                                      int v24 = v415 & 7;
                                      BytePtr += v415 >> 3;
                                      int v416 = v314 - BytePtr;
                                      if (v314 - (int)BytePtr < 4)
                                      {
                                        if (v416 < 1)
                                        {
                                          int v418 = v24 | v416;
                                          if (a4)
                                          {
                                            if (v418) {
                                              goto LABEL_952;
                                            }
                                            unsigned int v23 = 0;
                                          }
                                          else
                                          {
                                            unsigned int v23 = 0;
                                            if (v418) {
                                              goto LABEL_972;
                                            }
                                          }
                                        }
                                        else
                                        {
                                          int v417 = *BytePtr;
                                          if (v416 == 1)
                                          {
                                            unsigned int v23 = v417 << 24;
                                          }
                                          else
                                          {
                                            int v419 = (v417 << 16) | (BytePtr[1] << 8);
                                            if (v416 != 2) {
                                              v419 |= BytePtr[2];
                                            }
                                            unsigned int v23 = v419 << 8;
                                          }
                                        }
                                      }
                                      else
                                      {
                                        unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                                      }
                                      v23 <<= v24;
                                      HIDWORD(v470) = ((v414 + (1 << v413)) >> 1)
                                                    - ((v414 + (1 << v413)) >> 1) * 2 * ((v414 + (1 << v413)) & 1);
                                    }
LABEL_1031:
                                    if (*(int *)(a3 + 52 * v80 + 1296) < 1
                                      || (*(_DWORD *)(a3 + 52 * v80 + 1300) - 3) > 2)
                                    {
                                      goto LABEL_1050;
                                    }
                                    unsigned int v420 = vcvtpd_s64_f64(log2((double)((*(_DWORD *)(a3 + 40 * v450 + 28)
                                                                       + 1
                                                                       + (*(_DWORD *)(a3 + 40 * v450 + 28) + 1)
                                                                       * *(_DWORD *)(a3 + 40 * v450 + 32))
                                                                      / (*(_DWORD *)(a3 + 52 * v80 + 1304)
                                                                                     + 1)
                                                                      + 1)));
                                    unsigned int v421 = v420 - 26;
                                    if (a4)
                                    {
                                      if (v421 < 0xFFFFFFE7) {
                                        goto LABEL_952;
                                      }
                                    }
                                    else if (v421 < 0xFFFFFFE7)
                                    {
                                      goto LABEL_972;
                                    }
                                    LODWORD(v471) = v23 >> -(char)v420;
                                    unsigned int v422 = v24 + v420;
                                    int v24 = v422 & 7;
                                    BytePtr += v422 >> 3;
                                    int v423 = v314 - BytePtr;
                                    if (v314 - (int)BytePtr < 4)
                                    {
                                      if (v423 < 1)
                                      {
                                        int v425 = v24 | v423;
                                        if (a4)
                                        {
                                          if (v425) {
                                            goto LABEL_952;
                                          }
                                          unsigned int v23 = 0;
                                        }
                                        else
                                        {
                                          unsigned int v23 = 0;
                                          if (v425) {
                                            goto LABEL_972;
                                          }
                                        }
                                      }
                                      else
                                      {
                                        int v424 = *BytePtr;
                                        if (v423 == 1)
                                        {
                                          unsigned int v23 = v424 << 24;
                                        }
                                        else
                                        {
                                          int v426 = (v424 << 16) | (BytePtr[1] << 8);
                                          if (v423 != 2) {
                                            v426 |= BytePtr[2];
                                          }
                                          unsigned int v23 = v426 << 8;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                                    }
                                    v23 <<= v24;
                                    break;
                                  default:
                                    goto LABEL_932;
                                }
                                goto LABEL_1050;
                              }
                            }
                            else if (v23 >= 0x80000)
                            {
                              goto LABEL_874;
                            }
                          }
                        }
                        else if (v23 >= 0x80000)
                        {
                          goto LABEL_904;
                        }
                      }
                      else
                      {
                        unsigned int v23 = 0;
                        if (!v326) {
                          goto LABEL_855;
                        }
                      }
                    }
LABEL_972:
                    uint64_t v22 = 4294954582;
                    goto LABEL_973;
                  }
                  BYTE12(v468) = v268 < 0;
                  if (v316 < 4)
                  {
                    if (v316 < 1)
                    {
                      int v321 = v24 | v316;
                      if (a4)
                      {
                        if (v321) {
                          goto LABEL_952;
                        }
                        unsigned int v23 = 0;
                      }
                      else
                      {
                        unsigned int v23 = 0;
                        if (v321) {
                          goto LABEL_972;
                        }
                      }
                    }
                    else
                    {
                      int v319 = *BytePtr;
                      if (v316 == 1)
                      {
                        unsigned int v23 = v319 << 24;
                      }
                      else
                      {
                        int v327 = (v319 << 16) | (BytePtr[1] << 8);
                        if (v316 != 2) {
                          v327 |= BytePtr[2];
                        }
                        unsigned int v23 = v327 << 8;
                      }
                    }
                  }
                  else
                  {
                    unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                  }
                  v23 <<= v24;
                  if ((v268 & 0x80000000) == 0) {
                    goto LABEL_856;
                  }
                  while (2)
                  {
                    if (a4)
                    {
                      if (v23 < 0x80000) {
                        goto LABEL_952;
                      }
                    }
                    else if (v23 < 0x80000)
                    {
                      goto LABEL_972;
                    }
                    unsigned int v332 = __clz(v23);
                    unsigned int v333 = v23 << (v332 + 1) >> -(char)v332;
                    if (!v332) {
                      unsigned int v333 = 0;
                    }
                    unsigned int v334 = v333 + ~(-1 << v332);
                    unsigned int v335 = v332 + v24 + v332 + 1;
                    int v24 = v335 & 7;
                    BytePtr += v335 >> 3;
                    int v336 = v314 - BytePtr;
                    if (v314 - (int)BytePtr >= 4)
                    {
                      unsigned int v337 = bswap32(*(_DWORD *)BytePtr);
                      goto LABEL_789;
                    }
                    if (v336 < 1)
                    {
                      int v339 = v24 | v336;
                      if (a4)
                      {
                        if (v339) {
                          goto LABEL_952;
                        }
                        unsigned int v23 = 0;
                        goto LABEL_790;
                      }
                      unsigned int v23 = 0;
                      if (v339) {
                        goto LABEL_972;
                      }
                    }
                    else
                    {
                      int v338 = *BytePtr;
                      if (v336 == 1)
                      {
                        unsigned int v337 = v338 << 24;
                      }
                      else
                      {
                        int v340 = (v338 << 16) | (BytePtr[1] << 8);
                        if (v336 != 2) {
                          v340 |= BytePtr[2];
                        }
                        unsigned int v337 = v340 << 8;
                      }
LABEL_789:
                      unsigned int v23 = v337 << v24;
                      if (a4)
                      {
LABEL_790:
                        if (v334 > 6) {
                          goto LABEL_952;
                        }
                        goto LABEL_794;
                      }
                    }
                    if (v334 > 6) {
                      break;
                    }
LABEL_794:
                    if ((v334 | 2) == 3)
                    {
                      if (a4)
                      {
                        if (v23 < 0x80000) {
                          goto LABEL_952;
                        }
                      }
                      else if (v23 < 0x80000)
                      {
                        goto LABEL_972;
                      }
                      unsigned int v341 = v24 + 2 * __clz(v23) + 1;
                      int v24 = v341 & 7;
                      BytePtr += v341 >> 3;
                      int v342 = v314 - BytePtr;
                      if (v314 - (int)BytePtr < 4)
                      {
                        if (v342 < 1)
                        {
                          int v344 = v24 | v342;
                          if (a4)
                          {
                            if (v344) {
                              goto LABEL_952;
                            }
                            unsigned int v23 = 0;
                          }
                          else
                          {
                            unsigned int v23 = 0;
                            if (v344) {
                              goto LABEL_972;
                            }
                          }
                        }
                        else
                        {
                          int v343 = *BytePtr;
                          if (v342 == 1)
                          {
                            unsigned int v23 = v343 << 24;
                          }
                          else
                          {
                            int v345 = (v343 << 16) | (BytePtr[1] << 8);
                            if (v342 != 2) {
                              v345 |= BytePtr[2];
                            }
                            unsigned int v23 = v345 << 8;
                          }
                        }
                      }
                      else
                      {
                        unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                      }
                      v23 <<= v24;
                    }
                    switch(v334)
                    {
                      case 6u:
                      case 3u:
                        if (a4)
                        {
                          if (v23 < 0x80000) {
                            goto LABEL_952;
                          }
                        }
                        else if (v23 < 0x80000)
                        {
                          goto LABEL_972;
                        }
                        unsigned int v346 = v24 + 2 * __clz(v23) + 1;
                        int v24 = v346 & 7;
                        BytePtr += v346 >> 3;
                        int v347 = v314 - BytePtr;
                        if (v314 - (int)BytePtr < 4)
                        {
                          if (v347 < 1)
                          {
                            int v349 = v24 | v347;
                            if (a4)
                            {
                              if (v349) {
                                goto LABEL_952;
                              }
                              unsigned int v23 = 0;
                            }
                            else
                            {
                              unsigned int v23 = 0;
                              if (v349) {
                                goto LABEL_972;
                              }
                            }
                          }
                          else
                          {
                            int v348 = *BytePtr;
                            if (v347 == 1)
                            {
                              unsigned int v23 = v348 << 24;
                            }
                            else
                            {
                              int v350 = (v348 << 16) | (BytePtr[1] << 8);
                              if (v347 != 2) {
                                v350 |= BytePtr[2];
                              }
                              unsigned int v23 = v350 << 8;
                            }
                          }
                        }
                        else
                        {
                          unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                        }
                        v23 <<= v24;
                        break;
                      case 2u:
LABEL_834:
                        if (a4)
                        {
                          if (v23 < 0x80000) {
                            goto LABEL_952;
                          }
                        }
                        else if (v23 < 0x80000)
                        {
                          goto LABEL_972;
                        }
                        unsigned int v351 = v24 + 2 * __clz(v23) + 1;
                        int v24 = v351 & 7;
                        BytePtr += v351 >> 3;
                        int v352 = v314 - BytePtr;
                        if (v314 - (int)BytePtr < 4)
                        {
                          if (v352 < 1)
                          {
                            int v354 = v24 | v352;
                            if (a4)
                            {
                              if (v354) {
                                goto LABEL_952;
                              }
                              unsigned int v23 = 0;
                            }
                            else
                            {
                              unsigned int v23 = 0;
                              if (v354) {
                                goto LABEL_972;
                              }
                            }
                          }
                          else
                          {
                            int v353 = *BytePtr;
                            if (v352 == 1)
                            {
                              unsigned int v23 = v353 << 24;
                            }
                            else
                            {
                              int v355 = (v353 << 16) | (BytePtr[1] << 8);
                              if (v352 != 2) {
                                v355 |= BytePtr[2];
                              }
                              unsigned int v23 = v355 << 8;
                            }
                          }
                        }
                        else
                        {
                          unsigned int v23 = bswap32(*(_DWORD *)BytePtr);
                        }
                        v23 <<= v24;
                        break;
                      case 4u:
                        goto LABEL_834;
                    }
                    if (!v334) {
                      goto LABEL_856;
                    }
                    continue;
                  }
                }
LABEL_853:
                LODWORD(v22) = -12714;
                FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
                goto LABEL_974;
              }
              while (2)
              {
                if (a4)
                {
                  if (v23 < 0x80000) {
                    goto LABEL_952;
                  }
                }
                else if (v23 < 0x80000)
                {
                  goto LABEL_658;
                }
                unsigned int v299 = __clz(v23);
                unsigned int v300 = v23 << (v299 + 1) >> -(char)v299;
                if (!v299) {
                  unsigned int v300 = 0;
                }
                unsigned int v301 = v300 + ~(-1 << v299);
                unsigned int v302 = v299 + v24 + v299 + 1;
                int v24 = v302 & 7;
                v72 += v302 >> 3;
                int v303 = v26 - v72;
                if (v26 - (int)v72 >= 4)
                {
                  unsigned int v304 = bswap32(*(_DWORD *)v72);
                  goto LABEL_693;
                }
                if (v303 < 1)
                {
                  int v306 = v24 | v303;
                  if (a4)
                  {
                    if (v306) {
                      goto LABEL_952;
                    }
                    unsigned int v23 = 0;
                    goto LABEL_694;
                  }
                  unsigned int v23 = 0;
                  if (v306) {
                    goto LABEL_658;
                  }
                }
                else
                {
                  int v305 = *v72;
                  if (v303 == 1)
                  {
                    unsigned int v304 = v305 << 24;
                  }
                  else
                  {
                    int v307 = (v305 << 16) | (v72[1] << 8);
                    if (v303 != 2) {
                      v307 |= v72[2];
                    }
                    unsigned int v304 = v307 << 8;
                  }
LABEL_693:
                  unsigned int v23 = v304 << v24;
                  if (a4)
                  {
LABEL_694:
                    if (v301 > 3) {
                      goto LABEL_1007;
                    }
                    if (v301 > 2) {
                      goto LABEL_665;
                    }
                    if (v23 < 0x80000) {
                      goto LABEL_952;
                    }
LABEL_702:
                    unsigned int v308 = v24 + 2 * __clz(v23) + 1;
                    int v24 = v308 & 7;
                    v72 += v308 >> 3;
                    int v309 = v26 - v72;
                    if (v26 - (int)v72 < 4)
                    {
                      if (v309 < 1)
                      {
                        int v311 = v24 | v309;
                        if (a4)
                        {
                          if (v311) {
                            goto LABEL_952;
                          }
                          unsigned int v23 = 0;
                        }
                        else
                        {
                          unsigned int v23 = 0;
                          if (v311) {
                            goto LABEL_658;
                          }
                        }
                      }
                      else
                      {
                        int v310 = *v72;
                        if (v309 == 1)
                        {
                          unsigned int v23 = v310 << 24;
                        }
                        else
                        {
                          int v312 = (v310 << 16) | (v72[1] << 8);
                          if (v309 != 2) {
                            v312 |= v72[2];
                          }
                          unsigned int v23 = v312 << 8;
                        }
                      }
                    }
                    else
                    {
                      unsigned int v23 = bswap32(*(_DWORD *)v72);
                    }
                    v23 <<= v24;
                    continue;
                  }
                }
                break;
              }
              if (v301 > 3) {
                goto LABEL_1115;
              }
              if (v301 > 2) {
                goto LABEL_665;
              }
              if (v23 < 0x80000) {
                goto LABEL_658;
              }
              goto LABEL_702;
            }
            BYTE12(v459) = v268 < 0;
            uint64_t v282 = (v24 + 1) >> 3;
            int v24 = (v24 + 1) & 7;
            v72 += v282;
            int v283 = v26 - v72;
            if (v26 - (int)v72 < 4)
            {
              if (v283 < 1)
              {
                int v330 = v24 | v283;
                if (a4)
                {
                  if (v330) {
                    goto LABEL_952;
                  }
                  unsigned int v23 = 0;
                }
                else
                {
                  unsigned int v23 = 0;
                  if (v330) {
                    goto LABEL_658;
                  }
                }
              }
              else
              {
                int v293 = *v72;
                if (v283 == 1)
                {
                  unsigned int v23 = v293 << 24;
                }
                else
                {
                  int v331 = (v293 << 16) | (v72[1] << 8);
                  if (v283 != 2) {
                    v331 |= v72[2];
                  }
                  unsigned int v23 = v331 << 8;
                }
              }
            }
            else
            {
              unsigned int v23 = bswap32(*(_DWORD *)v72);
            }
            v23 <<= v24;
            if ((v268 & 0x80000000) == 0)
            {
LABEL_1073:
              int v268 = v23;
              goto LABEL_628;
            }
            while (2)
            {
              if (a4)
              {
                if (v23 < 0x80000) {
                  goto LABEL_952;
                }
              }
              else if (v23 < 0x80000)
              {
                goto LABEL_658;
              }
              unsigned int v434 = __clz(v23);
              unsigned int v435 = v23 << (v434 + 1) >> -(char)v434;
              if (!v434) {
                unsigned int v435 = 0;
              }
              unsigned int v436 = v435 + ~(-1 << v434);
              unsigned int v437 = v434 + v24 + v434 + 1;
              int v24 = v437 & 7;
              v72 += v437 >> 3;
              int v438 = v26 - v72;
              if (v26 - (int)v72 >= 4)
              {
                unsigned int v439 = bswap32(*(_DWORD *)v72);
                goto LABEL_1091;
              }
              if (v438 < 1)
              {
                int v441 = v24 | v438;
                if (a4)
                {
                  if (v441) {
                    goto LABEL_952;
                  }
                  unsigned int v23 = 0;
                  goto LABEL_1092;
                }
                unsigned int v23 = 0;
                if (v441) {
                  goto LABEL_658;
                }
              }
              else
              {
                int v440 = *v72;
                if (v438 == 1)
                {
                  unsigned int v439 = v440 << 24;
                }
                else
                {
                  int v442 = (v440 << 16) | (v72[1] << 8);
                  if (v438 != 2) {
                    v442 |= v72[2];
                  }
                  unsigned int v439 = v442 << 8;
                }
LABEL_1091:
                unsigned int v23 = v439 << v24;
                if (a4)
                {
LABEL_1092:
                  if (v436 > 3) {
                    goto LABEL_1007;
                  }
                  if (v436 > 2) {
                    goto LABEL_1073;
                  }
                  if (v23 < 0x80000) {
                    goto LABEL_952;
                  }
LABEL_1100:
                  unsigned int v443 = v24 + 2 * __clz(v23) + 1;
                  int v24 = v443 & 7;
                  v72 += v443 >> 3;
                  int v444 = v26 - v72;
                  if (v26 - (int)v72 < 4)
                  {
                    if (v444 < 1)
                    {
                      int v446 = v24 | v444;
                      if (a4)
                      {
                        if (v446) {
                          goto LABEL_952;
                        }
                        unsigned int v23 = 0;
                      }
                      else
                      {
                        unsigned int v23 = 0;
                        if (v446) {
                          goto LABEL_658;
                        }
                      }
                    }
                    else
                    {
                      int v445 = *v72;
                      if (v444 == 1)
                      {
                        unsigned int v23 = v445 << 24;
                      }
                      else
                      {
                        int v447 = (v445 << 16) | (v72[1] << 8);
                        if (v444 != 2) {
                          v447 |= v72[2];
                        }
                        unsigned int v23 = v447 << 8;
                      }
                    }
                  }
                  else
                  {
                    unsigned int v23 = bswap32(*(_DWORD *)v72);
                  }
                  v23 <<= v24;
                  continue;
                }
              }
              break;
            }
            if (v436 > 3) {
              goto LABEL_1115;
            }
            if (v436 > 2) {
              goto LABEL_1073;
            }
            if (v23 < 0x80000) {
              goto LABEL_658;
            }
            goto LABEL_1100;
          }
        }
        if (v405 <= 0x1F)
        {
LABEL_626:
          int v268 = v23;
          goto LABEL_627;
        }
LABEL_1115:
        uint64_t v22 = 4294954577;
        goto LABEL_659;
      }
    }
    if (v287 <= 0x1F) {
      goto LABEL_986;
    }
    goto LABEL_1115;
  }
  uint64_t v234 = (v24 + 1) >> 3;
  int v24 = (v24 + 1) & 7;
  v72 += v234;
  int v235 = v26 - v72;
  if (v26 - (int)v72 >= 4)
  {
    unsigned int v236 = bswap32(*(_DWORD *)v72);
    goto LABEL_526;
  }
  if (v235 < 1)
  {
    int v239 = v24 | v235;
    if (a4)
    {
      if (v239) {
        goto LABEL_952;
      }
      unsigned int v23 = 0;
    }
    else
    {
      unsigned int v23 = 0;
      if (v239) {
        goto LABEL_658;
      }
    }
  }
  else
  {
    int v237 = *v72;
    if (v235 == 1)
    {
      unsigned int v236 = v237 << 24;
    }
    else
    {
      int v240 = (v237 << 16) | (v72[1] << 8);
      if (v235 != 2) {
        v240 |= v72[2];
      }
      unsigned int v236 = v240 << 8;
    }
LABEL_526:
    unsigned int v23 = v236 << v24;
  }
  unsigned int v241 = 1;
  unsigned int v242 = v23;
  while (2)
  {
    int v214 = (v24 + 1) & 7;
    v72 += (v24 + 1) >> 3;
    int v243 = v26 - v72;
    if (v26 - (int)v72 >= 4)
    {
      unsigned int v244 = bswap32(*(_DWORD *)v72);
      goto LABEL_540;
    }
    if (v243 < 1)
    {
      int v246 = v214 | v243;
      if (a4)
      {
        if (v246) {
          goto LABEL_952;
        }
        if ((v242 & 0x80000000) != 0) {
          goto LABEL_546;
        }
        int v246 = 0;
      }
      else
      {
        if (v246) {
          goto LABEL_1136;
        }
        unsigned int v23 = 0;
        if ((v242 & 0x80000000) != 0) {
          goto LABEL_551;
        }
      }
      goto LABEL_541;
    }
    int v245 = *v72;
    if (v243 == 1)
    {
      unsigned int v244 = v245 << 24;
    }
    else
    {
      int v247 = (v245 << 16) | (v72[1] << 8);
      if (v243 != 2) {
        v247 |= v72[2];
      }
      unsigned int v244 = v247 << 8;
    }
LABEL_540:
    int v246 = v244 << v214;
    if ((v242 & 0x80000000) == 0)
    {
LABEL_541:
      ++v241;
      unsigned int v242 = v246;
      int v24 = (v24 + 1) & 7;
      continue;
    }
    break;
  }
  unsigned int v23 = v246;
  if (!a4)
  {
LABEL_551:
    if (v241 - 1 <= 0x1E)
    {
      if (v241 < 0x19)
      {
LABEL_553:
        unsigned int v232 = (((_BYTE)v24 + 1) & 7) + v241;
        goto LABEL_554;
      }
      unsigned int v255 = (((_BYTE)v24 + 1) & 7) + v241;
      uint64_t v256 = (v255 - 16) >> 3;
      int v24 = v255 & 7;
      long long v222 = &v72[v256];
      int v257 = v26 - (v72 + v256);
      if (v257 > 0 || !(v24 | v257)) {
        goto LABEL_566;
      }
LABEL_1141:
      unsigned int v23 = 0;
      uint64_t v22 = 4294954582;
      BytePtr = v222;
      goto LABEL_973;
    }
LABEL_1137:
    uint64_t v22 = 4294954582;
    LOBYTE(v24) = v214;
    goto LABEL_659;
  }
LABEL_546:
  if (v241 - 1 > 0x1E) {
    goto LABEL_952;
  }
  if (v241 <= 0x18) {
    goto LABEL_553;
  }
  unsigned int v248 = (((_BYTE)v24 + 1) & 7) + v241;
  uint64_t v249 = (v248 - 16) >> 3;
  int v24 = v248 & 7;
  long long v222 = &v72[v249];
  int v250 = v26 - (v72 + v249);
  if (v250 <= 0 && v24 | v250) {
    goto LABEL_952;
  }
LABEL_566:
  int v72 = v222 + 2;
  int v258 = v26 - (v222 + 2);
  if (v258 >= 4)
  {
LABEL_567:
    unsigned int v23 = bswap32(*(_DWORD *)v72);
    goto LABEL_568;
  }
  if (v258 >= 1)
  {
    int v448 = *v72;
    if (v258 == 1)
    {
      unsigned int v23 = v448 << 24;
    }
    else
    {
      int v449 = (v448 << 16) | (v222[3] << 8);
      if (v258 != 2) {
        v449 |= v222[4];
      }
      unsigned int v23 = v449 << 8;
    }
    goto LABEL_568;
  }
  int v253 = v24 | v258;
  if (a4) {
    goto LABEL_559;
  }
LABEL_1122:
  unsigned int v23 = 0;
  if (!v253) {
    goto LABEL_568;
  }
LABEL_658:
  uint64_t v22 = 4294954582;
LABEL_659:
  BytePtr = v72;
LABEL_973:
  LODWORD(v22) = FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  if (v22)
  {
LABEL_974:
    if ((void)v455 - (void)v454 + 4 >= DWORD2(v454)) {
      uint64_t v400 = 4294950906;
    }
    else {
      uint64_t v400 = v22;
    }
    goto LABEL_1068;
  }
LABEL_1050:
  *(void *)&long long v455 = BytePtr;
  DWORD2(v455) = v23;
  BYTE12(v455) = v24;
  v427 = &BytePtr[-v454];
  if ((_BYTE)v24) {
    ++v427;
  }
  if (theData)
  {
    v428 = v452;
    if (a2 >= 3 && v427)
    {
      int v429 = 0;
      unint64_t v430 = 0;
      unint64_t v431 = 2;
      unint64_t v432 = (unint64_t)v427;
      do
      {
        if (v451[v430] || *(_WORD *)&v451[v430 + 1] != 768)
        {
          unint64_t v431 = v430;
        }
        else
        {
          if (v432 < v431) {
            break;
          }
          ++v432;
          int v429 = 1;
        }
        if (v431 + 3 >= a2) {
          break;
        }
        unint64_t v430 = v431 + 1;
        v431 += 3;
      }
      while (v430 < v432);
      if (v429) {
        v427 = (const UInt8 *)v432;
      }
    }
  }
  else
  {
    v428 = v452;
  }
  uint64_t v400 = 0;
  *v428 = v427;
LABEL_1068:
  if (theData) {
    CFRelease(theData);
  }
  return v400;
}

uint64_t FigH264Bridge_LocateSliceHeaderForHLSfMP4EncryptableNAL(CMBlockBufferRef theBuffer, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t a6, void *a7, unint64_t a8, void *a9)
{
  size_t totalLengthOut = 0;
  dataPointerOut = 0;
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v9 = 4294954584;
  if (!theBuffer || !a4) {
    return v9;
  }
  unint64_t v12 = (unint64_t)a7;
  if (a5) {
    *a5 = 0;
  }
  if (a7) {
    *a7 = 0;
  }
  if (a8) {
    *(void *)a8 = 0;
  }
  if (a9) {
    *a9 = 0;
  }
  Dataint Length = CMBlockBufferGetDataLength(theBuffer);
  if (!DataLength) {
    goto LABEL_58;
  }
  size_t v18 = DataLength;
  if (CMBlockBufferIsRangeContiguous(theBuffer, 0, 0))
  {
    unsigned int v19 = (OpaqueCMBlockBuffer *)CFRetain(theBuffer);
    CMBlockBufferRef blockBufferOut = v19;
  }
  else
  {
    uint64_t DataPointer = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theBuffer, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, v18, 0, &blockBufferOut);
    if (DataPointer)
    {
LABEL_59:
      uint64_t v9 = DataPointer;
      goto LABEL_60;
    }
    unsigned int v19 = blockBufferOut;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(v19, 0, 0, &totalLengthOut, &dataPointerOut);
  if (DataPointer) {
    goto LABEL_59;
  }
  if (!a3)
  {
    unint64_t v21 = (unint64_t)a9;
    uint64_t v22 = a6;
    if (!a2)
    {
      long long v40 = a5;
      a3 = totalLengthOut;
      goto LABEL_22;
    }
LABEL_58:
    uint64_t DataPointer = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    goto LABEL_59;
  }
  unint64_t v21 = (unint64_t)a9;
  uint64_t v22 = a6;
  if (a3 + a2 > totalLengthOut) {
    goto LABEL_58;
  }
  long long v40 = a5;
  size_t totalLengthOut = a3;
  dataPointerOut += a2;
LABEL_22:
  unsigned int v23 = 0;
  int v24 = 0;
  int v39 = (void *)v12;
  BOOL v25 = (a8 | v21 | v12) != 0;
  BOOL v26 = (a8 | v21) != 0;
  BOOL v38 = v26;
  while (1)
  {
    if (a3 - 4 <= v24)
    {
      if (!v23) {
        goto LABEL_58;
      }
      if (v40) {
        *long long v40 = v23;
      }
      goto LABEL_56;
    }
    unsigned int v27 = *(_DWORD *)&dataPointerOut[v24];
    if (!v27) {
      goto LABEL_58;
    }
    uint64_t v28 = (v24 + 4);
    unint64_t v29 = bswap32(v27);
    int v24 = v29 + v28;
    if (a3 < (int)v29 + (int)v28) {
      goto LABEL_58;
    }
    if ((dataPointerOut[v28] & 0x1B) == 1) {
      break;
    }
LABEL_50:
    if (a3 < v24) {
      goto LABEL_58;
    }
  }
  if (v29 <= 1) {
    goto LABEL_58;
  }
  if (v23 != v22 || !v25)
  {
LABEL_49:
    ++v23;
    goto LABEL_50;
  }
  if (v12) {
    *(void *)unint64_t v12 = v28;
  }
  if (v26)
  {
    BOOL v31 = v25;
    unsigned int v42 = 0;
    unint64_t v32 = 64;
    do
    {
      if (v32 >= v29) {
        unint64_t v33 = v29;
      }
      else {
        unint64_t v33 = v32;
      }
      uint64_t v34 = FigH264Bridge_MeasureSliceHeader((const UInt8 *)&dataPointerOut[v28], v33, a4, 0, &v42);
      uint64_t v9 = v34;
      if (v32 >= v29) {
        break;
      }
      unint64_t v32 = v33 + 64;
    }
    while (v34 == -16390);
    if (v34) {
      goto LABEL_60;
    }
    int v35 = v42;
    if (a8) {
      *(void *)a8 = &v42[v28];
    }
    uint64_t v22 = a6;
    BOOL v25 = v31;
    BOOL v26 = v38;
    if (a9) {
      *a9 = v29 - (void)v35;
    }
    unint64_t v12 = (unint64_t)v39;
  }
  if (v40)
  {
    a3 = totalLengthOut;
    goto LABEL_49;
  }
  if (__CFADD__(v23++, 1)) {
    goto LABEL_58;
  }
LABEL_56:
  if (v23 <= v22) {
    goto LABEL_58;
  }
  uint64_t v9 = 0;
LABEL_60:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v9;
}

uint64_t scaling_list(uint64_t result, int a2, _DWORD *a3)
{
  unsigned int v3 = *(unsigned __int8 **)(result + 16);
  unsigned int v4 = *(_DWORD *)(result + 24);
  int v5 = *(unsigned __int8 *)(result + 28);
  if (a2)
  {
    uint64_t v7 = *(void *)result + *(unsigned int *)(result + 8);
    int v8 = 8;
    int v9 = 8;
    do
    {
      if (!v8) {
        goto LABEL_23;
      }
      if (*a3) {
        return result;
      }
      if (!(v4 >> 19))
      {
LABEL_27:
        uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        *a3 = result;
        return result;
      }
      unsigned int v10 = __clz(v4);
      unsigned int v11 = v4 << (v10 + 1) >> -(char)v10;
      unsigned int v12 = v10 ? v11 : 0;
      unsigned int v13 = v10 + v5 + v10 + 1;
      uint64_t v14 = v13 >> 3;
      int v5 = v13 & 7;
      v3 += v14;
      int v15 = v7 - v3;
      if ((int)v7 - (int)v3 < 4)
      {
        if (v15 < 1)
        {
          int v16 = v5 | v15;
          if (v16) {
            goto LABEL_27;
          }
        }
        else
        {
          int v17 = *v3;
          if (v15 == 1)
          {
            int v16 = v17 << 24;
          }
          else
          {
            int v18 = (v17 << 16) | (v3[1] << 8);
            if (v15 != 2) {
              v18 |= v3[2];
            }
            int v16 = v18 << 8;
          }
        }
      }
      else
      {
        int v16 = bswap32(*(_DWORD *)v3);
      }
      unsigned int v4 = v16 << v5;
      unsigned int v19 = ((v12 + (1 << v10)) >> 1) - ((v12 + (1 << v10)) >> 1) * 2 * ((v12 + (1 << v10)) & 1) + v9 + 256;
      int v20 = v19;
      int v21 = -v19;
      int v8 = v21 >= 0 ? -v21 : v20;
      unsigned __int8 v22 = v8;
      if (!v8)
      {
LABEL_23:
        int v8 = 0;
        unsigned __int8 v22 = v9;
      }
      int v9 = v22;
      --a2;
    }
    while (a2);
  }
  *(void *)(result + 16) = v3;
  *(_DWORD *)(result + 24) = v4;
  *(unsigned char *)(result + 28) = v5;
  return result;
}

uint64_t PullVUIParamSet(uint64_t *a1, unsigned int *a2)
{
  uint64_t v3 = *a1;
  int v4 = *((_DWORD *)a1 + 2);
  unint64_t v5 = *((unsigned __int8 *)a1 + 28);
  unsigned int v6 = *((_DWORD *)a1 + 6);
  uint64_t v7 = a1[2];
  *a2 = v6 >> 31;
  int v8 = ++v5 & 7;
  int v9 = (unsigned __int8 *)(v7 + (v5 >> 3));
  int v10 = v3 + v4;
  int v11 = v3 + v4 - v9;
  if (v11 < 4)
  {
    if (v11 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v11) {
        goto LABEL_748;
      }
    }
    else
    {
      int v13 = *v9;
      if (v11 == 1)
      {
        unsigned int v12 = v13 << 24;
      }
      else
      {
        int v14 = (v13 << 16) | (v9[1] << 8);
        if (v11 != 2) {
          v14 |= v9[2];
        }
        unsigned int v12 = v14 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  unsigned int v15 = v12 << v8;
  if ((v6 & 0x80000000) != 0)
  {
    unsigned int v17 = HIBYTE(v15);
    a2[1] = HIBYTE(v15);
    int v16 = (unsigned int *)(v9 + 1);
    int v18 = v10 - (v9 + 1);
    if (v18 < 4)
    {
      if (v18 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v18) {
          goto LABEL_40;
        }
      }
      else
      {
        int v19 = *(unsigned __int8 *)v16;
        if (v18 == 1)
        {
          unsigned int v12 = v19 << 24;
        }
        else
        {
          int v20 = (v19 << 16) | (v9[2] << 8);
          if (v18 != 2) {
            v20 |= v9[3];
          }
          unsigned int v12 = v20 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*v16);
    }
    unsigned int v15 = v12 << v8;
    if (v17 != 255) {
      goto LABEL_45;
    }
    a2[2] = HIWORD(v15);
    int v16 = (unsigned int *)(v9 + 3);
    int v21 = v10 - (v9 + 3);
    if (v21 < 4)
    {
      if (v21 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v21) {
          goto LABEL_40;
        }
      }
      else
      {
        int v22 = *(unsigned __int8 *)v16;
        if (v21 == 1)
        {
          unsigned int v12 = v22 << 24;
        }
        else
        {
          int v23 = (v22 << 16) | (v9[4] << 8);
          if (v21 != 2) {
            v23 |= v9[5];
          }
          unsigned int v12 = v23 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*v16);
    }
    a2[3] = v12 << v8 >> 16;
    int v16 = (unsigned int *)(v9 + 5);
    int v24 = v10 - (v9 + 5);
    if (v24 >= 4)
    {
      unsigned int v12 = bswap32(*v16);
      goto LABEL_44;
    }
    if (v24 >= 1)
    {
      int v25 = *(unsigned __int8 *)v16;
      if (v24 == 1)
      {
        unsigned int v12 = v25 << 24;
      }
      else
      {
        int v26 = (v25 << 16) | (v9[6] << 8);
        if (v24 != 2) {
          v26 |= v9[7];
        }
        unsigned int v12 = v26 << 8;
      }
      goto LABEL_44;
    }
    unsigned int v12 = 0;
    if (!(v8 | v24))
    {
LABEL_44:
      unsigned int v15 = v12 << v8;
      goto LABEL_45;
    }
LABEL_40:
    int v9 = (unsigned __int8 *)v16;
    goto LABEL_748;
  }
  int v16 = (unsigned int *)v9;
LABEL_45:
  int v27 = v7 - v3;
  if (v4 < v27) {
    goto LABEL_746;
  }
  a2[4] = v15 >> 31;
  uint64_t v28 = (v8 + 1) >> 3;
  int v8 = (v8 + 1) & 7;
  int v9 = (unsigned __int8 *)v16 + v28;
  int v29 = v10 - (v16 + v28);
  if (v29 < 4)
  {
    if (v29 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v29) {
        goto LABEL_748;
      }
    }
    else
    {
      int v30 = *v9;
      if (v29 == 1)
      {
        unsigned int v12 = v30 << 24;
      }
      else
      {
        int v31 = (v30 << 16) | (v9[1] << 8);
        if (v29 != 2) {
          v31 |= v9[2];
        }
        unsigned int v12 = v31 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  unsigned int v32 = v12 << v8;
  if ((v15 & 0x80000000) != 0)
  {
    a2[5] = v32 >> 31;
    uint64_t v33 = (v8 + 1) >> 3;
    int v8 = (v8 + 1) & 7;
    v9 += v33;
    int v34 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v34 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v34) {
          goto LABEL_748;
        }
      }
      else
      {
        int v35 = *v9;
        if (v34 == 1)
        {
          unsigned int v12 = v35 << 24;
        }
        else
        {
          int v36 = (v35 << 16) | (v9[1] << 8);
          if (v34 != 2) {
            v36 |= v9[2];
          }
          unsigned int v12 = v36 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    unsigned int v32 = v12 << v8;
  }
  a2[6] = v32 >> 31;
  uint64_t v37 = (v8 + 1) >> 3;
  int v8 = (v8 + 1) & 7;
  v9 += v37;
  int v38 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v38 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v38) {
        goto LABEL_748;
      }
    }
    else
    {
      int v39 = *v9;
      if (v38 == 1)
      {
        unsigned int v12 = v39 << 24;
      }
      else
      {
        int v40 = (v39 << 16) | (v9[1] << 8);
        if (v38 != 2) {
          v40 |= v9[2];
        }
        unsigned int v12 = v40 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  unsigned int v41 = v12 << v8;
  if ((v32 & 0x80000000) != 0)
  {
    a2[7] = v41 >> 29;
    uint64_t v42 = (v8 + 3) >> 3;
    int v8 = (v8 + 3) & 7;
    v9 += v42;
    int v43 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v43 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v43) {
          goto LABEL_748;
        }
      }
      else
      {
        int v44 = *v9;
        if (v43 == 1)
        {
          unsigned int v12 = v44 << 24;
        }
        else
        {
          int v45 = (v44 << 16) | (v9[1] << 8);
          if (v43 != 2) {
            v45 |= v9[2];
          }
          unsigned int v12 = v45 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    a2[8] = v12 << v8 >> 31;
    uint64_t v46 = (v8 + 1) >> 3;
    int v8 = (v8 + 1) & 7;
    v9 += v46;
    int v47 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v47 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v47) {
          goto LABEL_748;
        }
      }
      else
      {
        int v48 = *v9;
        if (v47 == 1)
        {
          unsigned int v12 = v48 << 24;
        }
        else
        {
          int v49 = (v48 << 16) | (v9[1] << 8);
          if (v47 != 2) {
            v49 |= v9[2];
          }
          unsigned int v12 = v49 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    unsigned int v50 = v12 << v8;
    a2[9] = v12 << v8 >> 31;
    uint64_t v51 = (v8 + 1) >> 3;
    int v8 = (v8 + 1) & 7;
    unsigned int v52 = &v9[v51];
    int v53 = v10 - (v9 + v51);
    if (v53 < 4)
    {
      if (v53 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v53)
        {
LABEL_105:
          int v9 = v52;
          goto LABEL_748;
        }
      }
      else
      {
        int v54 = *v52;
        if (v53 == 1)
        {
          unsigned int v12 = v54 << 24;
        }
        else
        {
          int v55 = (v54 << 16) | (v52[1] << 8);
          if (v53 != 2) {
            v55 |= v52[2];
          }
          unsigned int v12 = v55 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v52);
    }
    unsigned int v41 = v12 << v8;
    if ((v50 & 0x80000000) != 0)
    {
      a2[10] = HIBYTE(v41);
      int v9 = v52 + 1;
      int v56 = v10 - (v52 + 1);
      if (v56 < 4)
      {
        if (v56 < 1)
        {
          unsigned int v12 = 0;
          if (v8 | v56) {
            goto LABEL_748;
          }
        }
        else
        {
          int v57 = *v9;
          if (v56 == 1)
          {
            unsigned int v12 = v57 << 24;
          }
          else
          {
            int v58 = (v57 << 16) | (v52[2] << 8);
            if (v56 != 2) {
              v58 |= v52[3];
            }
            unsigned int v12 = v58 << 8;
          }
        }
      }
      else
      {
        unsigned int v12 = bswap32(*(_DWORD *)v9);
      }
      a2[11] = v12 << v8 >> 24;
      int v9 = v52 + 2;
      int v59 = v10 - (v52 + 2);
      if (v59 < 4)
      {
        if (v59 < 1)
        {
          unsigned int v12 = 0;
          if (v8 | v59) {
            goto LABEL_748;
          }
        }
        else
        {
          int v60 = *v9;
          if (v59 == 1)
          {
            unsigned int v12 = v60 << 24;
          }
          else
          {
            int v61 = (v60 << 16) | (v52[3] << 8);
            if (v59 != 2) {
              v61 |= v52[4];
            }
            unsigned int v12 = v61 << 8;
          }
        }
      }
      else
      {
        unsigned int v12 = bswap32(*(_DWORD *)v9);
      }
      a2[12] = v12 << v8 >> 24;
      int v9 = v52 + 3;
      int v62 = v10 - (v52 + 3);
      if (v62 < 4)
      {
        if (v62 < 1)
        {
          unsigned int v12 = 0;
          if (v8 | v62) {
            goto LABEL_748;
          }
        }
        else
        {
          int v63 = *v9;
          if (v62 == 1)
          {
            unsigned int v12 = v63 << 24;
          }
          else
          {
            int v64 = (v63 << 16) | (v52[4] << 8);
            if (v62 != 2) {
              v64 |= v52[5];
            }
            unsigned int v12 = v64 << 8;
          }
        }
      }
      else
      {
        unsigned int v12 = bswap32(*(_DWORD *)v9);
      }
      unsigned int v41 = v12 << v8;
    }
    else
    {
      int v9 = v52;
    }
  }
  a2[13] = v41 >> 31;
  uint64_t v65 = (v8 + 1) >> 3;
  int v8 = (v8 + 1) & 7;
  v9 += v65;
  int v66 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v66 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v66) {
        goto LABEL_748;
      }
    }
    else
    {
      int v67 = *v9;
      if (v66 == 1)
      {
        unsigned int v12 = v67 << 24;
      }
      else
      {
        int v68 = (v67 << 16) | (v9[1] << 8);
        if (v66 != 2) {
          v68 |= v9[2];
        }
        unsigned int v12 = v68 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  v12 <<= v8;
  if ((v41 & 0x80000000) != 0)
  {
    if (v12 < 0x80000) {
      goto LABEL_748;
    }
    unsigned int v69 = __clz(v12);
    unsigned int v70 = v12 << (v69 + 1) >> -(char)v69;
    if (!v69) {
      unsigned int v70 = 0;
    }
    a2[14] = v70 + ~(-1 << v69);
    unsigned int v71 = v69 + v8 + v69 + 1;
    int v8 = v71 & 7;
    v9 += v71 >> 3;
    int v72 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v72 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v72) {
          goto LABEL_748;
        }
      }
      else
      {
        int v73 = *v9;
        if (v72 == 1)
        {
          unsigned int v12 = v73 << 24;
        }
        else
        {
          int v74 = (v73 << 16) | (v9[1] << 8);
          if (v72 != 2) {
            v74 |= v9[2];
          }
          unsigned int v12 = v74 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000) {
      goto LABEL_748;
    }
    unsigned int v75 = __clz(v12);
    unsigned int v76 = v12 << (v75 + 1) >> -(char)v75;
    if (!v75) {
      unsigned int v76 = 0;
    }
    a2[15] = v76 + ~(-1 << v75);
    unsigned int v77 = v75 + v8 + v75 + 1;
    int v8 = v77 & 7;
    v9 += v77 >> 3;
    int v78 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v78 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v78) {
          goto LABEL_748;
        }
      }
      else
      {
        int v79 = *v9;
        if (v78 == 1)
        {
          unsigned int v12 = v79 << 24;
        }
        else
        {
          int v80 = (v79 << 16) | (v9[1] << 8);
          if (v78 != 2) {
            v80 |= v9[2];
          }
          unsigned int v12 = v80 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    int v4 = *((_DWORD *)a1 + 2);
    int v27 = *((_DWORD *)a1 + 4) - *(_DWORD *)a1;
  }
  if (v4 < v27) {
    goto LABEL_746;
  }
  a2[16] = v12 >> 31;
  uint64_t v81 = (v8 + 1) >> 3;
  int v8 = (v8 + 1) & 7;
  int v82 = &v9[v81];
  int v83 = v10 - (v9 + v81);
  if (v83 < 4)
  {
    if (v83 < 1)
    {
      unsigned int v84 = 0;
      if (v8 | v83)
      {
        unsigned int v12 = 0;
        goto LABEL_238;
      }
    }
    else
    {
      int v85 = *v82;
      if (v83 == 1)
      {
        unsigned int v84 = v85 << 24;
      }
      else
      {
        int v86 = (v85 << 16) | (v82[1] << 8);
        if (v83 != 2) {
          v86 |= v82[2];
        }
        unsigned int v84 = v86 << 8;
      }
    }
  }
  else
  {
    unsigned int v84 = bswap32(*(_DWORD *)v82);
  }
  unsigned int v87 = v84 << v8;
  if ((v12 & 0x80000000) == 0) {
    goto LABEL_243;
  }
  int v9 = v82 + 2;
  int v88 = v10 - (v82 + 2);
  if (v88 < 4)
  {
    if (v88 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v88) {
        goto LABEL_748;
      }
    }
    else
    {
      int v89 = *v9;
      if (v88 == 1)
      {
        unsigned int v12 = v89 << 24;
      }
      else
      {
        int v90 = (v89 << 16) | (v82[3] << 8);
        if (v88 != 2) {
          v90 |= v82[4];
        }
        unsigned int v12 = v90 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  int v9 = v82 + 4;
  int v91 = v10 - (v82 + 4);
  if (v91 < 4)
  {
    if (v91 < 1)
    {
      unsigned int v92 = 0;
      if (v8 | v91)
      {
        unsigned int v12 = 0;
        goto LABEL_748;
      }
    }
    else
    {
      int v93 = *v9;
      if (v91 == 1)
      {
        unsigned int v92 = v93 << 24;
      }
      else
      {
        int v94 = (v93 << 16) | (v82[5] << 8);
        if (v91 != 2) {
          v94 |= v82[6];
        }
        unsigned int v92 = v94 << 8;
      }
    }
  }
  else
  {
    unsigned int v92 = bswap32(*(_DWORD *)v9);
  }
  a2[17] = (v12 << v8 >> 16) | v87 & 0xFFFF0000;
  int v9 = v82 + 6;
  int v95 = v10 - (v82 + 6);
  if (v95 < 4)
  {
    if (v95 < 1)
    {
      unsigned int v96 = 0;
      if (v8 | v95)
      {
        unsigned int v12 = 0;
        goto LABEL_748;
      }
    }
    else
    {
      int v97 = *v9;
      if (v95 == 1)
      {
        unsigned int v96 = v97 << 24;
      }
      else
      {
        int v98 = (v97 << 16) | (v82[7] << 8);
        if (v95 != 2) {
          v98 |= v82[8];
        }
        unsigned int v96 = v98 << 8;
      }
    }
  }
  else
  {
    unsigned int v96 = bswap32(*(_DWORD *)v9);
  }
  int v9 = v82 + 8;
  int v99 = v10 - (v82 + 8);
  if (v99 < 4)
  {
    if (v99 < 1)
    {
      unsigned int v100 = 0;
      unsigned int v12 = 0;
      if (v8 | v99) {
        goto LABEL_748;
      }
    }
    else
    {
      int v101 = *v9;
      if (v99 == 1)
      {
        unsigned int v100 = v101 << 24;
      }
      else
      {
        int v102 = (v101 << 16) | (v82[9] << 8);
        if (v99 != 2) {
          v102 |= v82[10];
        }
        unsigned int v100 = v102 << 8;
      }
    }
  }
  else
  {
    unsigned int v100 = bswap32(*(_DWORD *)v9);
  }
  a2[18] = (v96 << v8 >> 16) | (v92 << v8) & 0xFFFF0000;
  a2[19] = v100 << v8 >> 31;
  uint64_t v103 = (v8 + 1) >> 3;
  int v8 = (v8 + 1) & 7;
  int v82 = &v9[v103];
  int v104 = v10 - (v9 + v103);
  if (v104 >= 4)
  {
    unsigned int v12 = bswap32(*(_DWORD *)v82);
    goto LABEL_242;
  }
  if (v104 >= 1)
  {
    int v105 = *v82;
    if (v104 == 1)
    {
      unsigned int v12 = v105 << 24;
    }
    else
    {
      int v106 = (v105 << 16) | (v82[1] << 8);
      if (v104 != 2) {
        v106 |= v82[2];
      }
      unsigned int v12 = v106 << 8;
    }
    goto LABEL_242;
  }
  unsigned int v12 = 0;
  if (v8 | v104)
  {
LABEL_238:
    int v9 = v82;
    goto LABEL_748;
  }
LABEL_242:
  unsigned int v87 = v12 << v8;
LABEL_243:
  if (*((_DWORD *)a1 + 2) < *((_DWORD *)a1 + 4) - *(_DWORD *)a1) {
    goto LABEL_746;
  }
  a2[20] = v87 >> 31;
  uint64_t v107 = (v8 + 1) >> 3;
  int v8 = (v8 + 1) & 7;
  int v9 = &v82[v107];
  int v108 = v10 - (v82 + v107);
  if (v108 < 4)
  {
    if (v108 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v108) {
        goto LABEL_748;
      }
    }
    else
    {
      int v109 = *v9;
      if (v108 == 1)
      {
        unsigned int v12 = v109 << 24;
      }
      else
      {
        int v110 = (v109 << 16) | (v9[1] << 8);
        if (v108 != 2) {
          v110 |= v9[2];
        }
        unsigned int v12 = v110 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  v12 <<= v8;
  if ((v87 & 0x80000000) == 0)
  {
    unsigned int v111 = v12;
    goto LABEL_432;
  }
  if (v12 < 0x80000) {
    goto LABEL_748;
  }
  unsigned int v112 = __clz(v12);
  if (v112) {
    unsigned int v113 = v12 << (v112 + 1) >> -(char)v112;
  }
  else {
    unsigned int v113 = 0;
  }
  int v114 = -1 << v112;
  int v115 = v113 + ~(-1 << v112);
  a2[32] = v115;
  unsigned int v116 = v112 + v8 + v112 + 1;
  int v8 = v116 & 7;
  v9 += v116 >> 3;
  int v117 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v117 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v117) {
        goto LABEL_748;
      }
    }
    else
    {
      int v118 = *v9;
      if (v117 == 1)
      {
        unsigned int v12 = v118 << 24;
      }
      else
      {
        int v119 = (v118 << 16) | (v9[1] << 8);
        if (v117 != 2) {
          v119 |= v9[2];
        }
        unsigned int v12 = v119 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  v12 <<= v8;
  if (v115 > 31) {
    goto LABEL_748;
  }
  a2[33] = v12 >> 28;
  uint64_t v120 = (v8 + 4) >> 3;
  int v8 = (v8 + 4) & 7;
  v9 += v120;
  int v121 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v121 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v121) {
        goto LABEL_748;
      }
    }
    else
    {
      int v122 = *v9;
      if (v121 == 1)
      {
        unsigned int v12 = v122 << 24;
      }
      else
      {
        int v123 = (v122 << 16) | (v9[1] << 8);
        if (v121 != 2) {
          v123 |= v9[2];
        }
        unsigned int v12 = v123 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  a2[34] = v12 << v8 >> 28;
  uint64_t v124 = (v8 + 4) >> 3;
  int v8 = (v8 + 4) & 7;
  v9 += v124;
  int v125 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v125 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v125) {
        goto LABEL_748;
      }
    }
    else
    {
      int v126 = *v9;
      if (v125 == 1)
      {
        unsigned int v12 = v126 << 24;
      }
      else
      {
        int v127 = (v126 << 16) | (v9[1] << 8);
        if (v125 != 2) {
          v127 |= v9[2];
        }
        unsigned int v12 = v127 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  unsigned int v128 = v12 << v8;
  if ((v115 & 0x80000000) == 0)
  {
    int v129 = 0;
    unsigned int v130 = v113 - v114;
    while (v128 < 0x80000)
    {
      uint64_t v132 = (v8 + 1) >> 3;
      int v8 = (v8 + 1) & 7;
      v9 += v132;
      int v133 = v10 - v9;
      if (v10 - (int)v9 < 4)
      {
        if (v133 < 1)
        {
          unsigned int v12 = 0;
          if (v8 | v133) {
            goto LABEL_748;
          }
        }
        else
        {
          int v134 = *v9;
          if (v133 == 1)
          {
            unsigned int v12 = v134 << 24;
          }
          else
          {
            int v135 = (v134 << 16) | (v9[1] << 8);
            if (v133 != 2) {
              v135 |= v9[2];
            }
            unsigned int v12 = v135 << 8;
          }
        }
      }
      else
      {
        unsigned int v12 = bswap32(*(_DWORD *)v9);
      }
      unsigned int v136 = 0;
      v12 <<= v8;
      do
      {
        char v137 = v8;
        unsigned int v138 = v12;
        uint64_t v139 = (v8 + 1) >> 3;
        int v8 = (v8 + 1) & 7;
        v9 += v139;
        int v140 = v10 - v9;
        if (v10 - (int)v9 < 4)
        {
          if (v140 < 1)
          {
            unsigned int v12 = 0;
            if (v8 | v140) {
              goto LABEL_748;
            }
          }
          else
          {
            int v141 = *v9;
            if (v140 == 1)
            {
              unsigned int v12 = v141 << 24;
            }
            else
            {
              int v142 = (v141 << 16) | (v9[1] << 8);
              if (v140 != 2) {
                v142 |= v9[2];
              }
              unsigned int v12 = v142 << 8;
            }
          }
        }
        else
        {
          unsigned int v12 = bswap32(*(_DWORD *)v9);
        }
        v12 <<= v8;
        ++v136;
      }
      while ((v138 & 0x80000000) == 0);
      if (v136 - 1 > 0x1E) {
        goto LABEL_748;
      }
      unsigned int v143 = ((v137 + 1) & 7) + v136;
      if (v136 <= 0x18)
      {
        int v8 = v143 & 7;
        unsigned int v52 = &v9[v143 >> 3];
LABEL_320:
        int v144 = v10 - v52;
        if (v10 - (int)v52 >= 4) {
          goto LABEL_329;
        }
        if (v144 >= 1)
        {
          int v145 = *v52;
          if (v144 == 1) {
            goto LABEL_332;
          }
          int v146 = (v145 << 16) | (v52[1] << 8);
          if (v144 != 2)
          {
            int v147 = v52[2];
            goto LABEL_337;
          }
          goto LABEL_338;
        }
        goto LABEL_333;
      }
      int v8 = v143 & 7;
      v9 += (v143 - 16) >> 3;
      int v148 = v10 - v9;
      if (v10 - (int)v9 <= 3 && v148 <= 0 && v8 | v148) {
        goto LABEL_747;
      }
      unsigned int v52 = v9 + 2;
      int v144 = v10 - (v9 + 2);
      if (v144 >= 4)
      {
LABEL_329:
        unsigned int v12 = bswap32(*(_DWORD *)v52);
        goto LABEL_339;
      }
      if (v144 >= 1)
      {
        int v145 = *v52;
        if (v144 == 1)
        {
LABEL_332:
          unsigned int v12 = v145 << 24;
          goto LABEL_339;
        }
        int v146 = (v145 << 16) | (v9[3] << 8);
        if (v144 != 2)
        {
          int v147 = v9[4];
LABEL_337:
          v146 |= v147;
        }
LABEL_338:
        unsigned int v12 = v146 << 8;
        goto LABEL_339;
      }
LABEL_333:
      unsigned int v12 = 0;
      if (v8 | v144) {
        goto LABEL_105;
      }
LABEL_339:
      if (v12 << v8 < 0x80000)
      {
        uint64_t v154 = (v8 + 1) >> 3;
        int v8 = (v8 + 1) & 7;
        int v9 = &v52[v154];
        int v155 = v10 - (v52 + v154);
        if (v155 < 4)
        {
          if (v155 < 1)
          {
            unsigned int v12 = 0;
            if (v8 | v155) {
              goto LABEL_748;
            }
          }
          else
          {
            int v156 = *v9;
            if (v155 == 1)
            {
              unsigned int v12 = v156 << 24;
            }
            else
            {
              int v157 = (v156 << 16) | (v9[1] << 8);
              if (v155 != 2) {
                v157 |= v9[2];
              }
              unsigned int v12 = v157 << 8;
            }
          }
        }
        else
        {
          unsigned int v12 = bswap32(*(_DWORD *)v9);
        }
        unsigned int v158 = 0;
        v12 <<= v8;
        do
        {
          char v159 = v8;
          unsigned int v160 = v12;
          uint64_t v161 = (v8 + 1) >> 3;
          int v8 = (v8 + 1) & 7;
          v9 += v161;
          int v162 = v10 - v9;
          if (v10 - (int)v9 < 4)
          {
            if (v162 < 1)
            {
              unsigned int v12 = 0;
              if (v8 | v162) {
                goto LABEL_748;
              }
            }
            else
            {
              int v163 = *v9;
              if (v162 == 1)
              {
                unsigned int v12 = v163 << 24;
              }
              else
              {
                int v164 = (v163 << 16) | (v9[1] << 8);
                if (v162 != 2) {
                  v164 |= v9[2];
                }
                unsigned int v12 = v164 << 8;
              }
            }
          }
          else
          {
            unsigned int v12 = bswap32(*(_DWORD *)v9);
          }
          v12 <<= v8;
          ++v158;
        }
        while ((v160 & 0x80000000) == 0);
        if (v158 - 1 > 0x1E) {
          goto LABEL_748;
        }
        unsigned int v165 = ((v159 + 1) & 7) + v158;
        if (v158 > 0x18)
        {
          int v8 = v165 & 7;
          v9 += (v165 - 16) >> 3;
          int v166 = v10 - v9;
          if (v10 - (int)v9 <= 3 && v166 <= 0 && v8 | v166) {
            goto LABEL_747;
          }
          v9 += 2;
        }
        else
        {
          int v8 = v165 & 7;
          v9 += v165 >> 3;
        }
        int v167 = v10 - v9;
        if (v10 - (int)v9 <= 3 && v167 <= 0 && v8 | v167) {
          goto LABEL_747;
        }
      }
      else
      {
        unsigned int v149 = v8 + 2 * __clz(v12 << v8) + 1;
        uint64_t v150 = v149 >> 3;
        int v8 = v149 & 7;
        int v9 = &v52[v150];
        int v151 = v10 - (v52 + v150);
        if (v151 <= 3 && v151 <= 0 && (v8 | v151) != 0)
        {
LABEL_747:
          unsigned int v12 = 0;
          goto LABEL_748;
        }
      }
      uint64_t v168 = (v8 + 1) >> 3;
      int v8 = (v8 + 1) & 7;
      v9 += v168;
      int v169 = v10 - v9;
      if (v10 - (int)v9 < 4)
      {
        if (v169 < 1)
        {
          unsigned int v12 = 0;
          if (v8 | v169) {
            goto LABEL_748;
          }
        }
        else
        {
          int v170 = *v9;
          if (v169 == 1)
          {
            unsigned int v12 = v170 << 24;
          }
          else
          {
            int v171 = (v170 << 16) | (v9[1] << 8);
            if (v169 != 2) {
              v171 |= v9[2];
            }
            unsigned int v12 = v171 << 8;
          }
        }
      }
      else
      {
        unsigned int v12 = bswap32(*(_DWORD *)v9);
      }
      unsigned int v128 = v12 << v8;
      if (++v129 == v130) {
        goto LABEL_391;
      }
    }
    unsigned int v131 = v8 + 2 * __clz(v128) + 1;
    int v8 = v131 & 7;
    unsigned int v52 = &v9[v131 >> 3];
    goto LABEL_320;
  }
LABEL_391:
  a2[35] = v128 >> 27;
  uint64_t v172 = (v8 + 5) >> 3;
  int v8 = (v8 + 5) & 7;
  v9 += v172;
  int v173 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v173 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v173) {
        goto LABEL_748;
      }
    }
    else
    {
      int v174 = *v9;
      if (v173 == 1)
      {
        unsigned int v12 = v174 << 24;
      }
      else
      {
        int v175 = (v174 << 16) | (v9[1] << 8);
        if (v173 != 2) {
          v175 |= v9[2];
        }
        unsigned int v12 = v175 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  a2[36] = v12 << v8 >> 27;
  uint64_t v176 = (v8 + 5) >> 3;
  int v8 = (v8 + 5) & 7;
  v9 += v176;
  int v177 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v177 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v177) {
        goto LABEL_748;
      }
    }
    else
    {
      int v178 = *v9;
      if (v177 == 1)
      {
        unsigned int v12 = v178 << 24;
      }
      else
      {
        int v179 = (v178 << 16) | (v9[1] << 8);
        if (v177 != 2) {
          v179 |= v9[2];
        }
        unsigned int v12 = v179 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  a2[37] = v12 << v8 >> 27;
  uint64_t v180 = (v8 + 5) >> 3;
  int v8 = (v8 + 5) & 7;
  v9 += v180;
  int v181 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v181 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v181) {
        goto LABEL_748;
      }
    }
    else
    {
      int v182 = *v9;
      if (v181 == 1)
      {
        unsigned int v12 = v182 << 24;
      }
      else
      {
        int v183 = (v182 << 16) | (v9[1] << 8);
        if (v181 != 2) {
          v183 |= v9[2];
        }
        unsigned int v12 = v183 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  a2[38] = v12 << v8 >> 27;
  uint64_t v184 = (v8 + 5) >> 3;
  int v8 = (v8 + 5) & 7;
  v9 += v184;
  int v185 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v185 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v185) {
        goto LABEL_748;
      }
    }
    else
    {
      int v186 = *v9;
      if (v185 == 1)
      {
        unsigned int v12 = v186 << 24;
      }
      else
      {
        int v187 = (v186 << 16) | (v9[1] << 8);
        if (v185 != 2) {
          v187 |= v9[2];
        }
        unsigned int v12 = v187 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  unsigned int v111 = v12 << v8;
LABEL_432:
  a2[21] = v111 >> 31;
  uint64_t v188 = (v8 + 1) >> 3;
  int v8 = (v8 + 1) & 7;
  v9 += v188;
  int v189 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v189 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v189) {
        goto LABEL_748;
      }
    }
    else
    {
      int v190 = *v9;
      if (v189 == 1)
      {
        unsigned int v12 = v190 << 24;
      }
      else
      {
        int v191 = (v190 << 16) | (v9[1] << 8);
        if (v189 != 2) {
          v191 |= v9[2];
        }
        unsigned int v12 = v191 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  v12 <<= v8;
  if ((v111 & 0x80000000) != 0)
  {
    if (v12 < 0x80000) {
      goto LABEL_748;
    }
    unsigned int v192 = __clz(v12);
    if (v192) {
      unsigned int v193 = v12 << (v192 + 1) >> -(char)v192;
    }
    else {
      unsigned int v193 = 0;
    }
    int v194 = -1 << v192;
    int v195 = v193 + ~(-1 << v192);
    a2[32] = v195;
    unsigned int v196 = v192 + v8 + v192 + 1;
    int v8 = v196 & 7;
    v9 += v196 >> 3;
    int v197 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v197 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v197) {
          goto LABEL_748;
        }
      }
      else
      {
        int v198 = *v9;
        if (v197 == 1)
        {
          unsigned int v12 = v198 << 24;
        }
        else
        {
          int v199 = (v198 << 16) | (v9[1] << 8);
          if (v197 != 2) {
            v199 |= v9[2];
          }
          unsigned int v12 = v199 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v195 > 31) {
      goto LABEL_748;
    }
    a2[33] = v12 >> 28;
    uint64_t v200 = (v8 + 4) >> 3;
    int v8 = (v8 + 4) & 7;
    v9 += v200;
    int v201 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v201 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v201) {
          goto LABEL_748;
        }
      }
      else
      {
        int v202 = *v9;
        if (v201 == 1)
        {
          unsigned int v12 = v202 << 24;
        }
        else
        {
          int v203 = (v202 << 16) | (v9[1] << 8);
          if (v201 != 2) {
            v203 |= v9[2];
          }
          unsigned int v12 = v203 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    a2[34] = v12 << v8 >> 28;
    uint64_t v204 = (v8 + 4) >> 3;
    int v8 = (v8 + 4) & 7;
    v9 += v204;
    int v205 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v205 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v205) {
          goto LABEL_748;
        }
      }
      else
      {
        int v206 = *v9;
        if (v205 == 1)
        {
          unsigned int v12 = v206 << 24;
        }
        else
        {
          int v207 = (v206 << 16) | (v9[1] << 8);
          if (v205 != 2) {
            v207 |= v9[2];
          }
          unsigned int v12 = v207 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    unsigned int v208 = v12 << v8;
    if ((v195 & 0x80000000) == 0)
    {
      int v209 = 0;
      unsigned int v210 = v193 - v194;
      while (v208 < 0x80000)
      {
        uint64_t v212 = (v8 + 1) >> 3;
        int v8 = (v8 + 1) & 7;
        v9 += v212;
        int v213 = v10 - v9;
        if (v10 - (int)v9 < 4)
        {
          if (v213 < 1)
          {
            unsigned int v12 = 0;
            if (v8 | v213) {
              goto LABEL_748;
            }
          }
          else
          {
            int v214 = *v9;
            if (v213 == 1)
            {
              unsigned int v12 = v214 << 24;
            }
            else
            {
              int v215 = (v214 << 16) | (v9[1] << 8);
              if (v213 != 2) {
                v215 |= v9[2];
              }
              unsigned int v12 = v215 << 8;
            }
          }
        }
        else
        {
          unsigned int v12 = bswap32(*(_DWORD *)v9);
        }
        unsigned int v216 = 0;
        v12 <<= v8;
        do
        {
          char v217 = v8;
          unsigned int v218 = v12;
          uint64_t v219 = (v8 + 1) >> 3;
          int v8 = (v8 + 1) & 7;
          v9 += v219;
          int v220 = v10 - v9;
          if (v10 - (int)v9 < 4)
          {
            if (v220 < 1)
            {
              unsigned int v12 = 0;
              if (v8 | v220) {
                goto LABEL_748;
              }
            }
            else
            {
              int v221 = *v9;
              if (v220 == 1)
              {
                unsigned int v12 = v221 << 24;
              }
              else
              {
                int v222 = (v221 << 16) | (v9[1] << 8);
                if (v220 != 2) {
                  v222 |= v9[2];
                }
                unsigned int v12 = v222 << 8;
              }
            }
          }
          else
          {
            unsigned int v12 = bswap32(*(_DWORD *)v9);
          }
          v12 <<= v8;
          ++v216;
        }
        while ((v218 & 0x80000000) == 0);
        if (v216 - 1 > 0x1E) {
          goto LABEL_748;
        }
        unsigned int v223 = ((v217 + 1) & 7) + v216;
        if (v216 <= 0x18)
        {
          int v8 = v223 & 7;
          unsigned int v52 = &v9[v223 >> 3];
LABEL_507:
          int v224 = v10 - v52;
          if (v10 - (int)v52 >= 4) {
            goto LABEL_516;
          }
          if (v224 >= 1)
          {
            int v225 = *v52;
            if (v224 == 1) {
              goto LABEL_519;
            }
            int v226 = (v225 << 16) | (v52[1] << 8);
            if (v224 != 2)
            {
              int v227 = v52[2];
              goto LABEL_524;
            }
            goto LABEL_525;
          }
          goto LABEL_520;
        }
        int v8 = v223 & 7;
        v9 += (v223 - 16) >> 3;
        int v228 = v10 - v9;
        if (v10 - (int)v9 <= 3 && v228 <= 0 && v8 | v228) {
          goto LABEL_747;
        }
        unsigned int v52 = v9 + 2;
        int v224 = v10 - (v9 + 2);
        if (v224 >= 4)
        {
LABEL_516:
          unsigned int v12 = bswap32(*(_DWORD *)v52);
          goto LABEL_526;
        }
        if (v224 >= 1)
        {
          int v225 = *v52;
          if (v224 == 1)
          {
LABEL_519:
            unsigned int v12 = v225 << 24;
            goto LABEL_526;
          }
          int v226 = (v225 << 16) | (v9[3] << 8);
          if (v224 != 2)
          {
            int v227 = v9[4];
LABEL_524:
            v226 |= v227;
          }
LABEL_525:
          unsigned int v12 = v226 << 8;
          goto LABEL_526;
        }
LABEL_520:
        unsigned int v12 = 0;
        if (v8 | v224) {
          goto LABEL_105;
        }
LABEL_526:
        if (v12 << v8 < 0x80000)
        {
          uint64_t v234 = (v8 + 1) >> 3;
          int v8 = (v8 + 1) & 7;
          int v9 = &v52[v234];
          int v235 = v10 - (v52 + v234);
          if (v235 < 4)
          {
            if (v235 < 1)
            {
              unsigned int v12 = 0;
              if (v8 | v235) {
                goto LABEL_748;
              }
            }
            else
            {
              int v236 = *v9;
              if (v235 == 1)
              {
                unsigned int v12 = v236 << 24;
              }
              else
              {
                int v237 = (v236 << 16) | (v9[1] << 8);
                if (v235 != 2) {
                  v237 |= v9[2];
                }
                unsigned int v12 = v237 << 8;
              }
            }
          }
          else
          {
            unsigned int v12 = bswap32(*(_DWORD *)v9);
          }
          unsigned int v238 = 0;
          v12 <<= v8;
          do
          {
            char v239 = v8;
            unsigned int v240 = v12;
            uint64_t v241 = (v8 + 1) >> 3;
            int v8 = (v8 + 1) & 7;
            v9 += v241;
            int v242 = v10 - v9;
            if (v10 - (int)v9 < 4)
            {
              if (v242 < 1)
              {
                unsigned int v12 = 0;
                if (v8 | v242) {
                  goto LABEL_748;
                }
              }
              else
              {
                int v243 = *v9;
                if (v242 == 1)
                {
                  unsigned int v12 = v243 << 24;
                }
                else
                {
                  int v244 = (v243 << 16) | (v9[1] << 8);
                  if (v242 != 2) {
                    v244 |= v9[2];
                  }
                  unsigned int v12 = v244 << 8;
                }
              }
            }
            else
            {
              unsigned int v12 = bswap32(*(_DWORD *)v9);
            }
            v12 <<= v8;
            ++v238;
          }
          while ((v240 & 0x80000000) == 0);
          if (v238 - 1 > 0x1E) {
            goto LABEL_748;
          }
          unsigned int v245 = ((v239 + 1) & 7) + v238;
          if (v238 > 0x18)
          {
            int v8 = v245 & 7;
            v9 += (v245 - 16) >> 3;
            int v246 = v10 - v9;
            if (v10 - (int)v9 <= 3 && v246 <= 0 && v8 | v246) {
              goto LABEL_747;
            }
            v9 += 2;
          }
          else
          {
            int v8 = v245 & 7;
            v9 += v245 >> 3;
          }
          int v247 = v10 - v9;
          if (v10 - (int)v9 <= 3 && v247 <= 0 && v8 | v247) {
            goto LABEL_747;
          }
        }
        else
        {
          unsigned int v229 = v8 + 2 * __clz(v12 << v8) + 1;
          uint64_t v230 = v229 >> 3;
          int v8 = v229 & 7;
          int v9 = &v52[v230];
          int v231 = v10 - (v52 + v230);
          if (v231 <= 3 && v231 <= 0 && (v8 | v231) != 0) {
            goto LABEL_747;
          }
        }
        uint64_t v248 = (v8 + 1) >> 3;
        int v8 = (v8 + 1) & 7;
        v9 += v248;
        int v249 = v10 - v9;
        if (v10 - (int)v9 < 4)
        {
          if (v249 < 1)
          {
            unsigned int v12 = 0;
            if (v8 | v249) {
              goto LABEL_748;
            }
          }
          else
          {
            int v250 = *v9;
            if (v249 == 1)
            {
              unsigned int v12 = v250 << 24;
            }
            else
            {
              int v251 = (v250 << 16) | (v9[1] << 8);
              if (v249 != 2) {
                v251 |= v9[2];
              }
              unsigned int v12 = v251 << 8;
            }
          }
        }
        else
        {
          unsigned int v12 = bswap32(*(_DWORD *)v9);
        }
        if (*((_DWORD *)a1 + 2) < *((_DWORD *)a1 + 4) - *(_DWORD *)a1) {
          goto LABEL_746;
        }
        unsigned int v208 = v12 << v8;
        if (++v209 == v210) {
          goto LABEL_579;
        }
      }
      unsigned int v211 = v8 + 2 * __clz(v208) + 1;
      int v8 = v211 & 7;
      unsigned int v52 = &v9[v211 >> 3];
      goto LABEL_507;
    }
LABEL_579:
    a2[35] = v208 >> 27;
    uint64_t v252 = (v8 + 5) >> 3;
    int v8 = (v8 + 5) & 7;
    v9 += v252;
    int v253 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v253 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v253) {
          goto LABEL_748;
        }
      }
      else
      {
        int v254 = *v9;
        if (v253 == 1)
        {
          unsigned int v12 = v254 << 24;
        }
        else
        {
          int v255 = (v254 << 16) | (v9[1] << 8);
          if (v253 != 2) {
            v255 |= v9[2];
          }
          unsigned int v12 = v255 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    a2[36] = v12 << v8 >> 27;
    uint64_t v256 = (v8 + 5) >> 3;
    int v8 = (v8 + 5) & 7;
    v9 += v256;
    int v257 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v257 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v257) {
          goto LABEL_748;
        }
      }
      else
      {
        int v258 = *v9;
        if (v257 == 1)
        {
          unsigned int v12 = v258 << 24;
        }
        else
        {
          int v259 = (v258 << 16) | (v9[1] << 8);
          if (v257 != 2) {
            v259 |= v9[2];
          }
          unsigned int v12 = v259 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    a2[37] = v12 << v8 >> 27;
    uint64_t v260 = (v8 + 5) >> 3;
    int v8 = (v8 + 5) & 7;
    v9 += v260;
    int v261 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v261 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v261) {
          goto LABEL_748;
        }
      }
      else
      {
        int v262 = *v9;
        if (v261 == 1)
        {
          unsigned int v12 = v262 << 24;
        }
        else
        {
          int v263 = (v262 << 16) | (v9[1] << 8);
          if (v261 != 2) {
            v263 |= v9[2];
          }
          unsigned int v12 = v263 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    a2[38] = v12 << v8 >> 27;
    uint64_t v264 = (v8 + 5) >> 3;
    int v8 = (v8 + 5) & 7;
    v9 += v264;
    int v265 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v265 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v265) {
          goto LABEL_748;
        }
      }
      else
      {
        int v266 = *v9;
        if (v265 == 1)
        {
          unsigned int v12 = v266 << 24;
        }
        else
        {
          int v267 = (v266 << 16) | (v9[1] << 8);
          if (v265 != 2) {
            v267 |= v9[2];
          }
          unsigned int v12 = v267 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
  }
  if (*((_DWORD *)a1 + 2) < *((_DWORD *)a1 + 4) - *(_DWORD *)a1)
  {
LABEL_746:
    uint64_t v321 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    return v321;
  }
  if (a2[20] || a2[21])
  {
    a2[22] = v12 >> 31;
    uint64_t v268 = (v8 + 1) >> 3;
    int v8 = (v8 + 1) & 7;
    v9 += v268;
    int v269 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v269 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v269) {
          goto LABEL_748;
        }
      }
      else
      {
        int v270 = *v9;
        if (v269 == 1)
        {
          unsigned int v12 = v270 << 24;
        }
        else
        {
          int v271 = (v270 << 16) | (v9[1] << 8);
          if (v269 != 2) {
            v271 |= v9[2];
          }
          unsigned int v12 = v271 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
  }
  a2[23] = v12 >> 31;
  uint64_t v272 = (v8 + 1) >> 3;
  int v8 = (v8 + 1) & 7;
  v9 += v272;
  int v273 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v273 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v273) {
        goto LABEL_748;
      }
    }
    else
    {
      int v274 = *v9;
      if (v273 == 1)
      {
        unsigned int v12 = v274 << 24;
      }
      else
      {
        int v275 = (v274 << 16) | (v9[1] << 8);
        if (v273 != 2) {
          v275 |= v9[2];
        }
        unsigned int v12 = v275 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  unsigned int v276 = v12 << v8;
  a2[24] = v12 << v8 >> 31;
  uint64_t v277 = (v8 + 1) >> 3;
  int v8 = (v8 + 1) & 7;
  v9 += v277;
  int v278 = v10 - v9;
  if (v10 - (int)v9 < 4)
  {
    if (v278 < 1)
    {
      unsigned int v12 = 0;
      if (v8 | v278) {
        goto LABEL_748;
      }
    }
    else
    {
      int v279 = *v9;
      if (v278 == 1)
      {
        unsigned int v12 = v279 << 24;
      }
      else
      {
        int v280 = (v279 << 16) | (v9[1] << 8);
        if (v278 != 2) {
          v280 |= v9[2];
        }
        unsigned int v12 = v280 << 8;
      }
    }
  }
  else
  {
    unsigned int v12 = bswap32(*(_DWORD *)v9);
  }
  v12 <<= v8;
  if ((v276 & 0x80000000) != 0)
  {
    a2[25] = v12 >> 31;
    uint64_t v281 = (v8 + 1) >> 3;
    int v8 = (v8 + 1) & 7;
    v9 += v281;
    int v282 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v282 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v282) {
          goto LABEL_748;
        }
      }
      else
      {
        int v283 = *v9;
        if (v282 == 1)
        {
          unsigned int v12 = v283 << 24;
        }
        else
        {
          int v284 = (v283 << 16) | (v9[1] << 8);
          if (v282 != 2) {
            v284 |= v9[2];
          }
          unsigned int v12 = v284 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000) {
      goto LABEL_748;
    }
    unsigned int v285 = __clz(v12);
    unsigned int v286 = v12 << (v285 + 1) >> -(char)v285;
    if (!v285) {
      unsigned int v286 = 0;
    }
    a2[26] = v286 + ~(-1 << v285);
    unsigned int v287 = v285 + v8 + v285 + 1;
    int v8 = v287 & 7;
    v9 += v287 >> 3;
    int v288 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v288 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v288) {
          goto LABEL_748;
        }
      }
      else
      {
        int v289 = *v9;
        if (v288 == 1)
        {
          unsigned int v12 = v289 << 24;
        }
        else
        {
          int v290 = (v289 << 16) | (v9[1] << 8);
          if (v288 != 2) {
            v290 |= v9[2];
          }
          unsigned int v12 = v290 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000) {
      goto LABEL_748;
    }
    unsigned int v291 = __clz(v12);
    unsigned int v292 = v12 << (v291 + 1) >> -(char)v291;
    if (!v291) {
      unsigned int v292 = 0;
    }
    a2[27] = v292 + ~(-1 << v291);
    unsigned int v293 = v291 + v8 + v291 + 1;
    int v8 = v293 & 7;
    v9 += v293 >> 3;
    int v294 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v294 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v294) {
          goto LABEL_748;
        }
      }
      else
      {
        int v295 = *v9;
        if (v294 == 1)
        {
          unsigned int v12 = v295 << 24;
        }
        else
        {
          int v296 = (v295 << 16) | (v9[1] << 8);
          if (v294 != 2) {
            v296 |= v9[2];
          }
          unsigned int v12 = v296 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000) {
      goto LABEL_748;
    }
    unsigned int v297 = __clz(v12);
    unsigned int v298 = v12 << (v297 + 1) >> -(char)v297;
    if (!v297) {
      unsigned int v298 = 0;
    }
    a2[28] = v298 + ~(-1 << v297);
    unsigned int v299 = v297 + v8 + v297 + 1;
    int v8 = v299 & 7;
    v9 += v299 >> 3;
    int v300 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v300 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v300) {
          goto LABEL_748;
        }
      }
      else
      {
        int v301 = *v9;
        if (v300 == 1)
        {
          unsigned int v12 = v301 << 24;
        }
        else
        {
          int v302 = (v301 << 16) | (v9[1] << 8);
          if (v300 != 2) {
            v302 |= v9[2];
          }
          unsigned int v12 = v302 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000) {
      goto LABEL_748;
    }
    unsigned int v303 = __clz(v12);
    unsigned int v304 = v12 << (v303 + 1) >> -(char)v303;
    if (!v303) {
      unsigned int v304 = 0;
    }
    a2[29] = v304 + ~(-1 << v303);
    unsigned int v305 = v303 + v8 + v303 + 1;
    int v8 = v305 & 7;
    v9 += v305 >> 3;
    int v306 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v306 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v306) {
          goto LABEL_748;
        }
      }
      else
      {
        int v307 = *v9;
        if (v306 == 1)
        {
          unsigned int v12 = v307 << 24;
        }
        else
        {
          int v308 = (v307 << 16) | (v9[1] << 8);
          if (v306 != 2) {
            v308 |= v9[2];
          }
          unsigned int v12 = v308 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000) {
      goto LABEL_748;
    }
    unsigned int v309 = __clz(v12);
    unsigned int v310 = v12 << (v309 + 1) >> -(char)v309;
    if (!v309) {
      unsigned int v310 = 0;
    }
    a2[30] = v310 + ~(-1 << v309);
    unsigned int v311 = v309 + v8 + v309 + 1;
    int v8 = v311 & 7;
    v9 += v311 >> 3;
    int v312 = v10 - v9;
    if (v10 - (int)v9 < 4)
    {
      if (v312 < 1)
      {
        unsigned int v12 = 0;
        if (v8 | v312) {
          goto LABEL_748;
        }
      }
      else
      {
        int v313 = *v9;
        if (v312 == 1)
        {
          unsigned int v12 = v313 << 24;
        }
        else
        {
          int v314 = (v313 << 16) | (v9[1] << 8);
          if (v312 != 2) {
            v314 |= v9[2];
          }
          unsigned int v12 = v314 << 8;
        }
      }
    }
    else
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000) {
      goto LABEL_748;
    }
    unsigned int v315 = __clz(v12);
    unsigned int v316 = v12 << (v315 + 1) >> -(char)v315;
    if (!v315) {
      unsigned int v316 = 0;
    }
    a2[31] = v316 + ~(-1 << v315);
    unsigned int v317 = v315 + v8 + v315 + 1;
    int v8 = v317 & 7;
    v9 += v317 >> 3;
    int v318 = v10 - v9;
    if (v318 >= 4)
    {
      unsigned int v12 = bswap32(*(_DWORD *)v9);
      goto LABEL_743;
    }
    if (v318 >= 1)
    {
      int v319 = *v9;
      if (v318 == 1)
      {
        unsigned int v12 = v319 << 24;
      }
      else
      {
        int v320 = (v319 << 16) | (v9[1] << 8);
        if (v318 != 2) {
          v320 |= v9[2];
        }
        unsigned int v12 = v320 << 8;
      }
      goto LABEL_743;
    }
    unsigned int v12 = 0;
    if (!(v8 | v318))
    {
LABEL_743:
      v12 <<= v8;
      goto LABEL_744;
    }
LABEL_748:
    uint64_t v321 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    if (v321) {
      return v321;
    }
  }
LABEL_744:
  uint64_t v321 = 0;
  a1[2] = (uint64_t)v9;
  *((_DWORD *)a1 + 6) = v12;
  *((unsigned char *)a1 + 28) = v8;
  return v321;
}

uint64_t PullSliceHeaderPredWeightTable(uint64_t *a1, _DWORD *a2, uint64_t a3, int a4)
{
  if (*(_DWORD *)(a3 + 8)) {
    int v5 = 0;
  }
  else {
    int v5 = *(_DWORD *)(a3 + 4);
  }
  unsigned int v6 = (unsigned __int8 *)a1[2];
  unsigned int v7 = *((_DWORD *)a1 + 6);
  int v8 = *((unsigned __int8 *)a1 + 28);
  int v9 = *((_DWORD *)a1 + 2);
  uint64_t v10 = *a1;
  if (a4)
  {
    if (v7 < 0x80000) {
      goto LABEL_243;
    }
  }
  else if (v7 < 0x80000)
  {
    goto LABEL_245;
  }
  unsigned int v11 = __clz(v7);
  unsigned int v12 = v7 << (v11 + 1) >> -(char)v11;
  if (!v11) {
    unsigned int v12 = 0;
  }
  a2[17] = v12 + ~(-1 << v11);
  unsigned int v13 = v11 + 1 + v11 + v8;
  int v8 = v13 & 7;
  v6 += v13 >> 3;
  int v14 = v10 + v9;
  int v15 = v14 - v6;
  if (v14 - (int)v6 < 4)
  {
    if (v15 < 1)
    {
      BOOL v18 = (v8 | v15 | v5) == 0;
      unsigned int v7 = 0;
      if (a4)
      {
        if (!v18) {
          goto LABEL_243;
        }
      }
      else if (!v18)
      {
        goto LABEL_245;
      }
      goto LABEL_40;
    }
    int v17 = *v6;
    if (v15 == 1)
    {
      unsigned int v16 = v17 << 24;
    }
    else
    {
      int v19 = (v17 << 16) | (v6[1] << 8);
      if (v15 != 2) {
        v19 |= v6[2];
      }
      unsigned int v16 = v19 << 8;
    }
  }
  else
  {
    unsigned int v16 = bswap32(*(_DWORD *)v6);
  }
  unsigned int v7 = v16 << v8;
  if (v5)
  {
    if (a4)
    {
      if (v7 < 0x80000) {
        goto LABEL_243;
      }
    }
    else if (v7 < 0x80000)
    {
      goto LABEL_245;
    }
    unsigned int v20 = __clz(v7);
    unsigned int v21 = v7 << (v20 + 1) >> -(char)v20;
    if (!v20) {
      unsigned int v21 = 0;
    }
    a2[18] = v21 + ~(-1 << v20);
    unsigned int v22 = v20 + v8 + v20 + 1;
    int v8 = v22 & 7;
    v6 += v22 >> 3;
    int v23 = v14 - v6;
    if (v14 - (int)v6 >= 4)
    {
      unsigned int v7 = bswap32(*(_DWORD *)v6);
      goto LABEL_42;
    }
    if (v23 >= 1)
    {
      int v24 = *v6;
      if (v23 == 1)
      {
        unsigned int v7 = v24 << 24;
      }
      else
      {
        int v26 = (v24 << 16) | (v6[1] << 8);
        if (v23 != 2) {
          v26 |= v6[2];
        }
        unsigned int v7 = v26 << 8;
      }
      goto LABEL_42;
    }
    int v25 = v8 | v23;
    unsigned int v7 = 0;
    if (a4)
    {
      if (v25) {
        goto LABEL_243;
      }
      goto LABEL_42;
    }
    if (!v25)
    {
LABEL_42:
      char v27 = 0;
      v7 <<= v8;
      goto LABEL_43;
    }
LABEL_245:
    uint64_t result = 4294954582;
    goto LABEL_246;
  }
LABEL_40:
  char v27 = 1;
LABEL_43:
  unsigned int v28 = a2[13];
  if (v28 - 32 < 0xFFFFFFDF) {
    goto LABEL_249;
  }
  int v29 = 0;
  while (1)
  {
    uint64_t v30 = (v8 + 1) >> 3;
    int v8 = (v8 + 1) & 7;
    v6 += v30;
    int v31 = v14 - v6;
    if (v14 - (int)v6 >= 4)
    {
      unsigned int v32 = bswap32(*(_DWORD *)v6);
      goto LABEL_62;
    }
    if (v31 < 1)
    {
      if (v8 | v31) {
        BOOL v34 = 1;
      }
      else {
        BOOL v34 = (v7 & 0x80000000) != 0;
      }
      char v35 = !v34;
      if (!a4)
      {
        if ((v35 & 1) == 0)
        {
LABEL_244:
          unsigned int v7 = 0;
          goto LABEL_245;
        }
LABEL_85:
        unsigned int v37 = 0;
        unsigned int v7 = 0;
        if ((v27 & 1) == 0) {
          goto LABEL_96;
        }
        goto LABEL_139;
      }
      if (v35) {
        goto LABEL_85;
      }
LABEL_242:
      unsigned int v7 = 0;
LABEL_243:
      uint64_t result = 4294954582;
      goto LABEL_247;
    }
    int v33 = *v6;
    if (v31 == 1)
    {
      unsigned int v32 = v33 << 24;
    }
    else
    {
      int v36 = (v33 << 16) | (v6[1] << 8);
      if (v31 != 2) {
        v36 |= v6[2];
      }
      unsigned int v32 = v36 << 8;
    }
LABEL_62:
    unsigned int v37 = v32 << v8;
    if ((v7 & 0x80000000) == 0) {
      goto LABEL_95;
    }
    if (a4)
    {
      if (v37 < 0x80000)
      {
LABEL_250:
        uint64_t result = 4294954582;
        unsigned int v7 = v37;
        goto LABEL_247;
      }
    }
    else if (v37 < 0x80000)
    {
LABEL_251:
      uint64_t result = 4294954582;
      unsigned int v7 = v37;
      goto LABEL_246;
    }
    unsigned int v38 = v8 + 2 * __clz(v37) + 1;
    int v8 = v38 & 7;
    v6 += v38 >> 3;
    int v39 = v14 - v6;
    if (v14 - (int)v6 < 4) {
      break;
    }
    unsigned int v40 = bswap32(*(_DWORD *)v6);
LABEL_75:
    unsigned int v7 = v40 << v8;
    if (a4)
    {
      if (v7 < 0x80000) {
        goto LABEL_243;
      }
    }
    else if (v7 < 0x80000)
    {
      goto LABEL_245;
    }
    unsigned int v43 = v8 + 2 * __clz(v7) + 1;
    int v8 = v43 & 7;
    v6 += v43 >> 3;
    int v44 = v14 - v6;
    if (v14 - (int)v6 < 4)
    {
      if (v44 < 1)
      {
        int v46 = v8 | v44;
        unsigned int v7 = 0;
        if (a4)
        {
          if (v46) {
            goto LABEL_243;
          }
        }
        else if (v46)
        {
          goto LABEL_245;
        }
      }
      else
      {
        int v45 = *v6;
        if (v44 == 1)
        {
          unsigned int v7 = v45 << 24;
        }
        else
        {
          int v47 = (v45 << 16) | (v6[1] << 8);
          if (v44 != 2) {
            v47 |= v6[2];
          }
          unsigned int v7 = v47 << 8;
        }
      }
    }
    else
    {
      unsigned int v7 = bswap32(*(_DWORD *)v6);
    }
    unsigned int v37 = v7 << v8;
LABEL_95:
    unsigned int v7 = v37;
    if ((v27 & 1) == 0)
    {
LABEL_96:
      uint64_t v48 = (v8 + 1) >> 3;
      int v8 = (v8 + 1) & 7;
      v6 += v48;
      int v49 = v14 - v6;
      if (v14 - (int)v6 < 4)
      {
        if (v49 < 1)
        {
          int v51 = v8 | v49;
          unsigned int v7 = 0;
          if (a4)
          {
            if (v51) {
              goto LABEL_243;
            }
          }
          else if (v51)
          {
            goto LABEL_245;
          }
        }
        else
        {
          int v50 = *v6;
          if (v49 == 1)
          {
            unsigned int v7 = v50 << 24;
          }
          else
          {
            int v52 = (v50 << 16) | (v6[1] << 8);
            if (v49 != 2) {
              v52 |= v6[2];
            }
            unsigned int v7 = v52 << 8;
          }
        }
      }
      else
      {
        unsigned int v7 = bswap32(*(_DWORD *)v6);
      }
      v7 <<= v8;
      if ((v37 & 0x80000000) != 0)
      {
        char v53 = 1;
        do
        {
          char v54 = v53;
          if (a4)
          {
            if (v7 < 0x80000) {
              goto LABEL_243;
            }
          }
          else if (v7 < 0x80000)
          {
            goto LABEL_245;
          }
          unsigned int v55 = v8 + 2 * __clz(v7) + 1;
          int v8 = v55 & 7;
          v6 += v55 >> 3;
          int v56 = v14 - v6;
          if (v14 - (int)v6 < 4)
          {
            if (v56 < 1) {
              goto LABEL_240;
            }
            int v58 = *v6;
            if (v56 == 1)
            {
              unsigned int v57 = v58 << 24;
            }
            else
            {
              int v59 = (v58 << 16) | (v6[1] << 8);
              if (v56 != 2) {
                v59 |= v6[2];
              }
              unsigned int v57 = v59 << 8;
            }
          }
          else
          {
            unsigned int v57 = bswap32(*(_DWORD *)v6);
          }
          unsigned int v7 = v57 << v8;
          if (a4)
          {
            if (v7 < 0x80000) {
              goto LABEL_243;
            }
          }
          else if (v7 < 0x80000)
          {
            goto LABEL_245;
          }
          unsigned int v60 = v8 + 2 * __clz(v7) + 1;
          int v8 = v60 & 7;
          v6 += v60 >> 3;
          int v61 = v14 - v6;
          if (v14 - (int)v6 < 4)
          {
            if (v61 < 1)
            {
              int v63 = v8 | v61;
              unsigned int v7 = 0;
              if (a4)
              {
                if (v63) {
                  goto LABEL_243;
                }
              }
              else if (v63)
              {
                goto LABEL_245;
              }
            }
            else
            {
              int v62 = *v6;
              if (v61 == 1)
              {
                unsigned int v7 = v62 << 24;
              }
              else
              {
                int v64 = (v62 << 16) | (v6[1] << 8);
                if (v61 != 2) {
                  v64 |= v6[2];
                }
                unsigned int v7 = v64 << 8;
              }
            }
          }
          else
          {
            unsigned int v7 = bswap32(*(_DWORD *)v6);
          }
          char v53 = 0;
          v7 <<= v8;
        }
        while ((v54 & 1) != 0);
      }
    }
LABEL_139:
    if (++v29 > v28)
    {
      int v65 = a2[4];
      if (v65 != 6 && v65 != 1)
      {
        uint64_t result = 0;
        goto LABEL_247;
      }
      unsigned int v66 = a2[14];
      if (v66 - 32 >= 0xFFFFFFDF)
      {
        int v67 = 0;
        while (1)
        {
          uint64_t v68 = (v8 + 1) >> 3;
          int v8 = (v8 + 1) & 7;
          v6 += v68;
          int v69 = v14 - v6;
          if (v14 - (int)v6 < 4)
          {
            if (v69 < 1)
            {
              if (v8 | v69) {
                BOOL v72 = 1;
              }
              else {
                BOOL v72 = (v7 & 0x80000000) != 0;
              }
              char v73 = !v72;
              if (a4)
              {
                if ((v73 & 1) == 0) {
                  goto LABEL_242;
                }
              }
              else if ((v73 & 1) == 0)
              {
                goto LABEL_244;
              }
              unsigned int v37 = 0;
              unsigned int v7 = 0;
              if ((v27 & 1) == 0) {
                goto LABEL_195;
              }
              goto LABEL_238;
            }
            int v71 = *v6;
            if (v69 == 1)
            {
              unsigned int v70 = v71 << 24;
            }
            else
            {
              int v74 = (v71 << 16) | (v6[1] << 8);
              if (v69 != 2) {
                v74 |= v6[2];
              }
              unsigned int v70 = v74 << 8;
            }
          }
          else
          {
            unsigned int v70 = bswap32(*(_DWORD *)v6);
          }
          unsigned int v37 = v70 << v8;
          if ((v7 & 0x80000000) != 0)
          {
            if (a4)
            {
              if (v37 < 0x80000) {
                goto LABEL_250;
              }
            }
            else if (v37 < 0x80000)
            {
              goto LABEL_251;
            }
            unsigned int v75 = v8 + 2 * __clz(v37) + 1;
            int v8 = v75 & 7;
            v6 += v75 >> 3;
            int v76 = v14 - v6;
            if (v14 - (int)v6 < 4)
            {
              if (v76 < 1) {
                goto LABEL_240;
              }
              int v78 = *v6;
              if (v76 == 1)
              {
                unsigned int v77 = v78 << 24;
              }
              else
              {
                int v79 = (v78 << 16) | (v6[1] << 8);
                if (v76 != 2) {
                  v79 |= v6[2];
                }
                unsigned int v77 = v79 << 8;
              }
            }
            else
            {
              unsigned int v77 = bswap32(*(_DWORD *)v6);
            }
            unsigned int v7 = v77 << v8;
            if (a4)
            {
              if (v7 < 0x80000) {
                goto LABEL_243;
              }
            }
            else if (v7 < 0x80000)
            {
              goto LABEL_245;
            }
            unsigned int v80 = v8 + 2 * __clz(v7) + 1;
            int v8 = v80 & 7;
            v6 += v80 >> 3;
            int v81 = v14 - v6;
            if (v14 - (int)v6 < 4)
            {
              if (v81 < 1)
              {
                int v83 = v8 | v81;
                unsigned int v7 = 0;
                if (a4)
                {
                  if (v83) {
                    goto LABEL_243;
                  }
                }
                else if (v83)
                {
                  goto LABEL_245;
                }
              }
              else
              {
                int v82 = *v6;
                if (v81 == 1)
                {
                  unsigned int v7 = v82 << 24;
                }
                else
                {
                  int v84 = (v82 << 16) | (v6[1] << 8);
                  if (v81 != 2) {
                    v84 |= v6[2];
                  }
                  unsigned int v7 = v84 << 8;
                }
              }
            }
            else
            {
              unsigned int v7 = bswap32(*(_DWORD *)v6);
            }
            unsigned int v37 = v7 << v8;
          }
          unsigned int v7 = v37;
          if ((v27 & 1) == 0)
          {
LABEL_195:
            uint64_t v85 = (v8 + 1) >> 3;
            int v8 = (v8 + 1) & 7;
            v6 += v85;
            int v86 = v14 - v6;
            if (v14 - (int)v6 < 4)
            {
              if (v86 < 1)
              {
                int v88 = v8 | v86;
                unsigned int v7 = 0;
                if (a4)
                {
                  if (v88) {
                    goto LABEL_243;
                  }
                }
                else if (v88)
                {
                  goto LABEL_245;
                }
              }
              else
              {
                int v87 = *v6;
                if (v86 == 1)
                {
                  unsigned int v7 = v87 << 24;
                }
                else
                {
                  int v89 = (v87 << 16) | (v6[1] << 8);
                  if (v86 != 2) {
                    v89 |= v6[2];
                  }
                  unsigned int v7 = v89 << 8;
                }
              }
            }
            else
            {
              unsigned int v7 = bswap32(*(_DWORD *)v6);
            }
            v7 <<= v8;
            if ((v37 & 0x80000000) != 0)
            {
              char v90 = 1;
              do
              {
                char v91 = v90;
                if (a4)
                {
                  if (v7 < 0x80000) {
                    goto LABEL_243;
                  }
                }
                else if (v7 < 0x80000)
                {
                  goto LABEL_245;
                }
                unsigned int v92 = v8 + 2 * __clz(v7) + 1;
                int v8 = v92 & 7;
                v6 += v92 >> 3;
                int v93 = v14 - v6;
                if (v14 - (int)v6 < 4)
                {
                  if (v93 < 1) {
                    goto LABEL_240;
                  }
                  int v95 = *v6;
                  if (v93 == 1)
                  {
                    unsigned int v94 = v95 << 24;
                  }
                  else
                  {
                    int v96 = (v95 << 16) | (v6[1] << 8);
                    if (v93 != 2) {
                      v96 |= v6[2];
                    }
                    unsigned int v94 = v96 << 8;
                  }
                }
                else
                {
                  unsigned int v94 = bswap32(*(_DWORD *)v6);
                }
                unsigned int v7 = v94 << v8;
                if (a4)
                {
                  if (v7 < 0x80000) {
                    goto LABEL_243;
                  }
                }
                else if (v7 < 0x80000)
                {
                  goto LABEL_245;
                }
                unsigned int v97 = v8 + 2 * __clz(v7) + 1;
                int v8 = v97 & 7;
                v6 += v97 >> 3;
                int v98 = v14 - v6;
                if (v14 - (int)v6 < 4)
                {
                  if (v98 < 1)
                  {
                    int v100 = v8 | v98;
                    unsigned int v7 = 0;
                    if (a4)
                    {
                      if (v100) {
                        goto LABEL_243;
                      }
                    }
                    else if (v100)
                    {
                      goto LABEL_245;
                    }
                  }
                  else
                  {
                    int v99 = *v6;
                    if (v98 == 1)
                    {
                      unsigned int v7 = v99 << 24;
                    }
                    else
                    {
                      int v101 = (v99 << 16) | (v6[1] << 8);
                      if (v98 != 2) {
                        v101 |= v6[2];
                      }
                      unsigned int v7 = v101 << 8;
                    }
                  }
                }
                else
                {
                  unsigned int v7 = bswap32(*(_DWORD *)v6);
                }
                char v90 = 0;
                v7 <<= v8;
              }
              while ((v91 & 1) != 0);
            }
          }
LABEL_238:
          uint64_t result = 0;
          if (++v67 > v66) {
            goto LABEL_247;
          }
        }
      }
LABEL_249:
      uint64_t result = 4294954577;
LABEL_246:
      uint64_t result = FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
      goto LABEL_247;
    }
  }
  if (v39 >= 1)
  {
    int v41 = *v6;
    if (v39 == 1)
    {
      unsigned int v40 = v41 << 24;
    }
    else
    {
      int v42 = (v41 << 16) | (v6[1] << 8);
      if (v39 != 2) {
        v42 |= v6[2];
      }
      unsigned int v40 = v42 << 8;
    }
    goto LABEL_75;
  }
LABEL_240:
  unsigned int v7 = 0;
  uint64_t result = 4294954582;
  if (!a4) {
    goto LABEL_246;
  }
LABEL_247:
  a1[2] = (uint64_t)v6;
  *((_DWORD *)a1 + 6) = v7;
  *((unsigned char *)a1 + 28) = v8;
  return result;
}

uint64_t FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(CFAllocatorRef alloc, int codecType, int32_t width, int32_t height, int a5, const UInt8 *a6, CFIndex a7, const __CFDictionary *a8, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  CFDictionaryRef v13 = 0;
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  values = 0;
  keys[0] = 0;
  CFTypeRef cf = 0;
  if (!a5 || !a6)
  {
    CFStringRef v16 = 0;
    CFDictionaryRef v17 = 0;
    goto LABEL_14;
  }
  CFStringRef v16 = 0;
  CFDictionaryRef v17 = 0;
  if (!a7)
  {
LABEL_14:
    uint64_t FallbackExtensionsFromVUI = CMVideoFormatDescriptionCreate(alloc, codecType, width, height, v13, formatDescriptionOut);
    goto LABEL_15;
  }
  pStr[0] = 4;
  pStr[1] = HIBYTE(a5);
  pStr[2] = BYTE2(a5);
  pStr[3] = BYTE1(a5);
  pStr[4] = a5;
  CFStringRef v16 = CFStringCreateWithPascalString(alloc, pStr, 0);
  if (v16 || (uint64_t v21 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0), !v21))
  {
    keys[0] = (void *)v16;
    values = CFDataCreate(alloc, a6, a7);
    if (!values)
    {
      uint64_t v20 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
      goto LABEL_19;
    }
    CFDictionaryRef v17 = CFDictionaryCreate(alloc, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
    if (!v17) {
      goto LABEL_12;
    }
    if (values)
    {
      CFRelease(values);
      values = 0;
    }
    keys[0] = @"SampleDescriptionExtensionAtoms";
    values = (void *)CFRetain(v17);
    if (a8)
    {
      uint64_t FallbackExtensionsFromVUI = FigCFCreateExtendedDictionary(alloc, a8, keys, &values, 1, (CFDictionaryRef *)&cf);
      if (FallbackExtensionsFromVUI)
      {
LABEL_15:
        uint64_t v20 = FallbackExtensionsFromVUI;
        goto LABEL_20;
      }
      CFDictionaryRef v13 = (const __CFDictionary *)cf;
      if (!cf)
      {
LABEL_12:
        uint64_t FallbackExtensionsFromVUI = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        goto LABEL_15;
      }
    }
    else
    {
      CFDictionaryRef v13 = CFDictionaryCreate(alloc, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
      CFTypeRef cf = v13;
      if (!v13) {
        goto LABEL_12;
      }
    }
    if (codecType > 1700886114)
    {
      if (codecType > 1902212708)
      {
        if (codecType == 1902212709) {
          goto LABEL_42;
        }
        int v23 = 2053207651;
      }
      else
      {
        if (codecType == 1700886115) {
          goto LABEL_42;
        }
        int v23 = 1902212707;
      }
    }
    else if (codecType > 1667331682)
    {
      if (codecType == 1667331683) {
        goto LABEL_42;
      }
      int v23 = 1685220713;
    }
    else
    {
      if (codecType == 1635148593) {
        goto LABEL_42;
      }
      int v23 = 1635148595;
    }
    if (codecType != v23 && !FigVideoCodecTypeIsHEVCFlavorOrDolbyVisionHEVCFlavor(codecType)) {
      goto LABEL_14;
    }
LABEL_42:
    uint64_t FallbackExtensionsFromVUI = FigBridge_MakeFallbackExtensionsFromVUI(alloc, codecType, 0, (const __CFDictionary **)&cf);
    if (FallbackExtensionsFromVUI) {
      goto LABEL_15;
    }
    CFDictionaryRef v13 = (const __CFDictionary *)cf;
    goto LABEL_14;
  }
  uint64_t v20 = v21;
  CFStringRef v16 = 0;
LABEL_19:
  CFDictionaryRef v17 = 0;
LABEL_20:
  if (values) {
    CFRelease(values);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v16) {
    CFRelease(v16);
  }
  return v20;
}

OSStatus CMVideoFormatDescriptionGetH264ParameterSetAtIndex(CMFormatDescriptionRef videoDesc, size_t parameterSetIndex, const uint8_t **parameterSetPointerOut, size_t *parameterSetSizeOut, size_t *parameterSetCountOut, int *NALUnitHeaderLengthOut)
{
  if (!videoDesc) {
    goto LABEL_13;
  }
  CFTypeID v12 = CFGetTypeID(videoDesc);
  if (v12 != CMFormatDescriptionGetTypeID()) {
    goto LABEL_13;
  }
  CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(videoDesc, @"SampleDescriptionExtensionAtoms");
  if (!Extension) {
    goto LABEL_13;
  }
  CFDictionaryRef v14 = Extension;
  CFTypeID v15 = CFGetTypeID(Extension);
  if (v15 != CFDictionaryGetTypeID()) {
    goto LABEL_13;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v14, @"avcC");
  if (!Value) {
    goto LABEL_13;
  }
  CFArrayRef ValueAtIndex = Value;
  CFTypeID v18 = CFGetTypeID(Value);
  if (v18 == CFArrayGetTypeID())
  {
    if (CFArrayGetCount(ValueAtIndex) <= 0) {
      goto LABEL_13;
    }
    CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    if (!ValueAtIndex) {
      goto LABEL_13;
    }
  }
  CFTypeID v19 = CFGetTypeID(ValueAtIndex);
  if (v19 == CFDataGetTypeID())
  {
    return FigH264Bridge_GetH264ParameterSetAtIndex(ValueAtIndex, parameterSetIndex, (unint64_t)parameterSetPointerOut, parameterSetSizeOut, (unint64_t)parameterSetCountOut, NALUnitHeaderLengthOut);
  }
  else
  {
LABEL_13:
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMVideoFormatDescriptionCreateFromH264ParameterSets(CFAllocatorRef allocator, size_t parameterSetCount, const uint8_t *const *parameterSetPointers, const size_t *parameterSetSizes, int NALUnitHeaderLength, CMFormatDescriptionRef *formatDescriptionOut)
{
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  CFDataRef theData = 0;
  OSStatus v8 = FigH264Bridge_CreateAVCCFromH264ParameterSets((int)allocator, parameterSetCount, (uint64_t)parameterSetPointers, (uint64_t)parameterSetSizes, NALUnitHeaderLength, &v18, &v17, &theData);
  if (!v8)
  {
    int32_t v10 = v17;
    int32_t v9 = v18;
    if (v18) {
      BOOL v11 = v17 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11)
    {
      OSStatus v8 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      BytePtr = CFDataGetBytePtr(theData);
      CFIndex Length = CFDataGetLength(theData);
      OSStatus v8 = FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(allocator, 1635148593, v9, v10, 1635148611, BytePtr, Length, 0, formatDescriptionOut);
    }
  }
  OSStatus v14 = v8;
  if (theData) {
    CFRelease(theData);
  }
  return v14;
}

OSStatus CMVideoFormatDescriptionCreateFromHEVCParameterSets(CFAllocatorRef allocator, size_t parameterSetCount, const uint8_t *const *parameterSetPointers, const size_t *parameterSetSizes, int NALUnitHeaderLength, CFDictionaryRef extensions, CMFormatDescriptionRef *formatDescriptionOut)
{
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  CFDataRef theData = 0;
  OSStatus v10 = FigHEVCBridge_CreateHVCCFromHEVCParameterSets((int)allocator, parameterSetCount, (uint64_t)parameterSetPointers, (uint64_t)parameterSetSizes, NALUnitHeaderLength, &v28, &v27, &theData);
  if (v10) {
    goto LABEL_23;
  }
  if (v28) {
    BOOL v11 = v27 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11)
  {
    uint64_t v25 = 4294954586;
LABEL_22:
    OSStatus v10 = FigSignalErrorAt(v25, 0, 0, 0, 0, 0, 0);
LABEL_23:
    OSStatus v23 = v10;
    goto LABEL_17;
  }
  if (extensions)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(extensions, @"SampleDescriptionExtensionAtoms");
    if (Value)
    {
      if (CFDictionaryContainsKey(Value, @"dvcC"))
      {
        CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFIndex Count = CFDictionaryGetCount(extensions);
        CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v13, Count, extensions);
        if (MutableCopy)
        {
          CFStringRef v16 = MutableCopy;
          CFDictionaryRemoveValue(MutableCopy, (const void *)*MEMORY[0x1E4F24A90]);
          CFDictionaryRemoveValue(v16, (const void *)*MEMORY[0x1E4F24BC8]);
          CFDictionaryRemoveValue(v16, (const void *)*MEMORY[0x1E4F24C18]);
          int v17 = 1685481521;
          goto LABEL_12;
        }
        uint64_t v25 = 4294954585;
        goto LABEL_22;
      }
    }
  }
  CFStringRef v16 = 0;
  int v17 = 1752589105;
LABEL_12:
  int32_t v19 = v27;
  int32_t v18 = v28;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  if (v16) {
    CFDictionaryRef v22 = v16;
  }
  else {
    CFDictionaryRef v22 = extensions;
  }
  OSStatus v23 = FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(allocator, v17, v18, v19, 1752589123, BytePtr, Length, v22, formatDescriptionOut);
  if (v16) {
    CFRelease(v16);
  }
LABEL_17:
  if (theData) {
    CFRelease(theData);
  }
  return v23;
}

OSStatus CMVideoFormatDescriptionGetHEVCParameterSetAtIndex(CMFormatDescriptionRef videoDesc, size_t parameterSetIndex, const uint8_t **parameterSetPointerOut, size_t *parameterSetSizeOut, size_t *parameterSetCountOut, int *NALUnitHeaderLengthOut)
{
  if (!videoDesc) {
    goto LABEL_13;
  }
  CFTypeID v12 = CFGetTypeID(videoDesc);
  if (v12 != CMFormatDescriptionGetTypeID()) {
    goto LABEL_13;
  }
  CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(videoDesc, @"SampleDescriptionExtensionAtoms");
  if (!Extension) {
    goto LABEL_13;
  }
  CFDictionaryRef v14 = Extension;
  CFTypeID v15 = CFGetTypeID(Extension);
  if (v15 != CFDictionaryGetTypeID()) {
    goto LABEL_13;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v14, @"hvcC");
  if (!Value) {
    goto LABEL_13;
  }
  CFArrayRef ValueAtIndex = Value;
  CFTypeID v18 = CFGetTypeID(Value);
  if (v18 == CFArrayGetTypeID())
  {
    if (CFArrayGetCount(ValueAtIndex) <= 0) {
      goto LABEL_13;
    }
    CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    if (!ValueAtIndex) {
      goto LABEL_13;
    }
  }
  CFTypeID v19 = CFGetTypeID(ValueAtIndex);
  if (v19 == CFDataGetTypeID())
  {
    return FigHEVCBridge_GetHEVCParameterSetAtIndex(ValueAtIndex, 0, parameterSetIndex, (unint64_t)parameterSetPointerOut, (unint64_t)parameterSetSizeOut, (unint64_t)parameterSetCountOut, NALUnitHeaderLengthOut);
  }
  else
  {
LABEL_13:
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigVideoFormatDescriptionVisitAllParameterSets(const void *a1, uint64_t a2)
{
  if (!a1) {
    goto LABEL_23;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CMFormatDescriptionGetTypeID()) {
    goto LABEL_23;
  }
  CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension((CMFormatDescriptionRef)a1, @"SampleDescriptionExtensionAtoms");
  if (!Extension) {
    goto LABEL_23;
  }
  CFDictionaryRef v6 = Extension;
  CFTypeID v7 = CFGetTypeID(Extension);
  if (v7 != CFDictionaryGetTypeID()) {
    goto LABEL_23;
  }
  if (CFDictionaryContainsKey(v6, @"avcC"))
  {
    CFArrayRef Value = CFDictionaryGetValue(v6, @"avcC");
    if (Value)
    {
      CFArrayRef ValueAtIndex = Value;
      CFTypeID v10 = CFGetTypeID(Value);
      if (v10 != CFArrayGetTypeID()
        || CFArrayGetCount((CFArrayRef)ValueAtIndex) > 0
        && (CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0)) != 0)
      {
        CFTypeID v11 = CFGetTypeID(ValueAtIndex);
        if (v11 == CFDataGetTypeID())
        {
          return FigH264Bridge_VisitAllH264ParameterSets(ValueAtIndex, 0, 0, (unint64_t)dispatchVideoFormatParameterSetVisitor, a2);
        }
      }
    }
    goto LABEL_23;
  }
  uint64_t result = CFDictionaryContainsKey(v6, @"hvcC");
  if (!result) {
    return result;
  }
  if ((CFArrayRef v13 = (const __CFArray *)CFDictionaryGetValue(v6, @"hvcC")) == 0
    || (v14 = v13, CFTypeID v15 = CFGetTypeID(v13), v15 == CFArrayGetTypeID())
    && (CFArrayGetCount(v14) <= 0 || (CFArrayRef v14 = (const __CFArray *)CFArrayGetValueAtIndex(v14, 0)) == 0)
    || (CFTypeID v16 = CFGetTypeID(v14), v16 != CFDataGetTypeID()))
  {
LABEL_23:
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }

  return FigHEVCBridge_VisitAllHEVCParameterSets(v14, 0, 0, 0, (uint64_t)dispatchVideoFormatParameterSetVisitor, a2);
}

uint64_t dispatchVideoFormatParameterSetVisitor(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

uint64_t FigVideoFormatDescriptionCreateUpdatedHVCCWithAdditionalHEVCParameterSets(int a1, const void *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, void *a7, void *a8, __CFData **a9)
{
  return FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t FigVideoFormatDescriptionCreateUpdatedFromHEVCParameterSets(const __CFAllocator *a1, CMFormatDescriptionRef desc, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, CMVideoFormatDescriptionRef *a7)
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  CFDataRef theData = 0;
  if (desc)
  {
    CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(desc);
    if (Extensions)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms");
      if (Value)
      {
        CFTypeID v15 = CFDictionaryGetValue(Value, @"hvcC");
        if (v15)
        {
          uint64_t v16 = FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets((int)a1, v15, a3, a4, a5, a6, &v25, &v24, &theData);
          if (v16)
          {
LABEL_9:
            uint64_t v21 = v16;
            if (theData) {
              CFRelease(theData);
            }
            return v21;
          }
          int32_t v17 = v25;
          if (v25)
          {
            int32_t v18 = v24;
            if (v24)
            {
              BytePtr = CFDataGetBytePtr(theData);
              CFIndex Length = CFDataGetLength(theData);
              uint64_t v16 = FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(a1, 1752589105, v17, v18, 1752589123, BytePtr, Length, 0, a7);
              goto LABEL_9;
            }
          }
        }
      }
    }
    uint64_t v16 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

uint64_t FigVideoFormatDescriptionCreateFromSPSAndPPS(const __CFAllocator *a1, const UInt8 *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, CMVideoFormatDescriptionRef *a7)
{
  uint64_t v19 = 0;
  CFDataRef theData = 0;
  uint64_t v18 = 0;
  uint64_t SPSWidthAndHeight = FigH264Bridge_CreateAVCCFromSPSAndPPS((int)a1, (uint64_t)a2, a3, a4, a5, a6, &theData);
  if (!SPSWidthAndHeight)
  {
    uint64_t SPSWidthAndHeight = FigH264Bridge_GetSPSWidthAndHeight(a2, a3, &v19, &v18);
    if (!SPSWidthAndHeight)
    {
      int32_t v13 = v18;
      int32_t v12 = v19;
      BytePtr = CFDataGetBytePtr(theData);
      CFIndex Length = CFDataGetLength(theData);
      uint64_t SPSWidthAndHeight = FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(a1, 1635148593, v12, v13, 1635148611, BytePtr, Length, 0, a7);
    }
  }
  uint64_t v16 = SPSWidthAndHeight;
  if (theData) {
    CFRelease(theData);
  }
  return v16;
}

uint64_t FigHALAudioDeviceBrokerGetClassID()
{
  if (FigHALAudioDeviceBrokerGetClassID_sRegisterFigHALAudioDeviceBrokerClassOnce != -1) {
    dispatch_once(&FigHALAudioDeviceBrokerGetClassID_sRegisterFigHALAudioDeviceBrokerClassOnce, &__block_literal_global_32);
  }
  return FigHALAudioDeviceBrokerGetClassID_sFigHALAudioDeviceBrokerClassID;
}

uint64_t __FigHALAudioDeviceBrokerGetClassID_block_invoke()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&FigHALAudioDeviceBrokerGetClassID_sFigHALAudioDeviceBrokerClassDesc, ClassID, 1, &FigHALAudioDeviceBrokerGetClassID_sFigHALAudioDeviceBrokerClassID);
}

uint64_t FigHALAudioDeviceBrokerGetTypeID()
{
  if (FigHALAudioDeviceBrokerGetClassID_sRegisterFigHALAudioDeviceBrokerClassOnce != -1) {
    dispatch_once(&FigHALAudioDeviceBrokerGetClassID_sRegisterFigHALAudioDeviceBrokerClassOnce, &__block_literal_global_32);
  }
  uint64_t v0 = (void *)FigHALAudioDeviceBrokerGetClassID_sFigHALAudioDeviceBrokerClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigHALAudioDeviceBrokerRegister(const void *a1, const void *a2)
{
  if (a1 && a2)
  {
    if (sFigHALAudioDeviceBrokerRegistryInitOnce != -1) {
      dispatch_once_f(&sFigHALAudioDeviceBrokerRegistryInitOnce, 0, (dispatch_function_t)figHALAudioDeviceRegistryOneTimeInitialization);
    }
    FigSimpleMutexLock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
    CFDictionarySetValue((CFMutableDictionaryRef)sFigHALAudioDeviceBrokerRegistry_1, a1, a2);
    FigSimpleMutexUnlock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949445, 0, 0, 0, 0, 0, 0);
  }
}

CFMutableDictionaryRef figHALAudioDeviceRegistryOneTimeInitialization()
{
  sFigHALAudioDeviceBrokerRegistry_0 = (uint64_t)FigSimpleMutexCreate();
  CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  sFigHALAudioDeviceBrokerRegistry_1 = (uint64_t)result;
  return result;
}

uint64_t FigHALAudioDeviceBrokerUnregister(const void *a1)
{
  if (a1)
  {
    if (sFigHALAudioDeviceBrokerRegistryInitOnce != -1) {
      dispatch_once_f(&sFigHALAudioDeviceBrokerRegistryInitOnce, 0, (dispatch_function_t)figHALAudioDeviceRegistryOneTimeInitialization);
    }
    FigSimpleMutexLock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
    size_t Count = CFDictionaryGetCount((CFDictionaryRef)sFigHALAudioDeviceBrokerRegistry_1);
    if (Count)
    {
      int64_t v4 = Count;
      int v5 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
      CFDictionaryRef v6 = (const void **)malloc_type_calloc(v4, 8uLL, 0xC0040B8AA526DuLL);
      CFDictionaryGetKeysAndValues((CFDictionaryRef)sFigHALAudioDeviceBrokerRegistry_1, v5, v6);
      if (v4 >= 1)
      {
        CFTypeID v7 = v6;
        OSStatus v8 = v5;
        while (*v7 != a1)
        {
          ++v8;
          ++v7;
          if (!--v4) {
            goto LABEL_11;
          }
        }
        CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigHALAudioDeviceBrokerRegistry_1, *v8);
      }
LABEL_11:
      free(v5);
      free(v6);
    }
    FigSimpleMutexUnlock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949445, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigHALAudioDeviceBrokerCopy(const void *a1, void *a2)
{
  if (a1 && a2)
  {
    if (sFigHALAudioDeviceBrokerRegistryInitOnce != -1) {
      dispatch_once_f(&sFigHALAudioDeviceBrokerRegistryInitOnce, 0, (dispatch_function_t)figHALAudioDeviceRegistryOneTimeInitialization);
    }
    FigSimpleMutexLock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
    CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)sFigHALAudioDeviceBrokerRegistry_1, a1);
    if (Value) {
      CFDictionaryRef Value = CFRetain(Value);
    }
    *a2 = Value;
    FigSimpleMutexUnlock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949445, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigEndpointStreamXPCRemoteGetObjectID(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v5 = 4294954511;
  }
  else
  {
    if (!*(unsigned char *)(DerivedStorage + 1))
    {
      *a2 = *(void *)(DerivedStorage + 8);
      return 0;
    }
    uint64_t v5 = 4294950574;
  }

  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointStreamXPCRemotePing()
{
  uint64_t v5 = 0;
  uint64_t v0 = figEndpointStreamRemoteXPC_EnsureClientEstablished();
  if (v0)
  {
    uint64_t v3 = v0;
    unsigned int v2 = 0;
  }
  else
  {
    uint64_t v1 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &v5);
    unsigned int v2 = v5;
    if (v1)
    {
      uint64_t v3 = v1;
    }
    else
    {
      uint64_t v3 = FigXPCRemoteClientSendSyncMessage(gFigEndpointStreamRemoteClient, (uint64_t)v5);
      unsigned int v2 = v5;
    }
  }
  FigXPCRelease(v2);
  return v3;
}

uint64_t figEndpointStreamRemoteXPC_EnsureClientEstablished()
{
  uint64_t v3 = 0;
  int64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __figEndpointStreamRemoteXPC_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E5679DF0;
  void block[4] = &v3;
  if (figEndpointStreamRemoteXPC_EnsureClientEstablished_sFigEndpointStreamRemoteClientSetupOnce != -1) {
    dispatch_once(&figEndpointStreamRemoteXPC_EnsureClientEstablished_sFigEndpointStreamRemoteClientSetupOnce, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t FigEndpointStreamXPCRemoteCreateWithObjectID(const void *a1, void *a2)
{
  if (a1 && a2)
  {
    uint64_t result = figEndpointStreamRemoteXPC_EnsureClientEstablished();
    if (!result)
    {
      return remoteXPCEndpointStream_CreateInternal(a1, a2);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t remoteXPCEndpointStream_CreateInternal(const void *a1, void *a2)
{
  uint64_t v11 = 0;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  ClassID = (void *)FigEndpointStreamAirPlayGetClassID();
  uint64_t result = CMDerivedObjectCreate((uint64_t)v4, (uint64_t)&kFigEndpointStreamRemoteXPC_EndpointVTable, ClassID, &v11);
  if (!result)
  {
    uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(v11);
    DerivedStorage[1] = a1;
    DerivedStorage[4] = 1;
    v10.version = 0;
    v10.retain = (CFDictionaryRetainCallBack)remoteXPCEndpointStream_cloneCompletionCallback;
    v10.release = (CFDictionaryReleaseCallBack)remoteXPCEndpointStream_freeCompletionCallback;
    v10.copyDescription = 0;
    v10.equal = 0;
    CFMutableDictionaryRef v8 = CFDictionaryCreateMutable(v4, 0, 0, &v10);
    DerivedStorage[3] = v8;
    if (v8
      && (dispatch_queue_t v9 = dispatch_queue_create("com.apple.coremedia.endpointstream.completioncallbacks", 0),
          (DerivedStorage[2] = v9) != 0))
    {
      FigXPCRemoteClientAssociateObject(gFigEndpointStreamRemoteClient, v11, a1);
      uint64_t result = 0;
    }
    else
    {
      uint64_t result = FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
    }
  }
  *a2 = v11;
  return result;
}

uint64_t FigEndpointStreamXPCRemoteRetainCopiedEndpointStream(const void *a1, void *a2)
{
  uint64_t v6 = 0;
  if (a1 && a2)
  {
    uint64_t result = figEndpointStreamRemoteXPC_EnsureClientEstablished();
    if (!result)
    {
      uint64_t result = FigXPCRemoteClientRetainCopiedObject(gFigEndpointStreamRemoteClient, (uint64_t)a1, &v6);
      if (!result)
      {
        uint64_t v5 = v6;
        if (v6)
        {
          uint64_t result = 0;
        }
        else
        {
          uint64_t result = remoteXPCEndpointStream_CreateInternal(a1, &v6);
          uint64_t v5 = v6;
        }
        *a2 = v5;
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

void remoteXPCEndpointStreamClient_DeadConnectionCallback(uint64_t a1)
{
  *(unsigned char *)(CMBaseObjectGetDerivedStorage(a1) + 1) = 1;

  FigEndpointStreamRemoteXPC_runAllCallbacks(a1, -16722);
}

uint64_t remoteXPCEndpointStreamClient_HandleClientMessage(uint64_t a1, void *a2)
{
  int v17 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v17);
  if (OpCode) {
    return OpCode;
  }
  if (v17 != 1667329122) {
    return 4294966630;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v27 = 0;
  uint64_t v28 = &v27;
  uint64_t v29 = 0x3800000000;
  long long v30 = 0u;
  long long v31 = 0u;
  uint64_t int64 = xpc_dictionary_get_uint64(a2, "CompletionID");
  int64_t int64 = xpc_dictionary_get_int64(a2, "CompletionStatus");
  CFMutableDictionaryRef v8 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointStreamClient_handleCompletionCallback_block_invoke;
  block[3] = &unk_1E5679E40;
  void block[5] = DerivedStorage;
  void block[6] = uint64;
  void block[4] = &v27;
  dispatch_sync(v8, block);
  if (v28[3] == a1)
  {
    int v9 = *((_DWORD *)v28 + 12);
    if (v9 == 2)
    {
      long long v24 = *(_OWORD *)&kCMTimeInvalid.value;
      uint64_t v25 = 0;
      long long v22 = *(_OWORD *)&kCMTimeInvalid.value;
      uint64_t v23 = 0;
      double v11 = xpc_dictionary_get_double(a2, "Rate");
      FigXPCMessageGetCMTime(a2, "SampleTime", (uint64_t)&v24);
      FigXPCMessageGetCMTime(a2, "HostTime", (uint64_t)&v22);
      uint64_t v12 = v28[4];
      int32_t v13 = (void (*)(uint64_t, int64_t, long long *, long long *, uint64_t, double))v28[5];
      uint64_t v14 = v28[3];
      long long v20 = v24;
      uint64_t v21 = v25;
      long long v18 = v22;
      uint64_t v19 = v23;
      v13(v14, int64, &v20, &v18, v12, v11);
    }
    else if (v9 == 1)
    {
      ((void (*)(uint64_t, int64_t, uint64_t))v28[5])(a1, int64, v28[4]);
    }
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = FigSignalErrorAt(4294950531, 0, 0, 0, 0, 0, 0);
  }
  CFTypeID v15 = (const void *)v28[3];
  if (v15) {
    CFRelease(v15);
  }
  _Block_object_dispose(&v27, 8);
  return v10;
}

void FigEndpointStreamRemoteXPC_runAllCallbacks(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0;
  int context = a2;
  CFAllocatorRef v4 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigEndpointStreamRemoteXPC_runAllCallbacks_block_invoke;
  block[3] = &unk_1E5679E18;
  void block[4] = &v9;
  void block[5] = DerivedStorage;
  dispatch_sync(v4, block);
  CFDictionaryRef v5 = (const __CFDictionary *)v10[3];
  if (v5)
  {
    CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)FigEndpointStreamRemoteXPC_runOneCallback, &context);
    uint64_t v6 = (const void *)v10[3];
    if (v6) {
      CFRelease(v6);
    }
  }
  _Block_object_dispose(&v9, 8);
}

void FigEndpointStreamRemoteXPC_runOneCallback(uint64_t a1, uint64_t *a2, unsigned int *a3)
{
  int v3 = *((_DWORD *)a2 + 6);
  if (v3 == 2)
  {
    uint64_t v8 = a2[1];
    uint64_t v9 = (void (*)(uint64_t, uint64_t, long long *, long long *, uint64_t, double))a2[2];
    uint64_t v10 = *a3;
    uint64_t v11 = *a2;
    long long v14 = *(_OWORD *)&kCMTimeInvalid.value;
    uint64_t v15 = 0;
    long long v12 = *(_OWORD *)&kCMTimeInvalid.value;
    uint64_t v13 = 0;
    v9(v11, v10, &v14, &v12, v8, 0.0);
  }
  else if (v3 == 1)
  {
    uint64_t v4 = *a3;
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
    CFTypeID v7 = (void (*)(uint64_t, uint64_t, uint64_t))a2[2];
    v7(v5, v4, v6);
  }
}

void __remoteXPCEndpointStreamClient_handleCompletionCallback_block_invoke(uint64_t a1)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(*(void *)(a1 + 40) + 24);
  if (v2)
  {
    CFDictionaryRef Value = (long long *)CFDictionaryGetValue(v2, *(const void **)(a1 + 48));
    if (Value)
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
      long long v5 = *Value;
      *(_OWORD *)(v4 + 40) = Value[1];
      *(_OWORD *)(v4 + 24) = v5;
      uint64_t v6 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (v6) {
        CFRetain(v6);
      }
    }
    CFTypeID v7 = *(const void **)(a1 + 48);
    uint64_t v8 = *(__CFDictionary **)(*(void *)(a1 + 40) + 24);
    CFDictionaryRemoveValue(v8, v7);
  }
}

CFTypeRef *remoteXPCEndpointStream_cloneCompletionCallback(const __CFAllocator *a1, _OWORD *a2)
{
  int v3 = (CFTypeRef *)CFAllocatorAllocate(a1, 32, 0);
  long long v4 = a2[1];
  *(_OWORD *)int v3 = *a2;
  *((_OWORD *)v3 + 1) = v4;
  if (*v3) {
    CFRetain(*v3);
  }
  return v3;
}

void remoteXPCEndpointStream_freeCompletionCallback(CFAllocatorRef allocator, CFTypeRef *ptr)
{
  if (*ptr) {
    CFRelease(*ptr);
  }

  CFAllocatorDeallocate(allocator, ptr);
}

uint64_t FigEndpointStreamRemoteXPC_Invalidate(uint64_t a1)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage(a1);
  if (!*DerivedStorage)
  {
    *uint64_t DerivedStorage = 1;
    FigEndpointStreamRemoteXPC_runAllCallbacks(a1, -12785);
    FigEndpointStreamRemoteXPC_teardown(a1);
  }
  return 0;
}

void FigEndpointStreamRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigEndpointStreamRemoteXPC_teardown(a1);
  int v3 = *(NSObject **)(DerivedStorage + 16);
  if (v3)
  {
    dispatch_release(v3);
  }
}

uint64_t FigEndpointStreamRemoteXPC_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFTypeRef *a4)
{
  uint64_t v14 = 0;
  uint64_t ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v14);
  if (ObjectID) {
    return ObjectID;
  }
  if (CFEqual(a2, @"SupportedAudioFormatDescriptions"))
  {
    xpc_object_t xdict = 0;
    xpc_object_t v17 = 0;
    uint64_t v15 = 0;
    uint64_t v8 = FigXPCCreateBasicMessage(0x73756164u, v14, &v17);
    if (!v8)
    {
      uint64_t v8 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigEndpointStreamRemoteClient, (uint64_t)v17, &xdict);
      if (!v8)
      {
        uint64_t v9 = FigXPCMessageCopyFigEndpointStreamAudioFormatDescriptionArray(a3, xdict, "FormatDescriptionArray", &v15);
        goto LABEL_10;
      }
    }
    goto LABEL_17;
  }
  if (CFEqual(a2, @"RichestAudioFormatDescription"))
  {
    xpc_object_t xdict = 0;
    xpc_object_t v17 = 0;
    uint64_t v15 = 0;
    uint64_t v8 = FigXPCCreateBasicMessage(0x72616664u, v14, &v17);
    if (!v8)
    {
      uint64_t v8 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigEndpointStreamRemoteClient, (uint64_t)v17, &xdict);
      if (!v8)
      {
        uint64_t v9 = (uint64_t)FigXPCMessageCopyFigEndpointStreamAudioFormatDescription((uint64_t)a3, xdict, "RichestFormatDescription", (uint64_t *)&v15);
LABEL_10:
        uint64_t v10 = v9;
        if (!v9) {
          *a4 = v15;
        }
        goto LABEL_12;
      }
    }
LABEL_17:
    uint64_t v10 = v8;
LABEL_12:
    FigXPCRelease(v17);
    FigXPCRelease(xdict);
    return v10;
  }
  uint64_t v12 = gFigEndpointStreamRemoteClient;
  uint64_t v13 = v14;

  return FigXPCSendStdCopyPropertyMessage(v12, v13, a2, a4);
}

uint64_t FigEndpointStreamRemoteXPC_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v8 = 0;
  uint64_t result = FigEndpointStreamXPCRemoteGetObjectID(a1, &v8);
  if (!result)
  {
    uint64_t v6 = gFigEndpointStreamRemoteClient;
    uint64_t v7 = v8;
    return FigXPCSendStdSetPropertyMessage(v6, v7, a2, a3);
  }
  return result;
}

void FigEndpointStreamRemoteXPC_teardown(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = DerivedStorage;
  xpc_object_t v5 = 0;
  if (!*(unsigned char *)DerivedStorage)
  {
    int v3 = *(const void **)(DerivedStorage + 8);
    FigXPCRemoteClientDisassociateObject(gFigEndpointStreamRemoteClient, v3);
    if (!*(unsigned char *)(v2 + 1) && !FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v3, &v5)) {
      FigXPCRemoteClientSendSyncMessage(gFigEndpointStreamRemoteClient, (uint64_t)v5);
    }
  }
  long long v4 = *(const void **)(v2 + 24);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(v2 + 24) = 0;
  }
  FigXPCRelease(v5);
}

uint64_t FigEndpointStreamRemoteXPC_SuspendWithCompletionCallback(uint64_t a1, const void *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v12 = 0;
  *(void *)uint64_t v13 = 0;
  uint64_t ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v12);
  if (ObjectID)
  {
    uint64_t v9 = ObjectID;
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v9 = FigXPCCreateBasicMessage(0x73737064u, v12, v13);
    uint64_t v10 = *(void **)v13;
    if (!v9)
    {
      FigXPCMessageSetCFDictionary(*(void **)v13, "Options", a2);
      uint64_t v9 = FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v13, a3, 0, a4);
      uint64_t v10 = *(void **)v13;
    }
  }
  FigXPCRelease(v10);
  return v9;
}

uint64_t FigEndpointStreamRemoteXPC_ResumeWithCompletionCallback(uint64_t a1, const void *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v12 = 0;
  *(void *)uint64_t v13 = 0;
  uint64_t ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v12);
  if (ObjectID)
  {
    uint64_t v9 = ObjectID;
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v9 = FigXPCCreateBasicMessage(0x7273756Du, v12, v13);
    uint64_t v10 = *(void **)v13;
    if (!v9)
    {
      FigXPCMessageSetCFDictionary(*(void **)v13, "Options", a2);
      uint64_t v9 = FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v13, a3, 0, a4);
      uint64_t v10 = *(void **)v13;
    }
  }
  FigXPCRelease(v10);
  return v9;
}

uint64_t FigEndpointStreamRemoteXPC_Flush(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v9 = 0;
  xpc_object_t xdict = 0;
  uint64_t ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v9);
  if (ObjectID)
  {
    uint64_t v6 = ObjectID;
    xpc_object_t v7 = 0;
  }
  else
  {
    uint64_t v6 = FigXPCCreateBasicMessage(0x666C7573u, v9, &xdict);
    xpc_object_t v7 = xdict;
    if (!v6)
    {
      FigXPCMessageSetCFDictionary(xdict, "Options", a3);
      xpc_dictionary_set_uint64(xdict, "FlushFlags", a2);
      uint64_t v6 = FigXPCRemoteClientSendSyncMessage(gFigEndpointStreamRemoteClient, (uint64_t)xdict);
      xpc_object_t v7 = xdict;
    }
  }
  FigXPCRelease(v7);
  return v6;
}

uint64_t FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(uint64_t a1, void *a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v11 = DerivedStorage;
  uint64_t v31 = 0;
  unsigned int v32 = &v31;
  uint64_t v33 = 0x2000000000;
  uint64_t v34 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = &v27;
  uint64_t v29 = 0x2000000000;
  char v30 = 0;
  if (a3 | a4)
  {
    if (a3) {
      unint64_t v12 = a3;
    }
    else {
      unint64_t v12 = a4;
    }
    uint64_t v13 = *(NSObject **)(DerivedStorage + 16);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke;
    block[3] = &unk_1E5679E68;
    if (a3) {
      int v14 = 1;
    }
    else {
      int v14 = 2;
    }
    void block[4] = &v31;
    void block[5] = a1;
    void block[6] = v11;
    void block[7] = a1;
    void block[8] = a5;
    block[9] = v12;
    int v25 = v14;
    int v26 = 0;
    dispatch_sync(v13, block);
    xpc_dictionary_set_uint64(a2, "CompletionID", v32[3]);
  }
  uint64_t v15 = FigXPCRemoteClientSendSyncMessage(gFigEndpointStreamRemoteClient, (uint64_t)a2);
  if (v15) {
    BOOL v16 = (a3 | a4) == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16)
  {
    xpc_object_t v17 = *(NSObject **)(v11 + 16);
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 0x40000000;
    int v23[2] = __FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke_2;
    v23[3] = &unk_1E5679E90;
    v23[4] = &v31;
    v23[5] = &v27;
    v23[6] = v11;
    dispatch_sync(v17, v23);
  }
  if (*((unsigned char *)v28 + 24))
  {
    if (a3)
    {
      ((void (*)(uint64_t, uint64_t, uint64_t))a3)(a1, v15, a5);
    }
    else
    {
      long long v21 = *(_OWORD *)&kCMTimeInvalid.value;
      uint64_t v22 = 0;
      long long v19 = *(_OWORD *)&kCMTimeInvalid.value;
      uint64_t v20 = 0;
      ((void (*)(uint64_t, uint64_t, long long *, long long *, uint64_t, double))a4)(a1, v15, &v21, &v19, a5, 0.0);
    }
  }
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointStreamRemoteClient, v15, "FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback", 0);
  _Block_object_dispose(&v27, 8);
  _Block_object_dispose(&v31, 8);
  return v15;
}

uint64_t FigEndpointStreamRemoteXPC_SetRateAndAnchorTimeWithCompletionCallback(uint64_t a1, long long *a2, long long *a3, unint64_t a4, uint64_t a5, double a6)
{
  uint64_t v18 = 0;
  xpc_object_t xdict = 0;
  uint64_t ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v18);
  if (ObjectID)
  {
    uint64_t v13 = ObjectID;
    xpc_object_t v14 = 0;
  }
  else
  {
    uint64_t v13 = FigXPCCreateBasicMessage(0x73726174u, v18, &xdict);
    xpc_object_t v14 = xdict;
    if (!v13)
    {
      xpc_dictionary_set_double(xdict, "Rate", a6);
      long long v16 = *a2;
      uint64_t v17 = *((void *)a2 + 2);
      FigXPCMessageSetCMTime(xdict, "SampleTime", &v16);
      long long v16 = *a3;
      uint64_t v17 = *((void *)a3 + 2);
      FigXPCMessageSetCMTime(xdict, "HostTime", &v16);
      uint64_t v13 = FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, xdict, 0, a4, a5);
      xpc_object_t v14 = xdict;
    }
  }
  FigXPCRelease(v14);
  return v13;
}

uint64_t FigEndpointStreamRemoteXPC_CopyTransportFormatDescriptionForSourceContentFormatDescription(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  xpc_object_t xdict = 0;
  uint64_t ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v9);
  if (!ObjectID)
  {
    uint64_t ObjectID = FigXPCCreateBasicMessage(0x63746664u, v9, &v10);
    if (!ObjectID)
    {
      uint64_t ObjectID = FigXPCMessageSetFigEndpointStreamAudioFormatDescription(v10, "FormatDescription", a2);
      if (!ObjectID)
      {
        uint64_t ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigEndpointStreamRemoteClient, (uint64_t)v10, &xdict);
        if (!ObjectID) {
          uint64_t ObjectID = (uint64_t)FigXPCMessageCopyFigEndpointStreamAudioFormatDescription(*MEMORY[0x1E4F1CF80], xdict, "FormatDescription", a3);
        }
      }
    }
  }
  uint64_t v6 = ObjectID;
  FigXPCRelease(v10);
  FigXPCRelease(xdict);
  return v6;
}

uint64_t FigEndpointStreamRemoteXPC_IsPassthroughSupportedForFormatDescription(uint64_t a1, void *a2, BOOL *a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  xpc_object_t xdict = 0;
  uint64_t ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v10);
  if (ObjectID
    || (uint64_t ObjectID = FigXPCCreateBasicMessage(0x70736664u, v10, &v11), ObjectID)
    || (uint64_t ObjectID = FigXPCMessageSetFigEndpointStreamAudioFormatDescription(v11, "FormatDescription", a2),
        ObjectID))
  {
    uint64_t v6 = ObjectID;
    goto LABEL_8;
  }
  uint64_t v6 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigEndpointStreamRemoteClient, (uint64_t)v11, &xdict);
  if (v6)
  {
LABEL_8:
    BOOL v7 = 0;
    goto LABEL_6;
  }
  BOOL v7 = xpc_dictionary_get_BOOL(xdict, "IsPassthroughSupported");
LABEL_6:
  *a3 = v7;
  FigXPCRelease(v11);
  FigXPCRelease(xdict);
  return v6;
}

uint64_t FigAtomStreamInitWithByteStreamWithSizeAndReporter(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  uint64_t EntireLengthOfByteStream = GetEntireLengthOfByteStream(a1, &v17);
  if (!EntireLengthOfByteStream)
  {
    uint64_t v13 = v17;
    if (a2 < 0 || (uint64_t v14 = v17 - a2, v17 <= a2))
    {
      v18[0] = 0;
      v18[1] = 0;
      snprintf(__str, 0x100uLL, "Offset %lld exceeds stream length %lld", a2, v17);
      uint64_t v15 = 4294954403;
      FigSignalErrorAt(4294954403, 0, 0, 0, 0, 0, 0);
      AtomStreamReportErrorMessage(a5, (const char *)v18, -12893, (uint64_t)__str);
      return v15;
    }
    *(_OWORD *)a6 = 0u;
    *(_OWORD *)(a6 + 16) = 0u;
    *(_OWORD *)(a6 + 32) = 0u;
    *(_OWORD *)(a6 + 48) = 0u;
    *(_OWORD *)(a6 + 80) = 0u;
    *(_OWORD *)(a6 + 96) = 0u;
    *(_OWORD *)(a6 + 64) = 0u;
    *(unsigned char *)a6 = a4;
    *(void *)(a6 + 8) = a1;
    *(void *)(a6 + 16) = v13;
    *(void *)(a6 + 24) = ReadBytesFromByteStreamDataSource;
    *(void *)(a6 + 32) = ReadBBufFromByteStreamDataSource;
    *(void *)(a6 + 40) = a2;
    *(void *)(a6 + 48) = v14;
    *(void *)(a6 + 104) = a5;
    if (v14 > a3) {
      *(void *)(a6 + 48) = a3;
    }
    return CommonAtomStreamInitialization((unsigned __int8 *)a6);
  }
  return EntireLengthOfByteStream;
}

uint64_t GetEntireLengthOfByteStream(uint64_t a1, void *a2)
{
  CFNumberRef number = 0;
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, __CFString *, void, CFNumberRef *))(v5 + 48);
  if (!v6) {
    return 4294954514;
  }
  uint64_t result = v6(CMBaseObject, @"FBS_EntireLength", 0, &number);
  if (!result)
  {
    CFNumberGetValue(number, kCFNumberSInt64Type, a2);
    CFRelease(number);
    return 0;
  }
  return result;
}

void AtomStreamReportErrorMessage(uint64_t a1, const char *a2, int a3, uint64_t a4)
{
  if (a1)
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFMutableDictionaryRef v10 = Mutable;
      int v14 = 0;
      uint64_t v11 = CFStringCreateMutable(v8, 0);
      if (v11)
      {
        unint64_t v12 = v11;
        CFStringAppendFormat(v11, 0, @"%s", a4);
        FigCFDictionarySetInt32(v10, @"FailureCode", a3);
        if (*a2)
        {
          CFStringRef v13 = CFStringCreateWithCString(v8, a2, 0);
          if (FigCFStringGetOSTypeValue(v13, &v14)) {
            FigCFDictionarySetInt32(v10, @"AtomType", v14);
          }
          if (v13) {
            CFRelease(v13);
          }
        }
        CFDictionarySetValue(v10, @"DiagnosticInformation", v12);
        FigCFDictionarySetInt32(v10, @"AnalysisType", 1635020653);
        FigAssetAnalysisReporterAddMessage(a1, v10);
        CFRelease(v12);
      }
      CFRelease(v10);
    }
  }
}

uint64_t ReadBytesFromByteStreamDataSource(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *a1;
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable(*a1) + 16);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  unint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 8);
  if (!v12) {
    return 4294954514;
  }

  return v12(v9, a2, a3, a4, a5);
}

uint64_t ReadBBufFromByteStreamDataSource(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *a1;
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable(*a1) + 16);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  unint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 32);
  if (!v12) {
    return 4294954514;
  }

  return v12(v9, a2, a3, a4, a5);
}

uint64_t CommonAtomStreamInitialization(unsigned __int8 *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)a1 + 5);
  uint64_t v3 = *((void *)a1 + 6) + v2;
  uint64_t AtomHeader = ReadAtomHeader(*((void *)a1 + 13), (uint64_t)(a1 + 8), v2, v3, *a1, 0, 0);
  if (!AtomHeader)
  {
    uint64_t v5 = *((void *)a1 + 9);
    if (v5 > 7)
    {
      if (v5 <= v3 - *((void *)a1 + 5))
      {
        uint64_t AtomHeader = 0;
        *((void *)a1 + 7) = 0;
        *((void *)a1 + 10) = v5;
        return AtomHeader;
      }
      *(void *)BOOL v7 = 0;
      uint64_t v8 = 0;
      AtomTypeToString(*((_DWORD *)a1 + 16), v7);
      snprintf(__str, 0x100uLL, "Atom total length (%lld) exceeds container's length. Atom '%s' at offset %lld.");
    }
    else
    {
      *(void *)BOOL v7 = 0;
      uint64_t v8 = 0;
      AtomTypeToString(*((_DWORD *)a1 + 16), v7);
      snprintf(__str, 0x100uLL, "Atom total length (%lld) less than an atom header size. Atom '%s' at offset %lld.");
    }
    uint64_t AtomHeader = 4294954402;
    AtomStreamReportErrorMessage(*((void *)a1 + 13), v7, -12894, (uint64_t)__str);
  }
  return AtomHeader;
}

uint64_t FigAtomStreamInitWithByteStreamAndReporter(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  return FigAtomStreamInitWithByteStreamWithSizeAndReporter(a1, a2, 0x7FFFFFFFFFFFFFFFLL, a3, a4, a5);
}

uint64_t FigAtomStreamInitWithByteStreamWithSize(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  return FigAtomStreamInitWithByteStreamWithSizeAndReporter(a1, a2, a3, a4, 0, a5);
}

uint64_t FigAtomStreamInitWithByteStream(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  return FigAtomStreamInitWithByteStreamWithSizeAndReporter(a1, a2, 0x7FFFFFFFFFFFFFFFLL, a3, 0, a4);
}

uint64_t FigAtomStreamInitWithParent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)a3 = 0;
  long long v5 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a3 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a3 + 8) = v5;
  uint64_t v6 = *(void *)(a1 + 56) + *(void *)(a1 + 40);
  *(void *)(a3 + 40) = v6;
  uint64_t v7 = *(void *)(a1 + 80);
  *(void *)(a3 + 48) = v7;
  uint64_t v8 = *(void *)(a1 + 104);
  *(void *)(a3 + 104) = v8;
  if (v7 < a2)
  {
    *(void *)long long v16 = 0;
    uint64_t v17 = 0;
    snprintf(__str, 0x100uLL, "Offset %zd outside of parent container length %lld (Effective global offset %lld)", a2, v7, v6 + a2);
    uint64_t AtomHeader = 4294954403;
    FigSignalErrorAt(4294954403, 0, 0, 0, 0, 0, 0);
    uint64_t v10 = *(void *)(a3 + 104);
    int v11 = -12893;
LABEL_7:
    AtomStreamReportErrorMessage(v10, v16, v11, (uint64_t)__str);
    return AtomHeader;
  }
  uint64_t v12 = v7 + v6;
  CFStringRef v13 = (uint64_t *)(a3 + 72);
  uint64_t AtomHeader = ReadAtomHeader(v8, a3 + 8, v6 + a2, v7 + v6, 0, 0, 1);
  if (!AtomHeader)
  {
    uint64_t v14 = *v13;
    if (*v13 >= 8 && v14 <= v12 - (*(void *)(a3 + 40) + a2))
    {
      uint64_t AtomHeader = 0;
      *(void *)(a3 + 56) = a2;
      *(void *)(a3 + 80) = v14;
      return AtomHeader;
    }
    *(void *)long long v16 = 0;
    uint64_t v17 = 0;
    AtomTypeToString(*(_DWORD *)(a3 + 64), v16);
    snprintf(__str, 0x100uLL, "Atom '%s' has an invalid length %lld, offset %lld, limit %lld", v16, *(void *)(a3 + 72), *(void *)(a3 + 40) + a2, v12);
    uint64_t AtomHeader = 4294954402;
    FigSignalErrorAt(4294954402, 0, 0, 0, 0, 0, 0);
    uint64_t v10 = *(void *)(a3 + 104);
    int v11 = -12894;
    goto LABEL_7;
  }
  return AtomHeader;
}

uint64_t ReadAtomHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a3 + 8 > a4) {
    return 4294954403;
  }
  uint64_t v14 = 0;
  *(void *)uint64_t v15 = 0;
  size_t v13 = 0;
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 8);
  if (v11) {
    return v11;
  }
  *(void *)long long v16 = 0;
  uint64_t v17 = 0;
  snprintf(__str, 0x100uLL, "Fewer bytes read than expected reading atom header at offset %lld (read %zd wanted %zd)", a3, v13, 8uLL);
  if (a7) {
    FigSignalErrorAt(4294954404, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v7 = 4294954404;
  AtomStreamReportErrorMessage(a1, v16, -12892, (uint64_t)__str);
  return v7;
}

char *AtomTypeToString(unsigned int a1, char *__str)
{
  if ((a1 & 0x80000000) != 0) {
    int v4 = __maskrune(HIBYTE(a1), 0x40000uLL);
  }
  else {
    int v4 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * HIBYTE(a1) + 60) & 0x40000;
  }
  if (!v4) {
    goto LABEL_15;
  }
  if (BYTE2(a1) > 0x7Fu)
  {
    if (!__maskrune(BYTE2(a1), 0x40000uLL)) {
      goto LABEL_15;
    }
  }
  else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * BYTE2(a1) + 60) & 0x40000) == 0)
  {
    goto LABEL_15;
  }
  if (BYTE1(a1) <= 0x7Fu)
  {
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * BYTE1(a1) + 60) & 0x40000) == 0) {
      goto LABEL_15;
    }
LABEL_13:
    if (a1 > 0x7Fu)
    {
      if (!__maskrune(a1, 0x40000uLL)) {
        goto LABEL_15;
      }
    }
    else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * a1 + 60) & 0x40000) == 0)
    {
      goto LABEL_15;
    }
    snprintf(__str, 0x10uLL, "%c%c%c%c");
    return __str;
  }
  if (__maskrune(BYTE1(a1), 0x40000uLL)) {
    goto LABEL_13;
  }
LABEL_15:
  snprintf(__str, 0x10uLL, "0x%02x%02x%02x%02x");
  return __str;
}

uint64_t FigAtomStreamGetCurrentAtomTypeAndDataLength(uint64_t a1, _DWORD *a2, void *a3)
{
  if (a2) {
    *a2 = *(_DWORD *)(a1 + 64);
  }
  if (a3) {
    *a3 = *(void *)(a1 + 80);
  }
  return 0;
}

uint64_t FigAtomStreamGetCurrentAtomUUIDType(uint64_t a1, _OWORD *a2)
{
  if (*(_DWORD *)(a1 + 64) != 1970628964) {
    return 4294954401;
  }
  uint64_t result = 0;
  *a2 = *(_OWORD *)(a1 + 88);
  return result;
}

uint64_t FigAtomStreamGetCurrentAtomVersionAndFlags(uint64_t a1, unsigned char *a2, unsigned int *a3)
{
  unsigned int v7 = 0;
  uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 4, (uint64_t)&v7);
  if (!result)
  {
    unsigned int v6 = bswap32(v7);
    if (a2) {
      *a2 = HIBYTE(v6);
    }
    if (a3) {
      *a3 = v6 & 0xFFFFFF;
    }
  }
  return result;
}

uint64_t FigAtomStreamReadCurrentAtomData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = 0;
  uint64_t v7 = *(void *)(a1 + 80);
  if (v7 > a2 && a3 + a2 <= v7)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(a1 + 24))(a1 + 8, a3, *(void *)(a1 + 40) + a2 + *(void *)(a1 + 56), a4, &v14);
    if (v9) {
      return v9;
    }
    uint64_t v12 = v14;
    if (v14 == a3) {
      return 0;
    }
    *(void *)uint64_t v15 = 0;
    uint64_t v16 = 0;
    AtomTypeToString(*(_DWORD *)(a1 + 64), v15);
    snprintf(__str, 0x100uLL, "Fewer bytes read than expected (got %zd wanted %zd) %lld bytes into '%s' atom length %lld @ %lld", v12, a3, a2, v15, *(void *)(a1 + 80), *(void *)(a1 + 56) + *(void *)(a1 + 40));
    uint64_t v9 = 4294954404;
    FigSignalErrorAt(4294954404, 0, 0, 0, 0, 0, 0);
    uint64_t v10 = *(void *)(a1 + 104);
    int v11 = -12892;
  }
  else
  {
    *(void *)uint64_t v15 = 0;
    uint64_t v16 = 0;
    AtomTypeToString(*(_DWORD *)(a1 + 64), v15);
    snprintf(__str, 0x100uLL, "Attempt to read %zd bytes at %lld out of range of '%s' atom's data size %lld", a3, a2, v15, *(void *)(a1 + 80));
    uint64_t v9 = 4294954405;
    FigSignalErrorAt(4294954405, 0, 0, 0, 0, 0, 0);
    uint64_t v10 = *(void *)(a1 + 104);
    int v11 = -12891;
  }
  AtomStreamReportErrorMessage(v10, v15, v11, (uint64_t)__str);
  return v9;
}

uint64_t FigAtomStreamGetCurrentAtomGlobalOffset(void *a1, void *a2, void *a3)
{
  if (a2) {
    *a2 = a1[7] + a1[5] - a1[9] + a1[10];
  }
  if (a3) {
    *a3 = a1[9];
  }
  return 0;
}

uint64_t FigAtomStreamGetCurrentAtomOffsetInParent(void *a1, void *a2)
{
  *a2 = a1[10] - a1[9] + a1[7];
  return 0;
}

uint64_t FigAtomStreamGetCurrentAtomDataGlobalOffset(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 80) <= a2)
  {
    *(void *)uint64_t v7 = 0;
    uint64_t v8 = 0;
    AtomTypeToString(*(_DWORD *)(a1 + 64), v7);
    snprintf(__str, 0x100uLL, "Offset %lld beyond end of '%s' atom's dataLength %lld", a2, v7, *(void *)(a1 + 80));
    uint64_t v5 = 4294954405;
    FigSignalErrorAt(4294954405, 0, 0, 0, 0, 0, 0);
    AtomStreamReportErrorMessage(*(void *)(a1 + 104), v7, -12891, (uint64_t)__str);
  }
  else
  {
    uint64_t v5 = 0;
    *a3 = *(void *)(a1 + 40) + a2 + *(void *)(a1 + 56);
  }
  return v5;
}

uint64_t FigAtomStreamGetCurrentAtomHeaderSize(uint64_t a1, void *a2)
{
  *a2 = *(void *)(a1 + 72) - *(void *)(a1 + 80);
  return 0;
}

uint64_t FigAtomStreamReadCurrentAtomDataAndCreateBBuf(uint64_t a1, uint64_t a2, size_t a3, CMBlockBufferRef *a4)
{
  size_t v4 = a3;
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = 0;
  uint64_t v7 = *(void *)(a1 + 80);
  if (v7 <= a2 || (uint64_t)(a3 + a2) > v7)
  {
    *(void *)uint64_t v17 = 0;
    uint64_t v18 = 0;
    AtomTypeToString(*(_DWORD *)(a1 + 64), v17);
    snprintf(__str, 0x100uLL, "Attempt to read %zd bytes at %lld out of range of '%s' atom's data size %lld", v4, a2, v17, *(void *)(a1 + 80));
    uint64_t Contiguous = 4294954405;
    FigSignalErrorAt(4294954405, 0, 0, 0, 0, 0, 0);
    uint64_t v10 = *(void *)(a1 + 104);
    int v11 = -12891;
LABEL_6:
    AtomStreamReportErrorMessage(v10, v17, v11, (uint64_t)__str);
    return Contiguous;
  }
  CMBlockBufferRef sourceBuffer = 0;
  if (!a3) {
    size_t v4 = v7 - a2;
  }
  uint64_t Contiguous = (*(uint64_t (**)(uint64_t, size_t, uint64_t, CMBlockBufferRef *, uint64_t *))(a1 + 32))(a1 + 8, v4, *(void *)(a1 + 40) + a2 + *(void *)(a1 + 56), &sourceBuffer, &v16);
  if (!Contiguous)
  {
    uint64_t v14 = v16;
    if (v16 != v4)
    {
      if (sourceBuffer)
      {
        CFRelease(sourceBuffer);
        uint64_t v14 = v16;
      }
      *(void *)uint64_t v17 = 0;
      uint64_t v18 = 0;
      AtomTypeToString(*(_DWORD *)(a1 + 64), v17);
      snprintf(__str, 0x100uLL, "Fewer bytes read than expected (got %zd wanted %zd) %lld bytes into '%s' atom length %lld @ %lld", v14, v4, a2, v17, *(void *)(a1 + 80), *(void *)(a1 + 56) + *(void *)(a1 + 40));
      uint64_t Contiguous = 4294954404;
      FigSignalErrorAt(4294954404, 0, 0, 0, 0, 0, 0);
      uint64_t v10 = *(void *)(a1 + 104);
      int v11 = -12892;
      goto LABEL_6;
    }
    if (CMBlockBufferIsRangeContiguous(sourceBuffer, 0, v4))
    {
      uint64_t Contiguous = 0;
      *a4 = sourceBuffer;
    }
    else
    {
      *(void *)__str = 0;
      uint64_t Contiguous = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E4F1CF80], sourceBuffer, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, v4, 0, (CMBlockBufferRef *)__str);
      *a4 = *(CMBlockBufferRef *)__str;
      if (sourceBuffer) {
        CFRelease(sourceBuffer);
      }
    }
  }
  return Contiguous;
}

uint64_t FigAtomStreamReadCurrentAtomAndCreateBBuf(uint64_t a1, CMBlockBufferRef *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CMBlockBufferRef sourceBuffer = 0;
  uint64_t v10 = 0;
  size_t v4 = *(void *)(a1 + 72);
  size_t v5 = *(void *)(a1 + 80) - v4 + *(void *)(a1 + 40) + *(void *)(a1 + 56);
  uint64_t Contiguous = (*(uint64_t (**)(uint64_t, size_t, size_t, CMBlockBufferRef *, uint64_t *))(a1 + 32))(a1 + 8, v4, v5, &sourceBuffer, &v10);
  if (!Contiguous)
  {
    uint64_t v7 = v10;
    if (v10 == v4)
    {
      if (CMBlockBufferIsRangeContiguous(sourceBuffer, 0, v4))
      {
        uint64_t Contiguous = 0;
        *a2 = sourceBuffer;
      }
      else
      {
        *(void *)__str = 0;
        uint64_t Contiguous = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E4F1CF80], sourceBuffer, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, v4, 0, (CMBlockBufferRef *)__str);
        *a2 = *(CMBlockBufferRef *)__str;
        if (sourceBuffer) {
          CFRelease(sourceBuffer);
        }
      }
    }
    else
    {
      if (sourceBuffer)
      {
        CFRelease(sourceBuffer);
        uint64_t v7 = v10;
      }
      *(void *)int v11 = 0;
      uint64_t v12 = 0;
      AtomTypeToString(*(_DWORD *)(a1 + 64), v11);
      snprintf(__str, 0x100uLL, "Fewer bytes read than expected (got %zd wanted %zd) for '%s' atom @ %lld", v7, v4, v11, v5);
      uint64_t Contiguous = 4294954404;
      FigSignalErrorAt(4294954404, 0, 0, 0, 0, 0, 0);
      AtomStreamReportErrorMessage(*(void *)(a1 + 104), v11, -12892, (uint64_t)__str);
    }
  }
  return Contiguous;
}

uint64_t FigAtomStreamAdvanceToNextAtom(void *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1[6];
  uint64_t v2 = a1[10] + a1[7];
  if (v2 == v1) {
    return 4294954406;
  }
  uint64_t v5 = a1[5];
  uint64_t v6 = v5 + v1;
  uint64_t AtomHeader = ReadAtomHeader(a1[13], (uint64_t)(a1 + 1), v5 + v2, v5 + v1, *(unsigned __int8 *)a1, 0, 1);
  if (!AtomHeader)
  {
    *(void *)uint64_t v8 = 0;
    uint64_t v9 = 0;
    AtomTypeToString(0, v8);
    snprintf(__str, 0x100uLL, "Atom '%s' has an invalid length %lld, offset %lld, limit %lld", v8, 0, a1[5] + v2, v6);
    uint64_t AtomHeader = 4294954402;
    FigSignalErrorAt(4294954402, 0, 0, 0, 0, 0, 0);
    AtomStreamReportErrorMessage(a1[13], v8, -12894, (uint64_t)__str);
  }
  return AtomHeader;
}

uint64_t FigAtomStreamAdvanceToNextAtomWithType(void *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1[6];
  uint64_t v2 = a1[10] + a1[7];
  if (v2 == v1) {
    return 4294954406;
  }
  uint64_t v5 = a1[5];
  uint64_t v6 = v1 + v5;
  uint64_t AtomHeader = ReadAtomHeader(a1[13], (uint64_t)(a1 + 1), v5 + v2, v1 + v5, *(unsigned __int8 *)a1, 0, 1);
  if (AtomHeader) {
    return AtomHeader;
  }
  *(void *)uint64_t v9 = 0;
  uint64_t v10 = 0;
  AtomTypeToString(0, v9);
  snprintf(__str, 0x100uLL, "Atom '%s' has an invalid length %lld, offset %lld, limit %lld", v9, 0, a1[5] + v2, v6);
  uint64_t v3 = 4294954402;
  FigSignalErrorAt(4294954402, 0, 0, 0, 0, 0, 0);
  AtomStreamReportErrorMessage(a1[13], v9, -12894, (uint64_t)__str);
  return v3;
}

uint64_t FigAtomStreamPositionAtFirstAtomWithType(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 64) == a2) {
    return 0;
  }
  else {
    return FigAtomStreamAdvanceToNextAtomWithType((void *)a1);
  }
}

__n128 FigAtomStreamAdvanceViaAtomPath(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  long long v14 = 0u;
  long long v15 = 0u;
  __n128 v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  if (!FigAtomStreamInitWithParent(a1, 0, (uint64_t)&v9)
    && (v13 == *a3 || !FigAtomStreamAdvanceToNextAtomWithType(&v9))
    && (a2 < 2 || !FigAtomStreamAdvanceViaAtomPath(&v9, a2 - 1, a3 + 1)))
  {
    long long v7 = v14;
    *(_OWORD *)(a1 + 64) = v13;
    *(_OWORD *)(a1 + 80) = v7;
    *(_OWORD *)(a1 + 96) = v15;
    long long v8 = v10;
    *(_OWORD *)a1 = v9;
    *(_OWORD *)(a1 + 16) = v8;
    __n128 result = v12;
    *(_OWORD *)(a1 + 32) = v11;
    *(__n128 *)(a1 + 48) = result;
  }
  return result;
}

__n128 FigAtomStreamPositionViaAtomPath(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (*(_DWORD *)(a1 + 64) == *a3) {
    int AtomWithType = 0;
  }
  else {
    int AtomWithType = FigAtomStreamAdvanceToNextAtomWithType((void *)a1);
  }
  if (a2 >= 2 && !AtomWithType)
  {
    long long v15 = 0u;
    long long v16 = 0u;
    __n128 v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v10 = 0u;
    if (!FigAtomStreamInitWithParent(a1, 0, (uint64_t)&v10)
      && !FigAtomStreamPositionViaAtomPath(&v10, a2 - 1, a3 + 1))
    {
      long long v8 = v15;
      *(_OWORD *)(a1 + 64) = v14;
      *(_OWORD *)(a1 + 80) = v8;
      *(_OWORD *)(a1 + 96) = v16;
      long long v9 = v11;
      *(_OWORD *)a1 = v10;
      *(_OWORD *)(a1 + 16) = v9;
      __n128 result = v13;
      *(_OWORD *)(a1 + 32) = v12;
      *(__n128 *)(a1 + 48) = result;
    }
  }
  return result;
}

uint64_t FigAtomStreamInitWithBBufAndReporter(OpaqueCMBlockBuffer *a1, unint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  DataCFIndex Length = CMBlockBufferGetDataLength(a1);
  if ((a2 & 0x8000000000000000) != 0 || DataLength <= a2)
  {
    v12[0] = 0;
    v12[1] = 0;
    snprintf(__str, 0x100uLL, "Offset %zd exceeds block buffer length %zd", a2, DataLength);
    FigSignalErrorAt(4294954403, 0, 0, 0, 0, 0, 0);
    AtomStreamReportErrorMessage(a4, (const char *)v12, -12893, (uint64_t)__str);
    return 4294954403;
  }
  else
  {
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)(a5 + 48) = 0u;
    *(_OWORD *)(a5 + 80) = 0u;
    *(_OWORD *)(a5 + 96) = 0u;
    *(_OWORD *)(a5 + 64) = 0u;
    *(unsigned char *)a5 = a3;
    *(void *)(a5 + 8) = a1;
    *(void *)(a5 + 16) = DataLength;
    *(void *)(a5 + 24) = ReadBytesFromBlockBufferDataSource;
    *(void *)(a5 + 32) = ReadBBufFromBlockBufferDataSource;
    *(void *)(a5 + 40) = a2;
    *(void *)(a5 + 48) = DataLength - a2;
    *(void *)(a5 + 104) = a4;
    return CommonAtomStreamInitialization((unsigned __int8 *)a5);
  }
}

uint64_t ReadBytesFromBlockBufferDataSource(CMBlockBufferRef *a1, size_t dataLength, size_t offsetToData, void *a4, size_t *a5)
{
  uint64_t result = CMBlockBufferCopyDataBytes(*a1, offsetToData, dataLength, a4);
  if (result) {
    size_t v8 = 0;
  }
  else {
    size_t v8 = dataLength;
  }
  *a5 = v8;
  return result;
}

uint64_t ReadBBufFromBlockBufferDataSource(CMBlockBufferRef *a1, size_t dataLength, size_t a3, CMBlockBufferRef *blockBufferOut, size_t *a5)
{
  uint64_t result = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *a1, a3, dataLength, 0, blockBufferOut);
  if (result) {
    size_t v8 = 0;
  }
  else {
    size_t v8 = dataLength;
  }
  *a5 = v8;
  return result;
}

uint64_t FigAtomStreamInitWithBBuf(OpaqueCMBlockBuffer *a1, unint64_t a2, char a3, uint64_t a4)
{
  return FigAtomStreamInitWithBBufAndReporter(a1, a2, a3, 0, a4);
}

uint64_t FigAtomStreamInitWithMemoryBlockAndReporter(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  if (!a2) {
    return FigSignalErrorAt(4294954399, 0, 0, 0, 0, 0, 0);
  }
  *(_OWORD *)a6 = 0u;
  *(_OWORD *)(a6 + 16) = 0u;
  *(_OWORD *)(a6 + 32) = 0u;
  *(_OWORD *)(a6 + 48) = 0u;
  *(_OWORD *)(a6 + 80) = 0u;
  *(_OWORD *)(a6 + 96) = 0u;
  *(_OWORD *)(a6 + 64) = 0u;
  *(unsigned char *)a6 = a4;
  *(void *)(a6 + 8) = a1;
  *(void *)(a6 + 16) = a2;
  *(void *)(a6 + 24) = ReadBytesFromMemoryBlockDataSource;
  *(void *)(a6 + 32) = ReadBBufFromMemoryBlockDataSource;
  *(void *)(a6 + 40) = a3;
  *(void *)(a6 + 48) = a2;
  *(void *)(a6 + 104) = a5;
  return CommonAtomStreamInitialization((unsigned __int8 *)a6);
}

uint64_t ReadBytesFromMemoryBlockDataSource(void *a1, int64_t a2, uint64_t a3, void *__dst, int64_t *a5)
{
  uint64_t v5 = a1[1];
  BOOL v6 = v5 <= a3;
  int64_t v7 = v5 - a3;
  if (v6) {
    return 4294954404;
  }
  if (v7 >= a2) {
    int64_t v7 = a2;
  }
  *a5 = v7;
  if (v7) {
    memcpy(__dst, (const void *)(*a1 + a3), v7);
  }
  return 0;
}

uint64_t ReadBBufFromMemoryBlockDataSource(void *a1, int64_t a2, uint64_t a3, CMBlockBufferRef *a4, size_t *a5)
{
  uint64_t v5 = a1[1];
  BOOL v6 = v5 <= a3;
  int64_t v7 = v5 - a3;
  if (v6) {
    return 4294954404;
  }
  if (v7 >= a2) {
    size_t v9 = a2;
  }
  else {
    size_t v9 = v7;
  }
  *a5 = v9;
  if (v9)
  {
    CMBlockBufferRef destinationBuffer = 0;
    uint64_t result = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v9, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, v9, 1u, &destinationBuffer);
    if (!result)
    {
      CMBlockBufferReplaceDataBytes((const void *)(*a1 + a3), destinationBuffer, 0, v9);
      uint64_t result = 0;
      *a4 = destinationBuffer;
    }
  }
  else
  {
    uint64_t result = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t FigAtomStreamInitWithMemoryBlock(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  return FigAtomStreamInitWithMemoryBlockAndReporter(a1, a2, a3, a4, 0, a5);
}

uint64_t FigAtomUtilityGetAtomTypeAndLengthInByteStream(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4, void *a5)
{
  return FigAtomUtilityGetAtomTypeAndLengthInByteStreamWithSize(a1, a2, 0x7FFFFFFFFFFFFFFFLL, a3, a4, a5);
}

uint64_t FigAtomUtilityGetAtomTypeAndLengthInByteStreamWithSize(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, void *a5, void *a6)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  uint64_t EntireLengthOfByteStream = GetEntireLengthOfByteStream(a1, &v17);
  if (EntireLengthOfByteStream) {
    return EntireLengthOfByteStream;
  }
  if (a2 < 0 || v17 <= a2)
  {
    snprintf(__str, 0x100uLL, "Offset %lld exceeds stream length %lld.", a2, v17);
    uint64_t v15 = 4294954403;
    FigSignalErrorAt(4294954403, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    *(void *)__str = a1;
    uint64_t v19 = v17;
    uint64_t v20 = ReadBytesFromByteStreamDataSource;
    long long v21 = ReadBBufFromByteStreamDataSource;
    if (v17 - a2 >= a3) {
      uint64_t v13 = a3;
    }
    else {
      uint64_t v13 = v17 - a2;
    }
    unsigned int AtomHeader = ReadAtomHeader(0, (uint64_t)__str, a2, v13 + a2, 0, 1, 0);
    if (a4) {
      *a4 = 0;
    }
    if (a5) {
      *a5 = 0;
    }
    if (a6) {
      *a6 = 0;
    }
    if (AtomHeader + 12893 >= 2) {
      return AtomHeader;
    }
    else {
      return 4294954400;
    }
  }
  return v15;
}

uint64_t FigAtomUtilityGetAtomTypeAndLengthInBBuf(OpaqueCMBlockBuffer *a1, unint64_t a2, _DWORD *a3, void *a4, void *a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  DataCFIndex Length = CMBlockBufferGetDataLength(a1);
  if ((a2 & 0x8000000000000000) != 0 || DataLength <= a2)
  {
    snprintf(__str, 0x100uLL, "Offset %zd exceeds block buffer length %zd", a2, DataLength);
    uint64_t v12 = 4294954403;
    FigSignalErrorAt(4294954403, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    *(void *)__str = a1;
    size_t v15 = DataLength;
    long long v16 = ReadBytesFromBlockBufferDataSource;
    uint64_t v17 = ReadBBufFromBlockBufferDataSource;
    unsigned int AtomHeader = ReadAtomHeader(0, (uint64_t)__str, a2, DataLength, 0, 1, 1);
    if (a3) {
      *a3 = 0;
    }
    if (a4) {
      *a4 = 0;
    }
    if (a5) {
      *a5 = 0;
    }
    if (AtomHeader + 12893 >= 2) {
      return AtomHeader;
    }
    else {
      return 4294954400;
    }
  }
  return v12;
}

uint64_t FigPriorityQueueGetTypeID()
{
  return sFigPriorityQueueID;
}

uint64_t registerFigPriorityQueue()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigPriorityQueueID = result;
  return result;
}

uint64_t FigPriorityQueueCreate(const __CFAllocator *a1, CFIndex a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  if (a4 && a6)
  {
    FigThreadRunOnce(&FigPriorityQueueGetTypeID_sRegisterFigPriorityQueueOnce, (void (*)(void))registerFigPriorityQueue);
    uint64_t Instance = (void *)_CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v13 = Instance;
      if (a3)
      {
        Instance[2] = a3[1];
        Instance[3] = a3[2];
        Instance[4] = a3[3];
        Instance[5] = a3[4];
      }
      else
      {
        *((_OWORD *)Instance + 1) = 0u;
        *((_OWORD *)Instance + 2) = 0u;
      }
      Instance[6] = a4;
      Instance[7] = a5;
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(a1, a2, MEMORY[0x1E4F1D510]);
      v13[8] = Mutable;
      if (Mutable)
      {
        CFArrayAppendValue(Mutable, (const void *)*MEMORY[0x1E4F1D260]);
        uint64_t result = 0;
        *a6 = v13;
        return result;
      }
      CFRelease(v13);
    }
    return 4294954305;
  }
  else
  {
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigPriorityQueueCheckHeap(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  if (Count < 2) {
    return 0;
  }
  CFIndex v3 = Count;
  if (*((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), 1) + 3) == 1) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  if (v3 != 2)
  {
    for (unint64_t i = 2; i != v3; ++i)
    {
      CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), i);
      if (comparePriorityAtIndices(a1, i, i >> 1) == -1) {
        unsigned int v7 = -1;
      }
      else {
        unsigned int v7 = v4;
      }
      if (i == ValueAtIndex[3]) {
        uint64_t v4 = v7;
      }
      else {
        uint64_t v4 = 0xFFFFFFFFLL;
      }
    }
  }
  return v4;
}

uint64_t comparePriorityAtIndices(uint64_t result, CFIndex a2, CFIndex a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (!*(void *)(result + 48)) {
      return 0;
    }
    if (!a2) {
      return -1;
    }
    if (!a3 || CFArrayGetCount(*(CFArrayRef *)(result + 64)) <= a2) {
      return 1;
    }
    if (CFArrayGetCount(*(CFArrayRef *)(v3 + 64)) <= a3) {
      return -1;
    }
    uint64_t result = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 64), a2);
    if (result)
    {
      uint64_t v6 = result;
      uint64_t result = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 64), a3);
      if (result)
      {
        uint64_t v7 = *(void *)(result + 16);
        size_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v3 + 48);
        uint64_t v8 = *(void *)(v3 + 56);
        uint64_t v10 = *(void *)(v6 + 16);
        return v9(v10, v7, v8);
      }
    }
  }
  return result;
}

uint64_t FigPriorityQueueInsertItemAndCreateUpdateToken(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
    FigThreadRunOnce(&FigPriorityQueueNodeGetTypeID_sRegisterFigPriorityQueueNodeOnce, (void (*)(void))registerFigPriorityQueueNode);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v8 = (void *)Instance;
      *(void *)(Instance + 32) = a1;
      size_t v9 = *(uint64_t (**)(CFAllocatorRef, uint64_t))(a1 + 16);
      if (v9) {
        a2 = v9(v6, a2);
      }
      void v8[2] = a2;
      v8[6] = v6;
      v8[5] = *(void *)(a1 + 24);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 64), v8);
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
      v8[3] = Count - 1;
      siftUp(a1, Count - 1);
      if (a3) {
        *a3 = v8;
      }
      else {
        CFRelease(v8);
      }
      return 0;
    }
    uint64_t v12 = 4294954305;
  }
  else
  {
    uint64_t v12 = 4294954306;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

void siftUp(uint64_t a1, uint64_t a2)
{
  if (a2 >= 2)
  {
    unint64_t v2 = a2;
    do
    {
      if (comparePriorityAtIndices(a1, v2, v2 >> 1) != -1) {
        break;
      }
      swapIndices(*(const __CFArray **)(a1 + 64), v2, v2 >> 1);
      BOOL v4 = v2 > 3;
      v2 >>= 1;
    }
    while (v4);
  }
}

uint64_t FigPriorityQueueInsertItem(uint64_t a1, uint64_t a2)
{
  return FigPriorityQueueInsertItemAndCreateUpdateToken(a1, a2, 0);
}

uint64_t FigPriorityQueueGetItem(uint64_t a1, void *a2)
{
  if (a1)
  {
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 64)) < 2)
    {
      uint64_t v5 = 0;
      if (!a2) {
        return 0;
      }
    }
    else
    {
      uint64_t v5 = *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), 1) + 2);
      if (!a2) {
        return 0;
      }
    }
    *a2 = v5;
    return 0;
  }
  return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
}

uint64_t FigPriorityQueueRemoveItem(uint64_t a1)
{
  if (a1)
  {
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 64)) == 1) {
      return 0;
    }
    CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), 1);
    if (ValueAtIndex)
    {
      uint64_t v3 = ValueAtIndex;
      BOOL v4 = *(void (**)(CFAllocatorRef, void))(a1 + 24);
      if (v4)
      {
        CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a1);
        v4(v5, v3[2]);
      }
      void v3[2] = 0;
      v3[3] = 0;
      unint64_t v3[4] = 0;
      CFArrayRef v6 = *(const __CFArray **)(a1 + 64);
      CFIndex Count = CFArrayGetCount(v6);
      swapIndices(v6, 1, Count - 1);
      CFArrayRef v8 = *(const __CFArray **)(a1 + 64);
      CFIndex v9 = CFArrayGetCount(v8);
      CFArrayRemoveValueAtIndex(v8, v9 - 1);
      siftDown(a1, 1);
      return 0;
    }
  }

  return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
}

void swapIndices(const __CFArray *a1, CFIndex a2, CFIndex a3)
{
  CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex(a1, a2);
  uint64_t v7 = CFArrayGetValueAtIndex(a1, a3);
  ValueAtIndex[3] = a3;
  v7[3] = a2;

  CFArrayExchangeValuesAtIndices(a1, a2, a3);
}

void siftDown(uint64_t a1, CFIndex a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  CFIndex v5 = 2 * a2;
  if (2 * a2 < Count)
  {
    uint64_t v6 = Count;
    do
    {
      CFIndex v7 = v5 | 1;
      if (comparePriorityAtIndices(a1, v5, v5 | 1) != 1) {
        CFIndex v7 = v5;
      }
      if (comparePriorityAtIndices(a1, v7, a2) != -1) {
        break;
      }
      swapIndices(*(const __CFArray **)(a1 + 64), a2, v7);
      CFIndex v5 = 2 * v7;
      a2 = v7;
    }
    while (2 * v7 < v6);
  }
}

uint64_t FigPriorityQueueCopyAndRemoveItem(void *a1, void *a2)
{
  uint64_t result = FigPriorityQueueGetItem((uint64_t)a1, a2);
  if (!result)
  {
    CFIndex v5 = (void (*)(CFAllocatorRef, void))a1[2];
    if (v5)
    {
      CFAllocatorRef v6 = CFGetAllocator(a1);
      v5(v6, *a2);
    }
    return FigPriorityQueueRemoveItem((uint64_t)a1);
  }
  return result;
}

CFIndex FigPriorityQueueGetCount(uint64_t a1)
{
  return CFArrayGetCount(*(CFArrayRef *)(a1 + 64)) - 1;
}

uint64_t FigPriorityQueueTokenUpdatePriority(void *a1)
{
  if (!a1) {
    return 4294954306;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&FigPriorityQueueNodeGetTypeID_sRegisterFigPriorityQueueNodeOnce, (void (*)(void))registerFigPriorityQueueNode);
  if (v2 != sFigPriorityQueueNodeID) {
    return 4294954306;
  }
  uint64_t v3 = a1[4];
  if (!v3 || !*(void *)(v3 + 48)) {
    return 4294954306;
  }
  uint64_t v4 = a1[3];
  if (v4 >= 0) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v4 + 1;
  }
  if (comparePriorityAtIndices(v3, v4, v5 >> 1) == -1) {
    siftUp(v3, v4);
  }
  else {
    siftDown(v3, v4);
  }
  return 0;
}

double figPriorityQueueInit(uint64_t a1)
{
  *(void *)(a1 + 64) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void figPriorityQueueFinalize(uint64_t a1)
{
  CFTypeID v2 = *(const void **)(a1 + 64);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 64) = 0;
  }
}

__CFString *figPriorityQueueCopyFormattingDesc(const void *a1, const __CFDictionary *a2)
{
  if (!a1) {
    return 0;
  }
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v4, 0);
  if (Mutable)
  {
    CFAllocatorRef v6 = CFGetAllocator(a1);
    CFStringAppendFormat(Mutable, a2, @"<FigPriorityQueue %p [%p]>{}", a1, v6);
  }
  return Mutable;
}

__CFString *figPriorityQueueCopyDebugDesc(const void *a1)
{
  return figPriorityQueueCopyFormattingDesc(a1, 0);
}

uint64_t registerFigPriorityQueueNode()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigPriorityQueueNodeID = result;
  return result;
}

double figPriorityQueueNodeInit(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void *figPriorityQueueNodeFinalize(void *result)
{
  uint64_t v1 = result;
  if (result[2])
  {
    CFTypeID v2 = (uint64_t (*)(void))result[5];
    if (v2) {
      double result = (void *)v2(result[6]);
    }
  }
  v1[2] = 0;
  v1[4] = 0;
  return result;
}

__CFString *figPriorityQueueNodeCopyFormattingDesc(void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v4, 0);
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, a2, @"<FigPriorityQueueNode %p [%p]>{\n", a1, v6);
  CFIndex v7 = *(uint64_t (**)(void))(a1[4] + 32);
  if (v7 && (CFStringRef v8 = (const __CFString *)v7(a1[2])) != 0)
  {
    CFStringRef v9 = v8;
    CFStringAppend(Mutable, v8);
    CFStringAppendFormat(Mutable, a2, @"\n}\n");
    CFRelease(v9);
  }
  else
  {
    CFStringAppendFormat(Mutable, a2, @"\n}\n");
  }
  return Mutable;
}

__CFString *figPriorityQueueNodeCopyDebugDesc(void *a1)
{
  return figPriorityQueueNodeCopyFormattingDesc(a1, 0);
}

uint64_t FigCaptionRubyReserveGetTypeID()
{
  return sFigCaptionRubyReserveID;
}

uint64_t RegisterFigCaptionRubyReserveType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionRubyReserveID = result;
  return result;
}

uint64_t FigCaptionRubyReserveGetRubyPosition(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t FigCaptionRubyReserveGetLength(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t FigCaptionRubyReserveCreate(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a5)
  {
    FigThreadRunOnce(&sRegisterFigCaptionRubyReserveTypeOnce, (void (*)(void))RegisterFigCaptionRubyReserveType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      long long v11 = (void *)Instance;
      if (a2) {
        CFTypeRef v12 = CFRetain(a2);
      }
      else {
        CFTypeRef v12 = 0;
      }
      v11[2] = v12;
      _OWORD v11[3] = a3;
      v11[4] = a4;
      *a5 = v11;
    }
    else
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCaptionRubyReserveCreateNone(uint64_t a1, void *a2)
{
  return FigCaptionRubyReserveCreate(a1, 0, 0, 0, a2);
}

double fcrr_Init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void fcrr_Finalize(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 16);
  if (v1) {
    CFRelease(v1);
  }
}

BOOL fcrr_Equal(BOOL result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    FigThreadRunOnce(&sRegisterFigCaptionRubyReserveTypeOnce, (void (*)(void))RegisterFigCaptionRubyReserveType);
    double result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionRubyReserveID)
      {
        CFTypeID v5 = CFGetTypeID((CFTypeRef)a2);
        FigThreadRunOnce(&sRegisterFigCaptionRubyReserveTypeOnce, (void (*)(void))RegisterFigCaptionRubyReserveType);
        if (v5 == sFigCaptionRubyReserveID)
        {
          double result = FigGeometryDimensionEqualToDimension(*(void *)(v3 + 24), *(void *)(v3 + 32), *(void *)(a2 + 24), *(void *)(a2 + 32));
          if (result) {
            return FigCFEqual(*(CFTypeRef *)(v3 + 16), *(CFTypeRef *)(a2 + 16)) != 0;
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFHashCode fcrr_Hash(void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&sRegisterFigCaptionRubyReserveTypeOnce, (void (*)(void))RegisterFigCaptionRubyReserveType);
  if (v2 != sFigCaptionRubyReserveID) {
    return 0;
  }
  uint64_t v3 = (const void *)a1[2];
  if (!v3) {
    return 0;
  }

  return CFHash(v3);
}

CFStringRef fcrr_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionRubyReserve %p]", a1);
}

CFStringRef fcrr_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionRubyReserve %p]", a1);
}

uint64_t FigXPCEndpointMessengerServerAssociateNeighborFigEndpointMessenger(xpc_connection_t connection, const void *a2, void *a3)
{
  return FigXPCServerAssociateObjectWithNeighborProcess(gEndpointMessengerServer, connection, a2, 0, 0, 0, a3);
}

uint64_t FigEndpointMessengerStartServer()
{
  v1[0] = 1;
  v1[1] = HandleEndpointMessengerRemoteMessage;
  long long v2 = 0u;
  long long v3 = 0u;
  return FigXPCServerStart((uint64_t)"com.apple.coremedia.endpointmessenger.xpc", v1, 0, &gEndpointMessengerServer);
}

uint64_t HandleEndpointMessengerRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  int v29 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v29);
  if (OpCode) {
    return OpCode;
  }
  uint64_t int64 = (const void *)xpc_dictionary_get_uint64(a2, ".objectID");
  cf[0] = 0;
  uint64_t v8 = FigXPCServerLookupAndRetainAssociatedObject(a1, (uint64_t)uint64, cf, 0);
  if (!v8)
  {
    if (cf[0])
    {
      CFTypeID v9 = CFGetTypeID(cf[0]);
      if (v9 == FigEndpointMessengerGetTypeID())
      {
        CFTypeRef v10 = cf[0];
        goto LABEL_6;
      }
    }
    uint64_t v8 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v11 = v8;
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  if (!v11)
  {
    CFTypeRef v10 = 0;
LABEL_6:
    uint64_t v11 = 4294966630;
    if (v29 > 1936221291)
    {
      if (v29 == 1936221292)
      {
        cf[0] = (CFTypeRef)MEMORY[0x1E4F143A8];
        cf[1] = (CFTypeRef)0x40000000;
        CFTypeRef cf[2] = __HandleSetHandlerMessage_block_invoke;
        cf[3] = &__block_descriptor_tmp_39;
        cf[4] = uint64;
        cf[5] = a1;
        uint64_t v21 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
        if (v21) {
          uint64_t v22 = v21;
        }
        else {
          uint64_t v22 = 0;
        }
        uint64_t v23 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(v22 + 8);
        if (!v23)
        {
          uint64_t v11 = 4294954514;
LABEL_38:
          if (v10) {
            CFRelease(v10);
          }
          return v11;
        }
        uint64_t v12 = v23(v10, cf);
LABEL_24:
        uint64_t v11 = v12;
        goto LABEL_38;
      }
      if (v29 != 1936552807) {
        goto LABEL_38;
      }
      cf[0] = 0;
      uint64_t v13 = xpc_dictionary_get_uint64(a2, "MessageType");
      uint64_t v14 = FigXPCMessageCopyCFObject(a2, "Payload", (__CFDictionary **)cf);
      if (!v14)
      {
        CFTypeRef v15 = cf[0];
        uint64_t v16 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
        if (v16) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = 0;
        }
        long long v24 = *(uint64_t (**)(CFTypeRef, uint64_t, CFTypeRef))(v17 + 16);
        if (!v24) {
          goto LABEL_35;
        }
        uint64_t v14 = v24(v10, v13, v15);
      }
    }
    else
    {
      if (v29 != 778268793)
      {
        if (v29 != 779314548) {
          goto LABEL_38;
        }
        uint64_t v12 = FigXPCHandleStdSetPropertyMessage((uint64_t)v10, a2);
        goto LABEL_24;
      }
      CFTypeRef v30 = 0;
      cf[0] = 0;
      uint64_t v14 = FigXPCMessageCopyCFString(a2, ".PropertyName", cf);
      if (!v14)
      {
        CFTypeRef v18 = cf[0];
        if (cf[0])
        {
          uint64_t v19 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 8);
          if (v19) {
            uint64_t v20 = v19;
          }
          else {
            uint64_t v20 = 0;
          }
          int v25 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void, CFTypeRef *))(v20 + 48);
          if (v25)
          {
            uint64_t v26 = v25(v10, v18, *MEMORY[0x1E4F1CF80], &v30);
            CFTypeRef v27 = v30;
            if (!v26)
            {
              uint64_t v11 = FigXPCMessageSetCFObject(a3, ".Value", v30);
              CFTypeRef v27 = v30;
              if (!v30) {
                goto LABEL_36;
              }
              goto LABEL_34;
            }
            uint64_t v11 = v26;
            if (v30) {
LABEL_34:
            }
              CFRelease(v27);
LABEL_36:
            if (cf[0]) {
              CFRelease(cf[0]);
            }
            goto LABEL_38;
          }
LABEL_35:
          uint64_t v11 = 4294954514;
          goto LABEL_36;
        }
        uint64_t v14 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
      }
    }
    uint64_t v11 = v14;
    goto LABEL_36;
  }
  return v11;
}

void __HandleSetHandlerMessage_block_invoke(uint64_t a1, unsigned int a2, const void *a3)
{
  xpc_object_t xdict = 0;
  if (!FigXPCCreateBasicMessage(0x6F75746Du, *(void *)(a1 + 32), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "MessageType", a2);
    if (!a3 || !FigXPCMessageSetCFObject(xdict, "Payload", a3)) {
      xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), xdict);
    }
  }
  FigXPCRelease(xdict);
}

uint64_t FigCustomURLLoaderServerCopyLoaderForID(void *a1, void *a2)
{
  if (!a1
    || !a2
    || (uint64_t result = FigXPCServerRetainNeighborObjectFromID((uint64_t *)gFigCustomURLLoaderServer, a1, a2), !*a2))
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigCustomURLLoaderServerAssociateNeighbor(_xpc_connection_s *a1, const void *a2, void *a3)
{
  uint64_t v10 = 0;
  CFAllocatorRef v6 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
  v6[1] = FigOSTransactionCreate("FigCustomURLLoader", 0, 0, 0);
  FigCFWeakReferenceTableCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 1, v6);
  uint64_t v7 = FigXPCServerAssociateObjectWithNeighborProcess(gFigCustomURLLoaderServer, a1, a2, (uint64_t)v6, (uint64_t)figCustomURLLoaderServer_disposeServerCompanion, 0, &v10);
  if (v7) {
    uint64_t v8 = (CFTypeRef *)v6;
  }
  else {
    uint64_t v8 = 0;
  }
  if (!v7)
  {
    *a3 = v10;
    if (!v8) {
      return v7;
    }
    goto LABEL_6;
  }
  if (v8) {
LABEL_6:
  }
    figCustomURLLoaderServer_disposeServerCompanion(v8);
  return v7;
}

void figCustomURLLoaderServer_disposeServerCompanion(CFTypeRef *a1)
{
  long long v2 = (void *)a1[1];
  if (v2)
  {
    os_release(v2);
    a1[1] = 0;
  }
  if (*a1) {
    CFRelease(*a1);
  }

  free(a1);
}

uint64_t FigCustomURLLoaderServerStart()
{
  v7[0] = 1;
  v7[1] = figCustomURLLoaderServer_handleMessage;
  v7[2] = figCustomURLLoaderServer_handleMessageNoReply;
  memset(&v7[3], 0, 24);
  if (FigServer_IsMediaparserd())
  {
    uint64_t v0 = 4294951145;
    return FigSignalErrorAt(v0, 0, 0, 0, 0, 0, 0);
  }
  BOOL IsMediaplaybackd = FigServer_IsMediaplaybackd();
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    uint64_t v0 = 4294954510;
    return FigSignalErrorAt(v0, 0, 0, 0, 0, 0, 0);
  }
  CFMutableDictionaryRef v4 = Mutable;
  if (IsMediaplaybackd) {
    CFTypeID v5 = "com.apple.coremedia.mediaplaybackd.customurlloader.xpc";
  }
  else {
    CFTypeID v5 = "com.apple.coremedia.customurlloader.xpc";
  }
  uint64_t v1 = FigXPCServerStart((uint64_t)v5, v7, (uint64_t)v4, &gFigCustomURLLoaderServer);
  CFRelease(v4);
  return v1;
}

uint64_t figCustomURLLoaderServer_handleMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  int v37 = 0;
  char v35 = 0;
  CFTypeRef cf = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v37);
  if (OpCode) {
    goto LABEL_57;
  }
  CFTypeRef ConnectionRefcon = (CFTypeRef)FigXPCServerGetConnectionRefcon(a1);
  if (ConnectionRefcon)
  {
LABEL_7:
    CFRetain(ConnectionRefcon);
    goto LABEL_8;
  }
  xpc_connection_get_pid(a1);
  uint64_t v39 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a2, "CustomURLLoader_Endpoint");
  if (value)
  {
    uint64_t v9 = (uint64_t)value;
    if (MEMORY[0x192FC6B30]() == MEMORY[0x1E4F145A0])
    {
      uint64_t v10 = FigCustomURLHandlerRemoteClientCreateWithXPCEndpoint(v9, (uint64_t)&v39);
      if (!v10)
      {
        CFTypeRef ConnectionRefcon = (CFTypeRef)v39;
        FigXPCServerSetConnectionRefcon(a1, v39, (uint64_t)figCustomURLLoaderServer_connectionRefconDestructor);
        if (!ConnectionRefcon) {
          goto LABEL_8;
        }
        goto LABEL_7;
      }
      goto LABEL_56;
    }
  }
  uint64_t v10 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (v10)
  {
LABEL_56:
    OpCFIndex Code = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
LABEL_57:
    uint64_t v22 = OpCode;
    goto LABEL_50;
  }
  FigXPCServerSetConnectionRefcon(a1, 0, (uint64_t)figCustomURLLoaderServer_connectionRefconDestructor);
  CFTypeRef ConnectionRefcon = 0;
LABEL_8:
  uint64_t int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  uint64_t v12 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v35);
  if (v12)
  {
LABEL_19:
    uint64_t v22 = v12;
    goto LABEL_48;
  }
  if (!cf || (CFTypeID v13 = CFGetTypeID(cf), v13 != FigCustomURLLoaderGetCFTypeID()))
  {
    uint64_t v12 = FigSignalErrorAt(4294949916, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  CFTypeRef v14 = cf;
  if (v37 == 779314548)
  {
    uint64_t v12 = FigXPCHandleStdSetPropertyMessage((uint64_t)cf, a2);
    goto LABEL_19;
  }
  if (v37 != 1668043858)
  {
    if (v37 != 1668039497)
    {
      uint64_t v22 = 0;
      goto LABEL_48;
    }
    CFTypeRef v15 = v35;
    CFTypeRef v38 = 0;
    uint64_t v39 = 0;
    uint64_t v16 = (const void *)xpc_dictionary_get_uint64(a2, "CustomURLLoader_HandlerID");
    int64_t int64 = xpc_dictionary_get_int64(a2, "CustomURLLoader_Priority");
    uint64_t v18 = FigXPCMessageCopyCFDictionary(a2, "CustomURLLoader_CreateOptions", &v38);
    if (!v18)
    {
      uint64_t v18 = FigCustomURLHandlerRemoteCreateWithID(v16, ConnectionRefcon, (uint64_t)v38, (CFTypeRef *)&v39);
      if (!v18)
      {
        uint64_t v19 = v39;
        uint64_t v20 = *(void *)(CMBaseObjectGetVTable((uint64_t)v14) + 16);
        if (v20) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = 0;
        }
        uint64_t v31 = *(uint64_t (**)(CFTypeRef, uint64_t, int64_t))(v21 + 8);
        if (!v31)
        {
          uint64_t v22 = 4294954514;
          if (!a3) {
            goto LABEL_33;
          }
          goto LABEL_32;
        }
        uint64_t v18 = v31(v14, v19, int64);
        if (!v18) {
          uint64_t v18 = FigCFWeakReferenceTableAddValueAssociatedWithKey(*v15, v39, (uint64_t)v16);
        }
      }
    }
    uint64_t v22 = v18;
    if (!a3)
    {
LABEL_33:
      if (v38) {
        CFRelease(v38);
      }
      CFTypeRef v32 = (CFTypeRef)v39;
      if (!v39) {
        goto LABEL_48;
      }
      goto LABEL_47;
    }
LABEL_32:
    xpc_dictionary_set_int64(a3, ".ErrorReturn", (int)v22);
    goto LABEL_33;
  }
  uint64_t v23 = v35;
  long long v24 = (void *)xpc_dictionary_get_uint64(a2, "CustomURLLoader_FromHandlerID");
  int v25 = (void *)xpc_dictionary_get_uint64(a2, "CustomURLLoader_ToHandlerID");
  uint64_t v26 = xpc_dictionary_get_uint64(a2, "CustomURLLoader_RequestID");
  id v27 = FigCFWeakReferenceTableCopyValue(*v23, v24);
  if (!v27)
  {
    id v28 = 0;
LABEL_59:
    uint64_t v22 = 0;
    if (!a3) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  id v28 = FigCFWeakReferenceTableCopyValue(*v23, v25);
  if (!v28) {
    goto LABEL_59;
  }
  uint64_t v29 = *(void *)(CMBaseObjectGetVTable((uint64_t)v14) + 16);
  if (v29) {
    uint64_t v30 = v29;
  }
  else {
    uint64_t v30 = 0;
  }
  uint64_t v33 = *(uint64_t (**)(CFTypeRef, id, id, uint64_t))(v30 + 48);
  if (v33)
  {
    uint64_t v22 = v33(v14, v27, v28, v26);
    if (!a3) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  uint64_t v22 = 4294954514;
  if (a3) {
LABEL_42:
  }
    xpc_dictionary_set_int64(a3, ".ErrorReturn", (int)v22);
LABEL_43:
  if (v27) {
    CFRelease(v27);
  }
  if (!v28) {
    goto LABEL_48;
  }
  CFTypeRef v32 = v28;
LABEL_47:
  CFRelease(v32);
LABEL_48:
  if (ConnectionRefcon) {
    CFRelease(ConnectionRefcon);
  }
LABEL_50:
  if (cf) {
    CFRelease(cf);
  }
  return v22;
}

uint64_t figCustomURLLoaderServer_handleMessageNoReply(_xpc_connection_s *a1, void *a2)
{
  int v11 = 0;
  uint64_t v9 = 0;
  CFTypeRef cf = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v11);
  if (OpCode) {
    goto LABEL_7;
  }
  uint64_t int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  OpCFIndex Code = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v9);
  if (OpCode) {
    goto LABEL_7;
  }
  if (!cf || (CFTypeID v6 = CFGetTypeID(cf), v6 != FigCustomURLLoaderGetCFTypeID()))
  {
    OpCFIndex Code = FigSignalErrorAt(4294949916, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  if (v11 == 1668039785)
  {
    OpCFIndex Code = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_7:
    uint64_t v7 = OpCode;
    goto LABEL_9;
  }
  uint64_t v7 = 0;
LABEL_9:
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

uint64_t FigAtomWriterInitWithBlockBuffer(OpaqueCMBlockBuffer *a1, uint64_t a2)
{
  *(void *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(void *)a2 = a1;
  *(void *)(a2 + 24) = CMBlockBufferGetDataLength(a1);
  return 0;
}

uint64_t FigAtomWriterInitWithByteStream(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(void *)(a2 + 8) = a1;
  CFNumberRef number = 0;
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  CFTypeID v6 = *(uint64_t (**)(uint64_t, __CFString *, void, CFNumberRef *))(v5 + 48);
  if (v6)
  {
    uint64_t v7 = v6(CMBaseObject, @"FBS_EntireLength", *MEMORY[0x1E4F1CF80], &number);
    if (!v7)
    {
      if (CFNumberGetValue(number, kCFNumberSInt64Type, (void *)(a2 + 24)))
      {
        uint64_t v8 = 0;
        goto LABEL_11;
      }
      uint64_t v7 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v8 = v7;
  }
  else
  {
    uint64_t v8 = 4294954514;
  }
LABEL_11:
  if (number) {
    CFRelease(number);
  }
  return v8;
}

uint64_t FigAtomWriterInitWithParent(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  uint64_t v2 = *(void *)(a1 + 40) + *(void *)(a1 + 24);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = a1;
  *(void *)(a2 + 24) = v2;
  return 0;
}

uint64_t FigAtomWriterBeginAtom(uint64_t a1, unsigned int a2, int a3)
{
  if (*(unsigned char *)(a1 + 49))
  {
    uint64_t v8 = FigSignalErrorAt(4294954725, 0, 0, 0, 0, 0, 0);
    if (!v8) {
      return v8;
    }
LABEL_14:
    FigAtomWriterReleaseByteStreamIfNecessary((void *)a1);
    return v8;
  }
  if (!*(void *)(a1 + 16))
  {
    if (*(void *)a1)
    {
      uint64_t WritableForBlockBuffer = CMByteStreamCreateWritableForBlockBuffer((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(void **)a1, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFTypeRef *)(a1 + 8));
      if (WritableForBlockBuffer) {
        goto LABEL_12;
      }
    }
  }
  v11[0] = (a3 != 0) << 24;
  v11[1] = bswap32(a2);
  uint64_t WritableForBlockBuffer = CMByteStreamAppend(*(void *)(a1 + 8), 8, (uint64_t)v11, 0);
  if (WritableForBlockBuffer) {
    goto LABEL_12;
  }
  *(void *)(a1 + 40) = 8;
  if (!a3)
  {
    uint64_t v7 = 8;
    goto LABEL_10;
  }
  uint64_t v10 = 0;
  uint64_t WritableForBlockBuffer = CMByteStreamAppend(*(void *)(a1 + 8), 8, (uint64_t)&v10, 0);
  if (WritableForBlockBuffer)
  {
LABEL_12:
    uint64_t v8 = WritableForBlockBuffer;
    goto LABEL_14;
  }
  uint64_t v7 = *(void *)(a1 + 40) + 8;
  *(void *)(a1 + 40) = v7;
LABEL_10:
  uint64_t v8 = 0;
  *(void *)(a1 + 32) = v7;
  *(unsigned char *)(a1 + 48) = a3;
  *(unsigned char *)(a1 + 49) = 1;
  return v8;
}

void FigAtomWriterReleaseByteStreamIfNecessary(void *a1)
{
  if (!a1[2] && *a1)
  {
    uint64_t v2 = (const void *)a1[1];
    if (v2)
    {
      CFRelease(v2);
      a1[1] = 0;
    }
  }
}

uint64_t FigAtomWriterBeginUUIDAtom(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = FigAtomWriterBeginAtom(a1, 0x75756964u, a3);
  if (v5) {
    return v5;
  }
  uint64_t v6 = CMByteStreamAppend(*(void *)(a1 + 8), 16, a2, 0);
  if (v6)
  {
    FigAtomWriterReleaseByteStreamIfNecessary((void *)a1);
    *(unsigned char *)(a1 + 49) = 0;
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 40) + 16;
    *(void *)(a1 + 32) = v7;
    *(void *)(a1 + 40) = v7;
  }
  return v6;
}

uint64_t FigAtomWriterAppendVersionAndFlags(uint64_t a1, unsigned __int8 a2, int a3)
{
  if (*(unsigned char *)(a1 + 49))
  {
    unsigned int v6 = bswap32(a3 & 0xFFFFFF | (a2 << 24));
    uint64_t result = CMByteStreamAppend(*(void *)(a1 + 8), 4, (uint64_t)&v6, 0);
    if (!result)
    {
      uint64_t v5 = *(void *)(a1 + 40) + 4;
      *(void *)(a1 + 32) = v5;
      *(void *)(a1 + 40) = v5;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigAtomWriterAppendData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 49))
  {
    if (a3)
    {
      uint64_t result = CMByteStreamAppend(*(void *)(a1 + 8), a3, a2, 0);
      if (!result) {
        *(void *)(a1 + 40) += a3;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigAtomWriterAppendBlockBufferData(uint64_t a1, OpaqueCMBlockBuffer *a2, size_t a3, size_t dataLength)
{
  if (*(unsigned char *)(a1 + 49))
  {
    if (!dataLength) {
      return 0;
    }
    unsigned int v6 = *(OpaqueCMBlockBuffer **)a1;
    if (v6)
    {
      uint64_t result = CMBlockBufferAppendBufferReference(v6, a2, a3, dataLength, 0);
      if (result) {
        return result;
      }
    }
    else
    {
      uint64_t result = CMByteStreamAppendBlockBuffer(*(void *)(a1 + 8));
      if (result) {
        return result;
      }
    }
    uint64_t result = 0;
    *(void *)(a1 + 40) += dataLength;
  }
  else
  {
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigAtomWriterEndAtom(uint64_t a1)
{
  unint64_t v18 = 0;
  if (!*(unsigned char *)(a1 + 49))
  {
    uint64_t v7 = 0;
    goto LABEL_22;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  unint64_t v18 = v2;
  if (!*(unsigned char *)(a1 + 48))
  {
    if (v2 >= 0x100000000)
    {
      uint64_t v8 = FigSignalErrorAt(4294954724, 0, 0, 0, 0, 0, 0);
LABEL_8:
      uint64_t v7 = v8;
      goto LABEL_22;
    }
    unsigned int v17 = bswap32(v2);
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = *(void *)(a1 + 24);
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable(v11) + 16);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    CFTypeRef v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned int *, void))(v14 + 16);
    if (v15)
    {
      uint64_t v7 = v15(v11, 4, v12, &v17, 0);
      if (v7) {
        goto LABEL_22;
      }
      goto LABEL_12;
    }
LABEL_21:
    uint64_t v7 = 4294954514;
    goto LABEL_22;
  }
  unint64_t v18 = bswap64(v2);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable(v3) + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *, void))(v6 + 16);
  if (!v9) {
    goto LABEL_21;
  }
  uint64_t v8 = v9(v3, 8, v4 + 8, &v18, 0);
  if (v8) {
    goto LABEL_8;
  }
LABEL_12:
  uint64_t v10 = *(void *)(a1 + 16);
  if (v10) {
    *(void *)(v10 + 40) += *(void *)(a1 + 40);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 24) += *(void *)(a1 + 40);
LABEL_22:
  FigAtomWriterReleaseByteStreamIfNecessary((void *)a1);
  *(unsigned char *)(a1 + 49) = 0;
  return v7;
}

uint64_t FigAtomWriterGetAtomGlobalDataOffset(uint64_t a1, void *a2)
{
  if (!*(unsigned char *)(a1 + 49)) {
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  }
  *a2 = *(void *)(a1 + 32) + *(void *)(a1 + 24);
  return 0;
}

uint64_t FigAtomWriterGetAtomSize(uint64_t a1, void *a2)
{
  if (!*(unsigned char *)(a1 + 49)) {
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  }
  *a2 = *(void *)(a1 + 40);
  return 0;
}

uint64_t FigAtomWriterGetAtomDataSize(uint64_t a1, void *a2)
{
  if (!*(unsigned char *)(a1 + 49)) {
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  }
  *a2 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
  return 0;
}

uint64_t FigByteStreamProviderGetClassID()
{
  return sFigByteStreamProviderClassID;
}

uint64_t RegisterFigByteStreamProviderBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigByteStreamProviderClassDesc, ClassID, 1, &sFigByteStreamProviderClassID);
}

uint64_t FigByteStreamProviderGetTypeID()
{
  FigThreadRunOnce(&FigByteStreamProviderGetClassID_sRegisterFigByteStreamProviderBaseTypeOnce, (void (*)(void))RegisterFigByteStreamProviderBaseType);
  uint64_t v0 = (void *)sFigByteStreamProviderClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigGetBaseByteStreamProvider()
{
  return sFigBaseByteStreamProvider;
}

CFTypeRef createBaseByteStreamProvider()
{
  uint64_t v0 = *MEMORY[0x1E4F1CF80];
  FigThreadRunOnce(&FigByteStreamProviderGetClassID_sRegisterFigByteStreamProviderBaseTypeOnce, (void (*)(void))RegisterFigByteStreamProviderBaseType);
  CFTypeRef result = (CFTypeRef)CMDerivedObjectCreate(v0, (uint64_t)&kBaseByteStreamProvider_VTable, (void *)sFigByteStreamProviderClassID, &sFigBaseByteStreamProvider);
  if (!result)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(sFigBaseByteStreamProvider);
    CFTypeRef result = (CFTypeRef)FigGetDefaultManagedFilePool();
    *(void *)(DerivedStorage + 8) = result;
    if (result)
    {
      return CFRetain(result);
    }
  }
  return result;
}

uint64_t FigByteStreamProviderCreateForBaseURLWithSecurityOptions(int a1, CFTypeRef cf, const void *a3, int a4, CFTypeRef *a5)
{
  if (cf && a3 && a5)
  {
    if (a4)
    {
      uint64_t v13 = 0;
      uint64_t v9 = *MEMORY[0x1E4F1CF80];
      FigThreadRunOnce(&FigByteStreamProviderGetClassID_sRegisterFigByteStreamProviderBaseTypeOnce, (void (*)(void))RegisterFigByteStreamProviderBaseType);
      uint64_t v10 = CMDerivedObjectCreate(v9, (uint64_t)&kSecurityPolicyByteStreamProvider_VTable, (void *)sFigByteStreamProviderClassID, &v13);
      if (!v10)
      {
        uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)v13);
        *(void *)uint64_t DerivedStorage = CFRetain(a3);
        *(_DWORD *)(DerivedStorage + 8) = a4;
        *(void *)(DerivedStorage + 16) = CFRetain(cf);
        *a5 = v13;
      }
    }
    else
    {
      uint64_t v10 = 0;
      *a5 = CFRetain(cf);
    }
    return v10;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

CFStringRef FigByteStreamProviderCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigByteStreamProvider %p]", a1);
}

CFTypeRef baseByteStreamProvider_CopyDebugDescription()
{
  return CFRetain(@"[Base ByteStreamProvider]");
}

uint64_t baseByteStreamProvider_CreateByteStreamForURL(uint64_t a1, CFURLRef relativeURL, unsigned int a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  if (relativeURL && a6 && (CFURLRef v10 = CFURLCopyAbsoluteURL(relativeURL)) != 0)
  {
    CFURLRef v11 = v10;
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    if ((a3 & 0xFFFFFFBF) != 0 || (uint64_t v13 = *(const void **)(DerivedStorage + 8)) == 0) {
      uint64_t ByteStreamForFile = CMByteStreamCreateForFileURL(a5, v11, a3, a6);
    }
    else {
      uint64_t ByteStreamForFile = FigManagedFilePoolCreateByteStreamForFile(v13, v11, a3, a5, a6);
    }
    uint64_t v15 = ByteStreamForFile;
    CFRelease(v11);
    return v15;
  }
  else
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t baseByteStreamProvider_CreateScheduledIOForURL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  CFTypeRef cf = 0;
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, CFTypeRef *))(v11 + 8);
  if (!v12) {
    return 4294954514;
  }
  uint64_t v13 = v12(a1, a2, 0, a3, a4, &cf);
  CFTypeRef v14 = cf;
  if (v13)
  {
    uint64_t v15 = v13;
    if (!cf) {
      return v15;
    }
    goto LABEL_7;
  }
  uint64_t v15 = FigScheduledIOCreateForReadingByteStream(a4, cf, a5);
  CFTypeRef v14 = cf;
  if (cf) {
LABEL_7:
  }
    CFRelease(v14);
  return v15;
}

void securityPolicyByteStreamProvider_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  uint64_t v2 = *(const void **)(DerivedStorage + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(DerivedStorage + 16) = 0;
  }
}

CFTypeRef securityPolicyByteStreamProvider_CopyDebugDescription()
{
  return CFRetain(@"[Security Policy ByteStreamProvider]");
}

uint64_t securityPolicyByteStreamProvider_CreateByteStreamForURL(uint64_t a1, const __CFURL *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a2)
  {
    uint64_t v12 = DerivedStorage;
    if (FigIsReferenceAllowedBySecurityPolicy(*(const __CFURL **)DerivedStorage, a2, *(_DWORD *)(DerivedStorage + 8)))
    {
      uint64_t v13 = *(void *)(v12 + 16);
      uint64_t v14 = *(void *)(CMBaseObjectGetVTable(v13) + 16);
      if (v14) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = 0;
      }
      unint64_t v18 = *(uint64_t (**)(uint64_t, const __CFURL *, uint64_t, uint64_t, uint64_t, uint64_t))(v15 + 8);
      if (!v18) {
        return 4294954514;
      }
      return v18(v13, a2, a3, a4, a5, a6);
    }
    uint64_t v16 = 4294954846;
  }
  else
  {
    uint64_t v16 = 4294954516;
  }

  return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
}

uint64_t securityPolicyByteStreamProvider_CreateScheduledIOForURL(uint64_t a1, const __CFURL *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a2)
  {
    uint64_t v10 = DerivedStorage;
    if (FigIsReferenceAllowedBySecurityPolicy(*(const __CFURL **)DerivedStorage, a2, *(_DWORD *)(DerivedStorage + 8)))
    {
      uint64_t v11 = *(void *)(v10 + 16);
      uint64_t v12 = *(void *)(CMBaseObjectGetVTable(v11) + 16);
      if (v12) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = 0;
      }
      uint64_t v16 = *(uint64_t (**)(uint64_t, const __CFURL *, uint64_t, uint64_t, uint64_t))(v13 + 16);
      if (!v16) {
        return 4294954514;
      }
      return v16(v11, a2, a3, a4, a5);
    }
    uint64_t v14 = 4294954846;
  }
  else
  {
    uint64_t v14 = 4294954516;
  }

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

void *FigLogRingBufferCreate(NSObject *a1, size_t a2, uint64_t a3, char a4)
{
  uint64_t v4 = 0;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = 0;
  if (a3 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = a3;
  }
  if (!a1 || !a2) {
    return v4;
  }
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (!qword_1E9272690)
  {
    qword_1E9272690 = qword_1EDF6DD80;
    kCustomDictRingBufferCallbacks = (uint64_t)kFigTypeCFRingBufferCallBacks[0];
    qword_1E9272688 = (uint64_t)flr_CustomDictGetSize;
  }
  uint64_t v10 = FigRingBufferCreate(v9, 0, v5 * a2, (uint64_t (**)())&kCustomDictRingBufferCallbacks);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = (uint64_t)v10;
  int v12 = FigGzipCreate(&v21);
  uint64_t v13 = 0;
  uint64_t v14 = v21;
  if (v12 || !v21) {
    goto LABEL_33;
  }
  uint64_t v13 = malloc_type_calloc(1uLL, a2, 0x89B6F939uLL);
  if (!v13)
  {
    uint64_t v14 = v21;
    goto LABEL_33;
  }
  uint64_t v4 = malloc_type_calloc(1uLL, 0x48uLL, 0x10A0040F5008690uLL);
  uint64_t v14 = v21;
  if (!v4)
  {
LABEL_33:
    if (v14) {
      FigGzipDispose(v14);
    }
    if (v13) {
      free(v13);
    }
    FigRingBufferRelease(v11);
    return 0;
  }
  void v4[4] = v11;
  v4[5] = v14;
  *uint64_t v4 = v13;
  v4[1] = 0;
  v4[2] = a2;
  *((unsigned char *)v4 + 64) = a4;
  memset(&v22, 0, sizeof(v22));
  uint32_t v15 = arc4random_uniform(0xAu);
  int v16 = 0;
  __darwin_time_t tv_sec = 0;
  while (1)
  {
    if (!flr_FigLogRingBufferMakeLogFileName("/private/var/mobile/Library/Logs/CrashReporter/mediaserverd_autolog_", 1, v16, v23))
    {
      if ((stat(v23, &v22) & 0x80000000) == 0)
      {
        if (tv_sec) {
          BOOL v18 = tv_sec <= v22.st_mtimespec.tv_sec;
        }
        else {
          BOOL v18 = 0;
        }
        if (!v18)
        {
          __darwin_time_t tv_sec = v22.st_mtimespec.tv_sec;
          uint32_t v15 = v16;
        }
        goto LABEL_27;
      }
      if (*__error() == 2 || *__error() == 20) {
        break;
      }
    }
LABEL_27:
    if (++v16 == 10) {
      goto LABEL_30;
    }
  }
  uint32_t v15 = v16;
LABEL_30:
  *((_DWORD *)v4 + 14) = v15;
  v4[3] = a1;
  dispatch_retain(a1);
  return v4;
}

uint64_t FigLogRingBufferAppend(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 4294950824;
  }
  if (!a1) {
    return 4294950825;
  }
  uint64_t v4 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (!v4) {
    return 4294950826;
  }
  *uint64_t v4 = a1;
  v4[1] = a2;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 24), v4, (dispatch_function_t)flr_FigLogRingBufferAppendAsync);
  return 0;
}

void flr_FigLogRingBufferAppendAsync(void *a1)
{
  long long v10 = 0uLL;
  if (a1)
  {
    uint64_t v3 = *(void *)a1;
    uint64_t v2 = (OpaqueCMBlockBuffer *)*((void *)a1 + 1);
    if (v2) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4)
    {
      if (!v2) {
        goto LABEL_16;
      }
    }
    else
    {
      DataCFIndex Length = CMBlockBufferGetDataLength(*((CMBlockBufferRef *)a1 + 1));
      size_t v6 = DataLength;
      size_t v7 = *(void *)(v3 + 16);
      if (v7 <= DataLength)
      {
        syslog(3, "<<<< FigLogRingBuffer >>>> LogRingBuffer Error: log msg bigger than ring buffer size(%ld).", DataLength);
      }
      else
      {
        uint64_t v8 = *(void *)(v3 + 8);
        if (!v8)
        {
          *(CFAbsoluteTime *)(v3 + 48) = CFAbsoluteTimeGetCurrent();
          uint64_t v8 = *(void *)(v3 + 8);
          size_t v7 = *(void *)(v3 + 16);
        }
        size_t v9 = v8 + v6;
        if (v8 + v6 >= v7)
        {
          long long v10 = *(_OWORD *)v3;
          flr_FigLogRingBufferCommitBuffer(v3, (uint64_t)&v10, 0, *(double *)(v3 + 48));
        }
        if (*(void *)v3 && !CMBlockBufferCopyDataBytes(v2, 0, v6, (void *)(*(void *)v3 + *(void *)(v3 + 8))))
        {
          *(void *)(v3 + 8) += v6;
          if (v9 >= v7) {
            *(CFAbsoluteTime *)(v3 + 48) = CFAbsoluteTimeGetCurrent();
          }
        }
      }
    }
    CFRelease(v2);
LABEL_16:
    free(a1);
  }
}

uint64_t FigLogRingBufferGetEntries(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294950825;
  }
  if (!a2) {
    return 0;
  }
  BOOL v4 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (v4)
  {
    *BOOL v4 = a1;
    v4[1] = a2;
    dispatch_sync_f(*(dispatch_queue_t *)(a1 + 24), v4, (dispatch_function_t)flr_FigLogRingBufferGetEntries);
    return 0;
  }
  return 4294950826;
}

void flr_FigLogRingBufferGetEntries(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (__CFArray *)a1[1];
    if (v2) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (!v4) {
      flr_FigLogRingBufferGetEntriesInternal(v2, v3);
    }
    free(a1);
  }
}

uint64_t FigLogRingBufferWriteLogsAsync(uint64_t a1)
{
  if (!a1 || !*(void *)(a1 + 24))
  {
    uint64_t v3 = 4294950821;
LABEL_8:
    syslog(3, "<<<< FigLogRingBuffer >>>> failed to write ring buffer to logs err %d", v3);
    return v3;
  }
  uint64_t v2 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (!v2)
  {
    uint64_t v3 = 4294950826;
    goto LABEL_8;
  }
  *uint64_t v2 = a1;
  v2[1] = 0;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 24), v2, (dispatch_function_t)flr_FigLogRingBufferWriteLogsDispatch);
  return 0;
}

void flr_FigLogRingBufferWriteLogsDispatch(uint64_t *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    goto LABEL_23;
  }
  uint64_t v2 = *a1;
  if (!*a1)
  {
    int v10 = -16471;
    goto LABEL_22;
  }
  uint64_t v3 = (CFURLRef *)a1[1];
  int LogFileName = flr_FigLogRingBufferMakeLogFileName("/tmp/mediaserverd_cached_log_", 0, 0, __filename);
  if (LogFileName)
  {
    int v10 = LogFileName;
    goto LABEL_22;
  }
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    int v10 = -16470;
    goto LABEL_22;
  }
  size_t v7 = Mutable;
  flr_FigLogRingBufferGetEntriesInternal(v2, Mutable);
  if (CFArrayGetCount(v7) <= 0)
  {
    CFRelease(v7);
    goto LABEL_23;
  }
  uint64_t v8 = fopen(__filename, "wb+");
  if (!v8)
  {
    size_t v9 = __error();
    syslog(3, "<<<< FigLogRingBuffer >>>> Error in opening file %s errno %d", __filename, *v9);
    CFRelease(v7);
    int v10 = -16477;
LABEL_22:
    syslog(3, "<<<< FigLogRingBuffer >>>> failed to copy ring buffer logs error %d", v10);
    goto LABEL_23;
  }
  uint64_t v11 = v8;
  int v13 = *(_DWORD *)(v2 + 56);
  int v12 = *(_DWORD *)(v2 + 60);
  BOOL v14 = __OFSUB__(v13, v12);
  int v15 = v13 - v12;
  if (v15 < 0 != v14) {
    int v16 = v15 + 10;
  }
  else {
    int v16 = v15;
  }
  int appended = flr_FigLogRingBufferAppendRotatingLogFiles(v16, v12, v11);
  if (appended)
  {
    int v10 = appended;
    goto LABEL_21;
  }
  int v18 = flr_FigLogRingBufferWriteBuffersToFile(v7, v11);
  if (v18)
  {
LABEL_15:
    int v10 = v18;
    if (!v3) {
      goto LABEL_21;
    }
    goto LABEL_18;
  }
  int v19 = *(_DWORD *)(v2 + 60);
  if (v19 <= 9)
  {
    int v18 = flr_FigLogRingBufferAppendRotatingLogFiles(*(_DWORD *)(v2 + 56), 10 - v19, v11);
    goto LABEL_15;
  }
  int v10 = 0;
  if (!v3) {
    goto LABEL_21;
  }
LABEL_18:
  CFStringRef v20 = CFStringCreateWithCString(v5, __filename, 0);
  if (v20)
  {
    CFStringRef v21 = v20;
    *uint64_t v3 = CFURLCreateWithFileSystemPath(v5, v20, kCFURLPOSIXPathStyle, 0);
    CFRelease(v21);
    if (!*v3) {
      int v10 = -16470;
    }
  }
  else
  {
    int v10 = -16470;
  }
LABEL_21:
  fclose(v11);
  CFRelease(v7);
  if (v10) {
    goto LABEL_22;
  }
LABEL_23:
  free(a1);
}

uint64_t FigLogRingBufferWriteAndCopyURLContainingLogs(uint64_t a1, uint64_t a2)
{
  if (!a1 || !*(void *)(a1 + 24))
  {
    uint64_t v5 = 4294950821;
LABEL_8:
    syslog(3, "<<<< FigLogRingBuffer >>>> failed to write ring buffer to logs err %d", v5);
    return v5;
  }
  BOOL v4 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (!v4)
  {
    uint64_t v5 = 4294950826;
    goto LABEL_8;
  }
  *BOOL v4 = a1;
  v4[1] = a2;
  dispatch_sync_f(*(dispatch_queue_t *)(a1 + 24), v4, (dispatch_function_t)flr_FigLogRingBufferWriteLogsDispatch);
  return 0;
}

void FigLogRingBufferRelease(dispatch_queue_t *context)
{
  if (context)
  {
    dispatch_sync_f(context[3], context, (dispatch_function_t)flr_FigLogRingBufferRelease);
    dispatch_release(context[3]);
    free(context);
  }
}

void flr_FigLogRingBufferRelease(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)a1;
    if (v2) {
      free(v2);
    }
    uint64_t v3 = *(void **)(a1 + 40);
    if (v3) {
      FigGzipDispose(v3);
    }
    uint64_t v4 = *(void *)(a1 + 32);
    FigRingBufferRelease(v4);
  }
}

CFIndex FigLogRingBufferGetCount(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(const __CFArray ***)(a1 + 32)) != 0) {
    return FigRingBufferGetCount(v1);
  }
  else {
    return 0;
  }
}

uint64_t FigLogRingBufferGetBufferSize(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t FigLogRingBufferGetCompressedLogSize(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 32)) != 0) {
    return FigRingBufferGetSize(v1);
  }
  else {
    return 0;
  }
}

uint64_t FigLogRingBufferSetWriteRotatingLogFiles(uint64_t a1, char a2)
{
  if (!a1) {
    return 4294950825;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 64) = a2;
  return result;
}

CFIndex flr_CustomDictGetSize(const __CFDictionary *a1)
{
  if (!a1) {
    return 0;
  }
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a1, @"buffer");
  if (!Value) {
    return 0;
  }

  return CFDataGetLength(Value);
}

uint64_t flr_FigLogRingBufferMakeLogFileName(const char *a1, int a2, int a3, char *a4)
{
  size_t v8 = strlen(a1);
  strlcpy(a4, a1, 0x400uLL);
  if (a2)
  {
    if (1024 - v8 < 4)
    {
      return 4294950818;
    }
    else if (snprintf(&a4[v8], 1024 - v8, "%d.log.gz", a3))
    {
      return 0;
    }
    else
    {
      return 4294950818;
    }
  }
  else
  {
    time_t v12 = 0;
    time(&v12);
    uint64_t v9 = 4294950818;
    if (1024 - v8 >= 0x19)
    {
      int v10 = localtime(&v12);
      if (strftime(&a4[v8], 1024 - v8, "%Y-%m-%d-%H%M%S.log.gz", v10)) {
        return 0;
      }
      else {
        return 4294950818;
      }
    }
  }
  return v9;
}

void flr_FigLogRingBufferCommitBuffer(uint64_t a1, uint64_t a2, __CFArray *a3, double a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef v10 = Mutable;
  if (a2 && a1 && Mutable)
  {
    if (!*(void *)(a2 + 8) || !*(void *)a2) {
      goto LABEL_68;
    }
    CFIndex length = 0;
    bytes = 0;
    if (flr_FigLogRingBufferGzipBufferIntoNewBuffer(a1, a2, &bytes))
    {
      CFDataRef v12 = 0;
    }
    else
    {
      CFDataRef v11 = CFDataCreate(v8, bytes, length);
      CFDataRef v12 = v11;
      if (v11)
      {
        CFRetain(v11);
        CFRelease(v12);
      }
    }
    if (bytes) {
      free(bytes);
    }
    if (*(void *)a2)
    {
      free(*(void **)a2);
      *(void *)a2 = 0;
    }
    FigGzipReset(*(void *)(a1 + 40));
    if (!v12)
    {
LABEL_68:
      CFTypeRef v38 = v10;
LABEL_62:
      CFRelease(v38);
      return;
    }
    double Current = CFAbsoluteTimeGetCurrent();
    FigCFDictionarySetDouble(v10, @"start", a4);
    FigCFDictionarySetDouble(v10, @"end", Current);
    CFDictionarySetValue(v10, @"buffer", v12);
    if (*(unsigned char *)(a1 + 64))
    {
      BOOL v14 = CFArrayCreateMutable(v8, 0, MEMORY[0x1E4F1D510]);
      if (!v14) {
        goto LABEL_60;
      }
    }
    else
    {
      BOOL v14 = 0;
    }
    if (FigRingBufferAppendValueAndEvictBuffer(*(void *)(a1 + 32), v10, v14)) {
      goto LABEL_60;
    }
    if (!v14 || CFArrayGetCount(v14) < 1) {
      goto LABEL_56;
    }
    if (flr_FigLogRingBufferMakeLogFileName("/private/var/mobile/Library/Logs/CrashReporter/mediaserverd_autolog_", 1, *(_DWORD *)(a1 + 56), __filename))
    {
LABEL_60:
      CFRelease(v10);
      CFRelease(v12);
      if (!v14) {
        return;
      }
      CFTypeRef v38 = v14;
      goto LABEL_62;
    }
    int v15 = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a1 + 56) = (*(_DWORD *)(a1 + 56) + 1) % 10;
    if (v15 <= 9) {
      *(_DWORD *)(a1 + 60) = v15 + 1;
    }
    if (CFArrayGetCount(v14) < 1) {
      goto LABEL_56;
    }
    int v16 = fopen(__filename, "wb+");
    if (!v16)
    {
      unsigned int v17 = __error();
      syslog(3, "<<<< FigLogRingBuffer >>>> Error in opening file %s, errno %d", __filename, *v17);
      syslog(3, "<<<< FigLogRingBuffer >>>> failed to write ring log buffer to file %s error %d", __filename, -16477);
LABEL_56:
      if (a3) {
        CFArrayAppendValue(a3, v10);
      }
      int v37 = malloc_type_calloc(1uLL, *(void *)(a1 + 16), 0xE9362F0FuLL);
      *(void *)a1 = v37;
      if (v37)
      {
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 48) = 0;
      }
      goto LABEL_60;
    }
    int v18 = v16;
    bytes = 0;
    if (CFArrayGetCount(v14) < 1)
    {
      int v39 = -16475;
    }
    else
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v14, 0);
      if (ValueAtIndex)
      {
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"start");
        if (Value)
        {
          CFNumberGetValue(Value, kCFNumberDoubleType, &bytes);
          CFDateRef v21 = CFDateCreate(v8, *(CFAbsoluteTime *)&bytes);
          if (v21)
          {
            CFDateRef v22 = v21;
            CFLocaleRef v23 = CFLocaleCopyCurrent();
            if (!v23)
            {
              CFRelease(v22);
              CFStringRef StringWithDate = 0;
              syslog(3, "<<<< FigLogRingBuffer >>>> failed to get the buffer start time %d", -16470);
              goto LABEL_37;
            }
            CFLocaleRef v24 = v23;
            int v25 = CFDateFormatterCreate(v8, v23, kCFDateFormatterFullStyle, kCFDateFormatterFullStyle);
            uint64_t v26 = v25;
            if (v25)
            {
              CFDateFormatterSetFormat(v25, @"yyyy-MM-dd HH:mm:ss.SS");
              CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(v8, v26, v22);
              CFRelease(v26);
              if (StringWithDate)
              {
                int v40 = 0;
                LOBYTE(v26) = 1;
                goto LABEL_35;
              }
              LOBYTE(v26) = 0;
            }
            else
            {
              CFStringRef StringWithDate = 0;
            }
            int v40 = -16470;
LABEL_35:
            CFRelease(v22);
            CFRelease(v24);
            if ((v26 & 1) == 0) {
              syslog(3, "<<<< FigLogRingBuffer >>>> failed to get the buffer start time %d", v40);
            }
LABEL_37:
            v41[0] = &bytes;
            if (StringWithDate) {
              CStringPtr = CFStringGetCStringPtr(StringWithDate, 0x8000100u);
            }
            else {
              CStringPtr = 0;
            }
            pid_t v29 = getpid();
            uint64_t v30 = "TimeNotAvailable";
            if (CStringPtr) {
              uint64_t v30 = CStringPtr;
            }
            unsigned int v31 = snprintf((char *)&bytes, 0x480uLL, "==== mediaserverd Rotating AutoLogFile %s PID %d start time: %s ====\n", __filename, v29, v30);
            if (v31)
            {
              if (v31 >= 0x480) {
                uint64_t v32 = 1152;
              }
              else {
                uint64_t v32 = v31;
              }
              v41[1] = v32;
              int v42 = 0;
              size_t v43 = 0;
              int v33 = flr_FigLogRingBufferGzipBufferIntoNewBuffer(a1, (uint64_t)v41, (Bytef **)&v42);
              if (v33)
              {
                int v35 = v33;
              }
              else
              {
                if (fwrite(v42, v43, 1uLL, v18) == 1)
                {
                  free(v42);
LABEL_52:
                  int v36 = flr_FigLogRingBufferWriteBuffersToFile(v14, v18);
                  if (v36) {
                    syslog(3, "<<<< FigLogRingBuffer >>>> failed to write ring log buffer to file %s error %d", __filename, v36);
                  }
                  fclose(v18);
                  if (StringWithDate) {
                    CFRelease(StringWithDate);
                  }
                  goto LABEL_56;
                }
                uint64_t v34 = __error();
                syslog(3, "<<<< FigLogRingBuffer >>>> Failed to write the auto log file header, errno %d", *v34);
                int v35 = -16477;
              }
              free(v42);
            }
            else
            {
              int v35 = -16478;
            }
            syslog(3, "<<<< FigLogRingBuffer >>>> failed to write the auto log file header for %s (%d)", __filename, v35);
            goto LABEL_52;
          }
          int v39 = -16470;
        }
        else
        {
          int v39 = -16471;
        }
      }
      else
      {
        int v39 = -16474;
      }
    }
    CFStringRef StringWithDate = 0;
    syslog(3, "<<<< FigLogRingBuffer >>>> failed to get the buffer start time %d", v39);
    goto LABEL_37;
  }
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

uint64_t flr_FigLogRingBufferGzipBufferIntoNewBuffer(uint64_t a1, uint64_t a2, Bytef **a3)
{
  uint64_t v15 = 0;
  BOOL v14 = 0;
  uint64_t v3 = 4294950821;
  int v13 = 0;
  if (a1 && a2 && a3)
  {
    size_t v6 = *(void *)(a2 + 8);
    if (v6)
    {
      BOOL v12 = 0;
      CFAllocatorRef v8 = (Bytef *)malloc_type_calloc(1uLL, v6, 0x524446E4uLL);
      if (v8)
      {
        uint64_t v9 = *(void *)(a2 + 8);
        *a3 = v8;
        a3[1] = 0;
        uint64_t v10 = FigGzipCompressMemory(*(z_streamp *)(a1 + 40), *(Bytef **)a2, *(void *)(a2 + 8), &v15, &v14, v8, v9, &v13, &v12, 1);
        uint64_t v3 = v10;
        if (v10) {
          syslog(3, "<<<< FigLogRingBuffer >>>> error in compressing ring log buffer %d", v10);
        }
        else {
          a3[1] = v13;
        }
      }
      else
      {
        uint64_t v3 = 4294950826;
      }
      FigGzipReset(*(void *)(a1 + 40));
    }
    else
    {
      return 4294950821;
    }
  }
  return v3;
}

uint64_t flr_FigLogRingBufferWriteBuffersToFile(const __CFArray *a1, FILE *a2)
{
  if (!a1) {
    return 4294950822;
  }
  if (a2)
  {
    if (CFArrayGetCount(a1) < 1) {
      return 0;
    }
    CFIndex v4 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v4);
      if (ValueAtIndex)
      {
        CFDataRef Value = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, @"buffer");
        if (Value)
        {
          CFDataRef v7 = Value;
          BytePtr = CFDataGetBytePtr(Value);
          size_t Length = CFDataGetLength(v7);
          if (fwrite(BytePtr, Length, 1uLL, a2) != 1) {
            break;
          }
        }
      }
      if (++v4 >= CFArrayGetCount(a1)) {
        return 0;
      }
    }
    CFDataRef v11 = __error();
    syslog(3, "<<<< FigLogRingBuffer >>>> Failed to flush the fig log ring buffer logs, errno %d", *v11);
  }
  return 4294950819;
}

void flr_FigLogRingBufferGetEntriesInternal(uint64_t a1, __CFArray *a2)
{
  FigRingBufferGetEntries(*(void *)(a1 + 32), a2);
  if (*(void *)(a1 + 8))
  {
    long long v4 = *(_OWORD *)a1;
    flr_FigLogRingBufferCommitBuffer(a1, (uint64_t)&v4, a2, *(double *)(a1 + 48));
  }
}

uint64_t flr_FigLogRingBufferAppendRotatingLogFiles(int a1, int a2, FILE *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1 >= 0) {
    int v3 = a1;
  }
  else {
    int v3 = a1 + 10;
  }
  if (!a3)
  {
    syslog(3, "<<<< FigLogRingBuffer >>>> null target file cannot copy");
    return 4294950819;
  }
  if (v3 < 0)
  {
    syslog(3, "<<<< FigLogRingBuffer >>>> cannot determine the ring log file counter to use %d");
    return 4294950819;
  }
  int v4 = a2;
  if (a2 < 1) {
    return 0;
  }
  while (1)
  {
    uint64_t LogFileName = flr_FigLogRingBufferMakeLogFileName("/private/var/mobile/Library/Logs/CrashReporter/mediaserverd_autolog_", 1, v3, __filename);
    if (LogFileName)
    {
      uint64_t v11 = LogFileName;
      syslog(3, "<<<< FigLogRingBuffer >>>> failed (%d) to make the ring log file name for %d");
      return v11;
    }
    CFDataRef v7 = fopen(__filename, "rb");
    if (v7)
    {
      CFAllocatorRef v8 = v7;
      uint64_t v9 = malloc_type_calloc(1uLL, 0x4000uLL, 0x8DE28586uLL);
      if (v9)
      {
        while (1)
        {
          if (feof(v8))
          {
            uint64_t v11 = 0;
            char v12 = 1;
            goto LABEL_15;
          }
          size_t v10 = fread(v9, 1uLL, 0x4000uLL, v8);
          if (!v10) {
            break;
          }
          if (fwrite(v9, 1uLL, v10, a3) != v10)
          {
            syslog(3, "<<<< FigLogRingBuffer >>>> failed to write all the data %ld (read %ld)");
            goto LABEL_20;
          }
        }
        syslog(3, "<<<< FigLogRingBuffer >>>> failed to read bytes from source log file");
LABEL_20:
        char v12 = 0;
        uint64_t v11 = 4294950819;
      }
      else
      {
        char v12 = 0;
        uint64_t v11 = 4294950826;
      }
LABEL_15:
      free(v9);
      fclose(v8);
      if ((v12 & 1) == 0) {
        break;
      }
    }
    int v3 = (v3 + 1) % 10;
    BOOL v13 = __OFSUB__(v4--, 1);
    if ((v4 < 0) ^ v13 | (v4 == 0)) {
      return 0;
    }
  }
  syslog(3, "<<<< FigLogRingBuffer >>>> failed to append the ring log file %s");
  return v11;
}

uint64_t CMTagCollectionAssistantGetTypeID()
{
  if (CMTagCollectionAssistantGetTypeID_sRegisterTagCollectionAssistantTypeOnce != -1) {
    dispatch_once_f(&CMTagCollectionAssistantGetTypeID_sRegisterTagCollectionAssistantTypeOnce, 0, (dispatch_function_t)tagCollectionAssistant_registerTagCollectionAssistantType);
  }
  return sTagCollectionAssistantTypeID;
}

uint64_t tagCollectionAssistant_registerTagCollectionAssistantType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sTagCollectionAssistantCFTypeID TypeID = result;
  return result;
}

uint64_t CMTagCollectionAssistantCreateWithPreset(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  uint64_t result = 4294951345;
  if (a2 <= 1 && a3)
  {
    if (CMTagCollectionAssistantGetTypeID_sRegisterTagCollectionAssistantTypeOnce != -1) {
      dispatch_once_f(&CMTagCollectionAssistantGetTypeID_sRegisterTagCollectionAssistantTypeOnce, 0, (dispatch_function_t)tagCollectionAssistant_registerTagCollectionAssistantType);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v7 = Instance;
      uint64_t result = 0;
      *(_DWORD *)(v7 + 16) = a2;
      *(_OWORD *)(v7 + 24) = xmmword_18FE965F0;
      *a3 = v7;
    }
    else
    {
      return 4294951346;
    }
  }
  return result;
}

uint64_t CMTagCollectionAssistantCopyTagCollection(uint64_t a1, CFAllocatorRef allocator, CMTagCollectionRef *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 4294951345;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  if (v3 > 1) {
    return 4294951345;
  }
  CMTagCollectionRef newCollectionOut = 0;
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 32);
  int32x2_t v7 = vdup_n_s32(v3 == 1);
  v8.i64[0] = v7.u32[0];
  v8.i64[1] = v7.u32[1];
  CMTag tags = kCMTagMediaTypeVideo;
  int8x16_t v14 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v8, 0x3FuLL)), (int8x16_t)kCMTagStereoLeftAndRightEye, (int8x16_t)kCMTagStereoNone);
  uint64_t v15 = 0x57061636BLL;
  uint64_t v16 = v5;
  uint64_t v17 = 0x570726F6ALL;
  uint64_t v18 = v6;
  OSStatus v9 = CMTagCollectionCreate(allocator, &tags, 4, &newCollectionOut);
  CMTagCollectionRef v10 = newCollectionOut;
  if (v9)
  {
    if (newCollectionOut)
    {
      CFRelease(newCollectionOut);
      CMTagCollectionRef v10 = 0;
    }
  }
  uint64_t result = 0;
  *a3 = v10;
  return result;
}

uint64_t CMTagCollectionAssistantGetPreset(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t CMTagCollectionAssistantSetPreset(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t CMTagCollectionAssistantGetPackingType(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t CMTagCollectionAssistantSetPackingType(uint64_t result, uint64_t a2)
{
  *(void *)(result + 24) = a2;
  return result;
}

uint64_t CMTagCollectionAssistantGetProjectionType(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t CMTagCollectionAssistantSetProjectionType(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = a2;
  return result;
}

void *tagCollectionAssistant_init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

BOOL tagCollectionAssistant_equal(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16)
      && *(void *)(a1 + 24) == *(void *)(a2 + 24)
      && *(void *)(a1 + 32) == *(void *)(a2 + 32);
}

CFStringRef tagCollectionAssistant_copyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFIndex v3 = CFGetRetainCount((CFTypeRef)a1);
  return CFStringCreateWithFormat(v2, 0, @"<CMTagCollectionAssistant %p retainCount: %ld> preset: %u, packingType: %llu, projectionType: %llu", a1, v3, *(unsigned int *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32));
}

OSStatus CMSwapBigEndianMetadataDescriptionToHost(uint8_t *metadataDescriptionData, size_t metadataDescriptionSize)
{
  return 0;
}

OSStatus CMSwapHostEndianMetadataDescriptionToBig(uint8_t *metadataDescriptionData, size_t metadataDescriptionSize)
{
  return 0;
}

uint64_t FigMetadataUnboxMEBXKeyTableBox(const __CFAllocator *a1, uint64_t a2, CFMutableDictionaryRef *a3)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  memset(v58, 0, sizeof(v58));
  unsigned int v57 = 0;
  uint64_t v56 = 0;
  uint64_t v5 = FigAtomStreamInitWithParent(a2, 0, (uint64_t)v58);
  if (v5 == -12893)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t CurrentAtomVersionAndFlags = 0;
    goto LABEL_3;
  }
  uint64_t CurrentAtomVersionAndFlags = v5;
  if (!v5)
  {
    int v49 = a3;
    CFMutableDictionaryRef Mutable = 0;
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    int64x2_t v8 = @"MetadataKeyDataTypeNameSpace";
    OSStatus v9 = @"MetadataKeyDataType";
    char v53 = (const void *)*MEMORY[0x1E4F1CFC8];
    char v54 = (const void *)*MEMORY[0x1E4F1CFD0];
    while (1)
    {
      CurrentAtomTypeAndDatasize_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v58, &v57, &v56);
      if (CurrentAtomTypeAndDataLength)
      {
        uint64_t CurrentAtomVersionAndFlags = CurrentAtomTypeAndDataLength;
LABEL_174:
        if (Mutable) {
          CFRelease(Mutable);
        }
        return CurrentAtomVersionAndFlags;
      }
      if (v57) {
        BOOL v11 = v57 == 1970628964;
      }
      else {
        BOOL v11 = 1;
      }
      if (v11) {
        goto LABEL_12;
      }
      int v52 = v9;
      unsigned int valuePtr = v57;
      int v63 = 0;
      uint64_t v62 = 0;
      memset(v61, 0, sizeof(v61));
      long long value = 0uLL;
      long long v59 = 0uLL;
      uint64_t v13 = FigAtomStreamInitWithParent((uint64_t)v58, 0, (uint64_t)v61);
      int v51 = v8;
      if (v13)
      {
        uint64_t CurrentAtomVersionAndFlags = v13;
        int v44 = Mutable;
        CFStringRef v14 = 0;
        uint64_t v15 = 0;
        CFTypeRef v55 = 0;
LABEL_160:
        uint64_t v16 = 0;
        goto LABEL_131;
      }
      CFStringRef v14 = 0;
      uint64_t v15 = 0;
      CFTypeRef v55 = 0;
      uint64_t v16 = 0;
      while (1)
      {
        uint64_t v17 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v61, &v63, &v62);
        if (v17)
        {
LABEL_125:
          uint64_t CurrentAtomVersionAndFlags = v17;
          goto LABEL_126;
        }
        if (v63 <= 1819239264)
        {
          if (v63 == 1668575347)
          {
            if (!v16)
            {
              int v75 = 0;
              uint64_t v74 = 0;
              long long v72 = 0u;
              long long v73 = 0u;
              long long v70 = 0u;
              long long v71 = 0u;
              long long v68 = 0u;
              long long v69 = 0u;
              long long v67 = 0u;
              CFTypeRef v65 = 0;
              CFTypeRef cf = 0;
              uint64_t v27 = FigAtomStreamInitWithParent((uint64_t)v61, 0, (uint64_t)&v67);
              if (v27)
              {
                uint64_t CurrentAtomVersionAndFlags = v27;
                int v44 = Mutable;
                goto LABEL_160;
              }
              id v28 = 0;
              do
              {
                uint64_t v29 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v67, &v75, &v74);
                if (v29)
                {
                  uint64_t CurrentAtomVersionAndFlags = v29;
                  goto LABEL_90;
                }
                if (v75 == 1685354864)
                {
                  uint64_t CurrentAtomVersionAndFlags = copyKeyOrDataTypeAtom(a1, (uint64_t)&v67, (CFNumberRef *)&cf, (CFDataRef *)&v65);
                  CFTypeRef v30 = cf;
                  if (CurrentAtomVersionAndFlags)
                  {
                    if (cf) {
                      CFRelease(cf);
                    }
                    goto LABEL_90;
                  }
                  if (cf && v65)
                  {
                    keys[0] = v8;
                    keys[1] = v52;
                    values[0] = (void *)cf;
                    values[1] = (void *)v65;
                    CFDictionaryRef v31 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                    if (!v28) {
                      id v28 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
                    }
                    CFArrayAppendValue(v28, v31);
                    CFRelease(v31);
                    CFTypeRef v30 = cf;
                  }
                  if (v30)
                  {
                    CFRelease(v30);
                    CFTypeRef cf = 0;
                  }
                  if (v65)
                  {
                    CFRelease(v65);
                    CFTypeRef v65 = 0;
                  }
                }
                uint64_t v32 = FigAtomStreamAdvanceToNextAtom(&v67);
              }
              while (!v32);
              uint64_t CurrentAtomVersionAndFlags = v32;
              if (v32 == -12890)
              {
                uint64_t CurrentAtomVersionAndFlags = 0;
                uint64_t v16 = v28;
                id v28 = 0;
                goto LABEL_91;
              }
LABEL_90:
              uint64_t v16 = 0;
LABEL_91:
              if (v65) {
                CFRelease(v65);
              }
              if (v28) {
                CFRelease(v28);
              }
              if (CurrentAtomVersionAndFlags) {
                goto LABEL_126;
              }
            }
          }
          else if (v63 == 1685354864)
          {
            if (v59 == 0)
            {
              uint64_t v18 = (CFNumberRef *)&v59 + 1;
              p_long long value = (CFDataRef *)&v59;
LABEL_55:
              uint64_t v17 = copyKeyOrDataTypeAtom(a1, (uint64_t)v61, v18, p_value);
              if (v17) {
                goto LABEL_125;
              }
              goto LABEL_99;
            }
          }
          else if (v63 == 1801812324 && value == 0)
          {
            uint64_t v18 = (CFNumberRef *)&value + 1;
            p_long long value = (CFDataRef *)&value;
            goto LABEL_55;
          }
          goto LABEL_99;
        }
        if (v63 == 1819239265)
        {
          if (!v14)
          {
            *(void *)&long long v67 = 0;
            uint64_t CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v61, 0, &v67);
            int v33 = 0;
            if (CurrentAtomVersionAndFlags || !(void)v67) {
              goto LABEL_98;
            }
            int v33 = (char *)malloc_type_malloc(v67, 0xA8D583B0uLL);
            if (!v33) {
              goto LABEL_97;
            }
            uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData((uint64_t)v61, 0, v67, (uint64_t)v33);
            if (CurrentAtomData)
            {
              uint64_t CurrentAtomVersionAndFlags = CurrentAtomData;
              int v44 = Mutable;
              free(v33);
              CFStringRef v14 = 0;
              goto LABEL_131;
            }
            if (v33[(void)v67 - 1] || (CFStringRef v35 = CFStringCreateWithCString(a1, v33, 0x600u)) == 0)
            {
LABEL_97:
              uint64_t CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_98:
              free(v33);
              CFStringRef v14 = 0;
              if (CurrentAtomVersionAndFlags)
              {
                int v44 = Mutable;
                CFMutableDictionaryRef Mutable = 0;
                CFStringRef v46 = 0;
                int v45 = 0;
                goto LABEL_133;
              }
              goto LABEL_99;
            }
            CFStringRef v14 = v35;
            free(v33);
          }
          goto LABEL_99;
        }
        if (v63 != 1935962212)
        {
          if (v63 == 1936028789 && !v55)
          {
            CFStringRef v20 = v14;
            CFDateRef v21 = v16;
            *(void *)&long long v67 = 0;
            uint64_t CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v61, 0, &v67);
            CFTypeRef v22 = 0;
            if (!CurrentAtomVersionAndFlags && (void)v67)
            {
              CFLocaleRef v23 = CFDataCreateMutable(allocator, v67);
              if (v23)
              {
                CFLocaleRef v24 = v23;
                CFDataSetLength(v23, v67);
                uint64_t v25 = v67;
                MutableBytePtr = CFDataGetMutableBytePtr(v24);
                uint64_t CurrentAtomVersionAndFlags = FigAtomStreamReadCurrentAtomData((uint64_t)v61, 0, v25, (uint64_t)MutableBytePtr);
                if (CurrentAtomVersionAndFlags) {
                  CFTypeRef v22 = 0;
                }
                else {
                  CFTypeRef v22 = CFRetain(v24);
                }
                CFRelease(v24);
              }
              else
              {
                uint64_t CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                CFTypeRef v22 = 0;
              }
            }
            CFTypeRef v55 = v22;
            if (CurrentAtomVersionAndFlags)
            {
              int v44 = Mutable;
              CFMutableDictionaryRef Mutable = 0;
              CFStringRef v46 = 0;
              int v45 = 0;
              uint64_t v16 = v21;
              CFStringRef v14 = v20;
              goto LABEL_133;
            }
            uint64_t v16 = v21;
            CFStringRef v14 = v20;
          }
          goto LABEL_99;
        }
        if (!v15) {
          break;
        }
LABEL_99:
        uint64_t Atom = FigAtomStreamAdvanceToNextAtom(v61);
        if (Atom)
        {
          uint64_t CurrentAtomVersionAndFlags = Atom;
          if (Atom == -12890)
          {
            if (!Mutable)
            {
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              if (!Mutable)
              {
                uint64_t CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                int v44 = 0;
                goto LABEL_132;
              }
            }
            size_t v43 = (const void *)*((void *)&value + 1);
            if (!*((void *)&value + 1))
            {
              int v44 = Mutable;
              uint64_t CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
              goto LABEL_131;
            }
            int v44 = Mutable;
            int v45 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (v45)
            {
              CFMutableDictionaryRef Mutable = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
              if (Mutable)
              {
                CFStringRef v46 = CFStringCreateWithFormat(a1, 0, @"%d", valuePtr);
                if (v46)
                {
                  CFDictionaryAddValue(v45, @"MetadataKeyNamespace", v43);
                  if ((void)value) {
                    CFDictionaryAddValue(v45, @"MetadataKeyValue", (const void *)value);
                  }
                  CFDictionaryAddValue(v45, @"MetadataKeyLocalID", Mutable);
                  if (*((void *)&v59 + 1))
                  {
                    uint64_t v47 = (const void *)v59;
                    if ((void)v59)
                    {
                      CFDictionaryAddValue(v45, v51, *((const void **)&v59 + 1));
                      CFDictionaryAddValue(v45, v52, v47);
                    }
                  }
                  if (v14) {
                    CFDictionaryAddValue(v45, @"MetadataKeyLanguageTag", v14);
                  }
                  if (v15) {
                    CFDictionaryAddValue(v45, @"MetadataKeyStructuralDependency", v15);
                  }
                  if (v55) {
                    CFDictionaryAddValue(v45, @"MetadataKeySetupData", v55);
                  }
                  if (v16) {
                    CFDictionaryAddValue(v45, @"MetadataKeyConformingDataTypes", v16);
                  }
                  CFDictionaryAddValue(v44, v46, v45);
                  uint64_t CurrentAtomVersionAndFlags = 0;
                }
                else
                {
                  uint64_t CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                }
                goto LABEL_133;
              }
              uint64_t CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            }
            else
            {
              uint64_t CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              CFMutableDictionaryRef Mutable = 0;
            }
            CFStringRef v46 = 0;
            goto LABEL_133;
          }
LABEL_126:
          int v44 = Mutable;
          goto LABEL_131;
        }
      }
      LODWORD(v74) = 0;
      keys[0] = 0;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      long long v67 = 0u;
      uint64_t v36 = FigAtomStreamInitWithParent((uint64_t)v61, 0, (uint64_t)&v67);
      if (v36)
      {
        uint64_t CurrentAtomVersionAndFlags = v36;
        goto LABEL_130;
      }
      uint64_t v15 = 0;
      while (2)
      {
        uint64_t v37 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v67, &v74, keys);
        if (v37)
        {
          uint64_t CurrentAtomVersionAndFlags = v37;
          goto LABEL_128;
        }
        if (v74 == 1935962217 && v15 == 0)
        {
          LOBYTE(cf) = 0;
          LODWORD(values[0]) = 0;
          uint64_t CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomVersionAndFlags((uint64_t)&v67, &cf, (unsigned int *)values);
          if (!CurrentAtomVersionAndFlags && !(_BYTE)cf)
          {
            int v39 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (v39)
            {
              uint64_t v15 = v39;
              if ((uint64_t)values[0]) {
                int v40 = v54;
              }
              else {
                int v40 = v53;
              }
              CFDictionaryAddValue(v39, @"StructuralDependencyIsInvalidFlag", v40);
              goto LABEL_84;
            }
            uint64_t CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          }
          if (CurrentAtomVersionAndFlags) {
            goto LABEL_130;
          }
          uint64_t v15 = 0;
        }
LABEL_84:
        uint64_t v41 = FigAtomStreamAdvanceToNextAtom(&v67);
        if (!v41) {
          continue;
        }
        break;
      }
      uint64_t CurrentAtomVersionAndFlags = v41;
      if (v41 == -12890) {
        goto LABEL_99;
      }
LABEL_128:
      if (v15) {
        CFRelease(v15);
      }
LABEL_130:
      int v44 = Mutable;
      uint64_t v15 = 0;
LABEL_131:
      CFMutableDictionaryRef Mutable = 0;
LABEL_132:
      CFStringRef v46 = 0;
      int v45 = 0;
LABEL_133:
      if (*((void *)&value + 1)) {
        CFRelease(*((CFTypeRef *)&value + 1));
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (v46) {
        CFRelease(v46);
      }
      CFMutableDictionaryRef Mutable = v44;
      if ((void)value) {
        CFRelease((CFTypeRef)value);
      }
      int64x2_t v8 = v51;
      if (v45) {
        CFRelease(v45);
      }
      if (*((void *)&v59 + 1)) {
        CFRelease(*((CFTypeRef *)&v59 + 1));
      }
      if ((void)v59) {
        CFRelease((CFTypeRef)v59);
      }
      if (v14) {
        CFRelease(v14);
      }
      if (v15) {
        CFRelease(v15);
      }
      if (v55) {
        CFRelease(v55);
      }
      if (v16) {
        CFRelease(v16);
      }
      OSStatus v9 = v52;
      if (CurrentAtomVersionAndFlags) {
        goto LABEL_174;
      }
LABEL_12:
      unsigned int v12 = FigAtomStreamAdvanceToNextAtom(v58);
      if (v12)
      {
        if (v12 == -12890) {
          uint64_t CurrentAtomVersionAndFlags = 0;
        }
        else {
          uint64_t CurrentAtomVersionAndFlags = v12;
        }
        a3 = v49;
LABEL_3:
        *a3 = Mutable;
        return CurrentAtomVersionAndFlags;
      }
    }
  }
  return CurrentAtomVersionAndFlags;
}

uint64_t FigMetadataUnboxMEBXPrimaryLocalIDsBox(const __CFAllocator *a1, uint64_t a2, __CFArray **a3)
{
  uint64_t v16 = 0;
  unsigned int valuePtr = 0;
  CurrentAtomTypeAndDatasize_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength(a2, 0, &v16);
  if (CurrentAtomTypeAndDataLength) {
    return CurrentAtomTypeAndDataLength;
  }
  if ((v16 & 3) != 0)
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  else if (v16 < 1)
  {
    CFMutableDictionaryRef Mutable = 0;
LABEL_11:
    uint64_t v13 = 0;
    *a3 = Mutable;
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v8 = 0;
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CMTagCollectionRef v10 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    while (1)
    {
      uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData(a2, v8, 4, (uint64_t)&valuePtr);
      if (CurrentAtomData) {
        break;
      }
      unsigned int valuePtr = bswap32(valuePtr);
      CFNumberRef v12 = CFNumberCreate(v9, kCFNumberSInt32Type, &valuePtr);
      if (!Mutable) {
        CFMutableDictionaryRef Mutable = CFArrayCreateMutable(a1, (unint64_t)v16 >> 2, v10);
      }
      CFArrayAppendValue(Mutable, v12);
      CFRelease(v12);
      v8 += 4;
      if (v8 >= v16) {
        goto LABEL_11;
      }
    }
    uint64_t v13 = CurrentAtomData;
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  return v13;
}

uint64_t FigMetadataUnboxMEBXLocalIDDependencyListBoxes(const __CFAllocator *a1, uint64_t a2, __CFDictionary **a3)
{
  memset(v24, 0, sizeof(v24));
  uint64_t valuePtr = 0;
  uint64_t v23 = 0;
  uint64_t v5 = FigAtomStreamInitWithParent(a2, 0, (uint64_t)v24);
  if (v5) {
    return v5;
  }
  CFDateRef v21 = a3;
  uint64_t v6 = 0;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v8 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFAllocatorRef v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CMTagCollectionRef v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  do
  {
    CurrentAtomTypeAndDatasize_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v24, (_DWORD *)&valuePtr + 1, &v23);
    if (CurrentAtomTypeAndDataLength)
    {
      uint64_t v19 = CurrentAtomTypeAndDataLength;
      goto LABEL_21;
    }
    if ((v23 & 3) != 0 || (int v12 = HIDWORD(valuePtr), HIDWORD(valuePtr) = bswap32(HIDWORD(valuePtr)), !v12))
    {
      FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      uint64_t v19 = 0;
      goto LABEL_21;
    }
    if (v23 >= 1)
    {
      CFMutableDictionaryRef Mutable = 0;
      uint64_t v14 = 0;
      while (1)
      {
        uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData((uint64_t)v24, v14, 4, (uint64_t)&valuePtr);
        if (CurrentAtomData) {
          break;
        }
        LODWORD(valuePtr) = bswap32(valuePtr);
        CFNumberRef v16 = CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
        if (!Mutable) {
          CFMutableDictionaryRef Mutable = CFArrayCreateMutable(a1, (unint64_t)v23 >> 2, v8);
        }
        CFArrayAppendValue(Mutable, v16);
        CFRelease(v16);
        v14 += 4;
        if (v14 >= v23)
        {
          if (Mutable)
          {
            if (!v6) {
              uint64_t v6 = CFDictionaryCreateMutable(a1, 0, v9, v10);
            }
            CFStringRef v17 = CFStringCreateWithFormat(a1, 0, @"%d", HIDWORD(valuePtr));
            CFDictionarySetValue(v6, v17, Mutable);
            CFRelease(Mutable);
            CFRelease(v17);
          }
          goto LABEL_16;
        }
      }
      uint64_t v19 = CurrentAtomData;
      if (Mutable) {
        CFRelease(Mutable);
      }
      goto LABEL_21;
    }
LABEL_16:
    uint64_t Atom = FigAtomStreamAdvanceToNextAtom(v24);
  }
  while (!Atom);
  uint64_t v19 = Atom;
  if (Atom == -12890)
  {
    uint64_t v19 = 0;
    *CFDateRef v21 = v6;
    return v19;
  }
LABEL_21:
  if (v6) {
    CFRelease(v6);
  }
  return v19;
}

OSStatus CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionData(CFAllocatorRef allocator, const uint8_t *metadataDescriptionData, size_t size, CMMetadataDescriptionFlavor flavor, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  CMBlockBufferRef metadataDescriptionBlockBuffer = 0;
  if (!metadataDescriptionData || !formatDescriptionOut)
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  OSStatus v7 = CMBlockBufferCreateWithMemoryBlock(allocator, (void *)metadataDescriptionData, size, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0], 0, 0, size, 1u, &metadataDescriptionBlockBuffer);
  CMBlockBufferRef v9 = metadataDescriptionBlockBuffer;
  if (v7)
  {
    OSStatus v10 = v7;
    if (!metadataDescriptionBlockBuffer) {
      return v10;
    }
    goto LABEL_5;
  }
  OSStatus v10 = CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionBlockBuffer(allocator, metadataDescriptionBlockBuffer, v8, formatDescriptionOut);
  CMBlockBufferRef v9 = metadataDescriptionBlockBuffer;
  if (metadataDescriptionBlockBuffer) {
LABEL_5:
  }
    CFRelease(v9);
  return v10;
}

OSStatus CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef metadataDescriptionBlockBuffer, CMMetadataDescriptionFlavor flavor, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  keys[3] = *(void **)MEMORY[0x1E4F143B8];
  if (!metadataDescriptionBlockBuffer || !formatDescriptionOut)
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  unsigned int destination = 0;
  OSStatus v7 = CMBlockBufferCopyDataBytes(metadataDescriptionBlockBuffer, 4uLL, 4uLL, &destination);
  if (v7) {
    return v7;
  }
  unsigned int v8 = destination;
  unsigned int destination = bswap32(destination);
  CFTypeRef cf = 0;
  CFDictionaryRef theDict = 0;
  CFTypeRef v20 = 0;
  if (CMBlockBufferGetDataLength(metadataDescriptionBlockBuffer) > 0xF)
  {
    memset(v25, 0, sizeof(v25));
    int v24 = 0;
    uint64_t v23 = 0;
    if (v8 == 2019714413)
    {
      OSStatus v11 = FigAtomStreamInitWithBBuf(metadataDescriptionBlockBuffer, 0x10uLL, 0, (uint64_t)v25);
      if (!v11)
      {
        do
        {
          CurrentAtomTypeAndDatasize_t Length = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v25, &v24, &v23);
          if (CurrentAtomTypeAndDataLength)
          {
LABEL_36:
            OSStatus v9 = CurrentAtomTypeAndDataLength;
            goto LABEL_37;
          }
          if (v24 == 1818846320)
          {
            if (!cf)
            {
              CurrentAtomTypeAndDatasize_t Length = FigMetadataUnboxMEBXPrimaryLocalIDsBox(allocator, (uint64_t)v25, (__CFArray **)&cf);
              if (CurrentAtomTypeAndDataLength) {
                goto LABEL_36;
              }
            }
          }
          else if (v24 == 1818846316)
          {
            if (!v20)
            {
              CurrentAtomTypeAndDatasize_t Length = FigMetadataUnboxMEBXLocalIDDependencyListBoxes(allocator, (uint64_t)v25, (__CFDictionary **)&v20);
              if (CurrentAtomTypeAndDataLength) {
                goto LABEL_36;
              }
            }
          }
          else if (v24 == 1801812339 && !theDict)
          {
            CurrentAtomTypeAndDatasize_t Length = FigMetadataUnboxMEBXKeyTableBox(allocator, (uint64_t)v25, &theDict);
            if (CurrentAtomTypeAndDataLength) {
              goto LABEL_36;
            }
          }
          OSStatus Atom = FigAtomStreamAdvanceToNextAtom(v25);
        }
        while (!Atom);
        OSStatus v9 = Atom;
        if (Atom == -12890)
        {
          CFDictionaryRef v14 = theDict;
          if (!theDict)
          {
            CFDictionaryRef v10 = 0;
            OSStatus v9 = 0;
            goto LABEL_39;
          }
          if (CFDictionaryGetCount(theDict) < 1)
          {
            CFDictionaryRef v17 = 0;
          }
          else
          {
            keys[1] = @"MetadataPrimaryLocalIDs";
            keys[2] = @"MetadataLocalIDDependencyLists";
            values[0] = v14;
            values[1] = (void *)cf;
            values[2] = (void *)v20;
            keys[0] = @"MetadataKeyTable";
            if (v20) {
              BOOL v15 = cf == 0;
            }
            else {
              BOOL v15 = 1;
            }
            if (v15) {
              CFIndex v16 = 1;
            }
            else {
              CFIndex v16 = 3;
            }
            CFDictionaryRef v17 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, v16, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          }
          OSStatus v9 = 0;
          goto LABEL_38;
        }
LABEL_37:
        CFDictionaryRef v17 = 0;
        CFDictionaryRef v10 = 0;
        CFDictionaryRef v14 = theDict;
        if (!theDict) {
          goto LABEL_39;
        }
LABEL_38:
        CFRelease(v14);
        CFDictionaryRef v10 = v17;
        goto LABEL_39;
      }
    }
    else
    {
      OSStatus v11 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    }
    OSStatus v9 = v11;
    CFDictionaryRef v10 = 0;
LABEL_39:
    if (cf) {
      CFRelease(cf);
    }
    if (v20) {
      CFRelease(v20);
    }
    goto LABEL_43;
  }
  OSStatus v9 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  CFDictionaryRef v10 = 0;
LABEL_43:
  if (!v9) {
    OSStatus v9 = FigMetadataFormatDescriptionCreateWithExtensions(allocator, destination, v10, (uint64_t *)formatDescriptionOut);
  }
  if (v10) {
    CFRelease(v10);
  }
  return v9;
}

uint64_t FigMetadataAppendMEBXKeyTableBox(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  uint64_t result = FigAtomWriterInitWithParent(a1, (uint64_t)v6);
  if (!result)
  {
    uint64_t result = FigAtomWriterBeginAtom((uint64_t)v6, 0x6B657973u, 0);
    if (!result)
    {
      uint64_t result = FigAtomWriterInitWithParent((uint64_t)v6, (uint64_t)v4);
      if (!result)
      {
        CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)KeyEmitterApplierFunction, v4);
        return FigAtomWriterEndAtom((uint64_t)v6);
      }
    }
  }
  return result;
}

void KeyEmitterApplierFunction(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  unsigned int LocalIDUInt32 = FigMetadataKeyGetLocalIDUInt32(a2);
  if (!LocalIDUInt32)
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    return;
  }
  if (FigAtomWriterBeginAtom(a3, LocalIDUInt32, 0)) {
    return;
  }
  CFDataRef Value = CFDictionaryGetValue(a2, @"MetadataKeyNamespace");
  CFTypeID v7 = CFGetTypeID(Value);
  if (v7 == CFNumberGetTypeID())
  {
    uint64_t v52 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    LODWORD(valuePtr[0]) = 0;
    CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, valuePtr);
    LODWORD(valuePtr[0]) = bswap32(valuePtr[0]);
    CFStringRef v8 = (const __CFString *)CFDictionaryGetValue(a2, @"MetadataKeyValue");
    CFStringRef v9 = v8;
    if (v8)
    {
      CFRetain(v8);
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(v9))
      {
        CFIndex Length = CFStringGetLength(v9);
        if (Length >= 1)
        {
          CFIndex v12 = Length;
          CFIndex v13 = Length + 1;
          CFDictionaryRef v14 = (UInt8 *)malloc_type_calloc(1uLL, Length + 1, 0xF4139D1uLL);
          if (CFStringGetCString(v9, (char *)v14, v13, 0x600u))
          {
            CFRelease(v9);
            CFStringRef v9 = (const __CFString *)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v14, v12);
          }
          free(v14);
        }
      }
      CFTypeID v15 = CFGetTypeID(v9);
      if (v15 == CFDataGetTypeID())
      {
        if (CFDataGetLength((CFDataRef)v9)) {
          goto LABEL_12;
        }
        uint64_t v20 = 4294954581;
      }
      else
      {
        uint64_t v20 = 4294954584;
      }
      int appended = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
      goto LABEL_20;
    }
LABEL_12:
    int appended = FigAtomWriterInitWithParent(a3, (uint64_t)&v49);
    if (!appended)
    {
      int appended = FigAtomWriterBeginAtom((uint64_t)&v49, 0x6B657964u, 0);
      if (!appended)
      {
        int appended = FigAtomWriterAppendData((uint64_t)&v49, (uint64_t)valuePtr, 4);
        if (!appended)
        {
          if (v9)
          {
            BytePtr = CFDataGetBytePtr((CFDataRef)v9);
            CFIndex v18 = CFDataGetLength((CFDataRef)v9);
            int v19 = FigAtomWriterAppendData((uint64_t)&v49, (uint64_t)BytePtr, v18);
            if (v19)
            {
              int v21 = v19;
LABEL_21:
              CFRelease(v9);
LABEL_22:
              if (v21) {
                return;
              }
              goto LABEL_23;
            }
          }
          int appended = FigAtomWriterEndAtom((uint64_t)&v49);
        }
      }
    }
LABEL_20:
    int v21 = appended;
    if (!v9) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  if (FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0)) {
    return;
  }
LABEL_23:
  if (KeyEmitter_EmitDatatypeDeclarationBox(a3, a2)) {
    return;
  }
  CFIndex usedBufLen = 0;
  *(void *)&valuePtr[0] = 0;
  CFStringRef v22 = (const __CFString *)CFDictionaryGetValue(a2, @"MetadataKeyLanguageTag");
  if (!v22) {
    goto LABEL_34;
  }
  CFStringRef v23 = v22;
  uint64_t v24 = CFStringGetLength(v22);
  if (v24 < 1) {
    goto LABEL_34;
  }
  CFIndex v25 = v24;
  uint64_t v52 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v49 = 0u;
  v54.CFIndex location = 0;
  v54.CFIndex length = v24;
  CFStringGetBytes(v23, v54, 0x600u, 0, 0, 0, 0, (CFIndex *)valuePtr);
  if (*(uint64_t *)&valuePtr[0] <= 0)
  {
    uint64_t v45 = 4294954580;
    goto LABEL_68;
  }
  uint64_t v26 = (UInt8 *)malloc_type_malloc(*(void *)&valuePtr[0] + 1, 0xD94E18CCuLL);
  if (!v26)
  {
    uint64_t v45 = 4294954583;
LABEL_68:
    if (FigSignalErrorAt(v45, 0, 0, 0, 0, 0, 0)) {
      return;
    }
    goto LABEL_34;
  }
  uint64_t v27 = v26;
  v55.CFIndex location = 0;
  v55.CFIndex length = v25;
  CFStringGetBytes(v23, v55, 0x600u, 0, 0, v26, *(CFIndex *)&valuePtr[0], &usedBufLen);
  if (*(void *)&valuePtr[0] == usedBufLen)
  {
    v27[*(void *)&valuePtr[0]] = 0;
    int v28 = FigAtomWriterInitWithParent(a3, (uint64_t)&v49);
    if (!v28)
    {
      int v28 = FigAtomWriterBeginAtom((uint64_t)&v49, 0x6C6F6361u, 0);
      if (!v28)
      {
        int v28 = FigAtomWriterAppendData((uint64_t)&v49, (uint64_t)v27, *(void *)&valuePtr[0] + 1);
        if (!v28) {
          int v28 = FigAtomWriterEndAtom((uint64_t)&v49);
        }
      }
    }
  }
  else
  {
    int v28 = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
  }
  int v29 = v28;
  free(v27);
  if (v29) {
    return;
  }
LABEL_34:
  CFDictionaryRef v30 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"MetadataKeyStructuralDependency");
  if (v30)
  {
    CFDictionaryRef v31 = v30;
    if (CFDictionaryContainsKey(v30, @"StructuralDependencyIsInvalidFlag"))
    {
      uint64_t v48 = 0;
      memset(valuePtr, 0, sizeof(valuePtr));
      if (FigAtomWriterInitWithParent(a3, (uint64_t)valuePtr)) {
        return;
      }
      if (FigAtomWriterBeginAtom((uint64_t)valuePtr, 0x73647064u, 0)) {
        return;
      }
      uint64_t v52 = 0;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v49 = 0u;
      if (FigAtomWriterInitWithParent((uint64_t)valuePtr, (uint64_t)&v49)) {
        return;
      }
      uint64_t v32 = CFDictionaryGetValue(v31, @"StructuralDependencyIsInvalidFlag");
      int v33 = FigCFEqual(v32, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
      if (FigAtomWriterBeginAtom((uint64_t)&v49, 0x73647069u, 0)
        || FigAtomWriterAppendVersionAndFlags((uint64_t)&v49, 0, v33 != 0)
        || FigAtomWriterEndAtom((uint64_t)&v49)
        || FigAtomWriterEndAtom((uint64_t)valuePtr))
      {
        return;
      }
    }
  }
  CFDataRef v34 = (const __CFData *)CFDictionaryGetValue(a2, @"MetadataKeySetupData");
  if (v34)
  {
    CFDataRef v35 = v34;
    CFIndex v36 = CFDataGetLength(v34);
    if (v36)
    {
      uint64_t v37 = v36;
      uint64_t v52 = 0;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v49 = 0u;
      if (FigAtomWriterInitWithParent(a3, (uint64_t)&v49)) {
        return;
      }
      if (FigAtomWriterBeginAtom((uint64_t)&v49, 0x73657475u, 0)) {
        return;
      }
      CFTypeRef v38 = CFDataGetBytePtr(v35);
      if (FigAtomWriterAppendData((uint64_t)&v49, (uint64_t)v38, v37)
        || FigAtomWriterEndAtom((uint64_t)&v49))
      {
        return;
      }
    }
  }
  CFArrayRef v39 = (const __CFArray *)CFDictionaryGetValue(a2, @"MetadataKeyConformingDataTypes");
  if (!v39 || (v40 = v39, (CFIndex Count = CFArrayGetCount(v39)) == 0))
  {
LABEL_58:
    FigAtomWriterEndAtom(a3);
    return;
  }
  uint64_t v42 = Count;
  uint64_t v52 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v49 = 0u;
  if (FigAtomWriterInitWithParent(a3, (uint64_t)&v49)
    || FigAtomWriterBeginAtom((uint64_t)&v49, 0x63747073u, 0))
  {
    return;
  }
  if (v42 < 1)
  {
LABEL_57:
    if (FigAtomWriterEndAtom((uint64_t)&v49)) {
      return;
    }
    goto LABEL_58;
  }
  CFIndex v43 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v40, v43);
    if (KeyEmitter_EmitDatatypeDeclarationBox((uint64_t)&v49, ValueAtIndex)) {
      break;
    }
    if (v42 == ++v43) {
      goto LABEL_57;
    }
  }
}

uint64_t FigMetadataAppendMEBXPrimaryLocalIDsBox(uint64_t a1, const __CFArray *a2)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  uint64_t result = FigAtomWriterInitWithParent(a1, (uint64_t)v4);
  if (!result)
  {
    uint64_t result = FigAtomWriterBeginAtom((uint64_t)v4, 0x6C696470u, 0);
    if (!result)
    {
      v6.CFIndex length = CFArrayGetCount(a2);
      v6.CFIndex location = 0;
      CFArrayApplyFunction(a2, v6, (CFArrayApplierFunction)LocalIDEmitterApplierFunction, v4);
      return FigAtomWriterEndAtom((uint64_t)v4);
    }
  }
  return result;
}

uint64_t LocalIDEmitterApplierFunction(const __CFNumber *a1, uint64_t a2)
{
  signed int valuePtr = 0;
  uint64_t result = CFNumberGetValue(a1, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr >= 1)
  {
    signed int valuePtr = bswap32(valuePtr);
    return FigAtomWriterAppendData(a2, (uint64_t)&valuePtr, 4);
  }
  return result;
}

uint64_t FigMetadataAppendMEBXLocalIDDependencyListBoxes(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  uint64_t result = FigAtomWriterInitWithParent(a1, (uint64_t)v4);
  if (!result)
  {
    uint64_t result = FigAtomWriterBeginAtom((uint64_t)v4, 0x6C69646Cu, 0);
    if (!result)
    {
      CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)DependencyListsEmitterApplierFunction, v4);
      return FigAtomWriterEndAtom((uint64_t)v4);
    }
  }
  return result;
}

uint64_t DependencyListsEmitterApplierFunction(const __CFString *a1, const __CFArray *a2, uint64_t a3)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1) && (CFTypeID v7 = CFArrayGetTypeID(), v7 == CFGetTypeID(a2)))
  {
    uint64_t result = CFStringGetIntValue(a1);
    if (result)
    {
      unsigned int v9 = bswap32(result);
      uint64_t v11 = 0;
      memset(v10, 0, sizeof(v10));
      FigAtomWriterInitWithParent(a3, (uint64_t)v10);
      FigAtomWriterBeginAtom((uint64_t)v10, v9, 0);
      v13.CFIndex length = CFArrayGetCount(a2);
      v13.CFIndex location = 0;
      CFArrayApplyFunction(a2, v13, (CFArrayApplierFunction)LocalIDEmitterApplierFunction, v10);
      return FigAtomWriterEndAtom((uint64_t)v10);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

OSStatus CMMetadataFormatDescriptionCopyAsBigEndianMetadataDescriptionBlockBuffer(CFAllocatorRef allocator, CMMetadataFormatDescriptionRef metadataFormatDescription, CMMetadataDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  uint64_t v20 = 0;
  memset(v19, 0, sizeof(v19));
  unint64_t v17 = 0xFFFF000000000000;
  CMBlockBufferRef blockBufferOuta = 0;
  if (metadataFormatDescription)
  {
    if (blockBufferOut)
    {
      CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(metadataFormatDescription);
      if (Extensions)
      {
        CFDictionaryRef v8 = Extensions;
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"MetadataKeyTable");
        if (Value)
        {
          CFDictionaryRef v10 = Value;
          CFRetain(Value);
        }
        else
        {
          CFDictionaryRef v10 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        }
        CFArrayRef v11 = (const __CFArray *)CFDictionaryGetValue(v8, @"MetadataPrimaryLocalIDs");
        CFDictionaryRef v12 = (const __CFDictionary *)CFDictionaryGetValue(v8, @"MetadataLocalIDDependencyLists");
        if (CMFormatDescriptionGetMediaSubType(metadataFormatDescription) != 1835360888)
        {
          OSStatus v15 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
          goto LABEL_24;
        }
        OSStatus appended = CMBlockBufferCreateEmpty(allocator, 8u, 0, &blockBufferOuta);
        if (appended) {
          goto LABEL_18;
        }
        OSStatus appended = FigAtomWriterInitWithBlockBuffer(blockBufferOuta, (uint64_t)v19);
        if (appended) {
          goto LABEL_18;
        }
        OSStatus appended = FigAtomWriterBeginAtom((uint64_t)v19, 0x6D656278u, 0);
        if (appended) {
          goto LABEL_18;
        }
        FigAtomWriterAppendData((uint64_t)v19, (uint64_t)&v17, 8);
        OSStatus appended = FigMetadataAppendMEBXKeyTableBox((uint64_t)v19, v10);
        if (appended) {
          goto LABEL_18;
        }
        if (!v11) {
          goto LABEL_21;
        }
        if (CFArrayGetCount(v11) >= 1 && v12 && CFDictionaryGetCount(v12) >= 1)
        {
          OSStatus appended = FigMetadataAppendMEBXPrimaryLocalIDsBox((uint64_t)v19, v11);
          if (appended || (OSStatus appended = FigMetadataAppendMEBXLocalIDDependencyListBoxes((uint64_t)v19, v12)) != 0)
          {
LABEL_18:
            OSStatus v14 = appended;
            goto LABEL_25;
          }
          goto LABEL_23;
        }
        if (CFArrayGetCount(v11) <= 0)
        {
LABEL_21:
          if (v12) {
            CFDictionaryGetCount(v12);
          }
        }
LABEL_23:
        OSStatus v15 = FigAtomWriterEndAtom((uint64_t)v19);
LABEL_24:
        OSStatus v14 = v15;
        if (v15) {
          goto LABEL_25;
        }
LABEL_31:
        *CMBlockBufferRef blockBufferOut = blockBufferOuta;
        CMBlockBufferRef blockBufferOuta = 0;
        if (!v10) {
          return v14;
        }
        goto LABEL_28;
      }
    }
  }
  OSStatus v14 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  CFDictionaryRef v10 = 0;
  if (!v14) {
    goto LABEL_31;
  }
LABEL_25:
  if (blockBufferOuta) {
    CFRelease(blockBufferOuta);
  }
  if (v10) {
LABEL_28:
  }
    CFRelease(v10);
  return v14;
}

uint64_t copyKeyOrDataTypeAtom(const __CFAllocator *a1, uint64_t a2, CFNumberRef *a3, CFDataRef *a4)
{
  char v18 = 0;
  unsigned int valuePtr = 0;
  size_t totalLengthOut = 0;
  CMBlockBufferRef theBuffer = 0;
  unint64_t v13 = 0;
  dataPointerOut = 0;
  CurrentAtomTypeAndDataCFIndex Length = FigAtomStreamGetCurrentAtomTypeAndDataLength(a2, 0, &v13);
  if (!CurrentAtomTypeAndDataLength && v13 >= 4)
  {
    uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData(a2, 0, 4, (uint64_t)&valuePtr);
    if (!CurrentAtomData)
    {
      unsigned int valuePtr = bswap32(valuePtr);
      CFNumberRef v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
      *a3 = v10;
      if (v10)
      {
        if (v13 < 5)
        {
LABEL_9:
          CurrentAtomTypeAndDataCFIndex Length = 0;
          goto LABEL_10;
        }
        uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomDataAndCreateBBuf(a2, 4, 0, &theBuffer);
        if (CurrentAtomData) {
          goto LABEL_14;
        }
        uint64_t CurrentAtomData = CMBlockBufferGetDataPointer(theBuffer, 0, 0, &totalLengthOut, &dataPointerOut);
        if (CurrentAtomData) {
          goto LABEL_14;
        }
        CFDataRef v11 = CFDataCreate(a1, (const UInt8 *)dataPointerOut, totalLengthOut);
        *a4 = v11;
        if (v11) {
          goto LABEL_9;
        }
      }
      uint64_t CurrentAtomData = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    }
LABEL_14:
    CurrentAtomTypeAndDataCFIndex Length = CurrentAtomData;
  }
LABEL_10:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return CurrentAtomTypeAndDataLength;
}

uint64_t KeyEmitter_EmitDatatypeDeclarationBox(uint64_t a1, CFDictionaryRef theDict)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"MetadataKeyDataTypeNameSpace");
  unsigned int valuePtr = 0;
  if (Value)
  {
    uint64_t v23 = 0;
    memset(v22, 0, sizeof(v22));
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    unsigned int valuePtr = bswap32(valuePtr);
    CFStringRef v5 = (const __CFString *)CFDictionaryGetValue(theDict, @"MetadataKeyDataType");
    if (v5)
    {
      CFStringRef v6 = v5;
      CFRetain(v5);
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(v6))
      {
        CFIndex Length = CFStringGetLength(v6);
        if (Length >= 1)
        {
          CFIndex v9 = Length;
          CFIndex v10 = Length + 1;
          CFDataRef v11 = (UInt8 *)malloc_type_calloc(1uLL, Length + 1, 0x93AD09ACuLL);
          if (CFStringGetCString(v6, (char *)v11, v10, 0x600u))
          {
            CFRelease(v6);
            CFStringRef v6 = (const __CFString *)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v11, v9);
          }
          free(v11);
          if (!v6) {
            return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
          }
        }
        goto LABEL_13;
      }
      CFTypeID v12 = CFNumberGetTypeID();
      if (v12 == CFGetTypeID(v6))
      {
        *(_DWORD *)bytes = 0;
        CFNumberGetValue((CFNumberRef)v6, kCFNumberSInt32Type, bytes);
        CFRelease(v6);
        *(_DWORD *)bytes = bswap32(*(unsigned int *)bytes);
        CFStringRef v6 = (const __CFString *)CFDataCreate(0, bytes, 4);
        if (!v6) {
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        CFTypeID v14 = CFDataGetTypeID();
        if (v14 != CFGetTypeID(v6))
        {
          uint64_t v18 = 4294954584;
          goto LABEL_20;
        }
      }
LABEL_13:
      if (CFDataGetLength((CFDataRef)v6))
      {
        uint64_t appended = FigAtomWriterInitWithParent(a1, (uint64_t)v22);
        if (!appended)
        {
          uint64_t appended = FigAtomWriterBeginAtom((uint64_t)v22, 0x64747970u, 0);
          if (!appended)
          {
            uint64_t appended = FigAtomWriterAppendData((uint64_t)v22, (uint64_t)&valuePtr, 4);
            if (!appended)
            {
              BytePtr = CFDataGetBytePtr((CFDataRef)v6);
              CFIndex v17 = CFDataGetLength((CFDataRef)v6);
              uint64_t appended = FigAtomWriterAppendData((uint64_t)v22, (uint64_t)BytePtr, v17);
              if (!appended) {
                uint64_t appended = FigAtomWriterEndAtom((uint64_t)v22);
              }
            }
          }
        }
        goto LABEL_21;
      }
      uint64_t v18 = 4294954581;
LABEL_20:
      uint64_t appended = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
LABEL_21:
      uint64_t v13 = appended;
      CFRelease(v6);
      return v13;
    }
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

void FigSandboxServerXPC_RemoveAssertionForPID(int a1, uint64_t a2)
{
  if (gFigSandboxServerXPC_0)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 0x40000000;
    void v2[2] = __FigSandboxServerXPC_RemoveAssertionForPID_block_invoke;
    v2[3] = &__block_descriptor_tmp_40;
    int v3 = a1;
    v2[4] = a2;
    dispatch_sync((dispatch_queue_t)gFigSandboxServerXPC_0, v2);
  }
}

void fsbsxpc_removeAssertionForPIDOnQueue(int a1)
{
  CFAllocatorRef v2 = (const void *)a1;
  uint64_t v3 = MEMORY[0x192FC3C00](gFigSandboxServerXPC_2, a1);
  if (v3 >= 1)
  {
    uint64_t v4 = v3;
    CFBagRemoveValue((CFMutableBagRef)gFigSandboxServerXPC_2, v2);
    if (v4 == 1)
    {
      CFNumberRef SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1);
      long long value = 0;
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)gFigSandboxServerXPC_1, SInt32, (const void **)&value))
      {
        CFArrayGetCount((CFArrayRef)value);
        CFDictionaryRemoveValue((CFMutableDictionaryRef)gFigSandboxServerXPC_1, SInt32);
      }
      if (SInt32) {
        CFRelease(SInt32);
      }
    }
  }
}

void FigSandboxServerXPC_AddAssertionForPID(int a1, uint64_t a2)
{
  if (gFigSandboxServerXPC_0)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 0x40000000;
    void v2[2] = __FigSandboxServerXPC_AddAssertionForPID_block_invoke;
    v2[3] = &__block_descriptor_tmp_3_3;
    int v3 = a1;
    v2[4] = a2;
    dispatch_sync((dispatch_queue_t)gFigSandboxServerXPC_0, v2);
  }
}

uint64_t FigSandboxRegistrationServerStart()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigSandboxRegistrationServerStart_block_invoke;
  block[3] = &unk_1E5679FC8;
  void block[4] = &v3;
  if (FigSandboxRegistrationServerStart_static_init != -1) {
    dispatch_once(&FigSandboxRegistrationServerStart_static_init, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t HandleSandboxRegistrationMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t v18 = 0;
  CFTypeRef v19 = 0;
  int v17 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v17);
  if (OpCode) {
    goto LABEL_28;
  }
  if (v17 == 1668441400)
  {
    long long v30 = 0u;
    long long v29 = 0u;
    uint64_t v27 = 0;
    CFDataRef v28 = 0;
    CFTypeRef cf = 0;
    uint64_t value = 0;
    xpc_connection_get_audit_token();
    long long block = v29;
    long long v21 = v30;
    uint64_t ClientPIDFromAuditToken = FigServer_GetClientPIDFromAuditToken(&block);
    uint64_t v8 = FigXPCMessageCopyCFData(a2, "ExtensionTokenData", &v28);
    if (v8
      || (FigXPCMessageCopyCFString(a2, "ExtensionPath", &cf),
          uint64_t v8 = FigSandboxRegistrationCreate(v28, ClientPIDFromAuditToken, cf, &v27),
          v8)
      || (CFIndex v9 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL)) == 0
      && (uint64_t v8 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0), v8))
    {
      uint64_t v10 = v8;
      CFIndex v9 = 0;
    }
    else
    {
      uint64_t v10 = FigXPCServerAssociateObjectWithConnection(a1, v27, (uint64_t)v9, (uint64_t)DisposeServedSandboxRegistrationState, 0, &value);
      if (!v10)
      {
        xpc_dictionary_set_uint64(a3, ".objectID", value);
        CFNumberRef SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], ClientPIDFromAuditToken);
        *(void *)&long long block = MEMORY[0x1E4F143A8];
        *((void *)&block + 1) = 0x40000000;
        *(void *)&long long v21 = __HandleSandboxRegistrationCreationMessage_block_invoke;
        *((void *)&v21 + 1) = &__block_descriptor_tmp_24_0;
        CFNumberRef v22 = SInt32;
        uint64_t v23 = v27;
        int v24 = ClientPIDFromAuditToken;
        dispatch_sync((dispatch_queue_t)gFigSandboxServerXPC_0, &block);
        *(_DWORD *)CFIndex v9 = ClientPIDFromAuditToken;
        v9[1] = CFRetain(v27);
        CFIndex v9 = 0;
LABEL_8:
        DisposeServedSandboxRegistrationState(v9);
        if (v27) {
          CFRelease(v27);
        }
        if (cf) {
          CFRelease(cf);
        }
        if (v28) {
          CFRelease(v28);
        }
        if (SInt32) {
          CFRelease(SInt32);
        }
        goto LABEL_24;
      }
    }
    CFNumberRef SInt32 = 0;
    goto LABEL_8;
  }
  uint64_t int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  OpCFIndex Code = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &v19, &v18);
  if (OpCode)
  {
LABEL_28:
    uint64_t v10 = OpCode;
    goto LABEL_24;
  }
  if (!v19 || (CFTypeID v13 = CFGetTypeID(v19), v13 != FigSandboxRegistrationGetTypeID()))
  {
    OpCFIndex Code = FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  if (v17 == 1685024621)
  {
    CFNumberRef v14 = (const __CFNumber *)v19;
    if (v19)
    {
      int v15 = *v18;
      CFRetain(v19);
      *(void *)&long long block = MEMORY[0x1E4F143A8];
      *((void *)&block + 1) = 0x40000000;
      *(void *)&long long v21 = __HandleDestroySandboxRegistrationMessage_block_invoke;
      *((void *)&v21 + 1) = &__block_descriptor_tmp_26_2;
      LODWORD(v23) = v15;
      CFNumberRef v22 = v14;
      dispatch_async((dispatch_queue_t)gFigSandboxServerXPC_0, &block);
    }
    FigXPCServerDisassociateObjectWithConnection(a1, uint64);
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 4294951138;
  }
LABEL_24:
  if (v19) {
    CFRelease(v19);
  }
  return v10;
}

void __FigSandboxRegistrationServerStart_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (FigServer_IsMediaparserd())
  {
    CFAllocatorRef v2 = 0;
  }
  else if (FigServer_IsMediaplaybackd())
  {
    CFAllocatorRef v2 = "com.apple.coremedia.mediaplaybackd.sandboxserver.xpc";
  }
  else
  {
    CFAllocatorRef v2 = "com.apple.coremedia.sandboxserver.xpc";
  }
  v12[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v12, &type);
  int v4 = v12[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v6 = v4;
  }
  else {
    unsigned int v6 = v4 & 0xFFFFFFFE;
  }
  if (v6)
  {
    v12[1] = 136315394;
    CFTypeID v13 = "FigSandboxRegistrationServerStart_block_invoke";
    __int16 v14 = 2080;
    int v15 = v2;
    CFTypeID v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v12[0];
  }
  else
  {
    CFTypeID v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != &v16, v4, 0, v5);
  gFigSandboxServerXPC_0 = (uint64_t)dispatch_queue_create("FigSandboxServerXPCQueue", 0);
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  gFigSandboxServerXPC_1 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  gFigSandboxServerXPC_2 = (uint64_t)CFBagCreateMutable(v8, 0, 0);
  FigInstallSysdiagnoseBlock(@"FigSandboxSupportDump", (uint64_t)&__block_literal_global_33);
  if (v2)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v10 = (const void *)*MEMORY[0x1E4F1CFD0];
    FigCFDictionarySetValue(Mutable, @"xpcServerOption_SelfTerminateOnError", (const void *)*MEMORY[0x1E4F1CFD0]);
    FigCFDictionarySetValue(Mutable, @"xpcServerOption_OptOutOfPurge", v10);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigXPCServerStart((uint64_t)v2, FigSandboxRegistrationServerStart_callbacks, (uint64_t)Mutable, &gFigSandboxRegistrationServerXPC);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

void __FigSandboxRegistrationServerStart_block_invoke_8()
{
}

void __FigSandboxRegistrationServerStart_block_invoke_2()
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  int v22 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v22, &type);
  int v1 = v22;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v3 = v1;
  }
  else {
    unsigned int v3 = v1 & 0xFFFFFFFE;
  }
  if (v3)
  {
    int Count = CFDictionaryGetCount((CFDictionaryRef)gFigSandboxServerXPC_1);
    int v23 = 136315394;
    int v24 = "FigSandboxRegistrationServerStart_block_invoke_2";
    __int16 v25 = 1024;
    LODWORD(v26) = Count;
    uint64_t v5 = (unsigned char *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v22;
  }
  else
  {
    uint64_t v5 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v5, v5 != v27, v1, 0, v2);
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFMutableStringRef v8 = CFStringCreateMutable(v6, 0);
  CFMutableStringRef v9 = v8;
  if (Mutable) {
    BOOL v10 = v8 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    if (!Mutable)
    {
      if (!v8) {
        return;
      }
      goto LABEL_14;
    }
  }
  else if (CFDictionaryGetCount((CFDictionaryRef)gFigSandboxServerXPC_1) >= 1)
  {
    CFDictionaryApplyFunction((CFDictionaryRef)gFigSandboxServerXPC_1, (CFDictionaryApplierFunction)figSandboxRegistrationServerCompactDictionaryDescription, Mutable);
    int v22 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    CFDataRef v11 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v22, &type);
    int v12 = v22;
    if (os_log_type_enabled(v11, type)) {
      unsigned int v14 = v12;
    }
    else {
      unsigned int v14 = v12 & 0xFFFFFFFE;
    }
    if (v14)
    {
      int v23 = 136315394;
      int v24 = "FigSandboxRegistrationServerStart_block_invoke";
      __int16 v25 = 2112;
      CFMutableStringRef v26 = Mutable;
      int v15 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v12) = v22;
    }
    else
    {
      int v15 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v15, v15 != v27, v12, 0, v13);
    CFDictionaryApplyFunction((CFDictionaryRef)gFigSandboxServerXPC_1, (CFDictionaryApplierFunction)figSandboxRegistrationServerPublicDictionaryDescription, v9);
    int v22 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    char v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v22, &type);
    int v17 = v22;
    if (os_log_type_enabled(v16, type)) {
      unsigned int v19 = v17;
    }
    else {
      unsigned int v19 = v17 & 0xFFFFFFFE;
    }
    if (v19)
    {
      int v23 = 136315394;
      int v24 = "FigSandboxRegistrationServerStart_block_invoke";
      __int16 v25 = 2114;
      CFMutableStringRef v26 = v9;
      uint64_t v20 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v17) = v22;
    }
    else
    {
      uint64_t v20 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v20, v20 != v27, v17, 0, v18);
  }
  CFRelease(Mutable);
  if (!v9) {
    return;
  }
LABEL_14:
  CFRelease(v9);
}

void figSandboxRegistrationServerCompactDictionaryDescription(const __CFNumber *a1, const __CFSet *a2, __CFString *a3)
{
  CFNumberRef SInt32 = FigCFNumberGetSInt32(a1);
  CFStringAppendFormat(a3, 0, @"pid : %d = {", SInt32);
  CFAllocatorRef v6 = FigCFCopyCompactDescription(a2);
  CFStringAppendFormat(a3, 0, @"%@} ", v6);
  if (v6)
  {
    CFRelease(v6);
  }
}

void figSandboxRegistrationServerPublicDictionaryDescription(const __CFNumber *a1, const __CFArray *a2, __CFString *a3)
{
  CFNumberRef SInt32 = FigCFNumberGetSInt32(a1);
  CFStringAppendFormat(a3, 0, @"pid : %d = {", SInt32);
  CFIndex Count = CFArrayGetCount(a2);
  CFStringAppendFormat(a3, 0, @"%d} ", Count);
}

uint64_t FigSandboxRegistrationServerKillDueToError(int a1)
{
  return FigXPCServerSelfTerminateDueToError(gFigSandboxRegistrationServerXPC, a1);
}

uint64_t FigSandboxRegistrationServerCopyRegistrationForID(void *a1, void *a2)
{
  if (gFigSandboxRegistrationServerXPC) {
    return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gFigSandboxRegistrationServerXPC, a1, a2);
  }
  else {
    return FigSignalErrorAt(4294949792, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCMessageSetSandboxRegistration(void *a1, const char *a2, uint64_t a3)
{
  uint64_t value = 0;
  if (a3 && a1 && a2)
  {
    uint64_t result = FigSandboxRegistrationRemoteGetObjectID(a3, &value);
    if (!result)
    {
      xpc_dictionary_set_uint64(a1, a2, value);
      return 0;
    }
  }
  else
  {
    return FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigXPCMessageCopySandboxRegistration(void *a1, const char *a2, void *a3)
{
  if (a3 && a1 && a2)
  {
    uint64_t int64 = (void *)xpc_dictionary_get_uint64(a1, a2);
    if (uint64)
    {
      return FigSandboxRegistrationServerCopyRegistrationForID(uint64, a3);
    }
    else
    {
      return 4294949794;
    }
  }
  else
  {
    return FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
  }
}

void FigSandboxRegistrationServerDumpMappings(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (Mutable)
  {
    CFMutableStringRef v3 = Mutable;
    if (CFDictionaryGetCount((CFDictionaryRef)gFigSandboxServerXPC_1) >= 1)
    {
      CFDictionaryApplyFunction((CFDictionaryRef)gFigSandboxServerXPC_1, (CFDictionaryApplierFunction)figSandboxRegistrationServerPublicDictionaryDescription, v3);
      v10[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v10, &type);
      int v5 = v10[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v7 = v5;
      }
      else {
        unsigned int v7 = v5 & 0xFFFFFFFE;
      }
      if (v7)
      {
        v10[1] = 136315650;
        CFDataRef v11 = "FigSandboxRegistrationServerDumpMappings";
        __int16 v12 = 2048;
        uint64_t v13 = a1;
        __int16 v14 = 2114;
        CFMutableStringRef v15 = v3;
        CFMutableStringRef v8 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v5) = v10[0];
      }
      else
      {
        CFMutableStringRef v8 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v8, v8 != &v16, v5, 0, v6);
    }
    CFRelease(v3);
  }
}

void DisposeServedSandboxRegistrationState(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[1];
    if (v2)
    {
      CFTypeRef v3 = CFRetain(v2);
      int v4 = *(_DWORD *)a1;
      v6[0] = MEMORY[0x1E4F143A8];
      v6[1] = 0x40000000;
      int v6[2] = __DisposeServedSandboxRegistrationState_block_invoke;
      _OWORD v6[3] = &__block_descriptor_tmp_25;
      int v7 = v4;
      v6[4] = v3;
      dispatch_async((dispatch_queue_t)gFigSandboxServerXPC_0, v6);
      int v5 = (const void *)a1[1];
      if (v5) {
        CFRelease(v5);
      }
    }
    free(a1);
  }
}

void __HandleSandboxRegistrationCreationMessage_block_invoke(uint64_t a1)
{
  uint64_t value = 0;
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)gFigSandboxServerXPC_1, *(const void **)(a1 + 32), (const void **)&value))
  {
    CFRetain(value);
  }
  else
  {
    uint64_t value = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    CFDictionarySetValue((CFMutableDictionaryRef)gFigSandboxServerXPC_1, *(const void **)(a1 + 32), value);
  }
  CFArrayAppendValue((CFMutableArrayRef)value, *(const void **)(a1 + 40));
  if (value)
  {
    CFRelease(value);
    uint64_t value = 0;
  }
  uint64_t v2 = (const void *)*(int *)(a1 + 48);
  MEMORY[0x192FC3C00](gFigSandboxServerXPC_2, v2);
  CFBagAddValue((CFMutableBagRef)gFigSandboxServerXPC_2, v2);
}

void __DisposeServedSandboxRegistrationState_block_invoke(uint64_t a1)
{
  fsbsxpc_removeAssertionForPIDOnQueue(*(_DWORD *)(a1 + 40));
  uint64_t v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

void __HandleDestroySandboxRegistrationMessage_block_invoke(uint64_t a1)
{
  CFNumberRef SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(_DWORD *)(a1 + 40));
  uint64_t value = 0;
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)gFigSandboxServerXPC_1, SInt32, (const void **)&value)) {
    BOOL v3 = value == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3 && CFArrayGetCount((CFArrayRef)value) >= 1)
  {
    CFArrayRef v4 = (const __CFArray *)value;
    v8.CFIndex length = CFArrayGetCount((CFArrayRef)value);
    v8.CFIndex location = 0;
    CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v8, *(const void **)(a1 + 32));
    if (FirstIndexOfValue != -1) {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)value, FirstIndexOfValue);
    }
  }
  if (SInt32) {
    CFRelease(SInt32);
  }
  uint64_t v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFRelease(v6);
  }
}

uint64_t FigMetadataFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigMetadataFormatDescriptionRegisterOnce, (void (*)(void))FigMetadataFormatDescriptionRegisterOnce);
}

uint64_t FigMetadataFormatDescriptionRegisterOnce()
{
  int v1 = 0;
  int v5 = figMetadataFormatDescriptionFinalize;
  CFArrayRef v4 = figMetadataFormatDescriptionCopyDebugDesc;
  uint64_t v2 = 48;
  BOOL v3 = figMetadataFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x6D657461u, (long long *)&v1);
}

uint64_t FigMetadataFormatDescriptionCreateWithKeysAndDependencies(const __CFAllocator *a1, int a2, CFArrayRef theArray, const __CFString *a4, void *a5, uint64_t *a6)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  uint64_t valuePtr = 0;
  if (!a6 || !theArray || (int v7 = a6, !CFArrayGetCount(theArray)) || (theArraya = theArray, a2 != 1835360888))
  {
    uint64_t v65 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    CFMutableArrayRef v12 = 0;
    int v79 = 0;
    CFDictionaryRef v80 = 0;
    uint64_t v74 = 0;
    int v75 = 0;
    int v63 = 0;
    unsigned int v77 = 0;
    CFDictionaryRef theDict = 0;
    CFDictionaryRef v13 = 0;
    CFMutableStringRef v15 = 0;
    CFStringRef DynamicBaseDataType = 0;
    CFStringRef v18 = 0;
    goto LABEL_118;
  }
  FigThreadRunOnce(&sFigMetadataFormatDescriptionRegisterOnce, (void (*)(void))FigMetadataFormatDescriptionRegisterOnce);
  FigThreadRunOnce(&sFigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce, FigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce);
  uint64_t capacity = CFArrayGetCount(theArray);
  if (capacity < 1)
  {
    CFMutableArrayRef v12 = 0;
    int v79 = 0;
    CFDictionaryRef v80 = 0;
    uint64_t v74 = 0;
    int v75 = 0;
    int v63 = 0;
    unsigned int v77 = 0;
    CFDictionaryRef theDict = 0;
    CFStringRef DynamicBaseDataType = 0;
    CFTypeRef v17 = 0;
    CFStringRef v18 = 0;
    goto LABEL_108;
  }
  CFStringRef v68 = a4;
  long long v69 = a5;
  long long v71 = v7;
  long long v72 = 0;
  CFMutableArrayRef v12 = 0;
  CFDictionaryRef v13 = 0;
  __int16 v14 = 0;
  CFMutableStringRef v15 = 0;
  unsigned int v77 = 0;
  int v79 = 0;
  CFDictionaryRef theDict = 0;
  CFStringRef DynamicBaseDataType = 0;
  CFTypeRef v17 = 0;
  CFStringRef v18 = 0;
  CFIndex v19 = 0;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef v20 = theArraya;
  CFAllocatorRef alloc = a1;
  while (1)
  {
    if (v18) {
      CFRelease(v18);
    }
    if (v17) {
      CFRelease(v17);
    }
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
    if (DynamicBaseDataType) {
      CFRelease(DynamicBaseDataType);
    }
    if (v12) {
      CFRelease(v12);
    }
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v20, v19);
    if (ValueAtIndex) {
      CFTypeRef v17 = CFRetain(ValueAtIndex);
    }
    else {
      CFTypeRef v17 = 0;
    }
    CFTypeID v22 = CFGetTypeID(v17);
    if (v22 != CFDictionaryGetTypeID())
    {
      CFDictionaryRef v80 = v13;
      uint64_t v74 = v15;
      int v75 = v14;
      uint64_t v65 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      CFStringRef v18 = 0;
      goto LABEL_146;
    }
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v17, @"MetadataKeyLocalID");
    if (Value)
    {
      if (CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 4))
      {
        CFNumberRef LocalIDUInt32 = FigMetadataKeyGetLocalIDUInt32((const __CFDictionary *)v17);
        HIDWORD(valuePtr) = LocalIDUInt32;
        if (LocalIDUInt32) {
          break;
        }
      }
    }
    CFStringRef v18 = 0;
LABEL_48:
    CFStringRef DynamicBaseDataType = 0;
    CFMutableArrayRef v12 = 0;
LABEL_49:
    if (++v19 == capacity)
    {
      CFDictionaryRef v80 = v13;
      if (theDict)
      {
        int v63 = v72;
        if (CFDictionaryGetCount(theDict) >= 1)
        {
          *(_OWORD *)CMTime keys = xmmword_1E567A100;
          int v89 = 0;
          CFStringRef v86 = 0;
          int v87 = 0;
          values = theDict;
          if (v68)
          {
            keys[1] = @"MetadataPrimaryLocalIDs";
            CFStringRef v86 = v68;
            CFIndex v64 = 2;
          }
          else
          {
            CFIndex v64 = 1;
          }
          if (v69)
          {
            keys[v64] = @"MetadataLocalIDDependencyLists";
            *(&values + v64++) = v69;
          }
          CFDictionaryRef v13 = CFDictionaryCreate(a1, (const void **)keys, (const void **)&values, v64, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (v13)
          {
            uint64_t v65 = FigDerivedFormatDescriptionCreate(a1, (void *)0x6D657461, 1835360888, v13, v71);
            if (v65)
            {
              uint64_t v74 = v15;
              int v75 = v14;
            }
            else
            {
              uint64_t DerivedStorage = (void *)FigDerivedFormatDescriptionGetDerivedStorage(*v71);
              *uint64_t DerivedStorage = v80;
              DerivedStorage[1] = v79;
              DerivedStorage[2] = v77;
              DerivedStorage[3] = v72;
              DerivedStorage[4] = v15;
              DerivedStorage[5] = v14;
              int v79 = 0;
              CFDictionaryRef v80 = 0;
              unsigned int v77 = 0;
              int v63 = 0;
              uint64_t v74 = 0;
              int v75 = 0;
            }
          }
          else
          {
            uint64_t v74 = v15;
            int v75 = v14;
            uint64_t v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
          }
          CFMutableStringRef v15 = 0;
          goto LABEL_116;
        }
        uint64_t v74 = v15;
        int v75 = v14;
        int v7 = v71;
      }
      else
      {
        uint64_t v74 = v15;
        int v75 = v14;
        CFDictionaryRef theDict = 0;
        int v7 = v71;
        int v63 = v72;
      }
LABEL_108:
      uint64_t v65 = FigDerivedFormatDescriptionCreate(a1, (void *)0x6D657461, 1835360888, 0, v7);
      CFMutableStringRef v15 = 0;
      CFDictionaryRef v13 = 0;
      goto LABEL_116;
    }
  }
  CFStringRef v18 = CFStringCreateWithFormat(a1, 0, @"%d", LocalIDUInt32);
  if (!v18) {
    goto LABEL_48;
  }
  unsigned int KeyNamespaceUInt32 = FigMetadataKeyGetKeyNamespaceUInt32((const __CFDictionary *)v17);
  if (KeyNamespaceUInt32 != 1634627438 && !CFDictionaryGetValue((CFDictionaryRef)v17, @"MetadataKeyValue")) {
    goto LABEL_48;
  }
  CFMutableStringRef Mutable = theDict;
  if (!theDict)
  {
    CFMutableStringRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable)
    {
      CFDictionaryRef v80 = v13;
      uint64_t v74 = v15;
      int v75 = v14;
      uint64_t v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      CFStringRef DynamicBaseDataType = 0;
      CFMutableStringRef v15 = 0;
      CFDictionaryRef v13 = 0;
      CFDictionaryRef theDict = 0;
      goto LABEL_147;
    }
  }
  CFDictionaryRef theDict = Mutable;
  CFDictionaryAddValue(Mutable, v18, v17);
  uint64_t v27 = v79;
  if (!v79)
  {
    uint64_t v27 = CFDictionaryCreateMutable(a1, capacity, 0, MEMORY[0x1E4F1D540]);
    if (!v27)
    {
      CFDictionaryRef v80 = v13;
      uint64_t v74 = v15;
      int v75 = v14;
      uint64_t v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      CFStringRef DynamicBaseDataType = 0;
      CFMutableStringRef v15 = 0;
      CFDictionaryRef v13 = 0;
      int v79 = 0;
      goto LABEL_147;
    }
  }
  int v79 = v27;
  CFDictionaryAddValue(v27, (const void *)HIDWORD(valuePtr), v17);
  uint64_t v28 = CFDictionaryGetValue((CFDictionaryRef)v17, @"MetadataKeyValue");
  if (FigMetadataCreateIdentifierForKeyAndOSTypeKeySpace(a1, v28, KeyNamespaceUInt32, (CFStringRef *)&cf))
  {
    CFDictionaryRef v80 = v13;
LABEL_150:
    uint64_t v74 = v15;
    int v75 = v14;
    uint64_t v65 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_146:
    CFStringRef DynamicBaseDataType = 0;
    CFMutableStringRef v15 = 0;
    CFDictionaryRef v13 = 0;
LABEL_147:
    CFMutableArrayRef v12 = 0;
    goto LABEL_148;
  }
  if (!v13)
  {
    CFDictionaryRef v13 = CFArrayCreateMutable(a1, capacity, MEMORY[0x1E4F1D510]);
    if (!v13)
    {
      uint64_t v74 = v15;
      int v75 = v14;
      uint64_t v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      CFStringRef DynamicBaseDataType = 0;
      CFMutableStringRef v15 = 0;
      CFDictionaryRef v80 = 0;
      goto LABEL_147;
    }
  }
  v91.CFIndex length = CFArrayGetCount(v13);
  v91.CFIndex location = 0;
  if (!CFArrayContainsValue(v13, v91, cf)) {
    CFArrayAppendValue(v13, cf);
  }
  long long v29 = CFDictionaryGetValue((CFDictionaryRef)v17, @"MetadataKeyDataType");
  long long v30 = CFDictionaryGetValue((CFDictionaryRef)v17, @"MetadataKeyDataTypeNameSpace");
  int v78 = -1;
  CFDictionaryRef v80 = v13;
  if (!v29 || (CFDictionaryRef v31 = v30) == 0)
  {
LABEL_53:
    CFStringRef v35 = (const __CFString *)CFRetain(@"com.apple.metadata.datatype.raw-data");
    goto LABEL_54;
  }
  CFTypeID TypeID = CFDataGetTypeID();
  if (TypeID != CFGetTypeID(v29)) {
    goto LABEL_150;
  }
  CFTypeID v33 = CFNumberGetTypeID();
  if (v33 != CFGetTypeID(v31)) {
    goto LABEL_150;
  }
  CFNumberGetValue((CFNumberRef)v31, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr == 1)
  {
    CFStringRef DynamicBaseDataType = CFStringCreateFromExternalRepresentation(a1, (CFDataRef)v29, 0x600u);
    int v78 = -1;
    CFDictionaryRef v13 = v80;
    if (!DynamicBaseDataType) {
      goto LABEL_53;
    }
    goto LABEL_55;
  }
  CFDictionaryRef v13 = v80;
  if (valuePtr || CFDataGetLength((CFDataRef)v29) != 4)
  {
    int v78 = -1;
    goto LABEL_53;
  }
  int v78 = bswap32(*(_DWORD *)CFDataGetBytePtr((CFDataRef)v29));
  CFDataRef v34 = CFDictionaryGetValue((CFDictionaryRef)sWellKnownTypeToCanonicalMap, (const void *)v78);
  if (v34)
  {
    CFStringRef v35 = (const __CFString *)CFRetain(v34);
    if (v35)
    {
LABEL_54:
      CFStringRef DynamicBaseDataType = v35;
      goto LABEL_55;
    }
  }
  CFStringRef DynamicBaseDataType = FigMetadataCreateDynamicBaseDataType(a1, v78);
  if (!DynamicBaseDataType) {
    goto LABEL_53;
  }
LABEL_55:
  CFArrayRef v36 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v17, @"MetadataKeyConformingDataTypes");
  if (!v36)
  {
    CFMutableArrayRef v12 = 0;
LABEL_83:
    a1 = alloc;
    CFArrayRef v20 = theArraya;
LABEL_84:
    int v55 = v78;
    if (v78 == -1)
    {
      if (!v14)
      {
        __int16 v14 = CFArrayCreateMutable(a1, capacity, 0);
        if (!v14)
        {
          uint64_t v74 = v15;
          uint64_t v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
          CFMutableStringRef v15 = 0;
          CFDictionaryRef v13 = 0;
          int v75 = 0;
          goto LABEL_148;
        }
      }
      CFArrayAppendValue(v14, (const void *)HIDWORD(valuePtr));
      int v55 = 0;
      if (v15) {
        goto LABEL_91;
      }
    }
    else if (v15)
    {
      goto LABEL_91;
    }
    int v56 = v55;
    CFMutableDictionaryRef v57 = CFDictionaryCreateMutable(a1, capacity, 0, 0);
    int v55 = v56;
    CFMutableStringRef v15 = v57;
    if (!v57)
    {
      int v75 = v14;
      uint64_t v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      CFDictionaryRef v13 = 0;
      uint64_t v74 = 0;
      goto LABEL_148;
    }
LABEL_91:
    CFDictionaryAddValue(v15, (const void *)HIDWORD(valuePtr), (const void *)v55);
    int v58 = CFDictionaryGetValue((CFDictionaryRef)v17, @"MetadataKeyLanguageTag");
    if (cf)
    {
      *(_OWORD *)CMTime keys = xmmword_1E567A0E8;
      int v89 = @"MetadataExtendedLanguageTag";
      values = (void *)cf;
      CFStringRef v86 = DynamicBaseDataType;
      int v87 = v58;
      if (v58) {
        CFIndex v59 = 3;
      }
      else {
        CFIndex v59 = 2;
      }
      CFDictionaryRef v60 = CFDictionaryCreate(a1, (const void **)keys, (const void **)&values, v59, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (!v60)
      {
        uint64_t v74 = v15;
        int v75 = v14;
LABEL_158:
        uint64_t v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
        CFMutableStringRef v15 = 0;
LABEL_159:
        CFDictionaryRef v13 = 0;
LABEL_148:
        int v63 = v72;
        goto LABEL_116;
      }
      CFDictionaryRef v61 = v60;
      uint64_t v62 = v77;
      if (!v77)
      {
        uint64_t v62 = CFDictionaryCreateMutable(a1, capacity, 0, MEMORY[0x1E4F1D540]);
        if (!v62)
        {
          uint64_t v74 = v15;
          int v75 = v14;
          unsigned int v77 = 0;
          goto LABEL_158;
        }
      }
      unsigned int v77 = v62;
      CFDictionaryAddValue(v62, (const void *)HIDWORD(valuePtr), v61);
      CFRelease(v61);
      CFArrayRef v20 = theArraya;
    }
    goto LABEL_49;
  }
  CFArrayRef v37 = v36;
  CFIndex Count = CFArrayGetCount(v36);
  if (Count < 1)
  {
    CFMutableArrayRef v12 = 0;
    CFDictionaryRef v13 = v80;
    goto LABEL_83;
  }
  CFIndex v39 = Count;
  uint64_t v74 = v15;
  int v75 = v14;
  CFMutableArrayRef v12 = 0;
  CFIndex v40 = 0;
  while (2)
  {
    uint64_t v41 = CFArrayGetValueAtIndex(v37, v40);
    if (!v41) {
      goto LABEL_76;
    }
    uint64_t v42 = v41;
    CFTypeID v43 = CFDictionaryGetTypeID();
    if (v43 != CFGetTypeID(v42)) {
      goto LABEL_76;
    }
    unsigned int DatatypeNamespaceUInt32 = FigMetadataKeyGetDatatypeNamespaceUInt32((const __CFDictionary *)v42);
    LODWORD(valuePtr) = DatatypeNamespaceUInt32;
    if (DatatypeNamespaceUInt32 == 1)
    {
      long long v50 = CFDictionaryGetValue((CFDictionaryRef)v42, @"MetadataKeyDataType");
      if (!v50) {
        goto LABEL_76;
      }
      long long v51 = v50;
      CFTypeID v52 = CFDataGetTypeID();
      if (v52 != CFGetTypeID(v51)) {
        goto LABEL_76;
      }
      CFStringRef v53 = CFStringCreateFromExternalRepresentation(alloc, (CFDataRef)v51, 0x600u);
      goto LABEL_72;
    }
    if (DatatypeNamespaceUInt32) {
      goto LABEL_76;
    }
    uint64_t v45 = CFDictionaryGetValue((CFDictionaryRef)v42, @"MetadataKeyDataType");
    if (!v45) {
      goto LABEL_76;
    }
    CFStringRef v46 = v45;
    CFTypeID v47 = CFDataGetTypeID();
    if (v47 != CFGetTypeID(v46) || CFDataGetLength((CFDataRef)v46) != 4) {
      goto LABEL_76;
    }
    int v78 = bswap32(*(_DWORD *)CFDataGetBytePtr((CFDataRef)v46));
    uint64_t v48 = CFDictionaryGetValue((CFDictionaryRef)sWellKnownTypeToCanonicalMap, (const void *)v78);
    if (!v48 || (long long v49 = (__CFDictionary *)CFRetain(v48)) == 0)
    {
      CFStringRef v53 = FigMetadataCreateDynamicBaseDataType(alloc, v78);
LABEL_72:
      CFMutableStringRef v15 = (__CFDictionary *)v53;
      if (v53) {
        goto LABEL_73;
      }
      goto LABEL_76;
    }
    CFMutableStringRef v15 = v49;
LABEL_73:
    if (!v12)
    {
      CFMutableArrayRef v12 = CFArrayCreateMutable(allocator, v39, MEMORY[0x1E4F1D510]);
      if (!v12)
      {
        uint64_t v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
        goto LABEL_159;
      }
    }
    CFArrayAppendValue(v12, v15);
    CFRelease(v15);
LABEL_76:
    if (v39 != ++v40) {
      continue;
    }
    break;
  }
  CFArrayRef v20 = theArraya;
  if (!v12)
  {
    CFMutableStringRef v15 = v74;
    __int16 v14 = v75;
    CFDictionaryRef v13 = v80;
    a1 = alloc;
    goto LABEL_84;
  }
  CFMutableStringRef v15 = v74;
  __int16 v14 = v75;
  CFRange v54 = v72;
  CFDictionaryRef v13 = v80;
  a1 = alloc;
  if (v72 || (CFRange v54 = CFDictionaryCreateMutable(alloc, capacity, 0, MEMORY[0x1E4F1D540])) != 0)
  {
    long long v72 = v54;
    CFDictionaryAddValue(v54, (const void *)HIDWORD(valuePtr), v12);
    goto LABEL_84;
  }
  uint64_t v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
  CFMutableStringRef v15 = 0;
  CFDictionaryRef v13 = 0;
  int v63 = 0;
LABEL_116:
  if (v17) {
    CFRelease(v17);
  }
LABEL_118:
  if (cf) {
    CFRelease(cf);
  }
  if (DynamicBaseDataType) {
    CFRelease(DynamicBaseDataType);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v80) {
    CFRelease(v80);
  }
  if (v79) {
    CFRelease(v79);
  }
  if (v77) {
    CFRelease(v77);
  }
  if (v63) {
    CFRelease(v63);
  }
  if (v74) {
    CFRelease(v74);
  }
  if (v75) {
    CFRelease(v75);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v65;
}

OSStatus CMMetadataFormatDescriptionCreateWithKeys(CFAllocatorRef allocator, CMMetadataFormatType metadataType, CFArrayRef keys, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  if (metadataType != 1835360888 && keys == 0) {
    return CMFormatDescriptionCreate(allocator, 0x6D657461u, metadataType, 0, formatDescriptionOut);
  }
  else {
    return FigMetadataFormatDescriptionCreateWithKeysAndDependencies(allocator, metadataType, keys, 0, 0, (uint64_t *)formatDescriptionOut);
  }
}

uint64_t FigMetadataFormatDescriptionCreateWithExtensions(const __CFAllocator *a1, FourCharCode a2, CFTypeRef cf, uint64_t *a4)
{
  if (!a4)
  {
    uint64_t v20 = 4294954586;
    goto LABEL_15;
  }
  *a4 = 0;
  if (!a2)
  {
LABEL_13:
    uint64_t v20 = 4294954586;
LABEL_15:
    return FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
  }
  if (a2 == 1835360888 && cf)
  {
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 == CFDictionaryGetTypeID())
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, @"MetadataKeyTable");
      if (Value)
      {
        CFDictionaryRef v10 = Value;
        CFTypeID v11 = CFGetTypeID(Value);
        if (v11 == CFDictionaryGetTypeID())
        {
          CFIndex Count = CFDictionaryGetCount(v10);
          CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, Count, MEMORY[0x1E4F1D510]);
          if (Mutable)
          {
            CFArrayRef v14 = Mutable;
            CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)appendValuesToArray_dictionaryCallback, Mutable);
            CFStringRef v15 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"MetadataPrimaryLocalIDs");
            char v16 = (void *)CFDictionaryGetValue((CFDictionaryRef)cf, @"MetadataLocalIDDependencyLists");
            uint64_t v17 = FigMetadataFormatDescriptionCreateWithKeysAndDependencies(a1, 1835360888, v14, v15, v16, a4);
            CFRelease(v14);
            return v17;
          }
          uint64_t v20 = 4294954585;
          goto LABEL_15;
        }
      }
    }
    goto LABEL_13;
  }
  FigThreadRunOnce(&sFigMetadataFormatDescriptionRegisterOnce, (void (*)(void))FigMetadataFormatDescriptionRegisterOnce);
  CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];

  return CMFormatDescriptionCreate(v19, 0x6D657461u, a2, (CFDictionaryRef)cf, (CMFormatDescriptionRef *)a4);
}

void appendValuesToArray_dictionaryCallback(int a1, const void *a2, CFMutableArrayRef theArray)
{
}

OSStatus CMMetadataFormatDescriptionCreateWithMetadataSpecifications(CFAllocatorRef allocator, CMMetadataFormatType metadataType, CFArrayRef metadataSpecifications, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  if (metadataSpecifications)
  {
    if (CFArrayGetCount(metadataSpecifications))
    {
      CFIndex Count = CFArrayGetCount(metadataSpecifications);
      CFArrayRef Mutable = CFArrayCreateMutable(allocator, Count, MEMORY[0x1E4F1D510]);
      if (Mutable)
      {
        CFArrayRef v10 = Mutable;
        OSStatus v11 = metadataFormatDescriptionCreateWithMetadataSpecifications(allocator, metadataType, 1u, metadataSpecifications, Mutable, 0, 0, (uint64_t *)formatDescriptionOut);
        CFRelease(v10);
        return v11;
      }
      uint64_t v13 = 4294954585;
    }
    else
    {
      uint64_t v13 = 4294954586;
    }
  }
  else
  {
    uint64_t v13 = 4294954586;
  }

  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

uint64_t metadataFormatDescriptionCreateWithMetadataSpecifications(const __CFAllocator *a1, int a2, unsigned int a3, const __CFArray *a4, CFArrayRef theArray, const __CFArray *a6, const __CFDictionary *a7, uint64_t *a8)
{
  CFIndex Count = CFArrayGetCount(theArray);
  v45[0] = 1;
  if (a8 && a2 == 1835360888)
  {
    uint64_t v16 = Count;
    CFArrayRef v36 = a6;
    CFDictionaryRef v17 = a7;
    CFIndex capacity = 0;
    long long v42 = 0u;
    long long v43 = 0u;
    long long context = 0u;
    LODWORD(valuePtr[0]) = 0;
    CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v19 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, valuePtr);
    CFNumberRef v20 = CFNumberCreate(v18, kCFNumberSInt32Type, v45);
    CFIndex v21 = CFArrayGetCount(a4);
    LODWORD(CFDictionaryApplyFunction(theDict, applier, context) = 0;
    *((void *)&context + 1) = a1;
    *(void *)&long long v42 = a3 | 0x6D65627800000000;
    CFNumberRef v37 = v19;
    *((void *)&v42 + 1) = v19;
    CFNumberRef v22 = v20;
    CFIndex v23 = v21;
    *(void *)&long long v43 = v22;
    *((void *)&v43 + 1) = theArray;
    LODWORD(capacity) = 0;
    v47.CFIndex location = 0;
    v47.CFIndex length = v21;
    CFArrayApplyFunction(a4, v47, (CFArrayApplierFunction)metadataFormatDescriptionCreateWithMetadataSpecifications1_arrayCallback, &context);
    uint64_t v24 = context;
    if (context)
    {
      long long v29 = 0;
      CFMutableDictionaryRef MutableCopy = 0;
      goto LABEL_22;
    }
    if (capacity)
    {
      CFTypeRef cf = 0;
      valuePtr[0] = 0;
      if (v36 && v17)
      {
        CFIndex v25 = CFArrayGetCount(v36);
        CFMutableDictionaryRef MutableCopy = CFArrayCreateMutableCopy(a1, v25 + v23, v36);
        CFIndex v27 = CFDictionaryGetCount(v17);
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutableCopy(a1, v27 + capacity, v17);
      }
      else
      {
        CFMutableDictionaryRef MutableCopy = CFArrayCreateMutable(a1, v23 + v16, MEMORY[0x1E4F1D510]);
        if (v16 >= 1)
        {
          for (CFIndex i = 0; i != v16; ++i)
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
            CFDictionaryRef Value = CFDictionaryGetValue(ValueAtIndex, @"MetadataKeyLocalID");
            if (Value) {
              CFArrayAppendValue(MutableCopy, Value);
            }
          }
        }
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, capacity, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
      long long v29 = Mutable;
      uint64_t v34 = FigMetadataFormatDescriptionCreateWithKeysAndDependencies(a1, 1835360888, theArray, 0, 0, (uint64_t *)&cf);
      if (v34) {
        goto LABEL_21;
      }
      LODWORD(valuePtr[0]) = 0;
      valuePtr[1] = a1;
      valuePtr[2] = cf;
      _OWORD valuePtr[3] = MutableCopy;
      valuePtr[4] = v29;
      valuePtr[5] = 0;
      v48.CFIndex location = 0;
      v48.CFIndex length = v23;
      CFArrayApplyFunction(a4, v48, (CFArrayApplierFunction)metadataFormatDescriptionCreateWithMetadataSpecifications2_arrayCallback, valuePtr);
      CFRelease(cf);
      uint64_t v24 = LODWORD(valuePtr[0]);
      if (LODWORD(valuePtr[0]))
      {
LABEL_22:
        if (v37) {
          CFRelease(v37);
        }
        if (v22) {
          CFRelease(v22);
        }
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        if (v29) {
          CFRelease(v29);
        }
        return v24;
      }
    }
    else
    {
      long long v29 = 0;
      if (v36)
      {
        CFMutableDictionaryRef MutableCopy = 0;
        long long v30 = a8;
        if (v17)
        {
          CFMutableDictionaryRef MutableCopy = (__CFArray *)CFRetain(v36);
          long long v29 = (void *)CFRetain(v17);
        }
        goto LABEL_20;
      }
      CFMutableDictionaryRef MutableCopy = 0;
    }
    long long v30 = a8;
LABEL_20:
    uint64_t v34 = FigMetadataFormatDescriptionCreateWithKeysAndDependencies(a1, 1835360888, theArray, (const __CFString *)MutableCopy, v29, v30);
LABEL_21:
    uint64_t v24 = v34;
    goto LABEL_22;
  }

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

CFDictionaryRef FigMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors(const opaqueCMFormatDescription *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (a1
    && (uint64_t v9 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
    && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
    && a2
    && a3)
  {
    uint64_t v12 = 0;
    CFDictionaryRef result = *(const __CFDictionary **)(v9 + 16);
    if (result)
    {
      v11[0] = a2;
      v11[1] = a3;
      _DWORD v11[2] = a4;
      HIDWORD(v12) = 0;
      LOBYTE(v12) = 0;
      CFDictionaryApplyFunction(result, (CFDictionaryApplierFunction)figMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors_dictionaryCallback, v11);
      return (const __CFDictionary *)HIDWORD(v12);
    }
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

uint64_t figMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors_dictionaryCallback(uint64_t result, CFDictionaryRef theDict, uint64_t a3)
{
  if (!*(_DWORD *)(a3 + 28))
  {
    int v5 = result;
    CFDictionaryRef Value = CFDictionaryGetValue(theDict, @"MetadataIdentifier");
    CFDictionaryRef result = FigCFEqual(Value, *(CFTypeRef *)a3);
    if (result)
    {
      if (*(unsigned char *)(a3 + 24)
        || (int v7 = CFDictionaryGetValue(theDict, @"MetadataDataType"),
            CFDictionaryRef result = FigCFEqual(v7, *(CFTypeRef *)(a3 + 8)),
            result)
        && (CFTypeID v8 = CFDictionaryGetValue(theDict, @"MetadataExtendedLanguageTag"),
            CFDictionaryRef result = FigCFEqual(v8, *(CFTypeRef *)(a3 + 16)),
            result))
      {
        *(_DWORD *)(a3 + 28) = v5;
      }
    }
  }
  return result;
}

CFDictionaryRef FigMetadataFormatDescriptionGetFirstLocalIDForIdentifier(const opaqueCMFormatDescription *a1, uint64_t a2)
{
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (a1
    && (uint64_t v5 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
    && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
    && a2)
  {
    uint64_t v8 = 0;
    CFDictionaryRef result = *(const __CFDictionary **)(v5 + 16);
    if (result)
    {
      HIDWORD(v8) = 0;
      v7[1] = 0;
      v7[2] = 0;
      v7[0] = a2;
      LOBYTE(v8) = 1;
      CFDictionaryApplyFunction(result, (CFDictionaryApplierFunction)figMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors_dictionaryCallback, v7);
      return (const __CFDictionary *)HIDWORD(v8);
    }
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

const void *FigMetadataFormatDescriptionGetIdentifierForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  return getIdentifyingFactorForLocalID(a1, a2, @"MetadataIdentifier");
}

const void *getIdentifyingFactorForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2, const void *a3)
{
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (!a1
    || (uint64_t v7 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) != 1835365473)
    || CMFormatDescriptionGetMediaSubType(a1) != 1835360888
    || !a2)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  CFDictionaryRef v8 = *(const __CFDictionary **)(v7 + 16);
  if (!v8) {
    return 0;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v8, (const void *)a2);
  if (!Value) {
    return 0;
  }

  return CFDictionaryGetValue(Value, a3);
}

const void *FigMetadataFormatDescriptionGetDataTypeForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  return getIdentifyingFactorForLocalID(a1, a2, @"MetadataDataType");
}

const void *FigMetadataFormatDescriptionGetLanguageTagForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  return getIdentifyingFactorForLocalID(a1, a2, @"MetadataExtendedLanguageTag");
}

const void *FigMetadataFormatDescriptionGetConformingDataTypesForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (!a1
    || (uint64_t v5 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) != 1835365473)
    || CMFormatDescriptionGetMediaSubType(a1) != 1835360888
    || !a2)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  CFDictionaryRef v6 = *(const __CFDictionary **)(v5 + 24);
  if (!v6) {
    return 0;
  }

  return CFDictionaryGetValue(v6, (const void *)a2);
}

CFDictionaryRef FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (a1
    && (uint64_t v5 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
    && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
    && a2)
  {
    CFDictionaryRef result = *(const __CFDictionary **)(v5 + 32);
    if (result)
    {
      CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetCountOfKey(result, (const void *)a2);
      if (result) {
        return (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 32), (const void *)a2);
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

const void *FigMetadataFormatDescriptionGetSetupDataForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (!a1
    || (uint64_t v5 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) != 1835365473)
    || CMFormatDescriptionGetMediaSubType(a1) != 1835360888
    || !a2)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  CFDictionaryRef v6 = *(const __CFDictionary **)(v5 + 8);
  if (!v6) {
    return 0;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v6, (const void *)a2);
  if (!Value) {
    return 0;
  }

  return CFDictionaryGetValue(Value, @"MetadataKeySetupData");
}

uint64_t FigMetadataFormatDescriptionQuickTimeWellKnownTypeIsRecognized(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  unsigned int QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(a1, a2);
  if (QuickTimeWellKnownTypeForLocalID)
  {
    signed int v5 = QuickTimeWellKnownTypeForLocalID;
    FigThreadRunOnce(&sFigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce, FigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce);
    CFDictionaryRef v6 = (const __CFDictionary *)sWellKnownTypeToCanonicalMap;
    return CFDictionaryContainsKey(v6, (const void *)v5);
  }
  else
  {
    uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
    if (a1
      && (uint64_t v9 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
      && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
      && a2)
    {
      CFArrayRef v10 = *(const __CFArray **)(v9 + 40);
      if (v10)
      {
        v12.CFIndex length = CFArrayGetCount(*(CFArrayRef *)(v9 + 40));
        v12.CFIndex location = 0;
        return CFArrayContainsValue(v10, v12, (const void *)a2) == 0;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      return 0;
    }
  }
}

OSStatus CMMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications(CFAllocatorRef allocator, CMMetadataFormatDescriptionRef sourceDescription, CFArrayRef metadataSpecifications, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  if (metadataSpecifications)
  {
    if (sourceDescription
      && CMFormatDescriptionGetMediaSubType(sourceDescription) == 1835360888
      && (CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(sourceDescription)) != 0
      && (CFDictionaryRef v9 = Extensions,
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"MetadataKeyTable"),
          CFArrayRef v11 = (const __CFArray *)CFDictionaryGetValue(v9, @"MetadataPrimaryLocalIDs"),
          CFDictionaryRef v12 = (const __CFDictionary *)CFDictionaryGetValue(v9, @"MetadataLocalIDDependencyLists"),
          Value))
    {
      CFDictionaryRef v13 = v12;
      CFIndex Count = CFArrayGetCount(metadataSpecifications);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, Count, MEMORY[0x1E4F1D510]);
      if (Mutable)
      {
        CFArrayRef v16 = Mutable;
        uint64_t v26 = 0;
        context[0] = sourceDescription;
        context[1] = Mutable;
        v29.CFIndex length = CFArrayGetCount(metadataSpecifications);
        v29.CFIndex location = 0;
        CFArrayApplyFunction(metadataSpecifications, v29, (CFArrayApplierFunction)figMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications_arrayCallback, context);
        if (CFArrayGetCount(v16))
        {
          CFIndex v17 = CFArrayGetCount(metadataSpecifications);
          CFIndex v18 = CFDictionaryGetCount(Value);
          CFMutableArrayRef v19 = CFArrayCreateMutable(allocator, v18 + v17, MEMORY[0x1E4F1D510]);
          if (v19)
          {
            CFArrayRef v20 = v19;
            CFMutableArrayRef v25 = v19;
            LODWORD(v26) = 0;
            CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications_dictionaryCallback, &v25);
            OSStatus v21 = metadataFormatDescriptionCreateWithMetadataSpecifications(allocator, 1835360888, (int)v26 + 1, v16, v20, v11, v13, (uint64_t *)formatDescriptionOut);
            CFRelease(v16);
            CFArrayRef v22 = v20;
LABEL_16:
            CFRelease(v22);
            return v21;
          }
          OSStatus v21 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
        }
        else
        {
          OSStatus v21 = 0;
          *CMVideoFormatDescriptionRef formatDescriptionOut = (CMMetadataFormatDescriptionRef)CFRetain(sourceDescription);
        }
        CFArrayRef v22 = v16;
        goto LABEL_16;
      }
      uint64_t v23 = 4294954585;
    }
    else
    {
      uint64_t v23 = 4294954586;
    }
  }
  else
  {
    uint64_t v23 = 4294954586;
  }

  return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
}

void figMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications_arrayCallback(const __CFDictionary *a1, const opaqueCMFormatDescription **a2)
{
  CFArrayRef v4 = *a2;
  CFDictionaryRef Value = CFDictionaryGetValue(a1, @"MetadataIdentifier");
  CFDictionaryRef v6 = CFDictionaryGetValue(a1, @"MetadataDataType");
  uint64_t v7 = CFDictionaryGetValue(a1, @"MetadataExtendedLanguageTag");
  if (!FigMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors(v4, (uint64_t)Value, (uint64_t)v6, (uint64_t)v7))
  {
    CFDictionaryRef v8 = a2[1];
    CFArrayAppendValue(v8, a1);
  }
}

void figMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications_dictionaryCallback(const __CFString *a1, const void *a2, uint64_t a3)
{
  int valuePtr = -1;
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    SInt32 IntValue = CFStringGetIntValue(a1);
LABEL_5:
    int valuePtr = IntValue;
    goto LABEL_7;
  }
  CFTypeID v8 = CFNumberGetTypeID();
  if (v8 == CFGetTypeID(a1))
  {
    SInt32 IntValue = CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  SInt32 IntValue = -1;
LABEL_7:
  if (*(_DWORD *)(a3 + 8) < IntValue) {
    *(_DWORD *)(a3 + 8) = IntValue;
  }
  if (a2) {
    CFArrayAppendValue(*(CFMutableArrayRef *)a3, a2);
  }
}

OSStatus CMMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions(CFAllocatorRef allocator, CMMetadataFormatDescriptionRef sourceDescription, CMMetadataFormatDescriptionRef otherSourceDescription, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  if (sourceDescription)
  {
    FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(sourceDescription);
    if (!otherSourceDescription) {
      goto LABEL_24;
    }
    FourCharCode v9 = MediaSubType;
    if (MediaSubType != CMFormatDescriptionGetMediaSubType(otherSourceDescription)) {
      goto LABEL_24;
    }
    if (v9 == 1768126752 || v9 == 1768174368 || CMFormatDescriptionEqual(sourceDescription, otherSourceDescription))
    {
      OSStatus v10 = 0;
      *CMVideoFormatDescriptionRef formatDescriptionOut = (CMMetadataFormatDescriptionRef)CFRetain(sourceDescription);
      return v10;
    }
    if (v9 != 1835360888) {
      goto LABEL_24;
    }
    CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(sourceDescription);
    if (!Extensions) {
      goto LABEL_24;
    }
    CFDictionaryRef v13 = Extensions;
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"MetadataKeyTable");
    CFArrayRef v15 = (const __CFArray *)CFDictionaryGetValue(v13, @"MetadataPrimaryLocalIDs");
    CFDictionaryRef v41 = (const __CFDictionary *)CFDictionaryGetValue(v13, @"MetadataLocalIDDependencyLists");
    if (!Value) {
      goto LABEL_24;
    }
    CFDictionaryRef v16 = CMFormatDescriptionGetExtensions(otherSourceDescription);
    if (v16
      && (CFDictionaryRef v17 = v16,
          CFDictionaryRef v18 = (const __CFDictionary *)CFDictionaryGetValue(v16, @"MetadataKeyTable"),
          CFArrayRef v19 = (const __CFArray *)CFDictionaryGetValue(v17, @"MetadataPrimaryLocalIDs"),
          CFDictionaryRef theDict = (const __CFDictionary *)CFDictionaryGetValue(v17, @"MetadataLocalIDDependencyLists"),
          v18))
    {
      CFIndex Count = CFDictionaryGetCount(v18);
      CFIndex v21 = CFDictionaryGetCount(Value);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, v21 + Count, MEMORY[0x1E4F1D510]);
      if (Mutable)
      {
        CFArrayRef v23 = Mutable;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        uint64_t v50 = 0;
        CFArrayRef v45 = 0;
        CFMutableDictionaryRef v46 = 0;
        CFMutableArrayRef context = Mutable;
        uint64_t v52 = 0;
        CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback1, &context);
        CFMutableDictionaryRef v43 = CFDictionaryCreateMutable(allocator, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (!v43
          || (CFMutableDictionaryRef v24 = CFDictionaryCreateMutable(allocator, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) == 0)
        {
          OSStatus v10 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
          CFMutableDictionaryRef v25 = 0;
          uint64_t v32 = v23;
          CFMutableDictionaryRef v36 = v43;
LABEL_45:
          CFRelease(v32);
LABEL_46:
          if (v36) {
            CFRelease(v36);
          }
          if (v25) {
            CFRelease(v25);
          }
          return v10;
        }
        CFMutableDictionaryRef v25 = v24;
        *(void *)&long long v47 = allocator;
        *((void *)&v47 + 1) = v23;
        *(void *)&long long v48 = sourceDescription;
        *((void *)&v48 + 1) = otherSourceDescription;
        LODWORD(v50) = v52 + 1;
        *(void *)&long long v49 = v43;
        *((void *)&v49 + 1) = v24;
        CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback2, &v47);
        if (v19 && theDict)
        {
          CFIndex v26 = CFArrayGetCount(v19);
          CFIndex v27 = CFDictionaryGetCount(theDict);
          if (!v15 || !v41)
          {
            CFIndex v37 = CFDictionaryGetCount(Value);
            CFArrayRef MutableCopy = CFArrayCreateMutable(allocator, v37 + v26, MEMORY[0x1E4F1D510]);
            uint64_t v32 = CFDictionaryCreateMutable(allocator, v27, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CFArrayRef v45 = MutableCopy;
            CFMutableDictionaryRef v46 = 0;
            CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback3, &v45);
            goto LABEL_34;
          }
          CFIndex v28 = CFArrayGetCount(v15);
          CFArrayRef MutableCopy = CFArrayCreateMutableCopy(allocator, v28 + v26, v15);
          if (MutableCopy)
          {
            CFIndex v30 = CFDictionaryGetCount(v41);
            CFMutableDictionaryRef v31 = CFDictionaryCreateMutableCopy(allocator, v30 + v27, v41);
            if (v31)
            {
              uint64_t v32 = v31;
LABEL_34:
              if (v26 >= 1)
              {
                for (CFIndex i = 0; i != v26; ++i)
                {
                  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v19, i);
                  CFIndex v40 = CFDictionaryGetValue(v25, ValueAtIndex);
                  if (v40) {
                    CFDictionaryRef ValueAtIndex = v40;
                  }
                  v54.CFIndex length = CFArrayGetCount(MutableCopy);
                  v54.CFIndex location = 0;
                  if (!CFArrayContainsValue(MutableCopy, v54, ValueAtIndex)) {
                    CFArrayAppendValue(MutableCopy, ValueAtIndex);
                  }
                }
              }
              v44[0] = allocator;
              v44[1] = v32;
              CFMutableDictionaryRef v36 = v43;
              v44[2] = v43;
              v44[3] = v25;
              CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback4, v44);
              OSStatus v10 = FigMetadataFormatDescriptionCreateWithKeysAndDependencies(allocator, 1835360888, v23, (const __CFString *)MutableCopy, v32, (uint64_t *)formatDescriptionOut);
LABEL_42:
              CFRelease(v23);
              if (MutableCopy) {
                CFRelease(MutableCopy);
              }
              if (!v32) {
                goto LABEL_46;
              }
              goto LABEL_45;
            }
          }
          OSStatus v10 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
          uint64_t v32 = 0;
        }
        else
        {
          CFArrayRef MutableCopy = 0;
          uint64_t v32 = 0;
          if (v15 && v41)
          {
            CFIndex v34 = CFArrayGetCount(v15);
            CFIndex v35 = CFDictionaryGetCount(v18);
            CFArrayRef MutableCopy = CFArrayCreateMutableCopy(allocator, v35 + v34, v15);
            uint64_t v32 = (void *)CFRetain(v41);
            CFArrayRef v45 = MutableCopy;
            CFMutableDictionaryRef v46 = v25;
            CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback3, &v45);
          }
          OSStatus v10 = FigMetadataFormatDescriptionCreateWithKeysAndDependencies(allocator, 1835360888, v23, (const __CFString *)MutableCopy, v32, (uint64_t *)formatDescriptionOut);
        }
        CFMutableDictionaryRef v36 = v43;
        goto LABEL_42;
      }
      uint64_t v33 = 4294954585;
    }
    else
    {
LABEL_24:
      uint64_t v33 = 4294954586;
    }
  }
  else
  {
    uint64_t v33 = 4294954586;
  }

  return FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
}

void figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback1(const __CFString *a1, const void *a2, uint64_t a3)
{
  int valuePtr = -1;
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    SInt32 IntValue = CFStringGetIntValue(a1);
LABEL_5:
    int valuePtr = IntValue;
    goto LABEL_7;
  }
  CFTypeID v8 = CFNumberGetTypeID();
  if (v8 == CFGetTypeID(a1))
  {
    SInt32 IntValue = CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  SInt32 IntValue = -1;
LABEL_7:
  if (*(_DWORD *)(a3 + 8) < IntValue) {
    *(_DWORD *)(a3 + 8) = IntValue;
  }
  if (a2) {
    CFArrayAppendValue(*(CFMutableArrayRef *)a3, a2);
  }
}

void figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback2(const __CFString *a1, const __CFDictionary *a2, uint64_t a3)
{
  HIDWORD(v24) = -1;
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    SInt32 IntValue = CFStringGetIntValue(a1);
LABEL_5:
    unsigned int v9 = IntValue;
    HIDWORD(v24) = IntValue;
    goto LABEL_7;
  }
  CFTypeID v8 = CFNumberGetTypeID();
  if (v8 == CFGetTypeID(a1))
  {
    SInt32 IntValue = CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, (char *)&v24 + 4);
    goto LABEL_5;
  }
  unsigned int v9 = -1;
LABEL_7:
  OSStatus v10 = *(const opaqueCMFormatDescription **)(a3 + 16);
  IdentifyingFactorForLocalID = getIdentifyingFactorForLocalID(*(const opaqueCMFormatDescription **)(a3 + 24), v9, @"MetadataIdentifier");
  CFDictionaryRef v12 = getIdentifyingFactorForLocalID(*(const opaqueCMFormatDescription **)(a3 + 24), HIDWORD(v24), @"MetadataDataType");
  CFDictionaryRef v13 = getIdentifyingFactorForLocalID(*(const opaqueCMFormatDescription **)(a3 + 24), HIDWORD(v24), @"MetadataExtendedLanguageTag");
  CFDictionaryRef LocalIDForMetadataIdentifyingFactors = FigMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors(v10, (uint64_t)IdentifyingFactorForLocalID, (uint64_t)v12, (uint64_t)v13);
  int v15 = (int)LocalIDForMetadataIdentifyingFactors;
  if (LocalIDForMetadataIdentifyingFactors)
  {
    LODWORD(v24) = LocalIDForMetadataIdentifyingFactors;
    CFDictionaryRef v16 = LocalIDForMetadataIdentifyingFactors;
    if (LocalIDForMetadataIdentifyingFactors == HIDWORD(v24)) {
      return;
    }
LABEL_13:
    CFStringRef v18 = CFStringCreateWithFormat(*(CFAllocatorRef *)a3, 0, @"%d", v16, v24);
    CFNumberRef v19 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v24);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 32), a1, v18);
    CFArrayRef v20 = *(__CFDictionary **)(a3 + 40);
    CFDictionaryRef Value = CFDictionaryGetValue(a2, @"MetadataKeyLocalID");
    CFDictionarySetValue(v20, Value, v19);
    CFArrayRef MutableCopy = 0;
    if (!v15)
    {
      CFAllocatorRef v22 = *(const __CFAllocator **)a3;
      CFIndex Count = CFDictionaryGetCount(a2);
      CFArrayRef MutableCopy = CFDictionaryCreateMutableCopy(v22, Count, a2);
      CFDictionarySetValue(MutableCopy, @"MetadataKeyLocalID", v19);
    }
    CFRelease(v18);
    CFRelease(v19);
    if (MutableCopy) {
      goto LABEL_16;
    }
    return;
  }
  CFDictionaryRef v16 = (const __CFDictionary *)*(unsigned int *)(a3 + 48);
  *(_DWORD *)(a3 + 48) = v16 + 1;
  LODWORD(v24) = v16;
  if (v16 != HIDWORD(v24)) {
    goto LABEL_13;
  }
  CFArrayRef MutableCopy = (__CFDictionary *)CFRetain(a2);
  if (MutableCopy)
  {
LABEL_16:
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 8), MutableCopy);
    CFRelease(MutableCopy);
  }
}

void figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback3(int a1, CFDictionaryRef theDict, const __CFArray **a3)
{
  CFDictionaryRef Value = CFDictionaryGetValue(theDict, @"MetadataKeyLocalID");
  CFDictionaryRef v5 = a3[1];
  if (v5) {
    CFDictionaryRef v5 = (const __CFDictionary *)CFDictionaryGetValue(v5, Value);
  }
  if (v5) {
    CFDictionaryRef Value = v5;
  }
  CFArrayRef v6 = *a3;
  v9.CFIndex length = CFArrayGetCount(*a3);
  v9.CFIndex location = 0;
  if (!CFArrayContainsValue(v6, v9, Value))
  {
    uint64_t v7 = *a3;
    CFArrayAppendValue(v7, Value);
  }
}

void figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback4(const void *a1, CFArrayRef theArray, CFAllocatorRef *a3)
{
  uint64_t Count = CFArrayGetCount(theArray);
  CFArrayRef Mutable = CFArrayCreateMutable(*a3, Count, MEMORY[0x1E4F1D510]);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
      CFDictionaryRef Value = CFDictionaryGetValue(a3[3], ValueAtIndex);
      if (Value)
      {
        CFArrayRef v11 = Value;
        CFDictionaryRef v12 = Mutable;
      }
      else
      {
        CFDictionaryRef v12 = Mutable;
        CFArrayRef v11 = ValueAtIndex;
      }
      CFArrayAppendValue(v12, v11);
    }
  }
  CFDictionaryRef v13 = CFDictionaryGetValue(a3[2], a1);
  if (v13) {
    a1 = v13;
  }
  CFArrayRef v14 = (const __CFArray *)CFDictionaryGetValue(a3[1], a1);
  if (v14)
  {
    CFArrayRef v15 = v14;
    CFIndex v16 = CFArrayGetCount(v14);
    CFIndex v17 = CFArrayGetCount(Mutable);
    CFArrayRef MutableCopy = CFArrayCreateMutableCopy(*a3, v17 + v16, v15);
    if (v17 >= 1)
    {
      for (CFIndex j = 0; j != v17; ++j)
      {
        CFArrayRef v20 = CFArrayGetValueAtIndex(Mutable, j);
        v22.CFIndex location = 0;
        v22.CFIndex length = v16;
        if (!CFArrayContainsValue(v15, v22, v20)) {
          CFArrayAppendValue(MutableCopy, v20);
        }
      }
    }
    CFDictionarySetValue(a3[1], a1, MutableCopy);
    CFRelease(MutableCopy);
  }
  else
  {
    CFDictionarySetValue(a3[1], a1, Mutable);
  }

  CFRelease(Mutable);
}

CFDictionaryRef CMMetadataFormatDescriptionGetKeyWithLocalID(CMMetadataFormatDescriptionRef desc, OSType localKeyID)
{
  if (!desc
    || CMFormatDescriptionGetMediaType(desc) != 1835365473
    || CMFormatDescriptionGetMediaSubType(desc) != 1835360888)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
  if (!DerivedStorage) {
    return 0;
  }
  CFDictionaryRef v5 = *(const __CFDictionary **)(DerivedStorage + 8);
  if (!v5) {
    return 0;
  }

  return (CFDictionaryRef)CFDictionaryGetValue(v5, (const void *)localKeyID);
}

CFArrayRef CMMetadataFormatDescriptionGetIdentifiers(CMMetadataFormatDescriptionRef desc)
{
  if (desc
    && CMFormatDescriptionGetMediaType(desc) == 1835365473
    && CMFormatDescriptionGetMediaSubType(desc) == 1835360888)
  {
    CFArrayRef result = (CFArrayRef)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
    if (result) {
      return *(CFArrayRef *)result;
    }
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

void figMetadataFormatDescriptionFinalize(uint64_t a1)
{
  uint64_t DerivedStorage = (const void **)FigDerivedFormatDescriptionGetDerivedStorage(a1);
  if (DerivedStorage)
  {
    uint64_t v2 = DerivedStorage;
    BOOL v3 = *DerivedStorage;
    if (v3) {
      CFRelease(v3);
    }
    CFArrayRef v4 = v2[1];
    if (v4) {
      CFRelease(v4);
    }
    CFDictionaryRef v5 = v2[2];
    if (v5) {
      CFRelease(v5);
    }
    CFArrayRef v6 = v2[3];
    if (v6) {
      CFRelease(v6);
    }
    uint64_t v7 = v2[4];
    if (v7) {
      CFRelease(v7);
    }
    CFTypeID v8 = v2[5];
    if (v8)
    {
      CFRelease(v8);
    }
  }
}

__CFString *figMetadataFormatDescriptionCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = (void *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFArrayRef Mutable = CFStringCreateMutable(v3, 0);
  CFDictionaryRef v5 = Mutable;
  if (*DerivedStorage) {
    CFStringAppendFormat(Mutable, 0, @"\t\tidentifierToDataTypes %p", *DerivedStorage);
  }
  if (DerivedStorage[1]) {
    CFStringAppendFormat(v5, 0, @"\t\tlocalKeyIDToKeyEntryMapping %p", DerivedStorage[1]);
  }
  if (DerivedStorage[2]) {
    CFStringAppendFormat(v5, 0, @"\t\tlocalKeyIDToMetadataSpecificationMapping %p", DerivedStorage[2]);
  }
  if (DerivedStorage[3]) {
    CFStringAppendFormat(v5, 0, @"\t\tlocalKeyIDToConformingDataTypes %p", DerivedStorage[3]);
  }
  if (DerivedStorage[4]) {
    CFStringAppendFormat(v5, 0, @"\t\tlocalKeyIDToQuickTimeWellKnownTypeMapping %p", DerivedStorage[4]);
  }
  if (DerivedStorage[5]) {
    CFStringAppendFormat(v5, 0, @"\t\tlocalKeyIDsThatDoNotHaveAWellKnownType %p", DerivedStorage[5]);
  }
  return v5;
}

uint64_t figMetadataFormatDescriptionEqual(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2, unint64_t a3, unint64_t a4)
{
  uint64_t DerivedStorage = (CFTypeRef *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
  OSStatus v10 = (CFTypeRef *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a2);
  CFDictionaryRef v11 = CMFormatDescriptionGetExtensions(a2);
  uint64_t result = FigCFEqual(*DerivedStorage, *v10);
  if (result)
  {
    uint64_t result = FigCFEqual(DerivedStorage[1], v10[1]);
    if (result)
    {
      uint64_t result = FigCFEqual(DerivedStorage[2], v10[2]);
      if (result)
      {
        uint64_t result = FigCFEqual(DerivedStorage[3], v10[3]);
        if (result)
        {
          uint64_t result = FigCFEqual(DerivedStorage[4], v10[4]);
          if (result)
          {
            uint64_t result = FigCFEqual(DerivedStorage[5], v10[5]);
            if (result) {
              return FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(Extensions, v11, a3, a4) != 0;
            }
          }
        }
      }
    }
  }
  return result;
}

void FigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce()
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v5 = @"com.apple.metadata.datatype.raw-data";
  int v6 = 0;
  uint64_t v7 = @"com.apple.metadata.datatype.UTF-8";
  int v8 = 1;
  CFRange v9 = @"com.apple.metadata.datatype.UTF-16";
  int v10 = 2;
  CFDictionaryRef v11 = @"com.apple.metadata.datatype.UTF-8-sort";
  int v12 = 4;
  CFDictionaryRef v13 = @"com.apple.metadata.datatype.UTF-16-sort";
  int v14 = 5;
  CFArrayRef v15 = @"com.apple.metadata.datatype.GIF";
  int v16 = 12;
  CFIndex v17 = @"com.apple.metadata.datatype.JPEG";
  int v18 = 13;
  CFNumberRef v19 = @"com.apple.metadata.datatype.PNG";
  CFIndex v21 = @"com.apple.metadata.datatype.UPC";
  int v20 = 14;
  int v22 = 25;
  CFArrayRef v23 = @"com.apple.metadata.datatype.BMP";
  CFMutableDictionaryRef v25 = @"com.apple.metadata.datatype.QuickTime-metadata-box";
  int v24 = 27;
  int v26 = 28;
  CFIndex v27 = @"com.apple.metadata.datatype.float32";
  CFRange v29 = @"com.apple.metadata.datatype.float64";
  int v28 = 23;
  int v30 = 24;
  CFMutableDictionaryRef v31 = @"com.apple.metadata.datatype.pixel-density";
  uint64_t v33 = @"com.apple.metadata.datatype.int8";
  int v32 = 30;
  int v34 = 65;
  CFIndex v35 = @"com.apple.metadata.datatype.int16";
  CFIndex v37 = @"com.apple.metadata.datatype.int32";
  int v36 = 66;
  int v38 = 67;
  CFIndex v39 = @"com.apple.metadata.datatype.int64";
  int v40 = 74;
  CFDictionaryRef v41 = @"com.apple.metadata.datatype.uint8";
  int v42 = 75;
  CFMutableDictionaryRef v43 = @"com.apple.metadata.datatype.uint16";
  int v44 = 76;
  CFArrayRef v45 = @"com.apple.metadata.datatype.uint32";
  int v46 = 77;
  long long v47 = @"com.apple.metadata.datatype.uint64";
  int v48 = 78;
  long long v49 = @"com.apple.metadata.datatype.array-collection";
  int v50 = 68;
  long long v51 = @"com.apple.metadata.datatype.record-collection";
  int v52 = 69;
  CFStringRef v53 = @"com.apple.metadata.datatype.point-float32";
  int v54 = 70;
  int v55 = @"com.apple.metadata.datatype.dimensions-float32";
  int v56 = 71;
  CFMutableDictionaryRef v57 = @"com.apple.metadata.datatype.rectangle-float32";
  int v58 = 72;
  CFIndex v59 = @"com.apple.metadata.affine-transform-float64";
  int v60 = 79;
  CFDictionaryRef v61 = @"com.apple.metadata.datatype.polygon-float32";
  int v62 = 80;
  int v63 = @"com.apple.metadata.datatype.polyline-float32";
  int v64 = 81;
  uint64_t v65 = @"com.apple.metadata.datatype.JSON";
  int v66 = 82;
  long long v67 = @"com.apple.metadata.perspective-transform-float64";
  int v68 = 83;
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  int v1 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  sCanonicalToWellKnownTypeMap = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 32, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v2 = 0;
  sWellKnownTypeToCanonicalMap = (uint64_t)CFDictionaryCreateMutable(v0, 32, 0, v1);
  do
  {
    *(_DWORD *)bytes = bswap32(*(_DWORD *)((char *)&v5 + v2 + 8));
    CFDataRef v3 = CFDataCreate(v0, bytes, 4);
    CFDictionarySetValue((CFMutableDictionaryRef)sCanonicalToWellKnownTypeMap, *(__CFString **)((char *)&v5 + v2), v3);
    CFDictionarySetValue((CFMutableDictionaryRef)sWellKnownTypeToCanonicalMap, (const void *)*(int *)((char *)&v5 + v2 + 8), *(__CFString **)((char *)&v5 + v2));
    CFRelease(v3);
    v2 += 16;
  }
  while (v2 != 512);
}

void metadataFormatDescriptionCreateWithMetadataSpecifications1_arrayCallback(const void *a1, uint64_t a2)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a2) {
    return;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a1)) {
    goto LABEL_115;
  }
  CFAllocatorRef v5 = *(const __CFAllocator **)(a2 + 8);
  int v6 = *(_DWORD *)(a2 + 16);
  int v7 = *(_DWORD *)(a2 + 20);
  int v93 = *(const void **)(a2 + 24);
  CFArrayRef v8 = *(const __CFArray **)(a2 + 40);
  CFRange v91 = *(const void **)(a2 + 32);
  int valuePtr = 0;
  int v100 = v6;
  CFArrayRef theArray = v8;
  CFDataRef keyOut = 0;
  CFIndex Count = CFArrayGetCount(v8);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, @"MetadataIdentifier");
  if (!Value) {
    goto LABEL_30;
  }
  CFStringRef v11 = Value;
  CFTypeID v12 = CFStringGetTypeID();
  if (v12 != CFGetTypeID(v11)) {
    goto LABEL_30;
  }
  CFStringRef v13 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, @"MetadataDataType");
  if (!v13) {
    goto LABEL_30;
  }
  CFStringRef v14 = v13;
  CFTypeID v15 = CFStringGetTypeID();
  if (v15 != CFGetTypeID(v14)) {
    goto LABEL_30;
  }
  int v16 = CFDictionaryGetValue((CFDictionaryRef)a1, @"MetadataExtendedLanguageTag");
  if (v16)
  {
    CFTypeID v17 = CFStringGetTypeID();
    if (v17 != CFGetTypeID(v16)) {
      goto LABEL_30;
    }
  }
  CFStringRef dataType = v14;
  int v18 = CFDictionaryGetValue((CFDictionaryRef)a1, @"StructuralDependency");
  if (v18)
  {
    CFTypeID v19 = CFDictionaryGetTypeID();
    if (v19 != CFGetTypeID(v18)) {
      goto LABEL_30;
    }
  }
  int v20 = CFDictionaryGetValue((CFDictionaryRef)a1, @"MetadataKeySetupData");
  if (v20)
  {
    CFTypeID v21 = CFDataGetTypeID();
    if (v21 != CFGetTypeID(v20)) {
      goto LABEL_30;
    }
  }
  CFTypeRef v87 = v20;
  CFArrayRef v22 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1, @"MetadataConformingDataTypes");
  CFTypeRef v88 = v16;
  CFStringRef v86 = (void *)v18;
  if (v22)
  {
    CFArrayRef v23 = v22;
    CFTypeID v24 = CFArrayGetTypeID();
    if (v24 == CFGetTypeID(v23))
    {
      CFIndex v25 = CFArrayGetCount(v23);
      if (v25) {
        CFArrayRef ConformingDataTypes = v23;
      }
      else {
        CFArrayRef ConformingDataTypes = 0;
      }
      CFStringRef v27 = dataType;
      CFStringRef BaseDataTypeForConformingDataType = CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(dataType);
      if (BaseDataTypeForConformingDataType)
      {
        CFStringRef v29 = BaseDataTypeForConformingDataType;
        goto LABEL_23;
      }
      if (v25 >= 1)
      {
        CFIndex v33 = 0;
        while (1)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ConformingDataTypes, v33);
          CFStringRef v35 = CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(ValueAtIndex);
          if (v35) {
            break;
          }
          if (v25 == ++v33) {
            goto LABEL_30;
          }
        }
        CFStringRef v29 = v35;
        CFStringRef v27 = dataType;
        if (v7 != 1835360888) {
          goto LABEL_72;
        }
        goto LABEL_24;
      }
    }
LABEL_30:
    uint64_t v36 = 4294954586;
LABEL_73:
    int v40 = FigSignalErrorAt(v36, 0, 0, 0, 0, 0, 0);
    long long v72 = 0;
    int v75 = 0;
    CFIndex v59 = 0;
    CFDataRef v38 = 0;
    goto LABEL_74;
  }
  CFStringRef v30 = CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(dataType);
  if (!v30) {
    goto LABEL_30;
  }
  CFStringRef v29 = v30;
  CFArrayRef ConformingDataTypes = 0;
  CFStringRef v27 = dataType;
LABEL_23:
  if (v7 != 1835360888) {
    goto LABEL_72;
  }
LABEL_24:
  FigThreadRunOnce(&sFigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce, FigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce);
  CFDataRef v31 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)sCanonicalToWellKnownTypeMap, v29);
  if (v31)
  {
    CFDataRef Copy = CFDataCreateCopy(v5, v31);
  }
  else
  {
    QTWellKnownTypeFromCFStringRef DynamicBaseDataType = FigMetadataGetQTWellKnownTypeFromDynamicBaseDataType(v29);
    if (!QTWellKnownTypeFromDynamicBaseDataType) {
      goto LABEL_72;
    }
    *(_DWORD *)bytes = bswap32(QTWellKnownTypeFromDynamicBaseDataType);
    CFDataRef Copy = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 4);
  }
  CFDataRef v38 = Copy;
  if (!Copy)
  {
LABEL_72:
    uint64_t v36 = 4294954585;
    goto LABEL_73;
  }
  if (!CMMetadataDataTypeRegistryDataTypeIsBaseDataType(v27))
  {
    CFTypeRef ExternalRepresentation = CFStringCreateExternalRepresentation(v5, v27, 0x600u, 0);
    CFTypeRef v90 = v91;
    if (ExternalRepresentation) {
      goto LABEL_37;
    }
    int v40 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
    long long v72 = 0;
    int v75 = 0;
    CFIndex v59 = 0;
LABEL_74:
    CFDictionaryRef v76 = 0;
    goto LABEL_98;
  }
  CFTypeRef ExternalRepresentation = CFRetain(v38);
  CFTypeRef v90 = v93;
LABEL_37:
  OSStatus v39 = CMMetadataCreateKeyFromIdentifierAsCFData(v5, v11, &keyOut);
  if (v39)
  {
    int v40 = v39;
    if (v39 != -16308) {
      goto LABEL_97;
    }
  }
  int KeySpaceAsOSTypeFromIdentifier = FigMetadataGetKeySpaceAsOSTypeFromIdentifier(v11);
  int valuePtr = KeySpaceAsOSTypeFromIdentifier;
  if (!KeySpaceAsOSTypeFromIdentifier || KeySpaceAsOSTypeFromIdentifier != 1634627438 && !keyOut)
  {
    int v40 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_97:
    int v75 = 0;
    CFIndex v59 = 0;
    CFDictionaryRef v76 = 0;
    long long v72 = ExternalRepresentation;
    goto LABEL_98;
  }
  CFAllocatorRef v42 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v43 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v44 = CFNumberCreate(v42, kCFNumberSInt32Type, &v100);
  long long v109 = xmmword_1E567A138;
  long long v110 = unk_1E567A148;
  uint64_t v111 = 0;
  *(_OWORD *)bytes = xmmword_1E567A118;
  long long v108 = *(_OWORD *)&off_1E567A128;
  CFNumberRef v84 = v44;
  uint64_t v85 = a1;
  v103[0] = v44;
  v103[1] = v43;
  CFNumberRef cf1 = v43;
  v103[2] = (void *)v90;
  v103[3] = (void *)ExternalRepresentation;
  long long v104 = 0u;
  long long v105 = 0u;
  uint64_t v106 = 0;
  CFDataRef cf = v38;
  if (keyOut)
  {
    *(void *)&long long v109 = @"MetadataKeyValue";
    *(void *)&long long v104 = keyOut;
    uint64_t v45 = 5;
  }
  else
  {
    uint64_t v45 = 4;
  }
  CFIndex v83 = v45;
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFDictionaryRef v47 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
      int v48 = CFDictionaryGetValue(v47, @"MetadataKeyNamespace");
      if (FigCFEqual(v43, v48))
      {
        CFDataRef v49 = keyOut;
        int v50 = CFDictionaryGetValue(v47, @"MetadataKeyValue");
        if (FigCFEqual(v49, v50))
        {
          long long v51 = CFDictionaryGetValue(v47, @"MetadataKeyDataTypeNameSpace");
          if (FigCFEqual(v90, v51))
          {
            int v52 = CFDictionaryGetValue(v47, @"MetadataKeyDataType");
            if (FigCFEqual(ExternalRepresentation, v52))
            {
              CFStringRef v53 = CFDictionaryGetValue(v47, @"MetadataKeyLanguageTag");
              if (FigCFEqual(v88, v53))
              {
                int v54 = CFDictionaryGetValue(v47, @"MetadataKeySetupData");
                if (FigCFEqual(v87, v54))
                {
                  if (!ConformingDataTypes
                    || (int v55 = CFDictionaryGetValue(v47, @"MetadataKeyConformingDataTypes"),
                        FigCFEqual(ConformingDataTypes, v55)))
                  {
                    dataTypea = 0;
                    CFIndex v59 = 0;
                    CFDictionaryRef v76 = 0;
                    int v40 = 0;
LABEL_92:
                    CFNumberRef v74 = v84;
                    a1 = v85;
                    CFDataRef v38 = cf;
                    long long v72 = ExternalRepresentation;
                    CFNumberRef v73 = cf1;
                    goto LABEL_86;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (!ConformingDataTypes && (CFArrayRef ConformingDataTypes = CMMetadataDataTypeRegistryGetConformingDataTypes(dataType)) == 0
    || (uint64_t v56 = CFArrayGetCount(ConformingDataTypes), v56 < 1))
  {
    CFIndex v59 = 0;
    dataTypea = 0;
    a1 = v85;
    long long v70 = v86;
    int v68 = (void *)v88;
    long long v72 = ExternalRepresentation;
    uint64_t v69 = (void *)v87;
    CFNumberRef v73 = v43;
    CFIndex v71 = v83;
    CFNumberRef v74 = v84;
    goto LABEL_78;
  }
  uint64_t v57 = v56;
  dataTypea = CFArrayCreateMutable(v5, v56, MEMORY[0x1E4F1D510]);
  CFIndex v58 = 0;
  CFIndex v59 = 0;
  int v60 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFDictionaryRef v61 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  do
  {
    if (v59) {
      CFRelease(v59);
    }
    CFStringRef v62 = (const __CFString *)CFArrayGetValueAtIndex(ConformingDataTypes, v58);
    if (CMMetadataDataTypeRegistryDataTypeIsBaseDataType(v62))
    {
      if (CFStringCompare(v29, v62, 0))
      {
        int v40 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
        CFIndex v59 = 0;
        goto LABEL_95;
      }
      CFIndex v59 = CFRetain(cf);
      int v63 = (void *)v93;
      CFAllocatorRef v64 = v5;
    }
    else
    {
      CFStringRef v65 = (const __CFString *)CFArrayGetValueAtIndex(ConformingDataTypes, v58);
      CFAllocatorRef v64 = v5;
      CFIndex v59 = CFStringCreateExternalRepresentation(v5, v65, 0x600u, 0);
      int v63 = (void *)v91;
      if (!v59) {
        goto LABEL_93;
      }
    }
    *(_OWORD *)CMTime keys = xmmword_1E567A160;
    values[0] = v63;
    values[1] = (void *)v59;
    CFAllocatorRef v5 = v64;
    CFDictionaryRef v66 = CFDictionaryCreate(v64, (const void **)keys, (const void **)values, 2, v60, v61);
    if (!v66)
    {
LABEL_93:
      int v40 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_95:
      CFDictionaryRef v76 = 0;
      goto LABEL_92;
    }
    CFDictionaryRef v67 = v66;
    CFArrayAppendValue(dataTypea, v66);
    CFRelease(v67);
    ++v58;
  }
  while (v57 != v58);
  uint64_t v69 = (void *)v87;
  int v68 = (void *)v88;
  long long v70 = v86;
  CFIndex v71 = v83;
  if (dataTypea)
  {
    *(void *)&bytes[8 * v83] = @"MetadataKeyConformingDataTypes";
    v103[v83] = dataTypea;
    CFIndex v71 = v83 + 1;
  }
  else
  {
    dataTypea = 0;
  }
  long long v72 = ExternalRepresentation;
  CFNumberRef v74 = v84;
  a1 = v85;
  CFDataRef v38 = cf;
  CFNumberRef v73 = cf1;
LABEL_78:
  if (v68)
  {
    *(void *)&bytes[8 * v71] = @"MetadataKeyLanguageTag";
    v103[v71++] = v68;
  }
  if (v70)
  {
    *(void *)&bytes[8 * v71] = @"MetadataKeyStructuralDependency";
    v103[v71++] = v70;
  }
  if (v69)
  {
    *(void *)&bytes[8 * v71] = @"MetadataKeySetupData";
    v103[v71++] = v69;
  }
  CFDictionaryRef v76 = CFDictionaryCreate(v5, (const void **)bytes, (const void **)v103, v71, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v76)
  {
    CFArrayAppendValue(theArray, v76);
    int v40 = 0;
  }
  else
  {
    int v40 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
  }
LABEL_86:
  if (v74) {
    CFRelease(v74);
  }
  if (v73) {
    CFRelease(v73);
  }
  int v75 = dataTypea;
LABEL_98:
  if (keyOut) {
    CFRelease(keyOut);
  }
  if (v72) {
    CFRelease(v72);
  }
  if (v75) {
    CFRelease(v75);
  }
  if (v59) {
    CFRelease(v59);
  }
  if (v38) {
    CFRelease(v38);
  }
  if (v76) {
    CFRelease(v76);
  }
  if (!v40)
  {
    ++*(_DWORD *)(a2 + 16);
    CFArrayRef v77 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1, @"MetadataDependentSpecifications");
    if (!v77) {
      return;
    }
    CFArrayRef v78 = v77;
    CFTypeID v79 = CFArrayGetTypeID();
    if (v79 == CFGetTypeID(v78))
    {
      uint64_t v80 = CFArrayGetCount(v78);
      if (v80 >= 1)
      {
        v113.CFIndex length = v80;
        long long v81 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)bytes = *(_OWORD *)a2;
        long long v108 = v81;
        long long v109 = *(_OWORD *)(a2 + 32);
        *(void *)&long long v110 = *(void *)(a2 + 48);
        v113.CFIndex location = 0;
        CFArrayApplyFunction(v78, v113, (CFArrayApplierFunction)metadataFormatDescriptionCreateWithMetadataSpecifications1_arrayCallback, bytes);
        int v82 = v110;
        *(_DWORD *)(a2 + 16) = v108;
        *(_DWORD *)(a2 + 48) = v82 + 1;
      }
      return;
    }
LABEL_115:
    int v40 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    if (!v40) {
      return;
    }
  }
  if (!*(_DWORD *)a2) {
    *(_DWORD *)a2 = v40;
  }
}

void metadataFormatDescriptionCreateWithMetadataSpecifications2_arrayCallback(const __CFDictionary *a1, long long *a2)
{
  if (!*(_DWORD *)a2)
  {
    CFArrayRef v4 = (const opaqueCMFormatDescription *)*((void *)a2 + 2);
    CFStringRef Value = CFDictionaryGetValue(a1, @"MetadataIdentifier");
    int v6 = CFDictionaryGetValue(a1, @"MetadataDataType");
    int v7 = CFDictionaryGetValue(a1, @"MetadataExtendedLanguageTag");
    CFDictionaryRef LocalIDForMetadataIdentifyingFactors = FigMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors(v4, (uint64_t)Value, (uint64_t)v6, (uint64_t)v7);
    if (LocalIDForMetadataIdentifyingFactors)
    {
      CFDictionaryRef v9 = LocalIDForMetadataIdentifyingFactors;
      CFDictionaryRef KeyWithLocalID = CMMetadataFormatDescriptionGetKeyWithLocalID(*((CMMetadataFormatDescriptionRef *)a2 + 2), (OSType)LocalIDForMetadataIdentifyingFactors);
      if (KeyWithLocalID)
      {
        CFStringRef v11 = CFDictionaryGetValue(KeyWithLocalID, @"MetadataKeyLocalID");
        if (v11)
        {
          CFTypeID v12 = v11;
          CFStringRef v13 = CFStringCreateWithFormat(*((CFAllocatorRef *)a2 + 1), 0, @"%d", v9);
          if (v13)
          {
            CFStringRef v14 = v13;
            CFArrayRef v15 = (const __CFArray *)*((void *)a2 + 5);
            if (v15)
            {
              v35.CFIndex length = CFArrayGetCount(*((CFArrayRef *)a2 + 5));
              v35.CFIndex location = 0;
              if (!CFArrayContainsValue(v15, v35, v12)) {
                CFArrayAppendValue(*((CFMutableArrayRef *)a2 + 5), v12);
              }
              CFArrayRef v16 = (const __CFArray *)CFDictionaryGetValue(a1, @"MetadataDependentSpecifications");
              if (!v16) {
                goto LABEL_25;
              }
              CFArrayRef v17 = v16;
              long long v18 = a2[1];
              long long context = *a2;
              long long v33 = v18;
              *(_OWORD *)CFArrayRef theArray = a2[2];
              v36.CFIndex length = CFArrayGetCount(v16);
              v36.CFIndex location = 0;
              CFArrayApplyFunction(v17, v36, (CFArrayApplierFunction)metadataFormatDescriptionCreateWithMetadataSpecifications2_arrayCallback, &context);
            }
            else
            {
              CFArrayRef v19 = (const __CFArray *)*((void *)a2 + 3);
              v37.CFIndex length = CFArrayGetCount(v19);
              v37.CFIndex location = 0;
              if (!CFArrayContainsValue(v19, v37, v12)) {
                CFArrayAppendValue(*((CFMutableArrayRef *)a2 + 3), v12);
              }
              CFArrayRef v20 = (const __CFArray *)CFDictionaryGetValue(a1, @"MetadataDependentSpecifications");
              if (!v20) {
                goto LABEL_25;
              }
              CFArrayRef v21 = v20;
              long long v22 = a2[1];
              long long context = *a2;
              long long v33 = v22;
              theArray[0] = *((CFArrayRef *)a2 + 4);
              CFIndex Count = CFArrayGetCount(v20);
              theArray[1] = CFArrayCreateMutable(*((CFAllocatorRef *)a2 + 1), Count, MEMORY[0x1E4F1D510]);
              v38.CFIndex location = 0;
              v38.CFIndex length = Count;
              CFArrayApplyFunction(v21, v38, (CFArrayApplierFunction)metadataFormatDescriptionCreateWithMetadataSpecifications2_arrayCallback, &context);
              if (!context)
              {
                CFArrayRef v24 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 4), v14);
                if (v24)
                {
                  CFArrayRef v25 = v24;
                  CFIndex v26 = CFArrayGetCount(v24);
                  CFIndex v27 = CFArrayGetCount(theArray[1]);
                  CFArrayRef MutableCopy = CFArrayCreateMutableCopy(*((CFAllocatorRef *)a2 + 1), v27 + v26, v25);
                  if (v27 >= 1)
                  {
                    for (CFIndex i = 0; i != v27; ++i)
                    {
                      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray[1], i);
                      v39.CFIndex location = 0;
                      v39.CFIndex length = v26;
                      if (!CFArrayContainsValue(v25, v39, ValueAtIndex)) {
                        CFArrayAppendValue(MutableCopy, ValueAtIndex);
                      }
                    }
                  }
                  CFDictionarySetValue(*((CFMutableDictionaryRef *)a2 + 4), v14, MutableCopy);
                  CFRelease(MutableCopy);
                }
                else
                {
                  CFDictionarySetValue(*((CFMutableDictionaryRef *)a2 + 4), v14, theArray[1]);
                }
              }
              CFRelease(theArray[1]);
              if (*(_DWORD *)a2) {
                goto LABEL_25;
              }
            }
            *(_DWORD *)a2 = context;
LABEL_25:
            CFRelease(v14);
            return;
          }
        }
      }
    }
    int v31 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    if (v31 && !*(_DWORD *)a2) {
      *(_DWORD *)a2 = v31;
    }
  }
}

CMTimeRange *__cdecl CMTimeRangeMake(CMTimeRange *__return_ptr retstr, CMTimeRange *start, CMTime *duration)
{
  if (duration->epoch)
  {
    *(_OWORD *)&retstr->start.CMTimeEpoch epoch = 0u;
    *(_OWORD *)&retstr->duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->start.uint64_t value = 0u;
  }
  else
  {
    *(void *)CFDataRef v3 = start->start.epoch;
    *(CMTime *)&v3[8] = *duration;
    *(_OWORD *)&retstr->start.uint64_t value = *(_OWORD *)&start->start.value;
    *(_OWORD *)&retstr->start.CMTimeEpoch epoch = *(_OWORD *)v3;
    *(_OWORD *)&retstr->duration.CMTimeScale timescale = *(_OWORD *)&v3[16];
  }
  return start;
}

CMTimeMapping *__cdecl CMTimeMappingMake(CMTimeMapping *__return_ptr retstr, CMTimeMapping *source, CMTimeRange *target)
{
  if (source->source.duration.epoch || target->duration.epoch)
  {
    *(_OWORD *)&retstr->target.start.CMTimeEpoch epoch = 0u;
    *(_OWORD *)&retstr->target.duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->source.duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->target.start.uint64_t value = 0u;
    *(_OWORD *)&retstr->source.start.uint64_t value = 0u;
    *(_OWORD *)&retstr->source.start.CMTimeEpoch epoch = 0u;
  }
  else
  {
    long long v4 = *(_OWORD *)&source->source.start.epoch;
    long long v3 = *(_OWORD *)&source->source.duration.timescale;
    long long v6 = *(_OWORD *)&target->start.epoch;
    long long v5 = *(_OWORD *)&target->duration.timescale;
    long long v7 = *(_OWORD *)&target->start.value;
    *(_OWORD *)&retstr->source.start.uint64_t value = *(_OWORD *)&source->source.start.value;
    *(_OWORD *)&retstr->source.start.CMTimeEpoch epoch = v4;
    *(_OWORD *)&retstr->source.duration.CMTimeScale timescale = v3;
    *(_OWORD *)&retstr->target.start.uint64_t value = v7;
    *(_OWORD *)&retstr->target.start.CMTimeEpoch epoch = v6;
    *(_OWORD *)&retstr->target.duration.CMTimeScale timescale = v5;
  }
  return source;
}

CMTimeMapping *__cdecl CMTimeMappingMakeEmpty(CMTimeMapping *__return_ptr retstr, CMTimeMapping *target)
{
  if (target->source.duration.epoch)
  {
    *(_OWORD *)&retstr->target.start.CMTimeEpoch epoch = 0u;
    *(_OWORD *)&retstr->target.duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->source.duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->target.start.uint64_t value = 0u;
    *(_OWORD *)&retstr->source.start.uint64_t value = 0u;
    *(_OWORD *)&retstr->source.start.CMTimeEpoch epoch = 0u;
  }
  else
  {
    long long v2 = *(_OWORD *)&target->source.start.epoch;
    *(_OWORD *)&retstr->target.start.uint64_t value = *(_OWORD *)&target->source.start.value;
    *(_OWORD *)&retstr->target.start.CMTimeEpoch epoch = v2;
    uint64_t v3 = *(void *)&target->source.duration.timescale;
    *(_OWORD *)&retstr->source.start.uint64_t value = 0u;
    *(_OWORD *)&retstr->source.start.CMTimeEpoch epoch = 0u;
    *(_OWORD *)&retstr->source.duration.CMTimeScale timescale = 0u;
    *(void *)&retstr->target.duration.CMTimeScale timescale = v3;
    retstr->target.duration.CMTimeEpoch epoch = 0;
  }
  return target;
}

CMTimeRange *__cdecl CMTimeRangeGetUnion(CMTimeRange *__return_ptr retstr, CMTimeRange *range, CMTimeRange *otherRange)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  memset(&v16, 0, sizeof(v16));
  memset(&v14, 0, sizeof(v14));
  if (range->start.epoch != otherRange->start.epoch) {
    goto LABEL_9;
  }
  long long v5 = range;
  long long time1 = *(_OWORD *)&range->start.value;
  time1_16.uint64_t value = range->start.epoch;
  CMTime time2 = otherRange->start;
  CMTimeMinimum(&v16, (CMTime *)&time1, &time2);
  long long v6 = *(_OWORD *)&v5->start.epoch;
  long long time1 = *(_OWORD *)&v5->start.value;
  *(_OWORD *)&time1_16.uint64_t value = v6;
  CMTimeEpoch epoch = v5->duration.epoch;
  time1_16.CMTimeEpoch epoch = *(void *)&v5->duration.timescale;
  if (epoch)
  {
    memset(&v13, 0, sizeof(v13));
  }
  else
  {
    CMTime time2 = v5->start;
    *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&time1_16.timescale;
    rhs.CMTimeEpoch epoch = 0;
    CMTimeAdd(&v13, &time2, &rhs);
  }
  CMTime v15 = v13;
  long long v8 = *(_OWORD *)&otherRange->start.epoch;
  long long time1 = *(_OWORD *)&otherRange->start.value;
  *(_OWORD *)&time1_16.uint64_t value = v8;
  CMTimeEpoch v9 = otherRange->duration.epoch;
  time1_16.CMTimeEpoch epoch = *(void *)&otherRange->duration.timescale;
  if (v9)
  {
    memset(&v13, 0, sizeof(v13));
  }
  else
  {
    CMTime time2 = otherRange->start;
    *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&time1_16.timescale;
    rhs.CMTimeEpoch epoch = 0;
    CMTimeAdd(&v13, &time2, &rhs);
  }
  CMTime time2 = v13;
  long long time1 = *(_OWORD *)&v15.value;
  time1_16.uint64_t value = v15.epoch;
  CMTime rhs = v13;
  CMTimeMaximum(&v14, (CMTime *)&time1, &rhs);
  long long time1 = *(_OWORD *)&v14.value;
  time1_16.uint64_t value = v14.epoch;
  CMTime rhs = v16;
  char range = (CMTimeRange *)CMTimeSubtract(&v12, (CMTime *)&time1, &rhs);
  if (!v12.epoch)
  {
    *(void *)&time1_16.CMTimeScale timescale = v12.value;
    time1_16.uint64_t value = v16.epoch;
    long long v10 = *(_OWORD *)&time1_16.value;
    long long v11 = *(unint64_t *)&v12.timescale;
    *(_OWORD *)&retstr->start.uint64_t value = *(_OWORD *)&v16.value;
    *(_OWORD *)&retstr->start.CMTimeEpoch epoch = v10;
    *(_OWORD *)&retstr->duration.CMTimeScale timescale = v11;
  }
  else
  {
LABEL_9:
    *(_OWORD *)&retstr->start.CMTimeEpoch epoch = 0u;
    *(_OWORD *)&retstr->duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->start.uint64_t value = 0u;
  }
  return range;
}

CMTime *__cdecl CMTimeRangeGetEnd(CMTime *__return_ptr retstr, CMTime *range)
{
  if (range[1].epoch)
  {
    *(_OWORD *)&retstr->uint64_t value = *(_OWORD *)&kCMTimeInvalid.value;
    retstr->CMTimeEpoch epoch = 0;
  }
  else
  {
    CMTime lhs = *range;
    CMTime v2 = range[1];
    return CMTimeAdd(retstr, &lhs, &v2);
  }
  return range;
}

CMTimeRange *__cdecl CMTimeRangeGetIntersection(CMTimeRange *__return_ptr retstr, CMTimeRange *range, CMTimeRange *otherRange)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  memset(&v16, 0, sizeof(v16));
  memset(&v15[32], 0, 24);
  memset(v15, 0, 24);
  memset(&v14, 0, sizeof(v14));
  if (range->start.epoch != otherRange->start.epoch) {
    goto LABEL_11;
  }
  long long v5 = range;
  long long time1 = *(_OWORD *)&range->start.value;
  time1_16.uint64_t value = range->start.epoch;
  CMTime time2 = otherRange->start;
  CMTimeMaximum(&v16, (CMTime *)&time1, &time2);
  long long v6 = *(_OWORD *)&v5->start.epoch;
  long long time1 = *(_OWORD *)&v5->start.value;
  *(_OWORD *)&time1_16.uint64_t value = v6;
  CMTimeEpoch epoch = v5->duration.epoch;
  time1_16.CMTimeEpoch epoch = *(void *)&v5->duration.timescale;
  if (epoch)
  {
    memset(&v13, 0, sizeof(v13));
  }
  else
  {
    CMTime time2 = v5->start;
    *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&time1_16.timescale;
    rhs.CMTimeEpoch epoch = 0;
    CMTimeAdd(&v13, &time2, &rhs);
  }
  *(CMTime *)&v15[32] = v13;
  long long v8 = *(_OWORD *)&otherRange->start.epoch;
  long long time1 = *(_OWORD *)&otherRange->start.value;
  *(_OWORD *)&time1_16.uint64_t value = v8;
  CMTimeEpoch v9 = otherRange->duration.epoch;
  time1_16.CMTimeEpoch epoch = *(void *)&otherRange->duration.timescale;
  if (v9)
  {
    memset(&v13, 0, sizeof(v13));
  }
  else
  {
    CMTime time2 = otherRange->start;
    *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&time1_16.timescale;
    rhs.CMTimeEpoch epoch = 0;
    CMTimeAdd(&v13, &time2, &rhs);
  }
  *(CMTime *)CMTime v15 = v13;
  long long time1 = *(_OWORD *)&v15[32];
  time1_16.uint64_t value = *(void *)&v15[48];
  CMTime time2 = v13;
  CMTimeMinimum(&v14, (CMTime *)&time1, &time2);
  long long time1 = *(_OWORD *)&v16.value;
  time1_16.uint64_t value = v16.epoch;
  CMTime time2 = v14;
  char range = (CMTimeRange *)CMTimeCompare((CMTime *)&time1, &time2);
  if ((range & 0x80000000) == 0)
  {
    *retstr = kCMTimeRangeZero;
    return range;
  }
  long long time1 = *(_OWORD *)&v14.value;
  time1_16.uint64_t value = v14.epoch;
  CMTime time2 = v16;
  char range = (CMTimeRange *)CMTimeSubtract(&v12, (CMTime *)&time1, &time2);
  if (!v12.epoch)
  {
    *(void *)&time1_16.CMTimeScale timescale = v12.value;
    time1_16.uint64_t value = v16.epoch;
    long long v10 = *(_OWORD *)&time1_16.value;
    long long v11 = *(unint64_t *)&v12.timescale;
    *(_OWORD *)&retstr->start.uint64_t value = *(_OWORD *)&v16.value;
    *(_OWORD *)&retstr->start.CMTimeEpoch epoch = v10;
    *(_OWORD *)&retstr->duration.CMTimeScale timescale = v11;
  }
  else
  {
LABEL_11:
    *(_OWORD *)&retstr->start.CMTimeEpoch epoch = 0u;
    *(_OWORD *)&retstr->duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->start.uint64_t value = 0u;
  }
  return range;
}

Boolean CMTimeRangeEqual(CMTimeRange *range1, CMTimeRange *range2)
{
  if (range1->start.epoch != range2->start.epoch) {
    return 0;
  }
  CMTime time1 = range1->start;
  CMTime start = range2->start;
  if (CMTimeCompare(&time1, &start)) {
    return 0;
  }
  CMTime time1 = range1->duration;
  CMTime start = range2->duration;
  return CMTimeCompare(&time1, &start) == 0;
}

Boolean CMTimeRangeContainsTime(CMTimeRange *range, CMTime *time)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  long long time1 = *(_OWORD *)&range->start.value;
  time1_16.uint64_t value = range->start.epoch;
  CMTime time2 = *time;
  if (CMTimeCompare((CMTime *)&time1, &time2) <= 0)
  {
    long long v5 = *(_OWORD *)&range->start.epoch;
    long long time1 = *(_OWORD *)&range->start.value;
    *(_OWORD *)&time1_16.uint64_t value = v5;
    CMTimeEpoch epoch = range->duration.epoch;
    time1_16.CMTimeEpoch epoch = *(void *)&range->duration.timescale;
    if (epoch)
    {
      memset(&v8, 0, sizeof(v8));
    }
    else
    {
      CMTime time2 = range->start;
      *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&time1_16.timescale;
      rhs.CMTimeEpoch epoch = 0;
      CMTimeAdd(&v8, &time2, &rhs);
    }
    long long time1 = *(_OWORD *)&time->value;
    time1_16.uint64_t value = time->epoch;
    return CMTimeCompare((CMTime *)&time1, &v8) >> 31;
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  return v4;
}

Boolean CMTimeRangeContainsTimeRange(CMTimeRange *range, CMTimeRange *otherRange)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (range->start.epoch != otherRange->start.epoch)
  {
LABEL_15:
    LOBYTE(v5) = 0;
    return v5;
  }
  long long v4 = *(_OWORD *)&range->start.epoch;
  *(_OWORD *)&rangea.start.uint64_t value = *(_OWORD *)&range->start.value;
  *(_OWORD *)&rangea.start.CMTimeEpoch epoch = v4;
  *(_OWORD *)&rangea.duration.CMTimeScale timescale = *(_OWORD *)&range->duration.timescale;
  CMTime time = otherRange->start;
  int v5 = CMTimeRangeContainsTime(&rangea, &time);
  if (v5)
  {
    long long v6 = *(_OWORD *)&otherRange->start.epoch;
    *(_OWORD *)&rangea.start.uint64_t value = *(_OWORD *)&otherRange->start.value;
    *(_OWORD *)&rangea.start.CMTimeEpoch epoch = v6;
    CMTimeEpoch epoch = otherRange->duration.epoch;
    *(void *)&rangea.duration.CMTimeScale timescale = *(void *)&otherRange->duration.timescale;
    if (epoch)
    {
      memset(&v16, 0, sizeof(v16));
    }
    else
    {
      CMTime time = otherRange->start;
      *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&rangea.duration.value;
      rhs.CMTimeEpoch epoch = 0;
      CMTimeAdd(&v16, &time, &rhs);
    }
    long long v8 = *(_OWORD *)&range->start.epoch;
    *(_OWORD *)&rangea.start.uint64_t value = *(_OWORD *)&range->start.value;
    *(_OWORD *)&rangea.start.CMTimeEpoch epoch = v8;
    *(_OWORD *)&rangea.duration.CMTimeScale timescale = *(_OWORD *)&range->duration.timescale;
    if (!CMTimeRangeContainsTime(&rangea, &v16))
    {
      long long v9 = *(_OWORD *)&range->start.epoch;
      *(_OWORD *)&rangea.start.uint64_t value = *(_OWORD *)&range->start.value;
      *(_OWORD *)&rangea.start.CMTimeEpoch epoch = v9;
      CMTimeEpoch v10 = range->duration.epoch;
      *(void *)&rangea.duration.CMTimeScale timescale = *(void *)&range->duration.timescale;
      if (v10)
      {
        memset(&time1, 0, sizeof(time1));
      }
      else
      {
        CMTime time = range->start;
        *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&rangea.duration.value;
        rhs.CMTimeEpoch epoch = 0;
        CMTimeAdd(&time1, &time, &rhs);
      }
      long long v11 = *(_OWORD *)&otherRange->start.epoch;
      *(_OWORD *)&rangea.start.uint64_t value = *(_OWORD *)&otherRange->start.value;
      *(_OWORD *)&rangea.start.CMTimeEpoch epoch = v11;
      CMTimeEpoch v12 = otherRange->duration.epoch;
      *(void *)&rangea.duration.CMTimeScale timescale = *(void *)&otherRange->duration.timescale;
      if (v12)
      {
        memset(&v14, 0, sizeof(v14));
      }
      else
      {
        CMTime time = otherRange->start;
        *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&rangea.duration.value;
        rhs.CMTimeEpoch epoch = 0;
        CMTimeAdd(&v14, &time, &rhs);
      }
      if (CMTimeCompare(&time1, &v14)) {
        goto LABEL_15;
      }
    }
    LOBYTE(v5) = 1;
  }
  return v5;
}

CMTime *__cdecl CMTimeMapDurationFromRangeToRange(CMTime *__return_ptr retstr, CMTime *dur, CMTimeRange *fromRange, CMTimeRange *toRange)
{
  CMTime time1 = fromRange->duration;
  CMTime duration = toRange->duration;
  uint64_t result = (CMTime *)CMTimeCompare(&time1, &duration);
  if ((dur->flags & 0x1D) == 1 && dur->epoch
    || (fromRange->start.flags & 0x1D) != 1
    || (toRange->start.flags & 0x1D) != 1)
  {
    goto LABEL_17;
  }
  p_CMTime duration = &fromRange->duration;
  CMTimeEpoch v10 = &toRange->duration;
  if (((~fromRange->duration.flags & 0x11) == 0 || (fromRange->duration.flags & 5) == 5)
    && ((~toRange->duration.flags & 0x11) == 0 || (toRange->duration.flags & 5) == 5))
  {
    if (!result)
    {
LABEL_21:
      long long v11 = dur;
      goto LABEL_18;
    }
LABEL_20:
    *(_OWORD *)&time1.uint64_t value = *(_OWORD *)&v10->value;
    time1.CMTimeEpoch epoch = toRange->duration.epoch;
    double Seconds = CMTimeGetSeconds(&time1);
    *(_OWORD *)&time1.uint64_t value = *(_OWORD *)&p_duration->value;
    time1.CMTimeEpoch epoch = fromRange->duration.epoch;
    Float64 v13 = CMTimeGetSeconds(&time1);
    CMTime duration = *dur;
    uint64_t result = CMTimeMultiplyByFloat64(&time1, &duration, Seconds / v13);
    *dur = time1;
    goto LABEL_21;
  }
  if ((fromRange->duration.flags & 0x1D) != 1
    || p_duration->value < 1
    || fromRange->duration.epoch
    || (toRange->duration.flags & 0x1D) != 1)
  {
LABEL_17:
    long long v11 = (CMTime *)&kCMTimeInvalid;
    goto LABEL_18;
  }
  long long v11 = (CMTime *)&kCMTimeInvalid;
  if (v10->value >= 1 && !toRange->duration.epoch)
  {
    long long v11 = dur;
    if (result) {
      goto LABEL_20;
    }
  }
LABEL_18:
  *(_OWORD *)&retstr->uint64_t value = *(_OWORD *)&v11->value;
  retstr->CMTimeEpoch epoch = v11->epoch;
  return result;
}

CMTime *__cdecl CMTimeMapTimeFromRangeToRange(CMTime *__return_ptr retstr, CMTime *t, CMTimeRange *fromRange, CMTimeRange *toRange)
{
  CMTime time1 = fromRange->start;
  CMTime time2 = toRange->start;
  int32_t v8 = CMTimeCompare(&time1, &time2);
  CMTime time1 = fromRange->duration;
  CMTime time2 = toRange->duration;
  uint64_t result = (CMTime *)CMTimeCompare(&time1, &time2);
  if ((fromRange->start.flags & 0x1D) != 1 || (toRange->start.flags & 0x1D) != 1) {
    goto LABEL_19;
  }
  if ((int v10 = (int)result,
        p_CMTime duration = &fromRange->duration,
        CMTimeEpoch v12 = &toRange->duration,
        (~fromRange->duration.flags & 0x11) != 0)
    && (fromRange->duration.flags & 5) != 5
    || (~toRange->duration.flags & 0x11) != 0 && (toRange->duration.flags & 5) != 5)
  {
    if ((fromRange->duration.flags & 0x1D) != 1
      || p_duration->value < 1
      || fromRange->duration.epoch
      || (toRange->duration.flags & 0x1D) != 1
      || v12->value < 1
      || toRange->duration.epoch)
    {
      goto LABEL_19;
    }
  }
  if ((t->flags & 0x1D) != 1) {
    goto LABEL_20;
  }
  if (t->epoch != fromRange->start.epoch)
  {
LABEL_19:
    t = (CMTime *)&kCMTimeInvalid;
    goto LABEL_20;
  }
  if (v8 | result)
  {
    CMTime time2 = *t;
    CMTime start = fromRange->start;
    CMTimeSubtract(&time1, &time2, &start);
    *t = time1;
    if (v10)
    {
      *(_OWORD *)&time1.uint64_t value = *(_OWORD *)&v12->value;
      time1.CMTimeEpoch epoch = toRange->duration.epoch;
      double Seconds = CMTimeGetSeconds(&time1);
      *(_OWORD *)&time1.uint64_t value = *(_OWORD *)&p_duration->value;
      time1.CMTimeEpoch epoch = fromRange->duration.epoch;
      Float64 v14 = CMTimeGetSeconds(&time1);
      CMTime time2 = *t;
      CMTimeMultiplyByFloat64(&time1, &time2, Seconds / v14);
      *t = time1;
    }
    CMTime time2 = *t;
    CMTime start = toRange->start;
    uint64_t result = CMTimeAdd(&time1, &time2, &start);
    *t = time1;
  }
LABEL_20:
  *(_OWORD *)&retstr->uint64_t value = *(_OWORD *)&t->value;
  retstr->CMTimeEpoch epoch = t->epoch;
  return result;
}

CMTime *__cdecl CMTimeClampToRange(CMTime *__return_ptr retstr, CMTime *time, CMTimeRange *range)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if ((range->start.flags & 0x1D) != 1
    || ((v5 = time, (~range->duration.flags & 5) != 0) ? (BOOL v6 = (range->duration.flags & 0x11) == 17) : (BOOL v6 = 1),
        !v6 && ((range->duration.flags & 0x1D) != 1 || range->duration.value < 1 || range->duration.epoch)))
  {
LABEL_24:
    *(_OWORD *)&retstr->uint64_t value = *(_OWORD *)&kCMTimeInvalid.value;
    CMTimeEpoch epoch = 0;
    goto LABEL_25;
  }
  if (~time->flags & 0x11) != 0 && (time->flags)
  {
    long long time1 = *(_OWORD *)&time->value;
    time1_16.uint64_t value = time->epoch;
    CMTime time2 = range->start;
    CMTime time = (CMTime *)CMTimeCompare((CMTime *)&time1, &time2);
    if ((int)time <= 0)
    {
      *(_OWORD *)&retstr->uint64_t value = *(_OWORD *)&range->start.value;
      CMTimeEpoch epoch = range->start.epoch;
      goto LABEL_25;
    }
    long long v9 = *(_OWORD *)&range->start.epoch;
    long long time1 = *(_OWORD *)&range->start.value;
    *(_OWORD *)&time1_16.uint64_t value = v9;
    CMTimeEpoch v10 = range->duration.epoch;
    time1_16.CMTimeEpoch epoch = *(void *)&range->duration.timescale;
    if (v10)
    {
      memset(&v13, 0, sizeof(v13));
    }
    else
    {
      CMTime time2 = range->start;
      *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&time1_16.timescale;
      rhs.CMTimeEpoch epoch = 0;
      CMTimeAdd(&v13, &time2, &rhs);
    }
    long long time1 = *(_OWORD *)&v5->value;
    time1_16.uint64_t value = v5->epoch;
    CMTime time = (CMTime *)CMTimeCompare((CMTime *)&time1, &v13);
    if ((time & 0x80000000) == 0)
    {
      long long v11 = *(_OWORD *)&range->start.epoch;
      long long time1 = *(_OWORD *)&range->start.value;
      *(_OWORD *)&time1_16.uint64_t value = v11;
      CMTimeEpoch v12 = range->duration.epoch;
      time1_16.CMTimeEpoch epoch = *(void *)&range->duration.timescale;
      if (!v12)
      {
        CMTime time2 = range->start;
        *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&time1_16.timescale;
        rhs.CMTimeEpoch epoch = 0;
        return CMTimeAdd(retstr, &time2, &rhs);
      }
      goto LABEL_24;
    }
  }
  *(_OWORD *)&retstr->uint64_t value = *(_OWORD *)&v5->value;
  CMTimeEpoch epoch = v5->epoch;
LABEL_25:
  retstr->CMTimeEpoch epoch = epoch;
  return time;
}

CMTime *__cdecl CMTimeFoldIntoRange(CMTime *__return_ptr retstr, CMTime *time, CMTimeRange *foldRange)
{
  *(_OWORD *)&retstr->uint64_t value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  memset(&v10, 0, sizeof(v10));
  memset(&v9, 0, sizeof(v9));
  CMTime lhs = *time;
  CMTime rhs = foldRange->start;
  CMTimeSubtract(&v10, &lhs, &rhs);
  CMTime lhs = v10;
  *(_OWORD *)&rhs.uint64_t value = *(_OWORD *)&kCMTimeZero.value;
  rhs.CMTimeEpoch epoch = 0;
  if (CMTimeCompare(&lhs, &rhs) < 0)
  {
    CMTime rhs = v10;
    CMTime duration = foldRange->duration;
    CMTimeRemainder((long long *)&rhs.value, (long long *)&duration.value, &lhs);
    CMTime v10 = lhs;
    CMTime rhs = lhs;
    CMTime duration = foldRange->duration;
    CMTimeAdd(&lhs, &rhs, &duration);
    CMTime v10 = lhs;
  }
  CMTime lhs = v10;
  CMTime rhs = foldRange->duration;
  CMTimeRemainder((long long *)&lhs.value, (long long *)&rhs.value, &v9);
  CMTime lhs = v9;
  CMTime rhs = foldRange->start;
  return CMTimeAdd(retstr, &lhs, &rhs);
}

CFDictionaryRef CMTimeRangeCopyAsDictionary(CMTimeRange *range, CFAllocatorRef allocator)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CMTime time = range->start;
  CFDictionaryRef v4 = CMTimeCopyAsDictionary(&time, 0);
  CMTime time = range->duration;
  CFDictionaryRef v5 = CMTimeCopyAsDictionary(&time, 0);
  CFDictionaryRef v6 = v5;
  if (v4 && v5)
  {
    *(_OWORD *)&time.uint64_t value = xmmword_1E567A190;
    v10[0] = v4;
    v10[1] = v5;
    CFDictionaryRef v7 = CFDictionaryCreate(allocator, (const void **)&time, v10, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  else
  {
    CFDictionaryRef v7 = 0;
    CFDictionaryRef v8 = 0;
    if (!v4) {
      goto LABEL_6;
    }
  }
  CFRelease(v4);
  CFDictionaryRef v8 = v7;
LABEL_6:
  if (v6) {
    CFRelease(v6);
  }
  return v8;
}

CMTimeRange *__cdecl CMTimeRangeMakeFromDictionary(CMTimeRange *__return_ptr retstr, CMTimeRange *dictionaryRepresentation)
{
  if (dictionaryRepresentation
    && (uint64_t v3 = dictionaryRepresentation,
        CFTypeID TypeID = (CMTimeRange *)CFDictionaryGetTypeID(),
        CFDictionaryRef dictionaryRepresentation = (CMTimeRange *)CFGetTypeID(v3),
        TypeID == dictionaryRepresentation)
    && (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v3, @"start"),
        CFDictionaryRef dictionaryRepresentation = (CMTimeRange *)CFDictionaryGetValue((CFDictionaryRef)v3, @"duration"),
        Value)
    && (CFDictionaryRef v6 = dictionaryRepresentation) != 0)
  {
    CMTimeMakeFromDictionary(&v9, Value);
    CFDictionaryRef dictionaryRepresentation = (CMTimeRange *)CMTimeMakeFromDictionary(&v8, (CFDictionaryRef)v6);
    if (v8.epoch)
    {
      long long v11 = 0u;
      long long v12 = 0u;
      long long v10 = 0u;
    }
    else
    {
      *(void *)Float64 v14 = v9.epoch;
      long long v13 = *(_OWORD *)&v9.value;
      *(_OWORD *)&v14[8] = *(_OWORD *)&v8.value;
      uint64_t v15 = 0;
      long long v10 = *(_OWORD *)&v9.value;
      long long v11 = *(_OWORD *)v14;
      long long v12 = *(unint64_t *)&v8.timescale;
    }
    long long v7 = v11;
    *(_OWORD *)&retstr->start.uint64_t value = v10;
    *(_OWORD *)&retstr->start.CMTimeEpoch epoch = v7;
    *(_OWORD *)&retstr->duration.CMTimeScale timescale = v12;
  }
  else
  {
    *(_OWORD *)&retstr->start.CMTimeEpoch epoch = 0u;
    *(_OWORD *)&retstr->duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->start.uint64_t value = 0u;
  }
  return dictionaryRepresentation;
}

CFDictionaryRef CMTimeMappingCopyAsDictionary(CMTimeMapping *mapping, CFAllocatorRef allocator)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  long long v4 = *(_OWORD *)&mapping->source.start.epoch;
  *(_OWORD *)&range.start.uint64_t value = *(_OWORD *)&mapping->source.start.value;
  *(_OWORD *)&range.start.CMTimeEpoch epoch = v4;
  *(_OWORD *)&range.duration.CMTimeScale timescale = *(_OWORD *)&mapping->source.duration.timescale;
  CFDictionaryRef v5 = CMTimeRangeCopyAsDictionary(&range, 0);
  long long v6 = *(_OWORD *)&mapping->target.start.epoch;
  *(_OWORD *)&range.start.uint64_t value = *(_OWORD *)&mapping->target.start.value;
  *(_OWORD *)&range.start.CMTimeEpoch epoch = v6;
  *(_OWORD *)&range.duration.CMTimeScale timescale = *(_OWORD *)&mapping->target.duration.timescale;
  CFDictionaryRef v7 = CMTimeRangeCopyAsDictionary(&range, 0);
  CFDictionaryRef v8 = v7;
  if (v5 && v7)
  {
    *(_OWORD *)&range.start.uint64_t value = xmmword_1E567A1A0;
    v12[0] = v5;
    v12[1] = v7;
    CFDictionaryRef v9 = CFDictionaryCreate(allocator, (const void **)&range, v12, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  else
  {
    CFDictionaryRef v9 = 0;
    CFDictionaryRef v10 = 0;
    if (!v5) {
      goto LABEL_6;
    }
  }
  CFRelease(v5);
  CFDictionaryRef v10 = v9;
LABEL_6:
  if (v8) {
    CFRelease(v8);
  }
  return v10;
}

CMTimeMapping *__cdecl CMTimeMappingMakeFromDictionary(CMTimeMapping *__return_ptr retstr, CMTimeMapping *dictionaryRepresentation)
{
  if (dictionaryRepresentation
    && (uint64_t v3 = dictionaryRepresentation,
        CFTypeID TypeID = (CMTimeMapping *)CFDictionaryGetTypeID(),
        CFDictionaryRef dictionaryRepresentation = (CMTimeMapping *)CFGetTypeID(v3),
        TypeID == dictionaryRepresentation)
    && (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v3, @"source"),
        CFDictionaryRef dictionaryRepresentation = (CMTimeMapping *)CFDictionaryGetValue((CFDictionaryRef)v3, @"target"),
        Value)
    && (long long v6 = dictionaryRepresentation) != 0)
  {
    CMTimeRangeMakeFromDictionary(&v11, Value);
    CFDictionaryRef dictionaryRepresentation = (CMTimeMapping *)CMTimeRangeMakeFromDictionary(&v10, (CFDictionaryRef)v6);
    if (v11.duration.epoch || v10.duration.epoch)
    {
      long long v14 = 0u;
      long long v15 = 0u;
      long long v13 = 0u;
      memset(&v12, 0, sizeof(v12));
    }
    else
    {
      CMTimeRange v16 = v11;
      long long v17 = *(_OWORD *)&v10.start.value;
      long long v18 = *(_OWORD *)&v10.start.epoch;
      long long v19 = *(unint64_t *)&v10.duration.timescale;
      CMTimeRange v12 = v11;
      long long v13 = *(_OWORD *)&v10.start.value;
      long long v14 = *(_OWORD *)&v10.start.epoch;
      long long v15 = *(unint64_t *)&v10.duration.timescale;
    }
    long long v7 = v13;
    *(_OWORD *)&retstr->source.duration.CMTimeScale timescale = *(_OWORD *)&v12.duration.timescale;
    *(_OWORD *)&retstr->target.start.uint64_t value = v7;
    long long v8 = v15;
    *(_OWORD *)&retstr->target.start.CMTimeEpoch epoch = v14;
    *(_OWORD *)&retstr->target.duration.CMTimeScale timescale = v8;
    long long v9 = *(_OWORD *)&v12.start.epoch;
    *(_OWORD *)&retstr->source.start.uint64_t value = *(_OWORD *)&v12.start.value;
    *(_OWORD *)&retstr->source.start.CMTimeEpoch epoch = v9;
  }
  else
  {
    *(_OWORD *)&retstr->target.start.CMTimeEpoch epoch = 0u;
    *(_OWORD *)&retstr->target.duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->source.duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->target.start.uint64_t value = 0u;
    *(_OWORD *)&retstr->source.start.uint64_t value = 0u;
    *(_OWORD *)&retstr->source.start.CMTimeEpoch epoch = 0u;
  }
  return dictionaryRepresentation;
}

CFStringRef CMTimeRangeCopyDescription(CFAllocatorRef allocator, CMTimeRange *range)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(allocator, 0);
  if (!Mutable) {
    return Mutable;
  }
  CMTime start = range->start;
  CFStringRef v5 = CMTimeCopyDescription(allocator, &start);
  CMTime start = range->duration;
  CFStringRef v6 = CMTimeCopyDescription(allocator, &start);
  CFStringRef v7 = v6;
  if (v5 && v6)
  {
    CFStringAppend(Mutable, @"{");
    CFStringAppend(Mutable, v5);
    CFStringAppend(Mutable, @", ");
    CFStringAppend(Mutable, v7);
    CFStringAppend(Mutable, @"}");
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"{ERROR CONSTRUCTING DESCRIPTION}");
    if (!v5) {
      goto LABEL_7;
    }
  }
  CFRelease(v5);
LABEL_7:
  if (v7) {
    CFRelease(v7);
  }
  return Mutable;
}

void CMTimeRangeShow(CMTimeRange *range)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  long long v2 = *(_OWORD *)&range->start.epoch;
  *(_OWORD *)&rangea.start.uint64_t value = *(_OWORD *)&range->start.value;
  *(_OWORD *)&rangea.start.CMTimeEpoch epoch = v2;
  *(_OWORD *)&rangea.duration.CMTimeScale timescale = *(_OWORD *)&range->duration.timescale;
  CFStringRef v3 = CMTimeRangeCopyDescription(v1, &rangea);
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v6 = 0u;
  memset(&rangea, 0, sizeof(rangea));
  if (v3)
  {
    CFStringRef v4 = v3;
    if (CFStringGetCString(v3, (char *)&rangea, 512, 0)) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s\n", (const char *)&rangea);
    }
    CFRelease(v4);
  }
}

CFStringRef CMTimeMappingCopyDescription(CFAllocatorRef allocator, CMTimeMapping *mapping)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(allocator, 0);
  if (!Mutable) {
    return Mutable;
  }
  long long v5 = *(_OWORD *)&mapping->source.start.epoch;
  *(_OWORD *)&v11.start.uint64_t value = *(_OWORD *)&mapping->source.start.value;
  *(_OWORD *)&v11.start.CMTimeEpoch epoch = v5;
  *(_OWORD *)&v11.duration.CMTimeScale timescale = *(_OWORD *)&mapping->source.duration.timescale;
  CFStringRef v6 = CMTimeRangeCopyDescription(allocator, &v11);
  long long v7 = *(_OWORD *)&mapping->target.start.epoch;
  *(_OWORD *)&v11.start.uint64_t value = *(_OWORD *)&mapping->target.start.value;
  *(_OWORD *)&v11.start.CMTimeEpoch epoch = v7;
  *(_OWORD *)&v11.duration.CMTimeScale timescale = *(_OWORD *)&mapping->target.duration.timescale;
  CFStringRef v8 = CMTimeRangeCopyDescription(allocator, &v11);
  CFStringRef v9 = v8;
  if (v6 && v8)
  {
    CFStringAppend(Mutable, @"{");
    CFStringAppend(Mutable, v6);
    CFStringAppend(Mutable, @", ");
    CFStringAppend(Mutable, v9);
    CFStringAppend(Mutable, @"}");
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"{ERROR CONSTRUCTING DESCRIPTION}");
    if (!v6) {
      goto LABEL_7;
    }
  }
  CFRelease(v6);
LABEL_7:
  if (v9) {
    CFRelease(v9);
  }
  return Mutable;
}

void CMTimeMappingShow(CMTimeMapping *mapping)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  long long v2 = *(_OWORD *)&mapping->target.start.value;
  *(_OWORD *)&mappinga.source.duration.CMTimeScale timescale = *(_OWORD *)&mapping->source.duration.timescale;
  *(_OWORD *)&mappinga.target.start.uint64_t value = v2;
  long long v3 = *(_OWORD *)&mapping->target.duration.timescale;
  *(_OWORD *)&mappinga.target.start.CMTimeEpoch epoch = *(_OWORD *)&mapping->target.start.epoch;
  *(_OWORD *)&mappinga.target.duration.CMTimeScale timescale = v3;
  long long v4 = *(_OWORD *)&mapping->source.start.epoch;
  *(_OWORD *)&mappinga.source.start.uint64_t value = *(_OWORD *)&mapping->source.start.value;
  *(_OWORD *)&mappinga.source.start.CMTimeEpoch epoch = v4;
  CFStringRef v5 = CMTimeMappingCopyDescription(v1, &mappinga);
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  memset(&mappinga, 0, sizeof(mappinga));
  if (v5)
  {
    CFStringRef v6 = v5;
    if (CFStringGetCString(v5, (char *)&mappinga, 512, 0)) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s\n", (const char *)&mappinga);
    }
    CFRelease(v6);
  }
}

CMTimeRange *__cdecl CMTimeRangeFromTimeToTime(CMTimeRange *__return_ptr retstr, CMTime *start, CMTime *end)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  *(CMTime *)long long time1 = *start;
  CMTime time2 = *end;
  uint64_t result = (CMTimeRange *)CMTimeCompare((CMTime *)time1, &time2);
  if ((int)result >= 1
    || (CMTime time2 = *end,
        CMTime v9 = *start,
        uint64_t result = (CMTimeRange *)CMTimeSubtract((CMTime *)time1, &time2, &v9),
        *(_OWORD *)&time2.uint64_t value = *(_OWORD *)time1,
        *(void *)&time1[16]))
  {
    *(_OWORD *)&retstr->start.CMTimeEpoch epoch = 0u;
    *(_OWORD *)&retstr->duration.CMTimeScale timescale = 0u;
    *(_OWORD *)&retstr->start.uint64_t value = 0u;
  }
  else
  {
    *(void *)&time1[16] = start->epoch;
    *(_OWORD *)long long time1 = *(_OWORD *)&start->value;
    *(void *)&time1[24] = time2.value;
    uint64_t v7 = *(void *)&time2.timescale;
    long long v8 = *(_OWORD *)&time1[16];
    *(_OWORD *)&retstr->start.uint64_t value = *(_OWORD *)time1;
    *(_OWORD *)&retstr->start.CMTimeEpoch epoch = v8;
    *(void *)&retstr->duration.CMTimeScale timescale = v7;
    retstr->duration.CMTimeEpoch epoch = 0;
  }
  return result;
}

CMTime *CMSpeedRampMapTimeFromTargetToSource@<X0>(CMTime *result@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, CMTime *a4@<X8>)
{
  long long v4 = result;
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if ((result->flags & 0x1D) == 1)
  {
    unint64_t v34 = a3 - 1;
    if (((a3 - 1) & 0x8000000000000000) != 0)
    {
LABEL_22:
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&v4->value;
      time1.start.CMTimeEpoch epoch = v4->epoch;
      *(_OWORD *)&time.start.CMTimeValue value = *(_OWORD *)(a2 + 48);
      time.start.CMTimeEpoch epoch = *(void *)(a2 + 64);
      CMTimeSubtract(&v42, &time1.start, &time.start);
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)a2;
      time1.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
      long long v23 = &v42;
      p_CMTimeRange time1 = &time1;
      long long v25 = a4;
    }
    else
    {
      unint64_t v6 = 0;
      uint64_t v7 = a3 - 1;
      uint64_t v8 = a3 - 1;
      while (1)
      {
        uint64_t v9 = v8 + (v8 < 0);
        if (v6 >= a3) {
          break;
        }
        uint64_t v10 = v9 >> 1;
        uint64_t v11 = a2 + 96 * (v9 >> 1);
        CMTimeValue value = v4->value;
        CMTimeFlags flags = v4->flags;
        CMTimeScale timescale = v4->timescale;
        CMTimeEpoch epoch = v4->epoch;
        CMTimeValue v15 = *(void *)(v11 + 48);
        uint64_t v14 = v11 + 48;
        CMTimeValue v47 = v15;
        CMTimeFlags v16 = *(_DWORD *)(v14 + 12);
        CMTimeScale v48 = *(_DWORD *)(v14 + 8);
        CMTimeEpoch v17 = *(void *)(v14 + 16);
        if ((flags & 0x1F) == 3 || (v16 & 0x1F) == 3)
        {
          memset(&time1, 0, 24);
          lhs.CMTimeValue value = v4->value;
          lhs.CMTimeScale timescale = v4->timescale;
          lhs.CMTimeFlags flags = flags;
          lhs.CMTimeEpoch epoch = epoch;
          rhs.CMTimeValue value = *(void *)v14;
          rhs.CMTimeScale timescale = *(_DWORD *)(v14 + 8);
          rhs.CMTimeFlags flags = v16;
          rhs.CMTimeEpoch epoch = v17;
          CMTimeSubtract(&time.start, &lhs, &rhs);
          CMTimeAbsoluteValue(&time1.start, &time.start);
          CMTimeMake(&time2, 1, 1000000000);
          CMTime lhs = time1.start;
          if (CMTimeCompare(&lhs, &time2) <= 0) {
            goto LABEL_12;
          }
        }
        time1.start.CMTimeValue value = value;
        time1.start.CMTimeScale timescale = timescale;
        time1.start.CMTimeFlags flags = flags;
        time1.start.CMTimeEpoch epoch = epoch;
        lhs.CMTimeValue value = v47;
        lhs.CMTimeScale timescale = v48;
        lhs.CMTimeFlags flags = v16;
        lhs.CMTimeEpoch epoch = v17;
        if (CMTimeCompare(&time1.start, &lhs) < 0)
        {
          uint64_t v7 = v10 - 1;
        }
        else
        {
LABEL_12:
          long long v19 = *(_OWORD *)(v14 + 16);
          *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)v14;
          *(_OWORD *)&time1.start.CMTimeEpoch epoch = v19;
          uint64_t v20 = *(void *)(v14 + 40);
          *(void *)&time1.duration.CMTimeScale timescale = *(void *)(v14 + 32);
          if (v20)
          {
            memset(&v38, 0, sizeof(v38));
          }
          else
          {
            *(_OWORD *)&time.start.CMTimeValue value = *(_OWORD *)v14;
            time.start.CMTimeEpoch epoch = *(void *)(v14 + 16);
            *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&time1.duration.value;
            lhs.CMTimeEpoch epoch = 0;
            CMTimeAdd(&v38, &time.start, &lhs);
          }
          CMTimeValue value = v4->value;
          CMTimeFlags v21 = v4->flags;
          CMTimeScale timescale = v4->timescale;
          CMTimeEpoch v22 = v4->epoch;
          if ((v21 & 0x1F) != 3 && (v38.flags & 0x1F) != 3) {
            goto LABEL_35;
          }
          memset(&time1, 0, 24);
          lhs.CMTimeValue value = v4->value;
          lhs.CMTimeScale timescale = v4->timescale;
          lhs.CMTimeFlags flags = v21;
          lhs.CMTimeEpoch epoch = v22;
          CMTime rhs = v38;
          CMTimeSubtract(&time.start, &lhs, &rhs);
          CMTimeAbsoluteValue(&time1.start, &time.start);
          CMTimeMake(&time2, 1, 1000000000);
          CMTime lhs = time1.start;
          if (CMTimeCompare(&lhs, &time2) > 0)
          {
LABEL_35:
            time1.start.CMTimeValue value = value;
            time1.start.CMTimeScale timescale = timescale;
            time1.start.CMTimeFlags flags = v21;
            time1.start.CMTimeEpoch epoch = v22;
            CMTime lhs = v38;
            if (CMTimeCompare(&time1.start, &lhs) < 0)
            {
              CMTime lhs = *v4;
              long long v29 = (_OWORD *)(a2 + 96 * v10);
              long long v30 = *(_OWORD *)(v14 + 16);
              *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)v14;
              *(_OWORD *)&time1.start.CMTimeEpoch epoch = v30;
              *(_OWORD *)&time1.duration.CMTimeScale timescale = *(_OWORD *)(v14 + 32);
              long long v31 = v29[1];
              *(_OWORD *)&time.start.CMTimeValue value = *v29;
              *(_OWORD *)&time.start.CMTimeEpoch epoch = v31;
              *(_OWORD *)&time.duration.CMTimeScale timescale = v29[2];
              return CMTimeMapTimeFromRangeToRange(a4, &lhs, &time1, &time);
            }
          }
          unint64_t v6 = v10 + 1;
        }
        uint64_t v8 = v7 + v6;
        if (v7 < 0) {
          goto LABEL_22;
        }
      }
      uint64_t v26 = a2 + 96 * v34;
      long long v27 = *(_OWORD *)(v26 + 64);
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(v26 + 48);
      *(_OWORD *)&time1.start.CMTimeEpoch epoch = v27;
      uint64_t v28 = *(void *)(v26 + 88);
      *(void *)&time1.duration.CMTimeScale timescale = *(void *)(v26 + 80);
      if (v28)
      {
        memset(&v40, 0, sizeof(v40));
      }
      else
      {
        *(_OWORD *)&time.start.CMTimeValue value = *(_OWORD *)(v26 + 48);
        time.start.CMTimeEpoch epoch = *(void *)(v26 + 64);
        *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&time1.duration.value;
        lhs.CMTimeEpoch epoch = 0;
        CMTimeAdd(&v40, &time.start, &lhs);
      }
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&v4->value;
      time1.start.CMTimeEpoch epoch = v4->epoch;
      CMTimeSubtract(&v41, &time1.start, &v40);
      long long v32 = *(_OWORD *)(v26 + 16);
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)v26;
      *(_OWORD *)&time1.start.CMTimeEpoch epoch = v32;
      uint64_t v33 = *(void *)(v26 + 40);
      *(void *)&time1.duration.CMTimeScale timescale = *(void *)(v26 + 32);
      if (v33)
      {
        memset(&v39, 0, sizeof(v39));
      }
      else
      {
        *(_OWORD *)&time.start.CMTimeValue value = *(_OWORD *)v26;
        time.start.CMTimeEpoch epoch = *(void *)(v26 + 16);
        *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&time1.duration.value;
        lhs.CMTimeEpoch epoch = 0;
        CMTimeAdd(&v39, &time.start, &lhs);
      }
      long long v23 = &v41;
      p_CMTimeRange time1 = (CMTimeRange *)&v39;
      long long v25 = a4;
    }
    return CMTimeAdd(v25, v23, &p_time1->start);
  }
  else
  {
    *(_OWORD *)&a4->CMTimeValue value = *(_OWORD *)&result->value;
    a4->CMTimeEpoch epoch = result->epoch;
  }
  return result;
}

CMTime *CMSpeedRampMapTimeFromSourceToTarget@<X0>(CMTime *result@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, CMTime *a4@<X8>)
{
  long long v4 = result;
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if ((result->flags & 0x1D) == 1)
  {
    unint64_t v34 = a3 - 1;
    if (((a3 - 1) & 0x8000000000000000) != 0)
    {
LABEL_22:
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&v4->value;
      time1.start.CMTimeEpoch epoch = v4->epoch;
      *(_OWORD *)&time.start.CMTimeValue value = *(_OWORD *)a2;
      time.start.CMTimeEpoch epoch = *(void *)(a2 + 16);
      CMTimeSubtract(&v41, &time1.start, &time.start);
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(a2 + 48);
      time1.start.CMTimeEpoch epoch = *(void *)(a2 + 64);
      CMTimeFlags v21 = &v41;
      p_CMTimeRange time1 = &time1;
      long long v23 = a4;
    }
    else
    {
      unint64_t v6 = 0;
      uint64_t v7 = a3 - 1;
      uint64_t v8 = a3 - 1;
      while (1)
      {
        uint64_t v9 = v8 + (v8 < 0);
        if (v6 >= a3) {
          break;
        }
        uint64_t v10 = v9 >> 1;
        uint64_t v11 = a2 + 96 * (v9 >> 1);
        CMTimeValue value = v4->value;
        CMTimeFlags flags = v4->flags;
        CMTimeScale timescale = v4->timescale;
        CMTimeEpoch epoch = v4->epoch;
        CMTimeValue v46 = *(void *)v11;
        CMTimeFlags v14 = *(_DWORD *)(v11 + 12);
        CMTimeScale v47 = *(_DWORD *)(v11 + 8);
        CMTimeEpoch v15 = *(void *)(v11 + 16);
        if ((flags & 0x1F) == 3 || (v14 & 0x1F) == 3)
        {
          memset(&time1, 0, 24);
          lhs.CMTimeValue value = v4->value;
          lhs.CMTimeScale timescale = v4->timescale;
          lhs.CMTimeFlags flags = flags;
          lhs.CMTimeEpoch epoch = epoch;
          rhs.CMTimeValue value = *(void *)v11;
          rhs.CMTimeScale timescale = *(_DWORD *)(v11 + 8);
          rhs.CMTimeFlags flags = v14;
          rhs.CMTimeEpoch epoch = v15;
          CMTimeSubtract(&time.start, &lhs, &rhs);
          CMTimeAbsoluteValue(&time1.start, &time.start);
          CMTimeMake(&time2, 1, 1000000000);
          CMTime lhs = time1.start;
          if (CMTimeCompare(&lhs, &time2) <= 0) {
            goto LABEL_12;
          }
        }
        time1.start.CMTimeValue value = value;
        time1.start.CMTimeScale timescale = timescale;
        time1.start.CMTimeFlags flags = flags;
        time1.start.CMTimeEpoch epoch = epoch;
        lhs.CMTimeValue value = v46;
        lhs.CMTimeScale timescale = v47;
        lhs.CMTimeFlags flags = v14;
        lhs.CMTimeEpoch epoch = v15;
        if (CMTimeCompare(&time1.start, &lhs) < 0)
        {
          uint64_t v7 = v10 - 1;
        }
        else
        {
LABEL_12:
          long long v17 = *(_OWORD *)(v11 + 16);
          *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)v11;
          *(_OWORD *)&time1.start.CMTimeEpoch epoch = v17;
          uint64_t v18 = *(void *)(v11 + 40);
          *(void *)&time1.duration.CMTimeScale timescale = *(void *)(v11 + 32);
          if (v18)
          {
            memset(&v37, 0, sizeof(v37));
          }
          else
          {
            *(_OWORD *)&time.start.CMTimeValue value = *(_OWORD *)v11;
            time.start.CMTimeEpoch epoch = *(void *)(v11 + 16);
            *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&time1.duration.value;
            lhs.CMTimeEpoch epoch = 0;
            CMTimeAdd(&v37, &time.start, &lhs);
          }
          CMTimeValue value = v4->value;
          CMTimeFlags v19 = v4->flags;
          CMTimeScale timescale = v4->timescale;
          CMTimeEpoch v20 = v4->epoch;
          if ((v19 & 0x1F) != 3 && (v37.flags & 0x1F) != 3) {
            goto LABEL_35;
          }
          memset(&time1, 0, 24);
          lhs.CMTimeValue value = v4->value;
          lhs.CMTimeScale timescale = v4->timescale;
          lhs.CMTimeFlags flags = v19;
          lhs.CMTimeEpoch epoch = v20;
          CMTime rhs = v37;
          CMTimeSubtract(&time.start, &lhs, &rhs);
          CMTimeAbsoluteValue(&time1.start, &time.start);
          CMTimeMake(&time2, 1, 1000000000);
          CMTime lhs = time1.start;
          if (CMTimeCompare(&lhs, &time2) > 0)
          {
LABEL_35:
            time1.start.CMTimeValue value = value;
            time1.start.CMTimeScale timescale = timescale;
            time1.start.CMTimeFlags flags = v19;
            time1.start.CMTimeEpoch epoch = v20;
            CMTime lhs = v37;
            if (CMTimeCompare(&time1.start, &lhs) < 0)
            {
              CMTime lhs = *v4;
              long long v27 = (_OWORD *)(a2 + 96 * v10);
              long long v28 = *(_OWORD *)(v11 + 16);
              *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)v11;
              *(_OWORD *)&time1.start.CMTimeEpoch epoch = v28;
              *(_OWORD *)&time1.duration.CMTimeScale timescale = *(_OWORD *)(v11 + 32);
              long long v29 = v27[4];
              *(_OWORD *)&time.start.CMTimeValue value = v27[3];
              *(_OWORD *)&time.start.CMTimeEpoch epoch = v29;
              *(_OWORD *)&time.duration.CMTimeScale timescale = v27[5];
              return CMTimeMapTimeFromRangeToRange(a4, &lhs, &time1, &time);
            }
          }
          unint64_t v6 = v10 + 1;
        }
        uint64_t v8 = v7 + v6;
        if (v7 < 0) {
          goto LABEL_22;
        }
      }
      uint64_t v24 = a2 + 96 * v34;
      long long v25 = *(_OWORD *)(v24 + 16);
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)v24;
      *(_OWORD *)&time1.start.CMTimeEpoch epoch = v25;
      uint64_t v26 = *(void *)(v24 + 40);
      *(void *)&time1.duration.CMTimeScale timescale = *(void *)(v24 + 32);
      if (v26)
      {
        memset(&v39, 0, sizeof(v39));
      }
      else
      {
        *(_OWORD *)&time.start.CMTimeValue value = *(_OWORD *)v24;
        time.start.CMTimeEpoch epoch = *(void *)(v24 + 16);
        *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&time1.duration.value;
        lhs.CMTimeEpoch epoch = 0;
        CMTimeAdd(&v39, &time.start, &lhs);
      }
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)&v4->value;
      time1.start.CMTimeEpoch epoch = v4->epoch;
      CMTimeSubtract(&v40, &time1.start, &v39);
      uint64_t v30 = a2 + 96 * v34;
      long long v31 = *(_OWORD *)(v30 + 64);
      *(_OWORD *)&time1.start.CMTimeValue value = *(_OWORD *)(v30 + 48);
      *(_OWORD *)&time1.start.CMTimeEpoch epoch = v31;
      uint64_t v32 = *(void *)(v30 + 88);
      *(void *)&time1.duration.CMTimeScale timescale = *(void *)(v30 + 80);
      if (v32)
      {
        memset(&v38, 0, sizeof(v38));
      }
      else
      {
        *(_OWORD *)&time.start.CMTimeValue value = *(_OWORD *)(v30 + 48);
        time.start.CMTimeEpoch epoch = *(void *)(v30 + 64);
        *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&time1.duration.value;
        lhs.CMTimeEpoch epoch = 0;
        CMTimeAdd(&v38, &time.start, &lhs);
      }
      CMTimeFlags v21 = &v40;
      p_CMTimeRange time1 = (CMTimeRange *)&v38;
      long long v23 = a4;
    }
    return CMTimeAdd(v23, v21, &p_time1->start);
  }
  else
  {
    *(_OWORD *)&a4->CMTimeValue value = *(_OWORD *)&result->value;
    a4->CMTimeEpoch epoch = result->epoch;
  }
  return result;
}

uint64_t FigEndpointMessengerXPCRemotePing()
{
  CFStringRef v5 = 0;
  uint64_t v0 = figEndpointMessengerRemoteXPC_EnsureClientEstablished();
  if (v0)
  {
    uint64_t v3 = v0;
    long long v2 = 0;
  }
  else
  {
    uint64_t v1 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &v5);
    long long v2 = v5;
    if (v1)
    {
      uint64_t v3 = v1;
    }
    else
    {
      uint64_t v3 = FigXPCRemoteClientSendSyncMessage(gFigEndpointMessengerRemoteClient, (uint64_t)v5);
      long long v2 = v5;
    }
  }
  FigXPCRelease(v2);
  return v3;
}

uint64_t figEndpointMessengerRemoteXPC_EnsureClientEstablished()
{
  uint64_t v3 = 0;
  long long v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __figEndpointMessengerRemoteXPC_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E567A1B8;
  void block[4] = &v3;
  if (figEndpointMessengerRemoteXPC_EnsureClientEstablished_gFigEndpointMessengerClientSetupOnce != -1) {
    dispatch_once(&figEndpointMessengerRemoteXPC_EnsureClientEstablished_gFigEndpointMessengerClientSetupOnce, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t FigEndpointMessengerXPCRemoteCreateWithObjectID(const void *a1, void *a2)
{
  if (a1 && a2)
  {
    uint64_t v4 = figEndpointMessengerRemoteXPC_EnsureClientEstablished();
    if (v4) {
      return v4;
    }
    uint64_t v9 = 0;
    uint64_t v5 = *MEMORY[0x1E4F1CF80];
    ClassID = (void *)FigEndpointMessengerGetClassID();
    uint64_t v7 = CMDerivedObjectCreate(v5, (uint64_t)&kEndpointMessengerRemoteXPC_MessengerVTable, ClassID, &v9);
    if (!v7)
    {
      *(void *)(CMBaseObjectGetDerivedStorage(v9) + 8) = a1;
      FigXPCRemoteClientAssociateObject(gFigEndpointMessengerRemoteClient, v9, a1);
    }
    *a2 = v9;
    return v7;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t remoteXPCEndpointMessenger_DeadConnectionCallback(uint64_t a1)
{
  uint64_t result = CMBaseObjectGetDerivedStorage(a1);
  *(unsigned char *)(result + 1) = 1;
  return result;
}

uint64_t remoteXPCEndpointMessenger_handleClientMessage(uint64_t a1, void *a2)
{
  int v7 = 0;
  uint64_t result = FigXPCMessageGetOpCode(a2, &v7);
  if (!result)
  {
    if (v7 == 1869968493)
    {
      CFTypeRef cf = 0;
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
      if (*(void *)(DerivedStorage + 16))
      {
        uint64_t v6 = DerivedStorage;
        xpc_dictionary_get_uint64(a2, "MessageType");
        FigXPCMessageCopyCFObject(a2, "Payload", (__CFDictionary **)&cf);
        (*(void (**)(void))(*(void *)(v6 + 16) + 16))();
        if (cf) {
          CFRelease(cf);
        }
      }
      return 0;
    }
    else
    {
      return 4294966630;
    }
  }
  return result;
}

void FigEndpointMessengerRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = DerivedStorage;
  xpc_object_t v5 = 0;
  if (!*(unsigned char *)DerivedStorage)
  {
    uint64_t v3 = *(const void **)(DerivedStorage + 8);
    if (!FigXPCRemoteClientDisassociateObject(gFigEndpointMessengerRemoteClient, v3)
      && !*(unsigned char *)(v2 + 1)
      && !FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v3, &v5))
    {
      uint64_t v4 = FigXPCRemoteClientSendSyncMessage(gFigEndpointMessengerRemoteClient, (uint64_t)v5);
      FigXPCRemoteClientKillServerOnTimeout(gFigEndpointMessengerRemoteClient, v4, "FigEndpointMessengerRemoteXPC_teardown", 0);
    }
  }
  _Block_release(*(const void **)(v2 + 16));
  FigXPCRelease(v5);
}

uint64_t FigEndpointMessengerRemoteXPC_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  CFTypeRef cf = 0;
  uint64_t v12 = 0;
  uint64_t ObjectID = remoteXPCEndpointMessenger_GetObjectID(a1, &v12);
  if (ObjectID)
  {
    uint64_t v7 = ObjectID;
    if (!a4) {
      goto LABEL_11;
    }
    CFTypeRef v8 = 0;
LABEL_7:
    CFTypeRef v9 = 0;
    goto LABEL_8;
  }
  uint64_t v7 = FigXPCSendStdCopyPropertyMessage(gFigEndpointMessengerRemoteClient, v12, a2, &cf);
  CFTypeRef v8 = cf;
  if (!a4) {
    goto LABEL_9;
  }
  if (!cf) {
    goto LABEL_7;
  }
  CFTypeRef v9 = CFRetain(cf);
  CFTypeRef v8 = cf;
LABEL_8:
  *a4 = v9;
LABEL_9:
  if (v8) {
    CFRelease(v8);
  }
LABEL_11:
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointMessengerRemoteClient, v7, "FigEndpointMessengerRemoteXPC_CopyProperty", a2);
  return v7;
}

uint64_t FigEndpointMessengerRemoteXPC_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v8 = 0;
  uint64_t ObjectID = remoteXPCEndpointMessenger_GetObjectID(a1, &v8);
  if (!ObjectID) {
    uint64_t ObjectID = FigXPCSendStdSetPropertyMessage(gFigEndpointMessengerRemoteClient, v8, a2, a3);
  }
  uint64_t v6 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointMessengerRemoteClient, ObjectID, "FigEndpointMessengerRemoteXPC_SetProperty", a2);
  return v6;
}

uint64_t remoteXPCEndpointMessenger_GetObjectID(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v5 = 4294954511;
  }
  else
  {
    if (!*(unsigned char *)(DerivedStorage + 1))
    {
      *a2 = *(void *)(DerivedStorage + 8);
      return 0;
    }
    uint64_t v5 = 4294966630;
  }

  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointMessengerRemoteXPC_SetMessageHandler(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v8 = 0;
  xpc_object_t v9 = 0;
  uint64_t ObjectID = remoteXPCEndpointMessenger_GetObjectID(a1, &v8);
  if (ObjectID || (uint64_t ObjectID = FigXPCCreateBasicMessage(0x7368646Cu, v8, &v9), ObjectID))
  {
    uint64_t v6 = ObjectID;
  }
  else
  {
    uint64_t v6 = FigXPCRemoteClientSendSyncMessage(gFigEndpointMessengerRemoteClient, (uint64_t)v9);
    if (!v6) {
      *(void *)(DerivedStorage + 16) = _Block_copy(a2);
    }
  }
  FigXPCRelease(v9);
  return v6;
}

uint64_t FigEndpointMessengerRemoteXPC_SendMessage(uint64_t a1, unsigned int a2, const void *a3)
{
  uint64_t v8 = 0;
  xpc_object_t xdict = 0;
  uint64_t ObjectID = remoteXPCEndpointMessenger_GetObjectID(a1, &v8);
  if (!ObjectID)
  {
    uint64_t ObjectID = FigXPCCreateBasicMessage(0x736D7367u, v8, &xdict);
    if (!ObjectID)
    {
      xpc_dictionary_set_uint64(xdict, "MessageType", a2);
      if (!a2)
      {
        uint64_t v6 = 4294966630;
        goto LABEL_9;
      }
      if (!a3 || (uint64_t ObjectID = FigXPCMessageSetCFObject(xdict, "Payload", a3), !ObjectID)) {
        uint64_t ObjectID = FigXPCRemoteClientSendSyncMessage(gFigEndpointMessengerRemoteClient, (uint64_t)xdict);
      }
    }
  }
  uint64_t v6 = ObjectID;
LABEL_9:
  FigXPCRelease(xdict);
  return v6;
}

uint64_t FigRetainProxyGetTypeID()
{
  return sFigRetainProxyID;
}

uint64_t RegisterFigRetainProxyType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigRetainProxyID = result;
  return result;
}

uint64_t FigRetainProxyIsInvalidated(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 48);
}

uint64_t FigRetainProxyInvalidate(uint64_t a1)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  *(unsigned char *)(a1 + 48) = 1;
  uint64_t v2 = *(pthread_mutex_t **)(a1 + 16);

  return FigReentrantMutexUnlock(v2);
}

CFTypeRef FigRetainProxyRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void FigRetainProxyRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t FigRetainProxyLockMutex(uint64_t a1)
{
  uint64_t v2 = FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  figRetainProxyIncrementLockCount(a1);
  return v2;
}

void figRetainProxyIncrementLockCount(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = v1 + 1;
  if (!v1)
  {
    uint64_t v3 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 32));
    if (v3 == *(id **)(a1 + 24))
    {
      *(unsigned char *)(a1 + 49) = 1;
    }
    else
    {
      if (v3) {
        CFRelease(v3);
      }
      *(unsigned char *)(a1 + 48) = 1;
    }
  }
}

BOOL FigRetainProxyTryLockMutex(uint64_t a1)
{
  BOOL v2 = FigReentrantMutexTryLock(*(pthread_mutex_t **)(a1 + 16));
  if (v2) {
    figRetainProxyIncrementLockCount(a1);
  }
  return v2;
}

uint64_t FigRetainProxyGetLockCount(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t FigRetainProxyConditionVariableWaitRelative(uint64_t a1, pthread_cond_t *a2, unint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 40) - 1;
  *(void *)(a1 + 40) = v6;
  if (!v6 && *(unsigned char *)(a1 + 49) == 1)
  {
    *(unsigned char *)(a1 + 49) = 0;
    uint64_t v7 = *(const void **)(a1 + 24);
    if (v7) {
      CFRelease(v7);
    }
  }
  uint64_t v8 = FigConditionVariableWaitRelative(a2, *(pthread_mutex_t **)(a1 + 16), a3);
  figRetainProxyIncrementLockCount(a1);
  return v8;
}

uint64_t FigRetainProxyUnlockMutex(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40) - 1;
  *(void *)(a1 + 40) = v1;
  if (v1 || *(unsigned char *)(a1 + 49) != 1)
  {
    uint64_t v5 = *(pthread_mutex_t **)(a1 + 16);
    return FigReentrantMutexUnlock(v5);
  }
  else
  {
    *(unsigned char *)(a1 + 49) = 0;
    BOOL v2 = *(const void **)(a1 + 24);
    uint64_t v3 = FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    if (v2) {
      CFRelease(v2);
    }
    return v3;
  }
}

uint64_t FigRetainProxyUnlockAll(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (*(unsigned char *)(a1 + 49))
  {
    *(unsigned char *)(a1 + 49) = 0;
    uint64_t v3 = *(const void **)(a1 + 24);
    if (v3) {
      CFRelease(v3);
    }
  }
  if (v2 >= 1)
  {
    uint64_t v4 = v2;
    do
    {
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
      --v4;
    }
    while (v4);
  }
  return v2;
}

void FigRetainProxyRelock(uint64_t a1, uint64_t a2)
{
  do
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    figRetainProxyIncrementLockCount(a1);
  }
  while (*(void *)(a1 + 40) < a2);
}

uint64_t FigRetainProxyGetOwner(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

CFTypeRef FigRetainProxyRetainOwner(uint64_t a1)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 24);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void FigRetainProxyReleaseOwner(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t FigRetainProxyCreate(const __CFAllocator *a1, uint64_t a2, void *a3)
{
  if (a2 && a3)
  {
    FigThreadRunOnce(&sRegisterFigRetainProxyTypeOnce, (void (*)(void))RegisterFigRetainProxyType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v7 = (void *)Instance;
      uint64_t v8 = FigReentrantMutexCreateWithFlags(a1);
      v7[2] = v8;
      if (v8 && (v7[3] = a2, CFTypeRef v9 = FigCFWeakReferenceHolderCreateWithReferencedObject(a2), (v7[4] = v9) != 0))
      {
        v7[5] = 0;
        *a3 = v7;
        return 0;
      }
      else
      {
        uint64_t v11 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        CFRelease(v7);
        return v11;
      }
    }
    uint64_t v12 = 4294954510;
  }
  else
  {
    uint64_t v12 = 4294954516;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

double FigRetainProxyInit(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

__n128 FigRetainProxyFinalize(__n128 *a1)
{
  uint64_t v2 = (const void *)a1[2].n128_u64[0];
  if (v2) {
    CFRelease(v2);
  }
  unint64_t v5 = a1[1].n128_u64[0];
  uint64_t v4 = a1 + 1;
  unint64_t v3 = v5;
  if (v5) {
    FigReentrantMutexDestroy(v3);
  }
  v4[2].n128_u64[0] = -1;
  result.n128_u64[0] = -1;
  result.n128_u64[1] = -1;
  *uint64_t v4 = result;
  v4[1] = result;
  return result;
}

CFStringRef FigRetainProxyCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigRetainProxy %p]", a1);
}

CFStringRef FigRetainProxyCopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v3 = *(void *)(a1 + 24);
  if (*(unsigned char *)(a1 + 49)) {
    uint64_t v4 = " retained";
  }
  else {
    uint64_t v4 = "";
  }
  CFIndex v5 = CFGetRetainCount((CFTypeRef)a1);
  return CFStringCreateWithFormat(v2, 0, @"[FigRetainProxy %p owner %p%s retain count %d lock count %d", a1, v3, v4, v5, *(void *)(a1 + 40));
}

uint64_t FigIsReferenceAllowedBySecurityPolicy(const __CFURL *a1, const __CFURL *a2, char a3)
{
  int URLZone = GetURLZone(a1);
  int v7 = GetURLZone(a2);
  if ((a3 & 2) != 0 && URLZone == 2 && v7 == 1 || (a3 & 4) != 0 && URLZone == 1 && v7 == 2) {
    return 0;
  }
  if ((a3 & 0x10) == 0 || URLZone != 1 || v7 != 1)
  {
    uint64_t v11 = 1;
    if ((a3 & 8) == 0 || URLZone != 2 || v7 != 2) {
      return v11;
    }
    CFStringRef v12 = CFURLCopyScheme(a1);
    CFStringRef v13 = CFURLCopyScheme(a2);
    CFStringRef v8 = CFURLCopyHostName(a1);
    CFStringRef v14 = CFURLCopyHostName(a2);
    CFStringRef v10 = v14;
    if (v12 && v8 && v13 && v14)
    {
      if (CFStringCompare(v12, v13, 1uLL)) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = CFStringCompare(v8, v10, 1uLL) == kCFCompareEqualTo;
      }
    }
    else if (!v12)
    {
LABEL_29:
      if (v13) {
        CFRelease(v13);
      }
LABEL_31:
      if (!v8) {
        goto LABEL_33;
      }
      goto LABEL_32;
    }
    CFRelease(v12);
    goto LABEL_29;
  }
  CFStringRef v8 = (const __CFString *)CFURLCopyAbsoluteURL(a1);
  CFURLRef v9 = CFURLCopyAbsoluteURL(a2);
  CFStringRef v10 = (const __CFString *)v9;
  if (!v8 || !v9)
  {
    uint64_t v11 = 1;
    goto LABEL_31;
  }
  uint64_t v11 = CFEqual(v8, v9);
LABEL_32:
  CFRelease(v8);
LABEL_33:
  if (v10) {
    CFRelease(v10);
  }
  return v11;
}

uint64_t GetURLZone(const __CFURL *a1)
{
  if (!a1) {
    return 0;
  }
  CFStringRef v1 = CFURLCopyScheme(a1);
  if (!v1) {
    return 0;
  }
  CFStringRef v2 = v1;
  uint64_t v3 = 1;
  if (CFStringCompare(v1, @"file", 1uLL))
  {
    if (CFStringCompare(v2, @"res", 1uLL)) {
      uint64_t v3 = 2;
    }
    else {
      uint64_t v3 = 1;
    }
  }
  CFRelease(v2);
  return v3;
}

uint64_t FigCustomURLLoaderRemoteCreateWithObjectID(const void *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  if (figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce != -1) {
    dispatch_once(&figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce, &__block_literal_global_34);
  }
  uint64_t v4 = figCustomURLLoaderRemote_EnsureClientEstablished_err;
  if (!figCustomURLLoaderRemote_EnsureClientEstablished_err)
  {
    CFIndex v5 = (const void *)*MEMORY[0x1E4F1CF80];
    ClassID = (void *)FigCustomURLLoaderGetClassID();
    uint64_t v7 = CMDerivedObjectCreate((uint64_t)v5, (uint64_t)&kFigCustomURLLoaderRemote_VTable, ClassID, &cf);
    CFTypeRef v8 = cf;
    if (!v7)
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      *uint64_t DerivedStorage = a1;
      uint64_t v10 = FigCustomURLLoaderCreate(v5, 0, DerivedStorage + 3);
      if (v10)
      {
        uint64_t v4 = v10;
        CFTypeRef v8 = cf;
LABEL_12:
        if (v8) {
          CFRelease(v8);
        }
        return v4;
      }
      uint64_t v7 = FigCFWeakReferenceTableCreate((const __CFAllocator *)v5, 1, DerivedStorage + 2);
      CFTypeRef v8 = cf;
      if (!v7)
      {
        uint64_t v4 = FigXPCRemoteClientAssociateObject(gFigCustomURLLoaderRemoteClient, (uint64_t)cf, a1);
        CFTypeRef v8 = cf;
        if (!v4)
        {
          *a2 = cf;
          return v4;
        }
        goto LABEL_12;
      }
    }
    uint64_t v4 = v7;
    goto LABEL_12;
  }
  return v4;
}

uint64_t figCustomURLLoaderRemote_GetObjectID(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)(DerivedStorage + 8))
  {
    uint64_t v5 = 4294949911;
  }
  else
  {
    if (!*(unsigned char *)(DerivedStorage + 9))
    {
      *a2 = *(void *)DerivedStorage;
      return 0;
    }
    uint64_t v5 = 4294949910;
  }

  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t figCustomURLLoaderRemote_DeadConnectionCallback(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  uint64_t result = FigCustomURLLoaderGetCFTypeID();
  if (v2 == result)
  {
    uint64_t result = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    *(unsigned char *)(result + 8) = 1;
  }
  return result;
}

void figCustomURLLoaderRemote_serverStatePurged(const void *a1, uint64_t a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == FigCustomURLLoaderGetCFTypeID())
  {
    *(unsigned char *)(CMBaseObjectGetDerivedStorage((uint64_t)a1) + 9) = 1;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    FigCFDictionarySetInt64(Mutable, @"PurgeIdentifier", a2);
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification(DefaultLocalCenter, @"CustomURLLoader_ServerStatePurged", a1, Mutable);
    if (Mutable)
    {
      CFRelease(Mutable);
    }
  }
}

void figCustomURLLoaderRemote_Finalize(uint64_t a1)
{
  uint64_t v7 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigXPCRemoteClientDisassociateObject(gFigCustomURLLoaderRemoteClient, *(const void **)DerivedStorage);
  CFTypeID v2 = *(void **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    if (*(unsigned char *)(DerivedStorage + 8) || *(unsigned char *)(DerivedStorage + 9))
    {
      CFTypeID v2 = 0;
    }
    else
    {
      int v5 = FigXPCCreateBasicMessage(0x636C4469u, (uint64_t)v2, &v7);
      CFTypeID v2 = v7;
      if (!v5)
      {
        uint64_t v6 = FigXPCRemoteClientSendAsyncMessage(gFigCustomURLLoaderRemoteClient, v7);
        FigXPCRemoteClientKillServerOnTimeout(gFigCustomURLLoaderRemoteClient, v6, "figCustomURLLoaderRemote_Finalize", 0);
        CFTypeID v2 = v7;
      }
    }
  }
  FigXPCRelease(v2);
  uint64_t v3 = *(const void **)(DerivedStorage + 16);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(DerivedStorage + 16) = 0;
  }
  CFTypeID v4 = *(const void **)(DerivedStorage + 24);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(DerivedStorage + 24) = 0;
  }
}

uint64_t figCustomURLLoaderRemote_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v5 = *(void *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v6 = gFigCustomURLLoaderRemoteClient;

  return FigXPCSendStdSetPropertyMessage(v6, v5, a2, a3);
}

uint64_t figCustomURLLoaderRemote_CreateAndInstallHandler(uint64_t a1, int64_t a2, const char *a3, uint64_t a4, NSObject *a5, uint64_t a6, const void *a7, CFTypeRef *a8)
{
  CFTypeRef cf = 0;
  if (figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce != -1) {
    dispatch_once(&figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce, &__block_literal_global_34);
  }
  uint64_t v16 = figCustomURLLoaderRemote_EnsureClientEstablished_err;
  if (!figCustomURLLoaderRemote_EnsureClientEstablished_err)
  {
    uint64_t v17 = FigCustomURLHandlerCreate((const void *)*MEMORY[0x1E4F1CF80], a3, a4, a5, a6, (uint64_t)a7, &cf);
    CFTypeRef v18 = cf;
    if (v17)
    {
      uint64_t v16 = v17;
LABEL_25:
      if (v18) {
        CFRelease(v18);
      }
      return v16;
    }
    int v32 = 0;
    xpc_object_t v30 = 0;
    xpc_object_t xdict = 0;
    uint64_t v28 = 0;
    uint64_t value = 0;
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    uint64_t ObjectID = figCustomURLLoaderRemote_GetObjectID(a1, &v28);
    if (!ObjectID)
    {
      uint64_t ObjectID = FigCustomURLHandlerServerEnsure();
      if (!ObjectID)
      {
        uint64_t ObjectID = FigXPCRemoteClientGetServerPID(gFigCustomURLLoaderRemoteClient, &v32);
        if (!ObjectID)
        {
          uint64_t ObjectID = FigCustomURLHandlerServerAssociateObjectByPID(v32, v18, &value);
          if (!ObjectID)
          {
            uint64_t ObjectID = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(void *)(DerivedStorage + 16), (uint64_t)v18, value);
            if (!ObjectID)
            {
              uint64_t v21 = *(void *)(DerivedStorage + 24);
              uint64_t v22 = *(void *)(CMBaseObjectGetVTable(v21) + 16);
              if (v22) {
                uint64_t v23 = v22;
              }
              else {
                uint64_t v23 = 0;
              }
              uint64_t v24 = *(uint64_t (**)(uint64_t, CFTypeRef, int64_t))(v23 + 8);
              if (!v24)
              {
                xpc_object_t v25 = 0;
                uint64_t v16 = 4294954514;
                goto LABEL_20;
              }
              uint64_t ObjectID = v24(v21, v18, a2);
              if (!ObjectID)
              {
                uint64_t ObjectID = FigXPCCreateBasicMessage(0x636C4349u, v28, &xdict);
                if (!ObjectID)
                {
                  uint64_t ObjectID = figCustomURLLoaderRemote_addHandshakeParameters(xdict);
                  if (!ObjectID)
                  {
                    xpc_dictionary_set_uint64(xdict, "CustomURLLoader_HandlerID", value);
                    xpc_dictionary_set_int64(xdict, "CustomURLLoader_Priority", a2);
                    uint64_t ObjectID = FigXPCMessageSetCFDictionary(xdict, "CustomURLLoader_CreateOptions", a7);
                    if (!ObjectID)
                    {
                      uint64_t v16 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigCustomURLLoaderRemoteClient, (uint64_t)xdict, &v30);
                      xpc_object_t v25 = v30;
                      goto LABEL_20;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    uint64_t v16 = ObjectID;
    xpc_object_t v25 = 0;
LABEL_20:
    FigXPCRelease(v25);
    FigXPCRelease(xdict);
    CFTypeRef v18 = cf;
    if (!v16)
    {
      *a8 = cf;
      return v16;
    }
    goto LABEL_25;
  }
  return v16;
}

uint64_t figCustomURLLoaderRemote_GetURL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (DerivedStorage && (uint64_t v12 = *(void *)(DerivedStorage + 24)) != 0)
  {
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable(*(void *)(DerivedStorage + 24)) + 16);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    CMTimeEpoch v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 24);
    if (v15)
    {
      return v15(v12, a2, a3, a4, a5, a6);
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figCustomURLLoaderRemote_CancelRequest(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (DerivedStorage && (uint64_t v4 = *(void *)(DerivedStorage + 24)) != 0)
  {
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable(*(void *)(DerivedStorage + 24)) + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 32);
    if (v7)
    {
      return v7(v4, a2);
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figCustomURLLoaderRemote_TransferHandlingOfRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = 0;
  xpc_object_t xdict = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t ObjectID = figCustomURLLoaderRemote_GetObjectID(a1, &v15);
  if (ObjectID)
  {
    uint64_t v10 = ObjectID;
LABEL_10:
    xpc_object_t v13 = 0;
    goto LABEL_8;
  }
  if (figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce != -1) {
    dispatch_once(&figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce, &__block_literal_global_34);
  }
  uint64_t v10 = figCustomURLLoaderRemote_EnsureClientEstablished_err;
  if (figCustomURLLoaderRemote_EnsureClientEstablished_err) {
    goto LABEL_10;
  }
  uint64_t Key = FigCFWeakReferenceTableGetKey(*(void *)(DerivedStorage + 16), a2);
  uint64_t v12 = FigCFWeakReferenceTableGetKey(*(void *)(DerivedStorage + 16), a3);
  uint64_t v10 = FigXPCCreateBasicMessage(0x636C5452u, v15, &xdict);
  xpc_object_t v13 = xdict;
  if (!v10)
  {
    uint64_t v10 = figCustomURLLoaderRemote_addHandshakeParameters(xdict);
    xpc_object_t v13 = xdict;
    if (!v10)
    {
      xpc_dictionary_set_uint64(xdict, "CustomURLLoader_FromHandlerID", Key);
      xpc_dictionary_set_uint64(xdict, "CustomURLLoader_ToHandlerID", v12);
      xpc_dictionary_set_uint64(xdict, "CustomURLLoader_RequestID", a4);
      uint64_t v10 = FigXPCRemoteClientSendSyncMessage(gFigCustomURLLoaderRemoteClient, (uint64_t)xdict);
      xpc_object_t v13 = xdict;
    }
  }
LABEL_8:
  FigXPCRelease(v13);
  return v10;
}

uint64_t figCustomURLLoaderRemote_addHandshakeParameters(void *a1)
{
  xpc_object_t value = 0;
  uint64_t v2 = FigCustomURLHandlerServerCopyXPCEndpoint(&value);
  if (!v2) {
    xpc_dictionary_set_value(a1, "CustomURLLoader_Endpoint", value);
  }
  FigXPCRelease(value);
  return v2;
}

uint64_t FigManagedFilePoolGetTypeID()
{
  return sFigManagedFilePoolID;
}

uint64_t RegisterFigManagedFilePoolType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigManagedFilePoolID = result;
  return result;
}

uint64_t FigManagedFilePoolCreate(int64_t a1, CFAllocatorRef Default, void *a3)
{
  if (a1 <= 0)
  {
    uint64_t v12 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    uint64_t v7 = 0;
LABEL_14:
    if (!a3) {
      return v12;
    }
LABEL_15:
    *a3 = v7;
    return v12;
  }
  if (a3)
  {
    FigThreadRunOnce(&sRegisterFigManagedFilePoolTypeOnce, (void (*)(void))RegisterFigManagedFilePoolType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v7 = (void *)Instance;
    if (!Instance)
    {
      uint64_t v12 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      goto LABEL_15;
    }
    if (Default)
    {
      *(void *)(Instance + 16) = Default;
    }
    else
    {
      Default = CFAllocatorGetDefault();
      v7[2] = Default;
      if (!Default) {
        goto LABEL_8;
      }
    }
    CFRetain(Default);
LABEL_8:
    CFTypeRef v8 = FigReentrantMutexCreate();
    void v7[3] = v8;
    if (!v8 || (CFURLRef v9 = (char *)malloc_type_calloc(a1, 0x10uLL, 0x20040A4A59CD2uLL)) == 0)
    {
      uint64_t v12 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      if (v12)
      {
        CFRelease(v7);
        uint64_t v7 = 0;
      }
      goto LABEL_15;
    }
    if ((unint64_t)a1 >= 2)
    {
      int64_t v10 = a1 - 1;
      uint64_t v11 = v9 + 16;
      do
      {
        *((void *)v11 - 2) = v11;
        v11 += 16;
        --v10;
      }
      while (v10);
    }
    uint64_t v12 = 0;
    void v7[6] = a1;
    v7[7] = v9;
    goto LABEL_14;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigGetDefaultManagedFilePool()
{
  return sFigDefaultManagedFilePool;
}

uint64_t createDefaultManagedFilePool()
{
  return FigManagedFilePoolCreate(100, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], &sFigDefaultManagedFilePool);
}

uint64_t FigManagedFilePoolCreateByteStreamForFile(const void *a1, const __CFURL *a2, int a3, uint64_t a4, CFTypeRef *a5)
{
  CFTypeRef cf = 0;
  if (a1 && a2 && a5 && (a3 & 0xFFFFFFBF) == 0)
  {
    ClassID = (void *)CMByteStreamGetClassID();
    uint64_t v11 = CMDerivedObjectCreate(a4, (uint64_t)&kManagedFileByteStreamVTable, ClassID, &cf);
    CFTypeRef v12 = cf;
    if (v11
      || (uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf),
          *(void *)uint64_t DerivedStorage = CFRetain(a1),
          *(unsigned char *)(DerivedStorage + 16) = 0,
          *(void *)(DerivedStorage + 24) = 0,
          *(void *)(DerivedStorage + 32) = 0,
          uint64_t v11 = FindAndRetainManagedFile(DerivedStorage, a2, 0, a3),
          CFTypeRef v12 = cf,
          v11))
    {
      if (v12) {
        CFRelease(v12);
      }
    }
    else
    {
      *a5 = cf;
    }
    return v11;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FindAndRetainManagedFile(uint64_t a1, const __CFURL *a2, unsigned int *a3, int a4)
{
  uint64_t v28 = 0;
  long long v26 = 0u;
  long long v27 = 0u;
  int v8 = *(unsigned __int8 *)(a1 + 16);
  uint64_t v9 = *(void *)a1;
  unsigned __int8 v25 = 0;
  if (!v8)
  {
    uint64_t FileInfo = FigFileGetFileInfo(a2, (uint64_t)&v26);
    if (!FileInfo) {
      goto LABEL_6;
    }
LABEL_34:
    uint64_t v20 = FileInfo;
    goto LABEL_36;
  }
  int DarwinFileDesc = FigFileGetDarwinFileDesc(a3);
  if (DarwinFileDesc == -1)
  {
    uint64_t FileInfo = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_34;
  }
  memset(&v29, 0, sizeof(v29));
  if (!fstat(DarwinFileDesc, &v29))
  {
    LODWORD(v28) = v29.st_mtimespec.tv_nsec;
    *(void *)&long long v26 = v29.st_size;
    *((void *)&v26 + 1) = v29.st_dev;
    *(void *)&long long v27 = v29.st_ino;
    *((void *)&v27 + 1) = v29.st_mtimespec.tv_sec;
    goto LABEL_6;
  }
  uint64_t v20 = FigSignalErrorAt(4294954422, 0, 0, 0, 0, 0, 0);
  if (v20)
  {
LABEL_36:
    *(void *)(a1 + 8) = 0;
    goto LABEL_25;
  }
LABEL_6:
  FigReentrantMutexLock(*(pthread_mutex_t **)(v9 + 24));
  uint64_t v12 = *(void *)(v9 + 32);
  if (v12)
  {
    while (!CFEqual(a2, *(CFTypeRef *)(v12 + 24))
         || *(_DWORD *)(v12 + 16) != a4
         || !FigFileInfoEqual((uint64_t)&v26, v12 + 32)
         || *(unsigned __int8 *)(v12 + 72) != v8)
    {
      uint64_t v12 = *(void *)(v12 + 8);
      if (!v12) {
        goto LABEL_12;
      }
    }
    FigAtomicIncrement32((atomic_uint *)(v12 + 88));
    goto LABEL_23;
  }
LABEL_12:
  xpc_object_t v13 = malloc_type_calloc(1uLL, 0x68uLL, 0x106004065D502D3uLL);
  if (!v13)
  {
    unsigned int v24 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if (v24) {
      uint64_t v20 = v24;
    }
    else {
      uint64_t v20 = 0;
    }
    uint64_t v12 = 0;
    goto LABEL_24;
  }
  uint64_t v12 = (uint64_t)v13;
  v13[22] = 1;
  *((void *)v13 + 3) = CFRetain(a2);
  *(_DWORD *)(v12 + 16) = a4;
  long long v14 = v27;
  *(_OWORD *)(v12 + 32) = v26;
  *(_OWORD *)(v12 + 48) = v14;
  *(void *)(v12 + 64) = v28;
  *(unsigned char *)(v12 + 72) = v8;
  uint64_t v15 = *(void *)a1;
  FigReentrantMutexLock(*(pthread_mutex_t **)(*(void *)a1 + 24));
  if (*(unsigned char *)(a1 + 16))
  {
    if (!a3)
    {
      uint64_t v19 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      goto LABEL_18;
    }
    uint64_t v16 = &v25;
    uint64_t v17 = a1;
    CFTypeRef v18 = a3;
  }
  else
  {
    uint64_t v17 = a1;
    CFTypeRef v18 = 0;
    uint64_t v16 = 0;
  }
  uint64_t v19 = AccessManagedFileHelper(v17, v18, v16, v12);
LABEL_18:
  uint64_t v20 = v19;
  if (!v19)
  {
    FigAtomicDecrement32((atomic_uint *)(v12 + 92));
    uint64_t v21 = *(uint64_t **)(v15 + 32);
    if (v21)
    {
      *uint64_t v21 = v12;
      *(void *)(v12 + 8) = *(void *)(v15 + 32);
    }
    else
    {
      *(void *)(v15 + 40) = v12;
    }
    *(void *)(v15 + 32) = v12;
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(v15 + 24));
LABEL_23:
    uint64_t v20 = 0;
    goto LABEL_24;
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(v15 + 24));
  DisposeManagedFile((void *)v12);
  uint64_t v12 = 0;
LABEL_24:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(v9 + 24));
  int v22 = v25;
  *(void *)(a1 + 8) = v12;
  if (!v22) {
LABEL_25:
  }
    FigFileForkClose((int *)a3);
  return v20;
}

uint64_t FigManagedFilePoolCreateByteStreamForOpenFileAssumingOwnership(const void *a1, const __CFURL *a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, CFTypeRef *a7)
{
  uint64_t v7 = a3;
  CFTypeRef cf = 0;
  if (!a1 || !a2 || !a3 || !a4 || !a5 || !a7)
  {
    uint64_t v15 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  ClassID = (void *)CMByteStreamGetClassID();
  uint64_t v15 = CMDerivedObjectCreate(a6, (uint64_t)&kManagedFileByteStreamVTable, ClassID, &cf);
  if (v15)
  {
LABEL_14:
    uint64_t v17 = v15;
    goto LABEL_10;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  *(void *)uint64_t DerivedStorage = CFRetain(a1);
  *(unsigned char *)(DerivedStorage + 16) = 1;
  *(void *)(DerivedStorage + 24) = a4;
  *(void *)(DerivedStorage + 32) = FigCFWeakReferenceHolderCreateWithReferencedObject(a5);
  uint64_t v17 = FindAndRetainManagedFile(DerivedStorage, a2, v7, 0);
  uint64_t v7 = 0;
  if (!v17)
  {
    *a7 = cf;
    CFTypeRef cf = 0;
  }
LABEL_10:
  FigFileForkClose((int *)v7);
  if (cf) {
    CFRelease(cf);
  }
  return v17;
}

double ManagedFilePoolInit(_OWORD *a1)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void ManagedFilePoolFinalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    FigReentrantMutexDestroy(v2);
    *(void *)(a1 + 24) = 0;
  }
  free(*(void **)(a1 + 56));
  *(void *)(a1 + 56) = 0;
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 16) = 0;
  }
}

CFStringRef ManagedFilePoolCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigManagedFilePool %p]", a1);
}

__CFString *ManagedFilePoolCopyDebugDesc(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  uint64_t v4 = a1[6];
  CFIndex v5 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, @"FigManagedFilePool %p of %d descriptors retainCount: %d", a1, v4, v5);
  return Mutable;
}

BOOL ManagedFileByteStreamEqual(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  return *(void *)(DerivedStorage + 8) == *(void *)(CMBaseObjectGetDerivedStorage(a2) + 8);
}

void ManagedFileByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  CFAllocatorRef v2 = DerivedStorage;
  uint64_t v3 = DerivedStorage[1];
  if (v3)
  {
    uint64_t v4 = *DerivedStorage;
    FigReentrantMutexLock(*(pthread_mutex_t **)(*DerivedStorage + 24));
    if (!FigAtomicDecrement32((atomic_uint *)(v3 + 88)))
    {
      CloseManagedFile(v4, v3);
      uint64_t v5 = *(void *)v3;
      uint64_t v6 = *(void **)(v3 + 8);
      if (*(void *)v3)
      {
        *(void *)(v5 + 8) = v6;
        uint64_t v6 = *(void **)(v3 + 8);
      }
      else
      {
        *(void *)(v4 + 32) = v6;
        uint64_t v5 = *(void *)v3;
      }
      if (!v6) {
        uint64_t v6 = (void *)(v4 + 40);
      }
      *uint64_t v6 = v5;
      *(void *)uint64_t v3 = 0;
      *(void *)(v3 + 8) = 0;
      DisposeManagedFile((void *)v3);
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(v4 + 24));
    v2[1] = 0;
  }
  uint64_t v7 = (const void *)v2[4];
  if (v7)
  {
    CFRelease(v7);
    v2[4] = 0;
  }
  v2[3] = 0;
  if (*v2)
  {
    CFRelease((CFTypeRef)*v2);
    *CFAllocatorRef v2 = 0;
  }
}

__CFString *ManagedFileByteStreamCopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringRef v3 = CFCopyDescription(*(CFTypeRef *)(DerivedStorage[1] + 24));
  CFStringRef v4 = v3;
  uint64_t v5 = @"UNKNOWN PATH";
  if (v3) {
    uint64_t v5 = (__CFString *)v3;
  }
  if (*(void *)(DerivedStorage[1] + 80)) {
    uint64_t v6 = "open";
  }
  else {
    uint64_t v6 = "closed";
  }
  CFStringAppendFormat(Mutable, 0, @"<FigManagedFileByteStream %p>{%@} Owning pool %p Currently %s", DerivedStorage, v5, *DerivedStorage, v6);
  if (v4) {
    CFRelease(v4);
  }
  return Mutable;
}

uint64_t ManagedFileByteStreamCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    uint64_t v9 = AccessManagedFileHelper(DerivedStorage, 0, 0, *(void *)(DerivedStorage + 8));
    if (v9) {
      return v9;
    }
    uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(*(void *)(*(void *)(*(void *)(DerivedStorage + 8) + 80) + 8));
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v11) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0;
    }
    xpc_object_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 48);
    if (v13) {
      uint64_t v14 = v13(CMBaseObject, a2, a3, a4);
    }
    else {
      uint64_t v14 = 4294954514;
    }
    FigAtomicDecrement32((atomic_uint *)(*(void *)(DerivedStorage + 8) + 92));
    return v14;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t ManagedFileByteStreamSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    uint64_t v7 = AccessManagedFileHelper(DerivedStorage, 0, 0, *(void *)(DerivedStorage + 8));
    if (v7) {
      return v7;
    }
    uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(*(void *)(*(void *)(*(void *)(DerivedStorage + 8) + 80) + 8));
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 56);
    if (v11) {
      uint64_t v12 = v11(CMBaseObject, a2, a3);
    }
    else {
      uint64_t v12 = 4294954514;
    }
    FigAtomicDecrement32((atomic_uint *)(*(void *)(DerivedStorage + 8) + 92));
    return v12;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

void CloseManagedFile(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v2 = *(void **)(a2 + 80);
  if (v2)
  {
    *(void *)(a2 + 80) = 0;
    uint64_t v4 = (const void *)v2[1];
    if (v4)
    {
      CFRelease(v4);
      v2[1] = 0;
    }
    *CFAllocatorRef v2 = *(void *)(a1 + 56);
    *(void *)(a1 + 56) = v2;
  }
}

void DisposeManagedFile(void *a1)
{
  if (a1)
  {
    CFAllocatorRef v2 = (const void *)a1[3];
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

uint64_t AccessManagedFileHelper(uint64_t a1, unsigned int *a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v8 = *(void *)a1;
  FigReentrantMutexLock(*(pthread_mutex_t **)(*(void *)a1 + 24));
  FigAtomicIncrement32((atomic_uint *)(a4 + 92));
  *(void *)(a4 + 96) = FigGetUpTimeNanoseconds();
  if (*(void *)(a4 + 80)) {
    goto LABEL_2;
  }
  uint64_t v11 = *(void *)(v8 + 56);
  if (v11)
  {
LABEL_5:
    *(void *)(v8 + 56) = *(void *)v11;
    *(void *)uint64_t v11 = 0;
  }
  else
  {
    uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
    while (1)
    {
      uint64_t v17 = *(void *)(v8 + 32);
      if (!v17)
      {
        FigUSleep(0x64u);
LABEL_38:
        uint64_t v9 = FigSignalErrorAt(4294954856, 0, 0, 0, 0, 0, 0);
        FigReentrantMutexUnlock(*(pthread_mutex_t **)(v8 + 24));
        if (!v9) {
          return v9;
        }
        goto LABEL_39;
      }
      int v18 = 0;
      uint64_t v19 = 0;
      do
      {
        if (*(_DWORD *)(v17 + 92))
        {
          ++v18;
        }
        else if (*(void *)(v17 + 80) && *(void *)(v17 + 96) < v16)
        {
          uint64_t v16 = *(void *)(v17 + 96);
          uint64_t v19 = v17;
        }
        uint64_t v17 = *(void *)(v17 + 8);
      }
      while (v17);
      if (v19) {
        break;
      }
      FigUSleep(0x64u);
      if (v18 <= 1) {
        goto LABEL_38;
      }
    }
    CloseManagedFile(v8, v19);
    uint64_t v11 = *(void *)(v8 + 56);
    if (v11) {
      goto LABEL_5;
    }
  }
  if (*(unsigned char *)(a1 + 16))
  {
    xpc_object_t v13 = *(uint64_t (**)(id *, unsigned int **))(a1 + 24);
    uint64_t v12 = *(id **)(a1 + 32);
    CFTypeRef cf = 0;
    unsigned int v24 = 0;
    if (a2)
    {
      uint64_t v9 = FigByteStreamCreateFromReadOnlyOpenFileAssumingOwnership(a2, *MEMORY[0x1E4F1CF80], &cf);
      uint64_t v14 = 0;
      if (!v9)
      {
        uint64_t v15 = 0;
LABEL_28:
        uint64_t v14 = 0;
        uint64_t v9 = 0;
        *(void *)(v11 + 8) = cf;
        CFTypeRef cf = 0;
        *(void *)(a4 + 80) = v11;
        goto LABEL_29;
      }
      uint64_t v15 = 0;
    }
    else if (v13)
    {
      uint64_t v21 = FigCFWeakReferenceHolderCopyReferencedObject(v12);
      uint64_t v15 = v21;
      if (v21)
      {
        uint64_t v9 = v13(v21, &v24);
        uint64_t v14 = (int *)v24;
        if (v9) {
          goto LABEL_29;
        }
        uint64_t v22 = FigByteStreamCreateFromReadOnlyOpenFileAssumingOwnership(v24, *MEMORY[0x1E4F1CF80], &cf);
        unsigned int v24 = 0;
        if (!v22) {
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v22 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      }
      uint64_t v9 = v22;
      uint64_t v14 = 0;
    }
    else
    {
      uint64_t v9 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      uint64_t v14 = 0;
      uint64_t v15 = 0;
    }
LABEL_29:
    FigFileForkClose(v14);
    if (cf) {
      CFRelease(cf);
    }
    if (v15) {
      CFRelease(v15);
    }
    if (a3) {
      *a3 = 1;
    }
    if (!v9) {
      goto LABEL_2;
    }
    goto LABEL_36;
  }
  uint64_t v20 = CMByteStreamCreateForFileURL(*MEMORY[0x1E4F1CF80], *(const void **)(a4 + 24), *(_DWORD *)(a4 + 16), (CFTypeRef *)(v11 + 8));
  if (!v20)
  {
    *(void *)(a4 + 80) = v11;
LABEL_2:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(v8 + 24));
    return 0;
  }
  uint64_t v9 = v20;
LABEL_36:
  *(void *)uint64_t v11 = *(void *)(v8 + 56);
  *(void *)(v8 + 56) = v11;
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(v8 + 24));
LABEL_39:
  FigAtomicDecrement32((atomic_uint *)(a4 + 92));
  return v9;
}

uint64_t ManagedFileByteStreamRead(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    uint64_t v11 = AccessManagedFileHelper(DerivedStorage, 0, 0, *(void *)(DerivedStorage + 8));
    if (v11) {
      return v11;
    }
    uint64_t v12 = *(void *)(*(void *)(*(void *)(DerivedStorage + 8) + 80) + 8);
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable(v12) + 16);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 8);
    if (v15) {
      uint64_t v16 = v15(v12, a2, a3, a4, a5);
    }
    else {
      uint64_t v16 = 4294954514;
    }
    FigAtomicDecrement32((atomic_uint *)(*(void *)(DerivedStorage + 8) + 92));
    return v16;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t ManagedFileByteStreamGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    uint64_t v7 = AccessManagedFileHelper(DerivedStorage, 0, 0, *(void *)(DerivedStorage + 8));
    if (v7) {
      return v7;
    }
    uint64_t v8 = *(void *)(*(void *)(*(void *)(DerivedStorage + 8) + 80) + 8);
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable(v8) + 16);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 24);
    if (v11) {
      uint64_t v12 = v11(v8, a2, a3);
    }
    else {
      uint64_t v12 = 4294954514;
    }
    FigAtomicDecrement32((atomic_uint *)(*(void *)(DerivedStorage + 8) + 92));
    return v12;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t ManagedFileByteStreamReadAndCreateBlockBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    uint64_t v11 = AccessManagedFileHelper(DerivedStorage, 0, 0, *(void *)(DerivedStorage + 8));
    if (v11) {
      return v11;
    }
    uint64_t v12 = *(void *)(*(void *)(*(void *)(DerivedStorage + 8) + 80) + 8);
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable(v12) + 16);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 32);
    if (v15) {
      uint64_t v16 = v15(v12, a2, a3, a4, a5);
    }
    else {
      uint64_t v16 = 4294954514;
    }
    FigAtomicDecrement32((atomic_uint *)(*(void *)(DerivedStorage + 8) + 92));
    return v16;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigByteStreamCreateWithCFData(const void *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  return _createWithCFData(a1, 0, a2, a3, a4);
}

uint64_t _createWithCFData(const void *a1, int a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  CFTypeRef cf = 0;
  if (a3 || !a1)
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    ClassID = (void *)CMByteStreamGetClassID();
    uint64_t v10 = CMDerivedObjectCreate(a4, (uint64_t)&kFigDataByteStreamVTable, ClassID, &cf);
    if (v10)
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      *uint64_t DerivedStorage = CFRetain(a1);
      if (a2) {
        DerivedStorage[1] = CFRetain(a1);
      }
      uint64_t v10 = 0;
      *a5 = cf;
    }
    return v10;
  }
}

uint64_t FigByteStreamCreateWritableWithCFMutableData(const void *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  return _createWithCFData(a1, 1, a2, a3, a4);
}

BOOL FigDataByteStreamEqual(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  return *DerivedStorage == *(void *)CMBaseObjectGetDerivedStorage(a2);
}

void FigDataByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(void *)DerivedStorage) {
    CFRelease(*(CFTypeRef *)DerivedStorage);
  }
  CFAllocatorRef v2 = *(const void **)(DerivedStorage + 8);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(DerivedStorage + 16);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(DerivedStorage + 24);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(DerivedStorage + 32);
  if (v5)
  {
    CFRelease(v5);
  }
}

uint64_t FigDataByteStreamCopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, @"FBS_EntireLength") || CFEqual(a2, @"FBS_AvailableLength"))
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex Length = CFDataGetLength(*(CFDataRef *)DerivedStorage);
    CFNumberRef SInt64 = FigCFNumberCreateSInt64(v7, Length);
LABEL_4:
    uint64_t v10 = SInt64;
LABEL_5:
    uint64_t result = 0;
    *a4 = v10;
    return result;
  }
  if (CFEqual(a2, @"FBS_EntireLengthAvailableOnDemand"))
  {
    uint64_t v12 = (const void *)*MEMORY[0x1E4F1CFD0];
LABEL_8:
    CFNumberRef SInt64 = (void *)CFRetain(v12);
    goto LABEL_4;
  }
  if (CFEqual(a2, @"FBS_URL"))
  {
    uint64_t v12 = *(const void **)(DerivedStorage + 16);
    if (v12) {
      goto LABEL_8;
    }
    return 4294954512;
  }
  if (CFEqual(a2, @"FBS_FileType"))
  {
    uint64_t v12 = *(const void **)(DerivedStorage + 32);
    if (v12) {
      goto LABEL_8;
    }
    return 4294954512;
  }
  if (CFEqual(a2, @"FBS_MIMEType"))
  {
    uint64_t v12 = *(const void **)(DerivedStorage + 24);
    if (v12) {
      goto LABEL_8;
    }
    return 4294954512;
  }
  if (CFEqual(a2, @"FBS_ReadSupported"))
  {
    uint64_t v13 = (const void **)MEMORY[0x1E4F1CFD0];
    goto LABEL_23;
  }
  if (CFEqual(a2, @"FBS_WriteSupported"))
  {
    uint64_t v13 = (const void **)MEMORY[0x1E4F1CFD0];
    if (!*(void *)(DerivedStorage + 8)) {
      uint64_t v13 = (const void **)MEMORY[0x1E4F1CFC8];
    }
LABEL_23:
    uint64_t v12 = *v13;
    if (!*v13)
    {
      uint64_t v10 = 0;
      goto LABEL_5;
    }
    goto LABEL_8;
  }

  return FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
}

uint64_t FigDataByteStreamSetProperty(const void *a1, const void *a2, const __CFString *a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (CFEqual(a2, @"FBS_URL"))
  {
    if (a3)
    {
      CFTypeID v7 = CFGetTypeID(a3);
      if (v7 == CFURLGetTypeID())
      {
        uint64_t v8 = (const void *)DerivedStorage[2];
        DerivedStorage[2] = a3;
        goto LABEL_9;
      }
      goto LABEL_27;
    }
    uint64_t v8 = (const void *)DerivedStorage[2];
    DerivedStorage[2] = 0;
    if (!v8) {
      return 0;
    }
LABEL_21:
    CFRelease(v8);
    return 0;
  }
  if (CFEqual(a2, @"FBS_FileType"))
  {
    if (a3)
    {
      CFTypeID v9 = CFGetTypeID(a3);
      if (v9 == CFNumberGetTypeID())
      {
        uint64_t v8 = (const void *)DerivedStorage[4];
        DerivedStorage[4] = a3;
LABEL_9:
        CFRetain(a3);
        if (!v8) {
          return 0;
        }
        goto LABEL_21;
      }
      goto LABEL_27;
    }
    uint64_t v8 = (const void *)DerivedStorage[4];
    DerivedStorage[4] = 0;
    if (!v8) {
      return 0;
    }
    goto LABEL_21;
  }
  if (CFEqual(a2, @"FBS_MIMEType"))
  {
    if (!a3 || (CFTypeID v10 = CFGetTypeID(a3), v10 == CFStringGetTypeID()))
    {
      uint64_t v11 = (const void *)DerivedStorage[3];
      if (v11)
      {
        CFRelease(v11);
        DerivedStorage[3] = 0;
      }
      if (a3)
      {
        CFAllocatorRef v12 = CFGetAllocator(a1);
        DerivedStorage[3] = CFStringCreateCopy(v12, a3);
      }
      return 0;
    }
LABEL_27:
    uint64_t v14 = 4294954424;
    goto LABEL_24;
  }
  uint64_t v14 = 4294954512;
LABEL_24:

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t FigDataByteStreamRead(uint64_t a1, int64_t a2, CFIndex a3, void *a4, int64_t *a5)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = (CFDataRef *)CMBaseObjectGetDerivedStorage(CMBaseObject);
  CFIndex Length = CFDataGetLength(*DerivedStorage);
  if (a2)
  {
    if (a3 < 0)
    {
      uint64_t result = FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
      a2 = 0;
      if (!a5) {
        return result;
      }
      goto LABEL_10;
    }
    if (Length <= a3) {
      return 4294954423;
    }
    if ((a2 & (unint64_t)~(a2 >> 63)) >= Length - a3) {
      a2 = Length - a3;
    }
    else {
      a2 &= ~(a2 >> 63);
    }
    if (a2)
    {
      BytePtr = CFDataGetBytePtr(*DerivedStorage);
      memcpy(a4, &BytePtr[a3], a2);
    }
  }
  uint64_t result = 0;
  if (!a5) {
    return result;
  }
LABEL_10:
  if (!result) {
    *a5 = a2;
  }
  return result;
}

uint64_t FigDataByteStreamWrite(uint64_t a1, size_t a2, CFIndex a3, const UInt8 *a4, size_t *a5)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  CFDataRef v11 = *(const __CFData **)(DerivedStorage + 8);
  if (!v11)
  {
    uint64_t v17 = 4294954419;
LABEL_16:
    uint64_t result = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
    if (!a5) {
      return result;
    }
    goto LABEL_11;
  }
  if (!a4 || a3 < 0)
  {
    uint64_t v17 = 4294954424;
    goto LABEL_16;
  }
  if (a2)
  {
    CFIndex Length = CFDataGetLength(v11);
    if (Length == a3)
    {
      CFDataAppendBytes(*(CFMutableDataRef *)(DerivedStorage + 8), a4, a2);
    }
    else
    {
      unint64_t v13 = Length;
      uint64_t v14 = *(__CFData **)(DerivedStorage + 8);
      if (a3 + a2 <= v13)
      {
        v18.CFIndex location = a3;
        v18.CFIndex length = a2;
        CFDataReplaceBytes(v14, v18, a4, a2);
      }
      else
      {
        CFDataSetLength(v14, a3 + a2);
        BytePtr = CFDataGetBytePtr(*(CFDataRef *)(DerivedStorage + 8));
        memcpy((void *)&BytePtr[a3], a4, a2);
      }
    }
  }
  uint64_t result = 0;
  if (a5)
  {
LABEL_11:
    if (!result) {
      *a5 = a2;
    }
  }
  return result;
}

uint64_t FigDataByteStreamGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, CFIndex *a3)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = (CFDataRef *)CMBaseObjectGetDerivedStorage(CMBaseObject);
  if (a3)
  {
    CFIndex Length = CFDataGetLength(*DerivedStorage);
    *a3 = (Length - a2) & ~((Length - a2) >> 63);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigDataByteStreamReadAndCreateBlockBuffer(const void *a1, size_t a2, unint64_t a3, CFTypeRef *a4, void *a5)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  DataCFIndex Length = 0;
  CFTypeRef cf = 0;
  uint64_t v12 = *(void *)(DerivedStorage + 8);
  CFAllocatorRef v13 = CFGetAllocator(a1);
  if (v12)
  {
    BlockBufferWithCFDataNoCFDataRef Copy = CMCreateContiguousBlockBufferFromStream((uint64_t)a1, v13, a2, a3, (CMBlockBufferRef *)&cf, &DataLength);
    if (!BlockBufferWithCFDataNoCopy)
    {
      if (!a4) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
LABEL_13:
    uint64_t v15 = BlockBufferWithCFDataNoCopy;
    goto LABEL_7;
  }
  BlockBufferWithCFDataNoCFDataRef Copy = FigCreateBlockBufferWithCFDataNoCopy(v13, *(CFDataRef *)DerivedStorage, a3, a2, (CMBlockBufferRef *)&cf);
  if (BlockBufferWithCFDataNoCopy) {
    goto LABEL_13;
  }
  DataCFIndex Length = CMBlockBufferGetDataLength((CMBlockBufferRef)cf);
  if (a4)
  {
LABEL_4:
    *a4 = cf;
    CFTypeRef cf = 0;
  }
LABEL_5:
  uint64_t v15 = 0;
  if (a5) {
    *a5 = DataLength;
  }
LABEL_7:
  if (cf) {
    CFRelease(cf);
  }
  return v15;
}

uint64_t FigCPECryptorGetClassID()
{
  return sFigCPECryptorClassID;
}

uint64_t RegisterFigCPECryptorType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigCPECryptorClassDesc, ClassID, 1, &sFigCPECryptorClassID);
}

uint64_t FigCPECryptorGetTypeID()
{
  FigThreadRunOnce(&FigCPECryptorGetClassID_sRegisterFigCPECryptorTypeOnce, (void (*)(void))RegisterFigCPECryptorType);
  uint64_t v0 = (void *)sFigCPECryptorClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigCPECopyCryptorForSerializationToken(void *a1, void *a2)
{
  if (FigCPECryptorServerExistsInProcess())
  {
    return FigCPECryptorServerCopyCryptorForID(a1, a2);
  }
  else
  {
    uint64_t v5 = *MEMORY[0x1E4F1CF80];
    return FigCPECryptorRemoteRetainCopiedCryptor(v5, a1, a2);
  }
}

CFStringRef FigCPECryptorCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCPECryptor %p]", a1);
}

uint64_t FigTransportServiceGetClassID()
{
  if (FigTransportServiceGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigTransportServiceGetClassID_sRegisterOnce, &FigTransportServiceGetClassID_sClassID, (dispatch_function_t)service_getClassID);
  }
  return FigTransportServiceGetClassID_sClassID;
}

uint64_t service_getClassID(void *a1)
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&service_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigTransportServiceGetTypeID()
{
  if (FigTransportServiceGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigTransportServiceGetClassID_sRegisterOnce, &FigTransportServiceGetClassID_sClassID, (dispatch_function_t)service_getClassID);
  }
  uint64_t v0 = (void *)FigTransportServiceGetClassID_sClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFStringRef service_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigTransportService %p]", a1);
}

uint64_t FigSandboxRegistrationGetTypeID()
{
  if (sRegisterFigSandboxRegistrationTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigSandboxRegistrationTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxRegistrationType);
  }
  return sFigSandboxRegistrationID;
}

uint64_t RegisterFigSandboxRegistrationType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigSandboxRegistrationID = result;
  return result;
}

uint64_t FigSandboxRegistrationCreate(const __CFData *a1, uint64_t a2, const void *a3, void *a4)
{
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (sRegisterFigSandboxRegistrationTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigSandboxRegistrationTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxRegistrationType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    CFTypeID v10 = (void *)Instance;
    *(_DWORD *)(Instance + 24) = a2;
    CFDataGetBytePtr(a1);
    if (a3) {
      CFTypeRef v11 = CFRetain(a3);
    }
    else {
      CFTypeRef v11 = 0;
    }
    int v10[2] = v11;
    uint64_t v12 = sandbox_extension_consume();
    v10[4] = v12;
    if (v12 == -1)
    {
      FigSandboxRegistrationServerDumpMappings((uint64_t)v10);
      if (*__error() == 12)
      {
        uint64_t v13 = FigSignalErrorAt(4294949793, 0, 0, 0, 0, 0, 0);
        CFTypeRef cf = 0;
        FigServer_CopyProcessName(a2, (CFStringRef *)&cf);
        CFStringRef RadarDescriptionString = FigTapToRadarCreateRadarDescriptionString(v8, @"Pid %d (%@) failed to share sandbox extension for '%@' with mediaplaybackd - possible leak of sandbox extensions.", a2, cf, a3);
        FigTriggerTapToRadar(@"mediaplaybackd failed to obtain access to a media file", @"mediaplaybackd cannot access file. Failure to consume sandbox extension.", (uint64_t)RadarDescriptionString, 0x16FF06u);
        if (RadarDescriptionString) {
          CFRelease(RadarDescriptionString);
        }
        if (cf) {
          CFRelease(cf);
        }
        uint64_t v15 = dispatch_queue_create(0, 0);
        dispatch_time_t v16 = dispatch_time(0, 60000000000);
        dispatch_after(v16, v15, &__block_literal_global_35);
        dispatch_release(v15);
      }
      else
      {
        uint64_t v13 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
      }
      CFRelease(v10);
    }
    else
    {
      if (figSandboxRegistrationRecordForDiagnosticLogging_onceToken != -1) {
        dispatch_once(&figSandboxRegistrationRecordForDiagnosticLogging_onceToken, &__block_literal_global_20);
      }
      FigSimpleMutexLock((pthread_mutex_t *)figSandboxRegistrationRecordForDiagnosticLogging_mutex);
      FigCFWeakReferenceTableAddValueAssociatedWithKey(figSandboxRegistrationRecordForDiagnosticLogging_sandboxRegistrations, (uint64_t)v10, (uint64_t)v10);
      FigSimpleMutexUnlock((pthread_mutex_t *)figSandboxRegistrationRecordForDiagnosticLogging_mutex);
      uint64_t v13 = 0;
      *a4 = v10;
    }
    return v13;
  }
  else
  {
    return FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t __FigSandboxRegistrationCreate_block_invoke()
{
  return FigSandboxRegistrationServerKillDueToError(-17503);
}

uint64_t FigSandboxRegistrationCreateWithURLOnSelfGrantingReadWriteAccess(const __CFURL *a1, int a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (sRegisterFigSandboxRegistrationTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigSandboxRegistrationTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxRegistrationType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    CFTypeID v7 = (void *)Instance;
    *(_DWORD *)(Instance + 24) = a2;
    CFStringRef v8 = CFURLCopyFileSystemPath(a1, kCFURLPOSIXPathStyle);
    CFStringGetCString(v8, buffer, 1024, 0x8000100u);
    if (buffer[0])
    {
      uint64_t v9 = sandbox_extension_issue_file_to_self();
      if (v9)
      {
        CFTypeID v10 = (void *)v9;
        uint64_t v11 = sandbox_extension_consume();
        v7[4] = v11;
        if (v11 != -1)
        {
          *a3 = v7;
          free(v10);
          uint64_t v12 = 0;
          if (!v8) {
            return v12;
          }
LABEL_8:
          CFRelease(v8);
          return v12;
        }
        uint64_t v12 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
        free(v10);
      }
      else
      {
        FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
        uint64_t v12 = 0;
      }
    }
    else
    {
      uint64_t v12 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v7);
    if (!v8) {
      return v12;
    }
    goto LABEL_8;
  }

  return FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
}

void *figSandboxRegistrationInit(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = -1;
  return result;
}

void figSandboxRegistrationFinalize(uint64_t a1)
{
  if (*(void *)(a1 + 32) != -1) {
    sandbox_extension_release();
  }
  CFAllocatorRef v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

__CFString *figSandboxRegistrationCopyFormattingDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(unsigned int *)(a1 + 24);
  if (FigIsItOKToLogURLs()) {
    uint64_t v6 = *(__CFString **)(a1 + 16);
  }
  else {
    uint64_t v6 = @"<REDACTED>";
  }
  CFStringAppendFormat(Mutable, 0, @"<FigSandboxRegistration %p> hold <extensionHandle %lld> for client PID %d - %@", a1, v4, v5, v6);
  return Mutable;
}

__CFString *figSandboxRegistrationCopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  uint64_t v4 = *(unsigned int *)(a1 + 24);
  if (FigIsItOKToLogURLs()) {
    uint64_t v5 = *(__CFString **)(a1 + 16);
  }
  else {
    uint64_t v5 = @"<REDACTED>";
  }
  CFStringAppendFormat(Mutable, 0, @"<FigSandboxRegistration %p> for client PID %d - %@", a1, v4, v5);
  return Mutable;
}

void __figSandboxRegistrationRecordForDiagnosticLogging_block_invoke()
{
  figSandboxRegistrationRecordForDiagnosticLogging_mutex = (uint64_t)FigSimpleMutexCreate();
  FigCFWeakReferenceTableCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 1, &figSandboxRegistrationRecordForDiagnosticLogging_sandboxRegistrations);

  FigInstallSysdiagnoseBlock(@"Sandbox Registrations", (uint64_t)&__block_literal_global_26);
}

uint64_t __figSandboxRegistrationRecordForDiagnosticLogging_block_invoke_2()
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = &sLoadBrowserFrameworkOnce;
  FigSimpleMutexLock((pthread_mutex_t *)figSandboxRegistrationRecordForDiagnosticLogging_mutex);
  uint64_t v1 = figSandboxRegistrationRecordForDiagnosticLogging_sandboxRegistrations;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFDictionaryRef v3 = Mutable;
    FigCFWeakReferenceTableApplyFunction(v1, (void (*)(void, CFTypeRef, uint64_t))figSandboxRegistrationDumpAllApply, (uint64_t)Mutable);
    CFArrayRef v4 = FigCFDictionaryCopyArrayOfKeys(v3);
    if (v4)
    {
      CFArrayRef v5 = v4;
      if (CFArrayGetCount(v4) <= 0)
      {
        CFRelease(v3);
      }
      else
      {
        CFIndex v6 = 0;
        do
        {
          CFStringRef ValueAtIndex = FigCFArrayGetValueAtIndex(v5, v6);
          CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v3, ValueAtIndex);
          CFArrayRef v9 = Value;
          if (Value) {
            CFIndex Count = CFArrayGetCount(Value);
          }
          else {
            CFIndex Count = 0;
          }
          CFTypeRef cf = 0;
          CFNumberRef SInt32 = FigCFNumberGetSInt32((const __CFNumber *)ValueAtIndex);
          FigServer_CopyProcessName((uint64_t)SInt32, (CFStringRef *)&cf);
          int v22 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v22, &type);
          int v13 = v22;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v15 = v13;
          }
          else {
            unsigned int v15 = v13 & 0xFFFFFFFE;
          }
          if (v15)
          {
            dispatch_time_t v16 = "s";
            if (Count == 1) {
              dispatch_time_t v16 = "";
            }
            int v24 = 136316162;
            unsigned __int8 v25 = "figSandboxRegistrationDumpAll";
            __int16 v26 = 2114;
            long long v27 = ValueAtIndex;
            __int16 v28 = 2114;
            CFTypeRef v29 = cf;
            __int16 v30 = 2048;
            CFIndex v31 = Count;
            __int16 v32 = 2082;
            uint64_t v33 = v16;
            uint64_t v17 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v13) = v22;
          }
          else
          {
            uint64_t v17 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v17, v17 != &v34, v13, 0, v14);
          if (FigIsItOKToLogURLs() && Count >= 1)
          {
            for (CFIndex i = 0; i != Count; ++i)
              CFArrayGetValueAtIndex(v9, i);
          }
          if (cf) {
            CFRelease(cf);
          }
          ++v6;
        }
        while (v6 < CFArrayGetCount(v5));
        CFRelease(v3);
        uint64_t v0 = &sLoadBrowserFrameworkOnce;
      }
      CFArrayRef v19 = v5;
    }
    else
    {
      FigSignalErrorAt(4294949790, 0, 0, 0, 0, 0, 0);
      CFArrayRef v19 = v3;
    }
    CFRelease(v19);
  }
  else
  {
    FigSignalErrorAt(4294949790, 0, 0, 0, 0, 0, 0);
  }
  return FigSimpleMutexUnlock((pthread_mutex_t *)v0[227]);
}

void figSandboxRegistrationDumpAllApply(uint64_t a1, int *a2, void *a3)
{
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2[6]);
  if (SInt32)
  {
    CFNumberRef v7 = SInt32;
    CFArrayRef Value = (void *)FigCFDictionaryGetValue(a3, SInt32);
    if (!Value)
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E4F1D510]);
      if (!Mutable)
      {
        FigSignalErrorAt(4294949790, 0, 0, 0, 0, 0, 0);
        goto LABEL_6;
      }
      CFArrayRef Value = Mutable;
      FigCFDictionarySetValue(a3, v7, Mutable);
      CFRelease(Value);
    }
    CFArrayAppendValue((CFMutableArrayRef)Value, a2);
LABEL_6:
    CFRelease(v7);
    return;
  }

  FigSignalErrorAt(4294949790, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointManagerStartServer(const void *a1)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetValue(Mutable, @"AirPlay", a1);
  uint64_t started = FigEndpointManagerStartServerEx(Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return started;
}

uint64_t FigEndpointManagerStartServerEx(const __CFDictionary *a1)
{
  v11[0] = 1;
  v11[1] = HandleEndpointManagerRemoteMessage;
  long long v12 = 0u;
  long long v13 = 0u;
  if (!a1 || !CFDictionaryGetCount(a1)) {
    return 4294950586;
  }
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  gEndpointManagers = (uint64_t)CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1);
  CFArrayRef v3 = FigCFDictionaryCopyArrayOfKeys((const __CFDictionary *)gEndpointManagers);
  CFArrayRef v4 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFAllocatorRef v5 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 0x40000000;
  int v10[2] = __FigEndpointManagerStartServerEx_block_invoke;
  _OWORD v10[3] = &__block_descriptor_tmp_44;
  v10[4] = Mutable;
  FigCFArrayApplyBlock(v3, v10);
  gEndpointManagerData = (uint64_t)Mutable;
  CFMutableDictionaryRef v7 = CFDictionaryCreateMutable(v2, 0, v4, v5);
  FigCFDictionarySetInt32(v7, @"xpcServerOption_SelfTerminationTimeout", 30);
  uint64_t v8 = FigXPCServerStart((uint64_t)"com.apple.coremedia.endpointmanager.xpc", v11, (uint64_t)v7, &gEndpointManagerServer);
  if (v7) {
    CFRelease(v7);
  }
  if (v3) {
    CFRelease(v3);
  }
  return v8;
}

uint64_t HandleEndpointManagerRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  int v46 = 0;
  uint64_t v45 = 0;
  OpCFIndex Code = FigXPCMessageGetOpCode(a2, &v46);
  if (OpCode) {
    return OpCode;
  }
  if (v46 == 1734701165)
  {
    CFTypeRef cf = 0;
    OpCFIndex Code = FigXPCMessageCopyCFString(a2, "EndpointManagerType", &cf);
    if (OpCode) {
      return OpCode;
    }
    uint64_t EndpointManager = HandleGetEndpointManager(a1, cf, a3);
    CFTypeRef v8 = cf;
    if (!cf) {
      return EndpointManager;
    }
LABEL_77:
    CFRelease(v8);
    return EndpointManager;
  }
  if (v46 == 1734436205) {
    return HandleGetEndpointManager(a1, @"AirPlay", a3);
  }
  uint64_t int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  CFTypeRef cf = 0;
  uint64_t v10 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v45);
  if (!v10)
  {
    if (cf)
    {
      CFTypeID v11 = CFGetTypeID(cf);
      if (v11 == FigEndpointManagerGetTypeID())
      {
        CFTypeRef v12 = cf;
        goto LABEL_13;
      }
    }
    uint64_t v10 = FigSignalErrorAt(4294950586, 0, 0, 0, 0, 0, 0);
  }
  uint64_t EndpointManager = v10;
  if (cf) {
    CFRelease(cf);
  }
  if (!EndpointManager)
  {
    CFTypeRef v12 = 0;
LABEL_13:
    uint64_t EndpointManager = 4294950586;
    if (v46 > 1668441440)
    {
      if (v46 <= 1701995363)
      {
        if (v46 != 1668441441)
        {
          if (v46 == 1685024621)
          {
            uint64_t v13 = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_38:
            uint64_t EndpointManager = v13;
            goto LABEL_75;
          }
          goto LABEL_75;
        }
        CFTypeRef cf = 0;
        uint64_t v27 = xpc_dictionary_get_uint64(a2, "EndpointAggregateType");
        uint64_t v28 = *(void *)(CMBaseObjectGetVTable((uint64_t)v12) + 16);
        if (v28) {
          uint64_t v29 = v28;
        }
        else {
          uint64_t v29 = 0;
        }
        __int16 v32 = *(uint64_t (**)(CFTypeRef, uint64_t, CFTypeRef *))(v29 + 24);
        if (v32)
        {
          uint64_t v33 = v32(v12, v27, &cf);
LABEL_45:
          CFTypeRef v35 = cf;
          if (v33)
          {
            uint64_t EndpointManager = v33;
            if (!cf) {
              goto LABEL_75;
            }
          }
          else
          {
            uint64_t EndpointManager = FigEndpointXPCServerWriteNeighborEndpointToReply(a1, (void *)cf, a3, 0);
            CFTypeRef v35 = cf;
            if (!cf) {
              goto LABEL_75;
            }
          }
          CFTypeRef v36 = v35;
LABEL_74:
          CFRelease(v36);
          goto LABEL_75;
        }
        goto LABEL_48;
      }
      if (v46 == 1701995364)
      {
        CFTypeRef cf = 0;
        uint64_t v30 = *(void *)(CMBaseObjectGetVTable((uint64_t)v12) + 16);
        if (v30) {
          uint64_t v31 = v30;
        }
        else {
          uint64_t v31 = 0;
        }
        char v34 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(v31 + 32);
        if (v34)
        {
          uint64_t v33 = v34(v12, &cf);
          goto LABEL_45;
        }
LABEL_48:
        uint64_t EndpointManager = 4294954514;
        goto LABEL_75;
      }
      if (v46 != 1935961376) {
        goto LABEL_75;
      }
      xpc_object_t value = 0;
      CFTypeRef cf = 0;
      uint64_t v18 = FigXPCMessageCopyCFString(a2, "DiscoveryMode", &cf);
      if (!v18)
      {
        uint64_t v18 = FigXPCMessageCopyCFDictionary(a2, "DiscoveryOptions", &value);
        if (!v18)
        {
          xpc_object_t v20 = value;
          CFTypeRef v19 = cf;
          uint64_t v21 = *(void *)(CMBaseObjectGetVTable((uint64_t)v12) + 16);
          if (v21) {
            uint64_t v22 = v21;
          }
          else {
            uint64_t v22 = 0;
          }
          CFNumberRef v43 = *(uint64_t (**)(CFTypeRef, CFTypeRef, xpc_object_t))(v22 + 8);
          if (!v43)
          {
            uint64_t EndpointManager = 4294954514;
LABEL_71:
            xpc_object_t v42 = value;
            if (!value) {
              goto LABEL_73;
            }
            goto LABEL_72;
          }
          uint64_t v18 = v43(v12, v19, v20);
        }
      }
      uint64_t EndpointManager = v18;
      goto LABEL_71;
    }
    if (v46 != 778268793)
    {
      if (v46 == 779314548)
      {
        uint64_t v13 = FigXPCHandleStdSetPropertyMessage((uint64_t)v12, a2);
        goto LABEL_38;
      }
      if (v46 != 1635148140)
      {
LABEL_75:
        if (!v12) {
          return EndpointManager;
        }
        CFTypeRef v8 = v12;
        goto LABEL_77;
      }
      uint64_t v14 = *v45;
      xpc_object_t value = 0;
      CFTypeRef cf = 0;
      xpc_object_t v47 = 0;
      uint64_t CMBaseObject = FigEndpointManagerGetCMBaseObject(v12);
      uint64_t v16 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
      if (v16) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = 0;
      }
      CMTime v37 = *(uint64_t (**)(uint64_t, __CFString *, void, CFTypeRef *))(v17 + 48);
      if (v37)
      {
        uint64_t v38 = v37(CMBaseObject, @"AvailableEndpoints", *MEMORY[0x1E4F1CF80], &cf);
        if (v38
          || (uint64_t v38 = FigEndpointRPCCacheComputeCacheDeltas(v14, a1, (CFArrayRef)cf, &value, &v47), v38))
        {
          uint64_t EndpointManager = v38;
        }
        else
        {
          if (value) {
            xpc_dictionary_set_value(a3, "AddedEndpoints", value);
          }
          if (v47) {
            xpc_dictionary_set_value(a3, "SubtractedEndpoints", v47);
          }
          uint64_t EndpointManager = 0;
        }
      }
      else
      {
        uint64_t EndpointManager = 4294954514;
      }
      FigXPCRelease(value);
      FigXPCRelease(v47);
      goto LABEL_73;
    }
    xpc_object_t value = 0;
    CFTypeRef cf = 0;
    uint64_t v23 = FigXPCMessageCopyCFString(a2, ".PropertyName", &cf);
    if (!v23)
    {
      CFTypeRef v24 = cf;
      if (cf)
      {
        uint64_t v25 = *(void *)(CMBaseObjectGetVTable((uint64_t)v12) + 8);
        if (v25) {
          uint64_t v26 = v25;
        }
        else {
          uint64_t v26 = 0;
        }
        CMTime v39 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void, xpc_object_t *))(v26 + 48);
        if (!v39)
        {
          uint64_t EndpointManager = 4294954514;
          goto LABEL_73;
        }
        uint64_t v40 = v39(v12, v24, *MEMORY[0x1E4F1CF80], &value);
        xpc_object_t v41 = value;
        if (!v40)
        {
          uint64_t EndpointManager = FigXPCMessageSetCFObject(a3, ".Value", value);
          xpc_object_t v41 = value;
          if (!value) {
            goto LABEL_73;
          }
          goto LABEL_64;
        }
        uint64_t EndpointManager = v40;
        if (value)
        {
LABEL_64:
          xpc_object_t v42 = v41;
LABEL_72:
          CFRelease(v42);
        }
LABEL_73:
        CFTypeRef v36 = cf;
        if (!cf) {
          goto LABEL_75;
        }
        goto LABEL_74;
      }
      uint64_t v23 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
    }
    uint64_t EndpointManager = v23;
    goto LABEL_73;
  }
  return EndpointManager;
}

void __FigEndpointManagerStartServerEx_block_invoke(uint64_t a1, const void *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, Mutable);
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

uint64_t HandleGetEndpointManager(_xpc_connection_s *a1, const void *a2, void *a3)
{
  CFTypeRef cf = 0;
  uint64_t value = 0;
  if (!a2) {
    return 4294950586;
  }
  CFIndex v6 = CFDictionaryGetValue((CFDictionaryRef)gEndpointManagers, a2);
  if (v6 && (CFMutableDictionaryRef v7 = v6, (v8 = CFDictionaryGetValue((CFDictionaryRef)gEndpointManagerData, a2)) != 0))
  {
    CFArrayRef v9 = v8;
    uint64_t v10 = (void **)malloc_type_calloc(1uLL, 0x18uLL, 0x102004093CA8EA1uLL);
    if (v10)
    {
      CFTypeID v11 = v10;
      uint64_t pid = xpc_connection_get_pid(a1);
      int v13 = pid;
      FigServer_CopyProcessName(pid, (CFStringRef *)&cf);
      uint64_t v14 = FigEndpointRPCCacheCreate(v11, 1);
      if (v14)
      {
        uint64_t v15 = v14;
      }
      else
      {
        void v11[2] = CFRetain(v9);
        *((_DWORD *)v11 + 2) = v13;
        uint64_t v15 = FigXPCServerAssociateObjectWithConnection(a1, v7, (uint64_t)v11, (uint64_t)FigEndpointManagerXPCClientInfoDispose, 0, &value);
        if (!v15)
        {
          xpc_dictionary_set_uint64(a3, ".objectID", value);
          goto LABEL_9;
        }
      }
      FigEndpointRPCCacheDispose(*v11);
      uint64_t v17 = v11[2];
      if (v17) {
        CFRelease(v17);
      }
      free(v11);
      goto LABEL_9;
    }
    uint64_t v15 = 4294950585;
  }
  else
  {
    uint64_t v15 = 4294950583;
  }
LABEL_9:
  if (cf) {
    CFRelease(cf);
  }
  return v15;
}

void FigEndpointManagerXPCClientInfoDispose(void *a1)
{
  FigEndpointRPCCacheDispose((void *)*a1);
  CFAllocatorRef v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }

  free(a1);
}

uint64_t FigEndpointSubEndpointSupportProtocolGetProtocolID()
{
  return sFigEndpointSubEndpointSupportProtocolID;
}

uint64_t RegisterFigEndpointSubEndpointSupportProtocolType()
{
  return FigBaseProtocolRegisterProtocol((long long *)&sFigEndpointSubEndpointSupportProtocolDesc, 0, &sFigEndpointSubEndpointSupportProtocolID);
}

uint64_t FigVP9Bridge_ParseVPCC(const __CFData *a1, unsigned char *a2)
{
  if (a1 && a2)
  {
    if (!*a2)
    {
      if (CFDataGetLength(a1) > 11 && (BytePtr = CFDataGetBytePtr(a1), *BytePtr == 1))
      {
        a2[1] = BytePtr[4];
        a2[2] = BytePtr[5];
        a2[3] = BytePtr[6] >> 4;
        a2[4] = (BytePtr[6] >> 1) & 7;
        a2[5] = BytePtr[6] & 1;
        a2[6] = BytePtr[7];
        a2[7] = BytePtr[8];
        a2[8] = BytePtr[9];
      }
      else
      {
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
      return 0;
    }
    uint64_t v6 = 4294954579;
  }
  else
  {
    uint64_t v6 = 4294954584;
  }

  return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
}

uint64_t endpointCentricPlugin_CreateEndpointCentricPluginObjectInternal(const __CFAllocator *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  CFTypeRef cf = 0;
  ClassID = (void *)FigHALAudioPluginGetClassID();
  uint64_t v13 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigHALAudioPluginVTable_0, ClassID, &cf);
  if (v13) {
    goto LABEL_10;
  }
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
  DerivedStorage[1] = a2;
  DerivedStorage[6] = a4;
  DerivedStorage[7] = a5;
  DerivedStorage[4] = a3;
  dispatch_queue_t v15 = dispatch_queue_create("FigHALEndpointCentricPlugin.InternalQueue", 0);
  DerivedStorage[2] = v15;
  if (!v15
    || (dispatch_queue_t v16 = dispatch_queue_create("FigHALEndpointCentricPlugin.HostQueue", 0), (DerivedStorage[3] = v16) == 0)
    || (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]),
        (DerivedStorage[9] = Mutable) == 0)
    || (CFMutableDictionaryRef v18 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]),
        (DerivedStorage[10] = v18) == 0))
  {
    uint64_t v13 = FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
LABEL_10:
    uint64_t v19 = v13;
    goto LABEL_11;
  }
  uint64_t v19 = FigHALAudioObjectMapperAddPluginObjectMapping(a2, (uint64_t)cf);
  if (!v19)
  {
    *a6 = cf;
    return v19;
  }
LABEL_11:
  if (cf) {
    CFRelease(cf);
  }
  return v19;
}

uint64_t FigHALAudioCreateEndpointCentricPluginObject(const __CFAllocator *a1, uint64_t *a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  return endpointCentricPlugin_CreateEndpointCentricPluginObjectInternal(a1, a2, a3, a4, 0, a5);
}

void endpointCentricPlugin_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  CFAllocatorRef v2 = (const void *)DerivedStorage[9];
  if (v2)
  {
    CFRelease(v2);
    DerivedStorage[9] = 0;
  }
  CFArrayRef v3 = (const void *)DerivedStorage[10];
  if (v3)
  {
    CFRelease(v3);
    DerivedStorage[10] = 0;
  }
  CFArrayRef v4 = (const void *)DerivedStorage[5];
  if (v4)
  {
    CFRelease(v4);
    DerivedStorage[5] = 0;
  }
  CFAllocatorRef v5 = DerivedStorage[2];
  if (v5)
  {
    dispatch_release(v5);
    DerivedStorage[2] = 0;
  }
  uint64_t v6 = DerivedStorage[3];
  if (v6)
  {
    dispatch_release(v6);
    DerivedStorage[3] = 0;
  }
}

CFStringRef endpointCentricPlugin_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  uint64_t v16 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0;
  CFArrayRef v3 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __endpointCentricPlugin_CopyDebugDescription_block_invoke;
  block[3] = &unk_1E567A668;
  void block[6] = a1;
  void block[7] = DerivedStorage;
  void block[4] = &v13;
  void block[5] = &v9;
  dispatch_sync(v3, block);
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"FigHALEndpointCentricPlugin:\nEndponts/Streams:\n%@\nStreams/Devices:\n%@", v14[3], v10[3]);
  CFAllocatorRef v5 = (const void *)v14[3];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)v10[3];
  if (v6) {
    CFRelease(v6);
  }
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(&v13, 8);
  return v4;
}

uint64_t endpointCentricPlugin_GetObjectID()
{
  return 1;
}

uint64_t endpointCentricPlugin_HasProperty(uint64_t a1, int *a2)
{
  int v2 = *a2;
  uint64_t result = 1;
  if (*a2 <= 1819107690)
  {
    BOOL v4 = v2 == 1668047219;
    int v5 = 1684370979;
  }
  else
  {
    BOOL v4 = v2 == 1819107691 || v2 == 1870098020;
    int v5 = 1969841252;
  }
  if (!v4 && v2 != v5) {
    return 0;
  }
  return result;
}

uint64_t endpointCentricPlugin_IsPropertySettable()
{
  return 0;
}

uint64_t endpointCentricPlugin_GetPropertyDataSize(uint64_t a1, int *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v4 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  int v12 = 0;
  int v5 = *a2;
  if (*a2 > 1819107690)
  {
    if (v5 == 1819107691)
    {
      uint64_t v4 = 8;
      goto LABEL_11;
    }
    if (v5 != 1870098020)
    {
      if (v5 != 1969841252) {
        goto LABEL_12;
      }
      goto LABEL_9;
    }
LABEL_8:
    uint64_t v6 = *(NSObject **)(DerivedStorage + 16);
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    void v8[2] = __endpointCentricPlugin_GetPropertyDataSize_block_invoke;
    v8[3] = &unk_1E567A690;
    v8[4] = &v9;
    v8[5] = DerivedStorage;
    dispatch_sync(v6, v8);
    uint64_t v4 = *((unsigned int *)v10 + 6);
    goto LABEL_12;
  }
  if (v5 == 1668047219)
  {
LABEL_9:
    uint64_t v4 = 4;
LABEL_11:
    int v12 = v4;
    goto LABEL_12;
  }
  if (v5 == 1684370979) {
    goto LABEL_8;
  }
LABEL_12:
  _Block_object_dispose(&v9, 8);
  return v4;
}

uint64_t endpointCentricPlugin_GetPropertyData(uint64_t a1, int *a2, int a3, uint64_t a4, unsigned int a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t v26 = 0;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x2000000000;
  int v29 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  int v14 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v14 != 1668047219)
    {
      if (v14 != 1684370979) {
        goto LABEL_16;
      }
LABEL_11:
      v25[0] = 0;
      v25[1] = v25;
      v25[2] = 0x2000000000;
      v25[3] = 0;
      uint64_t v16 = *(NSObject **)(DerivedStorage + 16);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __endpointCentricPlugin_GetPropertyData_block_invoke;
      block[3] = &unk_1E567A6B8;
      void block[4] = v25;
      void block[5] = DerivedStorage;
      unsigned int v24 = a5;
      void block[6] = a7;
      void block[7] = a6;
      void block[8] = a2;
      dispatch_sync(v16, block);
      _Block_object_dispose(v25, 8);
      goto LABEL_19;
    }
    *a6 = 4;
    if (a5 >= 4)
    {
      int v17 = 0;
      *a7 = 1634757735;
      goto LABEL_18;
    }
LABEL_17:
    int v17 = 561211770;
    goto LABEL_18;
  }
  if (v14 == 1819107691)
  {
    *a6 = 8;
    if (a5 >= 8)
    {
      int v17 = 0;
      *(void *)a7 = @"Apple Inc.";
LABEL_18:
      *((_DWORD *)v27 + 6) = v17;
      goto LABEL_19;
    }
    goto LABEL_17;
  }
  if (v14 == 1870098020) {
    goto LABEL_11;
  }
  if (v14 != 1969841252)
  {
LABEL_16:
    *((_DWORD *)v27 + 6) = 2003332927;
    goto LABEL_19;
  }
  if (a5 > 3 && a3 == 8 && a4)
  {
    uint64_t v15 = *(NSObject **)(DerivedStorage + 16);
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 0x40000000;
    v21[2] = __endpointCentricPlugin_GetPropertyData_block_invoke_12;
    v21[3] = &unk_1E567A6E0;
    v21[4] = &v26;
    v21[5] = DerivedStorage;
    unsigned int v22 = a5;
    v21[6] = a4;
    v21[7] = a6;
    v21[8] = a7;
    dispatch_sync(v15, v21);
  }
  else
  {
    int v20 = FigSignalErrorAt(561211770, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v27 + 6) = v20;
  }
LABEL_19:
  uint64_t v18 = *((unsigned int *)v27 + 6);
  _Block_object_dispose(&v26, 8);
  return v18;
}

uint64_t endpointCentricPlugin_SetPropertyData()
{
  return 2003332927;
}

uint64_t endpointCentricPlugin_Initialize(const void *a1, uint64_t a2)
{
  uint64_t v11 = 0;
  int v12 = &v11;
  uint64_t v13 = 0x2000000000;
  int v14 = 0;
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v10 = 0;
  *uint64_t DerivedStorage = a2;
  int v5 = (void (*)(void, void, uint64_t, uint64_t *))DerivedStorage[7];
  if (v5) {
    v5(*MEMORY[0x1E4F1CF80], DerivedStorage[1], a2, &v10);
  }
  CFRetain(a1);
  uint64_t v6 = DerivedStorage[2];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __endpointCentricPlugin_Initialize_block_invoke;
  block[3] = &unk_1E567A708;
  void block[4] = &v11;
  void block[5] = v10;
  void block[6] = DerivedStorage;
  void block[7] = a1;
  dispatch_async(v6, block);
  uint64_t v7 = *((unsigned int *)v12 + 6);
  _Block_object_dispose(&v11, 8);
  return v7;
}

void endpointCentricPlugin_ActivatedEndpointsChangedNotificationCallback(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a2);
  CFRetain(a2);
  uint64_t v4 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __endpointCentricPlugin_ActivatedEndpointsChangedNotificationCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_15_1;
  void block[4] = a2;
  dispatch_async(v4, block);
}

void endpointCentricPlugin_PeruseActivatedEndpoints(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  long long v8 = (unint64_t)a1;
  uint64_t v7 = 0;
  if (!FigEndpointManagerCopyActivatedEndpoints(*(void *)(DerivedStorage + 40), (const __CFAllocator *)*MEMORY[0x1E4F1CF80], &v7))
  {
    FigCFArrayApplyFunction(v7, (void (__cdecl *)(const void *, void *))endpointCentricPlugin_UpdateEndpointApplier, &v8);
    if (BYTE9(v8))
    {
      CFArrayRef v3 = *(NSObject **)(DerivedStorage + 24);
      v4[0] = MEMORY[0x1E4F143A8];
      v4[1] = 0x40000000;
      v4[2] = __endpointCentricPlugin_PeruseActivatedEndpoints_block_invoke;
      _OWORD v4[3] = &__block_descriptor_tmp_16_1;
      long long v5 = v8;
      uint64_t v6 = DerivedStorage;
      dispatch_async(v3, v4);
    }
  }
  if (v7) {
    CFRelease(v7);
  }
}

uint64_t endpointCentricPlugin_UpdateEndpointApplier(void *a1, uint64_t a2)
{
  uint64_t result = endpointCentricPlugin_UpdateEndpoint(*(const void **)a2, a1, *(unsigned __int8 *)(a2 + 8));
  *(unsigned char *)(a2 + 9) += result;
  return result;
}

uint64_t endpointCentricPlugin_UpdateEndpoint(const void *a1, void *a2, int a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v31 = 0;
  CFArrayRef theArray = 0;
  context[0] = DerivedStorage;
  context[1] = a2;
  uint64_t v7 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (!a3)
  {
    uint64_t v8 = FigEndpointCopyStreamsForTypeAndSubType((uint64_t)a2, *MEMORY[0x1E4F1CF80], @"Audio", 0, &theArray);
    if (v8 != -16723 && v8 != 0) {
      FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
    }
  }
  uint64_t v10 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 80), a2);
  uint64_t value = v10;
  if (v10)
  {
    CFSetRef v11 = (const __CFSet *)v10;
    CFRetain(v10);
    CFAllocatorRef v12 = *v7;
  }
  else
  {
    CFAllocatorRef v12 = *v7;
    CFMutableSetRef Mutable = CFSetCreateMutable(*v7, 0, MEMORY[0x1E4F1D548]);
    uint64_t value = Mutable;
    if (!Mutable)
    {
      FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
      uint64_t v15 = 0;
      CFArrayRef MutableCopy = 0;
      goto LABEL_24;
    }
    CFSetRef v11 = Mutable;
  }
  CFArrayRef MutableCopy = CFSetCreateMutableCopy(v12, 0, v11);
  if (MutableCopy)
  {
    uint64_t v15 = CFSetCreateMutable(v12, 0, MEMORY[0x1E4F1D548]);
    if (v15)
    {
      if (theArray)
      {
        CFIndex Count = CFArrayGetCount(theArray);
        if (Count >= 1)
        {
          CFIndex v17 = Count;
          for (CFIndex i = 0; i != v17; ++i)
          {
            CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
            if (CFSetContainsValue(v11, ValueAtIndex)) {
              CFSetRemoveValue(MutableCopy, ValueAtIndex);
            }
            else {
              CFSetAddValue(v15, ValueAtIndex);
            }
          }
        }
      }
      CFSetApplyFunction(v15, (CFSetApplierFunction)endpointCentricPlugin_AddStreamApplier, context);
      CFSetApplyFunction(MutableCopy, (CFSetApplierFunction)endpointCentricPlugin_RemoveStreamApplier, context);
      if (a3)
      {
        DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRemoveListener(DefaultLocalCenter, a1, (int)endpointCentricPlugin_EndpointNotificationCallback, @"Endpoint_EndpointActivated", a2);
        uint64_t v21 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRemoveListener(v21, a1, (int)endpointCentricPlugin_EndpointNotificationCallback, @"Endpoint_EndpointDeactivated", a2);
        unsigned int v22 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRemoveListener(v22, a1, (int)endpointCentricPlugin_EndpointNotificationCallback, @"Endpoint_StreamsChanged", a2);
        uint64_t v23 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRemoveListener(v23, a1, (int)endpointCentricPlugin_EndpointNotificationCallback, @"Endpoint_Dissociated", a2);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(DerivedStorage + 80), a2);
      }
      else if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(DerivedStorage + 80), a2))
      {
        unsigned int v24 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterAddListener(v24, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))endpointCentricPlugin_EndpointNotificationCallback, @"Endpoint_EndpointActivated", (unint64_t)a2);
        uint64_t v25 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterAddListener(v25, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))endpointCentricPlugin_EndpointNotificationCallback, @"Endpoint_EndpointDeactivated", (unint64_t)a2);
        uint64_t v26 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterAddListener(v26, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))endpointCentricPlugin_EndpointNotificationCallback, @"Endpoint_StreamsChanged", (unint64_t)a2);
        uint64_t v27 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterAddListener(v27, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))endpointCentricPlugin_EndpointNotificationCallback, @"Endpoint_Dissociated", (unint64_t)a2);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(DerivedStorage + 80), a2, value);
      }
    }
    else
    {
      FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
    uint64_t v15 = 0;
  }
LABEL_24:
  if (theArray) {
    CFRelease(theArray);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (value) {
    CFRelease(value);
  }
  return v31;
}

void endpointCentricPlugin_AddStreamApplier(const void *a1, uint64_t a2)
{
  uint64_t value = 0;
  int v4 = (*(uint64_t (**)(void, void, void, void, const void *, void, void **))(*(void *)a2 + 48))(*MEMORY[0x1E4F1CF80], *(void *)(*(void *)a2 + 8), **(void **)a2, *(void *)(a2 + 8), a1, 0, &value);
  long long v5 = value;
  if (v4) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = value == 0;
  }
  if (!v6)
  {
    CFSetAddValue(*(CFMutableSetRef *)(a2 + 16), a1);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(void *)a2 + 72), a1, value);
    ++*(void *)(a2 + 24);
    long long v5 = value;
  }
  if (v5) {
    CFRelease(v5);
  }
}

void endpointCentricPlugin_RemoveStreamApplier(void *value, uint64_t a2)
{
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(*(void *)a2 + 72), value))
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(void *)a2 + 72), value);
    ++*(void *)(a2 + 24);
  }
}

void endpointCentricPlugin_EndpointNotificationCallback(uint64_t a1, const void *a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a2);
  CFRetain(a2);
  CFRetain(a4);
  uint64_t v8 = *(NSObject **)(DerivedStorage + 16);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  int v9[2] = __endpointCentricPlugin_EndpointNotificationCallback_block_invoke;
  void v9[3] = &__block_descriptor_tmp_18_2;
  void v9[4] = a3;
  v9[5] = a2;
  v9[6] = a4;
  v9[7] = DerivedStorage;
  dispatch_async(v8, v9);
}

BOOL FigTagCollectionIsEmpty(const OpaqueCMTagCollection *a1)
{
  return CMTagCollectionGetCount(a1) == 0;
}

Boolean CMTagCollectionIsEmpty(CMTagCollectionRef tagCollection)
{
  return CMTagCollectionGetCount(tagCollection) == 0;
}

CMItemCount CMTagCollectionGetCount(CMTagCollectionRef tagCollection)
{
  if (tagCollection)
  {
    CFTypeID v2 = CFGetTypeID(tagCollection);
    if (sRegisterCMTagCollectionTypeOnce != -1) {
      dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
    }
    if (v2 == sCMTagCollectionID) {
      return *((void *)tagCollection + 4);
    }
  }
  FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigTagCollectionGetTypeID()
{
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  return sCMTagCollectionID;
}

CFTypeID CMTagCollectionGetTypeID(void)
{
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  return sCMTagCollectionID;
}

uint64_t RegisterCMTagCollectionType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sCMTagCollectionID = result;
  return result;
}

uint64_t FigTagCollectionCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return _CMTagCollectionCreateCommon(0, a1, a2, a3, 0, 0, a4);
}

OSStatus CMTagCollectionCreate(CFAllocatorRef allocator, const CMTag *tags, CMItemCount tagCount, CMTagCollectionRef *newCollectionOut)
{
  return _CMTagCollectionCreateCommon(0, (uint64_t)allocator, (uint64_t)tags, tagCount, 0, 0, (uint64_t *)newCollectionOut);
}

uint64_t _CMTagCollectionCreateCommon(char a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5, uint64_t a6, uint64_t *a7)
{
  if (!a7)
  {
    uint64_t v15 = 4294951556;
    goto LABEL_19;
  }
  uint64_t v10 = a4;
  if ((a1 & 1) == 0 || (a1 & 2) != 0)
  {
    if ((a1 & 3) != 0)
    {
      if (((a1 & 1) == 0 || (a1 & 2) == 0) && (a1 & 3) != 2 || !a6) {
        goto LABEL_36;
      }
    }
    else
    {
      BOOL v19 = a4 < 0;
      if (!a3) {
        BOOL v19 = a4 != 0;
      }
      if (v19) {
        goto LABEL_36;
      }
    }
  }
  else if (a3 || a4 || a5 < 0)
  {
LABEL_36:
    uint64_t v15 = 4294951556;
    goto LABEL_19;
  }
  *a7 = 0;
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v15 = 4294951555;
LABEL_19:
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v14 = (uint64_t)Instance;
  Instance[3] = 0;
  Instance[4] = 0;
  Instance[2] = 0x274616773;
  Instance[5] = 0;
  Instance[6] = 16;
  Instance[7] = Instance + 8;
  if ((a1 & 2) != 0)
  {
    _CMTagCollectionEnsureTagArraySpace((uint64_t)Instance, *(void *)(a6 + 48), 0);
    *(void *)(v14 + 32) = *(void *)(a6 + 32);
    memcpy(*(void **)(v14 + 56), *(const void **)(a6 + 56), 16 * *(void *)(a6 + 32));
  }
  else
  {
    if (a1) {
      int64_t v17 = a5;
    }
    else {
      int64_t v17 = v10;
    }
    _CMTagCollectionEnsureTagArraySpace((uint64_t)Instance, v17, 0);
    if (a3 && v10 >= 1 && (a1 & 1) == 0)
    {
      uint64_t v18 = a3 + 8;
      do
      {
        _CMTagCollectionAddTagAvoidingDuplicates(v14, *(CMTag *)(v18 - 8));
        v18 += 16;
        --v10;
      }
      while (v10);
    }
  }
  if (a1) {
    *(_DWORD *)(v14 + 20) |= 1u;
  }
  *a7 = v14;
  return 0;
}

uint64_t FigTagCollectionCreateMutable(uint64_t a1, int64_t a2, uint64_t *a3)
{
  return _CMTagCollectionCreateCommon(1, a1, 0, 0, a2, 0, a3);
}

OSStatus CMTagCollectionCreateMutable(CFAllocatorRef allocator, CFIndex capacity, CMMutableTagCollectionRef *newMutableCollectionOut)
{
  return _CMTagCollectionCreateCommon(1, (uint64_t)allocator, 0, 0, capacity, 0, (uint64_t *)newMutableCollectionOut);
}

uint64_t FigTagCollectionCreateCopy(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return _CMTagCollectionCreateCommon(2, a2, 0, 0, 0, a1, a3);
}

OSStatus CMTagCollectionCreateCopy(CMTagCollectionRef tagCollection, CFAllocatorRef allocator, CMTagCollectionRef *newCollectionCopyOut)
{
  return _CMTagCollectionCreateCommon(2, (uint64_t)allocator, 0, 0, 0, (uint64_t)tagCollection, (uint64_t *)newCollectionCopyOut);
}

uint64_t FigTagCollectionCreateMutableCopy(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return _CMTagCollectionCreateCommon(3, a2, 0, 0, 0, a1, a3);
}

OSStatus CMTagCollectionCreateMutableCopy(CMTagCollectionRef tagCollection, CFAllocatorRef allocator, CMMutableTagCollectionRef *newMutableCollectionCopyOut)
{
  return _CMTagCollectionCreateCommon(3, (uint64_t)allocator, 0, 0, 0, (uint64_t)tagCollection, (uint64_t *)newMutableCollectionCopyOut);
}

CFStringRef CMTagCollectionCopyDescription(CFAllocatorRef allocator, CMTagCollectionRef tagCollection)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(allocator, 0);
  if (Mutable)
  {
    if (!tagCollection) {
      goto LABEL_19;
    }
    CFTypeID v5 = CFGetTypeID(tagCollection);
    if (sRegisterCMTagCollectionTypeOnce != -1) {
      dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
    }
    if (v5 == sCMTagCollectionID)
    {
      if (*((_DWORD *)tagCollection + 5)) {
        CFStringAppendFormat(Mutable, 0, @"CMMutableTagCollection");
      }
      else {
        CFStringAppendFormat(Mutable, 0, @"CMTagCollection");
      }
      if ((*((unsigned char *)tagCollection + 20) & 0x10) != 0)
      {
        CFStringAppendFormat(Mutable, 0, @"{inline}");
        if ((*((unsigned char *)tagCollection + 20) & 0x10) != 0) {
          CFStringAppendFormat(Mutable, 0, @"{%d tags}", *((void *)tagCollection + 4));
        }
      }
      CFStringAppendFormat(Mutable, 0, @"{\n");
      if (*((uint64_t *)tagCollection + 4) >= 1)
      {
        uint64_t v6 = 0;
        uint64_t v7 = 0;
        do
        {
          CFStringRef v8 = CMTagCopyDescription(allocator, *(CMTag *)(*((void *)tagCollection + 7) + v6));
          CFStringAppendFormat(Mutable, 0, @"%@\n", v8);
          if (v8) {
            CFRelease(v8);
          }
          ++v7;
          v6 += 16;
        }
        while (v7 < *((void *)tagCollection + 4));
      }
      CFStringAppendFormat(Mutable, 0, @"}");
    }
    else
    {
LABEL_19:
      FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    }
  }
  return Mutable;
}

void CMTagCollectionApply(CMTagCollectionRef tagCollection, CMTagCollectionApplierFunction applier, void *context)
{
  if (!tagCollection) {
    goto LABEL_12;
  }
  CFTypeID v6 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v6 != sCMTagCollectionID || applier == 0)
  {
LABEL_12:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
  else if (*((uint64_t *)tagCollection + 4) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      ((void (*)(void, void, void *))applier)(*(void *)(*((void *)tagCollection + 7) + v8), *(void *)(*((void *)tagCollection + 7) + v8 + 8), context);
      ++v9;
      v8 += 16;
    }
    while (v9 < *((void *)tagCollection + 4));
  }
}

CMTag CMTagCollectionApplyUntil(CMTagCollectionRef tagCollection, CMTagCollectionTagFilterFunction applier, void *context)
{
  uint64_t v4 = 0;
  CMTagValue v3 = 0;
  if (!tagCollection) {
    goto LABEL_15;
  }
  CFTypeID v8 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v8 != sCMTagCollectionID || applier == 0)
  {
LABEL_15:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
  else if (*((uint64_t *)tagCollection + 4) >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    while (1)
    {
      CFAllocatorRef v12 = (void *)(*((void *)tagCollection + 7) + v10);
      uint64_t v13 = *v12;
      CMTagValue v14 = v12[1];
      if (((unsigned int (*)(void, CMTagValue, void *))applier)(*v12, v14, context)) {
        break;
      }
      ++v11;
      v10 += 16;
      if (v11 >= *((void *)tagCollection + 4)) {
        goto LABEL_14;
      }
    }
    CMTagValue v3 = v14;
    uint64_t v4 = v13;
  }
LABEL_14:
  uint64_t v15 = v4;
  CMTagValue v16 = v3;
  result.uint64_t value = v16;
  result.category = v15;
  result.CFStringRef dataType = HIDWORD(v15);
  return result;
}

Boolean CMTagCollectionContainsTag(CMTagCollectionRef tagCollection, CMTag tag)
{
  if (!tagCollection) {
    goto LABEL_6;
  }
  CMTagValue value = tag.value;
  uint64_t v3 = *(void *)&tag.category;
  CFTypeID v5 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v5 == sCMTagCollectionID)
  {
    context[1] = value;
    uint64_t v8 = 0;
    context[0] = v3;
    CMTagCollectionApplyUntil(tagCollection, (CMTagCollectionTagFilterFunction)_CMTagCollectionContainsTagApplier, context);
    return v8;
  }
  else
  {
LABEL_6:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

uint64_t _CMTagCollectionContainsTagApplier(CMTag a1, uint64_t a2)
{
  if (!CMTagEqualToTag(a1, *(CMTag *)a2)) {
    return *(unsigned __int8 *)(a2 + 16);
  }
  uint64_t result = 1;
  *(unsigned char *)(a2 + 16) = 1;
  return result;
}

Boolean CMTagCollectionContainsTagsOfCollection(CMTagCollectionRef tagCollection, CMTagCollectionRef containedTagCollection)
{
  if (!tagCollection) {
    goto LABEL_7;
  }
  CFTypeID v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v4 == sCMTagCollectionID)
  {
    CMTagCollectionRef v6 = tagCollection;
    uint64_t v7 = 0;
    CMTagCollectionApply(containedTagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionContainsTagsApplier, &v6);
    if (!HIDWORD(v7)) {
      return (_BYTE)v7 == 0;
    }
  }
  else
  {
LABEL_7:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t _CMTagCollectionContainsTagsApplier(CMTag tag, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 12) && !*(unsigned char *)(a2 + 8))
  {
    *(void *)&tag.category = CMTagCollectionContainsTag(*(CMTagCollectionRef *)a2, tag);
    *(unsigned char *)(a2 + 8) = tag.category == kCMTagCategory_Undefined;
    if (!*(_DWORD *)(a2 + 12)) {
      *(_DWORD *)(a2 + 12) = 0;
    }
  }
  return *(void *)&tag.category;
}

Boolean CMTagCollectionContainsSpecifiedTags(CMTagCollectionRef tagCollection, const CMTag *containedTags, CMItemCount containedTagCount)
{
  if (!tagCollection) {
    goto LABEL_14;
  }
  CFTypeID v6 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v6 == sCMTagCollectionID && containedTags && (containedTagCount & 0x8000000000000000) == 0)
  {
    if (containedTagCount)
    {
      BOOL v7 = 0;
      p_CMTagValue value = &containedTags->value;
      do
      {
        if (!v7) {
          BOOL v7 = CMTagCollectionContainsTag(tagCollection, *(CMTag *)(p_value - 1)) == 0;
        }
        p_value += 2;
        --containedTagCount;
      }
      while (containedTagCount);
      return !v7;
    }
    else
    {
      return 1;
    }
  }
  else
  {
LABEL_14:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

Boolean CMTagCollectionContainsCategory(CMTagCollectionRef tagCollection, CMTagCategory category)
{
  if (!tagCollection) {
    goto LABEL_6;
  }
  CFTypeID v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v4 == sCMTagCollectionID)
  {
    CMTagCategory context = category;
    return CMTagCollectionApplyUntil(tagCollection, (CMTagCollectionTagFilterFunction)_CMTagCollectionContainsTagCategoryApplier, &context).category == category;
  }
  else
  {
LABEL_6:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

BOOL _CMTagCollectionContainsTagCategoryApplier(int a1, uint64_t a2, _DWORD *a3)
{
  return *a3 == a1;
}

CMItemCount CMTagCollectionGetCountOfCategory(CMTagCollectionRef tagCollection, CMTagCategory category)
{
  if (!tagCollection) {
    goto LABEL_6;
  }
  CFTypeID v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v4 == sCMTagCollectionID)
  {
    uint64_t v7 = 0;
    uint64_t v6 = category;
    CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionCountOfCategoryApplier, &v6);
    return v7;
  }
  else
  {
LABEL_6:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

uint64_t _CMTagCollectionCountOfCategoryApplier(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a3 == result) {
    ++*(void *)(a3 + 8);
  }
  return result;
}

CMItemCount CMTagCollectionCountTagsWithFilterFunction(CMTagCollectionRef tagCollection, CMTagCollectionTagFilterFunction filterApplier, void *context)
{
  if (!tagCollection) {
    goto LABEL_9;
  }
  CFTypeID v6 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v6 == sCMTagCollectionID && filterApplier)
  {
    long long v9 = 0uLL;
    v8[0] = filterApplier;
    v8[1] = context;
    long long v10 = 0uLL;
    CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionCountTagsFilterFunctionApplier, v8);
    if (HIDWORD(v10)) {
      return 0;
    }
    else {
      return v9;
    }
  }
  else
  {
LABEL_9:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

uint64_t _CMTagCollectionCountTagsFilterFunctionApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))a3)(a1, a2, *(void *)(a3 + 8));
  if (result) {
    ++*(void *)(a3 + 16);
  }
  return result;
}

OSStatus CMTagCollectionGetTagsWithFilterFunction(CMTagCollectionRef tagCollection, CMTag *tagBuffer, CMItemCount tagBufferCount, CMItemCount *numberOfTagsCopied, CMTagCollectionTagFilterFunction filter, void *context)
{
  if (!tagCollection) {
    goto LABEL_19;
  }
  CFTypeID v12 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  BOOL v13 = v12 != sCMTagCollectionID || tagBuffer == 0;
  if (v13 || filter == 0)
  {
LABEL_19:
    OSStatus result = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    CMItemCount v15 = 0;
    if (!numberOfTagsCopied) {
      return result;
    }
    goto LABEL_17;
  }
  v18[0] = filter;
  v18[1] = context;
  uint64_t v21 = tagBuffer;
  uint64_t v22 = 0;
  CMItemCount v19 = 0;
  CMItemCount v20 = tagBufferCount;
  CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionGetTagsFilterFunctionApplier, v18);
  CMItemCount v15 = v19;
  OSStatus result = HIDWORD(v22);
  if (!HIDWORD(v22))
  {
    if (v19 < tagBufferCount)
    {
      int64_t v17 = &tagBuffer[v19];
      do
      {
        *v17++ = kCMTagInvalid;
        --tagBufferCount;
      }
      while (v15 != tagBufferCount);
    }
    OSStatus result = 0;
  }
  if (numberOfTagsCopied) {
LABEL_17:
  }
    *numberOfTagsCopied = v15;
  return result;
}

uint64_t _CMTagCollectionGetTagsFilterFunctionApplier(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (!*(_DWORD *)(a3 + 44) && !*(unsigned char *)(a3 + 40))
  {
    uint64_t v5 = result;
    OSStatus result = (*(uint64_t (**)(uint64_t, uint64_t, void))a3)(result, a2, *(void *)(a3 + 8));
    if (result)
    {
      uint64_t v6 = *(void *)(a3 + 16);
      if (v6 == *(void *)(a3 + 24))
      {
        *(unsigned char *)(a3 + 40) = 1;
        *(_DWORD *)(a3 + 44) = -15748;
      }
      else
      {
        uint64_t v7 = (uint64_t *)(*(void *)(a3 + 32) + 16 * v6);
        *uint64_t v7 = v5;
        v7[1] = a2;
        ++*(void *)(a3 + 16);
      }
    }
  }
  return result;
}

uint64_t FigTagCollectionGetTags(const OpaqueCMTagCollection *a1, CMTag *a2, CMItemCount a3, CMItemCount *a4)
{
  return CMTagCollectionGetTagsWithFilterFunction(a1, a2, a3, a4, (CMTagCollectionTagFilterFunction)_CMTagCollectionAllTagsFilter, 0);
}

OSStatus CMTagCollectionGetTags(CMTagCollectionRef tagCollection, CMTag *tagBuffer, CMItemCount tagBufferCount, CMItemCount *numberOfTagsCopied)
{
  return CMTagCollectionGetTagsWithFilterFunction(tagCollection, tagBuffer, tagBufferCount, numberOfTagsCopied, (CMTagCollectionTagFilterFunction)_CMTagCollectionAllTagsFilter, 0);
}

uint64_t _CMTagCollectionAllTagsFilter()
{
  return 1;
}

uint64_t FigTagCollectionGetTagsWithCategory(const OpaqueCMTagCollection *a1, int a2, CMTag *tagBuffer, CMItemCount tagBufferCount, CMItemCount *numberOfTagsCopied)
{
  int context = a2;
  return CMTagCollectionGetTagsWithFilterFunction(a1, tagBuffer, tagBufferCount, numberOfTagsCopied, (CMTagCollectionTagFilterFunction)_CMTagCollectionAllTagsOfCategoryFilter, &context);
}

OSStatus CMTagCollectionGetTagsWithCategory(CMTagCollectionRef tagCollection, CMTagCategory category, CMTag *tagBuffer, CMItemCount tagBufferCount, CMItemCount *numberOfTagsCopied)
{
  CMTagCategory context = category;
  return CMTagCollectionGetTagsWithFilterFunction(tagCollection, tagBuffer, tagBufferCount, numberOfTagsCopied, (CMTagCollectionTagFilterFunction)_CMTagCollectionAllTagsOfCategoryFilter, &context);
}

BOOL _CMTagCollectionAllTagsOfCategoryFilter(int a1, uint64_t a2, _DWORD *a3)
{
  return *a3 == a1;
}

OSStatus CMTagCollectionCreateIntersection(CMTagCollectionRef tagCollection1, CMTagCollectionRef tagCollection2, CMTagCollectionRef *tagCollectionOut)
{
  CFTypeRef cf = 0;
  if (!tagCollection1) {
    goto LABEL_20;
  }
  CFTypeID v6 = CFGetTypeID(tagCollection1);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v6 != sCMTagCollectionID || tagCollection2 == 0) {
    goto LABEL_20;
  }
  CFTypeID v8 = CFGetTypeID(tagCollection2);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v8 == sCMTagCollectionID && tagCollectionOut)
  {
    CFAllocatorRef v9 = CFGetAllocator(tagCollection1);
    if (tagCollection1 == tagCollection2)
    {
      OSStatus Common = _CMTagCollectionCreateCommon(3, (uint64_t)v9, 0, 0, 0, (uint64_t)tagCollection1, (uint64_t *)&cf);
      if (!Common) {
        goto LABEL_18;
      }
    }
    else
    {
      OSStatus Common = _CMTagCollectionCreateCommon(1, (uint64_t)v9, 0, 0, 0, 0, (uint64_t *)&cf);
      if (!Common)
      {
        context[0] = tagCollection1;
        context[1] = tagCollection2;
        void context[2] = cf;
        uint64_t v14 = 0;
        CMTagCollectionApply(tagCollection1, (CMTagCollectionApplierFunction)_CMTagCollectionIntersectApplier, context);
        OSStatus v11 = v14;
        if (v14) {
          goto LABEL_15;
        }
LABEL_18:
        OSStatus v11 = 0;
        *tagCollectionOut = (CMTagCollectionRef)cf;
        return v11;
      }
    }
  }
  else
  {
LABEL_20:
    OSStatus Common = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
  OSStatus v11 = Common;
LABEL_15:
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t _CMTagCollectionIntersectApplier(CMTag tag, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 24))
  {
    CMTagValue value = tag.value;
    uint64_t v4 = *(void *)&tag.category;
    uint64_t v5 = *(const OpaqueCMTagCollection **)(a2 + 8);
    *(void *)&v7.category = v4;
    v7.CMTagValue value = value;
    *(void *)&tag.category = CMTagCollectionContainsTag(v5, v7);
    if (tag.category)
    {
      *(void *)&v8.category = v4;
      v8.CMTagValue value = value;
      *(void *)&tag.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a2 + 16), v8);
    }
    if (!*(_DWORD *)(a2 + 24)) {
      *(_DWORD *)(a2 + 24) = tag.category;
    }
  }
  return *(void *)&tag.category;
}

OSStatus CMTagCollectionCreateUnion(CMTagCollectionRef tagCollection1, CMTagCollectionRef tagCollection2, CMTagCollectionRef *tagCollectionOut)
{
  CFTypeRef cf = 0;
  if (!tagCollection1) {
    goto LABEL_18;
  }
  CFTypeID v6 = CFGetTypeID(tagCollection1);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v6 != sCMTagCollectionID || !tagCollection2) {
    goto LABEL_18;
  }
  CFTypeID v7 = CFGetTypeID(tagCollection2);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v7 != sCMTagCollectionID || !tagCollectionOut)
  {
LABEL_18:
    OSStatus Common = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  CFAllocatorRef v8 = CFGetAllocator(tagCollection1);
  if (tagCollection1 == tagCollection2)
  {
    OSStatus Common = _CMTagCollectionCreateCommon(3, (uint64_t)v8, 0, 0, 0, (uint64_t)tagCollection1, (uint64_t *)&cf);
    if (!Common)
    {
LABEL_16:
      OSStatus v10 = 0;
      *tagCollectionOut = (CMTagCollectionRef)cf;
      return v10;
    }
LABEL_19:
    OSStatus v10 = Common;
    goto LABEL_20;
  }
  OSStatus Common = _CMTagCollectionCreateCommon(1, (uint64_t)v8, 0, 0, 0, 0, (uint64_t *)&cf);
  if (Common) {
    goto LABEL_19;
  }
  context[0] = tagCollection1;
  context[1] = tagCollection2;
  void context[2] = cf;
  uint64_t v13 = 0;
  CMTagCollectionApply(tagCollection1, (CMTagCollectionApplierFunction)_CMTagCollectionUnionApplier, context);
  OSStatus v10 = v13;
  if (!v13)
  {
    LODWORD(v13) = 0;
    CMTagCollectionApply(tagCollection2, (CMTagCollectionApplierFunction)_CMTagCollectionUnionApplier, context);
    OSStatus v10 = v13;
    if (!v13) {
      goto LABEL_16;
    }
  }
LABEL_20:
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t _CMTagCollectionUnionApplier(CMTag tagToAdd, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 24))
  {
    *(void *)&tagToAdd.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a2 + 16), tagToAdd);
    if (!*(_DWORD *)(a2 + 24)) {
      *(_DWORD *)(a2 + 24) = tagToAdd.category;
    }
  }
  return *(void *)&tagToAdd.category;
}

OSStatus CMTagCollectionCreateDifference(CMTagCollectionRef tagCollectionMinuend, CMTagCollectionRef tagCollectionSubtrahend, CMTagCollectionRef *tagCollectionOut)
{
  CFTypeRef cf = 0;
  if (!tagCollectionMinuend) {
    goto LABEL_17;
  }
  CFTypeID v6 = CFGetTypeID(tagCollectionMinuend);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v6 != sCMTagCollectionID || tagCollectionSubtrahend == 0) {
    goto LABEL_17;
  }
  CFTypeID v8 = CFGetTypeID(tagCollectionSubtrahend);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v8 == sCMTagCollectionID && tagCollectionOut)
  {
    CFAllocatorRef v9 = CFGetAllocator(tagCollectionMinuend);
    OSStatus Common = _CMTagCollectionCreateCommon(1, (uint64_t)v9, 0, 0, 0, 0, (uint64_t *)&cf);
    OSStatus v11 = Common;
    if (tagCollectionMinuend != tagCollectionSubtrahend)
    {
      if (Common) {
        goto LABEL_18;
      }
      context[0] = tagCollectionMinuend;
      context[1] = tagCollectionSubtrahend;
      void context[2] = cf;
      uint64_t v14 = 0;
      CMTagCollectionApply(tagCollectionMinuend, (CMTagCollectionApplierFunction)_CMTagCollectionSubtractApplier, context);
      OSStatus v11 = v14;
    }
    if (!v11)
    {
      OSStatus v11 = 0;
      *tagCollectionOut = (CMTagCollectionRef)cf;
      return v11;
    }
  }
  else
  {
LABEL_17:
    OSStatus v11 = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
LABEL_18:
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t _CMTagCollectionSubtractApplier(CMTag tag, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 24))
  {
    CMTagValue value = tag.value;
    uint64_t v4 = *(void *)&tag.category;
    uint64_t v5 = *(const OpaqueCMTagCollection **)(a2 + 8);
    *(void *)&v7.category = v4;
    v7.CMTagValue value = value;
    if (CMTagCollectionContainsTag(v5, v7))
    {
      *(void *)&tag.category = 0;
    }
    else
    {
      *(void *)&v8.category = v4;
      v8.CMTagValue value = value;
      *(void *)&tag.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a2 + 16), v8);
    }
    if (!*(_DWORD *)(a2 + 24)) {
      *(_DWORD *)(a2 + 24) = tag.category;
    }
  }
  return *(void *)&tag.category;
}

OSStatus CMTagCollectionCreateExclusiveOr(CMTagCollectionRef tagCollection1, CMTagCollectionRef tagCollection2, CMTagCollectionRef *tagCollectionOut)
{
  CFTypeRef cf = 0;
  if (!tagCollection1) {
    goto LABEL_17;
  }
  CFTypeID v6 = CFGetTypeID(tagCollection1);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v6 != sCMTagCollectionID || !tagCollection2) {
    goto LABEL_17;
  }
  CFTypeID v7 = CFGetTypeID(tagCollection2);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v7 != sCMTagCollectionID || !tagCollectionOut)
  {
LABEL_17:
    OSStatus v10 = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    goto LABEL_18;
  }
  CFAllocatorRef v8 = CFGetAllocator(tagCollection1);
  OSStatus Common = _CMTagCollectionCreateCommon(1, (uint64_t)v8, 0, 0, 0, 0, (uint64_t *)&cf);
  OSStatus v10 = Common;
  if (tagCollection1 != tagCollection2)
  {
    if (Common) {
      goto LABEL_18;
    }
    CFTypeRef v14 = cf;
    uint64_t v15 = 0;
    CMTagCollectionRef context = tagCollection1;
    CMTagCollectionRef v13 = tagCollection2;
    CMTagCollectionApply(tagCollection1, (CMTagCollectionApplierFunction)_CMTagCollectionExcludeApplier, &context);
    OSStatus v10 = v15;
    if (v15) {
      goto LABEL_18;
    }
    CMTagCollectionRef context = tagCollection2;
    CMTagCollectionRef v13 = tagCollection1;
    LODWORD(v15) = 0;
    CMTagCollectionApply(tagCollection2, (CMTagCollectionApplierFunction)_CMTagCollectionExcludeApplier, &context);
    OSStatus v10 = v15;
  }
  if (!v10)
  {
    OSStatus v10 = 0;
    *tagCollectionOut = (CMTagCollectionRef)cf;
    return v10;
  }
LABEL_18:
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t _CMTagCollectionExcludeApplier(CMTag tag, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 24))
  {
    CMTagValue value = tag.value;
    uint64_t v4 = *(void *)&tag.category;
    uint64_t v5 = *(const OpaqueCMTagCollection **)(a2 + 8);
    *(void *)&v7.category = v4;
    v7.CMTagValue value = value;
    if (CMTagCollectionContainsTag(v5, v7))
    {
      *(void *)&tag.category = 0;
    }
    else
    {
      *(void *)&v8.category = v4;
      v8.CMTagValue value = value;
      *(void *)&tag.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a2 + 16), v8);
    }
    if (!*(_DWORD *)(a2 + 24)) {
      *(_DWORD *)(a2 + 24) = tag.category;
    }
  }
  return *(void *)&tag.category;
}

OSStatus CMTagCollectionAddTag(CMMutableTagCollectionRef tagCollection, CMTag tagToAdd)
{
  if (!tagCollection) {
    goto LABEL_7;
  }
  CMTagValue value = tagToAdd.value;
  uint64_t v3 = *(void *)&tagToAdd.category;
  CFTypeID v5 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v5 == sCMTagCollectionID && (*((unsigned char *)tagCollection + 20) & 1) != 0)
  {
    _CMTagCollectionEnsureTagArraySpace((uint64_t)tagCollection, *((void *)tagCollection + 4) + 1, 0);
    *(void *)&v8.category = v3;
    v8.CMTagValue value = value;
    _CMTagCollectionAddTagAvoidingDuplicates((uint64_t)tagCollection, v8);
    return 0;
  }
  else
  {
LABEL_7:
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
}

void _CMTagCollectionEnsureTagArraySpace(uint64_t a1, int64_t count, int a3)
{
  unsigned int v5 = *(unsigned __int8 *)(a1 + 20);
  if (*(void *)(a1 + 48) >= count)
  {
    if (count <= 15 && a3 && ((v5 >> 1) & 1) == 0)
    {
      CMTag v7 = *(long long **)(a1 + 56);
      long long v8 = v7[3];
      long long v10 = *v7;
      long long v9 = v7[1];
      *(_OWORD *)(a1 + 96) = v7[2];
      *(_OWORD *)(a1 + 112) = v8;
      *(_OWORD *)(a1 + 64) = v10;
      *(_OWORD *)(a1 + 80) = v9;
      long long v11 = v7[7];
      long long v13 = v7[4];
      long long v12 = v7[5];
      *(_OWORD *)(a1 + 160) = v7[6];
      *(_OWORD *)(a1 + 176) = v11;
      *(_OWORD *)(a1 + 128) = v13;
      *(_OWORD *)(a1 + 144) = v12;
      long long v14 = v7[11];
      long long v16 = v7[8];
      long long v15 = v7[9];
      *(_OWORD *)(a1 + 224) = v7[10];
      *(_OWORD *)(a1 + 240) = v14;
      *(_OWORD *)(a1 + 192) = v16;
      *(_OWORD *)(a1 + 208) = v15;
      long long v17 = v7[15];
      long long v19 = v7[12];
      long long v18 = v7[13];
      *(_OWORD *)(a1 + 288) = v7[14];
      *(_OWORD *)(a1 + 304) = v17;
      *(_OWORD *)(a1 + 256) = v19;
      *(_OWORD *)(a1 + 272) = v18;
      free(v7);
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = a1 + 64;
      *(_DWORD *)(a1 + 20) |= 2u;
    }
  }
  else if ((v5 & 2) != 0)
  {
    CMItemCount v20 = malloc_type_calloc(count, 0x10uLL, 0x1000040451B5BE8uLL);
    *(void *)(a1 + 56) = v20;
    *(_DWORD *)(a1 + 20) &= ~2u;
    long long v21 = *(_OWORD *)(a1 + 256);
    long long v22 = *(_OWORD *)(a1 + 272);
    long long v23 = *(_OWORD *)(a1 + 304);
    v20[14] = *(_OWORD *)(a1 + 288);
    v20[15] = v23;
    v20[12] = v21;
    v20[13] = v22;
    long long v24 = *(_OWORD *)(a1 + 192);
    long long v25 = *(_OWORD *)(a1 + 208);
    long long v26 = *(_OWORD *)(a1 + 240);
    v20[10] = *(_OWORD *)(a1 + 224);
    v20[11] = v26;
    v20[8] = v24;
    v20[9] = v25;
    long long v27 = *(_OWORD *)(a1 + 128);
    long long v28 = *(_OWORD *)(a1 + 144);
    long long v29 = *(_OWORD *)(a1 + 176);
    void v20[6] = *(_OWORD *)(a1 + 160);
    v20[7] = v29;
    v20[4] = v27;
    v20[5] = v28;
    long long v30 = *(_OWORD *)(a1 + 64);
    long long v31 = *(_OWORD *)(a1 + 80);
    long long v32 = *(_OWORD *)(a1 + 112);
    _OWORD v20[2] = *(_OWORD *)(a1 + 96);
    v20[3] = v32;
    *CMItemCount v20 = v30;
    v20[1] = v31;
    *(void *)(a1 + 48) = count;
  }
  else
  {
    CFTypeID v6 = malloc_type_realloc(*(void **)(a1 + 56), 16 * count, 0x1000040451B5BE8uLL);
    *(void *)(a1 + 48) = count;
    *(void *)(a1 + 56) = v6;
  }
  if (*(void *)(a1 + 32) > count) {
    *(void *)(a1 + 32) = count;
  }
}

uint64_t _CMTagCollectionAddTagAvoidingDuplicates(uint64_t a1, CMTag a2)
{
  CMTagValue value = a2.value;
  uint64_t v3 = *(void *)&a2.category;
  uint64_t v9 = -1;
  char v8 = 0;
  uint64_t result = _CMTagCollectionFindTag(a1, a2, &v9, &v8);
  if (!result)
  {
    uint64_t v6 = v9;
    if (!v8) {
      uint64_t result = (uint64_t)memmove((void *)(*(void *)(a1 + 56) + 16 * v9 + 16), (const void *)(*(void *)(a1 + 56) + 16 * v9), 16 * (*(void *)(a1 + 32) - v9));
    }
    CMTag v7 = (void *)(*(void *)(a1 + 56) + 16 * v6);
    *CMTag v7 = v3;
    v7[1] = value;
    ++*(void *)(a1 + 32);
  }
  return result;
}

OSStatus CMTagCollectionRemoveTag(CMMutableTagCollectionRef tagCollection, CMTag tagToRemove)
{
  if (!tagCollection) {
    goto LABEL_15;
  }
  CMTagValue value = tagToRemove.value;
  uint64_t v3 = *(void *)&tagToRemove.category;
  CFTypeID v5 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v5 == sCMTagCollectionID && (*((unsigned char *)tagCollection + 20) & 1) != 0)
  {
    uint64_t v6 = *((void *)tagCollection + 4);
    if (v6 < 0) {
      return 0;
    }
    if (v6
      && (uint64_t v13 = -1,
          char v12 = 0,
          *(void *)&v15.category = v3,
          v15.CMTagValue value = value,
          _CMTagCollectionFindTag((uint64_t)tagCollection, v15, &v13, &v12)))
    {
      if (v12) {
        return 0;
      }
      uint64_t v8 = v13;
      uint64_t v9 = *((void *)tagCollection + 4) - (v13 + 1);
      uint64_t v10 = *((void *)tagCollection + 7);
      long long v11 = (CMTag *)(v10 + 16 * v13);
      if (v9 >= 1)
      {
        memmove((void *)(v10 + 16 * v13), (const void *)(v10 + 16 * (v13 + 1)), 16 * v9);
        long long v11 = (CMTag *)(*((void *)tagCollection + 7) + 16 * (v9 + v8));
      }
      OSStatus result = 0;
      *long long v11 = kCMTagInvalid;
      --*((void *)tagCollection + 4);
    }
    else
    {
      return -15746;
    }
  }
  else
  {
LABEL_15:
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

OSStatus CMTagCollectionRemoveAllTags(CMMutableTagCollectionRef tagCollection)
{
  if (!tagCollection) {
    goto LABEL_7;
  }
  CFTypeID v2 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v2 == sCMTagCollectionID && (*((unsigned char *)tagCollection + 20) & 1) != 0)
  {
    _CMTagCollectionEnsureTagArraySpace((uint64_t)tagCollection, 0, 1);
    return 0;
  }
  else
  {
LABEL_7:
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMTagCollectionRemoveAllTagsOfCategory(CMMutableTagCollectionRef tagCollection, CMTagCategory category)
{
  if (!tagCollection) {
    goto LABEL_18;
  }
  CFTypeID v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v4 == sCMTagCollectionID && (*((unsigned char *)tagCollection + 20) & 1) != 0)
  {
    uint64_t v5 = *((void *)tagCollection + 4);
    if (v5)
    {
      if (v5 >= 1)
      {
        uint64_t v6 = 0;
        uint64_t v7 = 16 * v5 - 16;
        do
        {
          size_t v8 = v7 - 16 * v6;
          uint64_t v9 = (_DWORD *)(*((void *)tagCollection + 7) + 16 * v6);
          while (*v9 != category)
          {
            ++v6;
            v8 -= 16;
            v9 += 4;
            if (v6 >= v5) {
              goto LABEL_16;
            }
          }
          if (~v6 + v5 >= 1) {
            memmove(v9, v9 + 4, v8);
          }
          --v5;
          v7 -= 16;
        }
        while (v6 < v5);
      }
LABEL_16:
      *((void *)tagCollection + 4) = v5;
    }
    return 0;
  }
  else
  {
LABEL_18:
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigTagCollectionAddTagsFromCollection(uint64_t a1, CMTagCollectionRef tagCollection)
{
  uint64_t v3 = a1;
  uint64_t v4 = 0;
  CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionAddTagsFromCollectionApplier, &v3);
  return v4;
}

OSStatus CMTagCollectionAddTagsFromCollection(CMMutableTagCollectionRef tagCollection, CMTagCollectionRef collectionWithTagsToAdd)
{
  CMMutableTagCollectionRef v3 = tagCollection;
  uint64_t v4 = 0;
  CMTagCollectionApply(collectionWithTagsToAdd, (CMTagCollectionApplierFunction)_CMTagCollectionAddTagsFromCollectionApplier, &v3);
  return v4;
}

uint64_t _CMTagCollectionAddTagsFromCollectionApplier(CMTag tagToAdd, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 8))
  {
    *(void *)&tagToAdd.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)a2, tagToAdd);
    if (!*(_DWORD *)(a2 + 8)) {
      *(_DWORD *)(a2 + 8) = tagToAdd.category;
    }
  }
  return *(void *)&tagToAdd.category;
}

uint64_t FigTagCollectionAddTagsFromCollectionWithFilterFunction(uint64_t a1, CMTagCollectionRef tagCollection, uint64_t a3, uint64_t a4)
{
  v5[0] = 0;
  v5[1] = a1;
  v5[2] = a3;
  v5[3] = a4;
  if (a3)
  {
    CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionAddTagsFromCollectionWithFilterFunctionApplier, v5);
    return LODWORD(v5[0]);
  }
  else
  {
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t _CMTagCollectionAddTagsFromCollectionWithFilterFunctionApplier(uint64_t result, CMTagValue a2, uint64_t a3)
{
  if (!*(_DWORD *)a3)
  {
    uint64_t v5 = result;
    OSStatus result = (*(uint64_t (**)(uint64_t, CMTagValue, void))(a3 + 16))(result, a2, *(void *)(a3 + 24));
    if (result)
    {
      *(void *)&v6.category = v5;
      v6.CMTagValue value = a2;
      OSStatus result = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a3 + 8), v6);
      *(_DWORD *)a3 = result;
    }
  }
  return result;
}

OSStatus CMTagCollectionAddTagsFromArray(CMMutableTagCollectionRef tagCollection, CMTag *tags, CMItemCount tagCount)
{
  if (!tagCollection) {
    goto LABEL_13;
  }
  CFTypeID v6 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v6 == sCMTagCollectionID && (*((unsigned char *)tagCollection + 20) & 1) != 0 && tags)
  {
    if (tagCount < 1)
    {
      return 0;
    }
    else
    {
      for (CFIndex i = &tags->value; ; i += 2)
      {
        OSStatus result = CMTagCollectionAddTag(tagCollection, *(CMTag *)(i - 1));
        if (result) {
          break;
        }
        if (!--tagCount) {
          return 0;
        }
      }
    }
  }
  else
  {
LABEL_13:
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

OSStatus CMTagCollectionCopyTagsOfCategories(CFAllocatorRef allocator, CMTagCollectionRef tagCollection, const CMTagCategory *categories, CMItemCount categoriesCount, CMTagCollectionRef *collectionWithTagsOfCategories)
{
  CFTypeRef cf = 0;
  if (!tagCollection) {
    goto LABEL_12;
  }
  CFTypeID v10 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v10 == sCMTagCollectionID && categories && categoriesCount > 0 && collectionWithTagsOfCategories)
  {
    OSStatus Common = _CMTagCollectionCreateCommon(1, (uint64_t)allocator, 0, 0, 0, 0, (uint64_t *)&cf);
    CFTypeRef v12 = cf;
    if (Common
      || (void context[2] = cf,
          uint64_t v15 = 0,
          context[0] = categories,
          context[1] = categoriesCount,
          CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionAddTagsOfCategoriesFromCollectionApplier, context), Common = v15, CFTypeRef v12 = cf, v15))
    {
      if (v12) {
        CFRelease(v12);
      }
    }
    else
    {
      *collectionWithTagsOfCategories = (CMTagCollectionRef)cf;
    }
    return Common;
  }
  else
  {
LABEL_12:
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t _CMTagCollectionAddTagsOfCategoriesFromCollectionApplier(CMTag tagToAdd, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 24))
  {
    uint64_t v3 = *(void *)(a2 + 8);
    if (v3 < 1)
    {
      *(void *)&tagToAdd.category = 0;
LABEL_12:
      *(_DWORD *)(a2 + 24) = tagToAdd.category;
      return *(void *)&tagToAdd.category;
    }
    CMTagValue value = tagToAdd.value;
    uint64_t v5 = *(void *)&tagToAdd.category;
    for (uint64_t i = 0; i < v3; ++i)
    {
      if (*(_DWORD *)(*(void *)a2 + 4 * i) == v5)
      {
        *(void *)&v8.category = v5;
        v8.CMTagValue value = value;
        *(void *)&tagToAdd.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a2 + 16), v8);
        if (tagToAdd.category) {
          goto LABEL_9;
        }
        uint64_t v3 = *(void *)(a2 + 8);
      }
    }
    *(void *)&tagToAdd.category = 0;
LABEL_9:
    if (!*(_DWORD *)(a2 + 24)) {
      goto LABEL_12;
    }
  }
  return *(void *)&tagToAdd.category;
}

CFDictionaryRef CMTagCollectionCopyAsDictionary(CMTagCollectionRef tagCollection, CFAllocatorRef allocator)
{
  if (!tagCollection) {
    goto LABEL_10;
  }
  CFTypeID v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v4 != sCMTagCollectionID)
  {
LABEL_10:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
    return Mutable;
  }
  CFMutableArrayRef v6 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
  if (!v6)
  {
    FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
LABEL_14:
    CFRelease(Mutable);
    return 0;
  }
  CFMutableArrayRef v7 = v6;
  context[1] = allocator;
  uint64_t v10 = 0;
  context[0] = v6;
  CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionCopyAsDictionaryApplier, context);
  if (v10)
  {
    CFRelease(v7);
    goto LABEL_14;
  }
  CFDictionaryAddValue(Mutable, @"tags", v7);
  CFRelease(v7);
  return Mutable;
}

uint64_t _CMTagCollectionCopyAsDictionaryApplier(CMTag a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 16))
  {
    CFDictionaryRef v3 = CMTagCopyAsDictionary(a1, *(CFAllocatorRef *)(a2 + 8));
    if (v3)
    {
      CFDictionaryRef v4 = v3;
      CFArrayAppendValue(*(CFMutableArrayRef *)a2, v3);
      CFRelease(v4);
      *(void *)&a1.category = 0;
    }
    else
    {
      *(void *)&a1.category = FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
    }
    if (!*(_DWORD *)(a2 + 16)) {
      *(_DWORD *)(a2 + 16) = a1.category;
    }
  }
  return *(void *)&a1.category;
}

OSStatus CMTagCollectionCreateFromDictionary(CFDictionaryRef dict, CFAllocatorRef allocator, CMTagCollectionRef *newCollectionOut)
{
  CFTypeRef cf = 0;
  if (dict && (CFTypeID v6 = CFGetTypeID(dict), v6 == CFDictionaryGetTypeID()) && newCollectionOut)
  {
    OSStatus Common = _CMTagCollectionCreateCommon(1, (uint64_t)allocator, 0, 0, 0, 0, (uint64_t *)&cf);
    if (Common) {
      goto LABEL_12;
    }
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(dict, @"tags");
    if (Value)
    {
      CFTypeRef v12 = cf;
      uint64_t v13 = 0;
      FigCFArrayApplyFunction(Value, (void (__cdecl *)(const void *, void *))_CMTagCollectionMakeFromDictionaryApplier, &v12);
      uint64_t v9 = v13;
      if (!v13)
      {
        OSStatus v10 = 0;
        *CMTagCollectionRef newCollectionOut = (CMTagCollectionRef)cf;
        return v10;
      }
    }
    else
    {
      uint64_t v9 = 4294951552;
    }
  }
  else
  {
    uint64_t v9 = 4294951556;
  }
  OSStatus Common = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
LABEL_12:
  OSStatus v10 = Common;
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t _CMTagCollectionMakeFromDictionaryApplier(uint64_t cf, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 8))
  {
    CFDictionaryRef v3 = (const __CFDictionary *)cf;
    if (cf && (CFTypeID v4 = CFGetTypeID((CFTypeRef)cf), v4 == CFDictionaryGetTypeID()))
    {
      CMTag v5 = CMTagMakeFromDictionary(v3);
      if (HIDWORD(*(void *)&v5.category))
      {
        CFTypeRef cf = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)a2, v5);
        goto LABEL_6;
      }
      uint64_t v6 = 4294951553;
    }
    else
    {
      uint64_t v6 = 4294951556;
    }
    CFTypeRef cf = FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
LABEL_6:
    if (!*(_DWORD *)(a2 + 8)) {
      *(_DWORD *)(a2 + 8) = cf;
    }
  }
  return cf;
}

xpc_object_t FigTagCollectionCopyAsXPCDictionary(const void *a1)
{
  if (!a1) {
    goto LABEL_11;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v2 != sCMTagCollectionID)
  {
LABEL_11:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    CMTag v5 = 0;
    uint64_t v6 = 0;
LABEL_15:
    xpc_object_t empty = 0;
    goto LABEL_10;
  }
  xpc_object_t empty = xpc_dictionary_create_empty();
  if (!empty)
  {
    FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
    CMTag v5 = 0;
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_array_create_empty();
  CMTag v5 = v4;
  if (!v4)
  {
    FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  context[1] = 0;
  uint64_t v9 = 0;
  context[0] = v4;
  CMTagCollectionApply((CMTagCollectionRef)a1, (CMTagCollectionApplierFunction)_CMTagCollectionCopyAsXPCDictionaryApplier, context);
  if (v9)
  {
LABEL_14:
    uint64_t v6 = empty;
    goto LABEL_15;
  }
  xpc_dictionary_set_value(empty, (const char *)kCMTagCollection_TagsArrayKey, v5);
LABEL_9:
  uint64_t v6 = 0;
LABEL_10:
  FigXPCRelease(v5);
  FigXPCRelease(v6);
  return empty;
}

unint64_t _CMTagCollectionCopyAsXPCDictionaryApplier(unint64_t result, uint64_t a2, uint64_t a3)
{
  if (!*(_DWORD *)(a3 + 8))
  {
    xpc_object_t v4 = FigTagCopyAsXPCDictionary(result, a2);
    if (v4)
    {
      CMTag v5 = v4;
      xpc_array_append_value(*(xpc_object_t *)a3, v4);
      xpc_release(v5);
      OSStatus result = 0;
    }
    else
    {
      OSStatus result = FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
    }
    if (!*(_DWORD *)(a3 + 8)) {
      *(_DWORD *)(a3 + 8) = result;
    }
  }
  return result;
}

uint64_t FigTagCollectionCreateFromXPCDictionary(void *a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    if (a3)
    {
      uint64_t Common = _CMTagCollectionCreateCommon(1, a2, 0, 0, 0, 0, (uint64_t *)&cf);
      if (Common) {
        goto LABEL_19;
      }
      xpc_object_t value = xpc_dictionary_get_value(a1, (const char *)kCMTagCollection_TagsArrayKey);
      if (value)
      {
        CFMutableArrayRef v7 = value;
        CMTag v8 = (OpaqueCMTagCollection *)cf;
        if (!xpc_array_get_count(value)) {
          goto LABEL_10;
        }
        size_t v9 = 0;
        while (1)
        {
          xpc_object_t v10 = xpc_array_get_value(v7, v9);
          uint64_t v11 = FigTagMakeFromXPCDictionary(v10);
          if (!HIDWORD(v11)) {
            break;
          }
          v18.xpc_object_t value = v12;
          *(void *)&v18.category = v11;
          uint64_t Common = CMTagCollectionAddTag(v8, v18);
          if (Common) {
            goto LABEL_19;
          }
          if (++v9 >= xpc_array_get_count(v7)) {
            goto LABEL_10;
          }
        }
        uint64_t Common = FigSignalErrorAt(4294951554, 0, 0, 0, 0, 0, 0);
        if (!Common)
        {
LABEL_10:
          uint64_t v13 = 0;
          *a3 = cf;
          return v13;
        }
LABEL_19:
        uint64_t v13 = Common;
        if (cf) {
          CFRelease(cf);
        }
        return v13;
      }
      uint64_t v15 = 4294951552;
    }
    else
    {
      uint64_t v15 = 4294951556;
    }
    uint64_t Common = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }

  return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
}

CFDataRef CMTagCollectionCopyAsData(CMTagCollectionRef tagCollection, CFAllocatorRef allocator)
{
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  int v12 = 0;
  if (!tagCollection) {
    goto LABEL_17;
  }
  CFTypeID v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v4 != sCMTagCollectionID)
  {
LABEL_17:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
LABEL_18:
    CFDataRef v5 = 0;
    uint64_t v6 = 0;
    goto LABEL_14;
  }
  if (CMBlockBufferCreateEmpty(allocator, 4u, 0, &blockBufferOut)) {
    goto LABEL_18;
  }
  if (FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)v15)) {
    goto LABEL_18;
  }
  FigAtomWriterBeginAtom((uint64_t)v15, 0x7467636Fu, 0);
  if (FigAtomWriterInitWithParent((uint64_t)v15, (uint64_t)v13)) {
    goto LABEL_18;
  }
  FigAtomWriterBeginAtom((uint64_t)v13, 0x7467696Eu, 0);
  FigAtomWriterAppendVersionAndFlags((uint64_t)v13, 0, 0);
  int v12 = 543646068;
  FigAtomWriterAppendData((uint64_t)v13, (uint64_t)&v12, 4);
  int v12 = 1819045731;
  FigAtomWriterAppendData((uint64_t)v13, (uint64_t)&v12, 4);
  FigAtomWriterEndAtom((uint64_t)v13);
  FigAtomWriterBeginAtom((uint64_t)v13, 0x74676C69u, 0);
  FigAtomWriterAppendVersionAndFlags((uint64_t)v13, 0, 0);
  unsigned int v11 = bswap32(*((_DWORD *)tagCollection + 8));
  FigAtomWriterAppendData((uint64_t)v13, (uint64_t)&v11, 4);
  if (*((uint64_t *)tagCollection + 4) >= 1)
  {
    CMTagCollectionRef context = v13;
    uint64_t v10 = 0;
    CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionCopyAsDataApplier, &context);
    CFDataRef v5 = 0;
    uint64_t v6 = 0;
    if (v10) {
      goto LABEL_14;
    }
  }
  FigAtomWriterEndAtom((uint64_t)v13);
  FigAtomWriterEndAtom((uint64_t)v15);
  DataCFIndex Length = CMBlockBufferGetDataLength(blockBufferOut);
  uint64_t v6 = malloc_type_malloc(DataLength, 0xF217AC60uLL);
  if (!v6)
  {
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
  if (CMBlockBufferCopyDataBytes(blockBufferOut, 0, DataLength, v6))
  {
LABEL_20:
    CFDataRef v5 = 0;
    goto LABEL_14;
  }
  CFDataRef v5 = CFDataCreate(allocator, (const UInt8 *)v6, DataLength);
  if (!v5) {
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
LABEL_14:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  free(v6);
  return v5;
}

uint64_t _CMTagCollectionCopyAsDataApplier(uint64_t result, unint64_t a2, uint64_t a3)
{
  if (!*(_DWORD *)(a3 + 8))
  {
    unsigned int v4 = bswap32(result);
    unsigned int v5 = bswap32(HIDWORD(result));
    unint64_t v6 = bswap64(a2);
    OSStatus result = FigAtomWriterAppendData(*(void *)a3, (uint64_t)&v4, 4);
    if (!result)
    {
      OSStatus result = FigAtomWriterAppendData(*(void *)a3, (uint64_t)&v5, 4);
      if (!result) {
        OSStatus result = FigAtomWriterAppendData(*(void *)a3, (uint64_t)&v6, 8);
      }
    }
    if (!*(_DWORD *)(a3 + 8)) {
      *(_DWORD *)(a3 + 8) = result;
    }
  }
  return result;
}

OSStatus CMTagCollectionCreateFromData(CFDataRef data, CFAllocatorRef allocator, CMTagCollectionRef *newCollectionOut)
{
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  CFTypeRef cf = 0;
  if (!data) {
    goto LABEL_15;
  }
  CFTypeID v6 = CFGetTypeID(data);
  if (v6 != CFDataGetTypeID() || !newCollectionOut) {
    goto LABEL_15;
  }
  OSStatus Common = _CMTagCollectionCreateCommon(1, (uint64_t)allocator, 0, 0, 0, 0, (uint64_t *)&v13);
  if (Common)
  {
LABEL_16:
    OSStatus v9 = Common;
    goto LABEL_10;
  }
  size_t Length = CFDataGetLength(data);
  if (Length <= 7)
  {
LABEL_15:
    OSStatus Common = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  OSStatus Common = FigCreateBlockBufferWithCFDataNoCopy(allocator, data, 0, Length, (CMBlockBufferRef *)&cf);
  if (Common) {
    goto LABEL_16;
  }
  OSStatus Common = FigAtomStreamInitWithBBuf((OpaqueCMBlockBuffer *)cf, 0, 0, (uint64_t)v12);
  if (Common) {
    goto LABEL_16;
  }
  OSStatus v9 = ParseTagCollectionDataChildAtoms(v12, (uint64_t)CMTagCollectionCreateFromData_atomDispatch, 1, (uint64_t)v13);
  if (!v9)
  {
    *CMTagCollectionRef newCollectionOut = v13;
    uint64_t v13 = 0;
  }
LABEL_10:
  if (cf) {
    CFRelease(cf);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v9;
}

uint64_t ProcessTagCollectionContainerAtom(uint64_t a1, uint64_t a2)
{
  int v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v6, 0);
  if (!result)
  {
    uint64_t result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!result) {
      return ParseTagCollectionDataChildAtoms(v5, (uint64_t)ProcessTagCollectionContainerAtom_atomDispatch, 2, a2);
    }
  }
  return result;
}

uint64_t ParseTagCollectionDataChildAtoms(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v12 = 0;
  CFMutableArrayRef v7 = (_DWORD *)(a2 + 8);
  while (1)
  {
    uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)a1, &v12, 0);
    if (result) {
      return result;
    }
    if (a3 >= 1)
    {
      OSStatus v9 = v7;
      uint64_t v10 = v7;
      uint64_t v11 = a3;
      while (v12 != *(v9 - 2))
      {
        v10 += 4;
        v9 += 4;
        if (!--v11) {
          goto LABEL_9;
        }
      }
      uint64_t result = (*(uint64_t (**)(void *, uint64_t))v9)(a1, a4);
      if (result) {
        return result;
      }
    }
LABEL_9:
    LODWORD(result) = FigAtomStreamAdvanceToNextAtom(a1);
    if (result)
    {
      if (result == -12890) {
        return 0;
      }
      else {
        return result;
      }
    }
  }
}

double CMTagCollectionInit(_OWORD *a1)
{
  double result = 0.0;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void CMTagCollectionFinalize(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 20) & 2) == 0) {
    free(*(void **)(a1 + 56));
  }
}

BOOL CMTagCollectionEqual(const void **cf, const void **a2)
{
  if (cf == a2) {
    return 1;
  }
  BOOL result = 0;
  if (cf && a2)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (sRegisterCMTagCollectionTypeOnce != -1) {
      dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
    }
    if (v5 != sCMTagCollectionID) {
      goto LABEL_13;
    }
    CFTypeID v6 = CFGetTypeID(a2);
    if (sRegisterCMTagCollectionTypeOnce != -1) {
      dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
    }
    if (v6 == sCMTagCollectionID)
    {
      CFMutableArrayRef v7 = cf[4];
      if (v7 == a2[4]) {
        return memcmp(cf[7], a2[7], 16 * (void)v7) == 0;
      }
    }
    else
    {
LABEL_13:
      FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  return result;
}

unint64_t CMTagCollectionHash(void *a1)
{
  if (!a1) {
    goto LABEL_9;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (sRegisterCMTagCollectionTypeOnce != -1) {
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  }
  if (v2 == sCMTagCollectionID)
  {
    unint64_t v3 = _CMTagCFHashBytes((uint64_t)(a1 + 2), 4);
    unint64_t v4 = (_CMTagCFHashBytes((uint64_t)a1 + 20, 4) + (v3 << 6) + (v3 >> 2) + 2654435769u) ^ v3;
    unint64_t v5 = (_CMTagCFHashBytes((uint64_t)(a1 + 3), 8) + (v4 << 6) + (v4 >> 2) + 2654435769u) ^ v4;
    if ((uint64_t)a1[4] >= 1)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      do
      {
        v5 ^= (v5 << 6) + 2654435769u + (v5 >> 2) + CMTagHash(*(CMTag *)(a1[7] + v6));
        ++v7;
        v6 += 16;
      }
      while (v7 < a1[4]);
    }
  }
  else
  {
LABEL_9:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v5;
}

CFStringRef CMTagCollectionCopyFormattingDesc(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);

  return CMTagCollectionCopyDescription(v2, (CMTagCollectionRef)a1);
}

CFStringRef CMTagCollectionCopyDebugDesc(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);

  return CMTagCollectionCopyDescription(v2, (CMTagCollectionRef)a1);
}

uint64_t _CMTagCollectionFindTag(uint64_t a1, CMTag tag1, uint64_t *a3, char *a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6 < 1)
  {
    uint64_t result = 0;
    char v13 = 1;
  }
  else
  {
    CMTagValue value = tag1.value;
    uint64_t v8 = *(void *)&tag1.category;
    uint64_t v10 = 0;
    uint64_t v6 = 0;
    while (1)
    {
      *(void *)&v14.category = v8;
      v14.CMTagValue value = value;
      CFComparisonResult v11 = CMTagCompare(v14, *(CMTag *)(*(void *)(a1 + 56) + v10));
      if (v11 == kCFCompareLessThan)
      {
        uint64_t result = 0;
        char v13 = 0;
        goto LABEL_10;
      }
      if (v11 == kCFCompareEqualTo) {
        break;
      }
      ++v6;
      v10 += 16;
      if (v6 >= *(void *)(a1 + 32))
      {
        uint64_t result = 0;
        char v13 = 1;
        uint64_t v6 = *(void *)(a1 + 32);
        goto LABEL_10;
      }
    }
    char v13 = 0;
    uint64_t result = 1;
  }
LABEL_10:
  *a3 = v6;
  *a4 = v13;
  return result;
}

uint64_t ProcessTagCollectionInfoAtom(uint64_t a1)
{
  int v8 = 0;
  unint64_t v7 = 0;
  char v6 = 0;
  unsigned int v5 = 0;
  LODWORD(v4[1]) = 0;
  v4[0] = 0;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v8, &v7);
  if (!result)
  {
    uint64_t result = FigAtomStreamGetCurrentAtomVersionAndFlags(a1, &v6, &v5);
    if (!result)
    {
      if (v6)
      {
        uint64_t v3 = 4294951549;
      }
      else if (v7 < 0xC)
      {
        uint64_t v3 = 4294951551;
      }
      else
      {
        uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 12, (uint64_t)v4);
        if (result) {
          return result;
        }
        uint64_t v3 = 4294951551;
        if (*(void *)((char *)v4 + 4) == 0x6C6C6F6320676174) {
          return 0;
        }
      }
      return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t ProcessTagCollectionListAtom(uint64_t a1, OpaqueCMTagCollection *a2)
{
  int v13 = 0;
  unint64_t v12 = 0;
  char v11 = 0;
  memset(v10, 0, sizeof(v10));
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v13, &v12);
  if (result) {
    return result;
  }
  uint64_t result = FigAtomStreamGetCurrentAtomVersionAndFlags(a1, &v11, 0);
  if (result) {
    return result;
  }
  if (v11)
  {
    uint64_t v7 = 4294951549;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if (v12 <= 7) {
    goto LABEL_14;
  }
  uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)v10);
  if (result) {
    return result;
  }
  uint64_t v5 = bswap32(HIDWORD(v10[0]));
  if (v12 != ((16 * v5) | 8))
  {
LABEL_14:
    uint64_t v7 = 4294951551;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if (!HIDWORD(v10[0])) {
    return 0;
  }
  for (unsigned int i = 8; ; i += 16)
  {
    int8x8_t v8 = 0;
    CMTagValue value = 0;
    uint64_t result = FigAtomStreamReadCurrentAtomData(a1, i, 16, (uint64_t)&v8);
    if (result) {
      break;
    }
    int8x8_t v8 = vrev32_s8(v8);
    *(int8x8_t *)&v14.category = v8;
    v14.CMTagValue value = bswap64(value);
    CMTagValue value = v14.value;
    uint64_t result = CMTagCollectionAddTag(a2, v14);
    if (result) {
      break;
    }
    if (!--v5) {
      return 0;
    }
  }
  return result;
}

uint64_t FigApplicationStateMonitorGetClassID()
{
  if (sRegisterFigApplicationStateMonitorClassIDOnce != -1) {
    dispatch_once_f(&sRegisterFigApplicationStateMonitorClassIDOnce, 0, (dispatch_function_t)RegisterFigApplicationStateMonitorType);
  }
  return sFigApplicationStateMonitorClassID;
}

uint64_t RegisterFigApplicationStateMonitorType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigApplicationStateMonitorClassDesc, ClassID, 1, &sFigApplicationStateMonitorClassID);
}

uint64_t FigApplicationStateMonitorGetTypeID()
{
  if (sRegisterFigApplicationStateMonitorClassIDOnce != -1) {
    dispatch_once_f(&sRegisterFigApplicationStateMonitorClassIDOnce, 0, (dispatch_function_t)RegisterFigApplicationStateMonitorType);
  }
  uint64_t v0 = (void *)sFigApplicationStateMonitorClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigApplicationStateMonitorCopyProcessNameIfAvailable(uint64_t a1, CFStringRef *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1) {
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_36);
  }
  uint64_t result = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (!fasm_ensureInternalState_sFigApplicationStateMonitorInitResult)
  {
    if ((int)a1 > 0 && a2)
    {
      uint64_t v5 = objc_msgSend(MEMORY[0x1E4F963F0], "handleForIdentifier:error:", objc_msgSend(NSNumber, "numberWithInt:", a1), 0);
      if (v5)
      {
        char v6 = v5;
        uint64_t result = [v5 name];
        if (!result) {
          return result;
        }
        CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        CFStringRef Copy = CFStringCreateCopy(AllocatorForMedia, (CFStringRef)[v6 name]);
        if (Copy)
        {
          CFStringRef v9 = Copy;
          if (dword_1E9272F38 >= 2)
          {
            v17[0] = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, v17, &type);
            int v11 = v17[0];
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
              unsigned int v13 = v11;
            }
            else {
              unsigned int v13 = v11 & 0xFFFFFFFE;
            }
            if (v13)
            {
              v17[1] = 136315650;
              CMTag v18 = "FigApplicationStateMonitorCopyProcessNameIfAvailable";
              __int16 v19 = 1024;
              int v20 = a1;
              __int16 v21 = 2112;
              CFStringRef v22 = v9;
              CMTag v14 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(v11) = v17[0];
            }
            else
            {
              CMTag v14 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F30, 1u, 1, v14, v14 != &v23, v11, 0, v12);
          }
          uint64_t result = 0;
          *a2 = v9;
          return result;
        }
      }
      uint64_t v15 = 4294947865;
    }
    else
    {
      uint64_t v15 = 4294947866;
    }
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigApplicationStateMonitorGetHostPIDIfAvailable(uint64_t a1, int *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1) {
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_36);
  }
  uint64_t v4 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInitResult) {
    return v4;
  }
  if ((int)a1 > 0 && a2)
  {
    FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
    uint64_t v4 = fasm_ensureApplicationStateMonitor(a1, (void **)&v15);
    uint64_t v5 = (const void *)v15;
    if (v4 || !v15)
    {
      if (!v15) {
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v4 = 0;
      int v6 = *(_DWORD *)(CMBaseObjectGetDerivedStorage(v15) + 24);
      *a2 = v6;
      if (v6 != a1 && v6 >= 1 && dword_1E9272F38)
      {
        int v14 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, &v14, &type);
        int v8 = v14;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v10 = v8;
        }
        else {
          unsigned int v10 = v8 & 0xFFFFFFFE;
        }
        if (v10)
        {
          int v16 = 136315650;
          long long v17 = "FigApplicationStateMonitorGetHostPIDIfAvailable";
          __int16 v18 = 1024;
          int v19 = a1;
          __int16 v20 = 1024;
          int v21 = v6;
          int v11 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v8) = v14;
        }
        else
        {
          int v11 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F30, 1u, 1, v11, v11 != &v22, v8, 0, v9);
        uint64_t v4 = 0;
      }
    }
    CFRelease(v5);
LABEL_21:
    FigSimpleMutexUnlock((pthread_mutex_t *)gApplicationMonitorsMutex);
    return v4;
  }

  return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
}

uint64_t fasm_ensureApplicationStateMonitor(uint64_t a1, void **a2)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  CFArrayCallBacks callBacks = *(CFArrayCallBacks *)byte_1EDF703C0;
  unsigned int v4 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigApplicationStateMonitorTrace[1], @"figapplicationstatemonitor_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v4, 0, gFigApplicationStateMonitorTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1E9272F38, @"figapplicationstatemonitor_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1E9272F30);
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFNumberRef UInt32 = FigCFNumberCreateUInt32(AllocatorForMedia, a1);
  if (UInt32)
  {
    CFNumberRef v7 = UInt32;
    int v8 = CFDictionaryGetValue((CFDictionaryRef)gApplicationMonitors, UInt32);
    if (v8)
    {
      uint64_t v9 = (void *)CFRetain(v8);
      CMTagValue value = v9;
      if (v9)
      {
        if (dword_1E9272F38)
        {
          unsigned int v10 = v9;
          int v43 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, &v43, &type);
          int v12 = v43;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v14 = v12;
          }
          else {
            unsigned int v14 = v12 & 0xFFFFFFFE;
          }
          if (v14)
          {
            int v47 = 136315394;
            CMTimeScale v48 = "fasm_ensureApplicationStateMonitor";
            __int16 v49 = 2112;
            uint64_t v50 = v10;
LABEL_18:
            long long v17 = (unsigned char *)_os_log_send_and_compose_impl();
            LOBYTE(v12) = v43;
LABEL_26:
            uint64_t v24 = (uint64_t *)qword_1E9272F30;
            BOOL v25 = v17 != v51;
            char v26 = v12;
LABEL_39:
            fig_log_call_emit_and_clean_up_after_send_and_compose(v24, 1u, 1, v17, v25, v26, 0, v13);
            goto LABEL_40;
          }
          goto LABEL_25;
        }
        goto LABEL_40;
      }
    }
    else
    {
      CMTagValue value = 0;
    }
    if (CFSetContainsValue((CFSetRef)gExcludedPIDs, v7))
    {
      if (dword_1E9272F38)
      {
        int v43 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        uint64_t v15 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, &v43, &type);
        int v12 = v43;
        if (os_log_type_enabled(v15, type)) {
          unsigned int v16 = v12;
        }
        else {
          unsigned int v16 = v12 & 0xFFFFFFFE;
        }
        if (v16)
        {
          int v47 = 136315394;
          CMTimeScale v48 = "fasm_ensureApplicationStateMonitor";
          __int16 v49 = 1024;
          LODWORD(v50) = a1;
          goto LABEL_18;
        }
LABEL_25:
        long long v17 = 0;
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v18 = FigGetAllocatorForMedia();
      if (sRegisterFigApplicationStateMonitorClassIDOnce != -1) {
        dispatch_once_f(&sRegisterFigApplicationStateMonitorClassIDOnce, 0, (dispatch_function_t)RegisterFigApplicationStateMonitorType);
      }
      uint64_t v19 = CMDerivedObjectCreate(v18, (uint64_t)&kFigApplicationStateMonitor_VTable, (void *)sFigApplicationStateMonitorClassID, &value);
      if (v19)
      {
        uint64_t v35 = v19;
        goto LABEL_41;
      }
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)value);
      *(_DWORD *)uint64_t DerivedStorage = a1;
      *(void *)(DerivedStorage + 16) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callBacks);
      int v21 = objc_msgSend(MEMORY[0x1E4F963F0], "handleForIdentifier:error:", objc_msgSend(NSNumber, "numberWithInt:", a1), 0);
      if (!v21) {
        goto LABEL_47;
      }
      char v22 = (void *)[v21 hostProcess];
      int v23 = v22 ? [v22 pid] : 0;
      uint64_t v27 = objc_msgSend(MEMORY[0x1E4F96428], "predicateMatchingIdentifier:", objc_msgSend(NSNumber, "numberWithInt:", a1));
      if (!v27) {
        goto LABEL_47;
      }
      uint64_t v28 = v27;
      long long v29 = (void *)[MEMORY[0x1E4F96450] descriptor];
      if (!v29) {
        goto LABEL_47;
      }
      long long v30 = v29;
      [v29 setEndowmentNamespaces:&unk_1EDF88D98];
      v44[0] = MEMORY[0x1E4F143A8];
      v44[1] = 3221225472;
      v44[2] = __fasm_ensureApplicationStateMonitor_block_invoke;
      v44[3] = &unk_1E567A808;
      void v44[4] = v30;
      v44[5] = v28;
      long long v31 = (void *)[MEMORY[0x1E4F96420] monitorWithConfiguration:v44];
      if (!v31)
      {
LABEL_47:
        uint64_t v35 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
        CFSetAddValue((CFMutableSetRef)gExcludedPIDs, v7);
        if (dword_1E9272F38 >= 2)
        {
          int v43 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          CMTime v37 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, &v43, &type);
          int v38 = v43;
          if (os_log_type_enabled(v37, type)) {
            unsigned int v40 = v38;
          }
          else {
            unsigned int v40 = v38 & 0xFFFFFFFE;
          }
          if (v40)
          {
            int v47 = 136315394;
            CMTimeScale v48 = "fasm_ensureApplicationStateMonitor";
            __int16 v49 = 1024;
            LODWORD(v50) = a1;
            xpc_object_t v41 = (unsigned char *)_os_log_send_and_compose_impl();
            LOBYTE(v38) = v43;
          }
          else
          {
            xpc_object_t v41 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F30, 1u, 1, v41, v41 != v51, v38, 0, v39);
        }
        goto LABEL_41;
      }
      *(void *)(DerivedStorage + 8) = v31;
      *(_DWORD *)(DerivedStorage + 24) = v23;
      CFDictionarySetValue((CFMutableDictionaryRef)gApplicationMonitors, v7, value);
      if (dword_1E9272F38)
      {
        int v43 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        long long v32 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, &v43, &type);
        int v33 = v43;
        if (os_log_type_enabled(v32, type)) {
          unsigned int v34 = v33;
        }
        else {
          unsigned int v34 = v33 & 0xFFFFFFFE;
        }
        if (v34)
        {
          int v47 = 136315394;
          CMTimeScale v48 = "fasm_ensureApplicationStateMonitor";
          __int16 v49 = 2112;
          uint64_t v50 = value;
          long long v17 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v33) = v43;
        }
        else
        {
          long long v17 = 0;
        }
        uint64_t v24 = (uint64_t *)qword_1E9272F30;
        BOOL v25 = v17 != v51;
        char v26 = v33;
        goto LABEL_39;
      }
    }
LABEL_40:
    uint64_t v35 = 0;
    *a2 = value;
    CMTagValue value = 0;
LABEL_41:
    CFRelease(v7);
    if (value) {
      CFRelease(value);
    }
    return v35;
  }

  return FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
}

uint64_t FigApplicationStateMonitorAddPIDToIgnore(signed int a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1) {
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_36);
  }
  uint64_t v2 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInitResult) {
    goto LABEL_19;
  }
  if (a1 <= 0)
  {
    uint64_t v2 = FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
LABEL_19:
    CFNumberRef UInt32 = 0;
    goto LABEL_7;
  }
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFNumberRef UInt32 = FigCFNumberCreateUInt32(AllocatorForMedia, a1);
  if (UInt32)
  {
    FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
    CFSetAddValue((CFMutableSetRef)gExcludedPIDs, UInt32);
    FigSimpleMutexUnlock((pthread_mutex_t *)gApplicationMonitorsMutex);
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v2 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
  }
LABEL_7:
  if (dword_1E9272F38 >= 2)
  {
    v12[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, v12, &type);
    int v6 = v12[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v8 = v6;
    }
    else {
      unsigned int v8 = v6 & 0xFFFFFFFE;
    }
    if (v8)
    {
      v12[1] = 136315394;
      uint64_t v13 = "FigApplicationStateMonitorAddPIDToIgnore";
      __int16 v14 = 1024;
      signed int v15 = a1;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v6) = v12[0];
    }
    else
    {
      uint64_t v9 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F30, 1u, 1, v9, v9 != &v16, v6, 0, v7);
  }
  if (UInt32) {
    CFRelease(UInt32);
  }
  return v2;
}

uint64_t FigApplicationStateMonitorRemovePIDToIgnore(signed int a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1) {
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_36);
  }
  uint64_t v2 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInitResult) {
    goto LABEL_19;
  }
  if (a1 <= 0)
  {
    uint64_t v2 = FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
LABEL_19:
    CFNumberRef UInt32 = 0;
    goto LABEL_7;
  }
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFNumberRef UInt32 = FigCFNumberCreateUInt32(AllocatorForMedia, a1);
  if (UInt32)
  {
    FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
    CFSetRemoveValue((CFMutableSetRef)gExcludedPIDs, UInt32);
    FigSimpleMutexUnlock((pthread_mutex_t *)gApplicationMonitorsMutex);
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v2 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
  }
LABEL_7:
  if (dword_1E9272F38 >= 2)
  {
    v12[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, v12, &type);
    int v6 = v12[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v8 = v6;
    }
    else {
      unsigned int v8 = v6 & 0xFFFFFFFE;
    }
    if (v8)
    {
      v12[1] = 136315394;
      uint64_t v13 = "FigApplicationStateMonitorRemovePIDToIgnore";
      __int16 v14 = 1024;
      signed int v15 = a1;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v6) = v12[0];
    }
    else
    {
      uint64_t v9 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F30, 1u, 1, v9, v9 != &v16, v6, 0, v7);
  }
  if (UInt32) {
    CFRelease(UInt32);
  }
  return v2;
}

uint64_t FigApplicationStateMonitorAddCallbackClient(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = 0;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1) {
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_36);
  }
  uint64_t v6 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInitResult) {
    return v6;
  }
  if ((int)a1 > 0 && a2 && a3)
  {
    FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
    uint64_t v7 = fasm_ensureApplicationStateMonitor(a1, (void **)&v22);
    unsigned int v8 = (const void *)v22;
    if (v7)
    {
      uint64_t v6 = v7;
      if (!v22) {
        goto LABEL_21;
      }
    }
    else
    {
      if (!v22)
      {
        uint64_t v6 = FigSignalErrorAt(4294947857, 0, 0, 0, 0, 0, 0);
        goto LABEL_21;
      }
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(v22);
      CFTypeRef v10 = FigCFWeakReferenceHolderCreateWithReferencedObject(a2);
      if (v10 && (CFTypeRef v11 = v10, (v12 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL)) != 0))
      {
        uint64_t v13 = v12;
        *int v12 = v11;
        v12[1] = a3;
        CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 16), v12);
        if (dword_1E9272F38)
        {
          int v21 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, &v21, &type);
          int v15 = v21;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v17 = v15;
          }
          else {
            unsigned int v17 = v15 & 0xFFFFFFFE;
          }
          if (v17)
          {
            int v23 = 136315906;
            uint64_t v24 = "FigApplicationStateMonitorAddCallbackClient";
            __int16 v25 = 2048;
            char v26 = v13;
            __int16 v27 = 2112;
            uint64_t v28 = a2;
            __int16 v29 = 1024;
            int v30 = a1;
            uint64_t v18 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v15) = v21;
          }
          else
          {
            uint64_t v18 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F30, 1u, 1, v18, v18 != &v31, v15, 0, v16);
        }
        uint64_t v6 = 0;
      }
      else
      {
        uint64_t v6 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
      }
    }
    CFRelease(v8);
LABEL_21:
    FigSimpleMutexUnlock((pthread_mutex_t *)gApplicationMonitorsMutex);
    return v6;
  }

  return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
}

uint64_t FigApplicationStateMonitorRemoveCallbackClient(uint64_t a1, const void *a2)
{
  uint64_t v14 = 0;
  FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1) {
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_36);
  }
  uint64_t v4 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInitResult) {
    return v4;
  }
  if ((int)a1 > 0 && a2)
  {
    uint64_t v5 = fasm_ensureApplicationStateMonitor(a1, (void **)&v14);
    uint64_t v6 = (const void *)v14;
    if (v5)
    {
      uint64_t v4 = v5;
      if (!v14) {
        return v4;
      }
      goto LABEL_18;
    }
    if (v14)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(v14);
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 16));
      if (Count < 1)
      {
        uint64_t v4 = 0;
      }
      else
      {
        unint64_t v9 = Count + 1;
        do
        {
          CFStringRef ValueAtIndex = (id **)FigCFArrayGetValueAtIndex(*(const __CFArray **)(DerivedStorage + 16), v9 - 2);
          CFTypeRef v11 = FigCFWeakReferenceHolderCopyReferencedObject(*ValueAtIndex);
          if (FigCFEqual(v11, a2)) {
            fasm_callbackClientFreeAndClearContext((const void **)ValueAtIndex);
          }
          if (v11) {
            CFRelease(v11);
          }
          --v9;
        }
        while (v9 > 1);
        uint64_t v4 = 0;
        if (!v6) {
          return v4;
        }
      }
LABEL_18:
      CFRelease(v6);
      return v4;
    }
    uint64_t v13 = 4294947857;
  }
  else
  {
    uint64_t v13 = 4294947866;
  }

  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

void fasm_callbackClientFreeAndClearContext(const void **a1)
{
  a1[1] = 0;
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }

  free(a1);
}

CFStringRef FigApplicationStateMonitorCopyFormattingDesc(uint64_t a1)
{
  uint64_t DerivedStorage = (unsigned int *)CMBaseObjectGetDerivedStorage(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigApplicationStateMonitor %p pid %d]", a1, *DerivedStorage);
}

void __fasm_ensureInternalState_block_invoke()
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  gApplicationMonitors = (uint64_t)CFDictionaryCreateMutable(AllocatorForPermanentAllocations, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!gApplicationMonitors
    || (gApplicationMonitorsMutex = (uint64_t)FigSimpleMutexCreate()) == 0
    || (CFAllocatorRef v1 = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations(),
        (gExcludedPIDs = (uint64_t)CFSetCreateMutable(v1, 0, MEMORY[0x1E4F1D548])) == 0))
  {
    fasm_ensureInternalState_sFigApplicationStateMonitorInitResult = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
  }
  if (dword_1E9272F38)
  {
    v8[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, v8, &type);
    int v3 = v8[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v5 = v3;
    }
    else {
      unsigned int v5 = v3 & 0xFFFFFFFE;
    }
    if (v5)
    {
      v8[1] = 136315394;
      unint64_t v9 = "fasm_ensureInternalState_block_invoke";
      __int16 v10 = 1024;
      int v11 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v8[0];
    }
    else
    {
      uint64_t v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F30, 1u, 1, v6, v6 != &v12, v3, 0, v4);
  }
}

void fasm_callbackClientContextCFArrayReleaseCallback(int a1, const void **a2)
{
}

uint64_t __fasm_ensureApplicationStateMonitor_block_invoke(uint64_t a1, void *a2)
{
  v5[1] = *MEMORY[0x1E4F143B8];
  [a2 setStateDescriptor:*(void *)(a1 + 32)];
  v5[0] = *(void *)(a1 + 40);
  objc_msgSend(a2, "setPredicates:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v5, 1));
  return [a2 setUpdateHandler:&__block_literal_global_36];
}

void __fasm_ensureApplicationStateMonitor_block_invoke_2(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  int v6 = [a3 isDaemon];
  int v7 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a4, "state"), "endowmentNamespaces"), "containsObject:", @"com.apple.frontboard.visibility");
  unsigned int v8 = [a3 pid];
  int v9 = objc_msgSend((id)objc_msgSend(a4, "previousState"), "taskState");
  if (((v9 - 1) & 0xFC) != 0) {
    unsigned int v10 = 0;
  }
  else {
    unsigned int v10 = (v9 - 1) + 1;
  }
  switch(objc_msgSend((id)objc_msgSend(a4, "state"), "taskState"))
  {
    case 1u:
      int v11 = 1;
      unsigned int v12 = 1;
      break;
    case 2u:
      int v11 = 0;
      unsigned int v12 = 2;
      break;
    case 3u:
      int v11 = 0;
      unsigned int v12 = 3;
      break;
    case 4u:
      int v11 = 0;
      unsigned int v12 = 4;
      break;
    default:
      int v11 = 0;
      unsigned int v12 = 0;
      break;
  }
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFMutableDictionaryRef v15 = Mutable;
    FigCFDictionarySetUInt32(Mutable, @"FigApplicationStateMonitorCallbackDictionary_pid", v8);
    FigCFDictionarySetUInt32(v15, @"FigApplicationStateMonitorCallbackDictionary_currentSchedulerStatus", v12);
    FigCFDictionarySetUInt32(v15, @"FigApplicationStateMonitorCallbackDictionary_previousSchedulerStatus", v10);
    FigCFDictionarySetBoolean(v15, @"FigApplicationStateMonitorCallbackDictionary_isDaemon", v6);
    FigCFDictionarySetBoolean(v15, @"FigApplicationStateMonitorCallbackDictionary_isVisible", v7);
    CFAllocatorRef v16 = (const __CFAllocator *)FigGetAllocatorForMedia();
    CFNumberRef UInt32 = FigCFNumberCreateUInt32(v16, v8);
    if (UInt32)
    {
      CFNumberRef v18 = UInt32;
      unsigned int v45 = v12;
      FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
      CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)gApplicationMonitors, v18);
      if (Value)
      {
        __int16 v20 = Value;
        unsigned int v44 = v10;
        uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)Value);
        if (CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 16)) < 1)
        {
          int v22 = 0;
        }
        else
        {
          int v22 = 0;
          CFIndex v23 = 0;
          do
          {
            CFStringRef ValueAtIndex = (id **)FigCFArrayGetValueAtIndex(*(const __CFArray **)(DerivedStorage + 16), v23);
            __int16 v25 = FigCFWeakReferenceHolderCopyReferencedObject(*ValueAtIndex);
            if (v25) {
              BOOL v26 = 0;
            }
            else {
              BOOL v26 = v22 == 0;
            }
            if (v26)
            {
              int v22 = 1;
            }
            else
            {
              __int16 v27 = v25;
              ((void (*)(void))ValueAtIndex[1])();
              if (v27) {
                CFRelease(v27);
              }
            }
            ++v23;
          }
          while (v23 < CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 16)));
        }
        if (dword_1E9272F38)
        {
          v47[0] = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F30, 1, v47, &type);
          int v29 = v47[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v31 = v29;
          }
          else {
            unsigned int v31 = v29 & 0xFFFFFFFE;
          }
          if (v31)
          {
            v47[1] = 136315906;
            CMTimeScale v48 = "fasm_updateHandler";
            __int16 v49 = 2112;
            uint64_t v50 = v20;
            __int16 v51 = 1024;
            unsigned int v52 = v45;
            __int16 v53 = 1024;
            unsigned int v54 = v44;
            uint64_t v32 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v29) = v47[0];
          }
          else
          {
            uint64_t v32 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F30, 1u, 1, v32, v32 != &v55, v29, 0, v30);
        }
        if (v11) {
          CFDictionaryRemoveValue((CFMutableDictionaryRef)gApplicationMonitors, v18);
        }
        if (v22)
        {
          CFArrayRef v33 = FigCFDictionaryCopyArrayOfKeys((const __CFDictionary *)gApplicationMonitors);
          if (v33)
          {
            CFArrayRef v34 = v33;
            if (CFArrayGetCount(v33) >= 1)
            {
              CFIndex v35 = 0;
              do
              {
                CFTypeRef v36 = CFArrayGetValueAtIndex(v34, v35);
                CMTime v37 = CFDictionaryGetValue((CFDictionaryRef)gApplicationMonitors, v36);
                uint64_t v38 = CMBaseObjectGetDerivedStorage((uint64_t)v37);
                CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v38 + 16));
                if (Count >= 1)
                {
                  unint64_t v40 = Count + 1;
                  do
                  {
                    xpc_object_t v41 = (id **)CFArrayGetValueAtIndex(*(CFArrayRef *)(v38 + 16), v40 - 2);
                    xpc_object_t v42 = FigCFWeakReferenceHolderCopyReferencedObject(*v41);
                    if (v42)
                    {
                      CFRelease(v42);
                    }
                    else
                    {
                      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v38 + 16), v40 - 2);
                      fasm_callbackClientFreeAndClearContext((const void **)v41);
                    }
                    --v40;
                  }
                  while (v40 > 1);
                }
                ++v35;
              }
              while (v35 < CFArrayGetCount(v34));
            }
            CFRelease(v34);
          }
          else
          {
            FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
          }
        }
        int v43 = (pthread_mutex_t *)gApplicationMonitorsMutex;
      }
      else
      {
        FigSignalErrorAt(4294947858, 0, 0, 0, 0, 0, 0);
        int v43 = (pthread_mutex_t *)gApplicationMonitorsMutex;
      }
      FigSimpleMutexUnlock(v43);
      CFRelease(v18);
    }
    else
    {
      FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v15);
  }
  else
  {
    FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
  }
}

void fasm_finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  *(_DWORD *)uint64_t DerivedStorage = 0;
  [*(id *)(DerivedStorage + 8) invalidate];

  uint64_t v2 = *(const void **)(DerivedStorage + 16);
  if (v2)
  {
    CFRelease(v2);
  }
}

CFStringRef fasm_copyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = (unsigned int *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v3 = DerivedStorage[6];
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v5 = *DerivedStorage;
  if ((int)v3 < 1) {
    return CFStringCreateWithFormat(v4, 0, @"[FigApplicationStateMonitor %p pid %d]", a1, v5);
  }
  else {
    return CFStringCreateWithFormat(v4, 0, @"[FigApplicationStateMonitor %p pid %d hostPID %d]", a1, v5, v3);
  }
}

uint64_t FigScheduledIOFRSCreateForByteStream(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  CFTypeRef v13 = 0;
  unint64_t v11 = 0;
  if (!a2 || !a3)
  {
    uint64_t SchedulerCopyForByteStream = FigSignalErrorAt(4294948015, 0, 0, 0, 0, 0, 0);
LABEL_13:
    uint64_t v8 = SchedulerCopyForByteStream;
    goto LABEL_7;
  }
  uint64_t SchedulerCopyForByteStream = FigReadSchedulerCopyForByteStream((uint64_t)a2, (uint64_t *)&cf);
  if (SchedulerCopyForByteStream) {
    goto LABEL_13;
  }
  uint64_t SchedulerCopyForByteStream = FigReadSchedulerGetNewClientID((uint64_t)cf, &v11);
  if (SchedulerCopyForByteStream) {
    goto LABEL_13;
  }
  int v7 = (void *)FigScheduledIOGetClassID();
  uint64_t v8 = CMDerivedObjectCreate(a1, (uint64_t)&kFigScheduledIOFRSVTable, v7, &v13);
  if (!v8)
  {
    uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)v13);
    *uint64_t DerivedStorage = FigSimpleMutexCreate();
    DerivedStorage[3] = v11;
    DerivedStorage[1] = CFRetain(a2);
    DerivedStorage[2] = CFRetain(cf);
    *a3 = v13;
    CFTypeRef v13 = 0;
  }
LABEL_7:
  if (cf) {
    CFRelease(cf);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v8;
}

CFAllocatorRef figSchedIOFRS_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = (dispatch_queue_t *)DerivedStorage[2];
  if (v2)
  {
    FigReadSchedulerCancelAllClientRequests(v2, DerivedStorage[3], 0);
    uint64_t v3 = (const void *)DerivedStorage[4];
    if (v3)
    {
      CFRelease(v3);
      DerivedStorage[4] = 0;
    }
    CFAllocatorRef v4 = (const void *)DerivedStorage[2];
    if (v4)
    {
      CFRelease(v4);
      DerivedStorage[2] = 0;
    }
  }
  uint64_t v5 = (const void *)DerivedStorage[1];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[1] = 0;
  }
  uint64_t v6 = *DerivedStorage;

  return FigSimpleMutexDestroy(v6);
}

__CFString *figSchedIOFRS_CopyDebugDescription(const void *a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFIndex v4 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, @"FigSchedIOFRS %p(%d): BS=%@ clientID=%lld RS: %@", a1, v4, DerivedStorage[1], DerivedStorage[3], DerivedStorage[2]);
  if (DerivedStorage[4]) {
    CFStringAppendFormat(Mutable, 0, @" PrerollBatch: %@", DerivedStorage[4]);
  }
  return Mutable;
}

uint64_t figSchedIOFRS_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v14 = 0;
  if (CFEqual(a2, @"ScheduledIO_ReadStats"))
  {
    uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(*(void *)(DerivedStorage + 8));
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    CFTypeRef v13 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, uint64_t *))(v10 + 48);
    if (v13)
    {
      uint64_t result = v13(CMBaseObject, @"FBS_ReadStats", a3, &v14);
      uint64_t v11 = v14;
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t result = 4294954514;
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t result = 4294954512;
  }
  *a4 = v11;
  return result;
}

uint64_t figSchedIOFRS_GetEOF(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  CFNumberRef number = 0;
  *a2 = 0;
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(*(void *)(DerivedStorage + 8));
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  int v7 = *(uint64_t (**)(uint64_t, __CFString *, void, CFNumberRef *))(v6 + 48);
  if (!v7) {
    return 4294954514;
  }
  uint64_t v8 = v7(CMBaseObject, @"FBS_EntireLength", *MEMORY[0x1E4F1CF80], &number);
  CFNumberRef v9 = number;
  if (!v8)
  {
    CFNumberGetValue(number, kCFNumberSInt64Type, a2);
    CFNumberRef v9 = number;
  }
  if (v9) {
    CFRelease(v9);
  }
  return v8;
}

uint64_t figSchedIOFRS_RequestRead(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, void *a10)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v30 = 0;
  if ((a9 & 0xC) != 0 && a9 < 0)
  {
    uint64_t Batch = FigSignalErrorAt(4294948015, 0, 0, 0, 0, 0, 0);
    uint64_t v28 = 0;
    goto LABEL_18;
  }
  uint64_t v19 = DerivedStorage;
  uint64_t v29 = a2;
  __int16 v20 = malloc_type_calloc(1uLL, 0x18uLL, 0x80040D6874129uLL);
  uint64_t v28 = v20;
  if (!v20)
  {
    uint64_t v25 = FigSignalErrorAt(4294948016, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
  *__int16 v20 = a5;
  v20[1] = a6;
  _OWORD v20[2] = a7;
  if ((a9 & 0xC) == 0)
  {
    int v22 = *(dispatch_queue_t **)(v19 + 16);
    uint64_t v23 = *(void *)(v19 + 24);
    uint64_t v24 = *(const void **)(v19 + 8);
    if ((a9 & 0x80) == 0)
    {
      uint64_t v25 = FigReadSchedulerRequestReadWithDeadline(v22, v23, v24, v29, a3, a4, 0, a8, (uint64_t)figSchedIOFRS_Callback, (uint64_t)v28, 0, &v30);
      if (v25) {
        goto LABEL_20;
      }
LABEL_17:
      uint64_t Batch = 0;
      uint64_t v28 = 0;
      *a10 = v30;
      goto LABEL_18;
    }
    uint64_t v25 = FigReadSchedulerRequestBackgroundRead(v22, v23, v24, v29, a3, a4, 0, (uint64_t)figSchedIOFRS_Callback, (uint64_t)v28, 0, &v30);
    if (!v25) {
      goto LABEL_17;
    }
LABEL_20:
    uint64_t Batch = v25;
    goto LABEL_18;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)v19);
  uint64_t v21 = *(void *)(v19 + 32);
  if (v21
    || (uint64_t Batch = FigReadSchedulerCreateBatch(*(void **)(v19 + 16), (void *)(v19 + 32)),
        (uint64_t v21 = *(void *)(v19 + 32)) != 0))
  {
    uint64_t Batch = FigReadSchedulerBatchAddReadWithDeadline(v21, *(void *)(v19 + 24), *(const void **)(v19 + 8), v29, a3, a4, 0, a8, (uint64_t)figSchedIOFRS_Callback, (uint64_t)v28, 0, &v30);
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)v19);
  if (!Batch) {
    goto LABEL_17;
  }
LABEL_18:
  free(v28);
  return Batch;
}

uint64_t figSchedIOFRS_Finish(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v6 = DerivedStorage;
  if (a3 == 5)
  {
    int v7 = 0;
    goto LABEL_5;
  }
  if (a3 == 4)
  {
    int v7 = 1;
LABEL_5:
    return figSchedIOFRS_FinishPreroll(DerivedStorage, v7);
  }
  if (!a2)
  {
    if (a3 == 2)
    {
      uint64_t v14 = *(dispatch_queue_t **)(DerivedStorage + 16);
      uint64_t v15 = *(void *)(v6 + 24);
      int v16 = 0;
    }
    else
    {
      if (a3 != 1)
      {
        if (a3) {
          goto LABEL_21;
        }
        uint64_t v10 = *(dispatch_queue_t **)(DerivedStorage + 16);
        uint64_t v11 = *(void *)(v6 + 24);
        return FigReadSchedulerExpediteAllClientRequests(v10, v11, 1);
      }
      uint64_t v14 = *(dispatch_queue_t **)(DerivedStorage + 16);
      uint64_t v15 = *(void *)(v6 + 24);
      int v16 = 1;
    }
    uint64_t SchedulerCancelAllClientRequests = FigReadSchedulerCancelAllClientRequests(v14, v15, v16);
    uint64_t v18 = *(void *)(v6 + 32);
    if (v18) {
      FigReadSchedulerBatchCancel(v18);
    }
    return SchedulerCancelAllClientRequests;
  }
  if (a3 != 2)
  {
    if (a3 == 1)
    {
      uint64_t v12 = 4294954514;
      goto LABEL_26;
    }
    if (!a3)
    {
      CFNumberRef v9 = *(dispatch_queue_t **)(DerivedStorage + 16);
      return FigReadSchedulerExpediteRequest(v9, a2, 1);
    }
LABEL_21:
    uint64_t v12 = 4294948015;
LABEL_26:
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  CFTypeRef v13 = *(dispatch_queue_t **)(DerivedStorage + 16);

  return FigReadSchedulerCancelRequest(v13, a2);
}

uint64_t figSchedIOFRS_ExpediteAllClientRequests(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = *(void *)(DerivedStorage + 24);
  uint64_t v3 = *(dispatch_queue_t **)(DerivedStorage + 16);

  return FigReadSchedulerExpediteAllClientRequests(v3, v2, 0);
}

uint64_t figSchedIOFRS_GetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage(a1) + 8);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable(v5) + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 24);
  if (!v8) {
    return 4294954514;
  }

  return v8(v5, a2, a3);
}

uint64_t figSchedIOFRS_CreateBatch(const void *a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (a3 && a1)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    ClassID = (void *)FigScheduledIOBatchGetClassID();
    uint64_t Batch = CMDerivedObjectCreate(a2, (uint64_t)&kFigScheduledIOBatchFRSVTable, ClassID, &cf);
    CFTypeRef v9 = cf;
    if (!Batch)
    {
      uint64_t v10 = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      *(void *)uint64_t v10 = a1;
      CFRetain(a1);
      *(unsigned char *)(v10 + 16) = 0;
      uint64_t v11 = (unint64_t *)(v10 + 8);
      uint64_t Batch = FigReadSchedulerCreateBatch(*(void **)(DerivedStorage + 16), (void *)(v10 + 8));
      if (!Batch)
      {
        DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)cf, (CFNotificationCallback)figSchedIOBatchFRS_completionCallback, @"readSchedulerNotification_BatchCompleted", *v11, 0, 0);
        *a3 = cf;
        return Batch;
      }
      CFTypeRef v9 = cf;
    }
    if (v9) {
      CFRelease(v9);
    }
    return Batch;
  }

  return FigSignalErrorAt(4294948015, 0, 0, 0, 0, 0, 0);
}

void figSchedIOFRS_Callback(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  if (a6 == -17785) {
    uint64_t v8 = 4294948013;
  }
  else {
    uint64_t v8 = a6;
  }
  ((void (*)(void, void, uint64_t, uint64_t, uint64_t))*a2)(a2[1], a2[2], a4, a5, v8);

  free(a2);
}

uint64_t figSchedIOFRS_FinishPreroll(uint64_t a1, int a2)
{
  uint64_t v9 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)a1);
  CFIndex v4 = *(const void **)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
  if (!v4) {
    return 0;
  }
  uint64_t SchedulerBatchExpedite = FigReadSchedulerBatchExpedite((uint64_t)v4);
  uint64_t SchedulerBatchAwaitCompletion = SchedulerBatchExpedite;
  if (a2)
  {
    if (!SchedulerBatchExpedite)
    {
      v8[0] = v4;
      v8[1] = 0;
      FigThreadRegisterAbortAction((uint64_t (*)())figSchedIOFRSWaitForCompletionAbort, (_opaque_pthread_t *)v8, &v9);
      uint64_t SchedulerBatchAwaitCompletion = FigReadSchedulerBatchAwaitCompletion((uint64_t)v4);
      if (v9) {
        FigThreadUnregisterAbortAction(v9);
      }
    }
  }
  CFRelease(v4);
  return SchedulerBatchAwaitCompletion;
}

uint64_t figSchedIOFRSWaitForCompletionAbort(uint64_t a1)
{
  uint64_t result = FigReadSchedulerBatchCancel(*(void *)a1);
  *(_DWORD *)(a1 + 8) = -19283;
  return result;
}

uint64_t figSchedIOBatchFRS_completionCallback(uint64_t a1, const void *a2)
{
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();

  return CMNotificationCenterPostNotification(DefaultLocalCenter, @"scheduledIOBatchNotification_BatchCompleted", a2, 0);
}

void figSchedIOBatchFRS_Finalize(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)figSchedIOBatchFRS_completionCallback, @"readSchedulerNotification_BatchCompleted", *(const void **)(DerivedStorage + 8));
  if (!*(unsigned char *)(DerivedStorage + 16))
  {
    uint64_t v4 = *(void *)(DerivedStorage + 8);
    if (!v4) {
      goto LABEL_6;
    }
    FigReadSchedulerBatchCancel(v4);
  }
  uint64_t v5 = *(const void **)(DerivedStorage + 8);
  if (v5) {
    CFRelease(v5);
  }
LABEL_6:
  uint64_t v6 = *(const void **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    CFRelease(v6);
  }
}

__CFString *figSchedIOBatchFRS_CopyDebugDescription(const void *a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFIndex v4 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, @"FigSchedIOBatchFRS %p(%d): scheduledIO=%@, schedulerBatch=%@", a1, v4, *DerivedStorage, DerivedStorage[1]);
  return Mutable;
}

uint64_t figSchedIOBatchFRS_AddRead(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, void *a10)
{
  uint64_t v29 = 0;
  if (!a1)
  {
    uint64_t v28 = 4294948015;
LABEL_12:
    uint64_t v26 = FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
    uint64_t v21 = 0;
    goto LABEL_9;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v18 = CMBaseObjectGetDerivedStorage(*(void *)DerivedStorage);
  if (*(unsigned char *)(DerivedStorage + 16))
  {
    uint64_t v28 = 4294948014;
    goto LABEL_12;
  }
  uint64_t v19 = v18;
  __int16 v20 = malloc_type_calloc(1uLL, 0x18uLL, 0x80040D6874129uLL);
  uint64_t v21 = v20;
  if (!v20)
  {
    uint64_t v25 = FigSignalErrorAt(4294948016, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  *__int16 v20 = a5;
  v20[1] = a6;
  _OWORD v20[2] = a7;
  uint64_t v22 = *(void *)(DerivedStorage + 8);
  uint64_t v23 = *(void *)(v19 + 24);
  uint64_t v24 = *(const void **)(v19 + 8);
  if ((a9 & 0x80) == 0)
  {
    uint64_t v25 = FigReadSchedulerBatchAddReadWithDeadline(v22, v23, v24, a2, a3, a4, 0, a8, (uint64_t)figSchedIOFRS_Callback, (uint64_t)v21, 0, &v29);
    if (v25) {
      goto LABEL_14;
    }
    goto LABEL_8;
  }
  uint64_t v25 = FigReadSchedulerBatchAddBackgroundRead(v22, v23, v24, a2, a3, a4, 0, (uint64_t)figSchedIOFRS_Callback, (uint64_t)v21, 0, &v29);
  if (v25)
  {
LABEL_14:
    uint64_t v26 = v25;
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v26 = 0;
  uint64_t v21 = 0;
  *a10 = v29;
LABEL_9:
  free(v21);
  return v26;
}

uint64_t figSchedIOBatchFRS_Commit(uint64_t a1)
{
  if (a1)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    if (!*(unsigned char *)(DerivedStorage + 16))
    {
      uint64_t v2 = DerivedStorage;
      uint64_t result = FigReadSchedulerBatchCommit(*(void *)(DerivedStorage + 8));
      if (!result) {
        *(unsigned char *)(v2 + 16) = 1;
      }
      return result;
    }
    uint64_t v4 = 4294948014;
  }
  else
  {
    uint64_t v4 = 4294948015;
  }

  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t figSchedIOBatchFRS_Cancel(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(CMBaseObjectGetDerivedStorage(a1) + 8);
    return FigReadSchedulerBatchCancel(v2);
  }
  else
  {
    return FigSignalErrorAt(4294948015, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigHEVCBridge_GetSPS_VUI_AspectRatio(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  long long v11 = 0u;
  int v9 = 0;
  uint64_t v8 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v14, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v12[0]) = 1;
    *(void *)((char *)v12 + 12) = 0;
    *(void *)((char *)v12 + 4) = 0xF80000000000;
    v10[0] = (uint64_t)&v8;
    v10[1] = (uint64_t)hevcbridgeGetSPS_VUI_AspectRatioCallbackFlag;
    int v10[2] = (uint64_t)hevcbridgeGetSPS_VUI_AspectRatioCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v14, v10);
    if (!result)
    {
      uint64_t result = 4294954584;
      if ((_BYTE)v9)
      {
        if (BYTE1(v9))
        {
          uint64_t result = 0;
          int v7 = HIDWORD(v8);
          *a3 = v8;
          *a4 = v7;
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeSetupBitStreamFromPointerAndLength(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(unsigned char *)(a1 + 41) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a2 + a3;
  *(unsigned char *)(a1 + 40) = a4;
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = a2;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  return hevcbridgeAdvanceInBitstream(a1, 0);
}

uint64_t hevcbridgeGetSPS_VUI_AspectRatioCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 109)
  {
    *(unsigned char *)(a1 + 9) = a3;
    return a3 != 1;
  }
  if (a2 == 108)
  {
    *(unsigned char *)(a1 + 8) = a3;
    return a3 != 1;
  }
  return 4294954584;
}

uint64_t hevcbridgeGetSPS_VUI_AspectRatioCallbackUnsigned(unsigned int *a1, int a2, unsigned int a3)
{
  uint64_t v3 = 4294954584;
  if (a2 > 110)
  {
    if (a2 != 111)
    {
      if (a2 == 112)
      {
        a1[1] = a3;
        return 1;
      }
      return v3;
    }
    *a1 = a3;
    return 0;
  }
  if (!a2)
  {
    if (a3 != 33) {
      return v3;
    }
    return 0;
  }
  if (a2 == 110)
  {
    if (a3 - 1 <= 0xF)
    {
      uint64_t v4 = (unsigned __int8 *)&kHEVCSampleAspectRatioIndicators + 2 * a3;
      unsigned int v5 = *v4;
      LODWORD(v4) = v4[1];
      *a1 = v5;
      a1[1] = v4;
      return 1;
    }
    if (a3 != 255)
    {
      *(void *)a1 = 0x100000001;
      return 1;
    }
    return 0;
  }
  return v3;
}

uint64_t hevcbridgeParseNALUnit(void *a1, uint64_t *a2)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  unsigned int v4 = hevcbridgeUPullLong((uint64_t)a1, 1, (_DWORD *)&v11 + 1);
  if (!v4)
  {
    if (HIDWORD(v11))
    {
      uint64_t v8 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      return v8;
    }
    char v5 = *((unsigned char *)a2 + 40);
    unsigned int v4 = hevcbridgeUPullLong((uint64_t)a1, 6, &v11);
    if ((v5 & 1) != 0 && !v4) {
      unsigned int v4 = ((uint64_t (*)(uint64_t, void, void, uint64_t))a2[2])(*a2, 0, v11, 0xFFFFFFFFLL);
    }
    if (!v4)
    {
      char v6 = *((unsigned char *)a2 + 40);
      unsigned int v4 = hevcbridgeUPullLong((uint64_t)a1, 6, (_DWORD *)&v10 + 1);
      if ((v6 & 2) != 0 && !v4) {
        unsigned int v4 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 1, HIDWORD(v10), 0xFFFFFFFFLL);
      }
      if (!v4)
      {
        char v7 = *((unsigned char *)a2 + 40);
        unsigned int v4 = hevcbridgeUPullLong((uint64_t)a1, 3, &v10);
        if ((v7 & 4) != 0 && !v4) {
          unsigned int v4 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 2, v10, 0xFFFFFFFFLL);
        }
        if (!v4)
        {
          uint64_t v8 = 0;
          switch((int)v11)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
              unsigned int v4 = hevcbridgeParseSliceSegmentLayer((uint64_t)a1, a2, v11, HIDWORD(v10), v10);
              break;
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 35:
            case 36:
            case 37:
            case 38:
              return v8;
            case 32:
              unsigned int v4 = hevcbridgeParseVideoParameterSet((uint64_t)a1, a2);
              break;
            case 33:
              unsigned int v4 = hevcbridgeParseSequenceParameterSet((uint64_t)a1, a2, SHIDWORD(v10));
              break;
            case 34:
              unsigned int v4 = hevcbridgeParsePictureParameterSet(a1, a2);
              break;
            case 39:
            case 40:
              unsigned int v4 = hevcbridgeParseSEIRBSP(a1, a2, v11);
              break;
            default:
              if (v11 != 62) {
                return v8;
              }
              unsigned int v4 = hevcbridgeParseDolbyRPUDataRBSP((uint64_t)a1, a2, 0);
              break;
          }
        }
      }
    }
  }
  if (v4 == 1) {
    return 0;
  }
  else {
    return v4;
  }
}

uint64_t FigHEVCBridge_GetSPS_VUI_ChromaLocation(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  long long v11 = 0u;
  int v9 = 0;
  uint64_t v8 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v14, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v12[0]) = 1;
    *(void *)((char *)v12 + 12) = 0;
    *(void *)((char *)v12 + 4) = 0xE00080000000000;
    v10[0] = (uint64_t)&v8;
    v10[1] = (uint64_t)hevcbridgeGetSPS_VUI_ChromaLocationCallbackFlag;
    int v10[2] = (uint64_t)hevcbridgeGetSPS_VUI_ChromaLocationCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v14, v10);
    if (!result)
    {
      uint64_t result = 4294954584;
      if ((_BYTE)v9)
      {
        if (BYTE1(v9))
        {
          uint64_t result = 0;
          int v7 = HIDWORD(v8);
          *a3 = v8;
          *a4 = v7;
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPS_VUI_ChromaLocationCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 122)
  {
    *(unsigned char *)(a1 + 9) = a3;
    return a3 != 1;
  }
  if (a2 == 108)
  {
    *(unsigned char *)(a1 + 8) = a3;
    return a3 != 1;
  }
  return 4294954584;
}

uint64_t hevcbridgeGetSPS_VUI_ChromaLocationCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  if (a2 == 124)
  {
    a1[1] = a3;
    return 1;
  }
  else
  {
    if (a2 == 123)
    {
      *a1 = a3;
    }
    else if (a2 || a3 != 33)
    {
      return 4294954584;
    }
    return 0;
  }
}

uint64_t FigHEVCBridge_GetSPS_VUI_NCLC(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  long long v13 = 0u;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v16, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v14[0]) = 1;
    *(void *)((char *)v14 + 12) = 0;
    *(void *)((char *)v14 + 4) = 0x1E0080000000000;
    v12[0] = (uint64_t)&v10;
    v12[1] = (uint64_t)hevcbridgeGetSPS_VUI_NCLCCallbackFlag;
    int v12[2] = (uint64_t)hevcbridgeGetSPS_VUI_NCLCCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v16, v12);
    if (!result)
    {
      uint64_t result = 4294954584;
      if (BYTE4(v11))
      {
        if (BYTE5(v11))
        {
          uint64_t result = 0;
          int v9 = HIDWORD(v10);
          *a3 = v10;
          *a4 = v9;
          *a5 = v11;
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPS_VUI_NCLCCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 118)
  {
    *(unsigned char *)(a1 + 13) = a3;
    return a3 != 1;
  }
  if (a2 == 108)
  {
    *(unsigned char *)(a1 + 12) = a3;
    return a3 != 1;
  }
  return 4294954584;
}

uint64_t hevcbridgeGetSPS_VUI_NCLCCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  uint64_t result = 4294954584;
  if (a2 > 119)
  {
    if (a2 == 120)
    {
      ++a1;
LABEL_11:
      *a1 = a3;
      return 0;
    }
    if (a2 == 121)
    {
      a1[2] = a3;
      return 1;
    }
  }
  else
  {
    if (a2)
    {
      if (a2 != 119) {
        return result;
      }
      goto LABEL_11;
    }
    if (a3 == 33) {
      return 0;
    }
  }
  return result;
}

uint64_t FigHEVCBridge_GetSPS_VUI_FullRangeVideo(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  v10[13] = *MEMORY[0x1E4F143B8];
  memset(v10, 0, 104);
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  long long v7 = 0u;
  char v5 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v10, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v8[0]) = 1;
    *(void *)((char *)v8 + 12) = 0;
    *(void *)((char *)v8 + 4) = 0x10000000000000;
    v6[0] = (uint64_t)&v5;
    v6[1] = (uint64_t)hevcbridgeGetSPS_VUI_FullRangeVideoCallbackFlag;
    int v6[2] = (uint64_t)hevcbridgeGetSPS_VUI_FullRangeVideoCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v10, v6);
    if (!result) {
      *a3 = v5;
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPS_VUI_FullRangeVideoCallbackFlag(unsigned char *a1, int a2, char a3)
{
  if (a2 != 117) {
    return 4294954584;
  }
  *a1 = a3;
  return 1;
}

uint64_t hevcbridgeGetSPS_VUI_FullRangeVideoCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if (a3 == 33 && a2 == 0) {
    return 0;
  }
  else {
    return 4294954584;
  }
}

uint64_t FigHEVCBridge_GetNALUnitHeader(uint64_t a1, uint64_t a2, _DWORD *a3, const char **a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t v24 = 0;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  int v13 = 0;
  uint64_t v12 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v25, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v17) = 7;
    uint64_t v14 = &v12;
    *((void *)&v15 + 1) = hevcbridgeGetNALUnitHeaderCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v25, (uint64_t *)&v14);
    if (!result)
    {
      if (a3) {
        *a3 = v12;
      }
      if (a4)
      {
        if (v12 > 0x3F) {
          uint64_t v11 = "?";
        }
        else {
          uint64_t v11 = nalUnitTypeString[v12];
        }
        *a4 = v11;
      }
      if (a5) {
        *a5 = HIDWORD(v12);
      }
      uint64_t result = 0;
      if (a6) {
        *a6 = v13 - 1;
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGetNALUnitHeaderCallbackUnsigned(_DWORD *a1, uint64_t a2, int a3)
{
  if (a2)
  {
    if (a2 == 2)
    {
      a1 += 2;
      a2 = 1;
    }
    else
    {
      if (a2 != 1) {
        return 4294954584;
      }
      a2 = 0;
      ++a1;
    }
  }
  *a1 = a3;
  return a2;
}

uint64_t FigHEVCBridge_GetVPSAlphaChannelNuhLayerId(uint64_t a1, uint64_t a2, unsigned char *a3, _DWORD *a4)
{
  v18[13] = *MEMORY[0x1E4F143B8];
  memset(v18, 0, 104);
  uint64_t v17 = 0;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  uint64_t v7 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v18, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v10) = 1;
    *(void *)((char *)&v10 + 4) = 50397184;
    v8[0] = (uint64_t)&v7;
    v8[1] = (uint64_t)hevcbridgeGetVPSAlphaChannelNuhLayerIdCallbackFlag;
    void v8[2] = (uint64_t)hevcbridgeGetVPSAlphaChannelNuhLayerIdCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v18, v8);
    if (!result)
    {
      if (a3) {
        *a3 = BYTE4(v7);
      }
      uint64_t result = 0;
      if (a4) {
        *a4 = v7;
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGetVPSAlphaChannelNuhLayerIdCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 19) {
    return a3 == 0;
  }
  else {
    return 4294954584;
  }
}

uint64_t hevcbridgeGetVPSAlphaChannelNuhLayerIdCallbackUnsigned(uint64_t a1, int a2, unsigned int a3)
{
  if (a2 == 28) {
    return 1;
  }
  if (a2 == 27)
  {
    if (a3 == 1)
    {
      *(_DWORD *)a1 = a3 >> 8;
      uint64_t result = 1;
      *(unsigned char *)(a1 + 4) = 1;
      return result;
    }
  }
  else if (a2 || a3 != 32)
  {
    return 4294954584;
  }
  return 0;
}

uint64_t FigHEVCBridge_GetSEIAlphaChannelInfo(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  uint64_t v15 = 0;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  long long v8 = 0u;
  long long v7 = 0u;
  char v5 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v16, a1, a2, 1);
  if (!result)
  {
    BYTE12(v9) = 31;
    v6[0] = (uint64_t)&v5;
    v6[1] = (uint64_t)hevcbridgeGetSEIAlphaChannelInfoCallbackFlag;
    int v6[2] = (uint64_t)hevcbridgeGetSEIAlphaChannelInfoCallbackUnsigned;
    uint64_t result = hevcbridgeParseSEIAlphaChannelInfo((uint64_t)v16, v6);
    if (result <= 1)
    {
      uint64_t result = 0;
      *a3 = v5;
    }
  }
  return result;
}

uint64_t hevcbridgeGetSEIAlphaChannelInfoCallbackFlag(uint64_t a1, int a2, int a3)
{
  uint64_t result = 4294954584;
  if (a2 == 354)
  {
    if (a3) {
      return 4294954584;
    }
    else {
      return 1;
    }
  }
  else if (a2 == 353)
  {
    if (!a3) {
      return 0;
    }
  }
  else if (a2 == 348 && a3 != 1)
  {
    return 0;
  }
  return result;
}

uint64_t hevcbridgeGetSEIAlphaChannelInfoCallbackUnsigned(unsigned char *a1, int a2, int a3)
{
  switch(a2)
  {
    case 349:
      if (a3 == 1)
      {
        uint64_t result = 0;
        *a1 = 1;
      }
      else
      {
        if (a3) {
          goto LABEL_6;
        }
        uint64_t result = 0;
        *a1 = 0;
      }
      break;
    case 350:
    case 351:
      BOOL v3 = a3 == 0;
      goto LABEL_8;
    case 352:
      BOOL v3 = a3 == 255;
LABEL_8:
      if (v3) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = 4294954584;
      }
      break;
    default:
LABEL_6:
      uint64_t result = 4294954584;
      break;
  }
  return result;
}

uint64_t hevcbridgeParseSEIAlphaChannelInfo(uint64_t a1, uint64_t *a2)
{
  __int16 v9 = 0;
  uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, *((unsigned char *)a2 + 68) & 1, 348, (unsigned char *)&v9 + 1);
  if (result) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = HIBYTE(v9) == 0;
  }
  if (v5)
  {
    unsigned int v8 = 0;
    uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 68) >> 1) & 1, 349, 3);
    if (!result)
    {
      char v6 = *((unsigned char *)a2 + 68);
      uint64_t result = hevcbridgeUPullLong(a1, 3, &v8);
      if ((v6 & 4) != 0 && !result) {
        uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 350, v8, 0xFFFFFFFFLL);
      }
      if (!result)
      {
        int v7 = v8 + 9;
        uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 68) >> 3) & 1, 351, v8 + 9);
        if (!result)
        {
          uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 68) >> 4) & 1, 352, v7);
          if (!result)
          {
            uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 68) >> 5) & 1, 353);
            if (!result)
            {
              uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 68) >> 6) & 1, 354, &v9);
              if (!result)
              {
                if (!(_BYTE)v9) {
                  return 0;
                }
                uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, *((unsigned __int8 *)a2 + 68) >> 7, 355);
                if (!result) {
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t FigHEVCBridge_GetAmbientViewingEnvironment(uint64_t a1, uint64_t a2, _DWORD *a3, _WORD *a4, _WORD *a5)
{
  v23[13] = *MEMORY[0x1E4F143B8];
  memset(v23, 0, 104);
  uint64_t v22 = 0;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  uint64_t v11 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v23, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v15) = 1;
    LOBYTE(v17) = 7;
    long long v12 = &v11;
    *((void *)&v13 + 1) = hevcbridgeGetSEIAmbientViewingEnvironmentCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v23, (uint64_t *)&v12);
    if (result <= 1)
    {
      uint64_t result = 4294954584;
      if (v11)
      {
        __int16 v9 = WORD2(v11);
        if (WORD2(v11))
        {
          __int16 v10 = HIWORD(v11);
          if (HIWORD(v11))
          {
            if (a3) {
              *a3 = v11;
            }
            if (a4) {
              *a4 = v9;
            }
            uint64_t result = 0;
            if (a5) {
              *a5 = v10;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGetSEIAmbientViewingEnvironmentCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  uint64_t result = 4294954584;
  if (a2 > 356)
  {
    if (a2 == 357)
    {
      *(_WORD *)(a1 + 4) = a3;
LABEL_11:
      if (a3) {
        return 0;
      }
      else {
        return 4294954584;
      }
    }
    if (a2 == 358)
    {
      *(_WORD *)(a1 + 6) = a3;
      return 1;
    }
  }
  else
  {
    if (a2)
    {
      if (a2 != 356) {
        return result;
      }
      *(_DWORD *)a1 = a3;
      goto LABEL_11;
    }
    if (a3 == 39) {
      return 0;
    }
  }
  return result;
}

uint64_t FigHEVCBridge_GetSPSProfileTierLevel(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned char *a4, unsigned char *a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v23 = 0;
  memset(v22, 0, sizeof(v22));
  uint64_t v21 = 0;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  int v11 = 0;
  uint64_t v10 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v22, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v14) = 1;
    DWORD1(v15) = 1048583;
    v12[0] = (uint64_t)&v10;
    v12[1] = (uint64_t)hevcbridgeGetSPSProfileTierLevelCallbackFlag;
    int v12[2] = (uint64_t)hevcbridgeGetSPSProfileTierLevelCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v22, v12);
    if (!result)
    {
      char v9 = BYTE4(v10);
      *a3 = v10;
      *a4 = v11;
      *a5 = v9;
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPSProfileTierLevelCallbackFlag(uint64_t a1, int a2, char a3)
{
  if (a2 != 309) {
    return 4294954584;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 8) = a3;
  return result;
}

uint64_t hevcbridgeGetSPSProfileTierLevelCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  uint64_t result = 4294954584;
  if (a2 <= 309)
  {
    if (a2)
    {
      if (a2 != 308 || a3) {
        return result;
      }
    }
    else if (a3 != 33)
    {
      return result;
    }
    return 0;
  }
  if (a2 == 310)
  {
    *a1 = a3;
    return 0;
  }
  if (a2 == 328)
  {
    a1[1] = a3;
    return 1;
  }
  return result;
}

uint64_t FigHEVCBridge_GetSPSChromaFormatAndBitDepths(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned char *a4, unsigned char *a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0;
  memset(v17, 0, sizeof(v17));
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  long long v14 = 0u;
  unsigned int v12 = 0;
  uint64_t v11 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v17, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v15[0]) = 1;
    *(void *)((char *)v15 + 12) = 0;
    *(void *)((char *)v15 + 4) = 196768;
    v13[0] = (uint64_t)&v11;
    v13[1] = (uint64_t)hevcbridgeGetSPSChromaFormatAndBitDepthsCallbackFlag;
    int v13[2] = (uint64_t)hevcbridgeGetSPSChromaFormatAndBitDepthsCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v17, v13);
    if (!result)
    {
      if (v11 >= 4) {
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
      char v9 = BYTE4(v11);
      if (HIDWORD(v11) >= 9) {
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
      char v10 = v12;
      if (v12 >= 9)
      {
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        if (a3) {
          *a3 = v11;
        }
        if (a4) {
          *a4 = v9 + 8;
        }
        uint64_t result = 0;
        if (a5) {
          *a5 = v10 + 8;
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPSChromaFormatAndBitDepthsCallbackFlag(uint64_t a1, int a2)
{
  if (a2 == 70) {
    return 4294954579;
  }
  else {
    return 4294954584;
  }
}

uint64_t hevcbridgeGetSPSChromaFormatAndBitDepthsCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  uint64_t result = 4294954584;
  if (a2 > 80)
  {
    if (a2 == 81)
    {
      ++a1;
LABEL_11:
      *a1 = a3;
      return 0;
    }
    if (a2 == 82)
    {
      a1[2] = a3;
      return 1;
    }
  }
  else
  {
    if (a2)
    {
      if (a2 != 72) {
        return result;
      }
      goto LABEL_11;
    }
    if (a3 == 33) {
      return 0;
    }
  }
  return result;
}

uint64_t FigHEVCBridge_GetSPSIsScalingListPresent(uint64_t a1, uint64_t a2, char *a3)
{
  v12[13] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  long long v9 = 0u;
  __int16 v7 = 0;
  if (!a3) {
    return 4294954584;
  }
  memset(v12, 0, 104);
  *a3 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v12, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v10[0]) = 1;
    *(void *)((char *)v10 + 12) = 0;
    *(void *)((char *)v10 + 4) = 603979776;
    void v8[2] = (uint64_t)hevcbridgeGetSPSScalingListEnabledAndScalingListPresentCallbackUnsigned;
    v8[0] = (uint64_t)&v7;
    v8[1] = (uint64_t)hevcbridgeGetSPSScalingListEnabledAndScalingListPresentCallback;
    uint64_t result = hevcbridgeParseNALUnit(v12, v8);
    if (!result)
    {
      if (HIBYTE(v7)) {
        BOOL v5 = v7 == 0;
      }
      else {
        BOOL v5 = 1;
      }
      char v6 = !v5;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPSScalingListEnabledAndScalingListPresentCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if (a3 == 33 && a2 == 0) {
    return 0;
  }
  else {
    return 4294954584;
  }
}

uint64_t hevcbridgeGetSPSScalingListEnabledAndScalingListPresentCallback(unsigned char *a1, int a2, int a3)
{
  if (a2 == 94)
  {
    a1[1] = a3;
    return 1;
  }
  else if (a2 == 91)
  {
    *a1 = a3;
    return a3 == 0;
  }
  else
  {
    return 4294954584;
  }
}

uint64_t FigHEVCBridge_GetSPSBitDepths(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned char *a4)
{
  return FigHEVCBridge_GetSPSChromaFormatAndBitDepths(a1, a2, 0, a3, a4);
}

uint64_t FigHEVCBridge_GetSPSIsInterlaced(uint64_t a1, uint64_t a2, char *a3)
{
  v12[13] = *MEMORY[0x1E4F143B8];
  memset(v12, 0, 104);
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  long long v9 = 0u;
  __int16 v7 = 0;
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v12, a1, a2, 1);
  if (!result)
  {
    LOBYTE(v10[0]) = 1;
    *(void *)((char *)v10 + 12) = 0;
    *(void *)((char *)v10 + 4) = 0x2000080000000000;
    v8[0] = (uint64_t)&v7;
    v8[1] = (uint64_t)hevcbridgeGetSPSIsInterlacedCallbackFlag;
    void v8[2] = (uint64_t)hevcbridgeGetSPSIsInterlacedCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v12, v8);
    if (!result)
    {
      if ((_BYTE)v7) {
        BOOL v5 = HIBYTE(v7) == 0;
      }
      else {
        BOOL v5 = 1;
      }
      char v6 = !v5;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPSIsInterlacedCallbackFlag(unsigned char *a1, int a2, int a3)
{
  if (a2 == 126)
  {
    a1[1] = a3;
    return 1;
  }
  else if (a2 == 108)
  {
    *a1 = a3;
    return a3 == 0;
  }
  else
  {
    return 4294954584;
  }
}

uint64_t hevcbridgeGetSPSIsInterlacedCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if (a3 == 33 && a2 == 0) {
    return 0;
  }
  else {
    return 4294954584;
  }
}

double FigHEVCBridge_Get3DLayerIDSets(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5, _OWORD *a6)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  uint64_t v29 = 0;
  memset(v28, 0, sizeof(v28));
  uint64_t v27 = 0;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  memset(v16, 0, 140);
  if (!hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v30, a3, a4, 0))
  {
    LOBYTE(v20) = 1;
    WORD2(v22) = 48;
    long long v17 = v16;
    *((void *)&v18 + 1) = hevcbridgeGet3DLayerIDsSEICallbackUnsigned;
    *(void *)((char *)v16 + 4) = -1;
    if (hevcbridgeParseSEI3DReferenceDisplaysInformation((uint64_t)v30, &v17) <= 1
      && !hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v28, a1, a2, 1))
    {
      long long v20 = 0u;
      uint64_t v27 = 0;
      long long v26 = 0u;
      long long v25 = 0u;
      long long v24 = 0u;
      long long v23 = 0u;
      long long v22 = 0u;
      long long v21 = 0u;
      long long v19 = 0u;
      LOBYTE(v20) = 1;
      *(void *)((char *)&v20 + 4) = 4160815104;
      long long v17 = v16;
      *(void *)&long long v18 = hevcbridgeGet3DLayerIDsVPSCallbackFlag;
      *((void *)&v18 + 1) = hevcbridgeGet3DLayerIDsVPSCallbackUnsigned;
      *(void *)&long long v11 = -1;
      *((void *)&v11 + 1) = -1;
      *(_OWORD *)((char *)v16 + 12) = v11;
      *(_OWORD *)((char *)&v16[1] + 12) = v11;
      *(_OWORD *)((char *)&v16[2] + 12) = v11;
      *(_OWORD *)((char *)&v16[3] + 12) = v11;
      *(_OWORD *)((char *)&v16[4] + 12) = v11;
      *(_OWORD *)((char *)&v16[5] + 12) = v11;
      *(_OWORD *)((char *)&v16[6] + 12) = v11;
      *(_OWORD *)((char *)&v16[7] + 12) = v11;
      if (!hevcbridgeParseNALUnit(v28, (uint64_t *)&v17))
      {
        long long v12 = *(_OWORD *)(((unint64_t)v16 | 0xC) + 0x10);
        *a5 = *(_OWORD *)((unint64_t)v16 | 0xC);
        a5[1] = v12;
        long long v13 = *(_OWORD *)(((unint64_t)v16 | 0xC) + 0x30);
        a5[2] = *(_OWORD *)(((unint64_t)v16 | 0xC) + 0x20);
        a5[3] = v13;
        long long v14 = *(_OWORD *)((char *)&v16[5] + 12);
        *a6 = *(_OWORD *)((char *)&v16[4] + 12);
        a6[1] = v14;
        double result = *(double *)((char *)&v16[6] + 12);
        long long v15 = *(_OWORD *)((char *)&v16[7] + 12);
        a6[2] = *(_OWORD *)((char *)&v16[6] + 12);
        a6[3] = v15;
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGet3DLayerIDsSEICallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if (a2 == 364)
  {
    *(_DWORD *)(a1 + 8) = a3;
    return 1;
  }
  else
  {
    if (a2 == 363)
    {
      *(_DWORD *)(a1 + 4) = a3;
    }
    else if (a2 || a3 != 39)
    {
      return 4294954584;
    }
    return 0;
  }
}

uint64_t hevcbridgeParseSEI3DReferenceDisplaysInformation(uint64_t a1, void *a2)
{
  unsigned __int8 v24 = 0;
  unsigned int v23 = 0;
  uint64_t v22 = 0;
  __int16 v4 = *((_WORD *)a2 + 38);
  uint64_t result = hevcbridgeUEPullLong(a1, &v23);
  if ((v4 & 1) != 0 && !result) {
    uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 359, v23, 0xFFFFFFFFLL);
  }
  if (!result)
  {
    unsigned int v6 = v23;
    if (v23 >= 0x20)
    {
LABEL_14:
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    }
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 76) >> 1) & 1, 360, &v24);
    if (result) {
      return result;
    }
    int v7 = v24;
    if (v24)
    {
      __int16 v8 = *((_WORD *)a2 + 38);
      uint64_t result = hevcbridgeUEPullLong(a1, (unsigned int *)&v22);
      if ((v8 & 4) != 0 && !result) {
        uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 361, v22, 0xFFFFFFFFLL);
      }
      if (result) {
        return result;
      }
      int v9 = v22;
      if (v22 >= 0x20) {
        goto LABEL_14;
      }
    }
    else
    {
      int v9 = 0;
    }
    __int16 v10 = *((_WORD *)a2 + 38);
    uint64_t result = hevcbridgeUEPullLong(a1, (unsigned int *)&v22 + 1);
    if ((v10 & 8) != 0 && !result) {
      uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 362, HIDWORD(v22), 0xFFFFFFFFLL);
    }
    if (!result)
    {
      int v11 = 0;
      unsigned int v12 = HIDWORD(v22);
      int v13 = v6 - 30;
      unsigned int v14 = v6 - 31;
      while (1)
      {
        unsigned int v21 = 0;
        char v20 = 0;
        uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 76) >> 4) & 1, 363);
        if (result) {
          break;
        }
        uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 76) >> 5) & 1, 364);
        if (result) {
          break;
        }
        __int16 v15 = *((_WORD *)a2 + 38);
        uint64_t result = hevcbridgeUPullLong(a1, 6, &v21);
        if ((v15 & 0x40) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 365, v21, 0xFFFFFFFFLL);
        }
        if (result) {
          break;
        }
        if (v21 >= 0x3F) {
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        }
        if (v21) {
          int v16 = v14 + v21;
        }
        else {
          int v16 = v13;
        }
        uint64_t result = hevcbridgeUPullIfRequested(a1, a2, *((unsigned __int8 *)a2 + 76) >> 7, 366, v16);
        if (result) {
          return result;
        }
        if (v7)
        {
          int v19 = 0;
          uint64_t result = hevcbridgeUPullAlways(a1, a2, *((unsigned char *)a2 + 77) & 1, 367, &v19, 6);
          if (result) {
            return result;
          }
          int v17 = v19 ? v19 - 31 : 0;
          uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((unsigned __int16 *)a2 + 38) >> 9) & 1, 368, v9 + v17);
          if (result) {
            return result;
          }
        }
        uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int16 *)a2 + 38) >> 10) & 1, 369, &v20);
        if (result) {
          return result;
        }
        if (v20)
        {
          uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((unsigned __int16 *)a2 + 38) >> 11) & 1, 370, 10);
          if (result) {
            return result;
          }
        }
        if (++v11 > v12)
        {
          int v18 = (*((unsigned __int16 *)a2 + 38) >> 12) & 1;
          return hevcbridgeUPullFlagIfRequested(a1, a2, v18, 371);
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGet3DLayerIDsVPSCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 19) {
    unsigned int v3 = a3 == 0;
  }
  else {
    unsigned int v3 = -12712;
  }
  if (a2 == 31) {
    unsigned int v3 = 1;
  }
  if (a2 == 34) {
    return 1;
  }
  else {
    return v3;
  }
}

uint64_t hevcbridgeGet3DLayerIDsVPSCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if ((a2 - 32) < 2) {
    return 1;
  }
  if (a2 == 30)
  {
    if ((unsigned __int16)a3 == *(_DWORD *)(a1 + 4))
    {
      uint64_t v4 = 0;
      while (*(unsigned __int8 *)(a1 + 12 + v4) != 255)
      {
        if (++v4 == 64) {
          return 4294954584;
        }
      }
      unsigned int v6 = (unsigned char *)(a1 + v4 + 12);
    }
    else
    {
      if ((unsigned __int16)a3 != *(_DWORD *)(a1 + 8)) {
        return 0;
      }
      uint64_t v5 = 0;
      while (*(unsigned __int8 *)(a1 + 76 + v5) != 255)
      {
        ++v5;
        uint64_t v3 = 4294954584;
        if (v5 == 64) {
          return v3;
        }
      }
      unsigned int v6 = (unsigned char *)(a1 + v5 + 76);
    }
    *unsigned int v6 = BYTE2(a3);
    return 0;
  }
  if (!a2 && a3 == 32) {
    return 0;
  }
  return 4294954584;
}

void FigHEVCBridge_Get3DLayerIDs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, char *a6)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  memset(v14, 0, sizeof(v14));
  memset(v13, 0, sizeof(v13));
  FigHEVCBridge_Get3DLayerIDSets(a1, a2, a3, a4, v14, v13);
  char v8 = v14[0];
  if (v9) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = LOBYTE(v14[0]) == 255;
  }
  BOOL v11 = v10 || LOBYTE(v13[0]) == 255;
  if (v11) {
    char v8 = -1;
  }
  if (v11) {
    char v12 = -1;
  }
  else {
    char v12 = v13[0];
  }
  *a5 = v8;
  *a6 = v12;
}

unsigned char *FigHEVCBridge_AllocThreeDimensionalReferenceDisplaysInfo(unsigned int a1)
{
  if (a1 > 0x20) {
    return 0;
  }
  char v1 = a1;
  uint64_t result = malloc_type_calloc(1uLL, 40 * a1 + 8, 0xC28F6A3EuLL);
  if (result) {
    result[3] = v1 - 1;
  }
  return result;
}

uint64_t FigHEVCBridge_CreateThreeDimensionalReferenceDisplaysInfoSEI(unsigned __int8 *a1, CFDataRef *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  int v27 = 0;
  memset(v26, 0, sizeof(v26));
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v20 = 0u;
  memset(v18, 0, sizeof(v18));
  if (a2)
  {
    v19[0] = (uint64_t)v26;
    v19[1] = 260;
    *(void *)&long long v22 = v26;
    BYTE9(v21) = 0;
    uint64_t result = hevcbridgeUPush(v19, 1, 0);
    if (!result)
    {
      uint64_t result = hevcbridgeUPush(v19, 6, 39);
      if (!result)
      {
        uint64_t result = hevcbridgeUPush(v19, 6, 0);
        if (!result)
        {
          uint64_t result = hevcbridgeUPush(v19, 3, 1);
          if (!result)
          {
            uint64_t result = hevcbridgeUPush(v19, 8, 176);
            if (!result)
            {
              uint64_t result = hevcbridgeUPush(v19, 8, 0);
              if (!result)
              {
                uint64_t result = hevcbridgeUEPush((uint64_t)v19, *a1);
                if (!result)
                {
                  uint64_t result = hevcbridgeUPush(v19, 1, a1[1]);
                  if (!result)
                  {
                    if (!a1[1] || (uint64_t result = hevcbridgeUEPush((uint64_t)v19, a1[2]), !result))
                    {
                      uint64_t result = hevcbridgeUEPush((uint64_t)v19, a1[3]);
                      if (!result)
                      {
                        uint64_t v5 = a1 + 24;
                        unint64_t v6 = -1;
                        while (1)
                        {
                          uint64_t result = hevcbridgeUEPush((uint64_t)v19, *((unsigned __int16 *)v5 - 8));
                          if (result) {
                            return result;
                          }
                          uint64_t result = hevcbridgeUEPush((uint64_t)v19, *((unsigned __int16 *)v5 - 7));
                          if (result) {
                            return result;
                          }
                          uint64_t result = hevcbridgeUPush(v19, 6, *(v5 - 12));
                          if (result) {
                            return result;
                          }
                          if (*(v5 - 12))
                          {
                            unsigned int v7 = *a1 + *(v5 - 12);
                            int v8 = v7 - 31;
                            if (v7 < 0x1F) {
                              goto LABEL_19;
                            }
                          }
                          else
                          {
                            unsigned int v9 = *a1;
                            int v8 = v9 - 30;
                            if (v9 < 0x1E)
                            {
LABEL_19:
                              int v8 = 0;
LABEL_24:
                              unsigned int v10 = *((_DWORD *)v5 - 2);
                              goto LABEL_25;
                            }
                          }
                          if (v8 < 33) {
                            goto LABEL_24;
                          }
                          uint64_t result = hevcbridgeUPushLong(v19, v8 - 32, *((_DWORD *)v5 - 1));
                          if (result) {
                            return result;
                          }
                          unsigned int v10 = *((_DWORD *)v5 - 2);
                          int v8 = 32;
LABEL_25:
                          uint64_t result = hevcbridgeUPushLong(v19, v8, v10);
                          if (result) {
                            return result;
                          }
                          if (a1[1])
                          {
                            uint64_t result = hevcbridgeUPush(v19, 6, *v5);
                            if (result) {
                              return result;
                            }
                            if (*v5)
                            {
                              unsigned int v11 = a1[2] + *v5;
                              int v12 = v11 - 31;
                              if (v11 < 0x1F) {
                                goto LABEL_30;
                              }
LABEL_32:
                              if (v12 >= 33)
                              {
                                uint64_t result = hevcbridgeUPushLong(v19, v12 - 32, *((_DWORD *)v5 + 3));
                                if (result) {
                                  return result;
                                }
                                unsigned int v14 = *((_DWORD *)v5 + 2);
                                int v12 = 32;
LABEL_36:
                                uint64_t result = hevcbridgeUPushLong(v19, v12, v14);
                                if (result) {
                                  return result;
                                }
                                goto LABEL_37;
                              }
                            }
                            else
                            {
                              unsigned int v13 = a1[2];
                              int v12 = v13 - 30;
                              if (v13 >= 0x1E) {
                                goto LABEL_32;
                              }
LABEL_30:
                              int v12 = 0;
                            }
                            unsigned int v14 = *((_DWORD *)v5 + 2);
                            goto LABEL_36;
                          }
LABEL_37:
                          uint64_t result = hevcbridgeUPush(v19, 1, v5[16]);
                          if (result) {
                            return result;
                          }
                          if (v5[16])
                          {
                            uint64_t result = hevcbridgeUPush(v19, 10, *((unsigned __int16 *)v5 + 9));
                            if (result) {
                              return result;
                            }
                          }
                          ++v6;
                          v5 += 40;
                          if (v6 >= a1[3])
                          {
                            uint64_t result = hevcbridgeUPush(v19, 1, a1[4]);
                            if (result) {
                              return result;
                            }
                            if (HIDWORD(v23))
                            {
                              uint64_t result = hevcbridgeUPush(v19, 1, 1);
                              if (result) {
                                return result;
                              }
                              while (HIDWORD(v23))
                                hevcbridgeUPush(v19, 1, 0);
                            }
                            BYTE3(v26[0]) = v22 - LOBYTE(v19[0]) - 4;
                            uint64_t result = hevcbridgeUPush(v19, 1, 1);
                            if (!result)
                            {
                              int BufferWithStartCodeEmulationBytes = generateBufferWithStartCodeEmulationBytes(v22 - v19[0] + 1, v26, (uint64_t)v18);
                              CFDataRef v16 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v18, BufferWithStartCodeEmulationBytes);
                              if (v16)
                              {
                                CFDataRef v17 = v16;
                                uint64_t result = 0;
                                *a2 = v17;
                              }
                              else
                              {
                                return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                              }
                            }
                            return result;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t hevcbridgeUPushLong(uint64_t *a1, int a2, unsigned int a3)
{
  unsigned __int16 v3 = a3;
  uint64_t v4 = a1;
  if (a2 >= 26)
  {
    uint64_t result = hevcbridgeUPush(a1, a2 - 16, HIWORD(a3));
    if (result) {
      return result;
    }
    a3 = v3;
    a1 = v4;
    a2 = 16;
  }

  return hevcbridgeUPush(a1, a2, a3);
}

uint64_t hevcbridgeUEPush(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 41))
  {
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    int v3 = a2 + 1;
    if ((a2 + 1) < 2)
    {
      int v4 = 0;
    }
    else
    {
      int v4 = 0;
      unsigned int v5 = a2 + 1;
      do
      {
        unsigned int v6 = v4++;
        if (v6 > 0xE) {
          break;
        }
        BOOL v7 = v5 > 3;
        v5 >>= 1;
      }
      while (v7);
    }
    uint64_t result = hevcbridgeUPush((uint64_t *)a1, v4 + 1, 1);
    if (v4 && !result)
    {
      return hevcbridgeUPush((uint64_t *)a1, v4, (v3 - (1 << v4)) & ((1 << v4) - 1));
    }
  }
  return result;
}

uint64_t hevcbridgeUPush(uint64_t *a1, int a2, int a3)
{
  if (!*((unsigned char *)a1 + 41) && a2 > 0 && a2 < 0x1A)
  {
    unsigned int v4 = *((_DWORD *)a1 + 19) + a2;
    unsigned int v5 = (a3 << -(char)(*((unsigned char *)a1 + 76) + a2)) | *((_DWORD *)a1 + 20);
    *((_DWORD *)a1 + 20) = v5;
    unsigned int __src = bswap32(v5);
    uint64_t v6 = a1[1] + *a1;
    BOOL v7 = (unsigned int *)a1[6];
    unsigned int v8 = v6 - v7;
    size_t v9 = (v6 - v7);
    if (v9 >= 4)
    {
      *BOOL v7 = __src;
LABEL_7:
      int v10 = *((_DWORD *)a1 + 20) << (v4 & 0xF8);
      unint64_t v11 = a1[6] + (v4 >> 3);
      a1[6] = v11;
      *((_DWORD *)a1 + 19) = v4 & 7;
      *((_DWORD *)a1 + 20) = v10;
      uint64_t v12 = *a1;
      uint64_t v13 = a1[1];
      if (v13 + *a1 <= v11)
      {
        *((unsigned char *)a1 + 41) = 1;
        a1[6] = v12 + v13;
      }
      return 0;
    }
    memcpy(v7, &__src, v9);
    if (v8 >= (v4 + 7) >> 3) {
      goto LABEL_7;
    }
  }

  return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
}

uint64_t generateBufferWithStartCodeEmulationBytes(uint64_t result, unsigned char *a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v3 = result;
    int v4 = 0;
    LODWORD(result) = 0;
    do
    {
      if (v4 == 2)
      {
        if (*a2 > 3u)
        {
          int v4 = 2;
        }
        else
        {
          int v4 = 0;
          *(unsigned char *)(a3 + (int)result) = 3;
          LODWORD(result) = result + 1;
        }
      }
      *(unsigned char *)(a3 + (int)result) = *a2;
      if (*a2++) {
        int v4 = 0;
      }
      else {
        ++v4;
      }
      uint64_t result = (result + 1);
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets(int a1, const void *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, void *a7, void *a8, __CFData **a9)
{
  uint64_t v12 = a5;
  uint64_t v148 = *MEMORY[0x1E4F143B8];
  unint64_t v117 = 0;
  CFTypeRef cf = 0;
  int v116 = 0;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  *(_OWORD *)&v126[16] = 0u;
  long long v127 = 0u;
  *(_OWORD *)int v126 = 0u;
  memset(v123, 0, sizeof(v123));
  uint64_t v122 = 0;
  memset(v121, 0, sizeof(v121));
  uint64_t v124 = 0x100000000;
  uint64_t v125 = 2;
  *(void *)&v126[12] = 0x400000003;
  *(_DWORD *)int v115 = 0;
  unint64_t v114 = 0;
  if (a7) {
    *a7 = 0;
  }
  if (a8) {
    *a8 = 0;
  }
  if (!a4 || !a5 || a6 > 4 || ((1 << a6) & 0x16) == 0) {
    goto LABEL_103;
  }
  unsigned int v14 = (__CFArray *)a9;
  if (!a9)
  {
    uint64_t v77 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    goto LABEL_122;
  }
  *a9 = 0;
  if (a2)
  {
    uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a2, 1, 0, 0, 0, 0, (unint64_t)&v117, &v116, 0, 0);
    if (HEVCParameterSetAtIndex)
    {
LABEL_105:
      uint64_t v77 = HEVCParameterSetAtIndex;
      unsigned int v14 = 0;
      goto LABEL_122;
    }
    if (v116 != a6) {
      goto LABEL_103;
    }
  }
  if (a3 > 0x4FFFB || v117 > 0x4FFFB)
  {
LABEL_103:
    uint64_t v76 = 4294954584;
LABEL_104:
    uint64_t HEVCParameterSetAtIndex = FigSignalErrorAt(v76, 0, 0, 0, 0, 0, 0);
    goto LABEL_105;
  }
  CFDataRef v16 = malloc_type_calloc(v117 + a3, 0x20uLL, 0x10500408B07DF01uLL);
  if (!v16)
  {
    uint64_t v76 = 4294954583;
    goto LABEL_104;
  }
  CFDataRef v17 = v16;
  unint64_t v18 = v117;
  if (!(v117 + a3))
  {
    qsort(v16, 0, 0x20uLL, (int (__cdecl *)(const void *, const void *))FigHEVCBridge_sortParameterSetsByTypeThenIDThenBase);
    char v19 = 0;
    char v20 = 0;
    char v21 = 0;
    unint64_t v97 = 0;
    LOWORD(v96) = 0;
    unint64_t v100 = 0;
    uint64_t v101 = 0;
    unsigned int v14 = 0;
    CFDataRef v22 = 0;
    char v23 = 0;
    CFIndex v24 = 23;
LABEL_107:
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v24);
    if (Mutable)
    {
      CFTypeID v79 = Mutable;
      CFDataRef v106 = v22;
      uint64_t v111 = v14;
      bytes[0] = 1;
      bytes[1] = (32 * (v101 & 1)) | (BYTE4(v101) << 6) | BYTE4(v100) & 0x1F;
      CFDataAppendBytes(Mutable, bytes, 2);
      *(_DWORD *)int v115 = bswap32(*(unsigned int *)v115);
      CFDataAppendBytes(v79, v115, 4);
      unint64_t v114 = bswap64(v114);
      CFDataAppendBytes(v79, (const UInt8 *)&v114 + 2, 6);
      bytes[0] = v100;
      bytes[1] = BYTE1(v96) | 0xF0;
      UInt8 bytes[2] = v96;
      bytes[3] = -4;
      UInt8 bytes[4] = BYTE4(v97) | 0xFC;
      bytes[5] = v97 | 0xF8;
      bytes[6] = v21 | 0xF8;
      *(_WORD *)&bytes[7] = 0;
      bytes[9] = (a6 + 3) & 3 | (8 * (v20 & 7)) | (4 * (v19 & 1));
      bytes[10] = v23;
      CFDataAppendBytes(v79, bytes, 11);
      for (uint64_t i = 0; i != 5; ++i)
      {
        long long v81 = (char *)v121 + 24 * i;
        uint64_t v82 = *((unsigned __int16 *)v81 + 6);
        if (*((_WORD *)v81 + 6))
        {
          CFIndex v83 = v17;
          CFNumberRef v84 = (char *)v121 + 24 * i;
          *(_WORD *)int v141 = 0;
          *(_WORD *)int v119 = 0;
          bytes[0] = v84[16] & 0x3F | 0x80;
          CFDataAppendBytes(v79, bytes, 1);
          *(_WORD *)int v119 = bswap32(v82 - *((unsigned __int16 *)v84 + 7)) >> 16;
          CFDataAppendBytes(v79, v119, 2);
          uint64_t v85 = 0;
          uint64_t v86 = *(void *)v84;
          uint64_t v87 = v86 + 8;
          do
          {
            if (!v85
              || *(_DWORD *)(v87 - 8) != *(_DWORD *)(v86 + 32 * (v85 - 1))
              || *(_DWORD *)(v87 - 4) != *(_DWORD *)(v86 + 32 * (v85 - 1) + 4))
            {
              CFTypeRef v88 = *(const UInt8 **)v87;
              CFIndex v89 = *(void *)(v87 + 8);
              *(_WORD *)int v141 = bswap32(v89) >> 16;
              CFDataAppendBytes(v79, v141, 2);
              CFDataAppendBytes(v79, v88, v89);
            }
            ++v85;
            v87 += 32;
          }
          while (v82 != v85);
          CFDataRef v17 = v83;
        }
      }
      uint64_t v77 = 0;
      *a9 = v79;
      unsigned int v14 = v111;
LABEL_119:
      CFDataRef v22 = v106;
      goto LABEL_120;
    }
LABEL_134:
    uint64_t v91 = 4294954583;
LABEL_129:
    uint64_t ArrayOfSEINALUnitsFromJumboSEINALUnit = FigSignalErrorAt(v91, 0, 0, 0, 0, 0, 0);
LABEL_130:
    uint64_t v77 = ArrayOfSEINALUnitsFromJumboSEINALUnit;
    goto LABEL_120;
  }
  unint64_t v109 = a3;
  unsigned int v92 = a7;
  unint64_t v97 = 0;
  uint64_t v98 = 0;
  unsigned int v95 = 0;
  unsigned int v96 = 0;
  unint64_t v100 = 0;
  uint64_t v101 = 0;
  size_t v25 = 0;
  uint64_t v99 = 0;
  uint64_t v103 = 0;
  unint64_t v93 = 0;
  unint64_t v26 = 0;
  unsigned int v14 = 0;
  CFDataRef v22 = 0;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v104 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  int v94 = -1;
  uint64_t v102 = v12;
  while (2)
  {
    unint64_t v112 = 0;
    BytePtr = 0;
    BOOL v27 = v26 >= v18;
    unint64_t v28 = v26 - v18;
    if (v27)
    {
      uint64_t v32 = *(const UInt8 **)(a4 + 8 * v28);
      unint64_t v31 = *(void *)(v12 + 8 * v28);
      unint64_t v112 = v31;
      BytePtr = v32;
      CFArrayRef v33 = (char *)&v17[4 * v25];
      v33[24] = 0;
      *((void *)v33 + 1) = v32;
    }
    else
    {
      uint64_t ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridge_getHEVCParameterSetAtIndex(a2, 1, 0, v26, (unint64_t)&BytePtr, (unint64_t)&v112, 0, 0, 0, 0);
      if (ArrayOfSEINALUnitsFromJumboSEINALUnit) {
        goto LABEL_130;
      }
      uint64_t v30 = (char *)&v17[4 * v25];
      v30[24] = 1;
      *((void *)v30 + 1) = BytePtr;
      unint64_t v31 = v112;
    }
    v17[4 * v25 + 2] = v31;
    if (v112 >= 0x10000)
    {
LABEL_128:
      uint64_t v91 = 4294954584;
      goto LABEL_129;
    }
    if (!v112)
    {
      uint64_t v91 = 4294954584;
      goto LABEL_129;
    }
    if (!BytePtr)
    {
      uint64_t v91 = 4294954584;
      goto LABEL_129;
    }
    unint64_t v110 = v26;
    size_t v34 = v25;
    unint64_t v35 = ((unint64_t)*BytePtr >> 1) & 0x3F;
    switch((int)v35)
    {
      case ' ':
        uint64_t v147 = 0;
        long long v145 = 0u;
        long long v146 = 0u;
        long long v143 = 0u;
        long long v144 = 0u;
        *(_OWORD *)int v141 = 0u;
        long long v142 = 0u;
        uint64_t v140 = 0;
        long long v138 = 0u;
        long long v139 = 0u;
        long long v136 = 0u;
        long long v137 = 0u;
        long long v135 = 0u;
        long long v133 = 0u;
        memset(v134, 0, sizeof(v134));
        LODWORD(v120) = 0;
        memset(v119, 0, sizeof(v119));
        uint64_t ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v141, (uint64_t)BytePtr, v112, 1);
        if (ArrayOfSEINALUnitsFromJumboSEINALUnit) {
          goto LABEL_130;
        }
        LOBYTE(v134[0]) = 1;
        *(void *)&v134[1] = 49;
        v134[5] = 1048639;
        *(void *)bytes = v119;
        *(void *)&bytes[8] = hevcbridgeParseVPSForHVCCCallbackFlag;
        *(void *)&UInt8 bytes[16] = hevcbridgeParseVPSForHVCCCallbackUnsigned;
        uint64_t ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeParseNALUnit(v141, (uint64_t *)bytes);
        if (ArrayOfSEINALUnitsFromJumboSEINALUnit) {
          goto LABEL_130;
        }
        char v44 = BYTE1(v120);
        int v46 = *(_DWORD *)&v119[8];
        unsigned int v45 = *(_DWORD *)&v119[12];
        int v47 = *(_DWORD *)&v119[16];
        unsigned int v48 = *(_DWORD *)&v119[28];
        unint64_t v49 = *(unsigned int *)&v119[24] | ((unint64_t)*(unsigned int *)&v119[20] << 32);
        int v50 = *(_DWORD *)v119;
        int v51 = *(_DWORD *)&v119[4] + 1;
        char v52 = v120;
        if (!*((_WORD *)v121 + 12 * (int)v124 + 6)
          || *((_WORD *)v121 + 12 * (int)v124 + 6) == 1 && *((_DWORD *)v121 + 6 * (int)v124 + 2) == *(_DWORD *)v119)
        {
          char v53 = 0;
          *((unsigned char *)&v121[1] + 24 * (int)v124) = 32;
          LOBYTE(v101) = v44;
          HIDWORD(v101) = v46;
          *(_DWORD *)int v115 = v47;
          unint64_t v114 = v49;
          unint64_t v100 = __PAIR64__(v45, v48);
          LOBYTE(v98) = v52;
          HIDWORD(v98) = v51;
        }
        else
        {
          if (HIDWORD(v101) != *(_DWORD *)&v119[8]
            || BYTE1(v120) != v101
            || __PAIR64__(*(unsigned int *)v115, HIDWORD(v100)) != *(void *)&v119[12]
            || v114 != v49
            || v100 != *(_DWORD *)&v119[28]
            || HIDWORD(v98) != v51
            || v120 != v98)
          {
            goto LABEL_128;
          }
LABEL_71:
          char v53 = 0;
        }
        goto LABEL_87;
      case '!':
        uint64_t v147 = 0;
        long long v145 = 0u;
        long long v146 = 0u;
        long long v143 = 0u;
        long long v144 = 0u;
        *(_OWORD *)int v141 = 0u;
        long long v142 = 0u;
        uint64_t v140 = 0;
        long long v138 = 0u;
        long long v139 = 0u;
        long long v136 = 0u;
        long long v137 = 0u;
        long long v135 = 0u;
        long long v133 = 0u;
        memset(v134, 0, sizeof(v134));
        long long v120 = 0u;
        memset(v119, 0, sizeof(v119));
        uint64_t ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v141, (uint64_t)BytePtr, v112, 1);
        if (ArrayOfSEINALUnitsFromJumboSEINALUnit) {
          goto LABEL_130;
        }
        LOBYTE(v134[0]) = 3;
        *(void *)&v134[1] = 0x8000003F690;
        *(void *)&v134[3] = 17408;
        *(void *)bytes = v119;
        *(void *)&bytes[8] = hevcbridgeParseSPSForHVCCCallbackFlag;
        *(void *)&UInt8 bytes[16] = hevcbridgeParseSPSForHVCCCallbackUnsigned;
        uint64_t ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeParseNALUnit(v141, (uint64_t *)bytes);
        if (ArrayOfSEINALUnitsFromJumboSEINALUnit) {
          goto LABEL_130;
        }
        int v50 = *(_DWORD *)&v119[4];
        if (*(_DWORD *)v119) {
          goto LABEL_71;
        }
        unsigned int v54 = *(_DWORD *)&v119[8];
        if (*(_DWORD *)&v119[8] == 2)
        {
          int v56 = -1;
          int v55 = -2;
        }
        else if (*(_DWORD *)&v119[8] == 1)
        {
          int v55 = -2;
          int v56 = -2;
        }
        else
        {
          int v55 = -1;
          int v56 = -1;
        }
        unsigned int v65 = *(_DWORD *)&v119[12];
        unsigned int v64 = *(_DWORD *)&v119[16];
        unsigned int v66 = *(_DWORD *)&v119[20];
        uint64_t v67 = (*(_DWORD *)&v119[24] + (DWORD1(v120) + v120) * v55);
        uint64_t v68 = (*(_DWORD *)&v119[28] + (HIDWORD(v120) + DWORD2(v120)) * v56);
        if (!v99 || v99 == 1 && v94 == *(_DWORD *)&v119[4])
        {
          *((unsigned char *)&v121[1] + 24 * SHIDWORD(v124)) = 33;
          if (v92) {
            *unsigned int v92 = v67;
          }
          unint64_t v93 = __PAIR64__(v67, v68);
          if (a8) {
            *a8 = v68;
          }
          unsigned int v96 = v66;
          unint64_t v97 = __PAIR64__(v54, v65);
          unsigned int v95 = v64;
        }
        else if (v97 != __PAIR64__(*(unsigned int *)&v119[8], *(unsigned int *)&v119[12]) {
               || __PAIR64__(v96, v95) != *(void *)&v119[16]
        }
               || v93 != __PAIR64__(v67, v68))
        {
          goto LABEL_128;
        }
        char v53 = 0;
        ++v99;
        int v94 = v50;
        goto LABEL_87;
      case '""':
        uint64_t v147 = 0;
        long long v145 = 0u;
        long long v146 = 0u;
        long long v143 = 0u;
        long long v144 = 0u;
        *(_OWORD *)int v141 = 0u;
        long long v142 = 0u;
        uint64_t v140 = 0;
        long long v138 = 0u;
        long long v139 = 0u;
        long long v136 = 0u;
        long long v137 = 0u;
        long long v135 = 0u;
        long long v133 = 0u;
        memset(v134, 0, sizeof(v134));
        *(_OWORD *)&bytes[8] = 0u;
        *(_DWORD *)int v119 = 0;
        uint64_t ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v141, (uint64_t)BytePtr, v112, 1);
        if (ArrayOfSEINALUnitsFromJumboSEINALUnit) {
          goto LABEL_130;
        }
        LOBYTE(v134[0]) = 1;
        *(void *)&v134[3] = 0;
        *(void *)&v134[1] = 1;
        *(void *)bytes = v119;
        *(void *)&UInt8 bytes[16] = hevcbridgeParsePPSForHVCCCallbackUnsigned;
        uint64_t ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeParseNALUnit(v141, (uint64_t *)bytes);
        if (ArrayOfSEINALUnitsFromJumboSEINALUnit) {
          goto LABEL_130;
        }
        char v53 = 0;
        int v50 = *(_DWORD *)v119;
        goto LABEL_87;
      case '\'':
      case '(':
        if (v22) {
          CFRelease(v22);
        }
        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0;
        }
        CFDataRef v22 = CFDataCreateWithBytesNoCopy(allocator, BytePtr, v112, v104);
        uint64_t ArrayOfSEINALUnitsFromJumboSEINALUnit = FigHEVCBridge_CreateArrayOfSEINALUnitsFromJumboSEINALUnit(v22, (__CFArray **)&cf);
        if (ArrayOfSEINALUnitsFromJumboSEINALUnit) {
          goto LABEL_130;
        }
        if (!v14)
        {
          unsigned int v14 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
          if (!v14) {
            goto LABEL_134;
          }
        }
        CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
        CFIndex v37 = Count;
        if (Count < 2)
        {
          if (Count == 1)
          {
            CFDataRef v106 = v22;
LABEL_55:
            CFIndex v57 = 0;
            uint64_t v58 = 4 * v34;
            while (1)
            {
              CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v57);
              CFArrayAppendValue(v14, ValueAtIndex);
              if (v57) {
                LOBYTE(v17[v58 + 3]) = v17[v58 - 1];
              }
              BytePtr = CFDataGetBytePtr((CFDataRef)ValueAtIndex);
              CFIndex Length = CFDataGetLength((CFDataRef)ValueAtIndex);
              unint64_t v112 = Length;
              CFDictionaryRef v61 = (char *)&v17[v58];
              *((void *)v61 + 1) = BytePtr;
              *((void *)v61 + 2) = Length;
              uint64_t v147 = 0;
              long long v145 = 0u;
              long long v146 = 0u;
              long long v143 = 0u;
              long long v144 = 0u;
              *(_OWORD *)int v141 = 0u;
              long long v142 = 0u;
              uint64_t v140 = 0;
              long long v138 = 0u;
              long long v139 = 0u;
              long long v136 = 0u;
              long long v137 = 0u;
              long long v135 = 0u;
              long long v133 = 0u;
              memset(v134, 0, sizeof(v134));
              *(_OWORD *)&bytes[8] = 0u;
              *(_DWORD *)int v119 = 0;
              uint64_t v62 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v141, (uint64_t)BytePtr, v112, 1);
              if (v62) {
                break;
              }
              LOBYTE(v134[0]) = 1;
              LOBYTE(v134[1]) = 4;
              *(void *)bytes = v119;
              *(void *)&UInt8 bytes[16] = hevcbridgeParseSEIForHVCCCallbackUnsigned;
              uint64_t v62 = hevcbridgeParseNALUnit(v141, (uint64_t *)bytes);
              if (v62) {
                break;
              }
              int v50 = *(_DWORD *)v119;
              int v63 = &v17[v58];
              *int v63 = v35;
              v63[1] = v50;
              ++v57;
              v58 += 4;
              if (v37 == v57)
              {
                v34 += v57;
                char v53 = 1;
                CFDataRef v22 = v106;
                goto LABEL_63;
              }
            }
            uint64_t v77 = v62;
            goto LABEL_119;
          }
          int v50 = 0;
          char v53 = 1;
LABEL_63:
          uint64_t v12 = v102;
LABEL_87:
          uint64_t v69 = (char *)v121 + 24 * *((int *)v123 + v35);
          v69[16] = v35;
          ++*((_WORD *)v69 + 6);
          *((_DWORD *)v69 + 2) = v50;
          if (v53)
          {
            size_t v25 = v34;
          }
          else
          {
            long long v70 = &v17[4 * v34];
            *long long v70 = v35;
            v70[1] = v50;
            size_t v25 = v34 + 1;
          }
          unint64_t v26 = v110 + 1;
          unint64_t v18 = v117;
          if (v110 + 1 >= v117 + v109)
          {
            qsort(v17, v25, 0x20uLL, (int (__cdecl *)(const void *, const void *))FigHEVCBridge_sortParameterSetsByTypeThenIDThenBase);
            char v23 = 0;
            if (!v25)
            {
              CFIndex v24 = 23;
              char v19 = v98;
              char v20 = BYTE4(v98);
              char v21 = v95;
              goto LABEL_107;
            }
            uint64_t v71 = 0;
            CFIndex v24 = 23;
            long long v72 = (unsigned int *)v17;
            char v19 = v98;
            char v20 = BYTE4(v98);
            char v21 = v95;
            while (2)
            {
              uint64_t v73 = *v72;
              int v74 = *((_DWORD *)v123 + v73);
              int v75 = (void *)v121 + 3 * v74;
              if (*v75)
              {
                if (!v71) {
                  goto LABEL_100;
                }
              }
              else
              {
                *int v75 = v72;
                v24 += 3;
                ++v23;
                if (!v71) {
                  goto LABEL_100;
                }
              }
              if (v73 == *(v72 - 8) && v72[1] == *(v72 - 7)) {
                ++*((_WORD *)v121 + 12 * v74 + 7);
              }
              else {
LABEL_100:
              }
                v24 += *((void *)v72 + 2) + 2;
              ++v71;
              v72 += 8;
              if (v25 == v71) {
                goto LABEL_107;
              }
              continue;
            }
          }
          continue;
        }
        uint64_t v38 = v17;
        uint64_t v39 = v14;
        __int16 v40 = Count - 1;
        unint64_t v41 = Count - 1 + v103;
        if (v41 >= 0x10000)
        {
          uint64_t v77 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
          unsigned int v14 = v39;
          CFDataRef v17 = v38;
        }
        else
        {
          v103 += Count - 1;
          xpc_object_t v42 = malloc_type_realloc(v38, 32 * (v41 + v109 + v117), 0x10500408B07DF01uLL);
          if (v42)
          {
            CFDataRef v106 = v22;
            int v43 = (char *)v121 + 24 * *((int *)v123 + v35);
            *((_WORD *)v43 + 6) += v40;
            unsigned int v14 = v39;
            CFDataRef v17 = v42;
            goto LABEL_55;
          }
          free(v38);
          uint64_t v77 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          unsigned int v14 = v39;
          CFDataRef v17 = 0;
        }
LABEL_120:
        free(v17);
        if (v22) {
          CFRelease(v22);
        }
LABEL_122:
        if (cf) {
          CFRelease(cf);
        }
        if (v14) {
          CFRelease(v14);
        }
        return v77;
      default:
        goto LABEL_128;
    }
  }
}

uint64_t FigHEVCBridge_GetHEVCParameterSetAtIndex(const void *a1, int a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, _DWORD *a7)
{
  return hevcbridge_getHEVCParameterSetAtIndex(a1, 1, a2, a3, a4, a5, a6, a7, 0, 0);
}

uint64_t FigHEVCBridge_CreateArrayOfSEINALUnitsFromJumboSEINALUnit(const __CFData *a1, __CFArray **a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (theArray)
  {
    uint64_t v43 = 0;
    memset(v42, 0, sizeof(v42));
    BytePtr = CFDataGetBytePtr(a1);
    CFIndex Length = CFDataGetLength(a1);
    uint64_t v6 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v42, (uint64_t)BytePtr, Length, 1);
    if (!v6)
    {
      BYTE8(v34) |= 1u;
      BYTE12(v34) |= 1u;
      *(void *)&long long v32 = &theArray;
      *(void *)&long long v33 = hevcbridgeParseSEIForSplitterCallbackUnsigned;
      *(void *)&long long v34 = hevcbridgeParseSEIForSplitterCallbackCFData;
      uint64_t v6 = hevcbridgeParseNALUnit(v42, (uint64_t *)&v32);
      if (!v6)
      {
        uint64_t Count = CFArrayGetCount(theArray);
        CFMutableDictionaryRef Mutable = CFArrayCreateMutable(allocator, Count, MEMORY[0x1E4F1D510]);
        if (Mutable)
        {
          unint64_t v26 = a2;
          if (Count == 1)
          {
            CFArrayAppendValue(Mutable, a1);
LABEL_35:
            uint64_t v23 = 0;
            *unint64_t v26 = Mutable;
            goto LABEL_36;
          }
          if (Count < 1) {
            goto LABEL_35;
          }
          CFIndex v8 = 0;
          uint64_t v27 = Count;
          while (1)
          {
            CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(theArray, v8);
            UInt8 bytes = 0x80;
            if (CFDataGetLength(a1) <= 1) {
              break;
            }
            CFIndex v10 = CFDataGetLength(ValueAtIndex);
            unint64_t v11 = CFDataCreateMutable(allocator, 0);
            if (!v11)
            {
              uint64_t v24 = 4294954583;
              goto LABEL_32;
            }
            uint64_t v12 = v11;
            CFIndex v13 = v10 + 2;
            CFDataSetLength(v11, v10 + 2);
            MutableBytePtr = CFDataGetMutableBytePtr(v12);
            if (!MutableBytePtr)
            {
LABEL_29:
              uint64_t v23 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              CFRelease(v12);
              uint64_t Count = v27;
LABEL_33:
              if (v23)
              {
                CFRelease(Mutable);
                goto LABEL_36;
              }
              CFArrayAppendValue(Mutable, 0);
              goto LABEL_27;
            }
            uint64_t v15 = MutableBytePtr;
            CFDataRef v16 = CFDataGetBytePtr(ValueAtIndex);
            v46.CFIndex location = 0;
            v46.CFIndex length = 2;
            CFDataGetBytes(a1, v46, v15);
            if (v10 >= 1)
            {
              CFIndex v17 = 0;
              uint64_t v18 = 2;
              do
              {
                int v19 = v16[v17];
                if (v17 + 2 < v10 && v19 == 0)
                {
                  if (!v16[v17 + 1] && v16[v17 + 2] <= 3u)
                  {
                    CFDataSetLength(v12, ++v13);
                    char v21 = CFDataGetMutableBytePtr(v12);
                    if (!v21) {
                      goto LABEL_29;
                    }
                    uint64_t v15 = v21;
                    CFDataRef v22 = &v21[v18];
                    *CFDataRef v22 = v16[v17];
                    v18 += 2;
                    v22[1] = v16[v17 + 1];
                    v21[v18] = 3;
                    ++v17;
                    goto LABEL_25;
                  }
                  LOBYTE(v19) = 0;
                }
                v15[v18] = v19;
LABEL_25:
                ++v18;
                ++v17;
              }
              while (v17 < v10);
            }
            CFDataAppendBytes(v12, &bytes, 1);
            CFArrayAppendValue(Mutable, v12);
            CFRelease(v12);
            uint64_t Count = v27;
LABEL_27:
            if (++v8 == Count) {
              goto LABEL_35;
            }
          }
          uint64_t v24 = 4294954584;
LABEL_32:
          uint64_t v23 = FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
          goto LABEL_33;
        }
        uint64_t v6 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
      }
    }
    uint64_t v23 = v6;
LABEL_36:
    if (theArray) {
      CFRelease(theArray);
    }
    return v23;
  }
  else
  {
    return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigHEVCBridge_sortParameterSetsByTypeThenIDThenBase(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 < *(_DWORD *)a2) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 > *(_DWORD *)a2) {
    return 1;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 4);
  unsigned int v4 = *(_DWORD *)(a2 + 4);
  if (v3 < v4) {
    return 0xFFFFFFFFLL;
  }
  if (v3 > v4) {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 24))
  {
    if (!*(unsigned char *)(a2 + 24)) {
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  return !*(unsigned char *)(a2 + 24);
}

uint64_t hevcbridge_getHEVCParameterSetAtIndex(CFTypeRef cf, int a2, int a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, _DWORD *a8, uint64_t a9, uint64_t a10)
{
  if (a5) {
    *(void *)a5 = 0;
  }
  if (a6) {
    *(void *)a6 = 0;
  }
  if (a7) {
    *(void *)a7 = 0;
  }
  if (a8) {
    *a8 = 0;
  }
  if (cf)
  {
    CFTypeID v16 = CFGetTypeID(cf);
    if (v16 == CFDataGetTypeID())
    {
      CFIndex Length = CFDataGetLength((CFDataRef)cf);
      BytePtr = CFDataGetBytePtr((CFDataRef)cf);
      uint64_t v19 = 22;
      if (!a2) {
        uint64_t v19 = 5;
      }
      if (Length > v19)
      {
        char v20 = BytePtr;
        if (*BytePtr == 1)
        {
          if (a8)
          {
            uint64_t v21 = 21;
            if (!a2) {
              uint64_t v21 = 4;
            }
            *a8 = (BytePtr[v21] & 3) + 1;
            if (!a7 && !a5 && !a6 && !a9) {
              return 0;
            }
          }
          int v36 = BytePtr[v19];
          if (BytePtr[v19])
          {
            int v22 = 0;
            unint64_t v23 = 0;
            uint64_t v24 = 0;
            uint64_t v25 = v19 + 1;
            while (1)
            {
              int v40 = v22;
              unint64_t v41 = v23;
              uint64_t v26 = v25 + 3;
              if (Length < v25 + 3) {
                goto LABEL_56;
              }
              uint64_t v27 = &v20[v25];
              uint64_t v28 = __rev16(*(unsigned __int16 *)(v27 + 1));
              if (a3) {
                BOOL v29 = (*v27 & 0x3F) == a3;
              }
              else {
                BOOL v29 = 1;
              }
              uint64_t v30 = v29;
              if (v29) {
                uint64_t v31 = v28;
              }
              else {
                uint64_t v31 = 0;
              }
              for (uint64_t i = v31; v28; LODWORD(v28) = v28 - 1)
              {
                uint64_t v32 = v26 + 2;
                if (Length < v26 + 2) {
                  goto LABEL_56;
                }
                uint64_t v33 = __rev16(*(unsigned __int16 *)&v20[v26]);
                uint64_t v26 = v33 + v32;
                if (Length < v33 + v32) {
                  goto LABEL_56;
                }
                if (a4 == v24) {
                  int v34 = v30;
                }
                else {
                  int v34 = 0;
                }
                if (v34 == 1)
                {
                  if (a5) {
                    *(void *)a5 = &v20[v32];
                  }
                  if (a6) {
                    *(void *)a6 = v33;
                  }
                  if (!(a7 | a9)) {
                    return 0;
                  }
                }
                if (a9) {
                  ((void (*)(uint64_t, uint64_t, const UInt8 *))a9)(a10, v24, &v20[v32]);
                }
                v24 += v30;
              }
              unint64_t v23 = i + v41;
              int v22 = v40 + 1;
              uint64_t v25 = v26;
              if (v40 + 1 == v36) {
                goto LABEL_52;
              }
            }
          }
          unint64_t v23 = 0;
LABEL_52:
          if (a7) {
            *(void *)a7 = v23;
          }
          if (!(a5 | a6) || v23 > a4) {
            return 0;
          }
        }
      }
    }
  }
LABEL_56:

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_VisitAllHEVCParameterSets(const void *a1, int a2, unint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  return hevcbridge_getHEVCParameterSetAtIndex(a1, 1, a2, 0, 0, 0, a3, a4, a5, a6);
}

uint64_t FigHEVCBridge_GetHEVCParameterSetFromLHVCAtIndex(const void *a1, int a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, _DWORD *a7)
{
  return hevcbridge_getHEVCParameterSetAtIndex(a1, 0, a2, a3, a4, a5, a6, a7, 0, 0);
}

uint64_t FigHEVCBridge_CopyHEVCSEIPayloadData(CFTypeRef cf, __int16 a2, CFTypeRef *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  CFTypeRef cfa = 0;
  int v6 = 39;
  while (1)
  {
    unint64_t v13 = 0;
    uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(cf, 1, v6, 0, 0, 0, (unint64_t)&v13, 0, 0, 0);
    if (HEVCParameterSetAtIndex) {
      break;
    }
    if (v13)
    {
      unint64_t v8 = 0;
      do
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(cf, 1, v6, v8, (unint64_t)&v12, (unint64_t)&v11, 0, 0, 0, 0);
        if (HEVCParameterSetAtIndex) {
          goto LABEL_16;
        }
        uint64_t v28 = 0;
        memset(v27, 0, sizeof(v27));
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        LOWORD(v14) = a2;
        uint64_t v15 = &v17;
        CFTypeRef cfa = 0;
        uint64_t HEVCParameterSetAtIndex = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v27, v12, v11, 1);
        if (HEVCParameterSetAtIndex) {
          goto LABEL_16;
        }
        BYTE8(v19) |= 1u;
        BYTE12(v19) = BYTE12(v19) & 0xCB | 4;
        *(void *)&long long v17 = &v14;
        *(void *)&long long v18 = hevcbridgeParseSEITypeCallbackUnsigned;
        uint64_t HEVCParameterSetAtIndex = hevcbridgeParseNALUnit(v27, (uint64_t *)&v17);
        if (HEVCParameterSetAtIndex) {
          goto LABEL_16;
        }
        if (cfa)
        {
          uint64_t v9 = 0;
          *a3 = cfa;
          CFTypeRef cfa = 0;
          goto LABEL_13;
        }
      }
      while (++v8 < v13);
    }
    if (++v6 == 41)
    {
      uint64_t v9 = 0;
      *a3 = 0;
      goto LABEL_13;
    }
  }
LABEL_16:
  uint64_t v9 = HEVCParameterSetAtIndex;
LABEL_13:
  if (cfa) {
    CFRelease(cfa);
  }
  return v9;
}

uint64_t hevcbridgeParseSEITypeCallbackUnsigned(unsigned __int16 *a1, int a2, int a3)
{
  if (a2 == 344)
  {
    if (*a1 == a3) {
      unsigned int v4 = hevcbridgeParseSEIPayloadData;
    }
    else {
      unsigned int v4 = 0;
    }
    *(unsigned char *)(*((void *)a1 + 1) + 44) = *(unsigned char *)(*((void *)a1 + 1) + 44) & 0xDF | (32 * (*a1 == a3));
    *(void *)(*((void *)a1 + 1) + 32) = v4;
  }
  else if (a2 || (a3 - 41) < 0xFFFFFFFE)
  {
    return 4294954584;
  }
  return 0;
}

uint64_t FigHEVCBridge_GetATCSEI(const void *a1, UInt8 *a2)
{
  CFTypeRef cf = 0;
  if (a2)
  {
    uint64_t v3 = FigHEVCBridge_CopyHEVCSEIPayloadData(a1, 147, &cf);
    CFDataRef v4 = (const __CFData *)cf;
    if (v3)
    {
      uint64_t v6 = v3;
      if (!cf) {
        return v6;
      }
    }
    else
    {
      if (!cf) {
        return 4294954578;
      }
      CFTypeID v5 = CFGetTypeID(cf);
      if (v5 == CFDataGetTypeID() && CFDataGetLength(v4) == 1)
      {
        v10.CFIndex location = 0;
        v10.CFIndex length = 1;
        CFDataGetBytes(v4, v10, a2);
        uint64_t v6 = 0;
      }
      else
      {
        uint64_t v6 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
      }
    }
    CFRelease(v4);
    return v6;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t hevcbridgeParseSEIForSplitterCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if ((a3 - 41) >= 0xFFFFFFFE) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = -12712;
  }
  if (a2) {
    return 4294954584;
  }
  else {
    return v3;
  }
}

uint64_t hevcbridgeParseSEIForSplitterCallbackCFData(CFMutableArrayRef *a1, int a2, void *value)
{
  if (a2 != 342) {
    return 4294954584;
  }
  CFArrayAppendValue(*a1, value);
  return 0;
}

uint64_t FigHEVCBridge_GetNALUnitHeaderLengthFromHVCC(const __CFData *a1, void *a2)
{
  BytePtr = CFDataGetBytePtr(a1);
  if ((unint64_t)CFDataGetLength(a1) < 0x16) {
    return 4294954582;
  }
  uint64_t v5 = BytePtr[21] & 3;
  *a2 = v5 + 1;
  if (v5 < 2 || v5 == 3) {
    return 0;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CreateHVCCFromHEVCParameterSets(int a1, unint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, void *a6, void *a7, __CFData **a8)
{
  return FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets(a1, 0, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t FigHEVCBridge_CreateSelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord(const __CFData *a1, int a2, const __CFArray *a3, const __CFArray *a4, __CFData **a5)
{
  if (a1
    && (CFTypeID v10 = CFGetTypeID(a1), v10 == CFDataGetTypeID())
    && a3
    && CFArrayGetCount(a3) > 0
    && (!a4 || (CFIndex Count = CFArrayGetCount(a4), Count == CFArrayGetCount(a3))))
  {
    CFDataRef MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a1);
    if (MutableCopy)
    {
      unint64_t v13 = MutableCopy;
      CFArrayRef v52 = a3;
      CFIndex Length = CFDataGetLength(MutableCopy);
      MutableBytePtr = CFDataGetMutableBytePtr(v13);
      CFTypeID v16 = MutableBytePtr;
      CFArrayRef theArray = a4;
      unint64_t v41 = a5;
      if (a2)
      {
        if (Length > 5 && *MutableBytePtr == 1)
        {
          uint64_t v17 = 5;
LABEL_19:
          CFIndex v43 = v17;
          int v47 = MutableBytePtr[v17];
          if (!MutableBytePtr[v17])
          {
LABEL_45:
            uint64_t v39 = 0;
            unsigned char *v41 = v13;
            return v39;
          }
          int v48 = 0;
          int v20 = 0;
          uint64_t v21 = v17 + 1;
          while (1)
          {
            CFIndex v22 = v21 + 3;
            if (Length < v21 + 3) {
              break;
            }
            int v42 = v20;
            CFIndex range_8 = v21 + 1;
            unsigned int v23 = __rev16(*(unsigned __int16 *)&v16[v21 + 1]);
            if (v23)
            {
              unsigned int v50 = v23;
              int v51 = 0;
              CFIndex range = v21;
              uint64_t v24 = v16[v21] & 0x3F;
              unsigned int v44 = v24 - 33;
              while (1)
              {
                CFIndex v25 = v22 + 2;
                if (Length < v22 + 2) {
                  goto LABEL_46;
                }
                uint64_t v26 = __rev16(*(unsigned __int16 *)&v16[v22]);
                if (Length < v25 + v26
                  || v26 <= 1
                  || (char)v16[v25] < 0
                  || ((v16[v25] >> 1) & 0x3F) != v24)
                {
                  goto LABEL_46;
                }
                uint64_t v27 = v16;
                unsigned int v28 = v16[v22 + 3] | (v16[v25] << 8);
                int v55 = 0;
                uint64_t v29 = v24;
                int v30 = FigCFArrayContainsInt32(v52, (v28 >> 3) & 0x3F);
                uint64_t v24 = v29;
                if (v29 != 32 && !v30)
                {
                  v57.CFIndex length = v26 + 2;
                  v57.CFIndex location = v22;
                  CFDataDeleteBytes(v13, v57);
                  int v31 = v51 + 1;
                  if (v50 == (unsigned __int16)++v51)
                  {
                    v58.CFIndex location = range;
                    v58.CFIndex length = 3;
                    CFDataDeleteBytes(v13, v58);
                    char v54 = v47 - ++v48;
                    long long v35 = (UInt8 *)&v54;
                    int v36 = v13;
                    v37.CFIndex location = v43;
                    v37.CFIndex length = 1;
                    CFIndex v38 = 1;
                  }
                  else
                  {
                    *(_WORD *)newBytes = bswap32(v50 - v31) >> 16;
                    long long v35 = newBytes;
                    int v36 = v13;
                    v37.CFIndex location = range_8;
                    v37.CFIndex length = 2;
                    CFIndex v38 = 2;
                  }
                  CFDataReplaceBytes(v36, v37, v35, v38);
                  CFTypeID v16 = CFDataGetMutableBytePtr(v13);
                  CFIndex Length = CFDataGetLength(v13);
                  uint64_t v24 = v29;
                  goto LABEL_43;
                }
                if (!theArray) {
                  break;
                }
                if (CFArrayGetCount(theArray) < 1
                  || v44 > 1
                  || (CFIndex FirstIndexOfInt32 = FigCFArrayGetFirstIndexOfInt32(v52, (v28 >> 3) & 0x3F), FirstIndexOfInt32 == -1))
                {
                  CFIndex v22 = v25 + v26;
                  uint64_t v24 = v29;
LABEL_42:
                  CFTypeID v16 = v27;
                  goto LABEL_43;
                }
                FigCFArrayGetInt32AtIndex(theArray, FirstIndexOfInt32, &v55);
                __int16 v34 = (8 * (v55 & 0x1FFF)) | v28 & 0xFE07;
                CFTypeID v16 = v27;
                v27[v25] = HIBYTE(v34);
                v27[v22 + 3] = v34;
                CFIndex v22 = v25 + v26;
                uint64_t v24 = v29;
LABEL_43:
                if (!--v23) {
                  goto LABEL_44;
                }
              }
              CFIndex v22 = v25 + v26;
              goto LABEL_42;
            }
LABEL_44:
            int v20 = v42 + 1;
            uint64_t v21 = v22;
            if (v42 + 1 == v47) {
              goto LABEL_45;
            }
          }
LABEL_46:
          uint64_t v40 = 4294954582;
LABEL_47:
          uint64_t v39 = FigSignalErrorAt(v40, 0, 0, 0, 0, 0, 0);
          CFRelease(v13);
          return v39;
        }
      }
      else if (Length > 22 && *MutableBytePtr == 1)
      {
        uint64_t v17 = 22;
        goto LABEL_19;
      }
      uint64_t v40 = 4294954581;
      goto LABEL_47;
    }
    uint64_t v18 = 4294954583;
  }
  else
  {
    uint64_t v18 = 4294954584;
  }

  return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CreateSelectedLayerHVCCFromMuxedAlphaHVCC(const __CFData *a1, int a2, __CFData **a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFArrayRef v8 = Mutable;
    FigCFArrayAppendInt32(Mutable, a2);
    if (a2)
    {
      CFMutableArrayRef v9 = CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510]);
      if (!v9)
      {
        uint64_t SelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        CFArrayRef v12 = v8;
        goto LABEL_8;
      }
      CFArrayRef v10 = v9;
      FigCFArrayAppendInt32(v9, 0);
    }
    else
    {
      CFArrayRef v10 = 0;
    }
    uint64_t SelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord = FigHEVCBridge_CreateSelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord(a1, 0, v8, v10, a3);
    CFRelease(v8);
    if (!v10) {
      return SelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord;
    }
    CFArrayRef v12 = v10;
LABEL_8:
    CFRelease(v12);
    return SelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord;
  }

  return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CreateSelectedLayerFormatDescriptionFromMuxedAlphaFormatDescription(const opaqueCMFormatDescription *a1, int a2, CMVideoFormatDescriptionRef *a3)
{
  v44[1] = *(const UInt8 **)MEMORY[0x1E4F143B8];
  CFDataRef theData = 0;
  if (a1)
  {
    FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
    if (MediaSubType == 1836415073) {
      CMVideoCodecType v7 = 1752589105;
    }
    else {
      CMVideoCodecType v7 = MediaSubType;
    }
    CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
    CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
    if (Extensions
      && (CFDictionaryRef v10 = Extensions,
          (CFDictionaryRef v11 = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms")) != 0)
      && (CFDictionaryRef v12 = v11, (v13 = (const __CFData *)CFDictionaryGetValue(v11, @"hvcC")) != 0)
      && (v14 = v13, CFTypeID v15 = CFGetTypeID(v13), v15 == CFDataGetTypeID()))
    {
      CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v10);
      if (MutableCopy)
      {
        CFMutableDictionaryRef v18 = MutableCopy;
        CFMutableDictionaryRef v19 = CFDictionaryCreateMutableCopy(v16, 0, v12);
        if (!v19)
        {
          uint64_t v33 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          CFRelease(v18);
          return v33;
        }
        CFMutableDictionaryRef v20 = v19;
        FigHEVCBridge_CreateSelectedLayerHVCCFromMuxedAlphaHVCC(v14, a2, &theData);
        CFDataRef v21 = theData;
        if (theData)
        {
          CFMutableDataRef v22 = 0;
          goto LABEL_28;
        }
        uint64_t v42 = 0;
        CFIndex v43 = 0;
        v44[0] = 0;
        uint64_t v39 = 0;
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        uint64_t v38 = 0;
        uint64_t v34 = 0;
        uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(v14, 1, 32, 0, (unint64_t)&v42, (unint64_t)&v39, (unint64_t)&v36, (_DWORD *)&v34 + 1, 0, 0);
        if (!HEVCParameterSetAtIndex)
        {
          if (v36 != 1)
          {
            uint64_t v26 = 4294954584;
            goto LABEL_45;
          }
          CFArrayRef Value = CFDictionaryGetValue(v12, @"lhvC");
          if (!Value)
          {
LABEL_43:
            uint64_t v26 = 4294954583;
LABEL_45:
            uint64_t HEVCParameterSetAtIndex = FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
            goto LABEL_46;
          }
          CFIndex v25 = Value;
          uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetWithNuhLayerID(Value, 33, (unsigned __int16)a2, &v43, &v40, &v37, &v34);
          if (!HEVCParameterSetAtIndex)
          {
            uint64_t v26 = 4294954584;
            if (HIDWORD(v34) != v34 || v37 != 1) {
              goto LABEL_45;
            }
            uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetWithNuhLayerID(v25, 34, (unsigned __int16)a2, v44, &v41, &v38, &v34);
            if (!HEVCParameterSetAtIndex)
            {
              uint64_t v26 = 4294954584;
              if (HIDWORD(v34) != v34 || v38 != 1) {
                goto LABEL_45;
              }
              uint64_t HEVCParameterSetAtIndex = FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets(-12712, 0, 3uLL, (uint64_t)&v42, (uint64_t)&v39, HIDWORD(v34), 0, 0, &theData);
              if (!HEVCParameterSetAtIndex)
              {
                CFMutableDataRef v27 = CFDataCreateMutableCopy(v16, 0, theData);
                if (v27)
                {
                  CFMutableDataRef v22 = v27;
                  uint64_t updated = hevcbridge_updateConfigRecordNuhLayerID(v27, 0, 0);
                  if (updated)
                  {
LABEL_29:
                    uint64_t v30 = updated;
LABEL_30:
                    CFRelease(v18);
                    CFRelease(v20);
                    if (theData) {
                      CFRelease(theData);
                    }
                    if (v22) {
                      CFRelease(v22);
                    }
                    return v30;
                  }
                  CFDataRef v29 = theData;
                  CFDataRef theData = v22;
                  CFRetain(v22);
                  if (v29) {
                    CFRelease(v29);
                  }
                  CFDataRef v21 = theData;
LABEL_28:
                  CFDictionarySetValue(v20, @"hvcC", v21);
                  CFDictionarySetValue(v18, @"SampleDescriptionExtensionAtoms", v20);
                  CFDictionaryRemoveValue(v18, @"VerbatimSampleDescription");
                  CFDictionaryRemoveValue(v18, @"VerbatimISOSampleEntry");
                  CFDictionaryRemoveValue(v18, @"ContainsAlphaChannel");
                  CFDictionarySetValue(v18, @"IgnoreVPSExtension", (const void *)*MEMORY[0x1E4F1CFD0]);
                  uint64_t updated = CMVideoFormatDescriptionCreate(v16, v7, Dimensions.width, Dimensions.height, v18, a3);
                  goto LABEL_29;
                }
                goto LABEL_43;
              }
            }
          }
        }
LABEL_46:
        uint64_t v30 = HEVCParameterSetAtIndex;
        CFMutableDataRef v22 = 0;
        goto LABEL_30;
      }
      uint64_t v32 = 4294954583;
    }
    else
    {
      uint64_t v32 = 4294954581;
    }
  }
  else
  {
    uint64_t v32 = 4294954584;
  }

  return FigSignalErrorAt(v32, 0, 0, 0, 0, 0, 0);
}

uint64_t hevcbridge_getHEVCParameterSetWithNuhLayerID(CFTypeRef cf, int a2, int a3, const UInt8 **a4, void *a5, void *a6, _DWORD *a7)
{
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  if (a6) {
    *a6 = 0;
  }
  if (a7) {
    *a7 = 0;
  }
  if (cf)
  {
    CFTypeID v14 = CFGetTypeID(cf);
    if (v14 == CFDataGetTypeID())
    {
      CFIndex Length = CFDataGetLength((CFDataRef)cf);
      BytePtr = CFDataGetBytePtr((CFDataRef)cf);
      if (Length > 5 && *BytePtr == 1)
      {
        if (!a7 || (*a7 = (BytePtr[4] & 3) + 1, a4) || a5 || a6)
        {
          int v17 = BytePtr[5];
          if (BytePtr[5])
          {
            int v18 = 0;
            uint64_t v19 = 0;
            uint64_t v20 = 6;
            while (1)
            {
              uint64_t v21 = v20 + 3;
              if (Length < v20 + 3) {
                goto LABEL_41;
              }
              CFMutableDataRef v22 = &BytePtr[v20];
              unsigned int v23 = __rev16(*(unsigned __int16 *)(v22 + 1));
              if (v23)
              {
                int v24 = *v22 & 0x3F;
                while (1)
                {
                  uint64_t v25 = v21 + 2;
                  if (Length < v21 + 2) {
                    goto LABEL_41;
                  }
                  uint64_t v26 = __rev16(*(unsigned __int16 *)&BytePtr[v21]);
                  uint64_t v20 = v26 + v25;
                  if (Length < v26 + v25) {
                    goto LABEL_41;
                  }
                  if (v24 == a2)
                  {
                    CFMutableDataRef v27 = &BytePtr[v25];
                    if ((((BytePtr[v21 + 3] | (*v27 << 8)) >> 3) & 0x3F) == a3)
                    {
                      if (a4) {
                        *a4 = v27;
                      }
                      if (a5) {
                        *a5 = v26;
                      }
                      if (!a6) {
                        return 0;
                      }
                      ++v19;
                    }
                  }
                  uint64_t v21 = v20;
                  if (!--v23) {
                    goto LABEL_35;
                  }
                }
              }
              uint64_t v20 = v21;
LABEL_35:
              if (++v18 == v17)
              {
                if (!a6) {
                  return 0;
                }
                goto LABEL_37;
              }
            }
          }
          uint64_t v19 = 0;
          if (a6) {
LABEL_37:
          }
            *a6 = v19;
        }
        return 0;
      }
    }
  }
LABEL_41:

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t hevcbridge_updateConfigRecordNuhLayerID(void *a1, int a2, __int16 a3)
{
  if (!a1 || (CFTypeID v6 = CFGetTypeID(a1), v6 != CFDataGetTypeID()))
  {
    uint64_t v22 = 4294954584;
    goto LABEL_29;
  }
  CFIndex Length = CFDataGetLength((CFDataRef)a1);
  MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)a1);
  if (!a2)
  {
    if (Length >= 23 && *MutableBytePtr == 1)
    {
      uint64_t v9 = 22;
      goto LABEL_10;
    }
LABEL_33:
    uint64_t v22 = 4294954581;
    goto LABEL_29;
  }
  if (Length < 6 || *MutableBytePtr != 1) {
    goto LABEL_33;
  }
  uint64_t v9 = 5;
LABEL_10:
  int v10 = MutableBytePtr[v9];
  if (!MutableBytePtr[v9]) {
    return 0;
  }
  int v11 = 0;
  uint64_t v12 = v9 + 1;
  while (1)
  {
    uint64_t v13 = v12 + 3;
    if (Length < v12 + 3) {
      break;
    }
    unsigned int v14 = __rev16(*(unsigned __int16 *)&MutableBytePtr[v12 + 1]);
    if (v14)
    {
      int v15 = MutableBytePtr[v12] & 0x3F;
      while (1)
      {
        uint64_t v16 = v13 + 2;
        if (Length < v13 + 2) {
          goto LABEL_28;
        }
        uint64_t v17 = __rev16(*(unsigned __int16 *)&MutableBytePtr[v13]);
        uint64_t v12 = v16 + v17;
        BOOL v18 = Length >= v16 + v17 && v17 >= 2;
        if (!v18 || (char)MutableBytePtr[v16] < 0 || ((MutableBytePtr[v16] >> 1) & 0x3F) != v15) {
          goto LABEL_28;
        }
        uint64_t v19 = v13 + 3;
        __int16 v20 = MutableBytePtr[v19] & 7 | (MutableBytePtr[v16] << 8) & 0xFE07 | (8 * (a3 & 0x1FFF));
        MutableBytePtr[v16] = HIBYTE(v20);
        MutableBytePtr[v19] = v20;
        uint64_t v13 = v12;
        if (!--v14) {
          goto LABEL_26;
        }
      }
    }
    v12 += 3;
LABEL_26:
    if (++v11 == v10) {
      return 0;
    }
  }
LABEL_28:
  uint64_t v22 = 4294954582;
LABEL_29:

  return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CreateFormatDescriptionWithSelectedLayersFromMultiviewMuxedAlphaFormatDescription(const opaqueCMFormatDescription *a1, CFArrayRef theArray, const __CFArray *a3, CMVideoFormatDescriptionRef *a4)
{
  v52[1] = *(const UInt8 **)MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  CFDataRef theData = 0;
  int v41 = 0;
  if (!a1
    || !theArray
    || CFArrayGetCount(theArray) <= 0
    || a3 && (CFIndex Count = CFArrayGetCount(a3), Count != CFArrayGetCount(theArray)))
  {
    uint64_t v34 = 4294954584;
LABEL_36:
    uint64_t v33 = FigSignalErrorAt(v34, 0, 0, 0, 0, 0, 0);
LABEL_37:
    CFDataRef v26 = 0;
    goto LABEL_38;
  }
  FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions) {
    goto LABEL_43;
  }
  CFDictionaryRef v12 = Extensions;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms");
  if (!Value) {
    goto LABEL_43;
  }
  CFDictionaryRef v14 = Value;
  CFDataRef v15 = (const __CFData *)CFDictionaryGetValue(Value, @"hvcC");
  if (!v15
    || (CFDataRef v16 = v15, v17 = CFGetTypeID(v15), v17 != CFDataGetTypeID())
    || (codecType = MediaSubType, (BOOL v18 = CFDictionaryGetValue(v14, @"lhvC")) == 0)
    || (v19 = v18, CFTypeID v20 = CFGetTypeID(v18), v20 != CFDataGetTypeID()))
  {
LABEL_43:
    uint64_t v34 = 4294954581;
    goto LABEL_36;
  }
  CMVideoFormatDescriptionRef formatDescriptionOut = a4;
  CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v12);
  if (!MutableCopy)
  {
    uint64_t v34 = 4294954583;
    goto LABEL_36;
  }
  CFMutableDictionaryRef v23 = MutableCopy;
  CFMutableDictionaryRef v24 = CFDictionaryCreateMutableCopy(v21, 0, v14);
  if (!v24)
  {
    uint64_t v33 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    CFRelease(v23);
    goto LABEL_37;
  }
  uint64_t v25 = v24;
  FigCFArrayGetInt16AtIndex(theArray, 0, (char *)&v41 + 2);
  FigCFArrayGetInt16AtIndex(a3, 0, &v41);
  FigHEVCBridge_CreateSelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord(v16, 0, theArray, a3, &theData);
  CFDataRef v26 = 0;
  if (theData) {
    goto LABEL_28;
  }
  uint64_t v50 = 0;
  int v51 = 0;
  v52[0] = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  int v39 = 0;
  unsigned int v40 = 0;
  uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(v16, 1, 32, 0, (unint64_t)&v50, (unint64_t)&v47, (unint64_t)&v44, &v40, 0, 0);
  if (!HEVCParameterSetAtIndex)
  {
    if (v44 != 1) {
      goto LABEL_45;
    }
    uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetWithNuhLayerID(v19, 33, HIWORD(v41), &v51, &v48, &v45, &v39);
    if (HEVCParameterSetAtIndex) {
      goto LABEL_47;
    }
    if (v45 != 1 || v40 != v39) {
      goto LABEL_45;
    }
    uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetWithNuhLayerID(v19, 34, HIWORD(v41), v52, &v49, &v46, &v39);
    if (HEVCParameterSetAtIndex) {
      goto LABEL_47;
    }
    if (v46 != 1 || v40 != v39)
    {
LABEL_45:
      uint64_t v36 = 4294954584;
LABEL_46:
      uint64_t HEVCParameterSetAtIndex = FigSignalErrorAt(v36, 0, 0, 0, 0, 0, 0);
      goto LABEL_47;
    }
    uint64_t HEVCParameterSetAtIndex = FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets(0, 0, 3uLL, (uint64_t)&v50, (uint64_t)&v47, v40, 0, 0, &theData);
    if (!HEVCParameterSetAtIndex)
    {
      CFMutableDataRef v28 = CFDataCreateMutableCopy(v21, 0, theData);
      if (v28)
      {
        CFDataRef v26 = v28;
        uint64_t updated = hevcbridge_updateConfigRecordNuhLayerID(v28, 0, v41);
        if (updated)
        {
LABEL_32:
          uint64_t v33 = updated;
          goto LABEL_33;
        }
        CFDataRef v30 = theData;
        CFDataRef theData = v26;
        CFRetain(v26);
        if (v30) {
          CFRelease(v30);
        }
LABEL_28:
        uint64_t updated = FigHEVCBridge_CreateSelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord((const __CFData *)v19, 1, theArray, a3, (__CFData **)&cf);
        if (!updated)
        {
          CFTypeRef v31 = cf;
          if (cf && (CFTypeID v32 = CFGetTypeID(cf), v32 == CFDataGetTypeID()))
          {
            CFDictionarySetValue(v25, @"hvcC", theData);
            CFDictionarySetValue(v25, @"lhvC", v31);
            CFDictionarySetValue(v23, @"SampleDescriptionExtensionAtoms", v25);
            CFDictionaryRemoveValue(v23, @"VerbatimSampleDescription");
            CFDictionaryRemoveValue(v23, @"VerbatimISOSampleEntry");
            CFDictionaryRemoveValue(v23, @"ContainsAlphaChannel");
            uint64_t updated = CMVideoFormatDescriptionCreate(v21, codecType, Dimensions.width, Dimensions.height, v23, formatDescriptionOut);
          }
          else
          {
            uint64_t updated = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
          }
        }
        goto LABEL_32;
      }
      uint64_t v36 = 4294954583;
      goto LABEL_46;
    }
  }
LABEL_47:
  uint64_t v33 = HEVCParameterSetAtIndex;
  CFDataRef v26 = 0;
LABEL_33:
  CFRelease(v23);
  CFRelease(v25);
  if (theData) {
    CFRelease(theData);
  }
LABEL_38:
  if (cf) {
    CFRelease(cf);
  }
  if (v26) {
    CFRelease(v26);
  }
  return v33;
}

uint64_t FigHEVCBridge_ParseMuxedAlphaFrameAndWriteSelectedLayerNALUnitsToBuffer(OpaqueCMBlockBuffer *a1, unsigned int a2, void *a3, uint64_t a4, size_t a5)
{
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2);
  if (values)
  {
    CFArrayRef v11 = CFArrayCreate(v10, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    if (v11)
    {
      if (!a2)
      {
        CFArrayRef v12 = 0;
        goto LABEL_10;
      }
      if (values)
      {
        CFRelease(values);
        values = 0;
      }
      values = FigCFNumberCreateUInt32(v10, 0);
      if (values)
      {
        CFArrayRef v12 = CFArrayCreate(v10, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
        if (!v12)
        {
          uint64_t v13 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_11:
          uint64_t v14 = v13;
LABEL_12:
          if (values) {
            CFRelease(values);
          }
          if (v11) {
            CFRelease(v11);
          }
          if (v12) {
            CFRelease(v12);
          }
          return v14;
        }
LABEL_10:
        uint64_t v13 = FigHEVCBridge_ParseMuxedAlphaFrameAndWriteSelectedLayerIDsNALUnitsToBuffer(a1, v11, v12, a3, a4, a5);
        goto LABEL_11;
      }
    }
    uint64_t v14 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    CFArrayRef v12 = 0;
    goto LABEL_12;
  }

  return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_ParseMuxedAlphaFrameAndWriteSelectedLayerIDsNALUnitsToBuffer(OpaqueCMBlockBuffer *a1, CFArrayRef theArray, const __CFArray *a3, void *a4, uint64_t a5, size_t a6)
{
  if (a1
    && theArray
    && CFArrayGetCount(theArray) > 0
    && (!a3 || (CFIndex Count = CFArrayGetCount(a3), Count == CFArrayGetCount(theArray))))
  {
    CFDataRef v26 = a4;
    DataCFIndex Length = CMBlockBufferGetDataLength(a1);
    if (DataLength)
    {
      CFArrayRef v28 = a3;
      size_t v13 = 0;
      size_t v14 = 0;
      while (v14 + 6 <= DataLength)
      {
        unsigned int destination = 0;
        unsigned __int16 v30 = 0;
        uint64_t result = CMBlockBufferCopyDataBytes(a1, v14, 4uLL, &destination);
        if (result) {
          return result;
        }
        uint64_t v16 = bswap32(destination);
        if (v16 < 2 || v14 + 4 + v16 > DataLength) {
          break;
        }
        uint64_t result = CMBlockBufferCopyDataBytes(a1, v14 + 4, 2uLL, &v30);
        if (result) {
          return result;
        }
        int v18 = bswap32(v30);
        unsigned int v19 = v18 >> 16;
        if (v18 >> 16 < 0) {
          break;
        }
        int v20 = (v18 >> 19) & 0x3F;
        size_t v21 = (v16 + 4);
        if (FigCFArrayContainsInt32(theArray, v20))
        {
          size_t v22 = v13 + v21;
          if (a5)
          {
            if (v22 > a6) {
              return FigSignalErrorAt(4294954577, 0, 0, 0, 0, 0, 0);
            }
            uint64_t result = CMBlockBufferCopyDataBytes(a1, v14, v21, (void *)(a5 + v13));
            if (result) {
              return result;
            }
            int v29 = 0;
            if (!v28 || (CFIndex FirstIndexOfInt32 = FigCFArrayGetFirstIndexOfInt32(theArray, v20), FirstIndexOfInt32 == -1))
            {
              LOBYTE(v24) = BYTE1(v19);
            }
            else
            {
              FigCFArrayGetInt32AtIndex(v28, FirstIndexOfInt32, &v29);
              unsigned int v19 = (8 * (unsigned __int16)v29) | v19 & 0xFE07;
              unsigned int v24 = v19 >> 8;
            }
            uint64_t v25 = v13 + a5;
            *(unsigned char *)(v25 + 4) = v24;
            *(unsigned char *)(v25 + 5) = v19;
          }
        }
        else
        {
          size_t v22 = v13;
        }
        v14 += v21;
        size_t v13 = v22;
        if (v14 >= DataLength) {
          goto LABEL_32;
        }
      }
      return FigSignalErrorAt(4294954577, 0, 0, 0, 0, 0, 0);
    }
    size_t v14 = 0;
    size_t v22 = 0;
LABEL_32:
    if (v14 != DataLength) {
      return FigSignalErrorAt(4294954577, 0, 0, 0, 0, 0, 0);
    }
    if (v26)
    {
      uint64_t result = 0;
      *CFDataRef v26 = v22;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigHEVCBridge_CreateAlphaInfoSEI(int a1, int a2, int a3, CFDataRef *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  char v19 = 0;
  *(void *)UInt8 bytes = 0;
  uint64_t v17 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  if (a4)
  {
    v11[0] = (uint64_t)bytes;
    v11[1] = 9;
    *(void *)&long long v14 = bytes;
    hevcbridgeUPush(v11, 1, 0);
    hevcbridgeUPush(v11, 6, 39);
    hevcbridgeUPush(v11, 6, 0);
    hevcbridgeUPush(v11, 3, 1);
    hevcbridgeUPush(v11, 8, 165);
    hevcbridgeUPush(v11, 8, 4);
    hevcbridgeUPush(v11, 1, 0);
    hevcbridgeUPush(v11, 3, a1 != 0);
    hevcbridgeUPush(v11, 3, 0);
    hevcbridgeUPush(v11, 9, a2);
    hevcbridgeUPush(v11, 9, a3);
    hevcbridgeUPush(v11, 1, 0);
    hevcbridgeUPush(v11, 1, 0);
    if (HIDWORD(v15)) {
      hevcbridgeUPush(v11, 1, 1);
    }
    char v19 = 0x80;
    CFDataRef v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 9);
    if (v8)
    {
      CFDataRef v9 = v8;
      uint64_t result = 0;
      *a4 = v9;
    }
    else
    {
      return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(const void *a1, const void *a2, int a3, const __CFData *a4, int a5, __CFData **a6)
{
  CFDataRef theData = 0;
  CFTypeRef cf = 0;
  if (!a1) {
    goto LABEL_65;
  }
  CFTypeID v10 = CFGetTypeID(a1);
  if (v10 != CFDataGetTypeID()) {
    goto LABEL_65;
  }
  if (!a2)
  {
LABEL_8:
    CFDataRef MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDataRef)a1);
    if (MutableCopy)
    {
      long long v14 = MutableCopy;
      CFIndex Length = CFDataGetLength(MutableCopy);
      MutableBytePtr = CFDataGetMutableBytePtr(v14);
      if (MutableBytePtr) {
        BOOL v17 = Length <= 0;
      }
      else {
        BOOL v17 = 1;
      }
      if (v17)
      {
        uint64_t v42 = 4294954584;
        goto LABEL_59;
      }
      int v18 = MutableBytePtr;
      int v19 = *MutableBytePtr;
      if (a3)
      {
        if ((unint64_t)Length > 5 && v19 == 1)
        {
          uint64_t v20 = 5;
          goto LABEL_20;
        }
      }
      else if ((unint64_t)Length > 0x16 && v19 == 1)
      {
        uint64_t v20 = 22;
LABEL_20:
        CFIndex v21 = v20 + 1;
        CFIndex v45 = v20;
        int v47 = MutableBytePtr[v20];
        if (MutableBytePtr[v20])
        {
          uint64_t v48 = 0;
          int v50 = 0;
          int v22 = 0;
          CFIndex v23 = v20 + 1;
          while (1)
          {
            CFIndex v21 = v23 + 3;
            if (Length < v23 + 3) {
              goto LABEL_58;
            }
            int v49 = v22;
            range.CFIndex location = v23 + 1;
            unsigned int v24 = __rev16(*(unsigned __int16 *)&v18[v23 + 1]);
            if (v24) {
              break;
            }
LABEL_49:
            int v22 = v49 + 1;
            CFIndex v23 = v21;
            if (v49 + 1 == v47) {
              goto LABEL_52;
            }
          }
          int v25 = 0;
          int v26 = v18[v23] & 0x3F;
          if (a4) {
            BOOL v27 = v26 == 39;
          }
          else {
            BOOL v27 = 0;
          }
          char v28 = v27;
          char v52 = v28;
          unsigned int v29 = v24;
          while (1)
          {
            CFIndex v30 = v21 + 2;
            if (Length < v21 + 2) {
              goto LABEL_58;
            }
            uint64_t v31 = __rev16(*(unsigned __int16 *)&v18[v21]);
            CFIndex v21 = v30 + v31;
            if (Length < v30 + v31) {
              goto LABEL_58;
            }
            if (v31 <= 1) {
              goto LABEL_58;
            }
            int v32 = (char)v18[v30];
            if (v32 < 0 || v26 != v32 >> 1) {
              goto LABEL_58;
            }
            if (v29 == 1)
            {
              if ((v26 - 33) >= 2)
              {
                if (v52)
                {
                  int v50 = 1;
                  CFDataRef v33 = a4;
LABEL_47:
                  unsigned int v34 = CFDataGetLength(v33);
                  unsigned __int16 v35 = v34;
                  HIWORD(range.length) = bswap32(v34) >> 16;
                  v56.CFIndex location = v21;
                  v56.CFIndex length = 0;
                  CFDataReplaceBytes(v14, v56, (const UInt8 *)&range.length + 6, 2);
                  CFIndex v36 = v21 + 2;
                  BytePtr = CFDataGetBytePtr(v33);
                  v57.CFIndex location = v36;
                  v57.CFIndex length = 0;
                  CFDataReplaceBytes(v14, v57, BytePtr, v35);
                  CFIndex v21 = v36 + v35;
                  WORD2(range.length) = bswap32(++v25 + v24) >> 16;
                  v58.CFIndex location = range.location;
                  v58.CFIndex length = 2;
                  CFDataReplaceBytes(v14, v58, (const UInt8 *)&range.length + 4, 2);
                  int v18 = CFDataGetMutableBytePtr(v14);
                  CFIndex Length = CFDataGetLength(v14);
                }
              }
              else
              {
                if (v26 == 33)
                {
                  HIDWORD(v48) = 1;
                  CFDataRef v33 = (const __CFData *)cf;
                  if (!cf) {
                    goto LABEL_48;
                  }
                  goto LABEL_47;
                }
                if (v26 == 34)
                {
                  LODWORD(v48) = 1;
                  CFDataRef v33 = theData;
                  if (!theData) {
                    goto LABEL_48;
                  }
                  goto LABEL_47;
                }
                int v50 = 1;
                CFDataRef v33 = a4;
                if (a4) {
                  goto LABEL_47;
                }
              }
            }
LABEL_48:
            if (!--v29) {
              goto LABEL_49;
            }
          }
        }
        int v50 = 0;
        uint64_t v48 = 0;
LABEL_52:
        BYTE3(range.length) = v47;
        if (a4 && !v50)
        {
          BYTE3(range.length) = v47 + 1;
          v59.CFIndex location = v45;
          v59.CFIndex length = 1;
          CFDataReplaceBytes(v14, v59, (const UInt8 *)&range.length + 3, 1);
          BYTE2(range.length) = 39;
          v60.CFIndex location = v21;
          v60.CFIndex length = 0;
          CFDataReplaceBytes(v14, v60, (const UInt8 *)&range.length + 2, 1);
          v61.CFIndex location = v21 + 1;
          HIWORD(range.length) = 256;
          v61.CFIndex length = 0;
          CFDataReplaceBytes(v14, v61, (const UInt8 *)&range.length + 6, 2);
          unsigned int v38 = CFDataGetLength(a4);
          unsigned __int16 v39 = v38;
          WORD2(range.length) = bswap32(v38) >> 16;
          v62.CFIndex location = v21 + 3;
          v62.CFIndex length = 0;
          CFDataReplaceBytes(v14, v62, (const UInt8 *)&range.length + 4, 2);
          unsigned int v40 = CFDataGetBytePtr(a4);
          v63.CFIndex location = v21 + 5;
          v63.CFIndex length = 0;
          CFDataReplaceBytes(v14, v63, v40, v39);
        }
        if (HIDWORD(v48) && v48)
        {
          uint64_t v41 = 0;
          *a6 = v14;
          goto LABEL_60;
        }
      }
LABEL_58:
      uint64_t v42 = 4294954581;
LABEL_59:
      uint64_t v41 = FigSignalErrorAt(v42, 0, 0, 0, 0, 0, 0);
      CFRelease(v14);
      goto LABEL_60;
    }
    uint64_t v44 = 4294954583;
    goto LABEL_70;
  }
  CFTypeID v11 = CFGetTypeID(a2);
  if (v11 != CFDataGetTypeID())
  {
LABEL_65:
    uint64_t v44 = 4294954584;
    goto LABEL_70;
  }
  uint64_t v12 = hevcbridge_copyModifedAlphaSPSAndPPSFromHVCCOrLHVC(a2, a3, a5, (__CFData **)&cf, &theData);
  if (!v12)
  {
    if (!cf)
    {
      uint64_t v41 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
      goto LABEL_62;
    }
    if (theData) {
      goto LABEL_8;
    }
    uint64_t v44 = 4294954581;
LABEL_70:
    uint64_t v12 = FigSignalErrorAt(v44, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v41 = v12;
LABEL_60:
  if (cf) {
    CFRelease(cf);
  }
LABEL_62:
  if (theData) {
    CFRelease(theData);
  }
  return v41;
}

uint64_t hevcbridge_copyModifedAlphaSPSAndPPSFromHVCCOrLHVC(const void *a1, int a2, int a3, __CFData **a4, __CFData **a5)
{
  if (!a1
    || (CFTypeID v10 = CFGetTypeID(a1), v10 != CFDataGetTypeID())
    || (v32 = a5, CFIndex Length = CFDataGetLength((CFDataRef)a1), (BytePtr = CFDataGetBytePtr((CFDataRef)a1)) == 0)
    || Length <= 0)
  {
    uint64_t v30 = 4294954584;
LABEL_50:
    return FigSignalErrorAt(v30, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v13 = (uint64_t)BytePtr;
  int v14 = *BytePtr;
  if (!a2)
  {
    if ((unint64_t)Length > 0x16 && v14 == 1)
    {
      uint64_t v15 = 22;
      goto LABEL_12;
    }
    goto LABEL_49;
  }
  if ((unint64_t)Length <= 5 || v14 != 1)
  {
LABEL_49:
    uint64_t v30 = 4294954581;
    goto LABEL_50;
  }
  uint64_t v15 = 5;
LABEL_12:
  uint64_t v31 = a4;
  int v33 = BytePtr[v15];
  if (BytePtr[v15])
  {
    int v16 = 0;
    BOOL v17 = 0;
    int v18 = 0;
    uint64_t v19 = v15 + 1;
    while (1)
    {
      uint64_t v20 = v19 + 3;
      if (Length < v19 + 3) {
        break;
      }
      int v34 = v16;
      unsigned int v21 = __rev16(*(unsigned __int16 *)(v19 + v13 + 1));
      if (v21)
      {
        int v22 = *(unsigned char *)(v13 + v19) & 0x3F;
        unsigned int v23 = v21;
        while (1)
        {
          uint64_t v24 = v20 + 2;
          if (Length < v20 + 2) {
            goto LABEL_40;
          }
          uint64_t v25 = __rev16(*(unsigned __int16 *)(v13 + v20));
          uint64_t v19 = v24 + v25;
          if (Length < v24 + v25 || v25 < 2) {
            goto LABEL_40;
          }
          unsigned int v27 = *(unsigned __int8 *)(v20 + v13 + 3) | (*(unsigned __int8 *)(v13 + v24) << 8);
          if ((v27 & 0x8000) != 0 || ((v27 >> 9) & 0x3F) != v22 || !a2 && (v27 & 0x1F8) != 0) {
            goto LABEL_40;
          }
          if (v22 == 34)
          {
            if (v21 != 1 || v17) {
              goto LABEL_40;
            }
            BOOL v17 = hevcbridge_copyPatchedParameterSet(v13, v24, v25, v27, a3);
          }
          else if (v22 == 33)
          {
            if (v21 != 1) {
              goto LABEL_40;
            }
            if (v18)
            {
              uint64_t v28 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
              goto LABEL_41;
            }
            int v18 = hevcbridge_copyPatchedParameterSet(v13, v24, v25, v27, a3);
          }
          uint64_t v20 = v19;
          if (!--v23) {
            goto LABEL_38;
          }
        }
      }
      v19 += 3;
LABEL_38:
      int v16 = v34 + 1;
      if (v34 + 1 == v33) {
        goto LABEL_45;
      }
    }
LABEL_40:
    uint64_t v28 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    if (v18) {
LABEL_41:
    }
      CFRelease(v18);
    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    int v18 = 0;
    BOOL v17 = 0;
LABEL_45:
    uint64_t v28 = 0;
    *int v32 = v17;
    *uint64_t v31 = v18;
  }
  return v28;
}

uint64_t FigHEVCBridge_CreateMuxedAlphaHVCC(const void *a1, const void *a2, const __CFData *a3, __CFData **a4)
{
  return FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(a1, a2, 0, a3, 1, a4);
}

uint64_t FigHEVCBridge_CreateMuxedAlphaFormatDescription(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2, const __CFData *a3, CMVideoFormatDescriptionRef *a4)
{
  v48[2] = *MEMORY[0x1E4F143B8];
  char v46 = 0;
  CFTypeRef cf = 0;
  CMVideoFormatDescriptionRef formatDescriptionOut = 0;
  CFDataRef theData = 0;
  CMTagValue value = 0;
  CFDataRef v41 = 0;
  BOOL v40 = 0;
  CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
  if (CFDataGetLength(a3) <= 4) {
    goto LABEL_40;
  }
  CFDataRef v9 = CFDataGetBytePtr(a3) + 4;
  CFIndex Length = CFDataGetLength(a3);
  uint64_t SEIAlphaChannelInfo = FigHEVCBridge_GetSEIAlphaChannelInfo((uint64_t)v9, Length - 4, &v46);
  if (SEIAlphaChannelInfo) {
    goto LABEL_42;
  }
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions) {
    goto LABEL_40;
  }
  CFDictionaryRef v13 = Extensions;
  CFDictionaryRef v14 = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms");
  if (!v14) {
    goto LABEL_40;
  }
  CFDictionaryRef v15 = v14;
  int v16 = CFDictionaryGetValue(v14, @"hvcC");
  if (!v16) {
    goto LABEL_40;
  }
  BOOL v17 = v16;
  CFTypeID v18 = CFGetTypeID(v16);
  if (v18 != CFDataGetTypeID()) {
    goto LABEL_40;
  }
  CFDictionaryRef v19 = CMFormatDescriptionGetExtensions(a2);
  if (!v19) {
    goto LABEL_40;
  }
  CFDictionaryRef v20 = (const __CFDictionary *)CFDictionaryGetValue(v19, @"SampleDescriptionExtensionAtoms");
  if (!v20) {
    goto LABEL_40;
  }
  unsigned int v21 = CFDictionaryGetValue(v20, @"hvcC");
  if (!v21) {
    goto LABEL_40;
  }
  int v22 = v21;
  CFTypeID v23 = CFGetTypeID(v21);
  if (v23 != CFDataGetTypeID()) {
    goto LABEL_40;
  }
  uint64_t SEIAlphaChannelInfo = hevcbridgeIsHVCC8Bit420(v17, &v40);
  if (SEIAlphaChannelInfo) {
    goto LABEL_42;
  }
  BOOL v24 = v40;
  if (v40)
  {
    uint64_t SEIAlphaChannelInfo = FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(v17, v22, 0, a3, 1, (__CFData **)&cf);
    if (!SEIAlphaChannelInfo)
    {
      CFTypeRef v25 = cf;
      if (cf)
      {
        CFTypeID v26 = CFGetTypeID(cf);
        if (v26 == CFDataGetTypeID()) {
          goto LABEL_16;
        }
      }
LABEL_40:
      uint64_t v39 = 4294954581;
LABEL_41:
      uint64_t SEIAlphaChannelInfo = FigSignalErrorAt(v39, 0, 0, 0, 0, 0, 0);
      goto LABEL_42;
    }
    goto LABEL_42;
  }
  uint64_t SEIAlphaChannelInfo = FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(v17, 0, 0, a3, 0, (__CFData **)&cf);
  if (SEIAlphaChannelInfo) {
    goto LABEL_42;
  }
  CFTypeRef v25 = cf;
  if (!cf) {
    goto LABEL_40;
  }
  CFTypeID v35 = CFGetTypeID(cf);
  if (v35 != CFDataGetTypeID()) {
    goto LABEL_40;
  }
  uint64_t SEIAlphaChannelInfo = hevcbridge_copyModifedAlphaSPSAndPPSFromHVCCOrLHVC(v22, 0, 1, &theData, &v41);
  if (SEIAlphaChannelInfo)
  {
LABEL_42:
    uint64_t LHVCFromHEVCParameterSets = SEIAlphaChannelInfo;
    goto LABEL_31;
  }
  CFDataRef v36 = theData;
  v48[0] = CFDataGetBytePtr(theData);
  CFDataRef v37 = v41;
  v48[1] = CFDataGetBytePtr(v41);
  v47[0] = CFDataGetLength(v36);
  v47[1] = CFDataGetLength(v37);
  uint64_t LHVCFromHEVCParameterSets = hevcbridgeCreateLHVCFromHEVCParameterSets(0, (uint64_t)v48, (uint64_t)v47, (__CFData **)&value);
  if (LHVCFromHEVCParameterSets) {
    goto LABEL_31;
  }
LABEL_16:
  CFAllocatorRef v27 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v13);
  if (!MutableCopy)
  {
    uint64_t v39 = 4294954583;
    goto LABEL_41;
  }
  unsigned int v29 = MutableCopy;
  uint64_t v30 = CFDictionaryCreateMutableCopy(v27, 0, v15);
  if (v30)
  {
    uint64_t v31 = v30;
    CFDictionarySetValue(v30, @"hvcC", v25);
    if (!v24) {
      CFDictionarySetValue(v31, @"lhvC", value);
    }
    CFDictionarySetValue(v29, @"SampleDescriptionExtensionAtoms", v31);
    CFDictionarySetValue(v29, @"ContainsAlphaChannel", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v32 = (const void **)&kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha;
    if (!v46) {
      int v32 = (const void **)&kCMFormatDescriptionAlphaChannelMode_StraightAlpha;
    }
    CFDictionarySetValue(v29, @"AlphaChannelMode", *v32);
    CFDictionaryRemoveValue(v29, @"VerbatimSampleDescription");
    CFDictionaryRemoveValue(v29, @"VerbatimISOSampleEntry");
    uint64_t LHVCFromHEVCParameterSets = CMVideoFormatDescriptionCreate(v27, 0x68766331u, Dimensions.width, Dimensions.height, v29, &formatDescriptionOut);
    if (LHVCFromHEVCParameterSets)
    {
      if (formatDescriptionOut) {
        CFRelease(formatDescriptionOut);
      }
    }
    else
    {
      *a4 = formatDescriptionOut;
      CMVideoFormatDescriptionRef formatDescriptionOut = 0;
    }
    CFRelease(v29);
    int v34 = v31;
  }
  else
  {
    uint64_t LHVCFromHEVCParameterSets = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    int v34 = v29;
  }
  CFRelease(v34);
LABEL_31:
  if (cf) {
    CFRelease(cf);
  }
  if (value) {
    CFRelease(value);
  }
  if (theData) {
    CFRelease(theData);
  }
  if (v41) {
    CFRelease(v41);
  }
  return LHVCFromHEVCParameterSets;
}

uint64_t hevcbridgeIsHVCC8Bit420(const void *a1, BOOL *a2)
{
  uint64_t v11 = 0;
  __int16 v9 = 0;
  char v8 = 0;
  if (a1 && (CFTypeID v4 = CFGetTypeID(a1), v4 == CFDataGetTypeID()))
  {
    uint64_t v10 = 0;
    uint64_t result = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 33, 0, (unint64_t)&v10, (unint64_t)&v11, 0, 0, 0, 0);
    if (!result)
    {
      uint64_t result = FigHEVCBridge_GetSPSChromaFormatAndBitDepths(v10, v11, &v8, (unsigned char *)&v9 + 1, &v9);
      if (!result)
      {
        BOOL v7 = v8 == 1 && HIBYTE(v9) == 8;
        *a2 = v7;
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t hevcbridgeCreateLHVCFromHEVCParameterSets(CFDataRef theData, uint64_t a2, uint64_t a3, __CFData **a4)
{
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (theData)
  {
    CFDataRef MutableCopy = CFDataCreateMutableCopy(v7, 0, theData);
    if (MutableCopy)
    {
      __int16 v9 = MutableCopy;
      CFIndex Length = CFDataGetLength(MutableCopy);
      if (Length <= 5) {
        goto LABEL_30;
      }
      CFIndex v11 = Length;
      MutableBytePtr = CFDataGetMutableBytePtr(v9);
      if (!MutableBytePtr)
      {
        uint64_t v37 = 4294954584;
        goto LABEL_31;
      }
      CFDictionaryRef v13 = MutableBytePtr;
      if (*MutableBytePtr != 1)
      {
LABEL_30:
        uint64_t v37 = 4294954581;
LABEL_31:
        uint64_t v36 = FigSignalErrorAt(v37, 0, 0, 0, 0, 0, 0);
        CFRelease(v9);
        return v36;
      }
      int v40 = MutableBytePtr[5];
      if (MutableBytePtr[5])
      {
        uint64_t v39 = a4;
        int v14 = 0;
        uint64_t v15 = 6;
        uint64_t v16 = a3;
        CFIndex v17 = v11;
        while (1)
        {
          CFIndex v18 = v15 + 3;
          if (v17 < v15 + 3) {
            goto LABEL_30;
          }
          int v41 = v14;
          range.CFIndex location = v15 + 1;
          LODWORD(range.length) = __rev16(*(unsigned __int16 *)&v13[v15 + 1]);
          if (LODWORD(range.length))
          {
            int v19 = 0;
            int v20 = 0;
            int v21 = v13[v15] & 0x3F;
            do
            {
              CFIndex v22 = v18 + 2;
              if (v17 < v18 + 2) {
                goto LABEL_30;
              }
              uint64_t v23 = __rev16(*(unsigned __int16 *)&v13[v18]);
              CFIndex v24 = v22 + v23;
              if (v17 < v22 + v23) {
                goto LABEL_30;
              }
              if (v23 <= 1) {
                goto LABEL_30;
              }
              int v25 = (char)v13[v22];
              if (v25 < 0 || v21 != v25 >> 1) {
                goto LABEL_30;
              }
              int v42 = v19 + 1;
              if (v19 + 1 == LODWORD(range.length))
              {
                uint64_t v26 = 0;
                char v27 = 1;
                CFIndex v18 = v24;
                do
                {
                  char v28 = v27;
                  int v29 = (**(unsigned __int8 **)(a2 + 8 * v26) >> 1) & 0x3F;
                  uint64_t v30 = *(void *)(v16 + 8 * v26);
                  *(_WORD *)newBytes = bswap32(v30) >> 16;
                  if (v21 == v29)
                  {
                    CFIndex v31 = (unsigned __int16)v30;
                    v52.CFIndex location = v24;
                    v52.CFIndex length = 0;
                    CFDataReplaceBytes(v9, v52, newBytes, 2);
                    v53.CFIndex location = v24 + 2;
                    v53.CFIndex length = 0;
                    CFDataReplaceBytes(v9, v53, *(const UInt8 **)(a2 + 8 * v26), v31);
                    v18 += v31 + 2;
                    HIWORD(range.length) = bswap32(++v20 + LODWORD(range.length)) >> 16;
                    v54.CFIndex location = range.location;
                    v54.CFIndex length = 2;
                    CFDataReplaceBytes(v9, v54, (const UInt8 *)&range.length + 6, 2);
                    CFDictionaryRef v13 = CFDataGetMutableBytePtr(v9);
                    CFIndex v17 = CFDataGetLength(v9);
                    uint64_t v16 = a3;
                  }
                  char v27 = 0;
                  uint64_t v26 = 1;
                }
                while ((v28 & 1) != 0);
              }
              else
              {
                CFIndex v18 = v24;
              }
              int v19 = v42;
            }
            while (v42 != LODWORD(range.length));
          }
          int v14 = v41 + 1;
          uint64_t v15 = v18;
          if (v41 + 1 == v40)
          {
            a4 = v39;
            break;
          }
        }
      }
LABEL_29:
      uint64_t v36 = 0;
      *a4 = v9;
      return v36;
    }
  }
  else
  {
    CFMutableArrayRef Mutable = CFDataCreateMutable(v7, 0);
    if (Mutable)
    {
      __int16 v9 = Mutable;
      *(_DWORD *)UInt8 bytes = -67047423;
      __int16 v50 = 707;
      CFDataAppendBytes(Mutable, bytes, 6);
      uint64_t v33 = 0;
      char v34 = 1;
      do
      {
        char v35 = v34;
        UInt8 v48 = 0;
        UInt8 v48 = (**(unsigned char **)(a2 + 8 * v33) >> 1) & 0x3F | 0x80;
        *(_WORD *)int v47 = 256;
        *(_WORD *)char v46 = bswap32(*(unsigned __int16 *)(a3 + 8 * v33)) >> 16;
        CFDataAppendBytes(v9, &v48, 1);
        CFDataAppendBytes(v9, v47, 2);
        CFDataAppendBytes(v9, v46, 2);
        CFDataAppendBytes(v9, *(const UInt8 **)(a2 + 8 * v33), *(void *)(a3 + 8 * v33));
        char v34 = 0;
        uint64_t v33 = 1;
      }
      while ((v35 & 1) != 0);
      goto LABEL_29;
    }
  }

  return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CreateMultiviewMuxedAlphaFormatDescription(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2, const __CFData *a3, int a4, CFArrayRef theArray, const __CFArray *a6, CMVideoFormatDescriptionRef *a7)
{
  v76[2] = *MEMORY[0x1E4F143B8];
  char v74 = 0;
  CFTypeRef cf = 0;
  CMVideoFormatDescriptionRef formatDescriptionOut = 0;
  CFTypeRef v71 = 0;
  int v70 = 0;
  CFDataRef v68 = 0;
  CFDataRef theData = 0;
  CFTypeRef v67 = 0;
  BOOL v66 = 0;
  if (!theArray || CFArrayGetCount(theArray) != 2 || !a6 || CFArrayGetCount(a6) != 2)
  {
    uint64_t v48 = 4294954584;
LABEL_34:
    uint64_t SEIAlphaChannelInfo = FigSignalErrorAt(v48, 0, 0, 0, 0, 0, 0);
    goto LABEL_35;
  }
  CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
  if (CFDataGetLength(a3) <= 4) {
    goto LABEL_61;
  }
  int v14 = CFDataGetBytePtr(a3) + 4;
  CFIndex Length = CFDataGetLength(a3);
  uint64_t SEIAlphaChannelInfo = FigHEVCBridge_GetSEIAlphaChannelInfo((uint64_t)v14, Length - 4, &v74);
  if (SEIAlphaChannelInfo)
  {
LABEL_35:
    uint64_t v49 = SEIAlphaChannelInfo;
    goto LABEL_52;
  }
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions) {
    goto LABEL_61;
  }
  CFDictionaryRef v18 = Extensions;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms");
  if (!Value) {
    goto LABEL_61;
  }
  CFDictionaryRef v20 = Value;
  int v21 = CFDictionaryGetValue(Value, @"hvcC");
  if (!v21
    || (v22 = v21, CFTypeID v23 = CFGetTypeID(v21), v23 != CFDataGetTypeID())
    || (CFDataRef v24 = (const __CFData *)CFDictionaryGetValue(v20, @"lhvC")) == 0
    || (v25 = v24, theDict = v18, CFTypeID v26 = CFGetTypeID(v24), v26 != CFDataGetTypeID()))
  {
LABEL_61:
    uint64_t v48 = 4294954581;
    goto LABEL_34;
  }
  CMVideoDimensions v62 = Dimensions;
  CFAllocatorRef v27 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDataRef MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v25);
  if (!MutableCopy)
  {
    uint64_t v48 = 4294954583;
    goto LABEL_34;
  }
  CFDictionaryRef v28 = CMFormatDescriptionGetExtensions(a2);
  if (!v28) {
    goto LABEL_62;
  }
  CFDictionaryRef v29 = (const __CFDictionary *)CFDictionaryGetValue(v28, @"SampleDescriptionExtensionAtoms");
  if (!v29
    || (v30 = v29, (CFIndex v31 = CFDictionaryGetValue(v29, @"hvcC")) == 0)
    || (int v32 = v31, v33 = CFGetTypeID(v31), v33 != CFDataGetTypeID())
    || (char v34 = CFDictionaryGetValue(v30, @"lhvC")) == 0
    || (v35 = v34, CFTypeID v36 = CFGetTypeID(v34), v36 != CFDataGetTypeID()))
  {
LABEL_62:
    uint64_t IsHVCC8Bit420 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    goto LABEL_63;
  }
  FigCFArrayGetInt16AtIndex(a6, 0, (char *)&v70 + 2);
  uint64_t IsHVCC8Bit420 = hevcbridgeIsHVCC8Bit420(v22, &v66);
  if (IsHVCC8Bit420)
  {
LABEL_63:
    uint64_t v49 = IsHVCC8Bit420;
    CFMutableDataRef v58 = MutableCopy;
    goto LABEL_51;
  }
  CFRange v61 = a7;
  BOOL v38 = v66;
  if (v66) {
    uint64_t v39 = v32;
  }
  else {
    uint64_t v39 = 0;
  }
  uint64_t MuxedAlphaHVCCOrLHVC = FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(v22, v39, 0, a3, HIWORD(v70), (__CFData **)&cf);
  int v41 = (void *)cf;
  if (!MuxedAlphaHVCCOrLHVC)
  {
    if (cf)
    {
      CFTypeID v42 = CFGetTypeID(cf);
      if (v42 == CFDataGetTypeID())
      {
        __int16 v65 = 0;
        FigCFArrayGetInt16AtIndex(theArray, 1, &v65);
        uint64_t updated = hevcbridge_updateConfigRecordNuhLayerID(MutableCopy, 1, v65);
        if (updated) {
          goto LABEL_71;
        }
        FigCFArrayGetInt16AtIndex(a6, 1, &v70);
        uint64_t updated = FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(MutableCopy, v35, 1, 0, (unsigned __int16)v70, (__CFData **)&v71);
        if (updated) {
          goto LABEL_71;
        }
        CFDataRef v44 = (const __CFData *)v71;
        if (v71 && (CFTypeID v45 = CFGetTypeID(v71), v45 == CFDataGetTypeID()))
        {
          if (v38)
          {
            CFTypeRef v46 = v44;
            int v47 = v61;
          }
          else
          {
            uint64_t updated = hevcbridge_copyModifedAlphaSPSAndPPSFromHVCCOrLHVC(v32, 0, HIWORD(v70), &theData, &v68);
            if (updated) {
              goto LABEL_71;
            }
            CFDataRef v50 = theData;
            v76[0] = CFDataGetBytePtr(theData);
            CFDataRef v51 = v68;
            v76[1] = CFDataGetBytePtr(v68);
            v75[0] = CFDataGetLength(v50);
            v75[1] = CFDataGetLength(v51);
            uint64_t updated = hevcbridgeCreateLHVCFromHEVCParameterSets(v44, (uint64_t)v76, (uint64_t)v75, (__CFData **)&v67);
            if (updated) {
              goto LABEL_71;
            }
            CFTypeRef v46 = v67;
            CFTypeRef v71 = v67;
            int v47 = v61;
            if (v67) {
              CFRetain(v67);
            }
            CFRelease(v44);
          }
          CFMutableDictionaryRef v52 = CFDictionaryCreateMutableCopy(v27, 0, theDict);
          if (v52)
          {
            CFRange v53 = v52;
            CFRange v54 = CFDictionaryCreateMutableCopy(v27, 0, v20);
            if (v54)
            {
              int v55 = v54;
              CFDictionarySetValue(v54, @"hvcC", v41);
              CFDictionarySetValue(v55, @"lhvC", v46);
              CFDictionarySetValue(v53, @"SampleDescriptionExtensionAtoms", v55);
              CFDictionarySetValue(v53, @"ContainsAlphaChannel", (const void *)*MEMORY[0x1E4F1CFD0]);
              CFRange v56 = (const void **)&kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha;
              if (!v74) {
                CFRange v56 = (const void **)&kCMFormatDescriptionAlphaChannelMode_StraightAlpha;
              }
              CFDictionarySetValue(v53, @"AlphaChannelMode", *v56);
              CFDictionaryRemoveValue(v53, @"VerbatimSampleDescription");
              CFDictionaryRemoveValue(v53, @"VerbatimISOSampleEntry");
              uint64_t v49 = CMVideoFormatDescriptionCreate(v27, 0x68766331u, v62.width, v62.height, v53, &formatDescriptionOut);
              if (!v49)
              {
                *int v47 = formatDescriptionOut;
                CMVideoFormatDescriptionRef formatDescriptionOut = 0;
              }
              CFRelease(v53);
              CFRange v57 = v55;
            }
            else
            {
              uint64_t v49 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              CFRange v57 = v53;
            }
            CFRelease(v57);
            goto LABEL_49;
          }
          uint64_t v60 = 4294954583;
        }
        else
        {
          uint64_t v60 = 4294954581;
        }
        uint64_t updated = FigSignalErrorAt(v60, 0, 0, 0, 0, 0, 0);
LABEL_71:
        uint64_t v49 = updated;
LABEL_49:
        CFRelease(MutableCopy);
LABEL_50:
        CFMutableDataRef v58 = (CFMutableDataRef)v41;
LABEL_51:
        CFRelease(v58);
        goto LABEL_52;
      }
    }
    uint64_t MuxedAlphaHVCCOrLHVC = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v49 = MuxedAlphaHVCCOrLHVC;
  CFRelease(MutableCopy);
  if (v41) {
    goto LABEL_50;
  }
LABEL_52:
  if (v71) {
    CFRelease(v71);
  }
  if (theData) {
    CFRelease(theData);
  }
  if (v68) {
    CFRelease(v68);
  }
  if (v67) {
    CFRelease(v67);
  }
  return v49;
}

uint64_t FigHEVCBridge_CreateMuxedAlphaDataBuffer(OpaqueCMBlockBuffer *a1, OpaqueCMBlockBuffer *a2, CMBlockBufferRef *a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFMutableArrayRef v7 = Mutable;
    uint64_t appended = FigCFArrayAppendInt32(Mutable, 1);
    if (!appended) {
      uint64_t appended = FigHEVCBridge_CreateMultiviewMuxedAlphaDataBuffer(a1, a2, 0, v7, a3);
    }
    uint64_t v9 = appended;
    CFRelease(v7);
    return v9;
  }
  else
  {
    return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigHEVCBridge_CreateMultiviewMuxedAlphaDataBuffer(OpaqueCMBlockBuffer *a1, OpaqueCMBlockBuffer *a2, const void *a3, const void *a4, CMBlockBufferRef *a5)
{
  DataCFIndex Length = CMBlockBufferGetDataLength(a1);
  size_t v11 = CMBlockBufferGetDataLength(a2);
  dataPointerOut = 0;
  CMBlockBufferRef theBuffer = 0;
  if (a4 && (unint64_t v12 = v11, (unint64_t)(CFArrayGetCount((CFArrayRef)a4) - 3) > 0xFFFFFFFFFFFFFFFDLL))
  {
    uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v12 + DataLength, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, v12 + DataLength, 1u, &theBuffer);
    if (DataPointer
      || (uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut), DataPointer)
      || (uint64_t DataPointer = CMBlockBufferCopyDataBytes(a1, 0, DataLength, dataPointerOut), DataPointer)
      || a3
      && (uint64_t DataPointer = hevcbridge_updateNuhLayerIDs((uint64_t)dataPointerOut, DataLength, a3), DataPointer)
      || (uint64_t DataPointer = CMBlockBufferCopyDataBytes(a2, 0, v12, &dataPointerOut[DataLength]), DataPointer))
    {
      uint64_t updated = DataPointer;
    }
    else
    {
      uint64_t updated = hevcbridge_updateNuhLayerIDs((uint64_t)&dataPointerOut[DataLength], v12, a4);
      if (!updated)
      {
        *a5 = theBuffer;
        return updated;
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    uint64_t updated = 0;
  }
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return updated;
}

uint64_t hevcbridge_updateNuhLayerIDs(uint64_t a1, unint64_t a2, const void *a3)
{
  if (!a3) {
    return 0;
  }
  if (a2)
  {
    unint64_t v6 = 0;
    while (v6 + 6 <= a2)
    {
      uint64_t v7 = a1 + v6;
      uint64_t v8 = bswap32(*(_DWORD *)(a1 + v6));
      int v13 = 0;
      if (v8 < 2 || v6 + v8 + 4 > a2) {
        break;
      }
      int v10 = (int)bswap32(*(unsigned __int16 *)(v7 + 4)) >> 16;
      if (v10 < 0) {
        break;
      }
      unsigned int v11 = v10 & 0xFFFFFE07;
      FigCFArrayGetInt32AtIndex(a3, (v10 & 0x1F8) != 0, &v13);
      *(_WORD *)(v7 + 4) = bswap32(v11 | (8 * (unsigned __int16)v13)) >> 16;
      v6 += (v8 + 4);
      if (v6 >= a2) {
        goto LABEL_13;
      }
    }
    return FigSignalErrorAt(4294954577, 0, 0, 0, 0, 0, 0);
  }
  unint64_t v6 = 0;
LABEL_13:
  if (v6 != a2) {
    return FigSignalErrorAt(4294954577, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigHEVCBridge_CreateAmbientViewingEnvironmentSEINAL(unsigned int a1, int a2, int a3, CFDataRef *a4)
{
  v21[2] = *MEMORY[0x1E4F143B8];
  memset(v21, 0, 13);
  uint64_t v20 = 0;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  *(void *)UInt8 bytes = 0;
  v13[0] = 0;
  *(void *)((char *)v13 + 5) = 0;
  if (a4)
  {
    v14[0] = (uint64_t)v21;
    v14[1] = 13;
    *(void *)&long long v17 = v21;
    BYTE9(v16) = 0;
    uint64_t result = hevcbridgeUPush(v14, 1, 0);
    if (!result)
    {
      uint64_t result = hevcbridgeUPush(v14, 6, 39);
      if (!result)
      {
        uint64_t result = hevcbridgeUPush(v14, 6, 0);
        if (!result)
        {
          uint64_t result = hevcbridgeUPush(v14, 3, 1);
          if (!result)
          {
            uint64_t result = hevcbridgeUPush(v14, 8, 148);
            if (!result)
            {
              uint64_t result = hevcbridgeUPush(v14, 8, 8);
              if (!result)
              {
                uint64_t result = hevcbridgeUPushLong(v14, 32, a1);
                if (!result)
                {
                  uint64_t result = hevcbridgeUPush(v14, 16, a2);
                  if (!result)
                  {
                    uint64_t result = hevcbridgeUPush(v14, 16, a3);
                    if (!result)
                    {
                      BYTE4(v21[1]) = 0x80;
                      int BufferWithStartCodeEmulationBytes = generateBufferWithStartCodeEmulationBytes(13, v21, (uint64_t)bytes);
                      CFDataRef v10 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, BufferWithStartCodeEmulationBytes);
                      if (v10)
                      {
                        CFDataRef v11 = v10;
                        uint64_t result = 0;
                        *a4 = v11;
                      }
                      else
                      {
                        return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

void FigHEVCBridge_HLSfMP4ParsingInfoDestroy(void **a1)
{
  if (a1)
  {
    if (*a1)
    {
      unint64_t v2 = 0;
      do
        free(a1[++v2]);
      while (v2 < (unint64_t)*a1);
    }
    free(a1);
  }
}

uint64_t FigHEVCBridge_CreateHLSfMP4ParsingInfoFromHVCCAndLHVCData(const void *a1, const void *a2, char a3, void ***a4)
{
  v43[13] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v36 = 0;
  if (!a1) {
    goto LABEL_45;
  }
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 != CFDataGetTypeID()) {
    goto LABEL_45;
  }
  if (a2)
  {
    CFTypeID v9 = CFGetTypeID(a2);
    if (v9 != CFDataGetTypeID()) {
      goto LABEL_45;
    }
  }
  if (!a4) {
    goto LABEL_45;
  }
  uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 32, 0, 0, 0, (unint64_t)&v40, 0, 0, 0);
  if (HEVCParameterSetAtIndex) {
    goto LABEL_46;
  }
  uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 33, 0, 0, 0, (unint64_t)&v39, 0, 0, 0);
  if (HEVCParameterSetAtIndex) {
    goto LABEL_46;
  }
  uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 34, 0, 0, 0, (unint64_t)&v38, 0, 0, 0);
  if (HEVCParameterSetAtIndex) {
    goto LABEL_46;
  }
  uint64_t v11 = v40;
  if (!v40 || (uint64_t v12 = v39) == 0 || (v13 = v38) == 0)
  {
LABEL_45:
    uint64_t v17 = 4294954584;
    goto LABEL_19;
  }
  if (!a2)
  {
    uint64_t v15 = 0;
    uint64_t v14 = 0;
LABEL_17:
    unint64_t v16 = v12 + v14 + v11 + v13 + v15;
    if (v16 < 0x1FFFFFFFFFFFFFFFLL)
    {
      uint64_t v20 = (void **)malloc_type_calloc(1uLL, 8 * v16 + 8, 0x91F32BBuLL);
      if (v20)
      {
        long long v19 = v20;
        unint64_t v21 = v40;
        unint64_t v22 = v39 + v40;
        unint64_t v23 = v39 + v40 + v38;
        unint64_t v24 = v23 + v37;
        if (v23 + v37 + v36)
        {
          unint64_t v25 = 0;
          while (1)
          {
            memset(v43, 0, 104);
            long long v42 = 0u;
            memset(v41, 0, sizeof(v41));
            uint64_t v34 = 0;
            uint64_t v35 = 0;
            unint64_t v26 = v25 - v21;
            if (v25 < v21)
            {
              uint64_t v27 = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 32, v25, (unint64_t)&v35, (unint64_t)&v34, 0, 0, 0, 0);
              goto LABEL_36;
            }
            unint64_t v28 = v25 - v22;
            if (v25 >= v22)
            {
              unint64_t v26 = v25 - v23;
              if (v25 < v23)
              {
                CFDictionaryRef v29 = a1;
                int v30 = 1;
LABEL_34:
                int v31 = 34;
                unint64_t v26 = v28;
                goto LABEL_35;
              }
              unint64_t v28 = v25 - v24;
              if (v25 >= v24)
              {
                CFDictionaryRef v29 = a2;
                int v30 = 0;
                goto LABEL_34;
              }
              CFDictionaryRef v29 = a2;
              int v30 = 0;
            }
            else
            {
              CFDictionaryRef v29 = a1;
              int v30 = 1;
            }
            int v31 = 33;
LABEL_35:
            uint64_t v27 = hevcbridge_getHEVCParameterSetAtIndex(v29, v30, v31, v26, (unint64_t)&v35, (unint64_t)&v34, 0, 0, 0, 0);
LABEL_36:
            uint64_t v18 = v27;
            if (v27) {
              goto LABEL_20;
            }
            uint64_t v32 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v43, v35, v34, 1);
            if (v32
              || (*(void *)&long long v42 = &v19[(void)*v19 + 1],
                  BYTE8(v42) = a3,
                  uint64_t v32 = hevcbridgeParseNALUnit(v43, (uint64_t *)v41),
                  v32))
            {
              uint64_t v18 = v32;
              goto LABEL_20;
            }
            if (v19[(void)*v19 + 1]) {
              *long long v19 = (char *)*v19 + 1;
            }
            ++v25;
            unint64_t v21 = v40;
            unint64_t v22 = v39 + v40;
            unint64_t v23 = v39 + v40 + v38;
            unint64_t v24 = v23 + v37;
            if (v25 >= v23 + v37 + v36) {
              goto LABEL_42;
            }
          }
        }
        goto LABEL_42;
      }
    }
    uint64_t v17 = 4294954583;
LABEL_19:
    uint64_t v18 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
    long long v19 = 0;
    if (v18) {
      goto LABEL_20;
    }
LABEL_42:
    uint64_t v18 = 0;
    *a4 = v19;
    return v18;
  }
  uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a2, 0, 33, 0, 0, 0, (unint64_t)&v37, 0, 0, 0);
  if (!HEVCParameterSetAtIndex)
  {
    uint64_t HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a2, 0, 34, 0, 0, 0, (unint64_t)&v36, 0, 0, 0);
    if (!HEVCParameterSetAtIndex)
    {
      uint64_t v12 = v39;
      uint64_t v11 = v40;
      uint64_t v14 = v37;
      uint64_t v13 = v38;
      uint64_t v15 = v36;
      goto LABEL_17;
    }
  }
LABEL_46:
  uint64_t v18 = HEVCParameterSetAtIndex;
  long long v19 = 0;
LABEL_20:
  FigHEVCBridge_HLSfMP4ParsingInfoDestroy(v19);
  return v18;
}

uint64_t FigHEVCBridge_CreateHLSfMP4ParsingInfoFromHVCCData(const void *a1, void ***a2)
{
  return FigHEVCBridge_CreateHLSfMP4ParsingInfoFromHVCCAndLHVCData(a1, 0, 1, a2);
}

uint64_t FigHEVCBridge_MeasureSliceHeader(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v12 = 0;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  memset(v8, 0, sizeof(v8));
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v8, a1, a2, 1);
  if (!result)
  {
    *(void *)&long long v21 = *a3;
    *((void *)&v21 + 1) = a3 + 1;
    BYTE8(v15) = 1;
    *(void *)&long long v14 = hevcbridgeMeasureSliceHeaderCallbackUnsigned;
    uint64_t result = hevcbridgeParseNALUnit(v8, (uint64_t *)&v13);
    if (!result)
    {
      if (HIDWORD(v10))
      {
        return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        uint64_t result = 0;
        *a5 = v9 - *(void *)&v8[0];
      }
    }
  }
  return result;
}

uint64_t hevcbridgeMeasureSliceHeaderCallbackUnsigned(uint64_t a1, int a2, unsigned int a3)
{
  if (a3 <= 0x1F) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = -12712;
  }
  if (a2) {
    return 4294954584;
  }
  else {
    return v3;
  }
}

uint64_t FigHEVCBridge_LocateSliceHeaderForHLSfMP4EncryptableNAL(CMBlockBufferRef theBuffer, uint64_t a2, size_t a3, void *a4, void *a5, uint64_t a6, unint64_t a7, void *a8, uint64_t a9)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  unsigned int destination = 0;
  uint64_t result = 4294954584;
  if (!theBuffer || !a4) {
    return result;
  }
  long long v14 = a5;
  if (a5) {
    *a5 = 0;
  }
  if (a7) {
    *(void *)a7 = 0;
  }
  if (a8) {
    *a8 = 0;
  }
  if (a9) {
    *(void *)a9 = 0;
  }
  DataCFIndex Length = CMBlockBufferGetDataLength(theBuffer);
  if (!DataLength) {
    goto LABEL_16;
  }
  if (a3)
  {
    if (a3 + a2 <= DataLength) {
      goto LABEL_20;
    }
LABEL_16:
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  if (a2) {
    goto LABEL_16;
  }
  a3 = DataLength;
LABEL_20:
  unsigned int v40 = 0;
  size_t v18 = a3 - 4;
  if (a3 != 4)
  {
    unint64_t v19 = (unint64_t)a8;
    size_t v20 = 0;
    long long v21 = a4;
    uint64_t v22 = 0;
    uint64_t v32 = (void *)v19;
    uint64_t v23 = v19 | a9;
    BOOL v36 = v23 != 0;
    BOOL v37 = (v23 | a7) != 0;
    uint64_t v34 = v21;
    CFTypeID v33 = v21 + 1;
    uint64_t v35 = v14;
    do
    {
      uint64_t result = CMBlockBufferCopyDataBytes(theBuffer, v20 + a2, 4uLL, &destination);
      if (result) {
        return result;
      }
      unsigned int v24 = bswap32(destination);
      unsigned int destination = v24;
      if (v24 <= 1) {
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
      size_t v25 = v20 + 4;
      if (v25 + v24 > a3) {
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
      uint64_t v26 = v25 + a2;
      uint64_t result = CMBlockBufferCopyDataBytes(theBuffer, v25 + a2, 1uLL, &v40);
      if (result) {
        return result;
      }
      unsigned int v27 = (v40 >> 1) & 0x3F;
      unsigned int v40 = v27;
      if (v27 < 0xA || v27 - 19 < 2 || v27 <= 0x15 && ((1 << v27) & 0x270000) != 0)
      {
        BOOL v28 = v37;
        if (v22 != a6) {
          BOOL v28 = 0;
        }
        if (v28)
        {
          uint64_t v29 = a6;
          if (a7) {
            *(void *)a7 = v25;
          }
          if (v36)
          {
            uint64_t v30 = destination;
            long long v56 = 0u;
            long long v57 = 0u;
            long long v54 = 0u;
            long long v55 = 0u;
            long long v52 = 0u;
            long long v53 = 0u;
            long long v50 = 0u;
            long long v51 = 0u;
            long long v49 = 0u;
            long long v48 = 0u;
            v41[0] = 0;
            uint64_t v47 = 0;
            long long v45 = 0u;
            long long v46 = 0u;
            long long v43 = 0u;
            long long v44 = 0u;
            v41[1] = v26 + destination;
            long long v42 = (unint64_t)theBuffer;
            uint64_t result = CMBlockBufferGetDataPointer(theBuffer, v25 + a2, 0, 0, (char **)&v44);
            if (result) {
              return result;
            }
            v41[0] = v44 - v26;
            *((void *)&v42 + 1) = v44;
            WORD4(v43) = 1;
            *((void *)&v44 + 1) = v44;
            *((void *)&v46 + 1) = 0;
            LODWORD(v47) = 0;
            long long v45 = 0uLL;
            uint64_t result = hevcbridgeAdvanceInBitstream((uint64_t)v41, 0);
            if (result) {
              return result;
            }
            *(void *)&long long v56 = *v34;
            *((void *)&v56 + 1) = v33;
            BYTE8(v50) = 1;
            *(void *)&long long v49 = hevcbridgeMeasureSliceHeaderCallbackUnsigned;
            uint64_t result = hevcbridgeParseNALUnit(v41, (uint64_t *)&v48);
            if (result) {
              return result;
            }
            if (HIDWORD(v45))
            {
              uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
              uint64_t v31 = 0;
              if (result) {
                return result;
              }
            }
            else
            {
              uint64_t v31 = v44 - (v41[0] + v26);
            }
            if (v32) {
              *uint64_t v32 = v31 + v25;
            }
            if (a9) {
              *(void *)a9 = v30 - v31;
            }
          }
          a6 = v29;
          long long v14 = v35;
          size_t v18 = a3 - 4;
          if (!v35)
          {
            if (a6 == -1) {
              return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
            }
            return 0;
          }
        }
        ++v22;
      }
      size_t v20 = v25 + destination;
    }
    while (v20 < v18);
    if (v22)
    {
      if (v14) {
        *long long v14 = v22;
      }
      if (v22 > a6) {
        return 0;
      }
    }
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CheckVPSPrimaryAlphaLayerCompatibility(const void *a1, int *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  int v25 = 0;
  unsigned int v24 = 0;
  *a2 = 0;
  if (!a1 || (CFTypeID v4 = CFGetTypeID(a1), v4 != CFDataGetTypeID()))
  {
    uint64_t HLSfMP4ParsingInfoFromHVCCAndLHVCData = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    goto LABEL_38;
  }
  uint64_t HLSfMP4ParsingInfoFromHVCCAndLHVCData = FigHEVCBridge_CreateHLSfMP4ParsingInfoFromHVCCAndLHVCData(a1, 0, 0, (void ***)&v24);
  if (HLSfMP4ParsingInfoFromHVCCAndLHVCData) {
    goto LABEL_38;
  }
  CFDataRef theData = 0;
  uint64_t v30 = 0;
  uint64_t v28 = 0;
  uint64_t HLSfMP4ParsingInfoFromHVCCAndLHVCData = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 32, 0, (unint64_t)&v28, (unint64_t)&v30, 0, 0, 0, 0);
  if (HLSfMP4ParsingInfoFromHVCCAndLHVCData) {
    goto LABEL_38;
  }
  uint64_t v6 = FigHEVCBridge_CopyHEVCSEIPayloadData(a1, 176, (CFTypeRef *)&theData);
  uint64_t v7 = v6;
  if (!v6)
  {
    CFDataRef v8 = theData;
    if (theData)
    {
      uint64_t v9 = v28;
      uint64_t v10 = v30;
      BytePtr = CFDataGetBytePtr(theData);
      CFIndex Length = CFDataGetLength(v8);
      memset(v32, 0, 64);
      memset(v31, 0, sizeof(v31));
      FigHEVCBridge_Get3DLayerIDSets(v9, v10, (uint64_t)BytePtr, Length, v32, v31);
      if (!HLSfMP4ParsingInfoFromHVCCAndLHVCData)
      {
        BOOL v14 = v32[0] != 255 && LOBYTE(v31[0]) != 255;
        goto LABEL_16;
      }
LABEL_38:
      uint64_t v7 = HLSfMP4ParsingInfoFromHVCCAndLHVCData;
      goto LABEL_36;
    }
  }
  if (v6) {
    goto LABEL_36;
  }
  BOOL v14 = 0;
LABEL_16:
  uint64_t HLSfMP4ParsingInfoFromHVCCAndLHVCData = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 32, 0, (unint64_t)&v26, (unint64_t)&v27, 0, 0, 0, 0);
  if (HLSfMP4ParsingInfoFromHVCCAndLHVCData) {
    goto LABEL_38;
  }
  uint64_t HLSfMP4ParsingInfoFromHVCCAndLHVCData = FigHEVCBridge_GetVPSAlphaChannelNuhLayerId(v26, v27, 0, &v25);
  if (HLSfMP4ParsingInfoFromHVCCAndLHVCData) {
    goto LABEL_38;
  }
  if (*(void *)v24)
  {
    uint64_t v15 = 0;
    int v16 = 0;
    if (v14) {
      int v17 = 2;
    }
    else {
      int v17 = 1;
    }
    do
    {
      size_t v18 = (_DWORD *)*((void *)v24 + v15 + 1);
      if (*v18 == 32)
      {
        uint64_t v19 = 0;
        while (1)
        {
          uint64_t v20 = *((unsigned __int8 *)v18 + v19 + 335);
          if (v25 == v20)
          {
            long long v21 = (char *)v18 + v20;
            if (v21[76] || v21[140] == 0) {
              break;
            }
          }
          if (++v19 == 63) {
            goto LABEL_32;
          }
        }
        int v16 = v17;
      }
LABEL_32:
      ++v15;
    }
    while (v15 != *(void *)v24);
  }
  else
  {
    int v16 = 0;
  }
  uint64_t v7 = 0;
  *a2 = v16;
LABEL_36:
  FigHEVCBridge_HLSfMP4ParsingInfoDestroy((void **)v24);
  return v7;
}

uint64_t FigHEVCBridge_CopyParsingInformation(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  memset(v17, 0, sizeof(v17));
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  uint64_t v9 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v13, a1, a2, 1);
  if (v9) {
    goto LABEL_8;
  }
  *(void *)&long long v10 = -1;
  *((void *)&v10 + 1) = -1;
  *(_OWORD *)((char *)&v17[6] + 8) = v10;
  *(_OWORD *)((char *)&v17[5] + 8) = v10;
  *(_OWORD *)((char *)&v17[4] + 8) = v10;
  *(_OWORD *)((char *)&v17[3] + 8) = v10;
  *(_OWORD *)((char *)&v17[2] + 8) = v10;
  *(_OWORD *)((char *)&v17[1] + 8) = v10;
  *(_OWORD *)((char *)v17 + 8) = v10;
  *((void *)&v17[7] + 1) = -1;
  *(void *)&long long v15 = Mutable;
  *((void *)&v15 + 1) = hevcbridgeCopyParsingInformationCallbackFlag;
  *(void *)&long long v16 = hevcbridgeCopyParsingInformationCallbackUnsigned;
  *((void *)&v16 + 1) = hevcbridgeCopyParsingInformationCallbackSigned;
  *(void *)&v17[0] = hevcbridgeCopyParsingInformationCallbackCFData;
  if (a3)
  {
    *(void *)&_OWORD v17[6] = *a3;
    *((void *)&v17[6] + 1) = a3 + 1;
  }
  *(void *)&_OWORD v17[7] = 0;
  uint64_t v11 = hevcbridgeParseNALUnit(v13, (uint64_t *)&v15);
  if (v11) {
    CFStringAppendFormat(Mutable, 0, @"Error found: %d\n", v11);
  }
  if (!a4)
  {
LABEL_8:
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
    *a4 = Mutable;
  }
  return v9;
}

uint64_t hevcbridgeCopyParsingInformationCallbackFlag(__CFString *a1, int a2, int a3, uint64_t a4)
{
  if (a2 < 0) {
    CFTypeID v4 = "unknown field";
  }
  else {
    CFTypeID v4 = NALFieldsStrings[a2];
  }
  uint64_t v5 = "SET";
  if (!a3) {
    uint64_t v5 = "not set";
  }
  if ((a4 & 0x80000000) != 0) {
    CFStringAppendFormat(a1, 0, @"%s: %s\n", v4, v5);
  }
  else {
    CFStringAppendFormat(a1, 0, @"%s[%d]: %s\n", v4, a4, v5);
  }
  return 0;
}

uint64_t hevcbridgeCopyParsingInformationCallbackUnsigned(__CFString *a1, int a2, uint64_t a3)
{
  if (a2 < 0) {
    unsigned int v3 = "unknown field";
  }
  else {
    unsigned int v3 = NALFieldsStrings[a2];
  }
  if (a2 > 115)
  {
    if (a2 > 327)
    {
      if (a2 == 328)
      {
        CFStringAppendFormat(a1, 0, @"%s: %u (%f)\n", v3, a3, (float)((float)a3 / 30.0));
        return 0;
      }
      if (a2 != 344) {
        goto LABEL_33;
      }
      uint64_t v5 = "?";
      if ((int)a3 > 143)
      {
        switch((int)a3)
        {
          case 144:
            uint64_t v5 = "content_light_level_info";
            break;
          case 145:
          case 146:
            goto LABEL_29;
          case 147:
            uint64_t v5 = "alternative_transfer_characteristics";
            break;
          case 148:
            uint64_t v5 = "ambient_viewing_environment";
            break;
          case 149:
            uint64_t v5 = "content_color_volume";
            break;
          default:
            if (a3 == 165)
            {
              uint64_t v5 = "alpha_channel_info";
            }
            else if (a3 == 176)
            {
              uint64_t v5 = "three_dimensional_reference_displays_info";
            }
            break;
        }
      }
      else if (a3 <= 0x8F)
      {
        switch((int)a3)
        {
          case 0:
            uint64_t v5 = "buffering_period";
            break;
          case 1:
            uint64_t v5 = "pic_timing";
            break;
          case 2:
          case 3:
            goto LABEL_29;
          case 4:
            uint64_t v5 = "user_data_registered_itut35";
            break;
          case 5:
            uint64_t v5 = "user_data_unregistered";
            break;
          default:
            JUMPOUT(0);
        }
      }
      else
      {
        switch((int)a3)
        {
          case 128:
            uint64_t v5 = "structure_of_pictures_info";
            break;
          case 129:
            uint64_t v5 = "active_parameter_sets";
            break;
          case 132:
            uint64_t v5 = "decoded_picture_hash";
            break;
          case 137:
            uint64_t v5 = "mastering_display_colour_volume";
            break;
          default:
            goto LABEL_29;
        }
      }
      goto LABEL_29;
    }
    if (a2 == 116)
    {
      if (a3 <= 5)
      {
        CFTypeID v4 = off_1E567BCE0;
        goto LABEL_27;
      }
    }
    else
    {
      if (a2 != 269) {
        goto LABEL_33;
      }
      if (a3 <= 2)
      {
        CFTypeID v4 = off_1E567BD10;
LABEL_27:
        uint64_t v5 = v4[(int)a3];
        goto LABEL_29;
      }
    }
LABEL_28:
    uint64_t v5 = "?";
    goto LABEL_29;
  }
  if (a2 > 29)
  {
    if (a2 == 30)
    {
      uint64_t v7 = (unsigned __int16)a3;
      uint64_t v8 = WORD1(a3);
      goto LABEL_31;
    }
    if (a2 != 72)
    {
LABEL_33:
      CFStringAppendFormat(a1, 0, @"%s: %u\n", v3, a3);
      return 0;
    }
    if (a3 <= 3)
    {
      CFTypeID v4 = off_1E567BCC0;
      goto LABEL_27;
    }
    goto LABEL_28;
  }
  if (a2)
  {
    if (a2 == 27)
    {
      uint64_t v7 = a3;
      uint64_t v8 = a3 >> 8;
LABEL_31:
      CFStringAppendFormat(a1, 0, @"%s: %u and %u\n", v3, v7, v8);
      return 0;
    }
    goto LABEL_33;
  }
  uint64_t v5 = nalUnitTypeString[a3];
LABEL_29:
  CFStringAppendFormat(a1, 0, @"%s: %s (%u)\n", v3, v5, a3);
  return 0;
}

uint64_t hevcbridgeCopyParsingInformationCallbackSigned(__CFString *a1, int a2, uint64_t a3)
{
  if (a2 < 0) {
    unsigned int v3 = "unknown field";
  }
  else {
    unsigned int v3 = NALFieldsStrings[a2];
  }
  CFStringAppendFormat(a1, 0, @"%s: %d\n", v3, a3);
  return 0;
}

uint64_t hevcbridgeCopyParsingInformationCallbackCFData(__CFString *a1, int a2, CFDataRef theData)
{
  CFIndex Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  if (a2 < 0) {
    uint64_t v8 = "unknown field";
  }
  else {
    uint64_t v8 = NALFieldsStrings[a2];
  }
  CFStringAppendFormat(a1, 0, @"%s: ", v8);
  CFStringAppendFormat(a1, 0, @"{CFIndex length = %lu, bytes = 0x", Length);
  if (Length < 25)
  {
    if (Length >= 1)
    {
      do
      {
        unsigned int v12 = *BytePtr++;
        CFStringAppendFormat(a1, 0, @"%02x", v12);
        --Length;
      }
      while (Length);
    }
  }
  else
  {
    unint64_t v9 = 0;
    do
    {
      CFStringAppendFormat(a1, 0, @"%02x%02x%02x%02x", BytePtr[v9], BytePtr[v9 + 1], BytePtr[v9 + 2], BytePtr[v9 + 3]);
      BOOL v10 = v9 >= 0xC;
      v9 += 4;
    }
    while (!v10);
    CFStringAppend(a1, @" ... ");
    CFIndex v11 = Length - 8;
    do
    {
      CFStringAppendFormat(a1, 0, @"%02x%02x%02x%02x", BytePtr[v11], BytePtr[v11 + 1], BytePtr[v11 + 2], BytePtr[v11 + 3]);
      v11 += 4;
    }
    while (v11 < Length);
  }
  CFStringAppend(a1, @"}\n");
  return 0;
}

uint64_t FigHEVCBridge_GetRPUMetadataFromRPU(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  uint64_t result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v15, a1, a2, 0);
  if (!result)
  {
    uint64_t v14 = -1;
    *(void *)&long long v5 = -1;
    *((void *)&v5 + 1) = -1;
    long long v13 = v5;
    long long v12 = v5;
    long long v11 = v5;
    long long v10 = v5;
    long long v9 = v5;
    long long v8 = v5;
    long long v7 = v5;
    v6[0] = a3;
    v6[1] = (uint64_t)hevcbridgeGetRPUMetadataCallbackFlag;
    int v6[2] = (uint64_t)hevcbridgeGetRPUMetadataCallbackUnsigned;
    uint64_t v6[3] = (uint64_t)hevcbridgeGetRPUMetadataCallbackSigned;
    v6[4] = (uint64_t)hevcbridgeGetRPUMetadataCallbackCFData;
    return hevcbridgeParseDolbyRPUDataRBSP((uint64_t)v15, v6, a3);
  }
  return result;
}

uint64_t hevcbridgeGetRPUMetadataCallbackFlag()
{
  return 0;
}

uint64_t hevcbridgeGetRPUMetadataCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if (a3 != 62 && a2 == 0) {
    return 4294954584;
  }
  else {
    return 0;
  }
}

uint64_t hevcbridgeGetRPUMetadataCallbackSigned()
{
  return 0;
}

uint64_t hevcbridgeGetRPUMetadataCallbackCFData()
{
  return 0;
}

uint64_t hevcbridgeParseDolbyRPUDataRBSP(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  unsigned int v76 = 0;
  unsigned __int8 v75 = 0;
  unsigned int v74 = 0;
  __int16 v73 = 0;
  unsigned __int8 v72 = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  int v80 = 0;
  uint64_t v79 = 0;
  uint64_t v69 = 0;
  uint64_t result = hevcbridgeUPullLong(a1, 8, (_DWORD *)&v78 + 1);
  if (result) {
    return result;
  }
  if (HIDWORD(v78) != 25) {
    goto LABEL_42;
  }
  uint64_t v7 = *(uint64_t *)((char *)a2 + 44);
  uint64_t result = hevcbridgeUPullLong(a1, 6, &v78);
  if ((v7 & 1) != 0 && !result) {
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 412, v78, 0xFFFFFFFFLL);
  }
  if (result) {
    return result;
  }
  if (v78 != 2)
  {
LABEL_42:
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v8 = *(uint64_t *)((char *)a2 + 44);
  uint64_t result = hevcbridgeUPullLong(a1, 11, (_DWORD *)&v77 + 1);
  if ((v8 & 2) != 0 && !result) {
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 413, HIDWORD(v77), 0xFFFFFFFFLL);
  }
  if (result) {
    return result;
  }
  if (a3)
  {
    *(unsigned char *)(a3 + 6) = 2;
    *(_WORD *)(a3 + 8) = WORD2(v77);
  }
  unsigned __int8 v68 = 0;
  uint64_t v9 = *(uint64_t *)((char *)a2 + 44);
  uint64_t result = hevcbridgeUPullLong(a1, 4, (_DWORD *)&v69 + 1);
  if ((v9 & 4) != 0 && !result) {
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 414, HIDWORD(v69), 0xFFFFFFFFLL);
  }
  if (result) {
    return result;
  }
  uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 3) & 1, 415, &v69, 4);
  if (result) {
    return result;
  }
  unsigned __int8 v67 = 0;
  uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 4) & 1, 416, &v67);
  if (result) {
    return result;
  }
  int v10 = v67;
  if (a3)
  {
    *(unsigned char *)(a3 + 10) = BYTE4(v69);
    *(unsigned char *)(a3 + 11) = v69;
    *(unsigned char *)(a3 + 12) = v10;
  }
  unsigned int v66 = 0;
  uint64_t v65 = 0;
  char v64 = 0;
  if (!v10)
  {
    int v22 = 0;
    uint64_t v56 = 0;
    int v12 = 0;
    int v21 = 0;
    int v20 = 0;
    unsigned int v16 = 0;
    int v18 = 0;
    goto LABEL_36;
  }
  LOBYTE(v61) = 0;
  uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 6) & 1, 418, &v61);
  if (result) {
    return result;
  }
  int v11 = v61;
  uint64_t result = hevcbridgeUPullAlways(a1, a2, *((unsigned __int8 *)a2 + 44) >> 7, 419, &v77, 2);
  if (result) {
    return result;
  }
  int v12 = v77;
  if (v77)
  {
    char v13 = 0;
    char v14 = 0;
    unsigned int v15 = 0;
  }
  else
  {
    uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 8) & 1, 420, &v76);
    if (result) {
      return result;
    }
    unsigned int v15 = v76;
    if (v11)
    {
      unsigned int v63 = 0;
      uint64_t v25 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 9) & 1, 421, &v63);
      if (v25) {
        return v25;
      }
      char v14 = v63;
    }
    else
    {
      char v14 = 0;
    }
    char v13 = v15;
  }
  uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 10) & 1, 422, &v65, 2);
  if (result) {
    return result;
  }
  uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 11) & 1, 423, &v64);
  if (result) {
    return result;
  }
  char v54 = v13;
  LODWORD(v56) = v15;
  char v46 = v65;
  char v48 = v64;
  if ((v77 & 0x70000000000) != 0)
  {
    char v43 = 0;
    char v44 = 0;
    unsigned int v16 = 0;
    HIDWORD(v56) = 0;
    char v17 = 0;
    int v50 = 0;
    int v52 = 0;
    int v18 = 0;
    char v19 = 0;
    int v20 = 0;
LABEL_32:
    if (a3)
    {
      *(unsigned char *)(a3 + 13) = 0;
      *(unsigned char *)(a3 + 14) = v11;
      *(unsigned char *)(a3 + 15) = v12;
      *(unsigned char *)(a3 + 16) = v54;
      *(unsigned char *)(a3 + 17) = v44;
      *(unsigned char *)(a3 + 18) = v14;
      *(unsigned char *)(a3 + 19) = v46;
      *(unsigned char *)(a3 + 20) = v48;
      *(unsigned char *)(a3 + 21) = v16;
      *(unsigned char *)(a3 + 22) = BYTE4(v56);
      *(unsigned char *)(a3 + 23) = v17;
      *(unsigned char *)(a3 + 24) = v20;
      *(unsigned char *)(a3 + 25) = v52;
      *(unsigned char *)(a3 + 26) = v18;
      *(unsigned char *)(a3 + 27) = v43;
      *(unsigned char *)(a3 + 28) = v50;
      *(unsigned char *)(a3 + 29) = v19;
    }
    int v21 = v50;
    int v22 = v52;
LABEL_36:
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 22) & 1, 434, &v73);
    if (result) {
      return result;
    }
    int v23 = v73;
    if ((_BYTE)v73 || !v18)
    {
      uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 23) & 1, 435, &v72);
      if (result) {
        return result;
      }
      if (a3)
      {
        *(unsigned char *)(a3 + 30) = v23;
        int v24 = v72;
        *(unsigned char *)(a3 + 31) = v72;
      }
      else
      {
        int v24 = v72;
      }
      int v55 = v23;
      if (v24)
      {
        unsigned int v63 = 0;
        uint64_t v25 = hevcbridgeUEPullAlways(a1, a2, HIBYTE(*((_DWORD *)a2 + 11)) & 1, 436, &v63);
        if (a3 && !v25)
        {
          *(unsigned char *)(a3 + 32) = v63;
LABEL_177:
          if (!v55 || (uint64_t v25 = hevcbridgeParseVdrDmDataPayload(a1, a2, v18, a3), !v25))
          {
            int v58 = 0;
            while (*(_DWORD *)(a1 + 76))
            {
              uint64_t result = hevcbridgeUPullLong(a1, 1, &v58);
              if (result) {
                return result;
              }
              if (v58)
              {
                FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
                return 4294954582;
              }
            }
            return hevcbridgeUPullLong(a1, 32, &v57);
          }
          return v25;
        }
LABEL_174:
        if (!v25) {
          goto LABEL_177;
        }
        return v25;
      }
      int v51 = v21;
      int v53 = v22;
      unsigned int v62 = 0;
      unsigned int v63 = 0;
      uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 25) & 1, 437, &v63);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 26) & 1, 438, &v62);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 27) & 1, 439, (unsigned int *)&v71 + 1);
      if (result) {
        return result;
      }
      if (a3)
      {
        *(unsigned char *)(a3 + 33) = v63;
        *(unsigned char *)(a3 + 34) = v62;
        int v47 = HIDWORD(v71);
        *(unsigned char *)(a3 + 35) = BYTE4(v71);
      }
      else
      {
        int v47 = HIDWORD(v71);
      }
      int v45 = WORD2(v77) & 0x700;
      if ((v77 & 0x70000000000) == 0 && v47)
      {
        uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 28) & 1, 440, &v71, 4);
        if (result) {
          return result;
        }
        int v27 = v71;
        if (a3) {
          *(unsigned char *)(a3 + 36) = v71;
        }
        if (v27 == 14)
        {
          int v60 = 0;
          unsigned int v61 = 0;
          if (v47 == 2)
          {
            uint64_t v25 = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 29) & 1, 441, &v61, 2);
            if (v25) {
              return v25;
            }
            if (a3) {
              *(unsigned char *)(a3 + 37) = v61;
            }
          }
          uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 30) & 1, 442, &v60, 2);
          if (!a3 || result)
          {
            if (result) {
              return result;
            }
          }
          else
          {
            *(unsigned char *)(a3 + 38) = v60;
          }
        }
      }
      uint64_t v28 = 0;
      int v29 = v16 + 8;
      uint64_t v49 = 46;
      do
      {
        unsigned int v61 = 0;
        uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 35) & 1, 447, &v61);
        if (result) {
          return result;
        }
        uint64_t v30 = v61;
        if (v61 >= 0x10) {
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        }
        if (a3) {
          *(unsigned char *)(a3 + v28 + 43) = v61;
        }
        *((_DWORD *)&v79 + v28) = v30;
        uint64_t v31 = v30 + 2;
        uint64_t v32 = v49;
        do
        {
          int v60 = 0;
          uint64_t v25 = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 36) & 1, 448, &v60, v29);
          if (!a3 || v25)
          {
            if (v25) {
              return v25;
            }
          }
          else
          {
            *(_WORD *)(a3 + v32) = v60;
          }
          v32 += 2;
          --v31;
        }
        while (v31);
        v49 += 32;
        ++v28;
      }
      while (v28 != 3);
      if (!v45 && v20)
      {
        int v60 = 0;
        unsigned int v61 = 0;
        uint64_t v33 = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 37) & 1, 449, &v61, 3);
        if (v33) {
          return v33;
        }
        unsigned int v34 = v61;
        if (a3) {
          *(unsigned char *)(a3 + 238) = v61;
        }
        if (v34)
        {
          for (uint64_t i = 0; i != 3; ++i)
          {
            int v59 = 0;
            uint64_t result = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 38) & 1, 450, &v59, 3);
            if (!a3 || result)
            {
              if (result) {
                return result;
              }
            }
            else
            {
              *(unsigned char *)(a3 + 239 + i) = v34;
            }
          }
        }
        uint64_t v33 = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 39) & 1, 451, &v60, 3);
        if (v33) {
          return v33;
        }
        int v36 = v60;
        if (a3) {
          *(unsigned char *)(a3 + 242) = v60;
        }
        if (v36)
        {
          for (uint64_t j = 0; j != 3; ++j)
          {
            int v59 = 0;
            uint64_t result = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 40) & 1, 452, &v59, 3);
            if (!a3 || result)
            {
              if (result) {
                return result;
              }
            }
            else
            {
              *(unsigned char *)(a3 + 243 + j) = v59;
            }
          }
        }
      }
      if (v45 | v51)
      {
LABEL_129:
        uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 45) & 1, 457, (unsigned int *)&v70 + 1);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 46) & 1, 458, (unsigned int *)&v70);
        if (result) {
          return result;
        }
        unsigned int v38 = v70;
        unsigned int v39 = HIDWORD(v70);
        if (a3)
        {
          *(unsigned char *)(a3 + 313) = BYTE4(v70);
          *(unsigned char *)(a3 + 314) = v38;
        }
        if (v39 + v38)
        {
          unsigned int v61 = 0;
          uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 47) & 1, 459, &v61);
          if (!a3 || result)
          {
            if (result) {
              return result;
            }
          }
          else
          {
            *(unsigned char *)(a3 + 315) = v61;
          }
        }
        uint64_t v25 = hevcbridgeParseVDRRPUDataPayload(a1, a2, v39, v38, v12, v56, SWORD2(v77), v47, v53, v51, (uint64_t)&v79, a3);
        goto LABEL_174;
      }
      int v60 = 0;
      unsigned int v61 = 0;
      uint64_t result = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 41) & 1, 453, &v60, 3);
      if (result) {
        return result;
      }
      if (a3)
      {
        *(unsigned char *)(a3 + 246) = v60;
        if (v47 != 2)
        {
          *(unsigned char *)(a3 + 247) = 0;
LABEL_155:
          uint64_t v41 = 2;
LABEL_156:
          long long v42 = (_WORD *)(a3 + 248);
          do
          {
            int v59 = 0;
            uint64_t result = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 43) & 1, 455, &v59, HIDWORD(v56) + 8);
            if (!a3 || result)
            {
              if (result) {
                return result;
              }
            }
            else
            {
              *long long v42 = v59;
            }
            ++v42;
            --v41;
          }
          while (v41);
          if (v47)
          {
            int v59 = 0;
            uint64_t result = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 44) & 1, 456, &v59, 3);
            if (!a3 || result)
            {
              if (result) {
                return result;
              }
            }
            else
            {
              *(unsigned char *)(a3 + 312) = v59;
            }
          }
          goto LABEL_129;
        }
      }
      else if (v47 != 2)
      {
        goto LABEL_155;
      }
      uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 42) & 1, 454, &v61);
      if (result) {
        return result;
      }
      uint64_t v40 = v61;
      if (v61 >= 0x10) {
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
      if (a3) {
        *(unsigned char *)(a3 + 247) = v61;
      }
      uint64_t v41 = v40 + 2;
      goto LABEL_156;
    }
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  LOBYTE(v60) = 0;
  uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 12) & 1, 424, &v66);
  if (result) {
    return result;
  }
  unsigned int v16 = v66;
  if (v66 > 8) {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 13) & 1, 425, (unsigned int *)&v65 + 1);
  if (result) {
    return result;
  }
  HIDWORD(v56) = HIDWORD(v65);
  if (HIDWORD(v65) >> 8 < 0xE3)
  {
    unsigned int v26 = HIDWORD(v65);
  }
  else
  {
    if ((v65 & 0xFF000000000000) != 0 || BYTE5(v65) - 229 < 0xFFFFFFFE) {
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    }
    unsigned int v26 = BYTE4(v65);
  }
  if (v26 > 8) {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  unsigned int v63 = 0;
  uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 14) & 1, 426, &v63);
  if (result) {
    return result;
  }
  if (v63 >= 9) {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  char v17 = v63;
  uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 15) & 1, 427, &v68);
  if (result) {
    return result;
  }
  int v20 = v68;
  if (v68)
  {
    unsigned int v62 = 0;
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, HIWORD(*((_DWORD *)a2 + 11)) & 1, 428, &v75);
    if (result) {
      return result;
    }
    char v44 = 0;
    int v52 = v75;
    if (!v12 && v75)
    {
      uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 17) & 1, 429, &v62);
      if (result) {
        return result;
      }
      char v44 = v62;
    }
  }
  else
  {
    char v44 = 0;
    int v52 = 0;
  }
  uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 18) & 1, 430, &v74, 3);
  if (!result)
  {
    int v18 = v74;
    if (v74 >= 8) {
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    }
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 19) & 1, 431, &v60);
    if (result) {
      return result;
    }
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 20) & 1, 432, (unsigned char *)&v73 + 1);
    if (result) {
      return result;
    }
    char v43 = v60;
    char v19 = HIBYTE(v73);
    int v50 = HIBYTE(v73);
    if (HIBYTE(v73))
    {
      char v19 = 0;
    }
    else
    {
      unsigned int v62 = 0;
      if (!v12 && v11)
      {
        uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 21) & 1, 433, &v62);
        if (result) {
          return result;
        }
        char v19 = v62;
      }
    }
    goto LABEL_32;
  }
  return result;
}

uint64_t FigHEVCBridge_GetRPUMetadata(const void *a1, size_t a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t v6 = a2 + 2;
  uint64_t v7 = malloc_type_malloc(a2 + 2, 0xB22F6B69uLL);
  uint64_t v8 = v7;
  if (!v7)
  {
    uint64_t v9 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  *uint64_t v7 = 380;
  memcpy(v7 + 1, a1, a2);
  uint64_t v9 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v25, (uint64_t)v8, v6, 1);
  if (v9)
  {
LABEL_16:
    uint64_t v12 = v9;
    goto LABEL_14;
  }
  uint64_t v24 = -1;
  *(void *)&long long v10 = -1;
  *((void *)&v10 + 1) = -1;
  long long v23 = v10;
  long long v22 = v10;
  long long v21 = v10;
  long long v20 = v10;
  long long v19 = v10;
  long long v18 = v10;
  long long v17 = v10;
  v16[0] = a3;
  v16[1] = (uint64_t)hevcbridgeGetRPUMetadataCallbackFlag;
  _OWORD v16[2] = (uint64_t)hevcbridgeGetRPUMetadataCallbackUnsigned;
  v16[3] = (uint64_t)hevcbridgeGetRPUMetadataCallbackSigned;
  v16[4] = (uint64_t)hevcbridgeGetRPUMetadataCallbackCFData;
  uint64_t v15 = 0;
  unsigned int v11 = hevcbridgeUPullLong((uint64_t)v25, 1, (_DWORD *)&v15 + 1);
  if (!v11)
  {
    if (HIDWORD(v15))
    {
      uint64_t v12 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_14;
    }
    unsigned int v11 = hevcbridgeUPullLong((uint64_t)v25, 6, &v15);
    if (!v11)
    {
      if (v15 == 62)
      {
        unsigned int v11 = hevcbridgeUPullLong((uint64_t)v25, 6, &v14);
        if (!v11)
        {
          unsigned int v11 = hevcbridgeUPullIfRequested((uint64_t)v25, v16, 1, 2, 3);
          if (!v11) {
            unsigned int v11 = hevcbridgeParseDolbyRPUDataRBSP((uint64_t)v25, v16, a3);
          }
        }
      }
      else
      {
        unsigned int v11 = -12712;
      }
    }
  }
  if (v11 == 1) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v11;
  }
LABEL_14:
  free(v8);
  return v12;
}

uint64_t FigHEVCBridge_CreateDolbyRPUNAL(int *a1, CFDataRef *a2)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  int v2 = *a1;
  uint64_t v49 = 0;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v44 = 0u;
  if (!a2)
  {
    uint64_t v12 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    long long v5 = 0;
    uint64_t v7 = 0;
    goto LABEL_650;
  }
  long long v5 = (char *)malloc_type_calloc(1uLL, 0x1F4uLL, 0xAE8E47B8uLL);
  uint64_t v6 = (UInt8 *)malloc_type_calloc(1uLL, 0x1F4uLL, 0x6EDFC9D5uLL);
  uint64_t v7 = v6;
  if (!v5 || !v6)
  {
    uint64_t v8 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    goto LABEL_601;
  }
  v43[0] = (uint64_t)v5;
  v43[1] = 500;
  *(void *)&long long v46 = v5;
  BYTE9(v45) = 0;
  if (!hevcbridgeUPush(v43, 8, 25)
    && !hevcbridgeUPush(v43, 6, 2)
    && !hevcbridgeUPush(v43, 11, 18))
  {
    if (v2 == 1)
    {
      if (hevcbridgeUPush(v43, 4, 0)) {
        goto LABEL_75;
      }
    }
    else if (hevcbridgeUPush(v43, 4, 1))
    {
      goto LABEL_203;
    }
    if (!hevcbridgeUPush(v43, 4, 0)
      && !hevcbridgeUPush(v43, 1, 1)
      && !hevcbridgeUPush(v43, 1, 0)
      && !hevcbridgeUPush(v43, 2, 0)
      && !hevcbridgeUEPush((uint64_t)v43, 23)
      && !hevcbridgeUPush(v43, 2, 1))
    {
      if (v2 == 1)
      {
        if (hevcbridgeUPush(v43, 1, 1))
        {
LABEL_75:
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 384);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 6408);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 384);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 1153);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 7184);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 1184);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 1924);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 7952);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 1952);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 2688);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 8704);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 2752);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 3456);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 9536);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 3520);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 4288);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 10304);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 4224);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 4992);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 11008);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 4928);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 5760);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 11776);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 5760);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 96);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 7912);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 96);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 288);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 8104);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 288);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 480);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 8288);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 480);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 672);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 8448);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 672);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 96);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 7912);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 96);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 288);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 8104);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 288);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 480);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 8288);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 480);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 672);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 23, 8448);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if (v8) {
            goto LABEL_601;
          }
          int v9 = 672;
          goto LABEL_451;
        }
      }
      else if (hevcbridgeUPush(v43, 1, 0))
      {
        goto LABEL_203;
      }
      if (!hevcbridgeUEPush((uint64_t)v43, 2)
        && !hevcbridgeUEPush((uint64_t)v43, 2)
        && !hevcbridgeUEPush((uint64_t)v43, 4)
        && !hevcbridgeUPush(v43, 1, 0)
        && !hevcbridgeUPush(v43, 3, 0)
        && !hevcbridgeUPush(v43, 1, 0)
        && !hevcbridgeUPush(v43, 1, 1)
        && !hevcbridgeUPush(v43, 1, 1)
        && !hevcbridgeUPush(v43, 1, 0)
        && !hevcbridgeUEPush((uint64_t)v43, 0)
        && !hevcbridgeUEPush((uint64_t)v43, 0)
        && !hevcbridgeUEPush((uint64_t)v43, 0)
        && !hevcbridgeUEPush((uint64_t)v43, 7))
      {
        if (v2 == 1)
        {
          if (hevcbridgeUPush(v43, 10, 0)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 127)
            || hevcbridgeUEPush((uint64_t)v43, 3)
            || hevcbridgeUPush(v43, 10, 0)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 255)
            || hevcbridgeUEPush((uint64_t)v43, 3)
            || hevcbridgeUPush(v43, 10, 0)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 255))
          {
            goto LABEL_75;
          }
        }
        else if (hevcbridgeUPush(v43, 10, 63) {
               || hevcbridgeUPush(v43, 10, 69)
        }
               || hevcbridgeUPush(v43, 10, 230)
               || hevcbridgeUPush(v43, 10, 256)
               || hevcbridgeUPush(v43, 10, 256)
               || hevcbridgeUPush(v43, 10, 37)
               || hevcbridgeUPush(v43, 10, 16)
               || hevcbridgeUPush(v43, 10, 8)
               || hevcbridgeUPush(v43, 10, 7)
               || hevcbridgeUEPush((uint64_t)v43, 0)
               || hevcbridgeUPush(v43, 10, 0)
               || hevcbridgeUPush(v43, 10, 1023)
               || hevcbridgeUEPush((uint64_t)v43, 0)
               || hevcbridgeUPush(v43, 10, 0)
               || hevcbridgeUPush(v43, 10, 1023))
        {
          goto LABEL_203;
        }
        if (!hevcbridgeUEPush((uint64_t)v43, 0)) {
          hevcbridgeUEPush((uint64_t)v43, 0);
        }
      }
    }
  }
  if (v2 == 1) {
    goto LABEL_75;
  }
LABEL_203:
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 7978928);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 8332855);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -3);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 4889184);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 8269552);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 5186604);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -2);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 3909327);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 1317527);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 5338528);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 7440486);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 2119979);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 2065496);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 2288524);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 7982780);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -2);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 5409990);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 1585336);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 6);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 3460436);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -14);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 3197328);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 8);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 615464);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 13);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 3921968);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -30);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 6820672);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 16);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 5546752);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 28);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 1947392);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -62);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 1244640);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 34);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 23, 6094272);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  int v10 = *((unsigned __int8 *)a1 + 4);
  uint64_t v11 = hevcbridgeUPush(v43, 2, 2);
  uint64_t v12 = v11;
  if (v10)
  {
    if (v11) {
      goto LABEL_650;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 1150183);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 87355);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6228986);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -5);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 642500);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 1023296);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 5);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6569512);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 9);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5128216);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -12);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 4317296);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 8299905);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5819931);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 3);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2324124);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 7273546);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -5);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 1562484);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -12);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 3679480);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 18);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6357360);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 8172981);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 3261951);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5970055);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 927142);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 3525840);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 7);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5110348);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -19);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6236848);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 2, 2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6266112);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 4);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 193104);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5369128);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 5);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2553116);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 8009648);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -8);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2772020);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 3122453);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2961581);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -4);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6769788);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2565605);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -6);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 7864496);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 4777288);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 12);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 649616);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 7036536);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -4);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 1666406);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 406265);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2901521);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2680224);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 146340);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -8);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 1008052);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 4366810);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 4);
    if (v8) {
      goto LABEL_601;
    }
    int v9 = 5080852;
  }
  else
  {
    if (v11) {
      goto LABEL_650;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 4188155);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 705568);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 3);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6778652);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 739652);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -4);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6451088);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 4957009);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5762128);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5980826);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6359965);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -4);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 3533214);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 7481723);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 3);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 1107168);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 7291404);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 8100137);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -10);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5798904);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6900831);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 4107935);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 762460);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 4106660);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2620573);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 545445);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 12);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2973664);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 2, 2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6389327);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 3);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 4438378);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 3214133);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 5);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 4263144);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 8212876);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -7);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5336260);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 1628407);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5426045);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -3);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 3531622);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 3136655);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -7);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 7907964);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2444756);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 9);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 1229184);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 7962716);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -5);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 6901800);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 5917361);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2863974);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 8253338);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 2372924);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, -5);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 712920);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 23, 1229046);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeSEPush((uint64_t)v43, 6);
    if (v8) {
      goto LABEL_601;
    }
    int v9 = 3243492;
  }
LABEL_451:
  uint64_t v8 = hevcbridgeUPush(v43, 23, v9);
  if (v8) {
    goto LABEL_601;
  }
  int v13 = *a1;
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if (v8) {
    goto LABEL_601;
  }
  if (v13 == 1)
  {
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 0x2000);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 799);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 1681);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 0x2000);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, -933);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 1091);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 0x2000);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 267);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, -5545);
    if (v8) {
      goto LABEL_601;
    }
    unsigned int v14 = 0;
  }
  else
  {
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 9574);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 13802);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 9574);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, -1540);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, -5348);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 9574);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 17610);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 0);
    if (v8) {
      goto LABEL_601;
    }
    unsigned int v14 = 0x1000000;
  }
  uint64_t v8 = hevcbridgeUPushLong(v43, 32, v14);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPushLong(v43, 32, 0x8000000u);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPushLong(v43, 32, 0x8000000u);
  if (v8) {
    goto LABEL_601;
  }
  if (v13 == 1)
  {
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 17081);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 17081);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if (v8) {
      goto LABEL_601;
    }
    int v15 = 17081;
  }
  else
  {
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 7222);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 8771);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 390);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 2654);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 12430);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 1300);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 0);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, 422);
    if (v8) {
      goto LABEL_601;
    }
    int v15 = 15962;
  }
  uint64_t v8 = hevcbridgeIPush((uint64_t)v43, 16, v15);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 16, 0xFFFF);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 16, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 16, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPushLong(v43, 32, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 5, 12);
  if (v8) {
    goto LABEL_601;
  }
  int v16 = v13 == 1 ? 2 : 0;
  uint64_t v8 = hevcbridgeUPush(v43, 2, v16);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 2, 0);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 2, 1);
  if (v8) {
    goto LABEL_601;
  }
  int v17 = *((unsigned char *)a1 + 4) ? 62 : 0;
  uint64_t v8 = hevcbridgeUPush(v43, 12, v17);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 12, 3079);
  if (v8) {
    goto LABEL_601;
  }
  uint64_t v8 = hevcbridgeUPush(v43, 10, 42);
  if (v8) {
    goto LABEL_601;
  }
  int v18 = *((unsigned char *)a1 + 29120) != 0;
  if (*((unsigned char *)a1 + 29121)) {
    v18 += a1[7285];
  }
  if (*((unsigned char *)a1 + 29123)) {
    ++v18;
  }
  if (*((unsigned char *)a1 + 29124)) {
    ++v18;
  }
  if (*((unsigned char *)a1 + 29125)) {
    ++v18;
  }
  int v19 = *((unsigned char *)a1 + 29131) ? v18 + 1 : v18;
  uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, v19);
  if (v8) {
    goto LABEL_601;
  }
  hevcBridgeAlignToByte((uint64_t)v43);
  if (*((unsigned char *)a1 + 29120))
  {
    uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 5);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 8, 1);
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14566));
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14567));
    if (v8) {
      goto LABEL_601;
    }
    uint64_t v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14568));
    if (v8) {
      goto LABEL_601;
    }
    int v20 = 5;
    while (--v20)
    {
      uint64_t v8 = hevcbridgeUPush(v43, 1, 0);
      if (v8) {
        goto LABEL_601;
      }
    }
  }
  long long v42 = a2;
  if (!*((unsigned char *)a1 + 29121) || !a1[7285])
  {
LABEL_555:
    if (*((unsigned char *)a1 + 29123))
    {
      uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 3);
      if (v8) {
        goto LABEL_601;
      }
      uint64_t v8 = hevcbridgeUPush(v43, 8, 4);
      if (v8) {
        goto LABEL_601;
      }
      uint64_t v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14631));
      if (v8) {
        goto LABEL_601;
      }
      uint64_t v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14632));
      if (v8) {
        goto LABEL_601;
      }
    }
    if (*((unsigned char *)a1 + 29124))
    {
      uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 7);
      if (v8) {
        goto LABEL_601;
      }
      uint64_t v8 = hevcbridgeUPush(v43, 8, 5);
      if (v8) {
        goto LABEL_601;
      }
      uint64_t v8 = hevcbridgeUPush(v43, 13, *((unsigned __int16 *)a1 + 14633));
      if (v8) {
        goto LABEL_601;
      }
      uint64_t v8 = hevcbridgeUPush(v43, 13, *((unsigned __int16 *)a1 + 14634));
      if (v8) {
        goto LABEL_601;
      }
      uint64_t v8 = hevcbridgeUPush(v43, 13, *((unsigned __int16 *)a1 + 14635));
      if (v8) {
        goto LABEL_601;
      }
      uint64_t v8 = hevcbridgeUPush(v43, 13, *((unsigned __int16 *)a1 + 14636));
      if (v8) {
        goto LABEL_601;
      }
      int v24 = 5;
      while (--v24)
      {
        uint64_t v8 = hevcbridgeUPush(v43, 1, 0);
        if (v8) {
          goto LABEL_601;
        }
      }
    }
    if (!*((unsigned char *)a1 + 29125)
      || (uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 8), !v8)
      && (uint64_t v8 = hevcbridgeUPush(v43, 8, 6), !v8)
      && (uint64_t v8 = hevcbridgeUPush(v43, 16, 0), !v8)
      && (uint64_t v8 = hevcbridgeUPush(v43, 16, 0), !v8)
      && (uint64_t v8 = hevcbridgeUPush(v43, 16, 0), !v8)
      && (uint64_t v8 = hevcbridgeUPush(v43, 16, 0), !v8))
    {
      if (!*((unsigned char *)a1 + 4)) {
        goto LABEL_641;
      }
      int v25 = *((unsigned char *)a1 + 29122) != 0;
      if (*((unsigned char *)a1 + 29126)) {
        v25 += a1[7321];
      }
      if (*((unsigned char *)a1 + 29127)) {
        ++v25;
      }
      if (*((unsigned char *)a1 + 29128)) {
        v25 += a1[7372];
      }
      if (*((unsigned char *)a1 + 29129)) {
        ++v25;
      }
      int v26 = *((unsigned char *)a1 + 29130) ? v25 + 1 : v25;
      if (!v26) {
        goto LABEL_641;
      }
      uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, v26);
      if (!v8)
      {
        hevcBridgeAlignToByte((uint64_t)v43);
        if (*((unsigned char *)a1 + 29122))
        {
          uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 5);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 8, 3);
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14628));
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14629));
          if (v8) {
            goto LABEL_601;
          }
          uint64_t v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14630));
          if (v8) {
            goto LABEL_601;
          }
          int v27 = 5;
          while (--v27)
          {
            uint64_t v8 = hevcbridgeUPush(v43, 1, 0);
            if (v8) {
              goto LABEL_601;
            }
          }
        }
        if (*((unsigned char *)a1 + 29126) && a1[7321])
        {
          uint64_t v28 = 0;
          int v29 = (unsigned __int16 *)(a1 + 7326);
          do
          {
            uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, *((_DWORD *)v29 - 4));
            if (v8) {
              goto LABEL_601;
            }
            uint64_t v8 = hevcbridgeUPush(v43, 8, 8);
            if (v8) {
              goto LABEL_601;
            }
            uint64_t v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)v29 - 12));
            if (v8) {
              goto LABEL_601;
            }
            uint64_t v8 = hevcbridgeUPush(v43, 12, *(v29 - 5));
            if (v8) {
              goto LABEL_601;
            }
            uint64_t v8 = hevcbridgeUPush(v43, 12, *(v29 - 4));
            if (v8) {
              goto LABEL_601;
            }
            uint64_t v8 = hevcbridgeUPush(v43, 12, *(v29 - 3));
            if (v8) {
              goto LABEL_601;
            }
            uint64_t v8 = hevcbridgeUPush(v43, 12, *(v29 - 2));
            if (v8) {
              goto LABEL_601;
            }
            uint64_t v8 = hevcbridgeUPush(v43, 12, *(v29 - 1));
            if (v8) {
              goto LABEL_601;
            }
            uint64_t v8 = hevcbridgeUPush(v43, 12, *v29);
            if (v8) {
              goto LABEL_601;
            }
            v29 += 18;
          }
          while (++v28 < (unint64_t)a1[7321]);
        }
        if (!*((unsigned char *)a1 + 29127)
          || (uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 1), !v8)
          && (uint64_t v8 = hevcbridgeUPush(v43, 8, 9), !v8)
          && (uint64_t v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29468)), !v8))
        {
          if (*((unsigned char *)a1 + 29128) && a1[7372])
          {
            unint64_t v30 = 0;
            uint64_t v31 = (unsigned __int8 *)a1 + 29502;
            do
            {
              uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, *(_DWORD *)(v31 - 10));
              if (v8) {
                goto LABEL_601;
              }
              uint64_t v8 = hevcbridgeUPush(v43, 8, 10);
              if (v8) {
                goto LABEL_601;
              }
              uint64_t v8 = hevcbridgeUPush(v43, 8, *(v31 - 6));
              if (v8) {
                goto LABEL_601;
              }
              uint64_t v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)v31 - 2));
              if (v8) {
                goto LABEL_601;
              }
              uint64_t v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)v31 - 1));
              if (v8) {
                goto LABEL_601;
              }
              uint64_t v8 = hevcbridgeUPush(v43, 8, *v31);
              if (v8) {
                goto LABEL_601;
              }
              ++v30;
              v31 += 28;
            }
            while (v30 < a1[7372]);
          }
          if (!*((unsigned char *)a1 + 29129)
            || (uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 4), !v8)
            && (uint64_t v8 = hevcbridgeUPush(v43, 8, 11), !v8)
            && (uint64_t v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29604)), !v8)
            && (uint64_t v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29605)), !v8)
            && (uint64_t v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29606)), !v8)
            && (uint64_t v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29607)), !v8))
          {
            if (!*((unsigned char *)a1 + 29130)
              || (uint64_t v8 = hevcbridgeUEPush((uint64_t)v43, 2), !v8)
              && (uint64_t v8 = hevcbridgeUPush(v43, 8, 254), !v8)
              && (uint64_t v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29608)), !v8)
              && (uint64_t v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29609)), !v8))
            {
LABEL_641:
              hevcBridgeAlignToByte((uint64_t)v43);
              uint64_t v32 = v46 - v43[0];
              uint64_t v33 = &v5[v46 - v43[0]];
              if ((uint64_t)v46 - v43[0] - 1 < 1)
              {
                unsigned int v35 = -1;
              }
              else
              {
                unsigned int v34 = v5 + 1;
                unsigned int v35 = -1;
                do
                {
                  char v36 = *v34++;
                  unsigned int v35 = CRC32Lut[(v36 ^ HIBYTE(v35))] ^ (v35 << 8);
                }
                while (v34 < v33);
              }
              *(_DWORD *)uint64_t v33 = bswap32(v35);
              v5[v32 + 4] = 0x80;
              CFIndex BufferWithStartCodeEmulationBytes = (int)generateBufferWithStartCodeEmulationBytes(v32 + 5, v5, (uint64_t)v7);
              CFAllocatorRef v38 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
              GlobalCFAllocatorFigMCFAllocatorRef alloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
              CFDataRef v40 = CFDataCreateWithBytesNoCopy(v38, v7, BufferWithStartCodeEmulationBytes, GlobalCFAllocatorFigMalloc);
              if (v40)
              {
                uint64_t v7 = 0;
                uint64_t v12 = 0;
                *long long v42 = v40;
              }
              else
              {
                uint64_t v12 = 0;
              }
              goto LABEL_650;
            }
          }
        }
      }
    }
LABEL_601:
    uint64_t v12 = v8;
    goto LABEL_650;
  }
  uint64_t v21 = 0;
  while (1)
  {
    uint64_t v22 = hevcbridgeUEPush((uint64_t)v43, 11);
    if (v22) {
      break;
    }
    uint64_t v22 = hevcbridgeUPush(v43, 8, 2);
    if (v22) {
      break;
    }
    uint64_t v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14572));
    if (v22) {
      break;
    }
    uint64_t v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14573));
    if (v22) {
      break;
    }
    uint64_t v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14574));
    if (v22) {
      break;
    }
    uint64_t v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14575));
    if (v22) {
      break;
    }
    uint64_t v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14576));
    if (v22) {
      break;
    }
    uint64_t v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14577));
    if (v22) {
      break;
    }
    uint64_t v22 = hevcbridgeIPush((uint64_t)v43, 13, *((__int16 *)a1 + 7 * v21 + 14578));
    if (v22) {
      break;
    }
    int v23 = 4;
    while (--v23)
    {
      uint64_t v22 = hevcbridgeUPush(v43, 1, 0);
      if (v22) {
        goto LABEL_649;
      }
    }
    if (++v21 >= (unint64_t)a1[7285]) {
      goto LABEL_555;
    }
  }
LABEL_649:
  uint64_t v12 = v22;
LABEL_650:
  free(v5);
  free(v7);
  return v12;
}

uint64_t FigHEVCBridge_WritePaddingNALU(unsigned int a1, unsigned int a2, _WORD *a3)
{
  if (a3)
  {
    if (a2 <= 4 && ((1 << a2) & 0x16) != 0)
    {
      size_t v5 = a1 - (a2 + 2);
      if (a1 > a2 + 2)
      {
        unsigned int v6 = a1 - a2;
        if (a2 == 2)
        {
          if (a1 < 0x10000)
          {
            *a3 = bswap32(v6) >> 16;
            goto LABEL_14;
          }
        }
        else if (a2 == 1)
        {
          if (a1 < 0x100)
          {
            *(unsigned char *)a3 = v6;
LABEL_14:
            uint64_t v7 = (_WORD *)((char *)a3 + a2);
            *uint64_t v7 = 332;
            memset(v7 + 1, 255, v5);
            *((unsigned char *)a3 + a1 - 1) = 0x80;
            return 0;
          }
        }
        else if (a1 <= 0x10000 || a2 != 4)
        {
          *(_DWORD *)a3 = bswap32(v6);
          goto LABEL_14;
        }
      }
    }
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t hevcbridgeAdvanceInBitstream(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 76) + a2;
  int v4 = v3 >> 3;
  *(_DWORD *)(a1 + 76) = v3 & 7;
  if (*(unsigned char *)(a1 + 40))
  {
    size_t v5 = (*(_DWORD *)(a1 + 72) - v4);
    *(_DWORD *)(a1 + 72) = v5;
    if (!a2 || v3 >= 8)
    {
      if (v4 >= 8) {
        char v6 = 8;
      }
      else {
        char v6 = v3 >> 3;
      }
      *(_DWORD *)(a1 + 96) >>= v6;
      if ((int)v5 >= 1)
      {
        memmove((void *)(a1 + 64), (const void *)(a1 + 64 + v4), v5);
        LODWORD(v5) = *(_DWORD *)(a1 + 72);
      }
      uint64_t v7 = *(unsigned char **)(a1 + 56);
      uint64_t v8 = *(void *)(a1 + 8) + *(void *)a1 - (void)v7;
      if ((int)v5 <= 3 && v8 >= 1)
      {
        do
        {
          if ((unint64_t)(v7 + 3) > *(void *)(a1 + 24) && *(void *)(a1 + 16))
          {
            uint64_t result = hevcbridgeAdvanceAcrossBBufDiscontiguity(a1, 1);
            if (result) {
              return result;
            }
            uint64_t v7 = *(unsigned char **)(a1 + 56);
          }
          if (*v7) {
            BOOL v16 = 0;
          }
          else {
            BOOL v16 = (unint64_t)v8 >= 3;
          }
          if (v16 && !v7[1] && v7[2] == 3)
          {
            uint64_t v17 = *(unsigned int *)(a1 + 72);
            if ((v17 & 0x80000000) == 0)
            {
              *(unsigned char *)(a1 + v17 + 64) = 0;
              LODWORD(v17) = *(_DWORD *)(a1 + 72);
            }
            *(_DWORD *)(a1 + 72) = v17 + 1;
            if ((int)v17 <= -2)
            {
              LODWORD(v5) = v17 + 2;
              *(_DWORD *)(a1 + 72) = v17 + 2;
              v7 += 3;
              *(void *)(a1 + 56) = v7;
            }
            else
            {
              *(unsigned char *)(a1 + (v17 + 1) + 64) = 0;
              int v18 = *(_DWORD *)(a1 + 72);
              LODWORD(v5) = v18 + 1;
              *(_DWORD *)(a1 + 72) = v18 + 1;
              v7 += 3;
              *(void *)(a1 + 56) = v7;
              if (v18 >= 1) {
                *(_DWORD *)(a1 + 96) |= 1 << v18;
              }
            }
            v8 -= 3;
            ++*(void *)(a1 + 88);
          }
          else
          {
            uint64_t v19 = *(unsigned int *)(a1 + 72);
            if ((v19 & 0x80000000) == 0)
            {
              *(unsigned char *)(a1 + v19 + 64) = *v7;
              LODWORD(v19) = *(_DWORD *)(a1 + 72);
            }
            LODWORD(v5) = v19 + 1;
            *(_DWORD *)(a1 + 72) = v19 + 1;
            *(void *)(a1 + 56) = ++v7;
            --v8;
          }
        }
        while ((int)v5 <= 3 && v8 > 0);
      }
      uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)*(unsigned int *)(a1 + 96));
      v10.i16[0] = vaddlv_u8(v10);
      *(void *)(a1 + 48) = &v7[-(int)v5 - v10.u32[0]];
    }
    if ((int)v5 > 0 || (*(unsigned char *)(a1 + 41) = 1, !v5) && !*(_DWORD *)(a1 + 76))
    {
      unsigned int v11 = *(_DWORD *)(a1 + 64);
LABEL_25:
      unsigned int v15 = bswap32(v11);
LABEL_26:
      uint64_t result = 0;
      *(_DWORD *)(a1 + 80) = v15 << *(_DWORD *)(a1 + 76);
      return result;
    }
  }
  else
  {
    uint64_t v12 = (unsigned int *)(*(void *)(a1 + 48) + v4);
    *(void *)(a1 + 48) = v12;
    if ((unint64_t)(v12 + 1) <= *(void *)(a1 + 24)) {
      goto LABEL_24;
    }
    if (*(void *)(a1 + 16))
    {
      uint64_t result = hevcbridgeAdvanceAcrossBBufDiscontiguity(a1, 0);
      if (result) {
        return result;
      }
      uint64_t v12 = *(unsigned int **)(a1 + 48);
    }
    uint64_t v14 = *(void *)(a1 + 8) + *(void *)a1 - (void)v12;
    if (v14 > 3)
    {
LABEL_24:
      unsigned int v11 = *v12;
      goto LABEL_25;
    }
    unsigned int v15 = 0;
    int v21 = 3;
    uint64_t v22 = v12;
    do
    {
      if (v14 >= 1)
      {
        int v23 = *(unsigned __int8 *)v22;
        uint64_t v22 = (unsigned int *)((char *)v22 + 1);
        v15 |= v23;
        --v14;
      }
      v15 <<= 8;
      --v21;
    }
    while (v21);
    *(_DWORD *)(a1 + 80) = v15;
    if (v22 != v12) {
      goto LABEL_26;
    }
    *(unsigned char *)(a1 + 41) = 1;
    if (!v14 && !*(_DWORD *)(a1 + 76)) {
      goto LABEL_26;
    }
  }

  return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
}

uint64_t hevcbridgeAdvanceAcrossBBufDiscontiguity(uint64_t a1, int a2)
{
  if (a2) {
    uint64_t v3 = 56;
  }
  else {
    uint64_t v3 = 48;
  }
  int v4 = *(char **)(a1 + v3);
  size_t lengthAtOffsetOut = 0;
  dataPointerOut = v4;
  size_t v5 = (size_t)&v4[-*(void *)a1];
  size_t totalLengthOut = 0;
  uint64_t result = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(a1 + 16), v5, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
  if (!result)
  {
    if (lengthAtOffsetOut > 7 || lengthAtOffsetOut == totalLengthOut)
    {
      uint64_t v7 = dataPointerOut;
      uint64_t v8 = &dataPointerOut[lengthAtOffsetOut];
LABEL_13:
      uint64_t result = 0;
      *(void *)(a1 + 24) = v8;
      *(void *)a1 = &v7[-v5];
      *(void *)(a1 + v3) = v7;
      return result;
    }
    if (totalLengthOut >= 8) {
      size_t v9 = 8;
    }
    else {
      size_t v9 = totalLengthOut;
    }
    uint64_t v7 = (char *)(a1 + 32);
    uint64_t result = CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 16), v5, v9, (void *)(a1 + 32));
    if (!result)
    {
      uint64_t v8 = &v7[v9];
      goto LABEL_13;
    }
  }
  return result;
}

uint64_t hevcbridgeUPullLong(uint64_t a1, int a2, _DWORD *a3)
{
  int v9 = 0;
  if (*(unsigned char *)(a1 + 41) || a2 <= 0 || a2 >= 0x21)
  {
    uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  if (a2 > 0x18)
  {
    int v7 = 0;
    int v8 = 0;
    uint64_t result = hevcbridgeUPull(a1, a2 - 16, &v8);
    if (!result)
    {
      uint64_t result = hevcbridgeUPull(a1, 16, &v7);
      int v6 = v7 + (v8 << 16);
      goto LABEL_8;
    }
LABEL_10:
    int v6 = 0;
    goto LABEL_8;
  }
  uint64_t result = hevcbridgeUPull(a1, a2, &v9);
  int v6 = v9;
LABEL_8:
  *a3 = v6;
  return result;
}

uint64_t hevcbridgeUPullAlways(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, _DWORD *a5, int a6)
{
  uint64_t result = hevcbridgeUPullLong(a1, a6, a5);
  if (a3 && !result)
  {
    unsigned int v11 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))a2[2];
    uint64_t v12 = *a2;
    uint64_t v13 = *a5;
    return v11(v12, a4, v13, 0xFFFFFFFFLL);
  }
  return result;
}

uint64_t hevcbridgeParseVideoParameterSet(uint64_t a1, uint64_t *a2)
{
  unsigned int v45 = 0;
  __int16 v44 = 0;
  uint64_t v43 = 0;
  char v42 = 0;
  unsigned int v40 = 0;
  unsigned int v41 = 0;
  __int16 v39 = 0;
  uint64_t v4 = *(uint64_t *)((char *)a2 + 44);
  uint64_t v5 = hevcbridgeUPullLong(a1, 4, &v45);
  uint64_t v6 = v5;
  if ((v4 & 1) != 0 && !v5) {
    uint64_t v6 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 3, v45, 0xFFFFFFFFLL);
  }
  if (!v6)
  {
    uint64_t v7 = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 1) & 1, 4, (unsigned char *)&v44 + 1);
    if (v7) {
      goto LABEL_7;
    }
    uint64_t v7 = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 2) & 1, 5, &v44);
    if (v7) {
      goto LABEL_7;
    }
    uint64_t v17 = *(uint64_t *)((char *)a2 + 44);
    uint64_t v18 = hevcbridgeUPullLong(a1, 6, (_DWORD *)&v43 + 1);
    uint64_t v6 = v18;
    if ((v17 & 8) != 0 && !v18) {
      uint64_t v6 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 6, HIDWORD(v43), 0xFFFFFFFFLL);
    }
    if (!v6)
    {
      uint64_t v7 = hevcbridgeUPullAlways(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 4) & 1, 7, &v43, 3);
      if (v7
        || (uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 5) & 1, 8), v7)
        || (uint64_t v7 = hevcbridgeUSkip(a1, 16), v7))
      {
LABEL_7:
        uint64_t v6 = v7;
        goto LABEL_8;
      }
      uint64_t v19 = v43;
      uint64_t v20 = hevcbridgeParseProfileTierLevel(a1, a2, 1, v43);
      uint64_t v6 = v20;
      if (v20 == 1)
      {
        int v8 = 0;
        int v9 = 0;
        uint8x8_t v10 = (void **)a2[18];
        if (!v10) {
          goto LABEL_22;
        }
        goto LABEL_18;
      }
      if (!v20)
      {
        uint64_t v7 = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 6) & 1, 9, &v42);
        if (v7) {
          goto LABEL_7;
        }
        unsigned int v21 = v42 ? 0 : v19;
        do
        {
          uint64_t v7 = hevcbridgeUESkip(a1);
          if (v7) {
            goto LABEL_7;
          }
          uint64_t v7 = hevcbridgeUESkip(a1);
          if (v7) {
            goto LABEL_7;
          }
          uint64_t v7 = hevcbridgeUESkip(a1);
          if (v7) {
            goto LABEL_7;
          }
          ++v21;
        }
        while (v21 <= v19);
        uint64_t v7 = hevcbridgeUPullAlways(a1, a2, *((unsigned __int8 *)a2 + 44) >> 7, 10, &v41, 6);
        if (v7) {
          goto LABEL_7;
        }
        uint64_t v7 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 8) & 1, 11, &v40);
        if (v7) {
          goto LABEL_7;
        }
        uint64_t v34 = v40;
        if (v40 < 0x400)
        {
          if (v40)
          {
            unsigned int v22 = v41;
            unsigned int v23 = v41 + 1;
            unsigned int v35 = malloc_type_calloc(v40 + 1, v41 + 1, 0x100004077774924uLL);
            unsigned int v24 = 1;
            uint64_t v33 = malloc_type_calloc(v34 + 1, 1uLL, 0x100004077774924uLL);
LABEL_47:
            unsigned __int8 v25 = 0;
            int v26 = 0;
            while (1)
            {
              LOBYTE(v37) = 0;
              uint64_t v27 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 9) & 1, 12, &v37);
              if (v27) {
                break;
              }
              if ((_BYTE)v37)
              {
                int v28 = v26;
                v35[v23 * v24 + v25++] = v26;
                unsigned int v29 = v22;
              }
              else
              {
                unsigned int v29 = v22;
                int v28 = v26;
              }
              int v26 = v28 + 1;
              if (v28 + 1 > v29)
              {
                v33[v24++] = v25;
                if (v24 <= v34) {
                  goto LABEL_47;
                }
                goto LABEL_56;
              }
            }
          }
          else
          {
            uint64_t v33 = 0;
            unsigned int v35 = 0;
LABEL_56:
            uint64_t v27 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 10) & 1, 13, (unsigned char *)&v39 + 1);
            if (!v27)
            {
              if (!HIBYTE(v39)) {
                goto LABEL_75;
              }
              char v38 = 0;
              unsigned int v37 = 0;
              uint64_t v6 = hevcbridgeUPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 11) & 1, 14, 32);
              if (v6) {
                goto LABEL_58;
              }
              uint64_t v6 = hevcbridgeUPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 12) & 1, 15, 32);
              if (v6) {
                goto LABEL_58;
              }
              uint64_t v6 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 13) & 1, 16, &v38);
              if (v6) {
                goto LABEL_58;
              }
              if (v38)
              {
                uint64_t v6 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 14) & 1, 17);
                if (v6) {
                  goto LABEL_58;
                }
              }
              uint64_t v6 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 15) & 1, 18, &v37);
              if (v6) {
                goto LABEL_58;
              }
              unsigned int v30 = v37;
              if (v37)
              {
                int v31 = 0;
                while (1)
                {
                  uint64_t v27 = hevcbridgeUESkip(a1);
                  if (v27) {
                    break;
                  }
                  if (v31)
                  {
                    int v36 = 0;
                    uint64_t v27 = hevcbridgeUPull(a1, 1, &v36);
                    if (v27) {
                      break;
                    }
                    unsigned __int8 v32 = v36;
                  }
                  else
                  {
                    unsigned __int8 v32 = 1;
                  }
                  uint64_t v6 = hevcbridgeParseHRDParameters(a1, (uint64_t)a2, v32, v19);
                  if (v6) {
                    goto LABEL_58;
                  }
                  if (v30 == ++v31) {
                    goto LABEL_75;
                  }
                }
              }
              else
              {
LABEL_75:
                uint64_t v6 = hevcbridgeUPullFlagAlways(a1, a2, HIWORD(*((_DWORD *)a2 + 11)) & 1, 19, &v39);
                if (v6 || !(_BYTE)v39) {
                  goto LABEL_58;
                }
                unsigned int v37 = 0;
                while (*(_DWORD *)(a1 + 76))
                {
                  uint64_t v27 = hevcbridgeUPullLong(a1, 1, &v37);
                  if (v27) {
                    goto LABEL_57;
                  }
                  if (v37 != 1)
                  {
                    uint64_t v6 = 4294954582;
                    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
                    goto LABEL_58;
                  }
                }
                uint64_t v6 = hevcbridgeParseVPSExtension(a1, (uint64_t)a2, HIBYTE(v44), v44, HIDWORD(v43), v19, v34, v41, v35, v33);
                if (v6) {
                  goto LABEL_58;
                }
                uint64_t v27 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 17) & 1, 20, &v36);
              }
            }
          }
LABEL_57:
          uint64_t v6 = v27;
LABEL_58:
          int v8 = v35;
          int v9 = v33;
          goto LABEL_9;
        }
        uint64_t v6 = 4294954582;
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
    }
  }
LABEL_8:
  int v8 = 0;
  int v9 = 0;
LABEL_9:
  uint8x8_t v10 = (void **)a2[18];
  if (v10) {
    BOOL v11 = v6 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11 && v6 != 1)
  {
    unsigned int v15 = *v10;
    if (*v10)
    {
      dispatch_queue_t *v10 = 0;
      free(v15);
    }
    goto LABEL_22;
  }
  if (!v10) {
    goto LABEL_22;
  }
LABEL_18:
  uint64_t v13 = *v10;
  if (v13)
  {
    unsigned int v14 = v45;
    *uint64_t v13 = 32;
    v13[1] = v14;
  }
LABEL_22:
  free(v8);
  free(v9);
  return v6;
}

uint64_t hevcbridgeParseSequenceParameterSet(uint64_t a1, void *a2, int a3)
{
  unsigned int v71 = 0;
  unsigned int v70 = 0;
  uint64_t v69 = 0;
  char v68 = 0;
  unsigned int v66 = 0;
  int v67 = 0;
  char v65 = 0;
  uint64_t v64 = 0;
  char v63 = 0;
  unsigned int v62 = 0;
  char v61 = 0;
  unsigned int v59 = 0;
  unsigned int v60 = 0;
  __int16 count_6 = 0;
  char count_5 = 0;
  unsigned int count = 0;
  __int16 v55 = 0;
  __int16 v54 = 0;
  __int16 v53 = 0;
  __int16 v52 = 0;
  int v51 = 0;
  uint64_t v6 = *(void *)((char *)a2 + 44);
  uint64_t v7 = hevcbridgeUPullLong(a1, 4, &v71);
  uint64_t v8 = v7;
  if ((v6 & 1) != 0 && !v7) {
    uint64_t v8 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 65, v71, 0xFFFFFFFFLL);
  }
  if (v8) {
    goto LABEL_5;
  }
  uint64_t v12 = (void *)a2[17];
  if (v12 && (uint64_t v13 = a2[16]) != 0)
  {
    while (1)
    {
      unsigned int v14 = (_DWORD *)*v12;
      if (*(_DWORD *)*v12 == 32 && v14[1] == v71) {
        break;
      }
      ++v12;
      if (!--v13) {
        goto LABEL_15;
      }
    }
    unsigned int v15 = *((unsigned __int8 *)v14 + 4494);
  }
  else
  {
LABEL_15:
    unsigned int v15 = 0;
  }
  uint64_t v16 = *(void *)((char *)a2 + 44);
  if (a3)
  {
    uint64_t v17 = hevcbridgeUPullLong(a1, 3, (_DWORD *)&v69 + 1);
    uint64_t v8 = v17;
    if ((v16 & 4) != 0 && !v17) {
      uint64_t v8 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 67, HIDWORD(v69), 0xFFFFFFFFLL);
    }
    if (v8) {
      goto LABEL_5;
    }
    unsigned int v18 = HIDWORD(v69);
    if (HIDWORD(v69) == 7) {
      unsigned int v18 = v15;
    }
    unsigned int v70 = v18;
    if (HIDWORD(v69) == 7)
    {
      int v19 = 1;
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v21 = hevcbridgeUPullLong(a1, 3, &v70);
    uint64_t v8 = v21;
    if ((v16 & 2) != 0 && !v21) {
      uint64_t v8 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 66, v70, 0xFFFFFFFFLL);
    }
    if (v8) {
      goto LABEL_5;
    }
  }
  uint64_t v22 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 3) & 1, 68);
  if (v22) {
    goto LABEL_75;
  }
  unsigned int v15 = v70;
  uint64_t v22 = hevcbridgeParseProfileTierLevel(a1, a2, 1, v70);
  if (v22) {
    goto LABEL_75;
  }
  int v19 = 0;
LABEL_35:
  uint64_t v23 = *(void *)((char *)a2 + 44);
  uint64_t v24 = hevcbridgeUEPullLong(a1, (unsigned int *)&v69);
  uint64_t v8 = v24;
  if ((v23 & 0x10) != 0 && !v24) {
    uint64_t v8 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 69, v69, 0xFFFFFFFFLL);
  }
  if (v8) {
    goto LABEL_5;
  }
  unsigned int v25 = *((unsigned __int8 *)a2 + 44);
  if (v19)
  {
    uint64_t v22 = hevcbridgeUPullFlagAlways(a1, a2, (v25 >> 5) & 1, 70, &v68);
    if (v22) {
      goto LABEL_75;
    }
    char v26 = v68;
    if (v68)
    {
      uint64_t v22 = hevcbridgeUPullAlways(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 6) & 1, 71, &v67, 8);
      if (v22) {
        goto LABEL_75;
      }
    }
    unsigned int v27 = 0;
  }
  else
  {
    uint64_t v22 = hevcbridgeUEPullAlways(a1, a2, (v25 >> 7) & 1, 72, &v66);
    if (v22) {
      goto LABEL_75;
    }
    unsigned int v27 = v66;
    if (v66 == 3)
    {
      uint64_t v22 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 8) & 1, 73, &v65);
      if (v22) {
        goto LABEL_75;
      }
    }
    uint64_t v22 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 9) & 1, 74, (unsigned int *)&v64 + 1);
    if (v22) {
      goto LABEL_75;
    }
    uint64_t v22 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 10) & 1, 75, (unsigned int *)&v64);
    if (v22) {
      goto LABEL_75;
    }
    uint64_t v22 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 11) & 1, 76, &v63);
    if (v22) {
      goto LABEL_75;
    }
    if (v63)
    {
      uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 12) & 1, 77);
      if (v22) {
        goto LABEL_75;
      }
      uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 13) & 1, 78);
      if (v22) {
        goto LABEL_75;
      }
      uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 14) & 1, 79);
      if (v22) {
        goto LABEL_75;
      }
      uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 15) & 1, 80);
      if (v22) {
        goto LABEL_75;
      }
    }
    uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, HIWORD(*((_DWORD *)a2 + 11)) & 1, 81);
    if (v22) {
      goto LABEL_75;
    }
    uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 17) & 1, 82);
    if (v22) {
      goto LABEL_75;
    }
    char v26 = 0;
  }
  uint64_t v22 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 18) & 1, 83, &v62);
  if (v22) {
    goto LABEL_75;
  }
  unsigned int v28 = v62;
  if (v62 >= 0xD)
  {
LABEL_105:
    uint64_t v8 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_5;
  }
  if ((v19 & 1) == 0)
  {
    uint64_t v22 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 19) & 1, 84, &v61);
    if (!v22)
    {
      if (v61) {
        unsigned int v30 = 0;
      }
      else {
        unsigned int v30 = v15;
      }
      while (1)
      {
        uint64_t v22 = hevcbridgeUESkip(a1);
        if (v22) {
          break;
        }
        uint64_t v22 = hevcbridgeUESkip(a1);
        if (v22) {
          break;
        }
        uint64_t v22 = hevcbridgeUESkip(a1);
        if (v22) {
          break;
        }
        if (++v30 > v15) {
          goto LABEL_47;
        }
      }
    }
    goto LABEL_75;
  }
LABEL_47:
  uint64_t v22 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 20) & 1, 85, &v60);
  if (v22
    || (uint64_t v22 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 21) & 1, 86, &v59), v22)
    || (uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 22) & 1, 87), v22)
    || (uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 23) & 1, 88), v22)
    || (uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, HIBYTE(*((_DWORD *)a2 + 11)) & 1, 89), v22)
    || (uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 25) & 1, 90), v22)
    || (uint64_t v22 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 26) & 1, 91, (unsigned char *)&count_6 + 1),
        v22))
  {
LABEL_75:
    uint64_t v8 = v22;
    goto LABEL_5;
  }
  if (!HIBYTE(count_6)) {
    goto LABEL_88;
  }
  LOBYTE(v50) = 0;
  LOBYTE(v49) = 0;
  if (v19)
  {
    uint64_t v8 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 27) & 1, 92, &v50);
    if (v8)
    {
LABEL_5:
      int v9 = 0;
      goto LABEL_6;
    }
    if ((_BYTE)v50)
    {
      uint64_t v29 = hevcbridgeUPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 28) & 1, 93, 6);
      goto LABEL_87;
    }
  }
  uint64_t v8 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 29) & 1, 94, &v49);
  if (v8) {
    goto LABEL_5;
  }
  if ((_BYTE)v49)
  {
    uint64_t v29 = hevcbridgeParseScalingListData(a1);
LABEL_87:
    uint64_t v8 = v29;
    if (v29) {
      goto LABEL_5;
    }
  }
LABEL_88:
  uint64_t v22 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 30) & 1, 95);
  if (v22) {
    goto LABEL_75;
  }
  uint64_t v22 = hevcbridgeUPullFlagAlways(a1, a2, *((_DWORD *)a2 + 11) >> 31, 96, &count_6);
  if (v22) {
    goto LABEL_75;
  }
  uint64_t v22 = hevcbridgeUPullFlagAlways(a1, a2, a2[6] & 1, 97, &count_5);
  if (v22) {
    goto LABEL_75;
  }
  if (count_5)
  {
    uint64_t v22 = hevcbridgeUPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 33) & 1, 98, 4);
    if (v22) {
      goto LABEL_75;
    }
    uint64_t v22 = hevcbridgeUPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 34) & 1, 99, 4);
    if (v22) {
      goto LABEL_75;
    }
    uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 35) & 1, 100);
    if (v22) {
      goto LABEL_75;
    }
    uint64_t v22 = hevcbridgeUEPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 36) & 1, 101);
    if (v22) {
      goto LABEL_75;
    }
    uint64_t v22 = hevcbridgeUPullFlagIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 37) & 1, 102);
    if (v22) {
      goto LABEL_75;
    }
  }
  uint64_t v22 = hevcbridgeUEPullAlways(a1, a2, (*(void *)((char *)a2 + 44) >> 38) & 1, 103, &count);
  if (v22) {
    goto LABEL_75;
  }
  uint64_t v31 = count;
  if (count >= 0x41) {
    goto LABEL_105;
  }
  if (a2[18])
  {
    *(void *)a2[18] = malloc_type_calloc(1uLL, 164 * count + 96, 0xA24C4799uLL);
    uint64_t v32 = *(void *)a2[18];
    if (!v32)
    {
      int v9 = 0;
      uint64_t v8 = 4294954583;
      goto LABEL_6;
    }
    int v33 = v69;
    *(_DWORD *)uint64_t v32 = 33;
    *(_DWORD *)(v32 + 4) = v33;
    *(_DWORD *)(v32 + 8) = v71;
    uint64_t v48 = v32 + 8;
    *(unsigned char *)(v32 + 53) = v19;
    unsigned int v34 = v60;
    *(_DWORD *)(v32 + 12) = a3;
    *(_DWORD *)(v32 + 16) = v34;
    int v35 = HIDWORD(v64);
    *(_DWORD *)(v32 + 20) = v59;
    *(_DWORD *)(v32 + 24) = v35;
    *(_DWORD *)(v32 + 28) = v64;
    *(_DWORD *)(v32 + 32) = v28;
    char v36 = v65;
    if (v65) {
      unsigned int v37 = 0;
    }
    else {
      unsigned int v37 = v27;
    }
    int v38 = v67;
    *(_DWORD *)(v32 + 44) = v37;
    *(_DWORD *)(v32 + 48) = v38;
    *(unsigned char *)(v32 + 52) = v26;
    *(unsigned char *)(v32 + 54) = v36;
    *(unsigned char *)(v32 + 88) = count_6;
    *(unsigned char *)(v32 + 89) = *((unsigned char *)a2 + 152);
    int v9 = (void *)(v32 + 96);
    *(_DWORD *)(v32 + 92) = v31;
  }
  else
  {
    int v9 = malloc_type_calloc(count, 0xA4uLL, 0x1000040B98E1C1EuLL);
    uint64_t v48 = 0;
  }
  if (v31)
  {
    uint64_t v39 = 0;
    uint64_t v40 = (uint64_t)v9;
    do
    {
      uint64_t v41 = hevcbridgeParseSTRefPicSet(a1, v39, v31, (uint64_t)v9, v40);
      if (v41) {
        goto LABEL_112;
      }
      ++v39;
      v40 += 164;
    }
    while (v31 != v39);
  }
  uint64_t v41 = hevcbridgeUPullFlagAlways(a1, a2, (*(void *)((char *)a2 + 44) >> 39) & 1, 104, (unsigned char *)&v55 + 1);
  if (v41)
  {
LABEL_112:
    uint64_t v8 = v41;
    goto LABEL_6;
  }
  int v42 = HIBYTE(v55);
  if (v48) {
    *(unsigned char *)(v48 + 47) = HIBYTE(v55);
  }
  if (v42)
  {
    unsigned int v50 = 0;
    uint64_t v8 = hevcbridgeUEPullAlways(a1, a2, *(_DWORD *)((unsigned char *)a2 + 49) & 1, 105, &v50);
    if (v8) {
      goto LABEL_6;
    }
    unsigned int v43 = v50;
    if (v50 > 0x20)
    {
      uint64_t v8 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_6;
    }
    if (v50)
    {
      int v44 = v28 + 4;
      unsigned int v45 = (unsigned char *)(v48 + 48);
      uint64_t v46 = v50;
      do
      {
        uint64_t v41 = hevcbridgeUSkip(a1, v44);
        if (v41) {
          goto LABEL_112;
        }
        int v49 = 0;
        uint64_t v47 = hevcbridgeUPull(a1, 1, &v49);
        uint64_t v8 = v47;
        if (!v48 || v47)
        {
          if (v47) {
            goto LABEL_6;
          }
        }
        else
        {
          *unsigned int v45 = v49;
        }
        ++v45;
      }
      while (--v46);
    }
    if (v48) {
      *(_DWORD *)(v48 + 28) = v43;
    }
  }
  uint64_t v41 = hevcbridgeUPullFlagAlways(a1, a2, (*(void *)((char *)a2 + 44) >> 41) & 1, 106, &v55);
  if (v41) {
    goto LABEL_112;
  }
  if (v48) {
    *(_DWORD *)(v48 + 32) = v55;
  }
  uint64_t v41 = hevcbridgeUPullFlagIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 42) & 1, 107);
  if (v41) {
    goto LABEL_112;
  }
  uint64_t v41 = hevcbridgeUPullFlagAlways(a1, a2, (*(void *)((char *)a2 + 44) >> 43) & 1, 108, (unsigned char *)&v54 + 1);
  if (v41) {
    goto LABEL_112;
  }
  if (HIBYTE(v54))
  {
    uint64_t v41 = hevcbridgeParseVUIParameters(a1, a2, v15);
    if (v41) {
      goto LABEL_112;
    }
  }
  uint64_t v41 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 19) & 1, 148, &v54);
  if (v41) {
    goto LABEL_112;
  }
  if ((_BYTE)v54)
  {
    uint64_t v41 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 20) & 1, 149, (unsigned char *)&v53 + 1);
    if (v41) {
      goto LABEL_112;
    }
    uint64_t v41 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 21) & 1, 150, &v53);
    if (v41) {
      goto LABEL_112;
    }
    uint64_t v41 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 22) & 1, 151, (unsigned char *)&v52 + 1);
    if (v41) {
      goto LABEL_112;
    }
    uint64_t v41 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 23) & 1, 152, &v52);
    if (v41) {
      goto LABEL_112;
    }
    uint64_t v41 = hevcbridgeUPullAlways(a1, a2, *(_DWORD *)((unsigned char *)a2 + 55) & 1, 153, &v51, 4);
    if (v41) {
      goto LABEL_112;
    }
    if (HIBYTE(v53))
    {
      uint64_t v41 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 25) & 1, 154);
      if (v41) {
        goto LABEL_112;
      }
      uint64_t v41 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 26) & 1, 155);
      if (v41) {
        goto LABEL_112;
      }
      uint64_t v41 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 27) & 1, 156);
      if (v41) {
        goto LABEL_112;
      }
      uint64_t v41 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 28) & 1, 157);
      if (v41) {
        goto LABEL_112;
      }
      uint64_t v41 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 29) & 1, 158);
      if (v41) {
        goto LABEL_112;
      }
      uint64_t v41 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 30) & 1, 159);
      if (v41) {
        goto LABEL_112;
      }
      uint64_t v41 = hevcbridgeUPullFlagIfRequested(a1, a2, *((_DWORD *)a2 + 13) >> 31, 160);
      if (v41) {
        goto LABEL_112;
      }
      uint64_t v41 = hevcbridgeUPullFlagIfRequested(a1, a2, a2[7] & 1, 161);
      if (v41) {
        goto LABEL_112;
      }
      uint64_t v41 = hevcbridgeUPullFlagIfRequested(a1, a2, (*(void *)((char *)a2 + 52) >> 33) & 1, 162);
      if (v41) {
        goto LABEL_112;
      }
    }
  }
  uint64_t v8 = 0;
LABEL_6:
  uint8x8_t v10 = (void **)a2[18];
  if (!v10)
  {
    BOOL v11 = v9;
    goto LABEL_26;
  }
  if (v8 >= 2)
  {
    BOOL v11 = *v10;
    if (*v10)
    {
      dispatch_queue_t *v10 = 0;
LABEL_26:
      free(v11);
    }
  }
  return v8;
}

uint64_t hevcbridgeParsePictureParameterSet(void *a1, void *a2)
{
  uint64_t v46 = 0;
  __int16 v45 = 0;
  char v44 = 0;
  unsigned int v43 = 0;
  uint64_t v42 = 0;
  __int16 v41 = 0;
  __int16 v40 = 0;
  __int16 v39 = 0;
  __int16 v38 = 0;
  __int16 v37 = 0;
  __int16 v36 = 0;
  __int16 v35 = 0;
  __int16 v34 = 0;
  __int16 v33 = 0;
  char v32 = 0;
  int v31 = 0;
  char v30 = 0;
  uint64_t v4 = *(void *)((char *)a2 + 44);
  uint64_t v5 = hevcbridgeUEPullLong((uint64_t)a1, (unsigned int *)&v46 + 1);
  uint64_t v6 = v5;
  if ((v4 & 1) != 0 && !v5) {
    uint64_t v6 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 163, HIDWORD(v46), 0xFFFFFFFFLL);
  }
  if (v6) {
    goto LABEL_81;
  }
  if (a2[18])
  {
    *(void *)a2[18] = malloc_type_calloc(1uLL, 0x11A0uLL, 0x1000040A601553DuLL);
    uint64_t v7 = *(_DWORD **)a2[18];
    if (!v7)
    {
      uint64_t v6 = 4294954583;
      goto LABEL_81;
    }
    int v8 = HIDWORD(v46);
    *uint64_t v7 = 34;
    v7[1] = v8;
    int v9 = v7 + 2;
  }
  else
  {
    int v9 = 0;
  }
  uint64_t v10 = *(void *)((char *)a2 + 44);
  uint64_t v11 = hevcbridgeUEPullLong((uint64_t)a1, (unsigned int *)&v46);
  uint64_t v6 = v11;
  if ((v10 & 2) != 0 && !v11) {
    uint64_t v6 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 164, v46, 0xFFFFFFFFLL);
  }
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((unsigned __int8 *)a2 + 44) >> 2) & 1, 165, (unsigned char *)&v45 + 1);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((unsigned __int8 *)a2 + 44) >> 3) & 1, 166, &v45);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((unsigned __int8 *)a2 + 44) >> 4) & 1, 167, &v42, 3);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagIfRequested((uint64_t)a1, a2, (*((unsigned __int8 *)a2 + 44) >> 5) & 1, 168);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((unsigned __int8 *)a2 + 44) >> 6) & 1, 169, &v44);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUEPullAlways((uint64_t)a1, a2, *((unsigned __int8 *)a2 + 44) >> 7, 170, &v43);
  if (v6) {
    goto LABEL_81;
  }
  unsigned int v12 = v43;
  if (v43 >= 0xF) {
    goto LABEL_100;
  }
  uint64_t v6 = hevcbridgeUEPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 8) & 1, 171, (unsigned int *)&v42 + 1);
  if (v6) {
    goto LABEL_81;
  }
  int v13 = HIDWORD(v42);
  if (HIDWORD(v42) >= 0xF) {
    goto LABEL_100;
  }
  uint64_t v6 = hevcbridgeSEPullIfRequested((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 9) & 1, 172);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagIfRequested((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 10) & 1, 173);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 11) & 1, 174, (unsigned char *)&v41 + 1);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 12) & 1, 175, &v41);
  if (v6) {
    goto LABEL_81;
  }
  if ((_BYTE)v41)
  {
    uint64_t v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 13) & 1, 176);
    if (v6) {
      goto LABEL_81;
    }
  }
  uint64_t v6 = hevcbridgeSEPullIfRequested((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 14) & 1, 177);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeSEPullIfRequested((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 15) & 1, 178);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, HIWORD(*((_DWORD *)a2 + 11)) & 1, 179, (unsigned char *)&v40 + 1);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 17) & 1, 180, &v40);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 18) & 1, 181, (unsigned char *)&v39 + 1);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagIfRequested((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 19) & 1, 182);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 20) & 1, 183, &v39);
  if (v6) {
    goto LABEL_81;
  }
  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 21) & 1, 184, (unsigned char *)&v38 + 1);
  if (v6) {
    goto LABEL_81;
  }
  char v14 = v39;
  if (!(_BYTE)v39) {
    goto LABEL_113;
  }
  unsigned int v28 = 0;
  unsigned int v29 = 0;
  char v27 = 0;
  uint64_t v6 = hevcbridgeUEPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 22) & 1, 185, &v29);
  if (!v6)
  {
    uint64_t v6 = hevcbridgeUEPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 23) & 1, 186, &v28);
    if (!v6)
    {
      uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, HIBYTE(*((_DWORD *)a2 + 11)) & 1, 187, &v27);
      if (!v6)
      {
        if (!v27)
        {
          unsigned int v23 = v29;
          if (v29)
          {
            do
            {
              uint64_t v19 = hevcbridgeUESkip((uint64_t)a1);
              if (v19) {
                goto LABEL_93;
              }
            }
            while (--v23);
          }
          unsigned int v24 = v28;
          if (v28)
          {
            do
            {
              uint64_t v19 = hevcbridgeUESkip((uint64_t)a1);
              if (v19) {
                goto LABEL_93;
              }
            }
            while (--v24);
          }
        }
        uint64_t v6 = hevcbridgeUPullFlagIfRequested((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 25) & 1, 188);
        if (!v6)
        {
LABEL_113:
          uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 26) & 1, 189, &v38);
          if (!v6)
          {
            uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 27) & 1, 190, (unsigned char *)&v37 + 1);
            if (!v6)
            {
              if (HIBYTE(v37))
              {
                uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 28) & 1, 191, &v37);
                if (v6) {
                  goto LABEL_81;
                }
                uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 29) & 1, 192, (unsigned char *)&v36 + 1);
                if (v6) {
                  goto LABEL_81;
                }
                char v15 = HIBYTE(v36);
                if (HIBYTE(v36)) {
                  goto LABEL_51;
                }
                uint64_t v6 = hevcbridgeSEPullIfRequested((uint64_t)a1, a2, (*((_DWORD *)a2 + 11) >> 30) & 1, 193);
                if (v6) {
                  goto LABEL_81;
                }
                uint64_t v6 = hevcbridgeSEPullIfRequested((uint64_t)a1, a2, *((_DWORD *)a2 + 11) >> 31, 194);
                if (v6) {
                  goto LABEL_81;
                }
              }
              char v15 = 0;
LABEL_51:
              uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, a2[6] & 1, 195, &v36);
              if (v6) {
                goto LABEL_81;
              }
              if ((_BYTE)v36)
              {
                uint64_t v16 = hevcbridgeParseScalingListData((uint64_t)a1);
                uint64_t v6 = v16;
                if (v16 == 1) {
                  return v6;
                }
                if (v16) {
                  goto LABEL_81;
                }
              }
              uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 33) & 1, 196, (unsigned char *)&v35 + 1);
              if (v6) {
                goto LABEL_81;
              }
              uint64_t v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 34) & 1, 197);
              if (v6) {
                goto LABEL_81;
              }
              uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 35) & 1, 198, &v35);
              if (v6) {
                goto LABEL_81;
              }
              uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 36) & 1, 199, (unsigned char *)&v34 + 1);
              if (v6) {
                goto LABEL_81;
              }
              if (!HIBYTE(v34)) {
                goto LABEL_94;
              }
              uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 37) & 1, 200, &v34);
              if (v6) {
                goto LABEL_81;
              }
              uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 38) & 1, 201, (unsigned char *)&v33 + 1);
              if (v6) {
                goto LABEL_81;
              }
              uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 39) & 1, 202, &v33);
              if (v6) {
                goto LABEL_81;
              }
              uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, *(_DWORD *)((unsigned char *)a2 + 49) & 1, 203, &v32);
              if (v6) {
                goto LABEL_81;
              }
              uint64_t v6 = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 41) & 1, 204, &v31, 4);
              if (v6) {
                goto LABEL_81;
              }
              if ((_BYTE)v34)
              {
                if (HIBYTE(v41))
                {
                  uint64_t v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 42) & 1, 205);
                  if (v6) {
                    goto LABEL_81;
                  }
                }
                uint64_t v6 = hevcbridgeUPullFlagIfRequested((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 43) & 1, 206);
                if (v6) {
                  goto LABEL_81;
                }
                uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 44) & 1, 207, &v30);
                if (v6) {
                  goto LABEL_81;
                }
                char v17 = v30;
                if (v30)
                {
                  unsigned int v29 = 0;
                  uint64_t v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 45) & 1, 208);
                  if (!v6)
                  {
                    uint64_t v6 = hevcbridgeUEPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 46) & 1, 209, &v29);
                    if (!v6)
                    {
                      int v18 = 0;
                      unsigned int v26 = v29;
                      while (1)
                      {
                        uint64_t v19 = hevcbridgeSESkip((uint64_t)a1);
                        if (v19) {
                          break;
                        }
                        uint64_t v19 = hevcbridgeSESkip((uint64_t)a1);
                        if (v19) {
                          break;
                        }
                        if (++v18 > v26) {
                          goto LABEL_77;
                        }
                      }
LABEL_93:
                      uint64_t v6 = v19;
                      goto LABEL_81;
                    }
                  }
                  goto LABEL_81;
                }
LABEL_77:
                uint64_t v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, a2, (*(void *)((char *)a2 + 44) >> 47) & 1, 210);
                if (v6) {
                  goto LABEL_81;
                }
                uint64_t v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, a2, *(_DWORD *)((unsigned char *)a2 + 50) & 1, 211);
                if (v6) {
                  goto LABEL_81;
                }
              }
              else
              {
LABEL_94:
                char v17 = 0;
              }
              if (v9)
              {
                int v25 = v42;
                *int v9 = v46;
                v9[1] = v25;
                int v9[2] = v12;
                void v9[3] = v13;
                *((unsigned char *)v9 + 16) = HIBYTE(v45);
                *((unsigned char *)v9 + 17) = v45;
                *((unsigned char *)v9 + 18) = HIBYTE(v35);
                *((unsigned char *)v9 + 19) = v44;
                *((unsigned char *)v9 + 20) = v40;
                *((unsigned char *)v9 + 21) = HIBYTE(v39);
                *((unsigned char *)v9 + 22) = HIBYTE(v40);
                *((unsigned char *)v9 + 23) = v17;
                *((unsigned char *)v9 + 24) = v37;
                *((unsigned char *)v9 + 25) = v15;
                *((unsigned char *)v9 + 26) = v38;
                *((unsigned char *)v9 + 27) = v14;
                *((unsigned char *)v9 + 28) = HIBYTE(v38);
                *((unsigned char *)v9 + 29) = v35;
              }
              if (HIBYTE(v33))
              {
                uint64_t v6 = hevcbridgeParsePictureParameterSetMultilayerExtension((uint64_t)a1, a2);
                if (v6) {
                  goto LABEL_81;
                }
              }
              if (!(_BYTE)v33)
              {
                if (v32)
                {
                  uint64_t v6 = hevcbridgeParsePictureParameterSetSCCExtension((uint64_t)a1, (uint64_t)a2);
                  if (v6 || !v31) {
                    goto LABEL_81;
                  }
                }
                else if (!v31)
                {
                  return 0;
                }
                do
                  uint64_t v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 52) >> 35) & 1, 262, &v29);
                while (!v6
                     && (unint64_t)(a1[6] + 1) < a1[1] + *a1
                     && hevcbridgeMoreRBSPData((uint64_t)a1));
                goto LABEL_81;
              }
LABEL_100:
              uint64_t v6 = 4294954582;
              FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            }
          }
        }
      }
    }
  }
LABEL_81:
  if (v6 >= 2)
  {
    uint64_t v20 = (void **)a2[18];
    if (v20)
    {
      uint64_t v21 = *v20;
      if (*v20)
      {
        *uint64_t v20 = 0;
        free(v21);
      }
    }
  }
  return v6;
}

uint64_t hevcbridgeParseSEIRBSP(void *a1, void *a2, uint64_t a3)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  int v74 = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    unsigned int v75 = 0;
    unsigned int v76 = 0;
    if (*((unsigned char *)a2 + 44))
    {
      CFMutableArrayRef Mutable = CFDataCreateMutable(v6, 0);
      if (!Mutable)
      {
        uint64_t v11 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        goto LABEL_195;
      }
    }
    else
    {
      CFMutableArrayRef Mutable = 0;
    }
    LODWORD(v8) = 0;
    do
    {
      char v9 = *((unsigned char *)a2 + 44);
      uint64_t v10 = hevcbridgeUPullLong((uint64_t)a1, 8, &v76);
      uint64_t v11 = v10;
      if ((v9 & 2) != 0 && !v10) {
        uint64_t v11 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 343, v76, 0xFFFFFFFFLL);
      }
      if (v11) {
        goto LABEL_193;
      }
      unsigned int v12 = v76;
      if (Mutable)
      {
        bytes[0] = v76;
        CFDataAppendBytes(Mutable, bytes, 1);
      }
      uint64_t v8 = v12 + v8;
    }
    while (v12 == 255);
    if ((*((unsigned char *)a2 + 44) & 4) != 0)
    {
      uint64_t v11 = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t))a2[2])(*a2, 344, v8, 0xFFFFFFFFLL);
      if (v11)
      {
LABEL_193:
        if (!Mutable) {
          goto LABEL_195;
        }
        goto LABEL_194;
      }
    }
    LODWORD(v13) = 0;
    do
    {
      char v14 = *((unsigned char *)a2 + 44);
      uint64_t v15 = hevcbridgeUPullLong((uint64_t)a1, 8, &v75);
      uint64_t v11 = v15;
      if ((v14 & 8) != 0 && !v15) {
        uint64_t v11 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 345, v75, 0xFFFFFFFFLL);
      }
      if (v11) {
        goto LABEL_193;
      }
      unsigned int v16 = v75;
      if (Mutable)
      {
        bytes[0] = v75;
        CFDataAppendBytes(Mutable, bytes, 1);
      }
      CFIndex v13 = v16 + v13;
    }
    while (v16 == 255);
    if (v13 < 0x100000)
    {
      if (!Mutable)
      {
        uint64_t v20 = 0;
LABEL_29:
        if ((*((unsigned char *)a2 + 44) & 0x10) != 0)
        {
          uint64_t v11 = ((uint64_t (*)(void, uint64_t, CFIndex, uint64_t))a2[2])(*a2, 346, v13, 0xFFFFFFFFLL);
          if (v11) {
            goto LABEL_193;
          }
        }
        if (a3 != 39
          || ((int v69 = 1, (v8 - 148) > 0x1C) || ((1 << (v8 + 108)) & 0x10020001) == 0) && v8 != 4)
        {
          if ((*((unsigned char *)a2 + 44) & 0x20) == 0)
          {
            if (!v20)
            {
              uint64_t v11 = hevcbridgeUSkip((uint64_t)a1, 8 * (int)v13);
              if (v11) {
                goto LABEL_193;
              }
              CFDataRef v28 = 0;
              int v69 = 0;
LABEL_51:
              char v29 = *((unsigned char *)a2 + 44);
              if ((v29 & 0x20) != 0)
              {
                uint64_t v30 = ((uint64_t (*)(void, uint64_t, const __CFData *))a2[4])(*a2, 347, v28);
                if (v30)
                {
                  uint64_t v11 = v30;
                  goto LABEL_191;
                }
                char v29 = *((unsigned char *)a2 + 44);
              }
              if (v29)
              {
                uint64_t v31 = ((uint64_t (*)(void, uint64_t, __CFData *))a2[4])(*a2, 342, Mutable);
                uint64_t v11 = v31;
                if (v31 == 1) {
                  goto LABEL_191;
                }
                char v32 = v69;
                if (v31) {
                  char v32 = 0;
                }
                if ((v32 & 1) == 0) {
                  goto LABEL_191;
                }
              }
              else if (!v69)
              {
                goto LABEL_190;
              }
              uint64_t v91 = 0;
              long long v89 = 0u;
              long long v90 = 0u;
              long long v87 = 0u;
              long long v88 = 0u;
              *(_OWORD *)UInt8 bytes = 0u;
              long long v86 = 0u;
              BytePtr = CFDataGetBytePtr(v28);
              CFIndex Length = CFDataGetLength(v28);
              unsigned int v35 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)bytes, (uint64_t)BytePtr, Length, 0);
              if (v35) {
                uint64_t v11 = v35;
              }
              else {
                uint64_t v11 = 4294954584;
              }
              if (v35 || a3 != 39) {
                goto LABEL_191;
              }
              uint64_t v11 = 4294954584;
              if ((int)v8 > 164)
              {
                if (v8 == 176)
                {
                  uint64_t v36 = hevcbridgeParseSEI3DReferenceDisplaysInformation((uint64_t)bytes, a2);
                }
                else
                {
                  if (v8 != 165) {
                    goto LABEL_191;
                  }
                  uint64_t v36 = hevcbridgeParseSEIAlphaChannelInfo((uint64_t)bytes, a2);
                }
                goto LABEL_85;
              }
              if (v8 != 4)
              {
                if (v8 != 148) {
                  goto LABEL_191;
                }
                uint64_t v36 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, a2[9] & 1, 356, 32);
                if (!v36)
                {
                  uint64_t v36 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((unsigned __int8 *)a2 + 72) >> 1) & 1, 357, 16);
                  if (!v36) {
                    uint64_t v36 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((unsigned __int8 *)a2 + 72) >> 2) & 1, 358, 16);
                  }
                }
LABEL_85:
                uint64_t v11 = v36;
                int v39 = 1;
LABEL_86:
                if (v11 == 1) {
                  goto LABEL_191;
                }
                if (v11) {
                  goto LABEL_189;
                }
                if (BYTE9(v87))
                {
LABEL_190:
                  uint64_t v11 = 0;
                  goto LABEL_191;
                }
                unsigned int v84 = 0;
                uint64_t v11 = hevcbridgeUPullLong((uint64_t)bytes, 8 - HIDWORD(v89), &v84);
                if (v11)
                {
LABEL_189:
                  if (v11) {
                    goto LABEL_191;
                  }
                  goto LABEL_190;
                }
                if (BYTE9(v87)) {
                  unsigned int v40 = v84;
                }
                else {
                  unsigned int v40 = *(unsigned __int8 *)(*(void *)bytes + *(void *)&bytes[8] - 1);
                }
                if (v40) {
                  int v65 = 0;
                }
                else {
                  int v65 = v39;
                }
                if (v65 != 1)
                {
                  uint64_t v11 = 0;
                  goto LABEL_189;
                }
                uint64_t v11 = 4294954582;
                FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_191:
                if (!v28) {
                  goto LABEL_193;
                }
                goto LABEL_192;
              }
              uint64_t v78 = 0;
              unsigned int v77 = 0;
              char v37 = *((unsigned char *)a2 + 80);
              uint64_t v38 = hevcbridgeUPullLong((uint64_t)bytes, 8, (_DWORD *)&v78 + 1);
              uint64_t v11 = v38;
              if ((v37 & 1) != 0 && !v38) {
                uint64_t v11 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 372, HIDWORD(v78), 0xFFFFFFFFLL);
              }
              if (v11)
              {
LABEL_83:
                int v39 = 0;
                goto LABEL_86;
              }
              if (HIDWORD(v78) != 181)
              {
                if (HIDWORD(v78) == 255)
                {
                  uint64_t v11 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((unsigned __int8 *)a2 + 80) >> 1) & 1, 373, 8);
                  goto LABEL_83;
                }
LABEL_182:
                uint64_t v11 = 0;
                goto LABEL_83;
              }
              char v41 = *((unsigned char *)a2 + 80);
              uint64_t v42 = hevcbridgeUPullLong((uint64_t)bytes, 16, &v78);
              uint64_t v11 = v42;
              if ((v41 & 4) != 0 && !v42) {
                uint64_t v11 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 374, v78, 0xFFFFFFFFLL);
              }
              if (v11) {
                goto LABEL_83;
              }
              if (v78 != 60) {
                goto LABEL_182;
              }
              char v43 = *((unsigned char *)a2 + 80);
              uint64_t v44 = hevcbridgeUPullLong((uint64_t)bytes, 16, &v77);
              uint64_t v11 = v44;
              if ((v43 & 8) != 0 && !v44) {
                uint64_t v11 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 375, v77, 0xFFFFFFFFLL);
              }
              if (v11) {
                goto LABEL_83;
              }
              CFDataRef v45 = v28;
              if (v77 == 1)
              {
                unsigned int v84 = 0;
                __int16 v83 = 0;
                __int16 v82 = 0;
                uint64_t v80 = 0;
                uint64_t v81 = 0;
                uint64_t v46 = *(void *)((char *)a2 + 84);
                uint64_t v47 = hevcbridgeUPullLong((uint64_t)bytes, 8, (_DWORD *)&v80 + 1);
                uint64_t v11 = v47;
                if ((v46 & 1) != 0 && !v47) {
                  uint64_t v11 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 376, HIDWORD(v80), 0xFFFFFFFFLL);
                }
                if (v11) {
                  goto LABEL_209;
                }
                if (HIDWORD(v80) != 4) {
                  goto LABEL_212;
                }
                uint64_t v48 = *(void *)((char *)a2 + 84);
                uint64_t v49 = hevcbridgeUPullLong((uint64_t)bytes, 8, &v80);
                uint64_t v11 = v49;
                if ((v48 & 2) != 0 && !v49) {
                  uint64_t v11 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 377, v80, 0xFFFFFFFFLL);
                }
                if (v11) {
                  goto LABEL_209;
                }
                if (v80 != 1)
                {
LABEL_212:
                  uint64_t v11 = 1;
                  goto LABEL_209;
                }
                uint64_t v50 = *(void *)((char *)a2 + 84);
                uint64_t v51 = hevcbridgeUPullLong((uint64_t)bytes, 2, &v84);
                uint64_t v11 = v51;
                if ((v50 & 4) != 0 && !v51) {
                  uint64_t v11 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 378, v84, 0xFFFFFFFFLL);
                }
                if (v11) {
                  goto LABEL_209;
                }
                unsigned int v73 = v84;
                if (v84 >= 2)
                {
                  unsigned int v52 = v84 - 1;
                  do
                  {
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((unsigned __int8 *)a2 + 84) >> 3) & 1, 379, 16);
                    if (v53) {
                      goto LABEL_208;
                    }
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((unsigned __int8 *)a2 + 84) >> 4) & 1, 380, 16);
                    if (v53) {
                      goto LABEL_208;
                    }
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((unsigned __int8 *)a2 + 84) >> 5) & 1, 381, 16);
                    if (v53) {
                      goto LABEL_208;
                    }
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((unsigned __int8 *)a2 + 84) >> 6) & 1, 382, 16);
                    if (v53) {
                      goto LABEL_208;
                    }
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, *((unsigned __int8 *)a2 + 84) >> 7, 383, 16);
                    if (v53) {
                      goto LABEL_208;
                    }
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 8) & 1, 384, 16);
                    if (v53) {
                      goto LABEL_208;
                    }
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 9) & 1, 385, 8);
                    if (v53) {
                      goto LABEL_208;
                    }
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 10) & 1, 386, 16);
                    if (v53) {
                      goto LABEL_208;
                    }
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 11) & 1, 387, 16);
                    if (v53) {
                      goto LABEL_208;
                    }
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 12) & 1, 388, 16);
                    if (v53) {
                      goto LABEL_208;
                    }
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 13) & 1, 389, 1);
                    if (v53) {
                      goto LABEL_208;
                    }
                  }
                  while (--v52);
                }
                uint64_t v11 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 14) & 1, 390, 27);
                if (v11) {
                  goto LABEL_209;
                }
                uint64_t v11 = hevcbridgeUPullFlagAlways((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 15) & 1, 391, (unsigned char *)&v83 + 1);
                if (v11) {
                  goto LABEL_209;
                }
                if (HIBYTE(v83))
                {
                  uint64_t v11 = hevcbridgeUPullAlways((uint64_t)bytes, a2, HIWORD(*((_DWORD *)a2 + 21)) & 1, 392, (_DWORD *)&v81 + 1, 5);
                  if (v11) {
                    goto LABEL_209;
                  }
                  uint64_t v11 = hevcbridgeUPullAlways((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 17) & 1, 393, &v81, 5);
                  if (v11) {
                    goto LABEL_209;
                  }
                  int v70 = HIDWORD(v81);
                  if (HIDWORD(v81))
                  {
                    int v54 = 0;
                    int v55 = v81;
                    while (1)
                    {
                      int v56 = v55;
                      if (v55) {
                        break;
                      }
LABEL_143:
                      if (++v54 == v70) {
                        goto LABEL_144;
                      }
                    }
                    while (1)
                    {
                      uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 18) & 1, 394, 4);
                      if (v53) {
                        goto LABEL_208;
                      }
                      if (!--v56) {
                        goto LABEL_143;
                      }
                    }
                  }
                }
LABEL_144:
                if (v73)
                {
                  int v57 = 0;
LABEL_146:
                  HIDWORD(v79) = 0;
                  int v58 = 3;
                  while (1)
                  {
                    uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 19) & 1, 395, 17);
                    if (v53) {
                      goto LABEL_208;
                    }
                    if (!--v58)
                    {
                      uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 20) & 1, 396, 17);
                      if (v53) {
                        goto LABEL_208;
                      }
                      uint64_t v53 = hevcbridgeUPullAlways((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 21) & 1, 397, (_DWORD *)&v79 + 1, 4);
                      if (v53) {
                        goto LABEL_208;
                      }
                      int v59 = HIDWORD(v79);
                      if (HIDWORD(v79))
                      {
                        do
                        {
                          uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 22) & 1, 398, 7);
                          if (v53) {
                            goto LABEL_208;
                          }
                          uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 23) & 1, 399, 17);
                          if (v53) {
                            goto LABEL_208;
                          }
                        }
                        while (--v59);
                      }
                      uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, HIBYTE(*((_DWORD *)a2 + 21)) & 1, 400, 10);
                      if (v53) {
                        goto LABEL_208;
                      }
                      if (++v57 != v73) {
                        goto LABEL_146;
                      }
                      break;
                    }
                  }
                }
                uint64_t v11 = hevcbridgeUPullFlagAlways((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 25) & 1, 401, &v83);
                if (v11)
                {
LABEL_209:
                  CFDataRef v28 = v45;
                  goto LABEL_83;
                }
                if ((_BYTE)v83)
                {
                  uint64_t v79 = 0;
                  uint64_t v11 = hevcbridgeUPullAlways((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 26) & 1, 402, (_DWORD *)&v79 + 1, 5);
                  if (v11) {
                    goto LABEL_209;
                  }
                  uint64_t v11 = hevcbridgeUPullAlways((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 27) & 1, 403, &v79, 5);
                  if (v11) {
                    goto LABEL_209;
                  }
                  int v71 = HIDWORD(v79);
                  if (HIDWORD(v79))
                  {
                    int v60 = 0;
                    int v61 = v79;
                    while (1)
                    {
                      int v62 = v61;
                      if (v61) {
                        break;
                      }
LABEL_166:
                      if (++v60 == v71) {
                        goto LABEL_167;
                      }
                    }
                    while (1)
                    {
                      uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 28) & 1, 404, 4);
                      if (v53) {
                        goto LABEL_208;
                      }
                      if (!--v62) {
                        goto LABEL_166;
                      }
                    }
                  }
                }
LABEL_167:
                if (v73)
                {
                  int v63 = 0;
                  while (1)
                  {
                    uint64_t v53 = hevcbridgeUPullFlagAlways((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 29) & 1, 405, (unsigned char *)&v82 + 1);
                    if (v53) {
                      break;
                    }
                    if (HIBYTE(v82))
                    {
                      HIDWORD(v79) = 0;
                      uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*((_DWORD *)a2 + 21) >> 30) & 1, 406, 12);
                      if (v53) {
                        break;
                      }
                      uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, *((_DWORD *)a2 + 21) >> 31, 407, 12);
                      if (v53) {
                        break;
                      }
                      uint64_t v53 = hevcbridgeUPullAlways((uint64_t)bytes, a2, a2[11] & 1, 408, (_DWORD *)&v79 + 1, 4);
                      if (v53) {
                        break;
                      }
                      int v64 = HIDWORD(v79);
                      if (HIDWORD(v79))
                      {
                        do
                        {
                          uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*(void *)((char *)a2 + 84) >> 33) & 1, 409, 10);
                          if (v53) {
                            goto LABEL_208;
                          }
                        }
                        while (--v64);
                      }
                    }
                    uint64_t v53 = hevcbridgeUPullFlagAlways((uint64_t)bytes, a2, (*(void *)((char *)a2 + 84) >> 34) & 1, 410, &v82);
                    if (v53) {
                      break;
                    }
                    if ((_BYTE)v82)
                    {
                      uint64_t v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, a2, (*(void *)((char *)a2 + 84) >> 35) & 1, 411, 6);
                      if (v53) {
                        break;
                      }
                    }
                    uint64_t v11 = 0;
                    if (++v63 == v73) {
                      goto LABEL_209;
                    }
                  }
LABEL_208:
                  uint64_t v11 = v53;
                  goto LABEL_209;
                }
              }
              uint64_t v11 = 0;
              goto LABEL_209;
            }
            CFAllocatorRef v72 = v6;
            uint64_t v21 = a3;
            uint64_t v22 = 0;
            unsigned int v23 = 0;
            int v69 = 0;
            if (v13) {
              goto LABEL_44;
            }
LABEL_50:
            a3 = v21;
            CFAllocatorRef v6 = v72;
            CFDataRef v28 = v23;
            goto LABEL_51;
          }
          int v69 = 0;
        }
        unsigned int v24 = CFDataCreateMutable(v6, v13);
        if (v24)
        {
          int v25 = v24;
          CFAllocatorRef v72 = v6;
          uint64_t v21 = a3;
          CFDataSetLength(v24, v13);
          unsigned int v23 = v25;
          MutableBytePtr = CFDataGetMutableBytePtr(v25);
          if (!MutableBytePtr)
          {
            uint64_t v11 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            CFAllocatorRef v6 = v72;
            CFDataRef v28 = v23;
LABEL_192:
            CFRelease(v28);
            goto LABEL_193;
          }
          uint64_t v22 = MutableBytePtr;
          if (v13)
          {
LABEL_44:
            while (1)
            {
              *(_DWORD *)UInt8 bytes = 0;
              uint64_t v27 = hevcbridgeUPullLong((uint64_t)a1, 8, bytes);
              if (v27) {
                break;
              }
              if (v22) {
                *v22++ = bytes[0];
              }
              if (v20) {
                *v20++ = bytes[0];
              }
              if (!--v13) {
                goto LABEL_50;
              }
            }
            uint64_t v11 = v27;
            a3 = v21;
            CFAllocatorRef v6 = v72;
            CFDataRef v28 = v23;
            goto LABEL_191;
          }
          goto LABEL_50;
        }
        uint64_t v67 = 4294954583;
        goto LABEL_205;
      }
      unint64_t v17 = CFDataGetLength(Mutable);
      if (v17 >> 20)
      {
        uint64_t v66 = 4294954584;
      }
      else
      {
        unint64_t v18 = v17;
        CFDataSetLength(Mutable, v17 + v13);
        uint64_t v19 = CFDataGetMutableBytePtr(Mutable);
        if (v19)
        {
          uint64_t v20 = &v19[v18];
          goto LABEL_29;
        }
        uint64_t v66 = 4294954583;
      }
      uint64_t v11 = FigSignalErrorAt(v66, 0, 0, 0, 0, 0, 0);
LABEL_194:
      CFRelease(Mutable);
      goto LABEL_195;
    }
    uint64_t v67 = 4294954584;
LABEL_205:
    uint64_t v11 = FigSignalErrorAt(v67, 0, 0, 0, 0, 0, 0);
    if (Mutable) {
      goto LABEL_194;
    }
LABEL_195:
    if (v11) {
      return v11;
    }
  }
  while ((unint64_t)(a1[6] + 1) < a1[1] + *a1 && hevcbridgeMoreRBSPData((uint64_t)a1));
  uint64_t v11 = hevcbridgeUPullLong((uint64_t)a1, 8, &v74);
  if (!v11)
  {
    if (v74 == 128)
    {
      return 0;
    }
    else
    {
      uint64_t v11 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    }
  }
  return v11;
}

uint64_t hevcbridgeParseSliceSegmentLayer(uint64_t a1, uint64_t *a2, int a3, unsigned int a4, int a5)
{
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  char v120 = 0;
  unsigned int v119 = 0;
  char v118 = 0;
  unsigned int v117 = 0;
  uint64_t v116 = 0;
  uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, *((_DWORD *)a2 + 11) & 1, 263, &v120);
  if (result) {
    return result;
  }
  if ((a3 & 0xFFFFFFF8) == 0x10)
  {
    uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 1) & 1, 264);
    if (result) {
      return result;
    }
  }
  uint64_t v11 = *(uint64_t *)((char *)a2 + 44);
  uint64_t result = hevcbridgeUEPullLong(a1, &v119);
  if ((v11 & 4) != 0 && !result) {
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 265, v119, 0xFFFFFFFFLL);
  }
  if (result) {
    return result;
  }
  uint64_t v12 = a2[16];
  if (!v12)
  {
LABEL_19:
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  CFIndex v13 = (void *)a2[17];
  uint64_t v14 = a2[16];
  while (1)
  {
    uint64_t v15 = (_DWORD *)*v13;
    if (*(_DWORD *)*v13 == 34 && v15[1] == v119) {
      break;
    }
    ++v13;
    if (!--v14) {
      goto LABEL_19;
    }
  }
  unsigned int v16 = (void *)a2[17];
  uint64_t v17 = a2[16];
  while (1)
  {
    unint64_t v18 = (_DWORD *)*v16;
    if (*(_DWORD *)*v16 == 33 && v18[1] == v15[2]) {
      break;
    }
    ++v16;
    if (!--v17) {
      goto LABEL_19;
    }
  }
  uint64_t v19 = v18 + 2;
  uint64_t v20 = (void *)a2[17];
  while (1)
  {
    uint64_t v21 = (_DWORD *)*v20;
    if (*(_DWORD *)*v20 == 32 && v21[1] == *v19) {
      break;
    }
    ++v20;
    if (!--v12)
    {
      uint64_t v22 = 0;
      goto LABEL_28;
    }
  }
  uint64_t v22 = v21 + 2;
LABEL_28:
  if (*((unsigned char *)v18 + 53))
  {
    if (!v22) {
      goto LABEL_19;
    }
  }
  else if (!a4 || !v22)
  {
    uint64_t v102 = 0;
    int v101 = 0;
    int v99 = 0;
    unsigned int v26 = v18 + 6;
    uint64_t v27 = v18 + 7;
    CFDataRef v28 = (unsigned __int8 *)v18 + 54;
    char v29 = v18 + 11;
    goto LABEL_38;
  }
  unsigned int v23 = (unsigned __int8 *)v22 + a4;
  if (*((unsigned char *)v18 + 52)) {
    unsigned int v24 = v18[12];
  }
  else {
    unsigned int v24 = v23[4];
  }
  if (v24 > *v22) {
    goto LABEL_19;
  }
  int v25 = &v22[4 * v24];
  unsigned int v26 = v25 + 1122;
  uint64_t v27 = v25 + 1123;
  CFDataRef v28 = (unsigned __int8 *)(v25 + 1125);
  char v29 = (int *)(v25 + 1124);
  int v101 = *((unsigned __int8 *)v22 + 196);
  int v99 = *((unsigned __int8 *)v22 + 197);
  LODWORD(v102) = v23[68];
  HIDWORD(v102) = v23[132];
LABEL_38:
  int v100 = *v29;
  int v105 = *v28;
  if (v120) {
    goto LABEL_39;
  }
  int v32 = ~(-1 << (*((unsigned char *)v18 + 16) + *((unsigned char *)v18 + 20) + 3));
  double v33 = log2((double)(((*v26 + v32) >> (*((unsigned char *)v18 + 16) + *((unsigned char *)v18 + 20) + 3))
                    * ((*v27 + v32) >> (*((unsigned char *)v18 + 16) + *((unsigned char *)v18 + 20) + 3))));
  if (*((unsigned char *)v15 + 24))
  {
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 3) & 1, 266, &v118);
    if (result) {
      return result;
    }
  }
  uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 4) & 1, 267, vcvtpd_s64_f64(v33));
  if (result) {
    return result;
  }
  if (!v118)
  {
LABEL_39:
    memset(v126, 0, 164);
    uint64_t v115 = 0;
    v125[1] = 0;
    v125[0] = 0;
    __int16 v114 = 0;
    __int16 v113 = 0;
    __int16 v112 = 0;
    int v111 = 0;
    if (v15[3])
    {
      uint64_t result = hevcbridgeUSkip(a1, 1);
      if (result) {
        return result;
      }
      unsigned int v30 = v15[3];
      if (v30 >= 2)
      {
        uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 5) & 1, 268);
        if (!result)
        {
          unsigned int v30 = v15[3];
          unsigned int v31 = 2;
          goto LABEL_74;
        }
        return result;
      }
      unsigned int v31 = 1;
LABEL_74:
      while (v31 < v30)
      {
        uint64_t result = hevcbridgeUSkip(a1, 1);
        if (result) {
          return result;
        }
        ++v31;
        unsigned int v30 = v15[3];
      }
    }
    uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((unsigned __int8 *)a2 + 44) >> 6) & 1, 269, &v117);
    if (result) {
      return result;
    }
    if (*((unsigned char *)v15 + 25))
    {
      uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, *((unsigned __int8 *)a2 + 44) >> 7, 270);
      if (result) {
        return result;
      }
    }
    if (v105 == 1)
    {
      uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 8) & 1, 271, 2);
      if (result) {
        return result;
      }
    }
    if (!a4 || HIDWORD(v102))
    {
      if ((a3 - 21) > 0xFFFFFFFD) {
        goto LABEL_93;
      }
    }
    else if ((a3 - 21) >= 0xFFFFFFFE && *((unsigned char *)v18 + 89))
    {
      goto LABEL_93;
    }
    uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 9) & 1, 272, v18[8] + 4);
    if (result) {
      return result;
    }
    if ((a3 - 21) <= 0xFFFFFFFD)
    {
      v121[0] = 0;
      LODWORD(v124[0]) = 0;
      uint64_t v38 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 10) & 1, 273, v121);
      if (v38) {
        return v38;
      }
      int v39 = v121[0];
      unsigned int v40 = v18[23];
      if (v121[0])
      {
        if (v40 >= 2)
        {
          double v41 = log2((double)v40);
          uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 11) & 1, 274, v124, vcvtpd_s64_f64(v41));
          if (result) {
            return result;
          }
        }
        if (v39 == 1)
        {
          if (LODWORD(v124[0]) >= v18[23]) {
            goto LABEL_284;
          }
          uint64_t v51 = &v19[41 * LODWORD(v124[0]) + 22];
        }
        else
        {
          uint64_t v51 = v126;
        }
        unint64_t v97 = v51;
      }
      else
      {
        unint64_t v97 = v126;
        uint64_t v38 = hevcbridgeParseSTRefPicSet(a1, v40, v40, (uint64_t)(v18 + 24), (uint64_t)v126);
        if (v38) {
          return v38;
        }
      }
      if (*((unsigned char *)v18 + 55))
      {
        if (v18[9])
        {
          uint64_t v38 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 12) & 1, 275, (unsigned int *)&v115 + 1);
          if (v38) {
            return v38;
          }
        }
        uint64_t v38 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 13) & 1, 276, (unsigned int *)&v115);
        if (v38) {
          return v38;
        }
        unint64_t v106 = HIDWORD(v115);
        if (HIDWORD(v115) >= 0x11) {
          goto LABEL_284;
        }
        int v98 = v115;
        if (v115 >= 0x11) {
          goto LABEL_284;
        }
        uint64_t v95 = (v115 + HIDWORD(v115));
        if (v95 > 0x10) {
          goto LABEL_284;
        }
        if (v95)
        {
          for (unint64_t i = 0; i != v95; ++i)
          {
            LODWORD(v123[0]) = 0;
            if (i >= v106)
            {
              uint64_t v56 = hevcbridgeUSkip(a1, v18[8] + 4);
              if (v56) {
                return v56;
              }
              LODWORD(v122[0]) = 0;
              uint64_t v56 = hevcbridgeUPull(a1, 1, v122);
              if (v56) {
                return v56;
              }
              char v104 = v122[0];
            }
            else
            {
              unsigned int v54 = v18[9];
              if (v54 >= 2)
              {
                double v55 = log2((double)v54);
                uint64_t v56 = hevcbridgeUPullLong(a1, vcvtpd_s64_f64(v55), v123);
                if (v56) {
                  return v56;
                }
              }
              char v104 = 0;
            }
            LODWORD(v122[0]) = 0;
            uint64_t v56 = hevcbridgeUPull(a1, 1, v122);
            if (v56) {
              return v56;
            }
            if (LOBYTE(v122[0]))
            {
              uint64_t v56 = hevcbridgeUESkip(a1);
              if (v56) {
                return v56;
              }
            }
            if (i < v106) {
              char v104 = *((unsigned char *)v19 + LODWORD(v123[0]) + 48);
            }
            *((unsigned char *)v125 + i) = v104;
          }
        }
      }
      else
      {
        int v98 = 0;
        LODWORD(v106) = 0;
      }
      if (v18[10])
      {
        uint64_t v38 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 14) & 1, 277, (unsigned char *)&v114 + 1);
        if (v38) {
          return v38;
        }
      }
      int v103 = 1;
      uint64_t v42 = v97;
      goto LABEL_94;
    }
LABEL_93:
    int v98 = 0;
    LODWORD(v106) = 0;
    int v103 = 0;
    uint64_t v42 = 0;
LABEL_94:
    int v43 = 0;
    if (!a4 || v101 || !v102) {
      goto LABEL_105;
    }
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 15) & 1, 278, &v112);
    if (result) {
      return result;
    }
    uint64_t v44 = v42;
    int v43 = v112;
    if (!(_BYTE)v112) {
      goto LABEL_104;
    }
    if (v102 < 2)
    {
LABEL_105:
      int v46 = v43;
      if (*((unsigned char *)v18 + 88))
      {
        uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 18) & 1, 281, (unsigned char *)&v113 + 1);
        if (result) {
          return result;
        }
        if (v100)
        {
          uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 19) & 1, 282, &v113);
          if (result) {
            return result;
          }
        }
      }
      unsigned int v96 = v117;
      if (v117 > 1) {
        goto LABEL_247;
      }
      uint64_t v47 = (unsigned __int8 *)v42;
      char v110 = 0;
      unsigned int v93 = v15[5];
      unsigned int v94 = v15[4];
      unsigned int v108 = v93;
      unsigned int v109 = v94;
      uint64_t v38 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 20) & 1, 283, &v110);
      if (v38) {
        return v38;
      }
      if (v110)
      {
        uint64_t v38 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 21) & 1, 284, &v109);
        if (v38) {
          return v38;
        }
        unsigned int v94 = v109;
        if (v109 >= 0xF) {
          goto LABEL_284;
        }
        if (!v96)
        {
          uint64_t v38 = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 22) & 1, 285, &v108);
          if (v38) {
            return v38;
          }
          unsigned int v93 = v108;
          if (v108 >= 0xF)
          {
LABEL_284:
            uint64_t v38 = 4294954582;
            FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            return v38;
          }
        }
      }
      uint64_t v48 = (void *)a2[17];
      if (!v48 || v22)
      {
        if (v22)
        {
LABEL_169:
          int v57 = (char *)v22 + a4;
          int v58 = v57[68];
          if (!v57[68]) {
            goto LABEL_186;
          }
          int v52 = 0;
          int v59 = (char *)v22 + a4;
          uint64_t v60 = v59[198];
          unsigned int v61 = a5 - 1;
          int v62 = (unsigned __int8 *)(v59 + 326);
          do
          {
            if (v61 <= *((unsigned __int8 *)v22 + v60 + 262)
              && (a5 == 1 || v61 < *((unsigned __int8 *)&v22[16 * v60 + 97] + *v62 + 2)))
            {
              ++v52;
            }
            --v58;
          }
          while (v58);
LABEL_176:
          if (a4) {
            BOOL v63 = v52 == 0;
          }
          else {
            BOOL v63 = 1;
          }
          if (v63)
          {
            int v52 = 0;
            goto LABEL_187;
          }
          if (v101)
          {
LABEL_187:
            int v64 = v103;
            if (v103)
            {
              if (!v47) {
                goto LABEL_284;
              }
              uint64_t v65 = v47[160];
              if (v47[160])
              {
                int v64 = 0;
                uint64_t v66 = v47 + 128;
                do
                {
                  if (*v66++) {
                    ++v64;
                  }
                  --v65;
                }
                while (v65);
              }
              else
              {
                int v64 = 0;
              }
              uint64_t v68 = v47[161];
              if (v47[161])
              {
                int v69 = v47 + 144;
                do
                {
                  if (*v69++) {
                    ++v64;
                  }
                  --v68;
                }
                while (v68);
              }
              uint64_t v71 = (v98 + v106);
              if (v98 + v106)
              {
                CFAllocatorRef v72 = (unsigned __int8 *)v125;
                do
                {
                  if (*v72++) {
                    ++v64;
                  }
                  --v71;
                }
                while (v71);
              }
            }
            if (*((unsigned char *)v15 + 38)) {
              ++v64;
            }
            unsigned int v74 = v64 + v52;
            if (*((unsigned char *)v15 + 26)) {
              BOOL v75 = v74 >= 2;
            }
            else {
              BOOL v75 = 0;
            }
            if (!v75)
            {
LABEL_212:
              if (!v96)
              {
                uint64_t v38 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 25) & 1, 288);
                if (v38) {
                  return v38;
                }
              }
              if (*((unsigned char *)v15 + 27))
              {
                uint64_t v38 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 26) & 1, 289);
                if (v38) {
                  return v38;
                }
              }
              if (!HIBYTE(v114)) {
                goto LABEL_306;
              }
              int v76 = 1;
              LOBYTE(v124[0]) = 1;
              if (!v96)
              {
                uint64_t v38 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 27) & 1, 290, v124);
                if (v38) {
                  return v38;
                }
                int v76 = LOBYTE(v124[0]);
                if (!LOBYTE(v124[0])) {
                  goto LABEL_219;
                }
              }
              if (!v94)
              {
LABEL_219:
                if (v76 || !v93) {
                  goto LABEL_306;
                }
              }
              uint64_t v38 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 28) & 1, 291);
              if (!v38)
              {
LABEL_306:
                if (v96 == 1 && *((unsigned char *)v15 + 28) || !v96 && *((unsigned char *)v15 + 29))
                {
                  memset(v124, 0, 15);
                  memset(v123, 0, 15);
                  uint64_t v38 = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 29) & 1, 292);
                  if (v38) {
                    return v38;
                  }
                  if (v100)
                  {
                    uint64_t v38 = hevcbridgeSEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 11) >> 30) & 1, 293);
                    if (v38) {
                      return v38;
                    }
                  }
                  unsigned int v77 = 0;
                  while (1)
                  {
                    LODWORD(v122[0]) = 0;
                    uint64_t v56 = hevcbridgeUPull(a1, 1, v122);
                    *((unsigned char *)v124 + v77) = v122[0];
                    if (v56) {
                      return v56;
                    }
                    if (++v77 > v94)
                    {
                      if (v100)
                      {
                        unsigned int v78 = 0;
                        while (1)
                        {
                          LODWORD(v122[0]) = 0;
                          uint64_t v56 = hevcbridgeUPull(a1, 1, v122);
                          *((unsigned char *)v123 + v78) = v122[0];
                          if (v56) {
                            break;
                          }
                          if (++v78 > v94) {
                            goto LABEL_235;
                          }
                        }
                      }
                      else
                      {
LABEL_235:
                        unsigned int v79 = 0;
                        while (1)
                        {
                          if (*((unsigned char *)v124 + v79))
                          {
                            uint64_t v56 = hevcbridgeSESkip(a1);
                            if (v56) {
                              break;
                            }
                            uint64_t v56 = hevcbridgeSESkip(a1);
                            if (v56) {
                              break;
                            }
                          }
                          unsigned int v80 = v79;
                          if (*((unsigned char *)v123 + v79))
                          {
                            char v81 = 1;
                            do
                            {
                              char v82 = v81;
                              uint64_t v56 = hevcbridgeSESkip(a1);
                              if (v56) {
                                return v56;
                              }
                              uint64_t v56 = hevcbridgeSESkip(a1);
                              if (v56) {
                                return v56;
                              }
                              char v81 = 0;
                            }
                            while ((v82 & 1) != 0);
                          }
                          unsigned int v79 = v80 + 1;
                          if (v80 + 1 > v94)
                          {
                            if (v96) {
                              goto LABEL_246;
                            }
                            unsigned int v88 = 0;
                            memset(v122, 0, 15);
                            memset(v121, 0, 15);
                            while (1)
                            {
                              int v107 = 0;
                              uint64_t v56 = hevcbridgeUPull(a1, 1, &v107);
                              *((unsigned char *)v122 + v88) = v107;
                              if (v56) {
                                return v56;
                              }
                              if (++v88 > v93)
                              {
                                if (v100)
                                {
                                  unsigned int v89 = 0;
                                  while (1)
                                  {
                                    int v107 = 0;
                                    uint64_t v56 = hevcbridgeUPull(a1, 1, &v107);
                                    v121[v89] = v107;
                                    if (v56) {
                                      break;
                                    }
                                    if (++v89 > v93) {
                                      goto LABEL_292;
                                    }
                                  }
                                }
                                else
                                {
LABEL_292:
                                  unsigned int v90 = 0;
                                  while (1)
                                  {
                                    if (*((unsigned char *)v122 + v90))
                                    {
                                      uint64_t v56 = hevcbridgeSESkip(a1);
                                      if (v56) {
                                        break;
                                      }
                                      uint64_t v56 = hevcbridgeSESkip(a1);
                                      if (v56) {
                                        break;
                                      }
                                    }
                                    if (v121[v90])
                                    {
                                      char v91 = 1;
                                      do
                                      {
                                        char v92 = v91;
                                        uint64_t v56 = hevcbridgeSESkip(a1);
                                        if (v56) {
                                          return v56;
                                        }
                                        uint64_t v56 = hevcbridgeSESkip(a1);
                                        if (v56) {
                                          return v56;
                                        }
                                        char v91 = 0;
                                      }
                                      while ((v92 & 1) != 0);
                                    }
                                    if (++v90 > v93) {
                                      goto LABEL_246;
                                    }
                                  }
                                }
                                return v56;
                              }
                            }
                          }
                        }
                      }
                      return v56;
                    }
                  }
                }
LABEL_246:
                uint64_t v38 = hevcbridgeUEPullIfRequested(a1, a2, *((_DWORD *)a2 + 11) >> 31, 294);
                if (v38) {
                  return v38;
                }
LABEL_247:
                uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, a2[6] & 1, 295);
                if (result) {
                  return result;
                }
                if (*((unsigned char *)v15 + 30))
                {
                  uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 33) & 1, 296);
                  if (result) {
                    return result;
                  }
                  uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 34) & 1, 297);
                  if (result) {
                    return result;
                  }
                }
                if (*((unsigned char *)v15 + 31))
                {
                  uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 35) & 1, 298);
                  if (result) {
                    return result;
                  }
                }
                if (!*((unsigned char *)v15 + 32)) {
                  goto LABEL_273;
                }
                uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 36) & 1, 299, &v114);
                if (result) {
                  return result;
                }
                if ((_BYTE)v114)
                {
                  uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 37) & 1, 300, (unsigned char *)&v112 + 1);
                  if (result) {
                    return result;
                  }
                  int v83 = HIBYTE(v112);
                  if (!HIBYTE(v112))
                  {
                    uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 38) & 1, 301);
                    if (result) {
                      return result;
                    }
                    uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 39) & 1, 302);
                    if (result) {
                      return result;
                    }
                    int v83 = 0;
                  }
                }
                else
                {
LABEL_273:
                  int v83 = *((unsigned __int8 *)v15 + 33);
                }
                if (*((unsigned char *)v15 + 34) && (v113 || !v83))
                {
                  uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 40) & 1, 303);
                  if (result) {
                    return result;
                  }
                }
                goto LABEL_48;
              }
              return v38;
            }
            LOBYTE(v124[0]) = 0;
            double v84 = log2((double)v74);
            uint64_t v38 = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 11) >> 23) & 1, 286, v124);
            if (v38) {
              return v38;
            }
            int v85 = vcvtpd_s64_f64(v84);
            if (LOBYTE(v124[0]))
            {
              int v86 = 0;
              while (1)
              {
                uint64_t v56 = hevcbridgeUSkip(a1, v85);
                if (v56) {
                  break;
                }
                if (++v86 > v94) {
                  goto LABEL_266;
                }
              }
            }
            else
            {
LABEL_266:
              if (v96) {
                goto LABEL_212;
              }
              LOBYTE(v123[0]) = 0;
              uint64_t v38 = hevcbridgeUPullFlagAlways(a1, a2, HIBYTE(*((_DWORD *)a2 + 11)) & 1, 287, v123);
              if (v38) {
                return v38;
              }
              if (!LOBYTE(v123[0])) {
                goto LABEL_212;
              }
              int v87 = 0;
              while (1)
              {
                uint64_t v56 = hevcbridgeUSkip(a1, v85);
                if (v56) {
                  break;
                }
                if (++v87 > v93) {
                  goto LABEL_212;
                }
              }
            }
            return v56;
          }
          if (v46)
          {
            int v52 = 1;
            if (!v99 && v102 != 1) {
              int v52 = v111 + 1;
            }
            goto LABEL_187;
          }
LABEL_186:
          int v52 = 0;
          goto LABEL_187;
        }
      }
      else
      {
        uint64_t v49 = a2[16];
        if (v49)
        {
          while (1)
          {
            uint64_t v50 = (_DWORD *)*v48;
            if (*(_DWORD *)*v48 == 32 && v50[1] == *v19) {
              break;
            }
            ++v48;
            if (!--v49) {
              goto LABEL_135;
            }
          }
          uint64_t v22 = v50 + 2;
          goto LABEL_169;
        }
      }
LABEL_135:
      int v52 = 1;
      goto LABEL_176;
    }
    int v45 = vcvtpd_s64_f64(log2((double)v102));
    if (!v99)
    {
      if (v45 < 0 || (int)v102 <= v45) {
        return FigSignalErrorAt(1, 0, 0, 0, 0, 0, 0);
      }
      uint64_t result = hevcbridgeUPullAlways(a1, a2, HIWORD(*((_DWORD *)a2 + 11)) & 1, 279, &v111, v45);
      if (result) {
        return result;
      }
    }
    if ((v45 & 0x80000000) == 0 && v45 < (int)v102)
    {
      int v43 = 1;
LABEL_104:
      uint64_t v42 = v44;
      goto LABEL_105;
    }
    return FigSignalErrorAt(1, 0, 0, 0, 0, 0, 0);
  }
  if (!*((unsigned char *)v15 + 35) && !*((unsigned char *)v15 + 36)) {
    goto LABEL_59;
  }
LABEL_48:
  v126[0] = 0;
  uint64_t v34 = *(uint64_t *)((char *)a2 + 44);
  uint64_t result = hevcbridgeUEPullLong(a1, v126);
  if ((v34 & 0x20000000000) != 0 && !result) {
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 304, v126[0], 0xFFFFFFFFLL);
  }
  if (result) {
    return result;
  }
  unsigned int v35 = v126[0];
  if (v126[0])
  {
    LODWORD(v125[0]) = 0;
    uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 42) & 1, 305, (unsigned int *)v125);
    if (!result)
    {
      int v36 = LODWORD(v125[0]) + 1;
      while (1)
      {
        uint64_t result = hevcbridgeUSkip(a1, v36);
        if (result) {
          break;
        }
        if (!--v35) {
          goto LABEL_59;
        }
      }
    }
  }
  else
  {
    if (!*((unsigned char *)v15 + 37)) {
      goto LABEL_64;
    }
LABEL_59:
    v126[0] = 0;
    uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 43) & 1, 306, v126);
    if (result) {
      return result;
    }
    unsigned int v37 = v126[0];
    if (v126[0])
    {
      while (1)
      {
        uint64_t result = hevcbridgeUSkip(a1, 8);
        if (result) {
          break;
        }
        if (!--v37) {
          goto LABEL_64;
        }
      }
    }
    else
    {
LABEL_64:
      uint64_t result = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 44) & 1, 307, (_DWORD *)&v116 + 1, 1);
      if (!result)
      {
        if (HIDWORD(v116) == 1)
        {
          while (*(_DWORD *)(a1 + 76))
          {
            uint64_t result = hevcbridgeUPullLong(a1, 1, &v116);
            if (result) {
              return result;
            }
            if (v116) {
              goto LABEL_69;
            }
          }
          return 0;
        }
        else
        {
LABEL_69:
          FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
          return 4294954582;
        }
      }
    }
  }
  return result;
}